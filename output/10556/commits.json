[
  {
    "sha": "37065d2ed2869aea5a83e69a0ef7a55c5d56724c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNzA2NWQyZWQyODY5YWVhNWE4M2U2OWEwZWY3YTU1YzVkNTY3MjRj",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-06-07T15:54:39Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-06-29T10:16:32Z"
      },
      "message": "[tests] remove unused imports from utils.py",
      "tree": {
        "sha": "80546b50c01313b2dc6f6e42e7959c311a360bab",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/80546b50c01313b2dc6f6e42e7959c311a360bab"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/37065d2ed2869aea5a83e69a0ef7a55c5d56724c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/37065d2ed2869aea5a83e69a0ef7a55c5d56724c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/37065d2ed2869aea5a83e69a0ef7a55c5d56724c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/37065d2ed2869aea5a83e69a0ef7a55c5d56724c/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "90a002ea647dcea57a2ed4294eab77897168ba1d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/90a002ea647dcea57a2ed4294eab77897168ba1d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/90a002ea647dcea57a2ed4294eab77897168ba1d"
      }
    ],
    "stats": {
      "total": 12,
      "additions": 6,
      "deletions": 6
    },
    "files": [
      {
        "sha": "f00232c9ffe0398f4456b4881c48144873f5d336",
        "filename": "test/functional/bip9-softforks.py",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/37065d2ed2869aea5a83e69a0ef7a55c5d56724c/test/functional/bip9-softforks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/37065d2ed2869aea5a83e69a0ef7a55c5d56724c/test/functional/bip9-softforks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bip9-softforks.py?ref=37065d2ed2869aea5a83e69a0ef7a55c5d56724c",
        "patch": "@@ -15,16 +15,17 @@\n test that enforcement has not triggered (which triggers ACTIVE)\n test that enforcement has triggered\n \"\"\"\n+from io import BytesIO\n+import shutil\n+import time\n+import itertools\n \n from test_framework.test_framework import ComparisonTestFramework\n from test_framework.util import *\n from test_framework.mininode import CTransaction, NetworkThread\n from test_framework.blocktools import create_coinbase, create_block\n from test_framework.comptool import TestInstance, TestManager\n from test_framework.script import CScript, OP_1NEGATE, OP_CHECKSEQUENCEVERIFY, OP_DROP\n-from io import BytesIO\n-import time\n-import itertools\n \n class BIP9SoftForksTest(ComparisonTestFramework):\n "
      },
      {
        "sha": "9f40de08c6f9c80f38c2cc1915193980018d38e9",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/37065d2ed2869aea5a83e69a0ef7a55c5d56724c/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/37065d2ed2869aea5a83e69a0ef7a55c5d56724c/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=37065d2ed2869aea5a83e69a0ef7a55c5d56724c",
        "patch": "@@ -5,15 +5,13 @@\n \"\"\"Helpful routines for regression testing.\"\"\"\n \n import os\n-import sys\n \n from binascii import hexlify, unhexlify\n from base64 import b64encode\n from decimal import Decimal, ROUND_DOWN\n import json\n import http.client\n import random\n-import shutil\n import subprocess\n import tempfile\n import time"
      },
      {
        "sha": "ff51cba4b3f64f94c6de22081400a97a25e63cd1",
        "filename": "test/functional/walletbackup.py",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/37065d2ed2869aea5a83e69a0ef7a55c5d56724c/test/functional/walletbackup.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/37065d2ed2869aea5a83e69a0ef7a55c5d56724c/test/functional/walletbackup.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/walletbackup.py?ref=37065d2ed2869aea5a83e69a0ef7a55c5d56724c",
        "patch": "@@ -30,10 +30,11 @@\n Shutdown again, restore using importwallet,\n and confirm again balances are correct.\n \"\"\"\n+from random import randint\n+import shutil\n \n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n-from random import randint\n \n class WalletBackupTest(BitcoinTestFramework):\n "
      }
    ]
  },
  {
    "sha": "f1fe5368f191018a72276a93a9e74cd95f896697",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMWZlNTM2OGYxOTEwMThhNzIyNzZhOTNhOWU3NGNkOTVmODk2Njk3",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-06-07T15:44:17Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-06-29T10:19:06Z"
      },
      "message": "[tests] fix flake8 warnings in test_framework.py and util.py",
      "tree": {
        "sha": "b80612a6a7b9177e5eaf173f7548a12b58b06790",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b80612a6a7b9177e5eaf173f7548a12b58b06790"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f1fe5368f191018a72276a93a9e74cd95f896697",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f1fe5368f191018a72276a93a9e74cd95f896697",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f1fe5368f191018a72276a93a9e74cd95f896697",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f1fe5368f191018a72276a93a9e74cd95f896697/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "37065d2ed2869aea5a83e69a0ef7a55c5d56724c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/37065d2ed2869aea5a83e69a0ef7a55c5d56724c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/37065d2ed2869aea5a83e69a0ef7a55c5d56724c"
      }
    ],
    "stats": {
      "total": 205,
      "additions": 104,
      "deletions": 101
    },
    "files": [
      {
        "sha": "37e59f79db0b9f5ef552cebe605a55c24fde39f2",
        "filename": "test/functional/test_framework/test_framework.py",
        "status": "modified",
        "additions": 19,
        "deletions": 18,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f1fe5368f191018a72276a93a9e74cd95f896697/test/functional/test_framework/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f1fe5368f191018a72276a93a9e74cd95f896697/test/functional/test_framework/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_framework.py?ref=f1fe5368f191018a72276a93a9e74cd95f896697",
        "patch": "@@ -14,6 +14,7 @@\n import sys\n import tempfile\n import time\n+import traceback\n \n from .util import (\n     PortSeed,\n@@ -77,7 +78,7 @@ def add_options(self, parser):\n         pass\n \n     def setup_chain(self):\n-        self.log.info(\"Initializing test directory \"+self.options.tmpdir)\n+        self.log.info(\"Initializing test directory \" + self.options.tmpdir)\n         if self.setup_clean_chain:\n             self._initialize_chain_clean(self.options.tmpdir, self.num_nodes)\n         else:\n@@ -111,9 +112,9 @@ def main(self):\n                           help=\"Leave bitcoinds and test.* datadir on exit or error\")\n         parser.add_option(\"--noshutdown\", dest=\"noshutdown\", default=False, action=\"store_true\",\n                           help=\"Don't stop bitcoinds after the test execution\")\n-        parser.add_option(\"--srcdir\", dest=\"srcdir\", default=os.path.normpath(os.path.dirname(os.path.realpath(__file__))+\"/../../../src\"),\n+        parser.add_option(\"--srcdir\", dest=\"srcdir\", default=os.path.normpath(os.path.dirname(os.path.realpath(__file__)) + \"/../../../src\"),\n                           help=\"Source directory containing bitcoind/bitcoin-cli (default: %default)\")\n-        parser.add_option(\"--cachedir\", dest=\"cachedir\", default=os.path.normpath(os.path.dirname(os.path.realpath(__file__))+\"/../../cache\"),\n+        parser.add_option(\"--cachedir\", dest=\"cachedir\", default=os.path.normpath(os.path.dirname(os.path.realpath(__file__)) + \"/../../cache\"),\n                           help=\"Directory for caching pregenerated datadirs\")\n         parser.add_option(\"--tmpdir\", dest=\"tmpdir\", help=\"Root directory for datadirs\")\n         parser.add_option(\"-l\", \"--loglevel\", dest=\"loglevel\", default=\"INFO\",\n@@ -134,7 +135,7 @@ def main(self):\n \n         PortSeed.n = self.options.port_seed\n \n-        os.environ['PATH'] = self.options.srcdir+\":\"+self.options.srcdir+\"/qt:\"+os.environ['PATH']\n+        os.environ['PATH'] = self.options.srcdir + \":\" + self.options.srcdir + \"/qt:\" + os.environ['PATH']\n \n         check_json_precision()\n \n@@ -188,7 +189,7 @@ def main(self):\n                 for fn in filenames:\n                     try:\n                         with open(fn, 'r') as f:\n-                            print(\"From\" , fn, \":\")\n+                            print(\"From\", fn, \":\")\n                             print(\"\".join(deque(f, MAX_LINES_TO_PRINT)))\n                     except OSError:\n                         print(\"Opening file %s failed.\" % fn)\n@@ -257,7 +258,7 @@ def _start_logging(self):\n         ll = int(self.options.loglevel) if self.options.loglevel.isdigit() else self.options.loglevel.upper()\n         ch.setLevel(ll)\n         # Format logs the same as bitcoind's debug.log with microprecision (so log files can be concatenated and sorted)\n-        formatter = logging.Formatter(fmt = '%(asctime)s.%(msecs)03d000 %(name)s (%(levelname)s): %(message)s', datefmt='%Y-%m-%d %H:%M:%S')\n+        formatter = logging.Formatter(fmt='%(asctime)s.%(msecs)03d000 %(name)s (%(levelname)s): %(message)s', datefmt='%Y-%m-%d %H:%M:%S')\n         formatter.converter = time.gmtime\n         fh.setFormatter(formatter)\n         ch.setFormatter(formatter)\n@@ -354,18 +355,13 @@ def _initialize_chain_clean(self, test_dir, num_nodes):\n         for i in range(num_nodes):\n             initialize_datadir(test_dir, i)\n \n-# Test framework for doing p2p comparison testing, which sets up some bitcoind\n-# binaries:\n-# 1 binary: test binary\n-# 2 binaries: 1 test binary, 1 ref binary\n-# n>2 binaries: 1 test binary, n-1 ref binaries\n-\n-class SkipTest(Exception):\n-    \"\"\"This exception is raised to skip a test\"\"\"\n-    def __init__(self, message):\n-        self.message = message\n-\n class ComparisonTestFramework(BitcoinTestFramework):\n+    \"\"\"Test framework for doing p2p comparison testing\n+\n+    Sets up some bitcoind binaries:\n+    - 1 binary: test binary\n+    - 2 binaries: 1 test binary, 1 ref binary\n+    - n>2 binaries: 1 test binary, n-1 ref binaries\"\"\"\n \n     def __init__(self):\n         super().__init__()\n@@ -387,4 +383,9 @@ def setup_network(self):\n         self.nodes = self.start_nodes(\n             self.num_nodes, self.options.tmpdir, extra_args,\n             binary=[self.options.testbinary] +\n-            [self.options.refbinary]*(self.num_nodes-1))\n+            [self.options.refbinary] * (self.num_nodes - 1))\n+\n+class SkipTest(Exception):\n+    \"\"\"This exception is raised to skip a test\"\"\"\n+    def __init__(self, message):\n+        self.message = message"
      },
      {
        "sha": "d02a130a1f829c0df4777f644534a966a2e32c1d",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 85,
        "deletions": 83,
        "changes": 168,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f1fe5368f191018a72276a93a9e74cd95f896697/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f1fe5368f191018a72276a93a9e74cd95f896697/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=f1fe5368f191018a72276a93a9e74cd95f896697",
        "patch": "@@ -4,20 +4,19 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Helpful routines for regression testing.\"\"\"\n \n-import os\n-\n-from binascii import hexlify, unhexlify\n from base64 import b64encode\n+from binascii import hexlify, unhexlify\n from decimal import Decimal, ROUND_DOWN\n-import json\n+import errno\n import http.client\n+import json\n+import logging\n+import os\n import random\n+import re\n import subprocess\n import tempfile\n import time\n-import re\n-import errno\n-import logging\n \n from . import coverage\n from .authproxy import AuthServiceProxy, JSONRPCException\n@@ -40,17 +39,17 @@ class PortSeed:\n     # Must be initialized with a unique integer for each process\n     n = None\n \n-#Set Mocktime default to OFF.\n-#MOCKTIME is only needed for scripts that use the\n-#cached version of the blockchain.  If the cached\n-#version of the blockchain is used without MOCKTIME\n-#then the mempools will not sync due to IBD.\n+# Set Mocktime default to OFF.\n+# MOCKTIME is only needed for scripts that use the\n+# cached version of the blockchain.  If the cached\n+# version of the blockchain is used without MOCKTIME\n+# then the mempools will not sync due to IBD.\n MOCKTIME = 0\n \n def enable_mocktime():\n-    #For backwared compatibility of the python scripts\n-    #with previous versions of the cache, set MOCKTIME \n-    #to Jan 1, 2014 + (201 * 10 * 60)\n+    # For backwared compatibility of the python scripts\n+    # with previous versions of the cache, set MOCKTIME\n+    # to Jan 1, 2014 + (201 * 10 * 60)\n     global MOCKTIME\n     MOCKTIME = 1388534400 + (201 * 10 * 60)\n \n@@ -103,7 +102,7 @@ def rpc_port(n):\n def check_json_precision():\n     \"\"\"Make sure json library being used does not lose precision converting BTC values\"\"\"\n     n = Decimal(\"20000000.00000003\")\n-    satoshis = int(json.loads(json.dumps(float(n)))*1.0e8)\n+    satoshis = int(json.loads(json.dumps(float(n))) * 1.0e8)\n     if satoshis != 2000000000000003:\n         raise RuntimeError(\"JSON encode/decode loses precision\")\n \n@@ -150,7 +149,7 @@ def sync_chain(rpc_connections, *, wait=1, timeout=60):\n     \"\"\"\n     while timeout > 0:\n         best_hash = [x.getbestblockhash() for x in rpc_connections]\n-        if best_hash == [best_hash[0]]*len(best_hash):\n+        if best_hash == [best_hash[0]] * len(best_hash):\n             return\n         time.sleep(wait)\n         timeout -= wait\n@@ -166,7 +165,7 @@ def sync_mempools(rpc_connections, *, wait=1, timeout=60):\n         num_match = 1\n         for i in range(1, len(rpc_connections)):\n             if set(rpc_connections[i].getrawmempool()) == pool:\n-                num_match = num_match+1\n+                num_match = num_match + 1\n         if num_match == len(rpc_connections):\n             return\n         time.sleep(wait)\n@@ -176,18 +175,18 @@ def sync_mempools(rpc_connections, *, wait=1, timeout=60):\n bitcoind_processes = {}\n \n def initialize_datadir(dirname, n):\n-    datadir = os.path.join(dirname, \"node\"+str(n))\n+    datadir = os.path.join(dirname, \"node\" + str(n))\n     if not os.path.isdir(datadir):\n         os.makedirs(datadir)\n     with open(os.path.join(datadir, \"bitcoin.conf\"), 'w', encoding='utf8') as f:\n         f.write(\"regtest=1\\n\")\n-        f.write(\"port=\"+str(p2p_port(n))+\"\\n\")\n-        f.write(\"rpcport=\"+str(rpc_port(n))+\"\\n\")\n+        f.write(\"port=\" + str(p2p_port(n)) + \"\\n\")\n+        f.write(\"rpcport=\" + str(rpc_port(n)) + \"\\n\")\n         f.write(\"listenonion=0\\n\")\n     return datadir\n \n def get_datadir_path(dirname, n):\n-    return os.path.join(dirname, \"node\"+str(n))\n+    return os.path.join(dirname, \"node\" + str(n))\n \n def get_auth_cookie(datadir, n):\n     user = None\n@@ -196,10 +195,10 @@ def get_auth_cookie(datadir, n):\n         with open(os.path.join(datadir, \"bitcoin.conf\"), 'r') as f:\n             for line in f:\n                 if line.startswith(\"rpcuser=\"):\n-                    assert user is None # Ensure that there is only one rpcuser line\n+                    assert user is None  # Ensure that there is only one rpcuser line\n                     user = line.split(\"=\")[1].strip(\"\\n\")\n                 if line.startswith(\"rpcpassword=\"):\n-                    assert password is None # Ensure that there is only one rpcpassword line\n+                    assert password is None  # Ensure that there is only one rpcpassword line\n                     password = line.split(\"=\")[1].strip(\"\\n\")\n     if os.path.isfile(os.path.join(datadir, \"regtest\", \".cookie\")):\n         with open(os.path.join(datadir, \"regtest\", \".cookie\"), 'r') as f:\n@@ -234,15 +233,15 @@ def wait_for_bitcoind_start(process, datadir, i, rpchost=None):\n         try:\n             # Check if .cookie file to be created\n             rpc = get_rpc_proxy(rpc_url(datadir, i, rpchost), i)\n-            blocks = rpc.getblockcount()\n-            break # break out of loop on success\n+            rpc.getblockcount()\n+            break  # break out of loop on success\n         except IOError as e:\n-            if e.errno != errno.ECONNREFUSED: # Port not yet open?\n-                raise # unknown IO error\n-        except JSONRPCException as e: # Initialization phase\n-            if e.error['code'] != -28: # RPC in warmup?\n-                raise # unknown JSON RPC exception\n-        except ValueError as e: # cookie file not found and no rpcuser or rpcassword. bitcoind still starting\n+            if e.errno != errno.ECONNREFUSED:  # Port not yet open?\n+                raise  # unknown IO error\n+        except JSONRPCException as e:  # Initialization phase\n+            if e.error['code'] != -28:  # RPC in warmup?\n+                raise  # unknown JSON RPC exception\n+        except ValueError as e:  # cookie file not found and no rpcuser or rpcassword. bitcoind still starting\n             if \"No RPC credentials\" not in str(e):\n                 raise\n         time.sleep(0.25)\n@@ -255,11 +254,12 @@ def _start_node(i, dirname, extra_args=None, rpchost=None, timewait=None, binary\n \n     This function should only be called from within test_framework, not by individual test scripts.\"\"\"\n \n-    datadir = os.path.join(dirname, \"node\"+str(i))\n+    datadir = os.path.join(dirname, \"node\" + str(i))\n     if binary is None:\n         binary = os.getenv(\"BITCOIND\", \"bitcoind\")\n     args = [binary, \"-datadir=\" + datadir, \"-server\", \"-keypool=1\", \"-discover=0\", \"-rest\", \"-logtimemicros\", \"-debug\", \"-debugexclude=libevent\", \"-debugexclude=leveldb\", \"-mocktime=\" + str(get_mocktime()), \"-uacomment=testnode%d\" % i]\n-    if extra_args is not None: args.extend(extra_args)\n+    if extra_args is not None:\n+        args.extend(extra_args)\n     bitcoind_processes[i] = subprocess.Popen(args, stderr=stderr)\n     logger.debug(\"initialize_chain: bitcoind started, waiting for RPC to come up\")\n     wait_for_bitcoind_start(bitcoind_processes[i], datadir, i, rpchost)\n@@ -277,7 +277,7 @@ def assert_start_raises_init_error(i, dirname, extra_args=None, expected_msg=Non\n             node = _start_node(i, dirname, extra_args, stderr=log_stderr)\n             _stop_node(node, i)\n         except Exception as e:\n-            assert 'bitcoind exited' in str(e) #node must have shutdown\n+            assert 'bitcoind exited' in str(e)  # node must have shutdown\n             if expected_msg is not None:\n                 log_stderr.seek(0)\n                 stderr = log_stderr.read().decode('utf-8')\n@@ -292,24 +292,27 @@ def assert_start_raises_init_error(i, dirname, extra_args=None, expected_msg=Non\n \n def _start_nodes(num_nodes, dirname, extra_args=None, rpchost=None, timewait=None, binary=None):\n     \"\"\"Start multiple bitcoinds, return RPC connections to them\n-    \n+\n     This function should only be called from within test_framework, not by individual test scripts.\"\"\"\n \n-    if extra_args is None: extra_args = [ None for _ in range(num_nodes) ]\n-    if binary is None: binary = [ None for _ in range(num_nodes) ]\n+    if extra_args is None:\n+        extra_args = [None] * num_nodes\n+    if binary is None:\n+        binary = [None] * num_nodes\n     assert_equal(len(extra_args), num_nodes)\n     assert_equal(len(binary), num_nodes)\n     rpcs = []\n     try:\n         for i in range(num_nodes):\n             rpcs.append(_start_node(i, dirname, extra_args[i], rpchost, timewait=timewait, binary=binary[i]))\n-    except: # If one node failed to start, stop the others\n+    except:\n+        # If one node failed to start, stop the others\n         _stop_nodes(rpcs)\n         raise\n     return rpcs\n \n def log_filename(dirname, n_node, logname):\n-    return os.path.join(dirname, \"node\"+str(n_node), \"regtest\", logname)\n+    return os.path.join(dirname, \"node\" + str(n_node), \"regtest\", logname)\n \n def _stop_node(node, i):\n     \"\"\"Stop a bitcoind test node\n@@ -332,7 +335,7 @@ def _stop_nodes(nodes):\n \n     for i, node in enumerate(nodes):\n         _stop_node(node, i)\n-    assert not bitcoind_processes.values() # All connections must be gone now\n+    assert not bitcoind_processes.values()  # All connections must be gone now\n \n def set_node_times(nodes, t):\n     for node in nodes:\n@@ -350,7 +353,7 @@ def disconnect_nodes(from_connection, node_num):\n         raise AssertionError(\"timed out waiting for disconnect\")\n \n def connect_nodes(from_connection, node_num):\n-    ip_port = \"127.0.0.1:\"+str(p2p_port(node_num))\n+    ip_port = \"127.0.0.1:\" + str(p2p_port(node_num))\n     from_connection.addnode(ip_port, \"onetry\")\n     # poll until version handshake complete to avoid race conditions\n     # with transaction relaying\n@@ -370,38 +373,37 @@ def find_output(node, txid, amount):\n     for i in range(len(txdata[\"vout\"])):\n         if txdata[\"vout\"][i][\"value\"] == amount:\n             return i\n-    raise RuntimeError(\"find_output txid %s : %s not found\"%(txid,str(amount)))\n-\n+    raise RuntimeError(\"find_output txid %s : %s not found\" % (txid, str(amount)))\n \n def gather_inputs(from_node, amount_needed, confirmations_required=1):\n     \"\"\"\n     Return a random set of unspent txouts that are enough to pay amount_needed\n     \"\"\"\n-    assert(confirmations_required >=0)\n+    assert(confirmations_required >= 0)\n     utxo = from_node.listunspent(confirmations_required)\n     random.shuffle(utxo)\n     inputs = []\n     total_in = Decimal(\"0.00000000\")\n     while total_in < amount_needed and len(utxo) > 0:\n         t = utxo.pop()\n         total_in += t[\"amount\"]\n-        inputs.append({ \"txid\" : t[\"txid\"], \"vout\" : t[\"vout\"], \"address\" : t[\"address\"] } )\n+        inputs.append({\"txid\": t[\"txid\"], \"vout\": t[\"vout\"], \"address\": t[\"address\"]})\n     if total_in < amount_needed:\n-        raise RuntimeError(\"Insufficient funds: need %d, have %d\"%(amount_needed, total_in))\n+        raise RuntimeError(\"Insufficient funds: need %d, have %d\" % (amount_needed, total_in))\n     return (total_in, inputs)\n \n def make_change(from_node, amount_in, amount_out, fee):\n     \"\"\"\n     Create change output(s), return them\n     \"\"\"\n     outputs = {}\n-    amount = amount_out+fee\n+    amount = amount_out + fee\n     change = amount_in - amount\n-    if change > amount*2:\n+    if change > amount * 2:\n         # Create an extra change output to break up big inputs\n         change_address = from_node.getnewaddress()\n         # Split change in two, being careful of rounding:\n-        outputs[change_address] = Decimal(change/2).quantize(Decimal('0.00000001'), rounding=ROUND_DOWN)\n+        outputs[change_address] = Decimal(change / 2).quantize(Decimal('0.00000001'), rounding=ROUND_DOWN)\n         change = amount_in - amount - outputs[change_address]\n     if change > 0:\n         outputs[from_node.getnewaddress()] = change\n@@ -414,9 +416,9 @@ def random_transaction(nodes, amount, min_fee, fee_increment, fee_variants):\n     \"\"\"\n     from_node = random.choice(nodes)\n     to_node = random.choice(nodes)\n-    fee = min_fee + fee_increment*random.randint(0,fee_variants)\n+    fee = min_fee + fee_increment * random.randint(0, fee_variants)\n \n-    (total_in, inputs) = gather_inputs(from_node, amount+fee)\n+    (total_in, inputs) = gather_inputs(from_node, amount + fee)\n     outputs = make_change(from_node, total_in, amount, fee)\n     outputs[to_node.getnewaddress()] = float(amount)\n \n@@ -430,22 +432,22 @@ def assert_fee_amount(fee, tx_size, fee_per_kB):\n     \"\"\"Assert the fee was in range\"\"\"\n     target_fee = tx_size * fee_per_kB / 1000\n     if fee < target_fee:\n-        raise AssertionError(\"Fee of %s BTC too low! (Should be %s BTC)\"%(str(fee), str(target_fee)))\n+        raise AssertionError(\"Fee of %s BTC too low! (Should be %s BTC)\" % (str(fee), str(target_fee)))\n     # allow the wallet's estimation to be at most 2 bytes off\n     if fee > (tx_size + 2) * fee_per_kB / 1000:\n-        raise AssertionError(\"Fee of %s BTC too high! (Should be %s BTC)\"%(str(fee), str(target_fee)))\n+        raise AssertionError(\"Fee of %s BTC too high! (Should be %s BTC)\" % (str(fee), str(target_fee)))\n \n def assert_equal(thing1, thing2, *args):\n     if thing1 != thing2 or any(thing1 != arg for arg in args):\n         raise AssertionError(\"not(%s)\" % \" == \".join(str(arg) for arg in (thing1, thing2) + args))\n \n def assert_greater_than(thing1, thing2):\n     if thing1 <= thing2:\n-        raise AssertionError(\"%s <= %s\"%(str(thing1),str(thing2)))\n+        raise AssertionError(\"%s <= %s\" % (str(thing1), str(thing2)))\n \n def assert_greater_than_or_equal(thing1, thing2):\n     if thing1 < thing2:\n-        raise AssertionError(\"%s < %s\"%(str(thing1),str(thing2)))\n+        raise AssertionError(\"%s < %s\" % (str(thing1), str(thing2)))\n \n def assert_raises(exc, fun, *args, **kwds):\n     assert_raises_message(exc, None, fun, *args, **kwds)\n@@ -455,9 +457,9 @@ def assert_raises_message(exc, message, fun, *args, **kwds):\n         fun(*args, **kwds)\n     except exc as e:\n         if message is not None and message not in e.error['message']:\n-            raise AssertionError(\"Expected substring not found:\"+e.error['message'])\n+            raise AssertionError(\"Expected substring not found:\" + e.error['message'])\n     except Exception as e:\n-        raise AssertionError(\"Unexpected exception raised: \"+type(e).__name__)\n+        raise AssertionError(\"Unexpected exception raised: \" + type(e).__name__)\n     else:\n         raise AssertionError(\"No exception raised\")\n \n@@ -484,9 +486,9 @@ def assert_raises_jsonrpc(code, message, fun, *args, **kwds):\n         if (code is not None) and (code != e.error[\"code\"]):\n             raise AssertionError(\"Unexpected JSONRPC error code %i\" % e.error[\"code\"])\n         if (message is not None) and (message not in e.error['message']):\n-            raise AssertionError(\"Expected substring not found:\"+e.error['message'])\n+            raise AssertionError(\"Expected substring not found:\" + e.error['message'])\n     except Exception as e:\n-        raise AssertionError(\"Unexpected exception raised: \"+type(e).__name__)\n+        raise AssertionError(\"Unexpected exception raised: \" + type(e).__name__)\n     else:\n         raise AssertionError(\"No exception raised\")\n \n@@ -507,42 +509,42 @@ def assert_is_hash_string(string, length=64):\n         raise AssertionError(\n             \"String %r contains invalid characters for a hash.\" % string)\n \n-def assert_array_result(object_array, to_match, expected, should_not_find = False):\n+def assert_array_result(object_array, to_match, expected, should_not_find=False):\n     \"\"\"\n         Pass in array of JSON objects, a dictionary with key/value pairs\n         to match against, and another dictionary with expected key/value\n         pairs.\n         If the should_not_find flag is true, to_match should not be found\n         in object_array\n         \"\"\"\n-    if should_not_find == True:\n-        assert_equal(expected, { })\n+    if should_not_find:\n+        assert_equal(expected, {})\n     num_matched = 0\n     for item in object_array:\n         all_match = True\n-        for key,value in to_match.items():\n+        for key, value in to_match.items():\n             if item[key] != value:\n                 all_match = False\n         if not all_match:\n             continue\n-        elif should_not_find == True:\n-            num_matched = num_matched+1\n-        for key,value in expected.items():\n+        elif should_not_find:\n+            num_matched = num_matched + 1\n+        for key, value in expected.items():\n             if item[key] != value:\n-                raise AssertionError(\"%s : expected %s=%s\"%(str(item), str(key), str(value)))\n-            num_matched = num_matched+1\n-    if num_matched == 0 and should_not_find != True:\n-        raise AssertionError(\"No objects matched %s\"%(str(to_match)))\n-    if num_matched > 0 and should_not_find == True:\n-        raise AssertionError(\"Objects were found %s\"%(str(to_match)))\n+                raise AssertionError(\"%s : expected %s=%s\" % (str(item), str(key), str(value)))\n+            num_matched = num_matched + 1\n+    if num_matched == 0 and not should_not_find:\n+        raise AssertionError(\"No objects matched %s\" % (str(to_match)))\n+    if num_matched > 0 and should_not_find:\n+        raise AssertionError(\"Objects were found %s\" % (str(to_match)))\n \n def satoshi_round(amount):\n     return Decimal(amount).quantize(Decimal('0.00000001'), rounding=ROUND_DOWN)\n \n # Helper to create at least \"count\" utxos\n # Pass in a fee that is sufficient for relay and mining new transactions.\n def create_confirmed_utxos(fee, node, count):\n-    node.generate(int(0.5*count)+101)\n+    node.generate(int(0.5 * count) + 101)\n     utxos = node.listunspent()\n     iterations = count - len(utxos)\n     addr1 = node.getnewaddress()\n@@ -552,14 +554,14 @@ def create_confirmed_utxos(fee, node, count):\n     for i in range(iterations):\n         t = utxos.pop()\n         inputs = []\n-        inputs.append({ \"txid\" : t[\"txid\"], \"vout\" : t[\"vout\"]})\n+        inputs.append({\"txid\": t[\"txid\"], \"vout\": t[\"vout\"]})\n         outputs = {}\n         send_value = t['amount'] - fee\n-        outputs[addr1] = satoshi_round(send_value/2)\n-        outputs[addr2] = satoshi_round(send_value/2)\n+        outputs[addr1] = satoshi_round(send_value / 2)\n+        outputs[addr2] = satoshi_round(send_value / 2)\n         raw_tx = node.createrawtransaction(inputs, outputs)\n         signed_tx = node.signrawtransaction(raw_tx)[\"hex\"]\n-        txid = node.sendrawtransaction(signed_tx)\n+        node.sendrawtransaction(signed_tx)\n \n     while (node.getmempoolinfo()['size'] > 0):\n         node.generate(1)\n@@ -574,8 +576,8 @@ def gen_return_txouts():\n     # Some pre-processing to create a bunch of OP_RETURN txouts to insert into transactions we create\n     # So we have big transactions (and therefore can't fit very many into each block)\n     # create one script_pubkey\n-    script_pubkey = \"6a4d0200\" #OP_RETURN OP_PUSH2 512 bytes\n-    for i in range (512):\n+    script_pubkey = \"6a4d0200\"  # OP_RETURN OP_PUSH2 512 bytes\n+    for i in range(512):\n         script_pubkey = script_pubkey + \"01\"\n     # concatenate 128 txouts of above script_pubkey which we'll insert before the txout for change\n     txouts = \"81\"\n@@ -589,8 +591,8 @@ def gen_return_txouts():\n     return txouts\n \n def create_tx(node, coinbase, to_address, amount):\n-    inputs = [{ \"txid\" : coinbase, \"vout\" : 0}]\n-    outputs = { to_address : amount }\n+    inputs = [{\"txid\": coinbase, \"vout\": 0}]\n+    outputs = {to_address: amount}\n     rawtx = node.createrawtransaction(inputs, outputs)\n     signresult = node.signrawtransaction(rawtx)\n     assert_equal(signresult[\"complete\"], True)\n@@ -603,7 +605,7 @@ def create_lots_of_big_transactions(node, txouts, utxos, num, fee):\n     txids = []\n     for _ in range(num):\n         t = utxos.pop()\n-        inputs=[{ \"txid\" : t[\"txid\"], \"vout\" : t[\"vout\"]}]\n+        inputs = [{\"txid\": t[\"txid\"], \"vout\": t[\"vout\"]}]\n         outputs = {}\n         change = t['amount'] - fee\n         outputs[addr] = satoshi_round(change)"
      }
    ]
  },
  {
    "sha": "cad967a892d836b3afbd1ab81c73731e968368c6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjYWQ5NjdhODkyZDgzNmIzYWZiZDFhYjgxYzczNzMxZTk2ODM2OGM2",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-06-02T17:14:14Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-06-29T10:55:19Z"
      },
      "message": "[tests] Move stop_node and start_node methods to BitcoinTestFramework\n\nThis commit moves functions start_node, start_nodes, stop_node and\nstop_nodes functions into the BitcoinTestFramework class. It also moves\nthe bitcoind_processes dict and coverage variables into BitcoinTestFramework.",
      "tree": {
        "sha": "2d14c93b35f492798fd89ac6481218c9d489a30b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2d14c93b35f492798fd89ac6481218c9d489a30b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cad967a892d836b3afbd1ab81c73731e968368c6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cad967a892d836b3afbd1ab81c73731e968368c6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cad967a892d836b3afbd1ab81c73731e968368c6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cad967a892d836b3afbd1ab81c73731e968368c6/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f1fe5368f191018a72276a93a9e74cd95f896697",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f1fe5368f191018a72276a93a9e74cd95f896697",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f1fe5368f191018a72276a93a9e74cd95f896697"
      }
    ],
    "stats": {
      "total": 303,
      "additions": 131,
      "deletions": 172
    },
    "files": [
      {
        "sha": "a7034e6bcdbab5f2d743cfaab9cbfefb9a570840",
        "filename": "test/functional/blockchain.py",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cad967a892d836b3afbd1ab81c73731e968368c6/test/functional/blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cad967a892d836b3afbd1ab81c73731e968368c6/test/functional/blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/blockchain.py?ref=cad967a892d836b3afbd1ab81c73731e968368c6",
        "patch": "@@ -21,15 +21,13 @@\n import http.client\n import subprocess\n \n-from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.test_framework import (BitcoinTestFramework, BITCOIND_PROC_WAIT_TIMEOUT)\n from test_framework.util import (\n     assert_equal,\n     assert_raises,\n     assert_raises_jsonrpc,\n     assert_is_hex_string,\n     assert_is_hash_string,\n-    bitcoind_processes,\n-    BITCOIND_PROC_WAIT_TIMEOUT,\n )\n \n \n@@ -141,13 +139,13 @@ def _test_stopatheight(self):\n         self.nodes[0].generate(6)\n         assert_equal(self.nodes[0].getblockcount(), 206)\n         self.log.debug('Node should not stop at this height')\n-        assert_raises(subprocess.TimeoutExpired, lambda: bitcoind_processes[0].wait(timeout=3))\n+        assert_raises(subprocess.TimeoutExpired, lambda: self.bitcoind_processes[0].wait(timeout=3))\n         try:\n             self.nodes[0].generate(1)\n         except (ConnectionError, http.client.BadStatusLine):\n             pass  # The node already shut down before response\n         self.log.debug('Node should stop at this height...')\n-        bitcoind_processes[0].wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n+        self.bitcoind_processes[0].wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n         self.nodes[0] = self.start_node(0, self.options.tmpdir)\n         assert_equal(self.nodes[0].getblockcount(), 207)\n "
      },
      {
        "sha": "9237f0924012b1b1952037d4aab9475f16f45cf3",
        "filename": "test/functional/bumpfee.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cad967a892d836b3afbd1ab81c73731e968368c6/test/functional/bumpfee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cad967a892d836b3afbd1ab81c73731e968368c6/test/functional/bumpfee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bumpfee.py?ref=cad967a892d836b3afbd1ab81c73731e968368c6",
        "patch": "@@ -42,7 +42,7 @@ def setup_network(self, split=False):\n \n         # Encrypt wallet for test_locked_wallet_fails test\n         self.nodes[1].encryptwallet(WALLET_PASSPHRASE)\n-        bitcoind_processes[1].wait()\n+        self.bitcoind_processes[1].wait()\n         self.nodes[1] = self.start_node(1, self.options.tmpdir, extra_args[1])\n         self.nodes[1].walletpassphrase(WALLET_PASSPHRASE, WALLET_PASSPHRASE_TIMEOUT)\n "
      },
      {
        "sha": "6f877f8362fe06d9b8c8b9950cd2c1d11a0fc4a3",
        "filename": "test/functional/dbcrash.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cad967a892d836b3afbd1ab81c73731e968368c6/test/functional/dbcrash.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cad967a892d836b3afbd1ab81c73731e968368c6/test/functional/dbcrash.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/dbcrash.py?ref=cad967a892d836b3afbd1ab81c73731e968368c6",
        "patch": "@@ -88,7 +88,7 @@ def restart_node(self, node_index, expected_tip):\n                 # An exception here should mean the node is about to crash.\n                 # If bitcoind exits, then try again.  wait_for_node_exit()\n                 # should raise an exception if bitcoind doesn't exit.\n-                wait_for_node_exit(node_index, timeout=10)\n+                self.wait_for_node_exit(node_index, timeout=10)\n             self.crashed_on_restart += 1\n             time.sleep(1)\n \n@@ -140,7 +140,7 @@ def sync_node3blocks(self, block_hashes):\n                 if not self.submit_block_catch_error(i, block):\n                     # TODO: more carefully check that the crash is due to -dbcrashratio\n                     # (change the exit code perhaps, and check that here?)\n-                    wait_for_node_exit(i, timeout=30)\n+                    self.wait_for_node_exit(i, timeout=30)\n                     self.log.debug(\"Restarting node %d after block hash %s\", i, block_hash)\n                     nodei_utxo_hash = self.restart_node(i, block_hash)\n                     assert nodei_utxo_hash is not None"
      },
      {
        "sha": "0baab6d01cf3cbb5c4697a6059cb814dce309541",
        "filename": "test/functional/fundrawtransaction.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cad967a892d836b3afbd1ab81c73731e968368c6/test/functional/fundrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cad967a892d836b3afbd1ab81c73731e968368c6/test/functional/fundrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/fundrawtransaction.py?ref=cad967a892d836b3afbd1ab81c73731e968368c6",
        "patch": "@@ -4,7 +4,7 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the fundrawtransaction RPC.\"\"\"\n \n-from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.test_framework import BitcoinTestFramework, BITCOIND_PROC_WAIT_TIMEOUT\n from test_framework.util import *\n \n \n@@ -452,7 +452,7 @@ def run_test(self):\n         self.stop_node(2)\n         self.stop_node(3)\n         self.nodes[1].encryptwallet(\"test\")\n-        bitcoind_processes[1].wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n+        self.bitcoind_processes[1].wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n \n         self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir)\n         # This test is not meant to test fee estimation and we'd like"
      },
      {
        "sha": "e8be559918d52ae8449aec4ef1535c6b01c3bc3d",
        "filename": "test/functional/keypool.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cad967a892d836b3afbd1ab81c73731e968368c6/test/functional/keypool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cad967a892d836b3afbd1ab81c73731e968368c6/test/functional/keypool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/keypool.py?ref=cad967a892d836b3afbd1ab81c73731e968368c6",
        "patch": "@@ -18,7 +18,7 @@ def run_test(self):\n         \n         # Encrypt wallet and wait to terminate\n         nodes[0].encryptwallet('test')\n-        bitcoind_processes[0].wait()\n+        self.bitcoind_processes[0].wait()\n         # Restart node 0\n         nodes[0] = self.start_node(0, self.options.tmpdir)\n         # Keep creating keys"
      },
      {
        "sha": "951685aa7606a16c089c4280d0b221e836902774",
        "filename": "test/functional/rpcbind_test.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cad967a892d836b3afbd1ab81c73731e968368c6/test/functional/rpcbind_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cad967a892d836b3afbd1ab81c73731e968368c6/test/functional/rpcbind_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpcbind_test.py?ref=cad967a892d836b3afbd1ab81c73731e968368c6",
        "patch": "@@ -37,7 +37,7 @@ def run_bind_test(self, allow_ips, connect_to, addresses, expected):\n             base_args += ['-rpcallowip=' + x for x in allow_ips]\n         binds = ['-rpcbind='+addr for addr in addresses]\n         self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir, [base_args + binds], connect_to)\n-        pid = bitcoind_processes[0].pid\n+        pid = self.bitcoind_processes[0].pid\n         assert_equal(set(get_bind_addrs(pid)), set(expected))\n         self.stop_nodes()\n "
      },
      {
        "sha": "557c9db4823ec0670f2d0017ec31e51d4300b085",
        "filename": "test/functional/test_framework/test_framework.py",
        "status": "modified",
        "additions": 114,
        "deletions": 21,
        "changes": 135,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cad967a892d836b3afbd1ab81c73731e968368c6/test/functional/test_framework/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cad967a892d836b3afbd1ab81c73731e968368c6/test/functional/test_framework/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_framework.py?ref=cad967a892d836b3afbd1ab81c73731e968368c6",
        "patch": "@@ -5,7 +5,9 @@\n \"\"\"Base class for RPC testing.\"\"\"\n \n from collections import deque\n+import errno\n from enum import Enum\n+import http.client\n import logging\n import optparse\n import os\n@@ -16,15 +18,16 @@\n import time\n import traceback\n \n+from .authproxy import JSONRPCException\n+from . import coverage\n from .util import (\n-    PortSeed,\n     MAX_NODES,\n-    bitcoind_processes,\n+    PortSeed,\n+    assert_equal,\n     check_json_precision,\n     connect_nodes_bi,\n     disable_mocktime,\n     disconnect_nodes,\n-    enable_coverage,\n     enable_mocktime,\n     get_mocktime,\n     get_rpc_proxy,\n@@ -34,15 +37,9 @@\n     p2p_port,\n     rpc_url,\n     set_node_times,\n-    _start_node,\n-    _start_nodes,\n-    _stop_node,\n-    _stop_nodes,\n     sync_blocks,\n     sync_mempools,\n-    wait_for_bitcoind_start,\n )\n-from .authproxy import JSONRPCException\n \n class TestStatus(Enum):\n     PASSED = 1\n@@ -53,6 +50,8 @@ class TestStatus(Enum):\n TEST_EXIT_FAILED = 1\n TEST_EXIT_SKIPPED = 77\n \n+BITCOIND_PROC_WAIT_TIMEOUT = 60\n+\n class BitcoinTestFramework(object):\n     \"\"\"Base class for a bitcoin test script.\n \n@@ -72,7 +71,8 @@ class BitcoinTestFramework(object):\n     def __init__(self):\n         self.num_nodes = 4\n         self.setup_clean_chain = False\n-        self.nodes = None\n+        self.nodes = []\n+        self.bitcoind_processes = {}\n \n     def add_options(self, parser):\n         pass\n@@ -98,7 +98,7 @@ def setup_nodes(self):\n         extra_args = None\n         if hasattr(self, \"extra_args\"):\n             extra_args = self.extra_args\n-        self.nodes = _start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n+        self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n \n     def run_test(self):\n         raise NotImplementedError\n@@ -130,9 +130,6 @@ def main(self):\n         self.add_options(parser)\n         (self.options, self.args) = parser.parse_args()\n \n-        if self.options.coveragedir:\n-            enable_coverage(self.options.coveragedir)\n-\n         PortSeed.n = self.options.port_seed\n \n         os.environ['PATH'] = self.options.srcdir + \":\" + self.options.srcdir + \"/qt:\" + os.environ['PATH']\n@@ -209,16 +206,88 @@ def main(self):\n     # Public helper methods. These can be accessed by the subclass test scripts.\n \n     def start_node(self, i, dirname, extra_args=None, rpchost=None, timewait=None, binary=None, stderr=None):\n-        return _start_node(i, dirname, extra_args, rpchost, timewait, binary, stderr)\n+        \"\"\"Start a bitcoind and return RPC connection to it\"\"\"\n+\n+        datadir = os.path.join(dirname, \"node\" + str(i))\n+        if binary is None:\n+            binary = os.getenv(\"BITCOIND\", \"bitcoind\")\n+        args = [binary, \"-datadir=\" + datadir, \"-server\", \"-keypool=1\", \"-discover=0\", \"-rest\", \"-logtimemicros\", \"-debug\", \"-debugexclude=libevent\", \"-debugexclude=leveldb\", \"-mocktime=\" + str(get_mocktime()), \"-uacomment=testnode%d\" % i]\n+        if extra_args is not None:\n+            args.extend(extra_args)\n+        self.bitcoind_processes[i] = subprocess.Popen(args, stderr=stderr)\n+        self.log.debug(\"initialize_chain: bitcoind started, waiting for RPC to come up\")\n+        self._wait_for_bitcoind_start(self.bitcoind_processes[i], datadir, i, rpchost)\n+        self.log.debug(\"initialize_chain: RPC successfully started\")\n+        proxy = get_rpc_proxy(rpc_url(datadir, i, rpchost), i, timeout=timewait)\n+\n+        if self.options.coveragedir:\n+            coverage.write_all_rpc_commands(self.options.coveragedir, proxy)\n+\n+        return proxy\n \n     def start_nodes(self, num_nodes, dirname, extra_args=None, rpchost=None, timewait=None, binary=None):\n-        return _start_nodes(num_nodes, dirname, extra_args, rpchost, timewait, binary)\n+        \"\"\"Start multiple bitcoinds, return RPC connections to them\"\"\"\n+\n+        if extra_args is None:\n+            extra_args = [None] * num_nodes\n+        if binary is None:\n+            binary = [None] * num_nodes\n+        assert_equal(len(extra_args), num_nodes)\n+        assert_equal(len(binary), num_nodes)\n+        rpcs = []\n+        try:\n+            for i in range(num_nodes):\n+                rpcs.append(self.start_node(i, dirname, extra_args[i], rpchost, timewait=timewait, binary=binary[i]))\n+        except:\n+            # If one node failed to start, stop the others\n+            # TODO: abusing self.nodes in this way is a little hacky.\n+            # Eventually we should do a better job of tracking nodes\n+            self.nodes.extend(rpcs)\n+            self.stop_nodes()\n+            self.nodes = []\n+            raise\n+        return rpcs\n+\n+    def stop_node(self, i):\n+        \"\"\"Stop a bitcoind test node\"\"\"\n \n-    def stop_node(self, num_node):\n-        _stop_node(self.nodes[num_node], num_node)\n+        self.log.debug(\"Stopping node %d\" % i)\n+        try:\n+            self.nodes[i].stop()\n+        except http.client.CannotSendRequest as e:\n+            self.log.exception(\"Unable to stop node\")\n+        return_code = self.bitcoind_processes[i].wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n+        assert_equal(return_code, 0)\n+        del self.bitcoind_processes[i]\n \n     def stop_nodes(self):\n-        _stop_nodes(self.nodes)\n+        \"\"\"Stop multiple bitcoind test nodes\"\"\"\n+\n+        for i in range(len(self.nodes)):\n+            self.stop_node(i)\n+        assert not self.bitcoind_processes.values()  # All connections must be gone now\n+\n+    def assert_start_raises_init_error(self, i, dirname, extra_args=None, expected_msg=None):\n+        with tempfile.SpooledTemporaryFile(max_size=2**16) as log_stderr:\n+            try:\n+                self.start_node(i, dirname, extra_args, stderr=log_stderr)\n+                self.stop_node(i)\n+            except Exception as e:\n+                assert 'bitcoind exited' in str(e)  # node must have shutdown\n+                if expected_msg is not None:\n+                    log_stderr.seek(0)\n+                    stderr = log_stderr.read().decode('utf-8')\n+                    if expected_msg not in stderr:\n+                        raise AssertionError(\"Expected error \\\"\" + expected_msg + \"\\\" not found in:\\n\" + stderr)\n+            else:\n+                if expected_msg is None:\n+                    assert_msg = \"bitcoind should have exited with an error\"\n+                else:\n+                    assert_msg = \"bitcoind should have exited with expected error \" + expected_msg\n+                raise AssertionError(assert_msg)\n+\n+    def wait_for_node_exit(self, i, timeout):\n+        self.bitcoind_processes[i].wait(timeout)\n \n     def split_network(self):\n         \"\"\"\n@@ -300,9 +369,9 @@ def _initialize_chain(self, test_dir, num_nodes, cachedir):\n                 args = [os.getenv(\"BITCOIND\", \"bitcoind\"), \"-server\", \"-keypool=1\", \"-datadir=\" + datadir, \"-discover=0\"]\n                 if i > 0:\n                     args.append(\"-connect=127.0.0.1:\" + str(p2p_port(0)))\n-                bitcoind_processes[i] = subprocess.Popen(args)\n+                self.bitcoind_processes[i] = subprocess.Popen(args)\n                 self.log.debug(\"initialize_chain: bitcoind started, waiting for RPC to come up\")\n-                wait_for_bitcoind_start(bitcoind_processes[i], datadir, i)\n+                self._wait_for_bitcoind_start(self.bitcoind_processes[i], datadir, i)\n                 self.log.debug(\"initialize_chain: RPC successfully started\")\n \n             self.nodes = []\n@@ -355,6 +424,30 @@ def _initialize_chain_clean(self, test_dir, num_nodes):\n         for i in range(num_nodes):\n             initialize_datadir(test_dir, i)\n \n+    def _wait_for_bitcoind_start(self, process, datadir, i, rpchost=None):\n+        \"\"\"Wait for bitcoind to start.\n+\n+        This means that RPC is accessible and fully initialized.\n+        Raise an exception if bitcoind exits during initialization.\"\"\"\n+        while True:\n+            if process.poll() is not None:\n+                raise Exception('bitcoind exited with status %i during initialization' % process.returncode)\n+            try:\n+                # Check if .cookie file to be created\n+                rpc = get_rpc_proxy(rpc_url(datadir, i, rpchost), i, coveragedir=self.options.coveragedir)\n+                rpc.getblockcount()\n+                break  # break out of loop on success\n+            except IOError as e:\n+                if e.errno != errno.ECONNREFUSED:  # Port not yet open?\n+                    raise  # unknown IO error\n+            except JSONRPCException as e:  # Initialization phase\n+                if e.error['code'] != -28:  # RPC in warmup?\n+                    raise  # unknown JSON RPC exception\n+            except ValueError as e:  # cookie file not found and no rpcuser or rpcassword. bitcoind still starting\n+                if \"No RPC credentials\" not in str(e):\n+                    raise\n+            time.sleep(0.25)\n+\n class ComparisonTestFramework(BitcoinTestFramework):\n     \"\"\"Test framework for doing p2p comparison testing\n "
      },
      {
        "sha": "fbdb3d7e6daa62e1e9e8171ae0a20457d8f7fe17",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 2,
        "deletions": 131,
        "changes": 133,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cad967a892d836b3afbd1ab81c73731e968368c6/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cad967a892d836b3afbd1ab81c73731e968368c6/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=cad967a892d836b3afbd1ab81c73731e968368c6",
        "patch": "@@ -7,22 +7,16 @@\n from base64 import b64encode\n from binascii import hexlify, unhexlify\n from decimal import Decimal, ROUND_DOWN\n-import errno\n-import http.client\n import json\n import logging\n import os\n import random\n import re\n-import subprocess\n-import tempfile\n import time\n \n from . import coverage\n from .authproxy import AuthServiceProxy, JSONRPCException\n \n-COVERAGE_DIR = None\n-\n logger = logging.getLogger(\"TestFramework.utils\")\n \n # The maximum number of nodes a single test can spawn\n@@ -32,9 +26,6 @@\n # The number of ports to \"reserve\" for p2p and rpc, each\n PORT_RANGE = 5000\n \n-BITCOIND_PROC_WAIT_TIMEOUT = 60\n-\n-\n class PortSeed:\n     # Must be initialized with a unique integer for each process\n     n = None\n@@ -60,13 +51,7 @@ def disable_mocktime():\n def get_mocktime():\n     return MOCKTIME\n \n-def enable_coverage(dirname):\n-    \"\"\"Maintain a log of which RPC calls are made during testing.\"\"\"\n-    global COVERAGE_DIR\n-    COVERAGE_DIR = dirname\n-\n-\n-def get_rpc_proxy(url, node_number, timeout=None):\n+def get_rpc_proxy(url, node_number, timeout=None, coveragedir=None):\n     \"\"\"\n     Args:\n         url (str): URL of the RPC server to call\n@@ -87,7 +72,7 @@ def get_rpc_proxy(url, node_number, timeout=None):\n     proxy.url = url  # store URL on proxy for info\n \n     coverage_logfile = coverage.get_filename(\n-        COVERAGE_DIR, node_number) if COVERAGE_DIR else None\n+        coveragedir, node_number) if coveragedir else None\n \n     return coverage.AuthServiceProxyWrapper(proxy, coverage_logfile)\n \n@@ -172,8 +157,6 @@ def sync_mempools(rpc_connections, *, wait=1, timeout=60):\n         timeout -= wait\n     raise AssertionError(\"Mempool sync failed\")\n \n-bitcoind_processes = {}\n-\n def initialize_datadir(dirname, n):\n     datadir = os.path.join(dirname, \"node\" + str(n))\n     if not os.path.isdir(datadir):\n@@ -222,121 +205,9 @@ def rpc_url(datadir, i, rpchost=None):\n             host = rpchost\n     return \"http://%s:%s@%s:%d\" % (rpc_u, rpc_p, host, int(port))\n \n-def wait_for_bitcoind_start(process, datadir, i, rpchost=None):\n-    '''\n-    Wait for bitcoind to start. This means that RPC is accessible and fully initialized.\n-    Raise an exception if bitcoind exits during initialization.\n-    '''\n-    while True:\n-        if process.poll() is not None:\n-            raise Exception('bitcoind exited with status %i during initialization' % process.returncode)\n-        try:\n-            # Check if .cookie file to be created\n-            rpc = get_rpc_proxy(rpc_url(datadir, i, rpchost), i)\n-            rpc.getblockcount()\n-            break  # break out of loop on success\n-        except IOError as e:\n-            if e.errno != errno.ECONNREFUSED:  # Port not yet open?\n-                raise  # unknown IO error\n-        except JSONRPCException as e:  # Initialization phase\n-            if e.error['code'] != -28:  # RPC in warmup?\n-                raise  # unknown JSON RPC exception\n-        except ValueError as e:  # cookie file not found and no rpcuser or rpcassword. bitcoind still starting\n-            if \"No RPC credentials\" not in str(e):\n-                raise\n-        time.sleep(0.25)\n-\n-def wait_for_node_exit(node_index, timeout):\n-    bitcoind_processes[node_index].wait(timeout)\n-\n-def _start_node(i, dirname, extra_args=None, rpchost=None, timewait=None, binary=None, stderr=None):\n-    \"\"\"Start a bitcoind and return RPC connection to it\n-\n-    This function should only be called from within test_framework, not by individual test scripts.\"\"\"\n-\n-    datadir = os.path.join(dirname, \"node\" + str(i))\n-    if binary is None:\n-        binary = os.getenv(\"BITCOIND\", \"bitcoind\")\n-    args = [binary, \"-datadir=\" + datadir, \"-server\", \"-keypool=1\", \"-discover=0\", \"-rest\", \"-logtimemicros\", \"-debug\", \"-debugexclude=libevent\", \"-debugexclude=leveldb\", \"-mocktime=\" + str(get_mocktime()), \"-uacomment=testnode%d\" % i]\n-    if extra_args is not None:\n-        args.extend(extra_args)\n-    bitcoind_processes[i] = subprocess.Popen(args, stderr=stderr)\n-    logger.debug(\"initialize_chain: bitcoind started, waiting for RPC to come up\")\n-    wait_for_bitcoind_start(bitcoind_processes[i], datadir, i, rpchost)\n-    logger.debug(\"initialize_chain: RPC successfully started\")\n-    proxy = get_rpc_proxy(rpc_url(datadir, i, rpchost), i, timeout=timewait)\n-\n-    if COVERAGE_DIR:\n-        coverage.write_all_rpc_commands(COVERAGE_DIR, proxy)\n-\n-    return proxy\n-\n-def assert_start_raises_init_error(i, dirname, extra_args=None, expected_msg=None):\n-    with tempfile.SpooledTemporaryFile(max_size=2**16) as log_stderr:\n-        try:\n-            node = _start_node(i, dirname, extra_args, stderr=log_stderr)\n-            _stop_node(node, i)\n-        except Exception as e:\n-            assert 'bitcoind exited' in str(e)  # node must have shutdown\n-            if expected_msg is not None:\n-                log_stderr.seek(0)\n-                stderr = log_stderr.read().decode('utf-8')\n-                if expected_msg not in stderr:\n-                    raise AssertionError(\"Expected error \\\"\" + expected_msg + \"\\\" not found in:\\n\" + stderr)\n-        else:\n-            if expected_msg is None:\n-                assert_msg = \"bitcoind should have exited with an error\"\n-            else:\n-                assert_msg = \"bitcoind should have exited with expected error \" + expected_msg\n-            raise AssertionError(assert_msg)\n-\n-def _start_nodes(num_nodes, dirname, extra_args=None, rpchost=None, timewait=None, binary=None):\n-    \"\"\"Start multiple bitcoinds, return RPC connections to them\n-\n-    This function should only be called from within test_framework, not by individual test scripts.\"\"\"\n-\n-    if extra_args is None:\n-        extra_args = [None] * num_nodes\n-    if binary is None:\n-        binary = [None] * num_nodes\n-    assert_equal(len(extra_args), num_nodes)\n-    assert_equal(len(binary), num_nodes)\n-    rpcs = []\n-    try:\n-        for i in range(num_nodes):\n-            rpcs.append(_start_node(i, dirname, extra_args[i], rpchost, timewait=timewait, binary=binary[i]))\n-    except:\n-        # If one node failed to start, stop the others\n-        _stop_nodes(rpcs)\n-        raise\n-    return rpcs\n-\n def log_filename(dirname, n_node, logname):\n     return os.path.join(dirname, \"node\" + str(n_node), \"regtest\", logname)\n \n-def _stop_node(node, i):\n-    \"\"\"Stop a bitcoind test node\n-\n-    This function should only be called from within test_framework, not by individual test scripts.\"\"\"\n-\n-    logger.debug(\"Stopping node %d\" % i)\n-    try:\n-        node.stop()\n-    except http.client.CannotSendRequest as e:\n-        logger.exception(\"Unable to stop node\")\n-    return_code = bitcoind_processes[i].wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n-    del bitcoind_processes[i]\n-    assert_equal(return_code, 0)\n-\n-def _stop_nodes(nodes):\n-    \"\"\"Stop multiple bitcoind test nodes\n-\n-    This function should only be called from within test_framework, not by individual test scripts.\"\"\"\n-\n-    for i, node in enumerate(nodes):\n-        _stop_node(node, i)\n-    assert not bitcoind_processes.values()  # All connections must be gone now\n-\n def set_node_times(nodes, t):\n     for node in nodes:\n         node.setmocktime(t)"
      },
      {
        "sha": "569cc46e6cf92cea3c3e3d991673f8710056c825",
        "filename": "test/functional/wallet-dump.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cad967a892d836b3afbd1ab81c73731e968368c6/test/functional/wallet-dump.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cad967a892d836b3afbd1ab81c73731e968368c6/test/functional/wallet-dump.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet-dump.py?ref=cad967a892d836b3afbd1ab81c73731e968368c6",
        "patch": "@@ -7,7 +7,7 @@\n import os\n \n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import (assert_equal, bitcoind_processes)\n+from test_framework.util import assert_equal\n \n \n def read_dump(file_name, addrs, hd_master_addr_old):\n@@ -95,7 +95,7 @@ def run_test (self):\n \n         #encrypt wallet, restart, unlock and dump\n         self.nodes[0].encryptwallet('test')\n-        bitcoind_processes[0].wait()\n+        self.bitcoind_processes[0].wait()\n         self.nodes[0] = self.start_node(0, self.options.tmpdir, self.extra_args[0])\n         self.nodes[0].walletpassphrase('test', 10)\n         # Should be a no-op:"
      },
      {
        "sha": "ba72918fe1564dcf09153c5711ef9e9e8c373fc4",
        "filename": "test/functional/wallet-encryption.py",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cad967a892d836b3afbd1ab81c73731e968368c6/test/functional/wallet-encryption.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cad967a892d836b3afbd1ab81c73731e968368c6/test/functional/wallet-encryption.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet-encryption.py?ref=cad967a892d836b3afbd1ab81c73731e968368c6",
        "patch": "@@ -6,12 +6,10 @@\n \n import time\n \n-from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.test_framework import BitcoinTestFramework, BITCOIND_PROC_WAIT_TIMEOUT\n from test_framework.util import (\n     assert_equal,\n     assert_raises_jsonrpc,\n-    bitcoind_processes,\n-    BITCOIND_PROC_WAIT_TIMEOUT,\n )\n \n class WalletEncryptionTest(BitcoinTestFramework):\n@@ -33,7 +31,7 @@ def run_test(self):\n \n         # Encrypt the wallet\n         self.nodes[0].encryptwallet(passphrase)\n-        bitcoind_processes[0].wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n+        self.bitcoind_processes[0].wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n         self.nodes[0] = self.start_node(0, self.options.tmpdir)\n \n         # Test that the wallet is encrypted"
      },
      {
        "sha": "dfd3dc83c523a47ca59a9700ff2051b2238ed7d9",
        "filename": "test/functional/wallet-hd.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cad967a892d836b3afbd1ab81c73731e968368c6/test/functional/wallet-hd.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cad967a892d836b3afbd1ab81c73731e968368c6/test/functional/wallet-hd.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet-hd.py?ref=cad967a892d836b3afbd1ab81c73731e968368c6",
        "patch": "@@ -8,7 +8,6 @@\n from test_framework.util import (\n     assert_equal,\n     connect_nodes_bi,\n-    assert_start_raises_init_error\n )\n import os\n import shutil\n@@ -27,7 +26,7 @@ def run_test (self):\n \n         # Make sure can't switch off usehd after wallet creation\n         self.stop_node(1)\n-        assert_start_raises_init_error(1, self.options.tmpdir, ['-usehd=0'], 'already existing HD wallet')\n+        self.assert_start_raises_init_error(1, self.options.tmpdir, ['-usehd=0'], 'already existing HD wallet')\n         self.nodes[1] = self.start_node(1, self.options.tmpdir, self.extra_args[1])\n         connect_nodes_bi(self.nodes, 0, 1)\n "
      }
    ]
  },
  {
    "sha": "0d473c539ed0f53168aa3bae8474f214831dec1f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowZDQ3M2M1MzllZDBmNTMxNjhhYTNiYWU4NDc0ZjIxNDgzMWRlYzFm",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-06-07T17:43:03Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-06-29T10:55:23Z"
      },
      "message": "[tests] move mocktime property and functions to BitcoinTestFramework",
      "tree": {
        "sha": "3bb27a7b56a4d8d7cd49297d64dedf524cb8f872",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3bb27a7b56a4d8d7cd49297d64dedf524cb8f872"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0d473c539ed0f53168aa3bae8474f214831dec1f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0d473c539ed0f53168aa3bae8474f214831dec1f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0d473c539ed0f53168aa3bae8474f214831dec1f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0d473c539ed0f53168aa3bae8474f214831dec1f/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cad967a892d836b3afbd1ab81c73731e968368c6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cad967a892d836b3afbd1ab81c73731e968368c6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cad967a892d836b3afbd1ab81c73731e968368c6"
      }
    ],
    "stats": {
      "total": 52,
      "additions": 22,
      "deletions": 30
    },
    "files": [
      {
        "sha": "f75a8e29cc7a0b76e4c38451f2b53b16f1faa210",
        "filename": "test/functional/listtransactions.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0d473c539ed0f53168aa3bae8474f214831dec1f/test/functional/listtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0d473c539ed0f53168aa3bae8474f214831dec1f/test/functional/listtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/listtransactions.py?ref=0d473c539ed0f53168aa3bae8474f214831dec1f",
        "patch": "@@ -23,7 +23,7 @@ def __init__(self):\n \n     def setup_nodes(self):\n         #This test requires mocktime\n-        enable_mocktime()\n+        self.enable_mocktime()\n         self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir)\n \n     def run_test(self):"
      },
      {
        "sha": "19d99c9c9e9750241da3a46c59bebb9f21eae28f",
        "filename": "test/functional/receivedby.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0d473c539ed0f53168aa3bae8474f214831dec1f/test/functional/receivedby.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0d473c539ed0f53168aa3bae8474f214831dec1f/test/functional/receivedby.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/receivedby.py?ref=0d473c539ed0f53168aa3bae8474f214831dec1f",
        "patch": "@@ -31,7 +31,7 @@ def __init__(self):\n \n     def setup_nodes(self):\n         #This test requires mocktime\n-        enable_mocktime()\n+        self.enable_mocktime()\n         self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir)\n \n     def run_test(self):"
      },
      {
        "sha": "00807b022cf924c9cd5fdb83bca10a71ea7eb2ba",
        "filename": "test/functional/test_framework/test_framework.py",
        "status": "modified",
        "additions": 20,
        "deletions": 7,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0d473c539ed0f53168aa3bae8474f214831dec1f/test/functional/test_framework/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0d473c539ed0f53168aa3bae8474f214831dec1f/test/functional/test_framework/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_framework.py?ref=0d473c539ed0f53168aa3bae8474f214831dec1f",
        "patch": "@@ -26,10 +26,7 @@\n     assert_equal,\n     check_json_precision,\n     connect_nodes_bi,\n-    disable_mocktime,\n     disconnect_nodes,\n-    enable_mocktime,\n-    get_mocktime,\n     get_rpc_proxy,\n     initialize_datadir,\n     get_datadir_path,\n@@ -73,6 +70,7 @@ def __init__(self):\n         self.setup_clean_chain = False\n         self.nodes = []\n         self.bitcoind_processes = {}\n+        self.mocktime = 0\n \n     def add_options(self, parser):\n         pass\n@@ -211,7 +209,7 @@ def start_node(self, i, dirname, extra_args=None, rpchost=None, timewait=None, b\n         datadir = os.path.join(dirname, \"node\" + str(i))\n         if binary is None:\n             binary = os.getenv(\"BITCOIND\", \"bitcoind\")\n-        args = [binary, \"-datadir=\" + datadir, \"-server\", \"-keypool=1\", \"-discover=0\", \"-rest\", \"-logtimemicros\", \"-debug\", \"-debugexclude=libevent\", \"-debugexclude=leveldb\", \"-mocktime=\" + str(get_mocktime()), \"-uacomment=testnode%d\" % i]\n+        args = [binary, \"-datadir=\" + datadir, \"-server\", \"-keypool=1\", \"-discover=0\", \"-rest\", \"-logtimemicros\", \"-debug\", \"-debugexclude=libevent\", \"-debugexclude=leveldb\", \"-mocktime=\" + str(self.mocktime), \"-uacomment=testnode%d\" % i]\n         if extra_args is not None:\n             args.extend(extra_args)\n         self.bitcoind_processes[i] = subprocess.Popen(args, stderr=stderr)\n@@ -312,6 +310,21 @@ def sync_all(self, node_groups=None):\n             sync_blocks(group)\n             sync_mempools(group)\n \n+    def enable_mocktime(self):\n+        \"\"\"Enable mocktime for the script.\n+\n+        mocktime may be needed for scripts that use the cached version of the\n+        blockchain.  If the cached version of the blockchain is used without\n+        mocktime then the mempools will not sync due to IBD.\n+\n+        For backwared compatibility of the python scripts with previous\n+        versions of the cache, this helper function sets mocktime to Jan 1,\n+        2014 + (201 * 10 * 60)\"\"\"\n+        self.mocktime = 1388534400 + (201 * 10 * 60)\n+\n+    def disable_mocktime(self):\n+        self.mocktime = 0\n+\n     # Private helper methods. These should not be accessed by the subclass test scripts.\n \n     def _start_logging(self):\n@@ -389,8 +402,8 @@ def _initialize_chain(self, test_dir, num_nodes, cachedir):\n             #\n             # blocks are created with timestamps 10 minutes apart\n             # starting from 2010 minutes in the past\n-            enable_mocktime()\n-            block_time = get_mocktime() - (201 * 10 * 60)\n+            self.enable_mocktime()\n+            block_time = self.mocktime - (201 * 10 * 60)\n             for i in range(2):\n                 for peer in range(4):\n                     for j in range(25):\n@@ -403,7 +416,7 @@ def _initialize_chain(self, test_dir, num_nodes, cachedir):\n             # Shut them down, and clean up cache directories:\n             self.stop_nodes()\n             self.nodes = []\n-            disable_mocktime()\n+            self.disable_mocktime()\n             for i in range(MAX_NODES):\n                 os.remove(log_filename(cachedir, i, \"debug.log\"))\n                 os.remove(log_filename(cachedir, i, \"db.log\"))"
      },
      {
        "sha": "cca1e2b8943797167b9caeaeee390d1f33f53e43",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 0,
        "deletions": 21,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0d473c539ed0f53168aa3bae8474f214831dec1f/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0d473c539ed0f53168aa3bae8474f214831dec1f/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=0d473c539ed0f53168aa3bae8474f214831dec1f",
        "patch": "@@ -30,27 +30,6 @@ class PortSeed:\n     # Must be initialized with a unique integer for each process\n     n = None\n \n-# Set Mocktime default to OFF.\n-# MOCKTIME is only needed for scripts that use the\n-# cached version of the blockchain.  If the cached\n-# version of the blockchain is used without MOCKTIME\n-# then the mempools will not sync due to IBD.\n-MOCKTIME = 0\n-\n-def enable_mocktime():\n-    # For backwared compatibility of the python scripts\n-    # with previous versions of the cache, set MOCKTIME\n-    # to Jan 1, 2014 + (201 * 10 * 60)\n-    global MOCKTIME\n-    MOCKTIME = 1388534400 + (201 * 10 * 60)\n-\n-def disable_mocktime():\n-    global MOCKTIME\n-    MOCKTIME = 0\n-\n-def get_mocktime():\n-    return MOCKTIME\n-\n def get_rpc_proxy(url, node_number, timeout=None, coveragedir=None):\n     \"\"\"\n     Args:"
      }
    ]
  },
  {
    "sha": "05b8c081b435e87b08335e9f9b62a55fa1d48ecc",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNWI4YzA4MWI0MzVlODdiMDgzMzVlOWY5YjYyYTU1ZmExZDQ4ZWNj",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-06-07T17:51:25Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-06-29T10:56:33Z"
      },
      "message": "[tests] reorganize utils.py module (code move only)\n\nThis commit re-organizes the utils.py module into logical sections.",
      "tree": {
        "sha": "1da4d7589eb7eeb95c75f776d6c435891b6ceb71",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1da4d7589eb7eeb95c75f776d6c435891b6ceb71"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/05b8c081b435e87b08335e9f9b62a55fa1d48ecc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/05b8c081b435e87b08335e9f9b62a55fa1d48ecc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/05b8c081b435e87b08335e9f9b62a55fa1d48ecc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/05b8c081b435e87b08335e9f9b62a55fa1d48ecc/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0d473c539ed0f53168aa3bae8474f214831dec1f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0d473c539ed0f53168aa3bae8474f214831dec1f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0d473c539ed0f53168aa3bae8474f214831dec1f"
      }
    ],
    "stats": {
      "total": 417,
      "additions": 217,
      "deletions": 200
    },
    "files": [
      {
        "sha": "8080c8c97239d094a8eb64cda9535b46c1a14b3b",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 217,
        "deletions": 200,
        "changes": 417,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/05b8c081b435e87b08335e9f9b62a55fa1d48ecc/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/05b8c081b435e87b08335e9f9b62a55fa1d48ecc/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=05b8c081b435e87b08335e9f9b62a55fa1d48ecc",
        "patch": "@@ -19,6 +19,147 @@\n \n logger = logging.getLogger(\"TestFramework.utils\")\n \n+# Assert functions\n+##################\n+\n+def assert_fee_amount(fee, tx_size, fee_per_kB):\n+    \"\"\"Assert the fee was in range\"\"\"\n+    target_fee = tx_size * fee_per_kB / 1000\n+    if fee < target_fee:\n+        raise AssertionError(\"Fee of %s BTC too low! (Should be %s BTC)\" % (str(fee), str(target_fee)))\n+    # allow the wallet's estimation to be at most 2 bytes off\n+    if fee > (tx_size + 2) * fee_per_kB / 1000:\n+        raise AssertionError(\"Fee of %s BTC too high! (Should be %s BTC)\" % (str(fee), str(target_fee)))\n+\n+def assert_equal(thing1, thing2, *args):\n+    if thing1 != thing2 or any(thing1 != arg for arg in args):\n+        raise AssertionError(\"not(%s)\" % \" == \".join(str(arg) for arg in (thing1, thing2) + args))\n+\n+def assert_greater_than(thing1, thing2):\n+    if thing1 <= thing2:\n+        raise AssertionError(\"%s <= %s\" % (str(thing1), str(thing2)))\n+\n+def assert_greater_than_or_equal(thing1, thing2):\n+    if thing1 < thing2:\n+        raise AssertionError(\"%s < %s\" % (str(thing1), str(thing2)))\n+\n+def assert_raises(exc, fun, *args, **kwds):\n+    assert_raises_message(exc, None, fun, *args, **kwds)\n+\n+def assert_raises_message(exc, message, fun, *args, **kwds):\n+    try:\n+        fun(*args, **kwds)\n+    except exc as e:\n+        if message is not None and message not in e.error['message']:\n+            raise AssertionError(\"Expected substring not found:\" + e.error['message'])\n+    except Exception as e:\n+        raise AssertionError(\"Unexpected exception raised: \" + type(e).__name__)\n+    else:\n+        raise AssertionError(\"No exception raised\")\n+\n+def assert_raises_jsonrpc(code, message, fun, *args, **kwds):\n+    \"\"\"Run an RPC and verify that a specific JSONRPC exception code and message is raised.\n+\n+    Calls function `fun` with arguments `args` and `kwds`. Catches a JSONRPCException\n+    and verifies that the error code and message are as expected. Throws AssertionError if\n+    no JSONRPCException was returned or if the error code/message are not as expected.\n+\n+    Args:\n+        code (int), optional: the error code returned by the RPC call (defined\n+            in src/rpc/protocol.h). Set to None if checking the error code is not required.\n+        message (string), optional: [a substring of] the error string returned by the\n+            RPC call. Set to None if checking the error string is not required\n+        fun (function): the function to call. This should be the name of an RPC.\n+        args*: positional arguments for the function.\n+        kwds**: named arguments for the function.\n+    \"\"\"\n+    try:\n+        fun(*args, **kwds)\n+    except JSONRPCException as e:\n+        # JSONRPCException was thrown as expected. Check the code and message values are correct.\n+        if (code is not None) and (code != e.error[\"code\"]):\n+            raise AssertionError(\"Unexpected JSONRPC error code %i\" % e.error[\"code\"])\n+        if (message is not None) and (message not in e.error['message']):\n+            raise AssertionError(\"Expected substring not found:\" + e.error['message'])\n+    except Exception as e:\n+        raise AssertionError(\"Unexpected exception raised: \" + type(e).__name__)\n+    else:\n+        raise AssertionError(\"No exception raised\")\n+\n+def assert_is_hex_string(string):\n+    try:\n+        int(string, 16)\n+    except Exception as e:\n+        raise AssertionError(\n+            \"Couldn't interpret %r as hexadecimal; raised: %s\" % (string, e))\n+\n+def assert_is_hash_string(string, length=64):\n+    if not isinstance(string, str):\n+        raise AssertionError(\"Expected a string, got type %r\" % type(string))\n+    elif length and len(string) != length:\n+        raise AssertionError(\n+            \"String of length %d expected; got %d\" % (length, len(string)))\n+    elif not re.match('[abcdef0-9]+$', string):\n+        raise AssertionError(\n+            \"String %r contains invalid characters for a hash.\" % string)\n+\n+def assert_array_result(object_array, to_match, expected, should_not_find=False):\n+    \"\"\"\n+        Pass in array of JSON objects, a dictionary with key/value pairs\n+        to match against, and another dictionary with expected key/value\n+        pairs.\n+        If the should_not_find flag is true, to_match should not be found\n+        in object_array\n+        \"\"\"\n+    if should_not_find:\n+        assert_equal(expected, {})\n+    num_matched = 0\n+    for item in object_array:\n+        all_match = True\n+        for key, value in to_match.items():\n+            if item[key] != value:\n+                all_match = False\n+        if not all_match:\n+            continue\n+        elif should_not_find:\n+            num_matched = num_matched + 1\n+        for key, value in expected.items():\n+            if item[key] != value:\n+                raise AssertionError(\"%s : expected %s=%s\" % (str(item), str(key), str(value)))\n+            num_matched = num_matched + 1\n+    if num_matched == 0 and not should_not_find:\n+        raise AssertionError(\"No objects matched %s\" % (str(to_match)))\n+    if num_matched > 0 and should_not_find:\n+        raise AssertionError(\"Objects were found %s\" % (str(to_match)))\n+\n+# Utility functions\n+###################\n+\n+def check_json_precision():\n+    \"\"\"Make sure json library being used does not lose precision converting BTC values\"\"\"\n+    n = Decimal(\"20000000.00000003\")\n+    satoshis = int(json.loads(json.dumps(float(n))) * 1.0e8)\n+    if satoshis != 2000000000000003:\n+        raise RuntimeError(\"JSON encode/decode loses precision\")\n+\n+def count_bytes(hex_string):\n+    return len(bytearray.fromhex(hex_string))\n+\n+def bytes_to_hex_str(byte_str):\n+    return hexlify(byte_str).decode('ascii')\n+\n+def hex_str_to_bytes(hex_str):\n+    return unhexlify(hex_str.encode('ascii'))\n+\n+def str_to_b64str(string):\n+    return b64encode(string.encode('utf-8')).decode('ascii')\n+\n+def satoshi_round(amount):\n+    return Decimal(amount).quantize(Decimal('0.00000001'), rounding=ROUND_DOWN)\n+\n+# RPC/P2P connection constants and functions\n+############################################\n+\n # The maximum number of nodes a single test can spawn\n MAX_NODES = 8\n # Don't assign rpc or p2p ports lower than this\n@@ -55,86 +196,30 @@ def get_rpc_proxy(url, node_number, timeout=None, coveragedir=None):\n \n     return coverage.AuthServiceProxyWrapper(proxy, coverage_logfile)\n \n-\n def p2p_port(n):\n     assert(n <= MAX_NODES)\n     return PORT_MIN + n + (MAX_NODES * PortSeed.n) % (PORT_RANGE - 1 - MAX_NODES)\n \n def rpc_port(n):\n     return PORT_MIN + PORT_RANGE + n + (MAX_NODES * PortSeed.n) % (PORT_RANGE - 1 - MAX_NODES)\n \n-def check_json_precision():\n-    \"\"\"Make sure json library being used does not lose precision converting BTC values\"\"\"\n-    n = Decimal(\"20000000.00000003\")\n-    satoshis = int(json.loads(json.dumps(float(n))) * 1.0e8)\n-    if satoshis != 2000000000000003:\n-        raise RuntimeError(\"JSON encode/decode loses precision\")\n-\n-def count_bytes(hex_string):\n-    return len(bytearray.fromhex(hex_string))\n-\n-def bytes_to_hex_str(byte_str):\n-    return hexlify(byte_str).decode('ascii')\n-\n-def hex_str_to_bytes(hex_str):\n-    return unhexlify(hex_str.encode('ascii'))\n+def rpc_auth_pair(n):\n+    return 'rpcuser\ud83d\udcbb' + str(n), 'rpcpass\ud83d\udd11' + str(n)\n \n-def str_to_b64str(string):\n-    return b64encode(string.encode('utf-8')).decode('ascii')\n-\n-def sync_blocks(rpc_connections, *, wait=1, timeout=60):\n-    \"\"\"\n-    Wait until everybody has the same tip.\n-\n-    sync_blocks needs to be called with an rpc_connections set that has least\n-    one node already synced to the latest, stable tip, otherwise there's a\n-    chance it might return before all nodes are stably synced.\n-    \"\"\"\n-    # Use getblockcount() instead of waitforblockheight() to determine the\n-    # initial max height because the two RPCs look at different internal global\n-    # variables (chainActive vs latestBlock) and the former gets updated\n-    # earlier.\n-    maxheight = max(x.getblockcount() for x in rpc_connections)\n-    start_time = cur_time = time.time()\n-    while cur_time <= start_time + timeout:\n-        tips = [r.waitforblockheight(maxheight, int(wait * 1000)) for r in rpc_connections]\n-        if all(t[\"height\"] == maxheight for t in tips):\n-            if all(t[\"hash\"] == tips[0][\"hash\"] for t in tips):\n-                return\n-            raise AssertionError(\"Block sync failed, mismatched block hashes:{}\".format(\n-                                 \"\".join(\"\\n  {!r}\".format(tip) for tip in tips)))\n-        cur_time = time.time()\n-    raise AssertionError(\"Block sync to height {} timed out:{}\".format(\n-                         maxheight, \"\".join(\"\\n  {!r}\".format(tip) for tip in tips)))\n+def rpc_url(datadir, i, rpchost=None):\n+    rpc_u, rpc_p = get_auth_cookie(datadir, i)\n+    host = '127.0.0.1'\n+    port = rpc_port(i)\n+    if rpchost:\n+        parts = rpchost.split(':')\n+        if len(parts) == 2:\n+            host, port = parts\n+        else:\n+            host = rpchost\n+    return \"http://%s:%s@%s:%d\" % (rpc_u, rpc_p, host, int(port))\n \n-def sync_chain(rpc_connections, *, wait=1, timeout=60):\n-    \"\"\"\n-    Wait until everybody has the same best block\n-    \"\"\"\n-    while timeout > 0:\n-        best_hash = [x.getbestblockhash() for x in rpc_connections]\n-        if best_hash == [best_hash[0]] * len(best_hash):\n-            return\n-        time.sleep(wait)\n-        timeout -= wait\n-    raise AssertionError(\"Chain sync failed: Best block hashes don't match\")\n-\n-def sync_mempools(rpc_connections, *, wait=1, timeout=60):\n-    \"\"\"\n-    Wait until everybody has the same transactions in their memory\n-    pools\n-    \"\"\"\n-    while timeout > 0:\n-        pool = set(rpc_connections[0].getrawmempool())\n-        num_match = 1\n-        for i in range(1, len(rpc_connections)):\n-            if set(rpc_connections[i].getrawmempool()) == pool:\n-                num_match = num_match + 1\n-        if num_match == len(rpc_connections):\n-            return\n-        time.sleep(wait)\n-        timeout -= wait\n-    raise AssertionError(\"Mempool sync failed\")\n+# Node functions\n+################\n \n def initialize_datadir(dirname, n):\n     datadir = os.path.join(dirname, \"node\" + str(n))\n@@ -172,21 +257,13 @@ def get_auth_cookie(datadir, n):\n         raise ValueError(\"No RPC credentials\")\n     return user, password\n \n-def rpc_url(datadir, i, rpchost=None):\n-    rpc_u, rpc_p = get_auth_cookie(datadir, i)\n-    host = '127.0.0.1'\n-    port = rpc_port(i)\n-    if rpchost:\n-        parts = rpchost.split(':')\n-        if len(parts) == 2:\n-            host, port = parts\n-        else:\n-            host = rpchost\n-    return \"http://%s:%s@%s:%d\" % (rpc_u, rpc_p, host, int(port))\n-\n def log_filename(dirname, n_node, logname):\n     return os.path.join(dirname, \"node\" + str(n_node), \"regtest\", logname)\n \n+def get_bip9_status(node, key):\n+    info = node.getblockchaininfo()\n+    return info['bip9_softforks'][key]\n+\n def set_node_times(nodes, t):\n     for node in nodes:\n         node.setmocktime(t)\n@@ -214,6 +291,63 @@ def connect_nodes_bi(nodes, a, b):\n     connect_nodes(nodes[a], b)\n     connect_nodes(nodes[b], a)\n \n+def sync_blocks(rpc_connections, *, wait=1, timeout=60):\n+    \"\"\"\n+    Wait until everybody has the same tip.\n+\n+    sync_blocks needs to be called with an rpc_connections set that has least\n+    one node already synced to the latest, stable tip, otherwise there's a\n+    chance it might return before all nodes are stably synced.\n+    \"\"\"\n+    # Use getblockcount() instead of waitforblockheight() to determine the\n+    # initial max height because the two RPCs look at different internal global\n+    # variables (chainActive vs latestBlock) and the former gets updated\n+    # earlier.\n+    maxheight = max(x.getblockcount() for x in rpc_connections)\n+    start_time = cur_time = time.time()\n+    while cur_time <= start_time + timeout:\n+        tips = [r.waitforblockheight(maxheight, int(wait * 1000)) for r in rpc_connections]\n+        if all(t[\"height\"] == maxheight for t in tips):\n+            if all(t[\"hash\"] == tips[0][\"hash\"] for t in tips):\n+                return\n+            raise AssertionError(\"Block sync failed, mismatched block hashes:{}\".format(\n+                                 \"\".join(\"\\n  {!r}\".format(tip) for tip in tips)))\n+        cur_time = time.time()\n+    raise AssertionError(\"Block sync to height {} timed out:{}\".format(\n+                         maxheight, \"\".join(\"\\n  {!r}\".format(tip) for tip in tips)))\n+\n+def sync_chain(rpc_connections, *, wait=1, timeout=60):\n+    \"\"\"\n+    Wait until everybody has the same best block\n+    \"\"\"\n+    while timeout > 0:\n+        best_hash = [x.getbestblockhash() for x in rpc_connections]\n+        if best_hash == [best_hash[0]] * len(best_hash):\n+            return\n+        time.sleep(wait)\n+        timeout -= wait\n+    raise AssertionError(\"Chain sync failed: Best block hashes don't match\")\n+\n+def sync_mempools(rpc_connections, *, wait=1, timeout=60):\n+    \"\"\"\n+    Wait until everybody has the same transactions in their memory\n+    pools\n+    \"\"\"\n+    while timeout > 0:\n+        pool = set(rpc_connections[0].getrawmempool())\n+        num_match = 1\n+        for i in range(1, len(rpc_connections)):\n+            if set(rpc_connections[i].getrawmempool()) == pool:\n+                num_match = num_match + 1\n+        if num_match == len(rpc_connections):\n+            return\n+        time.sleep(wait)\n+        timeout -= wait\n+    raise AssertionError(\"Mempool sync failed\")\n+\n+# Transaction/Block functions\n+#############################\n+\n def find_output(node, txid, amount):\n     \"\"\"\n     Return index to output of txid with value amount\n@@ -278,119 +412,6 @@ def random_transaction(nodes, amount, min_fee, fee_increment, fee_variants):\n \n     return (txid, signresult[\"hex\"], fee)\n \n-def assert_fee_amount(fee, tx_size, fee_per_kB):\n-    \"\"\"Assert the fee was in range\"\"\"\n-    target_fee = tx_size * fee_per_kB / 1000\n-    if fee < target_fee:\n-        raise AssertionError(\"Fee of %s BTC too low! (Should be %s BTC)\" % (str(fee), str(target_fee)))\n-    # allow the wallet's estimation to be at most 2 bytes off\n-    if fee > (tx_size + 2) * fee_per_kB / 1000:\n-        raise AssertionError(\"Fee of %s BTC too high! (Should be %s BTC)\" % (str(fee), str(target_fee)))\n-\n-def assert_equal(thing1, thing2, *args):\n-    if thing1 != thing2 or any(thing1 != arg for arg in args):\n-        raise AssertionError(\"not(%s)\" % \" == \".join(str(arg) for arg in (thing1, thing2) + args))\n-\n-def assert_greater_than(thing1, thing2):\n-    if thing1 <= thing2:\n-        raise AssertionError(\"%s <= %s\" % (str(thing1), str(thing2)))\n-\n-def assert_greater_than_or_equal(thing1, thing2):\n-    if thing1 < thing2:\n-        raise AssertionError(\"%s < %s\" % (str(thing1), str(thing2)))\n-\n-def assert_raises(exc, fun, *args, **kwds):\n-    assert_raises_message(exc, None, fun, *args, **kwds)\n-\n-def assert_raises_message(exc, message, fun, *args, **kwds):\n-    try:\n-        fun(*args, **kwds)\n-    except exc as e:\n-        if message is not None and message not in e.error['message']:\n-            raise AssertionError(\"Expected substring not found:\" + e.error['message'])\n-    except Exception as e:\n-        raise AssertionError(\"Unexpected exception raised: \" + type(e).__name__)\n-    else:\n-        raise AssertionError(\"No exception raised\")\n-\n-def assert_raises_jsonrpc(code, message, fun, *args, **kwds):\n-    \"\"\"Run an RPC and verify that a specific JSONRPC exception code and message is raised.\n-\n-    Calls function `fun` with arguments `args` and `kwds`. Catches a JSONRPCException\n-    and verifies that the error code and message are as expected. Throws AssertionError if\n-    no JSONRPCException was returned or if the error code/message are not as expected.\n-\n-    Args:\n-        code (int), optional: the error code returned by the RPC call (defined\n-            in src/rpc/protocol.h). Set to None if checking the error code is not required.\n-        message (string), optional: [a substring of] the error string returned by the\n-            RPC call. Set to None if checking the error string is not required\n-        fun (function): the function to call. This should be the name of an RPC.\n-        args*: positional arguments for the function.\n-        kwds**: named arguments for the function.\n-    \"\"\"\n-    try:\n-        fun(*args, **kwds)\n-    except JSONRPCException as e:\n-        # JSONRPCException was thrown as expected. Check the code and message values are correct.\n-        if (code is not None) and (code != e.error[\"code\"]):\n-            raise AssertionError(\"Unexpected JSONRPC error code %i\" % e.error[\"code\"])\n-        if (message is not None) and (message not in e.error['message']):\n-            raise AssertionError(\"Expected substring not found:\" + e.error['message'])\n-    except Exception as e:\n-        raise AssertionError(\"Unexpected exception raised: \" + type(e).__name__)\n-    else:\n-        raise AssertionError(\"No exception raised\")\n-\n-def assert_is_hex_string(string):\n-    try:\n-        int(string, 16)\n-    except Exception as e:\n-        raise AssertionError(\n-            \"Couldn't interpret %r as hexadecimal; raised: %s\" % (string, e))\n-\n-def assert_is_hash_string(string, length=64):\n-    if not isinstance(string, str):\n-        raise AssertionError(\"Expected a string, got type %r\" % type(string))\n-    elif length and len(string) != length:\n-        raise AssertionError(\n-            \"String of length %d expected; got %d\" % (length, len(string)))\n-    elif not re.match('[abcdef0-9]+$', string):\n-        raise AssertionError(\n-            \"String %r contains invalid characters for a hash.\" % string)\n-\n-def assert_array_result(object_array, to_match, expected, should_not_find=False):\n-    \"\"\"\n-        Pass in array of JSON objects, a dictionary with key/value pairs\n-        to match against, and another dictionary with expected key/value\n-        pairs.\n-        If the should_not_find flag is true, to_match should not be found\n-        in object_array\n-        \"\"\"\n-    if should_not_find:\n-        assert_equal(expected, {})\n-    num_matched = 0\n-    for item in object_array:\n-        all_match = True\n-        for key, value in to_match.items():\n-            if item[key] != value:\n-                all_match = False\n-        if not all_match:\n-            continue\n-        elif should_not_find:\n-            num_matched = num_matched + 1\n-        for key, value in expected.items():\n-            if item[key] != value:\n-                raise AssertionError(\"%s : expected %s=%s\" % (str(item), str(key), str(value)))\n-            num_matched = num_matched + 1\n-    if num_matched == 0 and not should_not_find:\n-        raise AssertionError(\"No objects matched %s\" % (str(to_match)))\n-    if num_matched > 0 and should_not_find:\n-        raise AssertionError(\"Objects were found %s\" % (str(to_match)))\n-\n-def satoshi_round(amount):\n-    return Decimal(amount).quantize(Decimal('0.00000001'), rounding=ROUND_DOWN)\n-\n # Helper to create at least \"count\" utxos\n # Pass in a fee that is sufficient for relay and mining new transactions.\n def create_confirmed_utxos(fee, node, count):\n@@ -480,7 +501,3 @@ def mine_large_block(node, utxos=None):\n     fee = 100 * node.getnetworkinfo()[\"relayfee\"]\n     create_lots_of_big_transactions(node, txouts, utxos, num, fee=fee)\n     node.generate(1)\n-\n-def get_bip9_status(node, key):\n-    info = node.getblockchaininfo()\n-    return info['bip9_softforks'][key]"
      }
    ]
  },
  {
    "sha": "5ba83c1d434be508064cf039d73f215f0b199c2d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1YmE4M2MxZDQzNGJlNTA4MDY0Y2YwMzlkNzNmMjE1ZjBiMTk5YzJk",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-06-29T14:06:33Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-06-29T14:06:38Z"
      },
      "message": "[tests] fix nits.\n\nThanks to Marco Falke.",
      "tree": {
        "sha": "5e2f5010a38d7db088651eb4cae797c874fa4a76",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5e2f5010a38d7db088651eb4cae797c874fa4a76"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5ba83c1d434be508064cf039d73f215f0b199c2d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5ba83c1d434be508064cf039d73f215f0b199c2d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5ba83c1d434be508064cf039d73f215f0b199c2d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5ba83c1d434be508064cf039d73f215f0b199c2d/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "05b8c081b435e87b08335e9f9b62a55fa1d48ecc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/05b8c081b435e87b08335e9f9b62a55fa1d48ecc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/05b8c081b435e87b08335e9f9b62a55fa1d48ecc"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 1,
      "deletions": 4
    },
    "files": [
      {
        "sha": "8d698a73276a1eb38f4963fb67e4b5d0fb71d6f5",
        "filename": "test/functional/test_framework/test_framework.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5ba83c1d434be508064cf039d73f215f0b199c2d/test/functional/test_framework/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5ba83c1d434be508064cf039d73f215f0b199c2d/test/functional/test_framework/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_framework.py?ref=5ba83c1d434be508064cf039d73f215f0b199c2d",
        "patch": "@@ -255,8 +255,8 @@ def stop_node(self, i):\n         except http.client.CannotSendRequest as e:\n             self.log.exception(\"Unable to stop node\")\n         return_code = self.bitcoind_processes[i].wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n-        assert_equal(return_code, 0)\n         del self.bitcoind_processes[i]\n+        assert_equal(return_code, 0)\n \n     def stop_nodes(self):\n         \"\"\"Stop multiple bitcoind test nodes\"\"\""
      },
      {
        "sha": "3c918b48fbd87554f46397a4d8cb05e39edd02e6",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5ba83c1d434be508064cf039d73f215f0b199c2d/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5ba83c1d434be508064cf039d73f215f0b199c2d/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=5ba83c1d434be508064cf039d73f215f0b199c2d",
        "patch": "@@ -203,9 +203,6 @@ def p2p_port(n):\n def rpc_port(n):\n     return PORT_MIN + PORT_RANGE + n + (MAX_NODES * PortSeed.n) % (PORT_RANGE - 1 - MAX_NODES)\n \n-def rpc_auth_pair(n):\n-    return 'rpcuser\ud83d\udcbb' + str(n), 'rpcpass\ud83d\udd11' + str(n)\n-\n def rpc_url(datadir, i, rpchost=None):\n     rpc_u, rpc_p = get_auth_cookie(datadir, i)\n     host = '127.0.0.1'"
      }
    ]
  }
]