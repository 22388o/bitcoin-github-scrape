[
  {
    "sha": "e8acc6015695c8439fc971a12709468995b96dcf",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplOGFjYzYwMTU2OTVjODQzOWZjOTcxYTEyNzA5NDY4OTk1Yjk2ZGNm",
    "commit": {
      "author": {
        "name": "gzhao408",
        "email": "gzhao408@berkeley.edu",
        "date": "2020-05-10T16:39:30Z"
      },
      "committer": {
        "name": "gzhao408",
        "email": "gzhao408@berkeley.edu",
        "date": "2020-06-10T14:27:58Z"
      },
      "message": "[test] add mempool msg test for node with bloomfilter enabled\n\n-msg_mempool is currently only tested with bloomfilter disabled\n(node is disconnected) in p2p_mempool.py\n-msg_mempool should get mempool txns in response when bloomfilter\nis enabled\n-edit test that doesn't test msg_mempool as intended",
      "tree": {
        "sha": "d8d98eb85d7c2af53552c4f006fe45354bf9db61",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d8d98eb85d7c2af53552c4f006fe45354bf9db61"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e8acc6015695c8439fc971a12709468995b96dcf",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e8acc6015695c8439fc971a12709468995b96dcf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e8acc6015695c8439fc971a12709468995b96dcf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e8acc6015695c8439fc971a12709468995b96dcf/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b3091b2be7d1e5ab86d7380a884d4f23a5e9c9b7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b3091b2be7d1e5ab86d7380a884d4f23a5e9c9b7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b3091b2be7d1e5ab86d7380a884d4f23a5e9c9b7"
      }
    ],
    "stats": {
      "total": 19,
      "additions": 18,
      "deletions": 1
    },
    "files": [
      {
        "sha": "7dc0368ee151f984566ead7f6f75497b2fdf37f3",
        "filename": "test/functional/p2p_filter.py",
        "status": "modified",
        "additions": 18,
        "deletions": 1,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e8acc6015695c8439fc971a12709468995b96dcf/test/functional/p2p_filter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e8acc6015695c8439fc971a12709468995b96dcf/test/functional/p2p_filter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_filter.py?ref=e8acc6015695c8439fc971a12709468995b96dcf",
        "patch": "@@ -16,6 +16,7 @@\n     msg_filterclear,\n     msg_filterload,\n     msg_getdata,\n+    msg_mempool,\n )\n from test_framework.mininode import P2PInterface\n from test_framework.script import MAX_SCRIPT_ELEMENT_SIZE\n@@ -93,6 +94,20 @@ def test_size_limits(self, filter_node):\n \n         filter_node.send_and_ping(msg_filterclear())\n \n+    def test_msg_mempool(self):\n+        self.log.info(\"Check that a node with bloom filters enabled services p2p mempool messages\")\n+        filter_peer = FilterNode()\n+\n+        self.log.info(\"Create a tx relevant to the peer before connecting\")\n+        filter_address = self.nodes[0].decodescript(filter_peer.watch_script_pubkey)['addresses'][0]\n+        txid = self.nodes[0].sendtoaddress(filter_address, 90)\n+\n+        self.log.info(\"Send a mempool msg after connecting and check that the tx is received\")\n+        self.nodes[0].add_p2p_connection(filter_peer)\n+        filter_peer.send_and_ping(filter_peer.watch_filter_init)\n+        self.nodes[0].p2p.send_message(msg_mempool())\n+        filter_peer.wait_for_tx(txid)\n+\n     def run_test(self):\n         filter_node = self.nodes[0].add_p2p_connection(FilterNode())\n \n@@ -123,7 +138,7 @@ def run_test(self):\n         assert not filter_node.merkleblock_received\n         assert not filter_node.tx_received\n \n-        self.log.info('Check that we receive a tx in reply to a mempool msg if the filter matches a mempool tx')\n+        self.log.info('Check that we receive a tx if the filter matches a mempool tx')\n         filter_node.merkleblock_received = False\n         txid = self.nodes[0].sendtoaddress(filter_address, 90)\n         filter_node.wait_for_tx(txid)\n@@ -152,7 +167,9 @@ def run_test(self):\n         self.log.info(\"Check that division-by-zero remote crash bug [CVE-2013-5700] is fixed\")\n         filter_node.send_and_ping(msg_filterload(data=b'', nHashFuncs=1))\n         filter_node.send_and_ping(msg_filteradd(data=b'letstrytocrashthisnode'))\n+        self.nodes[0].disconnect_p2ps()\n \n+        self.test_msg_mempool()\n \n if __name__ == '__main__':\n     FilterTest().main()"
      }
    ]
  },
  {
    "sha": "497a619386008dfaec0db15ecaebcdfaf75f5011",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0OTdhNjE5Mzg2MDA4ZGZhZWMwZGIxNWVjYWViY2RmYWY3NWY1MDEx",
    "commit": {
      "author": {
        "name": "gzhao408",
        "email": "gzhao408@berkeley.edu",
        "date": "2020-05-26T19:28:59Z"
      },
      "committer": {
        "name": "gzhao408",
        "email": "gzhao408@berkeley.edu",
        "date": "2020-06-10T14:28:04Z"
      },
      "message": "[test] add BIP 37 test for node with fRelay=false\n\nA node with fRelay=False should not receive any invs until filter is set using\nfilterload; all other behavior should be identical.",
      "tree": {
        "sha": "5325f839f41fc1515bbc4be9cb17d29628c06493",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5325f839f41fc1515bbc4be9cb17d29628c06493"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/497a619386008dfaec0db15ecaebcdfaf75f5011",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/497a619386008dfaec0db15ecaebcdfaf75f5011",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/497a619386008dfaec0db15ecaebcdfaf75f5011",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/497a619386008dfaec0db15ecaebcdfaf75f5011/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e8acc6015695c8439fc971a12709468995b96dcf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e8acc6015695c8439fc971a12709468995b96dcf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e8acc6015695c8439fc971a12709468995b96dcf"
      }
    ],
    "stats": {
      "total": 42,
      "additions": 38,
      "deletions": 4
    },
    "files": [
      {
        "sha": "fef78a9c404c0317f50d4bcf70f5c6bc1bb00b98",
        "filename": "test/functional/p2p_filter.py",
        "status": "modified",
        "additions": 38,
        "deletions": 4,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/497a619386008dfaec0db15ecaebcdfaf75f5011/test/functional/p2p_filter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/497a619386008dfaec0db15ecaebcdfaf75f5011/test/functional/p2p_filter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_filter.py?ref=497a619386008dfaec0db15ecaebcdfaf75f5011",
        "patch": "@@ -17,6 +17,7 @@\n     msg_filterload,\n     msg_getdata,\n     msg_mempool,\n+    msg_version,\n )\n from test_framework.mininode import P2PInterface\n from test_framework.script import MAX_SCRIPT_ELEMENT_SIZE\n@@ -108,13 +109,23 @@ def test_msg_mempool(self):\n         self.nodes[0].p2p.send_message(msg_mempool())\n         filter_peer.wait_for_tx(txid)\n \n-    def run_test(self):\n-        filter_node = self.nodes[0].add_p2p_connection(FilterNode())\n+    def test_frelay_false(self, filter_peer):\n+        self.log.info(\"Check that a node with fRelay set to false does not receive invs until the filter is set\")\n+        filter_peer.tx_received = False\n+        filter_address = self.nodes[0].decodescript(filter_peer.watch_script_pubkey)['addresses'][0]\n+        self.nodes[0].sendtoaddress(filter_address, 90)\n+        # Sync to make sure the reason filter_peer doesn't receive the tx is not p2p delays\n+        filter_peer.sync_with_ping()\n+        assert not filter_peer.tx_received\n \n-        self.test_size_limits(filter_node)\n+        # Clear the mempool so that this transaction does not impact subsequent tests\n+        self.nodes[0].generate(1)\n \n-        self.log.info('Add filtered P2P connection to the node')\n+    def test_filter(self, filter_node):\n+        # Set the bloomfilter using filterload\n         filter_node.send_and_ping(filter_node.watch_filter_init)\n+        # If fRelay is not already True, sending filterload sets it to True\n+        assert self.nodes[0].getpeerinfo()[0]['relaytxes']\n         filter_address = self.nodes[0].decodescript(filter_node.watch_script_pubkey)['addresses'][0]\n \n         self.log.info('Check that we receive merkleblock and tx if the filter matches a tx in a block')\n@@ -169,6 +180,29 @@ def run_test(self):\n         filter_node.send_and_ping(msg_filteradd(data=b'letstrytocrashthisnode'))\n         self.nodes[0].disconnect_p2ps()\n \n+    def run_test(self):\n+        filter_peer = self.nodes[0].add_p2p_connection(FilterNode())\n+        self.log.info('Test filter size limits')\n+        self.test_size_limits(filter_peer)\n+\n+        self.log.info('Test BIP 37 for a node with fRelay = True (default)')\n+        self.test_filter(filter_peer)\n+        self.nodes[0].disconnect_p2ps()\n+\n+        self.log.info('Test BIP 37 for a node with fRelay = False')\n+        # Add peer but do not send version yet\n+        filter_peer_without_nrelay = self.nodes[0].add_p2p_connection(FilterNode(), send_version=False, wait_for_verack=False)\n+        # Send version with fRelay=False\n+        filter_peer_without_nrelay.wait_until(lambda: filter_peer_without_nrelay.is_connected, timeout=10)\n+        version_without_fRelay = msg_version()\n+        version_without_fRelay.nRelay = 0\n+        filter_peer_without_nrelay.send_message(version_without_fRelay)\n+        filter_peer_without_nrelay.wait_for_verack()\n+        assert not self.nodes[0].getpeerinfo()[0]['relaytxes']\n+        self.test_frelay_false(filter_peer_without_nrelay)\n+        self.test_filter(filter_peer_without_nrelay)\n+\n+        self.log.info('Test msg_mempool')\n         self.test_msg_mempool()\n \n if __name__ == '__main__':"
      }
    ]
  },
  {
    "sha": "4ef80f0827392a1310ca5a29cc1f8f5ca5d16f95",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ZWY4MGYwODI3MzkyYTEzMTBjYTVhMjljYzFmOGY1Y2E1ZDE2Zjk1",
    "commit": {
      "author": {
        "name": "gzhao408",
        "email": "gzhao408@berkeley.edu",
        "date": "2020-05-26T22:35:58Z"
      },
      "committer": {
        "name": "gzhao408",
        "email": "gzhao408@berkeley.edu",
        "date": "2020-06-10T14:28:04Z"
      },
      "message": "[test] sending invalid msgs to node with bloomfilters=0 causes disconnect\n\n-A node with bloomfilters disabled should disconnect peers that send\nmsg_mempool, msg_filterload, or msg_filteradd.\n-Renamed the test because it now has a wider scope and msg_mempool's\nactual functionality makes more sense for p2p_filter.py.",
      "tree": {
        "sha": "5b143722097c765c9f5765be0b57779f16e085c3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5b143722097c765c9f5765be0b57779f16e085c3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4ef80f0827392a1310ca5a29cc1f8f5ca5d16f95",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ef80f0827392a1310ca5a29cc1f8f5ca5d16f95",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4ef80f0827392a1310ca5a29cc1f8f5ca5d16f95",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ef80f0827392a1310ca5a29cc1f8f5ca5d16f95/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "497a619386008dfaec0db15ecaebcdfaf75f5011",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/497a619386008dfaec0db15ecaebcdfaf75f5011",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/497a619386008dfaec0db15ecaebcdfaf75f5011"
      }
    ],
    "stats": {
      "total": 79,
      "additions": 44,
      "deletions": 35
    },
    "files": [
      {
        "sha": "a8fcb181e6adc2631fc28170f7a9944fdff7b8f0",
        "filename": "test/functional/p2p_mempool.py",
        "status": "removed",
        "additions": 0,
        "deletions": 34,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/497a619386008dfaec0db15ecaebcdfaf75f5011/test/functional/p2p_mempool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/497a619386008dfaec0db15ecaebcdfaf75f5011/test/functional/p2p_mempool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_mempool.py?ref=497a619386008dfaec0db15ecaebcdfaf75f5011",
        "patch": "@@ -1,34 +0,0 @@\n-#!/usr/bin/env python3\n-# Copyright (c) 2015-2018 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Test p2p mempool message.\n-\n-Test that nodes are disconnected if they send mempool messages when bloom\n-filters are not enabled.\n-\"\"\"\n-\n-from test_framework.messages import msg_mempool\n-from test_framework.mininode import P2PInterface\n-from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal\n-\n-class P2PMempoolTests(BitcoinTestFramework):\n-    def set_test_params(self):\n-        self.setup_clean_chain = True\n-        self.num_nodes = 1\n-        self.extra_args = [[\"-peerbloomfilters=0\"]]\n-\n-    def run_test(self):\n-        # Add a p2p connection\n-        self.nodes[0].add_p2p_connection(P2PInterface())\n-\n-        #request mempool\n-        self.nodes[0].p2p.send_message(msg_mempool())\n-        self.nodes[0].p2p.wait_for_disconnect()\n-\n-        #mininode must be disconnected at this point\n-        assert_equal(len(self.nodes[0].getpeerinfo()), 0)\n-\n-if __name__ == '__main__':\n-    P2PMempoolTests().main()"
      },
      {
        "sha": "41af74ebb87ede805e798855251f99223ad1f834",
        "filename": "test/functional/p2p_nobloomfilter_messages.py",
        "status": "added",
        "additions": 43,
        "deletions": 0,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4ef80f0827392a1310ca5a29cc1f8f5ca5d16f95/test/functional/p2p_nobloomfilter_messages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4ef80f0827392a1310ca5a29cc1f8f5ca5d16f95/test/functional/p2p_nobloomfilter_messages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_nobloomfilter_messages.py?ref=4ef80f0827392a1310ca5a29cc1f8f5ca5d16f95",
        "patch": "@@ -0,0 +1,43 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2015-2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test invalid p2p messages for nodes with bloom filters disabled.\n+\n+Test that, when bloom filters are not enabled, nodes are disconnected if:\n+1. They send a p2p mempool message\n+2. They send a p2p filterload message\n+3. They send a p2p filteradd message\n+\"\"\"\n+\n+from test_framework.messages import msg_mempool, msg_filteradd, msg_filterload\n+from test_framework.mininode import P2PInterface\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal\n+\n+\n+class P2PNobloomfilterMessages(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\"-peerbloomfilters=0\"]]\n+\n+    def test_message_causes_disconnect(self, message):\n+        # Add a p2p connection that sends a message and check that it disconnects\n+        peer = self.nodes[0].add_p2p_connection(P2PInterface())\n+        peer.send_message(message)\n+        peer.wait_for_disconnect()\n+        assert_equal(len(self.nodes[0].getpeerinfo()), 0)\n+\n+    def run_test(self):\n+        self.log.info(\"Test that node is disconnected if it sends mempool message\")\n+        self.test_message_causes_disconnect(msg_mempool())\n+\n+        self.log.info(\"Test that node is disconnected if it sends filterload message\")\n+        self.test_message_causes_disconnect(msg_filterload())\n+\n+        self.log.info(\"Test that node is disconnected if it sends filteradd message\")\n+        self.test_message_causes_disconnect(msg_filteradd(data=b'\\xcc'))\n+\n+if __name__ == '__main__':\n+    P2PNobloomfilterMessages().main()"
      },
      {
        "sha": "c0bc471d5ade5d2e21d2591d020b38a85f9a05bc",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4ef80f0827392a1310ca5a29cc1f8f5ca5d16f95/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4ef80f0827392a1310ca5a29cc1f8f5ca5d16f95/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=4ef80f0827392a1310ca5a29cc1f8f5ca5d16f95",
        "patch": "@@ -164,7 +164,7 @@\n     'wallet_keypool.py',\n     'wallet_keypool.py --descriptors',\n     'wallet_descriptor.py',\n-    'p2p_mempool.py',\n+    'p2p_nobloomfilter_messages.py',\n     'p2p_filter.py',\n     'rpc_setban.py',\n     'p2p_blocksonly.py',"
      }
    ]
  },
  {
    "sha": "0474ea25afc65546cbfe5f822c0212bf3e211023",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNDc0ZWEyNWFmYzY1NTQ2Y2JmZTVmODIyYzAyMTJiZjNlMjExMDIz",
    "commit": {
      "author": {
        "name": "gzhao408",
        "email": "gzhao408@berkeley.edu",
        "date": "2020-06-05T22:08:03Z"
      },
      "committer": {
        "name": "gzhao408",
        "email": "gzhao408@berkeley.edu",
        "date": "2020-06-10T14:28:04Z"
      },
      "message": "[test] fix race conditions and test in p2p_filter\n\n-grab mininode_lock for every access to mininode attributes,\notherwise there are race conditions",
      "tree": {
        "sha": "e04ddda690e9c99e3b3462cc76e583450f310c84",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e04ddda690e9c99e3b3462cc76e583450f310c84"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0474ea25afc65546cbfe5f822c0212bf3e211023",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0474ea25afc65546cbfe5f822c0212bf3e211023",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0474ea25afc65546cbfe5f822c0212bf3e211023",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0474ea25afc65546cbfe5f822c0212bf3e211023/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4ef80f0827392a1310ca5a29cc1f8f5ca5d16f95",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ef80f0827392a1310ca5a29cc1f8f5ca5d16f95",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4ef80f0827392a1310ca5a29cc1f8f5ca5d16f95"
      }
    ],
    "stats": {
      "total": 31,
      "additions": 28,
      "deletions": 3
    },
    "files": [
      {
        "sha": "a1b3f2f0522023634be082705d18724b9f176c9c",
        "filename": "test/functional/p2p_filter.py",
        "status": "modified",
        "additions": 28,
        "deletions": 3,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0474ea25afc65546cbfe5f822c0212bf3e211023/test/functional/p2p_filter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0474ea25afc65546cbfe5f822c0212bf3e211023/test/functional/p2p_filter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_filter.py?ref=0474ea25afc65546cbfe5f822c0212bf3e211023",
        "patch": "@@ -19,7 +19,7 @@\n     msg_mempool,\n     msg_version,\n )\n-from test_framework.mininode import P2PInterface\n+from test_framework.mininode import P2PInterface, mininode_lock\n from test_framework.script import MAX_SCRIPT_ELEMENT_SIZE\n from test_framework.test_framework import BitcoinTestFramework\n \n@@ -36,6 +36,11 @@ class FilterNode(P2PInterface):\n         nFlags=1,\n     )\n \n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = False\n+        self._merkleblock_received = False\n+\n     def on_inv(self, message):\n         want = msg_getdata()\n         for i in message.inv:\n@@ -48,10 +53,30 @@ def on_inv(self, message):\n             self.send_message(want)\n \n     def on_merkleblock(self, message):\n-        self.merkleblock_received = True\n+        self._merkleblock_received = True\n \n     def on_tx(self, message):\n-        self.tx_received = True\n+        self._tx_received = True\n+\n+    @property\n+    def tx_received(self):\n+        with mininode_lock:\n+            return self._tx_received\n+\n+    @tx_received.setter\n+    def tx_received(self, value):\n+        with mininode_lock:\n+            self._tx_received = value\n+\n+    @property\n+    def merkleblock_received(self):\n+        with mininode_lock:\n+            return self._merkleblock_received\n+\n+    @merkleblock_received.setter\n+    def merkleblock_received(self, value):\n+        with mininode_lock:\n+            self._merkleblock_received = value\n \n \n class FilterTest(BitcoinTestFramework):"
      }
    ]
  },
  {
    "sha": "dca73941eb0f0a4c9b68efed3870b536f7dd6cfe",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkY2E3Mzk0MWViMGYwYTRjOWI2OGVmZWQzODcwYjUzNmY3ZGQ2Y2Zl",
    "commit": {
      "author": {
        "name": "gzhao408",
        "email": "gzhao408@berkeley.edu",
        "date": "2020-06-07T15:59:20Z"
      },
      "committer": {
        "name": "gzhao408",
        "email": "gzhao408@berkeley.edu",
        "date": "2020-06-10T14:28:45Z"
      },
      "message": "scripted-diff: rename node to peer for mininodes\n\n-BEGIN VERIFY SCRIPT-\nsed -i 's/FilterNode/P2PBloomFilter/g' test/functional/p2p_filter.py;\nsed -i 's/filter_node/filter_peer/g' test/functional/p2p_filter.py;\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "627b4230e56343c2458c0fe42c5b712e9afbc2a8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/627b4230e56343c2458c0fe42c5b712e9afbc2a8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dca73941eb0f0a4c9b68efed3870b536f7dd6cfe",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dca73941eb0f0a4c9b68efed3870b536f7dd6cfe",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dca73941eb0f0a4c9b68efed3870b536f7dd6cfe",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dca73941eb0f0a4c9b68efed3870b536f7dd6cfe/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0474ea25afc65546cbfe5f822c0212bf3e211023",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0474ea25afc65546cbfe5f822c0212bf3e211023",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0474ea25afc65546cbfe5f822c0212bf3e211023"
      }
    ],
    "stats": {
      "total": 82,
      "additions": 41,
      "deletions": 41
    },
    "files": [
      {
        "sha": "5726a73e4091c2a267bd66b3e6186c13a71ac4d8",
        "filename": "test/functional/p2p_filter.py",
        "status": "modified",
        "additions": 41,
        "deletions": 41,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dca73941eb0f0a4c9b68efed3870b536f7dd6cfe/test/functional/p2p_filter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dca73941eb0f0a4c9b68efed3870b536f7dd6cfe/test/functional/p2p_filter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_filter.py?ref=dca73941eb0f0a4c9b68efed3870b536f7dd6cfe",
        "patch": "@@ -24,7 +24,7 @@\n from test_framework.test_framework import BitcoinTestFramework\n \n \n-class FilterNode(P2PInterface):\n+class P2PBloomFilter(P2PInterface):\n     # This is a P2SH watch-only wallet\n     watch_script_pubkey = 'a914ffffffffffffffffffffffffffffffffffffffff87'\n     # The initial filter (n=10, fp=0.000001) with just the above scriptPubKey added\n@@ -91,38 +91,38 @@ def set_test_params(self):\n     def skip_test_if_missing_module(self):\n         self.skip_if_no_wallet()\n \n-    def test_size_limits(self, filter_node):\n+    def test_size_limits(self, filter_peer):\n         self.log.info('Check that too large filter is rejected')\n         with self.nodes[0].assert_debug_log(['Misbehaving']):\n-            filter_node.send_and_ping(msg_filterload(data=b'\\xbb'*(MAX_BLOOM_FILTER_SIZE+1)))\n+            filter_peer.send_and_ping(msg_filterload(data=b'\\xbb'*(MAX_BLOOM_FILTER_SIZE+1)))\n \n         self.log.info('Check that max size filter is accepted')\n         with self.nodes[0].assert_debug_log([], unexpected_msgs=['Misbehaving']):\n-            filter_node.send_and_ping(msg_filterload(data=b'\\xbb'*(MAX_BLOOM_FILTER_SIZE)))\n-        filter_node.send_and_ping(msg_filterclear())\n+            filter_peer.send_and_ping(msg_filterload(data=b'\\xbb'*(MAX_BLOOM_FILTER_SIZE)))\n+        filter_peer.send_and_ping(msg_filterclear())\n \n         self.log.info('Check that filter with too many hash functions is rejected')\n         with self.nodes[0].assert_debug_log(['Misbehaving']):\n-            filter_node.send_and_ping(msg_filterload(data=b'\\xaa', nHashFuncs=MAX_BLOOM_HASH_FUNCS+1))\n+            filter_peer.send_and_ping(msg_filterload(data=b'\\xaa', nHashFuncs=MAX_BLOOM_HASH_FUNCS+1))\n \n         self.log.info('Check that filter with max hash functions is accepted')\n         with self.nodes[0].assert_debug_log([], unexpected_msgs=['Misbehaving']):\n-            filter_node.send_and_ping(msg_filterload(data=b'\\xaa', nHashFuncs=MAX_BLOOM_HASH_FUNCS))\n+            filter_peer.send_and_ping(msg_filterload(data=b'\\xaa', nHashFuncs=MAX_BLOOM_HASH_FUNCS))\n         # Don't send filterclear until next two filteradd checks are done\n \n         self.log.info('Check that max size data element to add to the filter is accepted')\n         with self.nodes[0].assert_debug_log([], unexpected_msgs=['Misbehaving']):\n-            filter_node.send_and_ping(msg_filteradd(data=b'\\xcc'*(MAX_SCRIPT_ELEMENT_SIZE)))\n+            filter_peer.send_and_ping(msg_filteradd(data=b'\\xcc'*(MAX_SCRIPT_ELEMENT_SIZE)))\n \n         self.log.info('Check that too large data element to add to the filter is rejected')\n         with self.nodes[0].assert_debug_log(['Misbehaving']):\n-            filter_node.send_and_ping(msg_filteradd(data=b'\\xcc'*(MAX_SCRIPT_ELEMENT_SIZE+1)))\n+            filter_peer.send_and_ping(msg_filteradd(data=b'\\xcc'*(MAX_SCRIPT_ELEMENT_SIZE+1)))\n \n-        filter_node.send_and_ping(msg_filterclear())\n+        filter_peer.send_and_ping(msg_filterclear())\n \n     def test_msg_mempool(self):\n         self.log.info(\"Check that a node with bloom filters enabled services p2p mempool messages\")\n-        filter_peer = FilterNode()\n+        filter_peer = P2PBloomFilter()\n \n         self.log.info(\"Create a tx relevant to the peer before connecting\")\n         filter_address = self.nodes[0].decodescript(filter_peer.watch_script_pubkey)['addresses'][0]\n@@ -146,67 +146,67 @@ def test_frelay_false(self, filter_peer):\n         # Clear the mempool so that this transaction does not impact subsequent tests\n         self.nodes[0].generate(1)\n \n-    def test_filter(self, filter_node):\n+    def test_filter(self, filter_peer):\n         # Set the bloomfilter using filterload\n-        filter_node.send_and_ping(filter_node.watch_filter_init)\n+        filter_peer.send_and_ping(filter_peer.watch_filter_init)\n         # If fRelay is not already True, sending filterload sets it to True\n         assert self.nodes[0].getpeerinfo()[0]['relaytxes']\n-        filter_address = self.nodes[0].decodescript(filter_node.watch_script_pubkey)['addresses'][0]\n+        filter_address = self.nodes[0].decodescript(filter_peer.watch_script_pubkey)['addresses'][0]\n \n         self.log.info('Check that we receive merkleblock and tx if the filter matches a tx in a block')\n         block_hash = self.nodes[0].generatetoaddress(1, filter_address)[0]\n         txid = self.nodes[0].getblock(block_hash)['tx'][0]\n-        filter_node.wait_for_merkleblock(block_hash)\n-        filter_node.wait_for_tx(txid)\n+        filter_peer.wait_for_merkleblock(block_hash)\n+        filter_peer.wait_for_tx(txid)\n \n         self.log.info('Check that we only receive a merkleblock if the filter does not match a tx in a block')\n-        filter_node.tx_received = False\n+        filter_peer.tx_received = False\n         block_hash = self.nodes[0].generatetoaddress(1, self.nodes[0].getnewaddress())[0]\n-        filter_node.wait_for_merkleblock(block_hash)\n-        assert not filter_node.tx_received\n+        filter_peer.wait_for_merkleblock(block_hash)\n+        assert not filter_peer.tx_received\n \n         self.log.info('Check that we not receive a tx if the filter does not match a mempool tx')\n-        filter_node.merkleblock_received = False\n-        filter_node.tx_received = False\n+        filter_peer.merkleblock_received = False\n+        filter_peer.tx_received = False\n         self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 90)\n-        filter_node.sync_with_ping()\n-        filter_node.sync_with_ping()\n-        assert not filter_node.merkleblock_received\n-        assert not filter_node.tx_received\n+        filter_peer.sync_with_ping()\n+        filter_peer.sync_with_ping()\n+        assert not filter_peer.merkleblock_received\n+        assert not filter_peer.tx_received\n \n         self.log.info('Check that we receive a tx if the filter matches a mempool tx')\n-        filter_node.merkleblock_received = False\n+        filter_peer.merkleblock_received = False\n         txid = self.nodes[0].sendtoaddress(filter_address, 90)\n-        filter_node.wait_for_tx(txid)\n-        assert not filter_node.merkleblock_received\n+        filter_peer.wait_for_tx(txid)\n+        assert not filter_peer.merkleblock_received\n \n         self.log.info('Check that after deleting filter all txs get relayed again')\n-        filter_node.send_and_ping(msg_filterclear())\n+        filter_peer.send_and_ping(msg_filterclear())\n         for _ in range(5):\n             txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 7)\n-            filter_node.wait_for_tx(txid)\n+            filter_peer.wait_for_tx(txid)\n \n         self.log.info('Check that request for filtered blocks is ignored if no filter is set')\n-        filter_node.merkleblock_received = False\n-        filter_node.tx_received = False\n+        filter_peer.merkleblock_received = False\n+        filter_peer.tx_received = False\n         with self.nodes[0].assert_debug_log(expected_msgs=['received getdata']):\n             block_hash = self.nodes[0].generatetoaddress(1, self.nodes[0].getnewaddress())[0]\n-            filter_node.wait_for_inv([CInv(MSG_BLOCK, int(block_hash, 16))])\n-            filter_node.sync_with_ping()\n-            assert not filter_node.merkleblock_received\n-            assert not filter_node.tx_received\n+            filter_peer.wait_for_inv([CInv(MSG_BLOCK, int(block_hash, 16))])\n+            filter_peer.sync_with_ping()\n+            assert not filter_peer.merkleblock_received\n+            assert not filter_peer.tx_received\n \n         self.log.info('Check that sending \"filteradd\" if no filter is set is treated as misbehavior')\n         with self.nodes[0].assert_debug_log(['Misbehaving']):\n-            filter_node.send_and_ping(msg_filteradd(data=b'letsmisbehave'))\n+            filter_peer.send_and_ping(msg_filteradd(data=b'letsmisbehave'))\n \n         self.log.info(\"Check that division-by-zero remote crash bug [CVE-2013-5700] is fixed\")\n-        filter_node.send_and_ping(msg_filterload(data=b'', nHashFuncs=1))\n-        filter_node.send_and_ping(msg_filteradd(data=b'letstrytocrashthisnode'))\n+        filter_peer.send_and_ping(msg_filterload(data=b'', nHashFuncs=1))\n+        filter_peer.send_and_ping(msg_filteradd(data=b'letstrytocrashthisnode'))\n         self.nodes[0].disconnect_p2ps()\n \n     def run_test(self):\n-        filter_peer = self.nodes[0].add_p2p_connection(FilterNode())\n+        filter_peer = self.nodes[0].add_p2p_connection(P2PBloomFilter())\n         self.log.info('Test filter size limits')\n         self.test_size_limits(filter_peer)\n \n@@ -216,7 +216,7 @@ def run_test(self):\n \n         self.log.info('Test BIP 37 for a node with fRelay = False')\n         # Add peer but do not send version yet\n-        filter_peer_without_nrelay = self.nodes[0].add_p2p_connection(FilterNode(), send_version=False, wait_for_verack=False)\n+        filter_peer_without_nrelay = self.nodes[0].add_p2p_connection(P2PBloomFilter(), send_version=False, wait_for_verack=False)\n         # Send version with fRelay=False\n         filter_peer_without_nrelay.wait_until(lambda: filter_peer_without_nrelay.is_connected, timeout=10)\n         version_without_fRelay = msg_version()"
      }
    ]
  }
]