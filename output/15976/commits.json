[
  {
    "sha": "d7c97edeea8cee10ad9da1f940d39d5073ac142d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkN2M5N2VkZWVhOGNlZTEwYWQ5ZGExZjk0MGQzOWQ1MDczYWMxNDJk",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-03-27T14:20:41Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-05-16T13:05:07Z"
      },
      "message": "move-only: make the CChainState interface public\n\nalong with DisconnectResult, and CBlockIndexWorkComparator.\n\nThe CChainState interface needs to be known to the rest of the system because\nmany global functions will move to CChainState methods. This is to allow\nother parts of the system to be parameterized per chainstate instance\ninstead of assuming a single global.",
      "tree": {
        "sha": "1f6c2cd718759d3f955a111eef36bfe91e60178e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1f6c2cd718759d3f955a111eef36bfe91e60178e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d7c97edeea8cee10ad9da1f940d39d5073ac142d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d7c97edeea8cee10ad9da1f940d39d5073ac142d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d7c97edeea8cee10ad9da1f940d39d5073ac142d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d7c97edeea8cee10ad9da1f940d39d5073ac142d/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c459c5f70176928adcee4935813a2dbe7f4dbd51",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c459c5f70176928adcee4935813a2dbe7f4dbd51",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c459c5f70176928adcee4935813a2dbe7f4dbd51"
      }
    ],
    "stats": {
      "total": 310,
      "additions": 155,
      "deletions": 155
    },
    "files": [
      {
        "sha": "cc82dfb6cf3a67b82848edc965104fbef7f2d1a5",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 155,
        "changes": 170,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d7c97edeea8cee10ad9da1f940d39d5073ac142d/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d7c97edeea8cee10ad9da1f940d39d5073ac142d/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=d7c97edeea8cee10ad9da1f940d39d5073ac142d",
        "patch": "@@ -60,165 +60,25 @@\n #define MICRO 0.000001\n #define MILLI 0.001\n \n-/**\n- * Global state\n- */\n-namespace {\n-    struct CBlockIndexWorkComparator\n-    {\n-        bool operator()(const CBlockIndex *pa, const CBlockIndex *pb) const {\n-            // First sort by most total work, ...\n-            if (pa->nChainWork > pb->nChainWork) return false;\n-            if (pa->nChainWork < pb->nChainWork) return true;\n-\n-            // ... then by earliest time received, ...\n-            if (pa->nSequenceId < pb->nSequenceId) return false;\n-            if (pa->nSequenceId > pb->nSequenceId) return true;\n-\n-            // Use pointer address as tie breaker (should only happen with blocks\n-            // loaded from disk, as those all have id 0).\n-            if (pa < pb) return false;\n-            if (pa > pb) return true;\n-\n-            // Identical blocks.\n-            return false;\n-        }\n-    };\n-} // anon namespace\n-\n-enum DisconnectResult\n-{\n-    DISCONNECT_OK,      // All good.\n-    DISCONNECT_UNCLEAN, // Rolled back, but UTXO set was inconsistent with block.\n-    DISCONNECT_FAILED   // Something else went wrong.\n-};\n-\n-class ConnectTrace;\n-\n-/**\n- * CChainState stores and provides an API to update our local knowledge of the\n- * current best chain and header tree.\n- *\n- * It generally provides access to the current block tree, as well as functions\n- * to provide new data, which it will appropriately validate and incorporate in\n- * its state as necessary.\n- *\n- * Eventually, the API here is targeted at being exposed externally as a\n- * consumable libconsensus library, so any functions added must only call\n- * other class member functions, pure functions in other parts of the consensus\n- * library, callbacks via the validation interface, or read/write-to-disk\n- * functions (eventually this will also be via callbacks).\n- */\n-class CChainState {\n-private:\n-    /**\n-     * The set of all CBlockIndex entries with BLOCK_VALID_TRANSACTIONS (for itself and all ancestors) and\n-     * as good as our current tip or better. Entries may be failed, though, and pruning nodes may be\n-     * missing the data for the block.\n-     */\n-    std::set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexCandidates;\n-\n-    /**\n-     * Every received block is assigned a unique and increasing identifier, so we\n-     * know which one to give priority in case of a fork.\n-     */\n-    CCriticalSection cs_nBlockSequenceId;\n-    /** Blocks loaded from disk are assigned id 0, so start the counter at 1. */\n-    int32_t nBlockSequenceId = 1;\n-    /** Decreasing counter (used by subsequent preciousblock calls). */\n-    int32_t nBlockReverseSequenceId = -1;\n-    /** chainwork for the last block that preciousblock has been applied to. */\n-    arith_uint256 nLastPreciousChainwork = 0;\n-\n-    /** In order to efficiently track invalidity of headers, we keep the set of\n-      * blocks which we tried to connect and found to be invalid here (ie which\n-      * were set to BLOCK_FAILED_VALID since the last restart). We can then\n-      * walk this set and check if a new header is a descendant of something in\n-      * this set, preventing us from having to walk mapBlockIndex when we try\n-      * to connect a bad block and fail.\n-      *\n-      * While this is more complicated than marking everything which descends\n-      * from an invalid block as invalid at the time we discover it to be\n-      * invalid, doing so would require walking all of mapBlockIndex to find all\n-      * descendants. Since this case should be very rare, keeping track of all\n-      * BLOCK_FAILED_VALID blocks in a set should be just fine and work just as\n-      * well.\n-      *\n-      * Because we already walk mapBlockIndex in height-order at startup, we go\n-      * ahead and mark descendants of invalid blocks as FAILED_CHILD at that time,\n-      * instead of putting things in this set.\n-      */\n-    std::set<CBlockIndex*> m_failed_blocks;\n-\n-    /**\n-     * the ChainState CriticalSection\n-     * A lock that must be held when modifying this ChainState - held in ActivateBestChain()\n-     */\n-    CCriticalSection m_cs_chainstate;\n-\n-public:\n-    //! The current chain of blockheaders we consult and build on.\n-    //! @see CChain, CBlockIndex.\n-    CChain m_chain;\n-    BlockMap mapBlockIndex GUARDED_BY(cs_main);\n-    std::multimap<CBlockIndex*, CBlockIndex*> mapBlocksUnlinked;\n-    CBlockIndex *pindexBestInvalid = nullptr;\n-\n-    bool LoadBlockIndex(const Consensus::Params& consensus_params, CBlockTreeDB& blocktree) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-\n-    bool ActivateBestChain(CValidationState &state, const CChainParams& chainparams, std::shared_ptr<const CBlock> pblock) LOCKS_EXCLUDED(cs_main);\n-\n-    /**\n-     * If a block header hasn't already been seen, call CheckBlockHeader on it, ensure\n-     * that it doesn't descend from an invalid block, and then add it to mapBlockIndex.\n-     */\n-    bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-    bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex, bool fRequested, const FlatFilePos* dbp, bool* fNewBlock) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+bool CBlockIndexWorkComparator::operator()(const CBlockIndex *pa, const CBlockIndex *pb) const {\n+    // First sort by most total work, ...\n+    if (pa->nChainWork > pb->nChainWork) return false;\n+    if (pa->nChainWork < pb->nChainWork) return true;\n \n-    // Block (dis)connection on a given view:\n-    DisconnectResult DisconnectBlock(const CBlock& block, const CBlockIndex* pindex, CCoinsViewCache& view);\n-    bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pindex,\n-                      CCoinsViewCache& view, const CChainParams& chainparams, bool fJustCheck = false) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    // ... then by earliest time received, ...\n+    if (pa->nSequenceId < pb->nSequenceId) return false;\n+    if (pa->nSequenceId > pb->nSequenceId) return true;\n \n-    // Block disconnection on our pcoinsTip:\n-    bool DisconnectTip(CValidationState& state, const CChainParams& chainparams, DisconnectedBlockTransactions* disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    // Use pointer address as tie breaker (should only happen with blocks\n+    // loaded from disk, as those all have id 0).\n+    if (pa < pb) return false;\n+    if (pa > pb) return true;\n \n-    // Manual block validity manipulation:\n-    bool PreciousBlock(CValidationState& state, const CChainParams& params, CBlockIndex* pindex) LOCKS_EXCLUDED(cs_main);\n-    bool InvalidateBlock(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindex) LOCKS_EXCLUDED(cs_main);\n-    void ResetBlockFailureFlags(CBlockIndex* pindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-\n-    bool ReplayBlocks(const CChainParams& params, CCoinsView* view);\n-    bool RewindBlockIndex(const CChainParams& params) LOCKS_EXCLUDED(cs_main);\n-    bool LoadGenesisBlock(const CChainParams& chainparams);\n-\n-    void PruneBlockIndexCandidates();\n-\n-    void UnloadBlockIndex();\n-\n-private:\n-    bool ActivateBestChainStep(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-    bool ConnectTip(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions &disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-\n-    CBlockIndex* AddToBlockIndex(const CBlockHeader& block) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-    /** Create a new block index entry for a given block hash */\n-    CBlockIndex* InsertBlockIndex(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-    /**\n-     * Make various assertions about the state of the block index.\n-     *\n-     * By default this only executes fully when using the Regtest chain; see: fCheckBlockIndex.\n-     */\n-    void CheckBlockIndex(const Consensus::Params& consensusParams);\n-\n-    void InvalidBlockFound(CBlockIndex *pindex, const CValidationState &state) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-    CBlockIndex* FindMostWorkChain() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-    void ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pindexNew, const FlatFilePos& pos, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-\n-    bool RollforwardBlock(const CBlockIndex* pindex, CCoinsViewCache& inputs, const CChainParams& params) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    // Identical blocks.\n+    return false;\n+}\n \n-    //! Mark a block as not having block data\n-    void EraseBlockData(CBlockIndex* index) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-} g_chainstate;\n+CChainState g_chainstate;\n \n CChain& ChainActive() { return g_chainstate.m_chain; }\n "
      },
      {
        "sha": "8114d42d372cadf69a631f7a5c87bf0be8a30586",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 140,
        "deletions": 0,
        "changes": 140,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d7c97edeea8cee10ad9da1f940d39d5073ac142d/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d7c97edeea8cee10ad9da1f940d39d5073ac142d/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=d7c97edeea8cee10ad9da1f940d39d5073ac142d",
        "patch": "@@ -44,6 +44,7 @@ class CTxMemPool;\n class CValidationState;\n struct ChainTxData;\n \n+struct DisconnectedBlockTransactions;\n struct PrecomputedTransactionData;\n struct LockPoints;\n \n@@ -422,6 +423,145 @@ inline CBlockIndex* LookupBlockIndex(const uint256& hash)\n /** Find the last common block between the parameter chain and a locator. */\n CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n+enum DisconnectResult\n+{\n+    DISCONNECT_OK,      // All good.\n+    DISCONNECT_UNCLEAN, // Rolled back, but UTXO set was inconsistent with block.\n+    DISCONNECT_FAILED   // Something else went wrong.\n+};\n+\n+class ConnectTrace;\n+\n+struct CBlockIndexWorkComparator\n+{\n+    bool operator()(const CBlockIndex *pa, const CBlockIndex *pb) const;\n+};\n+\n+/**\n+ * CChainState stores and provides an API to update our local knowledge of the\n+ * current best chain and header tree.\n+ *\n+ * It generally provides access to the current block tree, as well as functions\n+ * to provide new data, which it will appropriately validate and incorporate in\n+ * its state as necessary.\n+ *\n+ * Eventually, the API here is targeted at being exposed externally as a\n+ * consumable libconsensus library, so any functions added must only call\n+ * other class member functions, pure functions in other parts of the consensus\n+ * library, callbacks via the validation interface, or read/write-to-disk\n+ * functions (eventually this will also be via callbacks).\n+ */\n+class CChainState {\n+private:\n+    /**\n+     * The set of all CBlockIndex entries with BLOCK_VALID_TRANSACTIONS (for itself and all ancestors) and\n+     * as good as our current tip or better. Entries may be failed, though, and pruning nodes may be\n+     * missing the data for the block.\n+     */\n+    std::set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexCandidates;\n+\n+    /**\n+     * Every received block is assigned a unique and increasing identifier, so we\n+     * know which one to give priority in case of a fork.\n+     */\n+    CCriticalSection cs_nBlockSequenceId;\n+    /** Blocks loaded from disk are assigned id 0, so start the counter at 1. */\n+    int32_t nBlockSequenceId = 1;\n+    /** Decreasing counter (used by subsequent preciousblock calls). */\n+    int32_t nBlockReverseSequenceId = -1;\n+    /** chainwork for the last block that preciousblock has been applied to. */\n+    arith_uint256 nLastPreciousChainwork = 0;\n+\n+    /** In order to efficiently track invalidity of headers, we keep the set of\n+      * blocks which we tried to connect and found to be invalid here (ie which\n+      * were set to BLOCK_FAILED_VALID since the last restart). We can then\n+      * walk this set and check if a new header is a descendant of something in\n+      * this set, preventing us from having to walk mapBlockIndex when we try\n+      * to connect a bad block and fail.\n+      *\n+      * While this is more complicated than marking everything which descends\n+      * from an invalid block as invalid at the time we discover it to be\n+      * invalid, doing so would require walking all of mapBlockIndex to find all\n+      * descendants. Since this case should be very rare, keeping track of all\n+      * BLOCK_FAILED_VALID blocks in a set should be just fine and work just as\n+      * well.\n+      *\n+      * Because we already walk mapBlockIndex in height-order at startup, we go\n+      * ahead and mark descendants of invalid blocks as FAILED_CHILD at that time,\n+      * instead of putting things in this set.\n+      */\n+    std::set<CBlockIndex*> m_failed_blocks;\n+\n+    /**\n+     * the ChainState CriticalSection\n+     * A lock that must be held when modifying this ChainState - held in ActivateBestChain()\n+     */\n+    CCriticalSection m_cs_chainstate;\n+\n+public:\n+    //! The current chain of blockheaders we consult and build on.\n+    //! @see CChain, CBlockIndex.\n+    CChain m_chain;\n+    BlockMap mapBlockIndex GUARDED_BY(cs_main);\n+    std::multimap<CBlockIndex*, CBlockIndex*> mapBlocksUnlinked;\n+    CBlockIndex *pindexBestInvalid = nullptr;\n+\n+    bool LoadBlockIndex(const Consensus::Params& consensus_params, CBlockTreeDB& blocktree) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    bool ActivateBestChain(CValidationState &state, const CChainParams& chainparams, std::shared_ptr<const CBlock> pblock) LOCKS_EXCLUDED(cs_main);\n+\n+    /**\n+     * If a block header hasn't already been seen, call CheckBlockHeader on it, ensure\n+     * that it doesn't descend from an invalid block, and then add it to mapBlockIndex.\n+     */\n+    bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex, bool fRequested, const FlatFilePos* dbp, bool* fNewBlock) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    // Block (dis)connection on a given view:\n+    DisconnectResult DisconnectBlock(const CBlock& block, const CBlockIndex* pindex, CCoinsViewCache& view);\n+    bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pindex,\n+                      CCoinsViewCache& view, const CChainParams& chainparams, bool fJustCheck = false) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    // Block disconnection on our pcoinsTip:\n+    bool DisconnectTip(CValidationState& state, const CChainParams& chainparams, DisconnectedBlockTransactions* disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    // Manual block validity manipulation:\n+    bool PreciousBlock(CValidationState& state, const CChainParams& params, CBlockIndex* pindex) LOCKS_EXCLUDED(cs_main);\n+    bool InvalidateBlock(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindex) LOCKS_EXCLUDED(cs_main);\n+    void ResetBlockFailureFlags(CBlockIndex* pindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    bool ReplayBlocks(const CChainParams& params, CCoinsView* view);\n+    bool RewindBlockIndex(const CChainParams& params) LOCKS_EXCLUDED(cs_main);\n+    bool LoadGenesisBlock(const CChainParams& chainparams);\n+\n+    void PruneBlockIndexCandidates();\n+\n+    void UnloadBlockIndex();\n+\n+private:\n+    bool ActivateBestChainStep(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool ConnectTip(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions &disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    CBlockIndex* AddToBlockIndex(const CBlockHeader& block) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    /** Create a new block index entry for a given block hash */\n+    CBlockIndex* InsertBlockIndex(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    /**\n+     * Make various assertions about the state of the block index.\n+     *\n+     * By default this only executes fully when using the Regtest chain; see: fCheckBlockIndex.\n+     */\n+    void CheckBlockIndex(const Consensus::Params& consensusParams);\n+\n+    void InvalidBlockFound(CBlockIndex *pindex, const CValidationState &state) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    CBlockIndex* FindMostWorkChain() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    void ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pindexNew, const FlatFilePos& pos, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    bool RollforwardBlock(const CBlockIndex* pindex, CCoinsViewCache& inputs, const CChainParams& params) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    //! Mark a block as not having block data\n+    void EraseBlockData(CBlockIndex* index) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+};\n+\n /** Mark a block as precious and reorganize.\n  *\n  * May not be called in a"
      }
    ]
  },
  {
    "sha": "4d6688603b8c8df854d52df464e157d0a6e7bde6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ZDY2ODg2MDNiOGM4ZGY4NTRkNTJkZjQ2NGUxNTdkMGE2ZTdiZGU2",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-03-27T15:53:31Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-05-16T13:06:54Z"
      },
      "message": "refactoring: introduce ChainstateActive()\n\nTo be used once we move global functions (e.g. FlushStateToDisk()) into\nCChainState methods.\n\nThanks to Marco Falke for suggestions",
      "tree": {
        "sha": "723066ac26b7bb41bfebdf133d0fd092170c3c5d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/723066ac26b7bb41bfebdf133d0fd092170c3c5d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4d6688603b8c8df854d52df464e157d0a6e7bde6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4d6688603b8c8df854d52df464e157d0a6e7bde6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4d6688603b8c8df854d52df464e157d0a6e7bde6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4d6688603b8c8df854d52df464e157d0a6e7bde6/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d7c97edeea8cee10ad9da1f940d39d5073ac142d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d7c97edeea8cee10ad9da1f940d39d5073ac142d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d7c97edeea8cee10ad9da1f940d39d5073ac142d"
      }
    ],
    "stats": {
      "total": 47,
      "additions": 26,
      "deletions": 21
    },
    "files": [
      {
        "sha": "279a7d0e09d5e9f4f4bfc9b8a2222b01109a8118",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 21,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4d6688603b8c8df854d52df464e157d0a6e7bde6/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4d6688603b8c8df854d52df464e157d0a6e7bde6/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=4d6688603b8c8df854d52df464e157d0a6e7bde6",
        "patch": "@@ -80,6 +80,8 @@ bool CBlockIndexWorkComparator::operator()(const CBlockIndex *pa, const CBlockIn\n \n CChainState g_chainstate;\n \n+CChainState& ChainstateActive() { return g_chainstate; }\n+\n CChain& ChainActive() { return g_chainstate.m_chain; }\n \n /**\n@@ -94,7 +96,7 @@ CChain& ChainActive() { return g_chainstate.m_chain; }\n  */\n RecursiveMutex cs_main;\n \n-BlockMap& mapBlockIndex = g_chainstate.mapBlockIndex;\n+BlockMap& mapBlockIndex = ::ChainstateActive().mapBlockIndex;\n CBlockIndex *pindexBestHeader = nullptr;\n Mutex g_best_block_mutex;\n std::condition_variable g_best_block_cv;\n@@ -125,12 +127,12 @@ CScript COINBASE_FLAGS;\n \n // Internal stuff\n namespace {\n-    CBlockIndex *&pindexBestInvalid = g_chainstate.pindexBestInvalid;\n+    CBlockIndex *&pindexBestInvalid = ::ChainstateActive().pindexBestInvalid;\n \n     /** All pairs A->B, where A (or one of its ancestors) misses transactions, but B has transactions.\n      * Pruned nodes may have entries where B is missing data.\n      */\n-    std::multimap<CBlockIndex*, CBlockIndex*>& mapBlocksUnlinked = g_chainstate.mapBlocksUnlinked;\n+    std::multimap<CBlockIndex*, CBlockIndex*>& mapBlocksUnlinked = ::ChainstateActive().mapBlocksUnlinked;\n \n     CCriticalSection cs_LastBlockFile;\n     std::vector<CBlockFileInfo> vinfoBlockFile;\n@@ -2627,7 +2629,7 @@ bool CChainState::ActivateBestChain(CValidationState &state, const CChainParams&\n }\n \n bool ActivateBestChain(CValidationState &state, const CChainParams& chainparams, std::shared_ptr<const CBlock> pblock) {\n-    return g_chainstate.ActivateBestChain(state, chainparams, std::move(pblock));\n+    return ::ChainstateActive().ActivateBestChain(state, chainparams, std::move(pblock));\n }\n \n bool CChainState::PreciousBlock(CValidationState& state, const CChainParams& params, CBlockIndex *pindex)\n@@ -2659,7 +2661,7 @@ bool CChainState::PreciousBlock(CValidationState& state, const CChainParams& par\n     return ActivateBestChain(state, params, std::shared_ptr<const CBlock>());\n }\n bool PreciousBlock(CValidationState& state, const CChainParams& params, CBlockIndex *pindex) {\n-    return g_chainstate.PreciousBlock(state, params, pindex);\n+    return ::ChainstateActive().PreciousBlock(state, params, pindex);\n }\n \n bool CChainState::InvalidateBlock(CValidationState& state, const CChainParams& chainparams, CBlockIndex *pindex)\n@@ -2748,7 +2750,7 @@ bool CChainState::InvalidateBlock(CValidationState& state, const CChainParams& c\n }\n \n bool InvalidateBlock(CValidationState& state, const CChainParams& chainparams, CBlockIndex *pindex) {\n-    return g_chainstate.InvalidateBlock(state, chainparams, pindex);\n+    return ::ChainstateActive().InvalidateBlock(state, chainparams, pindex);\n }\n \n void CChainState::ResetBlockFailureFlags(CBlockIndex *pindex) {\n@@ -2786,7 +2788,7 @@ void CChainState::ResetBlockFailureFlags(CBlockIndex *pindex) {\n }\n \n void ResetBlockFailureFlags(CBlockIndex *pindex) {\n-    return g_chainstate.ResetBlockFailureFlags(pindex);\n+    return ::ChainstateActive().ResetBlockFailureFlags(pindex);\n }\n \n CBlockIndex* CChainState::AddToBlockIndex(const CBlockHeader& block)\n@@ -3324,7 +3326,7 @@ bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& headers, CValidatio\n         LOCK(cs_main);\n         for (const CBlockHeader& header : headers) {\n             CBlockIndex *pindex = nullptr; // Use a temp pindex instead of ppindex to avoid a const_cast\n-            if (!g_chainstate.AcceptBlockHeader(header, state, chainparams, &pindex)) {\n+            if (!::ChainstateActive().AcceptBlockHeader(header, state, chainparams, &pindex)) {\n                 if (first_invalid) *first_invalid = header;\n                 return false;\n             }\n@@ -3455,7 +3457,7 @@ bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<cons\n         bool ret = CheckBlock(*pblock, state, chainparams.GetConsensus());\n         if (ret) {\n             // Store to disk\n-            ret = g_chainstate.AcceptBlock(pblock, state, chainparams, &pindex, fForceProcessing, nullptr, fNewBlock);\n+            ret = ::ChainstateActive().AcceptBlock(pblock, state, chainparams, &pindex, fForceProcessing, nullptr, fNewBlock);\n         }\n         if (!ret) {\n             GetMainSignals().BlockChecked(*pblock, state);\n@@ -3466,7 +3468,7 @@ bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<cons\n     NotifyHeaderTip();\n \n     CValidationState state; // Only used to report errors, not invalidity - ignore it\n-    if (!g_chainstate.ActivateBestChain(state, chainparams, pblock))\n+    if (!::ChainstateActive().ActivateBestChain(state, chainparams, pblock))\n         return error(\"%s: ActivateBestChain failed (%s)\", __func__, FormatStateMessage(state));\n \n     return true;\n@@ -3490,7 +3492,7 @@ bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams,\n         return error(\"%s: Consensus::CheckBlock: %s\", __func__, FormatStateMessage(state));\n     if (!ContextualCheckBlock(block, state, chainparams.GetConsensus(), pindexPrev))\n         return error(\"%s: Consensus::ContextualCheckBlock: %s\", __func__, FormatStateMessage(state));\n-    if (!g_chainstate.ConnectBlock(block, state, &indexDummy, viewNew, chainparams, true))\n+    if (!::ChainstateActive().ConnectBlock(block, state, &indexDummy, viewNew, chainparams, true))\n         return false;\n     assert(state.IsValid());\n \n@@ -3757,7 +3759,7 @@ bool CChainState::LoadBlockIndex(const Consensus::Params& consensus_params, CBlo\n \n bool static LoadBlockIndexDB(const CChainParams& chainparams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    if (!g_chainstate.LoadBlockIndex(chainparams.GetConsensus(), *pblocktree))\n+    if (!::ChainstateActive().LoadBlockIndex(chainparams.GetConsensus(), *pblocktree))\n         return false;\n \n     // Load block file info\n@@ -3832,7 +3834,7 @@ bool LoadChainTip(const CChainParams& chainparams)\n     }\n     ::ChainActive().SetTip(pindex);\n \n-    g_chainstate.PruneBlockIndexCandidates();\n+    ::ChainstateActive().PruneBlockIndexCandidates();\n \n     LogPrintf(\"Loaded best chain: hashBestChain=%s height=%d date=%s progress=%f\\n\",\n         ::ChainActive().Tip()->GetBlockHash().ToString(), ::ChainActive().Height(),\n@@ -3905,7 +3907,7 @@ bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview,\n         // check level 3: check for inconsistencies during memory-only disconnect of tip blocks\n         if (nCheckLevel >= 3 && (coins.DynamicMemoryUsage() + pcoinsTip->DynamicMemoryUsage()) <= nCoinCacheUsage) {\n             assert(coins.GetBestBlock() == pindex->GetBlockHash());\n-            DisconnectResult res = g_chainstate.DisconnectBlock(block, pindex, coins);\n+            DisconnectResult res = ::ChainstateActive().DisconnectBlock(block, pindex, coins);\n             if (res == DISCONNECT_FAILED) {\n                 return error(\"VerifyDB(): *** irrecoverable inconsistency in block data at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n             }\n@@ -3940,7 +3942,7 @@ bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview,\n             CBlock block;\n             if (!ReadBlockFromDisk(block, pindex, chainparams.GetConsensus()))\n                 return error(\"VerifyDB(): *** ReadBlockFromDisk failed at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n-            if (!g_chainstate.ConnectBlock(block, state, pindex, coins, chainparams))\n+            if (!::ChainstateActive().ConnectBlock(block, state, pindex, coins, chainparams))\n                 return error(\"VerifyDB(): *** found unconnectable block at %d, hash=%s (%s)\", pindex->nHeight, pindex->GetBlockHash().ToString(), FormatStateMessage(state));\n         }\n     }\n@@ -4039,7 +4041,7 @@ bool CChainState::ReplayBlocks(const CChainParams& params, CCoinsView* view)\n }\n \n bool ReplayBlocks(const CChainParams& params, CCoinsView* view) {\n-    return g_chainstate.ReplayBlocks(params, view);\n+    return ::ChainstateActive().ReplayBlocks(params, view);\n }\n \n //! Helper for CChainState::RewindBlockIndex\n@@ -4172,7 +4174,7 @@ bool CChainState::RewindBlockIndex(const CChainParams& params)\n }\n \n bool RewindBlockIndex(const CChainParams& params) {\n-    if (!g_chainstate.RewindBlockIndex(params)) {\n+    if (!::ChainstateActive().RewindBlockIndex(params)) {\n         return false;\n     }\n \n@@ -4222,7 +4224,7 @@ void UnloadBlockIndex()\n     mapBlockIndex.clear();\n     fHavePruned = false;\n \n-    g_chainstate.UnloadBlockIndex();\n+    ::ChainstateActive().UnloadBlockIndex();\n }\n \n bool LoadBlockIndex(const CChainParams& chainparams)\n@@ -4274,7 +4276,7 @@ bool CChainState::LoadGenesisBlock(const CChainParams& chainparams)\n \n bool LoadGenesisBlock(const CChainParams& chainparams)\n {\n-    return g_chainstate.LoadGenesisBlock(chainparams);\n+    return ::ChainstateActive().LoadGenesisBlock(chainparams);\n }\n \n bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, FlatFilePos *dbp)\n@@ -4339,7 +4341,7 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, FlatFi\n                     CBlockIndex* pindex = LookupBlockIndex(hash);\n                     if (!pindex || (pindex->nStatus & BLOCK_HAVE_DATA) == 0) {\n                       CValidationState state;\n-                      if (g_chainstate.AcceptBlock(pblock, state, chainparams, nullptr, true, dbp, nullptr)) {\n+                      if (::ChainstateActive().AcceptBlock(pblock, state, chainparams, nullptr, true, dbp, nullptr)) {\n                           nLoaded++;\n                       }\n                       if (state.IsError()) {\n@@ -4376,7 +4378,7 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, FlatFi\n                                     head.ToString());\n                             LOCK(cs_main);\n                             CValidationState dummy;\n-                            if (g_chainstate.AcceptBlock(pblockrecursive, dummy, chainparams, nullptr, true, &it->second, nullptr))\n+                            if (::ChainstateActive().AcceptBlock(pblockrecursive, dummy, chainparams, nullptr, true, &it->second, nullptr))\n                             {\n                                 nLoaded++;\n                                 queue.push_back(pblockrecursive->GetHash());"
      },
      {
        "sha": "34217b3454de8db3721cae0aa512b98c3293b567",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4d6688603b8c8df854d52df464e157d0a6e7bde6/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4d6688603b8c8df854d52df464e157d0a6e7bde6/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=4d6688603b8c8df854d52df464e157d0a6e7bde6",
        "patch": "@@ -575,6 +575,9 @@ bool InvalidateBlock(CValidationState& state, const CChainParams& chainparams, C\n /** Remove invalidity status from a block and its descendants. */\n void ResetBlockFailureFlags(CBlockIndex* pindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n+/** @returns the most-work valid chainstate. */\n+CChainState& ChainstateActive();\n+\n /** @returns the most-work chain. */\n CChain& ChainActive();\n "
      }
    ]
  },
  {
    "sha": "3ccbc376dd313fb7666471f24f6d9370914d00f3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozY2NiYzM3NmRkMzEzZmI3NjY2NDcxZjI0ZjZkOTM3MDkxNGQwMGYz",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-03-27T16:07:52Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-05-16T13:06:54Z"
      },
      "message": "refactoring: FlushStateToDisk -> CChainState\n\nAlso renames global methods for clarity:\n\n- ::FlushStateToDisk() -> CChainState::ForceFlushStateToDisk()\n  - This performs an unconditional flush.\n\n- ::PruneAndFlush() -> CChainState::PruneAndFlush()",
      "tree": {
        "sha": "282912702ec4b1769a97ebc6f2c839525034e601",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/282912702ec4b1769a97ebc6f2c839525034e601"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3ccbc376dd313fb7666471f24f6d9370914d00f3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3ccbc376dd313fb7666471f24f6d9370914d00f3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3ccbc376dd313fb7666471f24f6d9370914d00f3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3ccbc376dd313fb7666471f24f6d9370914d00f3/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4d6688603b8c8df854d52df464e157d0a6e7bde6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4d6688603b8c8df854d52df464e157d0a6e7bde6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4d6688603b8c8df854d52df464e157d0a6e7bde6"
      }
    ],
    "stats": {
      "total": 87,
      "additions": 52,
      "deletions": 35
    },
    "files": [
      {
        "sha": "58cba5b66565308e76bac5271a2357b38871fe16",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3ccbc376dd313fb7666471f24f6d9370914d00f3/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3ccbc376dd313fb7666471f24f6d9370914d00f3/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=3ccbc376dd313fb7666471f24f6d9370914d00f3",
        "patch": "@@ -259,7 +259,7 @@ void Shutdown(InitInterfaces& interfaces)\n \n     // FlushStateToDisk generates a ChainStateFlushed callback, which we should avoid missing\n     if (pcoinsTip != nullptr) {\n-        FlushStateToDisk();\n+        ::ChainstateActive().ForceFlushStateToDisk();\n     }\n \n     // After there are no more peers/RPC left to give us new data which may generate\n@@ -275,7 +275,7 @@ void Shutdown(InitInterfaces& interfaces)\n     {\n         LOCK(cs_main);\n         if (pcoinsTip != nullptr) {\n-            FlushStateToDisk();\n+            ::ChainstateActive().ForceFlushStateToDisk();\n         }\n         pcoinsTip.reset();\n         pcoinscatcher.reset();\n@@ -1692,7 +1692,7 @@ bool AppInitMain(InitInterfaces& interfaces)\n         nLocalServices = ServiceFlags(nLocalServices & ~NODE_NETWORK);\n         if (!fReindex) {\n             uiInterface.InitMessage(_(\"Pruning blockstore...\"));\n-            PruneAndFlush();\n+            ::ChainstateActive().PruneAndFlush();\n         }\n     }\n "
      },
      {
        "sha": "fef51bd7090e5952f620c259d500d91376a0b2fb",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3ccbc376dd313fb7666471f24f6d9370914d00f3/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3ccbc376dd313fb7666471f24f6d9370914d00f3/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=3ccbc376dd313fb7666471f24f6d9370914d00f3",
        "patch": "@@ -1077,7 +1077,7 @@ static UniValue gettxoutsetinfo(const JSONRPCRequest& request)\n     UniValue ret(UniValue::VOBJ);\n \n     CCoinsStats stats;\n-    FlushStateToDisk();\n+    ::ChainstateActive().ForceFlushStateToDisk();\n     if (GetUTXOStats(pcoinsdbview.get(), stats)) {\n         ret.pushKV(\"height\", (int64_t)stats.nHeight);\n         ret.pushKV(\"bestblock\", stats.hashBlock.GetHex());\n@@ -2283,7 +2283,7 @@ UniValue scantxoutset(const JSONRPCRequest& request)\n         std::unique_ptr<CCoinsViewCursor> pcursor;\n         {\n             LOCK(cs_main);\n-            FlushStateToDisk();\n+            ::ChainstateActive().ForceFlushStateToDisk();\n             pcursor = std::unique_ptr<CCoinsViewCursor>(pcoinsdbview->Cursor());\n             assert(pcursor);\n         }"
      },
      {
        "sha": "6087260c6b50f11371d59e9b6052767cf41b9407",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 26,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3ccbc376dd313fb7666471f24f6d9370914d00f3/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3ccbc376dd313fb7666471f24f6d9370914d00f3/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=3ccbc376dd313fb7666471f24f6d9370914d00f3",
        "patch": "@@ -173,15 +173,7 @@ std::unique_ptr<CCoinsViewDB> pcoinsdbview;\n std::unique_ptr<CCoinsViewCache> pcoinsTip;\n std::unique_ptr<CBlockTreeDB> pblocktree;\n \n-enum class FlushStateMode {\n-    NONE,\n-    IF_NEEDED,\n-    PERIODIC,\n-    ALWAYS\n-};\n-\n // See definition for documentation\n-static bool FlushStateToDisk(const CChainParams& chainParams, CValidationState &state, FlushStateMode mode, int nManualPruneHeight=0);\n static void FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nManualPruneHeight);\n static void FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPruneAfterHeight);\n bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks = nullptr);\n@@ -854,7 +846,7 @@ static bool AcceptToMemoryPoolWithTime(const CChainParams& chainparams, CTxMemPo\n     }\n     // After we've (potentially) uncached entries, ensure our coins cache is still within its size limits\n     CValidationState stateDummy;\n-    FlushStateToDisk(chainparams, stateDummy, FlushStateMode::PERIODIC);\n+    ::ChainstateActive().FlushStateToDisk(chainparams, stateDummy, FlushStateMode::PERIODIC);\n     return res;\n }\n \n@@ -1951,16 +1943,12 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n     return true;\n }\n \n-/**\n- * Update the on-disk chain state.\n- * The caches and indexes are flushed depending on the mode we're called with\n- * if they're too large, if it's been a while since the last write,\n- * or always and in all cases if we're in prune mode and are deleting files.\n- *\n- * If FlushStateMode::NONE is used, then FlushStateToDisk(...) won't do anything\n- * besides checking if we need to prune.\n- */\n-bool static FlushStateToDisk(const CChainParams& chainparams, CValidationState &state, FlushStateMode mode, int nManualPruneHeight) {\n+bool CChainState::FlushStateToDisk(\n+    const CChainParams& chainparams,\n+    CValidationState &state,\n+    FlushStateMode mode,\n+    int nManualPruneHeight)\n+{\n     int64_t nMempoolUsage = mempool.DynamicMemoryUsage();\n     LOCK(cs_main);\n     static int64_t nLastWrite = 0;\n@@ -2058,27 +2046,28 @@ bool static FlushStateToDisk(const CChainParams& chainparams, CValidationState &\n     }\n     if (full_flush_completed) {\n         // Update best block in wallet (so we can detect restored wallets).\n-        GetMainSignals().ChainStateFlushed(::ChainActive().GetLocator());\n+        GetMainSignals().ChainStateFlushed(m_chain.GetLocator());\n     }\n     } catch (const std::runtime_error& e) {\n         return AbortNode(state, std::string(\"System error while flushing: \") + e.what());\n     }\n     return true;\n }\n \n-void FlushStateToDisk() {\n+void CChainState::ForceFlushStateToDisk() {\n     CValidationState state;\n     const CChainParams& chainparams = Params();\n-    if (!FlushStateToDisk(chainparams, state, FlushStateMode::ALWAYS)) {\n+    if (!this->FlushStateToDisk(chainparams, state, FlushStateMode::ALWAYS)) {\n         LogPrintf(\"%s: failed to flush state (%s)\\n\", __func__, FormatStateMessage(state));\n     }\n }\n \n-void PruneAndFlush() {\n+void CChainState::PruneAndFlush() {\n     CValidationState state;\n     fCheckForPruning = true;\n     const CChainParams& chainparams = Params();\n-    if (!FlushStateToDisk(chainparams, state, FlushStateMode::NONE)) {\n+\n+    if (!this->FlushStateToDisk(chainparams, state, FlushStateMode::NONE)) {\n         LogPrintf(\"%s: failed to flush state (%s)\\n\", __func__, FormatStateMessage(state));\n     }\n }\n@@ -3587,7 +3576,8 @@ void PruneBlockFilesManual(int nManualPruneHeight)\n {\n     CValidationState state;\n     const CChainParams& chainparams = Params();\n-    if (!FlushStateToDisk(chainparams, state, FlushStateMode::NONE, nManualPruneHeight)) {\n+    if (!::ChainstateActive().FlushStateToDisk(\n+            chainparams, state, FlushStateMode::NONE, nManualPruneHeight)) {\n         LogPrintf(\"%s: failed to flush state (%s)\\n\", __func__, FormatStateMessage(state));\n     }\n }\n@@ -4183,7 +4173,7 @@ bool RewindBlockIndex(const CChainParams& params) {\n         // and skip it here, we're about to -reindex-chainstate anyway, so\n         // it'll get called a bunch real soon.\n         CValidationState state;\n-        if (!FlushStateToDisk(params, state, FlushStateMode::ALWAYS)) {\n+        if (!::ChainstateActive().FlushStateToDisk(params, state, FlushStateMode::ALWAYS)) {\n             LogPrintf(\"RewindBlockIndex: unable to flush state to disk (%s)\\n\", FormatStateMessage(state));\n             return false;\n         }"
      },
      {
        "sha": "3eece8d2b9c191748911438053895bfe279fb0ff",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 31,
        "deletions": 4,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3ccbc376dd313fb7666471f24f6d9370914d00f3/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3ccbc376dd313fb7666471f24f6d9370914d00f3/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=3ccbc376dd313fb7666471f24f6d9370914d00f3",
        "patch": "@@ -31,6 +31,7 @@\n #include <utility>\n #include <vector>\n \n+class CChainState;\n class CBlockIndex;\n class CBlockTreeDB;\n class CBlockUndo;\n@@ -277,10 +278,6 @@ void PruneOneBlockFile(const int fileNumber) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n  */\n void UnlinkPrunedFiles(const std::set<int>& setFilesToPrune);\n \n-/** Flush all state, indexes and buffers to disk. */\n-void FlushStateToDisk();\n-/** Prune block files and flush state to disk. */\n-void PruneAndFlush();\n /** Prune block files up to a given height */\n void PruneBlockFilesManual(int nManualPruneHeight);\n \n@@ -432,6 +429,14 @@ enum DisconnectResult\n \n class ConnectTrace;\n \n+/** @see CChainState::FlushStateToDisk */\n+enum class FlushStateMode {\n+    NONE,\n+    IF_NEEDED,\n+    PERIODIC,\n+    ALWAYS\n+};\n+\n struct CBlockIndexWorkComparator\n {\n     bool operator()(const CBlockIndex *pa, const CBlockIndex *pb) const;\n@@ -508,6 +513,28 @@ class CChainState {\n \n     bool LoadBlockIndex(const Consensus::Params& consensus_params, CBlockTreeDB& blocktree) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n+    /**\n+     * Update the on-disk chain state.\n+     * The caches and indexes are flushed depending on the mode we're called with\n+     * if they're too large, if it's been a while since the last write,\n+     * or always and in all cases if we're in prune mode and are deleting files.\n+     *\n+     * If FlushStateMode::NONE is used, then FlushStateToDisk(...) won't do anything\n+     * besides checking if we need to prune.\n+     */\n+    bool FlushStateToDisk(\n+        const CChainParams& chainparams,\n+        CValidationState &state,\n+        FlushStateMode mode,\n+        int nManualPruneHeight = 0);\n+\n+    //! Unconditionally flush all changes to disk.\n+    void ForceFlushStateToDisk();\n+\n+    //! Prune blockfiles from the disk if necessary and then flush chainstate changes\n+    //! if we pruned.\n+    void PruneAndFlush();\n+\n     bool ActivateBestChain(CValidationState &state, const CChainParams& chainparams, std::shared_ptr<const CBlock> pblock) LOCKS_EXCLUDED(cs_main);\n \n     /**"
      }
    ]
  },
  {
    "sha": "403e677c9ebbf9744733010e6b0c2d1b182ee850",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MDNlNjc3YzllYmJmOTc0NDczMzAxMGU2YjBjMmQxYjE4MmVlODUw",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-03-27T16:21:50Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-05-16T13:06:54Z"
      },
      "message": "refactoring: IsInitialBlockDownload -> CChainState\n\nWe introduce CChainState.m_cached_finished_ibd because the static state it\nreplaces would've been shared across all CChainState instances.",
      "tree": {
        "sha": "3c97f958fc6b15676945d55a82794366d3097fb6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3c97f958fc6b15676945d55a82794366d3097fb6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/403e677c9ebbf9744733010e6b0c2d1b182ee850",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/403e677c9ebbf9744733010e6b0c2d1b182ee850",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/403e677c9ebbf9744733010e6b0c2d1b182ee850",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/403e677c9ebbf9744733010e6b0c2d1b182ee850/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3ccbc376dd313fb7666471f24f6d9370914d00f3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3ccbc376dd313fb7666471f24f6d9370914d00f3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3ccbc376dd313fb7666471f24f6d9370914d00f3"
      }
    ],
    "stats": {
      "total": 70,
      "additions": 41,
      "deletions": 29
    },
    "files": [
      {
        "sha": "bc4be456b146395880d41998caa654c72dbe0c21",
        "filename": "src/interfaces/chain.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/403e677c9ebbf9744733010e6b0c2d1b182ee850/src/interfaces/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/403e677c9ebbf9744733010e6b0c2d1b182ee850/src/interfaces/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.cpp?ref=403e677c9ebbf9744733010e6b0c2d1b182ee850",
        "patch": "@@ -321,8 +321,8 @@ class ChainImpl : public Chain\n     CFeeRate relayDustFee() override { return ::dustRelayFee; }\n     bool getPruneMode() override { return ::fPruneMode; }\n     bool p2pEnabled() override { return g_connman != nullptr; }\n-    bool isReadyToBroadcast() override { return !::fImporting && !::fReindex && !IsInitialBlockDownload(); }\n-    bool isInitialBlockDownload() override { return IsInitialBlockDownload(); }\n+    bool isReadyToBroadcast() override { return !::fImporting && !::fReindex && !isInitialBlockDownload(); }\n+    bool isInitialBlockDownload() override { return ::ChainstateActive().IsInitialBlockDownload(); }\n     bool shutdownRequested() override { return ShutdownRequested(); }\n     int64_t getAdjustedTime() override { return GetAdjustedTime(); }\n     void initMessage(const std::string& message) override { ::uiInterface.InitMessage(message); }"
      },
      {
        "sha": "15646b0ff4ccc25bfcb5adb76ad10c2708857f38",
        "filename": "src/interfaces/node.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/403e677c9ebbf9744733010e6b0c2d1b182ee850/src/interfaces/node.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/403e677c9ebbf9744733010e6b0c2d1b182ee850/src/interfaces/node.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/node.cpp?ref=403e677c9ebbf9744733010e6b0c2d1b182ee850",
        "patch": "@@ -197,7 +197,7 @@ class NodeImpl : public Node\n         }\n         return GuessVerificationProgress(Params().TxData(), tip);\n     }\n-    bool isInitialBlockDownload() override { return IsInitialBlockDownload(); }\n+    bool isInitialBlockDownload() override { return ::ChainstateActive().IsInitialBlockDownload(); }\n     bool getReindex() override { return ::fReindex; }\n     bool getImporting() override { return ::fImporting; }\n     void setNetworkActive(bool active) override"
      },
      {
        "sha": "0a51cad745e3476ff3d51e239bb4f7da3ca4f16c",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/403e677c9ebbf9744733010e6b0c2d1b182ee850/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/403e677c9ebbf9744733010e6b0c2d1b182ee850/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=403e677c9ebbf9744733010e6b0c2d1b182ee850",
        "patch": "@@ -1240,7 +1240,7 @@ void PeerLogicValidation::BlockChecked(const CBlock& block, const CValidationSta\n     //    the tip yet so we have no way to check this directly here. Instead we\n     //    just check that there are currently no other blocks in flight.\n     else if (state.IsValid() &&\n-             !IsInitialBlockDownload() &&\n+             !::ChainstateActive().IsInitialBlockDownload() &&\n              mapBlocksInFlight.count(hash) == mapBlocksInFlight.size()) {\n         if (it != mapBlockSource.end()) {\n             MaybeSetPeerAsAnnouncingHeaderAndIDs(it->second.first, connman);\n@@ -1728,7 +1728,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n         }\n         // If we're in IBD, we want outbound peers that will serve us a useful\n         // chain. Disconnect peers that are on chains with insufficient work.\n-        if (IsInitialBlockDownload() && nCount != MAX_HEADERS_RESULTS) {\n+        if (::ChainstateActive().IsInitialBlockDownload() && nCount != MAX_HEADERS_RESULTS) {\n             // When nCount < MAX_HEADERS_RESULTS, we know we have no more\n             // headers to fetch from this peer.\n             if (nodestate->pindexBestKnownBlock && nodestate->pindexBestKnownBlock->nChainWork < nMinimumChainWork) {\n@@ -1994,7 +1994,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (!pfrom->fInbound)\n         {\n             // Advertise our address\n-            if (fListen && !IsInitialBlockDownload())\n+            if (fListen && !::ChainstateActive().IsInitialBlockDownload())\n             {\n                 CAddress addr = GetLocalAddress(&pfrom->addr, pfrom->GetLocalServices());\n                 FastRandomContext insecure_rand;\n@@ -2229,7 +2229,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 pfrom->AddInventoryKnown(inv);\n                 if (fBlocksOnly) {\n                     LogPrint(BCLog::NET, \"transaction (%s) inv sent in violation of protocol peer=%d\\n\", inv.hash.ToString(), pfrom->GetId());\n-                } else if (!fAlreadyHave && !fImporting && !fReindex && !IsInitialBlockDownload()) {\n+                } else if (!fAlreadyHave && !fImporting && !fReindex && !::ChainstateActive().IsInitialBlockDownload()) {\n                     RequestTx(State(pfrom->GetId()), inv.hash, nNow);\n                 }\n             }\n@@ -2387,7 +2387,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         }\n \n         LOCK(cs_main);\n-        if (IsInitialBlockDownload() && !pfrom->fWhitelisted) {\n+        if (::ChainstateActive().IsInitialBlockDownload() && !pfrom->fWhitelisted) {\n             LogPrint(BCLog::NET, \"Ignoring getheaders from peer=%d because node is in initial block download\\n\", pfrom->GetId());\n             return true;\n         }\n@@ -2609,7 +2609,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         if (!LookupBlockIndex(cmpctblock.header.hashPrevBlock)) {\n             // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n-            if (!IsInitialBlockDownload())\n+            if (!::ChainstateActive().IsInitialBlockDownload())\n                 connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexBestHeader), uint256()));\n             return true;\n         }\n@@ -3525,7 +3525,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n \n         // Address refresh broadcast\n         int64_t nNow = GetTimeMicros();\n-        if (!IsInitialBlockDownload() && pto->nNextLocalAddrSend < nNow) {\n+        if (!::ChainstateActive().IsInitialBlockDownload() && pto->nNextLocalAddrSend < nNow) {\n             AdvertiseLocal(pto);\n             pto->nNextLocalAddrSend = PoissonNextSend(nNow, AVG_LOCAL_ADDRESS_BROADCAST_INTERVAL);\n         }\n@@ -3926,7 +3926,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n         // Message: getdata (blocks)\n         //\n         std::vector<CInv> vGetData;\n-        if (!pto->fClient && ((fFetch && !pto->m_limited_node) || !IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+        if (!pto->fClient && ((fFetch && !pto->m_limited_node) || !::ChainstateActive().IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n             std::vector<const CBlockIndex*> vToDownload;\n             NodeId staller = -1;\n             FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams);"
      },
      {
        "sha": "556fea67ab9136352162de1f5fbddc63c33f3864",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/403e677c9ebbf9744733010e6b0c2d1b182ee850/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/403e677c9ebbf9744733010e6b0c2d1b182ee850/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=403e677c9ebbf9744733010e6b0c2d1b182ee850",
        "patch": "@@ -1342,7 +1342,7 @@ UniValue getblockchaininfo(const JSONRPCRequest& request)\n     obj.pushKV(\"difficulty\",            (double)GetDifficulty(tip));\n     obj.pushKV(\"mediantime\",            (int64_t)tip->GetMedianTimePast());\n     obj.pushKV(\"verificationprogress\",  GuessVerificationProgress(Params().TxData(), tip));\n-    obj.pushKV(\"initialblockdownload\",  IsInitialBlockDownload());\n+    obj.pushKV(\"initialblockdownload\",  ::ChainstateActive().IsInitialBlockDownload());\n     obj.pushKV(\"chainwork\",             tip->nChainWork.GetHex());\n     obj.pushKV(\"size_on_disk\",          CalculateCurrentUsage());\n     obj.pushKV(\"pruned\",                fPruneMode);"
      },
      {
        "sha": "477f05f46c3c0b078c33caedb39d0cc9745e9ead",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/403e677c9ebbf9744733010e6b0c2d1b182ee850/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/403e677c9ebbf9744733010e6b0c2d1b182ee850/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=403e677c9ebbf9744733010e6b0c2d1b182ee850",
        "patch": "@@ -442,7 +442,7 @@ static UniValue getblocktemplate(const JSONRPCRequest& request)\n     if (g_connman->GetNodeCount(CConnman::CONNECTIONS_ALL) == 0)\n         throw JSONRPCError(RPC_CLIENT_NOT_CONNECTED, PACKAGE_NAME \" is not connected!\");\n \n-    if (IsInitialBlockDownload())\n+    if (::ChainstateActive().IsInitialBlockDownload())\n         throw JSONRPCError(RPC_CLIENT_IN_INITIAL_DOWNLOAD, PACKAGE_NAME \" is in initial sync and waiting for blocks...\");\n \n     static unsigned int nTransactionsUpdatedLast;"
      },
      {
        "sha": "ca4a7ab3e6e0fd20460fcffbfa63c962be220d56",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 14,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/403e677c9ebbf9744733010e6b0c2d1b182ee850/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/403e677c9ebbf9744733010e6b0c2d1b182ee850/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=403e677c9ebbf9744733010e6b0c2d1b182ee850",
        "patch": "@@ -321,7 +321,7 @@ static void LimitMempoolSize(CTxMemPool& pool, size_t limit, unsigned long age)\n static bool IsCurrentForFeeEstimation() EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     AssertLockHeld(cs_main);\n-    if (IsInitialBlockDownload())\n+    if (::ChainstateActive().IsInitialBlockDownload())\n         return false;\n     if (::ChainActive().Tip()->GetBlockTime() < (GetTime() - MAX_FEE_ESTIMATION_TIP_AGE))\n         return false;\n@@ -1022,27 +1022,30 @@ CAmount GetBlockSubsidy(int nHeight, const Consensus::Params& consensusParams)\n     return nSubsidy;\n }\n \n-bool IsInitialBlockDownload()\n+// Note that though this is marked const, we may end up modifying `m_cached_finished_ibd`, which\n+// is a performance-related implementation detail. This function must be marked\n+// `const` so that `CValidationInterface` clients (which are given a `const CChainState*`)\n+// can call it.\n+//\n+bool CChainState::IsInitialBlockDownload() const\n {\n-    // Once this function has returned false, it must remain false.\n-    static std::atomic<bool> latchToFalse{false};\n     // Optimization: pre-test latch before taking the lock.\n-    if (latchToFalse.load(std::memory_order_relaxed))\n+    if (m_cached_finished_ibd.load(std::memory_order_relaxed))\n         return false;\n \n     LOCK(cs_main);\n-    if (latchToFalse.load(std::memory_order_relaxed))\n+    if (m_cached_finished_ibd.load(std::memory_order_relaxed))\n         return false;\n     if (fImporting || fReindex)\n         return true;\n-    if (::ChainActive().Tip() == nullptr)\n+    if (m_chain.Tip() == nullptr)\n         return true;\n-    if (::ChainActive().Tip()->nChainWork < nMinimumChainWork)\n+    if (m_chain.Tip()->nChainWork < nMinimumChainWork)\n         return true;\n-    if (::ChainActive().Tip()->GetBlockTime() < (GetTime() - nMaxTipAge))\n+    if (m_chain.Tip()->GetBlockTime() < (GetTime() - nMaxTipAge))\n         return true;\n     LogPrintf(\"Leaving InitialBlockDownload (latching to false)\\n\");\n-    latchToFalse.store(true, std::memory_order_relaxed);\n+    m_cached_finished_ibd.store(true, std::memory_order_relaxed);\n     return false;\n }\n \n@@ -1071,7 +1074,7 @@ static void CheckForkWarningConditions() EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n     AssertLockHeld(cs_main);\n     // Before we get past initial download, we cannot reliably alert about forks\n     // (we assume we don't get stuck on a fork before finishing our initial sync)\n-    if (IsInitialBlockDownload())\n+    if (::ChainstateActive().IsInitialBlockDownload())\n         return;\n \n     // If our best fork is no longer within 72 blocks (+/- 12 hours if no one mines it)\n@@ -2101,7 +2104,7 @@ void static UpdateTip(const CBlockIndex *pindexNew, const CChainParams& chainPar\n     }\n \n     std::string warningMessages;\n-    if (!IsInitialBlockDownload())\n+    if (!::ChainstateActive().IsInitialBlockDownload())\n     {\n         int nUpgraded = 0;\n         const CBlockIndex* pindex = pindexNew;\n@@ -2492,7 +2495,7 @@ static void NotifyHeaderTip() LOCKS_EXCLUDED(cs_main) {\n \n         if (pindexHeader != pindexHeaderOld) {\n             fNotify = true;\n-            fInitialBlockDownload = IsInitialBlockDownload();\n+            fInitialBlockDownload = ::ChainstateActive().IsInitialBlockDownload();\n             pindexHeaderOld = pindexHeader;\n         }\n     }\n@@ -3621,7 +3624,7 @@ static void FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPruneAfte\n         // To avoid excessive prune events negating the benefit of high dbcache\n         // values, we should not prune too rapidly.\n         // So when pruning in IBD, increase the buffer a bit to avoid a re-prune too soon.\n-        if (IsInitialBlockDownload()) {\n+        if (::ChainstateActive().IsInitialBlockDownload()) {\n             // Since this is only relevant during IBD, we use a fixed 10%\n             nBuffer += nPruneTarget / 10;\n         }"
      },
      {
        "sha": "d4c368a99cd93f32bcea388525df1d84c959616b",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 11,
        "deletions": 2,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/403e677c9ebbf9744733010e6b0c2d1b182ee850/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/403e677c9ebbf9744733010e6b0c2d1b182ee850/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=403e677c9ebbf9744733010e6b0c2d1b182ee850",
        "patch": "@@ -249,8 +249,6 @@ bool LoadChainTip(const CChainParams& chainparams) EXCLUSIVE_LOCKS_REQUIRED(cs_m\n void UnloadBlockIndex();\n /** Run an instance of the script checking thread */\n void ThreadScriptCheck(int worker_num);\n-/** Check whether we are doing an initial block download (synchronizing from disk or network) */\n-bool IsInitialBlockDownload();\n /** Retrieve a transaction (from memory pool, or from disk, if possible) */\n bool GetTransaction(const uint256& hash, CTransactionRef& tx, const Consensus::Params& params, uint256& hashBlock, const CBlockIndex* const blockIndex = nullptr);\n /**\n@@ -503,6 +501,14 @@ class CChainState {\n      */\n     CCriticalSection m_cs_chainstate;\n \n+    /**\n+     * Whether this chainstate is undergoing initial block download.\n+     *\n+     * Mutable because we need to be able to mark IsInitialBlockDownload()\n+     * const, which latches this for caching purposes.\n+     */\n+    mutable std::atomic<bool> m_cached_finished_ibd{false};\n+\n public:\n     //! The current chain of blockheaders we consult and build on.\n     //! @see CChain, CBlockIndex.\n@@ -565,6 +571,9 @@ class CChainState {\n \n     void UnloadBlockIndex();\n \n+    /** Check whether we are doing an initial block download (synchronizing from disk or network) */\n+    bool IsInitialBlockDownload() const;\n+\n private:\n     bool ActivateBestChainStep(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     bool ConnectTip(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions &disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main);"
      }
    ]
  }
]