[
  {
    "sha": "157254a4bfdfc4ca3ad5bf2d84e82f290bd0c7f2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxNTcyNTRhNGJmZGZjNGNhM2FkNWJmMmQ4NGU4MmYyOTBiZDBjN2Yy",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2016-09-15T01:00:53Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2016-09-15T16:32:53Z"
      },
      "message": "Fix broken sendcmpct test in p2p-compactblocks.py\n\nPython lambda use was incorrect.\n\nsendcmpct messages need to be synchronized with RPC calls to generate().\n\nHeaders need to be synced (eg with getheaders) for cmpctblock announcements\nto start.\n\nLast test omitted sending a sendcmpct message.",
      "tree": {
        "sha": "c5741f4d8ae94c6fec70637fdcacccdd70a70168",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c5741f4d8ae94c6fec70637fdcacccdd70a70168"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/157254a4bfdfc4ca3ad5bf2d84e82f290bd0c7f2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/157254a4bfdfc4ca3ad5bf2d84e82f290bd0c7f2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/157254a4bfdfc4ca3ad5bf2d84e82f290bd0c7f2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/157254a4bfdfc4ca3ad5bf2d84e82f290bd0c7f2/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a82e5d8220bbc8b5d786bed99b0876f530b9b7cc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a82e5d8220bbc8b5d786bed99b0876f530b9b7cc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a82e5d8220bbc8b5d786bed99b0876f530b9b7cc"
      }
    ],
    "stats": {
      "total": 58,
      "additions": 37,
      "deletions": 21
    },
    "files": [
      {
        "sha": "bf4fb43add3df6bb420e86cc7dcbdf4382d94206",
        "filename": "qa/rpc-tests/p2p-compactblocks.py",
        "status": "modified",
        "additions": 37,
        "deletions": 21,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/157254a4bfdfc4ca3ad5bf2d84e82f290bd0c7f2/qa/rpc-tests/p2p-compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/157254a4bfdfc4ca3ad5bf2d84e82f290bd0c7f2/qa/rpc-tests/p2p-compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-compactblocks.py?ref=157254a4bfdfc4ca3ad5bf2d84e82f290bd0c7f2",
        "patch": "@@ -78,6 +78,13 @@ def send_header_for_blocks(self, new_blocks):\n         headers_message.headers = [CBlockHeader(b) for b in new_blocks]\n         self.send_message(headers_message)\n \n+    def request_headers_and_sync(self, locator, hashstop=0):\n+        self.clear_block_announcement()\n+        self.get_headers(locator, hashstop)\n+        assert(wait_until(self.received_block_announcement, timeout=30))\n+        assert(self.received_block_announcement())\n+        self.clear_block_announcement()\n+\n \n class CompactBlocksTest(BitcoinTestFramework):\n     def __init__(self):\n@@ -130,7 +137,7 @@ def make_utxos(self):\n     # Test \"sendcmpct\":\n     # - No compact block announcements or getdata(MSG_CMPCT_BLOCK) unless\n     #   sendcmpct is sent.\n-    # - If sendcmpct is sent with version > 0, the message is ignored.\n+    # - If sendcmpct is sent with version > 1, the message is ignored.\n     # - If sendcmpct is sent with boolean 0, then block announcements are not\n     #   made with compact blocks.\n     # - If sendcmpct is then sent with boolean 1, then new block announcements\n@@ -142,57 +149,66 @@ def test_sendcmpct(self):\n         def received_sendcmpct():\n             return (self.test_node.last_sendcmpct is not None)\n         got_message = wait_until(received_sendcmpct, timeout=30)\n+        assert(received_sendcmpct())\n         assert(got_message)\n         assert_equal(self.test_node.last_sendcmpct.version, 1)\n \n         tip = int(self.nodes[0].getbestblockhash(), 16)\n \n         def check_announcement_of_new_block(node, peer, predicate):\n-            self.test_node.clear_block_announcement()\n+            peer.clear_block_announcement()\n             node.generate(1)\n-            got_message = wait_until(peer.received_block_announcement, timeout=30)\n+            got_message = wait_until(lambda: peer.block_announced, timeout=30)\n+            assert(peer.block_announced)\n             assert(got_message)\n             with mininode_lock:\n-                assert(predicate)\n+                assert(predicate(peer))\n \n         # We shouldn't get any block announcements via cmpctblock yet.\n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is None)\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is None)\n \n         # Try one more time, this time after requesting headers.\n-        self.test_node.clear_block_announcement()\n-        self.test_node.get_headers(locator=[tip], hashstop=0)\n-        wait_until(self.test_node.received_block_announcement, timeout=30)\n-        self.test_node.clear_block_announcement()\n+        self.test_node.request_headers_and_sync(locator=[tip])\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is None and p.last_inv is not None)\n \n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is None and self.test_node.last_inv is not None)\n+        # Test a few ways of using sendcmpct that should NOT\n+        # result in compact block announcements.\n+        # Before each test, sync the headers chain.\n+        self.test_node.request_headers_and_sync(locator=[tip])\n \n         # Now try a SENDCMPCT message with too-high version\n         sendcmpct = msg_sendcmpct()\n         sendcmpct.version = 2\n-        self.test_node.send_message(sendcmpct)\n+        self.test_node.send_and_ping(sendcmpct)\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is None)\n \n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is None)\n+        # Headers sync before next test.\n+        self.test_node.request_headers_and_sync(locator=[tip])\n \n         # Now try a SENDCMPCT message with valid version, but announce=False\n-        self.test_node.send_message(msg_sendcmpct())\n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is None)\n+        self.test_node.send_and_ping(msg_sendcmpct())\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is None)\n+\n+        # Headers sync before next test.\n+        self.test_node.request_headers_and_sync(locator=[tip])\n \n         # Finally, try a SENDCMPCT message with announce=True\n         sendcmpct.version = 1\n         sendcmpct.announce = True\n-        self.test_node.send_message(sendcmpct)\n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is not None)\n+        self.test_node.send_and_ping(sendcmpct)\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is not None)\n \n-        # Try one more time\n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is not None)\n+        # Try one more time (no headers sync should be needed!)\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is not None)\n \n         # Try one more time, after turning on sendheaders\n-        self.test_node.send_message(msg_sendheaders())\n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is not None)\n+        self.test_node.send_and_ping(msg_sendheaders())\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is not None)\n \n         # Now turn off announcements\n         sendcmpct.announce = False\n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda: self.test_node.last_cmpctblock is None and self.test_node.last_headers is not None)\n+        self.test_node.send_and_ping(sendcmpct)\n+        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is None and p.last_headers is not None)\n \n     # This test actually causes bitcoind to (reasonably!) disconnect us, so do this last.\n     def test_invalid_cmpctblock_message(self):"
      }
    ]
  }
]