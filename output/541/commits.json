[
  {
    "sha": "2499f59a67e25fc38b8b8b65026cda1ca247fab9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNDk5ZjU5YTY3ZTI1ZmMzOGI4YjhiNjUwMjZjZGExY2EyNDdmYWI5",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-09-29T13:46:52Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-09-30T13:20:30Z"
      },
      "message": "Collapse no-op ExtractAddress/ExtractAddressInner",
      "tree": {
        "sha": "98da155241585235c7b5f2dc1a91c29af727f442",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/98da155241585235c7b5f2dc1a91c29af727f442"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2499f59a67e25fc38b8b8b65026cda1ca247fab9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2499f59a67e25fc38b8b8b65026cda1ca247fab9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2499f59a67e25fc38b8b8b65026cda1ca247fab9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2499f59a67e25fc38b8b8b65026cda1ca247fab9/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f4769e44a326f61bdf47fa39346e1293b97e31c4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f4769e44a326f61bdf47fa39346e1293b97e31c4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f4769e44a326f61bdf47fa39346e1293b97e31c4"
      }
    ],
    "stats": {
      "total": 11,
      "additions": 1,
      "deletions": 10
    },
    "files": [
      {
        "sha": "4b2dc9a1a6e3c8f17a2e5e3bb19b74e34291bbf5",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 10,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2499f59a67e25fc38b8b8b65026cda1ca247fab9/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2499f59a67e25fc38b8b8b65026cda1ca247fab9/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=2499f59a67e25fc38b8b8b65026cda1ca247fab9",
        "patch": "@@ -1117,7 +1117,7 @@ bool IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n     return true;\n }\n \n-bool static ExtractAddressInner(const CScript& scriptPubKey, const CKeyStore* keystore, CBitcoinAddress& addressRet)\n+bool ExtractAddress(const CScript& scriptPubKey, const CKeyStore* keystore, CBitcoinAddress& addressRet)\n {\n     vector<pair<opcodetype, valtype> > vSolution;\n     if (!Solver(scriptPubKey, vSolution))\n@@ -1137,15 +1137,6 @@ bool static ExtractAddressInner(const CScript& scriptPubKey, const CKeyStore* ke\n }\n \n \n-bool ExtractAddress(const CScript& scriptPubKey, const CKeyStore* keystore, CBitcoinAddress& addressRet)\n-{\n-    if (keystore)\n-        return ExtractAddressInner(scriptPubKey, keystore, addressRet);\n-    else\n-        return ExtractAddressInner(scriptPubKey, NULL, addressRet);\n-    return false;\n-}\n-\n \n bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, int nHashType)\n {"
      }
    ]
  },
  {
    "sha": "9f461095c58e5511e506ebb21301546ba094041e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZjQ2MTA5NWM1OGU1NTExZTUwNmViYjIxMzAxNTQ2YmEwOTQwNDFl",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-09-28T16:30:06Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-09-30T13:20:59Z"
      },
      "message": "Support 3 new multisignature IsStandard transactions\n\nInitial support for (a and b), (a or b), ((a and b) or c)\ntransactions (where a, b, and c are keys). These will be\nrelayed and included in blocks, but, for this release,\nwill be ignored by the wallet (even if keys a/b/c are\nin the wallet).",
      "tree": {
        "sha": "df1e0cc061b77d22a0aa90d4e1e4a62ffa9bc146",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/df1e0cc061b77d22a0aa90d4e1e4a62ffa9bc146"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9f461095c58e5511e506ebb21301546ba094041e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9f461095c58e5511e506ebb21301546ba094041e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9f461095c58e5511e506ebb21301546ba094041e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9f461095c58e5511e506ebb21301546ba094041e/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2499f59a67e25fc38b8b8b65026cda1ca247fab9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2499f59a67e25fc38b8b8b65026cda1ca247fab9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2499f59a67e25fc38b8b8b65026cda1ca247fab9"
      }
    ],
    "stats": {
      "total": 498,
      "additions": 433,
      "deletions": 65
    },
    "files": [
      {
        "sha": "d7915c66e406981312ecb184be26a758af290946",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 113,
        "deletions": 65,
        "changes": 178,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9f461095c58e5511e506ebb21301546ba094041e/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9f461095c58e5511e506ebb21301546ba094041e/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=9f461095c58e5511e506ebb21301546ba094041e",
        "patch": "@@ -963,8 +963,11 @@ bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CSc\n \n \n \n-\n-bool Solver(const CScript& scriptPubKey, vector<pair<opcodetype, valtype> >& vSolutionRet)\n+//\n+// Returns lists of public keys (or public key hashes), any one of which can\n+// satisfy scriptPubKey\n+//\n+bool Solver(const CScript& scriptPubKey, vector<vector<pair<opcodetype, valtype> > >& vSolutionsRet)\n {\n     // Templates\n     static vector<CScript> vTemplates;\n@@ -975,13 +978,34 @@ bool Solver(const CScript& scriptPubKey, vector<pair<opcodetype, valtype> >& vSo\n \n         // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n         vTemplates.push_back(CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG);\n+\n+        // Sender provides two pubkeys, receivers provides two signatures\n+        vTemplates.push_back(CScript() << OP_PUBKEY << OP_CHECKSIGVERIFY << OP_PUBKEY << OP_CHECKSIG);\n+\n+        // Sender provides two pubkeys, receivers provides one of two signatures\n+        vTemplates.push_back(\n+            CScript() << OP_IF\n+                << OP_PUBKEY << OP_CHECKSIG\n+            << OP_ELSE\n+                << OP_PUBKEY << OP_CHECKSIG\n+            << OP_ENDIF);\n+\n+        // Sender provides three pubkeys, receiver provides 1 or 2 signatures.\n+        vTemplates.push_back(\n+            CScript() << OP_IF\n+                << OP_PUBKEY << OP_CHECKSIG\n+            << OP_ELSE\n+                << OP_PUBKEY << OP_CHECKSIGVERIFY << OP_PUBKEY << OP_CHECKSIG\n+            << OP_ENDIF);\n     }\n \n     // Scan templates\n     const CScript& script1 = scriptPubKey;\n     BOOST_FOREACH(const CScript& script2, vTemplates)\n     {\n-        vSolutionRet.clear();\n+        vSolutionsRet.clear();\n+\n+        vector<pair<opcodetype, valtype> > currentSolution;\n         opcodetype opcode1, opcode2;\n         vector<unsigned char> vch1, vch2;\n \n@@ -993,7 +1017,8 @@ bool Solver(const CScript& scriptPubKey, vector<pair<opcodetype, valtype> >& vSo\n             if (pc1 == script1.end() && pc2 == script2.end())\n             {\n                 // Found a match\n-                reverse(vSolutionRet.begin(), vSolutionRet.end());\n+                reverse(currentSolution.begin(), currentSolution.end());\n+                vSolutionsRet.push_back(currentSolution);\n                 return true;\n             }\n             if (!script1.GetOp(pc1, opcode1, vch1))\n@@ -1004,13 +1029,19 @@ bool Solver(const CScript& scriptPubKey, vector<pair<opcodetype, valtype> >& vSo\n             {\n                 if (vch1.size() < 33 || vch1.size() > 120)\n                     break;\n-                vSolutionRet.push_back(make_pair(opcode2, vch1));\n+                currentSolution.push_back(make_pair(opcode2, vch1));\n             }\n             else if (opcode2 == OP_PUBKEYHASH)\n             {\n                 if (vch1.size() != sizeof(uint160))\n                     break;\n-                vSolutionRet.push_back(make_pair(opcode2, vch1));\n+                currentSolution.push_back(make_pair(opcode2, vch1));\n+            }\n+            else if (opcode2 == OP_ELSE)\n+            {   // ELSE means move to other solution\n+                reverse(currentSolution.begin(), currentSolution.end());\n+                vSolutionsRet.push_back(currentSolution);\n+                currentSolution.clear();\n             }\n             else if (opcode1 != opcode2 || vch1 != vch2)\n             {\n@@ -1019,7 +1050,7 @@ bool Solver(const CScript& scriptPubKey, vector<pair<opcodetype, valtype> >& vSo\n         }\n     }\n \n-    vSolutionRet.clear();\n+    vSolutionsRet.clear();\n     return false;\n }\n \n@@ -1028,111 +1059,128 @@ bool Solver(const CKeyStore& keystore, const CScript& scriptPubKey, uint256 hash\n {\n     scriptSigRet.clear();\n \n-    vector<pair<opcodetype, valtype> > vSolution;\n-    if (!Solver(scriptPubKey, vSolution))\n+    vector<vector<pair<opcodetype, valtype> > > vSolutions;\n+    if (!Solver(scriptPubKey, vSolutions))\n         return false;\n \n-    // Compile solution\n-    BOOST_FOREACH(PAIRTYPE(opcodetype, valtype)& item, vSolution)\n+    // See if we have all the keys for any of the solutions:\n+    int whichSolution = -1;\n+    for (int i = 0; i < vSolutions.size(); i++)\n     {\n-        if (item.first == OP_PUBKEY)\n+        int keysFound = 0;\n+        CScript scriptSig;\n+\n+        BOOST_FOREACH(PAIRTYPE(opcodetype, valtype)& item, vSolutions[i])\n         {\n-            // Sign\n-            const valtype& vchPubKey = item.second;\n-            CKey key;\n-            if (!keystore.GetKey(Hash160(vchPubKey), key))\n-                return false;\n-            if (key.GetPubKey() != vchPubKey)\n-                return false;\n-            if (hash != 0)\n+            if (item.first == OP_PUBKEY)\n             {\n+                const valtype& vchPubKey = item.second;\n+                CKey key;\n                 vector<unsigned char> vchSig;\n-                if (!key.Sign(hash, vchSig))\n-                    return false;\n-                vchSig.push_back((unsigned char)nHashType);\n-                scriptSigRet << vchSig;\n+                if (keystore.GetKey(Hash160(vchPubKey), key) && key.GetPubKey() == vchPubKey\n+                    && hash != 0 && key.Sign(hash, vchSig))\n+                {\n+                    vchSig.push_back((unsigned char)nHashType);\n+                    scriptSig << vchSig;\n+                    ++keysFound;\n+                }\n             }\n-        }\n-        else if (item.first == OP_PUBKEYHASH)\n-        {\n-            // Sign and give pubkey\n-            CKey key;\n-            if (!keystore.GetKey(uint160(item.second), key))\n-                return false;\n-            if (hash != 0)\n+            else if (item.first == OP_PUBKEYHASH)\n             {\n+                CKey key;\n                 vector<unsigned char> vchSig;\n-                if (!key.Sign(hash, vchSig))\n-                    return false;\n-                vchSig.push_back((unsigned char)nHashType);\n-                scriptSigRet << vchSig << key.GetPubKey();\n+                if (keystore.GetKey(uint160(item.second), key) \n+                    && hash != 0 && key.Sign(hash, vchSig))\n+                {\n+                    vchSig.push_back((unsigned char)nHashType);\n+                    scriptSig << vchSig << key.GetPubKey();\n+                    ++keysFound;\n+                }\n             }\n         }\n-        else\n+        if (keysFound == vSolutions[i].size())\n         {\n-            return false;\n+            whichSolution = i;\n+            scriptSigRet = scriptSig;\n+            break;\n         }\n     }\n+    if (whichSolution == -1)\n+        return false;\n+\n+    if (vSolutions.size() == 2)\n+        scriptSigRet << (whichSolution == 0 ? OP_1 : OP_0);\n \n     return true;\n }\n \n \n bool IsStandard(const CScript& scriptPubKey)\n {\n-    vector<pair<opcodetype, valtype> > vSolution;\n-    return Solver(scriptPubKey, vSolution);\n+    vector<vector<pair<opcodetype, valtype> > > vSolutions;\n+    return Solver(scriptPubKey, vSolutions);\n }\n \n \n bool IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n {\n-    vector<pair<opcodetype, valtype> > vSolution;\n-    if (!Solver(scriptPubKey, vSolution))\n+    vector<vector<pair<opcodetype, valtype> > > vSolutions;\n+    if (!Solver(scriptPubKey, vSolutions))\n+        return false;\n+\n+    // For this release, multisignature transactions are relayed but\n+    // never considered \"mine\"\n+    if (vSolutions.size() != 1 || vSolutions[0].size() != 1)\n         return false;\n \n-    // Compile solution\n-    BOOST_FOREACH(PAIRTYPE(opcodetype, valtype)& item, vSolution)\n+    int keysFound = 0;\n+    int keysRequired = 0;\n+    for (int i = 0; i < vSolutions.size(); i++)\n     {\n-        if (item.first == OP_PUBKEY)\n-        {\n-            const valtype& vchPubKey = item.second;\n-            vector<unsigned char> vchPubKeyFound;\n-            if (!keystore.GetPubKey(Hash160(vchPubKey), vchPubKeyFound))\n-                return false;\n-            if (vchPubKeyFound != vchPubKey)\n-                return false;\n-        }\n-        else if (item.first == OP_PUBKEYHASH)\n-        {\n-            if (!keystore.HaveKey(uint160(item.second)))\n-                return false;\n-        }\n-        else\n+        BOOST_FOREACH(PAIRTYPE(opcodetype, valtype)& item, vSolutions[i])\n         {\n-            return false;\n+            ++keysRequired;\n+            if (item.first == OP_PUBKEY)\n+            {\n+                const valtype& vchPubKey = item.second;\n+                vector<unsigned char> vchPubKeyFound;\n+                if (keystore.GetPubKey(Hash160(vchPubKey), vchPubKeyFound) && vchPubKeyFound == vchPubKey)\n+                    ++keysFound;\n+            }\n+            else if (item.first == OP_PUBKEYHASH)\n+            {\n+                if (keystore.HaveKey(uint160(item.second)))\n+                    ++keysFound;\n+            }\n         }\n     }\n \n-    return true;\n+    return (keysFound == keysRequired);\n }\n \n bool ExtractAddress(const CScript& scriptPubKey, const CKeyStore* keystore, CBitcoinAddress& addressRet)\n {\n-    vector<pair<opcodetype, valtype> > vSolution;\n-    if (!Solver(scriptPubKey, vSolution))\n+    vector<vector<pair<opcodetype, valtype> > > vSolutions;\n+    if (!Solver(scriptPubKey, vSolutions))\n+        return false;\n+\n+    // Ignore multisignature transactions for now:\n+    if (vSolutions.size() != 1 || vSolutions[0].size() != 1)\n         return false;\n \n-    BOOST_FOREACH(PAIRTYPE(opcodetype, valtype)& item, vSolution)\n+    for (int i = 0; i < vSolutions.size(); i++)\n     {\n+        if (vSolutions[i].size() != 1)\n+            continue; // Can't return more than one address...\n+\n+        PAIRTYPE(opcodetype, valtype)& item = vSolutions[i][0];\n         if (item.first == OP_PUBKEY)\n             addressRet.SetPubKey(item.second);\n         else if (item.first == OP_PUBKEYHASH)\n             addressRet.SetHash160((uint160)item.second);\n         if (keystore == NULL || keystore->HaveKey(addressRet))\n             return true;\n     }\n-\n     return false;\n }\n "
      },
      {
        "sha": "9917cf75c2455a53fc9029f9e8184e2f0fd899bc",
        "filename": "src/test/multisig_tests.cpp",
        "status": "added",
        "additions": 319,
        "deletions": 0,
        "changes": 319,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9f461095c58e5511e506ebb21301546ba094041e/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9f461095c58e5511e506ebb21301546ba094041e/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=9f461095c58e5511e506ebb21301546ba094041e",
        "patch": "@@ -0,0 +1,319 @@\n+#include <boost/assert.hpp>\n+#include <boost/assign/list_of.hpp>\n+#include <boost/assign/list_inserter.hpp>\n+#include <boost/assign/std/vector.hpp>\n+#include <boost/test/unit_test.hpp>\n+#include <boost/foreach.hpp>\n+#include <boost/tuple/tuple.hpp>\n+\n+#include \"../keystore.h\"\n+#include \"../main.h\"\n+#include \"../script.h\"\n+\n+using namespace std;\n+using namespace boost::assign;\n+\n+typedef vector<unsigned char> valtype;\n+\n+extern uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n+extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, int nHashType);\n+extern bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, int nHashType);\n+extern bool Solver(const CScript& scriptPubKey, vector<vector<pair<opcodetype, valtype> > >& vSolutionsRet);\n+\n+BOOST_AUTO_TEST_SUITE(multisig_tests)\n+\n+CScript\n+sign_multisig(CScript scriptPubKey, vector<CKey> keys, CTransaction transaction, int whichIn)\n+{\n+    uint256 hash = SignatureHash(scriptPubKey, transaction, whichIn, SIGHASH_ALL);\n+\n+    CScript result;\n+    BOOST_FOREACH(CKey key, keys)\n+    {\n+        vector<unsigned char> vchSig;\n+        BOOST_CHECK(key.Sign(hash, vchSig));\n+        vchSig.push_back((unsigned char)SIGHASH_ALL);\n+        result << vchSig;\n+    }\n+    return result;\n+}\n+CScript\n+sign_multisig(CScript scriptPubKey, CKey key, CTransaction transaction, int whichIn)\n+{\n+    vector<CKey> keys;\n+    keys.push_back(key);\n+    return sign_multisig(scriptPubKey, keys, transaction, whichIn);\n+}\n+\n+BOOST_AUTO_TEST_CASE(multisig_verify)\n+{\n+    CKey key[4];\n+    for (int i = 0; i < 4; i++)\n+        key[i].MakeNewKey();\n+\n+    CScript a_and_b;\n+    a_and_b << key[1].GetPubKey() << OP_CHECKSIGVERIFY << key[0].GetPubKey() << OP_CHECKSIG;\n+\n+    CScript a_or_b;\n+    a_or_b << OP_IF << key[1].GetPubKey() << OP_CHECKSIG << OP_ELSE\n+           << key[0].GetPubKey() << OP_CHECKSIG\n+           << OP_ENDIF;\n+\n+    CScript a_and_b_or_c;\n+    a_and_b_or_c << OP_IF << key[2].GetPubKey() << OP_CHECKSIG << OP_ELSE\n+                 << key[1].GetPubKey() << OP_CHECKSIGVERIFY << key[0].GetPubKey() << OP_CHECKSIG\n+                 << OP_ENDIF;\n+\n+    CTransaction txFrom;  // Funding transaction\n+    txFrom.vout.resize(3);\n+    txFrom.vout[0].scriptPubKey = a_and_b;\n+    txFrom.vout[1].scriptPubKey = a_or_b;\n+    txFrom.vout[2].scriptPubKey = a_and_b_or_c;\n+\n+    CTransaction txTo[3]; // Spending transaction\n+    for (int i = 0; i < 3; i++)\n+    {\n+        txTo[i].vin.resize(1);\n+        txTo[i].vout.resize(1);\n+        txTo[i].vin[0].prevout.n = i;\n+        txTo[i].vin[0].prevout.hash = txFrom.GetHash();\n+        txTo[i].vout[0].nValue = 1;\n+    }\n+\n+    vector<CKey> keys;\n+    CScript s;\n+\n+    // Test a AND b:\n+    keys.clear();\n+    keys += key[0],key[1]; // magic operator+= from boost.assign\n+    s = sign_multisig(a_and_b, keys, txTo[0], 0);\n+    BOOST_CHECK(VerifyScript(s, a_and_b, txTo[0], 0, 0));\n+\n+    for (int i = 0; i < 4; i++)\n+    {\n+        keys.clear();\n+        keys += key[i];\n+        s = sign_multisig(a_and_b, keys, txTo[0], 0);\n+        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, 0), strprintf(\"a&b 1: %d\", i));\n+\n+        keys.clear();\n+        keys += key[1],key[i];\n+        s = sign_multisig(a_and_b, keys, txTo[0], 0);\n+        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, 0), strprintf(\"a&b 2: %d\", i));\n+    }\n+\n+    // Test a OR b:\n+    for (int i = 0; i < 4; i++)\n+    {\n+        keys.clear();\n+        keys += key[i];\n+        s = sign_multisig(a_or_b, keys, txTo[1], 0);\n+        s << (i == 0 ? OP_0 : OP_1);\n+        if (i == 0 || i == 1)\n+            BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, txTo[1], 0, 0), strprintf(\"a|b: %d\", i));\n+        else\n+            BOOST_CHECK_MESSAGE(!VerifyScript(s, a_or_b, txTo[1], 0, 0), strprintf(\"a|b: %d\", i));\n+    }\n+    s.clear();\n+    s << OP_0 << OP_0;\n+    BOOST_CHECK(!VerifyScript(s, a_or_b, txTo[1], 0, 0));\n+    s.clear();\n+    s << OP_0 << OP_1;\n+    BOOST_CHECK(!VerifyScript(s, a_or_b, txTo[1], 0, 0));\n+\n+\n+    // Test a AND b OR c:\n+    keys.clear();\n+    keys += key[0],key[1];\n+    s = sign_multisig(a_and_b_or_c, keys, txTo[2], 0);\n+    s << OP_0; // a AND b case\n+    BOOST_CHECK(VerifyScript(s, a_and_b_or_c, txTo[2], 0, 0));\n+    keys.clear();\n+    keys += key[2];\n+    s = sign_multisig(a_and_b_or_c, keys, txTo[2], 0);\n+    s << OP_1; // OR c case\n+    BOOST_CHECK(VerifyScript(s, a_and_b_or_c, txTo[2], 0, 0));\n+\n+\n+    for (int i = 0; i < 4; i++)\n+    {\n+        keys.clear();\n+        keys += key[i];\n+        s = sign_multisig(a_and_b_or_c, keys, txTo[2], 0);\n+        s << OP_0; // a AND b case\n+        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b_or_c, txTo[2], 0, 0), strprintf(\"a&b|c 1: %d\", i));\n+\n+        if (i != 2)\n+        {\n+            keys.clear();\n+            keys += key[i];\n+            s = sign_multisig(a_and_b_or_c, keys, txTo[2], 0);\n+            s << OP_1; // c case\n+            BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b_or_c, txTo[2], 0, 0), strprintf(\"a&b|c 2: %d\", i));\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(multisig_IsStandard)\n+{\n+    CKey key[3];\n+    for (int i = 0; i < 3; i++)\n+        key[i].MakeNewKey();\n+\n+    CScript a_and_b;\n+    a_and_b << key[1].GetPubKey() << OP_CHECKSIGVERIFY << key[0].GetPubKey() << OP_CHECKSIG;\n+    BOOST_CHECK(::IsStandard(a_and_b));\n+\n+    CScript a_or_b;\n+    a_or_b << OP_IF << key[1].GetPubKey() << OP_CHECKSIG << OP_ELSE\n+           << key[0].GetPubKey() << OP_CHECKSIG\n+           << OP_ENDIF;\n+    BOOST_CHECK(::IsStandard(a_or_b));\n+\n+    CScript a_and_b_or_c;\n+    a_and_b_or_c << OP_IF << key[2].GetPubKey() << OP_CHECKSIG << OP_ELSE\n+                 << key[1].GetPubKey() << OP_CHECKSIGVERIFY << key[0].GetPubKey() << OP_CHECKSIG\n+                 << OP_ENDIF;\n+    BOOST_CHECK(::IsStandard(a_and_b_or_c));\n+}\n+\n+BOOST_AUTO_TEST_CASE(multisig_Solver1)\n+{\n+    // Tests Solver() that returns lists of keys that are\n+    // required to satisfy a ScriptPubKey\n+    //\n+    // Also tests IsMine() and ExtractAddress()\n+    //\n+    // Note: ExtractAddress for the multisignature transactions\n+    // always returns false for this release, even if you have\n+    // one key that would satisfy an (a|b) or (a&b|c) transaction.\n+    //\n+    CBasicKeyStore keystore, emptykeystore;\n+    CKey key[3];\n+    CBitcoinAddress keyaddr[3];\n+    for (int i = 0; i < 3; i++)\n+    {\n+        key[i].MakeNewKey();\n+        keystore.AddKey(key[i]);\n+        keyaddr[i].SetPubKey(key[i].GetPubKey());\n+    }\n+\n+    {\n+        vector<vector<pair<opcodetype, valtype> > > solutions;\n+        CScript s;\n+        s << key[0].GetPubKey() << OP_CHECKSIG;\n+        BOOST_CHECK(Solver(s, solutions));\n+        BOOST_CHECK(solutions.size() == 1);\n+        BOOST_CHECK(solutions[0].size() == 1);\n+        CBitcoinAddress addr;\n+        BOOST_CHECK(ExtractAddress(s, &keystore, addr));\n+        BOOST_CHECK(addr == keyaddr[0]);\n+        BOOST_CHECK(IsMine(keystore, s));\n+        BOOST_CHECK(!IsMine(emptykeystore, s));\n+    }\n+    {\n+        vector<vector<pair<opcodetype, valtype> > > solutions;\n+        CScript s;\n+        s << OP_DUP << OP_HASH160 << Hash160(key[0].GetPubKey()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+        BOOST_CHECK(Solver(s, solutions));\n+        BOOST_CHECK(solutions.size() == 1);\n+        BOOST_CHECK(solutions[0].size() == 1);\n+        CBitcoinAddress addr;\n+        BOOST_CHECK(ExtractAddress(s, &keystore, addr));\n+        BOOST_CHECK(addr == keyaddr[0]);\n+        BOOST_CHECK(IsMine(keystore, s));\n+        BOOST_CHECK(!IsMine(emptykeystore, s));\n+    }\n+    {\n+        vector<vector<pair<opcodetype, valtype> > > solutions;\n+        CScript s;\n+        s << key[0].GetPubKey() << OP_CHECKSIGVERIFY << key[1].GetPubKey() << OP_CHECKSIG;\n+        BOOST_CHECK(Solver(s, solutions));\n+        BOOST_CHECK(solutions.size() == 1);\n+        BOOST_CHECK(solutions[0].size() == 2);\n+        CBitcoinAddress addr;\n+        BOOST_CHECK(!ExtractAddress(s, &keystore, addr));\n+        BOOST_CHECK(!IsMine(keystore, s));\n+    }\n+    {\n+        vector<vector<pair<opcodetype, valtype> > > solutions;\n+        CScript s;\n+        s << OP_IF\n+          << key[0].GetPubKey() << OP_CHECKSIG\n+          << OP_ELSE\n+          << key[1].GetPubKey() << OP_CHECKSIG\n+          << OP_ENDIF;\n+        BOOST_CHECK(Solver(s, solutions));\n+        BOOST_CHECK(solutions.size() == 2);\n+        BOOST_CHECK(solutions[0].size() == 1);\n+        BOOST_CHECK(solutions[1].size() == 1);\n+        CBitcoinAddress addr;\n+        BOOST_CHECK(!ExtractAddress(s, &keystore, addr));\n+        BOOST_CHECK(!IsMine(keystore, s));\n+    }\n+    {\n+        vector<vector<pair<opcodetype, valtype> > > solutions;\n+        CScript s;\n+        s << OP_IF\n+          << key[0].GetPubKey() << OP_CHECKSIG\n+          << OP_ELSE\n+          << key[1].GetPubKey() << OP_CHECKSIGVERIFY << key[2].GetPubKey() << OP_CHECKSIG\n+          << OP_ENDIF;\n+        BOOST_CHECK(Solver(s, solutions));\n+        BOOST_CHECK(solutions.size() == 2);\n+        BOOST_CHECK(solutions[0].size() == 1);\n+        BOOST_CHECK(solutions[1].size() == 2);\n+        CBitcoinAddress addr;\n+        BOOST_CHECK(!ExtractAddress(s, &keystore, addr));\n+        BOOST_CHECK(!IsMine(keystore, s));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(multisig_Sign)\n+{\n+    // Test SignSignature() (and therefore the version of Solver() that signs transactions)\n+    CBasicKeyStore keystore;\n+    CKey key[4];\n+    for (int i = 0; i < 4; i++)\n+    {\n+        key[i].MakeNewKey();\n+        keystore.AddKey(key[i]);\n+    }\n+\n+    CScript a_and_b;\n+    a_and_b << key[1].GetPubKey() << OP_CHECKSIGVERIFY << key[0].GetPubKey() << OP_CHECKSIG;\n+\n+    CScript a_or_b;\n+    a_or_b << OP_IF << key[1].GetPubKey() << OP_CHECKSIG << OP_ELSE\n+           << key[0].GetPubKey() << OP_CHECKSIG\n+           << OP_ENDIF;\n+\n+    CScript a_and_b_or_c;\n+    a_and_b_or_c << OP_IF << key[2].GetPubKey() << OP_CHECKSIG << OP_ELSE\n+                 << key[1].GetPubKey() << OP_CHECKSIGVERIFY << key[0].GetPubKey() << OP_CHECKSIG\n+                 << OP_ENDIF;\n+\n+    CTransaction txFrom;  // Funding transaction\n+    txFrom.vout.resize(3);\n+    txFrom.vout[0].scriptPubKey = a_and_b;\n+    txFrom.vout[1].scriptPubKey = a_or_b;\n+    txFrom.vout[2].scriptPubKey = a_and_b_or_c;\n+\n+    CTransaction txTo[3]; // Spending transaction\n+    for (int i = 0; i < 3; i++)\n+    {\n+        txTo[i].vin.resize(1);\n+        txTo[i].vout.resize(1);\n+        txTo[i].vin[0].prevout.n = i;\n+        txTo[i].vin[0].prevout.hash = txFrom.GetHash();\n+        txTo[i].vout[0].nValue = 1;\n+    }\n+\n+    for (int i = 0; i < 3; i++)\n+    {\n+        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0), strprintf(\"SignSignature %d\", i));\n+    }\n+}\n+\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "9203ceff23d0bc622ddbd16303b1d243586a4bba",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9f461095c58e5511e506ebb21301546ba094041e/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9f461095c58e5511e506ebb21301546ba094041e/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=9f461095c58e5511e506ebb21301546ba094041e",
        "patch": "@@ -10,6 +10,7 @@\n #include \"transaction_tests.cpp\"\n #include \"DoS_tests.cpp\"\n #include \"base64_tests.cpp\"\n+#include \"multisig_tests.cpp\"\n \n CWallet* pwalletMain;\n "
      }
    ]
  }
]