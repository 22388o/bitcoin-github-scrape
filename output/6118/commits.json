[
  {
    "sha": "15d974823d3ef60b0455ab99ed991b153887391e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxNWQ5NzQ4MjNkM2VmNjBiMDQ1NWFiOTllZDk5MWIxNTM4ODczOTFl",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-05-07T13:50:18Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-05-15T23:50:46Z"
      },
      "message": "Lazily update CBlockIndex entries when pruning\n\nRename BLOCK_HAVE_DATA/ BLOCK_HAVE_UNDO to BLOCK_STORED_DATA/\nBLOCK_STORED_UNDO. These status values now indicate that a block or its undo\ninformation has been stored on disk, but pruning may cause that information to\nno longer be true.\n\nHaveBlockData() uses vinfoBlockFile to determine whether we actually have block\ndata for a given block, and it updates the CBlockIndex passed in when\nSTORED_DATA was set to true but the block file has been pruned.\n\nAlso remove the iteration of mapBlockIndex in PruneOneBlockFile, as we no\nlonger need to update the CBlockIndex entries of the blocks referenced in a\npruned file.",
      "tree": {
        "sha": "3ef074ea1c84f75f66ddbf9bd1469090fc4c234d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3ef074ea1c84f75f66ddbf9bd1469090fc4c234d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/15d974823d3ef60b0455ab99ed991b153887391e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/15d974823d3ef60b0455ab99ed991b153887391e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/15d974823d3ef60b0455ab99ed991b153887391e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/15d974823d3ef60b0455ab99ed991b153887391e/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2cc1372190c01bc6aae70f94fcc3b81ae4f7aba3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2cc1372190c01bc6aae70f94fcc3b81ae4f7aba3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2cc1372190c01bc6aae70f94fcc3b81ae4f7aba3"
      }
    ],
    "stats": {
      "total": 150,
      "additions": 85,
      "deletions": 65
    },
    "files": [
      {
        "sha": "347715adf53363cc2ac0b20189892196fc555c05",
        "filename": "src/chain.h",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/15d974823d3ef60b0455ab99ed991b153887391e/src/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/15d974823d3ef60b0455ab99ed991b153887391e/src/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.h?ref=15d974823d3ef60b0455ab99ed991b153887391e",
        "patch": "@@ -85,9 +85,9 @@ enum BlockStatus {\n     BLOCK_VALID_MASK         =   BLOCK_VALID_HEADER | BLOCK_VALID_TREE | BLOCK_VALID_TRANSACTIONS |\n                                  BLOCK_VALID_CHAIN | BLOCK_VALID_SCRIPTS,\n \n-    BLOCK_HAVE_DATA          =    8, //! full block available in blk*.dat\n-    BLOCK_HAVE_UNDO          =   16, //! undo data available in rev*.dat\n-    BLOCK_HAVE_MASK          =   BLOCK_HAVE_DATA | BLOCK_HAVE_UNDO,\n+    BLOCK_STORED_DATA        =    8, //! full block was stored in blk*.dat; pruning may have deleted\n+    BLOCK_STORED_UNDO        =   16, //! undo data was stored in rev*.dat; pruning may have deleted\n+    BLOCK_STORED_MASK        =   BLOCK_STORED_DATA | BLOCK_STORED_UNDO,\n \n     BLOCK_FAILED_VALID       =   32, //! stage after last reached validness failed\n     BLOCK_FAILED_CHILD       =   64, //! descends from failed block\n@@ -188,7 +188,7 @@ class CBlockIndex\n \n     CDiskBlockPos GetBlockPos() const {\n         CDiskBlockPos ret;\n-        if (nStatus & BLOCK_HAVE_DATA) {\n+        if (nStatus & BLOCK_STORED_DATA) {\n             ret.nFile = nFile;\n             ret.nPos  = nDataPos;\n         }\n@@ -197,7 +197,7 @@ class CBlockIndex\n \n     CDiskBlockPos GetUndoPos() const {\n         CDiskBlockPos ret;\n-        if (nStatus & BLOCK_HAVE_UNDO) {\n+        if (nStatus & BLOCK_STORED_UNDO) {\n             ret.nFile = nFile;\n             ret.nPos  = nUndoPos;\n         }\n@@ -306,11 +306,11 @@ class CDiskBlockIndex : public CBlockIndex\n         READWRITE(VARINT(nHeight));\n         READWRITE(VARINT(nStatus));\n         READWRITE(VARINT(nTx));\n-        if (nStatus & (BLOCK_HAVE_DATA | BLOCK_HAVE_UNDO))\n+        if (nStatus & (BLOCK_STORED_DATA | BLOCK_STORED_UNDO))\n             READWRITE(VARINT(nFile));\n-        if (nStatus & BLOCK_HAVE_DATA)\n+        if (nStatus & BLOCK_STORED_DATA)\n             READWRITE(VARINT(nDataPos));\n-        if (nStatus & BLOCK_HAVE_UNDO)\n+        if (nStatus & BLOCK_STORED_UNDO)\n             READWRITE(VARINT(nUndoPos));\n \n         // block header"
      },
      {
        "sha": "51d0f707ef4824129d78afe1fe525371bfcf0873",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 66,
        "deletions": 53,
        "changes": 119,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/15d974823d3ef60b0455ab99ed991b153887391e/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/15d974823d3ef60b0455ab99ed991b153887391e/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=15d974823d3ef60b0455ab99ed991b153887391e",
        "patch": "@@ -424,7 +424,7 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<CBl\n                 // We consider the chain that this peer is on invalid.\n                 return;\n             }\n-            if (pindex->nStatus & BLOCK_HAVE_DATA) {\n+            if (HaveBlockData(pindex)) {\n                 if (pindex->nChainTx)\n                     state->pindexLastCommonBlock = pindex;\n             } else if (mapBlocksInFlight.count(pindex->GetBlockHash()) == 0) {\n@@ -451,6 +451,34 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<CBl\n \n } // anon namespace\n \n+/** Determine whether we actually have the data for this block,\n+ *  and update the passed CBlockIndex if STORED_DATA is set but\n+ *  the block has been pruned.\n+ *  When pruning, we delete the block file but don't update the\n+ *  CBlockIndex entries until calling this function. */\n+bool HaveBlockData(CBlockIndex *pindex)\n+{\n+    bool mayHaveData = pindex->nStatus & BLOCK_STORED_DATA;\n+    // If we haven't pruned, or if we don't think we have data,\n+    // then we know the answer and can return it.\n+    if (!fHavePruned || !mayHaveData) return mayHaveData;\n+    // Otherwise, we might have had data in the past and pruned it.\n+    // Since we prune whole files at a time, just check that this\n+    // block's file has non-zero size.\n+    LOCK2(cs_main, cs_LastBlockFile);\n+    if (vinfoBlockFile[pindex->nFile].nSize == 0) {\n+        // This was pruned, update the state.\n+        pindex->nStatus &= ~BLOCK_STORED_DATA;\n+        pindex->nStatus &= ~BLOCK_STORED_UNDO;\n+        pindex->nFile = 0;\n+        pindex->nDataPos = 0;\n+        pindex->nUndoPos = 0;\n+        setDirtyBlockIndex.insert(pindex);\n+        return false;\n+    }\n+    return true;\n+}\n+\n bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n     LOCK(cs_main);\n     CNodeState *state = State(nodeid);\n@@ -1836,7 +1864,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n \n             // update nUndoPos in block index\n             pindex->nUndoPos = pos.nPos;\n-            pindex->nStatus |= BLOCK_HAVE_UNDO;\n+            pindex->nStatus |= BLOCK_STORED_UNDO;\n         }\n \n         pindex->RaiseValidity(BLOCK_VALID_SCRIPTS);\n@@ -2135,7 +2163,7 @@ static CBlockIndex* FindMostWorkChain() {\n             // for the most work chain if we come across them; we can't switch\n             // to a chain unless we have all the non-active-chain parent blocks.\n             bool fFailedChain = pindexTest->nStatus & BLOCK_FAILED_MASK;\n-            bool fMissingData = !(pindexTest->nStatus & BLOCK_HAVE_DATA);\n+            bool fMissingData = !HaveBlockData(pindexTest);\n             if (fFailedChain || fMissingData) {\n                 // Candidate chain is not usable (either invalid or missing data)\n                 if (fFailedChain && (pindexBestInvalid == NULL || pindexNew->nChainWork > pindexBestInvalid->nChainWork))\n@@ -2412,7 +2440,7 @@ bool ReceivedBlockTransactions(const CBlock &block, CValidationState& state, CBl\n     pindexNew->nFile = pos.nFile;\n     pindexNew->nDataPos = pos.nPos;\n     pindexNew->nUndoPos = 0;\n-    pindexNew->nStatus |= BLOCK_HAVE_DATA;\n+    pindexNew->nStatus |= BLOCK_STORED_DATA;\n     pindexNew->RaiseValidity(BLOCK_VALID_TRANSACTIONS);\n     setDirtyBlockIndex.insert(pindexNew);\n \n@@ -2430,9 +2458,8 @@ bool ReceivedBlockTransactions(const CBlock &block, CValidationState& state, CBl\n                 LOCK(cs_nBlockSequenceId);\n                 pindex->nSequenceId = nBlockSequenceId++;\n             }\n-            if (chainActive.Tip() == NULL || !setBlockIndexCandidates.value_comp()(pindex, chainActive.Tip())) {\n+            if (chainActive.Tip() == NULL || !setBlockIndexCandidates.value_comp()(pindex, chainActive.Tip()))\n                 setBlockIndexCandidates.insert(pindex);\n-            }\n             std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> range = mapBlocksUnlinked.equal_range(pindex);\n             while (range.first != range.second) {\n                 std::multimap<CBlockIndex*, CBlockIndex*>::iterator it = range.first;\n@@ -2740,7 +2767,7 @@ bool AcceptBlock(CBlock& block, CValidationState& state, CBlockIndex** ppindex,\n     // If we're pruning, ensure that we don't allow a peer to dump a copy\n     // of old blocks.  But we might need blocks that are not on the main chain\n     // to handle a reorg, even if we've processed once.\n-    if (pindex->nStatus & BLOCK_HAVE_DATA || chainActive.Contains(pindex)) {\n+    if (HaveBlockData(pindex) || chainActive.Contains(pindex)) {\n         // TODO: deal better with duplicate blocks.\n         // return state.DoS(20, error(\"AcceptBlock(): already have block %d %s\", pindex->nHeight, pindex->GetBlockHash().ToString()), REJECT_DUPLICATE, \"duplicate\");\n         return true;\n@@ -2878,34 +2905,18 @@ uint64_t CalculateCurrentUsage()\n     return retval;\n }\n \n-/* Prune a block file (modify associated database entries)*/\n+/** Prune a block file\n+ *  Remove any entries from mapBlocksUnlinked which are stored in the file\n+ *  being deleted.  Use lazy updating of the CBlockIndex entries that are affected\n+ *  (see HaveBlockData()).  */\n void PruneOneBlockFile(const int fileNumber)\n {\n-    for (BlockMap::iterator it = mapBlockIndex.begin(); it != mapBlockIndex.end(); ++it) {\n-        CBlockIndex* pindex = it->second;\n-        if (pindex->nFile == fileNumber) {\n-            pindex->nStatus &= ~BLOCK_HAVE_DATA;\n-            pindex->nStatus &= ~BLOCK_HAVE_UNDO;\n-            pindex->nFile = 0;\n-            pindex->nDataPos = 0;\n-            pindex->nUndoPos = 0;\n-            setDirtyBlockIndex.insert(pindex);\n-\n-            // Prune from mapBlocksUnlinked -- any block we prune would have\n-            // to be downloaded again in order to consider its chain, at which\n-            // point it would be considered as a candidate for\n-            // mapBlocksUnlinked or setBlockIndexCandidates.\n-            std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> range = mapBlocksUnlinked.equal_range(pindex->pprev);\n-            while (range.first != range.second) {\n-                std::multimap<CBlockIndex *, CBlockIndex *>::iterator it = range.first;\n-                range.first++;\n-                if (it->second == pindex) {\n-                    mapBlocksUnlinked.erase(it);\n-                }\n-            }\n-        }\n+    std::multimap<CBlockIndex *, CBlockIndex *>::iterator it, eraseIt;\n+    for (it = mapBlocksUnlinked.begin(); it != mapBlocksUnlinked.end(); ) {\n+        eraseIt = it++;\n+        if (eraseIt->second->nFile == fileNumber)\n+            mapBlocksUnlinked.erase(eraseIt);\n     }\n-\n     vinfoBlockFile[fileNumber].SetNull();\n     setDirtyFileInfo.insert(fileNumber);\n }\n@@ -3098,13 +3109,18 @@ bool static LoadBlockIndexDB()\n         }\n     }\n \n+    // Check whether we have ever pruned block & undo files\n+    pblocktree->ReadFlag(\"prunedblockfiles\", fHavePruned);\n+    if (fHavePruned)\n+        LogPrintf(\"LoadBlockIndexDB(): Block files have previously been pruned\\n\");\n+\n     // Check presence of blk files\n     LogPrintf(\"Checking all blk files are present...\\n\");\n     set<int> setBlkDataFiles;\n     BOOST_FOREACH(const PAIRTYPE(uint256, CBlockIndex*)& item, mapBlockIndex)\n     {\n         CBlockIndex* pindex = item.second;\n-        if (pindex->nStatus & BLOCK_HAVE_DATA) {\n+        if (HaveBlockData(pindex)) {\n             setBlkDataFiles.insert(pindex->nFile);\n         }\n     }\n@@ -3116,11 +3132,6 @@ bool static LoadBlockIndexDB()\n         }\n     }\n \n-    // Check whether we have ever pruned block & undo files\n-    pblocktree->ReadFlag(\"prunedblockfiles\", fHavePruned);\n-    if (fHavePruned)\n-        LogPrintf(\"LoadBlockIndexDB(): Block files have previously been pruned\\n\");\n-\n     // Check whether we need to continue reindexing\n     bool fReindexing = false;\n     pblocktree->ReadReindexing(fReindexing);\n@@ -3370,7 +3381,7 @@ bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n                 }\n \n                 // process in case the block isn't known yet\n-                if (mapBlockIndex.count(hash) == 0 || (mapBlockIndex[hash]->nStatus & BLOCK_HAVE_DATA) == 0) {\n+                if (mapBlockIndex.count(hash) == 0 || !HaveBlockData(mapBlockIndex[hash])) {\n                     CValidationState state;\n                     if (ProcessNewBlock(state, NULL, &block, dbp))\n                         nLoaded++;\n@@ -3423,7 +3434,7 @@ void static CheckBlockIndex()\n         return;\n     }\n \n-    LOCK(cs_main);\n+    LOCK2(cs_main, cs_LastBlockFile);\n \n     // During a reindex, we read the genesis block and call CheckBlockIndex before ActivateBestChain,\n     // so we have the genesis block in mapBlockIndex but no active chain.  (A few of the tests when\n@@ -3452,16 +3463,18 @@ void static CheckBlockIndex()\n     size_t nNodes = 0;\n     int nHeight = 0;\n     CBlockIndex* pindexFirstInvalid = NULL; // Oldest ancestor of pindex which is invalid.\n-    CBlockIndex* pindexFirstMissing = NULL; // Oldest ancestor of pindex which does not have BLOCK_HAVE_DATA.\n+    CBlockIndex* pindexFirstMissing = NULL; // Oldest ancestor of pindex which does not have data.\n     CBlockIndex* pindexFirstNeverProcessed = NULL; // Oldest ancestor of pindex for which nTx == 0.\n     CBlockIndex* pindexFirstNotTreeValid = NULL; // Oldest ancestor of pindex which does not have BLOCK_VALID_TREE (regardless of being valid or not).\n     CBlockIndex* pindexFirstNotTransactionsValid = NULL; // Oldest ancestor of pindex which does not have BLOCK_VALID_TRANSACTIONS (regardless of being valid or not).\n     CBlockIndex* pindexFirstNotChainValid = NULL; // Oldest ancestor of pindex which does not have BLOCK_VALID_CHAIN (regardless of being valid or not).\n     CBlockIndex* pindexFirstNotScriptsValid = NULL; // Oldest ancestor of pindex which does not have BLOCK_VALID_SCRIPTS (regardless of being valid or not).\n     while (pindex != NULL) {\n         nNodes++;\n+        // Not calling HaveBlockData() directly, since that can change state.\n+        bool fHaveBlockData = (pindex->nStatus & BLOCK_STORED_DATA) && vinfoBlockFile[pindex->nFile].nSize != 0;\n         if (pindexFirstInvalid == NULL && pindex->nStatus & BLOCK_FAILED_VALID) pindexFirstInvalid = pindex;\n-        if (pindexFirstMissing == NULL && !(pindex->nStatus & BLOCK_HAVE_DATA)) pindexFirstMissing = pindex;\n+        if (pindexFirstMissing == NULL && !fHaveBlockData) pindexFirstMissing = pindex;\n         if (pindexFirstNeverProcessed == NULL && pindex->nTx == 0) pindexFirstNeverProcessed = pindex;\n         if (pindex->pprev != NULL && pindexFirstNotTreeValid == NULL && (pindex->nStatus & BLOCK_VALID_MASK) < BLOCK_VALID_TREE) pindexFirstNotTreeValid = pindex;\n         if (pindex->pprev != NULL && pindexFirstNotTransactionsValid == NULL && (pindex->nStatus & BLOCK_VALID_MASK) < BLOCK_VALID_TRANSACTIONS) pindexFirstNotTransactionsValid = pindex;\n@@ -3476,16 +3489,16 @@ void static CheckBlockIndex()\n         }\n         if (pindex->nChainTx == 0) assert(pindex->nSequenceId == 0);  // nSequenceId can't be set for blocks that aren't linked\n         // VALID_TRANSACTIONS is equivalent to nTx > 0 for all nodes (whether or not pruning has occurred).\n-        // HAVE_DATA is only equivalent to nTx > 0 (or VALID_TRANSACTIONS) if no pruning has occurred.\n+        // STORED_DATA is only equivalent to nTx > 0 (or VALID_TRANSACTIONS) if no pruning has occurred.\n         if (!fHavePruned) {\n-            // If we've never pruned, then HAVE_DATA should be equivalent to nTx > 0\n-            assert(!(pindex->nStatus & BLOCK_HAVE_DATA) == (pindex->nTx == 0));\n+            // If we've never pruned, then STORED_DATA should be equivalent to nTx > 0\n+            assert(!(pindex->nStatus & BLOCK_STORED_DATA) == (pindex->nTx == 0));\n             assert(pindexFirstMissing == pindexFirstNeverProcessed);\n         } else {\n-            // If we have pruned, then we can only say that HAVE_DATA implies nTx > 0\n-            if (pindex->nStatus & BLOCK_HAVE_DATA) assert(pindex->nTx > 0);\n+            // If we have pruned, then we can only say that STORED_DATA implies nTx > 0\n+            if (pindex->nStatus & BLOCK_STORED_DATA) assert(pindex->nTx > 0);\n         }\n-        if (pindex->nStatus & BLOCK_HAVE_UNDO) assert(pindex->nStatus & BLOCK_HAVE_DATA);\n+        if (pindex->nStatus & BLOCK_STORED_UNDO) assert(pindex->nStatus & BLOCK_STORED_DATA);\n         assert(((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_TRANSACTIONS) == (pindex->nTx > 0)); // This is pruning-independent.\n         // All parents having had data (at some point) is equivalent to all parents being VALID_TRANSACTIONS, which is equivalent to nChainTx being set.\n         assert((pindexFirstNeverProcessed != NULL) == (pindex->nChainTx == 0)); // nChainTx != 0 is used to signal that all parent blocks have been processed (but may have been pruned).\n@@ -3528,14 +3541,14 @@ void static CheckBlockIndex()\n             }\n             rangeUnlinked.first++;\n         }\n-        if (pindex->pprev && (pindex->nStatus & BLOCK_HAVE_DATA) && pindexFirstNeverProcessed != NULL && pindexFirstInvalid == NULL) {\n+        if (pindex->pprev && fHaveBlockData && pindexFirstNeverProcessed != NULL && pindexFirstInvalid == NULL) {\n             // If this block has block data available, some parent was never received, and has no invalid parents, it must be in mapBlocksUnlinked.\n             assert(foundInUnlinked);\n         }\n-        if (!(pindex->nStatus & BLOCK_HAVE_DATA)) assert(!foundInUnlinked); // Can't be in mapBlocksUnlinked if we don't HAVE_DATA\n+        if (!fHaveBlockData) assert(!foundInUnlinked); // Can't be in mapBlocksUnlinked if we don't actually have the data\n         if (pindexFirstMissing == NULL) assert(!foundInUnlinked); // We aren't missing data for any parent -- cannot be in mapBlocksUnlinked.\n-        if (pindex->pprev && (pindex->nStatus & BLOCK_HAVE_DATA) && pindexFirstNeverProcessed == NULL && pindexFirstMissing != NULL) {\n-            // We HAVE_DATA for this block, have received data for all parents at some point, but we're currently missing data for some parent.\n+        if (pindex->pprev && fHaveBlockData && pindexFirstNeverProcessed == NULL && pindexFirstMissing != NULL) {\n+            // We have data for this block, have received data for all parents at some point, but we're currently missing data for some parent.\n             assert(fHavePruned); // We must have pruned.\n             // This block may have entered mapBlocksUnlinked if:\n             //  - it has a descendant that at some point had more work than the\n@@ -3730,7 +3743,7 @@ void static ProcessGetData(CNode* pfrom)\n                 }\n                 // Pruned nodes may have deleted the block, so check whether\n                 // it's available before trying to send.\n-                if (send && (mi->second->nStatus & BLOCK_HAVE_DATA))\n+                if (send && HaveBlockData(mi->second))\n                 {\n                     // Send block from disk\n                     CBlock block;"
      },
      {
        "sha": "d771a8b962b17632f7b627bddf80b510cd9e8079",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/15d974823d3ef60b0455ab99ed991b153887391e/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/15d974823d3ef60b0455ab99ed991b153887391e/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=15d974823d3ef60b0455ab99ed991b153887391e",
        "patch": "@@ -148,6 +148,12 @@ static const signed int MIN_BLOCKS_TO_KEEP = 288;\n // Setting the target to > than 550MB will make it likely we can respect the target.\n static const signed int MIN_DISK_SPACE_FOR_BLOCK_FILES = 550 * 1024 * 1024;\n \n+/**\n+ * Check whether we have data for a block, and update the CBlockIndex\n+ * by unsetting STORED_DATA and STORED_UNDO if the block was pruned.\n+ */\n+bool HaveBlockData(CBlockIndex *pindex);\n+\n /** Register with a network node to receive its signals */\n void RegisterNodeSignals(CNodeSignals& nodeSignals);\n /** Unregister a network node */\n@@ -212,7 +218,8 @@ CAmount GetBlockValue(int nHeight, const CAmount& nFees);\n  * Block and undo files are deleted in lock-step (when blk00003.dat is deleted, so is rev00003.dat.)\n  * Pruning cannot take place until the longest chain is at least a certain length (100000 on mainnet, 1000 on testnet, 10 on regtest).\n  * Pruning will never delete a block within a defined distance (currently 288) from the active chain's tip.\n- * The block index is updated by unsetting HAVE_DATA and HAVE_UNDO for any blocks that were stored in the deleted files.\n+ * The block index is updated by setting the CBlockFileInfo for a given file to NULL.\n+ * The CBlockIndex BLOCK_STORED_DATA/STORED_UNDO information is lazily updated after files are deleted.\n  * A db flag records the fact that at least some block files have been pruned.\n  *\n  * @param[out]   setFilesToPrune   The set of file indices that can be unlinked will be returned"
      },
      {
        "sha": "b9f3937f6c0e3a21d4c55a640321c20f85cefc62",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/15d974823d3ef60b0455ab99ed991b153887391e/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/15d974823d3ef60b0455ab99ed991b153887391e/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=15d974823d3ef60b0455ab99ed991b153887391e",
        "patch": "@@ -197,7 +197,7 @@ static bool rest_block(AcceptedConnection* conn,\n             throw RESTERR(HTTP_NOT_FOUND, hashStr + \" not found\");\n \n         pblockindex = mapBlockIndex[hash];\n-        if (fHavePruned && !(pblockindex->nStatus & BLOCK_HAVE_DATA) && pblockindex->nTx > 0)\n+        if (fHavePruned && !HaveBlockData(pblockindex) && pblockindex->nTx > 0)\n             throw RESTERR(HTTP_NOT_FOUND, hashStr + \" not available (pruned data)\");\n \n         if (!ReadBlockFromDisk(block, pblockindex))"
      },
      {
        "sha": "669d6911157e45c6694b1d7dcff5a81255856708",
        "filename": "src/rpcblockchain.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/15d974823d3ef60b0455ab99ed991b153887391e/src/rpcblockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/15d974823d3ef60b0455ab99ed991b153887391e/src/rpcblockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcblockchain.cpp?ref=15d974823d3ef60b0455ab99ed991b153887391e",
        "patch": "@@ -299,7 +299,7 @@ Value getblock(const Array& params, bool fHelp)\n     CBlock block;\n     CBlockIndex* pblockindex = mapBlockIndex[hash];\n \n-    if (fHavePruned && !(pblockindex->nStatus & BLOCK_HAVE_DATA) && pblockindex->nTx > 0)\n+    if (fHavePruned && !HaveBlockData(pblockindex) && pblockindex->nTx > 0)\n         throw JSONRPCError(RPC_INTERNAL_ERROR, \"Block not available (pruned data)\");\n \n     if(!ReadBlockFromDisk(block, pblockindex))\n@@ -499,7 +499,7 @@ Value getblockchaininfo(const Array& params, bool fHelp)\n     if (fPruneMode)\n     {\n         CBlockIndex *block = chainActive.Tip();\n-        while (block && block->pprev && (block->pprev->nStatus & BLOCK_HAVE_DATA))\n+        while (block && block->pprev && HaveBlockData(block->pprev))\n             block = block->pprev;\n \n         obj.push_back(Pair(\"pruneheight\",        block->nHeight));"
      }
    ]
  }
]