[
  {
    "sha": "8af12a9f5a56de594700abb5b0d9a05adf82d64b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YWYxMmE5ZjVhNTZkZTU5NDcwMGFiYjViMGQ5YTA1YWRmODJkNjRi",
    "commit": {
      "author": {
        "name": "Jeff Garzik",
        "email": "jgarzik@exmulti.com",
        "date": "2012-11-16T00:41:12Z"
      },
      "committer": {
        "name": "Jeff Garzik",
        "email": "jgarzik@redhat.com",
        "date": "2012-11-16T00:41:12Z"
      },
      "message": "P2P: parse network datastream into header/data components in socket thread\n\nReplaces CNode::vRecv buffer with a vector of CNetMessage's.  This simplifies\nProcessMessages() and eliminates several redundant data copies.\n\nOverview:\n\n* socket thread now parses incoming message datastream into\n  header/data components, as encapsulated by CNetMessage\n* socket thread adds each CNetMessage to a vector inside CNode\n* message thread (ProcessMessages) iterates through CNode's CNetMessage vector\n\nMessage parsing is made more strict:\n\n* Socket is disconnected, if message larger than MAX_SIZE\n  or if CMessageHeader deserialization fails (latter is impossible?).\n  Previously, code would simply eat garbage data all day long.\n* Socket is disconnected, if we fail to find pchMessageStart.\n  We do not search through garbage, to find pchMessageStart.  Each\n  message must begin precisely after the last message ends.\n\nProcessMessages() always processes a complete message, and is more efficient:\n\n* buffer is always precisely sized, using CDataStream::resize(),\n  rather than progressively sized in 64k chunks.  More efficient\n  for large messages like \"block\".\n* whole-buffer memory copy eliminated (vRecv -> vMsg)\n* other buffer-shifting memory copies eliminated (vRecv.insert, vRecv.erase)",
      "tree": {
        "sha": "7f49572e7346cce0f403a6f15fefd9d558342e1c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7f49572e7346cce0f403a6f15fefd9d558342e1c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8af12a9f5a56de594700abb5b0d9a05adf82d64b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8af12a9f5a56de594700abb5b0d9a05adf82d64b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8af12a9f5a56de594700abb5b0d9a05adf82d64b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8af12a9f5a56de594700abb5b0d9a05adf82d64b/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "6caffb5358b1e403b293846b3c832433fa928e46",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6caffb5358b1e403b293846b3c832433fa928e46",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6caffb5358b1e403b293846b3c832433fa928e46"
      }
    ],
    "stats": {
      "total": 231,
      "additions": 176,
      "deletions": 55
    },
    "files": [
      {
        "sha": "98c7fe79b47663f8acb2de86a51a92b51c58cf45",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 38,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8af12a9f5a56de594700abb5b0d9a05adf82d64b/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8af12a9f5a56de594700abb5b0d9a05adf82d64b/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=8af12a9f5a56de594700abb5b0d9a05adf82d64b",
        "patch": "@@ -2821,7 +2821,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n     else if (strCommand == \"verack\")\n     {\n-        pfrom->vRecv.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n+        pfrom->SetRecvVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n     }\n \n \n@@ -3263,13 +3263,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n     return true;\n }\n \n+// requires LOCK(cs_vRecvMsg)\n bool ProcessMessages(CNode* pfrom)\n {\n-    CDataStream& vRecv = pfrom->vRecv;\n-    if (vRecv.empty())\n+    if (pfrom->vRecvMsg.empty())\n         return true;\n     //if (fDebug)\n-    //    printf(\"ProcessMessages(%u bytes)\\n\", vRecv.size());\n+    //    printf(\"ProcessMessages(%zu messages)\\n\", pfrom->vRecvMsg.size());\n \n     //\n     // Message format\n@@ -3280,32 +3280,32 @@ bool ProcessMessages(CNode* pfrom)\n     //  (x) data\n     //\n \n-    loop\n+    unsigned int nMsgPos = 0;\n+    for (; nMsgPos < pfrom->vRecvMsg.size(); nMsgPos++)\n     {\n         // Don't bother if send buffer is too full to respond anyway\n         if (pfrom->vSend.size() >= SendBufferSize())\n             break;\n \n-        // Scan for message start\n-        CDataStream::iterator pstart = search(vRecv.begin(), vRecv.end(), BEGIN(pchMessageStart), END(pchMessageStart));\n-        int nHeaderSize = vRecv.GetSerializeSize(CMessageHeader());\n-        if (vRecv.end() - pstart < nHeaderSize)\n-        {\n-            if ((int)vRecv.size() > nHeaderSize)\n-            {\n-                printf(\"\\n\\nPROCESSMESSAGE MESSAGESTART NOT FOUND\\n\\n\");\n-                vRecv.erase(vRecv.begin(), vRecv.end() - nHeaderSize);\n-            }\n+        // get next message; end, if an incomplete message is found\n+        CNetMessage& msg = pfrom->vRecvMsg[nMsgPos];\n+\n+        //if (fDebug)\n+        //    printf(\"ProcessMessages(message %u msgsz, %zu bytes, complete:%s)\\n\",\n+        //            msg.hdr.nMessageSize, msg.vRecv.size(),\n+        //            msg.complete() ? \"Y\" : \"N\");\n+\n+        if (!msg.complete())\n             break;\n+\n+        // Scan for message start\n+        if (memcmp(msg.hdr.pchMessageStart, pchMessageStart, sizeof(pchMessageStart)) != 0) {\n+            printf(\"\\n\\nPROCESSMESSAGE: INVALID MESSAGESTART\\n\\n\");\n+            return false;\n         }\n-        if (pstart - vRecv.begin() > 0)\n-            printf(\"\\n\\nPROCESSMESSAGE SKIPPED %\"PRIpdd\" BYTES\\n\\n\", pstart - vRecv.begin());\n-        vRecv.erase(vRecv.begin(), pstart);\n \n         // Read header\n-        vector<char> vHeaderSave(vRecv.begin(), vRecv.begin() + nHeaderSize);\n-        CMessageHeader hdr;\n-        vRecv >> hdr;\n+        CMessageHeader& hdr = msg.hdr;\n         if (!hdr.IsValid())\n         {\n             printf(\"\\n\\nPROCESSMESSAGE: ERRORS IN HEADER %s\\n\\n\\n\", hdr.GetCommand().c_str());\n@@ -3315,19 +3315,9 @@ bool ProcessMessages(CNode* pfrom)\n \n         // Message size\n         unsigned int nMessageSize = hdr.nMessageSize;\n-        if (nMessageSize > MAX_SIZE)\n-        {\n-            printf(\"ProcessMessages(%s, %u bytes) : nMessageSize > MAX_SIZE\\n\", strCommand.c_str(), nMessageSize);\n-            continue;\n-        }\n-        if (nMessageSize > vRecv.size())\n-        {\n-            // Rewind and wait for rest of message\n-            vRecv.insert(vRecv.begin(), vHeaderSave.begin(), vHeaderSave.end());\n-            break;\n-        }\n \n         // Checksum\n+        CDataStream& vRecv = msg.vRecv;\n         uint256 hash = Hash(vRecv.begin(), vRecv.begin() + nMessageSize);\n         unsigned int nChecksum = 0;\n         memcpy(&nChecksum, &hash, sizeof(nChecksum));\n@@ -3338,17 +3328,13 @@ bool ProcessMessages(CNode* pfrom)\n             continue;\n         }\n \n-        // Copy message to its own buffer\n-        CDataStream vMsg(vRecv.begin(), vRecv.begin() + nMessageSize, vRecv.nType, vRecv.nVersion);\n-        vRecv.ignore(nMessageSize);\n-\n         // Process message\n         bool fRet = false;\n         try\n         {\n             {\n                 LOCK(cs_main);\n-                fRet = ProcessMessage(pfrom, strCommand, vMsg);\n+                fRet = ProcessMessage(pfrom, strCommand, vRecv);\n             }\n             if (fShutdown)\n                 return true;\n@@ -3380,7 +3366,10 @@ bool ProcessMessages(CNode* pfrom)\n             printf(\"ProcessMessage(%s, %u bytes) FAILED\\n\", strCommand.c_str(), nMessageSize);\n     }\n \n-    vRecv.Compact();\n+    // remove processed messages; one incomplete message may remain\n+    if (nMsgPos > 0)\n+        pfrom->vRecvMsg.erase(pfrom->vRecvMsg.begin(),\n+                              pfrom->vRecvMsg.begin() + nMsgPos);\n     return true;\n }\n "
      },
      {
        "sha": "1d38d95441c9bb8796457190fe151c57e93dd2a1",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 83,
        "deletions": 13,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8af12a9f5a56de594700abb5b0d9a05adf82d64b/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8af12a9f5a56de594700abb5b0d9a05adf82d64b/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=8af12a9f5a56de594700abb5b0d9a05adf82d64b",
        "patch": "@@ -535,7 +535,7 @@ void CNode::CloseSocketDisconnect()\n         printf(\"disconnecting node %s\\n\", addrName.c_str());\n         closesocket(hSocket);\n         hSocket = INVALID_SOCKET;\n-        vRecv.clear();\n+        vRecvMsg.clear();\n     }\n }\n \n@@ -627,6 +627,78 @@ void CNode::copyStats(CNodeStats &stats)\n }\n #undef X\n \n+// requires LOCK(cs_vRecvMsg)\n+bool CNode::ReceiveMsgBytes(const char *pch, unsigned int nBytes)\n+{\n+    while (nBytes > 0) {\n+\n+        // get current incomplete message, or create a new one\n+        if (vRecvMsg.size() == 0 ||\n+            vRecvMsg.back().complete())\n+            vRecvMsg.push_back(CNetMessage(SER_NETWORK, nRecvVersion));\n+\n+        CNetMessage& msg = vRecvMsg.back();\n+\n+        // absorb network data\n+        int handled;\n+        if (!msg.in_data)\n+            handled = msg.readHeader(pch, nBytes);\n+        else\n+            handled = msg.readData(pch, nBytes);\n+\n+        if (handled < 0)\n+                return false;\n+\n+        pch += handled;\n+        nBytes -= handled;\n+    }\n+\n+    return true;\n+}\n+\n+int CNetMessage::readHeader(const char *pch, unsigned int nBytes)\n+{\n+    // copy data to temporary parsing buffer\n+    unsigned int nRemaining = 24 - nHdrPos;\n+    unsigned int nCopy = std::min(nRemaining, nBytes);\n+\n+    memcpy(&hdrbuf[nHdrPos], pch, nCopy);\n+    nHdrPos += nCopy;\n+\n+    // if header incomplete, exit\n+    if (nHdrPos < 24)\n+        return nCopy;\n+\n+    // deserialize to CMessageHeader\n+    try {\n+        hdrbuf >> hdr;\n+    }\n+    catch (std::exception &e) {\n+        return -1;\n+    }\n+\n+    // reject messages larger than MAX_SIZE\n+    if (hdr.nMessageSize > MAX_SIZE)\n+            return -1;\n+\n+    // switch state to reading message data\n+    in_data = true;\n+    vRecv.resize(hdr.nMessageSize);\n+\n+    return nCopy;\n+}\n+\n+int CNetMessage::readData(const char *pch, unsigned int nBytes)\n+{\n+    unsigned int nRemaining = hdr.nMessageSize - nDataPos;\n+    unsigned int nCopy = std::min(nRemaining, nBytes);\n+\n+    memcpy(&vRecv[nDataPos], pch, nCopy);\n+    nDataPos += nCopy;\n+\n+    return nCopy;\n+}\n+\n \n \n \n@@ -675,7 +747,7 @@ void ThreadSocketHandler2(void* parg)\n             BOOST_FOREACH(CNode* pnode, vNodesCopy)\n             {\n                 if (pnode->fDisconnect ||\n-                    (pnode->GetRefCount() <= 0 && pnode->vRecv.empty() && pnode->vSend.empty()))\n+                    (pnode->GetRefCount() <= 0 && pnode->vRecvMsg.empty() && pnode->vSend.empty()))\n                 {\n                     // remove from vNodes\n                     vNodes.erase(remove(vNodes.begin(), vNodes.end(), pnode), vNodes.end());\n@@ -707,7 +779,7 @@ void ThreadSocketHandler2(void* parg)\n                         TRY_LOCK(pnode->cs_vSend, lockSend);\n                         if (lockSend)\n                         {\n-                            TRY_LOCK(pnode->cs_vRecv, lockRecv);\n+                            TRY_LOCK(pnode->cs_vRecvMsg, lockRecv);\n                             if (lockRecv)\n                             {\n                                 TRY_LOCK(pnode->cs_inventory, lockInv);\n@@ -872,15 +944,12 @@ void ThreadSocketHandler2(void* parg)\n                 continue;\n             if (FD_ISSET(pnode->hSocket, &fdsetRecv) || FD_ISSET(pnode->hSocket, &fdsetError))\n             {\n-                TRY_LOCK(pnode->cs_vRecv, lockRecv);\n+                TRY_LOCK(pnode->cs_vRecvMsg, lockRecv);\n                 if (lockRecv)\n                 {\n-                    CDataStream& vRecv = pnode->vRecv;\n-                    unsigned int nPos = vRecv.size();\n-\n-                    if (nPos > ReceiveBufferSize()) {\n+                    if (pnode->GetTotalRecvSize() > ReceiveFloodSize()) {\n                         if (!pnode->fDisconnect)\n-                            printf(\"socket recv flood control disconnect (%\"PRIszu\" bytes)\\n\", vRecv.size());\n+                            printf(\"socket recv flood control disconnect (%u bytes)\\n\", pnode->GetTotalRecvSize());\n                         pnode->CloseSocketDisconnect();\n                     }\n                     else {\n@@ -889,8 +958,8 @@ void ThreadSocketHandler2(void* parg)\n                         int nBytes = recv(pnode->hSocket, pchBuf, sizeof(pchBuf), MSG_DONTWAIT);\n                         if (nBytes > 0)\n                         {\n-                            vRecv.resize(nPos + nBytes);\n-                            memcpy(&vRecv[nPos], pchBuf, nBytes);\n+                            if (!pnode->ReceiveMsgBytes(pchBuf, nBytes))\n+                                pnode->CloseSocketDisconnect();\n                             pnode->nLastRecv = GetTime();\n                         }\n                         else if (nBytes == 0)\n@@ -1672,9 +1741,10 @@ void ThreadMessageHandler2(void* parg)\n         {\n             // Receive messages\n             {\n-                TRY_LOCK(pnode->cs_vRecv, lockRecv);\n+                TRY_LOCK(pnode->cs_vRecvMsg, lockRecv);\n                 if (lockRecv)\n-                    ProcessMessages(pnode);\n+                    if (!ProcessMessages(pnode))\n+                        pnode->CloseSocketDisconnect();\n             }\n             if (fShutdown)\n                 return;"
      },
      {
        "sha": "9946e36c9af2b97c0bf4360290c8147fc0ddd10a",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 66,
        "deletions": 4,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8af12a9f5a56de594700abb5b0d9a05adf82d64b/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8af12a9f5a56de594700abb5b0d9a05adf82d64b/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=8af12a9f5a56de594700abb5b0d9a05adf82d64b",
        "patch": "@@ -25,7 +25,7 @@ extern int nBestHeight;\n \n \n \n-inline unsigned int ReceiveBufferSize() { return 1000*GetArg(\"-maxreceivebuffer\", 5*1000); }\n+inline unsigned int ReceiveFloodSize() { return 1000*GetArg(\"-maxreceivebuffer\", 5*1000); }\n inline unsigned int SendBufferSize() { return 1000*GetArg(\"-maxsendbuffer\", 1*1000); }\n \n void AddOneShot(std::string strDest);\n@@ -128,6 +128,44 @@ class CNodeStats\n \n \n \n+class CNetMessage {\n+public:\n+    bool in_data;                   // parsing header (false) or data (true)\n+\n+    CDataStream hdrbuf;             // partially received header\n+    CMessageHeader hdr;             // complete header\n+    unsigned int nHdrPos;\n+\n+    CDataStream vRecv;              // received message data\n+    unsigned int nDataPos;\n+\n+    CNetMessage(int nTypeIn, int nVersionIn) : hdrbuf(nTypeIn, nVersionIn), vRecv(nTypeIn, nVersionIn) {\n+        hdrbuf.resize(24);\n+        in_data = false;\n+        nHdrPos = 0;\n+        nDataPos = 0;\n+    }\n+\n+    bool complete() const\n+    {\n+        if (!in_data)\n+            return false;\n+        return (hdr.nMessageSize == nDataPos);\n+    }\n+\n+    void SetVersion(int nVersionIn)\n+    {\n+        hdrbuf.SetVersion(nVersionIn);\n+        vRecv.SetVersion(nVersionIn);\n+    }\n+\n+    int readHeader(const char *pch, unsigned int nBytes);\n+    int readData(const char *pch, unsigned int nBytes);\n+};\n+\n+\n+\n+\n \n /** Information about a peer */\n class CNode\n@@ -137,9 +175,12 @@ class CNode\n     uint64 nServices;\n     SOCKET hSocket;\n     CDataStream vSend;\n-    CDataStream vRecv;\n     CCriticalSection cs_vSend;\n-    CCriticalSection cs_vRecv;\n+\n+    std::vector<CNetMessage> vRecvMsg;\n+    CCriticalSection cs_vRecvMsg;\n+    int nRecvVersion;\n+\n     int64 nLastSend;\n     int64 nLastRecv;\n     int64 nLastSendEmpty;\n@@ -186,10 +227,11 @@ class CNode\n     CCriticalSection cs_inventory;\n     std::multimap<int64, CInv> mapAskFor;\n \n-    CNode(SOCKET hSocketIn, CAddress addrIn, std::string addrNameIn = \"\", bool fInboundIn=false) : vSend(SER_NETWORK, MIN_PROTO_VERSION), vRecv(SER_NETWORK, MIN_PROTO_VERSION)\n+    CNode(SOCKET hSocketIn, CAddress addrIn, std::string addrNameIn = \"\", bool fInboundIn=false) : vSend(SER_NETWORK, MIN_PROTO_VERSION)\n     {\n         nServices = 0;\n         hSocket = hSocketIn;\n+        nRecvVersion = MIN_PROTO_VERSION;\n         nLastSend = 0;\n         nLastRecv = 0;\n         nLastSendEmpty = GetTime();\n@@ -241,6 +283,26 @@ class CNode\n         return std::max(nRefCount, 0) + (GetTime() < nReleaseTime ? 1 : 0);\n     }\n \n+    // requires LOCK(cs_vRecvMsg)\n+    unsigned int GetTotalRecvSize()\n+    {\n+        unsigned int total = 0;\n+        for (unsigned int i = 0; i < vRecvMsg.size(); i++)\n+            total += vRecvMsg[i].vRecv.size();\n+        return total;\n+    }\n+\n+    // requires LOCK(cs_vRecvMsg)\n+    bool ReceiveMsgBytes(const char *pch, unsigned int nBytes);\n+\n+    // requires LOCK(cs_vRecvMsg)\n+    void SetRecvVersion(int nVersionIn)\n+    {\n+        nRecvVersion = nVersionIn;\n+        for (unsigned int i = 0; i < vRecvMsg.size(); i++)\n+            vRecvMsg[i].SetVersion(nVersionIn);\n+    }\n+\n     CNode* AddRef(int64 nTimeout=0)\n     {\n         if (nTimeout != 0)"
      }
    ]
  }
]