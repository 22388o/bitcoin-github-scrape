DrahtBot,2021-05-17 03:43:56,"<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #21981 (Remove unused float serialization by MarcoFalke)\n* #21969 (refactor: Switch serialize to uint8_t (Bundle 1/2) by ",https://github.com/bitcoin/bitcoin/pull/21966#issuecomment-841961633,841961633,
practicalswift,2021-05-17 09:40:30,Strong Concept ACK,https://github.com/bitcoin/bitcoin/pull/21966#issuecomment-842179889,842179889,
laanwj,2021-05-17 10:23:59,"While I think this is intriguing technically, I'm ~0 on this conceptually\n\nI think using floating point in places where 100% precision or portability across platforms is important is mistaken in the first place. This gives the wrong impression.\n\nIt raises deeper questions for me: do we really need floating point in Bitcoin at all? Narrower: do we really need to serialize/deserialize it?\n",https://github.com/bitcoin/bitcoin/pull/21966#issuecomment-842208191,842208191,
MarcoFalke,2021-05-17 10:28:14,"Haven't checked, but I presume it is only used for fees.dat?",https://github.com/bitcoin/bitcoin/pull/21966#issuecomment-842210758,842210758,
laanwj,2021-05-17 10:42:10,"If so, I'd prefer to find an alternative way of serializing those values specifically (as fixed-point or numerator / denominator pairs of integers) and dropping the general float/double (de)serialization.",https://github.com/bitcoin/bitcoin/pull/21966#issuecomment-842218859,842218859,
practicalswift,2021-05-17 14:08:51,"> Narrower: do we really need to serialize/deserialize it?\n\nAs MarcoFalke discovered `ser_float_to_uint32` and `ser_uint32_to_float` are currently unused (#21981), and AFAICT `TxConfirmStats::Write` and `TxConfirmStats::Read` are the only remaining users of `ser_double_to_uint64` and `ser_uint64_to_double`.\n\nLooks promising! :)",https://github.com/bitcoin/bitcoin/pull/21966#issuecomment-842355965,842355965,
sipa,2021-05-17 18:10:28,"@laanwj That""s fair. I agree that avoiding serialization of floating point values directly is much more desirable.\n\nMy thinking here is that it effectively gives us a well-specified serialization with testable properties without needing to break compatibility with existing files.\n\nHow about rebasing this PR on top of #21981, and making it remove serialization support for `double` too in serial",https://github.com/bitcoin/bitcoin/pull/21966#issuecomment-842528708,842528708,
laanwj,2021-05-18 07:39:18,"> How about rebasing this PR on top of #21981, and making it remove serialization support for double too in serialization.h, and instead make the feedata writing/reading code invoke EncodeDouble/DecodeDouble directly?\n\nI was about to comment this! Let's make this code private to the single case where it is used? It keeps the current format but also prevents future serialization of these types ",https://github.com/bitcoin/bitcoin/pull/21966#issuecomment-842934929,842934929,
sipa,2021-05-18 19:55:40,@laanwj Done.,https://github.com/bitcoin/bitcoin/pull/21966#issuecomment-843511988,843511988,
practicalswift,2021-05-18 22:06:33,"cr ACK 892522deba52f35fe5b08e2d7aebeb80600f9cdc: patch looks correct :)\n\nVery happy to see `ser_double_to_uint64`/`ser_uint64_to_double` go and `src/compat/assumptions.h` shrink :)",https://github.com/bitcoin/bitcoin/pull/21966#issuecomment-843597240,843597240,
laanwj,2021-05-19 08:23:35,"Thanks! Happy to see this now.\n\n~~Code review ACK 892522deba52f35fe5b08e2d7aebeb80600f9cdc~~\nCode review re-ACK 66545da2008cd9e806e41b74522ded259cd64f86",https://github.com/bitcoin/bitcoin/pull/21966#issuecomment-843868492,843868492,
practicalswift,2021-05-25 19:09:58,cr re-ACK 66545da2008cd9e806e41b74522ded259cd64f86,https://github.com/bitcoin/bitcoin/pull/21966#issuecomment-848189719,848189719,
MarcoFalke,2021-05-20 06:15:59,"would it make sense to also assert equality with the ""legacy"" serialization helpers in both this unit test and the fuzz test?\n\nOtherwise we might run into a corrupted fees.dat after an upgrade. A problem worse than the problem this pull is trying to solve (making fees.dat architecture independent).",https://github.com/bitcoin/bitcoin/pull/21966#discussion_r635795210,635795210,src/test/serfloat_tests.cpp
MarcoFalke,2021-05-20 06:20:15,"Oh sorry, I see that is what the ""should produce exactly the same as the in-memory representation for non-NaN"" test is doing.",https://github.com/bitcoin/bitcoin/pull/21966#discussion_r635797201,635797201,src/test/serfloat_tests.cpp
MarcoFalke,2021-05-20 06:23:25,"Though, it looks like the fuzz test isn't fuzzing the in-memory representation, only the round-trip?",https://github.com/bitcoin/bitcoin/pull/21966#discussion_r635798794,635798794,src/test/serfloat_tests.cpp
MarcoFalke,2021-05-20 06:24:57,"Any reason to check for float, but then test double?",https://github.com/bitcoin/bitcoin/pull/21966#discussion_r635799512,635799512,src/test/serfloat_tests.cpp
sipa,2021-05-24 23:15:30,Added back.,https://github.com/bitcoin/bitcoin/pull/21966#discussion_r638348520,638348520,src/test/serfloat_tests.cpp
sipa,2021-05-24 23:15:52,"The technical term for this would be an ""oops"". Fixed.",https://github.com/bitcoin/bitcoin/pull/21966#discussion_r638348644,638348644,src/test/serfloat_tests.cpp
practicalswift,2021-05-25 19:08:09,"Note to other reviewers: We assume this to hold `true` in `assumptions.h`:\n\n```\nstatic_assert(std::numeric_limits<double>::is_iec559, ""IEEE 754 double assumed"");\n```",https://github.com/bitcoin/bitcoin/pull/21966#discussion_r639111357,639111357,src/test/fuzz/float.cpp
practicalswift,2021-05-25 19:08:29,"Note to other reviewers: We assume this to hold `true` in `assumptions.h`:\n\n```\nstatic_assert(std::numeric_limits<double>::is_iec559, ""IEEE 754 double assumed"");\n```",https://github.com/bitcoin/bitcoin/pull/21966#discussion_r639111540,639111540,src/test/serfloat_tests.cpp
sipa,2021-05-25 19:11:20,"I should remove that assumption now, it's no longer needed.",https://github.com/bitcoin/bitcoin/pull/21966#discussion_r639113267,639113267,src/test/serfloat_tests.cpp
practicalswift,2021-05-25 19:30:32,"I think we need that assumption as long as we're doing floating-point division by zero? I still think we do that in `ConnectBlock`, `CreateTransaction`  and `EstimateMedianVal` :)",https://github.com/bitcoin/bitcoin/pull/21966#discussion_r639125203,639125203,src/test/serfloat_tests.cpp
sipa,2021-05-25 19:35:46,"Ah, good point.",https://github.com/bitcoin/bitcoin/pull/21966#discussion_r639128383,639128383,src/test/serfloat_tests.cpp
laanwj,2021-05-26 07:52:37,"Maybe a weaker assumption could do there. In any case, it's out of scope for this PR. Happy to leave it as it is for the foreseeable future unless anyone has good reason to work on porting bitcoind to non-IEC559 platforms.\n\n(in which case I heartily suggest: please get rid of *all* floating point code. it shouldn't be necessary in financial-ish code)",https://github.com/bitcoin/bitcoin/pull/21966#discussion_r639485049,639485049,src/test/serfloat_tests.cpp
MarcoFalke,2021-06-07 10:22:08,"Ah thanks, though the `fuzzed_data_provider.ConsumeFloatingPoint` only consumes ""nice"" floats, not odd ones. So the fuzzer is only testing the happy path.",https://github.com/bitcoin/bitcoin/pull/21966#discussion_r646459605,646459605,src/test/serfloat_tests.cpp
MarcoFalke,2021-06-07 11:56:31,Fixed in #22180 ,https://github.com/bitcoin/bitcoin/pull/21966#discussion_r646519694,646519694,src/test/serfloat_tests.cpp
