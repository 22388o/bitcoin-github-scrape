JeremyRubin,2020-07-27 06:43:20,"It should be substantially faster and memory friendly for these big txns to\nfill the parents set as a vector of hashes, sort it, use std::unique to\nshift out the duplicates, and then erase garbage.\n\n\nstd::set will do O(n) allocations and use about 3x the memory compared to\nstd::vector, and set traversal and construction is worse than vector.\n\n\nThe only case where set may win is if the dup",https://github.com/bitcoin/bitcoin/pull/19596#issuecomment-664151671,664151671,
jonatack,2020-07-27 07:31:44,"Good ideas. There is the question of using sets for the data structure. The first commit 2898d6505a3 ""Rewrite parent txid loop of requested transactions"" seems to break a number of functional tests for me locally. All the tests pass again after rebasing to keep only the second commit.\n\n```\ninterface_rest.py                       | âœ– Failed  | 35 s\nmempool_packages.py                     | ",https://github.com/bitcoin/bitcoin/pull/19596#issuecomment-664172214,664172214,
DrahtBot,2020-07-27 10:34:39,"<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #19610 (p2p: refactor AlreadyHave(), CInv::type, INV/TX processing by jonatack)\n* #19306 (refactor: Replace RecursiveMute",https://github.com/bitcoin/bitcoin/pull/19596#issuecomment-664291963,664291963,
ajtowns,2020-07-27 10:38:02,"> It should be substantially faster and memory friendly for these big txns to fill the parents set as a vector of hashes, sort it, use std::unique to shift out the duplicates, and then erase garbage.\n\nI think this is just:\n\n```diff\n--- a/src/net_processing.cpp\n+++ b/src/net_processing.cpp\n@@ -2990,10 +2990,12 @@ void ProcessMessage(\n \n             // Deduplicate parent txids, so ",https://github.com/bitcoin/bitcoin/pull/19596#issuecomment-664296550,664296550,
sdaftuar,2020-07-27 23:23:14,"Thanks all for the quick review!  @ajtowns I grabbed your code for using a vector instead of a set, and hopefully fixed the lock inversion problem.\n\n@jonatack I'm surprised by the test failures, is it possible the lock inversion caused that? ",https://github.com/bitcoin/bitcoin/pull/19596#issuecomment-664687862,664687862,
sipa,2020-07-28 18:34:16,"Code review ACK 842f908cefc33baea116bb134810fc9ff8a0ea17\n\nI don't understand where the locking failure is coming from. Is it possibly fixed now?",https://github.com/bitcoin/bitcoin/pull/19596#issuecomment-665207022,665207022,
sdaftuar,2020-07-28 18:48:25,"> I don't understand where the locking failure is coming from. Is it possibly fixed now?\n\n@sipa Yes it should be fixed now; when I opened the PR initially, I wasn't letting go of the mempool lock before acquiring the others in the first commit.",https://github.com/bitcoin/bitcoin/pull/19596#issuecomment-665213776,665213776,
sipa,2020-07-30 16:06:33,"@jnewbery Overhead of a set over a vector is the size of 3 pointers and an int (for red black tree structure), plus 2 pointers (for malloc overhead), and that rounded up to the next multiple of 2 pointers' worth.\n\nFor 64-bit systems that means between 48 and 63 bytes overhead.",https://github.com/bitcoin/bitcoin/pull/19596#issuecomment-666491932,666491932,
jnewbery,2020-07-30 16:21:08,Thanks @sipa!,https://github.com/bitcoin/bitcoin/pull/19596#issuecomment-666503220,666503220,
JeremyRubin,2020-07-30 17:47:22,"If that's not clear for anyone reading along, because I frequently have to re-check this logic...\n\nthe implementation we assume for std::set is a red black tree, with a layout of:\n```c++\ntemplate <typename T>\nstruct node {\nint color;\nvoid* parent;\nvoid* left;\nvoid* right;\nT element;\n}\n```\nThis sums to 8 bytes * 4 (int has 4 bytes padding) = 32 bytes of overhead, no extra ",https://github.com/bitcoin/bitcoin/pull/19596#issuecomment-666559300,666559300,
jnewbery,2020-07-30 22:15:48,Thanks @JeremyRubin! Very interesting.,https://github.com/bitcoin/bitcoin/pull/19596#issuecomment-666738950,666738950,
luke-jr,2020-07-31 00:51:00,Has `unordered_set` been evaluated?,https://github.com/bitcoin/bitcoin/pull/19596#issuecomment-666847359,666847359,
JeremyRubin,2020-07-31 04:50:46,"unordered_set... ah the promise of O(1) accesses. I don't think it makes sense to do here since N is small. Here's my overall thinking:\n\nThis piece of code isn't exactly *adversarial*. Whatever algorithm we pick -- sorting or hash tabling, is going to be good enough. This is mostly about picking something with good average runtime and acceptable worst case runtime, and preferably low memory on",https://github.com/bitcoin/bitcoin/pull/19596#issuecomment-666918300,666918300,
sdaftuar,2020-08-04 19:52:12,Rebased and addressed @jnewbery's feedback.,https://github.com/bitcoin/bitcoin/pull/19596#issuecomment-668792982,668792982,
laanwj,2020-08-10 18:37:50,"Code review ACK 4c0731f9c50b0556f8a57b912c8f295c7a9ea89c\n",https://github.com/bitcoin/bitcoin/pull/19596#issuecomment-671520330,671520330,
jonatack,2020-07-30 04:48:34,"nit: only if need to retouch, separating the `unique` operation from the `erase`, similar to the code example in https://en.cppreference.com/w/cpp/algorithm/unique, seems slightly clearer to me\n\n```diff\n-            unique_parents.erase(std::unique(unique_parents.begin(), unique_parents.end()), unique_parents.end());\n+            auto last_unique_parent = std::unique(unique_parents.begin()",https://github.com/bitcoin/bitcoin/pull/19596#discussion_r462733100,462733100,src/net_processing.cpp
jnewbery,2020-07-30 07:00:30,Would it be better to `reserve()` the capacity of this vector to `tx->vin.size()` here (or even better to `parents.size()` later) to avoid repeated reallocations in the worst case?,https://github.com/bitcoin/bitcoin/pull/19596#discussion_r462783746,462783746,src/net_processing.cpp
jnewbery,2020-07-30 07:11:11,I think `parents` would be a better name here. They only become unique later once you deduplicate them.,https://github.com/bitcoin/bitcoin/pull/19596#discussion_r462792647,462792647,src/net_processing.cpp
jnewbery,2020-07-30 07:14:29,"I disagree. The remove-erase (or in this case unique-erase) idiom is common in c++. Once you've seen it a couple of times it's clear what it's doing. Plus, unique leaves the last elements of the vector in indeterminate state, so we don't want anyone to be tempted to do anything with it between unique and erase.",https://github.com/bitcoin/bitcoin/pull/19596#discussion_r462795493,462795493,src/net_processing.cpp
jnewbery,2020-07-30 07:20:47,"This might be an over-optimization, but I expect that transactions which contain multiple inputs from the same parent may group those inputs together. If that's true, then checking the prevout hash against the last element of `unique_parents` would prevent us from adding duplicates in many cases.",https://github.com/bitcoin/bitcoin/pull/19596#discussion_r462798675,462798675,src/net_processing.cpp
jnewbery,2020-07-30 07:26:30,"Since you're already touching this line, maybe we could remove `nFetchFlags` here.\n\n`AlreadyHave()` and `RequestTx()` don't do anything differently depending on whether the CInv is an MSG_TX or MSG_WITNESSTX, so adding the `MSG_WITNESS_FLAG` is useless here. (the same is true for the `nFetchFlags` in the INV processing in ProcessMessages).\n\nPerhaps best left for a different PR.",https://github.com/bitcoin/bitcoin/pull/19596#discussion_r462801556,462801556,src/net_processing.cpp
jonatack,2020-07-30 08:58:24,Fair.,https://github.com/bitcoin/bitcoin/pull/19596#discussion_r462853312,462853312,src/net_processing.cpp
JeremyRubin,2020-07-30 17:26:20,"concept nack this one: I agree that this might be a good heuristic, but how commonly does a single wallet have multiple payments from the same parent? The need to compare an extra O(N) times would probably be slower than sorting & removing the extra elements anyways. We've already allocated the memory, may as well use it!\n\nIf this does come up as a big common case, the approach I'd take is to ",https://github.com/bitcoin/bitcoin/pull/19596#discussion_r463155654,463155654,src/net_processing.cpp
JeremyRubin,2020-07-30 17:34:40,"It's definitely clear. The only thing that would be a bit better is if instead of erasing, we just range over a Span(beigin, unique_it) because then we can do the erasing when the unique_parents vector is dropped. But I think that hash is trivially destructible, so not clear that erase will specialize with any overhead as there is no destructor to call. In any case, we only *actually* erase anythi",https://github.com/bitcoin/bitcoin/pull/19596#discussion_r463160275,463160275,src/net_processing.cpp
jnewbery,2020-07-31 10:34:53,"yep, agree that this is overoptimization.",https://github.com/bitcoin/bitcoin/pull/19596#discussion_r463535872,463535872,src/net_processing.cpp
jonatack,2020-08-03 14:39:17,"> Since you're already touching this line, maybe we could remove `nFetchFlags` here.\n> \n> `AlreadyHave()` and `RequestTx()` don't do anything differently depending on whether the CInv is an MSG_TX or MSG_WITNESSTX, so adding the `MSG_WITNESS_FLAG` is useless here. (the same is true for the `nFetchFlags` in the INV processing in ProcessMessages).\n> \n> Perhaps best left for a different PR.\",https://github.com/bitcoin/bitcoin/pull/19596#discussion_r464456865,464456865,src/net_processing.cpp
jonatack,2020-08-04 15:36:10,Removed unused `nFetchFlags` from ProcessMessages TX and INV processing in #19611.,https://github.com/bitcoin/bitcoin/pull/19596#discussion_r465142403,465142403,src/net_processing.cpp
sdaftuar,2020-08-04 17:44:17,"Leaving this alone, thanks.",https://github.com/bitcoin/bitcoin/pull/19596#discussion_r465221973,465221973,src/net_processing.cpp
sdaftuar,2020-08-04 18:00:00,"Added a comment instead, since the first thing we do is deduplicate, and then we use this as a list of unique_parents later on.",https://github.com/bitcoin/bitcoin/pull/19596#discussion_r465231032,465231032,src/net_processing.cpp
sdaftuar,2020-08-04 18:00:41,"Practically speaking the worst case here is pretty small, but sure I did the reserve() thing with parents.size().",https://github.com/bitcoin/bitcoin/pull/19596#discussion_r465231434,465231434,src/net_processing.cpp
ajtowns,2020-08-06 04:52:47,"It's probably fine in practice, and it's not a regression in this PR, but locking and unlocking cs_tx_inventory and cs_main (potentially) for each parent kind of bugs me each time I look at it, so I had a go at trying to avoid it. Came up with:\n\n```c++\n{\n    LOCK(pfrom.m_tx_relay->cs_tx_inventory);\n    auto is_known = [&](uint256& parent_txid) EXCLUSIVE_LOCKS_REQUIRED(pfrom.m_tx_relay->c",https://github.com/bitcoin/bitcoin/pull/19596#discussion_r466145042,466145042,src/net_processing.cpp
jnewbery,2020-08-06 14:24:30,"Calling `State()` to iterate over every peer for every input txid also seems wasteful, especially since we're already in a loop over all getdata items. I think better would be:\n\n```\n            if (!parent_ids_to_add.empty()) {\n                LOCK(cs_main);\n                CNodeState* node = State(pfrom.GetId());\n                for (const uint256& parent_txid : parent_ids_to_add) {\",https://github.com/bitcoin/bitcoin/pull/19596#discussion_r466450840,466450840,src/net_processing.cpp
sdaftuar,2020-08-06 16:43:27,"I started to do this, but this doesn't exactly add to the readability of the code; can we punt on this to some future refactor, especially if we think existing refactors under way would change all this anyway?  \n\nIn practice there should be more than 25 unconfirmed parents anyway, and I wouldn't expect much lock contention either.",https://github.com/bitcoin/bitcoin/pull/19596#discussion_r466544580,466544580,src/net_processing.cpp
ajtowns,2020-08-06 18:34:22,Definitely seems fine to punt it to me,https://github.com/bitcoin/bitcoin/pull/19596#discussion_r466609070,466609070,src/net_processing.cpp
ajtowns,2020-08-06 18:36:47,"@jnewbery Accessing guarded data structures in a lambda means the lambda needs to be annotated with the required lock (or an AssertLockHeld or LockAssertion added cf #19668), or there will be compile time thread safety errors. Doesn't matter how limited the lambda's scope is.",https://github.com/bitcoin/bitcoin/pull/19596#discussion_r466610313,466610313,src/net_processing.cpp
