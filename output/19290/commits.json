[
  {
    "sha": "c3538f435af8c408759d9d005e80b2f1690e0659",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjMzUzOGY0MzVhZjhjNDA4NzU5ZDlkMDA1ZTgwYjJmMTY5MGUwNjU5",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-06-15T18:14:51Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-06-15T18:14:51Z"
      },
      "message": "walletdb: Make SpliWalletFilePath non-static",
      "tree": {
        "sha": "562a54d5315761ad943b65492f42d12ca3972a67",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/562a54d5315761ad943b65492f42d12ca3972a67"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c3538f435af8c408759d9d005e80b2f1690e0659",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c3538f435af8c408759d9d005e80b2f1690e0659",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c3538f435af8c408759d9d005e80b2f1690e0659",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c3538f435af8c408759d9d005e80b2f1690e0659/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1c86ed41483471929840eec09b93d7de3a4aeacf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1c86ed41483471929840eec09b93d7de3a4aeacf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1c86ed41483471929840eec09b93d7de3a4aeacf"
      }
    ],
    "stats": {
      "total": 3,
      "additions": 2,
      "deletions": 1
    },
    "files": [
      {
        "sha": "f694ffc71c4ab0490d3676ace390cb45a352202f",
        "filename": "src/wallet/db.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c3538f435af8c408759d9d005e80b2f1690e0659/src/wallet/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c3538f435af8c408759d9d005e80b2f1690e0659/src/wallet/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.cpp?ref=c3538f435af8c408759d9d005e80b2f1690e0659",
        "patch": "@@ -51,7 +51,7 @@ bool WalletDatabaseFileId::operator==(const WalletDatabaseFileId& rhs) const\n     return memcmp(value, &rhs.value, sizeof(value)) == 0;\n }\n \n-static void SplitWalletPath(const fs::path& wallet_path, fs::path& env_directory, std::string& database_filename)\n+void SplitWalletPath(const fs::path& wallet_path, fs::path& env_directory, std::string& database_filename)\n {\n     if (fs::is_regular_file(wallet_path)) {\n         // Special case for backwards compatibility: if wallet path points to an"
      },
      {
        "sha": "5041a7f916b711918ffee9b117e41506c05e39b6",
        "filename": "src/wallet/db.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c3538f435af8c408759d9d005e80b2f1690e0659/src/wallet/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c3538f435af8c408759d9d005e80b2f1690e0659/src/wallet/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.h?ref=c3538f435af8c408759d9d005e80b2f1690e0659",
        "patch": "@@ -91,6 +91,7 @@ bool IsWalletLoaded(const fs::path& wallet_path);\n \n /** Given a wallet directory path or legacy file path, return path to main data file in the wallet database. */\n fs::path WalletDataFilePath(const fs::path& wallet_path);\n+void SplitWalletPath(const fs::path& wallet_path, fs::path& env_directory, std::string& database_filename);\n \n /** Get BerkeleyEnvironment and database filename given a wallet path. */\n std::shared_ptr<BerkeleyEnvironment> GetWalletEnv(const fs::path& wallet_path, std::string& database_filename);"
      }
    ]
  },
  {
    "sha": "f6fc5f3849bac48dfccd015bec7089cb711d0667",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNmZjNWYzODQ5YmFjNDhkZmNjZDAxNWJlYzcwODljYjcxMWQwNjY3",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-05-13T23:31:40Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-06-15T21:36:06Z"
      },
      "message": "walletdb: Add IsBDBWalletLoaded to look for BDB wallets specifically",
      "tree": {
        "sha": "87481df4e470ed3da6be5b1397d20fea7b6f9c3f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/87481df4e470ed3da6be5b1397d20fea7b6f9c3f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f6fc5f3849bac48dfccd015bec7089cb711d0667",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f6fc5f3849bac48dfccd015bec7089cb711d0667",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f6fc5f3849bac48dfccd015bec7089cb711d0667",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f6fc5f3849bac48dfccd015bec7089cb711d0667/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c3538f435af8c408759d9d005e80b2f1690e0659",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c3538f435af8c408759d9d005e80b2f1690e0659",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c3538f435af8c408759d9d005e80b2f1690e0659"
      }
    ],
    "stats": {
      "total": 8,
      "additions": 7,
      "deletions": 1
    },
    "files": [
      {
        "sha": "11b5992d801d349d17624291521c2667f3f073d7",
        "filename": "src/wallet/db.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f6fc5f3849bac48dfccd015bec7089cb711d0667/src/wallet/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f6fc5f3849bac48dfccd015bec7089cb711d0667/src/wallet/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.cpp?ref=f6fc5f3849bac48dfccd015bec7089cb711d0667",
        "patch": "@@ -67,7 +67,7 @@ void SplitWalletPath(const fs::path& wallet_path, fs::path& env_directory, std::\n     }\n }\n \n-bool IsWalletLoaded(const fs::path& wallet_path)\n+bool IsBDBWalletLoaded(const fs::path& wallet_path)\n {\n     fs::path env_directory;\n     std::string database_filename;\n@@ -79,6 +79,11 @@ bool IsWalletLoaded(const fs::path& wallet_path)\n     return database && database->IsDatabaseLoaded(database_filename);\n }\n \n+bool IsWalletLoaded(const fs::path& wallet_path)\n+{\n+    return IsBDBWalletLoaded(wallet_path);\n+}\n+\n fs::path WalletDataFilePath(const fs::path& wallet_path)\n {\n     fs::path env_directory;"
      },
      {
        "sha": "bc4b361c119342bdf5849470f8726e188d2236be",
        "filename": "src/wallet/db.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f6fc5f3849bac48dfccd015bec7089cb711d0667/src/wallet/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f6fc5f3849bac48dfccd015bec7089cb711d0667/src/wallet/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.h?ref=f6fc5f3849bac48dfccd015bec7089cb711d0667",
        "patch": "@@ -87,6 +87,7 @@ class BerkeleyEnvironment\n };\n \n /** Return whether a wallet database is currently loaded. */\n+bool IsBDBWalletLoaded(const fs::path& wallet_path);\n bool IsWalletLoaded(const fs::path& wallet_path);\n \n /** Given a wallet directory path or legacy file path, return path to main data file in the wallet database. */"
      }
    ]
  },
  {
    "sha": "25a655794a0c495332dadedd88b87d694c1077c2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNWE2NTU3OTRhMGM0OTUzMzJkYWRlZGQ4OGI4N2Q2OTRjMTA3N2My",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-06-15T20:10:08Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-06-15T21:36:08Z"
      },
      "message": "walletdb: move IsWalletLoaded to walletdb.cpp",
      "tree": {
        "sha": "fcab4b1e55e2d8018b125a83944579a702963094",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fcab4b1e55e2d8018b125a83944579a702963094"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/25a655794a0c495332dadedd88b87d694c1077c2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/25a655794a0c495332dadedd88b87d694c1077c2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/25a655794a0c495332dadedd88b87d694c1077c2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/25a655794a0c495332dadedd88b87d694c1077c2/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f6fc5f3849bac48dfccd015bec7089cb711d0667",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f6fc5f3849bac48dfccd015bec7089cb711d0667",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f6fc5f3849bac48dfccd015bec7089cb711d0667"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 8,
      "deletions": 6
    },
    "files": [
      {
        "sha": "99ad963f9a2f9190040bc70c77c166780e221441",
        "filename": "src/wallet/db.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/25a655794a0c495332dadedd88b87d694c1077c2/src/wallet/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/25a655794a0c495332dadedd88b87d694c1077c2/src/wallet/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.cpp?ref=25a655794a0c495332dadedd88b87d694c1077c2",
        "patch": "@@ -79,11 +79,6 @@ bool IsBDBWalletLoaded(const fs::path& wallet_path)\n     return database && database->IsDatabaseLoaded(database_filename);\n }\n \n-bool IsWalletLoaded(const fs::path& wallet_path)\n-{\n-    return IsBDBWalletLoaded(wallet_path);\n-}\n-\n fs::path WalletDataFilePath(const fs::path& wallet_path)\n {\n     fs::path env_directory;"
      },
      {
        "sha": "3c7c4c1255e27ee639324b342c6e2ebb581853f4",
        "filename": "src/wallet/db.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/25a655794a0c495332dadedd88b87d694c1077c2/src/wallet/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/25a655794a0c495332dadedd88b87d694c1077c2/src/wallet/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.h?ref=25a655794a0c495332dadedd88b87d694c1077c2",
        "patch": "@@ -88,7 +88,6 @@ class BerkeleyEnvironment\n \n /** Return whether a wallet database is currently loaded. */\n bool IsBDBWalletLoaded(const fs::path& wallet_path);\n-bool IsWalletLoaded(const fs::path& wallet_path);\n \n /** Given a wallet directory path or legacy file path, return path to main data file in the wallet database. */\n fs::path WalletDataFilePath(const fs::path& wallet_path);"
      },
      {
        "sha": "2f6c2b883aca520d3a94b248fc989b4d72d98573",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/25a655794a0c495332dadedd88b87d694c1077c2/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/25a655794a0c495332dadedd88b87d694c1077c2/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=25a655794a0c495332dadedd88b87d694c1077c2",
        "patch": "@@ -1018,3 +1018,8 @@ bool WalletBatch::TxnAbort()\n {\n     return m_batch.TxnAbort();\n }\n+\n+bool IsWalletLoaded(const fs::path& wallet_path)\n+{\n+    return IsBDBWalletLoaded(wallet_path);\n+}"
      },
      {
        "sha": "74ab144177c4b13746d9bccaa8e506a62657cbdf",
        "filename": "src/wallet/walletdb.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/25a655794a0c495332dadedd88b87d694c1077c2/src/wallet/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/25a655794a0c495332dadedd88b87d694c1077c2/src/wallet/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.h?ref=25a655794a0c495332dadedd88b87d694c1077c2",
        "patch": "@@ -289,4 +289,7 @@ void MaybeCompactWalletDB();\n //! Unserialize a given Key-Value pair and load it into the wallet\n bool ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strType, std::string& strErr);\n \n+/** Return whether a wallet database is currently loaded. */\n+bool IsWalletLoaded(const fs::path& wallet_path);\n+\n #endif // BITCOIN_WALLET_WALLETDB_H"
      }
    ]
  },
  {
    "sha": "8f033642a8c6874184e297b97b951b9bd12ffd75",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4ZjAzMzY0MmE4YzY4NzQxODRlMjk3Yjk3Yjk1MWI5YmQxMmZmZDc1",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-06-16T00:34:25Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-06-16T00:35:39Z"
      },
      "message": "walletdb: moveonly: Move BerkeleyBatch Cursor and Txn funcs to cpp\n\nPut the implementation in the cpp, not the h file.",
      "tree": {
        "sha": "0165173767e58873341b247e11b2f8d23f331275",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0165173767e58873341b247e11b2f8d23f331275"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8f033642a8c6874184e297b97b951b9bd12ffd75",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8f033642a8c6874184e297b97b951b9bd12ffd75",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8f033642a8c6874184e297b97b951b9bd12ffd75",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8f033642a8c6874184e297b97b951b9bd12ffd75/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "25a655794a0c495332dadedd88b87d694c1077c2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/25a655794a0c495332dadedd88b87d694c1077c2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/25a655794a0c495332dadedd88b87d694c1077c2"
      }
    ],
    "stats": {
      "total": 126,
      "additions": 66,
      "deletions": 60
    },
    "files": [
      {
        "sha": "5bf3f6dff6ea657a30e018a5a560e818a406aae6",
        "filename": "src/wallet/db.cpp",
        "status": "modified",
        "additions": 61,
        "deletions": 0,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f033642a8c6874184e297b97b951b9bd12ffd75/src/wallet/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f033642a8c6874184e297b97b951b9bd12ffd75/src/wallet/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.cpp?ref=8f033642a8c6874184e297b97b951b9bd12ffd75",
        "patch": "@@ -761,6 +761,67 @@ void BerkeleyDatabase::ReloadDbEnv()\n     }\n }\n \n+Dbc* BerkeleyBatch::GetCursor()\n+{\n+    if (!pdb)\n+        return nullptr;\n+    Dbc* pcursor = nullptr;\n+    int ret = pdb->cursor(nullptr, &pcursor, 0);\n+    if (ret != 0)\n+        return nullptr;\n+    return pcursor;\n+}\n+\n+int BerkeleyBatch::ReadAtCursor(Dbc* pcursor, CDataStream& ssKey, CDataStream& ssValue)\n+{\n+    // Read at cursor\n+    SafeDbt datKey;\n+    SafeDbt datValue;\n+    int ret = pcursor->get(datKey, datValue, DB_NEXT);\n+    if (ret != 0)\n+        return ret;\n+    else if (datKey.get_data() == nullptr || datValue.get_data() == nullptr)\n+        return 99999;\n+\n+    // Convert to streams\n+    ssKey.SetType(SER_DISK);\n+    ssKey.clear();\n+    ssKey.write((char*)datKey.get_data(), datKey.get_size());\n+    ssValue.SetType(SER_DISK);\n+    ssValue.clear();\n+    ssValue.write((char*)datValue.get_data(), datValue.get_size());\n+    return 0;\n+}\n+\n+bool BerkeleyBatch::TxnBegin()\n+{\n+    if (!pdb || activeTxn)\n+        return false;\n+    DbTxn* ptxn = env->TxnBegin();\n+    if (!ptxn)\n+        return false;\n+    activeTxn = ptxn;\n+    return true;\n+}\n+\n+bool BerkeleyBatch::TxnCommit()\n+{\n+    if (!pdb || !activeTxn)\n+        return false;\n+    int ret = activeTxn->commit(0);\n+    activeTxn = nullptr;\n+    return (ret == 0);\n+}\n+\n+bool BerkeleyBatch::TxnAbort()\n+{\n+    if (!pdb || !activeTxn)\n+        return false;\n+    int ret = activeTxn->abort();\n+    activeTxn = nullptr;\n+    return (ret == 0);\n+}\n+\n std::string BerkeleyDatabaseVersion()\n {\n     return DbEnv::version(nullptr, nullptr, nullptr);"
      },
      {
        "sha": "d8a3087306423af4851cd947c086602edf9102ff",
        "filename": "src/wallet/db.h",
        "status": "modified",
        "additions": 5,
        "deletions": 60,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f033642a8c6874184e297b97b951b9bd12ffd75/src/wallet/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f033642a8c6874184e297b97b951b9bd12ffd75/src/wallet/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.h?ref=8f033642a8c6874184e297b97b951b9bd12ffd75",
        "patch": "@@ -326,66 +326,11 @@ class BerkeleyBatch\n         return (ret == 0);\n     }\n \n-    Dbc* GetCursor()\n-    {\n-        if (!pdb)\n-            return nullptr;\n-        Dbc* pcursor = nullptr;\n-        int ret = pdb->cursor(nullptr, &pcursor, 0);\n-        if (ret != 0)\n-            return nullptr;\n-        return pcursor;\n-    }\n-\n-    int ReadAtCursor(Dbc* pcursor, CDataStream& ssKey, CDataStream& ssValue)\n-    {\n-        // Read at cursor\n-        SafeDbt datKey;\n-        SafeDbt datValue;\n-        int ret = pcursor->get(datKey, datValue, DB_NEXT);\n-        if (ret != 0)\n-            return ret;\n-        else if (datKey.get_data() == nullptr || datValue.get_data() == nullptr)\n-            return 99999;\n-\n-        // Convert to streams\n-        ssKey.SetType(SER_DISK);\n-        ssKey.clear();\n-        ssKey.write((char*)datKey.get_data(), datKey.get_size());\n-        ssValue.SetType(SER_DISK);\n-        ssValue.clear();\n-        ssValue.write((char*)datValue.get_data(), datValue.get_size());\n-        return 0;\n-    }\n-\n-    bool TxnBegin()\n-    {\n-        if (!pdb || activeTxn)\n-            return false;\n-        DbTxn* ptxn = env->TxnBegin();\n-        if (!ptxn)\n-            return false;\n-        activeTxn = ptxn;\n-        return true;\n-    }\n-\n-    bool TxnCommit()\n-    {\n-        if (!pdb || !activeTxn)\n-            return false;\n-        int ret = activeTxn->commit(0);\n-        activeTxn = nullptr;\n-        return (ret == 0);\n-    }\n-\n-    bool TxnAbort()\n-    {\n-        if (!pdb || !activeTxn)\n-            return false;\n-        int ret = activeTxn->abort();\n-        activeTxn = nullptr;\n-        return (ret == 0);\n-    }\n+    Dbc* GetCursor();\n+    int ReadAtCursor(Dbc* pcursor, CDataStream& ssKey, CDataStream& ssValue);\n+    bool TxnBegin();\n+    bool TxnCommit();\n+    bool TxnAbort();\n \n     bool static Rewrite(BerkeleyDatabase& database, const char* pszSkip = nullptr);\n };"
      }
    ]
  },
  {
    "sha": "61c16339da4e80b1320a6296df6d96cd7a84bb4e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MWMxNjMzOWRhNGU4MGIxMzIwYTYyOTZkZjZkOTZjZDdhODRiYjRl",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-06-15T18:29:29Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2020-06-16T00:41:05Z"
      },
      "message": "walletdb: Move BDB specific things into bdb.{cpp/h}\n\nLeave wallet/db.{cpp/h} for generic WalletDatabase stuff. The BDB\nspecific stuff goes into bdb.{cpp/h}",
      "tree": {
        "sha": "0c2dd92af7fe30748a01f040d534853aa1464c1e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0c2dd92af7fe30748a01f040d534853aa1464c1e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/61c16339da4e80b1320a6296df6d96cd7a84bb4e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/61c16339da4e80b1320a6296df6d96cd7a84bb4e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/61c16339da4e80b1320a6296df6d96cd7a84bb4e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/61c16339da4e80b1320a6296df6d96cd7a84bb4e/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8f033642a8c6874184e297b97b951b9bd12ffd75",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8f033642a8c6874184e297b97b951b9bd12ffd75",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8f033642a8c6874184e297b97b951b9bd12ffd75"
      }
    ],
    "stats": {
      "total": 2270,
      "additions": 1149,
      "deletions": 1121
    },
    "files": [
      {
        "sha": "a33ff8a46183c7d80961780955856870b55a33bb",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/61c16339da4e80b1320a6296df6d96cd7a84bb4e/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/61c16339da4e80b1320a6296df6d96cd7a84bb4e/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=61c16339da4e80b1320a6296df6d96cd7a84bb4e",
        "patch": "@@ -240,6 +240,7 @@ BITCOIN_CORE_H = \\\n   versionbits.h \\\n   versionbitsinfo.h \\\n   walletinitinterface.h \\\n+  wallet/bdb.h \\\n   wallet/coincontrol.h \\\n   wallet/context.h \\\n   wallet/crypter.h \\\n@@ -350,6 +351,7 @@ libbitcoin_wallet_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n libbitcoin_wallet_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_wallet_a_SOURCES = \\\n   interfaces/wallet.cpp \\\n+  wallet/bdb.cpp \\\n   wallet/coincontrol.cpp \\\n   wallet/context.cpp \\\n   wallet/crypter.cpp \\"
      },
      {
        "sha": "dafd517ca840b0fefde9bb4e913eb537aa0e1d85",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/61c16339da4e80b1320a6296df6d96cd7a84bb4e/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/61c16339da4e80b1320a6296df6d96cd7a84bb4e/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=61c16339da4e80b1320a6296df6d96cd7a84bb4e",
        "patch": "@@ -24,6 +24,7 @@\n #include <univalue.h>\n \n #ifdef ENABLE_WALLET\n+#include <wallet/bdb.h>\n #include <wallet/db.h>\n #include <wallet/wallet.h>\n #endif"
      },
      {
        "sha": "7ed9c88122aa70c9e93f39ccbe967289e22746ea",
        "filename": "src/wallet/bdb.cpp",
        "status": "added",
        "additions": 805,
        "deletions": 0,
        "changes": 805,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/61c16339da4e80b1320a6296df6d96cd7a84bb4e/src/wallet/bdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/61c16339da4e80b1320a6296df6d96cd7a84bb4e/src/wallet/bdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/bdb.cpp?ref=61c16339da4e80b1320a6296df6d96cd7a84bb4e",
        "patch": "@@ -0,0 +1,805 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <wallet/bdb.h>\n+#include <wallet/db.h>\n+\n+#include <util/strencodings.h>\n+#include <util/translation.h>\n+\n+#include <stdint.h>\n+\n+#ifndef WIN32\n+#include <sys/stat.h>\n+#endif\n+\n+namespace {\n+\n+//! Make sure database has a unique fileid within the environment. If it\n+//! doesn't, throw an error. BDB caches do not work properly when more than one\n+//! open database has the same fileid (values written to one database may show\n+//! up in reads to other databases).\n+//!\n+//! BerkeleyDB generates unique fileids by default\n+//! (https://docs.oracle.com/cd/E17275_01/html/programmer_reference/program_copy.html),\n+//! so bitcoin should never create different databases with the same fileid, but\n+//! this error can be triggered if users manually copy database files.\n+void CheckUniqueFileid(const BerkeleyEnvironment& env, const std::string& filename, Db& db, WalletDatabaseFileId& fileid)\n+{\n+    if (env.IsMock()) return;\n+\n+    int ret = db.get_mpf()->get_fileid(fileid.value);\n+    if (ret != 0) {\n+        throw std::runtime_error(strprintf(\"BerkeleyBatch: Can't open database %s (get_fileid failed with %d)\", filename, ret));\n+    }\n+\n+    for (const auto& item : env.m_fileids) {\n+        if (fileid == item.second && &fileid != &item.second) {\n+            throw std::runtime_error(strprintf(\"BerkeleyBatch: Can't open database %s (duplicates fileid %s from %s)\", filename,\n+                HexStr(std::begin(item.second.value), std::end(item.second.value)), item.first));\n+        }\n+    }\n+}\n+\n+RecursiveMutex cs_db;\n+std::map<std::string, std::weak_ptr<BerkeleyEnvironment>> g_dbenvs GUARDED_BY(cs_db); //!< Map from directory name to db environment.\n+} // namespace\n+\n+bool WalletDatabaseFileId::operator==(const WalletDatabaseFileId& rhs) const\n+{\n+    return memcmp(value, &rhs.value, sizeof(value)) == 0;\n+}\n+\n+bool IsBDBWalletLoaded(const fs::path& wallet_path)\n+{\n+    fs::path env_directory;\n+    std::string database_filename;\n+    SplitWalletPath(wallet_path, env_directory, database_filename);\n+    LOCK(cs_db);\n+    auto env = g_dbenvs.find(env_directory.string());\n+    if (env == g_dbenvs.end()) return false;\n+    auto database = env->second.lock();\n+    return database && database->IsDatabaseLoaded(database_filename);\n+}\n+\n+/**\n+ * @param[in] wallet_path Path to wallet directory. Or (for backwards compatibility only) a path to a berkeley btree data file inside a wallet directory.\n+ * @param[out] database_filename Filename of berkeley btree data file inside the wallet directory.\n+ * @return A shared pointer to the BerkeleyEnvironment object for the wallet directory, never empty because ~BerkeleyEnvironment\n+ * erases the weak pointer from the g_dbenvs map.\n+ * @post A new BerkeleyEnvironment weak pointer is inserted into g_dbenvs if the directory path key was not already in the map.\n+ */\n+std::shared_ptr<BerkeleyEnvironment> GetWalletEnv(const fs::path& wallet_path, std::string& database_filename)\n+{\n+    fs::path env_directory;\n+    SplitWalletPath(wallet_path, env_directory, database_filename);\n+    LOCK(cs_db);\n+    auto inserted = g_dbenvs.emplace(env_directory.string(), std::weak_ptr<BerkeleyEnvironment>());\n+    if (inserted.second) {\n+        auto env = std::make_shared<BerkeleyEnvironment>(env_directory.string());\n+        inserted.first->second = env;\n+        return env;\n+    }\n+    return inserted.first->second.lock();\n+}\n+\n+//\n+// BerkeleyBatch\n+//\n+\n+void BerkeleyEnvironment::Close()\n+{\n+    if (!fDbEnvInit)\n+        return;\n+\n+    fDbEnvInit = false;\n+\n+    for (auto& db : m_databases) {\n+        auto count = mapFileUseCount.find(db.first);\n+        assert(count == mapFileUseCount.end() || count->second == 0);\n+        BerkeleyDatabase& database = db.second.get();\n+        if (database.m_db) {\n+            database.m_db->close(0);\n+            database.m_db.reset();\n+        }\n+    }\n+\n+    FILE* error_file = nullptr;\n+    dbenv->get_errfile(&error_file);\n+\n+    int ret = dbenv->close(0);\n+    if (ret != 0)\n+        LogPrintf(\"BerkeleyEnvironment::Close: Error %d closing database environment: %s\\n\", ret, DbEnv::strerror(ret));\n+    if (!fMockDb)\n+        DbEnv((u_int32_t)0).remove(strPath.c_str(), 0);\n+\n+    if (error_file) fclose(error_file);\n+\n+    UnlockDirectory(strPath, \".walletlock\");\n+}\n+\n+void BerkeleyEnvironment::Reset()\n+{\n+    dbenv.reset(new DbEnv(DB_CXX_NO_EXCEPTIONS));\n+    fDbEnvInit = false;\n+    fMockDb = false;\n+}\n+\n+BerkeleyEnvironment::BerkeleyEnvironment(const fs::path& dir_path) : strPath(dir_path.string())\n+{\n+    Reset();\n+}\n+\n+BerkeleyEnvironment::~BerkeleyEnvironment()\n+{\n+    LOCK(cs_db);\n+    g_dbenvs.erase(strPath);\n+    Close();\n+}\n+\n+bool BerkeleyEnvironment::Open(bool retry)\n+{\n+    if (fDbEnvInit) {\n+        return true;\n+    }\n+\n+    fs::path pathIn = strPath;\n+    TryCreateDirectories(pathIn);\n+    if (!LockDirectory(pathIn, \".walletlock\")) {\n+        LogPrintf(\"Cannot obtain a lock on wallet directory %s. Another instance of bitcoin may be using it.\\n\", strPath);\n+        return false;\n+    }\n+\n+    fs::path pathLogDir = pathIn / \"database\";\n+    TryCreateDirectories(pathLogDir);\n+    fs::path pathErrorFile = pathIn / \"db.log\";\n+    LogPrintf(\"BerkeleyEnvironment::Open: LogDir=%s ErrorFile=%s\\n\", pathLogDir.string(), pathErrorFile.string());\n+\n+    unsigned int nEnvFlags = 0;\n+    if (gArgs.GetBoolArg(\"-privdb\", DEFAULT_WALLET_PRIVDB))\n+        nEnvFlags |= DB_PRIVATE;\n+\n+    dbenv->set_lg_dir(pathLogDir.string().c_str());\n+    dbenv->set_cachesize(0, 0x100000, 1); // 1 MiB should be enough for just the wallet\n+    dbenv->set_lg_bsize(0x10000);\n+    dbenv->set_lg_max(1048576);\n+    dbenv->set_lk_max_locks(40000);\n+    dbenv->set_lk_max_objects(40000);\n+    dbenv->set_errfile(fsbridge::fopen(pathErrorFile, \"a\")); /// debug\n+    dbenv->set_flags(DB_AUTO_COMMIT, 1);\n+    dbenv->set_flags(DB_TXN_WRITE_NOSYNC, 1);\n+    dbenv->log_set_config(DB_LOG_AUTO_REMOVE, 1);\n+    int ret = dbenv->open(strPath.c_str(),\n+                         DB_CREATE |\n+                             DB_INIT_LOCK |\n+                             DB_INIT_LOG |\n+                             DB_INIT_MPOOL |\n+                             DB_INIT_TXN |\n+                             DB_THREAD |\n+                             DB_RECOVER |\n+                             nEnvFlags,\n+                         S_IRUSR | S_IWUSR);\n+    if (ret != 0) {\n+        LogPrintf(\"BerkeleyEnvironment::Open: Error %d opening database environment: %s\\n\", ret, DbEnv::strerror(ret));\n+        int ret2 = dbenv->close(0);\n+        if (ret2 != 0) {\n+            LogPrintf(\"BerkeleyEnvironment::Open: Error %d closing failed database environment: %s\\n\", ret2, DbEnv::strerror(ret2));\n+        }\n+        Reset();\n+        if (retry) {\n+            // try moving the database env out of the way\n+            fs::path pathDatabaseBak = pathIn / strprintf(\"database.%d.bak\", GetTime());\n+            try {\n+                fs::rename(pathLogDir, pathDatabaseBak);\n+                LogPrintf(\"Moved old %s to %s. Retrying.\\n\", pathLogDir.string(), pathDatabaseBak.string());\n+            } catch (const fs::filesystem_error&) {\n+                // failure is ok (well, not really, but it's not worse than what we started with)\n+            }\n+            // try opening it again one more time\n+            if (!Open(false /* retry */)) {\n+                // if it still fails, it probably means we can't even create the database env\n+                return false;\n+            }\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    fDbEnvInit = true;\n+    fMockDb = false;\n+    return true;\n+}\n+\n+//! Construct an in-memory mock Berkeley environment for testing\n+BerkeleyEnvironment::BerkeleyEnvironment()\n+{\n+    Reset();\n+\n+    LogPrint(BCLog::WALLETDB, \"BerkeleyEnvironment::MakeMock\\n\");\n+\n+    dbenv->set_cachesize(1, 0, 1);\n+    dbenv->set_lg_bsize(10485760 * 4);\n+    dbenv->set_lg_max(10485760);\n+    dbenv->set_lk_max_locks(10000);\n+    dbenv->set_lk_max_objects(10000);\n+    dbenv->set_flags(DB_AUTO_COMMIT, 1);\n+    dbenv->log_set_config(DB_LOG_IN_MEMORY, 1);\n+    int ret = dbenv->open(nullptr,\n+                         DB_CREATE |\n+                             DB_INIT_LOCK |\n+                             DB_INIT_LOG |\n+                             DB_INIT_MPOOL |\n+                             DB_INIT_TXN |\n+                             DB_THREAD |\n+                             DB_PRIVATE,\n+                         S_IRUSR | S_IWUSR);\n+    if (ret > 0) {\n+        throw std::runtime_error(strprintf(\"BerkeleyEnvironment::MakeMock: Error %d opening database environment.\", ret));\n+    }\n+\n+    fDbEnvInit = true;\n+    fMockDb = true;\n+}\n+\n+bool BerkeleyEnvironment::Verify(const std::string& strFile)\n+{\n+    LOCK(cs_db);\n+    assert(mapFileUseCount.count(strFile) == 0);\n+\n+    Db db(dbenv.get(), 0);\n+    int result = db.verify(strFile.c_str(), nullptr, nullptr, 0);\n+    return result == 0;\n+}\n+\n+BerkeleyBatch::SafeDbt::SafeDbt()\n+{\n+    m_dbt.set_flags(DB_DBT_MALLOC);\n+}\n+\n+BerkeleyBatch::SafeDbt::SafeDbt(void* data, size_t size)\n+    : m_dbt(data, size)\n+{\n+}\n+\n+BerkeleyBatch::SafeDbt::~SafeDbt()\n+{\n+    if (m_dbt.get_data() != nullptr) {\n+        // Clear memory, e.g. in case it was a private key\n+        memory_cleanse(m_dbt.get_data(), m_dbt.get_size());\n+        // under DB_DBT_MALLOC, data is malloced by the Dbt, but must be\n+        // freed by the caller.\n+        // https://docs.oracle.com/cd/E17275_01/html/api_reference/C/dbt.html\n+        if (m_dbt.get_flags() & DB_DBT_MALLOC) {\n+            free(m_dbt.get_data());\n+        }\n+    }\n+}\n+\n+const void* BerkeleyBatch::SafeDbt::get_data() const\n+{\n+    return m_dbt.get_data();\n+}\n+\n+u_int32_t BerkeleyBatch::SafeDbt::get_size() const\n+{\n+    return m_dbt.get_size();\n+}\n+\n+BerkeleyBatch::SafeDbt::operator Dbt*()\n+{\n+    return &m_dbt;\n+}\n+\n+bool BerkeleyBatch::VerifyEnvironment(const fs::path& file_path, bilingual_str& errorStr)\n+{\n+    std::string walletFile;\n+    std::shared_ptr<BerkeleyEnvironment> env = GetWalletEnv(file_path, walletFile);\n+    fs::path walletDir = env->Directory();\n+\n+    LogPrintf(\"Using BerkeleyDB version %s\\n\", BerkeleyDatabaseVersion());\n+    LogPrintf(\"Using wallet %s\\n\", file_path.string());\n+\n+    if (!env->Open(true /* retry */)) {\n+        errorStr = strprintf(_(\"Error initializing wallet database environment %s!\"), walletDir);\n+        return false;\n+    }\n+\n+    return true;\n+}\n+\n+bool BerkeleyBatch::VerifyDatabaseFile(const fs::path& file_path, bilingual_str& errorStr)\n+{\n+    std::string walletFile;\n+    std::shared_ptr<BerkeleyEnvironment> env = GetWalletEnv(file_path, walletFile);\n+    fs::path walletDir = env->Directory();\n+\n+    if (fs::exists(walletDir / walletFile))\n+    {\n+        if (!env->Verify(walletFile)) {\n+            errorStr = strprintf(_(\"%s corrupt. Try using the wallet tool bitcoin-wallet to salvage or restoring a backup.\"), walletFile);\n+            return false;\n+        }\n+    }\n+    // also return true if files does not exists\n+    return true;\n+}\n+\n+void BerkeleyEnvironment::CheckpointLSN(const std::string& strFile)\n+{\n+    dbenv->txn_checkpoint(0, 0, 0);\n+    if (fMockDb)\n+        return;\n+    dbenv->lsn_reset(strFile.c_str(), 0);\n+}\n+\n+\n+BerkeleyBatch::BerkeleyBatch(BerkeleyDatabase& database, const char* pszMode, bool fFlushOnCloseIn) : pdb(nullptr), activeTxn(nullptr)\n+{\n+    fReadOnly = (!strchr(pszMode, '+') && !strchr(pszMode, 'w'));\n+    fFlushOnClose = fFlushOnCloseIn;\n+    env = database.env.get();\n+    if (database.IsDummy()) {\n+        return;\n+    }\n+    const std::string &strFilename = database.strFile;\n+\n+    bool fCreate = strchr(pszMode, 'c') != nullptr;\n+    unsigned int nFlags = DB_THREAD;\n+    if (fCreate)\n+        nFlags |= DB_CREATE;\n+\n+    {\n+        LOCK(cs_db);\n+        if (!env->Open(false /* retry */))\n+            throw std::runtime_error(\"BerkeleyBatch: Failed to open database environment.\");\n+\n+        pdb = database.m_db.get();\n+        if (pdb == nullptr) {\n+            int ret;\n+            std::unique_ptr<Db> pdb_temp = MakeUnique<Db>(env->dbenv.get(), 0);\n+\n+            bool fMockDb = env->IsMock();\n+            if (fMockDb) {\n+                DbMpoolFile* mpf = pdb_temp->get_mpf();\n+                ret = mpf->set_flags(DB_MPOOL_NOFILE, 1);\n+                if (ret != 0) {\n+                    throw std::runtime_error(strprintf(\"BerkeleyBatch: Failed to configure for no temp file backing for database %s\", strFilename));\n+                }\n+            }\n+\n+            ret = pdb_temp->open(nullptr,                             // Txn pointer\n+                            fMockDb ? nullptr : strFilename.c_str(),  // Filename\n+                            fMockDb ? strFilename.c_str() : \"main\",   // Logical db name\n+                            DB_BTREE,                                 // Database type\n+                            nFlags,                                   // Flags\n+                            0);\n+\n+            if (ret != 0) {\n+                throw std::runtime_error(strprintf(\"BerkeleyBatch: Error %d, can't open database %s\", ret, strFilename));\n+            }\n+\n+            // Call CheckUniqueFileid on the containing BDB environment to\n+            // avoid BDB data consistency bugs that happen when different data\n+            // files in the same environment have the same fileid.\n+            //\n+            // Also call CheckUniqueFileid on all the other g_dbenvs to prevent\n+            // bitcoin from opening the same data file through another\n+            // environment when the file is referenced through equivalent but\n+            // not obviously identical symlinked or hard linked or bind mounted\n+            // paths. In the future a more relaxed check for equal inode and\n+            // device ids could be done instead, which would allow opening\n+            // different backup copies of a wallet at the same time. Maybe even\n+            // more ideally, an exclusive lock for accessing the database could\n+            // be implemented, so no equality checks are needed at all. (Newer\n+            // versions of BDB have an set_lk_exclusive method for this\n+            // purpose, but the older version we use does not.)\n+            for (const auto& env : g_dbenvs) {\n+                CheckUniqueFileid(*env.second.lock().get(), strFilename, *pdb_temp, this->env->m_fileids[strFilename]);\n+            }\n+\n+            pdb = pdb_temp.release();\n+            database.m_db.reset(pdb);\n+\n+            if (fCreate && !Exists(std::string(\"version\"))) {\n+                bool fTmp = fReadOnly;\n+                fReadOnly = false;\n+                Write(std::string(\"version\"), CLIENT_VERSION);\n+                fReadOnly = fTmp;\n+            }\n+        }\n+        ++env->mapFileUseCount[strFilename];\n+        strFile = strFilename;\n+    }\n+}\n+\n+void BerkeleyBatch::Flush()\n+{\n+    if (activeTxn)\n+        return;\n+\n+    // Flush database activity from memory pool to disk log\n+    unsigned int nMinutes = 0;\n+    if (fReadOnly)\n+        nMinutes = 1;\n+\n+    if (env) { // env is nullptr for dummy databases (i.e. in tests). Don't actually flush if env is nullptr so we don't segfault\n+        env->dbenv->txn_checkpoint(nMinutes ? gArgs.GetArg(\"-dblogsize\", DEFAULT_WALLET_DBLOGSIZE) * 1024 : 0, nMinutes, 0);\n+    }\n+}\n+\n+void BerkeleyDatabase::IncrementUpdateCounter()\n+{\n+    ++nUpdateCounter;\n+}\n+\n+void BerkeleyBatch::Close()\n+{\n+    if (!pdb)\n+        return;\n+    if (activeTxn)\n+        activeTxn->abort();\n+    activeTxn = nullptr;\n+    pdb = nullptr;\n+\n+    if (fFlushOnClose)\n+        Flush();\n+\n+    {\n+        LOCK(cs_db);\n+        --env->mapFileUseCount[strFile];\n+    }\n+    env->m_db_in_use.notify_all();\n+}\n+\n+void BerkeleyEnvironment::CloseDb(const std::string& strFile)\n+{\n+    {\n+        LOCK(cs_db);\n+        auto it = m_databases.find(strFile);\n+        assert(it != m_databases.end());\n+        BerkeleyDatabase& database = it->second.get();\n+        if (database.m_db) {\n+            // Close the database handle\n+            database.m_db->close(0);\n+            database.m_db.reset();\n+        }\n+    }\n+}\n+\n+void BerkeleyEnvironment::ReloadDbEnv()\n+{\n+    // Make sure that no Db's are in use\n+    AssertLockNotHeld(cs_db);\n+    std::unique_lock<RecursiveMutex> lock(cs_db);\n+    m_db_in_use.wait(lock, [this](){\n+        for (auto& count : mapFileUseCount) {\n+            if (count.second > 0) return false;\n+        }\n+        return true;\n+    });\n+\n+    std::vector<std::string> filenames;\n+    for (auto it : m_databases) {\n+        filenames.push_back(it.first);\n+    }\n+    // Close the individual Db's\n+    for (const std::string& filename : filenames) {\n+        CloseDb(filename);\n+    }\n+    // Reset the environment\n+    Flush(true); // This will flush and close the environment\n+    Reset();\n+    Open(true);\n+}\n+\n+bool BerkeleyBatch::Rewrite(BerkeleyDatabase& database, const char* pszSkip)\n+{\n+    if (database.IsDummy()) {\n+        return true;\n+    }\n+    BerkeleyEnvironment *env = database.env.get();\n+    const std::string& strFile = database.strFile;\n+    while (true) {\n+        {\n+            LOCK(cs_db);\n+            if (!env->mapFileUseCount.count(strFile) || env->mapFileUseCount[strFile] == 0) {\n+                // Flush log data to the dat file\n+                env->CloseDb(strFile);\n+                env->CheckpointLSN(strFile);\n+                env->mapFileUseCount.erase(strFile);\n+\n+                bool fSuccess = true;\n+                LogPrintf(\"BerkeleyBatch::Rewrite: Rewriting %s...\\n\", strFile);\n+                std::string strFileRes = strFile + \".rewrite\";\n+                { // surround usage of db with extra {}\n+                    BerkeleyBatch db(database, \"r\");\n+                    std::unique_ptr<Db> pdbCopy = MakeUnique<Db>(env->dbenv.get(), 0);\n+\n+                    int ret = pdbCopy->open(nullptr,               // Txn pointer\n+                                            strFileRes.c_str(), // Filename\n+                                            \"main\",             // Logical db name\n+                                            DB_BTREE,           // Database type\n+                                            DB_CREATE,          // Flags\n+                                            0);\n+                    if (ret > 0) {\n+                        LogPrintf(\"BerkeleyBatch::Rewrite: Can't create database file %s\\n\", strFileRes);\n+                        fSuccess = false;\n+                    }\n+\n+                    Dbc* pcursor = db.GetCursor();\n+                    if (pcursor)\n+                        while (fSuccess) {\n+                            CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+                            CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n+                            int ret1 = db.ReadAtCursor(pcursor, ssKey, ssValue);\n+                            if (ret1 == DB_NOTFOUND) {\n+                                pcursor->close();\n+                                break;\n+                            } else if (ret1 != 0) {\n+                                pcursor->close();\n+                                fSuccess = false;\n+                                break;\n+                            }\n+                            if (pszSkip &&\n+                                strncmp(ssKey.data(), pszSkip, std::min(ssKey.size(), strlen(pszSkip))) == 0)\n+                                continue;\n+                            if (strncmp(ssKey.data(), \"\\x07version\", 8) == 0) {\n+                                // Update version:\n+                                ssValue.clear();\n+                                ssValue << CLIENT_VERSION;\n+                            }\n+                            Dbt datKey(ssKey.data(), ssKey.size());\n+                            Dbt datValue(ssValue.data(), ssValue.size());\n+                            int ret2 = pdbCopy->put(nullptr, &datKey, &datValue, DB_NOOVERWRITE);\n+                            if (ret2 > 0)\n+                                fSuccess = false;\n+                        }\n+                    if (fSuccess) {\n+                        db.Close();\n+                        env->CloseDb(strFile);\n+                        if (pdbCopy->close(0))\n+                            fSuccess = false;\n+                    } else {\n+                        pdbCopy->close(0);\n+                    }\n+                }\n+                if (fSuccess) {\n+                    Db dbA(env->dbenv.get(), 0);\n+                    if (dbA.remove(strFile.c_str(), nullptr, 0))\n+                        fSuccess = false;\n+                    Db dbB(env->dbenv.get(), 0);\n+                    if (dbB.rename(strFileRes.c_str(), nullptr, strFile.c_str(), 0))\n+                        fSuccess = false;\n+                }\n+                if (!fSuccess)\n+                    LogPrintf(\"BerkeleyBatch::Rewrite: Failed to rewrite database file %s\\n\", strFileRes);\n+                return fSuccess;\n+            }\n+        }\n+        UninterruptibleSleep(std::chrono::milliseconds{100});\n+    }\n+}\n+\n+\n+void BerkeleyEnvironment::Flush(bool fShutdown)\n+{\n+    int64_t nStart = GetTimeMillis();\n+    // Flush log data to the actual data file on all files that are not in use\n+    LogPrint(BCLog::WALLETDB, \"BerkeleyEnvironment::Flush: [%s] Flush(%s)%s\\n\", strPath, fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" database not started\");\n+    if (!fDbEnvInit)\n+        return;\n+    {\n+        LOCK(cs_db);\n+        std::map<std::string, int>::iterator mi = mapFileUseCount.begin();\n+        while (mi != mapFileUseCount.end()) {\n+            std::string strFile = (*mi).first;\n+            int nRefCount = (*mi).second;\n+            LogPrint(BCLog::WALLETDB, \"BerkeleyEnvironment::Flush: Flushing %s (refcount = %d)...\\n\", strFile, nRefCount);\n+            if (nRefCount == 0) {\n+                // Move log data to the dat file\n+                CloseDb(strFile);\n+                LogPrint(BCLog::WALLETDB, \"BerkeleyEnvironment::Flush: %s checkpoint\\n\", strFile);\n+                dbenv->txn_checkpoint(0, 0, 0);\n+                LogPrint(BCLog::WALLETDB, \"BerkeleyEnvironment::Flush: %s detach\\n\", strFile);\n+                if (!fMockDb)\n+                    dbenv->lsn_reset(strFile.c_str(), 0);\n+                LogPrint(BCLog::WALLETDB, \"BerkeleyEnvironment::Flush: %s closed\\n\", strFile);\n+                mapFileUseCount.erase(mi++);\n+            } else\n+                mi++;\n+        }\n+        LogPrint(BCLog::WALLETDB, \"BerkeleyEnvironment::Flush: Flush(%s)%s took %15dms\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" database not started\", GetTimeMillis() - nStart);\n+        if (fShutdown) {\n+            char** listp;\n+            if (mapFileUseCount.empty()) {\n+                dbenv->log_archive(&listp, DB_ARCH_REMOVE);\n+                Close();\n+                if (!fMockDb) {\n+                    fs::remove_all(fs::path(strPath) / \"database\");\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+bool BerkeleyBatch::PeriodicFlush(BerkeleyDatabase& database)\n+{\n+    if (database.IsDummy()) {\n+        return true;\n+    }\n+    bool ret = false;\n+    BerkeleyEnvironment *env = database.env.get();\n+    const std::string& strFile = database.strFile;\n+    TRY_LOCK(cs_db, lockDb);\n+    if (lockDb)\n+    {\n+        // Don't do this if any databases are in use\n+        int nRefCount = 0;\n+        std::map<std::string, int>::iterator mit = env->mapFileUseCount.begin();\n+        while (mit != env->mapFileUseCount.end())\n+        {\n+            nRefCount += (*mit).second;\n+            mit++;\n+        }\n+\n+        if (nRefCount == 0)\n+        {\n+            std::map<std::string, int>::iterator mi = env->mapFileUseCount.find(strFile);\n+            if (mi != env->mapFileUseCount.end())\n+            {\n+                LogPrint(BCLog::WALLETDB, \"Flushing %s\\n\", strFile);\n+                int64_t nStart = GetTimeMillis();\n+\n+                // Flush wallet file so it's self contained\n+                env->CloseDb(strFile);\n+                env->CheckpointLSN(strFile);\n+\n+                env->mapFileUseCount.erase(mi++);\n+                LogPrint(BCLog::WALLETDB, \"Flushed %s %dms\\n\", strFile, GetTimeMillis() - nStart);\n+                ret = true;\n+            }\n+        }\n+    }\n+\n+    return ret;\n+}\n+\n+bool BerkeleyDatabase::Rewrite(const char* pszSkip)\n+{\n+    return BerkeleyBatch::Rewrite(*this, pszSkip);\n+}\n+\n+bool BerkeleyDatabase::Backup(const std::string& strDest) const\n+{\n+    if (IsDummy()) {\n+        return false;\n+    }\n+    while (true)\n+    {\n+        {\n+            LOCK(cs_db);\n+            if (!env->mapFileUseCount.count(strFile) || env->mapFileUseCount[strFile] == 0)\n+            {\n+                // Flush log data to the dat file\n+                env->CloseDb(strFile);\n+                env->CheckpointLSN(strFile);\n+                env->mapFileUseCount.erase(strFile);\n+\n+                // Copy wallet file\n+                fs::path pathSrc = env->Directory() / strFile;\n+                fs::path pathDest(strDest);\n+                if (fs::is_directory(pathDest))\n+                    pathDest /= strFile;\n+\n+                try {\n+                    if (fs::equivalent(pathSrc, pathDest)) {\n+                        LogPrintf(\"cannot backup to wallet source file %s\\n\", pathDest.string());\n+                        return false;\n+                    }\n+\n+                    fs::copy_file(pathSrc, pathDest, fs::copy_option::overwrite_if_exists);\n+                    LogPrintf(\"copied %s to %s\\n\", strFile, pathDest.string());\n+                    return true;\n+                } catch (const fs::filesystem_error& e) {\n+                    LogPrintf(\"error copying %s to %s - %s\\n\", strFile, pathDest.string(), fsbridge::get_filesystem_error_message(e));\n+                    return false;\n+                }\n+            }\n+        }\n+        UninterruptibleSleep(std::chrono::milliseconds{100});\n+    }\n+}\n+\n+void BerkeleyDatabase::Flush(bool shutdown)\n+{\n+    if (!IsDummy()) {\n+        env->Flush(shutdown);\n+        if (shutdown) {\n+            LOCK(cs_db);\n+            g_dbenvs.erase(env->Directory().string());\n+            env = nullptr;\n+        } else {\n+            // TODO: To avoid g_dbenvs.erase erasing the environment prematurely after the\n+            // first database shutdown when multiple databases are open in the same\n+            // environment, should replace raw database `env` pointers with shared or weak\n+            // pointers, or else separate the database and environment shutdowns so\n+            // environments can be shut down after databases.\n+            env->m_fileids.erase(strFile);\n+        }\n+    }\n+}\n+\n+void BerkeleyDatabase::ReloadDbEnv()\n+{\n+    if (!IsDummy()) {\n+        env->ReloadDbEnv();\n+    }\n+}\n+\n+Dbc* BerkeleyBatch::GetCursor()\n+{\n+    if (!pdb)\n+        return nullptr;\n+    Dbc* pcursor = nullptr;\n+    int ret = pdb->cursor(nullptr, &pcursor, 0);\n+    if (ret != 0)\n+        return nullptr;\n+    return pcursor;\n+}\n+\n+int BerkeleyBatch::ReadAtCursor(Dbc* pcursor, CDataStream& ssKey, CDataStream& ssValue)\n+{\n+    // Read at cursor\n+    SafeDbt datKey;\n+    SafeDbt datValue;\n+    int ret = pcursor->get(datKey, datValue, DB_NEXT);\n+    if (ret != 0)\n+        return ret;\n+    else if (datKey.get_data() == nullptr || datValue.get_data() == nullptr)\n+        return 99999;\n+\n+    // Convert to streams\n+    ssKey.SetType(SER_DISK);\n+    ssKey.clear();\n+    ssKey.write((char*)datKey.get_data(), datKey.get_size());\n+    ssValue.SetType(SER_DISK);\n+    ssValue.clear();\n+    ssValue.write((char*)datValue.get_data(), datValue.get_size());\n+    return 0;\n+}\n+\n+bool BerkeleyBatch::TxnBegin()\n+{\n+    if (!pdb || activeTxn)\n+        return false;\n+    DbTxn* ptxn = env->TxnBegin();\n+    if (!ptxn)\n+        return false;\n+    activeTxn = ptxn;\n+    return true;\n+}\n+\n+bool BerkeleyBatch::TxnCommit()\n+{\n+    if (!pdb || !activeTxn)\n+        return false;\n+    int ret = activeTxn->commit(0);\n+    activeTxn = nullptr;\n+    return (ret == 0);\n+}\n+\n+bool BerkeleyBatch::TxnAbort()\n+{\n+    if (!pdb || !activeTxn)\n+        return false;\n+    int ret = activeTxn->abort();\n+    activeTxn = nullptr;\n+    return (ret == 0);\n+}\n+\n+std::string BerkeleyDatabaseVersion()\n+{\n+    return DbEnv::version(nullptr, nullptr, nullptr);\n+}"
      },
      {
        "sha": "5ed364344b44e993708fd6378ef09e58b4da8dcd",
        "filename": "src/wallet/bdb.h",
        "status": "added",
        "additions": 337,
        "deletions": 0,
        "changes": 337,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/61c16339da4e80b1320a6296df6d96cd7a84bb4e/src/wallet/bdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/61c16339da4e80b1320a6296df6d96cd7a84bb4e/src/wallet/bdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/bdb.h?ref=61c16339da4e80b1320a6296df6d96cd7a84bb4e",
        "patch": "@@ -0,0 +1,337 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_WALLET_BDB_H\n+#define BITCOIN_WALLET_BDB_H\n+\n+#include <clientversion.h>\n+#include <fs.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <util/system.h>\n+#include <wallet/db.h>\n+\n+#include <atomic>\n+#include <map>\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+#include <vector>\n+\n+#if defined(__GNUC__) && !defined(__clang__)\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wsuggest-override\"\n+#endif\n+#include <db_cxx.h>\n+#if defined(__GNUC__) && !defined(__clang__)\n+#pragma GCC diagnostic pop\n+#endif\n+\n+struct bilingual_str;\n+\n+static const unsigned int DEFAULT_WALLET_DBLOGSIZE = 100;\n+static const bool DEFAULT_WALLET_PRIVDB = true;\n+\n+struct WalletDatabaseFileId {\n+    u_int8_t value[DB_FILE_ID_LEN];\n+    bool operator==(const WalletDatabaseFileId& rhs) const;\n+};\n+\n+class BerkeleyDatabase;\n+\n+class BerkeleyEnvironment\n+{\n+private:\n+    bool fDbEnvInit;\n+    bool fMockDb;\n+    // Don't change into fs::path, as that can result in\n+    // shutdown problems/crashes caused by a static initialized internal pointer.\n+    std::string strPath;\n+\n+public:\n+    std::unique_ptr<DbEnv> dbenv;\n+    std::map<std::string, int> mapFileUseCount;\n+    std::map<std::string, std::reference_wrapper<BerkeleyDatabase>> m_databases;\n+    std::unordered_map<std::string, WalletDatabaseFileId> m_fileids;\n+    std::condition_variable_any m_db_in_use;\n+\n+    BerkeleyEnvironment(const fs::path& env_directory);\n+    BerkeleyEnvironment();\n+    ~BerkeleyEnvironment();\n+    void Reset();\n+\n+    bool IsMock() const { return fMockDb; }\n+    bool IsInitialized() const { return fDbEnvInit; }\n+    bool IsDatabaseLoaded(const std::string& db_filename) const { return m_databases.find(db_filename) != m_databases.end(); }\n+    fs::path Directory() const { return strPath; }\n+\n+    bool Verify(const std::string& strFile);\n+\n+    bool Open(bool retry);\n+    void Close();\n+    void Flush(bool fShutdown);\n+    void CheckpointLSN(const std::string& strFile);\n+\n+    void CloseDb(const std::string& strFile);\n+    void ReloadDbEnv();\n+\n+    DbTxn* TxnBegin(int flags = DB_TXN_WRITE_NOSYNC)\n+    {\n+        DbTxn* ptxn = nullptr;\n+        int ret = dbenv->txn_begin(nullptr, &ptxn, flags);\n+        if (!ptxn || ret != 0)\n+            return nullptr;\n+        return ptxn;\n+    }\n+};\n+\n+/** Get BerkeleyEnvironment and database filename given a wallet path. */\n+std::shared_ptr<BerkeleyEnvironment> GetWalletEnv(const fs::path& wallet_path, std::string& database_filename);\n+\n+/** Return wheter a BDB wallet database is currently loaded. */\n+bool IsBDBWalletLoaded(const fs::path& wallet_path);\n+\n+/** An instance of this class represents one database.\n+ * For BerkeleyDB this is just a (env, strFile) tuple.\n+ **/\n+class BerkeleyDatabase\n+{\n+    friend class BerkeleyBatch;\n+public:\n+    /** Create dummy DB handle */\n+    BerkeleyDatabase() : nUpdateCounter(0), nLastSeen(0), nLastFlushed(0), nLastWalletUpdate(0), env(nullptr)\n+    {\n+    }\n+\n+    /** Create DB handle to real database */\n+    BerkeleyDatabase(std::shared_ptr<BerkeleyEnvironment> env, std::string filename) :\n+        nUpdateCounter(0), nLastSeen(0), nLastFlushed(0), nLastWalletUpdate(0), env(std::move(env)), strFile(std::move(filename))\n+    {\n+        auto inserted = this->env->m_databases.emplace(strFile, std::ref(*this));\n+        assert(inserted.second);\n+    }\n+\n+    ~BerkeleyDatabase() {\n+        if (env) {\n+            size_t erased = env->m_databases.erase(strFile);\n+            assert(erased == 1);\n+        }\n+    }\n+\n+    /** Return object for accessing database at specified path. */\n+    static std::unique_ptr<BerkeleyDatabase> Create(const fs::path& path)\n+    {\n+        std::string filename;\n+        return MakeUnique<BerkeleyDatabase>(GetWalletEnv(path, filename), std::move(filename));\n+    }\n+\n+    /** Return object for accessing dummy database with no read/write capabilities. */\n+    static std::unique_ptr<BerkeleyDatabase> CreateDummy()\n+    {\n+        return MakeUnique<BerkeleyDatabase>();\n+    }\n+\n+    /** Return object for accessing temporary in-memory database. */\n+    static std::unique_ptr<BerkeleyDatabase> CreateMock()\n+    {\n+        return MakeUnique<BerkeleyDatabase>(std::make_shared<BerkeleyEnvironment>(), \"\");\n+    }\n+\n+    /** Rewrite the entire database on disk, with the exception of key pszSkip if non-zero\n+     */\n+    bool Rewrite(const char* pszSkip=nullptr);\n+\n+    /** Back up the entire database to a file.\n+     */\n+    bool Backup(const std::string& strDest) const;\n+\n+    /** Make sure all changes are flushed to disk.\n+     */\n+    void Flush(bool shutdown);\n+\n+    void IncrementUpdateCounter();\n+\n+    void ReloadDbEnv();\n+\n+    std::atomic<unsigned int> nUpdateCounter;\n+    unsigned int nLastSeen;\n+    unsigned int nLastFlushed;\n+    int64_t nLastWalletUpdate;\n+\n+    /**\n+     * Pointer to shared database environment.\n+     *\n+     * Normally there is only one BerkeleyDatabase object per\n+     * BerkeleyEnvivonment, but in the special, backwards compatible case where\n+     * multiple wallet BDB data files are loaded from the same directory, this\n+     * will point to a shared instance that gets freed when the last data file\n+     * is closed.\n+     */\n+    std::shared_ptr<BerkeleyEnvironment> env;\n+\n+    /** Database pointer. This is initialized lazily and reset during flushes, so it can be null. */\n+    std::unique_ptr<Db> m_db;\n+\n+private:\n+    std::string strFile;\n+\n+    /** Return whether this database handle is a dummy for testing.\n+     * Only to be used at a low level, application should ideally not care\n+     * about this.\n+     */\n+    bool IsDummy() const { return env == nullptr; }\n+};\n+\n+/** RAII class that provides access to a Berkeley database */\n+class BerkeleyBatch\n+{\n+    /** RAII class that automatically cleanses its data on destruction */\n+    class SafeDbt final\n+    {\n+        Dbt m_dbt;\n+\n+    public:\n+        // construct Dbt with internally-managed data\n+        SafeDbt();\n+        // construct Dbt with provided data\n+        SafeDbt(void* data, size_t size);\n+        ~SafeDbt();\n+\n+        // delegate to Dbt\n+        const void* get_data() const;\n+        u_int32_t get_size() const;\n+\n+        // conversion operator to access the underlying Dbt\n+        operator Dbt*();\n+    };\n+\n+protected:\n+    Db* pdb;\n+    std::string strFile;\n+    DbTxn* activeTxn;\n+    bool fReadOnly;\n+    bool fFlushOnClose;\n+    BerkeleyEnvironment *env;\n+\n+public:\n+    explicit BerkeleyBatch(BerkeleyDatabase& database, const char* pszMode = \"r+\", bool fFlushOnCloseIn=true);\n+    ~BerkeleyBatch() { Close(); }\n+\n+    BerkeleyBatch(const BerkeleyBatch&) = delete;\n+    BerkeleyBatch& operator=(const BerkeleyBatch&) = delete;\n+\n+    void Flush();\n+    void Close();\n+\n+    /* flush the wallet passively (TRY_LOCK)\n+       ideal to be called periodically */\n+    static bool PeriodicFlush(BerkeleyDatabase& database);\n+    /* verifies the database environment */\n+    static bool VerifyEnvironment(const fs::path& file_path, bilingual_str& errorStr);\n+    /* verifies the database file */\n+    static bool VerifyDatabaseFile(const fs::path& file_path, bilingual_str& errorStr);\n+\n+    template <typename K, typename T>\n+    bool Read(const K& key, T& value)\n+    {\n+        if (!pdb)\n+            return false;\n+\n+        // Key\n+        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+        ssKey.reserve(1000);\n+        ssKey << key;\n+        SafeDbt datKey(ssKey.data(), ssKey.size());\n+\n+        // Read\n+        SafeDbt datValue;\n+        int ret = pdb->get(activeTxn, datKey, datValue, 0);\n+        bool success = false;\n+        if (datValue.get_data() != nullptr) {\n+            // Unserialize value\n+            try {\n+                CDataStream ssValue((char*)datValue.get_data(), (char*)datValue.get_data() + datValue.get_size(), SER_DISK, CLIENT_VERSION);\n+                ssValue >> value;\n+                success = true;\n+            } catch (const std::exception&) {\n+                // In this case success remains 'false'\n+            }\n+        }\n+        return ret == 0 && success;\n+    }\n+\n+    template <typename K, typename T>\n+    bool Write(const K& key, const T& value, bool fOverwrite = true)\n+    {\n+        if (!pdb)\n+            return true;\n+        if (fReadOnly)\n+            assert(!\"Write called on database in read-only mode\");\n+\n+        // Key\n+        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+        ssKey.reserve(1000);\n+        ssKey << key;\n+        SafeDbt datKey(ssKey.data(), ssKey.size());\n+\n+        // Value\n+        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n+        ssValue.reserve(10000);\n+        ssValue << value;\n+        SafeDbt datValue(ssValue.data(), ssValue.size());\n+\n+        // Write\n+        int ret = pdb->put(activeTxn, datKey, datValue, (fOverwrite ? 0 : DB_NOOVERWRITE));\n+        return (ret == 0);\n+    }\n+\n+    template <typename K>\n+    bool Erase(const K& key)\n+    {\n+        if (!pdb)\n+            return false;\n+        if (fReadOnly)\n+            assert(!\"Erase called on database in read-only mode\");\n+\n+        // Key\n+        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+        ssKey.reserve(1000);\n+        ssKey << key;\n+        SafeDbt datKey(ssKey.data(), ssKey.size());\n+\n+        // Erase\n+        int ret = pdb->del(activeTxn, datKey, 0);\n+        return (ret == 0 || ret == DB_NOTFOUND);\n+    }\n+\n+    template <typename K>\n+    bool Exists(const K& key)\n+    {\n+        if (!pdb)\n+            return false;\n+\n+        // Key\n+        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+        ssKey.reserve(1000);\n+        ssKey << key;\n+        SafeDbt datKey(ssKey.data(), ssKey.size());\n+\n+        // Exists\n+        int ret = pdb->exists(activeTxn, datKey, 0);\n+        return (ret == 0);\n+    }\n+\n+    Dbc* GetCursor();\n+    int ReadAtCursor(Dbc* pcursor, CDataStream& ssKey, CDataStream& ssValue);\n+    bool TxnBegin();\n+    bool TxnCommit();\n+    bool TxnAbort();\n+\n+    bool static Rewrite(BerkeleyDatabase& database, const char* pszSkip = nullptr);\n+};\n+\n+std::string BerkeleyDatabaseVersion();\n+\n+#endif // BITCOIN_WALLET_BDB_H"
      },
      {
        "sha": "1eb82a03c7cd2da254eed54b3088a2a566ffdfa6",
        "filename": "src/wallet/db.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 797,
        "changes": 799,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/61c16339da4e80b1320a6296df6d96cd7a84bb4e/src/wallet/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/61c16339da4e80b1320a6296df6d96cd7a84bb4e/src/wallet/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.cpp?ref=61c16339da4e80b1320a6296df6d96cd7a84bb4e",
        "patch": "@@ -3,53 +3,10 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include <fs.h>\n #include <wallet/db.h>\n \n-#include <util/strencodings.h>\n-#include <util/translation.h>\n-\n-#include <stdint.h>\n-\n-#ifndef WIN32\n-#include <sys/stat.h>\n-#endif\n-\n-namespace {\n-\n-//! Make sure database has a unique fileid within the environment. If it\n-//! doesn't, throw an error. BDB caches do not work properly when more than one\n-//! open database has the same fileid (values written to one database may show\n-//! up in reads to other databases).\n-//!\n-//! BerkeleyDB generates unique fileids by default\n-//! (https://docs.oracle.com/cd/E17275_01/html/programmer_reference/program_copy.html),\n-//! so bitcoin should never create different databases with the same fileid, but\n-//! this error can be triggered if users manually copy database files.\n-void CheckUniqueFileid(const BerkeleyEnvironment& env, const std::string& filename, Db& db, WalletDatabaseFileId& fileid)\n-{\n-    if (env.IsMock()) return;\n-\n-    int ret = db.get_mpf()->get_fileid(fileid.value);\n-    if (ret != 0) {\n-        throw std::runtime_error(strprintf(\"BerkeleyBatch: Can't open database %s (get_fileid failed with %d)\", filename, ret));\n-    }\n-\n-    for (const auto& item : env.m_fileids) {\n-        if (fileid == item.second && &fileid != &item.second) {\n-            throw std::runtime_error(strprintf(\"BerkeleyBatch: Can't open database %s (duplicates fileid %s from %s)\", filename,\n-                HexStr(std::begin(item.second.value), std::end(item.second.value)), item.first));\n-        }\n-    }\n-}\n-\n-RecursiveMutex cs_db;\n-std::map<std::string, std::weak_ptr<BerkeleyEnvironment>> g_dbenvs GUARDED_BY(cs_db); //!< Map from directory name to db environment.\n-} // namespace\n-\n-bool WalletDatabaseFileId::operator==(const WalletDatabaseFileId& rhs) const\n-{\n-    return memcmp(value, &rhs.value, sizeof(value)) == 0;\n-}\n+#include <string>\n \n void SplitWalletPath(const fs::path& wallet_path, fs::path& env_directory, std::string& database_filename)\n {\n@@ -67,762 +24,10 @@ void SplitWalletPath(const fs::path& wallet_path, fs::path& env_directory, std::\n     }\n }\n \n-bool IsBDBWalletLoaded(const fs::path& wallet_path)\n-{\n-    fs::path env_directory;\n-    std::string database_filename;\n-    SplitWalletPath(wallet_path, env_directory, database_filename);\n-    LOCK(cs_db);\n-    auto env = g_dbenvs.find(env_directory.string());\n-    if (env == g_dbenvs.end()) return false;\n-    auto database = env->second.lock();\n-    return database && database->IsDatabaseLoaded(database_filename);\n-}\n-\n fs::path WalletDataFilePath(const fs::path& wallet_path)\n {\n     fs::path env_directory;\n     std::string database_filename;\n     SplitWalletPath(wallet_path, env_directory, database_filename);\n     return env_directory / database_filename;\n }\n-\n-/**\n- * @param[in] wallet_path Path to wallet directory. Or (for backwards compatibility only) a path to a berkeley btree data file inside a wallet directory.\n- * @param[out] database_filename Filename of berkeley btree data file inside the wallet directory.\n- * @return A shared pointer to the BerkeleyEnvironment object for the wallet directory, never empty because ~BerkeleyEnvironment\n- * erases the weak pointer from the g_dbenvs map.\n- * @post A new BerkeleyEnvironment weak pointer is inserted into g_dbenvs if the directory path key was not already in the map.\n- */\n-std::shared_ptr<BerkeleyEnvironment> GetWalletEnv(const fs::path& wallet_path, std::string& database_filename)\n-{\n-    fs::path env_directory;\n-    SplitWalletPath(wallet_path, env_directory, database_filename);\n-    LOCK(cs_db);\n-    auto inserted = g_dbenvs.emplace(env_directory.string(), std::weak_ptr<BerkeleyEnvironment>());\n-    if (inserted.second) {\n-        auto env = std::make_shared<BerkeleyEnvironment>(env_directory.string());\n-        inserted.first->second = env;\n-        return env;\n-    }\n-    return inserted.first->second.lock();\n-}\n-\n-//\n-// BerkeleyBatch\n-//\n-\n-void BerkeleyEnvironment::Close()\n-{\n-    if (!fDbEnvInit)\n-        return;\n-\n-    fDbEnvInit = false;\n-\n-    for (auto& db : m_databases) {\n-        auto count = mapFileUseCount.find(db.first);\n-        assert(count == mapFileUseCount.end() || count->second == 0);\n-        BerkeleyDatabase& database = db.second.get();\n-        if (database.m_db) {\n-            database.m_db->close(0);\n-            database.m_db.reset();\n-        }\n-    }\n-\n-    FILE* error_file = nullptr;\n-    dbenv->get_errfile(&error_file);\n-\n-    int ret = dbenv->close(0);\n-    if (ret != 0)\n-        LogPrintf(\"BerkeleyEnvironment::Close: Error %d closing database environment: %s\\n\", ret, DbEnv::strerror(ret));\n-    if (!fMockDb)\n-        DbEnv((u_int32_t)0).remove(strPath.c_str(), 0);\n-\n-    if (error_file) fclose(error_file);\n-\n-    UnlockDirectory(strPath, \".walletlock\");\n-}\n-\n-void BerkeleyEnvironment::Reset()\n-{\n-    dbenv.reset(new DbEnv(DB_CXX_NO_EXCEPTIONS));\n-    fDbEnvInit = false;\n-    fMockDb = false;\n-}\n-\n-BerkeleyEnvironment::BerkeleyEnvironment(const fs::path& dir_path) : strPath(dir_path.string())\n-{\n-    Reset();\n-}\n-\n-BerkeleyEnvironment::~BerkeleyEnvironment()\n-{\n-    LOCK(cs_db);\n-    g_dbenvs.erase(strPath);\n-    Close();\n-}\n-\n-bool BerkeleyEnvironment::Open(bool retry)\n-{\n-    if (fDbEnvInit) {\n-        return true;\n-    }\n-\n-    fs::path pathIn = strPath;\n-    TryCreateDirectories(pathIn);\n-    if (!LockDirectory(pathIn, \".walletlock\")) {\n-        LogPrintf(\"Cannot obtain a lock on wallet directory %s. Another instance of bitcoin may be using it.\\n\", strPath);\n-        return false;\n-    }\n-\n-    fs::path pathLogDir = pathIn / \"database\";\n-    TryCreateDirectories(pathLogDir);\n-    fs::path pathErrorFile = pathIn / \"db.log\";\n-    LogPrintf(\"BerkeleyEnvironment::Open: LogDir=%s ErrorFile=%s\\n\", pathLogDir.string(), pathErrorFile.string());\n-\n-    unsigned int nEnvFlags = 0;\n-    if (gArgs.GetBoolArg(\"-privdb\", DEFAULT_WALLET_PRIVDB))\n-        nEnvFlags |= DB_PRIVATE;\n-\n-    dbenv->set_lg_dir(pathLogDir.string().c_str());\n-    dbenv->set_cachesize(0, 0x100000, 1); // 1 MiB should be enough for just the wallet\n-    dbenv->set_lg_bsize(0x10000);\n-    dbenv->set_lg_max(1048576);\n-    dbenv->set_lk_max_locks(40000);\n-    dbenv->set_lk_max_objects(40000);\n-    dbenv->set_errfile(fsbridge::fopen(pathErrorFile, \"a\")); /// debug\n-    dbenv->set_flags(DB_AUTO_COMMIT, 1);\n-    dbenv->set_flags(DB_TXN_WRITE_NOSYNC, 1);\n-    dbenv->log_set_config(DB_LOG_AUTO_REMOVE, 1);\n-    int ret = dbenv->open(strPath.c_str(),\n-                         DB_CREATE |\n-                             DB_INIT_LOCK |\n-                             DB_INIT_LOG |\n-                             DB_INIT_MPOOL |\n-                             DB_INIT_TXN |\n-                             DB_THREAD |\n-                             DB_RECOVER |\n-                             nEnvFlags,\n-                         S_IRUSR | S_IWUSR);\n-    if (ret != 0) {\n-        LogPrintf(\"BerkeleyEnvironment::Open: Error %d opening database environment: %s\\n\", ret, DbEnv::strerror(ret));\n-        int ret2 = dbenv->close(0);\n-        if (ret2 != 0) {\n-            LogPrintf(\"BerkeleyEnvironment::Open: Error %d closing failed database environment: %s\\n\", ret2, DbEnv::strerror(ret2));\n-        }\n-        Reset();\n-        if (retry) {\n-            // try moving the database env out of the way\n-            fs::path pathDatabaseBak = pathIn / strprintf(\"database.%d.bak\", GetTime());\n-            try {\n-                fs::rename(pathLogDir, pathDatabaseBak);\n-                LogPrintf(\"Moved old %s to %s. Retrying.\\n\", pathLogDir.string(), pathDatabaseBak.string());\n-            } catch (const fs::filesystem_error&) {\n-                // failure is ok (well, not really, but it's not worse than what we started with)\n-            }\n-            // try opening it again one more time\n-            if (!Open(false /* retry */)) {\n-                // if it still fails, it probably means we can't even create the database env\n-                return false;\n-            }\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    fDbEnvInit = true;\n-    fMockDb = false;\n-    return true;\n-}\n-\n-//! Construct an in-memory mock Berkeley environment for testing\n-BerkeleyEnvironment::BerkeleyEnvironment()\n-{\n-    Reset();\n-\n-    LogPrint(BCLog::WALLETDB, \"BerkeleyEnvironment::MakeMock\\n\");\n-\n-    dbenv->set_cachesize(1, 0, 1);\n-    dbenv->set_lg_bsize(10485760 * 4);\n-    dbenv->set_lg_max(10485760);\n-    dbenv->set_lk_max_locks(10000);\n-    dbenv->set_lk_max_objects(10000);\n-    dbenv->set_flags(DB_AUTO_COMMIT, 1);\n-    dbenv->log_set_config(DB_LOG_IN_MEMORY, 1);\n-    int ret = dbenv->open(nullptr,\n-                         DB_CREATE |\n-                             DB_INIT_LOCK |\n-                             DB_INIT_LOG |\n-                             DB_INIT_MPOOL |\n-                             DB_INIT_TXN |\n-                             DB_THREAD |\n-                             DB_PRIVATE,\n-                         S_IRUSR | S_IWUSR);\n-    if (ret > 0) {\n-        throw std::runtime_error(strprintf(\"BerkeleyEnvironment::MakeMock: Error %d opening database environment.\", ret));\n-    }\n-\n-    fDbEnvInit = true;\n-    fMockDb = true;\n-}\n-\n-bool BerkeleyEnvironment::Verify(const std::string& strFile)\n-{\n-    LOCK(cs_db);\n-    assert(mapFileUseCount.count(strFile) == 0);\n-\n-    Db db(dbenv.get(), 0);\n-    int result = db.verify(strFile.c_str(), nullptr, nullptr, 0);\n-    return result == 0;\n-}\n-\n-BerkeleyBatch::SafeDbt::SafeDbt()\n-{\n-    m_dbt.set_flags(DB_DBT_MALLOC);\n-}\n-\n-BerkeleyBatch::SafeDbt::SafeDbt(void* data, size_t size)\n-    : m_dbt(data, size)\n-{\n-}\n-\n-BerkeleyBatch::SafeDbt::~SafeDbt()\n-{\n-    if (m_dbt.get_data() != nullptr) {\n-        // Clear memory, e.g. in case it was a private key\n-        memory_cleanse(m_dbt.get_data(), m_dbt.get_size());\n-        // under DB_DBT_MALLOC, data is malloced by the Dbt, but must be\n-        // freed by the caller.\n-        // https://docs.oracle.com/cd/E17275_01/html/api_reference/C/dbt.html\n-        if (m_dbt.get_flags() & DB_DBT_MALLOC) {\n-            free(m_dbt.get_data());\n-        }\n-    }\n-}\n-\n-const void* BerkeleyBatch::SafeDbt::get_data() const\n-{\n-    return m_dbt.get_data();\n-}\n-\n-u_int32_t BerkeleyBatch::SafeDbt::get_size() const\n-{\n-    return m_dbt.get_size();\n-}\n-\n-BerkeleyBatch::SafeDbt::operator Dbt*()\n-{\n-    return &m_dbt;\n-}\n-\n-bool BerkeleyBatch::VerifyEnvironment(const fs::path& file_path, bilingual_str& errorStr)\n-{\n-    std::string walletFile;\n-    std::shared_ptr<BerkeleyEnvironment> env = GetWalletEnv(file_path, walletFile);\n-    fs::path walletDir = env->Directory();\n-\n-    LogPrintf(\"Using BerkeleyDB version %s\\n\", BerkeleyDatabaseVersion());\n-    LogPrintf(\"Using wallet %s\\n\", file_path.string());\n-\n-    if (!env->Open(true /* retry */)) {\n-        errorStr = strprintf(_(\"Error initializing wallet database environment %s!\"), walletDir);\n-        return false;\n-    }\n-\n-    return true;\n-}\n-\n-bool BerkeleyBatch::VerifyDatabaseFile(const fs::path& file_path, bilingual_str& errorStr)\n-{\n-    std::string walletFile;\n-    std::shared_ptr<BerkeleyEnvironment> env = GetWalletEnv(file_path, walletFile);\n-    fs::path walletDir = env->Directory();\n-\n-    if (fs::exists(walletDir / walletFile))\n-    {\n-        if (!env->Verify(walletFile)) {\n-            errorStr = strprintf(_(\"%s corrupt. Try using the wallet tool bitcoin-wallet to salvage or restoring a backup.\"), walletFile);\n-            return false;\n-        }\n-    }\n-    // also return true if files does not exists\n-    return true;\n-}\n-\n-void BerkeleyEnvironment::CheckpointLSN(const std::string& strFile)\n-{\n-    dbenv->txn_checkpoint(0, 0, 0);\n-    if (fMockDb)\n-        return;\n-    dbenv->lsn_reset(strFile.c_str(), 0);\n-}\n-\n-\n-BerkeleyBatch::BerkeleyBatch(BerkeleyDatabase& database, const char* pszMode, bool fFlushOnCloseIn) : pdb(nullptr), activeTxn(nullptr)\n-{\n-    fReadOnly = (!strchr(pszMode, '+') && !strchr(pszMode, 'w'));\n-    fFlushOnClose = fFlushOnCloseIn;\n-    env = database.env.get();\n-    if (database.IsDummy()) {\n-        return;\n-    }\n-    const std::string &strFilename = database.strFile;\n-\n-    bool fCreate = strchr(pszMode, 'c') != nullptr;\n-    unsigned int nFlags = DB_THREAD;\n-    if (fCreate)\n-        nFlags |= DB_CREATE;\n-\n-    {\n-        LOCK(cs_db);\n-        if (!env->Open(false /* retry */))\n-            throw std::runtime_error(\"BerkeleyBatch: Failed to open database environment.\");\n-\n-        pdb = database.m_db.get();\n-        if (pdb == nullptr) {\n-            int ret;\n-            std::unique_ptr<Db> pdb_temp = MakeUnique<Db>(env->dbenv.get(), 0);\n-\n-            bool fMockDb = env->IsMock();\n-            if (fMockDb) {\n-                DbMpoolFile* mpf = pdb_temp->get_mpf();\n-                ret = mpf->set_flags(DB_MPOOL_NOFILE, 1);\n-                if (ret != 0) {\n-                    throw std::runtime_error(strprintf(\"BerkeleyBatch: Failed to configure for no temp file backing for database %s\", strFilename));\n-                }\n-            }\n-\n-            ret = pdb_temp->open(nullptr,                             // Txn pointer\n-                            fMockDb ? nullptr : strFilename.c_str(),  // Filename\n-                            fMockDb ? strFilename.c_str() : \"main\",   // Logical db name\n-                            DB_BTREE,                                 // Database type\n-                            nFlags,                                   // Flags\n-                            0);\n-\n-            if (ret != 0) {\n-                throw std::runtime_error(strprintf(\"BerkeleyBatch: Error %d, can't open database %s\", ret, strFilename));\n-            }\n-\n-            // Call CheckUniqueFileid on the containing BDB environment to\n-            // avoid BDB data consistency bugs that happen when different data\n-            // files in the same environment have the same fileid.\n-            //\n-            // Also call CheckUniqueFileid on all the other g_dbenvs to prevent\n-            // bitcoin from opening the same data file through another\n-            // environment when the file is referenced through equivalent but\n-            // not obviously identical symlinked or hard linked or bind mounted\n-            // paths. In the future a more relaxed check for equal inode and\n-            // device ids could be done instead, which would allow opening\n-            // different backup copies of a wallet at the same time. Maybe even\n-            // more ideally, an exclusive lock for accessing the database could\n-            // be implemented, so no equality checks are needed at all. (Newer\n-            // versions of BDB have an set_lk_exclusive method for this\n-            // purpose, but the older version we use does not.)\n-            for (const auto& env : g_dbenvs) {\n-                CheckUniqueFileid(*env.second.lock().get(), strFilename, *pdb_temp, this->env->m_fileids[strFilename]);\n-            }\n-\n-            pdb = pdb_temp.release();\n-            database.m_db.reset(pdb);\n-\n-            if (fCreate && !Exists(std::string(\"version\"))) {\n-                bool fTmp = fReadOnly;\n-                fReadOnly = false;\n-                Write(std::string(\"version\"), CLIENT_VERSION);\n-                fReadOnly = fTmp;\n-            }\n-        }\n-        ++env->mapFileUseCount[strFilename];\n-        strFile = strFilename;\n-    }\n-}\n-\n-void BerkeleyBatch::Flush()\n-{\n-    if (activeTxn)\n-        return;\n-\n-    // Flush database activity from memory pool to disk log\n-    unsigned int nMinutes = 0;\n-    if (fReadOnly)\n-        nMinutes = 1;\n-\n-    if (env) { // env is nullptr for dummy databases (i.e. in tests). Don't actually flush if env is nullptr so we don't segfault\n-        env->dbenv->txn_checkpoint(nMinutes ? gArgs.GetArg(\"-dblogsize\", DEFAULT_WALLET_DBLOGSIZE) * 1024 : 0, nMinutes, 0);\n-    }\n-}\n-\n-void BerkeleyDatabase::IncrementUpdateCounter()\n-{\n-    ++nUpdateCounter;\n-}\n-\n-void BerkeleyBatch::Close()\n-{\n-    if (!pdb)\n-        return;\n-    if (activeTxn)\n-        activeTxn->abort();\n-    activeTxn = nullptr;\n-    pdb = nullptr;\n-\n-    if (fFlushOnClose)\n-        Flush();\n-\n-    {\n-        LOCK(cs_db);\n-        --env->mapFileUseCount[strFile];\n-    }\n-    env->m_db_in_use.notify_all();\n-}\n-\n-void BerkeleyEnvironment::CloseDb(const std::string& strFile)\n-{\n-    {\n-        LOCK(cs_db);\n-        auto it = m_databases.find(strFile);\n-        assert(it != m_databases.end());\n-        BerkeleyDatabase& database = it->second.get();\n-        if (database.m_db) {\n-            // Close the database handle\n-            database.m_db->close(0);\n-            database.m_db.reset();\n-        }\n-    }\n-}\n-\n-void BerkeleyEnvironment::ReloadDbEnv()\n-{\n-    // Make sure that no Db's are in use\n-    AssertLockNotHeld(cs_db);\n-    std::unique_lock<RecursiveMutex> lock(cs_db);\n-    m_db_in_use.wait(lock, [this](){\n-        for (auto& count : mapFileUseCount) {\n-            if (count.second > 0) return false;\n-        }\n-        return true;\n-    });\n-\n-    std::vector<std::string> filenames;\n-    for (auto it : m_databases) {\n-        filenames.push_back(it.first);\n-    }\n-    // Close the individual Db's\n-    for (const std::string& filename : filenames) {\n-        CloseDb(filename);\n-    }\n-    // Reset the environment\n-    Flush(true); // This will flush and close the environment\n-    Reset();\n-    Open(true);\n-}\n-\n-bool BerkeleyBatch::Rewrite(BerkeleyDatabase& database, const char* pszSkip)\n-{\n-    if (database.IsDummy()) {\n-        return true;\n-    }\n-    BerkeleyEnvironment *env = database.env.get();\n-    const std::string& strFile = database.strFile;\n-    while (true) {\n-        {\n-            LOCK(cs_db);\n-            if (!env->mapFileUseCount.count(strFile) || env->mapFileUseCount[strFile] == 0) {\n-                // Flush log data to the dat file\n-                env->CloseDb(strFile);\n-                env->CheckpointLSN(strFile);\n-                env->mapFileUseCount.erase(strFile);\n-\n-                bool fSuccess = true;\n-                LogPrintf(\"BerkeleyBatch::Rewrite: Rewriting %s...\\n\", strFile);\n-                std::string strFileRes = strFile + \".rewrite\";\n-                { // surround usage of db with extra {}\n-                    BerkeleyBatch db(database, \"r\");\n-                    std::unique_ptr<Db> pdbCopy = MakeUnique<Db>(env->dbenv.get(), 0);\n-\n-                    int ret = pdbCopy->open(nullptr,               // Txn pointer\n-                                            strFileRes.c_str(), // Filename\n-                                            \"main\",             // Logical db name\n-                                            DB_BTREE,           // Database type\n-                                            DB_CREATE,          // Flags\n-                                            0);\n-                    if (ret > 0) {\n-                        LogPrintf(\"BerkeleyBatch::Rewrite: Can't create database file %s\\n\", strFileRes);\n-                        fSuccess = false;\n-                    }\n-\n-                    Dbc* pcursor = db.GetCursor();\n-                    if (pcursor)\n-                        while (fSuccess) {\n-                            CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n-                            CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n-                            int ret1 = db.ReadAtCursor(pcursor, ssKey, ssValue);\n-                            if (ret1 == DB_NOTFOUND) {\n-                                pcursor->close();\n-                                break;\n-                            } else if (ret1 != 0) {\n-                                pcursor->close();\n-                                fSuccess = false;\n-                                break;\n-                            }\n-                            if (pszSkip &&\n-                                strncmp(ssKey.data(), pszSkip, std::min(ssKey.size(), strlen(pszSkip))) == 0)\n-                                continue;\n-                            if (strncmp(ssKey.data(), \"\\x07version\", 8) == 0) {\n-                                // Update version:\n-                                ssValue.clear();\n-                                ssValue << CLIENT_VERSION;\n-                            }\n-                            Dbt datKey(ssKey.data(), ssKey.size());\n-                            Dbt datValue(ssValue.data(), ssValue.size());\n-                            int ret2 = pdbCopy->put(nullptr, &datKey, &datValue, DB_NOOVERWRITE);\n-                            if (ret2 > 0)\n-                                fSuccess = false;\n-                        }\n-                    if (fSuccess) {\n-                        db.Close();\n-                        env->CloseDb(strFile);\n-                        if (pdbCopy->close(0))\n-                            fSuccess = false;\n-                    } else {\n-                        pdbCopy->close(0);\n-                    }\n-                }\n-                if (fSuccess) {\n-                    Db dbA(env->dbenv.get(), 0);\n-                    if (dbA.remove(strFile.c_str(), nullptr, 0))\n-                        fSuccess = false;\n-                    Db dbB(env->dbenv.get(), 0);\n-                    if (dbB.rename(strFileRes.c_str(), nullptr, strFile.c_str(), 0))\n-                        fSuccess = false;\n-                }\n-                if (!fSuccess)\n-                    LogPrintf(\"BerkeleyBatch::Rewrite: Failed to rewrite database file %s\\n\", strFileRes);\n-                return fSuccess;\n-            }\n-        }\n-        UninterruptibleSleep(std::chrono::milliseconds{100});\n-    }\n-}\n-\n-\n-void BerkeleyEnvironment::Flush(bool fShutdown)\n-{\n-    int64_t nStart = GetTimeMillis();\n-    // Flush log data to the actual data file on all files that are not in use\n-    LogPrint(BCLog::WALLETDB, \"BerkeleyEnvironment::Flush: [%s] Flush(%s)%s\\n\", strPath, fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" database not started\");\n-    if (!fDbEnvInit)\n-        return;\n-    {\n-        LOCK(cs_db);\n-        std::map<std::string, int>::iterator mi = mapFileUseCount.begin();\n-        while (mi != mapFileUseCount.end()) {\n-            std::string strFile = (*mi).first;\n-            int nRefCount = (*mi).second;\n-            LogPrint(BCLog::WALLETDB, \"BerkeleyEnvironment::Flush: Flushing %s (refcount = %d)...\\n\", strFile, nRefCount);\n-            if (nRefCount == 0) {\n-                // Move log data to the dat file\n-                CloseDb(strFile);\n-                LogPrint(BCLog::WALLETDB, \"BerkeleyEnvironment::Flush: %s checkpoint\\n\", strFile);\n-                dbenv->txn_checkpoint(0, 0, 0);\n-                LogPrint(BCLog::WALLETDB, \"BerkeleyEnvironment::Flush: %s detach\\n\", strFile);\n-                if (!fMockDb)\n-                    dbenv->lsn_reset(strFile.c_str(), 0);\n-                LogPrint(BCLog::WALLETDB, \"BerkeleyEnvironment::Flush: %s closed\\n\", strFile);\n-                mapFileUseCount.erase(mi++);\n-            } else\n-                mi++;\n-        }\n-        LogPrint(BCLog::WALLETDB, \"BerkeleyEnvironment::Flush: Flush(%s)%s took %15dms\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" database not started\", GetTimeMillis() - nStart);\n-        if (fShutdown) {\n-            char** listp;\n-            if (mapFileUseCount.empty()) {\n-                dbenv->log_archive(&listp, DB_ARCH_REMOVE);\n-                Close();\n-                if (!fMockDb) {\n-                    fs::remove_all(fs::path(strPath) / \"database\");\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-bool BerkeleyBatch::PeriodicFlush(BerkeleyDatabase& database)\n-{\n-    if (database.IsDummy()) {\n-        return true;\n-    }\n-    bool ret = false;\n-    BerkeleyEnvironment *env = database.env.get();\n-    const std::string& strFile = database.strFile;\n-    TRY_LOCK(cs_db, lockDb);\n-    if (lockDb)\n-    {\n-        // Don't do this if any databases are in use\n-        int nRefCount = 0;\n-        std::map<std::string, int>::iterator mit = env->mapFileUseCount.begin();\n-        while (mit != env->mapFileUseCount.end())\n-        {\n-            nRefCount += (*mit).second;\n-            mit++;\n-        }\n-\n-        if (nRefCount == 0)\n-        {\n-            std::map<std::string, int>::iterator mi = env->mapFileUseCount.find(strFile);\n-            if (mi != env->mapFileUseCount.end())\n-            {\n-                LogPrint(BCLog::WALLETDB, \"Flushing %s\\n\", strFile);\n-                int64_t nStart = GetTimeMillis();\n-\n-                // Flush wallet file so it's self contained\n-                env->CloseDb(strFile);\n-                env->CheckpointLSN(strFile);\n-\n-                env->mapFileUseCount.erase(mi++);\n-                LogPrint(BCLog::WALLETDB, \"Flushed %s %dms\\n\", strFile, GetTimeMillis() - nStart);\n-                ret = true;\n-            }\n-        }\n-    }\n-\n-    return ret;\n-}\n-\n-bool BerkeleyDatabase::Rewrite(const char* pszSkip)\n-{\n-    return BerkeleyBatch::Rewrite(*this, pszSkip);\n-}\n-\n-bool BerkeleyDatabase::Backup(const std::string& strDest) const\n-{\n-    if (IsDummy()) {\n-        return false;\n-    }\n-    while (true)\n-    {\n-        {\n-            LOCK(cs_db);\n-            if (!env->mapFileUseCount.count(strFile) || env->mapFileUseCount[strFile] == 0)\n-            {\n-                // Flush log data to the dat file\n-                env->CloseDb(strFile);\n-                env->CheckpointLSN(strFile);\n-                env->mapFileUseCount.erase(strFile);\n-\n-                // Copy wallet file\n-                fs::path pathSrc = env->Directory() / strFile;\n-                fs::path pathDest(strDest);\n-                if (fs::is_directory(pathDest))\n-                    pathDest /= strFile;\n-\n-                try {\n-                    if (fs::equivalent(pathSrc, pathDest)) {\n-                        LogPrintf(\"cannot backup to wallet source file %s\\n\", pathDest.string());\n-                        return false;\n-                    }\n-\n-                    fs::copy_file(pathSrc, pathDest, fs::copy_option::overwrite_if_exists);\n-                    LogPrintf(\"copied %s to %s\\n\", strFile, pathDest.string());\n-                    return true;\n-                } catch (const fs::filesystem_error& e) {\n-                    LogPrintf(\"error copying %s to %s - %s\\n\", strFile, pathDest.string(), fsbridge::get_filesystem_error_message(e));\n-                    return false;\n-                }\n-            }\n-        }\n-        UninterruptibleSleep(std::chrono::milliseconds{100});\n-    }\n-}\n-\n-void BerkeleyDatabase::Flush(bool shutdown)\n-{\n-    if (!IsDummy()) {\n-        env->Flush(shutdown);\n-        if (shutdown) {\n-            LOCK(cs_db);\n-            g_dbenvs.erase(env->Directory().string());\n-            env = nullptr;\n-        } else {\n-            // TODO: To avoid g_dbenvs.erase erasing the environment prematurely after the\n-            // first database shutdown when multiple databases are open in the same\n-            // environment, should replace raw database `env` pointers with shared or weak\n-            // pointers, or else separate the database and environment shutdowns so\n-            // environments can be shut down after databases.\n-            env->m_fileids.erase(strFile);\n-        }\n-    }\n-}\n-\n-void BerkeleyDatabase::ReloadDbEnv()\n-{\n-    if (!IsDummy()) {\n-        env->ReloadDbEnv();\n-    }\n-}\n-\n-Dbc* BerkeleyBatch::GetCursor()\n-{\n-    if (!pdb)\n-        return nullptr;\n-    Dbc* pcursor = nullptr;\n-    int ret = pdb->cursor(nullptr, &pcursor, 0);\n-    if (ret != 0)\n-        return nullptr;\n-    return pcursor;\n-}\n-\n-int BerkeleyBatch::ReadAtCursor(Dbc* pcursor, CDataStream& ssKey, CDataStream& ssValue)\n-{\n-    // Read at cursor\n-    SafeDbt datKey;\n-    SafeDbt datValue;\n-    int ret = pcursor->get(datKey, datValue, DB_NEXT);\n-    if (ret != 0)\n-        return ret;\n-    else if (datKey.get_data() == nullptr || datValue.get_data() == nullptr)\n-        return 99999;\n-\n-    // Convert to streams\n-    ssKey.SetType(SER_DISK);\n-    ssKey.clear();\n-    ssKey.write((char*)datKey.get_data(), datKey.get_size());\n-    ssValue.SetType(SER_DISK);\n-    ssValue.clear();\n-    ssValue.write((char*)datValue.get_data(), datValue.get_size());\n-    return 0;\n-}\n-\n-bool BerkeleyBatch::TxnBegin()\n-{\n-    if (!pdb || activeTxn)\n-        return false;\n-    DbTxn* ptxn = env->TxnBegin();\n-    if (!ptxn)\n-        return false;\n-    activeTxn = ptxn;\n-    return true;\n-}\n-\n-bool BerkeleyBatch::TxnCommit()\n-{\n-    if (!pdb || !activeTxn)\n-        return false;\n-    int ret = activeTxn->commit(0);\n-    activeTxn = nullptr;\n-    return (ret == 0);\n-}\n-\n-bool BerkeleyBatch::TxnAbort()\n-{\n-    if (!pdb || !activeTxn)\n-        return false;\n-    int ret = activeTxn->abort();\n-    activeTxn = nullptr;\n-    return (ret == 0);\n-}\n-\n-std::string BerkeleyDatabaseVersion()\n-{\n-    return DbEnv::version(nullptr, nullptr, nullptr);\n-}"
      },
      {
        "sha": "1322bf54faa200af0dff0ef50895fcad32c25c94",
        "filename": "src/wallet/db.h",
        "status": "modified",
        "additions": 0,
        "deletions": 323,
        "changes": 323,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/61c16339da4e80b1320a6296df6d96cd7a84bb4e/src/wallet/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/61c16339da4e80b1320a6296df6d96cd7a84bb4e/src/wallet/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.h?ref=61c16339da4e80b1320a6296df6d96cd7a84bb4e",
        "patch": "@@ -6,335 +6,12 @@\n #ifndef BITCOIN_WALLET_DB_H\n #define BITCOIN_WALLET_DB_H\n \n-#include <clientversion.h>\n #include <fs.h>\n-#include <serialize.h>\n-#include <streams.h>\n-#include <util/system.h>\n \n-#include <atomic>\n-#include <map>\n-#include <memory>\n #include <string>\n-#include <unordered_map>\n-#include <vector>\n-\n-#if defined(__GNUC__) && !defined(__clang__)\n-#pragma GCC diagnostic push\n-#pragma GCC diagnostic ignored \"-Wsuggest-override\"\n-#endif\n-#include <db_cxx.h>\n-#if defined(__GNUC__) && !defined(__clang__)\n-#pragma GCC diagnostic pop\n-#endif\n-\n-struct bilingual_str;\n-\n-static const unsigned int DEFAULT_WALLET_DBLOGSIZE = 100;\n-static const bool DEFAULT_WALLET_PRIVDB = true;\n-\n-struct WalletDatabaseFileId {\n-    u_int8_t value[DB_FILE_ID_LEN];\n-    bool operator==(const WalletDatabaseFileId& rhs) const;\n-};\n-\n-class BerkeleyDatabase;\n-\n-class BerkeleyEnvironment\n-{\n-private:\n-    bool fDbEnvInit;\n-    bool fMockDb;\n-    // Don't change into fs::path, as that can result in\n-    // shutdown problems/crashes caused by a static initialized internal pointer.\n-    std::string strPath;\n-\n-public:\n-    std::unique_ptr<DbEnv> dbenv;\n-    std::map<std::string, int> mapFileUseCount;\n-    std::map<std::string, std::reference_wrapper<BerkeleyDatabase>> m_databases;\n-    std::unordered_map<std::string, WalletDatabaseFileId> m_fileids;\n-    std::condition_variable_any m_db_in_use;\n-\n-    BerkeleyEnvironment(const fs::path& env_directory);\n-    BerkeleyEnvironment();\n-    ~BerkeleyEnvironment();\n-    void Reset();\n-\n-    bool IsMock() const { return fMockDb; }\n-    bool IsInitialized() const { return fDbEnvInit; }\n-    bool IsDatabaseLoaded(const std::string& db_filename) const { return m_databases.find(db_filename) != m_databases.end(); }\n-    fs::path Directory() const { return strPath; }\n-\n-    bool Verify(const std::string& strFile);\n-\n-    bool Open(bool retry);\n-    void Close();\n-    void Flush(bool fShutdown);\n-    void CheckpointLSN(const std::string& strFile);\n-\n-    void CloseDb(const std::string& strFile);\n-    void ReloadDbEnv();\n-\n-    DbTxn* TxnBegin(int flags = DB_TXN_WRITE_NOSYNC)\n-    {\n-        DbTxn* ptxn = nullptr;\n-        int ret = dbenv->txn_begin(nullptr, &ptxn, flags);\n-        if (!ptxn || ret != 0)\n-            return nullptr;\n-        return ptxn;\n-    }\n-};\n-\n-/** Return whether a wallet database is currently loaded. */\n-bool IsBDBWalletLoaded(const fs::path& wallet_path);\n \n /** Given a wallet directory path or legacy file path, return path to main data file in the wallet database. */\n fs::path WalletDataFilePath(const fs::path& wallet_path);\n void SplitWalletPath(const fs::path& wallet_path, fs::path& env_directory, std::string& database_filename);\n \n-/** Get BerkeleyEnvironment and database filename given a wallet path. */\n-std::shared_ptr<BerkeleyEnvironment> GetWalletEnv(const fs::path& wallet_path, std::string& database_filename);\n-\n-/** An instance of this class represents one database.\n- * For BerkeleyDB this is just a (env, strFile) tuple.\n- **/\n-class BerkeleyDatabase\n-{\n-    friend class BerkeleyBatch;\n-public:\n-    /** Create dummy DB handle */\n-    BerkeleyDatabase() : nUpdateCounter(0), nLastSeen(0), nLastFlushed(0), nLastWalletUpdate(0), env(nullptr)\n-    {\n-    }\n-\n-    /** Create DB handle to real database */\n-    BerkeleyDatabase(std::shared_ptr<BerkeleyEnvironment> env, std::string filename) :\n-        nUpdateCounter(0), nLastSeen(0), nLastFlushed(0), nLastWalletUpdate(0), env(std::move(env)), strFile(std::move(filename))\n-    {\n-        auto inserted = this->env->m_databases.emplace(strFile, std::ref(*this));\n-        assert(inserted.second);\n-    }\n-\n-    ~BerkeleyDatabase() {\n-        if (env) {\n-            size_t erased = env->m_databases.erase(strFile);\n-            assert(erased == 1);\n-        }\n-    }\n-\n-    /** Return object for accessing database at specified path. */\n-    static std::unique_ptr<BerkeleyDatabase> Create(const fs::path& path)\n-    {\n-        std::string filename;\n-        return MakeUnique<BerkeleyDatabase>(GetWalletEnv(path, filename), std::move(filename));\n-    }\n-\n-    /** Return object for accessing dummy database with no read/write capabilities. */\n-    static std::unique_ptr<BerkeleyDatabase> CreateDummy()\n-    {\n-        return MakeUnique<BerkeleyDatabase>();\n-    }\n-\n-    /** Return object for accessing temporary in-memory database. */\n-    static std::unique_ptr<BerkeleyDatabase> CreateMock()\n-    {\n-        return MakeUnique<BerkeleyDatabase>(std::make_shared<BerkeleyEnvironment>(), \"\");\n-    }\n-\n-    /** Rewrite the entire database on disk, with the exception of key pszSkip if non-zero\n-     */\n-    bool Rewrite(const char* pszSkip=nullptr);\n-\n-    /** Back up the entire database to a file.\n-     */\n-    bool Backup(const std::string& strDest) const;\n-\n-    /** Make sure all changes are flushed to disk.\n-     */\n-    void Flush(bool shutdown);\n-\n-    void IncrementUpdateCounter();\n-\n-    void ReloadDbEnv();\n-\n-    std::atomic<unsigned int> nUpdateCounter;\n-    unsigned int nLastSeen;\n-    unsigned int nLastFlushed;\n-    int64_t nLastWalletUpdate;\n-\n-    /**\n-     * Pointer to shared database environment.\n-     *\n-     * Normally there is only one BerkeleyDatabase object per\n-     * BerkeleyEnvivonment, but in the special, backwards compatible case where\n-     * multiple wallet BDB data files are loaded from the same directory, this\n-     * will point to a shared instance that gets freed when the last data file\n-     * is closed.\n-     */\n-    std::shared_ptr<BerkeleyEnvironment> env;\n-\n-    /** Database pointer. This is initialized lazily and reset during flushes, so it can be null. */\n-    std::unique_ptr<Db> m_db;\n-\n-private:\n-    std::string strFile;\n-\n-    /** Return whether this database handle is a dummy for testing.\n-     * Only to be used at a low level, application should ideally not care\n-     * about this.\n-     */\n-    bool IsDummy() const { return env == nullptr; }\n-};\n-\n-/** RAII class that provides access to a Berkeley database */\n-class BerkeleyBatch\n-{\n-    /** RAII class that automatically cleanses its data on destruction */\n-    class SafeDbt final\n-    {\n-        Dbt m_dbt;\n-\n-    public:\n-        // construct Dbt with internally-managed data\n-        SafeDbt();\n-        // construct Dbt with provided data\n-        SafeDbt(void* data, size_t size);\n-        ~SafeDbt();\n-\n-        // delegate to Dbt\n-        const void* get_data() const;\n-        u_int32_t get_size() const;\n-\n-        // conversion operator to access the underlying Dbt\n-        operator Dbt*();\n-    };\n-\n-protected:\n-    Db* pdb;\n-    std::string strFile;\n-    DbTxn* activeTxn;\n-    bool fReadOnly;\n-    bool fFlushOnClose;\n-    BerkeleyEnvironment *env;\n-\n-public:\n-    explicit BerkeleyBatch(BerkeleyDatabase& database, const char* pszMode = \"r+\", bool fFlushOnCloseIn=true);\n-    ~BerkeleyBatch() { Close(); }\n-\n-    BerkeleyBatch(const BerkeleyBatch&) = delete;\n-    BerkeleyBatch& operator=(const BerkeleyBatch&) = delete;\n-\n-    void Flush();\n-    void Close();\n-\n-    /* flush the wallet passively (TRY_LOCK)\n-       ideal to be called periodically */\n-    static bool PeriodicFlush(BerkeleyDatabase& database);\n-    /* verifies the database environment */\n-    static bool VerifyEnvironment(const fs::path& file_path, bilingual_str& errorStr);\n-    /* verifies the database file */\n-    static bool VerifyDatabaseFile(const fs::path& file_path, bilingual_str& errorStr);\n-\n-    template <typename K, typename T>\n-    bool Read(const K& key, T& value)\n-    {\n-        if (!pdb)\n-            return false;\n-\n-        // Key\n-        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n-        ssKey.reserve(1000);\n-        ssKey << key;\n-        SafeDbt datKey(ssKey.data(), ssKey.size());\n-\n-        // Read\n-        SafeDbt datValue;\n-        int ret = pdb->get(activeTxn, datKey, datValue, 0);\n-        bool success = false;\n-        if (datValue.get_data() != nullptr) {\n-            // Unserialize value\n-            try {\n-                CDataStream ssValue((char*)datValue.get_data(), (char*)datValue.get_data() + datValue.get_size(), SER_DISK, CLIENT_VERSION);\n-                ssValue >> value;\n-                success = true;\n-            } catch (const std::exception&) {\n-                // In this case success remains 'false'\n-            }\n-        }\n-        return ret == 0 && success;\n-    }\n-\n-    template <typename K, typename T>\n-    bool Write(const K& key, const T& value, bool fOverwrite = true)\n-    {\n-        if (!pdb)\n-            return true;\n-        if (fReadOnly)\n-            assert(!\"Write called on database in read-only mode\");\n-\n-        // Key\n-        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n-        ssKey.reserve(1000);\n-        ssKey << key;\n-        SafeDbt datKey(ssKey.data(), ssKey.size());\n-\n-        // Value\n-        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n-        ssValue.reserve(10000);\n-        ssValue << value;\n-        SafeDbt datValue(ssValue.data(), ssValue.size());\n-\n-        // Write\n-        int ret = pdb->put(activeTxn, datKey, datValue, (fOverwrite ? 0 : DB_NOOVERWRITE));\n-        return (ret == 0);\n-    }\n-\n-    template <typename K>\n-    bool Erase(const K& key)\n-    {\n-        if (!pdb)\n-            return false;\n-        if (fReadOnly)\n-            assert(!\"Erase called on database in read-only mode\");\n-\n-        // Key\n-        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n-        ssKey.reserve(1000);\n-        ssKey << key;\n-        SafeDbt datKey(ssKey.data(), ssKey.size());\n-\n-        // Erase\n-        int ret = pdb->del(activeTxn, datKey, 0);\n-        return (ret == 0 || ret == DB_NOTFOUND);\n-    }\n-\n-    template <typename K>\n-    bool Exists(const K& key)\n-    {\n-        if (!pdb)\n-            return false;\n-\n-        // Key\n-        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n-        ssKey.reserve(1000);\n-        ssKey << key;\n-        SafeDbt datKey(ssKey.data(), ssKey.size());\n-\n-        // Exists\n-        int ret = pdb->exists(activeTxn, datKey, 0);\n-        return (ret == 0);\n-    }\n-\n-    Dbc* GetCursor();\n-    int ReadAtCursor(Dbc* pcursor, CDataStream& ssKey, CDataStream& ssValue);\n-    bool TxnBegin();\n-    bool TxnCommit();\n-    bool TxnAbort();\n-\n-    bool static Rewrite(BerkeleyDatabase& database, const char* pszSkip = nullptr);\n-};\n-\n-std::string BerkeleyDatabaseVersion();\n-\n #endif // BITCOIN_WALLET_DB_H"
      },
      {
        "sha": "8f0083cd2e4bf0cef43f461460b252ed2279c6da",
        "filename": "src/wallet/test/db_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/61c16339da4e80b1320a6296df6d96cd7a84bb4e/src/wallet/test/db_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/61c16339da4e80b1320a6296df6d96cd7a84bb4e/src/wallet/test/db_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/db_tests.cpp?ref=61c16339da4e80b1320a6296df6d96cd7a84bb4e",
        "patch": "@@ -8,7 +8,7 @@\n \n #include <fs.h>\n #include <test/util/setup_common.h>\n-#include <wallet/db.h>\n+#include <wallet/bdb.h>\n \n \n BOOST_FIXTURE_TEST_SUITE(db_tests, BasicTestingSetup)"
      },
      {
        "sha": "1037bd579feccf7eaafc855eb27c1eb98fc2b90e",
        "filename": "src/wallet/walletdb.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/61c16339da4e80b1320a6296df6d96cd7a84bb4e/src/wallet/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/61c16339da4e80b1320a6296df6d96cd7a84bb4e/src/wallet/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.h?ref=61c16339da4e80b1320a6296df6d96cd7a84bb4e",
        "patch": "@@ -8,6 +8,7 @@\n \n #include <amount.h>\n #include <script/sign.h>\n+#include <wallet/bdb.h>\n #include <wallet/db.h>\n #include <wallet/walletutil.h>\n #include <key.h>"
      }
    ]
  }
]