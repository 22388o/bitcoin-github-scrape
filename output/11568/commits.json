[
  {
    "sha": "4637f18522429473e68f6f512a03040e121a446d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NjM3ZjE4NTIyNDI5NDczZTY4ZjZmNTEyYTAzMDQwZTEyMWE0NDZk",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-10-26T18:46:17Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-10-26T20:37:06Z"
      },
      "message": "moveonly: factor out headers processing into separate function\n\nProcessMessages will now return earlier when processing headers\nmessages, rather than continuing on (and do nothing).",
      "tree": {
        "sha": "c4acdb165a3e94bac76e8c698d3a7d49eaba5fdc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c4acdb165a3e94bac76e8c698d3a7d49eaba5fdc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4637f18522429473e68f6f512a03040e121a446d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4637f18522429473e68f6f512a03040e121a446d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4637f18522429473e68f6f512a03040e121a446d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4637f18522429473e68f6f512a03040e121a446d/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d93fa261f079d529a94ff26aa406a49e28d10340",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d93fa261f079d529a94ff26aa406a49e28d10340",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d93fa261f079d529a94ff26aa406a49e28d10340"
      }
    ],
    "stats": {
      "total": 336,
      "additions": 173,
      "deletions": 163
    },
    "files": [
      {
        "sha": "78dc1a752ab5052ee2798f708573900ec7dce823",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 173,
        "deletions": 163,
        "changes": 336,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4637f18522429473e68f6f512a03040e121a446d/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4637f18522429473e68f6f512a03040e121a446d/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=4637f18522429473e68f6f512a03040e121a446d",
        "patch": "@@ -1205,6 +1205,178 @@ inline void static SendBlockTransactions(const CBlock& block, const BlockTransac\n     connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));\n }\n \n+bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::vector<CBlockHeader>& headers, const CChainParams& chainparams)\n+{\n+    const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n+    size_t nCount = headers.size();\n+\n+    if (nCount == 0) {\n+        // Nothing interesting. Stop asking this peers for more headers.\n+        return true;\n+    }\n+\n+    const CBlockIndex *pindexLast = nullptr;\n+    {\n+        LOCK(cs_main);\n+        CNodeState *nodestate = State(pfrom->GetId());\n+\n+        // If this looks like it could be a block announcement (nCount <\n+        // MAX_BLOCKS_TO_ANNOUNCE), use special logic for handling headers that\n+        // don't connect:\n+        // - Send a getheaders message in response to try to connect the chain.\n+        // - The peer can send up to MAX_UNCONNECTING_HEADERS in a row that\n+        //   don't connect before giving DoS points\n+        // - Once a headers message is received that is valid and does connect,\n+        //   nUnconnectingHeaders gets reset back to 0.\n+        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end() && nCount < MAX_BLOCKS_TO_ANNOUNCE) {\n+            nodestate->nUnconnectingHeaders++;\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));\n+            LogPrint(BCLog::NET, \"received header %s: missing prev block %s, sending getheaders (%d) to end (peer=%d, nUnconnectingHeaders=%d)\\n\",\n+                    headers[0].GetHash().ToString(),\n+                    headers[0].hashPrevBlock.ToString(),\n+                    pindexBestHeader->nHeight,\n+                    pfrom->GetId(), nodestate->nUnconnectingHeaders);\n+            // Set hashLastUnknownBlock for this peer, so that if we\n+            // eventually get the headers - even from a different peer -\n+            // we can use this peer to download.\n+            UpdateBlockAvailability(pfrom->GetId(), headers.back().GetHash());\n+\n+            if (nodestate->nUnconnectingHeaders % MAX_UNCONNECTING_HEADERS == 0) {\n+                Misbehaving(pfrom->GetId(), 20);\n+            }\n+            return true;\n+        }\n+\n+        uint256 hashLastBlock;\n+        for (const CBlockHeader& header : headers) {\n+            if (!hashLastBlock.IsNull() && header.hashPrevBlock != hashLastBlock) {\n+                Misbehaving(pfrom->GetId(), 20);\n+                return error(\"non-continuous headers sequence\");\n+            }\n+            hashLastBlock = header.GetHash();\n+        }\n+    }\n+\n+    CValidationState state;\n+    if (!ProcessNewBlockHeaders(headers, state, chainparams, &pindexLast)) {\n+        int nDoS;\n+        if (state.IsInvalid(nDoS)) {\n+            if (nDoS > 0) {\n+                LOCK(cs_main);\n+                Misbehaving(pfrom->GetId(), nDoS);\n+            }\n+            return error(\"invalid header received\");\n+        }\n+    }\n+\n+    {\n+        LOCK(cs_main);\n+        CNodeState *nodestate = State(pfrom->GetId());\n+        if (nodestate->nUnconnectingHeaders > 0) {\n+            LogPrint(BCLog::NET, \"peer=%d: resetting nUnconnectingHeaders (%d -> 0)\\n\", pfrom->GetId(), nodestate->nUnconnectingHeaders);\n+        }\n+        nodestate->nUnconnectingHeaders = 0;\n+\n+        assert(pindexLast);\n+        UpdateBlockAvailability(pfrom->GetId(), pindexLast->GetBlockHash());\n+\n+        // From here, pindexBestKnownBlock should be guaranteed to be non-null,\n+        // because it is set in UpdateBlockAvailability. Some nullptr checks\n+        // are still present, however, as belt-and-suspenders.\n+\n+        if (nCount == MAX_HEADERS_RESULTS) {\n+            // Headers message had its maximum size; the peer may have more headers.\n+            // TODO: optimize: if pindexLast is an ancestor of chainActive.Tip or pindexBestHeader, continue\n+            // from there instead.\n+            LogPrint(BCLog::NET, \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\", pindexLast->nHeight, pfrom->GetId(), pfrom->nStartingHeight);\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexLast), uint256()));\n+        }\n+\n+        bool fCanDirectFetch = CanDirectFetch(chainparams.GetConsensus());\n+        // If this set of headers is valid and ends in a block with at least as\n+        // much work as our tip, download as much as possible.\n+        if (fCanDirectFetch && pindexLast->IsValid(BLOCK_VALID_TREE) && chainActive.Tip()->nChainWork <= pindexLast->nChainWork) {\n+            std::vector<const CBlockIndex*> vToFetch;\n+            const CBlockIndex *pindexWalk = pindexLast;\n+            // Calculate all the blocks we'd need to switch to pindexLast, up to a limit.\n+            while (pindexWalk && !chainActive.Contains(pindexWalk) && vToFetch.size() <= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+                if (!(pindexWalk->nStatus & BLOCK_HAVE_DATA) &&\n+                        !mapBlocksInFlight.count(pindexWalk->GetBlockHash()) &&\n+                        (!IsWitnessEnabled(pindexWalk->pprev, chainparams.GetConsensus()) || State(pfrom->GetId())->fHaveWitness)) {\n+                    // We don't have this block, and it's not yet in flight.\n+                    vToFetch.push_back(pindexWalk);\n+                }\n+                pindexWalk = pindexWalk->pprev;\n+            }\n+            // If pindexWalk still isn't on our main chain, we're looking at a\n+            // very large reorg at a time we think we're close to caught up to\n+            // the main chain -- this shouldn't really happen.  Bail out on the\n+            // direct fetch and rely on parallel download instead.\n+            if (!chainActive.Contains(pindexWalk)) {\n+                LogPrint(BCLog::NET, \"Large reorg, won't direct fetch to %s (%d)\\n\",\n+                        pindexLast->GetBlockHash().ToString(),\n+                        pindexLast->nHeight);\n+            } else {\n+                std::vector<CInv> vGetData;\n+                // Download as much as possible, from earliest to latest.\n+                for (const CBlockIndex *pindex : reverse_iterate(vToFetch)) {\n+                    if (nodestate->nBlocksInFlight >= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+                        // Can't download any more from this peer\n+                        break;\n+                    }\n+                    uint32_t nFetchFlags = GetFetchFlags(pfrom);\n+                    vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n+                    MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), pindex);\n+                    LogPrint(BCLog::NET, \"Requesting block %s from  peer=%d\\n\",\n+                            pindex->GetBlockHash().ToString(), pfrom->GetId());\n+                }\n+                if (vGetData.size() > 1) {\n+                    LogPrint(BCLog::NET, \"Downloading blocks toward %s (%d) via headers direct fetch\\n\",\n+                            pindexLast->GetBlockHash().ToString(), pindexLast->nHeight);\n+                }\n+                if (vGetData.size() > 0) {\n+                    if (nodestate->fSupportsDesiredCmpctVersion && vGetData.size() == 1 && mapBlocksInFlight.size() == 1 && pindexLast->pprev->IsValid(BLOCK_VALID_CHAIN)) {\n+                        // In any case, we want to download using a compact block, not a regular one\n+                        vGetData[0] = CInv(MSG_CMPCT_BLOCK, vGetData[0].hash);\n+                    }\n+                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n+                }\n+            }\n+        }\n+        // If we're in IBD, we want outbound peers that will serve us a useful\n+        // chain. Disconnect peers that are on chains with insufficient work.\n+        if (IsInitialBlockDownload() && nCount != MAX_HEADERS_RESULTS) {\n+            // When nCount < MAX_HEADERS_RESULTS, we know we have no more\n+            // headers to fetch from this peer.\n+            if (nodestate->pindexBestKnownBlock && nodestate->pindexBestKnownBlock->nChainWork < nMinimumChainWork) {\n+                // This peer has too little work on their headers chain to help\n+                // us sync -- disconnect if using an outbound slot (unless\n+                // whitelisted or addnode).\n+                // Note: We compare their tip to nMinimumChainWork (rather than\n+                // chainActive.Tip()) because we won't start block download\n+                // until we have a headers chain that has at least\n+                // nMinimumChainWork, even if a peer has a chain past our tip,\n+                // as an anti-DoS measure.\n+                if (IsOutboundDisconnectionCandidate(pfrom)) {\n+                    LogPrintf(\"Disconnecting outbound peer %d -- headers chain has insufficient work\\n\", pfrom->GetId());\n+                    pfrom->fDisconnect = true;\n+                }\n+            }\n+        }\n+\n+        if (!pfrom->fDisconnect && IsOutboundDisconnectionCandidate(pfrom) && nodestate->pindexBestKnownBlock != nullptr) {\n+            // If this is an outbound peer, check to see if we should protect\n+            // it from the bad/lagging chain logic.\n+            if (g_outbound_peers_with_protect_from_disconnect < MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT && nodestate->pindexBestKnownBlock->nChainWork >= chainActive.Tip()->nChainWork && !nodestate->m_chain_sync.m_protect) {\n+                nodestate->m_chain_sync.m_protect = true;\n+                ++g_outbound_peers_with_protect_from_disconnect;\n+            }\n+        }\n+    }\n+\n+    return true;\n+}\n+\n bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n {\n     LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->GetId());\n@@ -2308,169 +2480,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             ReadCompactSize(vRecv); // ignore tx count; assume it is 0.\n         }\n \n-        if (nCount == 0) {\n-            // Nothing interesting. Stop asking this peers for more headers.\n-            return true;\n-        }\n-\n-        const CBlockIndex *pindexLast = nullptr;\n-        {\n-        LOCK(cs_main);\n-        CNodeState *nodestate = State(pfrom->GetId());\n-\n-        // If this looks like it could be a block announcement (nCount <\n-        // MAX_BLOCKS_TO_ANNOUNCE), use special logic for handling headers that\n-        // don't connect:\n-        // - Send a getheaders message in response to try to connect the chain.\n-        // - The peer can send up to MAX_UNCONNECTING_HEADERS in a row that\n-        //   don't connect before giving DoS points\n-        // - Once a headers message is received that is valid and does connect,\n-        //   nUnconnectingHeaders gets reset back to 0.\n-        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end() && nCount < MAX_BLOCKS_TO_ANNOUNCE) {\n-            nodestate->nUnconnectingHeaders++;\n-            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));\n-            LogPrint(BCLog::NET, \"received header %s: missing prev block %s, sending getheaders (%d) to end (peer=%d, nUnconnectingHeaders=%d)\\n\",\n-                    headers[0].GetHash().ToString(),\n-                    headers[0].hashPrevBlock.ToString(),\n-                    pindexBestHeader->nHeight,\n-                    pfrom->GetId(), nodestate->nUnconnectingHeaders);\n-            // Set hashLastUnknownBlock for this peer, so that if we\n-            // eventually get the headers - even from a different peer -\n-            // we can use this peer to download.\n-            UpdateBlockAvailability(pfrom->GetId(), headers.back().GetHash());\n-\n-            if (nodestate->nUnconnectingHeaders % MAX_UNCONNECTING_HEADERS == 0) {\n-                Misbehaving(pfrom->GetId(), 20);\n-            }\n-            return true;\n-        }\n-\n-        uint256 hashLastBlock;\n-        for (const CBlockHeader& header : headers) {\n-            if (!hashLastBlock.IsNull() && header.hashPrevBlock != hashLastBlock) {\n-                Misbehaving(pfrom->GetId(), 20);\n-                return error(\"non-continuous headers sequence\");\n-            }\n-            hashLastBlock = header.GetHash();\n-        }\n-        }\n-\n-        CValidationState state;\n-        if (!ProcessNewBlockHeaders(headers, state, chainparams, &pindexLast)) {\n-            int nDoS;\n-            if (state.IsInvalid(nDoS)) {\n-                if (nDoS > 0) {\n-                    LOCK(cs_main);\n-                    Misbehaving(pfrom->GetId(), nDoS);\n-                }\n-                return error(\"invalid header received\");\n-            }\n-        }\n-\n-        {\n-        LOCK(cs_main);\n-        CNodeState *nodestate = State(pfrom->GetId());\n-        if (nodestate->nUnconnectingHeaders > 0) {\n-            LogPrint(BCLog::NET, \"peer=%d: resetting nUnconnectingHeaders (%d -> 0)\\n\", pfrom->GetId(), nodestate->nUnconnectingHeaders);\n-        }\n-        nodestate->nUnconnectingHeaders = 0;\n-\n-        assert(pindexLast);\n-        UpdateBlockAvailability(pfrom->GetId(), pindexLast->GetBlockHash());\n-\n-        // From here, pindexBestKnownBlock should be guaranteed to be non-null,\n-        // because it is set in UpdateBlockAvailability. Some nullptr checks\n-        // are still present, however, as belt-and-suspenders.\n-\n-        if (nCount == MAX_HEADERS_RESULTS) {\n-            // Headers message had its maximum size; the peer may have more headers.\n-            // TODO: optimize: if pindexLast is an ancestor of chainActive.Tip or pindexBestHeader, continue\n-            // from there instead.\n-            LogPrint(BCLog::NET, \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\", pindexLast->nHeight, pfrom->GetId(), pfrom->nStartingHeight);\n-            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexLast), uint256()));\n-        }\n-\n-        bool fCanDirectFetch = CanDirectFetch(chainparams.GetConsensus());\n-        // If this set of headers is valid and ends in a block with at least as\n-        // much work as our tip, download as much as possible.\n-        if (fCanDirectFetch && pindexLast->IsValid(BLOCK_VALID_TREE) && chainActive.Tip()->nChainWork <= pindexLast->nChainWork) {\n-            std::vector<const CBlockIndex*> vToFetch;\n-            const CBlockIndex *pindexWalk = pindexLast;\n-            // Calculate all the blocks we'd need to switch to pindexLast, up to a limit.\n-            while (pindexWalk && !chainActive.Contains(pindexWalk) && vToFetch.size() <= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n-                if (!(pindexWalk->nStatus & BLOCK_HAVE_DATA) &&\n-                        !mapBlocksInFlight.count(pindexWalk->GetBlockHash()) &&\n-                        (!IsWitnessEnabled(pindexWalk->pprev, chainparams.GetConsensus()) || State(pfrom->GetId())->fHaveWitness)) {\n-                    // We don't have this block, and it's not yet in flight.\n-                    vToFetch.push_back(pindexWalk);\n-                }\n-                pindexWalk = pindexWalk->pprev;\n-            }\n-            // If pindexWalk still isn't on our main chain, we're looking at a\n-            // very large reorg at a time we think we're close to caught up to\n-            // the main chain -- this shouldn't really happen.  Bail out on the\n-            // direct fetch and rely on parallel download instead.\n-            if (!chainActive.Contains(pindexWalk)) {\n-                LogPrint(BCLog::NET, \"Large reorg, won't direct fetch to %s (%d)\\n\",\n-                        pindexLast->GetBlockHash().ToString(),\n-                        pindexLast->nHeight);\n-            } else {\n-                std::vector<CInv> vGetData;\n-                // Download as much as possible, from earliest to latest.\n-                for (const CBlockIndex *pindex : reverse_iterate(vToFetch)) {\n-                    if (nodestate->nBlocksInFlight >= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n-                        // Can't download any more from this peer\n-                        break;\n-                    }\n-                    uint32_t nFetchFlags = GetFetchFlags(pfrom);\n-                    vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n-                    MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), pindex);\n-                    LogPrint(BCLog::NET, \"Requesting block %s from  peer=%d\\n\",\n-                            pindex->GetBlockHash().ToString(), pfrom->GetId());\n-                }\n-                if (vGetData.size() > 1) {\n-                    LogPrint(BCLog::NET, \"Downloading blocks toward %s (%d) via headers direct fetch\\n\",\n-                            pindexLast->GetBlockHash().ToString(), pindexLast->nHeight);\n-                }\n-                if (vGetData.size() > 0) {\n-                    if (nodestate->fSupportsDesiredCmpctVersion && vGetData.size() == 1 && mapBlocksInFlight.size() == 1 && pindexLast->pprev->IsValid(BLOCK_VALID_CHAIN)) {\n-                        // In any case, we want to download using a compact block, not a regular one\n-                        vGetData[0] = CInv(MSG_CMPCT_BLOCK, vGetData[0].hash);\n-                    }\n-                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n-                }\n-            }\n-        }\n-        // If we're in IBD, we want outbound peers that will serve us a useful\n-        // chain. Disconnect peers that are on chains with insufficient work.\n-        if (IsInitialBlockDownload() && nCount != MAX_HEADERS_RESULTS) {\n-            // When nCount < MAX_HEADERS_RESULTS, we know we have no more\n-            // headers to fetch from this peer.\n-            if (nodestate->pindexBestKnownBlock && nodestate->pindexBestKnownBlock->nChainWork < nMinimumChainWork) {\n-                // This peer has too little work on their headers chain to help\n-                // us sync -- disconnect if using an outbound slot (unless\n-                // whitelisted or addnode).\n-                // Note: We compare their tip to nMinimumChainWork (rather than\n-                // chainActive.Tip()) because we won't start block download\n-                // until we have a headers chain that has at least\n-                // nMinimumChainWork, even if a peer has a chain past our tip,\n-                // as an anti-DoS measure.\n-                if (IsOutboundDisconnectionCandidate(pfrom)) {\n-                    LogPrintf(\"Disconnecting outbound peer %d -- headers chain has insufficient work\\n\", pfrom->GetId());\n-                    pfrom->fDisconnect = true;\n-                }\n-            }\n-        }\n-\n-        if (!pfrom->fDisconnect && IsOutboundDisconnectionCandidate(pfrom) && nodestate->pindexBestKnownBlock != nullptr) {\n-            // If this is an outbound peer, check to see if we should protect\n-            // it from the bad/lagging chain logic.\n-            if (g_outbound_peers_with_protect_from_disconnect < MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT && nodestate->pindexBestKnownBlock->nChainWork >= chainActive.Tip()->nChainWork && !nodestate->m_chain_sync.m_protect) {\n-                nodestate->m_chain_sync.m_protect = true;\n-                ++g_outbound_peers_with_protect_from_disconnect;\n-            }\n-        }\n-        }\n+        return ProcessHeadersMessage(pfrom, connman, headers, chainparams);\n     }\n \n     else if (strCommand == NetMsgType::BLOCK && !fImporting && !fReindex) // Ignore blocks received while importing"
      }
    ]
  },
  {
    "sha": "37886d5e2f9992678dea4b1bd893f4f10d61d3ad",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNzg4NmQ1ZTJmOTk5MjY3OGRlYTRiMWJkODkzZjRmMTBkNjFkM2Fk",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-10-26T18:54:33Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-10-27T20:29:12Z"
      },
      "message": "Disconnect outbound peers relaying invalid headers",
      "tree": {
        "sha": "25a7e92c05cad5014c522310e76efd4fbf88bb84",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/25a7e92c05cad5014c522310e76efd4fbf88bb84"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/37886d5e2f9992678dea4b1bd893f4f10d61d3ad",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/37886d5e2f9992678dea4b1bd893f4f10d61d3ad",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/37886d5e2f9992678dea4b1bd893f4f10d61d3ad",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/37886d5e2f9992678dea4b1bd893f4f10d61d3ad/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4637f18522429473e68f6f512a03040e121a446d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4637f18522429473e68f6f512a03040e121a446d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4637f18522429473e68f6f512a03040e121a446d"
      }
    ],
    "stats": {
      "total": 68,
      "additions": 56,
      "deletions": 12
    },
    "files": [
      {
        "sha": "4c3aacaf5f8609b678e88b1014a481b5e8eb00bb",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 51,
        "deletions": 10,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/37886d5e2f9992678dea4b1bd893f4f10d61d3ad/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/37886d5e2f9992678dea4b1bd893f4f10d61d3ad/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=37886d5e2f9992678dea4b1bd893f4f10d61d3ad",
        "patch": "@@ -1205,7 +1205,7 @@ inline void static SendBlockTransactions(const CBlock& block, const BlockTransac\n     connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));\n }\n \n-bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::vector<CBlockHeader>& headers, const CChainParams& chainparams)\n+bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::vector<CBlockHeader>& headers, const CChainParams& chainparams, bool punish_duplicate_invalid)\n {\n     const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n     size_t nCount = headers.size();\n@@ -1258,13 +1258,48 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n     }\n \n     CValidationState state;\n-    if (!ProcessNewBlockHeaders(headers, state, chainparams, &pindexLast)) {\n+    CBlockHeader first_invalid_header;\n+    if (!ProcessNewBlockHeaders(headers, state, chainparams, &pindexLast, &first_invalid_header)) {\n         int nDoS;\n         if (state.IsInvalid(nDoS)) {\n             if (nDoS > 0) {\n                 LOCK(cs_main);\n                 Misbehaving(pfrom->GetId(), nDoS);\n             }\n+            if (punish_duplicate_invalid && mapBlockIndex.find(first_invalid_header.GetHash()) != mapBlockIndex.end()) {\n+                // Goal: don't allow outbound peers to use up our outbound\n+                // connection slots if they are on incompatible chains.\n+                //\n+                // We ask the caller to set punish_invalid appropriately based\n+                // on the peer and the method of header delivery (compact\n+                // blocks are allowed to be invalid in some circumstances,\n+                // under BIP 152).\n+                // Here, we try to detect the narrow situation that we have a\n+                // valid block header (ie it was valid at the time the header\n+                // was received, and hence stored in mapBlockIndex) but know the\n+                // block is invalid, and that a peer has announced that same\n+                // block as being on its active chain.\n+                // Disconnect the peer in such a situation.\n+                //\n+                // Note: if the header that is invalid was not accepted to our\n+                // mapBlockIndex at all, that may also be grounds for\n+                // disconnecting the peer, as the chain they are on is likely\n+                // to be incompatible. However, there is a circumstance where\n+                // that does not hold: if the header's timestamp is more than\n+                // 2 hours ahead of our current time. In that case, the header\n+                // may become valid in the future, and we don't want to\n+                // disconnect a peer merely for serving us one too-far-ahead\n+                // block header, to prevent an attacker from splitting the\n+                // network by mining a block right at the 2 hour boundary.\n+                //\n+                // TODO: update the DoS logic (or, rather, rewrite the\n+                // DoS-interface between validation and net_processing) so that\n+                // the interface is cleaner, and so that we disconnect on all the\n+                // reasons that a peer's headers chain is incompatible\n+                // with ours (eg block->nVersion softforks, MTP violations,\n+                // etc), and not just the duplicate-invalid case.\n+                pfrom->fDisconnect = true;\n+            }\n             return error(\"invalid header received\");\n         }\n     }\n@@ -2219,7 +2254,6 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // If we end up treating this as a plain headers message, call that as well\n         // without cs_main.\n         bool fRevertToHeaderProcessing = false;\n-        CDataStream vHeadersMsg(SER_NETWORK, PROTOCOL_VERSION);\n \n         // Keep a CBlock for \"optimistic\" compactblock reconstructions (see\n         // below)\n@@ -2336,10 +2370,6 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 return true;\n             } else {\n                 // If this was an announce-cmpctblock, we want the same treatment as a header message\n-                // Dirty hack to process as if it were just a headers message (TODO: move message handling into their own functions)\n-                std::vector<CBlock> headers;\n-                headers.push_back(cmpctblock.header);\n-                vHeadersMsg << headers;\n                 fRevertToHeaderProcessing = true;\n             }\n         }\n@@ -2348,8 +2378,14 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (fProcessBLOCKTXN)\n             return ProcessMessage(pfrom, NetMsgType::BLOCKTXN, blockTxnMsg, nTimeReceived, chainparams, connman, interruptMsgProc);\n \n-        if (fRevertToHeaderProcessing)\n-            return ProcessMessage(pfrom, NetMsgType::HEADERS, vHeadersMsg, nTimeReceived, chainparams, connman, interruptMsgProc);\n+        if (fRevertToHeaderProcessing) {\n+            // Headers received from HB compact block peers are permitted to be\n+            // relayed before full validation (see BIP 152), so we don't want to disconnect\n+            // the peer if the header turns out to be for an invalid block.\n+            // Note that if a peer tries to build on an invalid chain, that\n+            // will be detected and the peer will be banned.\n+            return ProcessHeadersMessage(pfrom, connman, {cmpctblock.header}, chainparams, /*punish_duplicate_invalid=*/false);\n+        }\n \n         if (fBlockReconstructed) {\n             // If we got here, we were able to optimistically reconstruct a\n@@ -2480,7 +2516,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             ReadCompactSize(vRecv); // ignore tx count; assume it is 0.\n         }\n \n-        return ProcessHeadersMessage(pfrom, connman, headers, chainparams);\n+        // Headers received via a HEADERS message should be valid, and reflect\n+        // the chain the peer is on. If we receive a known-invalid header,\n+        // disconnect the peer if it is using one of our outbound connection\n+        // slots.\n+        bool should_punish = !pfrom->fInbound && !pfrom->m_manual_connection;\n+        return ProcessHeadersMessage(pfrom, connman, headers, chainparams, should_punish);\n     }\n \n     else if (strCommand == NetMsgType::BLOCK && !fImporting && !fReindex) // Ignore blocks received while importing"
      },
      {
        "sha": "78eb6d7302409aba715bb81567d36dddcd34a5e7",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/37886d5e2f9992678dea4b1bd893f4f10d61d3ad/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/37886d5e2f9992678dea4b1bd893f4f10d61d3ad/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=37886d5e2f9992678dea4b1bd893f4f10d61d3ad",
        "patch": "@@ -3079,13 +3079,15 @@ static bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state\n }\n \n // Exposed wrapper for AcceptBlockHeader\n-bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& headers, CValidationState& state, const CChainParams& chainparams, const CBlockIndex** ppindex)\n+bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& headers, CValidationState& state, const CChainParams& chainparams, const CBlockIndex** ppindex, CBlockHeader *first_invalid)\n {\n+    if (first_invalid != nullptr) first_invalid->SetNull();\n     {\n         LOCK(cs_main);\n         for (const CBlockHeader& header : headers) {\n             CBlockIndex *pindex = nullptr; // Use a temp pindex instead of ppindex to avoid a const_cast\n             if (!AcceptBlockHeader(header, state, chainparams, &pindex)) {\n+                if (first_invalid) *first_invalid = header;\n                 return false;\n             }\n             if (ppindex) {"
      },
      {
        "sha": "93669de6c4d7ae54bb14e042ca0dc84595b001aa",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/37886d5e2f9992678dea4b1bd893f4f10d61d3ad/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/37886d5e2f9992678dea4b1bd893f4f10d61d3ad/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=37886d5e2f9992678dea4b1bd893f4f10d61d3ad",
        "patch": "@@ -247,8 +247,9 @@ bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<cons\n  * @param[out] state This may be set to an Error state if any error occurred processing them\n  * @param[in]  chainparams The params for the chain we want to connect to\n  * @param[out] ppindex If set, the pointer will be set to point to the last new block index object for the given headers\n+ * @param[out] first_invalid First header that fails validation, if one exists\n  */\n-bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& block, CValidationState& state, const CChainParams& chainparams, const CBlockIndex** ppindex=nullptr);\n+bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& block, CValidationState& state, const CChainParams& chainparams, const CBlockIndex** ppindex=nullptr, CBlockHeader *first_invalid=nullptr);\n \n /** Check whether enough disk space is available for an incoming block */\n bool CheckDiskSpace(uint64_t nAdditionalBytes = 0);"
      }
    ]
  }
]