[
  {
    "sha": "ec89c16b0922e97cef9521015e5fe68ac25f7c57",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplYzg5YzE2YjA5MjJlOTdjZWY5NTIxMDE1ZTVmZTY4YWMyNWY3YzU3",
    "commit": {
      "author": {
        "name": "Zero Chen",
        "email": "chengang31@gmail.com",
        "date": "2017-05-30T08:38:13Z"
      },
      "committer": {
        "name": "Zero Chen",
        "email": "chengang31@gmail.com",
        "date": "2017-05-30T08:38:13Z"
      },
      "message": "Use C++ initializer to initialze map to avoid casting.",
      "tree": {
        "sha": "86fb8218660e771b42b18944ad591851d79f0fb7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/86fb8218660e771b42b18944ad591851d79f0fb7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ec89c16b0922e97cef9521015e5fe68ac25f7c57",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ec89c16b0922e97cef9521015e5fe68ac25f7c57",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ec89c16b0922e97cef9521015e5fe68ac25f7c57",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ec89c16b0922e97cef9521015e5fe68ac25f7c57/comments",
    "author": {
      "login": "cg31",
      "id": 575738,
      "node_id": "MDQ6VXNlcjU3NTczOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/575738?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cg31",
      "html_url": "https://github.com/cg31",
      "followers_url": "https://api.github.com/users/cg31/followers",
      "following_url": "https://api.github.com/users/cg31/following{/other_user}",
      "gists_url": "https://api.github.com/users/cg31/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cg31/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cg31/subscriptions",
      "organizations_url": "https://api.github.com/users/cg31/orgs",
      "repos_url": "https://api.github.com/users/cg31/repos",
      "events_url": "https://api.github.com/users/cg31/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cg31/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "cg31",
      "id": 575738,
      "node_id": "MDQ6VXNlcjU3NTczOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/575738?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cg31",
      "html_url": "https://github.com/cg31",
      "followers_url": "https://api.github.com/users/cg31/followers",
      "following_url": "https://api.github.com/users/cg31/following{/other_user}",
      "gists_url": "https://api.github.com/users/cg31/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cg31/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cg31/subscriptions",
      "organizations_url": "https://api.github.com/users/cg31/orgs",
      "repos_url": "https://api.github.com/users/cg31/repos",
      "events_url": "https://api.github.com/users/cg31/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cg31/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5c63d665e51ed0cd5d29275a5d63b07a64300ac8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5c63d665e51ed0cd5d29275a5d63b07a64300ac8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5c63d665e51ed0cd5d29275a5d63b07a64300ac8"
      }
    ],
    "stats": {
      "total": 45,
      "additions": 21,
      "deletions": 24
    },
    "files": [
      {
        "sha": "78c21fe946aecccf248f3598d430420781651618",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 24,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ec89c16b0922e97cef9521015e5fe68ac25f7c57/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ec89c16b0922e97cef9521015e5fe68ac25f7c57/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=ec89c16b0922e97cef9521015e5fe68ac25f7c57",
        "patch": "@@ -145,22 +145,21 @@ class CMainParams : public CChainParams {\n         fRequireStandard = true;\n         fMineBlocksOnDemand = false;\n \n-        checkpointData = (CCheckpointData) {\n-            boost::assign::map_list_of\n-            ( 11111, uint256S(\"0x0000000069e244f73d78e8fd29ba2fd2ed618bd6fa2ee92559f542fdb26e7c1d\"))\n-            ( 33333, uint256S(\"0x000000002dd5588a74784eaa7ab0507a18ad16a236e7b1ce69f00d7ddfb5d0a6\"))\n-            ( 74000, uint256S(\"0x0000000000573993a3c9e41ce34471c079dcf5f52a0e824a81e7f953b8661a20\"))\n-            (105000, uint256S(\"0x00000000000291ce28027faea320c8d2b054b2e0fe44a773f3eefb151d6bdc97\"))\n-            (134444, uint256S(\"0x00000000000005b12ffd4cd315cd34ffd4a594f430ac814c91184a0d42d2b0fe\"))\n-            (168000, uint256S(\"0x000000000000099e61ea72015e79632f216fe6cb33d7899acb35b75c8303b763\"))\n-            (193000, uint256S(\"0x000000000000059f452a5f7340de6682a977387c17010ff6e6c3bd83ca8b1317\"))\n-            (210000, uint256S(\"0x000000000000048b95347e83192f69cf0366076336c639f9b7228e9ba171342e\"))\n-            (216116, uint256S(\"0x00000000000001b4f4b433e81ee46494af945cf96014816a4e2370f11b23df4e\"))\n-            (225430, uint256S(\"0x00000000000001c108384350f74090433e7fcf79a606b8e797f065b130575932\"))\n-            (250000, uint256S(\"0x000000000000003887df1f29024b06fc2200b55f8af8f35453d7be294df2d214\"))\n-            (279000, uint256S(\"0x0000000000000001ae8c72a0b0c301f67e3afca10e819efa9041e458e9bd7e40\"))\n-            (295000, uint256S(\"0x00000000000000004d9b4ef50f0f9d686fd69db2e03af35a100370c64632a983\"))\n-        };\n+        checkpointData = { {\n+            { 11111, uint256S(\"0x0000000069e244f73d78e8fd29ba2fd2ed618bd6fa2ee92559f542fdb26e7c1d\")},\n+            { 33333, uint256S(\"0x000000002dd5588a74784eaa7ab0507a18ad16a236e7b1ce69f00d7ddfb5d0a6\")},\n+            { 74000, uint256S(\"0x0000000000573993a3c9e41ce34471c079dcf5f52a0e824a81e7f953b8661a20\")},\n+            {105000, uint256S(\"0x00000000000291ce28027faea320c8d2b054b2e0fe44a773f3eefb151d6bdc97\")},\n+            {134444, uint256S(\"0x00000000000005b12ffd4cd315cd34ffd4a594f430ac814c91184a0d42d2b0fe\")},\n+            {168000, uint256S(\"0x000000000000099e61ea72015e79632f216fe6cb33d7899acb35b75c8303b763\")},\n+            {193000, uint256S(\"0x000000000000059f452a5f7340de6682a977387c17010ff6e6c3bd83ca8b1317\")},\n+            {210000, uint256S(\"0x000000000000048b95347e83192f69cf0366076336c639f9b7228e9ba171342e\")},\n+            {216116, uint256S(\"0x00000000000001b4f4b433e81ee46494af945cf96014816a4e2370f11b23df4e\")},\n+            {225430, uint256S(\"0x00000000000001c108384350f74090433e7fcf79a606b8e797f065b130575932\")},\n+            {250000, uint256S(\"0x000000000000003887df1f29024b06fc2200b55f8af8f35453d7be294df2d214\")},\n+            {279000, uint256S(\"0x0000000000000001ae8c72a0b0c301f67e3afca10e819efa9041e458e9bd7e40\")},\n+            {295000, uint256S(\"0x00000000000000004d9b4ef50f0f9d686fd69db2e03af35a100370c64632a983\")}\n+        } };\n \n         chainTxData = ChainTxData{\n             // Data as of block 00000000000000000166d612d5595e2b1cd88d71d695fc580af64d8da8658c23 (height 446482).\n@@ -244,10 +243,9 @@ class CTestNetParams : public CChainParams {\n         fMineBlocksOnDemand = false;\n \n \n-        checkpointData = (CCheckpointData) {\n-            boost::assign::map_list_of\n-            ( 546, uint256S(\"000000002a936ca763904c3c35fce2f3556c559c0214345d31b1bcebf76acb70\")),\n-        };\n+        checkpointData = { {\n+            {546, uint256S(\"000000002a936ca763904c3c35fce2f3556c559c0214345d31b1bcebf76acb70\")}\n+        } };\n \n         chainTxData = ChainTxData{\n             // Data as of block 00000000c2872f8f8a8935c8e3c5862be9038c97d4de2cf37ed496991166928a (height 1063660)\n@@ -313,10 +311,9 @@ class CRegTestParams : public CChainParams {\n         fRequireStandard = false;\n         fMineBlocksOnDemand = true;\n \n-        checkpointData = (CCheckpointData){\n-            boost::assign::map_list_of\n-            ( 0, uint256S(\"0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\"))\n-        };\n+        checkpointData = { {\n+            {0, uint256S(\"0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\")}\n+        } };\n \n         chainTxData = ChainTxData{\n             0,"
      }
    ]
  },
  {
    "sha": "b28f8c0bcfaaa81f83a1d53e0e63f6293ecc3d2f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMjhmOGMwYmNmYWFhODFmODNhMWQ1M2UwZTYzZjYyOTNlY2MzZDJm",
    "commit": {
      "author": {
        "name": "Zero Chen",
        "email": "chengang31@gmail.com",
        "date": "2017-05-30T08:43:01Z"
      },
      "committer": {
        "name": "Zero Chen",
        "email": "chengang31@gmail.com",
        "date": "2017-05-30T08:43:01Z"
      },
      "message": "custom comparator for map should be declared as const.",
      "tree": {
        "sha": "ad8cbecb023ed283361eb00127a9e0ef12955138",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ad8cbecb023ed283361eb00127a9e0ef12955138"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b28f8c0bcfaaa81f83a1d53e0e63f6293ecc3d2f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b28f8c0bcfaaa81f83a1d53e0e63f6293ecc3d2f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b28f8c0bcfaaa81f83a1d53e0e63f6293ecc3d2f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b28f8c0bcfaaa81f83a1d53e0e63f6293ecc3d2f/comments",
    "author": {
      "login": "cg31",
      "id": 575738,
      "node_id": "MDQ6VXNlcjU3NTczOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/575738?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cg31",
      "html_url": "https://github.com/cg31",
      "followers_url": "https://api.github.com/users/cg31/followers",
      "following_url": "https://api.github.com/users/cg31/following{/other_user}",
      "gists_url": "https://api.github.com/users/cg31/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cg31/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cg31/subscriptions",
      "organizations_url": "https://api.github.com/users/cg31/orgs",
      "repos_url": "https://api.github.com/users/cg31/repos",
      "events_url": "https://api.github.com/users/cg31/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cg31/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "cg31",
      "id": 575738,
      "node_id": "MDQ6VXNlcjU3NTczOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/575738?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cg31",
      "html_url": "https://github.com/cg31",
      "followers_url": "https://api.github.com/users/cg31/followers",
      "following_url": "https://api.github.com/users/cg31/following{/other_user}",
      "gists_url": "https://api.github.com/users/cg31/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cg31/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cg31/subscriptions",
      "organizations_url": "https://api.github.com/users/cg31/orgs",
      "repos_url": "https://api.github.com/users/cg31/repos",
      "events_url": "https://api.github.com/users/cg31/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cg31/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ec89c16b0922e97cef9521015e5fe68ac25f7c57",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ec89c16b0922e97cef9521015e5fe68ac25f7c57",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ec89c16b0922e97cef9521015e5fe68ac25f7c57"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "7a1afd6832598b682a8be5152bbaf17a25a1a65b",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b28f8c0bcfaaa81f83a1d53e0e63f6293ecc3d2f/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b28f8c0bcfaaa81f83a1d53e0e63f6293ecc3d2f/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=b28f8c0bcfaaa81f83a1d53e0e63f6293ecc3d2f",
        "patch": "@@ -41,7 +41,7 @@ std::atomic<int64_t> nTimeBestReceived(0); // Used only to inform the wallet of\n struct IteratorComparator\n {\n     template<typename I>\n-    bool operator()(const I& a, const I& b)\n+    bool operator()(const I& a, const I& b) const\n     {\n         return &(*a) < &(*b);\n     }"
      }
    ]
  },
  {
    "sha": "336f4c034e268c0bc483ef02554a4441f01b3e5f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozMzZmNGMwMzRlMjY4YzBiYzQ4M2VmMDI1NTRhNDQ0MWYwMWIzZTVm",
    "commit": {
      "author": {
        "name": "Zero Chen",
        "email": "chengang31@gmail.com",
        "date": "2017-05-31T00:54:59Z"
      },
      "committer": {
        "name": "Zero Chen",
        "email": "chengang31@gmail.com",
        "date": "2017-05-31T00:54:59Z"
      },
      "message": "Merge remote-tracking branch 'upstream/master'",
      "tree": {
        "sha": "8a3291cca33b76b57dfe944c66c50808b365fed1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8a3291cca33b76b57dfe944c66c50808b365fed1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/336f4c034e268c0bc483ef02554a4441f01b3e5f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/336f4c034e268c0bc483ef02554a4441f01b3e5f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/336f4c034e268c0bc483ef02554a4441f01b3e5f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/336f4c034e268c0bc483ef02554a4441f01b3e5f/comments",
    "author": {
      "login": "cg31",
      "id": 575738,
      "node_id": "MDQ6VXNlcjU3NTczOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/575738?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cg31",
      "html_url": "https://github.com/cg31",
      "followers_url": "https://api.github.com/users/cg31/followers",
      "following_url": "https://api.github.com/users/cg31/following{/other_user}",
      "gists_url": "https://api.github.com/users/cg31/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cg31/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cg31/subscriptions",
      "organizations_url": "https://api.github.com/users/cg31/orgs",
      "repos_url": "https://api.github.com/users/cg31/repos",
      "events_url": "https://api.github.com/users/cg31/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cg31/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "cg31",
      "id": 575738,
      "node_id": "MDQ6VXNlcjU3NTczOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/575738?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cg31",
      "html_url": "https://github.com/cg31",
      "followers_url": "https://api.github.com/users/cg31/followers",
      "following_url": "https://api.github.com/users/cg31/following{/other_user}",
      "gists_url": "https://api.github.com/users/cg31/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cg31/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cg31/subscriptions",
      "organizations_url": "https://api.github.com/users/cg31/orgs",
      "repos_url": "https://api.github.com/users/cg31/repos",
      "events_url": "https://api.github.com/users/cg31/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cg31/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b28f8c0bcfaaa81f83a1d53e0e63f6293ecc3d2f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b28f8c0bcfaaa81f83a1d53e0e63f6293ecc3d2f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b28f8c0bcfaaa81f83a1d53e0e63f6293ecc3d2f"
      },
      {
        "sha": "f94b7d5bfa911ea7125920589723ee63a3eec9f0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f94b7d5bfa911ea7125920589723ee63a3eec9f0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f94b7d5bfa911ea7125920589723ee63a3eec9f0"
      }
    ],
    "stats": {
      "total": 277,
      "additions": 228,
      "deletions": 49
    },
    "files": [
      {
        "sha": "e4ccd54c4238b899752a7924da0ebc384e44206c",
        "filename": "src/core_memusage.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/336f4c034e268c0bc483ef02554a4441f01b3e5f/src/core_memusage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/336f4c034e268c0bc483ef02554a4441f01b3e5f/src/core_memusage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_memusage.h?ref=336f4c034e268c0bc483ef02554a4441f01b3e5f",
        "patch": "@@ -63,4 +63,9 @@ static inline size_t RecursiveDynamicUsage(const CBlockLocator& locator) {\n     return memusage::DynamicUsage(locator.vHave);\n }\n \n+template<typename X>\n+static inline size_t RecursiveDynamicUsage(const std::shared_ptr<X>& p) {\n+    return p ? memusage::DynamicUsage(p) + RecursiveDynamicUsage(*p) : 0;\n+}\n+\n #endif // BITCOIN_CORE_MEMUSAGE_H"
      },
      {
        "sha": "852984426f683e2725ea91e546aed026a054e862",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/336f4c034e268c0bc483ef02554a4441f01b3e5f/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/336f4c034e268c0bc483ef02554a4441f01b3e5f/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=336f4c034e268c0bc483ef02554a4441f01b3e5f",
        "patch": "@@ -24,7 +24,7 @@ CTxMemPoolEntry::CTxMemPoolEntry(const CTransactionRef& _tx, const CAmount& _nFe\n     spendsCoinbase(_spendsCoinbase), sigOpCost(_sigOpsCost), lockPoints(lp)\n {\n     nTxWeight = GetTransactionWeight(*tx);\n-    nUsageSize = RecursiveDynamicUsage(*tx) + memusage::DynamicUsage(tx);\n+    nUsageSize = RecursiveDynamicUsage(tx);\n \n     nCountWithDescendants = 1;\n     nSizeWithDescendants = GetTxSize();"
      },
      {
        "sha": "671a8b596c0e58bd9c15cf1728fa72dfef77a52f",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 98,
        "deletions": 1,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/336f4c034e268c0bc483ef02554a4441f01b3e5f/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/336f4c034e268c0bc483ef02554a4441f01b3e5f/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=336f4c034e268c0bc483ef02554a4441f01b3e5f",
        "patch": "@@ -24,6 +24,7 @@\n #include \"boost/multi_index_container.hpp\"\n #include \"boost/multi_index/ordered_index.hpp\"\n #include \"boost/multi_index/hashed_index.hpp\"\n+#include <boost/multi_index/sequenced_index.hpp>\n \n #include <boost/signals2/signal.hpp>\n \n@@ -185,14 +186,19 @@ struct update_lock_points\n     const LockPoints& lp;\n };\n \n-// extracts a TxMemPoolEntry's transaction hash\n+// extracts a transaction hash from CTxMempoolEntry or CTransactionRef\n struct mempoolentry_txid\n {\n     typedef uint256 result_type;\n     result_type operator() (const CTxMemPoolEntry &entry) const\n     {\n         return entry.GetTx().GetHash();\n     }\n+\n+    result_type operator() (const CTransactionRef& tx) const\n+    {\n+        return tx->GetHash();\n+    }\n };\n \n /** \\class CompareTxMemPoolEntryByDescendantScore\n@@ -662,4 +668,95 @@ class CCoinsViewMemPool : public CCoinsViewBacked\n     bool HaveCoins(const uint256 &txid) const;\n };\n \n+/**\n+ * DisconnectedBlockTransactions\n+\n+ * During the reorg, it's desirable to re-add previously confirmed transactions\n+ * to the mempool, so that anything not re-confirmed in the new chain is\n+ * available to be mined. However, it's more efficient to wait until the reorg\n+ * is complete and process all still-unconfirmed transactions at that time,\n+ * since we expect most confirmed transactions to (typically) still be\n+ * confirmed in the new chain, and re-accepting to the memory pool is expensive\n+ * (and therefore better to not do in the middle of reorg-processing).\n+ * Instead, store the disconnected transactions (in order!) as we go, remove any\n+ * that are included in blocks in the new chain, and then process the remaining\n+ * still-unconfirmed transactions at the end.\n+ */\n+\n+// multi_index tag names\n+struct txid_index {};\n+struct insertion_order {};\n+\n+struct DisconnectedBlockTransactions {\n+    typedef boost::multi_index_container<\n+        CTransactionRef,\n+        boost::multi_index::indexed_by<\n+            // sorted by txid\n+            boost::multi_index::hashed_unique<\n+                boost::multi_index::tag<txid_index>,\n+                mempoolentry_txid,\n+                SaltedTxidHasher\n+            >,\n+            // sorted by order in the blockchain\n+            boost::multi_index::sequenced<\n+                boost::multi_index::tag<insertion_order>\n+            >\n+        >\n+    > indexed_disconnected_transactions;\n+\n+    // It's almost certainly a logic bug if we don't clear out queuedTx before\n+    // destruction, as we add to it while disconnecting blocks, and then we\n+    // need to re-process remaining transactions to ensure mempool consistency.\n+    // For now, assert() that we've emptied out this object on destruction.\n+    // This assert() can always be removed if the reorg-processing code were\n+    // to be refactored such that this assumption is no longer true (for\n+    // instance if there was some other way we cleaned up the mempool after a\n+    // reorg, besides draining this object).\n+    ~DisconnectedBlockTransactions() { assert(queuedTx.empty()); }\n+\n+    indexed_disconnected_transactions queuedTx;\n+    uint64_t cachedInnerUsage = 0;\n+\n+    // Estimate the overhead of queuedTx to be 6 pointers + an allocation, as\n+    // no exact formula for boost::multi_index_contained is implemented.\n+    size_t DynamicMemoryUsage() const {\n+        return memusage::MallocUsage(sizeof(CTransactionRef) + 6 * sizeof(void*)) * queuedTx.size() + cachedInnerUsage;\n+    }\n+\n+    void addTransaction(const CTransactionRef& tx)\n+    {\n+        queuedTx.insert(tx);\n+        cachedInnerUsage += RecursiveDynamicUsage(tx);\n+    }\n+\n+    // Remove entries based on txid_index, and update memory usage.\n+    void removeForBlock(const std::vector<CTransactionRef>& vtx)\n+    {\n+        // Short-circuit in the common case of a block being added to the tip\n+        if (queuedTx.empty()) {\n+            return;\n+        }\n+        for (auto const &tx : vtx) {\n+            auto it = queuedTx.find(tx->GetHash());\n+            if (it != queuedTx.end()) {\n+                cachedInnerUsage -= RecursiveDynamicUsage(*it);\n+                queuedTx.erase(it);\n+            }\n+        }\n+    }\n+\n+    // Remove an entry by insertion_order index, and update memory usage.\n+    void removeEntry(indexed_disconnected_transactions::index<insertion_order>::type::iterator entry)\n+    {\n+        cachedInnerUsage -= RecursiveDynamicUsage(*entry);\n+        queuedTx.get<insertion_order>().erase(entry);\n+    }\n+\n+    void clear()\n+    {\n+        cachedInnerUsage = 0;\n+        queuedTx.clear();\n+    }\n+};\n+\n #endif // BITCOIN_TXMEMPOOL_H"
      },
      {
        "sha": "381d1b01c241b7805a24018ffe2ef39a12f852ab",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 110,
        "deletions": 44,
        "changes": 154,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/336f4c034e268c0bc483ef02554a4441f01b3e5f/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/336f4c034e268c0bc483ef02554a4441f01b3e5f/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=336f4c034e268c0bc483ef02554a4441f01b3e5f",
        "patch": "@@ -342,6 +342,56 @@ static bool IsCurrentForFeeEstimation()\n     return true;\n }\n \n+/* Make mempool consistent after a reorg, by re-adding or recursively erasing\n+ * disconnected block transactions from the mempool, and also removing any\n+ * other transactions from the mempool that are no longer valid given the new\n+ * tip/height.\n+ *\n+ * Note: we assume that disconnectpool only contains transactions that are NOT\n+ * confirmed in the current chain nor already in the mempool (otherwise,\n+ * in-mempool descendants of such transactions would be removed).\n+ *\n+ * Passing fAddToMempool=false will skip trying to add the transactions back,\n+ * and instead just erase from the mempool as needed.\n+ */\n+\n+void UpdateMempoolForReorg(DisconnectedBlockTransactions &disconnectpool, bool fAddToMempool)\n+{\n+    AssertLockHeld(cs_main);\n+    std::vector<uint256> vHashUpdate;\n+    // disconnectpool's insertion_order index sorts the entries from\n+    // oldest to newest, but the oldest entry will be the last tx from the\n+    // latest mined block that was disconnected.\n+    // Iterate disconnectpool in reverse, so that we add transactions\n+    // back to the mempool starting with the earliest transaction that had\n+    // been previously seen in a block.\n+    auto it = disconnectpool.queuedTx.get<insertion_order>().rbegin();\n+    while (it != disconnectpool.queuedTx.get<insertion_order>().rend()) {\n+        // ignore validation errors in resurrected transactions\n+        CValidationState stateDummy;\n+        if (!fAddToMempool || (*it)->IsCoinBase() || !AcceptToMemoryPool(mempool, stateDummy, *it, false, NULL, NULL, true)) {\n+            // If the transaction doesn't make it in to the mempool, remove any\n+            // transactions that depend on it (which would now be orphans).\n+            mempool.removeRecursive(**it, MemPoolRemovalReason::REORG);\n+        } else if (mempool.exists((*it)->GetHash())) {\n+            vHashUpdate.push_back((*it)->GetHash());\n+        }\n+        ++it;\n+    }\n+    disconnectpool.queuedTx.clear();\n+    // AcceptToMemoryPool/addUnchecked all assume that new mempool entries have\n+    // no in-mempool children, which is generally not true when adding\n+    // previously-confirmed transactions back to the mempool.\n+    // UpdateTransactionsFromBlock finds descendants of any transactions in\n+    // the disconnectpool that were added back and cleans up the mempool state.\n+    mempool.UpdateTransactionsFromBlock(vHashUpdate);\n+\n+    // We also need to remove any now-immature transactions\n+    mempool.removeForReorg(pcoinsTip, chainActive.Tip()->nHeight + 1, STANDARD_LOCKTIME_VERIFY_FLAGS);\n+    // Re-limit mempool size, in case we added any transactions\n+    LimitMempoolSize(mempool, GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n+}\n+\n bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx, bool fLimitFree,\n                               bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n                               bool fOverrideMempoolLimit, const CAmount& nAbsurdFee, std::vector<uint256>& vHashTxnToUncache)\n@@ -1814,6 +1864,16 @@ void PruneAndFlush() {\n     FlushStateToDisk(state, FLUSH_STATE_NONE);\n }\n \n+static void DoWarning(const std::string& strWarning)\n+{\n+    static bool fWarned = false;\n+    SetMiscWarning(strWarning);\n+    if (!fWarned) {\n+        AlertNotify(strWarning);\n+        fWarned = true;\n+    }\n+}\n+\n /** Update chainActive and related internal data structures. */\n void static UpdateTip(CBlockIndex *pindexNew, const CChainParams& chainParams) {\n     chainActive.SetTip(pindexNew);\n@@ -1823,7 +1883,6 @@ void static UpdateTip(CBlockIndex *pindexNew, const CChainParams& chainParams) {\n \n     cvBlockChange.notify_all();\n \n-    static bool fWarned = false;\n     std::vector<std::string> warningMessages;\n     if (!IsInitialBlockDownload())\n     {\n@@ -1833,15 +1892,11 @@ void static UpdateTip(CBlockIndex *pindexNew, const CChainParams& chainParams) {\n             WarningBitsConditionChecker checker(bit);\n             ThresholdState state = checker.GetStateFor(pindex, chainParams.GetConsensus(), warningcache[bit]);\n             if (state == THRESHOLD_ACTIVE || state == THRESHOLD_LOCKED_IN) {\n+                const std::string strWarning = strprintf(_(\"Warning: unknown new rules activated (versionbit %i)\"), bit);\n                 if (state == THRESHOLD_ACTIVE) {\n-                    std::string strWarning = strprintf(_(\"Warning: unknown new rules activated (versionbit %i)\"), bit);\n-                    SetMiscWarning(strWarning);\n-                    if (!fWarned) {\n-                        AlertNotify(strWarning);\n-                        fWarned = true;\n-                    }\n+                    DoWarning(strWarning);\n                 } else {\n-                    warningMessages.push_back(strprintf(\"unknown new rules are about to activate (versionbit %i)\", bit));\n+                    warningMessages.push_back(strWarning);\n                 }\n             }\n         }\n@@ -1854,16 +1909,12 @@ void static UpdateTip(CBlockIndex *pindexNew, const CChainParams& chainParams) {\n             pindex = pindex->pprev;\n         }\n         if (nUpgraded > 0)\n-            warningMessages.push_back(strprintf(\"%d of last 100 blocks have unexpected version\", nUpgraded));\n+            warningMessages.push_back(strprintf(_(\"%d of last 100 blocks have unexpected version\"), nUpgraded));\n         if (nUpgraded > 100/2)\n         {\n             std::string strWarning = _(\"Warning: Unknown block versions being mined! It's possible unknown rules are in effect\");\n             // notify GetWarnings(), called by Qt and the JSON-RPC code to warn the user:\n-            SetMiscWarning(strWarning);\n-            if (!fWarned) {\n-                AlertNotify(strWarning);\n-                fWarned = true;\n-            }\n+            DoWarning(strWarning);\n         }\n     }\n     LogPrintf(\"%s: new best=%s height=%d version=0x%08x log2_work=%.8g tx=%lu date='%s' progress=%f cache=%.1fMiB(%utx)\", __func__,\n@@ -1877,8 +1928,17 @@ void static UpdateTip(CBlockIndex *pindexNew, const CChainParams& chainParams) {\n \n }\n \n-/** Disconnect chainActive's tip. You probably want to call mempool.removeForReorg and manually re-limit mempool size after this, with cs_main held. */\n-bool static DisconnectTip(CValidationState& state, const CChainParams& chainparams, bool fBare = false)\n+/** Disconnect chainActive's tip.\n+  * After calling, the mempool will be in an inconsistent state, with\n+  * transactions from disconnected blocks being added to disconnectpool.  You\n+  * should make the mempool consistent again by calling UpdateMempoolForReorg.\n+  * with cs_main held.\n+  *\n+  * If disconnectpool is NULL, then no disconnected transactions are added to\n+  * disconnectpool (note that the caller is responsible for mempool consistency\n+  * in any case).\n+  */\n+bool static DisconnectTip(CValidationState& state, const CChainParams& chainparams, DisconnectedBlockTransactions *disconnectpool)\n {\n     CBlockIndex *pindexDelete = chainActive.Tip();\n     assert(pindexDelete);\n@@ -1901,25 +1961,17 @@ bool static DisconnectTip(CValidationState& state, const CChainParams& chainpara\n     if (!FlushStateToDisk(state, FLUSH_STATE_IF_NEEDED))\n         return false;\n \n-    if (!fBare) {\n-        // Resurrect mempool transactions from the disconnected block.\n-        std::vector<uint256> vHashUpdate;\n-        for (const auto& it : block.vtx) {\n-            const CTransaction& tx = *it;\n-            // ignore validation errors in resurrected transactions\n-            CValidationState stateDummy;\n-            if (tx.IsCoinBase() || !AcceptToMemoryPool(mempool, stateDummy, it, false, NULL, NULL, true)) {\n-                mempool.removeRecursive(tx, MemPoolRemovalReason::REORG);\n-            } else if (mempool.exists(tx.GetHash())) {\n-                vHashUpdate.push_back(tx.GetHash());\n-            }\n+    if (disconnectpool) {\n+        // Save transactions to re-add to mempool at end of reorg\n+        for (auto it = block.vtx.rbegin(); it != block.vtx.rend(); ++it) {\n+            disconnectpool->addTransaction(*it);\n+        }\n+        while (disconnectpool->DynamicMemoryUsage() > MAX_DISCONNECTED_TX_POOL_SIZE * 1000) {\n+            // Drop the earliest entry, and remove its children from the mempool.\n+            auto it = disconnectpool->queuedTx.get<insertion_order>().begin();\n+            mempool.removeRecursive(**it, MemPoolRemovalReason::REORG);\n+            disconnectpool->removeEntry(it);\n         }\n-        // AcceptToMemoryPool/addUnchecked all assume that new mempool entries have\n-        // no in-mempool children, which is generally not true when adding\n-        // previously-confirmed transactions back to the mempool.\n-        // UpdateTransactionsFromBlock finds descendants of any transactions in this\n-        // block that were added back and cleans up the mempool state.\n-        mempool.UpdateTransactionsFromBlock(vHashUpdate);\n     }\n \n     // Update chainActive and related variables.\n@@ -2007,7 +2059,7 @@ class ConnectTrace {\n  *\n  * The block is added to connectTrace if connection succeeds.\n  */\n-bool static ConnectTip(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace)\n+bool static ConnectTip(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions &disconnectpool)\n {\n     assert(pindexNew->pprev == chainActive.Tip());\n     // Read block from disk.\n@@ -2049,6 +2101,7 @@ bool static ConnectTip(CValidationState& state, const CChainParams& chainparams,\n     LogPrint(BCLog::BENCH, \"  - Writing chainstate: %.2fms [%.2fs]\\n\", (nTime5 - nTime4) * 0.001, nTimeChainState * 0.000001);\n     // Remove conflicting transactions from the mempool.;\n     mempool.removeForBlock(blockConnecting.vtx, pindexNew->nHeight);\n+    disconnectpool.removeForBlock(blockConnecting.vtx);\n     // Update chainActive & related variables.\n     UpdateTip(pindexNew, chainparams);\n \n@@ -2142,9 +2195,14 @@ static bool ActivateBestChainStep(CValidationState& state, const CChainParams& c\n \n     // Disconnect active blocks which are no longer in the best chain.\n     bool fBlocksDisconnected = false;\n+    DisconnectedBlockTransactions disconnectpool;\n     while (chainActive.Tip() && chainActive.Tip() != pindexFork) {\n-        if (!DisconnectTip(state, chainparams))\n+        if (!DisconnectTip(state, chainparams, &disconnectpool)) {\n+            // This is likely a fatal error, but keep the mempool consistent,\n+            // just in case. Only remove from the mempool in this case.\n+            UpdateMempoolForReorg(disconnectpool, false);\n             return false;\n+        }\n         fBlocksDisconnected = true;\n     }\n \n@@ -2167,7 +2225,7 @@ static bool ActivateBestChainStep(CValidationState& state, const CChainParams& c\n \n         // Connect new blocks.\n         BOOST_REVERSE_FOREACH(CBlockIndex *pindexConnect, vpindexToConnect) {\n-            if (!ConnectTip(state, chainparams, pindexConnect, pindexConnect == pindexMostWork ? pblock : std::shared_ptr<const CBlock>(), connectTrace)) {\n+            if (!ConnectTip(state, chainparams, pindexConnect, pindexConnect == pindexMostWork ? pblock : std::shared_ptr<const CBlock>(), connectTrace, disconnectpool)) {\n                 if (state.IsInvalid()) {\n                     // The block violates a consensus rule.\n                     if (!state.CorruptionPossible())\n@@ -2178,6 +2236,9 @@ static bool ActivateBestChainStep(CValidationState& state, const CChainParams& c\n                     break;\n                 } else {\n                     // A system error occurred (disk space, database error, ...).\n+                    // Make the mempool consistent with the current tip, just in case\n+                    // any observers try to use it before shutdown.\n+                    UpdateMempoolForReorg(disconnectpool, false);\n                     return false;\n                 }\n             } else {\n@@ -2192,8 +2253,9 @@ static bool ActivateBestChainStep(CValidationState& state, const CChainParams& c\n     }\n \n     if (fBlocksDisconnected) {\n-        mempool.removeForReorg(pcoinsTip, chainActive.Tip()->nHeight + 1, STANDARD_LOCKTIME_VERIFY_FLAGS);\n-        LimitMempoolSize(mempool, GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n+        // If any blocks were disconnected, disconnectpool may be non empty.  Add\n+        // any disconnected transactions back to the mempool.\n+        UpdateMempoolForReorg(disconnectpool, true);\n     }\n     mempool.check(pcoinsTip);\n \n@@ -2342,20 +2404,25 @@ bool InvalidateBlock(CValidationState& state, const CChainParams& chainparams, C\n     setDirtyBlockIndex.insert(pindex);\n     setBlockIndexCandidates.erase(pindex);\n \n+    DisconnectedBlockTransactions disconnectpool;\n     while (chainActive.Contains(pindex)) {\n         CBlockIndex *pindexWalk = chainActive.Tip();\n         pindexWalk->nStatus |= BLOCK_FAILED_CHILD;\n         setDirtyBlockIndex.insert(pindexWalk);\n         setBlockIndexCandidates.erase(pindexWalk);\n         // ActivateBestChain considers blocks already in chainActive\n         // unconditionally valid already, so force disconnect away from it.\n-        if (!DisconnectTip(state, chainparams)) {\n-            mempool.removeForReorg(pcoinsTip, chainActive.Tip()->nHeight + 1, STANDARD_LOCKTIME_VERIFY_FLAGS);\n+        if (!DisconnectTip(state, chainparams, &disconnectpool)) {\n+            // It's probably hopeless to try to make the mempool consistent\n+            // here if DisconnectTip failed, but we can try.\n+            UpdateMempoolForReorg(disconnectpool, false);\n             return false;\n         }\n     }\n \n-    LimitMempoolSize(mempool, GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n+    // DisconnectTip will add transactions to disconnectpool; try to add these\n+    // back to the mempool.\n+    UpdateMempoolForReorg(disconnectpool, true);\n \n     // The resulting new best tip may not be in setBlockIndexCandidates anymore, so\n     // add it again.\n@@ -2368,7 +2435,6 @@ bool InvalidateBlock(CValidationState& state, const CChainParams& chainparams, C\n     }\n \n     InvalidChainFound(pindex);\n-    mempool.removeForReorg(pcoinsTip, chainActive.Tip()->nHeight + 1, STANDARD_LOCKTIME_VERIFY_FLAGS);\n     uiInterface.NotifyBlockTip(IsInitialBlockDownload(), pindex->pprev);\n     return true;\n }\n@@ -3482,7 +3548,7 @@ bool RewindBlockIndex(const CChainParams& params)\n             // of the blockchain).\n             break;\n         }\n-        if (!DisconnectTip(state, params, true)) {\n+        if (!DisconnectTip(state, params, NULL)) {\n             return error(\"RewindBlockIndex: unable to disconnect block at height %i\", pindex->nHeight);\n         }\n         // Occasionally flush state to disk."
      },
      {
        "sha": "02a9b5a3695bfc4989f7799d1264a00ddd716054",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/336f4c034e268c0bc483ef02554a4441f01b3e5f/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/336f4c034e268c0bc483ef02554a4441f01b3e5f/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=336f4c034e268c0bc483ef02554a4441f01b3e5f",
        "patch": "@@ -70,6 +70,8 @@ static const unsigned int DEFAULT_DESCENDANT_LIMIT = 25;\n static const unsigned int DEFAULT_DESCENDANT_SIZE_LIMIT = 101;\n /** Default for -mempoolexpiry, expiration time for mempool transactions in hours */\n static const unsigned int DEFAULT_MEMPOOL_EXPIRY = 336;\n+/** Maximum kilobytes for transactions to store for processing during reorg */\n+static const unsigned int MAX_DISCONNECTED_TX_POOL_SIZE = 20000;\n /** The maximum size of a blk?????.dat file (since 0.8) */\n static const unsigned int MAX_BLOCKFILE_SIZE = 0x8000000; // 128 MiB\n /** The pre-allocation chunk size for blk?????.dat files (since 0.8) */"
      },
      {
        "sha": "7995e418c936027192dfc0cef91956f83ad7bdb6",
        "filename": "test/functional/pruning.py",
        "status": "modified",
        "additions": 12,
        "deletions": 3,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/336f4c034e268c0bc483ef02554a4441f01b3e5f/test/functional/pruning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/336f4c034e268c0bc483ef02554a4441f01b3e5f/test/functional/pruning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/pruning.py?ref=336f4c034e268c0bc483ef02554a4441f01b3e5f",
        "patch": "@@ -34,10 +34,11 @@ def __init__(self):\n \n         # Create nodes 0 and 1 to mine.\n         # Create node 2 to test pruning.\n+        self.full_node_default_args = [\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\", \"-checkblocks=5\", \"-limitdescendantcount=100\", \"-limitdescendantsize=5000\", \"-limitancestorcount=100\", \"-limitancestorsize=5000\" ]\n         # Create nodes 3 and 4 to test manual pruning (they will be re-started with manual pruning later)\n         # Create nodes 5 to test wallet in prune mode, but do not connect\n-        self.extra_args = [[\"-maxreceivebuffer=20000\", \"-blockmaxsize=999000\", \"-checkblocks=5\"],\n-                           [\"-maxreceivebuffer=20000\", \"-blockmaxsize=999000\", \"-checkblocks=5\"],\n+        self.extra_args = [self.full_node_default_args,\n+                           self.full_node_default_args,\n                            [\"-maxreceivebuffer=20000\", \"-prune=550\"],\n                            [\"-maxreceivebuffer=20000\", \"-blockmaxsize=999000\"],\n                            [\"-maxreceivebuffer=20000\", \"-blockmaxsize=999000\"],\n@@ -97,12 +98,15 @@ def create_chain_with_staleblocks(self):\n             # Node 2 stays connected, so it hears about the stale blocks and then reorg's when node0 reconnects\n             # Stopping node 0 also clears its mempool, so it doesn't have node1's transactions to accidentally mine\n             self.stop_node(0)\n-            self.nodes[0]=start_node(0, self.options.tmpdir, [\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\", \"-checkblocks=5\"], timewait=900)\n+            self.nodes[0]=start_node(0, self.options.tmpdir, self.full_node_default_args, timewait=900)\n             # Mine 24 blocks in node 1\n             for i in range(24):\n                 if j == 0:\n                     mine_large_block(self.nodes[1], self.utxo_cache_1)\n                 else:\n+                    # Add node1's wallet transactions back to the mempool, to\n+                    # avoid the mined blocks from being too small.\n+                    self.nodes[1].resendwallettransactions()\n                     self.nodes[1].generate(1) #tx's already in mempool from previous disconnects\n \n             # Reorg back with 25 block chain from node 0\n@@ -159,6 +163,11 @@ def reorg_test(self):\n         self.log.info(\"Usage possibly still high bc of stale blocks in block files: %d\" % calc_usage(self.prunedir))\n \n         self.log.info(\"Mine 220 more blocks so we have requisite history (some blocks will be big and cause pruning of previous chain)\")\n+\n+        # Get node0's wallet transactions back in its mempool, to avoid the\n+        # mined blocks from being too small.\n+        self.nodes[0].resendwallettransactions()\n+\n         for i in range(22):\n             # This can be slow, so do this in multiple RPC calls to avoid\n             # RPC timeouts."
      }
    ]
  },
  {
    "sha": "5ef86325d5a40d57c4488118d1df37ceb08a781d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ZWY4NjMyNWQ1YTQwZDU3YzQ0ODgxMThkMWRmMzdjZWIwOGE3ODFk",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-05-26T18:47:07Z"
      },
      "committer": {
        "name": "Zero Chen",
        "email": "chengang31@gmail.com",
        "date": "2017-05-31T08:52:24Z"
      },
      "message": "Broadcast address every day, not 9 hours",
      "tree": {
        "sha": "e4c4182202af8ccc23b8910e8e84337c48b52158",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e4c4182202af8ccc23b8910e8e84337c48b52158"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5ef86325d5a40d57c4488118d1df37ceb08a781d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5ef86325d5a40d57c4488118d1df37ceb08a781d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5ef86325d5a40d57c4488118d1df37ceb08a781d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5ef86325d5a40d57c4488118d1df37ceb08a781d/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "cg31",
      "id": 575738,
      "node_id": "MDQ6VXNlcjU3NTczOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/575738?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cg31",
      "html_url": "https://github.com/cg31",
      "followers_url": "https://api.github.com/users/cg31/followers",
      "following_url": "https://api.github.com/users/cg31/following{/other_user}",
      "gists_url": "https://api.github.com/users/cg31/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cg31/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cg31/subscriptions",
      "organizations_url": "https://api.github.com/users/cg31/orgs",
      "repos_url": "https://api.github.com/users/cg31/repos",
      "events_url": "https://api.github.com/users/cg31/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cg31/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b4b057a3e0712dd16b50cbcfe7d613e4413ffa1c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4b057a3e0712dd16b50cbcfe7d613e4413ffa1c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b4b057a3e0712dd16b50cbcfe7d613e4413ffa1c"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "c46f89af72605ddcc2d13c04f3c7110d7a65dd0d",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5ef86325d5a40d57c4488118d1df37ceb08a781d/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5ef86325d5a40d57c4488118d1df37ceb08a781d/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=5ef86325d5a40d57c4488118d1df37ceb08a781d",
        "patch": "@@ -105,7 +105,7 @@ static const unsigned int DATABASE_FLUSH_INTERVAL = 24 * 60 * 60;\n /** Maximum length of reject messages. */\n static const unsigned int MAX_REJECT_MESSAGE_LENGTH = 111;\n /** Average delay between local address broadcasts in seconds. */\n-static const unsigned int AVG_LOCAL_ADDRESS_BROADCAST_INTERVAL = 24 * 24 * 60;\n+static const unsigned int AVG_LOCAL_ADDRESS_BROADCAST_INTERVAL = 24 * 60 * 60;\n /** Average delay between peer address broadcasts in seconds. */\n static const unsigned int AVG_ADDRESS_BROADCAST_INTERVAL = 30;\n /** Average delay between trickled inventory transmissions in seconds."
      }
    ]
  },
  {
    "sha": "a8d4cc25e13fc08dadde58348d2a1813197b1906",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphOGQ0Y2MyNWUxM2ZjMDhkYWRkZTU4MzQ4ZDJhMTgxMzE5N2IxOTA2",
    "commit": {
      "author": {
        "name": "Zero Chen",
        "email": "chengang31@gmail.com",
        "date": "2017-05-30T08:38:13Z"
      },
      "committer": {
        "name": "Zero Chen",
        "email": "chengang31@gmail.com",
        "date": "2017-05-31T08:52:24Z"
      },
      "message": "Use C++ initializer to initialze map to avoid casting.",
      "tree": {
        "sha": "86fb8218660e771b42b18944ad591851d79f0fb7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/86fb8218660e771b42b18944ad591851d79f0fb7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a8d4cc25e13fc08dadde58348d2a1813197b1906",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a8d4cc25e13fc08dadde58348d2a1813197b1906",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a8d4cc25e13fc08dadde58348d2a1813197b1906",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a8d4cc25e13fc08dadde58348d2a1813197b1906/comments",
    "author": {
      "login": "cg31",
      "id": 575738,
      "node_id": "MDQ6VXNlcjU3NTczOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/575738?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cg31",
      "html_url": "https://github.com/cg31",
      "followers_url": "https://api.github.com/users/cg31/followers",
      "following_url": "https://api.github.com/users/cg31/following{/other_user}",
      "gists_url": "https://api.github.com/users/cg31/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cg31/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cg31/subscriptions",
      "organizations_url": "https://api.github.com/users/cg31/orgs",
      "repos_url": "https://api.github.com/users/cg31/repos",
      "events_url": "https://api.github.com/users/cg31/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cg31/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "cg31",
      "id": 575738,
      "node_id": "MDQ6VXNlcjU3NTczOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/575738?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cg31",
      "html_url": "https://github.com/cg31",
      "followers_url": "https://api.github.com/users/cg31/followers",
      "following_url": "https://api.github.com/users/cg31/following{/other_user}",
      "gists_url": "https://api.github.com/users/cg31/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cg31/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cg31/subscriptions",
      "organizations_url": "https://api.github.com/users/cg31/orgs",
      "repos_url": "https://api.github.com/users/cg31/repos",
      "events_url": "https://api.github.com/users/cg31/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cg31/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5ef86325d5a40d57c4488118d1df37ceb08a781d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5ef86325d5a40d57c4488118d1df37ceb08a781d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5ef86325d5a40d57c4488118d1df37ceb08a781d"
      }
    ],
    "stats": {
      "total": 45,
      "additions": 21,
      "deletions": 24
    },
    "files": [
      {
        "sha": "78c21fe946aecccf248f3598d430420781651618",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 24,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a8d4cc25e13fc08dadde58348d2a1813197b1906/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a8d4cc25e13fc08dadde58348d2a1813197b1906/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=a8d4cc25e13fc08dadde58348d2a1813197b1906",
        "patch": "@@ -145,22 +145,21 @@ class CMainParams : public CChainParams {\n         fRequireStandard = true;\n         fMineBlocksOnDemand = false;\n \n-        checkpointData = (CCheckpointData) {\n-            boost::assign::map_list_of\n-            ( 11111, uint256S(\"0x0000000069e244f73d78e8fd29ba2fd2ed618bd6fa2ee92559f542fdb26e7c1d\"))\n-            ( 33333, uint256S(\"0x000000002dd5588a74784eaa7ab0507a18ad16a236e7b1ce69f00d7ddfb5d0a6\"))\n-            ( 74000, uint256S(\"0x0000000000573993a3c9e41ce34471c079dcf5f52a0e824a81e7f953b8661a20\"))\n-            (105000, uint256S(\"0x00000000000291ce28027faea320c8d2b054b2e0fe44a773f3eefb151d6bdc97\"))\n-            (134444, uint256S(\"0x00000000000005b12ffd4cd315cd34ffd4a594f430ac814c91184a0d42d2b0fe\"))\n-            (168000, uint256S(\"0x000000000000099e61ea72015e79632f216fe6cb33d7899acb35b75c8303b763\"))\n-            (193000, uint256S(\"0x000000000000059f452a5f7340de6682a977387c17010ff6e6c3bd83ca8b1317\"))\n-            (210000, uint256S(\"0x000000000000048b95347e83192f69cf0366076336c639f9b7228e9ba171342e\"))\n-            (216116, uint256S(\"0x00000000000001b4f4b433e81ee46494af945cf96014816a4e2370f11b23df4e\"))\n-            (225430, uint256S(\"0x00000000000001c108384350f74090433e7fcf79a606b8e797f065b130575932\"))\n-            (250000, uint256S(\"0x000000000000003887df1f29024b06fc2200b55f8af8f35453d7be294df2d214\"))\n-            (279000, uint256S(\"0x0000000000000001ae8c72a0b0c301f67e3afca10e819efa9041e458e9bd7e40\"))\n-            (295000, uint256S(\"0x00000000000000004d9b4ef50f0f9d686fd69db2e03af35a100370c64632a983\"))\n-        };\n+        checkpointData = { {\n+            { 11111, uint256S(\"0x0000000069e244f73d78e8fd29ba2fd2ed618bd6fa2ee92559f542fdb26e7c1d\")},\n+            { 33333, uint256S(\"0x000000002dd5588a74784eaa7ab0507a18ad16a236e7b1ce69f00d7ddfb5d0a6\")},\n+            { 74000, uint256S(\"0x0000000000573993a3c9e41ce34471c079dcf5f52a0e824a81e7f953b8661a20\")},\n+            {105000, uint256S(\"0x00000000000291ce28027faea320c8d2b054b2e0fe44a773f3eefb151d6bdc97\")},\n+            {134444, uint256S(\"0x00000000000005b12ffd4cd315cd34ffd4a594f430ac814c91184a0d42d2b0fe\")},\n+            {168000, uint256S(\"0x000000000000099e61ea72015e79632f216fe6cb33d7899acb35b75c8303b763\")},\n+            {193000, uint256S(\"0x000000000000059f452a5f7340de6682a977387c17010ff6e6c3bd83ca8b1317\")},\n+            {210000, uint256S(\"0x000000000000048b95347e83192f69cf0366076336c639f9b7228e9ba171342e\")},\n+            {216116, uint256S(\"0x00000000000001b4f4b433e81ee46494af945cf96014816a4e2370f11b23df4e\")},\n+            {225430, uint256S(\"0x00000000000001c108384350f74090433e7fcf79a606b8e797f065b130575932\")},\n+            {250000, uint256S(\"0x000000000000003887df1f29024b06fc2200b55f8af8f35453d7be294df2d214\")},\n+            {279000, uint256S(\"0x0000000000000001ae8c72a0b0c301f67e3afca10e819efa9041e458e9bd7e40\")},\n+            {295000, uint256S(\"0x00000000000000004d9b4ef50f0f9d686fd69db2e03af35a100370c64632a983\")}\n+        } };\n \n         chainTxData = ChainTxData{\n             // Data as of block 00000000000000000166d612d5595e2b1cd88d71d695fc580af64d8da8658c23 (height 446482).\n@@ -244,10 +243,9 @@ class CTestNetParams : public CChainParams {\n         fMineBlocksOnDemand = false;\n \n \n-        checkpointData = (CCheckpointData) {\n-            boost::assign::map_list_of\n-            ( 546, uint256S(\"000000002a936ca763904c3c35fce2f3556c559c0214345d31b1bcebf76acb70\")),\n-        };\n+        checkpointData = { {\n+            {546, uint256S(\"000000002a936ca763904c3c35fce2f3556c559c0214345d31b1bcebf76acb70\")}\n+        } };\n \n         chainTxData = ChainTxData{\n             // Data as of block 00000000c2872f8f8a8935c8e3c5862be9038c97d4de2cf37ed496991166928a (height 1063660)\n@@ -313,10 +311,9 @@ class CRegTestParams : public CChainParams {\n         fRequireStandard = false;\n         fMineBlocksOnDemand = true;\n \n-        checkpointData = (CCheckpointData){\n-            boost::assign::map_list_of\n-            ( 0, uint256S(\"0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\"))\n-        };\n+        checkpointData = { {\n+            {0, uint256S(\"0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\")}\n+        } };\n \n         chainTxData = ChainTxData{\n             0,"
      }
    ]
  },
  {
    "sha": "dd17431c36131cd5f786d6a0bbd62825c9445cde",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkZDE3NDMxYzM2MTMxY2Q1Zjc4NmQ2YTBiYmQ2MjgyNWM5NDQ1Y2Rl",
    "commit": {
      "author": {
        "name": "Zero Chen",
        "email": "chengang31@gmail.com",
        "date": "2017-05-30T08:43:01Z"
      },
      "committer": {
        "name": "Zero Chen",
        "email": "chengang31@gmail.com",
        "date": "2017-05-31T08:52:24Z"
      },
      "message": "custom comparator for map should be declared as const.",
      "tree": {
        "sha": "ad8cbecb023ed283361eb00127a9e0ef12955138",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ad8cbecb023ed283361eb00127a9e0ef12955138"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dd17431c36131cd5f786d6a0bbd62825c9445cde",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dd17431c36131cd5f786d6a0bbd62825c9445cde",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dd17431c36131cd5f786d6a0bbd62825c9445cde",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dd17431c36131cd5f786d6a0bbd62825c9445cde/comments",
    "author": {
      "login": "cg31",
      "id": 575738,
      "node_id": "MDQ6VXNlcjU3NTczOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/575738?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cg31",
      "html_url": "https://github.com/cg31",
      "followers_url": "https://api.github.com/users/cg31/followers",
      "following_url": "https://api.github.com/users/cg31/following{/other_user}",
      "gists_url": "https://api.github.com/users/cg31/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cg31/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cg31/subscriptions",
      "organizations_url": "https://api.github.com/users/cg31/orgs",
      "repos_url": "https://api.github.com/users/cg31/repos",
      "events_url": "https://api.github.com/users/cg31/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cg31/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "cg31",
      "id": 575738,
      "node_id": "MDQ6VXNlcjU3NTczOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/575738?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cg31",
      "html_url": "https://github.com/cg31",
      "followers_url": "https://api.github.com/users/cg31/followers",
      "following_url": "https://api.github.com/users/cg31/following{/other_user}",
      "gists_url": "https://api.github.com/users/cg31/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cg31/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cg31/subscriptions",
      "organizations_url": "https://api.github.com/users/cg31/orgs",
      "repos_url": "https://api.github.com/users/cg31/repos",
      "events_url": "https://api.github.com/users/cg31/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cg31/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a8d4cc25e13fc08dadde58348d2a1813197b1906",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a8d4cc25e13fc08dadde58348d2a1813197b1906",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a8d4cc25e13fc08dadde58348d2a1813197b1906"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "7a1afd6832598b682a8be5152bbaf17a25a1a65b",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd17431c36131cd5f786d6a0bbd62825c9445cde/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd17431c36131cd5f786d6a0bbd62825c9445cde/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=dd17431c36131cd5f786d6a0bbd62825c9445cde",
        "patch": "@@ -41,7 +41,7 @@ std::atomic<int64_t> nTimeBestReceived(0); // Used only to inform the wallet of\n struct IteratorComparator\n {\n     template<typename I>\n-    bool operator()(const I& a, const I& b)\n+    bool operator()(const I& a, const I& b) const\n     {\n         return &(*a) < &(*b);\n     }"
      }
    ]
  },
  {
    "sha": "e4ef6315316ddbfdce0e52162c1fd7bdbc3f1751",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNGVmNjMxNTMxNmRkYmZkY2UwZTUyMTYyYzFmZDdiZGJjM2YxNzUx",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2016-11-07T18:42:09Z"
      },
      "committer": {
        "name": "Zero Chen",
        "email": "chengang31@gmail.com",
        "date": "2017-05-31T08:52:24Z"
      },
      "message": "[qa] Relax assumptions on mempool behavior during reorg\n\nPolicy limits (such as chain limits and mempool total size) could reasonably\nbe enforced more aggressively during a reorg, so use resendwallettransactions\nto repopulate the mempool to avoid mined blocks being too small, and increase\nthe chain limits from the default for this test.\n\nThis is in preparation for a change in mempool behavior during a reorg.",
      "tree": {
        "sha": "aca5e9483d98d2eb5a2dda13f1d0d95deffaaebe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/aca5e9483d98d2eb5a2dda13f1d0d95deffaaebe"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e4ef6315316ddbfdce0e52162c1fd7bdbc3f1751",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e4ef6315316ddbfdce0e52162c1fd7bdbc3f1751",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e4ef6315316ddbfdce0e52162c1fd7bdbc3f1751",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e4ef6315316ddbfdce0e52162c1fd7bdbc3f1751/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "cg31",
      "id": 575738,
      "node_id": "MDQ6VXNlcjU3NTczOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/575738?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cg31",
      "html_url": "https://github.com/cg31",
      "followers_url": "https://api.github.com/users/cg31/followers",
      "following_url": "https://api.github.com/users/cg31/following{/other_user}",
      "gists_url": "https://api.github.com/users/cg31/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cg31/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cg31/subscriptions",
      "organizations_url": "https://api.github.com/users/cg31/orgs",
      "repos_url": "https://api.github.com/users/cg31/repos",
      "events_url": "https://api.github.com/users/cg31/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cg31/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "dd17431c36131cd5f786d6a0bbd62825c9445cde",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dd17431c36131cd5f786d6a0bbd62825c9445cde",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/dd17431c36131cd5f786d6a0bbd62825c9445cde"
      }
    ],
    "stats": {
      "total": 15,
      "additions": 12,
      "deletions": 3
    },
    "files": [
      {
        "sha": "7995e418c936027192dfc0cef91956f83ad7bdb6",
        "filename": "test/functional/pruning.py",
        "status": "modified",
        "additions": 12,
        "deletions": 3,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e4ef6315316ddbfdce0e52162c1fd7bdbc3f1751/test/functional/pruning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e4ef6315316ddbfdce0e52162c1fd7bdbc3f1751/test/functional/pruning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/pruning.py?ref=e4ef6315316ddbfdce0e52162c1fd7bdbc3f1751",
        "patch": "@@ -34,10 +34,11 @@ def __init__(self):\n \n         # Create nodes 0 and 1 to mine.\n         # Create node 2 to test pruning.\n+        self.full_node_default_args = [\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\", \"-checkblocks=5\", \"-limitdescendantcount=100\", \"-limitdescendantsize=5000\", \"-limitancestorcount=100\", \"-limitancestorsize=5000\" ]\n         # Create nodes 3 and 4 to test manual pruning (they will be re-started with manual pruning later)\n         # Create nodes 5 to test wallet in prune mode, but do not connect\n-        self.extra_args = [[\"-maxreceivebuffer=20000\", \"-blockmaxsize=999000\", \"-checkblocks=5\"],\n-                           [\"-maxreceivebuffer=20000\", \"-blockmaxsize=999000\", \"-checkblocks=5\"],\n+        self.extra_args = [self.full_node_default_args,\n+                           self.full_node_default_args,\n                            [\"-maxreceivebuffer=20000\", \"-prune=550\"],\n                            [\"-maxreceivebuffer=20000\", \"-blockmaxsize=999000\"],\n                            [\"-maxreceivebuffer=20000\", \"-blockmaxsize=999000\"],\n@@ -97,12 +98,15 @@ def create_chain_with_staleblocks(self):\n             # Node 2 stays connected, so it hears about the stale blocks and then reorg's when node0 reconnects\n             # Stopping node 0 also clears its mempool, so it doesn't have node1's transactions to accidentally mine\n             self.stop_node(0)\n-            self.nodes[0]=start_node(0, self.options.tmpdir, [\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\", \"-checkblocks=5\"], timewait=900)\n+            self.nodes[0]=start_node(0, self.options.tmpdir, self.full_node_default_args, timewait=900)\n             # Mine 24 blocks in node 1\n             for i in range(24):\n                 if j == 0:\n                     mine_large_block(self.nodes[1], self.utxo_cache_1)\n                 else:\n+                    # Add node1's wallet transactions back to the mempool, to\n+                    # avoid the mined blocks from being too small.\n+                    self.nodes[1].resendwallettransactions()\n                     self.nodes[1].generate(1) #tx's already in mempool from previous disconnects\n \n             # Reorg back with 25 block chain from node 0\n@@ -159,6 +163,11 @@ def reorg_test(self):\n         self.log.info(\"Usage possibly still high bc of stale blocks in block files: %d\" % calc_usage(self.prunedir))\n \n         self.log.info(\"Mine 220 more blocks so we have requisite history (some blocks will be big and cause pruning of previous chain)\")\n+\n+        # Get node0's wallet transactions back in its mempool, to avoid the\n+        # mined blocks from being too small.\n+        self.nodes[0].resendwallettransactions()\n+\n         for i in range(22):\n             # This can be slow, so do this in multiple RPC calls to avoid\n             # RPC timeouts."
      }
    ]
  },
  {
    "sha": "05bc372e86fb5f2f5e04e855f246820713c57f06",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNWJjMzcyZTg2ZmI1ZjJmNWUwNGU4NTVmMjQ2ODIwNzEzYzU3ZjA2",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2016-11-03T18:45:10Z"
      },
      "committer": {
        "name": "Zero Chen",
        "email": "chengang31@gmail.com",
        "date": "2017-05-31T08:52:25Z"
      },
      "message": "Store disconnected block transactions outside mempool during reorg\n\nRather than re-add disconnected block transactions back to the mempool\nimmediately, store them in a separate disconnectpool for later processing,\nbecause we expect most such transactions to reappear in the chain that is\nstill to be connected (and thus we can avoid the work of reprocessing those\ntransactions through the mempool altogether).",
      "tree": {
        "sha": "edf42e7044c6565915ad0cbc19191c36d5f80368",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/edf42e7044c6565915ad0cbc19191c36d5f80368"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/05bc372e86fb5f2f5e04e855f246820713c57f06",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/05bc372e86fb5f2f5e04e855f246820713c57f06",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/05bc372e86fb5f2f5e04e855f246820713c57f06",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/05bc372e86fb5f2f5e04e855f246820713c57f06/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "cg31",
      "id": 575738,
      "node_id": "MDQ6VXNlcjU3NTczOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/575738?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cg31",
      "html_url": "https://github.com/cg31",
      "followers_url": "https://api.github.com/users/cg31/followers",
      "following_url": "https://api.github.com/users/cg31/following{/other_user}",
      "gists_url": "https://api.github.com/users/cg31/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cg31/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cg31/subscriptions",
      "organizations_url": "https://api.github.com/users/cg31/orgs",
      "repos_url": "https://api.github.com/users/cg31/repos",
      "events_url": "https://api.github.com/users/cg31/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cg31/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e4ef6315316ddbfdce0e52162c1fd7bdbc3f1751",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e4ef6315316ddbfdce0e52162c1fd7bdbc3f1751",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e4ef6315316ddbfdce0e52162c1fd7bdbc3f1751"
      }
    ],
    "stats": {
      "total": 226,
      "additions": 195,
      "deletions": 31
    },
    "files": [
      {
        "sha": "556ebaef74dfca7037edb1cbc51ffa87440b9399",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 98,
        "deletions": 1,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/05bc372e86fb5f2f5e04e855f246820713c57f06/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/05bc372e86fb5f2f5e04e855f246820713c57f06/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=05bc372e86fb5f2f5e04e855f246820713c57f06",
        "patch": "@@ -24,6 +24,7 @@\n #include \"boost/multi_index_container.hpp\"\n #include \"boost/multi_index/ordered_index.hpp\"\n #include \"boost/multi_index/hashed_index.hpp\"\n+#include <boost/multi_index/sequenced_index.hpp>\n \n #include <boost/signals2/signal.hpp>\n \n@@ -185,14 +186,19 @@ struct update_lock_points\n     const LockPoints& lp;\n };\n \n-// extracts a TxMemPoolEntry's transaction hash\n+// extracts a transaction hash from CTxMempoolEntry or CTransactionRef\n struct mempoolentry_txid\n {\n     typedef uint256 result_type;\n     result_type operator() (const CTxMemPoolEntry &entry) const\n     {\n         return entry.GetTx().GetHash();\n     }\n+\n+    result_type operator() (const CTransactionRef& tx) const\n+    {\n+        return tx->GetHash();\n+    }\n };\n \n /** \\class CompareTxMemPoolEntryByDescendantScore\n@@ -662,4 +668,95 @@ class CCoinsViewMemPool : public CCoinsViewBacked\n     bool HaveCoins(const uint256 &txid) const;\n };\n \n+/**\n+ * DisconnectedBlockTransactions\n+\n+ * During the reorg, it's desirable to re-add previously confirmed transactions\n+ * to the mempool, so that anything not re-confirmed in the new chain is\n+ * available to be mined. However, it's more efficient to wait until the reorg\n+ * is complete and process all still-unconfirmed transactions at that time,\n+ * since we expect most confirmed transactions to (typically) still be\n+ * confirmed in the new chain, and re-accepting to the memory pool is expensive\n+ * (and therefore better to not do in the middle of reorg-processing).\n+ * Instead, store the disconnected transactions (in order!) as we go, remove any\n+ * that are included in blocks in the new chain, and then process the remaining\n+ * still-unconfirmed transactions at the end.\n+ */\n+\n+// multi_index tag names\n+struct txid_index {};\n+struct insertion_order {};\n+\n+struct DisconnectedBlockTransactions {\n+    typedef boost::multi_index_container<\n+        CTransactionRef,\n+        boost::multi_index::indexed_by<\n+            // sorted by txid\n+            boost::multi_index::hashed_unique<\n+                boost::multi_index::tag<txid_index>,\n+                mempoolentry_txid,\n+                SaltedTxidHasher\n+            >,\n+            // sorted by order in the blockchain\n+            boost::multi_index::sequenced<\n+                boost::multi_index::tag<insertion_order>\n+            >\n+        >\n+    > indexed_disconnected_transactions;\n+\n+    // It's almost certainly a logic bug if we don't clear out queuedTx before\n+    // destruction, as we add to it while disconnecting blocks, and then we\n+    // need to re-process remaining transactions to ensure mempool consistency.\n+    // For now, assert() that we've emptied out this object on destruction.\n+    // This assert() can always be removed if the reorg-processing code were\n+    // to be refactored such that this assumption is no longer true (for\n+    // instance if there was some other way we cleaned up the mempool after a\n+    // reorg, besides draining this object).\n+    ~DisconnectedBlockTransactions() { assert(queuedTx.empty()); }\n+\n+    indexed_disconnected_transactions queuedTx;\n+    uint64_t cachedInnerUsage = 0;\n+\n+    // Estimate the overhead of queuedTx to be 6 pointers + an allocation, as\n+    // no exact formula for boost::multi_index_contained is implemented.\n+    size_t DynamicMemoryUsage() const {\n+        return memusage::MallocUsage(sizeof(CTransactionRef) + 6 * sizeof(void*)) * queuedTx.size() + cachedInnerUsage;\n+    }\n+\n+    void addTransaction(const CTransactionRef& tx)\n+    {\n+        queuedTx.insert(tx);\n+        cachedInnerUsage += RecursiveDynamicUsage(*tx) + memusage::DynamicUsage(tx);\n+    }\n+\n+    // Remove entries based on txid_index, and update memory usage.\n+    void removeForBlock(const std::vector<CTransactionRef>& vtx)\n+    {\n+        // Short-circuit in the common case of a block being added to the tip\n+        if (queuedTx.empty()) {\n+            return;\n+        }\n+        for (auto const &tx : vtx) {\n+            auto it = queuedTx.find(tx->GetHash());\n+            if (it != queuedTx.end()) {\n+                cachedInnerUsage -= RecursiveDynamicUsage(**it) + memusage::DynamicUsage(*it);\n+                queuedTx.erase(it);\n+            }\n+        }\n+    }\n+\n+    // Remove an entry by insertion_order index, and update memory usage.\n+    void removeEntry(indexed_disconnected_transactions::index<insertion_order>::type::iterator entry)\n+    {\n+        cachedInnerUsage -= RecursiveDynamicUsage(**entry) + memusage::DynamicUsage(*entry);\n+        queuedTx.get<insertion_order>().erase(entry);\n+    }\n+\n+    void clear()\n+    {\n+        cachedInnerUsage = 0;\n+        queuedTx.clear();\n+    }\n+};\n+\n #endif // BITCOIN_TXMEMPOOL_H"
      },
      {
        "sha": "f0cccf70b752de1f913a5c5fc225269344311cbe",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 95,
        "deletions": 30,
        "changes": 125,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/05bc372e86fb5f2f5e04e855f246820713c57f06/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/05bc372e86fb5f2f5e04e855f246820713c57f06/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=05bc372e86fb5f2f5e04e855f246820713c57f06",
        "patch": "@@ -342,6 +342,56 @@ static bool IsCurrentForFeeEstimation()\n     return true;\n }\n \n+/* Make mempool consistent after a reorg, by re-adding or recursively erasing\n+ * disconnected block transactions from the mempool, and also removing any\n+ * other transactions from the mempool that are no longer valid given the new\n+ * tip/height.\n+ *\n+ * Note: we assume that disconnectpool only contains transactions that are NOT\n+ * confirmed in the current chain nor already in the mempool (otherwise,\n+ * in-mempool descendants of such transactions would be removed).\n+ *\n+ * Passing fAddToMempool=false will skip trying to add the transactions back,\n+ * and instead just erase from the mempool as needed.\n+ */\n+\n+void UpdateMempoolForReorg(DisconnectedBlockTransactions &disconnectpool, bool fAddToMempool)\n+{\n+    AssertLockHeld(cs_main);\n+    std::vector<uint256> vHashUpdate;\n+    // disconnectpool's insertion_order index sorts the entries from\n+    // oldest to newest, but the oldest entry will be the last tx from the\n+    // latest mined block that was disconnected.\n+    // Iterate disconnectpool in reverse, so that we add transactions\n+    // back to the mempool starting with the earliest transaction that had\n+    // been previously seen in a block.\n+    auto it = disconnectpool.queuedTx.get<insertion_order>().rbegin();\n+    while (it != disconnectpool.queuedTx.get<insertion_order>().rend()) {\n+        // ignore validation errors in resurrected transactions\n+        CValidationState stateDummy;\n+        if (!fAddToMempool || (*it)->IsCoinBase() || !AcceptToMemoryPool(mempool, stateDummy, *it, false, NULL, NULL, true)) {\n+            // If the transaction doesn't make it in to the mempool, remove any\n+            // transactions that depend on it (which would now be orphans).\n+            mempool.removeRecursive(**it, MemPoolRemovalReason::REORG);\n+        } else if (mempool.exists((*it)->GetHash())) {\n+            vHashUpdate.push_back((*it)->GetHash());\n+        }\n+        ++it;\n+    }\n+    disconnectpool.queuedTx.clear();\n+    // AcceptToMemoryPool/addUnchecked all assume that new mempool entries have\n+    // no in-mempool children, which is generally not true when adding\n+    // previously-confirmed transactions back to the mempool.\n+    // UpdateTransactionsFromBlock finds descendants of any transactions in\n+    // the disconnectpool that were added back and cleans up the mempool state.\n+    mempool.UpdateTransactionsFromBlock(vHashUpdate);\n+\n+    // We also need to remove any now-immature transactions\n+    mempool.removeForReorg(pcoinsTip, chainActive.Tip()->nHeight + 1, STANDARD_LOCKTIME_VERIFY_FLAGS);\n+    // Re-limit mempool size, in case we added any transactions\n+    LimitMempoolSize(mempool, GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n+}\n+\n bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx, bool fLimitFree,\n                               bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n                               bool fOverrideMempoolLimit, const CAmount& nAbsurdFee, std::vector<uint256>& vHashTxnToUncache)\n@@ -1877,8 +1927,17 @@ void static UpdateTip(CBlockIndex *pindexNew, const CChainParams& chainParams) {\n \n }\n \n-/** Disconnect chainActive's tip. You probably want to call mempool.removeForReorg and manually re-limit mempool size after this, with cs_main held. */\n-bool static DisconnectTip(CValidationState& state, const CChainParams& chainparams, bool fBare = false)\n+/** Disconnect chainActive's tip.\n+  * After calling, the mempool will be in an inconsistent state, with\n+  * transactions from disconnected blocks being added to disconnectpool.  You\n+  * should make the mempool consistent again by calling UpdateMempoolForReorg.\n+  * with cs_main held.\n+  *\n+  * If disconnectpool is NULL, then no disconnected transactions are added to\n+  * disconnectpool (note that the caller is responsible for mempool consistency\n+  * in any case).\n+  */\n+bool static DisconnectTip(CValidationState& state, const CChainParams& chainparams, DisconnectedBlockTransactions *disconnectpool)\n {\n     CBlockIndex *pindexDelete = chainActive.Tip();\n     assert(pindexDelete);\n@@ -1901,25 +1960,17 @@ bool static DisconnectTip(CValidationState& state, const CChainParams& chainpara\n     if (!FlushStateToDisk(state, FLUSH_STATE_IF_NEEDED))\n         return false;\n \n-    if (!fBare) {\n-        // Resurrect mempool transactions from the disconnected block.\n-        std::vector<uint256> vHashUpdate;\n-        for (const auto& it : block.vtx) {\n-            const CTransaction& tx = *it;\n-            // ignore validation errors in resurrected transactions\n-            CValidationState stateDummy;\n-            if (tx.IsCoinBase() || !AcceptToMemoryPool(mempool, stateDummy, it, false, NULL, NULL, true)) {\n-                mempool.removeRecursive(tx, MemPoolRemovalReason::REORG);\n-            } else if (mempool.exists(tx.GetHash())) {\n-                vHashUpdate.push_back(tx.GetHash());\n-            }\n+    if (disconnectpool) {\n+        // Save transactions to re-add to mempool at end of reorg\n+        for (auto it = block.vtx.rbegin(); it != block.vtx.rend(); ++it) {\n+            disconnectpool->addTransaction(*it);\n+        }\n+        while (disconnectpool->DynamicMemoryUsage() > MAX_DISCONNECTED_TX_POOL_SIZE * 1000) {\n+            // Drop the earliest entry, and remove its children from the mempool.\n+            auto it = disconnectpool->queuedTx.get<insertion_order>().begin();\n+            mempool.removeRecursive(**it, MemPoolRemovalReason::REORG);\n+            disconnectpool->removeEntry(it);\n         }\n-        // AcceptToMemoryPool/addUnchecked all assume that new mempool entries have\n-        // no in-mempool children, which is generally not true when adding\n-        // previously-confirmed transactions back to the mempool.\n-        // UpdateTransactionsFromBlock finds descendants of any transactions in this\n-        // block that were added back and cleans up the mempool state.\n-        mempool.UpdateTransactionsFromBlock(vHashUpdate);\n     }\n \n     // Update chainActive and related variables.\n@@ -2007,7 +2058,7 @@ class ConnectTrace {\n  *\n  * The block is added to connectTrace if connection succeeds.\n  */\n-bool static ConnectTip(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace)\n+bool static ConnectTip(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions &disconnectpool)\n {\n     assert(pindexNew->pprev == chainActive.Tip());\n     // Read block from disk.\n@@ -2049,6 +2100,7 @@ bool static ConnectTip(CValidationState& state, const CChainParams& chainparams,\n     LogPrint(BCLog::BENCH, \"  - Writing chainstate: %.2fms [%.2fs]\\n\", (nTime5 - nTime4) * 0.001, nTimeChainState * 0.000001);\n     // Remove conflicting transactions from the mempool.;\n     mempool.removeForBlock(blockConnecting.vtx, pindexNew->nHeight);\n+    disconnectpool.removeForBlock(blockConnecting.vtx);\n     // Update chainActive & related variables.\n     UpdateTip(pindexNew, chainparams);\n \n@@ -2142,9 +2194,14 @@ static bool ActivateBestChainStep(CValidationState& state, const CChainParams& c\n \n     // Disconnect active blocks which are no longer in the best chain.\n     bool fBlocksDisconnected = false;\n+    DisconnectedBlockTransactions disconnectpool;\n     while (chainActive.Tip() && chainActive.Tip() != pindexFork) {\n-        if (!DisconnectTip(state, chainparams))\n+        if (!DisconnectTip(state, chainparams, &disconnectpool)) {\n+            // This is likely a fatal error, but keep the mempool consistent,\n+            // just in case. Only remove from the mempool in this case.\n+            UpdateMempoolForReorg(disconnectpool, false);\n             return false;\n+        }\n         fBlocksDisconnected = true;\n     }\n \n@@ -2167,7 +2224,7 @@ static bool ActivateBestChainStep(CValidationState& state, const CChainParams& c\n \n         // Connect new blocks.\n         BOOST_REVERSE_FOREACH(CBlockIndex *pindexConnect, vpindexToConnect) {\n-            if (!ConnectTip(state, chainparams, pindexConnect, pindexConnect == pindexMostWork ? pblock : std::shared_ptr<const CBlock>(), connectTrace)) {\n+            if (!ConnectTip(state, chainparams, pindexConnect, pindexConnect == pindexMostWork ? pblock : std::shared_ptr<const CBlock>(), connectTrace, disconnectpool)) {\n                 if (state.IsInvalid()) {\n                     // The block violates a consensus rule.\n                     if (!state.CorruptionPossible())\n@@ -2178,6 +2235,9 @@ static bool ActivateBestChainStep(CValidationState& state, const CChainParams& c\n                     break;\n                 } else {\n                     // A system error occurred (disk space, database error, ...).\n+                    // Make the mempool consistent with the current tip, just in case\n+                    // any observers try to use it before shutdown.\n+                    UpdateMempoolForReorg(disconnectpool, false);\n                     return false;\n                 }\n             } else {\n@@ -2192,8 +2252,9 @@ static bool ActivateBestChainStep(CValidationState& state, const CChainParams& c\n     }\n \n     if (fBlocksDisconnected) {\n-        mempool.removeForReorg(pcoinsTip, chainActive.Tip()->nHeight + 1, STANDARD_LOCKTIME_VERIFY_FLAGS);\n-        LimitMempoolSize(mempool, GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n+        // If any blocks were disconnected, disconnectpool may be non empty.  Add\n+        // any disconnected transactions back to the mempool.\n+        UpdateMempoolForReorg(disconnectpool, true);\n     }\n     mempool.check(pcoinsTip);\n \n@@ -2342,20 +2403,25 @@ bool InvalidateBlock(CValidationState& state, const CChainParams& chainparams, C\n     setDirtyBlockIndex.insert(pindex);\n     setBlockIndexCandidates.erase(pindex);\n \n+    DisconnectedBlockTransactions disconnectpool;\n     while (chainActive.Contains(pindex)) {\n         CBlockIndex *pindexWalk = chainActive.Tip();\n         pindexWalk->nStatus |= BLOCK_FAILED_CHILD;\n         setDirtyBlockIndex.insert(pindexWalk);\n         setBlockIndexCandidates.erase(pindexWalk);\n         // ActivateBestChain considers blocks already in chainActive\n         // unconditionally valid already, so force disconnect away from it.\n-        if (!DisconnectTip(state, chainparams)) {\n-            mempool.removeForReorg(pcoinsTip, chainActive.Tip()->nHeight + 1, STANDARD_LOCKTIME_VERIFY_FLAGS);\n+        if (!DisconnectTip(state, chainparams, &disconnectpool)) {\n+            // It's probably hopeless to try to make the mempool consistent\n+            // here if DisconnectTip failed, but we can try.\n+            UpdateMempoolForReorg(disconnectpool, false);\n             return false;\n         }\n     }\n \n-    LimitMempoolSize(mempool, GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n+    // DisconnectTip will add transactions to disconnectpool; try to add these\n+    // back to the mempool.\n+    UpdateMempoolForReorg(disconnectpool, true);\n \n     // The resulting new best tip may not be in setBlockIndexCandidates anymore, so\n     // add it again.\n@@ -2368,7 +2434,6 @@ bool InvalidateBlock(CValidationState& state, const CChainParams& chainparams, C\n     }\n \n     InvalidChainFound(pindex);\n-    mempool.removeForReorg(pcoinsTip, chainActive.Tip()->nHeight + 1, STANDARD_LOCKTIME_VERIFY_FLAGS);\n     uiInterface.NotifyBlockTip(IsInitialBlockDownload(), pindex->pprev);\n     return true;\n }\n@@ -3482,7 +3547,7 @@ bool RewindBlockIndex(const CChainParams& params)\n             // of the blockchain).\n             break;\n         }\n-        if (!DisconnectTip(state, params, true)) {\n+        if (!DisconnectTip(state, params, NULL)) {\n             return error(\"RewindBlockIndex: unable to disconnect block at height %i\", pindex->nHeight);\n         }\n         // Occasionally flush state to disk."
      },
      {
        "sha": "02a9b5a3695bfc4989f7799d1264a00ddd716054",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/05bc372e86fb5f2f5e04e855f246820713c57f06/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/05bc372e86fb5f2f5e04e855f246820713c57f06/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=05bc372e86fb5f2f5e04e855f246820713c57f06",
        "patch": "@@ -70,6 +70,8 @@ static const unsigned int DEFAULT_DESCENDANT_LIMIT = 25;\n static const unsigned int DEFAULT_DESCENDANT_SIZE_LIMIT = 101;\n /** Default for -mempoolexpiry, expiration time for mempool transactions in hours */\n static const unsigned int DEFAULT_MEMPOOL_EXPIRY = 336;\n+/** Maximum kilobytes for transactions to store for processing during reorg */\n+static const unsigned int MAX_DISCONNECTED_TX_POOL_SIZE = 20000;\n /** The maximum size of a blk?????.dat file (since 0.8) */\n static const unsigned int MAX_BLOCKFILE_SIZE = 0x8000000; // 128 MiB\n /** The pre-allocation chunk size for blk?????.dat files (since 0.8) */"
      }
    ]
  },
  {
    "sha": "34061ad07948d458977fe1412a40240a331750ef",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNDA2MWFkMDc5NDhkNDU4OTc3ZmUxNDEyYTQwMjQwYTMzMTc1MGVm",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2016-11-21T16:47:12Z"
      },
      "committer": {
        "name": "Zero Chen",
        "email": "chengang31@gmail.com",
        "date": "2017-05-31T08:52:25Z"
      },
      "message": "Add RecursiveDynamicUsage overload for std::shared_ptr\n\nThis simplifies a few usage expressions.",
      "tree": {
        "sha": "bca083b769f9d348a10e76e73e457dc112e5a482",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bca083b769f9d348a10e76e73e457dc112e5a482"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/34061ad07948d458977fe1412a40240a331750ef",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/34061ad07948d458977fe1412a40240a331750ef",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/34061ad07948d458977fe1412a40240a331750ef",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/34061ad07948d458977fe1412a40240a331750ef/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "cg31",
      "id": 575738,
      "node_id": "MDQ6VXNlcjU3NTczOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/575738?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cg31",
      "html_url": "https://github.com/cg31",
      "followers_url": "https://api.github.com/users/cg31/followers",
      "following_url": "https://api.github.com/users/cg31/following{/other_user}",
      "gists_url": "https://api.github.com/users/cg31/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cg31/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cg31/subscriptions",
      "organizations_url": "https://api.github.com/users/cg31/orgs",
      "repos_url": "https://api.github.com/users/cg31/repos",
      "events_url": "https://api.github.com/users/cg31/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cg31/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "05bc372e86fb5f2f5e04e855f246820713c57f06",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/05bc372e86fb5f2f5e04e855f246820713c57f06",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/05bc372e86fb5f2f5e04e855f246820713c57f06"
      }
    ],
    "stats": {
      "total": 13,
      "additions": 9,
      "deletions": 4
    },
    "files": [
      {
        "sha": "e4ccd54c4238b899752a7924da0ebc384e44206c",
        "filename": "src/core_memusage.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/34061ad07948d458977fe1412a40240a331750ef/src/core_memusage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/34061ad07948d458977fe1412a40240a331750ef/src/core_memusage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_memusage.h?ref=34061ad07948d458977fe1412a40240a331750ef",
        "patch": "@@ -63,4 +63,9 @@ static inline size_t RecursiveDynamicUsage(const CBlockLocator& locator) {\n     return memusage::DynamicUsage(locator.vHave);\n }\n \n+template<typename X>\n+static inline size_t RecursiveDynamicUsage(const std::shared_ptr<X>& p) {\n+    return p ? memusage::DynamicUsage(p) + RecursiveDynamicUsage(*p) : 0;\n+}\n+\n #endif // BITCOIN_CORE_MEMUSAGE_H"
      },
      {
        "sha": "852984426f683e2725ea91e546aed026a054e862",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/34061ad07948d458977fe1412a40240a331750ef/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/34061ad07948d458977fe1412a40240a331750ef/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=34061ad07948d458977fe1412a40240a331750ef",
        "patch": "@@ -24,7 +24,7 @@ CTxMemPoolEntry::CTxMemPoolEntry(const CTransactionRef& _tx, const CAmount& _nFe\n     spendsCoinbase(_spendsCoinbase), sigOpCost(_sigOpsCost), lockPoints(lp)\n {\n     nTxWeight = GetTransactionWeight(*tx);\n-    nUsageSize = RecursiveDynamicUsage(*tx) + memusage::DynamicUsage(tx);\n+    nUsageSize = RecursiveDynamicUsage(tx);\n \n     nCountWithDescendants = 1;\n     nSizeWithDescendants = GetTxSize();"
      },
      {
        "sha": "671a8b596c0e58bd9c15cf1728fa72dfef77a52f",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/34061ad07948d458977fe1412a40240a331750ef/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/34061ad07948d458977fe1412a40240a331750ef/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=34061ad07948d458977fe1412a40240a331750ef",
        "patch": "@@ -726,7 +726,7 @@ struct DisconnectedBlockTransactions {\n     void addTransaction(const CTransactionRef& tx)\n     {\n         queuedTx.insert(tx);\n-        cachedInnerUsage += RecursiveDynamicUsage(*tx) + memusage::DynamicUsage(tx);\n+        cachedInnerUsage += RecursiveDynamicUsage(tx);\n     }\n \n     // Remove entries based on txid_index, and update memory usage.\n@@ -739,7 +739,7 @@ struct DisconnectedBlockTransactions {\n         for (auto const &tx : vtx) {\n             auto it = queuedTx.find(tx->GetHash());\n             if (it != queuedTx.end()) {\n-                cachedInnerUsage -= RecursiveDynamicUsage(**it) + memusage::DynamicUsage(*it);\n+                cachedInnerUsage -= RecursiveDynamicUsage(*it);\n                 queuedTx.erase(it);\n             }\n         }\n@@ -748,7 +748,7 @@ struct DisconnectedBlockTransactions {\n     // Remove an entry by insertion_order index, and update memory usage.\n     void removeEntry(indexed_disconnected_transactions::index<insertion_order>::type::iterator entry)\n     {\n-        cachedInnerUsage -= RecursiveDynamicUsage(**entry) + memusage::DynamicUsage(*entry);\n+        cachedInnerUsage -= RecursiveDynamicUsage(*entry);\n         queuedTx.get<insertion_order>().erase(entry);\n     }\n "
      }
    ]
  },
  {
    "sha": "90f8fd96613b875767ada3b8444c3d1e2d0b7205",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MGY4ZmQ5NjYxM2I4NzU3NjdhZGEzYjg0NDRjM2QxZTJkMGI3MjA1",
    "commit": {
      "author": {
        "name": "Jorge Tim\u00f3n",
        "email": "jtimon@jtimon.cc",
        "date": "2017-05-27T03:31:04Z"
      },
      "committer": {
        "name": "Zero Chen",
        "email": "chengang31@gmail.com",
        "date": "2017-05-31T08:52:25Z"
      },
      "message": "Introduce static DoWarning (simplify UpdateTip)",
      "tree": {
        "sha": "8a3291cca33b76b57dfe944c66c50808b365fed1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8a3291cca33b76b57dfe944c66c50808b365fed1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/90f8fd96613b875767ada3b8444c3d1e2d0b7205",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/90f8fd96613b875767ada3b8444c3d1e2d0b7205",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/90f8fd96613b875767ada3b8444c3d1e2d0b7205",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/90f8fd96613b875767ada3b8444c3d1e2d0b7205/comments",
    "author": {
      "login": "jtimon",
      "id": 1008458,
      "node_id": "MDQ6VXNlcjEwMDg0NTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1008458?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtimon",
      "html_url": "https://github.com/jtimon",
      "followers_url": "https://api.github.com/users/jtimon/followers",
      "following_url": "https://api.github.com/users/jtimon/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtimon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtimon/subscriptions",
      "organizations_url": "https://api.github.com/users/jtimon/orgs",
      "repos_url": "https://api.github.com/users/jtimon/repos",
      "events_url": "https://api.github.com/users/jtimon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtimon/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "cg31",
      "id": 575738,
      "node_id": "MDQ6VXNlcjU3NTczOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/575738?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cg31",
      "html_url": "https://github.com/cg31",
      "followers_url": "https://api.github.com/users/cg31/followers",
      "following_url": "https://api.github.com/users/cg31/following{/other_user}",
      "gists_url": "https://api.github.com/users/cg31/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cg31/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cg31/subscriptions",
      "organizations_url": "https://api.github.com/users/cg31/orgs",
      "repos_url": "https://api.github.com/users/cg31/repos",
      "events_url": "https://api.github.com/users/cg31/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cg31/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "34061ad07948d458977fe1412a40240a331750ef",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/34061ad07948d458977fe1412a40240a331750ef",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/34061ad07948d458977fe1412a40240a331750ef"
      }
    ],
    "stats": {
      "total": 29,
      "additions": 15,
      "deletions": 14
    },
    "files": [
      {
        "sha": "381d1b01c241b7805a24018ffe2ef39a12f852ab",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 14,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90f8fd96613b875767ada3b8444c3d1e2d0b7205/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90f8fd96613b875767ada3b8444c3d1e2d0b7205/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=90f8fd96613b875767ada3b8444c3d1e2d0b7205",
        "patch": "@@ -1864,6 +1864,16 @@ void PruneAndFlush() {\n     FlushStateToDisk(state, FLUSH_STATE_NONE);\n }\n \n+static void DoWarning(const std::string& strWarning)\n+{\n+    static bool fWarned = false;\n+    SetMiscWarning(strWarning);\n+    if (!fWarned) {\n+        AlertNotify(strWarning);\n+        fWarned = true;\n+    }\n+}\n+\n /** Update chainActive and related internal data structures. */\n void static UpdateTip(CBlockIndex *pindexNew, const CChainParams& chainParams) {\n     chainActive.SetTip(pindexNew);\n@@ -1873,7 +1883,6 @@ void static UpdateTip(CBlockIndex *pindexNew, const CChainParams& chainParams) {\n \n     cvBlockChange.notify_all();\n \n-    static bool fWarned = false;\n     std::vector<std::string> warningMessages;\n     if (!IsInitialBlockDownload())\n     {\n@@ -1883,15 +1892,11 @@ void static UpdateTip(CBlockIndex *pindexNew, const CChainParams& chainParams) {\n             WarningBitsConditionChecker checker(bit);\n             ThresholdState state = checker.GetStateFor(pindex, chainParams.GetConsensus(), warningcache[bit]);\n             if (state == THRESHOLD_ACTIVE || state == THRESHOLD_LOCKED_IN) {\n+                const std::string strWarning = strprintf(_(\"Warning: unknown new rules activated (versionbit %i)\"), bit);\n                 if (state == THRESHOLD_ACTIVE) {\n-                    std::string strWarning = strprintf(_(\"Warning: unknown new rules activated (versionbit %i)\"), bit);\n-                    SetMiscWarning(strWarning);\n-                    if (!fWarned) {\n-                        AlertNotify(strWarning);\n-                        fWarned = true;\n-                    }\n+                    DoWarning(strWarning);\n                 } else {\n-                    warningMessages.push_back(strprintf(\"unknown new rules are about to activate (versionbit %i)\", bit));\n+                    warningMessages.push_back(strWarning);\n                 }\n             }\n         }\n@@ -1904,16 +1909,12 @@ void static UpdateTip(CBlockIndex *pindexNew, const CChainParams& chainParams) {\n             pindex = pindex->pprev;\n         }\n         if (nUpgraded > 0)\n-            warningMessages.push_back(strprintf(\"%d of last 100 blocks have unexpected version\", nUpgraded));\n+            warningMessages.push_back(strprintf(_(\"%d of last 100 blocks have unexpected version\"), nUpgraded));\n         if (nUpgraded > 100/2)\n         {\n             std::string strWarning = _(\"Warning: Unknown block versions being mined! It's possible unknown rules are in effect\");\n             // notify GetWarnings(), called by Qt and the JSON-RPC code to warn the user:\n-            SetMiscWarning(strWarning);\n-            if (!fWarned) {\n-                AlertNotify(strWarning);\n-                fWarned = true;\n-            }\n+            DoWarning(strWarning);\n         }\n     }\n     LogPrintf(\"%s: new best=%s height=%d version=0x%08x log2_work=%.8g tx=%lu date='%s' progress=%f cache=%.1fMiB(%utx)\", __func__,"
      }
    ]
  },
  {
    "sha": "5ce654de35a9b507e2cfe93ae93d3e5356a0704d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1Y2U2NTRkZTM1YTliNTA3ZTJjZmU5M2FlOTNkM2U1MzU2YTA3MDRk",
    "commit": {
      "author": {
        "name": "Zero Chen",
        "email": "chengang31@gmail.com",
        "date": "2017-05-31T08:55:27Z"
      },
      "committer": {
        "name": "Zero Chen",
        "email": "chengang31@gmail.com",
        "date": "2017-05-31T08:55:27Z"
      },
      "message": "Merge branch 'master' of github.com:cg31/bitcoin",
      "tree": {
        "sha": "8a3291cca33b76b57dfe944c66c50808b365fed1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8a3291cca33b76b57dfe944c66c50808b365fed1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5ce654de35a9b507e2cfe93ae93d3e5356a0704d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5ce654de35a9b507e2cfe93ae93d3e5356a0704d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5ce654de35a9b507e2cfe93ae93d3e5356a0704d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5ce654de35a9b507e2cfe93ae93d3e5356a0704d/comments",
    "author": {
      "login": "cg31",
      "id": 575738,
      "node_id": "MDQ6VXNlcjU3NTczOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/575738?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cg31",
      "html_url": "https://github.com/cg31",
      "followers_url": "https://api.github.com/users/cg31/followers",
      "following_url": "https://api.github.com/users/cg31/following{/other_user}",
      "gists_url": "https://api.github.com/users/cg31/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cg31/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cg31/subscriptions",
      "organizations_url": "https://api.github.com/users/cg31/orgs",
      "repos_url": "https://api.github.com/users/cg31/repos",
      "events_url": "https://api.github.com/users/cg31/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cg31/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "cg31",
      "id": 575738,
      "node_id": "MDQ6VXNlcjU3NTczOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/575738?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cg31",
      "html_url": "https://github.com/cg31",
      "followers_url": "https://api.github.com/users/cg31/followers",
      "following_url": "https://api.github.com/users/cg31/following{/other_user}",
      "gists_url": "https://api.github.com/users/cg31/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cg31/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cg31/subscriptions",
      "organizations_url": "https://api.github.com/users/cg31/orgs",
      "repos_url": "https://api.github.com/users/cg31/repos",
      "events_url": "https://api.github.com/users/cg31/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cg31/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "90f8fd96613b875767ada3b8444c3d1e2d0b7205",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/90f8fd96613b875767ada3b8444c3d1e2d0b7205",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/90f8fd96613b875767ada3b8444c3d1e2d0b7205"
      },
      {
        "sha": "336f4c034e268c0bc483ef02554a4441f01b3e5f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/336f4c034e268c0bc483ef02554a4441f01b3e5f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/336f4c034e268c0bc483ef02554a4441f01b3e5f"
      }
    ],
    "stats": {
      "total": 0,
      "additions": 0,
      "deletions": 0
    },
    "files": []
  },
  {
    "sha": "f6b2ac7fa22819d491076e85017e27362f549b7f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNmIyYWM3ZmEyMjgxOWQ0OTEwNzZlODUwMTdlMjczNjJmNTQ5Yjdm",
    "commit": {
      "author": {
        "name": "Zero Chen",
        "email": "chengang31@gmail.com",
        "date": "2017-05-31T08:56:13Z"
      },
      "committer": {
        "name": "Zero Chen",
        "email": "chengang31@gmail.com",
        "date": "2017-05-31T08:56:13Z"
      },
      "message": "Merge remote-tracking branch 'upstream/master'",
      "tree": {
        "sha": "07f2f937c14b570a5c25df8d1c274320863a05ab",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/07f2f937c14b570a5c25df8d1c274320863a05ab"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f6b2ac7fa22819d491076e85017e27362f549b7f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f6b2ac7fa22819d491076e85017e27362f549b7f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f6b2ac7fa22819d491076e85017e27362f549b7f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f6b2ac7fa22819d491076e85017e27362f549b7f/comments",
    "author": {
      "login": "cg31",
      "id": 575738,
      "node_id": "MDQ6VXNlcjU3NTczOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/575738?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cg31",
      "html_url": "https://github.com/cg31",
      "followers_url": "https://api.github.com/users/cg31/followers",
      "following_url": "https://api.github.com/users/cg31/following{/other_user}",
      "gists_url": "https://api.github.com/users/cg31/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cg31/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cg31/subscriptions",
      "organizations_url": "https://api.github.com/users/cg31/orgs",
      "repos_url": "https://api.github.com/users/cg31/repos",
      "events_url": "https://api.github.com/users/cg31/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cg31/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "cg31",
      "id": 575738,
      "node_id": "MDQ6VXNlcjU3NTczOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/575738?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cg31",
      "html_url": "https://github.com/cg31",
      "followers_url": "https://api.github.com/users/cg31/followers",
      "following_url": "https://api.github.com/users/cg31/following{/other_user}",
      "gists_url": "https://api.github.com/users/cg31/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cg31/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cg31/subscriptions",
      "organizations_url": "https://api.github.com/users/cg31/orgs",
      "repos_url": "https://api.github.com/users/cg31/repos",
      "events_url": "https://api.github.com/users/cg31/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cg31/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5ce654de35a9b507e2cfe93ae93d3e5356a0704d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5ce654de35a9b507e2cfe93ae93d3e5356a0704d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5ce654de35a9b507e2cfe93ae93d3e5356a0704d"
      },
      {
        "sha": "c1c9a95379d364ea8ca5d3d0789e8afb1a99bb8b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c1c9a95379d364ea8ca5d3d0789e8afb1a99bb8b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c1c9a95379d364ea8ca5d3d0789e8afb1a99bb8b"
      }
    ],
    "stats": {
      "total": 13,
      "additions": 12,
      "deletions": 1
    },
    "files": [
      {
        "sha": "0e12a9d53eb3ebc8eef02508db2ff3084990e668",
        "filename": "src/qt/test/wallettests.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 1,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f6b2ac7fa22819d491076e85017e27362f549b7f/src/qt/test/wallettests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f6b2ac7fa22819d491076e85017e27362f549b7f/src/qt/test/wallettests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/wallettests.cpp?ref=f6b2ac7fa22819d491076e85017e27362f549b7f",
        "patch": "@@ -90,6 +90,17 @@ QModelIndex FindTx(const QAbstractItemModel& model, const uint256& txid)\n     return {};\n }\n \n+//! Request context menu (call method that is public in qt5, but protected in qt4).\n+void RequestContextMenu(QWidget* widget)\n+{\n+    class Qt4Hack : public QWidget\n+    {\n+    public:\n+        using QWidget::customContextMenuRequested;\n+    };\n+    static_cast<Qt4Hack*>(widget)->customContextMenuRequested({});\n+}\n+\n //! Invoke bumpfee on txid and check results.\n void BumpFee(TransactionView& view, const uint256& txid, bool expectDisabled, std::string expectError, bool cancel)\n {\n@@ -102,7 +113,7 @@ void BumpFee(TransactionView& view, const uint256& txid, bool expectDisabled, st\n     QAction* action = view.findChild<QAction*>(\"bumpFeeAction\");\n     table->selectionModel()->select(index, QItemSelectionModel::ClearAndSelect | QItemSelectionModel::Rows);\n     action->setEnabled(expectDisabled);\n-    table->customContextMenuRequested({});\n+    RequestContextMenu(table);\n     QCOMPARE(action->isEnabled(), !expectDisabled);\n \n     action->setEnabled(true);"
      }
    ]
  },
  {
    "sha": "0e6fa32ff5906558ba772a46b5c2eeaa8abeb3b3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowZTZmYTMyZmY1OTA2NTU4YmE3NzJhNDZiNWMyZWVhYThhYmViM2Iz",
    "commit": {
      "author": {
        "name": "Zero Chen",
        "email": "chengang31@gmail.com",
        "date": "2017-05-31T17:56:36Z"
      },
      "committer": {
        "name": "Zero Chen",
        "email": "chengang31@gmail.com",
        "date": "2017-05-31T17:56:36Z"
      },
      "message": "Merge remote-tracking branch 'upstream/master'",
      "tree": {
        "sha": "4215bd41d5aaabfc6a3b3a303c34948f2bf11f18",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4215bd41d5aaabfc6a3b3a303c34948f2bf11f18"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0e6fa32ff5906558ba772a46b5c2eeaa8abeb3b3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0e6fa32ff5906558ba772a46b5c2eeaa8abeb3b3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0e6fa32ff5906558ba772a46b5c2eeaa8abeb3b3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0e6fa32ff5906558ba772a46b5c2eeaa8abeb3b3/comments",
    "author": {
      "login": "cg31",
      "id": 575738,
      "node_id": "MDQ6VXNlcjU3NTczOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/575738?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cg31",
      "html_url": "https://github.com/cg31",
      "followers_url": "https://api.github.com/users/cg31/followers",
      "following_url": "https://api.github.com/users/cg31/following{/other_user}",
      "gists_url": "https://api.github.com/users/cg31/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cg31/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cg31/subscriptions",
      "organizations_url": "https://api.github.com/users/cg31/orgs",
      "repos_url": "https://api.github.com/users/cg31/repos",
      "events_url": "https://api.github.com/users/cg31/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cg31/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "cg31",
      "id": 575738,
      "node_id": "MDQ6VXNlcjU3NTczOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/575738?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cg31",
      "html_url": "https://github.com/cg31",
      "followers_url": "https://api.github.com/users/cg31/followers",
      "following_url": "https://api.github.com/users/cg31/following{/other_user}",
      "gists_url": "https://api.github.com/users/cg31/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cg31/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cg31/subscriptions",
      "organizations_url": "https://api.github.com/users/cg31/orgs",
      "repos_url": "https://api.github.com/users/cg31/repos",
      "events_url": "https://api.github.com/users/cg31/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cg31/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f6b2ac7fa22819d491076e85017e27362f549b7f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f6b2ac7fa22819d491076e85017e27362f549b7f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f6b2ac7fa22819d491076e85017e27362f549b7f"
      },
      {
        "sha": "18ba984140be5fd03eee95a21796c498391146e6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/18ba984140be5fd03eee95a21796c498391146e6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/18ba984140be5fd03eee95a21796c498391146e6"
      }
    ],
    "stats": {
      "total": 69,
      "additions": 48,
      "deletions": 21
    },
    "files": [
      {
        "sha": "ec6abda91e7b96ef138a131a037d728dedcf0bde",
        "filename": "doc/developer-notes.md",
        "status": "modified",
        "additions": 34,
        "deletions": 11,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e6fa32ff5906558ba772a46b5c2eeaa8abeb3b3/doc/developer-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e6fa32ff5906558ba772a46b5c2eeaa8abeb3b3/doc/developer-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/developer-notes.md?ref=0e6fa32ff5906558ba772a46b5c2eeaa8abeb3b3",
        "patch": "@@ -3,41 +3,64 @@ Developer Notes\n \n Various coding styles have been used during the history of the codebase,\n and the result is not very consistent. However, we're now trying to converge to\n-a single style, so please use it in new code. Old code will be converted\n-gradually and you are encouraged to use the provided\n-[clang-format-diff script](/contrib/devtools/README.md#clang-format-diffpy)\n-to clean up the patch automatically before submitting a pull request.\n+a single style, which is specified below. When writing patches, favor the new\n+style over attempting to mimick the surrounding style, except for move-only\n+commits.\n+\n+Do not submit patches solely to modify the style of existing code.\n \n-- Basic rules specified in [src/.clang-format](/src/.clang-format).\n+- **Indentation and whitespace rules** as specified in\n+[src/.clang-format](/src/.clang-format). You can use the provided\n+[clang-format-diff script](/contrib/devtools/README.md#clang-format-diffpy)\n+tool to clean up patches automatically before submission.\n   - Braces on new lines for namespaces, classes, functions, methods.\n   - Braces on the same line for everything else.\n   - 4 space indentation (no tabs) for every block except namespaces.\n   - No indentation for `public`/`protected`/`private` or for `namespace`.\n   - No extra spaces inside parenthesis; don't do ( this )\n   - No space after function names; one space after `if`, `for` and `while`.\n-  - If an `if` only has a single-statement then-clause, it can appear\n-    on the same line as the if, without braces. In every other case,\n-    braces are required, and the then and else clauses must appear\n+  - If an `if` only has a single-statement `then`-clause, it can appear\n+    on the same line as the `if`, without braces. In every other case,\n+    braces are required, and the `then` and `else` clauses must appear\n     correctly indented on a new line.\n+\n+- **Symbol naming conventions**. These are preferred in new code, but are not\n+required when doing so would need changes to significant pieces of existing\n+code.\n+  - Variable and namespace names are all lowercase, and may use `_` to\n+    separate words.\n+    - Class member variables have a `m_` prefix.\n+    - Global variables have a `g_` prefix.\n+  - Constant names are all uppercase, and use `_` to separate words.\n+  - Class names, function names and method names are CamelCase. Do not prefix\n+    class names with `C`.\n+\n+- **Miscellaneous**\n   - `++i` is preferred over `i++`.\n \n Block style example:\n ```c++\n+int g_count = 0;\n+\n namespace foo\n {\n class Class\n {\n+    std::string m_name;\n+\n+public:\n     bool Function(const std::string& s, int n)\n     {\n         // Comment summarising what this section of code does\n         for (int i = 0; i < n; ++i) {\n+            int total_sum = 0;\n             // When something fails, return early\n             if (!Something()) return false;\n             ...\n-            if (SomethingElse()) {\n-                DoMore();\n+            if (SomethingElse(i)) {\n+                total_sum += ComputeSomething(g_count);\n             } else {\n-                DoLess();\n+                DoSomething(m_name, total_sum);\n             }\n         }\n "
      },
      {
        "sha": "f343f1d96521ac887c7354b2f39c71d76df91e4e",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e6fa32ff5906558ba772a46b5c2eeaa8abeb3b3/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e6fa32ff5906558ba772a46b5c2eeaa8abeb3b3/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=0e6fa32ff5906558ba772a46b5c2eeaa8abeb3b3",
        "patch": "@@ -1386,11 +1386,6 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n         }\n     }\n \n-    if (gArgs.IsArgSet(\"-seednode\")) {\n-        BOOST_FOREACH(const std::string& strDest, gArgs.GetArgs(\"-seednode\"))\n-            connman.AddOneShot(strDest);\n-    }\n-\n #if ENABLE_ZMQ\n     pzmqNotificationInterface = CZMQNotificationInterface::Create();\n \n@@ -1659,6 +1654,10 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     connOptions.nMaxOutboundTimeframe = nMaxOutboundTimeframe;\n     connOptions.nMaxOutboundLimit = nMaxOutboundLimit;\n \n+    if (gArgs.IsArgSet(\"-seednode\")) {\n+        connOptions.vSeedNodes = gArgs.GetArgs(\"-seednode\");\n+    }\n+\n     if (!connman.Start(scheduler, strNodeError, connOptions))\n         return InitError(strNodeError);\n "
      },
      {
        "sha": "bac9b5732a2601a6f1b8847dba031353039ca330",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e6fa32ff5906558ba772a46b5c2eeaa8abeb3b3/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e6fa32ff5906558ba772a46b5c2eeaa8abeb3b3/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=0e6fa32ff5906558ba772a46b5c2eeaa8abeb3b3",
        "patch": "@@ -1743,9 +1743,9 @@ void CConnman::ThreadOpenConnections()\n         //  * Increase the number of connectable addresses in the tried table.\n         //\n         // Method:\n-        //  * Choose a random address from new and attempt to connect to it if we can connect \n+        //  * Choose a random address from new and attempt to connect to it if we can connect\n         //    successfully it is added to tried.\n-        //  * Start attempting feeler connections only after node finishes making outbound \n+        //  * Start attempting feeler connections only after node finishes making outbound\n         //    connections.\n         //  * Only make a feeler connection once every few minutes.\n         //\n@@ -2212,6 +2212,10 @@ bool CConnman::Start(CScheduler& scheduler, std::string& strNodeError, Options c\n \n     SetBestHeight(connOptions.nBestHeight);\n \n+    for (const auto& strDest : connOptions.vSeedNodes) {\n+        AddOneShot(strDest);\n+    }\n+\n     clientInterface = connOptions.uiInterface;\n     if (clientInterface) {\n         clientInterface->InitMessage(_(\"Loading P2P addresses...\"));"
      },
      {
        "sha": "7f9ec1a57b6ec4622e340f5aa700de78e47912b7",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e6fa32ff5906558ba772a46b5c2eeaa8abeb3b3/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e6fa32ff5906558ba772a46b5c2eeaa8abeb3b3/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=0e6fa32ff5906558ba772a46b5c2eeaa8abeb3b3",
        "patch": "@@ -144,6 +144,7 @@ class CConnman\n         unsigned int nReceiveFloodSize = 0;\n         uint64_t nMaxOutboundTimeframe = 0;\n         uint64_t nMaxOutboundLimit = 0;\n+        std::vector<std::string> vSeedNodes;\n     };\n     CConnman(uint64_t seed0, uint64_t seed1);\n     ~CConnman();\n@@ -233,8 +234,6 @@ class CConnman\n     void GetBanned(banmap_t &banmap);\n     void SetBanned(const banmap_t &banmap);\n \n-    void AddOneShot(const std::string& strDest);\n-\n     bool AddNode(const std::string& node);\n     bool RemoveAddedNode(const std::string& node);\n     std::vector<AddedNodeInfo> GetAddedNodeInfo();\n@@ -292,6 +291,7 @@ class CConnman\n     };\n \n     void ThreadOpenAddedConnections();\n+    void AddOneShot(const std::string& strDest);\n     void ProcessOneShot();\n     void ThreadOpenConnections();\n     void ThreadMessageHandler();"
      },
      {
        "sha": "4386ddd550e63e9ddf373f5a6593acaacf6bd373",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e6fa32ff5906558ba772a46b5c2eeaa8abeb3b3/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e6fa32ff5906558ba772a46b5c2eeaa8abeb3b3/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=0e6fa32ff5906558ba772a46b5c2eeaa8abeb3b3",
        "patch": "@@ -241,7 +241,8 @@ bool SoftSetArg(const std::string& strArg, const std::string& strValue);\n  */\n bool SoftSetBoolArg(const std::string& strArg, bool fValue);\n \n-// Forces a arg setting, used only in testing\n+// Forces an arg setting. Called by SoftSetArg() if the arg hasn't already\n+// been set. Also called directly in testing.\n void ForceSetArg(const std::string& strArg, const std::string& strValue);\n };\n "
      }
    ]
  },
  {
    "sha": "99cd6459cdb7386f5cbb4a98062234068be5db30",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5OWNkNjQ1OWNkYjczODZmNWNiYjRhOTgwNjIyMzQwNjhiZTVkYjMw",
    "commit": {
      "author": {
        "name": "cg",
        "email": "chengang31@gmail.com",
        "date": "2017-06-02T03:00:58Z"
      },
      "committer": {
        "name": "cg",
        "email": "chengang31@gmail.com",
        "date": "2017-06-02T03:00:58Z"
      },
      "message": "Merge remote-tracking branch 'upstream/master'",
      "tree": {
        "sha": "fcd7cd994437e23eae7b8a1bd9bfa3e2c3b64c57",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fcd7cd994437e23eae7b8a1bd9bfa3e2c3b64c57"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/99cd6459cdb7386f5cbb4a98062234068be5db30",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/99cd6459cdb7386f5cbb4a98062234068be5db30",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/99cd6459cdb7386f5cbb4a98062234068be5db30",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/99cd6459cdb7386f5cbb4a98062234068be5db30/comments",
    "author": {
      "login": "cg31",
      "id": 575738,
      "node_id": "MDQ6VXNlcjU3NTczOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/575738?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cg31",
      "html_url": "https://github.com/cg31",
      "followers_url": "https://api.github.com/users/cg31/followers",
      "following_url": "https://api.github.com/users/cg31/following{/other_user}",
      "gists_url": "https://api.github.com/users/cg31/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cg31/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cg31/subscriptions",
      "organizations_url": "https://api.github.com/users/cg31/orgs",
      "repos_url": "https://api.github.com/users/cg31/repos",
      "events_url": "https://api.github.com/users/cg31/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cg31/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "cg31",
      "id": 575738,
      "node_id": "MDQ6VXNlcjU3NTczOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/575738?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cg31",
      "html_url": "https://github.com/cg31",
      "followers_url": "https://api.github.com/users/cg31/followers",
      "following_url": "https://api.github.com/users/cg31/following{/other_user}",
      "gists_url": "https://api.github.com/users/cg31/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cg31/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cg31/subscriptions",
      "organizations_url": "https://api.github.com/users/cg31/orgs",
      "repos_url": "https://api.github.com/users/cg31/repos",
      "events_url": "https://api.github.com/users/cg31/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cg31/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0e6fa32ff5906558ba772a46b5c2eeaa8abeb3b3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0e6fa32ff5906558ba772a46b5c2eeaa8abeb3b3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0e6fa32ff5906558ba772a46b5c2eeaa8abeb3b3"
      },
      {
        "sha": "cb1716acc720d482707530741848a45ecfc90777",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cb1716acc720d482707530741848a45ecfc90777",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cb1716acc720d482707530741848a45ecfc90777"
      }
    ],
    "stats": {
      "total": 48,
      "additions": 32,
      "deletions": 16
    },
    "files": [
      {
        "sha": "e9816f7d1916dd047e134eebba225d06f71e4432",
        "filename": "contrib/devtools/github-merge.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99cd6459cdb7386f5cbb4a98062234068be5db30/contrib/devtools/github-merge.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99cd6459cdb7386f5cbb4a98062234068be5db30/contrib/devtools/github-merge.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/github-merge.py?ref=99cd6459cdb7386f5cbb4a98062234068be5db30",
        "patch": "@@ -301,8 +301,7 @@ def main():\n                     subprocess.check_call([GIT,'commit','-q','--gpg-sign','--amend','--no-edit'])\n                     break\n                 except subprocess.CalledProcessError as e:\n-                    print(\"Error signing, exiting.\",file=stderr)\n-                    exit(1)\n+                    print(\"Error while signing, asking again.\",file=stderr)\n             elif reply == 'x':\n                 print(\"Not signing off on merge, exiting.\",file=stderr)\n                 exit(1)"
      },
      {
        "sha": "139c03181fc806a9854a3ad307146883df0e47cf",
        "filename": "contrib/seeds/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99cd6459cdb7386f5cbb4a98062234068be5db30/contrib/seeds/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99cd6459cdb7386f5cbb4a98062234068be5db30/contrib/seeds/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/seeds/README.md?ref=99cd6459cdb7386f5cbb4a98062234068be5db30",
        "patch": "@@ -8,7 +8,7 @@ and remove old versions as necessary.\n \n The seeds compiled into the release are created from sipa's DNS seed data, like this:\n \n-    curl -s http://bitcoin.sipa.be/seeds.txt > seeds_main.txt\n+    curl -s http://bitcoin.sipa.be/seeds.txt.gz | gzip -dc > seeds_main.txt\n     python3 makeseeds.py < seeds_main.txt > nodes_main.txt\n     python3 generate-seeds.py . > ../../src/chainparamsseeds.h\n "
      },
      {
        "sha": "5922e45801898460f8600245a61d86f60065a9d8",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 10,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99cd6459cdb7386f5cbb4a98062234068be5db30/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99cd6459cdb7386f5cbb4a98062234068be5db30/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=99cd6459cdb7386f5cbb4a98062234068be5db30",
        "patch": "@@ -117,17 +117,14 @@ bool AppInit(int argc, char* argv[])\n             return false;\n         }\n \n-        // Command-line RPC\n-        bool fCommandLine = false;\n-        for (int i = 1; i < argc; i++)\n-            if (!IsSwitchChar(argv[i][0]) && !boost::algorithm::istarts_with(argv[i], \"bitcoin:\"))\n-                fCommandLine = true;\n-\n-        if (fCommandLine)\n-        {\n-            fprintf(stderr, \"Error: There is no RPC client functionality in bitcoind anymore. Use the bitcoin-cli utility instead.\\n\");\n-            exit(EXIT_FAILURE);\n+        // Error out when loose non-argument tokens are encountered on command line\n+        for (int i = 1; i < argc; i++) {\n+            if (!IsSwitchChar(argv[i][0])) {\n+                fprintf(stderr, \"Error: Command line contains unexpected token '%s', see bitcoind -h for a list of options.\\n\", argv[i]);\n+                exit(EXIT_FAILURE);\n+            }\n         }\n+\n         // -server defaults to true for bitcoind but not for the GUI so do this here\n         SoftSetBoolArg(\"-server\", true);\n         // Set this early so that parameter interactions go to console"
      },
      {
        "sha": "378ac99d6660bb3b7328df869110e6bb637f2e09",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 1,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99cd6459cdb7386f5cbb4a98062234068be5db30/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99cd6459cdb7386f5cbb4a98062234068be5db30/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=99cd6459cdb7386f5cbb4a98062234068be5db30",
        "patch": "@@ -1721,11 +1721,17 @@ void CConnman::ThreadOpenConnections()\n         // Only connect out to one peer per network group (/16 for IPv4).\n         // Do this here so we don't have to critsect vNodes inside mapAddresses critsect.\n         int nOutbound = 0;\n+        int nOutboundRelevant = 0;\n         std::set<std::vector<unsigned char> > setConnected;\n         {\n             LOCK(cs_vNodes);\n             BOOST_FOREACH(CNode* pnode, vNodes) {\n                 if (!pnode->fInbound && !pnode->fAddnode) {\n+\n+                    // Count the peers that have all relevant services\n+                    if (pnode->fSuccessfullyConnected && !pnode->fFeeler && ((pnode->nServices & nRelevantServices) == nRelevantServices)) {\n+                        nOutboundRelevant++;\n+                    }\n                     // Netgroups for inbound and addnode peers are not excluded because our goal here\n                     // is to not use multiple of our limited outbound slots on a single netgroup\n                     // but inbound and addnode peers do not use our outbound slots.  Inbound peers\n@@ -1789,14 +1795,27 @@ void CConnman::ThreadOpenConnections()\n                 continue;\n \n             // only consider nodes missing relevant services after 40 failed attempts and only if less than half the outbound are up.\n-            if ((addr.nServices & nRelevantServices) != nRelevantServices && (nTries < 40 || nOutbound >= (nMaxOutbound >> 1)))\n+            ServiceFlags nRequiredServices = nRelevantServices;\n+            if (nTries >= 40 && nOutbound < (nMaxOutbound >> 1)) {\n+                nRequiredServices = REQUIRED_SERVICES;\n+            }\n+\n+            if ((addr.nServices & nRequiredServices) != nRequiredServices) {\n                 continue;\n+            }\n \n             // do not allow non-default ports, unless after 50 invalid addresses selected already\n             if (addr.GetPort() != Params().GetDefaultPort() && nTries < 50)\n                 continue;\n \n             addrConnect = addr;\n+\n+            // regardless of the services assumed to be available, only require the minimum if half or more outbound have relevant services\n+            if (nOutboundRelevant >= (nMaxOutbound >> 1)) {\n+                addrConnect.nServices = REQUIRED_SERVICES;\n+            } else {\n+                addrConnect.nServices = nRequiredServices;\n+            }\n             break;\n         }\n "
      },
      {
        "sha": "613d5d228a1456a581d2cc70232ad20e208b37d3",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99cd6459cdb7386f5cbb4a98062234068be5db30/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99cd6459cdb7386f5cbb4a98062234068be5db30/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=99cd6459cdb7386f5cbb4a98062234068be5db30",
        "patch": "@@ -357,7 +357,7 @@ UniValue removeprunedfunds(const JSONRPCRequest& request)\n     if (request.fHelp || request.params.size() != 1)\n         throw std::runtime_error(\n             \"removeprunedfunds \\\"txid\\\"\\n\"\n-            \"\\nDeletes the specified transaction from the wallet. Meant for use with pruned wallets and as a companion to importprunedfunds. This will effect wallet balances.\\n\"\n+            \"\\nDeletes the specified transaction from the wallet. Meant for use with pruned wallets and as a companion to importprunedfunds. This will affect wallet balances.\\n\"\n             \"\\nArguments:\\n\"\n             \"1. \\\"txid\\\"           (string, required) The hex-encoded id of the transaction you are deleting\\n\"\n             \"\\nExamples:\\n\""
      },
      {
        "sha": "0860d3565c1a04c8e2d4928c3a2b93c8405b76f1",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99cd6459cdb7386f5cbb4a98062234068be5db30/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99cd6459cdb7386f5cbb4a98062234068be5db30/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=99cd6459cdb7386f5cbb4a98062234068be5db30",
        "patch": "@@ -2909,7 +2909,7 @@ UniValue bumpfee(const JSONRPCRequest& request)\n     UniValue errors(UniValue::VARR);\n     for (const std::string& err: feeBump.getErrors())\n         errors.push_back(err);\n-    result.push_back(errors);\n+    result.push_back(Pair(\"errors\", errors));\n \n     return result;\n }"
      },
      {
        "sha": "aaed4206901318aecf363b5ad6897334ea6e4828",
        "filename": "test/functional/bumpfee.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99cd6459cdb7386f5cbb4a98062234068be5db30/test/functional/bumpfee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99cd6459cdb7386f5cbb4a98062234068be5db30/test/functional/bumpfee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bumpfee.py?ref=99cd6459cdb7386f5cbb4a98062234068be5db30",
        "patch": "@@ -88,6 +88,7 @@ def test_simple_bumpfee_succeeds(rbf_node, peer_node, dest_address):\n     sync_mempools((rbf_node, peer_node))\n     assert rbfid in rbf_node.getrawmempool() and rbfid in peer_node.getrawmempool()\n     bumped_tx = rbf_node.bumpfee(rbfid)\n+    assert_equal(bumped_tx[\"errors\"], [])\n     assert bumped_tx[\"fee\"] - abs(rbftx[\"fee\"]) > 0\n     # check that bumped_tx propogates, original tx was evicted and has a wallet conflict\n     sync_mempools((rbf_node, peer_node))"
      }
    ]
  },
  {
    "sha": "c48bb788672aeb85aa2b83b967c82ce287922d74",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNDhiYjc4ODY3MmFlYjg1YWEyYjgzYjk2N2M4MmNlMjg3OTIyZDc0",
    "commit": {
      "author": {
        "name": "cg",
        "email": "chengang31@gmail.com",
        "date": "2017-06-02T22:42:12Z"
      },
      "committer": {
        "name": "cg",
        "email": "chengang31@gmail.com",
        "date": "2017-06-02T22:42:12Z"
      },
      "message": "Merge remote-tracking branch 'upstream/master'",
      "tree": {
        "sha": "8d4e79691ea3be3c22c20f1ba1bb9a302b772122",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8d4e79691ea3be3c22c20f1ba1bb9a302b772122"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c48bb788672aeb85aa2b83b967c82ce287922d74",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c48bb788672aeb85aa2b83b967c82ce287922d74",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c48bb788672aeb85aa2b83b967c82ce287922d74",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c48bb788672aeb85aa2b83b967c82ce287922d74/comments",
    "author": {
      "login": "cg31",
      "id": 575738,
      "node_id": "MDQ6VXNlcjU3NTczOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/575738?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cg31",
      "html_url": "https://github.com/cg31",
      "followers_url": "https://api.github.com/users/cg31/followers",
      "following_url": "https://api.github.com/users/cg31/following{/other_user}",
      "gists_url": "https://api.github.com/users/cg31/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cg31/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cg31/subscriptions",
      "organizations_url": "https://api.github.com/users/cg31/orgs",
      "repos_url": "https://api.github.com/users/cg31/repos",
      "events_url": "https://api.github.com/users/cg31/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cg31/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "cg31",
      "id": 575738,
      "node_id": "MDQ6VXNlcjU3NTczOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/575738?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cg31",
      "html_url": "https://github.com/cg31",
      "followers_url": "https://api.github.com/users/cg31/followers",
      "following_url": "https://api.github.com/users/cg31/following{/other_user}",
      "gists_url": "https://api.github.com/users/cg31/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cg31/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cg31/subscriptions",
      "organizations_url": "https://api.github.com/users/cg31/orgs",
      "repos_url": "https://api.github.com/users/cg31/repos",
      "events_url": "https://api.github.com/users/cg31/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cg31/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "99cd6459cdb7386f5cbb4a98062234068be5db30",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/99cd6459cdb7386f5cbb4a98062234068be5db30",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/99cd6459cdb7386f5cbb4a98062234068be5db30"
      },
      {
        "sha": "7cc2c670e3d7cf26454ac8547a94ec2c8ca90b34",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7cc2c670e3d7cf26454ac8547a94ec2c8ca90b34",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7cc2c670e3d7cf26454ac8547a94ec2c8ca90b34"
      }
    ],
    "stats": {
      "total": 2188,
      "additions": 1124,
      "deletions": 1064
    },
    "files": [
      {
        "sha": "a9b246536e5bee0f2a011393a49c64d7a4f9e5f5",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -69,7 +69,7 @@ script:\n     - ./configure --cache-file=../config.cache $BITCOIN_CONFIG_ALL $BITCOIN_CONFIG || ( cat config.log && false)\n     - make $MAKEJOBS $GOAL || ( echo \"Build failure. Verbose build follows.\" && make $GOAL V=1 ; false )\n     - export LD_LIBRARY_PATH=$TRAVIS_BUILD_DIR/depends/$HOST/lib\n-    - if [ \"$RUN_TESTS\" = \"true\" ]; then make $MAKEJOBS check VERBOSE=1; fi\n+    - if [ \"$RUN_TESTS\" = \"true\" ]; then travis_wait 30 make $MAKEJOBS check VERBOSE=1; fi\n     - if [ \"$TRAVIS_EVENT_TYPE\" = \"cron\" ]; then extended=\"--extended --exclude pruning\"; fi\n     - if [ \"$RUN_TESTS\" = \"true\" ]; then test/functional/test_runner.py --coverage --quiet ${extended}; fi\n after_script:"
      },
      {
        "sha": "f70e25cb5fdd29e49de2c89b81bd92633e5b93df",
        "filename": "contrib/init/bitcoind.openrcconf",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/contrib/init/bitcoind.openrcconf",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/contrib/init/bitcoind.openrcconf",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/init/bitcoind.openrcconf?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -23,7 +23,7 @@\n #BITCOIND_NICE=0\n \n # Additional options (avoid -conf and -datadir, use flags above)\n-BITCOIND_OPTS=\"-disablewallet\"\n+#BITCOIND_OPTS=\"\"\n \n # The timeout in seconds OpenRC will wait for bitcoind to terminate\n # after a SIGTERM has been raised."
      },
      {
        "sha": "075c7c391104c6c5c70e6113431054f4dbc20201",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -36,6 +36,15 @@ Notable changes\n Low-level RPC changes\n ---------------------\n \n+- The new database model no longer stores information about transaction\n+  versions of unspent outputs. This means that:\n+  - The `gettxout` RPC no longer has a `version` field in the response.\n+  - The `gettxoutsetinfo` RPC reports `hash_serialized_2` instead of `hash_serialized`,\n+    which does not commit to the transaction versions of unspent outputs, but does\n+    commit to the height and coinbase information.\n+  - The `getutxos` REST path no longer reports the `txvers` field in JSON format,\n+    and always reports 0 for transaction versions in the binary format\n+\n - Error codes have been updated to be more accurate for the following error cases:\n   - `getblock` now returns RPC_MISC_ERROR if the block can't be found on disk (for\n   example if the block has been pruned). Previously returned RPC_INTERNAL_ERROR."
      },
      {
        "sha": "5aab3381fd21dd64684306b01b1dfce9861212fd",
        "filename": "src/bench/ccoins_caching.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/bench/ccoins_caching.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/bench/ccoins_caching.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/ccoins_caching.cpp?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -35,14 +35,14 @@ SetupDummyInputs(CBasicKeyStore& keystoreRet, CCoinsViewCache& coinsRet)\n     dummyTransactions[0].vout[0].scriptPubKey << ToByteVector(key[0].GetPubKey()) << OP_CHECKSIG;\n     dummyTransactions[0].vout[1].nValue = 50 * CENT;\n     dummyTransactions[0].vout[1].scriptPubKey << ToByteVector(key[1].GetPubKey()) << OP_CHECKSIG;\n-    coinsRet.ModifyCoins(dummyTransactions[0].GetHash())->FromTx(dummyTransactions[0], 0);\n+    AddCoins(coinsRet, dummyTransactions[0], 0);\n \n     dummyTransactions[1].vout.resize(2);\n     dummyTransactions[1].vout[0].nValue = 21 * CENT;\n     dummyTransactions[1].vout[0].scriptPubKey = GetScriptForDestination(key[2].GetPubKey().GetID());\n     dummyTransactions[1].vout[1].nValue = 22 * CENT;\n     dummyTransactions[1].vout[1].scriptPubKey = GetScriptForDestination(key[3].GetPubKey().GetID());\n-    coinsRet.ModifyCoins(dummyTransactions[1].GetHash())->FromTx(dummyTransactions[1], 0);\n+    AddCoins(coinsRet, dummyTransactions[1], 0);\n \n     return dummyTransactions;\n }"
      },
      {
        "sha": "cf280f485cb93c2634d20747c3133df158139ea1",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 12,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -556,24 +556,26 @@ static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n             if (nOut < 0)\n                 throw std::runtime_error(\"vout must be positive\");\n \n+            COutPoint out(txid, nOut);\n             std::vector<unsigned char> pkData(ParseHexUV(prevOut[\"scriptPubKey\"], \"scriptPubKey\"));\n             CScript scriptPubKey(pkData.begin(), pkData.end());\n \n             {\n-                CCoinsModifier coins = view.ModifyCoins(txid);\n-                if (coins->IsAvailable(nOut) && coins->vout[nOut].scriptPubKey != scriptPubKey) {\n+                const Coin& coin = view.AccessCoin(out);\n+                if (!coin.IsSpent() && coin.out.scriptPubKey != scriptPubKey) {\n                     std::string err(\"Previous output scriptPubKey mismatch:\\n\");\n-                    err = err + ScriptToAsmStr(coins->vout[nOut].scriptPubKey) + \"\\nvs:\\n\"+\n+                    err = err + ScriptToAsmStr(coin.out.scriptPubKey) + \"\\nvs:\\n\"+\n                         ScriptToAsmStr(scriptPubKey);\n                     throw std::runtime_error(err);\n                 }\n-                if ((unsigned int)nOut >= coins->vout.size())\n-                    coins->vout.resize(nOut+1);\n-                coins->vout[nOut].scriptPubKey = scriptPubKey;\n-                coins->vout[nOut].nValue = 0;\n+                Coin newcoin;\n+                newcoin.out.scriptPubKey = scriptPubKey;\n+                newcoin.out.nValue = 0;\n                 if (prevOut.exists(\"amount\")) {\n-                    coins->vout[nOut].nValue = AmountFromValue(prevOut[\"amount\"]);\n+                    newcoin.out.nValue = AmountFromValue(prevOut[\"amount\"]);\n                 }\n+                newcoin.nHeight = 1;\n+                view.AddCoin(out, std::move(newcoin), true);\n             }\n \n             // if redeemScript given and private keys given,\n@@ -595,13 +597,13 @@ static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n     // Sign what we can:\n     for (unsigned int i = 0; i < mergedTx.vin.size(); i++) {\n         CTxIn& txin = mergedTx.vin[i];\n-        const CCoins* coins = view.AccessCoins(txin.prevout.hash);\n-        if (!coins || !coins->IsAvailable(txin.prevout.n)) {\n+        const Coin& coin = view.AccessCoin(txin.prevout);\n+        if (coin.IsSpent()) {\n             fComplete = false;\n             continue;\n         }\n-        const CScript& prevPubKey = coins->vout[txin.prevout.n].scriptPubKey;\n-        const CAmount& amount = coins->vout[txin.prevout.n].nValue;\n+        const CScript& prevPubKey = coin.out.scriptPubKey;\n+        const CAmount& amount = coin.out.nValue;\n \n         SignatureData sigdata;\n         // Only sign SIGHASH_SINGLE if there's a corresponding output:"
      },
      {
        "sha": "5b7c56267839b2e10a5fb5cc11e3fcc31df54960",
        "filename": "src/coins.cpp",
        "status": "modified",
        "additions": 90,
        "deletions": 158,
        "changes": 248,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/coins.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/coins.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.cpp?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -4,174 +4,126 @@\n \n #include \"coins.h\"\n \n+#include \"consensus/consensus.h\"\n #include \"memusage.h\"\n #include \"random.h\"\n \n #include <assert.h>\n \n-/**\n- * calculate number of bytes for the bitmask, and its number of non-zero bytes\n- * each bit in the bitmask represents the availability of one output, but the\n- * availabilities of the first two outputs are encoded separately\n- */\n-void CCoins::CalcMaskSize(unsigned int &nBytes, unsigned int &nNonzeroBytes) const {\n-    unsigned int nLastUsedByte = 0;\n-    for (unsigned int b = 0; 2+b*8 < vout.size(); b++) {\n-        bool fZero = true;\n-        for (unsigned int i = 0; i < 8 && 2+b*8+i < vout.size(); i++) {\n-            if (!vout[2+b*8+i].IsNull()) {\n-                fZero = false;\n-                continue;\n-            }\n-        }\n-        if (!fZero) {\n-            nLastUsedByte = b + 1;\n-            nNonzeroBytes++;\n-        }\n-    }\n-    nBytes += nLastUsedByte;\n-}\n-\n-bool CCoins::Spend(uint32_t nPos) \n-{\n-    if (nPos >= vout.size() || vout[nPos].IsNull())\n-        return false;\n-    vout[nPos].SetNull();\n-    Cleanup();\n-    return true;\n-}\n-\n-bool CCoinsView::GetCoins(const uint256 &txid, CCoins &coins) const { return false; }\n-bool CCoinsView::HaveCoins(const uint256 &txid) const { return false; }\n+bool CCoinsView::GetCoin(const COutPoint &outpoint, Coin &coin) const { return false; }\n+bool CCoinsView::HaveCoin(const COutPoint &outpoint) const { return false; }\n uint256 CCoinsView::GetBestBlock() const { return uint256(); }\n bool CCoinsView::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) { return false; }\n CCoinsViewCursor *CCoinsView::Cursor() const { return 0; }\n \n \n CCoinsViewBacked::CCoinsViewBacked(CCoinsView *viewIn) : base(viewIn) { }\n-bool CCoinsViewBacked::GetCoins(const uint256 &txid, CCoins &coins) const { return base->GetCoins(txid, coins); }\n-bool CCoinsViewBacked::HaveCoins(const uint256 &txid) const { return base->HaveCoins(txid); }\n+bool CCoinsViewBacked::GetCoin(const COutPoint &outpoint, Coin &coin) const { return base->GetCoin(outpoint, coin); }\n+bool CCoinsViewBacked::HaveCoin(const COutPoint &outpoint) const { return base->HaveCoin(outpoint); }\n uint256 CCoinsViewBacked::GetBestBlock() const { return base->GetBestBlock(); }\n void CCoinsViewBacked::SetBackend(CCoinsView &viewIn) { base = &viewIn; }\n bool CCoinsViewBacked::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) { return base->BatchWrite(mapCoins, hashBlock); }\n CCoinsViewCursor *CCoinsViewBacked::Cursor() const { return base->Cursor(); }\n+size_t CCoinsViewBacked::EstimateSize() const { return base->EstimateSize(); }\n \n-SaltedTxidHasher::SaltedTxidHasher() : k0(GetRand(std::numeric_limits<uint64_t>::max())), k1(GetRand(std::numeric_limits<uint64_t>::max())) {}\n+SaltedOutpointHasher::SaltedOutpointHasher() : k0(GetRand(std::numeric_limits<uint64_t>::max())), k1(GetRand(std::numeric_limits<uint64_t>::max())) {}\n \n-CCoinsViewCache::CCoinsViewCache(CCoinsView *baseIn) : CCoinsViewBacked(baseIn), hasModifier(false), cachedCoinsUsage(0) { }\n-\n-CCoinsViewCache::~CCoinsViewCache()\n-{\n-    assert(!hasModifier);\n-}\n+CCoinsViewCache::CCoinsViewCache(CCoinsView *baseIn) : CCoinsViewBacked(baseIn), cachedCoinsUsage(0) {}\n \n size_t CCoinsViewCache::DynamicMemoryUsage() const {\n     return memusage::DynamicUsage(cacheCoins) + cachedCoinsUsage;\n }\n \n-CCoinsMap::const_iterator CCoinsViewCache::FetchCoins(const uint256 &txid) const {\n-    CCoinsMap::iterator it = cacheCoins.find(txid);\n+CCoinsMap::iterator CCoinsViewCache::FetchCoin(const COutPoint &outpoint) const {\n+    CCoinsMap::iterator it = cacheCoins.find(outpoint);\n     if (it != cacheCoins.end())\n         return it;\n-    CCoins tmp;\n-    if (!base->GetCoins(txid, tmp))\n+    Coin tmp;\n+    if (!base->GetCoin(outpoint, tmp))\n         return cacheCoins.end();\n-    CCoinsMap::iterator ret = cacheCoins.insert(std::make_pair(txid, CCoinsCacheEntry())).first;\n-    tmp.swap(ret->second.coins);\n-    if (ret->second.coins.IsPruned()) {\n-        // The parent only has an empty entry for this txid; we can consider our\n+    CCoinsMap::iterator ret = cacheCoins.emplace(std::piecewise_construct, std::forward_as_tuple(outpoint), std::forward_as_tuple(std::move(tmp))).first;\n+    if (ret->second.coin.IsSpent()) {\n+        // The parent only has an empty entry for this outpoint; we can consider our\n         // version as fresh.\n         ret->second.flags = CCoinsCacheEntry::FRESH;\n     }\n-    cachedCoinsUsage += ret->second.coins.DynamicMemoryUsage();\n+    cachedCoinsUsage += ret->second.coin.DynamicMemoryUsage();\n     return ret;\n }\n \n-bool CCoinsViewCache::GetCoins(const uint256 &txid, CCoins &coins) const {\n-    CCoinsMap::const_iterator it = FetchCoins(txid);\n+bool CCoinsViewCache::GetCoin(const COutPoint &outpoint, Coin &coin) const {\n+    CCoinsMap::const_iterator it = FetchCoin(outpoint);\n     if (it != cacheCoins.end()) {\n-        coins = it->second.coins;\n+        coin = it->second.coin;\n         return true;\n     }\n     return false;\n }\n \n-CCoinsModifier CCoinsViewCache::ModifyCoins(const uint256 &txid) {\n-    assert(!hasModifier);\n-    std::pair<CCoinsMap::iterator, bool> ret = cacheCoins.insert(std::make_pair(txid, CCoinsCacheEntry()));\n-    size_t cachedCoinUsage = 0;\n-    if (ret.second) {\n-        if (!base->GetCoins(txid, ret.first->second.coins)) {\n-            // The parent view does not have this entry; mark it as fresh.\n-            ret.first->second.coins.Clear();\n-            ret.first->second.flags = CCoinsCacheEntry::FRESH;\n-        } else if (ret.first->second.coins.IsPruned()) {\n-            // The parent view only has a pruned entry for this; mark it as fresh.\n-            ret.first->second.flags = CCoinsCacheEntry::FRESH;\n+void CCoinsViewCache::AddCoin(const COutPoint &outpoint, Coin&& coin, bool possible_overwrite) {\n+    assert(!coin.IsSpent());\n+    if (coin.out.scriptPubKey.IsUnspendable()) return;\n+    CCoinsMap::iterator it;\n+    bool inserted;\n+    std::tie(it, inserted) = cacheCoins.emplace(std::piecewise_construct, std::forward_as_tuple(outpoint), std::tuple<>());\n+    bool fresh = false;\n+    if (!inserted) {\n+        cachedCoinsUsage -= it->second.coin.DynamicMemoryUsage();\n+    }\n+    if (!possible_overwrite) {\n+        if (!it->second.coin.IsSpent()) {\n+            throw std::logic_error(\"Adding new coin that replaces non-pruned entry\");\n         }\n-    } else {\n-        cachedCoinUsage = ret.first->second.coins.DynamicMemoryUsage();\n+        fresh = !(it->second.flags & CCoinsCacheEntry::DIRTY);\n+    }\n+    it->second.coin = std::move(coin);\n+    it->second.flags |= CCoinsCacheEntry::DIRTY | (fresh ? CCoinsCacheEntry::FRESH : 0);\n+    cachedCoinsUsage += it->second.coin.DynamicMemoryUsage();\n+}\n+\n+void AddCoins(CCoinsViewCache& cache, const CTransaction &tx, int nHeight) {\n+    bool fCoinbase = tx.IsCoinBase();\n+    const uint256& txid = tx.GetHash();\n+    for (size_t i = 0; i < tx.vout.size(); ++i) {\n+        // Pass fCoinbase as the possible_overwrite flag to AddCoin, in order to correctly\n+        // deal with the pre-BIP30 occurrances of duplicate coinbase transactions.\n+        cache.AddCoin(COutPoint(txid, i), Coin(tx.vout[i], nHeight, fCoinbase), fCoinbase);\n     }\n-    // Assume that whenever ModifyCoins is called, the entry will be modified.\n-    ret.first->second.flags |= CCoinsCacheEntry::DIRTY;\n-    return CCoinsModifier(*this, ret.first, cachedCoinUsage);\n }\n \n-/* ModifyNewCoins allows for faster coin modification when creating the new\n- * outputs from a transaction.  It assumes that BIP 30 (no duplicate txids)\n- * applies and has already been tested for (or the test is not required due to\n- * BIP 34, height in coinbase).  If we can assume BIP 30 then we know that any\n- * non-coinbase transaction we are adding to the UTXO must not already exist in\n- * the utxo unless it is fully spent.  Thus we can check only if it exists DIRTY\n- * at the current level of the cache, in which case it is not safe to mark it\n- * FRESH (b/c then its spentness still needs to flushed).  If it's not dirty and\n- * doesn't exist or is pruned in the current cache, we know it either doesn't\n- * exist or is pruned in parent caches, which is the definition of FRESH.  The\n- * exception to this is the two historical violations of BIP 30 in the chain,\n- * both of which were coinbases.  We do not mark these fresh so we we can ensure\n- * that they will still be properly overwritten when spent.\n- */\n-CCoinsModifier CCoinsViewCache::ModifyNewCoins(const uint256 &txid, bool coinbase) {\n-    assert(!hasModifier);\n-    std::pair<CCoinsMap::iterator, bool> ret = cacheCoins.insert(std::make_pair(txid, CCoinsCacheEntry()));\n-    if (!coinbase) {\n-        // New coins must not already exist.\n-        if (!ret.first->second.coins.IsPruned())\n-            throw std::logic_error(\"ModifyNewCoins should not find pre-existing coins on a non-coinbase unless they are pruned!\");\n-\n-        if (!(ret.first->second.flags & CCoinsCacheEntry::DIRTY)) {\n-            // If the coin is known to be pruned (have no unspent outputs) in\n-            // the current view and the cache entry is not dirty, we know the\n-            // coin also must be pruned in the parent view as well, so it is safe\n-            // to mark this fresh.\n-            ret.first->second.flags |= CCoinsCacheEntry::FRESH;\n-        }\n+void CCoinsViewCache::SpendCoin(const COutPoint &outpoint, Coin* moveout) {\n+    CCoinsMap::iterator it = FetchCoin(outpoint);\n+    if (it == cacheCoins.end()) return;\n+    cachedCoinsUsage -= it->second.coin.DynamicMemoryUsage();\n+    if (moveout) {\n+        *moveout = std::move(it->second.coin);\n+    }\n+    if (it->second.flags & CCoinsCacheEntry::FRESH) {\n+        cacheCoins.erase(it);\n+    } else {\n+        it->second.flags |= CCoinsCacheEntry::DIRTY;\n+        it->second.coin.Clear();\n     }\n-    ret.first->second.coins.Clear();\n-    ret.first->second.flags |= CCoinsCacheEntry::DIRTY;\n-    return CCoinsModifier(*this, ret.first, 0);\n }\n \n-const CCoins* CCoinsViewCache::AccessCoins(const uint256 &txid) const {\n-    CCoinsMap::const_iterator it = FetchCoins(txid);\n+static const Coin coinEmpty;\n+\n+const Coin& CCoinsViewCache::AccessCoin(const COutPoint &outpoint) const {\n+    CCoinsMap::const_iterator it = FetchCoin(outpoint);\n     if (it == cacheCoins.end()) {\n-        return NULL;\n+        return coinEmpty;\n     } else {\n-        return &it->second.coins;\n+        return it->second.coin;\n     }\n }\n \n-bool CCoinsViewCache::HaveCoins(const uint256 &txid) const {\n-    CCoinsMap::const_iterator it = FetchCoins(txid);\n-    // We're using vtx.empty() instead of IsPruned here for performance reasons,\n-    // as we only care about the case where a transaction was replaced entirely\n-    // in a reorganization (which wipes vout entirely, as opposed to spending\n-    // which just cleans individual outputs).\n-    return (it != cacheCoins.end() && !it->second.coins.vout.empty());\n+bool CCoinsViewCache::HaveCoin(const COutPoint &outpoint) const {\n+    CCoinsMap::const_iterator it = FetchCoin(outpoint);\n+    return (it != cacheCoins.end() && !it->second.coin.IsSpent());\n }\n \n-bool CCoinsViewCache::HaveCoinsInCache(const uint256 &txid) const {\n-    CCoinsMap::const_iterator it = cacheCoins.find(txid);\n+bool CCoinsViewCache::HaveCoinInCache(const COutPoint &outpoint) const {\n+    CCoinsMap::const_iterator it = cacheCoins.find(outpoint);\n     return it != cacheCoins.end();\n }\n \n@@ -186,19 +138,18 @@ void CCoinsViewCache::SetBestBlock(const uint256 &hashBlockIn) {\n }\n \n bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn) {\n-    assert(!hasModifier);\n     for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end();) {\n         if (it->second.flags & CCoinsCacheEntry::DIRTY) { // Ignore non-dirty entries (optimization).\n             CCoinsMap::iterator itUs = cacheCoins.find(it->first);\n             if (itUs == cacheCoins.end()) {\n                 // The parent cache does not have an entry, while the child does\n                 // We can ignore it if it's both FRESH and pruned in the child\n-                if (!(it->second.flags & CCoinsCacheEntry::FRESH && it->second.coins.IsPruned())) {\n+                if (!(it->second.flags & CCoinsCacheEntry::FRESH && it->second.coin.IsSpent())) {\n                     // Otherwise we will need to create it in the parent\n                     // and move the data up and mark it as dirty\n                     CCoinsCacheEntry& entry = cacheCoins[it->first];\n-                    entry.coins.swap(it->second.coins);\n-                    cachedCoinsUsage += entry.coins.DynamicMemoryUsage();\n+                    entry.coin = std::move(it->second.coin);\n+                    cachedCoinsUsage += entry.coin.DynamicMemoryUsage();\n                     entry.flags = CCoinsCacheEntry::DIRTY;\n                     // We can mark it FRESH in the parent if it was FRESH in the child\n                     // Otherwise it might have just been flushed from the parent's cache\n@@ -211,21 +162,21 @@ bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn\n                 // parent cache entry has unspent outputs. If this ever happens,\n                 // it means the FRESH flag was misapplied and there is a logic\n                 // error in the calling code.\n-                if ((it->second.flags & CCoinsCacheEntry::FRESH) && !itUs->second.coins.IsPruned())\n+                if ((it->second.flags & CCoinsCacheEntry::FRESH) && !itUs->second.coin.IsSpent())\n                     throw std::logic_error(\"FRESH flag misapplied to cache entry for base transaction with spendable outputs\");\n \n                 // Found the entry in the parent cache\n-                if ((itUs->second.flags & CCoinsCacheEntry::FRESH) && it->second.coins.IsPruned()) {\n+                if ((itUs->second.flags & CCoinsCacheEntry::FRESH) && it->second.coin.IsSpent()) {\n                     // The grandparent does not have an entry, and the child is\n                     // modified and being pruned. This means we can just delete\n                     // it from the parent.\n-                    cachedCoinsUsage -= itUs->second.coins.DynamicMemoryUsage();\n+                    cachedCoinsUsage -= itUs->second.coin.DynamicMemoryUsage();\n                     cacheCoins.erase(itUs);\n                 } else {\n                     // A normal modification.\n-                    cachedCoinsUsage -= itUs->second.coins.DynamicMemoryUsage();\n-                    itUs->second.coins.swap(it->second.coins);\n-                    cachedCoinsUsage += itUs->second.coins.DynamicMemoryUsage();\n+                    cachedCoinsUsage -= itUs->second.coin.DynamicMemoryUsage();\n+                    itUs->second.coin = std::move(it->second.coin);\n+                    cachedCoinsUsage += itUs->second.coin.DynamicMemoryUsage();\n                     itUs->second.flags |= CCoinsCacheEntry::DIRTY;\n                     // NOTE: It is possible the child has a FRESH flag here in\n                     // the event the entry we found in the parent is pruned. But\n@@ -249,11 +200,11 @@ bool CCoinsViewCache::Flush() {\n     return fOk;\n }\n \n-void CCoinsViewCache::Uncache(const uint256& hash)\n+void CCoinsViewCache::Uncache(const COutPoint& hash)\n {\n     CCoinsMap::iterator it = cacheCoins.find(hash);\n     if (it != cacheCoins.end() && it->second.flags == 0) {\n-        cachedCoinsUsage -= it->second.coins.DynamicMemoryUsage();\n+        cachedCoinsUsage -= it->second.coin.DynamicMemoryUsage();\n         cacheCoins.erase(it);\n     }\n }\n@@ -262,21 +213,14 @@ unsigned int CCoinsViewCache::GetCacheSize() const {\n     return cacheCoins.size();\n }\n \n-const CTxOut &CCoinsViewCache::GetOutputFor(const CTxIn& input) const\n-{\n-    const CCoins* coins = AccessCoins(input.prevout.hash);\n-    assert(coins && coins->IsAvailable(input.prevout.n));\n-    return coins->vout[input.prevout.n];\n-}\n-\n CAmount CCoinsViewCache::GetValueIn(const CTransaction& tx) const\n {\n     if (tx.IsCoinBase())\n         return 0;\n \n     CAmount nResult = 0;\n     for (unsigned int i = 0; i < tx.vin.size(); i++)\n-        nResult += GetOutputFor(tx.vin[i]).nValue;\n+        nResult += AccessCoin(tx.vin[i].prevout).out.nValue;\n \n     return nResult;\n }\n@@ -285,35 +229,23 @@ bool CCoinsViewCache::HaveInputs(const CTransaction& tx) const\n {\n     if (!tx.IsCoinBase()) {\n         for (unsigned int i = 0; i < tx.vin.size(); i++) {\n-            const COutPoint &prevout = tx.vin[i].prevout;\n-            const CCoins* coins = AccessCoins(prevout.hash);\n-            if (!coins || !coins->IsAvailable(prevout.n)) {\n+            if (!HaveCoin(tx.vin[i].prevout)) {\n                 return false;\n             }\n         }\n     }\n     return true;\n }\n \n-CCoinsModifier::CCoinsModifier(CCoinsViewCache& cache_, CCoinsMap::iterator it_, size_t usage) : cache(cache_), it(it_), cachedCoinUsage(usage) {\n-    assert(!cache.hasModifier);\n-    cache.hasModifier = true;\n-}\n+static const size_t MAX_OUTPUTS_PER_BLOCK = MAX_BLOCK_BASE_SIZE /  ::GetSerializeSize(CTxOut(), SER_NETWORK, PROTOCOL_VERSION); // TODO: merge with similar definition in undo.h.\n \n-CCoinsModifier::~CCoinsModifier()\n+const Coin& AccessByTxid(const CCoinsViewCache& view, const uint256& txid)\n {\n-    assert(cache.hasModifier);\n-    cache.hasModifier = false;\n-    it->second.coins.Cleanup();\n-    cache.cachedCoinsUsage -= cachedCoinUsage; // Subtract the old usage\n-    if ((it->second.flags & CCoinsCacheEntry::FRESH) && it->second.coins.IsPruned()) {\n-        cache.cacheCoins.erase(it);\n-    } else {\n-        // If the coin still exists after the modification, add the new usage\n-        cache.cachedCoinsUsage += it->second.coins.DynamicMemoryUsage();\n+    COutPoint iter(txid, 0);\n+    while (iter.n < MAX_OUTPUTS_PER_BLOCK) {\n+        const Coin& alternate = view.AccessCoin(iter);\n+        if (!alternate.IsSpent()) return alternate;\n+        ++iter.n;\n     }\n-}\n-\n-CCoinsViewCursor::~CCoinsViewCursor()\n-{\n+    return coinEmpty;\n }"
      },
      {
        "sha": "476db8f37c73b14cbb42adb58488a726e332093a",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 83,
        "deletions": 266,
        "changes": 349,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -20,251 +20,90 @@\n #include <boost/foreach.hpp>\n #include <unordered_map>\n \n-/** \n- * Pruned version of CTransaction: only retains metadata and unspent transaction outputs\n+/**\n+ * A UTXO entry.\n  *\n  * Serialized format:\n- * - VARINT(nVersion)\n- * - VARINT(nCode)\n- * - unspentness bitvector, for vout[2] and further; least significant byte first\n- * - the non-spent CTxOuts (via CTxOutCompressor)\n- * - VARINT(nHeight)\n- *\n- * The nCode value consists of:\n- * - bit 0: IsCoinBase()\n- * - bit 1: vout[0] is not spent\n- * - bit 2: vout[1] is not spent\n- * - The higher bits encode N, the number of non-zero bytes in the following bitvector.\n- *   - In case both bit 1 and bit 2 are unset, they encode N-1, as there must be at\n- *     least one non-spent output).\n- *\n- * Example: 0104835800816115944e077fe7c803cfa57f29b36bf87c1d358bb85e\n- *          <><><--------------------------------------------><---->\n- *          |  \\                  |                             /\n- *    version   code             vout[1]                  height\n- *\n- *    - version = 1\n- *    - code = 4 (vout[1] is not spent, and 0 non-zero bytes of bitvector follow)\n- *    - unspentness bitvector: as 0 non-zero bytes follow, it has length 0\n- *    - vout[1]: 835800816115944e077fe7c803cfa57f29b36bf87c1d35\n- *               * 8358: compact amount representation for 60000000000 (600 BTC)\n- *               * 00: special txout type pay-to-pubkey-hash\n- *               * 816115944e077fe7c803cfa57f29b36bf87c1d35: address uint160\n- *    - height = 203998\n- *\n- *\n- * Example: 0109044086ef97d5790061b01caab50f1b8e9c50a5057eb43c2d9563a4eebbd123008c988f1a4a4de2161e0f50aac7f17e7f9555caa486af3b\n- *          <><><--><--------------------------------------------------><----------------------------------------------><---->\n- *         /  \\   \\                     |                                                           |                     /\n- *  version  code  unspentness       vout[4]                                                     vout[16]           height\n- *\n- *  - version = 1\n- *  - code = 9 (coinbase, neither vout[0] or vout[1] are unspent,\n- *                2 (1, +1 because both bit 1 and bit 2 are unset) non-zero bitvector bytes follow)\n- *  - unspentness bitvector: bits 2 (0x04) and 14 (0x4000) are set, so vout[2+2] and vout[14+2] are unspent\n- *  - vout[4]: 86ef97d5790061b01caab50f1b8e9c50a5057eb43c2d9563a4ee\n- *             * 86ef97d579: compact amount representation for 234925952 (2.35 BTC)\n- *             * 00: special txout type pay-to-pubkey-hash\n- *             * 61b01caab50f1b8e9c50a5057eb43c2d9563a4ee: address uint160\n- *  - vout[16]: bbd123008c988f1a4a4de2161e0f50aac7f17e7f9555caa4\n- *              * bbd123: compact amount representation for 110397 (0.001 BTC)\n- *              * 00: special txout type pay-to-pubkey-hash\n- *              * 8c988f1a4a4de2161e0f50aac7f17e7f9555caa4: address uint160\n- *  - height = 120891\n+ * - VARINT((coinbase ? 1 : 0) | (height << 1))\n+ * - the non-spent CTxOut (via CTxOutCompressor)\n  */\n-class CCoins\n+class Coin\n {\n public:\n-    //! whether transaction is a coinbase\n-    bool fCoinBase;\n-\n-    //! unspent transaction outputs; spent outputs are .IsNull(); spent outputs at the end of the array are dropped\n-    std::vector<CTxOut> vout;\n+    //! unspent transaction output\n+    CTxOut out;\n \n-    //! at which height this transaction was included in the active block chain\n-    int nHeight;\n+    //! whether containing transaction was a coinbase\n+    unsigned int fCoinBase : 1;\n \n-    //! version of the CTransaction; accesses to this value should probably check for nHeight as well,\n-    //! as new tx version will probably only be introduced at certain heights\n-    int nVersion;\n+    //! at which height this containing transaction was included in the active block chain\n+    uint32_t nHeight : 31;\n \n-    void FromTx(const CTransaction &tx, int nHeightIn) {\n-        fCoinBase = tx.IsCoinBase();\n-        vout = tx.vout;\n-        nHeight = nHeightIn;\n-        nVersion = tx.nVersion;\n-        ClearUnspendable();\n-    }\n-\n-    //! construct a CCoins from a CTransaction, at a given height\n-    CCoins(const CTransaction &tx, int nHeightIn) {\n-        FromTx(tx, nHeightIn);\n-    }\n+    //! construct a Coin from a CTxOut and height/coinbase information.\n+    Coin(CTxOut&& outIn, int nHeightIn, bool fCoinBaseIn) : out(std::move(outIn)), fCoinBase(fCoinBaseIn), nHeight(nHeightIn) {}\n+    Coin(const CTxOut& outIn, int nHeightIn, bool fCoinBaseIn) : out(outIn), fCoinBase(fCoinBaseIn),nHeight(nHeightIn) {}\n \n     void Clear() {\n+        out.SetNull();\n         fCoinBase = false;\n-        std::vector<CTxOut>().swap(vout);\n         nHeight = 0;\n-        nVersion = 0;\n     }\n \n     //! empty constructor\n-    CCoins() : fCoinBase(false), vout(0), nHeight(0), nVersion(0) { }\n-\n-    //!remove spent outputs at the end of vout\n-    void Cleanup() {\n-        while (vout.size() > 0 && vout.back().IsNull())\n-            vout.pop_back();\n-        if (vout.empty())\n-            std::vector<CTxOut>().swap(vout);\n-    }\n-\n-    void ClearUnspendable() {\n-        BOOST_FOREACH(CTxOut &txout, vout) {\n-            if (txout.scriptPubKey.IsUnspendable())\n-                txout.SetNull();\n-        }\n-        Cleanup();\n-    }\n-\n-    void swap(CCoins &to) {\n-        std::swap(to.fCoinBase, fCoinBase);\n-        to.vout.swap(vout);\n-        std::swap(to.nHeight, nHeight);\n-        std::swap(to.nVersion, nVersion);\n-    }\n-\n-    //! equality test\n-    friend bool operator==(const CCoins &a, const CCoins &b) {\n-         // Empty CCoins objects are always equal.\n-         if (a.IsPruned() && b.IsPruned())\n-             return true;\n-         return a.fCoinBase == b.fCoinBase &&\n-                a.nHeight == b.nHeight &&\n-                a.nVersion == b.nVersion &&\n-                a.vout == b.vout;\n-    }\n-    friend bool operator!=(const CCoins &a, const CCoins &b) {\n-        return !(a == b);\n-    }\n-\n-    void CalcMaskSize(unsigned int &nBytes, unsigned int &nNonzeroBytes) const;\n+    Coin() : fCoinBase(false), nHeight(0) { }\n \n     bool IsCoinBase() const {\n         return fCoinBase;\n     }\n \n     template<typename Stream>\n     void Serialize(Stream &s) const {\n-        unsigned int nMaskSize = 0, nMaskCode = 0;\n-        CalcMaskSize(nMaskSize, nMaskCode);\n-        bool fFirst = vout.size() > 0 && !vout[0].IsNull();\n-        bool fSecond = vout.size() > 1 && !vout[1].IsNull();\n-        assert(fFirst || fSecond || nMaskCode);\n-        unsigned int nCode = 8*(nMaskCode - (fFirst || fSecond ? 0 : 1)) + (fCoinBase ? 1 : 0) + (fFirst ? 2 : 0) + (fSecond ? 4 : 0);\n-        // version\n-        ::Serialize(s, VARINT(this->nVersion));\n-        // header code\n-        ::Serialize(s, VARINT(nCode));\n-        // spentness bitmask\n-        for (unsigned int b = 0; b<nMaskSize; b++) {\n-            unsigned char chAvail = 0;\n-            for (unsigned int i = 0; i < 8 && 2+b*8+i < vout.size(); i++)\n-                if (!vout[2+b*8+i].IsNull())\n-                    chAvail |= (1 << i);\n-            ::Serialize(s, chAvail);\n-        }\n-        // txouts themself\n-        for (unsigned int i = 0; i < vout.size(); i++) {\n-            if (!vout[i].IsNull())\n-                ::Serialize(s, CTxOutCompressor(REF(vout[i])));\n-        }\n-        // coinbase height\n-        ::Serialize(s, VARINT(nHeight));\n+        assert(!IsSpent());\n+        uint32_t code = nHeight * 2 + fCoinBase;\n+        ::Serialize(s, VARINT(code));\n+        ::Serialize(s, CTxOutCompressor(REF(out)));\n     }\n \n     template<typename Stream>\n     void Unserialize(Stream &s) {\n-        unsigned int nCode = 0;\n-        // version\n-        ::Unserialize(s, VARINT(this->nVersion));\n-        // header code\n-        ::Unserialize(s, VARINT(nCode));\n-        fCoinBase = nCode & 1;\n-        std::vector<bool> vAvail(2, false);\n-        vAvail[0] = (nCode & 2) != 0;\n-        vAvail[1] = (nCode & 4) != 0;\n-        unsigned int nMaskCode = (nCode / 8) + ((nCode & 6) != 0 ? 0 : 1);\n-        // spentness bitmask\n-        while (nMaskCode > 0) {\n-            unsigned char chAvail = 0;\n-            ::Unserialize(s, chAvail);\n-            for (unsigned int p = 0; p < 8; p++) {\n-                bool f = (chAvail & (1 << p)) != 0;\n-                vAvail.push_back(f);\n-            }\n-            if (chAvail != 0)\n-                nMaskCode--;\n-        }\n-        // txouts themself\n-        vout.assign(vAvail.size(), CTxOut());\n-        for (unsigned int i = 0; i < vAvail.size(); i++) {\n-            if (vAvail[i])\n-                ::Unserialize(s, REF(CTxOutCompressor(vout[i])));\n-        }\n-        // coinbase height\n-        ::Unserialize(s, VARINT(nHeight));\n-        Cleanup();\n+        uint32_t code = 0;\n+        ::Unserialize(s, VARINT(code));\n+        nHeight = code >> 1;\n+        fCoinBase = code & 1;\n+        ::Unserialize(s, REF(CTxOutCompressor(out)));\n     }\n \n-    //! mark a vout spent\n-    bool Spend(uint32_t nPos);\n-\n-    //! check whether a particular output is still available\n-    bool IsAvailable(unsigned int nPos) const {\n-        return (nPos < vout.size() && !vout[nPos].IsNull());\n-    }\n-\n-    //! check whether the entire CCoins is spent\n-    //! note that only !IsPruned() CCoins can be serialized\n-    bool IsPruned() const {\n-        BOOST_FOREACH(const CTxOut &out, vout)\n-            if (!out.IsNull())\n-                return false;\n-        return true;\n+    bool IsSpent() const {\n+        return out.IsNull();\n     }\n \n     size_t DynamicMemoryUsage() const {\n-        size_t ret = memusage::DynamicUsage(vout);\n-        BOOST_FOREACH(const CTxOut &out, vout) {\n-            ret += RecursiveDynamicUsage(out.scriptPubKey);\n-        }\n-        return ret;\n+        return memusage::DynamicUsage(out.scriptPubKey);\n     }\n };\n \n-class SaltedTxidHasher\n+class SaltedOutpointHasher\n {\n private:\n     /** Salt */\n     const uint64_t k0, k1;\n \n public:\n-    SaltedTxidHasher();\n+    SaltedOutpointHasher();\n \n     /**\n      * This *must* return size_t. With Boost 1.46 on 32-bit systems the\n      * unordered_map will behave unpredictably if the custom hasher returns a\n      * uint64_t, resulting in failures when syncing the chain (#4634).\n      */\n-    size_t operator()(const uint256& txid) const {\n-        return SipHashUint256(k0, k1, txid);\n+    size_t operator()(const COutPoint& id) const {\n+        return SipHashUint256Extra(k0, k1, id.hash, id.n);\n     }\n };\n \n struct CCoinsCacheEntry\n {\n-    CCoins coins; // The actual cached data.\n+    Coin coin; // The actual cached data.\n     unsigned char flags;\n \n     enum Flags {\n@@ -277,20 +116,21 @@ struct CCoinsCacheEntry\n          */\n     };\n \n-    CCoinsCacheEntry() : coins(), flags(0) {}\n+    CCoinsCacheEntry() : flags(0) {}\n+    explicit CCoinsCacheEntry(Coin&& coin_) : coin(std::move(coin_)), flags(0) {}\n };\n \n-typedef std::unordered_map<uint256, CCoinsCacheEntry, SaltedTxidHasher> CCoinsMap;\n+typedef std::unordered_map<COutPoint, CCoinsCacheEntry, SaltedOutpointHasher> CCoinsMap;\n \n /** Cursor for iterating over CoinsView state */\n class CCoinsViewCursor\n {\n public:\n     CCoinsViewCursor(const uint256 &hashBlockIn): hashBlock(hashBlockIn) {}\n-    virtual ~CCoinsViewCursor();\n+    virtual ~CCoinsViewCursor() {}\n \n-    virtual bool GetKey(uint256 &key) const = 0;\n-    virtual bool GetValue(CCoins &coins) const = 0;\n+    virtual bool GetKey(COutPoint &key) const = 0;\n+    virtual bool GetValue(Coin &coin) const = 0;\n     virtual unsigned int GetValueSize() const = 0;\n \n     virtual bool Valid() const = 0;\n@@ -306,17 +146,17 @@ class CCoinsViewCursor\n class CCoinsView\n {\n public:\n-    //! Retrieve the CCoins (unspent transaction outputs) for a given txid\n-    virtual bool GetCoins(const uint256 &txid, CCoins &coins) const;\n+    //! Retrieve the Coin (unspent transaction output) for a given outpoint.\n+    virtual bool GetCoin(const COutPoint &outpoint, Coin &coin) const;\n \n-    //! Just check whether we have data for a given txid.\n-    //! This may (but cannot always) return true for fully spent transactions\n-    virtual bool HaveCoins(const uint256 &txid) const;\n+    //! Just check whether we have data for a given outpoint.\n+    //! This may (but cannot always) return true for spent outputs.\n+    virtual bool HaveCoin(const COutPoint &outpoint) const;\n \n     //! Retrieve the block hash whose state this CCoinsView currently represents\n     virtual uint256 GetBestBlock() const;\n \n-    //! Do a bulk modification (multiple CCoins changes + BestBlock change).\n+    //! Do a bulk modification (multiple Coin changes + BestBlock change).\n     //! The passed mapCoins can be modified.\n     virtual bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock);\n \n@@ -325,6 +165,9 @@ class CCoinsView\n \n     //! As we use CCoinsViews polymorphically, have a virtual destructor\n     virtual ~CCoinsView() {}\n+\n+    //! Estimate database size (0 if not implemented)\n+    virtual size_t EstimateSize() const { return 0; }\n };\n \n \n@@ -336,97 +179,66 @@ class CCoinsViewBacked : public CCoinsView\n \n public:\n     CCoinsViewBacked(CCoinsView *viewIn);\n-    bool GetCoins(const uint256 &txid, CCoins &coins) const;\n-    bool HaveCoins(const uint256 &txid) const;\n-    uint256 GetBestBlock() const;\n+    bool GetCoin(const COutPoint &outpoint, Coin &coin) const override;\n+    bool HaveCoin(const COutPoint &outpoint) const override;\n+    uint256 GetBestBlock() const override;\n     void SetBackend(CCoinsView &viewIn);\n-    bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock);\n-    CCoinsViewCursor *Cursor() const;\n+    bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) override;\n+    CCoinsViewCursor *Cursor() const override;\n+    size_t EstimateSize() const override;\n };\n \n \n-class CCoinsViewCache;\n-\n-/** \n- * A reference to a mutable cache entry. Encapsulating it allows us to run\n- *  cleanup code after the modification is finished, and keeping track of\n- *  concurrent modifications. \n- */\n-class CCoinsModifier\n-{\n-private:\n-    CCoinsViewCache& cache;\n-    CCoinsMap::iterator it;\n-    size_t cachedCoinUsage; // Cached memory usage of the CCoins object before modification\n-    CCoinsModifier(CCoinsViewCache& cache_, CCoinsMap::iterator it_, size_t usage);\n-\n-public:\n-    CCoins* operator->() { return &it->second.coins; }\n-    CCoins& operator*() { return it->second.coins; }\n-    ~CCoinsModifier();\n-    friend class CCoinsViewCache;\n-};\n-\n /** CCoinsView that adds a memory cache for transactions to another CCoinsView */\n class CCoinsViewCache : public CCoinsViewBacked\n {\n protected:\n-    /* Whether this cache has an active modifier. */\n-    bool hasModifier;\n-\n-\n     /**\n      * Make mutable so that we can \"fill the cache\" even from Get-methods\n      * declared as \"const\".  \n      */\n     mutable uint256 hashBlock;\n     mutable CCoinsMap cacheCoins;\n \n-    /* Cached dynamic memory usage for the inner CCoins objects. */\n+    /* Cached dynamic memory usage for the inner Coin objects. */\n     mutable size_t cachedCoinsUsage;\n \n public:\n     CCoinsViewCache(CCoinsView *baseIn);\n-    ~CCoinsViewCache();\n \n     // Standard CCoinsView methods\n-    bool GetCoins(const uint256 &txid, CCoins &coins) const;\n-    bool HaveCoins(const uint256 &txid) const;\n+    bool GetCoin(const COutPoint &outpoint, Coin &coin) const;\n+    bool HaveCoin(const COutPoint &outpoint) const;\n     uint256 GetBestBlock() const;\n     void SetBestBlock(const uint256 &hashBlock);\n     bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock);\n \n     /**\n-     * Check if we have the given tx already loaded in this cache.\n-     * The semantics are the same as HaveCoins(), but no calls to\n+     * Check if we have the given utxo already loaded in this cache.\n+     * The semantics are the same as HaveCoin(), but no calls to\n      * the backing CCoinsView are made.\n      */\n-    bool HaveCoinsInCache(const uint256 &txid) const;\n+    bool HaveCoinInCache(const COutPoint &outpoint) const;\n \n     /**\n-     * Return a pointer to CCoins in the cache, or NULL if not found. This is\n-     * more efficient than GetCoins. Modifications to other cache entries are\n+     * Return a reference to Coin in the cache, or a pruned one if not found. This is\n+     * more efficient than GetCoin. Modifications to other cache entries are\n      * allowed while accessing the returned pointer.\n      */\n-    const CCoins* AccessCoins(const uint256 &txid) const;\n+    const Coin& AccessCoin(const COutPoint &output) const;\n \n     /**\n-     * Return a modifiable reference to a CCoins. If no entry with the given\n-     * txid exists, a new one is created. Simultaneous modifications are not\n-     * allowed.\n+     * Add a coin. Set potential_overwrite to true if a non-pruned version may\n+     * already exist.\n      */\n-    CCoinsModifier ModifyCoins(const uint256 &txid);\n+    void AddCoin(const COutPoint& outpoint, Coin&& coin, bool potential_overwrite);\n \n     /**\n-     * Return a modifiable reference to a CCoins. Assumes that no entry with the given\n-     * txid exists and creates a new one. This saves a database access in the case where\n-     * the coins were to be wiped out by FromTx anyway.  This should not be called with\n-     * the 2 historical coinbase duplicate pairs because the new coins are marked fresh, and\n-     * in the event the duplicate coinbase was spent before a flush, the now pruned coins\n-     * would not properly overwrite the first coinbase of the pair. Simultaneous modifications\n-     * are not allowed.\n+     * Spend a coin. Pass moveto in order to get the deleted data.\n+     * If no unspent output exists for the passed outpoint, this call\n+     * has no effect.\n      */\n-    CCoinsModifier ModifyNewCoins(const uint256 &txid, bool coinbase);\n+    void SpendCoin(const COutPoint &outpoint, Coin* moveto = nullptr);\n \n     /**\n      * Push the modifications applied to this cache to its base.\n@@ -436,12 +248,12 @@ class CCoinsViewCache : public CCoinsViewBacked\n     bool Flush();\n \n     /**\n-     * Removes the transaction with the given hash from the cache, if it is\n+     * Removes the UTXO with the given outpoint from the cache, if it is\n      * not modified.\n      */\n-    void Uncache(const uint256 &txid);\n+    void Uncache(const COutPoint &outpoint);\n \n-    //! Calculate the size of the cache (in number of transactions)\n+    //! Calculate the size of the cache (in number of transaction outputs)\n     unsigned int GetCacheSize() const;\n \n     //! Calculate the size of the cache (in bytes)\n@@ -460,17 +272,22 @@ class CCoinsViewCache : public CCoinsViewBacked\n     //! Check whether all prevouts of the transaction are present in the UTXO set represented by this view\n     bool HaveInputs(const CTransaction& tx) const;\n \n-    const CTxOut &GetOutputFor(const CTxIn& input) const;\n-\n-    friend class CCoinsModifier;\n-\n private:\n-    CCoinsMap::const_iterator FetchCoins(const uint256 &txid) const;\n+    CCoinsMap::iterator FetchCoin(const COutPoint &outpoint) const;\n \n     /**\n      * By making the copy constructor private, we prevent accidentally using it when one intends to create a cache on top of a base cache.\n      */\n     CCoinsViewCache(const CCoinsViewCache &);\n };\n \n+//! Utility function to add all of a transaction's outputs to a cache.\n+// It assumes that overwrites are only possible for coinbase transactions,\n+// TODO: pass in a boolean to limit these possible overwrites to known\n+// (pre-BIP34) cases.\n+void AddCoins(CCoinsViewCache& cache, const CTransaction& tx, int nHeight);\n+\n+//! Utility function to find any unspent output with a given txid.\n+const Coin& AccessByTxid(const CCoinsViewCache& cache, const uint256& txid);\n+\n #endif // BITCOIN_COINS_H"
      },
      {
        "sha": "bf68f8754b71739ba3aa4cc11e6180acec62fabf",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -126,7 +126,7 @@ unsigned int GetP2SHSigOpCount(const CTransaction& tx, const CCoinsViewCache& in\n     unsigned int nSigOps = 0;\n     for (unsigned int i = 0; i < tx.vin.size(); i++)\n     {\n-        const CTxOut &prevout = inputs.GetOutputFor(tx.vin[i]);\n+        const CTxOut &prevout = inputs.AccessCoin(tx.vin[i].prevout).out;\n         if (prevout.scriptPubKey.IsPayToScriptHash())\n             nSigOps += prevout.scriptPubKey.GetSigOpCount(tx.vin[i].scriptSig);\n     }\n@@ -146,7 +146,7 @@ int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& i\n \n     for (unsigned int i = 0; i < tx.vin.size(); i++)\n     {\n-        const CTxOut &prevout = inputs.GetOutputFor(tx.vin[i]);\n+        const CTxOut &prevout = inputs.AccessCoin(tx.vin[i].prevout).out;\n         nSigOps += CountWitnessSigOps(tx.vin[i].scriptSig, prevout.scriptPubKey, &tx.vin[i].scriptWitness, flags);\n     }\n     return nSigOps;\n@@ -213,20 +213,20 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n         for (unsigned int i = 0; i < tx.vin.size(); i++)\n         {\n             const COutPoint &prevout = tx.vin[i].prevout;\n-            const CCoins *coins = inputs.AccessCoins(prevout.hash);\n-            assert(coins);\n+            const Coin& coin = inputs.AccessCoin(prevout);\n+            assert(!coin.IsSpent());\n \n             // If prev is coinbase, check that it's matured\n-            if (coins->IsCoinBase()) {\n-                if (nSpendHeight - coins->nHeight < COINBASE_MATURITY)\n+            if (coin.IsCoinBase()) {\n+                if (nSpendHeight - coin.nHeight < COINBASE_MATURITY)\n                     return state.Invalid(false,\n                         REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\",\n-                        strprintf(\"tried to spend coinbase at depth %d\", nSpendHeight - coins->nHeight));\n+                        strprintf(\"tried to spend coinbase at depth %d\", nSpendHeight - coin.nHeight));\n             }\n \n             // Check for negative or overflow input values\n-            nValueIn += coins->vout[prevout.n].nValue;\n-            if (!MoneyRange(coins->vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n+            nValueIn += coin.out.nValue;\n+            if (!MoneyRange(coin.out.nValue) || !MoneyRange(nValueIn))\n                 return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputvalues-outofrange\");\n \n         }"
      },
      {
        "sha": "24ef71bfbffa9461eadcc94e0db83bb3dd3c5a70",
        "filename": "src/dbwrapper.h",
        "status": "modified",
        "additions": 41,
        "deletions": 2,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/dbwrapper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/dbwrapper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dbwrapper.h?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -55,11 +55,19 @@ class CDBBatch\n     CDataStream ssKey;\n     CDataStream ssValue;\n \n+    size_t size_estimate;\n+\n public:\n     /**\n      * @param[in] _parent   CDBWrapper that this batch is to be submitted to\n      */\n-    CDBBatch(const CDBWrapper &_parent) : parent(_parent), ssKey(SER_DISK, CLIENT_VERSION), ssValue(SER_DISK, CLIENT_VERSION) { };\n+    CDBBatch(const CDBWrapper &_parent) : parent(_parent), ssKey(SER_DISK, CLIENT_VERSION), ssValue(SER_DISK, CLIENT_VERSION), size_estimate(0) { };\n+\n+    void Clear()\n+    {\n+        batch.Clear();\n+        size_estimate = 0;\n+    }\n \n     template <typename K, typename V>\n     void Write(const K& key, const V& value)\n@@ -74,6 +82,14 @@ class CDBBatch\n         leveldb::Slice slValue(ssValue.data(), ssValue.size());\n \n         batch.Put(slKey, slValue);\n+        // LevelDB serializes writes as:\n+        // - byte: header\n+        // - varint: key length (1 byte up to 127B, 2 bytes up to 16383B, ...)\n+        // - byte[]: key\n+        // - varint: value length\n+        // - byte[]: value\n+        // The formula below assumes the key and value are both less than 16k.\n+        size_estimate += 3 + (slKey.size() > 127) + slKey.size() + (slValue.size() > 127) + slValue.size();\n         ssKey.clear();\n         ssValue.clear();\n     }\n@@ -86,8 +102,16 @@ class CDBBatch\n         leveldb::Slice slKey(ssKey.data(), ssKey.size());\n \n         batch.Delete(slKey);\n+        // LevelDB serializes erases as:\n+        // - byte: header\n+        // - varint: key length\n+        // - byte[]: key\n+        // The formula below assumes the key is less than 16kB.\n+        size_estimate += 2 + (slKey.size() > 127) + slKey.size();\n         ssKey.clear();\n     }\n+\n+    size_t SizeEstimate() const { return size_estimate; }\n };\n \n class CDBIterator\n@@ -281,7 +305,22 @@ class CDBWrapper\n      * Return true if the database managed by this class contains no entries.\n      */\n     bool IsEmpty();\n+\n+    template<typename K>\n+    size_t EstimateSize(const K& key_begin, const K& key_end) const\n+    {\n+        CDataStream ssKey1(SER_DISK, CLIENT_VERSION), ssKey2(SER_DISK, CLIENT_VERSION);\n+        ssKey1.reserve(DBWRAPPER_PREALLOC_KEY_SIZE);\n+        ssKey2.reserve(DBWRAPPER_PREALLOC_KEY_SIZE);\n+        ssKey1 << key_begin;\n+        ssKey2 << key_end;\n+        leveldb::Slice slKey1(ssKey1.data(), ssKey1.size());\n+        leveldb::Slice slKey2(ssKey2.data(), ssKey2.size());\n+        uint64_t size = 0;\n+        leveldb::Range range(slKey1, slKey2);\n+        pdb->GetApproximateSizes(&range, 1, &size);\n+        return size;\n+    }\n };\n \n #endif // BITCOIN_DBWRAPPER_H\n-"
      },
      {
        "sha": "b361c90d1626ae5cb5fc720d54ffb09546549da5",
        "filename": "src/hash.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 0,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/hash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/hash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.cpp?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -208,3 +208,44 @@ uint64_t SipHashUint256(uint64_t k0, uint64_t k1, const uint256& val)\n     SIPROUND;\n     return v0 ^ v1 ^ v2 ^ v3;\n }\n+\n+uint64_t SipHashUint256Extra(uint64_t k0, uint64_t k1, const uint256& val, uint32_t extra)\n+{\n+    /* Specialized implementation for efficiency */\n+    uint64_t d = val.GetUint64(0);\n+\n+    uint64_t v0 = 0x736f6d6570736575ULL ^ k0;\n+    uint64_t v1 = 0x646f72616e646f6dULL ^ k1;\n+    uint64_t v2 = 0x6c7967656e657261ULL ^ k0;\n+    uint64_t v3 = 0x7465646279746573ULL ^ k1 ^ d;\n+\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    d = val.GetUint64(1);\n+    v3 ^= d;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    d = val.GetUint64(2);\n+    v3 ^= d;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    d = val.GetUint64(3);\n+    v3 ^= d;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    d = (((uint64_t)36) << 56) | extra;\n+    v3 ^= d;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    v2 ^= 0xFF;\n+    SIPROUND;\n+    SIPROUND;\n+    SIPROUND;\n+    SIPROUND;\n+    return v0 ^ v1 ^ v2 ^ v3;\n+}"
      },
      {
        "sha": "b9952d39fc97dc1472a1c11b6e9e312f1b7a5e01",
        "filename": "src/hash.h",
        "status": "modified",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.h?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -160,6 +160,41 @@ class CHashWriter\n     }\n };\n \n+/** Reads data from an underlying stream, while hashing the read data. */\n+template<typename Source>\n+class CHashVerifier : public CHashWriter\n+{\n+private:\n+    Source* source;\n+\n+public:\n+    CHashVerifier(Source* source_) : CHashWriter(source_->GetType(), source_->GetVersion()), source(source_) {}\n+\n+    void read(char* pch, size_t nSize)\n+    {\n+        source->read(pch, nSize);\n+        this->write(pch, nSize);\n+    }\n+\n+    void ignore(size_t nSize)\n+    {\n+        char data[1024];\n+        while (nSize > 0) {\n+            size_t now = std::min<size_t>(nSize, 1024);\n+            read(data, now);\n+            nSize -= now;\n+        }\n+    }\n+\n+    template<typename T>\n+    CHashVerifier<Source>& operator>>(T& obj)\n+    {\n+        // Unserialize from this stream\n+        ::Unserialize(*this, obj);\n+        return (*this);\n+    }\n+};\n+\n /** Compute the 256-bit hash of an object's serialization. */\n template<typename T>\n uint256 SerializeHash(const T& obj, int nType=SER_GETHASH, int nVersion=PROTOCOL_VERSION)\n@@ -206,5 +241,6 @@ class CSipHasher\n  *      .Finalize()\n  */\n uint64_t SipHashUint256(uint64_t k0, uint64_t k1, const uint256& val);\n+uint64_t SipHashUint256Extra(uint64_t k0, uint64_t k1, const uint256& val, uint32_t extra);\n \n #endif // BITCOIN_HASH_H"
      },
      {
        "sha": "33023a180024a55983d688e071bf7d82a83d72ee",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -146,9 +146,9 @@ class CCoinsViewErrorCatcher : public CCoinsViewBacked\n {\n public:\n     CCoinsViewErrorCatcher(CCoinsView* view) : CCoinsViewBacked(view) {}\n-    bool GetCoins(const uint256 &txid, CCoins &coins) const {\n+    bool GetCoin(const COutPoint &outpoint, Coin &coin) const override {\n         try {\n-            return CCoinsViewBacked::GetCoins(txid, coins);\n+            return CCoinsViewBacked::GetCoin(outpoint, coin);\n         } catch(const std::runtime_error& e) {\n             uiInterface.ThreadSafeMessageBox(_(\"Error reading from database, shutting down.\"), \"\", CClientUIInterface::MSG_ERROR);\n             LogPrintf(\"Error reading from database: %s\\n\", e.what());\n@@ -1450,6 +1450,12 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n                     //If we're reindexing in prune mode, wipe away unusable block files and all undo data files\n                     if (fPruneMode)\n                         CleanupBlockRevFiles();\n+                } else {\n+                    // If necessary, upgrade from older database format.\n+                    if (!pcoinsdbview->Upgrade()) {\n+                        strLoadError = _(\"Error upgrading chainstate database\");\n+                        break;\n+                    }\n                 }\n \n                 if (!LoadBlockIndex(chainparams)) {"
      },
      {
        "sha": "c4f58fadbffcd84f011683c38f43d7e518686182",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -911,12 +911,11 @@ bool static AlreadyHave(const CInv& inv) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n                 recentRejects->reset();\n             }\n \n-            // Use pcoinsTip->HaveCoinsInCache as a quick approximation to exclude\n-            // requesting or processing some txs which have already been included in a block\n             return recentRejects->contains(inv.hash) ||\n                    mempool.exists(inv.hash) ||\n                    mapOrphanTransactions.count(inv.hash) ||\n-                   pcoinsTip->HaveCoinsInCache(inv.hash);\n+                   pcoinsTip->HaveCoinInCache(COutPoint(inv.hash, 0)) || // Best effort: only try output 0 and 1\n+                   pcoinsTip->HaveCoinInCache(COutPoint(inv.hash, 1));\n         }\n     case MSG_BLOCK:\n     case MSG_WITNESS_BLOCK:"
      },
      {
        "sha": "14d58e7442db0b52277dcbdacdc62d8e9bc8234d",
        "filename": "src/policy/policy.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/policy/policy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/policy/policy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.cpp?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -165,7 +165,7 @@ bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n \n     for (unsigned int i = 0; i < tx.vin.size(); i++)\n     {\n-        const CTxOut& prev = mapInputs.GetOutputFor(tx.vin[i]);\n+        const CTxOut& prev = mapInputs.AccessCoin(tx.vin[i].prevout).out;\n \n         std::vector<std::vector<unsigned char> > vSolutions;\n         txnouttype whichType;\n@@ -204,7 +204,7 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n         if (tx.vin[i].scriptWitness.IsNull())\n             continue;\n \n-        const CTxOut &prev = mapInputs.GetOutputFor(tx.vin[i]);\n+        const CTxOut &prev = mapInputs.AccessCoin(tx.vin[i].prevout).out;\n \n         // get the scriptPubKey corresponding to this input:\n         CScript prevScript = prev.scriptPubKey;"
      },
      {
        "sha": "ff1eb59f16b7cb18b8dc9f4a407891de3de176a9",
        "filename": "src/qt/test/wallettests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/qt/test/wallettests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/qt/test/wallettests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/wallettests.cpp?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -182,7 +182,7 @@ void TestSendCoins()\n     BumpFee(transactionView, txid1, true /* expect disabled */, \"not BIP 125 replaceable\" /* expected error */, false /* cancel */);\n     BumpFee(transactionView, txid2, false /* expect disabled */, {} /* expected error */, true /* cancel */);\n     BumpFee(transactionView, txid2, false /* expect disabled */, {} /* expected error */, false /* cancel */);\n-    BumpFee(transactionView, txid2, false /* expect disabled */, \"already bumped\" /* expected error */, false /* cancel */);\n+    BumpFee(transactionView, txid2, true /* expect disabled */, \"already bumped\" /* expected error */, false /* cancel */);\n \n     bitdb.Flush(true);\n     bitdb.Reset();"
      },
      {
        "sha": "233fc08772170929ccb05c950bafde9edd3a17eb",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -293,13 +293,12 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n         {\n             COutPoint prevout = txin.prevout;\n \n-            CCoins prev;\n-            if(pcoinsTip->GetCoins(prevout.hash, prev))\n+            Coin prev;\n+            if(pcoinsTip->GetCoin(prevout, prev))\n             {\n-                if (prevout.n < prev.vout.size())\n                 {\n                     strHTML += \"<li>\";\n-                    const CTxOut &vout = prev.vout[prevout.n];\n+                    const CTxOut &vout = prev.out;\n                     CTxDestination address;\n                     if (ExtractDestination(vout.scriptPubKey, address))\n                     {"
      },
      {
        "sha": "0090b0c74bf5924267b222b7d5708cc122e8e195",
        "filename": "src/qt/transactionrecord.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/qt/transactionrecord.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/qt/transactionrecord.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.cpp?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -246,13 +246,13 @@ void TransactionRecord::updateStatus(const CWalletTx &wtx)\n             status.status = TransactionStatus::Confirmed;\n         }\n     }\n-\n+    status.needsUpdate = false;\n }\n \n bool TransactionRecord::statusUpdateNeeded()\n {\n     AssertLockHeld(cs_main);\n-    return status.cur_num_blocks != chainActive.Height();\n+    return status.cur_num_blocks != chainActive.Height() || status.needsUpdate;\n }\n \n QString TransactionRecord::getTxID() const"
      },
      {
        "sha": "59f681224fc995b8e5a610d3e107e672a5bc58b5",
        "filename": "src/qt/transactionrecord.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/qt/transactionrecord.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/qt/transactionrecord.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.h?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -61,6 +61,8 @@ class TransactionStatus\n \n     /** Current number of blocks (to know whether cached status is still valid) */\n     int cur_num_blocks;\n+\n+    bool needsUpdate;\n };\n \n /** UI model for a transaction. A core transaction can be represented by multiple UI transactions if it has"
      },
      {
        "sha": "f27abc2104cbfb566ca92c5007d9ac9e8d4959f8",
        "filename": "src/qt/transactiontablemodel.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/qt/transactiontablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/qt/transactiontablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiontablemodel.cpp?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -168,6 +168,10 @@ class TransactionTablePriv\n         case CT_UPDATED:\n             // Miscellaneous updates -- nothing to do, status update will take care of this, and is only computed for\n             // visible transactions.\n+            for (int i = lowerIndex; i < upperIndex; i++) {\n+                TransactionRecord *rec = &cachedWallet[i];\n+                rec->status.needsUpdate = true;\n+            }\n             break;\n         }\n     }"
      },
      {
        "sha": "e3e070b27f3545d96498d27167854516b4709890",
        "filename": "src/qt/transactionview.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/qt/transactionview.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/qt/transactionview.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionview.cpp?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -379,7 +379,7 @@ void TransactionView::contextualMenu(const QPoint &point)\n     uint256 hash;\n     hash.SetHex(selection.at(0).data(TransactionTableModel::TxHashRole).toString().toStdString());\n     abandonAction->setEnabled(model->transactionCanBeAbandoned(hash));\n-    bumpFeeAction->setEnabled(model->transactionSignalsRBF(hash));\n+    bumpFeeAction->setEnabled(model->transactionCanBeBumped(hash));\n \n     if(index.isValid())\n     {"
      },
      {
        "sha": "8df0e481bdb47d2a8d0a328b172e904f3ad1697a",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -656,11 +656,11 @@ bool WalletModel::abandonTransaction(uint256 hash) const\n     return wallet->AbandonTransaction(hash);\n }\n \n-bool WalletModel::transactionSignalsRBF(uint256 hash) const\n+bool WalletModel::transactionCanBeBumped(uint256 hash) const\n {\n     LOCK2(cs_main, wallet->cs_wallet);\n     const CWalletTx *wtx = wallet->GetWalletTx(hash);\n-    return wtx && SignalsOptInRBF(*wtx);\n+    return wtx && SignalsOptInRBF(*wtx) && !wtx->mapValue.count(\"replaced_by_txid\");\n }\n \n bool WalletModel::bumpFee(uint256 hash)"
      },
      {
        "sha": "16b0caed4efa99f7f98fdc5cb31bde65c2d1f96b",
        "filename": "src/qt/walletmodel.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/qt/walletmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/qt/walletmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.h?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -207,7 +207,7 @@ class WalletModel : public QObject\n     bool transactionCanBeAbandoned(uint256 hash) const;\n     bool abandonTransaction(uint256 hash) const;\n \n-    bool transactionSignalsRBF(uint256 hash) const;\n+    bool transactionCanBeBumped(uint256 hash) const;\n     bool bumpFee(uint256 hash);\n \n     static bool isWalletEnabled();"
      },
      {
        "sha": "b08d7153b1d0a91d1e1e3e003abff475dc36739c",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 18,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -42,16 +42,19 @@ static const struct {\n };\n \n struct CCoin {\n-    uint32_t nTxVer; // Don't call this nVersion, that name has a special meaning inside IMPLEMENT_SERIALIZE\n     uint32_t nHeight;\n     CTxOut out;\n \n     ADD_SERIALIZE_METHODS;\n \n+    CCoin() : nHeight(0) {}\n+    CCoin(Coin&& in) : nHeight(in.nHeight), out(std::move(in.out)) {}\n+\n     template <typename Stream, typename Operation>\n     inline void SerializationOp(Stream& s, Operation ser_action)\n     {\n-        READWRITE(nTxVer);\n+        uint32_t nTxVerDummy = 0;\n+        READWRITE(nTxVerDummy);\n         READWRITE(nHeight);\n         READWRITE(out);\n     }\n@@ -509,22 +512,11 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n             view.SetBackend(viewMempool); // switch cache backend to db+mempool in case user likes to query mempool\n \n         for (size_t i = 0; i < vOutPoints.size(); i++) {\n-            CCoins coins;\n-            uint256 hash = vOutPoints[i].hash;\n             bool hit = false;\n-            if (view.GetCoins(hash, coins)) {\n-                mempool.pruneSpent(hash, coins);\n-                if (coins.IsAvailable(vOutPoints[i].n)) {\n-                    hit = true;\n-                    // Safe to index into vout here because IsAvailable checked if it's off the end of the array, or if\n-                    // n is valid but points to an already spent output (IsNull).\n-                    CCoin coin;\n-                    coin.nTxVer = coins.nVersion;\n-                    coin.nHeight = coins.nHeight;\n-                    coin.out = coins.vout.at(vOutPoints[i].n);\n-                    assert(!coin.out.IsNull());\n-                    outs.push_back(coin);\n-                }\n+            Coin coin;\n+            if (view.GetCoin(vOutPoints[i], coin) && !mempool.isSpent(vOutPoints[i])) {\n+                hit = true;\n+                outs.emplace_back(std::move(coin));\n             }\n \n             hits.push_back(hit);\n@@ -568,7 +560,6 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n         UniValue utxos(UniValue::VARR);\n         BOOST_FOREACH (const CCoin& coin, outs) {\n             UniValue utxo(UniValue::VOBJ);\n-            utxo.push_back(Pair(\"txvers\", (int32_t)coin.nTxVer));\n             utxo.push_back(Pair(\"height\", (int32_t)coin.nHeight));\n             utxo.push_back(Pair(\"value\", ValueFromAmount(coin.out.nValue)));\n "
      },
      {
        "sha": "96871ce1dc9f1b28e36286e551501f6755f4b843",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 49,
        "deletions": 36,
        "changes": 85,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -781,13 +781,29 @@ struct CCoinsStats\n     uint256 hashBlock;\n     uint64_t nTransactions;\n     uint64_t nTransactionOutputs;\n-    uint64_t nSerializedSize;\n     uint256 hashSerialized;\n+    uint64_t nDiskSize;\n     CAmount nTotalAmount;\n \n-    CCoinsStats() : nHeight(0), nTransactions(0), nTransactionOutputs(0), nSerializedSize(0), nTotalAmount(0) {}\n+    CCoinsStats() : nHeight(0), nTransactions(0), nTransactionOutputs(0), nTotalAmount(0) {}\n };\n \n+static void ApplyStats(CCoinsStats &stats, CHashWriter& ss, const uint256& hash, const std::map<uint32_t, Coin>& outputs)\n+{\n+    assert(!outputs.empty());\n+    ss << hash;\n+    ss << VARINT(outputs.begin()->second.nHeight * 2 + outputs.begin()->second.fCoinBase);\n+    stats.nTransactions++;\n+    for (const auto output : outputs) {\n+        ss << VARINT(output.first + 1);\n+        ss << *(const CScriptBase*)(&output.second.out.scriptPubKey);\n+        ss << VARINT(output.second.out.nValue);\n+        stats.nTransactionOutputs++;\n+        stats.nTotalAmount += output.second.out.nValue;\n+    }\n+    ss << VARINT(0);\n+}\n+\n //! Calculate statistics about the unspent transaction output set\n static bool GetUTXOStats(CCoinsView *view, CCoinsStats &stats)\n {\n@@ -800,32 +816,29 @@ static bool GetUTXOStats(CCoinsView *view, CCoinsStats &stats)\n         stats.nHeight = mapBlockIndex.find(stats.hashBlock)->second->nHeight;\n     }\n     ss << stats.hashBlock;\n-    CAmount nTotalAmount = 0;\n+    uint256 prevkey;\n+    std::map<uint32_t, Coin> outputs;\n     while (pcursor->Valid()) {\n         boost::this_thread::interruption_point();\n-        uint256 key;\n-        CCoins coins;\n-        if (pcursor->GetKey(key) && pcursor->GetValue(coins)) {\n-            stats.nTransactions++;\n-            ss << key;\n-            for (unsigned int i=0; i<coins.vout.size(); i++) {\n-                const CTxOut &out = coins.vout[i];\n-                if (!out.IsNull()) {\n-                    stats.nTransactionOutputs++;\n-                    ss << VARINT(i+1);\n-                    ss << out;\n-                    nTotalAmount += out.nValue;\n-                }\n+        COutPoint key;\n+        Coin coin;\n+        if (pcursor->GetKey(key) && pcursor->GetValue(coin)) {\n+            if (!outputs.empty() && key.hash != prevkey) {\n+                ApplyStats(stats, ss, prevkey, outputs);\n+                outputs.clear();\n             }\n-            stats.nSerializedSize += 32 + pcursor->GetValueSize();\n-            ss << VARINT(0);\n+            prevkey = key.hash;\n+            outputs[key.n] = std::move(coin);\n         } else {\n             return error(\"%s: unable to read value\", __func__);\n         }\n         pcursor->Next();\n     }\n+    if (!outputs.empty()) {\n+        ApplyStats(stats, ss, prevkey, outputs);\n+    }\n     stats.hashSerialized = ss.GetHash();\n-    stats.nTotalAmount = nTotalAmount;\n+    stats.nDiskSize = view->EstimateSize();\n     return true;\n }\n \n@@ -891,8 +904,8 @@ UniValue gettxoutsetinfo(const JSONRPCRequest& request)\n             \"  \\\"bestblock\\\": \\\"hex\\\",   (string) the best block hash hex\\n\"\n             \"  \\\"transactions\\\": n,      (numeric) The number of transactions\\n\"\n             \"  \\\"txouts\\\": n,            (numeric) The number of output transactions\\n\"\n-            \"  \\\"bytes_serialized\\\": n,  (numeric) The serialized size\\n\"\n             \"  \\\"hash_serialized\\\": \\\"hash\\\",   (string) The serialized hash\\n\"\n+            \"  \\\"disk_size\\\": n,         (numeric) The estimated size of the chainstate on disk\\n\"\n             \"  \\\"total_amount\\\": x.xxx          (numeric) The total amount\\n\"\n             \"}\\n\"\n             \"\\nExamples:\\n\"\n@@ -909,8 +922,8 @@ UniValue gettxoutsetinfo(const JSONRPCRequest& request)\n         ret.push_back(Pair(\"bestblock\", stats.hashBlock.GetHex()));\n         ret.push_back(Pair(\"transactions\", (int64_t)stats.nTransactions));\n         ret.push_back(Pair(\"txouts\", (int64_t)stats.nTransactionOutputs));\n-        ret.push_back(Pair(\"bytes_serialized\", (int64_t)stats.nSerializedSize));\n-        ret.push_back(Pair(\"hash_serialized\", stats.hashSerialized.GetHex()));\n+        ret.push_back(Pair(\"hash_serialized_2\", stats.hashSerialized.GetHex()));\n+        ret.push_back(Pair(\"disk_size\", stats.nDiskSize));\n         ret.push_back(Pair(\"total_amount\", ValueFromAmount(stats.nTotalAmount)));\n     } else {\n         throw JSONRPCError(RPC_INTERNAL_ERROR, \"Unable to read UTXO set\");\n@@ -963,37 +976,37 @@ UniValue gettxout(const JSONRPCRequest& request)\n     std::string strHash = request.params[0].get_str();\n     uint256 hash(uint256S(strHash));\n     int n = request.params[1].get_int();\n+    COutPoint out(hash, n);\n     bool fMempool = true;\n     if (request.params.size() > 2)\n         fMempool = request.params[2].get_bool();\n \n-    CCoins coins;\n+    Coin coin;\n     if (fMempool) {\n         LOCK(mempool.cs);\n         CCoinsViewMemPool view(pcoinsTip, mempool);\n-        if (!view.GetCoins(hash, coins))\n+        if (!view.GetCoin(out, coin) || mempool.isSpent(out)) { // TODO: filtering spent coins should be done by the CCoinsViewMemPool\n             return NullUniValue;\n-        mempool.pruneSpent(hash, coins); // TODO: this should be done by the CCoinsViewMemPool\n+        }\n     } else {\n-        if (!pcoinsTip->GetCoins(hash, coins))\n+        if (!pcoinsTip->GetCoin(out, coin)) {\n             return NullUniValue;\n+        }\n     }\n-    if (n<0 || (unsigned int)n>=coins.vout.size() || coins.vout[n].IsNull())\n-        return NullUniValue;\n \n     BlockMap::iterator it = mapBlockIndex.find(pcoinsTip->GetBestBlock());\n     CBlockIndex *pindex = it->second;\n     ret.push_back(Pair(\"bestblock\", pindex->GetBlockHash().GetHex()));\n-    if ((unsigned int)coins.nHeight == MEMPOOL_HEIGHT)\n+    if (coin.nHeight == MEMPOOL_HEIGHT) {\n         ret.push_back(Pair(\"confirmations\", 0));\n-    else\n-        ret.push_back(Pair(\"confirmations\", pindex->nHeight - coins.nHeight + 1));\n-    ret.push_back(Pair(\"value\", ValueFromAmount(coins.vout[n].nValue)));\n+    } else {\n+        ret.push_back(Pair(\"confirmations\", (int64_t)(pindex->nHeight - coin.nHeight + 1)));\n+    }\n+    ret.push_back(Pair(\"value\", ValueFromAmount(coin.out.nValue)));\n     UniValue o(UniValue::VOBJ);\n-    ScriptPubKeyToUniv(coins.vout[n].scriptPubKey, o, true);\n+    ScriptPubKeyToUniv(coin.out.scriptPubKey, o, true);\n     ret.push_back(Pair(\"scriptPubKey\", o));\n-    ret.push_back(Pair(\"version\", coins.nVersion));\n-    ret.push_back(Pair(\"coinbase\", coins.fCoinBase));\n+    ret.push_back(Pair(\"coinbase\", (bool)coin.fCoinBase));\n \n     return ret;\n }\n@@ -1325,7 +1338,7 @@ UniValue getmempoolinfo(const JSONRPCRequest& request)\n             \"  \\\"bytes\\\": xxxxx,              (numeric) Sum of all virtual transaction sizes as defined in BIP 141. Differs from actual serialized size because witness data is discounted\\n\"\n             \"  \\\"usage\\\": xxxxx,              (numeric) Total memory usage for the mempool\\n\"\n             \"  \\\"maxmempool\\\": xxxxx,         (numeric) Maximum memory usage for the mempool\\n\"\n-            \"  \\\"mempoolminfee\\\": xxxxx       (numeric) Minimum fee for tx to be accepted\\n\"\n+            \"  \\\"mempoolminfee\\\": xxxxx       (numeric) Minimum feerate (\" + CURRENCY_UNIT + \" per KB) for tx to be accepted\\n\"\n             \"}\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"getmempoolinfo\", \"\")"
      },
      {
        "sha": "e27c2a77c763c235ee51bfb8301e6569c0728a12",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 20,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -219,9 +219,10 @@ UniValue gettxoutproof(const JSONRPCRequest& request)\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n         pblockindex = mapBlockIndex[hashBlock];\n     } else {\n-        CCoins coins;\n-        if (pcoinsTip->GetCoins(oneTxid, coins) && coins.nHeight > 0 && coins.nHeight <= chainActive.Height())\n-            pblockindex = chainActive[coins.nHeight];\n+        const Coin& coin = AccessByTxid(*pcoinsTip, oneTxid);\n+        if (!coin.IsSpent() && coin.nHeight > 0 && coin.nHeight <= chainActive.Height()) {\n+            pblockindex = chainActive[coin.nHeight];\n+        }\n     }\n \n     if (pblockindex == NULL)\n@@ -637,9 +638,7 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n         view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n \n         BOOST_FOREACH(const CTxIn& txin, mergedTx.vin) {\n-            const uint256& prevHash = txin.prevout.hash;\n-            CCoins coins;\n-            view.AccessCoins(prevHash); // this is certainly allowed to fail\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n         }\n \n         view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n@@ -691,24 +690,26 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n             if (nOut < 0)\n                 throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"vout must be positive\");\n \n+            COutPoint out(txid, nOut);\n             std::vector<unsigned char> pkData(ParseHexO(prevOut, \"scriptPubKey\"));\n             CScript scriptPubKey(pkData.begin(), pkData.end());\n \n             {\n-                CCoinsModifier coins = view.ModifyCoins(txid);\n-                if (coins->IsAvailable(nOut) && coins->vout[nOut].scriptPubKey != scriptPubKey) {\n+                const Coin& coin = view.AccessCoin(out);\n+                if (!coin.IsSpent() && coin.out.scriptPubKey != scriptPubKey) {\n                     std::string err(\"Previous output scriptPubKey mismatch:\\n\");\n-                    err = err + ScriptToAsmStr(coins->vout[nOut].scriptPubKey) + \"\\nvs:\\n\"+\n+                    err = err + ScriptToAsmStr(coin.out.scriptPubKey) + \"\\nvs:\\n\"+\n                         ScriptToAsmStr(scriptPubKey);\n                     throw JSONRPCError(RPC_DESERIALIZATION_ERROR, err);\n                 }\n-                if ((unsigned int)nOut >= coins->vout.size())\n-                    coins->vout.resize(nOut+1);\n-                coins->vout[nOut].scriptPubKey = scriptPubKey;\n-                coins->vout[nOut].nValue = 0;\n+                Coin newcoin;\n+                newcoin.out.scriptPubKey = scriptPubKey;\n+                newcoin.out.nValue = 0;\n                 if (prevOut.exists(\"amount\")) {\n-                    coins->vout[nOut].nValue = AmountFromValue(find_value(prevOut, \"amount\"));\n+                    newcoin.out.nValue = AmountFromValue(find_value(prevOut, \"amount\"));\n                 }\n+                newcoin.nHeight = 1;\n+                view.AddCoin(out, std::move(newcoin), true);\n             }\n \n             // if redeemScript given and not using the local wallet (private keys\n@@ -766,13 +767,13 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n     // Sign what we can:\n     for (unsigned int i = 0; i < mergedTx.vin.size(); i++) {\n         CTxIn& txin = mergedTx.vin[i];\n-        const CCoins* coins = view.AccessCoins(txin.prevout.hash);\n-        if (coins == NULL || !coins->IsAvailable(txin.prevout.n)) {\n+        const Coin& coin = view.AccessCoin(txin.prevout);\n+        if (coin.IsSpent()) {\n             TxInErrorToJSON(txin, vErrors, \"Input not found or already spent\");\n             continue;\n         }\n-        const CScript& prevPubKey = coins->vout[txin.prevout.n].scriptPubKey;\n-        const CAmount& amount = coins->vout[txin.prevout.n].nValue;\n+        const CScript& prevPubKey = coin.out.scriptPubKey;\n+        const CAmount& amount = coin.out.nValue;\n \n         SignatureData sigdata;\n         // Only sign SIGHASH_SINGLE if there's a corresponding output:\n@@ -844,9 +845,12 @@ UniValue sendrawtransaction(const JSONRPCRequest& request)\n         nMaxRawTxFee = 0;\n \n     CCoinsViewCache &view = *pcoinsTip;\n-    const CCoins* existingCoins = view.AccessCoins(hashTx);\n+    bool fHaveChain = false;\n+    for (size_t o = 0; !fHaveChain && o < tx->vout.size(); o++) {\n+        const Coin& existingCoin = view.AccessCoin(COutPoint(hashTx, o));\n+        fHaveChain = !existingCoin.IsSpent();\n+    }\n     bool fHaveMempool = mempool.exists(hashTx);\n-    bool fHaveChain = existingCoins && existingCoins->nHeight < 1000000000;\n     if (!fHaveMempool && !fHaveChain) {\n         // push to local node and sync with wallets\n         CValidationState state;"
      },
      {
        "sha": "4a4e5516953a57a6f157789d632f6decdc12f179",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 268,
        "deletions": 293,
        "changes": 561,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -17,35 +17,44 @@\n \n #include <boost/test/unit_test.hpp>\n \n-bool ApplyTxInUndo(const CTxInUndo& undo, CCoinsViewCache& view, const COutPoint& out);\n+int ApplyTxInUndo(Coin&& undo, CCoinsViewCache& view, const COutPoint& out);\n void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, CTxUndo &txundo, int nHeight);\n \n namespace\n {\n+//! equality test\n+bool operator==(const Coin &a, const Coin &b) {\n+    // Empty Coin objects are always equal.\n+    if (a.IsSpent() && b.IsSpent()) return true;\n+    return a.fCoinBase == b.fCoinBase &&\n+           a.nHeight == b.nHeight &&\n+           a.out == b.out;\n+}\n+\n class CCoinsViewTest : public CCoinsView\n {\n     uint256 hashBestBlock_;\n-    std::map<uint256, CCoins> map_;\n+    std::map<COutPoint, Coin> map_;\n \n public:\n-    bool GetCoins(const uint256& txid, CCoins& coins) const\n+    bool GetCoin(const COutPoint& outpoint, Coin& coin) const\n     {\n-        std::map<uint256, CCoins>::const_iterator it = map_.find(txid);\n+        std::map<COutPoint, Coin>::const_iterator it = map_.find(outpoint);\n         if (it == map_.end()) {\n             return false;\n         }\n-        coins = it->second;\n-        if (coins.IsPruned() && insecure_rand() % 2 == 0) {\n+        coin = it->second;\n+        if (coin.IsSpent() && insecure_rand() % 2 == 0) {\n             // Randomly return false in case of an empty entry.\n             return false;\n         }\n         return true;\n     }\n \n-    bool HaveCoins(const uint256& txid) const\n+    bool HaveCoin(const COutPoint& outpoint) const\n     {\n-        CCoins coins;\n-        return GetCoins(txid, coins);\n+        Coin coin;\n+        return GetCoin(outpoint, coin);\n     }\n \n     uint256 GetBestBlock() const { return hashBestBlock_; }\n@@ -55,8 +64,8 @@ class CCoinsViewTest : public CCoinsView\n         for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end(); ) {\n             if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n                 // Same optimization used in CCoinsViewDB is to only write dirty entries.\n-                map_[it->first] = it->second.coins;\n-                if (it->second.coins.IsPruned() && insecure_rand() % 3 == 0) {\n+                map_[it->first] = it->second.coin;\n+                if (it->second.coin.IsSpent() && insecure_rand() % 3 == 0) {\n                     // Randomly delete empty entries on write.\n                     map_.erase(it->first);\n                 }\n@@ -78,9 +87,12 @@ class CCoinsViewCacheTest : public CCoinsViewCache\n     {\n         // Manually recompute the dynamic usage of the whole data, and compare it.\n         size_t ret = memusage::DynamicUsage(cacheCoins);\n+        size_t count = 0;\n         for (CCoinsMap::iterator it = cacheCoins.begin(); it != cacheCoins.end(); it++) {\n-            ret += it->second.coins.DynamicMemoryUsage();\n+            ret += it->second.coin.DynamicMemoryUsage();\n+            ++count;\n         }\n+        BOOST_CHECK_EQUAL(GetCacheSize(), count);\n         BOOST_CHECK_EQUAL(DynamicMemoryUsage(), ret);\n     }\n \n@@ -97,7 +109,7 @@ static const unsigned int NUM_SIMULATION_ITERATIONS = 40000;\n // This is a large randomized insert/remove simulation test on a variable-size\n // stack of caches on top of CCoinsViewTest.\n //\n-// It will randomly create/update/delete CCoins entries to a tip of caches, with\n+// It will randomly create/update/delete Coin entries to a tip of caches, with\n // txids picked from a limited list of random 256-bit hashes. Occasionally, a\n // new tip is added to the stack of caches, or the tip is flushed and removed.\n //\n@@ -109,13 +121,15 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n     bool removed_all_caches = false;\n     bool reached_4_caches = false;\n     bool added_an_entry = false;\n+    bool added_an_unspendable_entry = false;\n     bool removed_an_entry = false;\n     bool updated_an_entry = false;\n     bool found_an_entry = false;\n     bool missed_an_entry = false;\n+    bool uncached_an_entry = false;\n \n     // A simple map to track what we expect the cache stack to represent.\n-    std::map<uint256, CCoins> result;\n+    std::map<COutPoint, Coin> result;\n \n     // The cache stack.\n     CCoinsViewTest base; // A CCoinsViewTest at the bottom.\n@@ -133,36 +147,51 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n         // Do a random modification.\n         {\n             uint256 txid = txids[insecure_rand() % txids.size()]; // txid we're going to modify in this iteration.\n-            CCoins& coins = result[txid];\n-            CCoinsModifier entry = stack.back()->ModifyCoins(txid);\n-            BOOST_CHECK(coins == *entry);\n-            if (insecure_rand() % 5 == 0 || coins.IsPruned()) {\n-                if (coins.IsPruned()) {\n-                    added_an_entry = true;\n+            Coin& coin = result[COutPoint(txid, 0)];\n+            const Coin& entry = (insecure_rand() % 500 == 0) ? AccessByTxid(*stack.back(), txid) : stack.back()->AccessCoin(COutPoint(txid, 0));\n+            BOOST_CHECK(coin == entry);\n+\n+            if (insecure_rand() % 5 == 0 || coin.IsSpent()) {\n+                Coin newcoin;\n+                newcoin.out.nValue = insecure_rand();\n+                newcoin.nHeight = 1;\n+                if (insecure_rand() % 16 == 0 && coin.IsSpent()) {\n+                    newcoin.out.scriptPubKey.assign(1 + (insecure_rand() & 0x3F), OP_RETURN);\n+                    BOOST_CHECK(newcoin.out.scriptPubKey.IsUnspendable());\n+                    added_an_unspendable_entry = true;\n                 } else {\n-                    updated_an_entry = true;\n+                    newcoin.out.scriptPubKey.assign(insecure_rand() & 0x3F, 0); // Random sizes so we can test memory usage accounting\n+                    (coin.IsSpent() ? added_an_entry : updated_an_entry) = true;\n+                    coin = newcoin;\n                 }\n-                coins.nVersion = insecure_rand();\n-                coins.vout.resize(1);\n-                coins.vout[0].nValue = insecure_rand();\n-                *entry = coins;\n+                stack.back()->AddCoin(COutPoint(txid, 0), std::move(newcoin), !coin.IsSpent() || insecure_rand() & 1);\n             } else {\n-                coins.Clear();\n-                entry->Clear();\n                 removed_an_entry = true;\n+                coin.Clear();\n+                stack.back()->SpendCoin(COutPoint(txid, 0));\n             }\n         }\n \n+        // One every 10 iterations, remove a random entry from the cache\n+        if (insecure_rand() % 10) {\n+            COutPoint out(txids[insecure_rand() % txids.size()], 0);\n+            int cacheid = insecure_rand() % stack.size();\n+            stack[cacheid]->Uncache(out);\n+            uncached_an_entry |= !stack[cacheid]->HaveCoinInCache(out);\n+        }\n+\n         // Once every 1000 iterations and at the end, verify the full cache.\n         if (insecure_rand() % 1000 == 1 || i == NUM_SIMULATION_ITERATIONS - 1) {\n-            for (std::map<uint256, CCoins>::iterator it = result.begin(); it != result.end(); it++) {\n-                const CCoins* coins = stack.back()->AccessCoins(it->first);\n-                if (coins) {\n-                    BOOST_CHECK(*coins == it->second);\n-                    found_an_entry = true;\n-                } else {\n-                    BOOST_CHECK(it->second.IsPruned());\n+            for (auto it = result.begin(); it != result.end(); it++) {\n+                bool have = stack.back()->HaveCoin(it->first);\n+                const Coin& coin = stack.back()->AccessCoin(it->first);\n+                BOOST_CHECK(have == !coin.IsSpent());\n+                BOOST_CHECK(coin == it->second);\n+                if (coin.IsSpent()) {\n                     missed_an_entry = true;\n+                } else {\n+                    BOOST_CHECK(stack.back()->HaveCoinInCache(it->first));\n+                    found_an_entry = true;\n                 }\n             }\n             BOOST_FOREACH(const CCoinsViewCacheTest *test, stack) {\n@@ -211,25 +240,27 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n     BOOST_CHECK(removed_all_caches);\n     BOOST_CHECK(reached_4_caches);\n     BOOST_CHECK(added_an_entry);\n+    BOOST_CHECK(added_an_unspendable_entry);\n     BOOST_CHECK(removed_an_entry);\n     BOOST_CHECK(updated_an_entry);\n     BOOST_CHECK(found_an_entry);\n     BOOST_CHECK(missed_an_entry);\n+    BOOST_CHECK(uncached_an_entry);\n }\n \n-typedef std::tuple<CTransaction,CTxUndo,CCoins> TxData;\n // Store of all necessary tx and undo data for next test\n-std::map<uint256, TxData> alltxs;\n-\n-TxData &FindRandomFrom(const std::set<uint256> &txidset) {\n-    assert(txidset.size());\n-    std::set<uint256>::iterator txIt = txidset.lower_bound(GetRandHash());\n-    if (txIt == txidset.end()) {\n-        txIt = txidset.begin();\n+typedef std::map<COutPoint, std::tuple<CTransaction,CTxUndo,Coin>> UtxoData;\n+UtxoData utxoData;\n+\n+UtxoData::iterator FindRandomFrom(const std::set<COutPoint> &utxoSet) {\n+    assert(utxoSet.size());\n+    auto utxoSetIt = utxoSet.lower_bound(COutPoint(GetRandHash(), 0));\n+    if (utxoSetIt == utxoSet.end()) {\n+        utxoSetIt = utxoSet.begin();\n     }\n-    std::map<uint256, TxData>::iterator txdit = alltxs.find(*txIt);\n-    assert(txdit != alltxs.end());\n-    return txdit->second;\n+    auto utxoDataIt = utxoData.find(*utxoSetIt);\n+    assert(utxoDataIt != utxoData.end());\n+    return utxoDataIt;\n }\n \n \n@@ -242,18 +273,18 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n {\n     bool spent_a_duplicate_coinbase = false;\n     // A simple map to track what we expect the cache stack to represent.\n-    std::map<uint256, CCoins> result;\n+    std::map<COutPoint, Coin> result;\n \n     // The cache stack.\n     CCoinsViewTest base; // A CCoinsViewTest at the bottom.\n     std::vector<CCoinsViewCacheTest*> stack; // A stack of CCoinsViewCaches on top.\n     stack.push_back(new CCoinsViewCacheTest(&base)); // Start with one cache.\n \n     // Track the txids we've used in various sets\n-    std::set<uint256> coinbaseids;\n-    std::set<uint256> disconnectedids;\n-    std::set<uint256> duplicateids;\n-    std::set<uint256> utxoset;\n+    std::set<COutPoint> coinbase_coins;\n+    std::set<COutPoint> disconnected_coins;\n+    std::set<COutPoint> duplicate_coins;\n+    std::set<COutPoint> utxoset;\n \n     for (unsigned int i = 0; i < NUM_SIMULATION_ITERATIONS; i++) {\n         uint32_t randiter = insecure_rand();\n@@ -264,138 +295,143 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n             tx.vin.resize(1);\n             tx.vout.resize(1);\n             tx.vout[0].nValue = i; //Keep txs unique unless intended to duplicate\n+            tx.vout[0].scriptPubKey.assign(insecure_rand() & 0x3F, 0); // Random sizes so we can test memory usage accounting\n             unsigned int height = insecure_rand();\n-            CCoins oldcoins;\n+            Coin old_coin;\n \n             // 2/20 times create a new coinbase\n-            if (randiter % 20 < 2 || coinbaseids.size() < 10) {\n+            if (randiter % 20 < 2 || coinbase_coins.size() < 10) {\n                 // 1/10 of those times create a duplicate coinbase\n-                if (insecure_rand() % 10 == 0 && coinbaseids.size()) {\n-                    TxData &txd = FindRandomFrom(coinbaseids);\n+                if (insecure_rand() % 10 == 0 && coinbase_coins.size()) {\n+                    auto utxod = FindRandomFrom(coinbase_coins);\n                     // Reuse the exact same coinbase\n-                    tx = std::get<0>(txd);\n+                    tx = std::get<0>(utxod->second);\n                     // shouldn't be available for reconnection if its been duplicated\n-                    disconnectedids.erase(tx.GetHash());\n+                    disconnected_coins.erase(utxod->first);\n \n-                    duplicateids.insert(tx.GetHash());\n+                    duplicate_coins.insert(utxod->first);\n                 }\n                 else {\n-                    coinbaseids.insert(tx.GetHash());\n+                    coinbase_coins.insert(COutPoint(tx.GetHash(), 0));\n                 }\n                 assert(CTransaction(tx).IsCoinBase());\n             }\n \n             // 17/20 times reconnect previous or add a regular tx\n             else {\n \n-                uint256 prevouthash;\n+                COutPoint prevout;\n                 // 1/20 times reconnect a previously disconnected tx\n-                if (randiter % 20 == 2 && disconnectedids.size()) {\n-                    TxData &txd = FindRandomFrom(disconnectedids);\n-                    tx = std::get<0>(txd);\n-                    prevouthash = tx.vin[0].prevout.hash;\n-                    if (!CTransaction(tx).IsCoinBase() && !utxoset.count(prevouthash)) {\n-                        disconnectedids.erase(tx.GetHash());\n+                if (randiter % 20 == 2 && disconnected_coins.size()) {\n+                    auto utxod = FindRandomFrom(disconnected_coins);\n+                    tx = std::get<0>(utxod->second);\n+                    prevout = tx.vin[0].prevout;\n+                    if (!CTransaction(tx).IsCoinBase() && !utxoset.count(prevout)) {\n+                        disconnected_coins.erase(utxod->first);\n                         continue;\n                     }\n \n                     // If this tx is already IN the UTXO, then it must be a coinbase, and it must be a duplicate\n-                    if (utxoset.count(tx.GetHash())) {\n+                    if (utxoset.count(utxod->first)) {\n                         assert(CTransaction(tx).IsCoinBase());\n-                        assert(duplicateids.count(tx.GetHash()));\n+                        assert(duplicate_coins.count(utxod->first));\n                     }\n-                    disconnectedids.erase(tx.GetHash());\n+                    disconnected_coins.erase(utxod->first);\n                 }\n \n                 // 16/20 times create a regular tx\n                 else {\n-                    TxData &txd = FindRandomFrom(utxoset);\n-                    prevouthash = std::get<0>(txd).GetHash();\n+                    auto utxod = FindRandomFrom(utxoset);\n+                    prevout = utxod->first;\n \n                     // Construct the tx to spend the coins of prevouthash\n-                    tx.vin[0].prevout.hash = prevouthash;\n-                    tx.vin[0].prevout.n = 0;\n+                    tx.vin[0].prevout = prevout;\n                     assert(!CTransaction(tx).IsCoinBase());\n                 }\n                 // In this simple test coins only have two states, spent or unspent, save the unspent state to restore\n-                oldcoins = result[prevouthash];\n+                old_coin = result[prevout];\n                 // Update the expected result of prevouthash to know these coins are spent\n-                result[prevouthash].Clear();\n+                result[prevout].Clear();\n \n-                utxoset.erase(prevouthash);\n+                utxoset.erase(prevout);\n \n                 // The test is designed to ensure spending a duplicate coinbase will work properly\n                 // if that ever happens and not resurrect the previously overwritten coinbase\n-                if (duplicateids.count(prevouthash))\n+                if (duplicate_coins.count(prevout)) {\n                     spent_a_duplicate_coinbase = true;\n+                }\n \n             }\n             // Update the expected result to know about the new output coins\n-            result[tx.GetHash()].FromTx(tx, height);\n+            assert(tx.vout.size() == 1);\n+            const COutPoint outpoint(tx.GetHash(), 0);\n+            result[outpoint] = Coin(tx.vout[0], height, CTransaction(tx).IsCoinBase());\n \n             // Call UpdateCoins on the top cache\n             CTxUndo undo;\n             UpdateCoins(tx, *(stack.back()), undo, height);\n \n             // Update the utxo set for future spends\n-            utxoset.insert(tx.GetHash());\n+            utxoset.insert(outpoint);\n \n             // Track this tx and undo info to use later\n-            alltxs.insert(std::make_pair(tx.GetHash(),std::make_tuple(tx,undo,oldcoins)));\n-        }\n-\n-        //1/20 times undo a previous transaction\n-        else if (utxoset.size()) {\n-            TxData &txd = FindRandomFrom(utxoset);\n+            utxoData.emplace(outpoint, std::make_tuple(tx,undo,old_coin));\n+        } else if (utxoset.size()) {\n+            //1/20 times undo a previous transaction\n+            auto utxod = FindRandomFrom(utxoset);\n \n-            CTransaction &tx = std::get<0>(txd);\n-            CTxUndo &undo = std::get<1>(txd);\n-            CCoins &origcoins = std::get<2>(txd);\n-\n-            uint256 undohash = tx.GetHash();\n+            CTransaction &tx = std::get<0>(utxod->second);\n+            CTxUndo &undo = std::get<1>(utxod->second);\n+            Coin &orig_coin = std::get<2>(utxod->second);\n \n             // Update the expected result\n             // Remove new outputs\n-            result[undohash].Clear();\n+            result[utxod->first].Clear();\n             // If not coinbase restore prevout\n             if (!tx.IsCoinBase()) {\n-                result[tx.vin[0].prevout.hash] = origcoins;\n+                result[tx.vin[0].prevout] = orig_coin;\n             }\n \n             // Disconnect the tx from the current UTXO\n             // See code in DisconnectBlock\n             // remove outputs\n-            {\n-                CCoinsModifier outs = stack.back()->ModifyCoins(undohash);\n-                outs->Clear();\n-            }\n+            stack.back()->SpendCoin(utxod->first);\n             // restore inputs\n             if (!tx.IsCoinBase()) {\n                 const COutPoint &out = tx.vin[0].prevout;\n-                const CTxInUndo &undoin = undo.vprevout[0];\n-                ApplyTxInUndo(undoin, *(stack.back()), out);\n+                Coin coin = undo.vprevout[0];\n+                ApplyTxInUndo(std::move(coin), *(stack.back()), out);\n             }\n             // Store as a candidate for reconnection\n-            disconnectedids.insert(undohash);\n+            disconnected_coins.insert(utxod->first);\n \n             // Update the utxoset\n-            utxoset.erase(undohash);\n+            utxoset.erase(utxod->first);\n             if (!tx.IsCoinBase())\n-                utxoset.insert(tx.vin[0].prevout.hash);\n+                utxoset.insert(tx.vin[0].prevout);\n         }\n \n         // Once every 1000 iterations and at the end, verify the full cache.\n         if (insecure_rand() % 1000 == 1 || i == NUM_SIMULATION_ITERATIONS - 1) {\n-            for (std::map<uint256, CCoins>::iterator it = result.begin(); it != result.end(); it++) {\n-                const CCoins* coins = stack.back()->AccessCoins(it->first);\n-                if (coins) {\n-                    BOOST_CHECK(*coins == it->second);\n-                } else {\n-                    BOOST_CHECK(it->second.IsPruned());\n-                }\n+            for (auto it = result.begin(); it != result.end(); it++) {\n+                bool have = stack.back()->HaveCoin(it->first);\n+                const Coin& coin = stack.back()->AccessCoin(it->first);\n+                BOOST_CHECK(have == !coin.IsSpent());\n+                BOOST_CHECK(coin == it->second);\n             }\n         }\n \n+        // One every 10 iterations, remove a random entry from the cache\n+        if (utxoset.size() > 1 && insecure_rand() % 30) {\n+            stack[insecure_rand() % stack.size()]->Uncache(FindRandomFrom(utxoset)->first);\n+        }\n+        if (disconnected_coins.size() > 1 && insecure_rand() % 30) {\n+            stack[insecure_rand() % stack.size()]->Uncache(FindRandomFrom(disconnected_coins)->first);\n+        }\n+        if (duplicate_coins.size() > 1 && insecure_rand() % 30) {\n+            stack[insecure_rand() % stack.size()]->Uncache(FindRandomFrom(duplicate_coins)->first);\n+        }\n+\n         if (insecure_rand() % 100 == 0) {\n             // Every 100 iterations, flush an intermediate cache\n             if (stack.size() > 1 && insecure_rand() % 2 == 0) {\n@@ -433,53 +469,36 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n BOOST_AUTO_TEST_CASE(ccoins_serialization)\n {\n     // Good example\n-    CDataStream ss1(ParseHex(\"0104835800816115944e077fe7c803cfa57f29b36bf87c1d358bb85e\"), SER_DISK, CLIENT_VERSION);\n-    CCoins cc1;\n+    CDataStream ss1(ParseHex(\"97f23c835800816115944e077fe7c803cfa57f29b36bf87c1d35\"), SER_DISK, CLIENT_VERSION);\n+    Coin cc1;\n     ss1 >> cc1;\n-    BOOST_CHECK_EQUAL(cc1.nVersion, 1);\n     BOOST_CHECK_EQUAL(cc1.fCoinBase, false);\n     BOOST_CHECK_EQUAL(cc1.nHeight, 203998);\n-    BOOST_CHECK_EQUAL(cc1.vout.size(), 2);\n-    BOOST_CHECK_EQUAL(cc1.IsAvailable(0), false);\n-    BOOST_CHECK_EQUAL(cc1.IsAvailable(1), true);\n-    BOOST_CHECK_EQUAL(cc1.vout[1].nValue, 60000000000ULL);\n-    BOOST_CHECK_EQUAL(HexStr(cc1.vout[1].scriptPubKey), HexStr(GetScriptForDestination(CKeyID(uint160(ParseHex(\"816115944e077fe7c803cfa57f29b36bf87c1d35\"))))));\n+    BOOST_CHECK_EQUAL(cc1.out.nValue, 60000000000ULL);\n+    BOOST_CHECK_EQUAL(HexStr(cc1.out.scriptPubKey), HexStr(GetScriptForDestination(CKeyID(uint160(ParseHex(\"816115944e077fe7c803cfa57f29b36bf87c1d35\"))))));\n \n     // Good example\n-    CDataStream ss2(ParseHex(\"0109044086ef97d5790061b01caab50f1b8e9c50a5057eb43c2d9563a4eebbd123008c988f1a4a4de2161e0f50aac7f17e7f9555caa486af3b\"), SER_DISK, CLIENT_VERSION);\n-    CCoins cc2;\n+    CDataStream ss2(ParseHex(\"8ddf77bbd123008c988f1a4a4de2161e0f50aac7f17e7f9555caa4\"), SER_DISK, CLIENT_VERSION);\n+    Coin cc2;\n     ss2 >> cc2;\n-    BOOST_CHECK_EQUAL(cc2.nVersion, 1);\n     BOOST_CHECK_EQUAL(cc2.fCoinBase, true);\n     BOOST_CHECK_EQUAL(cc2.nHeight, 120891);\n-    BOOST_CHECK_EQUAL(cc2.vout.size(), 17);\n-    for (int i = 0; i < 17; i++) {\n-        BOOST_CHECK_EQUAL(cc2.IsAvailable(i), i == 4 || i == 16);\n-    }\n-    BOOST_CHECK_EQUAL(cc2.vout[4].nValue, 234925952);\n-    BOOST_CHECK_EQUAL(HexStr(cc2.vout[4].scriptPubKey), HexStr(GetScriptForDestination(CKeyID(uint160(ParseHex(\"61b01caab50f1b8e9c50a5057eb43c2d9563a4ee\"))))));\n-    BOOST_CHECK_EQUAL(cc2.vout[16].nValue, 110397);\n-    BOOST_CHECK_EQUAL(HexStr(cc2.vout[16].scriptPubKey), HexStr(GetScriptForDestination(CKeyID(uint160(ParseHex(\"8c988f1a4a4de2161e0f50aac7f17e7f9555caa4\"))))));\n+    BOOST_CHECK_EQUAL(cc2.out.nValue, 110397);\n+    BOOST_CHECK_EQUAL(HexStr(cc2.out.scriptPubKey), HexStr(GetScriptForDestination(CKeyID(uint160(ParseHex(\"8c988f1a4a4de2161e0f50aac7f17e7f9555caa4\"))))));\n \n     // Smallest possible example\n-    CDataStream ssx(SER_DISK, CLIENT_VERSION);\n-    BOOST_CHECK_EQUAL(HexStr(ssx.begin(), ssx.end()), \"\");\n-\n-    CDataStream ss3(ParseHex(\"0002000600\"), SER_DISK, CLIENT_VERSION);\n-    CCoins cc3;\n+    CDataStream ss3(ParseHex(\"000006\"), SER_DISK, CLIENT_VERSION);\n+    Coin cc3;\n     ss3 >> cc3;\n-    BOOST_CHECK_EQUAL(cc3.nVersion, 0);\n     BOOST_CHECK_EQUAL(cc3.fCoinBase, false);\n     BOOST_CHECK_EQUAL(cc3.nHeight, 0);\n-    BOOST_CHECK_EQUAL(cc3.vout.size(), 1);\n-    BOOST_CHECK_EQUAL(cc3.IsAvailable(0), true);\n-    BOOST_CHECK_EQUAL(cc3.vout[0].nValue, 0);\n-    BOOST_CHECK_EQUAL(cc3.vout[0].scriptPubKey.size(), 0);\n+    BOOST_CHECK_EQUAL(cc3.out.nValue, 0);\n+    BOOST_CHECK_EQUAL(cc3.out.scriptPubKey.size(), 0);\n \n     // scriptPubKey that ends beyond the end of the stream\n-    CDataStream ss4(ParseHex(\"0002000800\"), SER_DISK, CLIENT_VERSION);\n+    CDataStream ss4(ParseHex(\"000007\"), SER_DISK, CLIENT_VERSION);\n     try {\n-        CCoins cc4;\n+        Coin cc4;\n         ss4 >> cc4;\n         BOOST_CHECK_MESSAGE(false, \"We should have thrown\");\n     } catch (const std::ios_base::failure& e) {\n@@ -490,16 +509,16 @@ BOOST_AUTO_TEST_CASE(ccoins_serialization)\n     uint64_t x = 3000000000ULL;\n     tmp << VARINT(x);\n     BOOST_CHECK_EQUAL(HexStr(tmp.begin(), tmp.end()), \"8a95c0bb00\");\n-    CDataStream ss5(ParseHex(\"0002008a95c0bb0000\"), SER_DISK, CLIENT_VERSION);\n+    CDataStream ss5(ParseHex(\"00008a95c0bb00\"), SER_DISK, CLIENT_VERSION);\n     try {\n-        CCoins cc5;\n+        Coin cc5;\n         ss5 >> cc5;\n         BOOST_CHECK_MESSAGE(false, \"We should have thrown\");\n     } catch (const std::ios_base::failure& e) {\n     }\n }\n \n-const static uint256 TXID;\n+const static COutPoint OUTPOINT;\n const static CAmount PRUNED = -1;\n const static CAmount ABSENT = -2;\n const static CAmount FAIL = -3;\n@@ -514,15 +533,15 @@ const static auto FLAGS = {char(0), FRESH, DIRTY, char(DIRTY | FRESH)};\n const static auto CLEAN_FLAGS = {char(0), FRESH};\n const static auto ABSENT_FLAGS = {NO_ENTRY};\n \n-void SetCoinsValue(CAmount value, CCoins& coins)\n+void SetCoinsValue(CAmount value, Coin& coin)\n {\n     assert(value != ABSENT);\n-    coins.Clear();\n-    assert(coins.IsPruned());\n+    coin.Clear();\n+    assert(coin.IsSpent());\n     if (value != PRUNED) {\n-        coins.vout.emplace_back();\n-        coins.vout.back().nValue = value;\n-        assert(!coins.IsPruned());\n+        coin.out.nValue = value;\n+        coin.nHeight = 1;\n+        assert(!coin.IsSpent());\n     }\n }\n \n@@ -535,25 +554,23 @@ size_t InsertCoinsMapEntry(CCoinsMap& map, CAmount value, char flags)\n     assert(flags != NO_ENTRY);\n     CCoinsCacheEntry entry;\n     entry.flags = flags;\n-    SetCoinsValue(value, entry.coins);\n-    auto inserted = map.emplace(TXID, std::move(entry));\n+    SetCoinsValue(value, entry.coin);\n+    auto inserted = map.emplace(OUTPOINT, std::move(entry));\n     assert(inserted.second);\n-    return inserted.first->second.coins.DynamicMemoryUsage();\n+    return inserted.first->second.coin.DynamicMemoryUsage();\n }\n \n void GetCoinsMapEntry(const CCoinsMap& map, CAmount& value, char& flags)\n {\n-    auto it = map.find(TXID);\n+    auto it = map.find(OUTPOINT);\n     if (it == map.end()) {\n         value = ABSENT;\n         flags = NO_ENTRY;\n     } else {\n-        if (it->second.coins.IsPruned()) {\n-            assert(it->second.coins.vout.size() == 0);\n+        if (it->second.coin.IsSpent()) {\n             value = PRUNED;\n         } else {\n-            assert(it->second.coins.vout.size() == 1);\n-            value = it->second.coins.vout[0].nValue;\n+            value = it->second.coin.out.nValue;\n         }\n         flags = it->second.flags;\n         assert(flags != NO_ENTRY);\n@@ -581,10 +598,10 @@ class SingleEntryCacheTest\n     CCoinsViewCacheTest cache{&base};\n };\n \n-void CheckAccessCoins(CAmount base_value, CAmount cache_value, CAmount expected_value, char cache_flags, char expected_flags)\n+void CheckAccessCoin(CAmount base_value, CAmount cache_value, CAmount expected_value, char cache_flags, char expected_flags)\n {\n     SingleEntryCacheTest test(base_value, cache_value, cache_flags);\n-    test.cache.AccessCoins(TXID);\n+    test.cache.AccessCoin(OUTPOINT);\n     test.cache.SelfTest();\n \n     CAmount result_value;\n@@ -603,39 +620,39 @@ BOOST_AUTO_TEST_CASE(ccoins_access)\n      *               Base    Cache   Result  Cache        Result\n      *               Value   Value   Value   Flags        Flags\n      */\n-    CheckAccessCoins(ABSENT, ABSENT, ABSENT, NO_ENTRY   , NO_ENTRY   );\n-    CheckAccessCoins(ABSENT, PRUNED, PRUNED, 0          , 0          );\n-    CheckAccessCoins(ABSENT, PRUNED, PRUNED, FRESH      , FRESH      );\n-    CheckAccessCoins(ABSENT, PRUNED, PRUNED, DIRTY      , DIRTY      );\n-    CheckAccessCoins(ABSENT, PRUNED, PRUNED, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckAccessCoins(ABSENT, VALUE2, VALUE2, 0          , 0          );\n-    CheckAccessCoins(ABSENT, VALUE2, VALUE2, FRESH      , FRESH      );\n-    CheckAccessCoins(ABSENT, VALUE2, VALUE2, DIRTY      , DIRTY      );\n-    CheckAccessCoins(ABSENT, VALUE2, VALUE2, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckAccessCoins(PRUNED, ABSENT, PRUNED, NO_ENTRY   , FRESH      );\n-    CheckAccessCoins(PRUNED, PRUNED, PRUNED, 0          , 0          );\n-    CheckAccessCoins(PRUNED, PRUNED, PRUNED, FRESH      , FRESH      );\n-    CheckAccessCoins(PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      );\n-    CheckAccessCoins(PRUNED, PRUNED, PRUNED, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckAccessCoins(PRUNED, VALUE2, VALUE2, 0          , 0          );\n-    CheckAccessCoins(PRUNED, VALUE2, VALUE2, FRESH      , FRESH      );\n-    CheckAccessCoins(PRUNED, VALUE2, VALUE2, DIRTY      , DIRTY      );\n-    CheckAccessCoins(PRUNED, VALUE2, VALUE2, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckAccessCoins(VALUE1, ABSENT, VALUE1, NO_ENTRY   , 0          );\n-    CheckAccessCoins(VALUE1, PRUNED, PRUNED, 0          , 0          );\n-    CheckAccessCoins(VALUE1, PRUNED, PRUNED, FRESH      , FRESH      );\n-    CheckAccessCoins(VALUE1, PRUNED, PRUNED, DIRTY      , DIRTY      );\n-    CheckAccessCoins(VALUE1, PRUNED, PRUNED, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckAccessCoins(VALUE1, VALUE2, VALUE2, 0          , 0          );\n-    CheckAccessCoins(VALUE1, VALUE2, VALUE2, FRESH      , FRESH      );\n-    CheckAccessCoins(VALUE1, VALUE2, VALUE2, DIRTY      , DIRTY      );\n-    CheckAccessCoins(VALUE1, VALUE2, VALUE2, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckAccessCoin(ABSENT, ABSENT, ABSENT, NO_ENTRY   , NO_ENTRY   );\n+    CheckAccessCoin(ABSENT, PRUNED, PRUNED, 0          , 0          );\n+    CheckAccessCoin(ABSENT, PRUNED, PRUNED, FRESH      , FRESH      );\n+    CheckAccessCoin(ABSENT, PRUNED, PRUNED, DIRTY      , DIRTY      );\n+    CheckAccessCoin(ABSENT, PRUNED, PRUNED, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckAccessCoin(ABSENT, VALUE2, VALUE2, 0          , 0          );\n+    CheckAccessCoin(ABSENT, VALUE2, VALUE2, FRESH      , FRESH      );\n+    CheckAccessCoin(ABSENT, VALUE2, VALUE2, DIRTY      , DIRTY      );\n+    CheckAccessCoin(ABSENT, VALUE2, VALUE2, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckAccessCoin(PRUNED, ABSENT, PRUNED, NO_ENTRY   , FRESH      );\n+    CheckAccessCoin(PRUNED, PRUNED, PRUNED, 0          , 0          );\n+    CheckAccessCoin(PRUNED, PRUNED, PRUNED, FRESH      , FRESH      );\n+    CheckAccessCoin(PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      );\n+    CheckAccessCoin(PRUNED, PRUNED, PRUNED, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckAccessCoin(PRUNED, VALUE2, VALUE2, 0          , 0          );\n+    CheckAccessCoin(PRUNED, VALUE2, VALUE2, FRESH      , FRESH      );\n+    CheckAccessCoin(PRUNED, VALUE2, VALUE2, DIRTY      , DIRTY      );\n+    CheckAccessCoin(PRUNED, VALUE2, VALUE2, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckAccessCoin(VALUE1, ABSENT, VALUE1, NO_ENTRY   , 0          );\n+    CheckAccessCoin(VALUE1, PRUNED, PRUNED, 0          , 0          );\n+    CheckAccessCoin(VALUE1, PRUNED, PRUNED, FRESH      , FRESH      );\n+    CheckAccessCoin(VALUE1, PRUNED, PRUNED, DIRTY      , DIRTY      );\n+    CheckAccessCoin(VALUE1, PRUNED, PRUNED, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckAccessCoin(VALUE1, VALUE2, VALUE2, 0          , 0          );\n+    CheckAccessCoin(VALUE1, VALUE2, VALUE2, FRESH      , FRESH      );\n+    CheckAccessCoin(VALUE1, VALUE2, VALUE2, DIRTY      , DIRTY      );\n+    CheckAccessCoin(VALUE1, VALUE2, VALUE2, DIRTY|FRESH, DIRTY|FRESH);\n }\n \n-void CheckModifyCoins(CAmount base_value, CAmount cache_value, CAmount modify_value, CAmount expected_value, char cache_flags, char expected_flags)\n+void CheckSpendCoins(CAmount base_value, CAmount cache_value, CAmount expected_value, char cache_flags, char expected_flags)\n {\n     SingleEntryCacheTest test(base_value, cache_value, cache_flags);\n-    SetCoinsValue(modify_value, *test.cache.ModifyCoins(TXID));\n+    test.cache.SpendCoin(OUTPOINT);\n     test.cache.SelfTest();\n \n     CAmount result_value;\n@@ -645,79 +662,55 @@ void CheckModifyCoins(CAmount base_value, CAmount cache_value, CAmount modify_va\n     BOOST_CHECK_EQUAL(result_flags, expected_flags);\n };\n \n-BOOST_AUTO_TEST_CASE(ccoins_modify)\n+BOOST_AUTO_TEST_CASE(ccoins_spend)\n {\n-    /* Check ModifyCoin behavior, requesting a coin from a cache view layered on\n-     * top of a base view, writing a modification to the coin, and then checking\n+    /* Check SpendCoin behavior, requesting a coin from a cache view layered on\n+     * top of a base view, spending, and then checking\n      * the resulting entry in the cache after the modification.\n      *\n-     *               Base    Cache   Write   Result  Cache        Result\n-     *               Value   Value   Value   Value   Flags        Flags\n+     *              Base    Cache   Result  Cache        Result\n+     *              Value   Value   Value   Flags        Flags\n      */\n-    CheckModifyCoins(ABSENT, ABSENT, PRUNED, ABSENT, NO_ENTRY   , NO_ENTRY   );\n-    CheckModifyCoins(ABSENT, ABSENT, VALUE3, VALUE3, NO_ENTRY   , DIRTY|FRESH);\n-    CheckModifyCoins(ABSENT, PRUNED, PRUNED, PRUNED, 0          , DIRTY      );\n-    CheckModifyCoins(ABSENT, PRUNED, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n-    CheckModifyCoins(ABSENT, PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      );\n-    CheckModifyCoins(ABSENT, PRUNED, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n-    CheckModifyCoins(ABSENT, PRUNED, VALUE3, VALUE3, 0          , DIRTY      );\n-    CheckModifyCoins(ABSENT, PRUNED, VALUE3, VALUE3, FRESH      , DIRTY|FRESH);\n-    CheckModifyCoins(ABSENT, PRUNED, VALUE3, VALUE3, DIRTY      , DIRTY      );\n-    CheckModifyCoins(ABSENT, PRUNED, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckModifyCoins(ABSENT, VALUE2, PRUNED, PRUNED, 0          , DIRTY      );\n-    CheckModifyCoins(ABSENT, VALUE2, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n-    CheckModifyCoins(ABSENT, VALUE2, PRUNED, PRUNED, DIRTY      , DIRTY      );\n-    CheckModifyCoins(ABSENT, VALUE2, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n-    CheckModifyCoins(ABSENT, VALUE2, VALUE3, VALUE3, 0          , DIRTY      );\n-    CheckModifyCoins(ABSENT, VALUE2, VALUE3, VALUE3, FRESH      , DIRTY|FRESH);\n-    CheckModifyCoins(ABSENT, VALUE2, VALUE3, VALUE3, DIRTY      , DIRTY      );\n-    CheckModifyCoins(ABSENT, VALUE2, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckModifyCoins(PRUNED, ABSENT, PRUNED, ABSENT, NO_ENTRY   , NO_ENTRY   );\n-    CheckModifyCoins(PRUNED, ABSENT, VALUE3, VALUE3, NO_ENTRY   , DIRTY|FRESH);\n-    CheckModifyCoins(PRUNED, PRUNED, PRUNED, PRUNED, 0          , DIRTY      );\n-    CheckModifyCoins(PRUNED, PRUNED, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n-    CheckModifyCoins(PRUNED, PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      );\n-    CheckModifyCoins(PRUNED, PRUNED, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n-    CheckModifyCoins(PRUNED, PRUNED, VALUE3, VALUE3, 0          , DIRTY      );\n-    CheckModifyCoins(PRUNED, PRUNED, VALUE3, VALUE3, FRESH      , DIRTY|FRESH);\n-    CheckModifyCoins(PRUNED, PRUNED, VALUE3, VALUE3, DIRTY      , DIRTY      );\n-    CheckModifyCoins(PRUNED, PRUNED, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckModifyCoins(PRUNED, VALUE2, PRUNED, PRUNED, 0          , DIRTY      );\n-    CheckModifyCoins(PRUNED, VALUE2, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n-    CheckModifyCoins(PRUNED, VALUE2, PRUNED, PRUNED, DIRTY      , DIRTY      );\n-    CheckModifyCoins(PRUNED, VALUE2, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n-    CheckModifyCoins(PRUNED, VALUE2, VALUE3, VALUE3, 0          , DIRTY      );\n-    CheckModifyCoins(PRUNED, VALUE2, VALUE3, VALUE3, FRESH      , DIRTY|FRESH);\n-    CheckModifyCoins(PRUNED, VALUE2, VALUE3, VALUE3, DIRTY      , DIRTY      );\n-    CheckModifyCoins(PRUNED, VALUE2, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckModifyCoins(VALUE1, ABSENT, PRUNED, PRUNED, NO_ENTRY   , DIRTY      );\n-    CheckModifyCoins(VALUE1, ABSENT, VALUE3, VALUE3, NO_ENTRY   , DIRTY      );\n-    CheckModifyCoins(VALUE1, PRUNED, PRUNED, PRUNED, 0          , DIRTY      );\n-    CheckModifyCoins(VALUE1, PRUNED, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n-    CheckModifyCoins(VALUE1, PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      );\n-    CheckModifyCoins(VALUE1, PRUNED, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n-    CheckModifyCoins(VALUE1, PRUNED, VALUE3, VALUE3, 0          , DIRTY      );\n-    CheckModifyCoins(VALUE1, PRUNED, VALUE3, VALUE3, FRESH      , DIRTY|FRESH);\n-    CheckModifyCoins(VALUE1, PRUNED, VALUE3, VALUE3, DIRTY      , DIRTY      );\n-    CheckModifyCoins(VALUE1, PRUNED, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckModifyCoins(VALUE1, VALUE2, PRUNED, PRUNED, 0          , DIRTY      );\n-    CheckModifyCoins(VALUE1, VALUE2, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n-    CheckModifyCoins(VALUE1, VALUE2, PRUNED, PRUNED, DIRTY      , DIRTY      );\n-    CheckModifyCoins(VALUE1, VALUE2, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n-    CheckModifyCoins(VALUE1, VALUE2, VALUE3, VALUE3, 0          , DIRTY      );\n-    CheckModifyCoins(VALUE1, VALUE2, VALUE3, VALUE3, FRESH      , DIRTY|FRESH);\n-    CheckModifyCoins(VALUE1, VALUE2, VALUE3, VALUE3, DIRTY      , DIRTY      );\n-    CheckModifyCoins(VALUE1, VALUE2, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckSpendCoins(ABSENT, ABSENT, ABSENT, NO_ENTRY   , NO_ENTRY   );\n+    CheckSpendCoins(ABSENT, PRUNED, PRUNED, 0          , DIRTY      );\n+    CheckSpendCoins(ABSENT, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n+    CheckSpendCoins(ABSENT, PRUNED, PRUNED, DIRTY      , DIRTY      );\n+    CheckSpendCoins(ABSENT, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n+    CheckSpendCoins(ABSENT, VALUE2, PRUNED, 0          , DIRTY      );\n+    CheckSpendCoins(ABSENT, VALUE2, ABSENT, FRESH      , NO_ENTRY   );\n+    CheckSpendCoins(ABSENT, VALUE2, PRUNED, DIRTY      , DIRTY      );\n+    CheckSpendCoins(ABSENT, VALUE2, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n+    CheckSpendCoins(PRUNED, ABSENT, ABSENT, NO_ENTRY   , NO_ENTRY   );\n+    CheckSpendCoins(PRUNED, PRUNED, PRUNED, 0          , DIRTY      );\n+    CheckSpendCoins(PRUNED, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n+    CheckSpendCoins(PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      );\n+    CheckSpendCoins(PRUNED, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n+    CheckSpendCoins(PRUNED, VALUE2, PRUNED, 0          , DIRTY      );\n+    CheckSpendCoins(PRUNED, VALUE2, ABSENT, FRESH      , NO_ENTRY   );\n+    CheckSpendCoins(PRUNED, VALUE2, PRUNED, DIRTY      , DIRTY      );\n+    CheckSpendCoins(PRUNED, VALUE2, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n+    CheckSpendCoins(VALUE1, ABSENT, PRUNED, NO_ENTRY   , DIRTY      );\n+    CheckSpendCoins(VALUE1, PRUNED, PRUNED, 0          , DIRTY      );\n+    CheckSpendCoins(VALUE1, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n+    CheckSpendCoins(VALUE1, PRUNED, PRUNED, DIRTY      , DIRTY      );\n+    CheckSpendCoins(VALUE1, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n+    CheckSpendCoins(VALUE1, VALUE2, PRUNED, 0          , DIRTY      );\n+    CheckSpendCoins(VALUE1, VALUE2, ABSENT, FRESH      , NO_ENTRY   );\n+    CheckSpendCoins(VALUE1, VALUE2, PRUNED, DIRTY      , DIRTY      );\n+    CheckSpendCoins(VALUE1, VALUE2, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n }\n \n-void CheckModifyNewCoinsBase(CAmount base_value, CAmount cache_value, CAmount modify_value, CAmount expected_value, char cache_flags, char expected_flags, bool coinbase)\n+void CheckAddCoinBase(CAmount base_value, CAmount cache_value, CAmount modify_value, CAmount expected_value, char cache_flags, char expected_flags, bool coinbase)\n {\n     SingleEntryCacheTest test(base_value, cache_value, cache_flags);\n \n     CAmount result_value;\n     char result_flags;\n     try {\n-        SetCoinsValue(modify_value, *test.cache.ModifyNewCoins(TXID, coinbase));\n+        CTxOut output;\n+        output.nValue = modify_value;\n+        test.cache.AddCoin(OUTPOINT, Coin(std::move(output), 1, coinbase), coinbase);\n+        test.cache.SelfTest();\n         GetCoinsMapEntry(test.cache.map(), result_value, result_flags);\n     } catch (std::logic_error& e) {\n         result_value = FAIL;\n@@ -728,64 +721,46 @@ void CheckModifyNewCoinsBase(CAmount base_value, CAmount cache_value, CAmount mo\n     BOOST_CHECK_EQUAL(result_flags, expected_flags);\n }\n \n-// Simple wrapper for CheckModifyNewCoinsBase function above that loops through\n+// Simple wrapper for CheckAddCoinBase function above that loops through\n // different possible base_values, making sure each one gives the same results.\n-// This wrapper lets the modify_new test below be shorter and less repetitive,\n-// while still verifying that the CoinsViewCache::ModifyNewCoins implementation\n+// This wrapper lets the coins_add test below be shorter and less repetitive,\n+// while still verifying that the CoinsViewCache::AddCoin implementation\n // ignores base values.\n template <typename... Args>\n-void CheckModifyNewCoins(Args&&... args)\n+void CheckAddCoin(Args&&... args)\n {\n     for (CAmount base_value : {ABSENT, PRUNED, VALUE1})\n-        CheckModifyNewCoinsBase(base_value, std::forward<Args>(args)...);\n+        CheckAddCoinBase(base_value, std::forward<Args>(args)...);\n }\n \n-BOOST_AUTO_TEST_CASE(ccoins_modify_new)\n+BOOST_AUTO_TEST_CASE(ccoins_add)\n {\n-    /* Check ModifyNewCoin behavior, requesting a new coin from a cache view,\n+    /* Check AddCoin behavior, requesting a new coin from a cache view,\n      * writing a modification to the coin, and then checking the resulting\n      * entry in the cache after the modification. Verify behavior with the\n-     * with the ModifyNewCoin coinbase argument set to false, and to true.\n+     * with the AddCoin potential_overwrite argument set to false, and to true.\n      *\n-     *                  Cache   Write   Result  Cache        Result     Coinbase\n-     *                  Value   Value   Value   Flags        Flags\n+     *           Cache   Write   Result  Cache        Result       potential_overwrite\n+     *           Value   Value   Value   Flags        Flags\n      */\n-    CheckModifyNewCoins(ABSENT, PRUNED, ABSENT, NO_ENTRY   , NO_ENTRY   , false);\n-    CheckModifyNewCoins(ABSENT, PRUNED, PRUNED, NO_ENTRY   , DIRTY      , true );\n-    CheckModifyNewCoins(ABSENT, VALUE3, VALUE3, NO_ENTRY   , DIRTY|FRESH, false);\n-    CheckModifyNewCoins(ABSENT, VALUE3, VALUE3, NO_ENTRY   , DIRTY      , true );\n-    CheckModifyNewCoins(PRUNED, PRUNED, ABSENT, 0          , NO_ENTRY   , false);\n-    CheckModifyNewCoins(PRUNED, PRUNED, PRUNED, 0          , DIRTY      , true );\n-    CheckModifyNewCoins(PRUNED, PRUNED, ABSENT, FRESH      , NO_ENTRY   , false);\n-    CheckModifyNewCoins(PRUNED, PRUNED, ABSENT, FRESH      , NO_ENTRY   , true );\n-    CheckModifyNewCoins(PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      , false);\n-    CheckModifyNewCoins(PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      , true );\n-    CheckModifyNewCoins(PRUNED, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   , false);\n-    CheckModifyNewCoins(PRUNED, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   , true );\n-    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, 0          , DIRTY|FRESH, false);\n-    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, 0          , DIRTY      , true );\n-    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, FRESH      , DIRTY|FRESH, false);\n-    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, FRESH      , DIRTY|FRESH, true );\n-    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, DIRTY      , DIRTY      , false);\n-    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, DIRTY      , DIRTY      , true );\n-    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH, false);\n-    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH, true );\n-    CheckModifyNewCoins(VALUE2, PRUNED, FAIL  , 0          , NO_ENTRY   , false);\n-    CheckModifyNewCoins(VALUE2, PRUNED, PRUNED, 0          , DIRTY      , true );\n-    CheckModifyNewCoins(VALUE2, PRUNED, FAIL  , FRESH      , NO_ENTRY   , false);\n-    CheckModifyNewCoins(VALUE2, PRUNED, ABSENT, FRESH      , NO_ENTRY   , true );\n-    CheckModifyNewCoins(VALUE2, PRUNED, FAIL  , DIRTY      , NO_ENTRY   , false);\n-    CheckModifyNewCoins(VALUE2, PRUNED, PRUNED, DIRTY      , DIRTY      , true );\n-    CheckModifyNewCoins(VALUE2, PRUNED, FAIL  , DIRTY|FRESH, NO_ENTRY   , false);\n-    CheckModifyNewCoins(VALUE2, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   , true );\n-    CheckModifyNewCoins(VALUE2, VALUE3, FAIL  , 0          , NO_ENTRY   , false);\n-    CheckModifyNewCoins(VALUE2, VALUE3, VALUE3, 0          , DIRTY      , true );\n-    CheckModifyNewCoins(VALUE2, VALUE3, FAIL  , FRESH      , NO_ENTRY   , false);\n-    CheckModifyNewCoins(VALUE2, VALUE3, VALUE3, FRESH      , DIRTY|FRESH, true );\n-    CheckModifyNewCoins(VALUE2, VALUE3, FAIL  , DIRTY      , NO_ENTRY   , false);\n-    CheckModifyNewCoins(VALUE2, VALUE3, VALUE3, DIRTY      , DIRTY      , true );\n-    CheckModifyNewCoins(VALUE2, VALUE3, FAIL  , DIRTY|FRESH, NO_ENTRY   , false);\n-    CheckModifyNewCoins(VALUE2, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH, true );\n+    CheckAddCoin(ABSENT, VALUE3, VALUE3, NO_ENTRY   , DIRTY|FRESH, false);\n+    CheckAddCoin(ABSENT, VALUE3, VALUE3, NO_ENTRY   , DIRTY      , true );\n+    CheckAddCoin(PRUNED, VALUE3, VALUE3, 0          , DIRTY|FRESH, false);\n+    CheckAddCoin(PRUNED, VALUE3, VALUE3, 0          , DIRTY      , true );\n+    CheckAddCoin(PRUNED, VALUE3, VALUE3, FRESH      , DIRTY|FRESH, false);\n+    CheckAddCoin(PRUNED, VALUE3, VALUE3, FRESH      , DIRTY|FRESH, true );\n+    CheckAddCoin(PRUNED, VALUE3, VALUE3, DIRTY      , DIRTY      , false);\n+    CheckAddCoin(PRUNED, VALUE3, VALUE3, DIRTY      , DIRTY      , true );\n+    CheckAddCoin(PRUNED, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH, false);\n+    CheckAddCoin(PRUNED, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH, true );\n+    CheckAddCoin(VALUE2, VALUE3, FAIL  , 0          , NO_ENTRY   , false);\n+    CheckAddCoin(VALUE2, VALUE3, VALUE3, 0          , DIRTY      , true );\n+    CheckAddCoin(VALUE2, VALUE3, FAIL  , FRESH      , NO_ENTRY   , false);\n+    CheckAddCoin(VALUE2, VALUE3, VALUE3, FRESH      , DIRTY|FRESH, true );\n+    CheckAddCoin(VALUE2, VALUE3, FAIL  , DIRTY      , NO_ENTRY   , false);\n+    CheckAddCoin(VALUE2, VALUE3, VALUE3, DIRTY      , DIRTY      , true );\n+    CheckAddCoin(VALUE2, VALUE3, FAIL  , DIRTY|FRESH, NO_ENTRY   , false);\n+    CheckAddCoin(VALUE2, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH, true );\n }\n \n void CheckWriteCoins(CAmount parent_value, CAmount child_value, CAmount expected_value, char parent_flags, char child_flags, char expected_flags)"
      },
      {
        "sha": "bb7e473248777f153d298bef3472d407b9ce18a9",
        "filename": "src/test/hash_tests.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/test/hash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/test/hash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/hash_tests.cpp?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -128,6 +128,23 @@ BOOST_AUTO_TEST_CASE(siphash)\n     tx.nVersion = 1;\n     ss << tx;\n     BOOST_CHECK_EQUAL(SipHashUint256(1, 2, ss.GetHash()), 0x79751e980c2a0a35ULL);\n+\n+    // Check consistency between CSipHasher and SipHashUint256[Extra].\n+    FastRandomContext ctx;\n+    for (int i = 0; i < 16; ++i) {\n+        uint64_t k1 = ctx.rand64();\n+        uint64_t k2 = ctx.rand64();\n+        uint256 x = GetRandHash();\n+        uint32_t n = ctx.rand32();\n+        uint8_t nb[4];\n+        WriteLE32(nb, n);\n+        CSipHasher sip256(k1, k2);\n+        sip256.Write(x.begin(), 32);\n+        CSipHasher sip288 = sip256;\n+        sip288.Write(nb, 4);\n+        BOOST_CHECK_EQUAL(SipHashUint256(k1, k2, x), sip256.Finalize());\n+        BOOST_CHECK_EQUAL(SipHashUint256Extra(k1, k2, x, n), sip288.Finalize());\n+    }\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "0789b2e80cacdf2c044c5b3c133500273ccda6dc",
        "filename": "src/test/script_P2SH_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/test/script_P2SH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/test/script_P2SH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2SH_tests.cpp?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -112,7 +112,8 @@ BOOST_AUTO_TEST_CASE(sign)\n         {\n             CScript sigSave = txTo[i].vin[0].scriptSig;\n             txTo[i].vin[0].scriptSig = txTo[j].vin[0].scriptSig;\n-            bool sigOK = CScriptCheck(CCoins(txFrom, 0), txTo[i], 0, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC, false, &txdata)();\n+            const CTxOut& output = txFrom.vout[txTo[i].vin[0].prevout.n];\n+            bool sigOK = CScriptCheck(output.scriptPubKey, output.nValue, txTo[i], 0, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC, false, &txdata)();\n             if (i == j)\n                 BOOST_CHECK_MESSAGE(sigOK, strprintf(\"VerifySignature %d %d\", i, j));\n             else\n@@ -316,7 +317,7 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     txFrom.vout[6].scriptPubKey = GetScriptForDestination(CScriptID(twentySigops));\n     txFrom.vout[6].nValue = 6000;\n \n-    coins.ModifyCoins(txFrom.GetHash())->FromTx(txFrom, 0);\n+    AddCoins(coins, txFrom, 0);\n \n     CMutableTransaction txTo;\n     txTo.vout.resize(1);"
      },
      {
        "sha": "4e117448fe2acd9e5abe3ebb0818213d40cadb86",
        "filename": "src/test/sigopcount_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/test/sigopcount_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/test/sigopcount_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sigopcount_tests.cpp?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -102,7 +102,7 @@ void BuildTxs(CMutableTransaction& spendingTx, CCoinsViewCache& coins, CMutableT\n     spendingTx.vout[0].nValue = 1;\n     spendingTx.vout[0].scriptPubKey = CScript();\n \n-    coins.ModifyCoins(creationTx.GetHash())->FromTx(creationTx, 0);\n+    AddCoins(coins, creationTx, 0);\n }\n \n BOOST_AUTO_TEST_CASE(GetTxSigOpCost)"
      },
      {
        "sha": "de14251601377956cb368634d22f48f54a5a1832",
        "filename": "src/test/test_bitcoin_fuzzy.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/test/test_bitcoin_fuzzy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/test/test_bitcoin_fuzzy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin_fuzzy.cpp?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -168,8 +168,8 @@ int do_fuzz()\n         {\n             try\n             {\n-                CCoins block;\n-                ds >> block;\n+                Coin coin;\n+                ds >> coin;\n             } catch (const std::ios_base::failure& e) {return 0;}\n             break;\n         }"
      },
      {
        "sha": "5c7516fbf1c2385504f435fcdcdf797796f0e82f",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 10,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -307,14 +307,14 @@ SetupDummyInputs(CBasicKeyStore& keystoreRet, CCoinsViewCache& coinsRet)\n     dummyTransactions[0].vout[0].scriptPubKey << ToByteVector(key[0].GetPubKey()) << OP_CHECKSIG;\n     dummyTransactions[0].vout[1].nValue = 50*CENT;\n     dummyTransactions[0].vout[1].scriptPubKey << ToByteVector(key[1].GetPubKey()) << OP_CHECKSIG;\n-    coinsRet.ModifyCoins(dummyTransactions[0].GetHash())->FromTx(dummyTransactions[0], 0);\n+    AddCoins(coinsRet, dummyTransactions[0], 0);\n \n     dummyTransactions[1].vout.resize(2);\n     dummyTransactions[1].vout[0].nValue = 21*CENT;\n     dummyTransactions[1].vout[0].scriptPubKey = GetScriptForDestination(key[2].GetPubKey().GetID());\n     dummyTransactions[1].vout[1].nValue = 22*CENT;\n     dummyTransactions[1].vout[1].scriptPubKey = GetScriptForDestination(key[3].GetPubKey().GetID());\n-    coinsRet.ModifyCoins(dummyTransactions[1].GetHash())->FromTx(dummyTransactions[1], 0);\n+    AddCoins(coinsRet, dummyTransactions[1], 0);\n \n     return dummyTransactions;\n }\n@@ -470,19 +470,20 @@ BOOST_AUTO_TEST_CASE(test_big_witness_transaction) {\n     for (int i=0; i<20; i++)\n         threadGroup.create_thread(boost::bind(&CCheckQueue<CScriptCheck>::Thread, boost::ref(scriptcheckqueue)));\n \n-    CCoins coins;\n-    coins.nVersion = 1;\n-    coins.fCoinBase = false;\n+    std::vector<Coin> coins;\n     for(uint32_t i = 0; i < mtx.vin.size(); i++) {\n-        CTxOut txout;\n-        txout.nValue = 1000;\n-        txout.scriptPubKey = scriptPubKey;\n-        coins.vout.push_back(txout);\n+        Coin coin;\n+        coin.nHeight = 1;\n+        coin.fCoinBase = false;\n+        coin.out.nValue = 1000;\n+        coin.out.scriptPubKey = scriptPubKey;\n+        coins.emplace_back(std::move(coin));\n     }\n \n     for(uint32_t i = 0; i < mtx.vin.size(); i++) {\n         std::vector<CScriptCheck> vChecks;\n-        CScriptCheck check(coins, tx, i, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false, &txdata);\n+        const CTxOut& output = coins[tx.vin[i].prevout.n].out;\n+        CScriptCheck check(output.scriptPubKey, output.nValue, tx, i, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false, &txdata);\n         vChecks.push_back(CScriptCheck());\n         check.swap(vChecks.back());\n         control.Add(vChecks);"
      },
      {
        "sha": "c8f509029324e7da3fd3d4a572401414908956a9",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 154,
        "deletions": 17,
        "changes": 171,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -14,6 +14,7 @@\n \n #include <boost/thread.hpp>\n \n+static const char DB_COIN = 'C';\n static const char DB_COINS = 'c';\n static const char DB_BLOCK_FILES = 'f';\n static const char DB_TXINDEX = 't';\n@@ -24,17 +25,40 @@ static const char DB_FLAG = 'F';\n static const char DB_REINDEX_FLAG = 'R';\n static const char DB_LAST_BLOCK = 'l';\n \n+namespace {\n+\n+struct CoinEntry {\n+    COutPoint* outpoint;\n+    char key;\n+    CoinEntry(const COutPoint* ptr) : outpoint(const_cast<COutPoint*>(ptr)), key(DB_COIN)  {}\n+\n+    template<typename Stream>\n+    void Serialize(Stream &s) const {\n+        s << key;\n+        s << outpoint->hash;\n+        s << VARINT(outpoint->n);\n+    }\n+\n+    template<typename Stream>\n+    void Unserialize(Stream& s) {\n+        s >> key;\n+        s >> outpoint->hash;\n+        s >> VARINT(outpoint->n);\n+    }\n+};\n+\n+}\n \n CCoinsViewDB::CCoinsViewDB(size_t nCacheSize, bool fMemory, bool fWipe) : db(GetDataDir() / \"chainstate\", nCacheSize, fMemory, fWipe, true) \n {\n }\n \n-bool CCoinsViewDB::GetCoins(const uint256 &txid, CCoins &coins) const {\n-    return db.Read(std::make_pair(DB_COINS, txid), coins);\n+bool CCoinsViewDB::GetCoin(const COutPoint &outpoint, Coin &coin) const {\n+    return db.Read(CoinEntry(&outpoint), coin);\n }\n \n-bool CCoinsViewDB::HaveCoins(const uint256 &txid) const {\n-    return db.Exists(std::make_pair(DB_COINS, txid));\n+bool CCoinsViewDB::HaveCoin(const COutPoint &outpoint) const {\n+    return db.Exists(CoinEntry(&outpoint));\n }\n \n uint256 CCoinsViewDB::GetBestBlock() const {\n@@ -50,10 +74,11 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n     size_t changed = 0;\n     for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end();) {\n         if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n-            if (it->second.coins.IsPruned())\n-                batch.Erase(std::make_pair(DB_COINS, it->first));\n+            CoinEntry entry(&it->first);\n+            if (it->second.coin.IsSpent())\n+                batch.Erase(entry);\n             else\n-                batch.Write(std::make_pair(DB_COINS, it->first), it->second.coins);\n+                batch.Write(entry, it->second.coin);\n             changed++;\n         }\n         count++;\n@@ -63,8 +88,14 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n     if (!hashBlock.IsNull())\n         batch.Write(DB_BEST_BLOCK, hashBlock);\n \n-    LogPrint(BCLog::COINDB, \"Committing %u changed transactions (out of %u) to coin database...\\n\", (unsigned int)changed, (unsigned int)count);\n-    return db.WriteBatch(batch);\n+    bool ret = db.WriteBatch(batch);\n+    LogPrint(BCLog::COINDB, \"Committed %u changed transaction outputs (out of %u) to coin database...\\n\", (unsigned int)changed, (unsigned int)count);\n+    return ret;\n+}\n+\n+size_t CCoinsViewDB::EstimateSize() const\n+{\n+    return db.EstimateSize(DB_COIN, (char)(DB_COIN+1));\n }\n \n CBlockTreeDB::CBlockTreeDB(size_t nCacheSize, bool fMemory, bool fWipe) : CDBWrapper(GetDataDir() / \"blocks\" / \"index\", nCacheSize, fMemory, fWipe) {\n@@ -96,29 +127,31 @@ CCoinsViewCursor *CCoinsViewDB::Cursor() const\n     /* It seems that there are no \"const iterators\" for LevelDB.  Since we\n        only need read operations on it, use a const-cast to get around\n        that restriction.  */\n-    i->pcursor->Seek(DB_COINS);\n+    i->pcursor->Seek(DB_COIN);\n     // Cache key of first record\n     if (i->pcursor->Valid()) {\n-        i->pcursor->GetKey(i->keyTmp);\n+        CoinEntry entry(&i->keyTmp.second);\n+        i->pcursor->GetKey(entry);\n+        i->keyTmp.first = entry.key;\n     } else {\n         i->keyTmp.first = 0; // Make sure Valid() and GetKey() return false\n     }\n     return i;\n }\n \n-bool CCoinsViewDBCursor::GetKey(uint256 &key) const\n+bool CCoinsViewDBCursor::GetKey(COutPoint &key) const\n {\n     // Return cached key\n-    if (keyTmp.first == DB_COINS) {\n+    if (keyTmp.first == DB_COIN) {\n         key = keyTmp.second;\n         return true;\n     }\n     return false;\n }\n \n-bool CCoinsViewDBCursor::GetValue(CCoins &coins) const\n+bool CCoinsViewDBCursor::GetValue(Coin &coin) const\n {\n-    return pcursor->GetValue(coins);\n+    return pcursor->GetValue(coin);\n }\n \n unsigned int CCoinsViewDBCursor::GetValueSize() const\n@@ -128,14 +161,18 @@ unsigned int CCoinsViewDBCursor::GetValueSize() const\n \n bool CCoinsViewDBCursor::Valid() const\n {\n-    return keyTmp.first == DB_COINS;\n+    return keyTmp.first == DB_COIN;\n }\n \n void CCoinsViewDBCursor::Next()\n {\n     pcursor->Next();\n-    if (!pcursor->Valid() || !pcursor->GetKey(keyTmp))\n+    CoinEntry entry(&keyTmp.second);\n+    if (!pcursor->Valid() || !pcursor->GetKey(entry)) {\n         keyTmp.first = 0; // Invalidate cached key after last record so that Valid() and GetKey() return false\n+    } else {\n+        keyTmp.first = entry.key;\n+    }\n }\n \n bool CBlockTreeDB::WriteBatchSync(const std::vector<std::pair<int, const CBlockFileInfo*> >& fileInfo, int nLastFile, const std::vector<const CBlockIndex*>& blockinfo) {\n@@ -215,3 +252,103 @@ bool CBlockTreeDB::LoadBlockIndexGuts(std::function<CBlockIndex*(const uint256&)\n \n     return true;\n }\n+\n+namespace {\n+\n+//! Legacy class to deserialize pre-pertxout database entries without reindex.\n+class CCoins\n+{\n+public:\n+    //! whether transaction is a coinbase\n+    bool fCoinBase;\n+\n+    //! unspent transaction outputs; spent outputs are .IsNull(); spent outputs at the end of the array are dropped\n+    std::vector<CTxOut> vout;\n+\n+    //! at which height this transaction was included in the active block chain\n+    int nHeight;\n+\n+    //! empty constructor\n+    CCoins() : fCoinBase(false), vout(0), nHeight(0) { }\n+\n+    template<typename Stream>\n+    void Unserialize(Stream &s) {\n+        unsigned int nCode = 0;\n+        // version\n+        int nVersionDummy;\n+        ::Unserialize(s, VARINT(nVersionDummy));\n+        // header code\n+        ::Unserialize(s, VARINT(nCode));\n+        fCoinBase = nCode & 1;\n+        std::vector<bool> vAvail(2, false);\n+        vAvail[0] = (nCode & 2) != 0;\n+        vAvail[1] = (nCode & 4) != 0;\n+        unsigned int nMaskCode = (nCode / 8) + ((nCode & 6) != 0 ? 0 : 1);\n+        // spentness bitmask\n+        while (nMaskCode > 0) {\n+            unsigned char chAvail = 0;\n+            ::Unserialize(s, chAvail);\n+            for (unsigned int p = 0; p < 8; p++) {\n+                bool f = (chAvail & (1 << p)) != 0;\n+                vAvail.push_back(f);\n+            }\n+            if (chAvail != 0)\n+                nMaskCode--;\n+        }\n+        // txouts themself\n+        vout.assign(vAvail.size(), CTxOut());\n+        for (unsigned int i = 0; i < vAvail.size(); i++) {\n+            if (vAvail[i])\n+                ::Unserialize(s, REF(CTxOutCompressor(vout[i])));\n+        }\n+        // coinbase height\n+        ::Unserialize(s, VARINT(nHeight));\n+    }\n+};\n+\n+}\n+\n+/** Upgrade the database from older formats.\n+ *\n+ * Currently implemented: from the per-tx utxo model (0.8..0.14.x) to per-txout.\n+ */\n+bool CCoinsViewDB::Upgrade() {\n+    std::unique_ptr<CDBIterator> pcursor(db.NewIterator());\n+    pcursor->Seek(std::make_pair(DB_COINS, uint256()));\n+    if (!pcursor->Valid()) {\n+        return true;\n+    }\n+\n+    LogPrintf(\"Upgrading database...\\n\");\n+    size_t batch_size = 1 << 24;\n+    CDBBatch batch(db);\n+    while (pcursor->Valid()) {\n+        boost::this_thread::interruption_point();\n+        std::pair<unsigned char, uint256> key;\n+        if (pcursor->GetKey(key) && key.first == DB_COINS) {\n+            CCoins old_coins;\n+            if (!pcursor->GetValue(old_coins)) {\n+                return error(\"%s: cannot parse CCoins record\", __func__);\n+            }\n+            COutPoint outpoint(key.second, 0);\n+            for (size_t i = 0; i < old_coins.vout.size(); ++i) {\n+                if (!old_coins.vout[i].IsNull() && !old_coins.vout[i].scriptPubKey.IsUnspendable()) {\n+                    Coin newcoin(std::move(old_coins.vout[i]), old_coins.nHeight, old_coins.fCoinBase);\n+                    outpoint.n = i;\n+                    CoinEntry entry(&outpoint);\n+                    batch.Write(entry, newcoin);\n+                }\n+            }\n+            batch.Erase(key);\n+            if (batch.SizeEstimate() > batch_size) {\n+                db.WriteBatch(batch);\n+                batch.Clear();\n+            }\n+            pcursor->Next();\n+        } else {\n+            break;\n+        }\n+    }\n+    db.WriteBatch(batch);\n+    return true;\n+}"
      },
      {
        "sha": "974dd4ebe351c42995288ab08ecf644e9dcbc2ab",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 13,
        "deletions": 11,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -22,9 +22,7 @@ class uint256;\n //! Compensate for extra memory peak (x1.5-x1.9) at flush time.\n static constexpr int DB_PEAK_USAGE_FACTOR = 2;\n //! No need to periodic flush if at least this much space still available.\n-static constexpr int MAX_BLOCK_COINSDB_USAGE = 200 * DB_PEAK_USAGE_FACTOR;\n-//! Always periodic flush if less than this much space still available.\n-static constexpr int MIN_BLOCK_COINSDB_USAGE = 50 * DB_PEAK_USAGE_FACTOR;\n+static constexpr int MAX_BLOCK_COINSDB_USAGE = 10 * DB_PEAK_USAGE_FACTOR;\n //! -dbcache default (MiB)\n static const int64_t nDefaultDbCache = 450;\n //! max. -dbcache (MiB)\n@@ -73,11 +71,15 @@ class CCoinsViewDB : public CCoinsView\n public:\n     CCoinsViewDB(size_t nCacheSize, bool fMemory = false, bool fWipe = false);\n \n-    bool GetCoins(const uint256 &txid, CCoins &coins) const;\n-    bool HaveCoins(const uint256 &txid) const;\n-    uint256 GetBestBlock() const;\n-    bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock);\n-    CCoinsViewCursor *Cursor() const;\n+    bool GetCoin(const COutPoint &outpoint, Coin &coin) const override;\n+    bool HaveCoin(const COutPoint &outpoint) const override;\n+    uint256 GetBestBlock() const override;\n+    bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) override;\n+    CCoinsViewCursor *Cursor() const override;\n+\n+    //! Attempt to update from an older database format. Returns whether an error occurred.\n+    bool Upgrade();\n+    size_t EstimateSize() const override;\n };\n \n /** Specialization of CCoinsViewCursor to iterate over a CCoinsViewDB */\n@@ -86,8 +88,8 @@ class CCoinsViewDBCursor: public CCoinsViewCursor\n public:\n     ~CCoinsViewDBCursor() {}\n \n-    bool GetKey(uint256 &key) const;\n-    bool GetValue(CCoins &coins) const;\n+    bool GetKey(COutPoint &key) const;\n+    bool GetValue(Coin &coin) const;\n     unsigned int GetValueSize() const;\n \n     bool Valid() const;\n@@ -97,7 +99,7 @@ class CCoinsViewDBCursor: public CCoinsViewCursor\n     CCoinsViewDBCursor(CDBIterator* pcursorIn, const uint256 &hashBlockIn):\n         CCoinsViewCursor(hashBlockIn), pcursor(pcursorIn) {}\n     std::unique_ptr<CDBIterator> pcursor;\n-    std::pair<char, uint256> keyTmp;\n+    std::pair<char, COutPoint> keyTmp;\n \n     friend class CCoinsViewDB;\n };"
      },
      {
        "sha": "17389db9f089827d7c120f729b012e45f65e2aeb",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 27,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -343,17 +343,10 @@ CTxMemPool::CTxMemPool(CBlockPolicyEstimator* estimator) :\n     nCheckFrequency = 0;\n }\n \n-void CTxMemPool::pruneSpent(const uint256 &hashTx, CCoins &coins)\n+bool CTxMemPool::isSpent(const COutPoint& outpoint)\n {\n     LOCK(cs);\n-\n-    auto it = mapNextTx.lower_bound(COutPoint(hashTx, 0));\n-\n-    // iterate over all COutPoints in mapNextTx whose hash equals the provided hashTx\n-    while (it != mapNextTx.end() && it->first->hash == hashTx) {\n-        coins.Spend(it->first->n); // and remove those outputs from coins\n-        it++;\n-    }\n+    return mapNextTx.count(outpoint);\n }\n \n unsigned int CTxMemPool::GetTransactionsUpdated() const\n@@ -531,9 +524,9 @@ void CTxMemPool::removeForReorg(const CCoinsViewCache *pcoins, unsigned int nMem\n                 indexed_transaction_set::const_iterator it2 = mapTx.find(txin.prevout.hash);\n                 if (it2 != mapTx.end())\n                     continue;\n-                const CCoins *coins = pcoins->AccessCoins(txin.prevout.hash);\n-                if (nCheckFrequency != 0) assert(coins);\n-                if (!coins || (coins->IsCoinBase() && ((signed long)nMemPoolHeight) - coins->nHeight < COINBASE_MATURITY)) {\n+                const Coin &coin = pcoins->AccessCoin(txin.prevout);\n+                if (nCheckFrequency != 0) assert(!coin.IsSpent());\n+                if (coin.IsSpent() || (coin.IsCoinBase() && ((signed long)nMemPoolHeight) - coin.nHeight < COINBASE_MATURITY)) {\n                     txToRemove.insert(it);\n                     break;\n                 }\n@@ -661,8 +654,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n                     parentSigOpCost += it2->GetSigOpCost();\n                 }\n             } else {\n-                const CCoins* coins = pcoins->AccessCoins(txin.prevout.hash);\n-                assert(coins && coins->IsAvailable(txin.prevout.n));\n+                assert(pcoins->HaveCoin(txin.prevout));\n             }\n             // Check whether its inputs are marked in mapNextTx.\n             auto it3 = mapNextTx.find(txin.prevout);\n@@ -898,20 +890,24 @@ bool CTxMemPool::HasNoInputsOf(const CTransaction &tx) const\n \n CCoinsViewMemPool::CCoinsViewMemPool(CCoinsView* baseIn, const CTxMemPool& mempoolIn) : CCoinsViewBacked(baseIn), mempool(mempoolIn) { }\n \n-bool CCoinsViewMemPool::GetCoins(const uint256 &txid, CCoins &coins) const {\n+bool CCoinsViewMemPool::GetCoin(const COutPoint &outpoint, Coin &coin) const {\n     // If an entry in the mempool exists, always return that one, as it's guaranteed to never\n     // conflict with the underlying cache, and it cannot have pruned entries (as it contains full)\n     // transactions. First checking the underlying cache risks returning a pruned entry instead.\n-    CTransactionRef ptx = mempool.get(txid);\n+    CTransactionRef ptx = mempool.get(outpoint.hash);\n     if (ptx) {\n-        coins = CCoins(*ptx, MEMPOOL_HEIGHT);\n-        return true;\n+        if (outpoint.n < ptx->vout.size()) {\n+            coin = Coin(ptx->vout[outpoint.n], MEMPOOL_HEIGHT, false);\n+            return true;\n+        } else {\n+            return false;\n+        }\n     }\n-    return (base->GetCoins(txid, coins) && !coins.IsPruned());\n+    return (base->GetCoin(outpoint, coin) && !coin.IsSpent());\n }\n \n-bool CCoinsViewMemPool::HaveCoins(const uint256 &txid) const {\n-    return mempool.exists(txid) || base->HaveCoins(txid);\n+bool CCoinsViewMemPool::HaveCoin(const COutPoint &outpoint) const {\n+    return mempool.exists(outpoint) || base->HaveCoin(outpoint);\n }\n \n size_t CTxMemPool::DynamicMemoryUsage() const {\n@@ -1022,7 +1018,7 @@ void CTxMemPool::trackPackageRemoved(const CFeeRate& rate) {\n     }\n }\n \n-void CTxMemPool::TrimToSize(size_t sizelimit, std::vector<uint256>* pvNoSpendsRemaining) {\n+void CTxMemPool::TrimToSize(size_t sizelimit, std::vector<COutPoint>* pvNoSpendsRemaining) {\n     LOCK(cs);\n \n     unsigned nTxnRemoved = 0;\n@@ -1053,11 +1049,10 @@ void CTxMemPool::TrimToSize(size_t sizelimit, std::vector<uint256>* pvNoSpendsRe\n         if (pvNoSpendsRemaining) {\n             BOOST_FOREACH(const CTransaction& tx, txn) {\n                 BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n-                    if (exists(txin.prevout.hash))\n-                        continue;\n-                    auto iter = mapNextTx.lower_bound(COutPoint(txin.prevout.hash, 0));\n-                    if (iter == mapNextTx.end() || iter->first->hash != txin.prevout.hash)\n-                        pvNoSpendsRemaining->push_back(txin.prevout.hash);\n+                    if (exists(txin.prevout.hash)) continue;\n+                    if (!mapNextTx.count(txin.prevout)) {\n+                        pvNoSpendsRemaining->push_back(txin.prevout);\n+                    }\n                 }\n             }\n         }\n@@ -1074,3 +1069,5 @@ bool CTxMemPool::TransactionWithinChainLimit(const uint256& txid, size_t chainLi\n     return it == mapTx.end() || (it->GetCountWithAncestors() < chainLimit &&\n        it->GetCountWithDescendants() < chainLimit);\n }\n+\n+SaltedTxidHasher::SaltedTxidHasher() : k0(GetRand(std::numeric_limits<uint64_t>::max())), k1(GetRand(std::numeric_limits<uint64_t>::max())) {}"
      },
      {
        "sha": "0316b42ba29527cd8bea15fd4fad3bea4fece15e",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 28,
        "deletions": 7,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -31,8 +31,8 @@\n class CAutoFile;\n class CBlockIndex;\n \n-/** Fake height value used in CCoins to signify they are only in the memory pool (since 0.8) */\n-static const unsigned int MEMPOOL_HEIGHT = 0x7FFFFFFF;\n+/** Fake height value used in Coin to signify they are only in the memory pool (since 0.8) */\n+static const uint32_t MEMPOOL_HEIGHT = 0x7FFFFFFF;\n \n struct LockPoints\n {\n@@ -327,6 +327,20 @@ enum class MemPoolRemovalReason {\n     REPLACED     //! Removed for replacement\n };\n \n+class SaltedTxidHasher\n+{\n+private:\n+    /** Salt */\n+    const uint64_t k0, k1;\n+\n+public:\n+    SaltedTxidHasher();\n+\n+    size_t operator()(const uint256& txid) const {\n+        return SipHashUint256(k0, k1, txid);\n+    }\n+};\n+\n /**\n  * CTxMemPool stores valid-according-to-the-current-best-chain transactions\n  * that may be included in the next block.\n@@ -515,7 +529,7 @@ class CTxMemPool\n     void _clear(); //lock free\n     bool CompareDepthAndScore(const uint256& hasha, const uint256& hashb);\n     void queryHashes(std::vector<uint256>& vtxid);\n-    void pruneSpent(const uint256& hash, CCoins &coins);\n+    bool isSpent(const COutPoint& outpoint);\n     unsigned int GetTransactionsUpdated() const;\n     void AddTransactionsUpdated(unsigned int n);\n     /**\n@@ -576,10 +590,10 @@ class CTxMemPool\n     CFeeRate GetMinFee(size_t sizelimit) const;\n \n     /** Remove transactions from the mempool until its dynamic size is <= sizelimit.\n-      *  pvNoSpendsRemaining, if set, will be populated with the list of transactions\n+      *  pvNoSpendsRemaining, if set, will be populated with the list of outpoints\n       *  which are not in mempool which no longer have any spends in this mempool.\n       */\n-    void TrimToSize(size_t sizelimit, std::vector<uint256>* pvNoSpendsRemaining=NULL);\n+    void TrimToSize(size_t sizelimit, std::vector<COutPoint>* pvNoSpendsRemaining=NULL);\n \n     /** Expire all transaction (and their dependencies) in the mempool older than time. Return the number of removed transactions. */\n     int Expire(int64_t time);\n@@ -605,6 +619,13 @@ class CTxMemPool\n         return (mapTx.count(hash) != 0);\n     }\n \n+    bool exists(const COutPoint& outpoint) const\n+    {\n+        LOCK(cs);\n+        auto it = mapTx.find(outpoint.hash);\n+        return (it != mapTx.end() && outpoint.n < it->GetTx().vout.size());\n+    }\n+\n     CTransactionRef get(const uint256& hash) const;\n     TxMempoolInfo info(const uint256& hash) const;\n     std::vector<TxMempoolInfo> infoAll() const;\n@@ -664,8 +685,8 @@ class CCoinsViewMemPool : public CCoinsViewBacked\n \n public:\n     CCoinsViewMemPool(CCoinsView* baseIn, const CTxMemPool& mempoolIn);\n-    bool GetCoins(const uint256 &txid, CCoins &coins) const;\n-    bool HaveCoins(const uint256 &txid) const;\n+    bool GetCoin(const COutPoint &outpoint, Coin &coin) const;\n+    bool HaveCoin(const COutPoint &outpoint) const;\n };\n \n /**"
      },
      {
        "sha": "3749d5d7a8df79c1f8e04626b438a48d66a4e979",
        "filename": "src/undo.h",
        "status": "modified",
        "additions": 58,
        "deletions": 26,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/undo.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/undo.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/undo.h?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -7,58 +7,90 @@\n #define BITCOIN_UNDO_H\n \n #include \"compressor.h\" \n+#include \"consensus/consensus.h\"\n #include \"primitives/transaction.h\"\n #include \"serialize.h\"\n \n /** Undo information for a CTxIn\n  *\n- *  Contains the prevout's CTxOut being spent, and if this was the\n- *  last output of the affected transaction, its metadata as well\n- *  (coinbase or not, height, transaction version)\n+ *  Contains the prevout's CTxOut being spent, and its metadata as well\n+ *  (coinbase or not, height). The serialization contains a dummy value of\n+ *  zero. This is be compatible with older versions which expect to see\n+ *  the transaction version there.\n  */\n-class CTxInUndo\n+class TxInUndoSerializer\n {\n-public:\n-    CTxOut txout;         // the txout data before being spent\n-    bool fCoinBase;       // if the outpoint was the last unspent: whether it belonged to a coinbase\n-    unsigned int nHeight; // if the outpoint was the last unspent: its height\n-    int nVersion;         // if the outpoint was the last unspent: its version\n-\n-    CTxInUndo() : txout(), fCoinBase(false), nHeight(0), nVersion(0) {}\n-    CTxInUndo(const CTxOut &txoutIn, bool fCoinBaseIn = false, unsigned int nHeightIn = 0, int nVersionIn = 0) : txout(txoutIn), fCoinBase(fCoinBaseIn), nHeight(nHeightIn), nVersion(nVersionIn) { }\n+    const Coin* txout;\n \n+public:\n     template<typename Stream>\n     void Serialize(Stream &s) const {\n-        ::Serialize(s, VARINT(nHeight*2+(fCoinBase ? 1 : 0)));\n-        if (nHeight > 0)\n-            ::Serialize(s, VARINT(this->nVersion));\n-        ::Serialize(s, CTxOutCompressor(REF(txout)));\n+        ::Serialize(s, VARINT(txout->nHeight * 2 + (txout->fCoinBase ? 1 : 0)));\n+        if (txout->nHeight > 0) {\n+            // Required to maintain compatibility with older undo format.\n+            ::Serialize(s, (unsigned char)0);\n+        }\n+        ::Serialize(s, CTxOutCompressor(REF(txout->out)));\n     }\n \n+    TxInUndoSerializer(const Coin* coin) : txout(coin) {}\n+};\n+\n+class TxInUndoDeserializer\n+{\n+    Coin* txout;\n+\n+public:\n     template<typename Stream>\n     void Unserialize(Stream &s) {\n         unsigned int nCode = 0;\n         ::Unserialize(s, VARINT(nCode));\n-        nHeight = nCode / 2;\n-        fCoinBase = nCode & 1;\n-        if (nHeight > 0)\n-            ::Unserialize(s, VARINT(this->nVersion));\n-        ::Unserialize(s, REF(CTxOutCompressor(REF(txout))));\n+        txout->nHeight = nCode / 2;\n+        txout->fCoinBase = nCode & 1;\n+        if (txout->nHeight > 0) {\n+            // Old versions stored the version number for the last spend of\n+            // a transaction's outputs. Non-final spends were indicated with\n+            // height = 0.\n+            int nVersionDummy;\n+            ::Unserialize(s, VARINT(nVersionDummy));\n+        }\n+        ::Unserialize(s, REF(CTxOutCompressor(REF(txout->out))));\n     }\n+\n+    TxInUndoDeserializer(Coin* coin) : txout(coin) {}\n };\n \n+static const size_t MAX_INPUTS_PER_BLOCK = MAX_BLOCK_BASE_SIZE / ::GetSerializeSize(CTxIn(), SER_NETWORK, PROTOCOL_VERSION);\n+\n /** Undo information for a CTransaction */\n class CTxUndo\n {\n public:\n     // undo information for all txins\n-    std::vector<CTxInUndo> vprevout;\n+    std::vector<Coin> vprevout;\n \n-    ADD_SERIALIZE_METHODS;\n+    template <typename Stream>\n+    void Serialize(Stream& s) const {\n+        // TODO: avoid reimplementing vector serializer\n+        uint64_t count = vprevout.size();\n+        ::Serialize(s, COMPACTSIZE(REF(count)));\n+        for (const auto& prevout : vprevout) {\n+            ::Serialize(s, REF(TxInUndoSerializer(&prevout)));\n+        }\n+    }\n \n-    template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action) {\n-        READWRITE(vprevout);\n+    template <typename Stream>\n+    void Unserialize(Stream& s) {\n+        // TODO: avoid reimplementing vector deserializer\n+        uint64_t count = 0;\n+        ::Unserialize(s, COMPACTSIZE(count));\n+        if (count > MAX_INPUTS_PER_BLOCK) {\n+            throw std::ios_base::failure(\"Too many input undo records\");\n+        }\n+        vprevout.resize(count);\n+        for (auto& prevout : vprevout) {\n+            ::Unserialize(s, REF(TxInUndoDeserializer(&prevout)));\n+        }\n     }\n };\n "
      },
      {
        "sha": "de65839eef4fea216b8ac1463cc6e09e3a7e3b06",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 100,
        "deletions": 119,
        "changes": 219,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -268,15 +268,15 @@ bool CheckSequenceLocks(const CTransaction &tx, int flags, LockPoints* lp, bool\n         prevheights.resize(tx.vin.size());\n         for (size_t txinIndex = 0; txinIndex < tx.vin.size(); txinIndex++) {\n             const CTxIn& txin = tx.vin[txinIndex];\n-            CCoins coins;\n-            if (!viewMemPool.GetCoins(txin.prevout.hash, coins)) {\n+            Coin coin;\n+            if (!viewMemPool.GetCoin(txin.prevout, coin)) {\n                 return error(\"%s: Missing input\", __func__);\n             }\n-            if (coins.nHeight == MEMPOOL_HEIGHT) {\n+            if (coin.nHeight == MEMPOOL_HEIGHT) {\n                 // Assume all mempool transaction confirm in the next block\n                 prevheights[txinIndex] = tip->nHeight + 1;\n             } else {\n-                prevheights[txinIndex] = coins.nHeight;\n+                prevheights[txinIndex] = coin.nHeight;\n             }\n         }\n         lockPair = CalculateSequenceLocks(tx, flags, &prevheights, index);\n@@ -315,9 +315,9 @@ void LimitMempoolSize(CTxMemPool& pool, size_t limit, unsigned long age) {\n         LogPrint(BCLog::MEMPOOL, \"Expired %i transactions from the memory pool\\n\", expired);\n     }\n \n-    std::vector<uint256> vNoSpendsRemaining;\n+    std::vector<COutPoint> vNoSpendsRemaining;\n     pool.TrimToSize(limit, &vNoSpendsRemaining);\n-    BOOST_FOREACH(const uint256& removed, vNoSpendsRemaining)\n+    BOOST_FOREACH(const COutPoint& removed, vNoSpendsRemaining)\n         pcoinsTip->Uncache(removed);\n }\n \n@@ -394,7 +394,7 @@ void UpdateMempoolForReorg(DisconnectedBlockTransactions &disconnectpool, bool f\n \n bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx, bool fLimitFree,\n                               bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool fOverrideMempoolLimit, const CAmount& nAbsurdFee, std::vector<uint256>& vHashTxnToUncache)\n+                              bool fOverrideMempoolLimit, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache)\n {\n     const CTransaction& tx = *ptx;\n     const uint256 hash = tx.GetHash();\n@@ -487,30 +487,30 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         view.SetBackend(viewMemPool);\n \n         // do we already have it?\n-        bool fHadTxInCache = pcoinsTip->HaveCoinsInCache(hash);\n-        if (view.HaveCoins(hash)) {\n-            if (!fHadTxInCache)\n-                vHashTxnToUncache.push_back(hash);\n-            return state.Invalid(false, REJECT_ALREADY_KNOWN, \"txn-already-known\");\n+        for (size_t out = 0; out < tx.vout.size(); out++) {\n+            COutPoint outpoint(hash, out);\n+            bool had_coin_in_cache = pcoinsTip->HaveCoinInCache(outpoint);\n+            if (view.HaveCoin(outpoint)) {\n+                if (!had_coin_in_cache) {\n+                    coins_to_uncache.push_back(outpoint);\n+                }\n+                return state.Invalid(false, REJECT_ALREADY_KNOWN, \"txn-already-known\");\n+            }\n         }\n \n         // do all inputs exist?\n-        // Note that this does not check for the presence of actual outputs (see the next check for that),\n-        // and only helps with filling in pfMissingInputs (to determine missing vs spent).\n         BOOST_FOREACH(const CTxIn txin, tx.vin) {\n-            if (!pcoinsTip->HaveCoinsInCache(txin.prevout.hash))\n-                vHashTxnToUncache.push_back(txin.prevout.hash);\n-            if (!view.HaveCoins(txin.prevout.hash)) {\n-                if (pfMissingInputs)\n+            if (!pcoinsTip->HaveCoinInCache(txin.prevout)) {\n+                coins_to_uncache.push_back(txin.prevout);\n+            }\n+            if (!view.HaveCoin(txin.prevout)) {\n+                if (pfMissingInputs) {\n                     *pfMissingInputs = true;\n+                }\n                 return false; // fMissingInputs and !state.IsInvalid() is used to detect this condition, don't set state.Invalid()\n             }\n         }\n \n-        // are the actual inputs available?\n-        if (!view.HaveInputs(tx))\n-            return state.Invalid(false, REJECT_DUPLICATE, \"bad-txns-inputs-spent\");\n-\n         // Bring the best block into scope\n         view.GetBestBlock();\n \n@@ -548,8 +548,8 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         // during reorgs to ensure COINBASE_MATURITY is still met.\n         bool fSpendsCoinbase = false;\n         BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n-            const CCoins *coins = view.AccessCoins(txin.prevout.hash);\n-            if (coins->IsCoinBase()) {\n+            const Coin &coin = view.AccessCoin(txin.prevout);\n+            if (coin.IsCoinBase()) {\n                 fSpendsCoinbase = true;\n                 break;\n             }\n@@ -813,10 +813,10 @@ bool AcceptToMemoryPoolWithTime(CTxMemPool& pool, CValidationState &state, const\n                         bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n                         bool fOverrideMempoolLimit, const CAmount nAbsurdFee)\n {\n-    std::vector<uint256> vHashTxToUncache;\n-    bool res = AcceptToMemoryPoolWorker(pool, state, tx, fLimitFree, pfMissingInputs, nAcceptTime, plTxnReplaced, fOverrideMempoolLimit, nAbsurdFee, vHashTxToUncache);\n+    std::vector<COutPoint> coins_to_uncache;\n+    bool res = AcceptToMemoryPoolWorker(pool, state, tx, fLimitFree, pfMissingInputs, nAcceptTime, plTxnReplaced, fOverrideMempoolLimit, nAbsurdFee, coins_to_uncache);\n     if (!res) {\n-        BOOST_FOREACH(const uint256& hashTx, vHashTxToUncache)\n+        BOOST_FOREACH(const COutPoint& hashTx, coins_to_uncache)\n             pcoinsTip->Uncache(hashTx);\n     }\n     // After we've (potentially) uncached entries, ensure our coins cache is still within its size limits\n@@ -868,15 +868,8 @@ bool GetTransaction(const uint256 &hash, CTransactionRef &txOut, const Consensus\n     }\n \n     if (fAllowSlow) { // use coin database to locate block that contains transaction, and scan it\n-        int nHeight = -1;\n-        {\n-            const CCoinsViewCache& view = *pcoinsTip;\n-            const CCoins* coins = view.AccessCoins(hash);\n-            if (coins)\n-                nHeight = coins->nHeight;\n-        }\n-        if (nHeight > 0)\n-            pindexSlow = chainActive[nHeight];\n+        const Coin& coin = AccessByTxid(*pcoinsTip, hash);\n+        if (!coin.IsSpent()) pindexSlow = chainActive[coin.nHeight];\n     }\n \n     if (pindexSlow) {\n@@ -1124,24 +1117,12 @@ void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, CTxUndo &txund\n     if (!tx.IsCoinBase()) {\n         txundo.vprevout.reserve(tx.vin.size());\n         BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n-            CCoinsModifier coins = inputs.ModifyCoins(txin.prevout.hash);\n-            unsigned nPos = txin.prevout.n;\n-\n-            if (nPos >= coins->vout.size() || coins->vout[nPos].IsNull())\n-                assert(false);\n-            // mark an outpoint spent, and construct undo information\n-            txundo.vprevout.push_back(CTxInUndo(coins->vout[nPos]));\n-            coins->Spend(nPos);\n-            if (coins->vout.size() == 0) {\n-                CTxInUndo& undo = txundo.vprevout.back();\n-                undo.nHeight = coins->nHeight;\n-                undo.fCoinBase = coins->fCoinBase;\n-                undo.nVersion = coins->nVersion;\n-            }\n+            txundo.vprevout.emplace_back();\n+            inputs.SpendCoin(txin.prevout, &txundo.vprevout.back());\n         }\n     }\n     // add outputs\n-    inputs.ModifyNewCoins(tx.GetHash(), tx.IsCoinBase())->FromTx(tx, nHeight);\n+    AddCoins(inputs, tx, nHeight);\n }\n \n void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, int nHeight)\n@@ -1185,11 +1166,19 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n         if (fScriptChecks) {\n             for (unsigned int i = 0; i < tx.vin.size(); i++) {\n                 const COutPoint &prevout = tx.vin[i].prevout;\n-                const CCoins* coins = inputs.AccessCoins(prevout.hash);\n-                assert(coins);\n+                const Coin& coin = inputs.AccessCoin(prevout);\n+                assert(!coin.IsSpent());\n+\n+                // We very carefully only pass in things to CScriptCheck which\n+                // are clearly committed to by tx' witness hash. This provides\n+                // a sanity check that our caching is not introducing consensus\n+                // failures through additional data in, eg, the coins being\n+                // spent being checked as a part of CScriptCheck.\n+                const CScript& scriptPubKey = coin.out.scriptPubKey;\n+                const CAmount amount = coin.out.nValue;\n \n                 // Verify signature\n-                CScriptCheck check(*coins, tx, i, flags, cacheStore, &txdata);\n+                CScriptCheck check(scriptPubKey, amount, tx, i, flags, cacheStore, &txdata);\n                 if (pvChecks) {\n                     pvChecks->push_back(CScriptCheck());\n                     check.swap(pvChecks->back());\n@@ -1201,7 +1190,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                         // arguments; if so, don't trigger DoS protection to\n                         // avoid splitting the network between upgraded and\n                         // non-upgraded nodes.\n-                        CScriptCheck check2(*coins, tx, i,\n+                        CScriptCheck check2(scriptPubKey, amount, tx, i,\n                                 flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheStore, &txdata);\n                         if (check2())\n                             return state.Invalid(false, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n@@ -1260,19 +1249,18 @@ bool UndoReadFromDisk(CBlockUndo& blockundo, const CDiskBlockPos& pos, const uin\n \n     // Read block\n     uint256 hashChecksum;\n+    CHashVerifier<CAutoFile> verifier(&filein); // We need a CHashVerifier as reserializing may lose data\n     try {\n-        filein >> blockundo;\n+        verifier << hashBlock;\n+        verifier >> blockundo;\n         filein >> hashChecksum;\n     }\n     catch (const std::exception& e) {\n         return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n     }\n \n     // Verify checksum\n-    CHashWriter hasher(SER_GETHASH, PROTOCOL_VERSION);\n-    hasher << hashBlock;\n-    hasher << blockundo;\n-    if (hashChecksum != hasher.GetHash())\n+    if (hashChecksum != verifier.GetHash())\n         return error(\"%s: Checksum mismatch\", __func__);\n \n     return true;\n@@ -1298,46 +1286,43 @@ bool AbortNode(CValidationState& state, const std::string& strMessage, const std\n \n } // anon namespace\n \n+enum DisconnectResult\n+{\n+    DISCONNECT_OK,      // All good.\n+    DISCONNECT_UNCLEAN, // Rolled back, but UTXO set was inconsistent with block.\n+    DISCONNECT_FAILED   // Something else went wrong.\n+};\n+\n /**\n- * Apply the undo operation of a CTxInUndo to the given chain state.\n- * @param undo The undo object.\n+ * Restore the UTXO in a Coin at a given COutPoint\n+ * @param undo The Coin to be restored.\n  * @param view The coins view to which to apply the changes.\n  * @param out The out point that corresponds to the tx input.\n- * @return True on success.\n+ * @return A DisconnectResult as an int\n  */\n-bool ApplyTxInUndo(const CTxInUndo& undo, CCoinsViewCache& view, const COutPoint& out)\n+int ApplyTxInUndo(Coin&& undo, CCoinsViewCache& view, const COutPoint& out)\n {\n     bool fClean = true;\n \n-    CCoinsModifier coins = view.ModifyCoins(out.hash);\n-    if (undo.nHeight != 0) {\n-        // undo data contains height: this is the last output of the prevout tx being spent\n-        if (!coins->IsPruned())\n-            fClean = fClean && error(\"%s: undo data overwriting existing transaction\", __func__);\n-        coins->Clear();\n-        coins->fCoinBase = undo.fCoinBase;\n-        coins->nHeight = undo.nHeight;\n-        coins->nVersion = undo.nVersion;\n-    } else {\n-        if (coins->IsPruned())\n-            fClean = fClean && error(\"%s: undo data adding output to missing transaction\", __func__);\n+    if (view.HaveCoin(out)) fClean = false; // overwriting transaction output\n+\n+    if (undo.nHeight == 0) {\n+        // Missing undo metadata (height and coinbase). Older versions included this\n+        // information only in undo records for the last spend of a transactions'\n+        // outputs. This implies that it must be present for some other output of the same tx.\n+        const Coin& alternate = AccessByTxid(view, out.hash);\n+        if (!alternate.IsSpent()) {\n+            undo.nHeight = alternate.nHeight;\n+            undo.fCoinBase = alternate.fCoinBase;\n+        } else {\n+            return DISCONNECT_FAILED; // adding output for transaction without known metadata\n+        }\n     }\n-    if (coins->IsAvailable(out.n))\n-        fClean = fClean && error(\"%s: undo data overwriting existing output\", __func__);\n-    if (coins->vout.size() < out.n+1)\n-        coins->vout.resize(out.n+1);\n-    coins->vout[out.n] = undo.txout;\n+    view.AddCoin(out, std::move(undo), undo.fCoinBase);\n \n-    return fClean;\n+    return fClean ? DISCONNECT_OK : DISCONNECT_UNCLEAN;\n }\n \n-enum DisconnectResult\n-{\n-    DISCONNECT_OK,      // All good.\n-    DISCONNECT_UNCLEAN, // Rolled back, but UTXO set was inconsistent with block.\n-    DISCONNECT_FAILED   // Something else went wrong.\n-};\n-\n /** Undo the effects of this block (with given index) on the UTXO set represented by coins.\n  *  When UNCLEAN or FAILED is returned, view is left in an indeterminate state. */\n static DisconnectResult DisconnectBlock(const CBlock& block, const CBlockIndex* pindex, CCoinsViewCache& view)\n@@ -1369,36 +1354,31 @@ static DisconnectResult DisconnectBlock(const CBlock& block, const CBlockIndex*\n \n         // Check that all outputs are available and match the outputs in the block itself\n         // exactly.\n-        {\n-        CCoinsModifier outs = view.ModifyCoins(hash);\n-        outs->ClearUnspendable();\n-\n-        CCoins outsBlock(tx, pindex->nHeight);\n-        // The CCoins serialization does not serialize negative numbers.\n-        // No network rules currently depend on the version here, so an inconsistency is harmless\n-        // but it must be corrected before txout nversion ever influences a network rule.\n-        if (outsBlock.nVersion < 0)\n-            outs->nVersion = outsBlock.nVersion;\n-        if (*outs != outsBlock)\n-            fClean = fClean && error(\"DisconnectBlock(): added transaction mismatch? database corrupted\");\n-\n-        // remove outputs\n-        outs->Clear();\n+        for (size_t o = 0; o < tx.vout.size(); o++) {\n+            if (!tx.vout[o].scriptPubKey.IsUnspendable()) {\n+                COutPoint out(hash, o);\n+                Coin coin;\n+                view.SpendCoin(out, &coin);\n+                if (tx.vout[o] != coin.out) {\n+                    fClean = false; // transaction output mismatch\n+                }\n+            }\n         }\n \n         // restore inputs\n         if (i > 0) { // not coinbases\n-            const CTxUndo &txundo = blockUndo.vtxundo[i-1];\n+            CTxUndo &txundo = blockUndo.vtxundo[i-1];\n             if (txundo.vprevout.size() != tx.vin.size()) {\n                 error(\"DisconnectBlock(): transaction and undo data inconsistent\");\n                 return DISCONNECT_FAILED;\n             }\n             for (unsigned int j = tx.vin.size(); j-- > 0;) {\n                 const COutPoint &out = tx.vin[j].prevout;\n-                const CTxInUndo &undo = txundo.vprevout[j];\n-                if (!ApplyTxInUndo(undo, view, out))\n-                    fClean = false;\n+                int res = ApplyTxInUndo(std::move(txundo.vprevout[j]), view, out);\n+                if (res == DISCONNECT_FAILED) return DISCONNECT_FAILED;\n+                fClean = fClean && res != DISCONNECT_UNCLEAN;\n             }\n+            // At this point, all of txundo.vprevout should have been moved out.\n         }\n     }\n \n@@ -1579,10 +1559,12 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n \n     if (fEnforceBIP30) {\n         for (const auto& tx : block.vtx) {\n-            const CCoins* coins = view.AccessCoins(tx->GetHash());\n-            if (coins && !coins->IsPruned())\n-                return state.DoS(100, error(\"ConnectBlock(): tried to overwrite transaction\"),\n-                                 REJECT_INVALID, \"bad-txns-BIP30\");\n+            for (size_t o = 0; o < tx->vout.size(); o++) {\n+                if (view.HaveCoin(COutPoint(tx->GetHash(), o))) {\n+                    return state.DoS(100, error(\"ConnectBlock(): tried to overwrite transaction\"),\n+                                     REJECT_INVALID, \"bad-txns-BIP30\");\n+                }\n+            }\n         }\n     }\n \n@@ -1649,7 +1631,7 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n             // be in ConnectBlock because they require the UTXO set\n             prevheights.resize(tx.vin.size());\n             for (size_t j = 0; j < tx.vin.size(); j++) {\n-                prevheights[j] = view.AccessCoins(tx.vin[j].prevout.hash)->nHeight;\n+                prevheights[j] = view.AccessCoin(tx.vin[j].prevout).nHeight;\n             }\n \n             if (!SequenceLocks(tx, nLockTimeFlags, &prevheights, *pindex)) {\n@@ -1787,9 +1769,8 @@ bool static FlushStateToDisk(CValidationState &state, FlushStateMode mode, int n\n     int64_t nMempoolSizeMax = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n     int64_t cacheSize = pcoinsTip->DynamicMemoryUsage() * DB_PEAK_USAGE_FACTOR;\n     int64_t nTotalSpace = nCoinCacheUsage + std::max<int64_t>(nMempoolSizeMax - nMempoolUsage, 0);\n-    // The cache is large and we're within 10% and 200 MiB or 50% and 50MiB of the limit, but we have time now (not in the middle of a block processing).\n-    bool fCacheLarge = mode == FLUSH_STATE_PERIODIC && cacheSize > std::min(std::max(nTotalSpace / 2, nTotalSpace - MIN_BLOCK_COINSDB_USAGE * 1024 * 1024),\n-                                                                            std::max((9 * nTotalSpace) / 10, nTotalSpace - MAX_BLOCK_COINSDB_USAGE * 1024 * 1024));\n+    // The cache is large and we're within 10% and 10 MiB of the limit, but we have time now (not in the middle of a block processing).\n+    bool fCacheLarge = mode == FLUSH_STATE_PERIODIC && cacheSize > std::max((9 * nTotalSpace) / 10, nTotalSpace - MAX_BLOCK_COINSDB_USAGE * 1024 * 1024);\n     // The cache is over the limit, we have to write now.\n     bool fCacheCritical = mode == FLUSH_STATE_IF_NEEDED && cacheSize > nTotalSpace;\n     // It's been a while since we wrote the block index to disk. Do this frequently, so we don't need to redownload after a crash.\n@@ -1830,12 +1811,12 @@ bool static FlushStateToDisk(CValidationState &state, FlushStateMode mode, int n\n     }\n     // Flush best chain related state. This can only be done if the blocks / block index write was also done.\n     if (fDoFullFlush) {\n-        // Typical CCoins structures on disk are around 128 bytes in size.\n+        // Typical Coin structures on disk are around 48 bytes in size.\n         // Pushing a new one to the database can cause it to be written\n         // twice (once in the log, and once in the tables). This is already\n         // an overestimation, as most will delete an existing entry or\n         // overwrite one. Still, use a conservative safety factor of 2.\n-        if (!CheckDiskSpace(128 * 2 * 2 * pcoinsTip->GetCacheSize()))\n+        if (!CheckDiskSpace(48 * 2 * 2 * pcoinsTip->GetCacheSize()))\n             return state.Error(\"out of disk space\");\n         // Flush the chainstate (which may refer to block index entries).\n         if (!pcoinsTip->Flush())\n@@ -1917,7 +1898,7 @@ void static UpdateTip(CBlockIndex *pindexNew, const CChainParams& chainParams) {\n             DoWarning(strWarning);\n         }\n     }\n-    LogPrintf(\"%s: new best=%s height=%d version=0x%08x log2_work=%.8g tx=%lu date='%s' progress=%f cache=%.1fMiB(%utx)\", __func__,\n+    LogPrintf(\"%s: new best=%s height=%d version=0x%08x log2_work=%.8g tx=%lu date='%s' progress=%f cache=%.1fMiB(%utxo)\", __func__,\n       chainActive.Tip()->GetBlockHash().ToString(), chainActive.Height(), chainActive.Tip()->nVersion,\n       log(chainActive.Tip()->nChainWork.getdouble())/log(2.0), (unsigned long)chainActive.Tip()->nChainTx,\n       DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()),"
      },
      {
        "sha": "096fd0a9eeb6ad79c59ba89a3a9ebf28ccf288a0",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -406,8 +406,8 @@ class CScriptCheck\n \n public:\n     CScriptCheck(): amount(0), ptxTo(0), nIn(0), nFlags(0), cacheStore(false), error(SCRIPT_ERR_UNKNOWN_ERROR) {}\n-    CScriptCheck(const CCoins& txFromIn, const CTransaction& txToIn, unsigned int nInIn, unsigned int nFlagsIn, bool cacheIn, PrecomputedTransactionData* txdataIn) :\n-        scriptPubKey(txFromIn.vout[txToIn.vin[nInIn].prevout.n].scriptPubKey), amount(txFromIn.vout[txToIn.vin[nInIn].prevout.n].nValue),\n+    CScriptCheck(const CScript& scriptPubKeyIn, const CAmount amountIn, const CTransaction& txToIn, unsigned int nInIn, unsigned int nFlagsIn, bool cacheIn, PrecomputedTransactionData* txdataIn) :\n+        scriptPubKey(scriptPubKeyIn), amount(amountIn),\n         ptxTo(&txToIn), nIn(nInIn), nFlags(nFlagsIn), cacheStore(cacheIn), error(SCRIPT_ERR_UNKNOWN_ERROR), txdata(txdataIn) { }\n \n     bool operator()();"
      },
      {
        "sha": "4bfd3ee6770233c081ac2fd96046afcceffb0271",
        "filename": "test/functional/blockchain.py",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/test/functional/blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/test/functional/blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/blockchain.py?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -49,10 +49,12 @@ def _test_gettxoutsetinfo(self):\n         assert_equal(res['transactions'], 200)\n         assert_equal(res['height'], 200)\n         assert_equal(res['txouts'], 200)\n-        assert_equal(res['bytes_serialized'], 13924),\n         assert_equal(res['bestblock'], node.getblockhash(200))\n+        size = res['disk_size']\n+        assert size > 6400\n+        assert size < 64000\n         assert_equal(len(res['bestblock']), 64)\n-        assert_equal(len(res['hash_serialized']), 64)\n+        assert_equal(len(res['hash_serialized_2']), 64)\n \n         self.log.info(\"Test that gettxoutsetinfo() works for blockchain with just the genesis block\")\n         b1hash = node.getblockhash(1)\n@@ -64,7 +66,7 @@ def _test_gettxoutsetinfo(self):\n         assert_equal(res2['height'], 0)\n         assert_equal(res2['txouts'], 0)\n         assert_equal(res2['bestblock'], node.getblockhash(0))\n-        assert_equal(len(res2['hash_serialized']), 64)\n+        assert_equal(len(res2['hash_serialized_2']), 64)\n \n         self.log.info(\"Test that gettxoutsetinfo() returns the same result after invalidate/reconsider block\")\n         node.reconsiderblock(b1hash)\n@@ -75,7 +77,7 @@ def _test_gettxoutsetinfo(self):\n         assert_equal(res['height'], res3['height'])\n         assert_equal(res['txouts'], res3['txouts'])\n         assert_equal(res['bestblock'], res3['bestblock'])\n-        assert_equal(res['hash_serialized'], res3['hash_serialized'])\n+        assert_equal(res['hash_serialized_2'], res3['hash_serialized_2'])\n \n     def _test_getblockheader(self):\n         node = self.nodes[0]"
      }
    ]
  },
  {
    "sha": "2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyY2Y3ZWEwYmQ5NjI0MTkyNmM4NGZkOWJlYjE1NTM4YmE4MmZiNWI4",
    "commit": {
      "author": {
        "name": "cg",
        "email": "chengang31@gmail.com",
        "date": "2017-06-03T19:15:58Z"
      },
      "committer": {
        "name": "cg",
        "email": "chengang31@gmail.com",
        "date": "2017-06-03T19:15:58Z"
      },
      "message": "Merge remote-tracking branch 'upstream/master'",
      "tree": {
        "sha": "52c9195520b610bf87adcf67e033eede9da49ddf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/52c9195520b610bf87adcf67e033eede9da49ddf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/comments",
    "author": {
      "login": "cg31",
      "id": 575738,
      "node_id": "MDQ6VXNlcjU3NTczOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/575738?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cg31",
      "html_url": "https://github.com/cg31",
      "followers_url": "https://api.github.com/users/cg31/followers",
      "following_url": "https://api.github.com/users/cg31/following{/other_user}",
      "gists_url": "https://api.github.com/users/cg31/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cg31/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cg31/subscriptions",
      "organizations_url": "https://api.github.com/users/cg31/orgs",
      "repos_url": "https://api.github.com/users/cg31/repos",
      "events_url": "https://api.github.com/users/cg31/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cg31/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "cg31",
      "id": 575738,
      "node_id": "MDQ6VXNlcjU3NTczOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/575738?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cg31",
      "html_url": "https://github.com/cg31",
      "followers_url": "https://api.github.com/users/cg31/followers",
      "following_url": "https://api.github.com/users/cg31/following{/other_user}",
      "gists_url": "https://api.github.com/users/cg31/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cg31/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cg31/subscriptions",
      "organizations_url": "https://api.github.com/users/cg31/orgs",
      "repos_url": "https://api.github.com/users/cg31/repos",
      "events_url": "https://api.github.com/users/cg31/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cg31/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c48bb788672aeb85aa2b83b967c82ce287922d74",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c48bb788672aeb85aa2b83b967c82ce287922d74",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c48bb788672aeb85aa2b83b967c82ce287922d74"
      },
      {
        "sha": "098b01dc58ff555c473ae58c92c34b03a77eda5f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/098b01dc58ff555c473ae58c92c34b03a77eda5f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/098b01dc58ff555c473ae58c92c34b03a77eda5f"
      }
    ],
    "stats": {
      "total": 1224,
      "additions": 789,
      "deletions": 435
    },
    "files": [
      {
        "sha": "c071fbe2753c9bda4c8d7b74143dc15878572c4b",
        "filename": "src/secp256k1/Makefile.am",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/Makefile.am?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -93,7 +93,10 @@ TESTS =\n if USE_TESTS\n noinst_PROGRAMS += tests\n tests_SOURCES = src/tests.c\n-tests_CPPFLAGS = -DSECP256K1_BUILD -DVERIFY -I$(top_srcdir)/src -I$(top_srcdir)/include $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n+tests_CPPFLAGS = -DSECP256K1_BUILD -I$(top_srcdir)/src -I$(top_srcdir)/include $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n+if !ENABLE_COVERAGE\n+tests_CPPFLAGS += -DVERIFY\n+endif\n tests_LDADD = $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n tests_LDFLAGS = -static\n TESTS += tests\n@@ -102,7 +105,10 @@ endif\n if USE_EXHAUSTIVE_TESTS\n noinst_PROGRAMS += exhaustive_tests\n exhaustive_tests_SOURCES = src/tests_exhaustive.c\n-exhaustive_tests_CPPFLAGS = -DSECP256K1_BUILD -DVERIFY -I$(top_srcdir)/src $(SECP_INCLUDES)\n+exhaustive_tests_CPPFLAGS = -DSECP256K1_BUILD -I$(top_srcdir)/src $(SECP_INCLUDES)\n+if !ENABLE_COVERAGE\n+exhaustive_tests_CPPFLAGS += -DVERIFY\n+endif\n exhaustive_tests_LDADD = $(SECP_LIBS)\n exhaustive_tests_LDFLAGS = -static\n TESTS += exhaustive_tests"
      },
      {
        "sha": "e5fcbcb4edf2ace1c2b8740fc118b1e784f12d5e",
        "filename": "src/secp256k1/configure.ac",
        "status": "modified",
        "additions": 16,
        "deletions": 1,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/configure.ac?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -20,7 +20,7 @@ AC_PATH_TOOL(STRIP, strip)\n AX_PROG_CC_FOR_BUILD\n \n if test \"x$CFLAGS\" = \"x\"; then\n-  CFLAGS=\"-O3 -g\"\n+  CFLAGS=\"-g\"\n fi\n \n AM_PROG_CC_C_O\n@@ -89,6 +89,11 @@ AC_ARG_ENABLE(benchmark,\n     [use_benchmark=$enableval],\n     [use_benchmark=no])\n \n+AC_ARG_ENABLE(coverage,\n+    AS_HELP_STRING([--enable-coverage],[enable compiler flags to support kcov coverage analysis]),\n+    [enable_coverage=$enableval],\n+    [enable_coverage=no])\n+\n AC_ARG_ENABLE(tests,\n     AS_HELP_STRING([--enable-tests],[compile tests (default is yes)]),\n     [use_tests=$enableval],\n@@ -154,6 +159,14 @@ AC_COMPILE_IFELSE([AC_LANG_SOURCE([[void myfunc() {__builtin_expect(0,0);}]])],\n     [ AC_MSG_RESULT([no])\n     ])\n \n+if test x\"$enable_coverage\" = x\"yes\"; then\n+    AC_DEFINE(COVERAGE, 1, [Define this symbol to compile out all VERIFY code])\n+    CFLAGS=\"$CFLAGS -O0 --coverage\"\n+    LDFLAGS=\"--coverage\"\n+else\n+    CFLAGS=\"$CFLAGS -O3\"\n+fi\n+\n if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n   save_cross_compiling=$cross_compiling\n   cross_compiling=no\n@@ -434,6 +447,7 @@ AC_MSG_NOTICE([Using field implementation: $set_field])\n AC_MSG_NOTICE([Using bignum implementation: $set_bignum])\n AC_MSG_NOTICE([Using scalar implementation: $set_scalar])\n AC_MSG_NOTICE([Using endomorphism optimizations: $use_endomorphism])\n+AC_MSG_NOTICE([Building for coverage analysis: $enable_coverage])\n AC_MSG_NOTICE([Building ECDH module: $enable_module_ecdh])\n AC_MSG_NOTICE([Building ECDSA pubkey recovery module: $enable_module_recovery])\n AC_MSG_NOTICE([Using jni: $use_jni])\n@@ -460,6 +474,7 @@ AC_SUBST(SECP_INCLUDES)\n AC_SUBST(SECP_LIBS)\n AC_SUBST(SECP_TEST_LIBS)\n AC_SUBST(SECP_TEST_INCLUDES)\n+AM_CONDITIONAL([ENABLE_COVERAGE], [test x\"$enable_coverage\" = x\"yes\"])\n AM_CONDITIONAL([USE_TESTS], [test x\"$use_tests\" != x\"no\"])\n AM_CONDITIONAL([USE_EXHAUSTIVE_TESTS], [test x\"$use_exhaustive_tests\" != x\"no\"])\n AM_CONDITIONAL([USE_BENCHMARK], [test x\"$use_benchmark\" = x\"yes\"])"
      },
      {
        "sha": "fc4c5cefbb3b654855908761b9a68be88303b813",
        "filename": "src/secp256k1/include/secp256k1.h",
        "status": "modified",
        "additions": 38,
        "deletions": 1,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1.h?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -163,6 +163,8 @@ typedef int (*secp256k1_nonce_function)(\n  *\n  *  Returns: a newly created context object.\n  *  In:      flags: which parts of the context to initialize.\n+ *\n+ *  See also secp256k1_context_randomize.\n  */\n SECP256K1_API secp256k1_context* secp256k1_context_create(\n     unsigned int flags\n@@ -485,6 +487,28 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_create(\n     const unsigned char *seckey\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Negates a private key in place.\n+ *\n+ *  Returns: 1 always\n+ *  Args:   ctx:        pointer to a context object\n+ *  In/Out: pubkey:     pointer to the public key to be negated (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_negate(\n+    const secp256k1_context* ctx,\n+    unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n+\n+/** Negates a public key in place.\n+ *\n+ *  Returns: 1 always\n+ *  Args:   ctx:        pointer to a context object\n+ *  In/Out: pubkey:     pointer to the public key to be negated (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_negate(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n+\n /** Tweak a private key by adding tweak to it.\n  * Returns: 0 if the tweak was out of range (chance of around 1 in 2^128 for\n  *          uniformly random 32-byte arrays, or if the resulting private key\n@@ -543,11 +567,24 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n     const unsigned char *tweak\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n-/** Updates the context randomization.\n+/** Updates the context randomization to protect against side-channel leakage.\n  *  Returns: 1: randomization successfully updated\n  *           0: error\n  *  Args:    ctx:       pointer to a context object (cannot be NULL)\n  *  In:      seed32:    pointer to a 32-byte random seed (NULL resets to initial state)\n+ *\n+ * While secp256k1 code is written to be constant-time no matter what secret\n+ * values are, it's possible that a future compiler may output code which isn't,\n+ * and also that the CPU may not emit the same radio frequencies or draw the same\n+ * amount power for all values.\n+ *\n+ * This function provides a seed which is combined into the blinding value: that\n+ * blinding value is added before each multiplication (and removed afterwards) so\n+ * that it does not affect function results, but shields against attacks which\n+ * rely on any input-dependent behaviour.\n+ *\n+ * You should call this after secp256k1_context_create or\n+ * secp256k1_context_clone, and may call this repeatedly afterwards.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_context_randomize(\n     secp256k1_context* ctx,"
      },
      {
        "sha": "d67f08a4267bcb2e03e8ffbedb8c01de2691863b",
        "filename": "src/secp256k1/src/bench.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/src/bench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/src/bench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench.h?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -23,7 +23,7 @@ void print_number(double x) {\n     if (y < 0.0) {\n         y = -y;\n     }\n-    while (y < 100.0) {\n+    while (y > 0 && y < 100.0) {\n         y *= 10.0;\n         c++;\n     }"
      },
      {
        "sha": "5f137dda23ef3a62326a6aee21cd152fa09860da",
        "filename": "src/secp256k1/src/bench_schnorr_verify.c",
        "status": "removed",
        "additions": 0,
        "deletions": 73,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c48bb788672aeb85aa2b83b967c82ce287922d74/src/secp256k1/src/bench_schnorr_verify.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c48bb788672aeb85aa2b83b967c82ce287922d74/src/secp256k1/src/bench_schnorr_verify.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_schnorr_verify.c?ref=c48bb788672aeb85aa2b83b967c82ce287922d74",
        "patch": "@@ -1,73 +0,0 @@\n-/**********************************************************************\n- * Copyright (c) 2014 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n-\n-#include <stdio.h>\n-#include <string.h>\n-\n-#include \"include/secp256k1.h\"\n-#include \"include/secp256k1_schnorr.h\"\n-#include \"util.h\"\n-#include \"bench.h\"\n-\n-typedef struct {\n-    unsigned char key[32];\n-    unsigned char sig[64];\n-    unsigned char pubkey[33];\n-    size_t pubkeylen;\n-} benchmark_schnorr_sig_t;\n-\n-typedef struct {\n-    secp256k1_context *ctx;\n-    unsigned char msg[32];\n-    benchmark_schnorr_sig_t sigs[64];\n-    int numsigs;\n-} benchmark_schnorr_verify_t;\n-\n-static void benchmark_schnorr_init(void* arg) {\n-    int i, k;\n-    benchmark_schnorr_verify_t* data = (benchmark_schnorr_verify_t*)arg;\n-\n-    for (i = 0; i < 32; i++) {\n-        data->msg[i] = 1 + i;\n-    }\n-    for (k = 0; k < data->numsigs; k++) {\n-        secp256k1_pubkey pubkey;\n-        for (i = 0; i < 32; i++) {\n-            data->sigs[k].key[i] = 33 + i + k;\n-        }\n-        secp256k1_schnorr_sign(data->ctx, data->sigs[k].sig, data->msg, data->sigs[k].key, NULL, NULL);\n-        data->sigs[k].pubkeylen = 33;\n-        CHECK(secp256k1_ec_pubkey_create(data->ctx, &pubkey, data->sigs[k].key));\n-        CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->sigs[k].pubkey, &data->sigs[k].pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED));\n-    }\n-}\n-\n-static void benchmark_schnorr_verify(void* arg) {\n-    int i;\n-    benchmark_schnorr_verify_t* data = (benchmark_schnorr_verify_t*)arg;\n-\n-    for (i = 0; i < 20000 / data->numsigs; i++) {\n-        secp256k1_pubkey pubkey;\n-        data->sigs[0].sig[(i >> 8) % 64] ^= (i & 0xFF);\n-        CHECK(secp256k1_ec_pubkey_parse(data->ctx, &pubkey, data->sigs[0].pubkey, data->sigs[0].pubkeylen));\n-        CHECK(secp256k1_schnorr_verify(data->ctx, data->sigs[0].sig, data->msg, &pubkey) == ((i & 0xFF) == 0));\n-        data->sigs[0].sig[(i >> 8) % 64] ^= (i & 0xFF);\n-    }\n-}\n-\n-\n-\n-int main(void) {\n-    benchmark_schnorr_verify_t data;\n-\n-    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n-\n-    data.numsigs = 1;\n-    run_benchmark(\"schnorr_verify\", benchmark_schnorr_verify, benchmark_schnorr_init, NULL, &data, 10, 20000);\n-\n-    secp256k1_context_destroy(data.ctx);\n-    return 0;\n-}"
      },
      {
        "sha": "453bb1188066f90f7b4648ac19c8e78212973e11",
        "filename": "src/secp256k1/src/ecdsa_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 11,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/src/ecdsa_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/src/ecdsa_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecdsa_impl.h?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -225,14 +225,12 @@ static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context *ctx, const\n #if defined(EXHAUSTIVE_TEST_ORDER)\n {\n     secp256k1_scalar computed_r;\n-    int overflow = 0;\n     secp256k1_ge pr_ge;\n     secp256k1_ge_set_gej(&pr_ge, &pr);\n     secp256k1_fe_normalize(&pr_ge.x);\n \n     secp256k1_fe_get_b32(c, &pr_ge.x);\n-    secp256k1_scalar_set_b32(&computed_r, c, &overflow);\n-    /* we fully expect overflow */\n+    secp256k1_scalar_set_b32(&computed_r, c, NULL);\n     return secp256k1_scalar_eq(sigr, &computed_r);\n }\n #else\n@@ -285,14 +283,10 @@ static int secp256k1_ecdsa_sig_sign(const secp256k1_ecmult_gen_context *ctx, sec\n     secp256k1_fe_normalize(&r.y);\n     secp256k1_fe_get_b32(b, &r.x);\n     secp256k1_scalar_set_b32(sigr, b, &overflow);\n-    if (secp256k1_scalar_is_zero(sigr)) {\n-        /* P.x = order is on the curve, so technically sig->r could end up zero, which would be an invalid signature.\n-         * This branch is cryptographically unreachable as hitting it requires finding the discrete log of P.x = N.\n-         */\n-        secp256k1_gej_clear(&rp);\n-        secp256k1_ge_clear(&r);\n-        return 0;\n-    }\n+    /* These two conditions should be checked before calling */\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(sigr));\n+    VERIFY_CHECK(overflow == 0);\n+\n     if (recid) {\n         /* The overflow condition is cryptographically unreachable as hitting it requires finding the discrete log\n          * of some P where P.x >= order, and only 1 in about 2^127 points meet this criteria."
      },
      {
        "sha": "234c13a644233b15d84aa45183c5674ad37457ce",
        "filename": "src/secp256k1/src/field_10x26_impl.h",
        "status": "modified",
        "additions": 43,
        "deletions": 26,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/src/field_10x26_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/src/field_10x26_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_10x26_impl.h?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -38,10 +38,6 @@ static void secp256k1_fe_verify(const secp256k1_fe *a) {\n     }\n     VERIFY_CHECK(r == 1);\n }\n-#else\n-static void secp256k1_fe_verify(const secp256k1_fe *a) {\n-    (void)a;\n-}\n #endif\n \n static void secp256k1_fe_normalize(secp256k1_fe *r) {\n@@ -325,17 +321,17 @@ static int secp256k1_fe_cmp_var(const secp256k1_fe *a, const secp256k1_fe *b) {\n }\n \n static int secp256k1_fe_set_b32(secp256k1_fe *r, const unsigned char *a) {\n-    int i;\n-    r->n[0] = r->n[1] = r->n[2] = r->n[3] = r->n[4] = 0;\n-    r->n[5] = r->n[6] = r->n[7] = r->n[8] = r->n[9] = 0;\n-    for (i=0; i<32; i++) {\n-        int j;\n-        for (j=0; j<4; j++) {\n-            int limb = (8*i+2*j)/26;\n-            int shift = (8*i+2*j)%26;\n-            r->n[limb] |= (uint32_t)((a[31-i] >> (2*j)) & 0x3) << shift;\n-        }\n-    }\n+    r->n[0] = (uint32_t)a[31] | ((uint32_t)a[30] << 8) | ((uint32_t)a[29] << 16) | ((uint32_t)(a[28] & 0x3) << 24);\n+    r->n[1] = (uint32_t)((a[28] >> 2) & 0x3f) | ((uint32_t)a[27] << 6) | ((uint32_t)a[26] << 14) | ((uint32_t)(a[25] & 0xf) << 22);\n+    r->n[2] = (uint32_t)((a[25] >> 4) & 0xf) | ((uint32_t)a[24] << 4) | ((uint32_t)a[23] << 12) | ((uint32_t)(a[22] & 0x3f) << 20);\n+    r->n[3] = (uint32_t)((a[22] >> 6) & 0x3) | ((uint32_t)a[21] << 2) | ((uint32_t)a[20] << 10) | ((uint32_t)a[19] << 18);\n+    r->n[4] = (uint32_t)a[18] | ((uint32_t)a[17] << 8) | ((uint32_t)a[16] << 16) | ((uint32_t)(a[15] & 0x3) << 24);\n+    r->n[5] = (uint32_t)((a[15] >> 2) & 0x3f) | ((uint32_t)a[14] << 6) | ((uint32_t)a[13] << 14) | ((uint32_t)(a[12] & 0xf) << 22);\n+    r->n[6] = (uint32_t)((a[12] >> 4) & 0xf) | ((uint32_t)a[11] << 4) | ((uint32_t)a[10] << 12) | ((uint32_t)(a[9] & 0x3f) << 20);\n+    r->n[7] = (uint32_t)((a[9] >> 6) & 0x3) | ((uint32_t)a[8] << 2) | ((uint32_t)a[7] << 10) | ((uint32_t)a[6] << 18);\n+    r->n[8] = (uint32_t)a[5] | ((uint32_t)a[4] << 8) | ((uint32_t)a[3] << 16) | ((uint32_t)(a[2] & 0x3) << 24);\n+    r->n[9] = (uint32_t)((a[2] >> 2) & 0x3f) | ((uint32_t)a[1] << 6) | ((uint32_t)a[0] << 14);\n+\n     if (r->n[9] == 0x3FFFFFUL && (r->n[8] & r->n[7] & r->n[6] & r->n[5] & r->n[4] & r->n[3] & r->n[2]) == 0x3FFFFFFUL && (r->n[1] + 0x40UL + ((r->n[0] + 0x3D1UL) >> 26)) > 0x3FFFFFFUL) {\n         return 0;\n     }\n@@ -349,21 +345,42 @@ static int secp256k1_fe_set_b32(secp256k1_fe *r, const unsigned char *a) {\n \n /** Convert a field element to a 32-byte big endian value. Requires the input to be normalized */\n static void secp256k1_fe_get_b32(unsigned char *r, const secp256k1_fe *a) {\n-    int i;\n #ifdef VERIFY\n     VERIFY_CHECK(a->normalized);\n     secp256k1_fe_verify(a);\n #endif\n-    for (i=0; i<32; i++) {\n-        int j;\n-        int c = 0;\n-        for (j=0; j<4; j++) {\n-            int limb = (8*i+2*j)/26;\n-            int shift = (8*i+2*j)%26;\n-            c |= ((a->n[limb] >> shift) & 0x3) << (2 * j);\n-        }\n-        r[31-i] = c;\n-    }\n+    r[0] = (a->n[9] >> 14) & 0xff;\n+    r[1] = (a->n[9] >> 6) & 0xff;\n+    r[2] = ((a->n[9] & 0x3F) << 2) | ((a->n[8] >> 24) & 0x3);\n+    r[3] = (a->n[8] >> 16) & 0xff;\n+    r[4] = (a->n[8] >> 8) & 0xff;\n+    r[5] = a->n[8] & 0xff;\n+    r[6] = (a->n[7] >> 18) & 0xff;\n+    r[7] = (a->n[7] >> 10) & 0xff;\n+    r[8] = (a->n[7] >> 2) & 0xff;\n+    r[9] = ((a->n[7] & 0x3) << 6) | ((a->n[6] >> 20) & 0x3f);\n+    r[10] = (a->n[6] >> 12) & 0xff;\n+    r[11] = (a->n[6] >> 4) & 0xff;\n+    r[12] = ((a->n[6] & 0xf) << 4) | ((a->n[5] >> 22) & 0xf);\n+    r[13] = (a->n[5] >> 14) & 0xff;\n+    r[14] = (a->n[5] >> 6) & 0xff;\n+    r[15] = ((a->n[5] & 0x3f) << 2) | ((a->n[4] >> 24) & 0x3);\n+    r[16] = (a->n[4] >> 16) & 0xff;\n+    r[17] = (a->n[4] >> 8) & 0xff;\n+    r[18] = a->n[4] & 0xff;\n+    r[19] = (a->n[3] >> 18) & 0xff;\n+    r[20] = (a->n[3] >> 10) & 0xff;\n+    r[21] = (a->n[3] >> 2) & 0xff;\n+    r[22] = ((a->n[3] & 0x3) << 6) | ((a->n[2] >> 20) & 0x3f);\n+    r[23] = (a->n[2] >> 12) & 0xff;\n+    r[24] = (a->n[2] >> 4) & 0xff;\n+    r[25] = ((a->n[2] & 0xf) << 4) | ((a->n[1] >> 22) & 0xf);\n+    r[26] = (a->n[1] >> 14) & 0xff;\n+    r[27] = (a->n[1] >> 6) & 0xff;\n+    r[28] = ((a->n[1] & 0x3f) << 2) | ((a->n[0] >> 24) & 0x3);\n+    r[29] = (a->n[0] >> 16) & 0xff;\n+    r[30] = (a->n[0] >> 8) & 0xff;\n+    r[31] = a->n[0] & 0xff;\n }\n \n SECP256K1_INLINE static void secp256k1_fe_negate(secp256k1_fe *r, const secp256k1_fe *a, int m) {"
      },
      {
        "sha": "8e8b286baff86a7e7796380e977194c2255483c2",
        "filename": "src/secp256k1/src/field_5x52_impl.h",
        "status": "modified",
        "additions": 66,
        "deletions": 25,
        "changes": 91,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/src/field_5x52_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/src/field_5x52_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52_impl.h?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -49,10 +49,6 @@ static void secp256k1_fe_verify(const secp256k1_fe *a) {\n     }\n     VERIFY_CHECK(r == 1);\n }\n-#else\n-static void secp256k1_fe_verify(const secp256k1_fe *a) {\n-    (void)a;\n-}\n #endif\n \n static void secp256k1_fe_normalize(secp256k1_fe *r) {\n@@ -288,16 +284,40 @@ static int secp256k1_fe_cmp_var(const secp256k1_fe *a, const secp256k1_fe *b) {\n }\n \n static int secp256k1_fe_set_b32(secp256k1_fe *r, const unsigned char *a) {\n-    int i;\n-    r->n[0] = r->n[1] = r->n[2] = r->n[3] = r->n[4] = 0;\n-    for (i=0; i<32; i++) {\n-        int j;\n-        for (j=0; j<2; j++) {\n-            int limb = (8*i+4*j)/52;\n-            int shift = (8*i+4*j)%52;\n-            r->n[limb] |= (uint64_t)((a[31-i] >> (4*j)) & 0xF) << shift;\n-        }\n-    }\n+    r->n[0] = (uint64_t)a[31]\n+            | ((uint64_t)a[30] << 8)\n+            | ((uint64_t)a[29] << 16)\n+            | ((uint64_t)a[28] << 24)\n+            | ((uint64_t)a[27] << 32)\n+            | ((uint64_t)a[26] << 40)\n+            | ((uint64_t)(a[25] & 0xF)  << 48);\n+    r->n[1] = (uint64_t)((a[25] >> 4) & 0xF)\n+            | ((uint64_t)a[24] << 4)\n+            | ((uint64_t)a[23] << 12)\n+            | ((uint64_t)a[22] << 20)\n+            | ((uint64_t)a[21] << 28)\n+            | ((uint64_t)a[20] << 36)\n+            | ((uint64_t)a[19] << 44);\n+    r->n[2] = (uint64_t)a[18]\n+            | ((uint64_t)a[17] << 8)\n+            | ((uint64_t)a[16] << 16)\n+            | ((uint64_t)a[15] << 24)\n+            | ((uint64_t)a[14] << 32)\n+            | ((uint64_t)a[13] << 40)\n+            | ((uint64_t)(a[12] & 0xF) << 48);\n+    r->n[3] = (uint64_t)((a[12] >> 4) & 0xF)\n+            | ((uint64_t)a[11] << 4)\n+            | ((uint64_t)a[10] << 12)\n+            | ((uint64_t)a[9]  << 20)\n+            | ((uint64_t)a[8]  << 28)\n+            | ((uint64_t)a[7]  << 36)\n+            | ((uint64_t)a[6]  << 44);\n+    r->n[4] = (uint64_t)a[5]\n+            | ((uint64_t)a[4] << 8)\n+            | ((uint64_t)a[3] << 16)\n+            | ((uint64_t)a[2] << 24)\n+            | ((uint64_t)a[1] << 32)\n+            | ((uint64_t)a[0] << 40);\n     if (r->n[4] == 0x0FFFFFFFFFFFFULL && (r->n[3] & r->n[2] & r->n[1]) == 0xFFFFFFFFFFFFFULL && r->n[0] >= 0xFFFFEFFFFFC2FULL) {\n         return 0;\n     }\n@@ -311,21 +331,42 @@ static int secp256k1_fe_set_b32(secp256k1_fe *r, const unsigned char *a) {\n \n /** Convert a field element to a 32-byte big endian value. Requires the input to be normalized */\n static void secp256k1_fe_get_b32(unsigned char *r, const secp256k1_fe *a) {\n-    int i;\n #ifdef VERIFY\n     VERIFY_CHECK(a->normalized);\n     secp256k1_fe_verify(a);\n #endif\n-    for (i=0; i<32; i++) {\n-        int j;\n-        int c = 0;\n-        for (j=0; j<2; j++) {\n-            int limb = (8*i+4*j)/52;\n-            int shift = (8*i+4*j)%52;\n-            c |= ((a->n[limb] >> shift) & 0xF) << (4 * j);\n-        }\n-        r[31-i] = c;\n-    }\n+    r[0] = (a->n[4] >> 40) & 0xFF;\n+    r[1] = (a->n[4] >> 32) & 0xFF;\n+    r[2] = (a->n[4] >> 24) & 0xFF;\n+    r[3] = (a->n[4] >> 16) & 0xFF;\n+    r[4] = (a->n[4] >> 8) & 0xFF;\n+    r[5] = a->n[4] & 0xFF;\n+    r[6] = (a->n[3] >> 44) & 0xFF;\n+    r[7] = (a->n[3] >> 36) & 0xFF;\n+    r[8] = (a->n[3] >> 28) & 0xFF;\n+    r[9] = (a->n[3] >> 20) & 0xFF;\n+    r[10] = (a->n[3] >> 12) & 0xFF;\n+    r[11] = (a->n[3] >> 4) & 0xFF;\n+    r[12] = ((a->n[2] >> 48) & 0xF) | ((a->n[3] & 0xF) << 4);\n+    r[13] = (a->n[2] >> 40) & 0xFF;\n+    r[14] = (a->n[2] >> 32) & 0xFF;\n+    r[15] = (a->n[2] >> 24) & 0xFF;\n+    r[16] = (a->n[2] >> 16) & 0xFF;\n+    r[17] = (a->n[2] >> 8) & 0xFF;\n+    r[18] = a->n[2] & 0xFF;\n+    r[19] = (a->n[1] >> 44) & 0xFF;\n+    r[20] = (a->n[1] >> 36) & 0xFF;\n+    r[21] = (a->n[1] >> 28) & 0xFF;\n+    r[22] = (a->n[1] >> 20) & 0xFF;\n+    r[23] = (a->n[1] >> 12) & 0xFF;\n+    r[24] = (a->n[1] >> 4) & 0xFF;\n+    r[25] = ((a->n[0] >> 48) & 0xF) | ((a->n[1] & 0xF) << 4);\n+    r[26] = (a->n[0] >> 40) & 0xFF;\n+    r[27] = (a->n[0] >> 32) & 0xFF;\n+    r[28] = (a->n[0] >> 24) & 0xFF;\n+    r[29] = (a->n[0] >> 16) & 0xFF;\n+    r[30] = (a->n[0] >> 8) & 0xFF;\n+    r[31] = a->n[0] & 0xFF;\n }\n \n SECP256K1_INLINE static void secp256k1_fe_negate(secp256k1_fe *r, const secp256k1_fe *a, int m) {"
      },
      {
        "sha": "7d723532ff3e12c1767540d019e35ede17a7c6c4",
        "filename": "src/secp256k1/src/group_impl.h",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group_impl.h?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -200,12 +200,6 @@ static void secp256k1_gej_set_infinity(secp256k1_gej *r) {\n     secp256k1_fe_clear(&r->z);\n }\n \n-static void secp256k1_ge_set_infinity(secp256k1_ge *r) {\n-    r->infinity = 1;\n-    secp256k1_fe_clear(&r->x);\n-    secp256k1_fe_clear(&r->y);\n-}\n-\n static void secp256k1_gej_clear(secp256k1_gej *r) {\n     r->infinity = 0;\n     secp256k1_fe_clear(&r->x);"
      },
      {
        "sha": "9e30fb73dd7fb98b6e860cfb9054f1d66fb4089a",
        "filename": "src/secp256k1/src/modules/ecdh/main_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/src/modules/ecdh/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/src/modules/ecdh/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/ecdh/main_impl.h?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -16,10 +16,10 @@ int secp256k1_ecdh(const secp256k1_context* ctx, unsigned char *result, const se\n     secp256k1_gej res;\n     secp256k1_ge pt;\n     secp256k1_scalar s;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(result != NULL);\n     ARG_CHECK(point != NULL);\n     ARG_CHECK(scalar != NULL);\n-    (void)ctx;\n \n     secp256k1_pubkey_load(ctx, &pt, point);\n     secp256k1_scalar_set_b32(&s, scalar, &overflow);"
      },
      {
        "sha": "85a5d0a9a69e10d585c2bc2ad4df03f14cf0def6",
        "filename": "src/secp256k1/src/modules/ecdh/tests_impl.h",
        "status": "modified",
        "additions": 30,
        "deletions": 0,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/src/modules/ecdh/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/src/modules/ecdh/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/ecdh/tests_impl.h?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -7,6 +7,35 @@\n #ifndef _SECP256K1_MODULE_ECDH_TESTS_\n #define _SECP256K1_MODULE_ECDH_TESTS_\n \n+void test_ecdh_api(void) {\n+    /* Setup context that just counts errors */\n+    secp256k1_context *tctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n+    secp256k1_pubkey point;\n+    unsigned char res[32];\n+    unsigned char s_one[32] = { 0 };\n+    int32_t ecount = 0;\n+    s_one[31] = 1;\n+\n+    secp256k1_context_set_error_callback(tctx, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(tctx, counting_illegal_callback_fn, &ecount);\n+    CHECK(secp256k1_ec_pubkey_create(tctx, &point, s_one) == 1);\n+\n+    /* Check all NULLs are detected */\n+    CHECK(secp256k1_ecdh(tctx, res, &point, s_one) == 1);\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_ecdh(tctx, NULL, &point, s_one) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_ecdh(tctx, res, NULL, s_one) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdh(tctx, res, &point, NULL) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_ecdh(tctx, res, &point, s_one) == 1);\n+    CHECK(ecount == 3);\n+\n+    /* Cleanup */\n+    secp256k1_context_destroy(tctx);\n+}\n+\n void test_ecdh_generator_basepoint(void) {\n     unsigned char s_one[32] = { 0 };\n     secp256k1_pubkey point[2];\n@@ -68,6 +97,7 @@ void test_bad_scalar(void) {\n }\n \n void run_ecdh_tests(void) {\n+    test_ecdh_api();\n     test_ecdh_generator_basepoint();\n     test_bad_scalar();\n }"
      },
      {
        "sha": "c6fbe239813a3e45559bd36098d3d2ca2dac145a",
        "filename": "src/secp256k1/src/modules/recovery/main_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/src/modules/recovery/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/src/modules/recovery/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/main_impl.h?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -179,7 +179,7 @@ int secp256k1_ecdsa_recover(const secp256k1_context* ctx, secp256k1_pubkey *pubk\n     ARG_CHECK(pubkey != NULL);\n \n     secp256k1_ecdsa_recoverable_signature_load(ctx, &r, &s, &recid, signature);\n-    ARG_CHECK(recid >= 0 && recid < 4);\n+    VERIFY_CHECK(recid >= 0 && recid < 4);  /* should have been caught in parse_compact */\n     secp256k1_scalar_set_b32(&m, msg32, NULL);\n     if (secp256k1_ecdsa_sig_recover(&ctx->ecmult_ctx, &r, &s, &q, &m, recid)) {\n         secp256k1_pubkey_save(pubkey, &q);"
      },
      {
        "sha": "765c7dd81e958c9ca37ee50117b286e90b6c7f7f",
        "filename": "src/secp256k1/src/modules/recovery/tests_impl.h",
        "status": "modified",
        "additions": 143,
        "deletions": 0,
        "changes": 143,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/src/modules/recovery/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/src/modules/recovery/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/tests_impl.h?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -7,6 +7,146 @@\n #ifndef _SECP256K1_MODULE_RECOVERY_TESTS_\n #define _SECP256K1_MODULE_RECOVERY_TESTS_\n \n+static int recovery_test_nonce_function(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    (void) msg32;\n+    (void) key32;\n+    (void) algo16;\n+    (void) data;\n+\n+    /* On the first run, return 0 to force a second run */\n+    if (counter == 0) {\n+        memset(nonce32, 0, 32);\n+        return 1;\n+    }\n+    /* On the second run, return an overflow to force a third run */\n+    if (counter == 1) {\n+        memset(nonce32, 0xff, 32);\n+        return 1;\n+    }\n+    /* On the next run, return a valid nonce, but flip a coin as to whether or not to fail signing. */\n+    memset(nonce32, 1, 32);\n+    return secp256k1_rand_bits(1);\n+}\n+\n+void test_ecdsa_recovery_api(void) {\n+    /* Setup contexts that just count errors */\n+    secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    secp256k1_context *sign = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n+    secp256k1_context *vrfy = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n+    secp256k1_context *both = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    secp256k1_pubkey pubkey;\n+    secp256k1_pubkey recpubkey;\n+    secp256k1_ecdsa_signature normal_sig;\n+    secp256k1_ecdsa_recoverable_signature recsig;\n+    unsigned char privkey[32] = { 1 };\n+    unsigned char message[32] = { 2 };\n+    int32_t ecount = 0;\n+    int recid = 0;\n+    unsigned char sig[74];\n+    unsigned char zero_privkey[32] = { 0 };\n+    unsigned char over_privkey[32] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+                                       0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+                                       0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+                                       0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n+\n+    secp256k1_context_set_error_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(sign, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(vrfy, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(both, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(sign, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(vrfy, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(both, counting_illegal_callback_fn, &ecount);\n+\n+    /* Construct and verify corresponding public key. */\n+    CHECK(secp256k1_ec_seckey_verify(ctx, privkey) == 1);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey, privkey) == 1);\n+\n+    /* Check bad contexts and NULLs for signing */\n+    ecount = 0;\n+    CHECK(secp256k1_ecdsa_sign_recoverable(none, &recsig, message, privkey, NULL, NULL) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_ecdsa_sign_recoverable(sign, &recsig, message, privkey, NULL, NULL) == 1);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_ecdsa_sign_recoverable(vrfy, &recsig, message, privkey, NULL, NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, &recsig, message, privkey, NULL, NULL) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, NULL, message, privkey, NULL, NULL) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, &recsig, NULL, privkey, NULL, NULL) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, &recsig, message, NULL, NULL, NULL) == 0);\n+    CHECK(ecount == 5);\n+    /* This will fail or succeed randomly, and in either case will not ARG_CHECK failure */\n+    secp256k1_ecdsa_sign_recoverable(both, &recsig, message, privkey, recovery_test_nonce_function, NULL);\n+    CHECK(ecount == 5);\n+    /* These will all fail, but not in ARG_CHECK way */\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, &recsig, message, zero_privkey, NULL, NULL) == 0);\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, &recsig, message, over_privkey, NULL, NULL) == 0);\n+    /* This one will succeed. */\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, &recsig, message, privkey, NULL, NULL) == 1);\n+    CHECK(ecount == 5);\n+\n+    /* Check signing with a goofy nonce function */\n+\n+    /* Check bad contexts and NULLs for recovery */\n+    ecount = 0;\n+    CHECK(secp256k1_ecdsa_recover(none, &recpubkey, &recsig, message) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_ecdsa_recover(sign, &recpubkey, &recsig, message) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_recover(vrfy, &recpubkey, &recsig, message) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_recover(both, &recpubkey, &recsig, message) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_recover(both, NULL, &recsig, message) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_ecdsa_recover(both, &recpubkey, NULL, message) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_ecdsa_recover(both, &recpubkey, &recsig, NULL) == 0);\n+    CHECK(ecount == 5);\n+\n+    /* Check NULLs for conversion */\n+    CHECK(secp256k1_ecdsa_sign(both, &normal_sig, message, privkey, NULL, NULL) == 1);\n+    ecount = 0;\n+    CHECK(secp256k1_ecdsa_recoverable_signature_convert(both, NULL, &recsig) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_convert(both, &normal_sig, NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_convert(both, &normal_sig, &recsig) == 1);\n+\n+    /* Check NULLs for de/serialization */\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, &recsig, message, privkey, NULL, NULL) == 1);\n+    ecount = 0;\n+    CHECK(secp256k1_ecdsa_recoverable_signature_serialize_compact(both, NULL, &recid, &recsig) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_serialize_compact(both, sig, NULL, &recsig) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_serialize_compact(both, sig, &recid, NULL) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_serialize_compact(both, sig, &recid, &recsig) == 1);\n+\n+    CHECK(secp256k1_ecdsa_recoverable_signature_parse_compact(both, NULL, sig, recid) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_parse_compact(both, &recsig, NULL, recid) == 0);\n+    CHECK(ecount == 5);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_parse_compact(both, &recsig, sig, -1) == 0);\n+    CHECK(ecount == 6);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_parse_compact(both, &recsig, sig, 5) == 0);\n+    CHECK(ecount == 7);\n+    /* overflow in signature will fail but not affect ecount */\n+    memcpy(sig, over_privkey, 32);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_parse_compact(both, &recsig, sig, recid) == 0);\n+    CHECK(ecount == 7);\n+\n+    /* cleanup */\n+    secp256k1_context_destroy(none);\n+    secp256k1_context_destroy(sign);\n+    secp256k1_context_destroy(vrfy);\n+    secp256k1_context_destroy(both);\n+}\n+\n void test_ecdsa_recovery_end_to_end(void) {\n     unsigned char extra[32] = {0x00};\n     unsigned char privkey[32];\n@@ -241,6 +381,9 @@ void test_ecdsa_recovery_edge_cases(void) {\n \n void run_recovery_tests(void) {\n     int i;\n+    for (i = 0; i < count; i++) {\n+        test_ecdsa_recovery_api();\n+    }\n     for (i = 0; i < 64*count; i++) {\n         test_ecdsa_recovery_end_to_end();\n     }"
      },
      {
        "sha": "2690d86558a9a1973ee5f4cc9c339c527718c54c",
        "filename": "src/secp256k1/src/scalar_impl.h",
        "status": "modified",
        "additions": 67,
        "deletions": 104,
        "changes": 171,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_impl.h?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -66,88 +66,79 @@ static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar\n #else\n     secp256k1_scalar *t;\n     int i;\n-    /* First compute x ^ (2^N - 1) for some values of N. */\n-    secp256k1_scalar x2, x3, x4, x6, x7, x8, x15, x30, x60, x120, x127;\n+    /* First compute xN as x ^ (2^N - 1) for some values of N,\n+     * and uM as x ^ M for some values of M. */\n+    secp256k1_scalar x2, x3, x6, x8, x14, x28, x56, x112, x126;\n+    secp256k1_scalar u2, u5, u9, u11, u13;\n \n-    secp256k1_scalar_sqr(&x2,  x);\n-    secp256k1_scalar_mul(&x2, &x2,  x);\n+    secp256k1_scalar_sqr(&u2, x);\n+    secp256k1_scalar_mul(&x2, &u2,  x);\n+    secp256k1_scalar_mul(&u5, &u2, &x2);\n+    secp256k1_scalar_mul(&x3, &u5,  &u2);\n+    secp256k1_scalar_mul(&u9, &x3, &u2);\n+    secp256k1_scalar_mul(&u11, &u9, &u2);\n+    secp256k1_scalar_mul(&u13, &u11, &u2);\n \n-    secp256k1_scalar_sqr(&x3, &x2);\n-    secp256k1_scalar_mul(&x3, &x3,  x);\n-\n-    secp256k1_scalar_sqr(&x4, &x3);\n-    secp256k1_scalar_mul(&x4, &x4,  x);\n-\n-    secp256k1_scalar_sqr(&x6, &x4);\n+    secp256k1_scalar_sqr(&x6, &u13);\n     secp256k1_scalar_sqr(&x6, &x6);\n-    secp256k1_scalar_mul(&x6, &x6, &x2);\n-\n-    secp256k1_scalar_sqr(&x7, &x6);\n-    secp256k1_scalar_mul(&x7, &x7,  x);\n+    secp256k1_scalar_mul(&x6, &x6, &u11);\n \n-    secp256k1_scalar_sqr(&x8, &x7);\n-    secp256k1_scalar_mul(&x8, &x8,  x);\n+    secp256k1_scalar_sqr(&x8, &x6);\n+    secp256k1_scalar_sqr(&x8, &x8);\n+    secp256k1_scalar_mul(&x8, &x8,  &x2);\n \n-    secp256k1_scalar_sqr(&x15, &x8);\n-    for (i = 0; i < 6; i++) {\n-        secp256k1_scalar_sqr(&x15, &x15);\n+    secp256k1_scalar_sqr(&x14, &x8);\n+    for (i = 0; i < 5; i++) {\n+        secp256k1_scalar_sqr(&x14, &x14);\n     }\n-    secp256k1_scalar_mul(&x15, &x15, &x7);\n+    secp256k1_scalar_mul(&x14, &x14, &x6);\n \n-    secp256k1_scalar_sqr(&x30, &x15);\n-    for (i = 0; i < 14; i++) {\n-        secp256k1_scalar_sqr(&x30, &x30);\n+    secp256k1_scalar_sqr(&x28, &x14);\n+    for (i = 0; i < 13; i++) {\n+        secp256k1_scalar_sqr(&x28, &x28);\n     }\n-    secp256k1_scalar_mul(&x30, &x30, &x15);\n+    secp256k1_scalar_mul(&x28, &x28, &x14);\n \n-    secp256k1_scalar_sqr(&x60, &x30);\n-    for (i = 0; i < 29; i++) {\n-        secp256k1_scalar_sqr(&x60, &x60);\n+    secp256k1_scalar_sqr(&x56, &x28);\n+    for (i = 0; i < 27; i++) {\n+        secp256k1_scalar_sqr(&x56, &x56);\n     }\n-    secp256k1_scalar_mul(&x60, &x60, &x30);\n+    secp256k1_scalar_mul(&x56, &x56, &x28);\n \n-    secp256k1_scalar_sqr(&x120, &x60);\n-    for (i = 0; i < 59; i++) {\n-        secp256k1_scalar_sqr(&x120, &x120);\n+    secp256k1_scalar_sqr(&x112, &x56);\n+    for (i = 0; i < 55; i++) {\n+        secp256k1_scalar_sqr(&x112, &x112);\n     }\n-    secp256k1_scalar_mul(&x120, &x120, &x60);\n+    secp256k1_scalar_mul(&x112, &x112, &x56);\n \n-    secp256k1_scalar_sqr(&x127, &x120);\n-    for (i = 0; i < 6; i++) {\n-        secp256k1_scalar_sqr(&x127, &x127);\n+    secp256k1_scalar_sqr(&x126, &x112);\n+    for (i = 0; i < 13; i++) {\n+        secp256k1_scalar_sqr(&x126, &x126);\n     }\n-    secp256k1_scalar_mul(&x127, &x127, &x7);\n+    secp256k1_scalar_mul(&x126, &x126, &x14);\n \n-    /* Then accumulate the final result (t starts at x127). */\n-    t = &x127;\n-    for (i = 0; i < 2; i++) { /* 0 */\n+    /* Then accumulate the final result (t starts at x126). */\n+    t = &x126;\n+    for (i = 0; i < 3; i++) {\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n+    secp256k1_scalar_mul(t, t, &u5); /* 101 */\n     for (i = 0; i < 4; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n     }\n     secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n+    for (i = 0; i < 4; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 4; i++) { /* 0 */\n+    secp256k1_scalar_mul(t, t, &u5); /* 101 */\n+    for (i = 0; i < 5; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 3; i++) { /* 0 */\n+    secp256k1_scalar_mul(t, t, &u11); /* 1011 */\n+    for (i = 0; i < 4; i++) {\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, &x2); /* 11 */\n+    secp256k1_scalar_mul(t, t, &u11); /* 1011 */\n     for (i = 0; i < 4; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n     }\n@@ -156,38 +147,26 @@ static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar\n         secp256k1_scalar_sqr(t, t);\n     }\n     secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 4; i++) { /* 00 */\n+    for (i = 0; i < 6; i++) { /* 00 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n+    secp256k1_scalar_mul(t, t, &u13); /* 1101 */\n+    for (i = 0; i < 4; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n+    secp256k1_scalar_mul(t, t, &u5); /* 101 */\n+    for (i = 0; i < 3; i++) {\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n+    secp256k1_scalar_mul(t, t, &x3); /* 111 */\n     for (i = 0; i < 5; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, &x4); /* 1111 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 3; i++) { /* 00 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 4; i++) { /* 000 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n+    secp256k1_scalar_mul(t, t, &u9); /* 1001 */\n+    for (i = 0; i < 6; i++) { /* 000 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n+    secp256k1_scalar_mul(t, t, &u5); /* 101 */\n     for (i = 0; i < 10; i++) { /* 0000000 */\n         secp256k1_scalar_sqr(t, t);\n     }\n@@ -200,50 +179,34 @@ static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar\n         secp256k1_scalar_sqr(t, t);\n     }\n     secp256k1_scalar_mul(t, t, &x8); /* 11111111 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 3; i++) { /* 00 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 3; i++) { /* 00 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n     for (i = 0; i < 5; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, &x4); /* 1111 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n+    secp256k1_scalar_mul(t, t, &u9); /* 1001 */\n+    for (i = 0; i < 6; i++) { /* 00 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 5; i++) { /* 000 */\n+    secp256k1_scalar_mul(t, t, &u11); /* 1011 */\n+    for (i = 0; i < 4; i++) {\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 4; i++) { /* 00 */\n+    secp256k1_scalar_mul(t, t, &u13); /* 1101 */\n+    for (i = 0; i < 5; i++) {\n         secp256k1_scalar_sqr(t, t);\n     }\n     secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n+    for (i = 0; i < 6; i++) { /* 00 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 8; i++) { /* 000000 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 3; i++) { /* 0 */\n+    secp256k1_scalar_mul(t, t, &u13); /* 1101 */\n+    for (i = 0; i < 10; i++) { /* 000000 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 3; i++) { /* 00 */\n+    secp256k1_scalar_mul(t, t, &u13); /* 1101 */\n+    for (i = 0; i < 4; i++) {\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n+    secp256k1_scalar_mul(t, t, &u9); /* 1001 */\n     for (i = 0; i < 6; i++) { /* 00000 */\n         secp256k1_scalar_sqr(t, t);\n     }"
      },
      {
        "sha": "4f8c01655bd00eed0565b698f7029421b5fd1562",
        "filename": "src/secp256k1/src/secp256k1.c",
        "status": "modified",
        "additions": 27,
        "deletions": 4,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/secp256k1.c?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -424,6 +424,33 @@ int secp256k1_ec_pubkey_create(const secp256k1_context* ctx, secp256k1_pubkey *p\n     return ret;\n }\n \n+int secp256k1_ec_privkey_negate(const secp256k1_context* ctx, unsigned char *seckey) {\n+    secp256k1_scalar sec;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    secp256k1_scalar_set_b32(&sec, seckey, NULL);\n+    secp256k1_scalar_negate(&sec, &sec);\n+    secp256k1_scalar_get_b32(seckey, &sec);\n+\n+    return 1;\n+}\n+\n+int secp256k1_ec_pubkey_negate(const secp256k1_context* ctx, secp256k1_pubkey *pubkey) {\n+    int ret = 0;\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    ret = secp256k1_pubkey_load(ctx, &p, pubkey);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    if (ret) {\n+        secp256k1_ge_neg(&p, &p);\n+        secp256k1_pubkey_save(pubkey, &p);\n+    }\n+    return ret;\n+}\n+\n int secp256k1_ec_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n     secp256k1_scalar term;\n     secp256k1_scalar sec;\n@@ -552,10 +579,6 @@ int secp256k1_ec_pubkey_combine(const secp256k1_context* ctx, secp256k1_pubkey *\n # include \"modules/ecdh/main_impl.h\"\n #endif\n \n-#ifdef ENABLE_MODULE_SCHNORR\n-# include \"modules/schnorr/main_impl.h\"\n-#endif\n-\n #ifdef ENABLE_MODULE_RECOVERY\n # include \"modules/recovery/main_impl.h\"\n #endif"
      },
      {
        "sha": "3d9bd5ebb48d46dff2d677976f850ad8809592e7",
        "filename": "src/secp256k1/src/tests.c",
        "status": "modified",
        "additions": 31,
        "deletions": 20,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests.c?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -10,6 +10,7 @@\n \n #include <stdio.h>\n #include <stdlib.h>\n+#include <string.h>\n \n #include <time.h>\n \n@@ -135,6 +136,7 @@ void random_scalar_order(secp256k1_scalar *num) {\n \n void run_context_tests(void) {\n     secp256k1_pubkey pubkey;\n+    secp256k1_pubkey zero_pubkey;\n     secp256k1_ecdsa_signature sig;\n     unsigned char ctmp[32];\n     int32_t ecount;\n@@ -149,6 +151,8 @@ void run_context_tests(void) {\n     secp256k1_scalar msg, key, nonce;\n     secp256k1_scalar sigr, sigs;\n \n+    memset(&zero_pubkey, 0, sizeof(zero_pubkey));\n+\n     ecount = 0;\n     ecount2 = 10;\n     secp256k1_context_set_illegal_callback(vrfy, counting_illegal_callback_fn, &ecount);\n@@ -201,12 +205,20 @@ void run_context_tests(void) {\n     CHECK(ecount == 2);\n     CHECK(secp256k1_ec_pubkey_tweak_mul(sign, &pubkey, ctmp) == 0);\n     CHECK(ecount2 == 13);\n-    CHECK(secp256k1_ec_pubkey_tweak_mul(vrfy, &pubkey, ctmp) == 1);\n+    CHECK(secp256k1_ec_pubkey_negate(vrfy, &pubkey) == 1);\n     CHECK(ecount == 2);\n-    CHECK(secp256k1_context_randomize(vrfy, ctmp) == 0);\n+    CHECK(secp256k1_ec_pubkey_negate(sign, &pubkey) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ec_pubkey_negate(sign, NULL) == 0);\n+    CHECK(ecount2 == 14);\n+    CHECK(secp256k1_ec_pubkey_negate(vrfy, &zero_pubkey) == 0);\n     CHECK(ecount == 3);\n+    CHECK(secp256k1_ec_pubkey_tweak_mul(vrfy, &pubkey, ctmp) == 1);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_context_randomize(vrfy, ctmp) == 0);\n+    CHECK(ecount == 4);\n     CHECK(secp256k1_context_randomize(sign, NULL) == 1);\n-    CHECK(ecount2 == 13);\n+    CHECK(ecount2 == 14);\n     secp256k1_context_set_illegal_callback(vrfy, NULL, NULL);\n     secp256k1_context_set_illegal_callback(sign, NULL, NULL);\n \n@@ -1879,9 +1891,9 @@ void test_ge(void) {\n      *\n      * When the endomorphism code is compiled in, p5 = lambda*p1 and p6 = lambda^2*p1 are added as well.\n      */\n-    secp256k1_ge *ge = (secp256k1_ge *)malloc(sizeof(secp256k1_ge) * (1 + 4 * runs));\n-    secp256k1_gej *gej = (secp256k1_gej *)malloc(sizeof(secp256k1_gej) * (1 + 4 * runs));\n-    secp256k1_fe *zinv = (secp256k1_fe *)malloc(sizeof(secp256k1_fe) * (1 + 4 * runs));\n+    secp256k1_ge *ge = (secp256k1_ge *)checked_malloc(&ctx->error_callback, sizeof(secp256k1_ge) * (1 + 4 * runs));\n+    secp256k1_gej *gej = (secp256k1_gej *)checked_malloc(&ctx->error_callback, sizeof(secp256k1_gej) * (1 + 4 * runs));\n+    secp256k1_fe *zinv = (secp256k1_fe *)checked_malloc(&ctx->error_callback, sizeof(secp256k1_fe) * (1 + 4 * runs));\n     secp256k1_fe zf;\n     secp256k1_fe zfi2, zfi3;\n \n@@ -1919,7 +1931,7 @@ void test_ge(void) {\n \n     /* Compute z inverses. */\n     {\n-        secp256k1_fe *zs = malloc(sizeof(secp256k1_fe) * (1 + 4 * runs));\n+        secp256k1_fe *zs = checked_malloc(&ctx->error_callback, sizeof(secp256k1_fe) * (1 + 4 * runs));\n         for (i = 0; i < 4 * runs + 1; i++) {\n             if (i == 0) {\n                 /* The point at infinity does not have a meaningful z inverse. Any should do. */\n@@ -2020,7 +2032,7 @@ void test_ge(void) {\n     /* Test adding all points together in random order equals infinity. */\n     {\n         secp256k1_gej sum = SECP256K1_GEJ_CONST_INFINITY;\n-        secp256k1_gej *gej_shuffled = (secp256k1_gej *)malloc((4 * runs + 1) * sizeof(secp256k1_gej));\n+        secp256k1_gej *gej_shuffled = (secp256k1_gej *)checked_malloc(&ctx->error_callback, (4 * runs + 1) * sizeof(secp256k1_gej));\n         for (i = 0; i < 4 * runs + 1; i++) {\n             gej_shuffled[i] = gej[i];\n         }\n@@ -2041,9 +2053,9 @@ void test_ge(void) {\n \n     /* Test batch gej -> ge conversion with and without known z ratios. */\n     {\n-        secp256k1_fe *zr = (secp256k1_fe *)malloc((4 * runs + 1) * sizeof(secp256k1_fe));\n-        secp256k1_ge *ge_set_table = (secp256k1_ge *)malloc((4 * runs + 1) * sizeof(secp256k1_ge));\n-        secp256k1_ge *ge_set_all = (secp256k1_ge *)malloc((4 * runs + 1) * sizeof(secp256k1_ge));\n+        secp256k1_fe *zr = (secp256k1_fe *)checked_malloc(&ctx->error_callback, (4 * runs + 1) * sizeof(secp256k1_fe));\n+        secp256k1_ge *ge_set_table = (secp256k1_ge *)checked_malloc(&ctx->error_callback, (4 * runs + 1) * sizeof(secp256k1_ge));\n+        secp256k1_ge *ge_set_all = (secp256k1_ge *)checked_malloc(&ctx->error_callback, (4 * runs + 1) * sizeof(secp256k1_ge));\n         for (i = 0; i < 4 * runs + 1; i++) {\n             /* Compute gej[i + 1].z / gez[i].z (with gej[n].z taken to be 1). */\n             if (i < 4 * runs) {\n@@ -3436,6 +3448,7 @@ void test_ecdsa_end_to_end(void) {\n     unsigned char pubkeyc[65];\n     size_t pubkeyclen = 65;\n     secp256k1_pubkey pubkey;\n+    secp256k1_pubkey pubkey_tmp;\n     unsigned char seckey[300];\n     size_t seckeylen = 300;\n \n@@ -3457,6 +3470,13 @@ void test_ecdsa_end_to_end(void) {\n     memset(&pubkey, 0, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, pubkeyc, pubkeyclen) == 1);\n \n+    /* Verify negation changes the key and changes it back */\n+    memcpy(&pubkey_tmp, &pubkey, sizeof(pubkey));\n+    CHECK(secp256k1_ec_pubkey_negate(ctx, &pubkey_tmp) == 1);\n+    CHECK(memcmp(&pubkey_tmp, &pubkey, sizeof(pubkey)) != 0);\n+    CHECK(secp256k1_ec_pubkey_negate(ctx, &pubkey_tmp) == 1);\n+    CHECK(memcmp(&pubkey_tmp, &pubkey, sizeof(pubkey)) == 0);\n+\n     /* Verify private key import and export. */\n     CHECK(ec_privkey_export_der(ctx, seckey, &seckeylen, privkey, secp256k1_rand_bits(1) == 1));\n     CHECK(ec_privkey_import_der(ctx, privkey2, seckey, seckeylen) == 1);\n@@ -4383,10 +4403,6 @@ void run_ecdsa_openssl(void) {\n # include \"modules/ecdh/tests_impl.h\"\n #endif\n \n-#ifdef ENABLE_MODULE_SCHNORR\n-# include \"modules/schnorr/tests_impl.h\"\n-#endif\n-\n #ifdef ENABLE_MODULE_RECOVERY\n # include \"modules/recovery/tests_impl.h\"\n #endif\n@@ -4504,11 +4520,6 @@ int main(int argc, char **argv) {\n     run_ecdsa_openssl();\n #endif\n \n-#ifdef ENABLE_MODULE_SCHNORR\n-    /* Schnorr tests */\n-    run_schnorr_tests();\n-#endif\n-\n #ifdef ENABLE_MODULE_RECOVERY\n     /* ECDSA pubkey recovery tests */\n     run_recovery_tests();"
      },
      {
        "sha": "b040bb0733ddf1abef0b715b807d3133db37d2f8",
        "filename": "src/secp256k1/src/tests_exhaustive.c",
        "status": "modified",
        "additions": 142,
        "deletions": 1,
        "changes": 143,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests_exhaustive.c?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -26,6 +26,11 @@\n #include \"secp256k1.c\"\n #include \"testrand_impl.h\"\n \n+#ifdef ENABLE_MODULE_RECOVERY\n+#include \"src/modules/recovery/main_impl.h\"\n+#include \"include/secp256k1_recovery.h\"\n+#endif\n+\n /** stolen from tests.c */\n void ge_equals_ge(const secp256k1_ge *a, const secp256k1_ge *b) {\n     CHECK(a->infinity == b->infinity);\n@@ -77,7 +82,7 @@ int secp256k1_nonce_function_smallint(unsigned char *nonce32, const unsigned cha\n      * function with an increased `attempt`. So if attempt > 0 this means we\n      * need to change the nonce to avoid an infinite loop. */\n     if (attempt > 0) {\n-        (*idata)++;\n+        *idata = (*idata + 1) % EXHAUSTIVE_TEST_ORDER;\n     }\n     secp256k1_scalar_set_int(&s, *idata);\n     secp256k1_scalar_get_b32(nonce32, &s);\n@@ -244,6 +249,7 @@ void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *grou\n     for (i = 1; i < order; i++) {  /* message */\n         for (j = 1; j < order; j++) {  /* key */\n             for (k = 1; k < order; k++) {  /* nonce */\n+                const int starting_k = k;\n                 secp256k1_ecdsa_signature sig;\n                 secp256k1_scalar sk, msg, r, s, expected_r;\n                 unsigned char sk32[32], msg32[32];\n@@ -262,6 +268,11 @@ void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *grou\n                 CHECK(r == expected_r);\n                 CHECK((k * s) % order == (i + r * j) % order ||\n                       (k * (EXHAUSTIVE_TEST_ORDER - s)) % order == (i + r * j) % order);\n+\n+                /* Overflow means we've tried every possible nonce */\n+                if (k < starting_k) {\n+                    break;\n+                }\n             }\n         }\n     }\n@@ -276,6 +287,130 @@ void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *grou\n      */\n }\n \n+#ifdef ENABLE_MODULE_RECOVERY\n+void test_exhaustive_recovery_sign(const secp256k1_context *ctx, const secp256k1_ge *group, int order) {\n+    int i, j, k;\n+\n+    /* Loop */\n+    for (i = 1; i < order; i++) {  /* message */\n+        for (j = 1; j < order; j++) {  /* key */\n+            for (k = 1; k < order; k++) {  /* nonce */\n+                const int starting_k = k;\n+                secp256k1_fe r_dot_y_normalized;\n+                secp256k1_ecdsa_recoverable_signature rsig;\n+                secp256k1_ecdsa_signature sig;\n+                secp256k1_scalar sk, msg, r, s, expected_r;\n+                unsigned char sk32[32], msg32[32];\n+                int expected_recid;\n+                int recid;\n+                secp256k1_scalar_set_int(&msg, i);\n+                secp256k1_scalar_set_int(&sk, j);\n+                secp256k1_scalar_get_b32(sk32, &sk);\n+                secp256k1_scalar_get_b32(msg32, &msg);\n+\n+                secp256k1_ecdsa_sign_recoverable(ctx, &rsig, msg32, sk32, secp256k1_nonce_function_smallint, &k);\n+\n+                /* Check directly */\n+                secp256k1_ecdsa_recoverable_signature_load(ctx, &r, &s, &recid, &rsig);\n+                r_from_k(&expected_r, group, k);\n+                CHECK(r == expected_r);\n+                CHECK((k * s) % order == (i + r * j) % order ||\n+                      (k * (EXHAUSTIVE_TEST_ORDER - s)) % order == (i + r * j) % order);\n+                /* In computing the recid, there is an overflow condition that is disabled in\n+                 * scalar_low_impl.h `secp256k1_scalar_set_b32` because almost every r.y value\n+                 * will exceed the group order, and our signing code always holds out for r\n+                 * values that don't overflow, so with a proper overflow check the tests would\n+                 * loop indefinitely. */\n+                r_dot_y_normalized = group[k].y;\n+                secp256k1_fe_normalize(&r_dot_y_normalized);\n+                /* Also the recovery id is flipped depending if we hit the low-s branch */\n+                if ((k * s) % order == (i + r * j) % order) {\n+                    expected_recid = secp256k1_fe_is_odd(&r_dot_y_normalized) ? 1 : 0;\n+                } else {\n+                    expected_recid = secp256k1_fe_is_odd(&r_dot_y_normalized) ? 0 : 1;\n+                }\n+                CHECK(recid == expected_recid);\n+\n+                /* Convert to a standard sig then check */\n+                secp256k1_ecdsa_recoverable_signature_convert(ctx, &sig, &rsig);\n+                secp256k1_ecdsa_signature_load(ctx, &r, &s, &sig);\n+                /* Note that we compute expected_r *after* signing -- this is important\n+                 * because our nonce-computing function function might change k during\n+                 * signing. */\n+                r_from_k(&expected_r, group, k);\n+                CHECK(r == expected_r);\n+                CHECK((k * s) % order == (i + r * j) % order ||\n+                      (k * (EXHAUSTIVE_TEST_ORDER - s)) % order == (i + r * j) % order);\n+\n+                /* Overflow means we've tried every possible nonce */\n+                if (k < starting_k) {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+void test_exhaustive_recovery_verify(const secp256k1_context *ctx, const secp256k1_ge *group, int order) {\n+    /* This is essentially a copy of test_exhaustive_verify, with recovery added */\n+    int s, r, msg, key;\n+    for (s = 1; s < order; s++) {\n+        for (r = 1; r < order; r++) {\n+            for (msg = 1; msg < order; msg++) {\n+                for (key = 1; key < order; key++) {\n+                    secp256k1_ge nonconst_ge;\n+                    secp256k1_ecdsa_recoverable_signature rsig;\n+                    secp256k1_ecdsa_signature sig;\n+                    secp256k1_pubkey pk;\n+                    secp256k1_scalar sk_s, msg_s, r_s, s_s;\n+                    secp256k1_scalar s_times_k_s, msg_plus_r_times_sk_s;\n+                    int recid = 0;\n+                    int k, should_verify;\n+                    unsigned char msg32[32];\n+\n+                    secp256k1_scalar_set_int(&s_s, s);\n+                    secp256k1_scalar_set_int(&r_s, r);\n+                    secp256k1_scalar_set_int(&msg_s, msg);\n+                    secp256k1_scalar_set_int(&sk_s, key);\n+                    secp256k1_scalar_get_b32(msg32, &msg_s);\n+\n+                    /* Verify by hand */\n+                    /* Run through every k value that gives us this r and check that *one* works.\n+                     * Note there could be none, there could be multiple, ECDSA is weird. */\n+                    should_verify = 0;\n+                    for (k = 0; k < order; k++) {\n+                        secp256k1_scalar check_x_s;\n+                        r_from_k(&check_x_s, group, k);\n+                        if (r_s == check_x_s) {\n+                            secp256k1_scalar_set_int(&s_times_k_s, k);\n+                            secp256k1_scalar_mul(&s_times_k_s, &s_times_k_s, &s_s);\n+                            secp256k1_scalar_mul(&msg_plus_r_times_sk_s, &r_s, &sk_s);\n+                            secp256k1_scalar_add(&msg_plus_r_times_sk_s, &msg_plus_r_times_sk_s, &msg_s);\n+                            should_verify |= secp256k1_scalar_eq(&s_times_k_s, &msg_plus_r_times_sk_s);\n+                        }\n+                    }\n+                    /* nb we have a \"high s\" rule */\n+                    should_verify &= !secp256k1_scalar_is_high(&s_s);\n+\n+                    /* We would like to try recovering the pubkey and checking that it matches,\n+                     * but pubkey recovery is impossible in the exhaustive tests (the reason\n+                     * being that there are 12 nonzero r values, 12 nonzero points, and no\n+                     * overlap between the sets, so there are no valid signatures). */\n+\n+                    /* Verify by converting to a standard signature and calling verify */\n+                    secp256k1_ecdsa_recoverable_signature_save(&rsig, &r_s, &s_s, recid);\n+                    secp256k1_ecdsa_recoverable_signature_convert(ctx, &sig, &rsig);\n+                    memcpy(&nonconst_ge, &group[sk_s], sizeof(nonconst_ge));\n+                    secp256k1_pubkey_save(&pk, &nonconst_ge);\n+                    CHECK(should_verify ==\n+                          secp256k1_ecdsa_verify(ctx, &sig, msg32, &pk));\n+                }\n+            }\n+        }\n+    }\n+}\n+#endif\n+\n int main(void) {\n     int i;\n     secp256k1_gej groupj[EXHAUSTIVE_TEST_ORDER];\n@@ -324,6 +459,12 @@ int main(void) {\n     test_exhaustive_sign(ctx, group, EXHAUSTIVE_TEST_ORDER);\n     test_exhaustive_verify(ctx, group, EXHAUSTIVE_TEST_ORDER);\n \n+#ifdef ENABLE_MODULE_RECOVERY\n+    test_exhaustive_recovery_sign(ctx, group, EXHAUSTIVE_TEST_ORDER);\n+    test_exhaustive_recovery_verify(ctx, group, EXHAUSTIVE_TEST_ORDER);\n+#endif\n+\n+    secp256k1_context_destroy(ctx);\n     return 0;\n }\n "
      },
      {
        "sha": "4092a86c9175cb7815cd4ebe5cf791940f72fb47",
        "filename": "src/secp256k1/src/util.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/secp256k1/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/util.h?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -57,7 +57,10 @@ static SECP256K1_INLINE void secp256k1_callback_call(const secp256k1_callback *\n #endif\n \n /* Like assert(), but when VERIFY is defined, and side-effect safe. */\n-#ifdef VERIFY\n+#if defined(COVERAGE)\n+#define VERIFY_CHECK(check)\n+#define VERIFY_SETUP(stmt)\n+#elif defined(VERIFY)\n #define VERIFY_CHECK CHECK\n #define VERIFY_SETUP(stmt) do { stmt; } while(0)\n #else"
      },
      {
        "sha": "78bfe02b8926ec99063e13fecba846fac52a2051",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -3261,9 +3261,9 @@ std::map<CTxDestination, CAmount> CWallet::GetAddressBalances()\n \n     {\n         LOCK(cs_wallet);\n-        BOOST_FOREACH(PAIRTYPE(uint256, CWalletTx) walletEntry, mapWallet)\n+        for (const auto& walletEntry : mapWallet)\n         {\n-            CWalletTx *pcoin = &walletEntry.second;\n+            const CWalletTx *pcoin = &walletEntry.second;\n \n             if (!pcoin->IsTrusted())\n                 continue;\n@@ -3301,9 +3301,9 @@ std::set< std::set<CTxDestination> > CWallet::GetAddressGroupings()\n     std::set< std::set<CTxDestination> > groupings;\n     std::set<CTxDestination> grouping;\n \n-    BOOST_FOREACH(PAIRTYPE(uint256, CWalletTx) walletEntry, mapWallet)\n+    for (const auto& walletEntry : mapWallet)\n     {\n-        CWalletTx *pcoin = &walletEntry.second;\n+        const CWalletTx *pcoin = &walletEntry.second;\n \n         if (pcoin->tx->vin.size() > 0)\n         {"
      },
      {
        "sha": "c87c02492d7cc488196706311d65bff7f284ff81",
        "filename": "test/functional/abandonconflict.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/abandonconflict.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/abandonconflict.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/abandonconflict.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -73,8 +73,8 @@ def run_test(self):\n \n         # Restart the node with a higher min relay fee so the parent tx is no longer in mempool\n         # TODO: redo with eviction\n-        stop_node(self.nodes[0],0)\n-        self.nodes[0]=start_node(0, self.options.tmpdir, [\"-minrelaytxfee=0.0001\"])\n+        self.stop_node(0)\n+        self.nodes[0] = self.start_node(0, self.options.tmpdir, [\"-minrelaytxfee=0.0001\"])\n \n         # Verify txs no longer in either node's mempool\n         assert_equal(len(self.nodes[0].getrawmempool()), 0)\n@@ -100,8 +100,8 @@ def run_test(self):\n         balance = newbalance\n \n         # Verify that even with a low min relay fee, the tx is not reaccepted from wallet on startup once abandoned\n-        stop_node(self.nodes[0],0)\n-        self.nodes[0]=start_node(0, self.options.tmpdir, [\"-minrelaytxfee=0.00001\"])\n+        self.stop_node(0)\n+        self.nodes[0] = self.start_node(0, self.options.tmpdir, [\"-minrelaytxfee=0.00001\"])\n         assert_equal(len(self.nodes[0].getrawmempool()), 0)\n         assert_equal(self.nodes[0].getbalance(), balance)\n \n@@ -120,8 +120,8 @@ def run_test(self):\n         balance = newbalance\n \n         # Remove using high relay fee again\n-        stop_node(self.nodes[0],0)\n-        self.nodes[0]=start_node(0, self.options.tmpdir, [\"-minrelaytxfee=0.0001\"])\n+        self.stop_node(0)\n+        self.nodes[0] = self.start_node(0, self.options.tmpdir, [\"-minrelaytxfee=0.0001\"])\n         assert_equal(len(self.nodes[0].getrawmempool()), 0)\n         newbalance = self.nodes[0].getbalance()\n         assert_equal(newbalance, balance - Decimal(\"24.9996\"))"
      },
      {
        "sha": "9d17faac51ba2a5da6e62636f35140d83a1516a3",
        "filename": "test/functional/assumevalid.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/assumevalid.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/assumevalid.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/assumevalid.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -45,7 +45,7 @@\n                                      msg_headers)\n from test_framework.script import (CScript, OP_TRUE)\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import (start_node, p2p_port, assert_equal)\n+from test_framework.util import (p2p_port, assert_equal)\n \n class BaseNode(NodeConnCB):\n     def send_header_for_blocks(self, new_blocks):\n@@ -63,7 +63,7 @@ def setup_network(self):\n         # Start node0. We don't start the other nodes yet since\n         # we need to pre-mine a block with an invalid transaction\n         # signature so we can pass in the block hash as assumevalid.\n-        self.nodes = [start_node(0, self.options.tmpdir)]\n+        self.nodes = [self.start_node(0, self.options.tmpdir)]\n \n     def send_blocks_until_disconnected(self, node):\n         \"\"\"Keep sending blocks to the node until we're disconnected.\"\"\"\n@@ -162,14 +162,14 @@ def run_test(self):\n             height += 1\n \n         # Start node1 and node2 with assumevalid so they accept a block with a bad signature.\n-        self.nodes.append(start_node(1, self.options.tmpdir,\n+        self.nodes.append(self.start_node(1, self.options.tmpdir,\n                                      [\"-assumevalid=\" + hex(block102.sha256)]))\n         node1 = BaseNode()  # connects to node1\n         connections.append(NodeConn('127.0.0.1', p2p_port(1), self.nodes[1], node1))\n         node1.add_connection(connections[1])\n         node1.wait_for_verack()\n \n-        self.nodes.append(start_node(2, self.options.tmpdir,\n+        self.nodes.append(self.start_node(2, self.options.tmpdir,\n                                      [\"-assumevalid=\" + hex(block102.sha256)]))\n         node2 = BaseNode()  # connects to node2\n         connections.append(NodeConn('127.0.0.1', p2p_port(2), self.nodes[2], node2))"
      },
      {
        "sha": "b90b0ca62842eb28d04a25f5ff96ce19df2d56d1",
        "filename": "test/functional/bip9-softforks.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/bip9-softforks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/bip9-softforks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bip9-softforks.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -239,7 +239,7 @@ def test_BIP(self, bipName, activated_version, invalidate, invalidatePostSignatu\n \n         # Restart all\n         self.test.clear_all_connections()\n-        stop_nodes(self.nodes)\n+        self.stop_nodes()\n         shutil.rmtree(self.options.tmpdir + \"/node0\")\n         self.setup_chain()\n         self.setup_network()"
      },
      {
        "sha": "d42bab6cbfae98db8d5930ef4b0103be22cbbf19",
        "filename": "test/functional/bumpfee.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/bumpfee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/bumpfee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bumpfee.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -38,12 +38,12 @@ def __init__(self):\n     def setup_network(self, split=False):\n         extra_args = [[\"-prematurewitness\", \"-walletprematurewitness\", \"-walletrbf={}\".format(i)]\n                       for i in range(self.num_nodes)]\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n+        self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n \n         # Encrypt wallet for test_locked_wallet_fails test\n         self.nodes[1].encryptwallet(WALLET_PASSPHRASE)\n         bitcoind_processes[1].wait()\n-        self.nodes[1] = start_node(1, self.options.tmpdir, extra_args[1])\n+        self.nodes[1] = self.start_node(1, self.options.tmpdir, extra_args[1])\n         self.nodes[1].walletpassphrase(WALLET_PASSPHRASE, WALLET_PASSPHRASE_TIMEOUT)\n \n         connect_nodes_bi(self.nodes, 0, 1)"
      },
      {
        "sha": "89b68aeb25e6a0bf8120af1f7bac0126e1b7e647",
        "filename": "test/functional/disconnect_ban.py",
        "status": "modified",
        "additions": 3,
        "deletions": 6,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/disconnect_ban.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/disconnect_ban.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/disconnect_ban.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -9,10 +9,7 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (assert_equal,\n                                  assert_raises_jsonrpc,\n-                                 connect_nodes_bi,\n-                                 start_node,\n-                                 stop_node,\n-                                 )\n+                                 connect_nodes_bi)\n \n class DisconnectBanTest(BitcoinTestFramework):\n \n@@ -68,9 +65,9 @@ def run_test(self):\n         self.nodes[1].setmocktime(old_time + 3)\n         assert_equal(len(self.nodes[1].listbanned()), 3)\n \n-        stop_node(self.nodes[1], 1)\n+        self.stop_node(1)\n \n-        self.nodes[1] = start_node(1, self.options.tmpdir)\n+        self.nodes[1] = self.start_node(1, self.options.tmpdir)\n         listAfterShutdown = self.nodes[1].listbanned()\n         assert_equal(\"127.0.0.0/24\", listAfterShutdown[0]['address'])\n         assert_equal(\"127.0.0.0/32\", listAfterShutdown[1]['address'])"
      },
      {
        "sha": "3bcf0a679511f68a4e03b16e36a5788eb60c88af",
        "filename": "test/functional/forknotify.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/forknotify.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/forknotify.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/forknotify.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -21,10 +21,10 @@ def setup_network(self):\n         self.alert_filename = os.path.join(self.options.tmpdir, \"alert.txt\")\n         with open(self.alert_filename, 'w', encoding='utf8'):\n             pass  # Just open then close to create zero-length file\n-        self.nodes.append(start_node(0, self.options.tmpdir,\n+        self.nodes.append(self.start_node(0, self.options.tmpdir,\n                             [\"-blockversion=2\", \"-alertnotify=echo %s >> \\\"\" + self.alert_filename + \"\\\"\"]))\n         # Node1 mines block.version=211 blocks\n-        self.nodes.append(start_node(1, self.options.tmpdir,\n+        self.nodes.append(self.start_node(1, self.options.tmpdir,\n                                 [\"-blockversion=211\"]))\n         connect_nodes(self.nodes[1], 0)\n "
      },
      {
        "sha": "c41afe2b93853dd5115f75d4580c2f8bb9b8a3a4",
        "filename": "test/functional/fundrawtransaction.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/fundrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/fundrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/fundrawtransaction.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -448,13 +448,13 @@ def run_test(self):\n \n         ############################################################\n         # locked wallet test\n+        self.stop_node(0)\n+        self.stop_node(2)\n+        self.stop_node(3)\n         self.nodes[1].encryptwallet(\"test\")\n         self.nodes.pop(1)\n-        stop_node(self.nodes[0], 0)\n-        stop_node(self.nodes[1], 2)\n-        stop_node(self.nodes[2], 3)\n \n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir)\n+        self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir)\n         # This test is not meant to test fee estimation and we'd like\n         # to be sure all txs are sent at a consistent desired feerate\n         for node in self.nodes:"
      },
      {
        "sha": "4fc507821760e8492e32fe1ccd8a622a573de719",
        "filename": "test/functional/import-rescan.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/import-rescan.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/import-rescan.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/import-rescan.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -21,7 +21,7 @@\n \n from test_framework.authproxy import JSONRPCException\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import (start_nodes, connect_nodes, sync_blocks, assert_equal, set_node_times)\n+from test_framework.util import (connect_nodes, sync_blocks, assert_equal, set_node_times)\n \n import collections\n import enum\n@@ -121,7 +121,7 @@ def setup_network(self):\n             if import_node.prune:\n                 extra_args[i] += [\"-prune=1\"]\n \n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n+        self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n         for i in range(1, self.num_nodes):\n             connect_nodes(self.nodes[i], 0)\n "
      },
      {
        "sha": "e83e85de138ef421ef01783ee1ef024ae609cfda",
        "filename": "test/functional/importmulti.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/importmulti.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -428,8 +428,8 @@ def run_test (self):\n \n \n         # restart nodes to check for proper serialization/deserialization of watch only address\n-        stop_nodes(self.nodes)\n-        self.nodes = start_nodes(2, self.options.tmpdir)\n+        self.stop_nodes()\n+        self.nodes = self.start_nodes(2, self.options.tmpdir)\n         address_assert = self.nodes[1].validateaddress(watchonly_address)\n         assert_equal(address_assert['iswatchonly'], True)\n         assert_equal(address_assert['ismine'], False)"
      },
      {
        "sha": "f23a427d1fff72c3a6f79edd91dfe196186d50c9",
        "filename": "test/functional/keypool.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/keypool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/keypool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/keypool.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -20,7 +20,7 @@ def run_test(self):\n         nodes[0].encryptwallet('test')\n         bitcoind_processes[0].wait()\n         # Restart node 0\n-        nodes[0] = start_node(0, self.options.tmpdir)\n+        nodes[0] = self.start_node(0, self.options.tmpdir)\n         # Keep creating keys\n         addr = nodes[0].getnewaddress()\n         addr_data = nodes[0].validateaddress(addr)"
      },
      {
        "sha": "f69f1c5724ef35694fdb7534018904da673da787",
        "filename": "test/functional/listtransactions.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/listtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/listtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/listtransactions.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -24,7 +24,7 @@ def __init__(self):\n     def setup_nodes(self):\n         #This test requires mocktime\n         enable_mocktime()\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir)\n+        self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir)\n \n     def run_test(self):\n         # Simple send, 0 to 1:"
      },
      {
        "sha": "66e5bd29e6d244b9e50e108e95b2d517d9f2363e",
        "filename": "test/functional/maxuploadtarget.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/maxuploadtarget.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/maxuploadtarget.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/maxuploadtarget.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -146,8 +146,8 @@ def run_test(self):\n \n         #stop and start node 0 with 1MB maxuploadtarget, whitelist 127.0.0.1\n         self.log.info(\"Restarting nodes with -whitelist=127.0.0.1\")\n-        stop_node(self.nodes[0], 0)\n-        self.nodes[0] = start_node(0, self.options.tmpdir, [\"-whitelist=127.0.0.1\", \"-maxuploadtarget=1\", \"-blockmaxsize=999000\"])\n+        self.stop_node(0)\n+        self.nodes[0] = self.start_node(0, self.options.tmpdir, [\"-whitelist=127.0.0.1\", \"-maxuploadtarget=1\", \"-blockmaxsize=999000\"])\n \n         #recreate/reconnect a test node\n         test_nodes = [TestNode()]"
      },
      {
        "sha": "e0889fd5e9d89eb0bb89cb9ccc8be9fdb5801786",
        "filename": "test/functional/mempool_persist.py",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/mempool_persist.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/mempool_persist.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_persist.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -63,27 +63,27 @@ def run_test(self):\n         assert_equal(len(self.nodes[1].getrawmempool()), 5)\n \n         self.log.debug(\"Stop-start node0 and node1. Verify that node0 has the transactions in its mempool and node1 does not.\")\n-        stop_nodes(self.nodes)\n+        self.stop_nodes()\n         self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir))\n-        self.nodes.append(start_node(1, self.options.tmpdir))\n+        self.nodes.append(self.start_node(0, self.options.tmpdir))\n+        self.nodes.append(self.start_node(1, self.options.tmpdir))\n         # Give bitcoind a second to reload the mempool\n         time.sleep(1)\n         assert wait_until(lambda: len(self.nodes[0].getrawmempool()) == 5)\n         assert_equal(len(self.nodes[1].getrawmempool()), 0)\n \n         self.log.debug(\"Stop-start node0 with -persistmempool=0. Verify that it doesn't load its mempool.dat file.\")\n-        stop_nodes(self.nodes)\n+        self.stop_nodes()\n         self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-persistmempool=0\"]))\n+        self.nodes.append(self.start_node(0, self.options.tmpdir, [\"-persistmempool=0\"]))\n         # Give bitcoind a second to reload the mempool\n         time.sleep(1)\n         assert_equal(len(self.nodes[0].getrawmempool()), 0)\n \n         self.log.debug(\"Stop-start node0. Verify that it has the transactions in its mempool.\")\n-        stop_nodes(self.nodes)\n+        self.stop_nodes()\n         self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir))\n+        self.nodes.append(self.start_node(0, self.options.tmpdir))\n         assert wait_until(lambda: len(self.nodes[0].getrawmempool()) == 5)\n \n if __name__ == '__main__':"
      },
      {
        "sha": "ab97596ba35bca1f7f5282612d76bf953ccd0b74",
        "filename": "test/functional/p2p-segwit.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/p2p-segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/p2p-segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-segwit.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -1495,8 +1495,8 @@ def test_upgrade_after_activation(self, node, node_id):\n         sync_blocks(self.nodes)\n \n         # Restart with the new binary\n-        stop_node(node, node_id)\n-        self.nodes[node_id] = start_node(node_id, self.options.tmpdir)\n+        self.stop_node(node_id)\n+        self.nodes[node_id] = self.start_node(node_id, self.options.tmpdir)\n         connect_nodes(self.nodes[0], node_id)\n \n         sync_blocks(self.nodes)"
      },
      {
        "sha": "df7e8ce5c1630999ee95a3eb32ac9b2a416b00d9",
        "filename": "test/functional/p2p-versionbits-warning.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/p2p-versionbits-warning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/p2p-versionbits-warning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-versionbits-warning.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -108,22 +108,22 @@ def run_test(self):\n         # is cleared, and restart the node. This should move the versionbit state\n         # to ACTIVE.\n         self.nodes[0].generate(VB_PERIOD)\n-        stop_nodes(self.nodes)\n+        self.stop_nodes()\n         # Empty out the alert file\n         with open(self.alert_filename, 'w', encoding='utf8') as _:\n             pass\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, self.extra_args)\n+        self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir, self.extra_args)\n \n         # Connecting one block should be enough to generate an error.\n         self.nodes[0].generate(1)\n         assert(WARN_UNKNOWN_RULES_ACTIVE in self.nodes[0].getinfo()[\"errors\"])\n         assert(WARN_UNKNOWN_RULES_ACTIVE in self.nodes[0].getmininginfo()[\"errors\"])\n         assert(WARN_UNKNOWN_RULES_ACTIVE in self.nodes[0].getnetworkinfo()[\"warnings\"])\n-        stop_nodes(self.nodes)\n+        self.stop_nodes()\n         self.test_versionbits_in_alert_file()\n \n         # Test framework expects the node to still be running...\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, self.extra_args)\n+        self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir, self.extra_args)\n \n if __name__ == '__main__':\n     VersionBitsWarningTest().main()"
      },
      {
        "sha": "ae6f843ddce7b0e9bd2935384e1e62d989c11c9c",
        "filename": "test/functional/proxy_test.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/proxy_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/proxy_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/proxy_test.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -35,7 +35,6 @@\n from test_framework.util import (\n     PORT_MIN,\n     PORT_RANGE,\n-    start_nodes,\n     assert_equal,\n )\n from test_framework.netutil import test_ipv6_local\n@@ -90,7 +89,7 @@ def setup_nodes(self):\n             ]\n         if self.have_ipv6:\n             args[3] = ['-listen', '-proxy=[%s]:%i' % (self.conf3.addr),'-proxyrandomize=0', '-noonion']\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, extra_args=args)\n+        self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir, extra_args=args)\n \n     def node_test(self, node, proxies, auth, test_onion=True):\n         rv = []"
      },
      {
        "sha": "4c3501ad7798a818253f6868d5d556b7b526f80f",
        "filename": "test/functional/pruning.py",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/pruning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/pruning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/pruning.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -98,7 +98,7 @@ def create_chain_with_staleblocks(self):\n             # Node 2 stays connected, so it hears about the stale blocks and then reorg's when node0 reconnects\n             # Stopping node 0 also clears its mempool, so it doesn't have node1's transactions to accidentally mine\n             self.stop_node(0)\n-            self.nodes[0]=start_node(0, self.options.tmpdir, self.full_node_default_args, timewait=900)\n+            self.nodes[0]=self.start_node(0, self.options.tmpdir, self.full_node_default_args, timewait=900)\n             # Mine 24 blocks in node 1\n             for i in range(24):\n                 if j == 0:\n@@ -126,7 +126,7 @@ def reorg_test(self):\n         # Reboot node 1 to clear its mempool (hopefully make the invalidate faster)\n         # Lower the block max size so we don't keep mining all our big mempool transactions (from disconnected blocks)\n         self.stop_node(1)\n-        self.nodes[1]=start_node(1, self.options.tmpdir, [\"-maxreceivebuffer=20000\",\"-blockmaxsize=5000\", \"-checkblocks=5\", \"-disablesafemode\"], timewait=900)\n+        self.nodes[1] = self.start_node(1, self.options.tmpdir, [\"-maxreceivebuffer=20000\",\"-blockmaxsize=5000\", \"-checkblocks=5\", \"-disablesafemode\"], timewait=900)\n \n         height = self.nodes[1].getblockcount()\n         self.log.info(\"Current block height: %d\" % height)\n@@ -149,7 +149,7 @@ def reorg_test(self):\n \n         # Reboot node1 to clear those giant tx's from mempool\n         self.stop_node(1)\n-        self.nodes[1]=start_node(1, self.options.tmpdir, [\"-maxreceivebuffer=20000\",\"-blockmaxsize=5000\", \"-checkblocks=5\", \"-disablesafemode\"], timewait=900)\n+        self.nodes[1] = self.start_node(1, self.options.tmpdir, [\"-maxreceivebuffer=20000\",\"-blockmaxsize=5000\", \"-checkblocks=5\", \"-disablesafemode\"], timewait=900)\n \n         self.log.info(\"Generating new longer chain of 300 more blocks\")\n         self.nodes[1].generate(300)\n@@ -227,13 +227,13 @@ def reorg_back(self):\n \n     def manual_test(self, node_number, use_timestamp):\n         # at this point, node has 995 blocks and has not yet run in prune mode\n-        node = self.nodes[node_number] = start_node(node_number, self.options.tmpdir, timewait=900)\n+        node = self.nodes[node_number] = self.start_node(node_number, self.options.tmpdir, timewait=900)\n         assert_equal(node.getblockcount(), 995)\n         assert_raises_jsonrpc(-1, \"not in prune mode\", node.pruneblockchain, 500)\n         self.stop_node(node_number)\n \n         # now re-start in manual pruning mode\n-        node = self.nodes[node_number] = start_node(node_number, self.options.tmpdir, [\"-prune=1\"], timewait=900)\n+        node = self.nodes[node_number] = self.start_node(node_number, self.options.tmpdir, [\"-prune=1\"], timewait=900)\n         assert_equal(node.getblockcount(), 995)\n \n         def height(index):\n@@ -307,15 +307,15 @@ def has_block(index):\n \n         # stop node, start back up with auto-prune at 550MB, make sure still runs\n         self.stop_node(node_number)\n-        self.nodes[node_number] = start_node(node_number, self.options.tmpdir, [\"-prune=550\"], timewait=900)\n+        self.nodes[node_number] = self.start_node(node_number, self.options.tmpdir, [\"-prune=550\"], timewait=900)\n \n         self.log.info(\"Success\")\n \n     def wallet_test(self):\n         # check that the pruning node's wallet is still in good shape\n         self.log.info(\"Stop and start pruning node to trigger wallet rescan\")\n         self.stop_node(2)\n-        start_node(2, self.options.tmpdir, [\"-prune=550\"])\n+        self.start_node(2, self.options.tmpdir, [\"-prune=550\"])\n         self.log.info(\"Success\")\n \n         # check that wallet loads loads successfully when restarting a pruned node after IBD.\n@@ -325,7 +325,7 @@ def wallet_test(self):\n         nds = [self.nodes[0], self.nodes[5]]\n         sync_blocks(nds, wait=5, timeout=300)\n         self.stop_node(5) #stop and start to trigger rescan\n-        start_node(5, self.options.tmpdir, [\"-prune=550\"])\n+        self.start_node(5, self.options.tmpdir, [\"-prune=550\"])\n         self.log.info(\"Success\")\n \n     def run_test(self):"
      },
      {
        "sha": "2cad6269acb7e20401e818fc982cb520a0156393",
        "filename": "test/functional/receivedby.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/receivedby.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/receivedby.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/receivedby.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -32,7 +32,7 @@ def __init__(self):\n     def setup_nodes(self):\n         #This test requires mocktime\n         enable_mocktime()\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir)\n+        self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir)\n \n     def run_test(self):\n         '''"
      },
      {
        "sha": "b446baa04dee4bd511a6df16cc4939d7468cebd0",
        "filename": "test/functional/reindex.py",
        "status": "modified",
        "additions": 3,
        "deletions": 7,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/reindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/reindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/reindex.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -10,11 +10,7 @@\n \"\"\"\n \n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import (\n-    start_nodes,\n-    stop_nodes,\n-    assert_equal,\n-)\n+from test_framework.util import assert_equal\n import time\n \n class ReindexTest(BitcoinTestFramework):\n@@ -27,9 +23,9 @@ def __init__(self):\n     def reindex(self, justchainstate=False):\n         self.nodes[0].generate(3)\n         blockcount = self.nodes[0].getblockcount()\n-        stop_nodes(self.nodes)\n+        self.stop_nodes()\n         extra_args = [[\"-reindex-chainstate\" if justchainstate else \"-reindex\", \"-checkblockindex=1\"]]\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n+        self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n         while self.nodes[0].getblockcount() < blockcount:\n             time.sleep(0.1)\n         assert_equal(self.nodes[0].getblockcount(), blockcount)"
      },
      {
        "sha": "5336cf2ec89f2779e995c2bb1daf90be609ecde5",
        "filename": "test/functional/rpcbind_test.py",
        "status": "modified",
        "additions": 8,
        "deletions": 11,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/rpcbind_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/rpcbind_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpcbind_test.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -7,7 +7,7 @@\n import socket\n import sys\n \n-from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.test_framework import BitcoinTestFramework, SkipTest\n from test_framework.util import *\n from test_framework.netutil import *\n \n@@ -36,44 +36,41 @@ def run_bind_test(self, allow_ips, connect_to, addresses, expected):\n         if allow_ips:\n             base_args += ['-rpcallowip=' + x for x in allow_ips]\n         binds = ['-rpcbind='+addr for addr in addresses]\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, [base_args + binds], connect_to)\n+        self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir, [base_args + binds], connect_to)\n         pid = bitcoind_processes[0].pid\n         assert_equal(set(get_bind_addrs(pid)), set(expected))\n-        stop_nodes(self.nodes)\n+        self.stop_nodes()\n \n     def run_allowip_test(self, allow_ips, rpchost, rpcport):\n         '''\n         Start a node with rpcallow IP, and request getnetworkinfo\n         at a non-localhost IP.\n         '''\n         base_args = ['-disablewallet', '-nolisten'] + ['-rpcallowip='+x for x in allow_ips]\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, [base_args])\n+        self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir, [base_args])\n         # connect to node through non-loopback interface\n         node = get_rpc_proxy(rpc_url(0, \"%s:%d\" % (rpchost, rpcport)), 0)\n         node.getnetworkinfo()\n-        stop_nodes(self.nodes)\n+        self.stop_nodes()\n \n     def run_test(self):\n         # due to OS-specific network stats queries, this test works only on Linux\n         if not sys.platform.startswith('linux'):\n-            self.log.warning(\"This test can only be run on linux. Skipping test.\")\n-            sys.exit(self.TEST_EXIT_SKIPPED)\n+            raise SkipTest(\"This test can only be run on linux.\")\n         # find the first non-loopback interface for testing\n         non_loopback_ip = None\n         for name,ip in all_interfaces():\n             if ip != '127.0.0.1':\n                 non_loopback_ip = ip\n                 break\n         if non_loopback_ip is None:\n-            self.log.warning(\"This test requires at least one non-loopback IPv4 interface. Skipping test.\")\n-            sys.exit(self.TEST_EXIT_SKIPPED)\n+            raise SkipTest(\"This test requires at least one non-loopback IPv4 interface.\")\n         try:\n             s = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n             s.connect((\"::1\",1))\n             s.close\n         except OSError:\n-            self.log.warning(\"This test requires IPv6 support. Skipping test.\")\n-            sys.exit(self.TEST_EXIT_SKIPPED)\n+            raise SkipTest(\"This test requires IPv6 support.\")\n \n         self.log.info(\"Using interface %s for testing\" % non_loopback_ip)\n "
      },
      {
        "sha": "482c77863f1920176e2e4a6c83662c62dea7d7a5",
        "filename": "test/functional/smartfees.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/smartfees.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/smartfees.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/smartfees.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -155,7 +155,7 @@ def setup_network(self):\n         \"\"\"\n         self.nodes = []\n         # Use node0 to mine blocks for input splitting\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-maxorphantx=1000\",\n+        self.nodes.append(self.start_node(0, self.options.tmpdir, [\"-maxorphantx=1000\",\n                                                               \"-whitelist=127.0.0.1\"]))\n \n         self.log.info(\"This test is time consuming, please be patient\")\n@@ -191,15 +191,15 @@ def setup_network(self):\n         # Node1 mines small blocks but that are bigger than the expected transaction rate.\n         # NOTE: the CreateNewBlock code starts counting block size at 1,000 bytes,\n         # (17k is room enough for 110 or so transactions)\n-        self.nodes.append(start_node(1, self.options.tmpdir,\n+        self.nodes.append(self.start_node(1, self.options.tmpdir,\n                                      [\"-blockmaxsize=17000\", \"-maxorphantx=1000\"]))\n         connect_nodes(self.nodes[1], 0)\n \n         # Node2 is a stingy miner, that\n         # produces too small blocks (room for only 55 or so transactions)\n         node2args = [\"-blockmaxsize=8000\", \"-maxorphantx=1000\"]\n \n-        self.nodes.append(start_node(2, self.options.tmpdir, node2args))\n+        self.nodes.append(self.start_node(2, self.options.tmpdir, node2args))\n         connect_nodes(self.nodes[0], 2)\n         connect_nodes(self.nodes[2], 1)\n "
      },
      {
        "sha": "67abf356870ace720841098fe1319e3edfc479ec",
        "filename": "test/functional/test_framework/test_framework.py",
        "status": "modified",
        "additions": 39,
        "deletions": 21,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/test_framework/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/test_framework/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_framework.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -5,6 +5,7 @@\n \"\"\"Base class for RPC testing.\"\"\"\n \n from collections import deque\n+from enum import Enum\n import logging\n import optparse\n import os\n@@ -31,16 +32,25 @@\n     p2p_port,\n     rpc_url,\n     set_node_times,\n-    start_node,\n-    start_nodes,\n-    stop_node,\n-    stop_nodes,\n+    _start_node,\n+    _start_nodes,\n+    _stop_node,\n+    _stop_nodes,\n     sync_blocks,\n     sync_mempools,\n     wait_for_bitcoind_start,\n )\n from .authproxy import JSONRPCException\n \n+class TestStatus(Enum):\n+    PASSED = 1\n+    FAILED = 2\n+    SKIPPED = 3\n+\n+TEST_EXIT_PASSED = 0\n+TEST_EXIT_FAILED = 1\n+TEST_EXIT_SKIPPED = 77\n+\n class BitcoinTestFramework(object):\n     \"\"\"Base class for a bitcoin test script.\n \n@@ -57,11 +67,6 @@ class BitcoinTestFramework(object):\n     This class also contains various public and private helper methods.\"\"\"\n \n     # Methods to override in subclass test scripts.\n-\n-    TEST_EXIT_PASSED = 0\n-    TEST_EXIT_FAILED = 1\n-    TEST_EXIT_SKIPPED = 77\n-\n     def __init__(self):\n         self.num_nodes = 4\n         self.setup_clean_chain = False\n@@ -91,7 +96,7 @@ def setup_nodes(self):\n         extra_args = None\n         if hasattr(self, \"extra_args\"):\n             extra_args = self.extra_args\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n+        self.nodes = _start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n \n     def run_test(self):\n         raise NotImplementedError\n@@ -139,15 +144,18 @@ def main(self):\n             self.options.tmpdir = tempfile.mkdtemp(prefix=\"test\")\n         self._start_logging()\n \n-        success = False\n+        success = TestStatus.FAILED\n \n         try:\n             self.setup_chain()\n             self.setup_network()\n             self.run_test()\n-            success = True\n+            success = TestStatus.PASSED\n         except JSONRPCException as e:\n             self.log.exception(\"JSONRPC error\")\n+        except SkipTest as e:\n+            self.log.warning(\"Test Skipped: %s\" % e.message)\n+            success = TestStatus.SKIPPED\n         except AssertionError as e:\n             self.log.exception(\"Assertion failed\")\n         except KeyError as e:\n@@ -159,11 +167,12 @@ def main(self):\n \n         if not self.options.noshutdown:\n             self.log.info(\"Stopping nodes\")\n-            self.stop_nodes()\n+            if self.nodes:\n+                self.stop_nodes()\n         else:\n             self.log.info(\"Note: bitcoinds were not stopped and may still be running\")\n \n-        if not self.options.nocleanup and not self.options.noshutdown and success:\n+        if not self.options.nocleanup and not self.options.noshutdown and success != TestStatus.FAILED:\n             self.log.info(\"Cleaning up\")\n             shutil.rmtree(self.options.tmpdir)\n         else:\n@@ -183,27 +192,31 @@ def main(self):\n                     except OSError:\n                         print(\"Opening file %s failed.\" % fn)\n                         traceback.print_exc()\n-        if success:\n+\n+        if success == TestStatus.PASSED:\n             self.log.info(\"Tests successful\")\n-            sys.exit(self.TEST_EXIT_PASSED)\n+            sys.exit(TEST_EXIT_PASSED)\n+        elif success == TestStatus.SKIPPED:\n+            self.log.info(\"Test skipped\")\n+            sys.exit(TEST_EXIT_SKIPPED)\n         else:\n             self.log.error(\"Test failed. Test logging available at %s/test_framework.log\", self.options.tmpdir)\n             logging.shutdown()\n-            sys.exit(self.TEST_EXIT_FAILED)\n+            sys.exit(TEST_EXIT_FAILED)\n \n     # Public helper methods. These can be accessed by the subclass test scripts.\n \n     def start_node(self, i, dirname, extra_args=None, rpchost=None, timewait=None, binary=None, stderr=None):\n-        return start_node(i, dirname, extra_args, rpchost, timewait, binary, stderr)\n+        return _start_node(i, dirname, extra_args, rpchost, timewait, binary, stderr)\n \n     def start_nodes(self, num_nodes, dirname, extra_args=None, rpchost=None, timewait=None, binary=None):\n-        return start_nodes(num_nodes, dirname, extra_args, rpchost, timewait, binary)\n+        return _start_nodes(num_nodes, dirname, extra_args, rpchost, timewait, binary)\n \n     def stop_node(self, num_node):\n-        stop_node(self.nodes[num_node], num_node)\n+        _stop_node(self.nodes[num_node], num_node)\n \n     def stop_nodes(self):\n-        stop_nodes(self.nodes)\n+        _stop_nodes(self.nodes)\n \n     def split_network(self):\n         \"\"\"\n@@ -346,6 +359,11 @@ def _initialize_chain_clean(self, test_dir, num_nodes):\n # 2 binaries: 1 test binary, 1 ref binary\n # n>2 binaries: 1 test binary, n-1 ref binaries\n \n+class SkipTest(Exception):\n+    \"\"\"This exception is raised to skip a test\"\"\"\n+    def __init__(self, message):\n+        self.message = message\n+\n class ComparisonTestFramework(BitcoinTestFramework):\n \n     def __init__(self):"
      },
      {
        "sha": "2b0f32c2b6cbfba2533e381547bd40d356dd12f1",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 25,
        "deletions": 15,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -227,10 +227,11 @@ def wait_for_bitcoind_start(process, url, i):\n         time.sleep(0.25)\n \n \n-def start_node(i, dirname, extra_args=None, rpchost=None, timewait=None, binary=None, stderr=None):\n-    \"\"\"\n-    Start a bitcoind and return RPC connection to it\n-    \"\"\"\n+def _start_node(i, dirname, extra_args=None, rpchost=None, timewait=None, binary=None, stderr=None):\n+    \"\"\"Start a bitcoind and return RPC connection to it\n+\n+    This function should only be called from within test_framework, not by individual test scripts.\"\"\"\n+\n     datadir = os.path.join(dirname, \"node\"+str(i))\n     if binary is None:\n         binary = os.getenv(\"BITCOIND\", \"bitcoind\")\n@@ -251,8 +252,8 @@ def start_node(i, dirname, extra_args=None, rpchost=None, timewait=None, binary=\n def assert_start_raises_init_error(i, dirname, extra_args=None, expected_msg=None):\n     with tempfile.SpooledTemporaryFile(max_size=2**16) as log_stderr:\n         try:\n-            node = start_node(i, dirname, extra_args, stderr=log_stderr)\n-            stop_node(node, i)\n+            node = _start_node(i, dirname, extra_args, stderr=log_stderr)\n+            _stop_node(node, i)\n         except Exception as e:\n             assert 'bitcoind exited' in str(e) #node must have shutdown\n             if expected_msg is not None:\n@@ -267,27 +268,32 @@ def assert_start_raises_init_error(i, dirname, extra_args=None, expected_msg=Non\n                 assert_msg = \"bitcoind should have exited with expected error \" + expected_msg\n             raise AssertionError(assert_msg)\n \n-def start_nodes(num_nodes, dirname, extra_args=None, rpchost=None, timewait=None, binary=None):\n-    \"\"\"\n-    Start multiple bitcoinds, return RPC connections to them\n-    \"\"\"\n+def _start_nodes(num_nodes, dirname, extra_args=None, rpchost=None, timewait=None, binary=None):\n+    \"\"\"Start multiple bitcoinds, return RPC connections to them\n+    \n+    This function should only be called from within test_framework, not by individual test scripts.\"\"\"\n+\n     if extra_args is None: extra_args = [ None for _ in range(num_nodes) ]\n     if binary is None: binary = [ None for _ in range(num_nodes) ]\n     assert_equal(len(extra_args), num_nodes)\n     assert_equal(len(binary), num_nodes)\n     rpcs = []\n     try:\n         for i in range(num_nodes):\n-            rpcs.append(start_node(i, dirname, extra_args[i], rpchost, timewait=timewait, binary=binary[i]))\n+            rpcs.append(_start_node(i, dirname, extra_args[i], rpchost, timewait=timewait, binary=binary[i]))\n     except: # If one node failed to start, stop the others\n-        stop_nodes(rpcs)\n+        _stop_nodes(rpcs)\n         raise\n     return rpcs\n \n def log_filename(dirname, n_node, logname):\n     return os.path.join(dirname, \"node\"+str(n_node), \"regtest\", logname)\n \n-def stop_node(node, i):\n+def _stop_node(node, i):\n+    \"\"\"Stop a bitcoind test node\n+\n+    This function should only be called from within test_framework, not by individual test scripts.\"\"\"\n+\n     logger.debug(\"Stopping node %d\" % i)\n     try:\n         node.stop()\n@@ -297,9 +303,13 @@ def stop_node(node, i):\n     assert_equal(return_code, 0)\n     del bitcoind_processes[i]\n \n-def stop_nodes(nodes):\n+def _stop_nodes(nodes):\n+    \"\"\"Stop multiple bitcoind test nodes\n+\n+    This function should only be called from within test_framework, not by individual test scripts.\"\"\"\n+\n     for i, node in enumerate(nodes):\n-        stop_node(node, i)\n+        _stop_node(node, i)\n     assert not bitcoind_processes.values() # All connections must be gone now\n \n def set_node_times(nodes, t):"
      },
      {
        "sha": "158aa9ae896c75894f433769b105e1e3c0d8cc45",
        "filename": "test/functional/wallet-accounts.py",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/wallet-accounts.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/wallet-accounts.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet-accounts.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -14,9 +14,7 @@\n \"\"\"\n \n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import (\n-    assert_equal,\n-)\n+from test_framework.util import assert_equal\n \n class WalletAccountsTest(BitcoinTestFramework):\n "
      },
      {
        "sha": "c38a9bc996e5976126e9ca4c8f58087a9cc6691b",
        "filename": "test/functional/wallet-dump.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/wallet-dump.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/wallet-dump.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet-dump.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -5,7 +5,7 @@\n \"\"\"Test the dumpwallet RPC.\"\"\"\n \n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import (start_nodes, start_node, assert_equal, bitcoind_processes)\n+from test_framework.util import (assert_equal, bitcoind_processes)\n \n \n def read_dump(file_name, addrs, hd_master_addr_old):\n@@ -66,7 +66,7 @@ def setup_network(self, split=False):\n         # longer than the default 30 seconds due to an expensive\n         # CWallet::TopUpKeyPool call, and the encryptwallet RPC made later in\n         # the test often takes even longer.\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, self.extra_args, timewait=60)\n+        self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir, self.extra_args, timewait=60)\n \n     def run_test (self):\n         tmpdir = self.options.tmpdir\n@@ -93,7 +93,7 @@ def run_test (self):\n         #encrypt wallet, restart, unlock and dump\n         self.nodes[0].encryptwallet('test')\n         bitcoind_processes[0].wait()\n-        self.nodes[0] = start_node(0, self.options.tmpdir, self.extra_args[0])\n+        self.nodes[0] = self.start_node(0, self.options.tmpdir, self.extra_args[0])\n         self.nodes[0].walletpassphrase('test', 10)\n         # Should be a no-op:\n         self.nodes[0].keypoolrefill()"
      },
      {
        "sha": "e7ec72a2484e5018f152b2c7e3aba5c006da1897",
        "filename": "test/functional/wallet-hd.py",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/wallet-hd.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/wallet-hd.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet-hd.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -6,7 +6,6 @@\n \n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n-    start_node,\n     assert_equal,\n     connect_nodes_bi,\n     assert_start_raises_init_error\n@@ -29,7 +28,7 @@ def run_test (self):\n         # Make sure can't switch off usehd after wallet creation\n         self.stop_node(1)\n         assert_start_raises_init_error(1, self.options.tmpdir, ['-usehd=0'], 'already existing HD wallet')\n-        self.nodes[1] = start_node(1, self.options.tmpdir, self.extra_args[1])\n+        self.nodes[1] = self.start_node(1, self.options.tmpdir, self.extra_args[1])\n         connect_nodes_bi(self.nodes, 0, 1)\n \n         # Make sure we use hd, keep masterkeyid\n@@ -76,7 +75,7 @@ def run_test (self):\n         self.stop_node(1)\n         os.remove(self.options.tmpdir + \"/node1/regtest/wallet.dat\")\n         shutil.copyfile(tmpdir + \"/hd.bak\", tmpdir + \"/node1/regtest/wallet.dat\")\n-        self.nodes[1] = start_node(1, self.options.tmpdir, self.extra_args[1])\n+        self.nodes[1] = self.start_node(1, self.options.tmpdir, self.extra_args[1])\n         #connect_nodes_bi(self.nodes, 0, 1)\n \n         # Assert that derivation is deterministic\n@@ -90,7 +89,7 @@ def run_test (self):\n \n         # Needs rescan\n         self.stop_node(1)\n-        self.nodes[1] = start_node(1, self.options.tmpdir, self.extra_args[1] + ['-rescan'])\n+        self.nodes[1] = self.start_node(1, self.options.tmpdir, self.extra_args[1] + ['-rescan'])\n         #connect_nodes_bi(self.nodes, 0, 1)\n         assert_equal(self.nodes[1].getbalance(), num_hd_adds + 1)\n "
      },
      {
        "sha": "3e3e8fcddb389044d5faff872aba0e289262fe8f",
        "filename": "test/functional/wallet.py",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/wallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/wallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -21,7 +21,7 @@ def __init__(self):\n         self.extra_args = [['-usehd={:d}'.format(i%2==0)] for i in range(4)]\n \n     def setup_network(self):\n-        self.nodes = start_nodes(3, self.options.tmpdir, self.extra_args[:3])\n+        self.nodes = self.start_nodes(3, self.options.tmpdir, self.extra_args[:3])\n         connect_nodes_bi(self.nodes,0,1)\n         connect_nodes_bi(self.nodes,1,2)\n         connect_nodes_bi(self.nodes,0,2)\n@@ -178,7 +178,7 @@ def run_test(self):\n         txid2 = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n         sync_mempools(self.nodes)\n \n-        self.nodes.append(start_node(3, self.options.tmpdir, self.extra_args[3]))\n+        self.nodes.append(self.start_node(3, self.options.tmpdir, self.extra_args[3]))\n         connect_nodes_bi(self.nodes, 0, 3)\n         sync_blocks(self.nodes)\n \n@@ -221,8 +221,8 @@ def run_test(self):\n         assert(found)\n \n         #do some -walletbroadcast tests\n-        stop_nodes(self.nodes)\n-        self.nodes = start_nodes(3, self.options.tmpdir, [[\"-walletbroadcast=0\"],[\"-walletbroadcast=0\"],[\"-walletbroadcast=0\"]])\n+        self.stop_nodes()\n+        self.nodes = self.start_nodes(3, self.options.tmpdir, [[\"-walletbroadcast=0\"],[\"-walletbroadcast=0\"],[\"-walletbroadcast=0\"]])\n         connect_nodes_bi(self.nodes,0,1)\n         connect_nodes_bi(self.nodes,1,2)\n         connect_nodes_bi(self.nodes,0,2)\n@@ -246,8 +246,8 @@ def run_test(self):\n         txIdNotBroadcasted  = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 2)\n \n         #restart the nodes with -walletbroadcast=1\n-        stop_nodes(self.nodes)\n-        self.nodes = start_nodes(3, self.options.tmpdir)\n+        self.stop_nodes()\n+        self.nodes = self.start_nodes(3, self.options.tmpdir)\n         connect_nodes_bi(self.nodes,0,1)\n         connect_nodes_bi(self.nodes,1,2)\n         connect_nodes_bi(self.nodes,0,2)\n@@ -348,9 +348,9 @@ def run_test(self):\n         chainlimit = 6\n         for m in maintenance:\n             self.log.info(\"check \" + m)\n-            stop_nodes(self.nodes)\n+            self.stop_nodes()\n             # set lower ancestor limit for later\n-            self.nodes = start_nodes(3, self.options.tmpdir, [[m, \"-limitancestorcount=\"+str(chainlimit)]] * 3)\n+            self.nodes = self.start_nodes(3, self.options.tmpdir, [[m, \"-limitancestorcount=\"+str(chainlimit)]] * 3)\n             while m == '-reindex' and [block_count] * 3 != [self.nodes[i].getblockcount() for i in range(3)]:\n                 # reindex will leave rpc warm up \"early\"; Wait for it to finish\n                 time.sleep(0.1)\n@@ -397,8 +397,8 @@ def run_test(self):\n \n         # Try with walletrejectlongchains\n         # Double chain limit but require combining inputs, so we pass SelectCoinsMinConf\n-        stop_node(self.nodes[0],0)\n-        self.nodes[0] = start_node(0, self.options.tmpdir, [\"-walletrejectlongchains\", \"-limitancestorcount=\"+str(2*chainlimit)])\n+        self.stop_node(0)\n+        self.nodes[0] = self.start_node(0, self.options.tmpdir, [\"-walletrejectlongchains\", \"-limitancestorcount=\"+str(2*chainlimit)])\n \n         # wait for loadmempool\n         timeout = 10"
      },
      {
        "sha": "a4507182a24dfa9eac95fee521f9b652132911d0",
        "filename": "test/functional/walletbackup.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/walletbackup.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/walletbackup.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/walletbackup.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -77,18 +77,18 @@ def do_one_round(self):\n \n     # As above, this mirrors the original bash test.\n     def start_three(self):\n-        self.nodes[0] = start_node(0, self.options.tmpdir)\n-        self.nodes[1] = start_node(1, self.options.tmpdir)\n-        self.nodes[2] = start_node(2, self.options.tmpdir)\n+        self.nodes[0] = self.start_node(0, self.options.tmpdir)\n+        self.nodes[1] = self.start_node(1, self.options.tmpdir)\n+        self.nodes[2] = self.start_node(2, self.options.tmpdir)\n         connect_nodes(self.nodes[0], 3)\n         connect_nodes(self.nodes[1], 3)\n         connect_nodes(self.nodes[2], 3)\n         connect_nodes(self.nodes[2], 0)\n \n     def stop_three(self):\n-        stop_node(self.nodes[0], 0)\n-        stop_node(self.nodes[1], 1)\n-        stop_node(self.nodes[2], 2)\n+        self.stop_node(0)\n+        self.stop_node(1)\n+        self.stop_node(2)\n \n     def erase_three(self):\n         os.remove(self.options.tmpdir + \"/node0/regtest/wallet.dat\")"
      },
      {
        "sha": "a8600e82f64febf888c985d2b6de8d4b1354c507",
        "filename": "test/functional/zapwallettxes.py",
        "status": "modified",
        "additions": 4,
        "deletions": 6,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/zapwallettxes.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/zapwallettxes.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/zapwallettxes.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -58,18 +58,16 @@ def run_test (self):\n         assert_equal(tx3['txid'], txid3) #tx3 must be available (unconfirmed)\n         \n         #restart bitcoind\n-        self.nodes[0].stop()\n-        bitcoind_processes[0].wait()\n-        self.nodes[0] = start_node(0,self.options.tmpdir)\n+        self.stop_node(0)\n+        self.nodes[0] = self.start_node(0,self.options.tmpdir)\n         \n         tx3 = self.nodes[0].gettransaction(txid3)\n         assert_equal(tx3['txid'], txid3) #tx must be available (unconfirmed)\n         \n-        self.nodes[0].stop()\n-        bitcoind_processes[0].wait()\n+        self.stop_node(0)\n         \n         #restart bitcoind with zapwallettxes\n-        self.nodes[0] = start_node(0,self.options.tmpdir, [\"-zapwallettxes=1\"])\n+        self.nodes[0] = self.start_node(0,self.options.tmpdir, [\"-zapwallettxes=1\"])\n         \n         assert_raises(JSONRPCException, self.nodes[0].gettransaction, [txid3])\n         #there must be a expection because the unconfirmed wallettx0 must be gone by now"
      },
      {
        "sha": "ce39cfefdc963da96144cbe10837e937a873499b",
        "filename": "test/functional/zmq_test.py",
        "status": "modified",
        "additions": 4,
        "deletions": 7,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/zmq_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cf7ea0bd96241926c84fd9beb15538ba82fb5b8/test/functional/zmq_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/zmq_test.py?ref=2cf7ea0bd96241926c84fd9beb15538ba82fb5b8",
        "patch": "@@ -6,9 +6,8 @@\n import configparser\n import os\n import struct\n-import sys\n \n-from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.test_framework import BitcoinTestFramework, SkipTest\n from test_framework.util import *\n \n class ZMQTest (BitcoinTestFramework):\n@@ -24,8 +23,7 @@ def setup_nodes(self):\n         try:\n             import zmq\n         except ImportError:\n-            self.log.warning(\"python3-zmq module not available. Skipping zmq tests!\")\n-            sys.exit(self.TEST_EXIT_SKIPPED)\n+            raise SkipTest(\"python3-zmq module not available.\")\n \n         # Check that bitcoin has been built with ZMQ enabled\n         config = configparser.ConfigParser()\n@@ -34,15 +32,14 @@ def setup_nodes(self):\n         config.read_file(open(self.options.configfile))\n \n         if not config[\"components\"].getboolean(\"ENABLE_ZMQ\"):\n-            self.log.warning(\"bitcoind has not been built with zmq enabled. Skipping zmq tests!\")\n-            sys.exit(self.TEST_EXIT_SKIPPED)\n+            raise SkipTest(\"bitcoind has not been built with zmq enabled.\")\n \n         self.zmqContext = zmq.Context()\n         self.zmqSubSocket = self.zmqContext.socket(zmq.SUB)\n         self.zmqSubSocket.setsockopt(zmq.SUBSCRIBE, b\"hashblock\")\n         self.zmqSubSocket.setsockopt(zmq.SUBSCRIBE, b\"hashtx\")\n         self.zmqSubSocket.connect(\"tcp://127.0.0.1:%i\" % self.port)\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, extra_args=[\n+        self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir, extra_args=[\n             ['-zmqpubhashtx=tcp://127.0.0.1:'+str(self.port), '-zmqpubhashblock=tcp://127.0.0.1:'+str(self.port)],\n             [],\n             [],"
      }
    ]
  }
]