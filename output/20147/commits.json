[
  {
    "sha": "52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1MjM4MGJmMzA0YjFjMDJkZGEyM2YxZTJmYWQwMTU5ZTI5YjJmN2Ey",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-14T18:41:15Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-14T18:41:15Z"
      },
      "message": "Squashed 'src/secp256k1/' changes from 8ab24e8dad..c6b6b8f1bb\n\nc6b6b8f1bb Merge #830: Rip out non-endomorphism code + dependencies\nc582abade1 Consistency improvements to the comments\n63c6b71616 Reorder comments/function around scalar_split_lambda\n2edc514c90 WNAF of lambda_split output has max size 129\n4232e5b7da Rip out non-endomorphism code\nebad8414b0 Check correctness of lambda split without -DVERIFY\nfe7fc1fda8 Make lambda constant accessible\n9d2f2b44d8 Add tests to exercise lambda split near bounds\n9aca2f7f07 Add secp256k1_split_lambda_verify\nacab934d24 Detailed comments for secp256k1_scalar_split_lambda\n76ed922a5f Increase precision of g1 and g2\n6173839c90 Switch to our own memcmp function\n63150ab4da Merge #827: Rename testrand functions to have test in name\nc5257aed0b Merge #821: travis: Explicitly set --with-valgrind\nbb1f54280f Merge #818: Add static assertion that uint32_t is unsigned int or wider\na45c1fa63c Rename testrand functions to have test in name\n5006895bd6 Merge #808: Exhaustive test improvements + exhaustive schnorrsig tests\n4eecb4d6ef travis: VALGRIND->RUN_VALGRIND to avoid confusion with WITH_VALGRIND\n66a765c775 travis: Explicitly set --with-valgrind\nd7838ba6a6 Merge #813: Enable configuring Valgrind support\n7ceb0b7611 Merge #819: Enable -Wundef warning\n8b7dcdd955 Add exhaustive test for extrakeys and schnorrsig\n08d7d89299 Make pubkey parsing test whether points are in the correct subgroup\n87af00b511 Abstract out challenge computation in schnorrsig\n63e1b2aa7d Disable output buffering in tests_exhaustive.c\n39f67dd072 Support splitting exhaustive tests across cores\ne99b26fcd5 Give exhaustive_tests count and seed cmdline inputs\n49e6630bca refactor: move RNG seeding to testrand\nb110c106fa Change exhaustive test groups so they have a point with X=1\ncec7b18a34 Select exhaustive lambda in function of order\n78f6cdfaae Make the curve B constant a secp256k1_fe\nd7f39ae4b6 Delete gej_is_valid_var: unused outside tests\n8bcd78cd79 Make secp256k1_scalar_b32 detect overflow in scalar_low\nc498366e5b Move exhaustive tests for recovery to module\nbe31791543 Make group order purely compile-time in exhaustive tests\ne73ff30922 Enable -Wundef warning\nc0041b5cfc Add static assertion that uint32_t is unsigned int or wider\n4ad408faf3 Merge #782: Check if variable=yes instead of if var is set in travis.sh\n412bf874d0 configure: Allow specifying --with[out]-valgrind explicitly\n34debf7a6d Modify .travis.yml to explictly pass no in env vars instead of setting to nothing\na0e99fc121 Merge #814: tests: Initialize random group elements fully\n5738e8622d tests: Initialize random group elements fully\nc9939ba55d Merge #812: travis: run bench_schnorrsig\na51f2af62b travis: run bench_schnorrsig\nef37761fee Change travis.sh to check if variables are equal to yes instead of not-empty. Before this, setting `VALGRIND=wat` was considered as true, and to make it evaluate as false you had to unset the variable `VALGRIND=` but not it checks if `VALGRIND=yes` and if it's not `yes` then it's evaluated to false\n\ngit-subtree-dir: src/secp256k1\ngit-subtree-split: c6b6b8f1bb044d7d1aa065ebb674adde98a36a8e",
      "tree": {
        "sha": "c79797189781d6656eba6cb155c249c57b4f5c9a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c79797189781d6656eba6cb155c249c57b4f5c9a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b9c1a7648131c5deec9704ee9acd00ec1820b9ce",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b9c1a7648131c5deec9704ee9acd00ec1820b9ce"
      }
    ],
    "stats": {
      "total": 2533,
      "additions": 1586,
      "deletions": 947
    },
    "files": [
      {
        "sha": "bcc8c210f590523df3187091c54b0a37e40212a0",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 8,
        "deletions": 12,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -17,33 +17,29 @@ compiler:\n   - gcc\n env:\n   global:\n-    - WIDEMUL=auto  BIGNUM=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ECMULTGENPRECISION=auto  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no SCHNORRSIG=no EXPERIMENTAL=no CTIMETEST=yes BENCH=yes ITERS=2\n+    - WIDEMUL=auto  BIGNUM=auto  STATICPRECOMPUTATION=yes  ECMULTGENPRECISION=auto  ASM=no  BUILD=check  WITH_VALGRIND=yes RUN_VALGRIND=no EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no SCHNORRSIG=no EXPERIMENTAL=no CTIMETEST=yes BENCH=yes ITERS=2\n   matrix:\n     - WIDEMUL=int64   RECOVERY=yes\n     - WIDEMUL=int64   ECDH=yes  EXPERIMENTAL=yes SCHNORRSIG=yes\n-    - WIDEMUL=int64   ENDOMORPHISM=yes\n     - WIDEMUL=int128\n     - WIDEMUL=int128  RECOVERY=yes EXPERIMENTAL=yes SCHNORRSIG=yes\n-    - WIDEMUL=int128  ENDOMORPHISM=yes\n-    - WIDEMUL=int128  ENDOMORPHISM=yes  ECDH=yes EXPERIMENTAL=yes SCHNORRSIG=yes\n+    - WIDEMUL=int128  ECDH=yes EXPERIMENTAL=yes SCHNORRSIG=yes\n     - WIDEMUL=int128                    ASM=x86_64\n-    - WIDEMUL=int128  ENDOMORPHISM=yes  ASM=x86_64\n     - BIGNUM=no\n-    - BIGNUM=no       ENDOMORPHISM=yes RECOVERY=yes EXPERIMENTAL=yes SCHNORRSIG=yes\n+    - BIGNUM=no       RECOVERY=yes EXPERIMENTAL=yes SCHNORRSIG=yes\n     - BIGNUM=no       STATICPRECOMPUTATION=no\n-    - BUILD=distcheck CTIMETEST= BENCH=\n+    - BUILD=distcheck WITH_VALGRIND=no CTIMETEST=no BENCH=no\n     - CPPFLAGS=-DDETERMINISTIC\n-    - CFLAGS=-O0 CTIMETEST=\n+    - CFLAGS=-O0 CTIMETEST=no\n     - ECMULTGENPRECISION=2\n     - ECMULTGENPRECISION=8\n-    - VALGRIND=yes ENDOMORPHISM=yes BIGNUM=no ASM=x86_64 EXPERIMENTAL=yes ECDH=yes  RECOVERY=yes EXTRAFLAGS=\"--disable-openssl-tests\" CPPFLAGS=-DVALGRIND BUILD=\n-    - VALGRIND=yes                  BIGNUM=no ASM=x86_64 EXPERIMENTAL=yes ECDH=yes  RECOVERY=yes EXTRAFLAGS=\"--disable-openssl-tests\" CPPFLAGS=-DVALGRIND BUILD=\n+    - RUN_VALGRIND=yes BIGNUM=no ASM=x86_64 EXPERIMENTAL=yes ECDH=yes  RECOVERY=yes EXTRAFLAGS=\"--disable-openssl-tests\" BUILD=\n matrix:\n   fast_finish: true\n   include:\n     - compiler: clang\n       os: linux\n-      env: HOST=i686-linux-gnu ENDOMORPHISM=yes\n+      env: HOST=i686-linux-gnu\n       addons:\n         apt:\n           packages:\n@@ -63,7 +59,7 @@ matrix:\n             - libtool-bin\n             - libc6-dbg:i386\n     - compiler: gcc\n-      env: HOST=i686-linux-gnu ENDOMORPHISM=yes\n+      env: HOST=i686-linux-gnu\n       os: linux\n       addons:\n         apt:"
      },
      {
        "sha": "260247578704fd655971a04c2f322d012245bd94",
        "filename": "README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/README.md?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -48,7 +48,7 @@ Implementation details\n   * Use wNAF notation for point multiplicands.\n   * Use a much larger window for multiples of G, using precomputed multiples.\n   * Use Shamir's trick to do the multiplication with the public key and the generator simultaneously.\n-  * Optionally (off by default) use secp256k1's efficiently-computable endomorphism to split the P multiplicand into 2 half-sized ones.\n+  * Use secp256k1's efficiently-computable endomorphism to split the P multiplicand into 2 half-sized ones.\n * Point multiplication for signing\n   * Use a precomputed table of multiples of powers of 16 multiplied with the generator, so general multiplication becomes a series of additions.\n   * Intended to be completely free of timing sidechannels for secret-key operations (on reasonable hardware/toolchains)"
      },
      {
        "sha": "5a078e6c819198c5b3ba01d361e8ee195461a706",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 17,
        "deletions": 14,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -67,7 +67,7 @@ esac\n \n CFLAGS=\"-W $CFLAGS\"\n \n-warn_CFLAGS=\"-std=c89 -pedantic -Wall -Wextra -Wcast-align -Wnested-externs -Wshadow -Wstrict-prototypes -Wno-unused-function -Wno-long-long -Wno-overlength-strings\"\n+warn_CFLAGS=\"-std=c89 -pedantic -Wall -Wextra -Wcast-align -Wnested-externs -Wshadow -Wstrict-prototypes -Wundef -Wno-unused-function -Wno-long-long -Wno-overlength-strings\"\n saved_CFLAGS=\"$CFLAGS\"\n CFLAGS=\"$warn_CFLAGS $CFLAGS\"\n AC_MSG_CHECKING([if ${CC} supports ${warn_CFLAGS}])\n@@ -116,11 +116,6 @@ AC_ARG_ENABLE(exhaustive_tests,\n     [use_exhaustive_tests=$enableval],\n     [use_exhaustive_tests=yes])\n \n-AC_ARG_ENABLE(endomorphism,\n-    AS_HELP_STRING([--enable-endomorphism],[enable endomorphism [default=no]]),\n-    [use_endomorphism=$enableval],\n-    [use_endomorphism=no])\n-\n AC_ARG_ENABLE(ecmult_static_precomputation,\n     AS_HELP_STRING([--enable-ecmult-static-precomputation],[enable precomputed ecmult table for signing [default=auto]]),\n     [use_ecmult_static_precomputation=$enableval],\n@@ -164,8 +159,7 @@ AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|arm|no|auto],\n AC_ARG_WITH([ecmult-window], [AS_HELP_STRING([--with-ecmult-window=SIZE|auto],\n [window size for ecmult precomputation for verification, specified as integer in range [2..24].]\n [Larger values result in possibly better performance at the cost of an exponentially larger precomputed table.]\n-[The table will store 2^(SIZE-2) * 64 bytes of data but can be larger in memory due to platform-specific padding and alignment.]\n-[If the endomorphism optimization is enabled, two tables of this size are used instead of only one.]\n+[The table will store 2^(SIZE-1) * 64 bytes of data but can be larger in memory due to platform-specific padding and alignment.]\n [\"auto\" is a reasonable setting for desktop machines (currently 15). [default=auto]]\n )],\n [req_ecmult_window=$withval], [req_ecmult_window=auto])\n@@ -178,7 +172,21 @@ AC_ARG_WITH([ecmult-gen-precision], [AS_HELP_STRING([--with-ecmult-gen-precision\n )],\n [req_ecmult_gen_precision=$withval], [req_ecmult_gen_precision=auto])\n \n-AC_CHECK_HEADER([valgrind/memcheck.h], [enable_valgrind=yes], [enable_valgrind=no], [])\n+AC_ARG_WITH([valgrind], [AS_HELP_STRING([--with-valgrind=yes|no|auto],\n+[Build with extra checks for running inside Valgrind [default=auto]]\n+)],\n+[req_valgrind=$withval], [req_valgrind=auto])\n+\n+if test x\"$req_valgrind\" = x\"no\"; then\n+  enable_valgrind=no\n+else\n+  AC_CHECK_HEADER([valgrind/memcheck.h], [enable_valgrind=yes], [\n+    if test x\"$req_valgrind\" = x\"yes\"; then\n+      AC_MSG_ERROR([Valgrind support explicitly requested but valgrind/memcheck.h header not available])\n+    fi\n+    enable_valgrind=no\n+  ], [])\n+fi\n AM_CONDITIONAL([VALGRIND_ENABLED],[test \"$enable_valgrind\" = \"yes\"])\n \n if test x\"$enable_coverage\" = x\"yes\"; then\n@@ -415,10 +423,6 @@ if test x\"$set_bignum\" = x\"gmp\"; then\n   SECP_INCLUDES=\"$SECP_INCLUDES $GMP_CPPFLAGS\"\n fi\n \n-if test x\"$use_endomorphism\" = x\"yes\"; then\n-  AC_DEFINE(USE_ENDOMORPHISM, 1, [Define this symbol to use endomorphism optimization])\n-fi\n-\n if test x\"$set_precomp\" = x\"yes\"; then\n   AC_DEFINE(USE_ECMULT_STATIC_PRECOMPUTATION, 1, [Define this symbol to use a statically generated ecmult table])\n fi\n@@ -500,7 +504,6 @@ AC_OUTPUT\n \n echo\n echo \"Build Options:\"\n-echo \"  with endomorphism       = $use_endomorphism\"\n echo \"  with ecmult precomp     = $set_precomp\"\n echo \"  with external callbacks = $use_external_default_callbacks\"\n echo \"  with benchmarks         = $use_benchmark\""
      },
      {
        "sha": "24cc9315cb116939f7871b644e77a40544816e9d",
        "filename": "contrib/travis.sh",
        "status": "modified",
        "additions": 10,
        "deletions": 5,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/contrib/travis.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/contrib/travis.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/travis.sh?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -13,27 +13,28 @@ then\n fi\n \n ./configure \\\n-    --enable-experimental=\"$EXPERIMENTAL\" --enable-endomorphism=\"$ENDOMORPHISM\" \\\n+    --enable-experimental=\"$EXPERIMENTAL\" \\\n     --with-test-override-wide-multiply=\"$WIDEMUL\" --with-bignum=\"$BIGNUM\" --with-asm=\"$ASM\" \\\n     --enable-ecmult-static-precomputation=\"$STATICPRECOMPUTATION\" --with-ecmult-gen-precision=\"$ECMULTGENPRECISION\" \\\n     --enable-module-ecdh=\"$ECDH\" --enable-module-recovery=\"$RECOVERY\" \\\n     --enable-module-schnorrsig=\"$SCHNORRSIG\" \\\n+    --with-valgrind=\"$WITH_VALGRIND\" \\\n     --host=\"$HOST\" $EXTRAFLAGS\n \n if [ -n \"$BUILD\" ]\n then\n     make -j2 \"$BUILD\"\n fi\n-if [ -n \"$VALGRIND\" ]\n+if [ \"$RUN_VALGRIND\" = \"yes\" ]\n then\n     make -j2\n     # the `--error-exitcode` is required to make the test fail if valgrind found errors, otherwise it'll return 0 (http://valgrind.org/docs/manual/manual-core.html)\n     valgrind --error-exitcode=42 ./tests 16\n     valgrind --error-exitcode=42 ./exhaustive_tests\n fi\n-if [ -n \"$BENCH\" ]\n+if [ \"$BENCH\" = \"yes\" ]\n then\n-    if [ -n \"$VALGRIND\" ]\n+    if [ \"$RUN_VALGRIND\" = \"yes\" ]\n     then\n         # Using the local `libtool` because on macOS the system's libtool has nothing to do with GNU libtool\n         EXEC='./libtool --mode=execute valgrind --error-exitcode=42'\n@@ -56,8 +57,12 @@ then\n     then\n         $EXEC ./bench_ecdh >> bench.log 2>&1\n     fi\n+    if [ \"$SCHNORRSIG\" = \"yes\" ]\n+    then\n+        $EXEC ./bench_schnorrsig >> bench.log 2>&1\n+    fi\n fi\n-if [ -n \"$CTIMETEST\" ]\n+if [ \"$CTIMETEST\" = \"yes\" ]\n then\n     ./libtool --mode=execute valgrind --error-exitcode=42 ./valgrind_ctime_test > valgrind_ctime_test.log 2>&1\n fi"
      },
      {
        "sha": "3c3c984811e3a7cb101e4d6514cd55198a2f2a20",
        "filename": "sage/gen_exhaustive_groups.sage",
        "status": "added",
        "additions": 129,
        "deletions": 0,
        "changes": 129,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/sage/gen_exhaustive_groups.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/sage/gen_exhaustive_groups.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/sage/gen_exhaustive_groups.sage?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -0,0 +1,129 @@\n+# Define field size and field\n+P = 2^256 - 2^32 - 977\n+F = GF(P)\n+BETA = F(0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee)\n+\n+assert(BETA != F(1) and BETA^3 == F(1))\n+\n+orders_done = set()\n+results = {}\n+first = True\n+for b in range(1, P):\n+    # There are only 6 curves (up to isomorphism) of the form y^2=x^3+B. Stop once we have tried all.\n+    if len(orders_done) == 6:\n+        break\n+\n+    E = EllipticCurve(F, [0, b])\n+    print(\"Analyzing curve y^2 = x^3 + %i\" % b)\n+    n = E.order()\n+    # Skip curves with an order we've already tried\n+    if n in orders_done:\n+        print(\"- Isomorphic to earlier curve\")\n+        continue\n+    orders_done.add(n)\n+    # Skip curves isomorphic to the real secp256k1\n+    if n.is_pseudoprime():\n+        print(\" - Isomorphic to secp256k1\")\n+        continue\n+\n+    print(\"- Finding subgroups\")\n+\n+    # Find what prime subgroups exist\n+    for f, _ in n.factor():\n+        print(\"- Analyzing subgroup of order %i\" % f)\n+        # Skip subgroups of order >1000\n+        if f < 4 or f > 1000:\n+            print(\"  - Bad size\")\n+            continue\n+\n+        # Iterate over X coordinates until we find one that is on the curve, has order f,\n+        # and for which curve isomorphism exists that maps it to X coordinate 1.\n+        for x in range(1, P):\n+            # Skip X coordinates not on the curve, and construct the full point otherwise.\n+            if not E.is_x_coord(x):\n+                continue\n+            G = E.lift_x(F(x))\n+\n+            print(\"  - Analyzing (multiples of) point with X=%i\" % x)\n+\n+            # Skip points whose order is not a multiple of f. Project the point to have\n+            # order f otherwise.\n+            if (G.order() % f):\n+                print(\"    - Bad order\")\n+                continue\n+            G = G * (G.order() // f)\n+\n+            # Find lambda for endomorphism. Skip if none can be found.\n+            lam = None\n+            for l in Integers(f)(1).nth_root(3, all=True):\n+                if int(l)*G == E(BETA*G[0], G[1]):\n+                    lam = int(l)\n+                    break\n+            if lam is None:\n+                print(\"    - No endomorphism for this subgroup\")\n+                break\n+\n+            # Now look for an isomorphism of the curve that gives this point an X\n+            # coordinate equal to 1.\n+            # If (x,y) is on y^2 = x^3 + b, then (a^2*x, a^3*y) is on y^2 = x^3 + a^6*b.\n+            # So look for m=a^2=1/x.\n+            m = F(1)/G[0]\n+            if not m.is_square():\n+                print(\"    - No curve isomorphism maps it to a point with X=1\")\n+                continue\n+            a = m.sqrt()\n+            rb = a^6*b\n+            RE = EllipticCurve(F, [0, rb])\n+\n+            # Use as generator twice the image of G under the above isormorphism.\n+            # This means that generator*(1/2 mod f) will have X coordinate 1.\n+            RG = RE(1, a^3*G[1]) * 2\n+            # And even Y coordinate.\n+            if int(RG[1]) % 2:\n+                RG = -RG\n+            assert(RG.order() == f)\n+            assert(lam*RG == RE(BETA*RG[0], RG[1]))\n+\n+            # We have found curve RE:y^2=x^3+rb with generator RG of order f. Remember it\n+            results[f] = {\"b\": rb, \"G\": RG, \"lambda\": lam}\n+            print(\"    - Found solution\")\n+            break\n+\n+    print(\"\")\n+\n+print(\"\")\n+print(\"\")\n+print(\"/* To be put in src/group_impl.h: */\")\n+first = True\n+for f in sorted(results.keys()):\n+    b = results[f][\"b\"]\n+    G = results[f][\"G\"]\n+    print(\"#  %s EXHAUSTIVE_TEST_ORDER == %i\" % (\"if\" if first else \"elif\", f))\n+    first = False\n+    print(\"static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\")\n+    print(\"    0x%08x, 0x%08x, 0x%08x, 0x%08x,\" % tuple((int(G[0]) >> (32 * (7 - i))) & 0xffffffff for i in range(4)))\n+    print(\"    0x%08x, 0x%08x, 0x%08x, 0x%08x,\" % tuple((int(G[0]) >> (32 * (7 - i))) & 0xffffffff for i in range(4, 8)))\n+    print(\"    0x%08x, 0x%08x, 0x%08x, 0x%08x,\" % tuple((int(G[1]) >> (32 * (7 - i))) & 0xffffffff for i in range(4)))\n+    print(\"    0x%08x, 0x%08x, 0x%08x, 0x%08x\" % tuple((int(G[1]) >> (32 * (7 - i))) & 0xffffffff for i in range(4, 8)))\n+    print(\");\")\n+    print(\"static const secp256k1_fe secp256k1_fe_const_b = SECP256K1_FE_CONST(\")\n+    print(\"    0x%08x, 0x%08x, 0x%08x, 0x%08x,\" % tuple((int(b) >> (32 * (7 - i))) & 0xffffffff for i in range(4)))\n+    print(\"    0x%08x, 0x%08x, 0x%08x, 0x%08x\" % tuple((int(b) >> (32 * (7 - i))) & 0xffffffff for i in range(4, 8)))\n+    print(\");\")\n+print(\"#  else\")\n+print(\"#    error No known generator for the specified exhaustive test group order.\")\n+print(\"#  endif\")\n+\n+print(\"\")\n+print(\"\")\n+print(\"/* To be put in src/scalar_impl.h: */\")\n+first = True\n+for f in sorted(results.keys()):\n+    lam = results[f][\"lambda\"]\n+    print(\"#  %s EXHAUSTIVE_TEST_ORDER == %i\" % (\"if\" if first else \"elif\", f))\n+    first = False\n+    print(\"#    define EXHAUSTIVE_TEST_LAMBDA %i\" % lam)\n+print(\"#  else\")\n+print(\"#    error No known lambda for the specified exhaustive test group order.\")\n+print(\"#  endif\")\n+print(\"\")"
      },
      {
        "sha": "77204de2b89cf9761c5965ac6b155311956b1d13",
        "filename": "src/assumptions.h",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/assumptions.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/assumptions.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/assumptions.h?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -7,6 +7,8 @@\n #ifndef SECP256K1_ASSUMPTIONS_H\n #define SECP256K1_ASSUMPTIONS_H\n \n+#include <limits.h>\n+\n #include \"util.h\"\n \n /* This library, like most software, relies on a number of compiler implementation defined (but not undefined)\n@@ -19,7 +21,11 @@ struct secp256k1_assumption_checker {\n        allowed. */\n     int dummy_array[(\n         /* Bytes are 8 bits. */\n-        CHAR_BIT == 8 &&\n+        (CHAR_BIT == 8) &&\n+\n+        /* No integer promotion for uint32_t. This ensures that we can multiply uintXX_t values where XX >= 32\n+           without signed overflow, which would be undefined behaviour. */\n+        (UINT_MAX <= UINT32_MAX) &&\n \n         /* Conversions from unsigned to signed outside of the bounds of the signed type are\n            implementation-defined. Verify that they function as reinterpreting the lower"
      },
      {
        "sha": "b0d82e89b412d7bd735a411a0798cff92282c318",
        "filename": "src/basic-config.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/basic-config.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/basic-config.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/basic-config.h?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -11,7 +11,6 @@\n \n #undef USE_ASM_X86_64\n #undef USE_ECMULT_STATIC_PRECOMPUTATION\n-#undef USE_ENDOMORPHISM\n #undef USE_EXTERNAL_ASM\n #undef USE_EXTERNAL_DEFAULT_CALLBACKS\n #undef USE_FIELD_INV_BUILTIN"
      },
      {
        "sha": "5f2b7a9759319daded58478940b443924ebf7223",
        "filename": "src/bench_internal.c",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/bench_internal.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/bench_internal.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_internal.c?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -117,7 +117,6 @@ void bench_scalar_mul(void* arg, int iters) {\n     }\n }\n \n-#ifdef USE_ENDOMORPHISM\n void bench_scalar_split(void* arg, int iters) {\n     int i, j = 0;\n     bench_inv *data = (bench_inv*)arg;\n@@ -128,7 +127,6 @@ void bench_scalar_split(void* arg, int iters) {\n     }\n     CHECK(j <= iters);\n }\n-#endif\n \n void bench_scalar_inverse(void* arg, int iters) {\n     int i, j = 0;\n@@ -397,9 +395,7 @@ int main(int argc, char **argv) {\n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"negate\")) run_benchmark(\"scalar_negate\", bench_scalar_negate, bench_setup, NULL, &data, 10, iters*100);\n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"sqr\")) run_benchmark(\"scalar_sqr\", bench_scalar_sqr, bench_setup, NULL, &data, 10, iters*10);\n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"mul\")) run_benchmark(\"scalar_mul\", bench_scalar_mul, bench_setup, NULL, &data, 10, iters*10);\n-#ifdef USE_ENDOMORPHISM\n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"split\")) run_benchmark(\"scalar_split\", bench_scalar_split, bench_setup, NULL, &data, 10, iters);\n-#endif\n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"scalar_inverse\", bench_scalar_inverse, bench_setup, NULL, &data, 10, 2000);\n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"scalar_inverse_var\", bench_scalar_inverse_var, bench_setup, NULL, &data, 10, 2000);\n "
      },
      {
        "sha": "09e8146414b61d8fcef12695423229d52eb3b50d",
        "filename": "src/ecmult.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/ecmult.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/ecmult.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult.h?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -15,9 +15,7 @@\n typedef struct {\n     /* For accelerating the computation of a*P + b*G: */\n     secp256k1_ge_storage (*pre_g)[];    /* odd multiples of the generator */\n-#ifdef USE_ENDOMORPHISM\n     secp256k1_ge_storage (*pre_g_128)[]; /* odd multiples of 2^128*generator */\n-#endif\n } secp256k1_ecmult_context;\n \n static const size_t SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;"
      },
      {
        "sha": "bb9511108be7e84a595c8f9834bfc0fe1bb9c964",
        "filename": "src/ecmult_const_impl.h",
        "status": "modified",
        "additions": 0,
        "deletions": 20,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/ecmult_const_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/ecmult_const_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_const_impl.h?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -140,32 +140,26 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n     secp256k1_fe Z;\n \n     int skew_1;\n-#ifdef USE_ENDOMORPHISM\n     secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n     int wnaf_lam[1 + WNAF_SIZE(WINDOW_A - 1)];\n     int skew_lam;\n     secp256k1_scalar q_1, q_lam;\n-#endif\n     int wnaf_1[1 + WNAF_SIZE(WINDOW_A - 1)];\n \n     int i;\n \n     /* build wnaf representation for q. */\n     int rsize = size;\n-#ifdef USE_ENDOMORPHISM\n     if (size > 128) {\n         rsize = 128;\n         /* split q into q_1 and q_lam (where q = q_1 + q_lam*lambda, and q_1 and q_lam are ~128 bit) */\n         secp256k1_scalar_split_lambda(&q_1, &q_lam, scalar);\n         skew_1   = secp256k1_wnaf_const(wnaf_1,   &q_1,   WINDOW_A - 1, 128);\n         skew_lam = secp256k1_wnaf_const(wnaf_lam, &q_lam, WINDOW_A - 1, 128);\n     } else\n-#endif\n     {\n         skew_1   = secp256k1_wnaf_const(wnaf_1, scalar, WINDOW_A - 1, size);\n-#ifdef USE_ENDOMORPHISM\n         skew_lam = 0;\n-#endif\n     }\n \n     /* Calculate odd multiples of a.\n@@ -179,14 +173,12 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n     for (i = 0; i < ECMULT_TABLE_SIZE(WINDOW_A); i++) {\n         secp256k1_fe_normalize_weak(&pre_a[i].y);\n     }\n-#ifdef USE_ENDOMORPHISM\n     if (size > 128) {\n         for (i = 0; i < ECMULT_TABLE_SIZE(WINDOW_A); i++) {\n             secp256k1_ge_mul_lambda(&pre_a_lam[i], &pre_a[i]);\n         }\n \n     }\n-#endif\n \n     /* first loop iteration (separated out so we can directly set r, rather\n      * than having it start at infinity, get doubled several times, then have\n@@ -195,14 +187,12 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n     VERIFY_CHECK(i != 0);\n     ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a, i, WINDOW_A);\n     secp256k1_gej_set_ge(r, &tmpa);\n-#ifdef USE_ENDOMORPHISM\n     if (size > 128) {\n         i = wnaf_lam[WNAF_SIZE_BITS(rsize, WINDOW_A - 1)];\n         VERIFY_CHECK(i != 0);\n         ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a_lam, i, WINDOW_A);\n         secp256k1_gej_add_ge(r, r, &tmpa);\n     }\n-#endif\n     /* remaining loop iterations */\n     for (i = WNAF_SIZE_BITS(rsize, WINDOW_A - 1) - 1; i >= 0; i--) {\n         int n;\n@@ -215,14 +205,12 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n         ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a, n, WINDOW_A);\n         VERIFY_CHECK(n != 0);\n         secp256k1_gej_add_ge(r, r, &tmpa);\n-#ifdef USE_ENDOMORPHISM\n         if (size > 128) {\n             n = wnaf_lam[i];\n             ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a_lam, n, WINDOW_A);\n             VERIFY_CHECK(n != 0);\n             secp256k1_gej_add_ge(r, r, &tmpa);\n         }\n-#endif\n     }\n \n     secp256k1_fe_mul(&r->z, &r->z, &Z);\n@@ -231,43 +219,35 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n         /* Correct for wNAF skew */\n         secp256k1_ge correction = *a;\n         secp256k1_ge_storage correction_1_stor;\n-#ifdef USE_ENDOMORPHISM\n         secp256k1_ge_storage correction_lam_stor;\n-#endif\n         secp256k1_ge_storage a2_stor;\n         secp256k1_gej tmpj;\n         secp256k1_gej_set_ge(&tmpj, &correction);\n         secp256k1_gej_double_var(&tmpj, &tmpj, NULL);\n         secp256k1_ge_set_gej(&correction, &tmpj);\n         secp256k1_ge_to_storage(&correction_1_stor, a);\n-#ifdef USE_ENDOMORPHISM\n         if (size > 128) {\n             secp256k1_ge_to_storage(&correction_lam_stor, a);\n         }\n-#endif\n         secp256k1_ge_to_storage(&a2_stor, &correction);\n \n         /* For odd numbers this is 2a (so replace it), for even ones a (so no-op) */\n         secp256k1_ge_storage_cmov(&correction_1_stor, &a2_stor, skew_1 == 2);\n-#ifdef USE_ENDOMORPHISM\n         if (size > 128) {\n             secp256k1_ge_storage_cmov(&correction_lam_stor, &a2_stor, skew_lam == 2);\n         }\n-#endif\n \n         /* Apply the correction */\n         secp256k1_ge_from_storage(&correction, &correction_1_stor);\n         secp256k1_ge_neg(&correction, &correction);\n         secp256k1_gej_add_ge(r, r, &correction);\n \n-#ifdef USE_ENDOMORPHISM\n         if (size > 128) {\n             secp256k1_ge_from_storage(&correction, &correction_lam_stor);\n             secp256k1_ge_neg(&correction, &correction);\n             secp256k1_ge_mul_lambda(&correction, &correction);\n             secp256k1_gej_add_ge(r, r, &correction);\n         }\n-#endif\n     }\n }\n "
      },
      {
        "sha": "057a69cf73d7705dec94082caa91e03fed720b2d",
        "filename": "src/ecmult_impl.h",
        "status": "modified",
        "additions": 12,
        "deletions": 145,
        "changes": 157,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_impl.h?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -38,8 +38,8 @@\n  *      (1 << (WINDOW_G - 2)) * sizeof(secp256k1_ge_storage)  bytes,\n  *  where sizeof(secp256k1_ge_storage) is typically 64 bytes but can\n  *  be larger due to platform-specific padding and alignment.\n- *  If the endomorphism optimization is enabled (USE_ENDOMORMPHSIM)\n- *  two tables of this size are used instead of only one.\n+ *  Two tables of this size are used (due to the endomorphism\n+ *  optimization).\n  */\n #  define WINDOW_G ECMULT_WINDOW_SIZE\n #endif\n@@ -59,11 +59,7 @@\n #  error Set ECMULT_WINDOW_SIZE to an integer in range [2..24].\n #endif\n \n-#ifdef USE_ENDOMORPHISM\n-    #define WNAF_BITS 128\n-#else\n-    #define WNAF_BITS 256\n-#endif\n+#define WNAF_BITS 128\n #define WNAF_SIZE_BITS(bits, w) (((bits) + (w) - 1) / (w))\n #define WNAF_SIZE(w) WNAF_SIZE_BITS(WNAF_BITS, w)\n \n@@ -77,17 +73,9 @@\n #define PIPPENGER_MAX_BUCKET_WINDOW 12\n \n /* Minimum number of points for which pippenger_wnaf is faster than strauss wnaf */\n-#ifdef USE_ENDOMORPHISM\n-    #define ECMULT_PIPPENGER_THRESHOLD 88\n-#else\n-    #define ECMULT_PIPPENGER_THRESHOLD 160\n-#endif\n+#define ECMULT_PIPPENGER_THRESHOLD 88\n \n-#ifdef USE_ENDOMORPHISM\n-    #define ECMULT_MAX_POINTS_PER_BATCH 5000000\n-#else\n-    #define ECMULT_MAX_POINTS_PER_BATCH 10000000\n-#endif\n+#define ECMULT_MAX_POINTS_PER_BATCH 5000000\n \n /** Fill a table 'prej' with precomputed odd multiples of a. Prej will contain\n  *  the values [1*a,3*a,...,(2*n-1)*a], so it space for n values. zr[0] will\n@@ -313,16 +301,12 @@ static void secp256k1_ecmult_odd_multiples_table_storage_var(const int n, secp25\n \n static const size_t SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE =\n     ROUND_TO_ALIGN(sizeof((*((secp256k1_ecmult_context*) NULL)->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G))\n-#ifdef USE_ENDOMORPHISM\n     + ROUND_TO_ALIGN(sizeof((*((secp256k1_ecmult_context*) NULL)->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G))\n-#endif\n     ;\n \n static void secp256k1_ecmult_context_init(secp256k1_ecmult_context *ctx) {\n     ctx->pre_g = NULL;\n-#ifdef USE_ENDOMORPHISM\n     ctx->pre_g_128 = NULL;\n-#endif\n }\n \n static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, void **prealloc) {\n@@ -347,7 +331,6 @@ static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, void *\n     /* precompute the tables with odd multiples */\n     secp256k1_ecmult_odd_multiples_table_storage_var(ECMULT_TABLE_SIZE(WINDOW_G), *ctx->pre_g, &gj);\n \n-#ifdef USE_ENDOMORPHISM\n     {\n         secp256k1_gej g_128j;\n         int i;\n@@ -364,19 +347,16 @@ static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, void *\n         }\n         secp256k1_ecmult_odd_multiples_table_storage_var(ECMULT_TABLE_SIZE(WINDOW_G), *ctx->pre_g_128, &g_128j);\n     }\n-#endif\n }\n \n static void secp256k1_ecmult_context_finalize_memcpy(secp256k1_ecmult_context *dst, const secp256k1_ecmult_context *src) {\n     if (src->pre_g != NULL) {\n         /* We cast to void* first to suppress a -Wcast-align warning. */\n         dst->pre_g = (secp256k1_ge_storage (*)[])(void*)((unsigned char*)dst + ((unsigned char*)(src->pre_g) - (unsigned char*)src));\n     }\n-#ifdef USE_ENDOMORPHISM\n     if (src->pre_g_128 != NULL) {\n         dst->pre_g_128 = (secp256k1_ge_storage (*)[])(void*)((unsigned char*)dst + ((unsigned char*)(src->pre_g_128) - (unsigned char*)src));\n     }\n-#endif\n }\n \n static int secp256k1_ecmult_context_is_built(const secp256k1_ecmult_context *ctx) {\n@@ -447,43 +427,31 @@ static int secp256k1_ecmult_wnaf(int *wnaf, int len, const secp256k1_scalar *a,\n }\n \n struct secp256k1_strauss_point_state {\n-#ifdef USE_ENDOMORPHISM\n     secp256k1_scalar na_1, na_lam;\n-    int wnaf_na_1[130];\n-    int wnaf_na_lam[130];\n+    int wnaf_na_1[129];\n+    int wnaf_na_lam[129];\n     int bits_na_1;\n     int bits_na_lam;\n-#else\n-    int wnaf_na[256];\n-    int bits_na;\n-#endif\n     size_t input_pos;\n };\n \n struct secp256k1_strauss_state {\n     secp256k1_gej* prej;\n     secp256k1_fe* zr;\n     secp256k1_ge* pre_a;\n-#ifdef USE_ENDOMORPHISM\n     secp256k1_ge* pre_a_lam;\n-#endif\n     struct secp256k1_strauss_point_state* ps;\n };\n \n static void secp256k1_ecmult_strauss_wnaf(const secp256k1_ecmult_context *ctx, const struct secp256k1_strauss_state *state, secp256k1_gej *r, int num, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n     secp256k1_ge tmpa;\n     secp256k1_fe Z;\n-#ifdef USE_ENDOMORPHISM\n     /* Splitted G factors. */\n     secp256k1_scalar ng_1, ng_128;\n     int wnaf_ng_1[129];\n     int bits_ng_1 = 0;\n     int wnaf_ng_128[129];\n     int bits_ng_128 = 0;\n-#else\n-    int wnaf_ng[256];\n-    int bits_ng = 0;\n-#endif\n     int i;\n     int bits = 0;\n     int np;\n@@ -494,28 +462,20 @@ static void secp256k1_ecmult_strauss_wnaf(const secp256k1_ecmult_context *ctx, c\n             continue;\n         }\n         state->ps[no].input_pos = np;\n-#ifdef USE_ENDOMORPHISM\n         /* split na into na_1 and na_lam (where na = na_1 + na_lam*lambda, and na_1 and na_lam are ~128 bit) */\n         secp256k1_scalar_split_lambda(&state->ps[no].na_1, &state->ps[no].na_lam, &na[np]);\n \n         /* build wnaf representation for na_1 and na_lam. */\n-        state->ps[no].bits_na_1   = secp256k1_ecmult_wnaf(state->ps[no].wnaf_na_1,   130, &state->ps[no].na_1,   WINDOW_A);\n-        state->ps[no].bits_na_lam = secp256k1_ecmult_wnaf(state->ps[no].wnaf_na_lam, 130, &state->ps[no].na_lam, WINDOW_A);\n-        VERIFY_CHECK(state->ps[no].bits_na_1 <= 130);\n-        VERIFY_CHECK(state->ps[no].bits_na_lam <= 130);\n+        state->ps[no].bits_na_1   = secp256k1_ecmult_wnaf(state->ps[no].wnaf_na_1,   129, &state->ps[no].na_1,   WINDOW_A);\n+        state->ps[no].bits_na_lam = secp256k1_ecmult_wnaf(state->ps[no].wnaf_na_lam, 129, &state->ps[no].na_lam, WINDOW_A);\n+        VERIFY_CHECK(state->ps[no].bits_na_1 <= 129);\n+        VERIFY_CHECK(state->ps[no].bits_na_lam <= 129);\n         if (state->ps[no].bits_na_1 > bits) {\n             bits = state->ps[no].bits_na_1;\n         }\n         if (state->ps[no].bits_na_lam > bits) {\n             bits = state->ps[no].bits_na_lam;\n         }\n-#else\n-        /* build wnaf representation for na. */\n-        state->ps[no].bits_na     = secp256k1_ecmult_wnaf(state->ps[no].wnaf_na,     256, &na[np],      WINDOW_A);\n-        if (state->ps[no].bits_na > bits) {\n-            bits = state->ps[no].bits_na;\n-        }\n-#endif\n         ++no;\n     }\n \n@@ -547,7 +507,6 @@ static void secp256k1_ecmult_strauss_wnaf(const secp256k1_ecmult_context *ctx, c\n         secp256k1_fe_set_int(&Z, 1);\n     }\n \n-#ifdef USE_ENDOMORPHISM\n     for (np = 0; np < no; ++np) {\n         for (i = 0; i < ECMULT_TABLE_SIZE(WINDOW_A); i++) {\n             secp256k1_ge_mul_lambda(&state->pre_a_lam[np * ECMULT_TABLE_SIZE(WINDOW_A) + i], &state->pre_a[np * ECMULT_TABLE_SIZE(WINDOW_A) + i]);\n@@ -568,21 +527,12 @@ static void secp256k1_ecmult_strauss_wnaf(const secp256k1_ecmult_context *ctx, c\n             bits = bits_ng_128;\n         }\n     }\n-#else\n-    if (ng) {\n-        bits_ng     = secp256k1_ecmult_wnaf(wnaf_ng,     256, ng,      WINDOW_G);\n-        if (bits_ng > bits) {\n-            bits = bits_ng;\n-        }\n-    }\n-#endif\n \n     secp256k1_gej_set_infinity(r);\n \n     for (i = bits - 1; i >= 0; i--) {\n         int n;\n         secp256k1_gej_double_var(r, r, NULL);\n-#ifdef USE_ENDOMORPHISM\n         for (np = 0; np < no; ++np) {\n             if (i < state->ps[np].bits_na_1 && (n = state->ps[np].wnaf_na_1[i])) {\n                 ECMULT_TABLE_GET_GE(&tmpa, state->pre_a + np * ECMULT_TABLE_SIZE(WINDOW_A), n, WINDOW_A);\n@@ -601,18 +551,6 @@ static void secp256k1_ecmult_strauss_wnaf(const secp256k1_ecmult_context *ctx, c\n             ECMULT_TABLE_GET_GE_STORAGE(&tmpa, *ctx->pre_g_128, n, WINDOW_G);\n             secp256k1_gej_add_zinv_var(r, r, &tmpa, &Z);\n         }\n-#else\n-        for (np = 0; np < no; ++np) {\n-            if (i < state->ps[np].bits_na && (n = state->ps[np].wnaf_na[i])) {\n-                ECMULT_TABLE_GET_GE(&tmpa, state->pre_a + np * ECMULT_TABLE_SIZE(WINDOW_A), n, WINDOW_A);\n-                secp256k1_gej_add_ge_var(r, r, &tmpa, NULL);\n-            }\n-        }\n-        if (i < bits_ng && (n = wnaf_ng[i])) {\n-            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, *ctx->pre_g, n, WINDOW_G);\n-            secp256k1_gej_add_zinv_var(r, r, &tmpa, &Z);\n-        }\n-#endif\n     }\n \n     if (!r->infinity) {\n@@ -625,27 +563,19 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n     secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n     struct secp256k1_strauss_point_state ps[1];\n-#ifdef USE_ENDOMORPHISM\n     secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n-#endif\n     struct secp256k1_strauss_state state;\n \n     state.prej = prej;\n     state.zr = zr;\n     state.pre_a = pre_a;\n-#ifdef USE_ENDOMORPHISM\n     state.pre_a_lam = pre_a_lam;\n-#endif\n     state.ps = ps;\n     secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n }\n \n static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n-#ifdef USE_ENDOMORPHISM\n     static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n-#else\n-    static const size_t point_size = (sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n-#endif\n     return n_points*point_size;\n }\n \n@@ -665,12 +595,8 @@ static int secp256k1_ecmult_strauss_batch(const secp256k1_callback* error_callba\n     scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(error_callback, scratch, n_points * sizeof(secp256k1_scalar));\n     state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(error_callback, scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n     state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(error_callback, scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n-#ifdef USE_ENDOMORPHISM\n     state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(error_callback, scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n     state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n-#else\n-    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(error_callback, scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n-#endif\n     state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(error_callback, scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n \n     if (points == NULL || scalars == NULL || state.prej == NULL || state.zr == NULL || state.pre_a == NULL) {\n@@ -868,7 +794,6 @@ static int secp256k1_ecmult_pippenger_wnaf(secp256k1_gej *buckets, int bucket_wi\n  * set of buckets) for a given number of points.\n  */\n static int secp256k1_pippenger_bucket_window(size_t n) {\n-#ifdef USE_ENDOMORPHISM\n     if (n <= 1) {\n         return 1;\n     } else if (n <= 4) {\n@@ -892,41 +817,13 @@ static int secp256k1_pippenger_bucket_window(size_t n) {\n     } else {\n         return PIPPENGER_MAX_BUCKET_WINDOW;\n     }\n-#else\n-    if (n <= 1) {\n-        return 1;\n-    } else if (n <= 11) {\n-        return 2;\n-    } else if (n <= 45) {\n-        return 3;\n-    } else if (n <= 100) {\n-        return 4;\n-    } else if (n <= 275) {\n-        return 5;\n-    } else if (n <= 625) {\n-        return 6;\n-    } else if (n <= 1850) {\n-        return 7;\n-    } else if (n <= 3400) {\n-        return 8;\n-    } else if (n <= 9630) {\n-        return 9;\n-    } else if (n <= 17900) {\n-        return 10;\n-    } else if (n <= 32800) {\n-        return 11;\n-    } else {\n-        return PIPPENGER_MAX_BUCKET_WINDOW;\n-    }\n-#endif\n }\n \n /**\n  * Returns the maximum optimal number of points for a bucket_window.\n  */\n static size_t secp256k1_pippenger_bucket_window_inv(int bucket_window) {\n     switch(bucket_window) {\n-#ifdef USE_ENDOMORPHISM\n         case 1: return 1;\n         case 2: return 4;\n         case 3: return 20;\n@@ -939,26 +836,11 @@ static size_t secp256k1_pippenger_bucket_window_inv(int bucket_window) {\n         case 10: return 7880;\n         case 11: return 16050;\n         case PIPPENGER_MAX_BUCKET_WINDOW: return SIZE_MAX;\n-#else\n-        case 1: return 1;\n-        case 2: return 11;\n-        case 3: return 45;\n-        case 4: return 100;\n-        case 5: return 275;\n-        case 6: return 625;\n-        case 7: return 1850;\n-        case 8: return 3400;\n-        case 9: return 9630;\n-        case 10: return 17900;\n-        case 11: return 32800;\n-        case PIPPENGER_MAX_BUCKET_WINDOW: return SIZE_MAX;\n-#endif\n     }\n     return 0;\n }\n \n \n-#ifdef USE_ENDOMORPHISM\n SECP256K1_INLINE static void secp256k1_ecmult_endo_split(secp256k1_scalar *s1, secp256k1_scalar *s2, secp256k1_ge *p1, secp256k1_ge *p2) {\n     secp256k1_scalar tmp = *s1;\n     secp256k1_scalar_split_lambda(s1, s2, &tmp);\n@@ -973,32 +855,23 @@ SECP256K1_INLINE static void secp256k1_ecmult_endo_split(secp256k1_scalar *s1, s\n         secp256k1_ge_neg(p2, p2);\n     }\n }\n-#endif\n \n /**\n  * Returns the scratch size required for a given number of points (excluding\n  * base point G) without considering alignment.\n  */\n static size_t secp256k1_pippenger_scratch_size(size_t n_points, int bucket_window) {\n-#ifdef USE_ENDOMORPHISM\n     size_t entries = 2*n_points + 2;\n-#else\n-    size_t entries = n_points + 1;\n-#endif\n     size_t entry_size = sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) + sizeof(struct secp256k1_pippenger_point_state) + (WNAF_SIZE(bucket_window+1)+1)*sizeof(int);\n     return (sizeof(secp256k1_gej) << bucket_window) + sizeof(struct secp256k1_pippenger_state) + entries * entry_size;\n }\n \n static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n     const size_t scratch_checkpoint = secp256k1_scratch_checkpoint(error_callback, scratch);\n-    /* Use 2(n+1) with the endomorphism, n+1 without, when calculating batch\n+    /* Use 2(n+1) with the endomorphism, when calculating batch\n      * sizes. The reason for +1 is that we add the G scalar to the list of\n      * other scalars. */\n-#ifdef USE_ENDOMORPHISM\n     size_t entries = 2*n_points + 2;\n-#else\n-    size_t entries = n_points + 1;\n-#endif\n     secp256k1_ge *points;\n     secp256k1_scalar *scalars;\n     secp256k1_gej *buckets;\n@@ -1035,10 +908,8 @@ static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_call\n         scalars[0] = *inp_g_sc;\n         points[0] = secp256k1_ge_const_g;\n         idx++;\n-#ifdef USE_ENDOMORPHISM\n         secp256k1_ecmult_endo_split(&scalars[0], &scalars[1], &points[0], &points[1]);\n         idx++;\n-#endif\n     }\n \n     while (point_idx < n_points) {\n@@ -1047,10 +918,8 @@ static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_call\n             return 0;\n         }\n         idx++;\n-#ifdef USE_ENDOMORPHISM\n         secp256k1_ecmult_endo_split(&scalars[idx - 1], &scalars[idx], &points[idx - 1], &points[idx]);\n         idx++;\n-#endif\n         point_idx++;\n     }\n \n@@ -1093,9 +962,7 @@ static size_t secp256k1_pippenger_max_points(const secp256k1_callback* error_cal\n         size_t space_overhead;\n         size_t entry_size = sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) + sizeof(struct secp256k1_pippenger_point_state) + (WNAF_SIZE(bucket_window+1)+1)*sizeof(int);\n \n-#ifdef USE_ENDOMORPHISM\n         entry_size = 2*entry_size;\n-#endif\n         space_overhead = (sizeof(secp256k1_gej) << bucket_window) + entry_size + sizeof(struct secp256k1_pippenger_state);\n         if (space_overhead > max_alloc) {\n             break;"
      },
      {
        "sha": "36e39ecf0f159ba6c3b234dfde8c06e267525b05",
        "filename": "src/group.h",
        "status": "modified",
        "additions": 12,
        "deletions": 2,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/group.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/group.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/group.h?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -59,6 +59,7 @@ static int secp256k1_ge_is_infinity(const secp256k1_ge *a);\n /** Check whether a group element is valid (i.e., on the curve). */\n static int secp256k1_ge_is_valid_var(const secp256k1_ge *a);\n \n+/** Set r equal to the inverse of a (i.e., mirrored around the X axis) */\n static void secp256k1_ge_neg(secp256k1_ge *r, const secp256k1_ge *a);\n \n /** Set a group element equal to another which is given in jacobian coordinates */\n@@ -115,10 +116,8 @@ static void secp256k1_gej_add_ge_var(secp256k1_gej *r, const secp256k1_gej *a, c\n /** Set r equal to the sum of a and b (with the inverse of b's Z coordinate passed as bzinv). */\n static void secp256k1_gej_add_zinv_var(secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_ge *b, const secp256k1_fe *bzinv);\n \n-#ifdef USE_ENDOMORPHISM\n /** Set r to be equal to lambda times a, where lambda is chosen in a way such that this is very fast. */\n static void secp256k1_ge_mul_lambda(secp256k1_ge *r, const secp256k1_ge *a);\n-#endif\n \n /** Clear a secp256k1_gej to prevent leaking sensitive information. */\n static void secp256k1_gej_clear(secp256k1_gej *r);\n@@ -138,4 +137,15 @@ static void secp256k1_ge_storage_cmov(secp256k1_ge_storage *r, const secp256k1_g\n /** Rescale a jacobian point by b which must be non-zero. Constant-time. */\n static void secp256k1_gej_rescale(secp256k1_gej *r, const secp256k1_fe *b);\n \n+/** Determine if a point (which is assumed to be on the curve) is in the correct (sub)group of the curve.\n+ *\n+ * In normal mode, the used group is secp256k1, which has cofactor=1 meaning that every point on the curve is in the\n+ * group, and this function returns always true.\n+ *\n+ * When compiling in exhaustive test mode, a slightly different curve equation is used, leading to a group with a\n+ * (very) small subgroup, and that subgroup is what is used for all cryptographic operations. In that mode, this\n+ * function checks whether a point that is on the curve is in fact also in that subgroup.\n+ */\n+static int secp256k1_ge_is_in_correct_subgroup(const secp256k1_ge* ge);\n+\n #endif /* SECP256K1_GROUP_H */"
      },
      {
        "sha": "a5fbc91a0f88d2e9eddcb13072b95d9f5938c258",
        "filename": "src/group_impl.h",
        "status": "modified",
        "additions": 52,
        "deletions": 66,
        "changes": 118,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/group_impl.h?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -11,49 +11,38 @@\n #include \"field.h\"\n #include \"group.h\"\n \n-/* These points can be generated in sage as follows:\n+/* These exhaustive group test orders and generators are chosen such that:\n+ * - The field size is equal to that of secp256k1, so field code is the same.\n+ * - The curve equation is of the form y^2=x^3+B for some constant B.\n+ * - The subgroup has a generator 2*P, where P.x=1.\n+ * - The subgroup has size less than 1000 to permit exhaustive testing.\n+ * - The subgroup admits an endomorphism of the form lambda*(x,y) == (beta*x,y).\n  *\n- * 0. Setup a worksheet with the following parameters.\n- *   b = 4  # whatever CURVE_B will be set to\n- *   F = FiniteField (0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F)\n- *   C = EllipticCurve ([F (0), F (b)])\n- *\n- * 1. Determine all the small orders available to you. (If there are\n- *    no satisfactory ones, go back and change b.)\n- *   print C.order().factor(limit=1000)\n- *\n- * 2. Choose an order as one of the prime factors listed in the above step.\n- *    (You can also multiply some to get a composite order, though the\n- *    tests will crash trying to invert scalars during signing.) We take a\n- *    random point and scale it to drop its order to the desired value.\n- *    There is some probability this won't work; just try again.\n- *   order = 199\n- *   P = C.random_point()\n- *   P = (int(P.order()) / int(order)) * P\n- *   assert(P.order() == order)\n- *\n- * 3. Print the values. You'll need to use a vim macro or something to\n- *    split the hex output into 4-byte chunks.\n- *   print \"%x %x\" % P.xy()\n+ * These parameters are generated using sage/gen_exhaustive_groups.sage.\n  */\n #if defined(EXHAUSTIVE_TEST_ORDER)\n-#  if EXHAUSTIVE_TEST_ORDER == 199\n+#  if EXHAUSTIVE_TEST_ORDER == 13\n static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n-    0xFA7CC9A7, 0x0737F2DB, 0xA749DD39, 0x2B4FB069,\n-    0x3B017A7D, 0xA808C2F1, 0xFB12940C, 0x9EA66C18,\n-    0x78AC123A, 0x5ED8AEF3, 0x8732BC91, 0x1F3A2868,\n-    0x48DF246C, 0x808DAE72, 0xCFE52572, 0x7F0501ED\n+    0xc3459c3d, 0x35326167, 0xcd86cce8, 0x07a2417f,\n+    0x5b8bd567, 0xde8538ee, 0x0d507b0c, 0xd128f5bb,\n+    0x8e467fec, 0xcd30000a, 0x6cc1184e, 0x25d382c2,\n+    0xa2f4494e, 0x2fbe9abc, 0x8b64abac, 0xd005fb24\n );\n-\n-static const int CURVE_B = 4;\n-#  elif EXHAUSTIVE_TEST_ORDER == 13\n+static const secp256k1_fe secp256k1_fe_const_b = SECP256K1_FE_CONST(\n+    0x3d3486b2, 0x159a9ca5, 0xc75638be, 0xb23a69bc,\n+    0x946a45ab, 0x24801247, 0xb4ed2b8e, 0x26b6a417\n+);\n+#  elif EXHAUSTIVE_TEST_ORDER == 199\n static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n-    0xedc60018, 0xa51a786b, 0x2ea91f4d, 0x4c9416c0,\n-    0x9de54c3b, 0xa1316554, 0x6cf4345c, 0x7277ef15,\n-    0x54cb1b6b, 0xdc8c1273, 0x087844ea, 0x43f4603e,\n-    0x0eaf9a43, 0xf6effe55, 0x939f806d, 0x37adf8ac\n+    0x226e653f, 0xc8df7744, 0x9bacbf12, 0x7d1dcbf9,\n+    0x87f05b2a, 0xe7edbd28, 0x1f564575, 0xc48dcf18,\n+    0xa13872c2, 0xe933bb17, 0x5d9ffd5b, 0xb5b6e10c,\n+    0x57fe3c00, 0xbaaaa15a, 0xe003ec3e, 0x9c269bae\n+);\n+static const secp256k1_fe secp256k1_fe_const_b = SECP256K1_FE_CONST(\n+    0x2cca28fa, 0xfc614b80, 0x2a3db42b, 0x00ba00b1,\n+    0xbea8d943, 0xdace9ab2, 0x9536daea, 0x0074defb\n );\n-static const int CURVE_B = 2;\n #  else\n #    error No known generator for the specified exhaustive test group order.\n #  endif\n@@ -68,7 +57,7 @@ static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n     0xFD17B448UL, 0xA6855419UL, 0x9C47D08FUL, 0xFB10D4B8UL\n );\n \n-static const int CURVE_B = 7;\n+static const secp256k1_fe secp256k1_fe_const_b = SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 7);\n #endif\n \n static void secp256k1_ge_set_gej_zinv(secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_fe *zi) {\n@@ -219,14 +208,13 @@ static void secp256k1_ge_clear(secp256k1_ge *r) {\n }\n \n static int secp256k1_ge_set_xquad(secp256k1_ge *r, const secp256k1_fe *x) {\n-    secp256k1_fe x2, x3, c;\n+    secp256k1_fe x2, x3;\n     r->x = *x;\n     secp256k1_fe_sqr(&x2, x);\n     secp256k1_fe_mul(&x3, x, &x2);\n     r->infinity = 0;\n-    secp256k1_fe_set_int(&c, CURVE_B);\n-    secp256k1_fe_add(&c, &x3);\n-    return secp256k1_fe_sqrt(&r->y, &c);\n+    secp256k1_fe_add(&x3, &secp256k1_fe_const_b);\n+    return secp256k1_fe_sqrt(&r->y, &x3);\n }\n \n static int secp256k1_ge_set_xo_var(secp256k1_ge *r, const secp256k1_fe *x, int odd) {\n@@ -269,36 +257,15 @@ static int secp256k1_gej_is_infinity(const secp256k1_gej *a) {\n     return a->infinity;\n }\n \n-static int secp256k1_gej_is_valid_var(const secp256k1_gej *a) {\n-    secp256k1_fe y2, x3, z2, z6;\n-    if (a->infinity) {\n-        return 0;\n-    }\n-    /** y^2 = x^3 + 7\n-     *  (Y/Z^3)^2 = (X/Z^2)^3 + 7\n-     *  Y^2 / Z^6 = X^3 / Z^6 + 7\n-     *  Y^2 = X^3 + 7*Z^6\n-     */\n-    secp256k1_fe_sqr(&y2, &a->y);\n-    secp256k1_fe_sqr(&x3, &a->x); secp256k1_fe_mul(&x3, &x3, &a->x);\n-    secp256k1_fe_sqr(&z2, &a->z);\n-    secp256k1_fe_sqr(&z6, &z2); secp256k1_fe_mul(&z6, &z6, &z2);\n-    secp256k1_fe_mul_int(&z6, CURVE_B);\n-    secp256k1_fe_add(&x3, &z6);\n-    secp256k1_fe_normalize_weak(&x3);\n-    return secp256k1_fe_equal_var(&y2, &x3);\n-}\n-\n static int secp256k1_ge_is_valid_var(const secp256k1_ge *a) {\n-    secp256k1_fe y2, x3, c;\n+    secp256k1_fe y2, x3;\n     if (a->infinity) {\n         return 0;\n     }\n     /* y^2 = x^3 + 7 */\n     secp256k1_fe_sqr(&y2, &a->y);\n     secp256k1_fe_sqr(&x3, &a->x); secp256k1_fe_mul(&x3, &x3, &a->x);\n-    secp256k1_fe_set_int(&c, CURVE_B);\n-    secp256k1_fe_add(&x3, &c);\n+    secp256k1_fe_add(&x3, &secp256k1_fe_const_b);\n     secp256k1_fe_normalize_weak(&x3);\n     return secp256k1_fe_equal_var(&y2, &x3);\n }\n@@ -679,7 +646,6 @@ static SECP256K1_INLINE void secp256k1_ge_storage_cmov(secp256k1_ge_storage *r,\n     secp256k1_fe_storage_cmov(&r->y, &a->y, flag);\n }\n \n-#ifdef USE_ENDOMORPHISM\n static void secp256k1_ge_mul_lambda(secp256k1_ge *r, const secp256k1_ge *a) {\n     static const secp256k1_fe beta = SECP256K1_FE_CONST(\n         0x7ae96a2bul, 0x657c0710ul, 0x6e64479eul, 0xac3434e9ul,\n@@ -688,7 +654,6 @@ static void secp256k1_ge_mul_lambda(secp256k1_ge *r, const secp256k1_ge *a) {\n     *r = *a;\n     secp256k1_fe_mul(&r->x, &r->x, &beta);\n }\n-#endif\n \n static int secp256k1_gej_has_quad_y_var(const secp256k1_gej *a) {\n     secp256k1_fe yz;\n@@ -704,4 +669,25 @@ static int secp256k1_gej_has_quad_y_var(const secp256k1_gej *a) {\n     return secp256k1_fe_is_quad_var(&yz);\n }\n \n+static int secp256k1_ge_is_in_correct_subgroup(const secp256k1_ge* ge) {\n+#ifdef EXHAUSTIVE_TEST_ORDER\n+    secp256k1_gej out;\n+    int i;\n+\n+    /* A very simple EC multiplication ladder that avoids a dependecy on ecmult. */\n+    secp256k1_gej_set_infinity(&out);\n+    for (i = 0; i < 32; ++i) {\n+        secp256k1_gej_double_var(&out, &out, NULL);\n+        if ((((uint32_t)EXHAUSTIVE_TEST_ORDER) >> (31 - i)) & 1) {\n+            secp256k1_gej_add_ge_var(&out, &out, ge, NULL);\n+        }\n+    }\n+    return secp256k1_gej_is_infinity(&out);\n+#else\n+    (void)ge;\n+    /* The real secp256k1 group has cofactor 1, so the subgroup is the entire curve. */\n+    return 1;\n+#endif\n+}\n+\n #endif /* SECP256K1_GROUP_IMPL_H */"
      },
      {
        "sha": "e8d2aeab9a59b25fbceabf87fa8c0aab7f01dfd5",
        "filename": "src/modules/ecdh/tests_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/modules/ecdh/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/modules/ecdh/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/ecdh/tests_impl.h?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -80,7 +80,7 @@ void test_ecdh_generator_basepoint(void) {\n         /* compute \"explicitly\" */\n         CHECK(secp256k1_ec_pubkey_serialize(ctx, point_ser, &point_ser_len, &point[1], SECP256K1_EC_UNCOMPRESSED) == 1);\n         /* compare */\n-        CHECK(memcmp(output_ecdh, point_ser, 65) == 0);\n+        CHECK(secp256k1_memcmp_var(output_ecdh, point_ser, 65) == 0);\n \n         /* compute using ECDH function with default hash function */\n         CHECK(secp256k1_ecdh(ctx, output_ecdh, &point[0], s_b32, NULL, NULL) == 1);\n@@ -90,7 +90,7 @@ void test_ecdh_generator_basepoint(void) {\n         secp256k1_sha256_write(&sha, point_ser, point_ser_len);\n         secp256k1_sha256_finalize(&sha, output_ser);\n         /* compare */\n-        CHECK(memcmp(output_ecdh, output_ser, 32) == 0);\n+        CHECK(secp256k1_memcmp_var(output_ecdh, output_ser, 32) == 0);\n     }\n }\n "
      },
      {
        "sha": "0d901ec1f4495a56bebb918dd5a351e9e52c7d92",
        "filename": "src/modules/extrakeys/Makefile.am.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/modules/extrakeys/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/modules/extrakeys/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/extrakeys/Makefile.am.include?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -1,3 +1,4 @@\n include_HEADERS += include/secp256k1_extrakeys.h\n noinst_HEADERS += src/modules/extrakeys/tests_impl.h\n+noinst_HEADERS += src/modules/extrakeys/tests_exhaustive_impl.h\n noinst_HEADERS += src/modules/extrakeys/main_impl.h"
      },
      {
        "sha": "5378d2f301bc9e79d88f04d7b823fbbd94bf8f95",
        "filename": "src/modules/extrakeys/main_impl.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/modules/extrakeys/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/modules/extrakeys/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/extrakeys/main_impl.h?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -33,6 +33,9 @@ int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_p\n     if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n         return 0;\n     }\n+    if (!secp256k1_ge_is_in_correct_subgroup(&pk)) {\n+        return 0;\n+    }\n     secp256k1_xonly_pubkey_save(pubkey, &pk);\n     return 1;\n }\n@@ -121,7 +124,7 @@ int secp256k1_xonly_pubkey_tweak_add_check(const secp256k1_context* ctx, const u\n     secp256k1_fe_normalize_var(&pk.y);\n     secp256k1_fe_get_b32(pk_expected32, &pk.x);\n \n-    return memcmp(&pk_expected32, tweaked_pubkey32, 32) == 0\n+    return secp256k1_memcmp_var(&pk_expected32, tweaked_pubkey32, 32) == 0\n             && secp256k1_fe_is_odd(&pk.y) == tweaked_pk_parity;\n }\n "
      },
      {
        "sha": "0e29bc6b09d951f3fc3517d0f14470f6d8d29a48",
        "filename": "src/modules/extrakeys/tests_exhaustive_impl.h",
        "status": "added",
        "additions": 68,
        "deletions": 0,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/modules/extrakeys/tests_exhaustive_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/modules/extrakeys/tests_exhaustive_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/extrakeys/tests_exhaustive_impl.h?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -0,0 +1,68 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Pieter Wuille                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_TESTS_EXHAUSTIVE_\n+#define _SECP256K1_MODULE_EXTRAKEYS_TESTS_EXHAUSTIVE_\n+\n+#include \"src/modules/extrakeys/main_impl.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static void test_exhaustive_extrakeys(const secp256k1_context *ctx, const secp256k1_ge* group) {\n+    secp256k1_keypair keypair[EXHAUSTIVE_TEST_ORDER - 1];\n+    secp256k1_pubkey pubkey[EXHAUSTIVE_TEST_ORDER - 1];\n+    secp256k1_xonly_pubkey xonly_pubkey[EXHAUSTIVE_TEST_ORDER - 1];\n+    int parities[EXHAUSTIVE_TEST_ORDER - 1];\n+    unsigned char xonly_pubkey_bytes[EXHAUSTIVE_TEST_ORDER - 1][32];\n+    int i;\n+\n+    for (i = 1; i < EXHAUSTIVE_TEST_ORDER; i++) {\n+        secp256k1_fe fe;\n+        secp256k1_scalar scalar_i;\n+        unsigned char buf[33];\n+        int parity;\n+\n+        secp256k1_scalar_set_int(&scalar_i, i);\n+        secp256k1_scalar_get_b32(buf, &scalar_i);\n+\n+        /* Construct pubkey and keypair. */\n+        CHECK(secp256k1_keypair_create(ctx, &keypair[i - 1], buf));\n+        CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey[i - 1], buf));\n+\n+        /* Construct serialized xonly_pubkey from keypair. */\n+        CHECK(secp256k1_keypair_xonly_pub(ctx, &xonly_pubkey[i - 1], &parities[i - 1], &keypair[i - 1]));\n+        CHECK(secp256k1_xonly_pubkey_serialize(ctx, xonly_pubkey_bytes[i - 1], &xonly_pubkey[i - 1]));\n+\n+        /* Parse the xonly_pubkey back and verify it matches the previously serialized value. */\n+        CHECK(secp256k1_xonly_pubkey_parse(ctx, &xonly_pubkey[i - 1], xonly_pubkey_bytes[i - 1]));\n+        CHECK(secp256k1_xonly_pubkey_serialize(ctx, buf, &xonly_pubkey[i - 1]));\n+        CHECK(secp256k1_memcmp_var(xonly_pubkey_bytes[i - 1], buf, 32) == 0);\n+\n+        /* Construct the xonly_pubkey from the pubkey, and verify it matches the same. */\n+        CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &xonly_pubkey[i - 1], &parity, &pubkey[i - 1]));\n+        CHECK(parity == parities[i - 1]);\n+        CHECK(secp256k1_xonly_pubkey_serialize(ctx, buf, &xonly_pubkey[i - 1]));\n+        CHECK(secp256k1_memcmp_var(xonly_pubkey_bytes[i - 1], buf, 32) == 0);\n+\n+        /* Compare the xonly_pubkey bytes against the precomputed group. */\n+        secp256k1_fe_set_b32(&fe, xonly_pubkey_bytes[i - 1]);\n+        CHECK(secp256k1_fe_equal_var(&fe, &group[i].x));\n+\n+        /* Check the parity against the precomputed group. */\n+        fe = group[i].y;\n+        secp256k1_fe_normalize_var(&fe);\n+        CHECK(secp256k1_fe_is_odd(&fe) == parities[i - 1]);\n+\n+        /* Verify that the higher half is identical to the lower half mirrored. */\n+        if (i > EXHAUSTIVE_TEST_ORDER / 2) {\n+            CHECK(secp256k1_memcmp_var(xonly_pubkey_bytes[i - 1], xonly_pubkey_bytes[EXHAUSTIVE_TEST_ORDER - i - 1], 32) == 0);\n+            CHECK(parities[i - 1] == 1 - parities[EXHAUSTIVE_TEST_ORDER - i - 1]);\n+        }\n+    }\n+\n+    /* TODO: keypair/xonly_pubkey tweak tests */\n+}\n+\n+#endif"
      },
      {
        "sha": "5ee135849ef21682be45d3d177acbc02f66e10f0",
        "filename": "src/modules/extrakeys/tests_impl.h",
        "status": "modified",
        "additions": 48,
        "deletions": 48,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/modules/extrakeys/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/modules/extrakeys/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/extrakeys/tests_impl.h?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -35,9 +35,9 @@ void test_xonly_pubkey(void) {\n     secp256k1_context *sign = api_test_context(SECP256K1_CONTEXT_SIGN, &ecount);\n     secp256k1_context *verify = api_test_context(SECP256K1_CONTEXT_VERIFY, &ecount);\n \n-    secp256k1_rand256(sk);\n+    secp256k1_testrand256(sk);\n     memset(ones32, 0xFF, 32);\n-    secp256k1_rand256(xy_sk);\n+    secp256k1_testrand256(xy_sk);\n     CHECK(secp256k1_ec_pubkey_create(sign, &pk, sk) == 1);\n     CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &xonly_pk, &pk_parity, &pk) == 1);\n \n@@ -60,15 +60,15 @@ void test_xonly_pubkey(void) {\n     sk[0] = 1;\n     CHECK(secp256k1_ec_pubkey_create(ctx, &pk, sk) == 1);\n     CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &xonly_pk, &pk_parity, &pk) == 1);\n-    CHECK(memcmp(&pk, &xonly_pk, sizeof(pk)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pk, &xonly_pk, sizeof(pk)) == 0);\n     CHECK(pk_parity == 0);\n \n     /* Choose a secret key such that pubkey and xonly_pubkey are each others\n      * negation. */\n     sk[0] = 2;\n     CHECK(secp256k1_ec_pubkey_create(ctx, &pk, sk) == 1);\n     CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &xonly_pk, &pk_parity, &pk) == 1);\n-    CHECK(memcmp(&xonly_pk, &pk, sizeof(xonly_pk)) != 0);\n+    CHECK(secp256k1_memcmp_var(&xonly_pk, &pk, sizeof(xonly_pk)) != 0);\n     CHECK(pk_parity == 1);\n     secp256k1_pubkey_load(ctx, &pk1, &pk);\n     secp256k1_pubkey_load(ctx, &pk2, (secp256k1_pubkey *) &xonly_pk);\n@@ -81,7 +81,7 @@ void test_xonly_pubkey(void) {\n     CHECK(secp256k1_xonly_pubkey_serialize(none, NULL, &xonly_pk) == 0);\n     CHECK(ecount == 1);\n     CHECK(secp256k1_xonly_pubkey_serialize(none, buf32, NULL) == 0);\n-    CHECK(memcmp(buf32, zeros64, 32) == 0);\n+    CHECK(secp256k1_memcmp_var(buf32, zeros64, 32) == 0);\n     CHECK(ecount == 2);\n     {\n         /* A pubkey filled with 0s will fail to serialize due to pubkey_load\n@@ -104,28 +104,28 @@ void test_xonly_pubkey(void) {\n     CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &xonly_pk, NULL, &pk) == 1);\n     CHECK(secp256k1_xonly_pubkey_serialize(ctx, buf32, &xonly_pk) == 1);\n     CHECK(secp256k1_xonly_pubkey_parse(ctx, &xonly_pk_tmp, buf32) == 1);\n-    CHECK(memcmp(&xonly_pk, &xonly_pk_tmp, sizeof(xonly_pk)) == 0);\n+    CHECK(secp256k1_memcmp_var(&xonly_pk, &xonly_pk_tmp, sizeof(xonly_pk)) == 0);\n \n     /* Test parsing invalid field elements */\n     memset(&xonly_pk, 1, sizeof(xonly_pk));\n     /* Overflowing field element */\n     CHECK(secp256k1_xonly_pubkey_parse(none, &xonly_pk, ones32) == 0);\n-    CHECK(memcmp(&xonly_pk, zeros64, sizeof(xonly_pk)) == 0);\n+    CHECK(secp256k1_memcmp_var(&xonly_pk, zeros64, sizeof(xonly_pk)) == 0);\n     memset(&xonly_pk, 1, sizeof(xonly_pk));\n     /* There's no point with x-coordinate 0 on secp256k1 */\n     CHECK(secp256k1_xonly_pubkey_parse(none, &xonly_pk, zeros64) == 0);\n-    CHECK(memcmp(&xonly_pk, zeros64, sizeof(xonly_pk)) == 0);\n+    CHECK(secp256k1_memcmp_var(&xonly_pk, zeros64, sizeof(xonly_pk)) == 0);\n     /* If a random 32-byte string can not be parsed with ec_pubkey_parse\n      * (because interpreted as X coordinate it does not correspond to a point on\n      * the curve) then xonly_pubkey_parse should fail as well. */\n     for (i = 0; i < count; i++) {\n         unsigned char rand33[33];\n-        secp256k1_rand256(&rand33[1]);\n+        secp256k1_testrand256(&rand33[1]);\n         rand33[0] = SECP256K1_TAG_PUBKEY_EVEN;\n         if (!secp256k1_ec_pubkey_parse(ctx, &pk, rand33, 33)) {\n             memset(&xonly_pk, 1, sizeof(xonly_pk));\n             CHECK(secp256k1_xonly_pubkey_parse(ctx, &xonly_pk, &rand33[1]) == 0);\n-            CHECK(memcmp(&xonly_pk, zeros64, sizeof(xonly_pk)) == 0);\n+            CHECK(secp256k1_memcmp_var(&xonly_pk, zeros64, sizeof(xonly_pk)) == 0);\n         } else {\n             CHECK(secp256k1_xonly_pubkey_parse(ctx, &xonly_pk, &rand33[1]) == 1);\n         }\n@@ -154,8 +154,8 @@ void test_xonly_pubkey_tweak(void) {\n     secp256k1_context *verify = api_test_context(SECP256K1_CONTEXT_VERIFY, &ecount);\n \n     memset(overflows, 0xff, sizeof(overflows));\n-    secp256k1_rand256(tweak);\n-    secp256k1_rand256(sk);\n+    secp256k1_testrand256(tweak);\n+    secp256k1_testrand256(sk);\n     CHECK(secp256k1_ec_pubkey_create(ctx, &internal_pk, sk) == 1);\n     CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &internal_xonly_pk, &pk_parity, &internal_pk) == 1);\n \n@@ -170,15 +170,15 @@ void test_xonly_pubkey_tweak(void) {\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, NULL, tweak) == 0);\n     CHECK(ecount == 4);\n     /* NULL internal_xonly_pk zeroes the output_pk */\n-    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk)) == 0);\n+    CHECK(secp256k1_memcmp_var(&output_pk, zeros64, sizeof(output_pk)) == 0);\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, NULL) == 0);\n     CHECK(ecount == 5);\n     /* NULL tweak zeroes the output_pk */\n-    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk)) == 0);\n+    CHECK(secp256k1_memcmp_var(&output_pk, zeros64, sizeof(output_pk)) == 0);\n \n     /* Invalid tweak zeroes the output_pk */\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, overflows) == 0);\n-    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk))  == 0);\n+    CHECK(secp256k1_memcmp_var(&output_pk, zeros64, sizeof(output_pk))  == 0);\n \n     /* A zero tweak is fine */\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, zeros64) == 1);\n@@ -193,16 +193,16 @@ void test_xonly_pubkey_tweak(void) {\n         secp256k1_scalar_get_b32(tweak, &scalar_tweak);\n         CHECK((secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, sk) == 0)\n               || (secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, tweak) == 0));\n-        CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk)) == 0);\n+        CHECK(secp256k1_memcmp_var(&output_pk, zeros64, sizeof(output_pk)) == 0);\n     }\n \n     /* Invalid pk with a valid tweak */\n     memset(&internal_xonly_pk, 0, sizeof(internal_xonly_pk));\n-    secp256k1_rand256(tweak);\n+    secp256k1_testrand256(tweak);\n     ecount = 0;\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, tweak) == 0);\n     CHECK(ecount == 1);\n-    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk))  == 0);\n+    CHECK(secp256k1_memcmp_var(&output_pk, zeros64, sizeof(output_pk))  == 0);\n \n     secp256k1_context_destroy(none);\n     secp256k1_context_destroy(sign);\n@@ -228,8 +228,8 @@ void test_xonly_pubkey_tweak_check(void) {\n     secp256k1_context *verify = api_test_context(SECP256K1_CONTEXT_VERIFY, &ecount);\n \n     memset(overflows, 0xff, sizeof(overflows));\n-    secp256k1_rand256(tweak);\n-    secp256k1_rand256(sk);\n+    secp256k1_testrand256(tweak);\n+    secp256k1_testrand256(sk);\n     CHECK(secp256k1_ec_pubkey_create(ctx, &internal_pk, sk) == 1);\n     CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &internal_xonly_pk, &pk_parity, &internal_pk) == 1);\n \n@@ -268,7 +268,7 @@ void test_xonly_pubkey_tweak_check(void) {\n     /* Overflowing tweak not allowed */\n     CHECK(secp256k1_xonly_pubkey_tweak_add_check(ctx, output_pk32, pk_parity, &internal_xonly_pk, overflows) == 0);\n     CHECK(secp256k1_xonly_pubkey_tweak_add(ctx, &output_pk, &internal_xonly_pk, overflows) == 0);\n-    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk)) == 0);\n+    CHECK(secp256k1_memcmp_var(&output_pk, zeros64, sizeof(output_pk)) == 0);\n     CHECK(ecount == 5);\n \n     secp256k1_context_destroy(none);\n@@ -287,7 +287,7 @@ void test_xonly_pubkey_tweak_recursive(void) {\n     unsigned char tweak[N_PUBKEYS - 1][32];\n     int i;\n \n-    secp256k1_rand256(sk);\n+    secp256k1_testrand256(sk);\n     CHECK(secp256k1_ec_pubkey_create(ctx, &pk[0], sk) == 1);\n     /* Add tweaks */\n     for (i = 0; i < N_PUBKEYS - 1; i++) {\n@@ -327,73 +327,73 @@ void test_keypair(void) {\n \n     /* Test keypair_create */\n     ecount = 0;\n-    secp256k1_rand256(sk);\n+    secp256k1_testrand256(sk);\n     CHECK(secp256k1_keypair_create(none, &keypair, sk) == 0);\n-    CHECK(memcmp(zeros96, &keypair, sizeof(keypair)) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros96, &keypair, sizeof(keypair)) == 0);\n     CHECK(ecount == 1);\n     CHECK(secp256k1_keypair_create(verify, &keypair, sk) == 0);\n-    CHECK(memcmp(zeros96, &keypair, sizeof(keypair)) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros96, &keypair, sizeof(keypair)) == 0);\n     CHECK(ecount == 2);\n     CHECK(secp256k1_keypair_create(sign, &keypair, sk) == 1);\n     CHECK(secp256k1_keypair_create(sign, NULL, sk) == 0);\n     CHECK(ecount == 3);\n     CHECK(secp256k1_keypair_create(sign, &keypair, NULL) == 0);\n-    CHECK(memcmp(zeros96, &keypair, sizeof(keypair)) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros96, &keypair, sizeof(keypair)) == 0);\n     CHECK(ecount == 4);\n \n     /* Invalid secret key */\n     CHECK(secp256k1_keypair_create(sign, &keypair, zeros96) == 0);\n-    CHECK(memcmp(zeros96, &keypair, sizeof(keypair)) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros96, &keypair, sizeof(keypair)) == 0);\n     CHECK(secp256k1_keypair_create(sign, &keypair, overflows) == 0);\n-    CHECK(memcmp(zeros96, &keypair, sizeof(keypair)) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros96, &keypair, sizeof(keypair)) == 0);\n \n     /* Test keypair_pub */\n     ecount = 0;\n-    secp256k1_rand256(sk);\n+    secp256k1_testrand256(sk);\n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n     CHECK(secp256k1_keypair_pub(none, &pk, &keypair) == 1);\n     CHECK(secp256k1_keypair_pub(none, NULL, &keypair) == 0);\n     CHECK(ecount == 1);\n     CHECK(secp256k1_keypair_pub(none, &pk, NULL) == 0);\n     CHECK(ecount == 2);\n-    CHECK(memcmp(zeros96, &pk, sizeof(pk)) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros96, &pk, sizeof(pk)) == 0);\n \n     /* Using an invalid keypair is fine for keypair_pub */\n     memset(&keypair, 0, sizeof(keypair));\n     CHECK(secp256k1_keypair_pub(none, &pk, &keypair) == 1);\n-    CHECK(memcmp(zeros96, &pk, sizeof(pk)) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros96, &pk, sizeof(pk)) == 0);\n \n     /* keypair holds the same pubkey as pubkey_create */\n     CHECK(secp256k1_ec_pubkey_create(sign, &pk, sk) == 1);\n     CHECK(secp256k1_keypair_create(sign, &keypair, sk) == 1);\n     CHECK(secp256k1_keypair_pub(none, &pk_tmp, &keypair) == 1);\n-    CHECK(memcmp(&pk, &pk_tmp, sizeof(pk)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pk, &pk_tmp, sizeof(pk)) == 0);\n \n     /** Test keypair_xonly_pub **/\n     ecount = 0;\n-    secp256k1_rand256(sk);\n+    secp256k1_testrand256(sk);\n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n     CHECK(secp256k1_keypair_xonly_pub(none, &xonly_pk, &pk_parity, &keypair) == 1);\n     CHECK(secp256k1_keypair_xonly_pub(none, NULL, &pk_parity, &keypair) == 0);\n     CHECK(ecount == 1);\n     CHECK(secp256k1_keypair_xonly_pub(none, &xonly_pk, NULL, &keypair) == 1);\n     CHECK(secp256k1_keypair_xonly_pub(none, &xonly_pk, &pk_parity, NULL) == 0);\n     CHECK(ecount == 2);\n-    CHECK(memcmp(zeros96, &xonly_pk, sizeof(xonly_pk)) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros96, &xonly_pk, sizeof(xonly_pk)) == 0);\n     /* Using an invalid keypair will set the xonly_pk to 0 (first reset\n      * xonly_pk). */\n     CHECK(secp256k1_keypair_xonly_pub(none, &xonly_pk, &pk_parity, &keypair) == 1);\n     memset(&keypair, 0, sizeof(keypair));\n     CHECK(secp256k1_keypair_xonly_pub(none, &xonly_pk, &pk_parity, &keypair) == 0);\n-    CHECK(memcmp(zeros96, &xonly_pk, sizeof(xonly_pk)) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros96, &xonly_pk, sizeof(xonly_pk)) == 0);\n     CHECK(ecount == 3);\n \n     /** keypair holds the same xonly pubkey as pubkey_create **/\n     CHECK(secp256k1_ec_pubkey_create(sign, &pk, sk) == 1);\n     CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &xonly_pk, &pk_parity, &pk) == 1);\n     CHECK(secp256k1_keypair_create(sign, &keypair, sk) == 1);\n     CHECK(secp256k1_keypair_xonly_pub(none, &xonly_pk_tmp, &pk_parity_tmp, &keypair) == 1);\n-    CHECK(memcmp(&xonly_pk, &xonly_pk_tmp, sizeof(pk)) == 0);\n+    CHECK(secp256k1_memcmp_var(&xonly_pk, &xonly_pk_tmp, sizeof(pk)) == 0);\n     CHECK(pk_parity == pk_parity_tmp);\n \n     secp256k1_context_destroy(none);\n@@ -414,8 +414,8 @@ void test_keypair_add(void) {\n     secp256k1_context *verify = api_test_context(SECP256K1_CONTEXT_VERIFY, &ecount);\n \n     CHECK(sizeof(zeros96) == sizeof(keypair));\n-    secp256k1_rand256(sk);\n-    secp256k1_rand256(tweak);\n+    secp256k1_testrand256(sk);\n+    secp256k1_testrand256(tweak);\n     memset(overflows, 0xFF, 32);\n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n \n@@ -429,12 +429,12 @@ void test_keypair_add(void) {\n     CHECK(secp256k1_keypair_xonly_tweak_add(verify, &keypair, NULL) == 0);\n     CHECK(ecount == 4);\n     /* This does not set the keypair to zeroes */\n-    CHECK(memcmp(&keypair, zeros96, sizeof(keypair)) != 0);\n+    CHECK(secp256k1_memcmp_var(&keypair, zeros96, sizeof(keypair)) != 0);\n \n     /* Invalid tweak zeroes the keypair */\n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n     CHECK(secp256k1_keypair_xonly_tweak_add(ctx, &keypair, overflows) == 0);\n-    CHECK(memcmp(&keypair, zeros96, sizeof(keypair))  == 0);\n+    CHECK(secp256k1_memcmp_var(&keypair, zeros96, sizeof(keypair))  == 0);\n \n     /* A zero tweak is fine */\n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n@@ -444,7 +444,7 @@ void test_keypair_add(void) {\n     for (i = 0; i < count; i++) {\n         secp256k1_scalar scalar_tweak;\n         secp256k1_keypair keypair_tmp;\n-        secp256k1_rand256(sk);\n+        secp256k1_testrand256(sk);\n         CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n         memcpy(&keypair_tmp, &keypair, sizeof(keypair));\n         /* Because sk may be negated before adding, we need to try with tweak =\n@@ -454,17 +454,17 @@ void test_keypair_add(void) {\n         secp256k1_scalar_get_b32(tweak, &scalar_tweak);\n         CHECK((secp256k1_keypair_xonly_tweak_add(ctx, &keypair, sk) == 0)\n               || (secp256k1_keypair_xonly_tweak_add(ctx, &keypair_tmp, tweak) == 0));\n-        CHECK(memcmp(&keypair, zeros96, sizeof(keypair)) == 0\n-              || memcmp(&keypair_tmp, zeros96, sizeof(keypair_tmp)) == 0);\n+        CHECK(secp256k1_memcmp_var(&keypair, zeros96, sizeof(keypair)) == 0\n+              || secp256k1_memcmp_var(&keypair_tmp, zeros96, sizeof(keypair_tmp)) == 0);\n     }\n \n     /* Invalid keypair with a valid tweak */\n     memset(&keypair, 0, sizeof(keypair));\n-    secp256k1_rand256(tweak);\n+    secp256k1_testrand256(tweak);\n     ecount = 0;\n     CHECK(secp256k1_keypair_xonly_tweak_add(verify, &keypair, tweak) == 0);\n     CHECK(ecount == 1);\n-    CHECK(memcmp(&keypair, zeros96, sizeof(keypair))  == 0);\n+    CHECK(secp256k1_memcmp_var(&keypair, zeros96, sizeof(keypair))  == 0);\n     /* Only seckey part of keypair invalid */\n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n     memset(&keypair, 0, 32);\n@@ -486,7 +486,7 @@ void test_keypair_add(void) {\n         unsigned char pk32[32];\n         int pk_parity;\n \n-        secp256k1_rand256(tweak);\n+        secp256k1_testrand256(tweak);\n         CHECK(secp256k1_keypair_xonly_pub(ctx, &internal_pk, NULL, &keypair) == 1);\n         CHECK(secp256k1_keypair_xonly_tweak_add(ctx, &keypair, tweak) == 1);\n         CHECK(secp256k1_keypair_xonly_pub(ctx, &output_pk, &pk_parity, &keypair) == 1);\n@@ -498,11 +498,11 @@ void test_keypair_add(void) {\n         /* Check that the resulting pubkey matches xonly_pubkey_tweak_add */\n         CHECK(secp256k1_keypair_pub(ctx, &output_pk_xy, &keypair) == 1);\n         CHECK(secp256k1_xonly_pubkey_tweak_add(ctx, &output_pk_expected, &internal_pk, tweak) == 1);\n-        CHECK(memcmp(&output_pk_xy, &output_pk_expected, sizeof(output_pk_xy)) == 0);\n+        CHECK(secp256k1_memcmp_var(&output_pk_xy, &output_pk_expected, sizeof(output_pk_xy)) == 0);\n \n         /* Check that the secret key in the keypair is tweaked correctly */\n         CHECK(secp256k1_ec_pubkey_create(ctx, &output_pk_expected, &keypair.data[0]) == 1);\n-        CHECK(memcmp(&output_pk_xy, &output_pk_expected, sizeof(output_pk_xy)) == 0);\n+        CHECK(secp256k1_memcmp_var(&output_pk_xy, &output_pk_expected, sizeof(output_pk_xy)) == 0);\n     }\n     secp256k1_context_destroy(none);\n     secp256k1_context_destroy(sign);"
      },
      {
        "sha": "e2d3f1248d25c178c95902f9d609109063ada444",
        "filename": "src/modules/recovery/Makefile.am.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/modules/recovery/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/modules/recovery/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/recovery/Makefile.am.include?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -1,6 +1,7 @@\n include_HEADERS += include/secp256k1_recovery.h\n noinst_HEADERS += src/modules/recovery/main_impl.h\n noinst_HEADERS += src/modules/recovery/tests_impl.h\n+noinst_HEADERS += src/modules/recovery/tests_exhaustive_impl.h\n if USE_BENCHMARK\n noinst_PROGRAMS += bench_recover\n bench_recover_SOURCES = src/bench_recover.c"
      },
      {
        "sha": "a2f381d77a120c932cd297edc5d2eaf67dd28934",
        "filename": "src/modules/recovery/tests_exhaustive_impl.h",
        "status": "added",
        "additions": 149,
        "deletions": 0,
        "changes": 149,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/modules/recovery/tests_exhaustive_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/modules/recovery/tests_exhaustive_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/recovery/tests_exhaustive_impl.h?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -0,0 +1,149 @@\n+/**********************************************************************\n+ * Copyright (c) 2016 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_RECOVERY_EXHAUSTIVE_TESTS_H\n+#define SECP256K1_MODULE_RECOVERY_EXHAUSTIVE_TESTS_H\n+\n+#include \"src/modules/recovery/main_impl.h\"\n+#include \"include/secp256k1_recovery.h\"\n+\n+void test_exhaustive_recovery_sign(const secp256k1_context *ctx, const secp256k1_ge *group) {\n+    int i, j, k;\n+    uint64_t iter = 0;\n+\n+    /* Loop */\n+    for (i = 1; i < EXHAUSTIVE_TEST_ORDER; i++) {  /* message */\n+        for (j = 1; j < EXHAUSTIVE_TEST_ORDER; j++) {  /* key */\n+            if (skip_section(&iter)) continue;\n+            for (k = 1; k < EXHAUSTIVE_TEST_ORDER; k++) {  /* nonce */\n+                const int starting_k = k;\n+                secp256k1_fe r_dot_y_normalized;\n+                secp256k1_ecdsa_recoverable_signature rsig;\n+                secp256k1_ecdsa_signature sig;\n+                secp256k1_scalar sk, msg, r, s, expected_r;\n+                unsigned char sk32[32], msg32[32];\n+                int expected_recid;\n+                int recid;\n+                int overflow;\n+                secp256k1_scalar_set_int(&msg, i);\n+                secp256k1_scalar_set_int(&sk, j);\n+                secp256k1_scalar_get_b32(sk32, &sk);\n+                secp256k1_scalar_get_b32(msg32, &msg);\n+\n+                secp256k1_ecdsa_sign_recoverable(ctx, &rsig, msg32, sk32, secp256k1_nonce_function_smallint, &k);\n+\n+                /* Check directly */\n+                secp256k1_ecdsa_recoverable_signature_load(ctx, &r, &s, &recid, &rsig);\n+                r_from_k(&expected_r, group, k, &overflow);\n+                CHECK(r == expected_r);\n+                CHECK((k * s) % EXHAUSTIVE_TEST_ORDER == (i + r * j) % EXHAUSTIVE_TEST_ORDER ||\n+                      (k * (EXHAUSTIVE_TEST_ORDER - s)) % EXHAUSTIVE_TEST_ORDER == (i + r * j) % EXHAUSTIVE_TEST_ORDER);\n+                /* The recid's second bit is for conveying overflow (R.x value >= group order).\n+                 * In the actual secp256k1 this is an astronomically unlikely event, but in the\n+                 * small group used here, it will be the case for all points except the ones where\n+                 * R.x=1 (which the group is specifically selected to have).\n+                 * Note that this isn't actually useful; full recovery would need to convey\n+                 * floor(R.x / group_order), but only one bit is used as that is sufficient\n+                 * in the real group. */\n+                expected_recid = overflow ? 2 : 0;\n+                r_dot_y_normalized = group[k].y;\n+                secp256k1_fe_normalize(&r_dot_y_normalized);\n+                /* Also the recovery id is flipped depending if we hit the low-s branch */\n+                if ((k * s) % EXHAUSTIVE_TEST_ORDER == (i + r * j) % EXHAUSTIVE_TEST_ORDER) {\n+                    expected_recid |= secp256k1_fe_is_odd(&r_dot_y_normalized);\n+                } else {\n+                    expected_recid |= !secp256k1_fe_is_odd(&r_dot_y_normalized);\n+                }\n+                CHECK(recid == expected_recid);\n+\n+                /* Convert to a standard sig then check */\n+                secp256k1_ecdsa_recoverable_signature_convert(ctx, &sig, &rsig);\n+                secp256k1_ecdsa_signature_load(ctx, &r, &s, &sig);\n+                /* Note that we compute expected_r *after* signing -- this is important\n+                 * because our nonce-computing function function might change k during\n+                 * signing. */\n+                r_from_k(&expected_r, group, k, NULL);\n+                CHECK(r == expected_r);\n+                CHECK((k * s) % EXHAUSTIVE_TEST_ORDER == (i + r * j) % EXHAUSTIVE_TEST_ORDER ||\n+                      (k * (EXHAUSTIVE_TEST_ORDER - s)) % EXHAUSTIVE_TEST_ORDER == (i + r * j) % EXHAUSTIVE_TEST_ORDER);\n+\n+                /* Overflow means we've tried every possible nonce */\n+                if (k < starting_k) {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+void test_exhaustive_recovery_verify(const secp256k1_context *ctx, const secp256k1_ge *group) {\n+    /* This is essentially a copy of test_exhaustive_verify, with recovery added */\n+    int s, r, msg, key;\n+    uint64_t iter = 0;\n+    for (s = 1; s < EXHAUSTIVE_TEST_ORDER; s++) {\n+        for (r = 1; r < EXHAUSTIVE_TEST_ORDER; r++) {\n+            for (msg = 1; msg < EXHAUSTIVE_TEST_ORDER; msg++) {\n+                for (key = 1; key < EXHAUSTIVE_TEST_ORDER; key++) {\n+                    secp256k1_ge nonconst_ge;\n+                    secp256k1_ecdsa_recoverable_signature rsig;\n+                    secp256k1_ecdsa_signature sig;\n+                    secp256k1_pubkey pk;\n+                    secp256k1_scalar sk_s, msg_s, r_s, s_s;\n+                    secp256k1_scalar s_times_k_s, msg_plus_r_times_sk_s;\n+                    int recid = 0;\n+                    int k, should_verify;\n+                    unsigned char msg32[32];\n+\n+                    if (skip_section(&iter)) continue;\n+\n+                    secp256k1_scalar_set_int(&s_s, s);\n+                    secp256k1_scalar_set_int(&r_s, r);\n+                    secp256k1_scalar_set_int(&msg_s, msg);\n+                    secp256k1_scalar_set_int(&sk_s, key);\n+                    secp256k1_scalar_get_b32(msg32, &msg_s);\n+\n+                    /* Verify by hand */\n+                    /* Run through every k value that gives us this r and check that *one* works.\n+                     * Note there could be none, there could be multiple, ECDSA is weird. */\n+                    should_verify = 0;\n+                    for (k = 0; k < EXHAUSTIVE_TEST_ORDER; k++) {\n+                        secp256k1_scalar check_x_s;\n+                        r_from_k(&check_x_s, group, k, NULL);\n+                        if (r_s == check_x_s) {\n+                            secp256k1_scalar_set_int(&s_times_k_s, k);\n+                            secp256k1_scalar_mul(&s_times_k_s, &s_times_k_s, &s_s);\n+                            secp256k1_scalar_mul(&msg_plus_r_times_sk_s, &r_s, &sk_s);\n+                            secp256k1_scalar_add(&msg_plus_r_times_sk_s, &msg_plus_r_times_sk_s, &msg_s);\n+                            should_verify |= secp256k1_scalar_eq(&s_times_k_s, &msg_plus_r_times_sk_s);\n+                        }\n+                    }\n+                    /* nb we have a \"high s\" rule */\n+                    should_verify &= !secp256k1_scalar_is_high(&s_s);\n+\n+                    /* We would like to try recovering the pubkey and checking that it matches,\n+                     * but pubkey recovery is impossible in the exhaustive tests (the reason\n+                     * being that there are 12 nonzero r values, 12 nonzero points, and no\n+                     * overlap between the sets, so there are no valid signatures). */\n+\n+                    /* Verify by converting to a standard signature and calling verify */\n+                    secp256k1_ecdsa_recoverable_signature_save(&rsig, &r_s, &s_s, recid);\n+                    secp256k1_ecdsa_recoverable_signature_convert(ctx, &sig, &rsig);\n+                    memcpy(&nonconst_ge, &group[sk_s], sizeof(nonconst_ge));\n+                    secp256k1_pubkey_save(&pk, &nonconst_ge);\n+                    CHECK(should_verify ==\n+                          secp256k1_ecdsa_verify(ctx, &sig, msg32, &pk));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+static void test_exhaustive_recovery(const secp256k1_context *ctx, const secp256k1_ge *group) {\n+    test_exhaustive_recovery_sign(ctx, group);\n+    test_exhaustive_recovery_verify(ctx, group);\n+}\n+\n+#endif /* SECP256K1_MODULE_RECOVERY_EXHAUSTIVE_TESTS_H */"
      },
      {
        "sha": "09cae384035ff892d47a7d5c4f9f0c18273daa87",
        "filename": "src/modules/recovery/tests_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/modules/recovery/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/modules/recovery/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/recovery/tests_impl.h?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -25,7 +25,7 @@ static int recovery_test_nonce_function(unsigned char *nonce32, const unsigned c\n     }\n     /* On the next run, return a valid nonce, but flip a coin as to whether or not to fail signing. */\n     memset(nonce32, 1, 32);\n-    return secp256k1_rand_bits(1);\n+    return secp256k1_testrand_bits(1);\n }\n \n void test_ecdsa_recovery_api(void) {\n@@ -184,7 +184,7 @@ void test_ecdsa_recovery_end_to_end(void) {\n     CHECK(secp256k1_ecdsa_sign_recoverable(ctx, &rsignature[3], message, privkey, NULL, extra) == 1);\n     CHECK(secp256k1_ecdsa_recoverable_signature_serialize_compact(ctx, sig, &recid, &rsignature[4]) == 1);\n     CHECK(secp256k1_ecdsa_recoverable_signature_convert(ctx, &signature[4], &rsignature[4]) == 1);\n-    CHECK(memcmp(&signature[4], &signature[0], 64) == 0);\n+    CHECK(secp256k1_memcmp_var(&signature[4], &signature[0], 64) == 0);\n     CHECK(secp256k1_ecdsa_verify(ctx, &signature[4], message, &pubkey) == 1);\n     memset(&rsignature[4], 0, sizeof(rsignature[4]));\n     CHECK(secp256k1_ecdsa_recoverable_signature_parse_compact(ctx, &rsignature[4], sig, recid) == 1);\n@@ -193,16 +193,16 @@ void test_ecdsa_recovery_end_to_end(void) {\n     /* Parse compact (with recovery id) and recover. */\n     CHECK(secp256k1_ecdsa_recoverable_signature_parse_compact(ctx, &rsignature[4], sig, recid) == 1);\n     CHECK(secp256k1_ecdsa_recover(ctx, &recpubkey, &rsignature[4], message) == 1);\n-    CHECK(memcmp(&pubkey, &recpubkey, sizeof(pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, &recpubkey, sizeof(pubkey)) == 0);\n     /* Serialize/destroy/parse signature and verify again. */\n     CHECK(secp256k1_ecdsa_recoverable_signature_serialize_compact(ctx, sig, &recid, &rsignature[4]) == 1);\n-    sig[secp256k1_rand_bits(6)] += 1 + secp256k1_rand_int(255);\n+    sig[secp256k1_testrand_bits(6)] += 1 + secp256k1_testrand_int(255);\n     CHECK(secp256k1_ecdsa_recoverable_signature_parse_compact(ctx, &rsignature[4], sig, recid) == 1);\n     CHECK(secp256k1_ecdsa_recoverable_signature_convert(ctx, &signature[4], &rsignature[4]) == 1);\n     CHECK(secp256k1_ecdsa_verify(ctx, &signature[4], message, &pubkey) == 0);\n     /* Recover again */\n     CHECK(secp256k1_ecdsa_recover(ctx, &recpubkey, &rsignature[4], message) == 0 ||\n-          memcmp(&pubkey, &recpubkey, sizeof(pubkey)) != 0);\n+          secp256k1_memcmp_var(&pubkey, &recpubkey, sizeof(pubkey)) != 0);\n }\n \n /* Tests several edge cases. */"
      },
      {
        "sha": "568bcc35232d54f48a88f31e4d03c8163cf93a8a",
        "filename": "src/modules/schnorrsig/Makefile.am.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/modules/schnorrsig/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/modules/schnorrsig/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorrsig/Makefile.am.include?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -1,6 +1,7 @@\n include_HEADERS += include/secp256k1_schnorrsig.h\n noinst_HEADERS += src/modules/schnorrsig/main_impl.h\n noinst_HEADERS += src/modules/schnorrsig/tests_impl.h\n+noinst_HEADERS += src/modules/schnorrsig/tests_exhaustive_impl.h\n if USE_BENCHMARK\n noinst_PROGRAMS += bench_schnorrsig\n bench_schnorrsig_SOURCES = src/bench_schnorrsig.c"
      },
      {
        "sha": "b0d8481f9be347ace5b712e6b8d4cd1fc1965c0c",
        "filename": "src/modules/schnorrsig/main_impl.h",
        "status": "modified",
        "additions": 20,
        "deletions": 19,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/modules/schnorrsig/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/modules/schnorrsig/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorrsig/main_impl.h?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -68,7 +68,7 @@ static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *ms\n     /* Tag the hash with algo16 which is important to avoid nonce reuse across\n      * algorithms. If this nonce function is used in BIP-340 signing as defined\n      * in the spec, an optimized tagging implementation is used. */\n-    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+    if (secp256k1_memcmp_var(algo16, bip340_algo16, 16) == 0) {\n         secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n     } else {\n         int algo16_len = 16;\n@@ -108,14 +108,29 @@ static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n     sha->bytes = 64;\n }\n \n+static void secp256k1_schnorrsig_challenge(secp256k1_scalar* e, const unsigned char *r32, const unsigned char *msg32, const unsigned char *pubkey32)\n+{\n+    unsigned char buf[32];\n+    secp256k1_sha256 sha;\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, r32, 32);\n+    secp256k1_sha256_write(&sha, pubkey32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    /* Set scalar e to the challenge hash modulo the curve order as per\n+     * BIP340. */\n+    secp256k1_scalar_set_b32(e, buf, NULL);\n+}\n+\n int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n     secp256k1_scalar sk;\n     secp256k1_scalar e;\n     secp256k1_scalar k;\n     secp256k1_gej rj;\n     secp256k1_ge pk;\n     secp256k1_ge r;\n-    secp256k1_sha256 sha;\n     unsigned char buf[32] = { 0 };\n     unsigned char pk_buf[32];\n     unsigned char seckey[32];\n@@ -159,16 +174,7 @@ int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64\n     secp256k1_fe_normalize_var(&r.x);\n     secp256k1_fe_get_b32(&sig64[0], &r.x);\n \n-    /* tagged hash(r.x, pk.x, msg32) */\n-    secp256k1_schnorrsig_sha256_tagged(&sha);\n-    secp256k1_sha256_write(&sha, &sig64[0], 32);\n-    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n-    secp256k1_sha256_write(&sha, msg32, 32);\n-    secp256k1_sha256_finalize(&sha, buf);\n-\n-    /* Set scalar e to the challenge hash modulo the curve order as per\n-     * BIP340. */\n-    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_schnorrsig_challenge(&e, &sig64[0], msg32, pk_buf);\n     secp256k1_scalar_mul(&e, &e, &sk);\n     secp256k1_scalar_add(&e, &e, &k);\n     secp256k1_scalar_get_b32(&sig64[32], &e);\n@@ -189,7 +195,6 @@ int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned cha\n     secp256k1_gej pkj;\n     secp256k1_fe rx;\n     secp256k1_ge r;\n-    secp256k1_sha256 sha;\n     unsigned char buf[32];\n     int overflow;\n \n@@ -212,13 +217,9 @@ int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned cha\n         return 0;\n     }\n \n-    secp256k1_schnorrsig_sha256_tagged(&sha);\n-    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    /* Compute e. */\n     secp256k1_fe_get_b32(buf, &pk.x);\n-    secp256k1_sha256_write(&sha, buf, sizeof(buf));\n-    secp256k1_sha256_write(&sha, msg32, 32);\n-    secp256k1_sha256_finalize(&sha, buf);\n-    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_schnorrsig_challenge(&e, &sig64[0], msg32, buf);\n \n     /* Compute rj =  s*G + (-e)*pkj */\n     secp256k1_scalar_negate(&e, &e);"
      },
      {
        "sha": "4bf0bc1680feeb2366c7cafa10d70870ccdcd601",
        "filename": "src/modules/schnorrsig/tests_exhaustive_impl.h",
        "status": "added",
        "additions": 206,
        "deletions": 0,
        "changes": 206,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/modules/schnorrsig/tests_exhaustive_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/modules/schnorrsig/tests_exhaustive_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorrsig/tests_exhaustive_impl.h?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -0,0 +1,206 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Pieter Wuille                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_TESTS_EXHAUSTIVE_\n+#define _SECP256K1_MODULE_SCHNORRSIG_TESTS_EXHAUSTIVE_\n+\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"src/modules/schnorrsig/main_impl.h\"\n+\n+static const unsigned char invalid_pubkey_bytes[][32] = {\n+    /* 0 */\n+    {\n+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n+    },\n+    /* 2 */\n+    {\n+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2\n+    },\n+    /* order */\n+    {\n+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+        ((EXHAUSTIVE_TEST_ORDER + 0UL) >> 24) & 0xFF,\n+        ((EXHAUSTIVE_TEST_ORDER + 0UL) >> 16) & 0xFF,\n+        ((EXHAUSTIVE_TEST_ORDER + 0UL) >> 8) & 0xFF,\n+        (EXHAUSTIVE_TEST_ORDER + 0UL) & 0xFF\n+    },\n+    /* order + 1 */\n+    {\n+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+        ((EXHAUSTIVE_TEST_ORDER + 1UL) >> 24) & 0xFF,\n+        ((EXHAUSTIVE_TEST_ORDER + 1UL) >> 16) & 0xFF,\n+        ((EXHAUSTIVE_TEST_ORDER + 1UL) >> 8) & 0xFF,\n+        (EXHAUSTIVE_TEST_ORDER + 1UL) & 0xFF\n+    },\n+    /* field size */\n+    {\n+        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFC, 0x2F\n+    },\n+    /* field size + 1 (note that 1 is legal) */\n+    {\n+        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFC, 0x30\n+    },\n+    /* 2^256 - 1 */\n+    {\n+        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\n+    }\n+};\n+\n+#define NUM_INVALID_KEYS (sizeof(invalid_pubkey_bytes) / sizeof(invalid_pubkey_bytes[0]))\n+\n+static int secp256k1_hardened_nonce_function_smallint(unsigned char *nonce32, const unsigned char *msg32,\n+                                                      const unsigned char *key32, const unsigned char *xonly_pk32,\n+                                                      const unsigned char *algo16, void* data) {\n+    secp256k1_scalar s;\n+    int *idata = data;\n+    (void)msg32;\n+    (void)key32;\n+    (void)xonly_pk32;\n+    (void)algo16;\n+    secp256k1_scalar_set_int(&s, *idata);\n+    secp256k1_scalar_get_b32(nonce32, &s);\n+    return 1;\n+}\n+\n+static void test_exhaustive_schnorrsig_verify(const secp256k1_context *ctx, const secp256k1_xonly_pubkey* pubkeys, unsigned char (*xonly_pubkey_bytes)[32], const int* parities) {\n+    int d;\n+    uint64_t iter = 0;\n+    /* Iterate over the possible public keys to verify against (through their corresponding DL d). */\n+    for (d = 1; d <= EXHAUSTIVE_TEST_ORDER / 2; ++d) {\n+        int actual_d;\n+        unsigned k;\n+        unsigned char pk32[32];\n+        memcpy(pk32, xonly_pubkey_bytes[d - 1], 32);\n+        actual_d = parities[d - 1] ? EXHAUSTIVE_TEST_ORDER - d : d;\n+        /* Iterate over the possible valid first 32 bytes in the signature, through their corresponding DL k.\n+           Values above EXHAUSTIVE_TEST_ORDER/2 refer to the entries in invalid_pubkey_bytes. */\n+        for (k = 1; k <= EXHAUSTIVE_TEST_ORDER / 2 + NUM_INVALID_KEYS; ++k) {\n+            unsigned char sig64[64];\n+            int actual_k = -1;\n+            int e_done[EXHAUSTIVE_TEST_ORDER] = {0};\n+            int e_count_done = 0;\n+            if (skip_section(&iter)) continue;\n+            if (k <= EXHAUSTIVE_TEST_ORDER / 2) {\n+                memcpy(sig64, xonly_pubkey_bytes[k - 1], 32);\n+                actual_k = parities[k - 1] ? EXHAUSTIVE_TEST_ORDER - k : k;\n+            } else {\n+                memcpy(sig64, invalid_pubkey_bytes[k - 1 - EXHAUSTIVE_TEST_ORDER / 2], 32);\n+            }\n+            /* Randomly generate messages until all challenges have been hit. */\n+            while (e_count_done < EXHAUSTIVE_TEST_ORDER) {\n+                secp256k1_scalar e;\n+                unsigned char msg32[32];\n+                secp256k1_testrand256(msg32);\n+                secp256k1_schnorrsig_challenge(&e, sig64, msg32, pk32);\n+                /* Only do work if we hit a challenge we haven't tried before. */\n+                if (!e_done[e]) {\n+                    /* Iterate over the possible valid last 32 bytes in the signature.\n+                       0..order=that s value; order+1=random bytes */\n+                    int count_valid = 0, s;\n+                    for (s = 0; s <= EXHAUSTIVE_TEST_ORDER + 1; ++s) {\n+                        int expect_valid, valid;\n+                        if (s <= EXHAUSTIVE_TEST_ORDER) {\n+                            secp256k1_scalar s_s;\n+                            secp256k1_scalar_set_int(&s_s, s);\n+                            secp256k1_scalar_get_b32(sig64 + 32, &s_s);\n+                            expect_valid = actual_k != -1 && s != EXHAUSTIVE_TEST_ORDER &&\n+                                           (s_s == (actual_k + actual_d * e) % EXHAUSTIVE_TEST_ORDER);\n+                        } else {\n+                            secp256k1_testrand256(sig64 + 32);\n+                            expect_valid = 0;\n+                        }\n+                        valid = secp256k1_schnorrsig_verify(ctx, sig64, msg32, &pubkeys[d - 1]);\n+                        CHECK(valid == expect_valid);\n+                        count_valid += valid;\n+                    }\n+                    /* Exactly one s value must verify, unless R is illegal. */\n+                    CHECK(count_valid == (actual_k != -1));\n+                    /* Don't retry other messages that result in the same challenge. */\n+                    e_done[e] = 1;\n+                    ++e_count_done;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+static void test_exhaustive_schnorrsig_sign(const secp256k1_context *ctx, unsigned char (*xonly_pubkey_bytes)[32], const secp256k1_keypair* keypairs, const int* parities) {\n+    int d, k;\n+    uint64_t iter = 0;\n+    /* Loop over keys. */\n+    for (d = 1; d < EXHAUSTIVE_TEST_ORDER; ++d) {\n+        int actual_d = d;\n+        if (parities[d - 1]) actual_d = EXHAUSTIVE_TEST_ORDER - d;\n+        /* Loop over nonces. */\n+        for (k = 1; k < EXHAUSTIVE_TEST_ORDER; ++k) {\n+            int e_done[EXHAUSTIVE_TEST_ORDER] = {0};\n+            int e_count_done = 0;\n+            unsigned char msg32[32];\n+            unsigned char sig64[64];\n+            int actual_k = k;\n+            if (skip_section(&iter)) continue;\n+            if (parities[k - 1]) actual_k = EXHAUSTIVE_TEST_ORDER - k;\n+            /* Generate random messages until all challenges have been tried. */\n+            while (e_count_done < EXHAUSTIVE_TEST_ORDER) {\n+                secp256k1_scalar e;\n+                secp256k1_testrand256(msg32);\n+                secp256k1_schnorrsig_challenge(&e, xonly_pubkey_bytes[k - 1], msg32, xonly_pubkey_bytes[d - 1]);\n+                /* Only do work if we hit a challenge we haven't tried before. */\n+                if (!e_done[e]) {\n+                    secp256k1_scalar expected_s = (actual_k + e * actual_d) % EXHAUSTIVE_TEST_ORDER;\n+                    unsigned char expected_s_bytes[32];\n+                    secp256k1_scalar_get_b32(expected_s_bytes, &expected_s);\n+                    /* Invoke the real function to construct a signature. */\n+                    CHECK(secp256k1_schnorrsig_sign(ctx, sig64, msg32, &keypairs[d - 1], secp256k1_hardened_nonce_function_smallint, &k));\n+                    /* The first 32 bytes must match the xonly pubkey for the specified k. */\n+                    CHECK(secp256k1_memcmp_var(sig64, xonly_pubkey_bytes[k - 1], 32) == 0);\n+                    /* The last 32 bytes must match the expected s value. */\n+                    CHECK(secp256k1_memcmp_var(sig64 + 32, expected_s_bytes, 32) == 0);\n+                    /* Don't retry other messages that result in the same challenge. */\n+                    e_done[e] = 1;\n+                    ++e_count_done;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+static void test_exhaustive_schnorrsig(const secp256k1_context *ctx) {\n+    secp256k1_keypair keypair[EXHAUSTIVE_TEST_ORDER - 1];\n+    secp256k1_xonly_pubkey xonly_pubkey[EXHAUSTIVE_TEST_ORDER - 1];\n+    int parity[EXHAUSTIVE_TEST_ORDER - 1];\n+    unsigned char xonly_pubkey_bytes[EXHAUSTIVE_TEST_ORDER - 1][32];\n+    unsigned i;\n+\n+    /* Verify that all invalid_pubkey_bytes are actually invalid. */\n+    for (i = 0; i < NUM_INVALID_KEYS; ++i) {\n+        secp256k1_xonly_pubkey pk;\n+        CHECK(!secp256k1_xonly_pubkey_parse(ctx, &pk, invalid_pubkey_bytes[i]));\n+    }\n+\n+    /* Construct keypairs and xonly-pubkeys for the entire group. */\n+    for (i = 1; i < EXHAUSTIVE_TEST_ORDER; ++i) {\n+        secp256k1_scalar scalar_i;\n+        unsigned char buf[32];\n+        secp256k1_scalar_set_int(&scalar_i, i);\n+        secp256k1_scalar_get_b32(buf, &scalar_i);\n+        CHECK(secp256k1_keypair_create(ctx, &keypair[i - 1], buf));\n+        CHECK(secp256k1_keypair_xonly_pub(ctx, &xonly_pubkey[i - 1], &parity[i - 1], &keypair[i - 1]));\n+        CHECK(secp256k1_xonly_pubkey_serialize(ctx, xonly_pubkey_bytes[i - 1], &xonly_pubkey[i - 1]));\n+    }\n+\n+    test_exhaustive_schnorrsig_sign(ctx, xonly_pubkey_bytes, keypair, parity);\n+    test_exhaustive_schnorrsig_verify(ctx, xonly_pubkey, xonly_pubkey_bytes, parity);\n+}\n+\n+#endif"
      },
      {
        "sha": "f522fcb3208fffeac16409d11de2a8d3f1da9608",
        "filename": "src/modules/schnorrsig/tests_impl.h",
        "status": "modified",
        "additions": 26,
        "deletions": 26,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/modules/schnorrsig/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/modules/schnorrsig/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorrsig/tests_impl.h?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -15,9 +15,9 @@\n void nonce_function_bip340_bitflip(unsigned char **args, size_t n_flip, size_t n_bytes) {\n     unsigned char nonces[2][32];\n     CHECK(nonce_function_bip340(nonces[0], args[0], args[1], args[2], args[3], args[4]) == 1);\n-    secp256k1_rand_flip(args[n_flip], n_bytes);\n+    secp256k1_testrand_flip(args[n_flip], n_bytes);\n     CHECK(nonce_function_bip340(nonces[1], args[0], args[1], args[2], args[3], args[4]) == 1);\n-    CHECK(memcmp(nonces[0], nonces[1], 32) != 0);\n+    CHECK(secp256k1_memcmp_var(nonces[0], nonces[1], 32) != 0);\n }\n \n /* Tests for the equality of two sha256 structs. This function only produces a\n@@ -28,7 +28,7 @@ void test_sha256_eq(const secp256k1_sha256 *sha1, const secp256k1_sha256 *sha2)\n     CHECK((sha1->bytes & 0x3F) == 0);\n \n     CHECK(sha1->bytes == sha2->bytes);\n-    CHECK(memcmp(sha1->s, sha2->s, sizeof(sha1->s)) == 0);\n+    CHECK(secp256k1_memcmp_var(sha1->s, sha2->s, sizeof(sha1->s)) == 0);\n }\n \n void run_nonce_function_bip340_tests(void) {\n@@ -59,10 +59,10 @@ void run_nonce_function_bip340_tests(void) {\n     secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha_optimized);\n     test_sha256_eq(&sha, &sha_optimized);\n \n-    secp256k1_rand256(msg);\n-    secp256k1_rand256(key);\n-    secp256k1_rand256(pk);\n-    secp256k1_rand256(aux_rand);\n+    secp256k1_testrand256(msg);\n+    secp256k1_testrand256(key);\n+    secp256k1_testrand256(pk);\n+    secp256k1_testrand256(aux_rand);\n \n     /* Check that a bitflip in an argument results in different nonces. */\n     args[0] = msg;\n@@ -124,10 +124,10 @@ void test_schnorrsig_api(void) {\n     secp256k1_context_set_illegal_callback(vrfy, counting_illegal_callback_fn, &ecount);\n     secp256k1_context_set_illegal_callback(both, counting_illegal_callback_fn, &ecount);\n \n-    secp256k1_rand256(sk1);\n-    secp256k1_rand256(sk2);\n-    secp256k1_rand256(sk3);\n-    secp256k1_rand256(msg);\n+    secp256k1_testrand256(sk1);\n+    secp256k1_testrand256(sk2);\n+    secp256k1_testrand256(sk3);\n+    secp256k1_testrand256(msg);\n     CHECK(secp256k1_keypair_create(ctx, &keypairs[0], sk1) == 1);\n     CHECK(secp256k1_keypair_create(ctx, &keypairs[1], sk2) == 1);\n     CHECK(secp256k1_keypair_create(ctx, &keypairs[2], sk3) == 1);\n@@ -197,11 +197,11 @@ void test_schnorrsig_bip_vectors_check_signing(const unsigned char *sk, const un\n \n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk));\n     CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL, aux_rand));\n-    CHECK(memcmp(sig, expected_sig, 64) == 0);\n+    CHECK(secp256k1_memcmp_var(sig, expected_sig, 64) == 0);\n \n     CHECK(secp256k1_xonly_pubkey_parse(ctx, &pk_expected, pk_serialized));\n     CHECK(secp256k1_keypair_xonly_pub(ctx, &pk, NULL, &keypair));\n-    CHECK(memcmp(&pk, &pk_expected, sizeof(pk)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pk, &pk_expected, sizeof(pk)) == 0);\n     CHECK(secp256k1_schnorrsig_verify(ctx, sig, msg, &pk));\n }\n \n@@ -675,19 +675,19 @@ void test_schnorrsig_sign(void) {\n     unsigned char sig[64];\n     unsigned char zeros64[64] = { 0 };\n \n-    secp256k1_rand256(sk);\n+    secp256k1_testrand256(sk);\n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk));\n     CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL, NULL) == 1);\n \n     /* Test different nonce functions */\n     memset(sig, 1, sizeof(sig));\n     CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, nonce_function_failing, NULL) == 0);\n-    CHECK(memcmp(sig, zeros64, sizeof(sig)) == 0);\n+    CHECK(secp256k1_memcmp_var(sig, zeros64, sizeof(sig)) == 0);\n     memset(&sig, 1, sizeof(sig));\n     CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, nonce_function_0, NULL) == 0);\n-    CHECK(memcmp(sig, zeros64, sizeof(sig)) == 0);\n+    CHECK(secp256k1_memcmp_var(sig, zeros64, sizeof(sig)) == 0);\n     CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, nonce_function_overflowing, NULL) == 1);\n-    CHECK(memcmp(sig, zeros64, sizeof(sig)) != 0);\n+    CHECK(secp256k1_memcmp_var(sig, zeros64, sizeof(sig)) != 0);\n }\n \n #define N_SIGS 3\n@@ -703,32 +703,32 @@ void test_schnorrsig_sign_verify(void) {\n     secp256k1_xonly_pubkey pk;\n     secp256k1_scalar s;\n \n-    secp256k1_rand256(sk);\n+    secp256k1_testrand256(sk);\n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk));\n     CHECK(secp256k1_keypair_xonly_pub(ctx, &pk, NULL, &keypair));\n \n     for (i = 0; i < N_SIGS; i++) {\n-        secp256k1_rand256(msg[i]);\n+        secp256k1_testrand256(msg[i]);\n         CHECK(secp256k1_schnorrsig_sign(ctx, sig[i], msg[i], &keypair, NULL, NULL));\n         CHECK(secp256k1_schnorrsig_verify(ctx, sig[i], msg[i], &pk));\n     }\n \n     {\n         /* Flip a few bits in the signature and in the message and check that\n          * verify and verify_batch (TODO) fail */\n-        size_t sig_idx = secp256k1_rand_int(N_SIGS);\n-        size_t byte_idx = secp256k1_rand_int(32);\n-        unsigned char xorbyte = secp256k1_rand_int(254)+1;\n+        size_t sig_idx = secp256k1_testrand_int(N_SIGS);\n+        size_t byte_idx = secp256k1_testrand_int(32);\n+        unsigned char xorbyte = secp256k1_testrand_int(254)+1;\n         sig[sig_idx][byte_idx] ^= xorbyte;\n         CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], &pk));\n         sig[sig_idx][byte_idx] ^= xorbyte;\n \n-        byte_idx = secp256k1_rand_int(32);\n+        byte_idx = secp256k1_testrand_int(32);\n         sig[sig_idx][32+byte_idx] ^= xorbyte;\n         CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], &pk));\n         sig[sig_idx][32+byte_idx] ^= xorbyte;\n \n-        byte_idx = secp256k1_rand_int(32);\n+        byte_idx = secp256k1_testrand_int(32);\n         msg[sig_idx][byte_idx] ^= xorbyte;\n         CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], &pk));\n         msg[sig_idx][byte_idx] ^= xorbyte;\n@@ -766,7 +766,7 @@ void test_schnorrsig_taproot(void) {\n     unsigned char sig[64];\n \n     /* Create output key */\n-    secp256k1_rand256(sk);\n+    secp256k1_testrand256(sk);\n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n     CHECK(secp256k1_keypair_xonly_pub(ctx, &internal_pk, NULL, &keypair) == 1);\n     /* In actual taproot the tweak would be hash of internal_pk */\n@@ -776,7 +776,7 @@ void test_schnorrsig_taproot(void) {\n     CHECK(secp256k1_xonly_pubkey_serialize(ctx, output_pk_bytes, &output_pk) == 1);\n \n     /* Key spend */\n-    secp256k1_rand256(msg);\n+    secp256k1_testrand256(msg);\n     CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL, NULL) == 1);\n     /* Verify key spend */\n     CHECK(secp256k1_xonly_pubkey_parse(ctx, &output_pk, output_pk_bytes) == 1);"
      },
      {
        "sha": "fb3fb187cec3fe7af90a6862f61f30b7541fce26",
        "filename": "src/scalar.h",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/scalar.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/scalar.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar.h?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -102,12 +102,11 @@ static void secp256k1_scalar_order_get_num(secp256k1_num *r);\n /** Compare two scalars. */\n static int secp256k1_scalar_eq(const secp256k1_scalar *a, const secp256k1_scalar *b);\n \n-#ifdef USE_ENDOMORPHISM\n-/** Find r1 and r2 such that r1+r2*2^128 = a. */\n-static void secp256k1_scalar_split_128(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *a);\n-/** Find r1 and r2 such that r1+r2*lambda = a, and r1 and r2 are maximum 128 bits long (see secp256k1_gej_mul_lambda). */\n-static void secp256k1_scalar_split_lambda(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *a);\n-#endif\n+/** Find r1 and r2 such that r1+r2*2^128 = k. */\n+static void secp256k1_scalar_split_128(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *k);\n+/** Find r1 and r2 such that r1+r2*lambda = k,\n+ * where r1 and r2 or their negations are maximum 128 bits long (see secp256k1_ge_mul_lambda). */\n+static void secp256k1_scalar_split_lambda(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *k);\n \n /** Multiply a and b (without taking the modulus!), divide by 2**shift, and round to the nearest integer. Shift must be at least 256. */\n static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r, const secp256k1_scalar *a, const secp256k1_scalar *b, unsigned int shift);"
      },
      {
        "sha": "73cbd5e18a4d6a69a9ba672f23210689d1532422",
        "filename": "src/scalar_4x64_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 7,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/scalar_4x64_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/scalar_4x64_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_4x64_impl.h?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -912,18 +912,16 @@ static void secp256k1_scalar_sqr(secp256k1_scalar *r, const secp256k1_scalar *a)\n     secp256k1_scalar_reduce_512(r, l);\n }\n \n-#ifdef USE_ENDOMORPHISM\n-static void secp256k1_scalar_split_128(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *a) {\n-    r1->d[0] = a->d[0];\n-    r1->d[1] = a->d[1];\n+static void secp256k1_scalar_split_128(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *k) {\n+    r1->d[0] = k->d[0];\n+    r1->d[1] = k->d[1];\n     r1->d[2] = 0;\n     r1->d[3] = 0;\n-    r2->d[0] = a->d[2];\n-    r2->d[1] = a->d[3];\n+    r2->d[0] = k->d[2];\n+    r2->d[1] = k->d[3];\n     r2->d[2] = 0;\n     r2->d[3] = 0;\n }\n-#endif\n \n SECP256K1_INLINE static int secp256k1_scalar_eq(const secp256k1_scalar *a, const secp256k1_scalar *b) {\n     return ((a->d[0] ^ b->d[0]) | (a->d[1] ^ b->d[1]) | (a->d[2] ^ b->d[2]) | (a->d[3] ^ b->d[3])) == 0;"
      },
      {
        "sha": "6853f79eccbe173bef6487e95a580a873aaf10f9",
        "filename": "src/scalar_8x32_impl.h",
        "status": "modified",
        "additions": 9,
        "deletions": 11,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/scalar_8x32_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/scalar_8x32_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_8x32_impl.h?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -672,26 +672,24 @@ static void secp256k1_scalar_sqr(secp256k1_scalar *r, const secp256k1_scalar *a)\n     secp256k1_scalar_reduce_512(r, l);\n }\n \n-#ifdef USE_ENDOMORPHISM\n-static void secp256k1_scalar_split_128(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *a) {\n-    r1->d[0] = a->d[0];\n-    r1->d[1] = a->d[1];\n-    r1->d[2] = a->d[2];\n-    r1->d[3] = a->d[3];\n+static void secp256k1_scalar_split_128(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *k) {\n+    r1->d[0] = k->d[0];\n+    r1->d[1] = k->d[1];\n+    r1->d[2] = k->d[2];\n+    r1->d[3] = k->d[3];\n     r1->d[4] = 0;\n     r1->d[5] = 0;\n     r1->d[6] = 0;\n     r1->d[7] = 0;\n-    r2->d[0] = a->d[4];\n-    r2->d[1] = a->d[5];\n-    r2->d[2] = a->d[6];\n-    r2->d[3] = a->d[7];\n+    r2->d[0] = k->d[4];\n+    r2->d[1] = k->d[5];\n+    r2->d[2] = k->d[6];\n+    r2->d[3] = k->d[7];\n     r2->d[4] = 0;\n     r2->d[5] = 0;\n     r2->d[6] = 0;\n     r2->d[7] = 0;\n }\n-#endif\n \n SECP256K1_INLINE static int secp256k1_scalar_eq(const secp256k1_scalar *a, const secp256k1_scalar *b) {\n     return ((a->d[0] ^ b->d[0]) | (a->d[1] ^ b->d[1]) | (a->d[2] ^ b->d[2]) | (a->d[3] ^ b->d[3]) | (a->d[4] ^ b->d[4]) | (a->d[5] ^ b->d[5]) | (a->d[6] ^ b->d[6]) | (a->d[7] ^ b->d[7])) == 0;"
      },
      {
        "sha": "fc758918180b660008d5829addfe8b84bae3be24",
        "filename": "src/scalar_impl.h",
        "status": "modified",
        "additions": 212,
        "deletions": 38,
        "changes": 250,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_impl.h?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -7,6 +7,10 @@\n #ifndef SECP256K1_SCALAR_IMPL_H\n #define SECP256K1_SCALAR_IMPL_H\n \n+#ifdef VERIFY\n+#include <string.h>\n+#endif\n+\n #include \"scalar.h\"\n #include \"util.h\"\n \n@@ -252,37 +256,65 @@ static void secp256k1_scalar_inverse_var(secp256k1_scalar *r, const secp256k1_sc\n #endif\n }\n \n-#ifdef USE_ENDOMORPHISM\n+/* These parameters are generated using sage/gen_exhaustive_groups.sage. */\n #if defined(EXHAUSTIVE_TEST_ORDER)\n+#  if EXHAUSTIVE_TEST_ORDER == 13\n+#    define EXHAUSTIVE_TEST_LAMBDA 9\n+#  elif EXHAUSTIVE_TEST_ORDER == 199\n+#    define EXHAUSTIVE_TEST_LAMBDA 92\n+#  else\n+#    error No known lambda for the specified exhaustive test group order.\n+#  endif\n+\n /**\n- * Find k1 and k2 given k, such that k1 + k2 * lambda == k mod n; unlike in the\n- * full case we don't bother making k1 and k2 be small, we just want them to be\n+ * Find r1 and r2 given k, such that r1 + r2 * lambda == k mod n; unlike in the\n+ * full case we don't bother making r1 and r2 be small, we just want them to be\n  * nontrivial to get full test coverage for the exhaustive tests. We therefore\n- * (arbitrarily) set k2 = k + 5 and k1 = k - k2 * lambda.\n+ * (arbitrarily) set r2 = k + 5 (mod n) and r1 = k - r2 * lambda (mod n).\n  */\n-static void secp256k1_scalar_split_lambda(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *a) {\n-    *r2 = (*a + 5) % EXHAUSTIVE_TEST_ORDER;\n-    *r1 = (*a + (EXHAUSTIVE_TEST_ORDER - *r2) * EXHAUSTIVE_TEST_LAMBDA) % EXHAUSTIVE_TEST_ORDER;\n+static void secp256k1_scalar_split_lambda(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *k) {\n+    *r2 = (*k + 5) % EXHAUSTIVE_TEST_ORDER;\n+    *r1 = (*k + (EXHAUSTIVE_TEST_ORDER - *r2) * EXHAUSTIVE_TEST_LAMBDA) % EXHAUSTIVE_TEST_ORDER;\n }\n #else\n /**\n  * The Secp256k1 curve has an endomorphism, where lambda * (x, y) = (beta * x, y), where\n- * lambda is {0x53,0x63,0xad,0x4c,0xc0,0x5c,0x30,0xe0,0xa5,0x26,0x1c,0x02,0x88,0x12,0x64,0x5a,\n- *            0x12,0x2e,0x22,0xea,0x20,0x81,0x66,0x78,0xdf,0x02,0x96,0x7c,0x1b,0x23,0xbd,0x72}\n+ * lambda is: */\n+static const secp256k1_scalar secp256k1_const_lambda = SECP256K1_SCALAR_CONST(\n+    0x5363AD4CUL, 0xC05C30E0UL, 0xA5261C02UL, 0x8812645AUL,\n+    0x122E22EAUL, 0x20816678UL, 0xDF02967CUL, 0x1B23BD72UL\n+);\n+\n+#ifdef VERIFY\n+static void secp256k1_scalar_split_lambda_verify(const secp256k1_scalar *r1, const secp256k1_scalar *r2, const secp256k1_scalar *k);\n+#endif\n+\n+/*\n+ * Both lambda and beta are primitive cube roots of unity.  That is lamba^3 == 1 mod n and\n+ * beta^3 == 1 mod p, where n is the curve order and p is the field order.\n  *\n- * \"Guide to Elliptic Curve Cryptography\" (Hankerson, Menezes, Vanstone) gives an algorithm\n- * (algorithm 3.74) to find k1 and k2 given k, such that k1 + k2 * lambda == k mod n, and k1\n- * and k2 have a small size.\n- * It relies on constants a1, b1, a2, b2. These constants for the value of lambda above are:\n+ * Futhermore, because (X^3 - 1) = (X - 1)(X^2 + X + 1), the primitive cube roots of unity are\n+ * roots of X^2 + X + 1.  Therefore lambda^2 + lamba == -1 mod n and beta^2 + beta == -1 mod p.\n+ * (The other primitive cube roots of unity are lambda^2 and beta^2 respectively.)\n+ *\n+ * Let l = -1/2 + i*sqrt(3)/2, the complex root of X^2 + X + 1. We can define a ring\n+ * homomorphism phi : Z[l] -> Z_n where phi(a + b*l) == a + b*lambda mod n. The kernel of phi\n+ * is a lattice over Z[l] (considering Z[l] as a Z-module). This lattice is generated by a\n+ * reduced basis {a1 + b1*l, a2 + b2*l} where\n  *\n  * - a1 =      {0x30,0x86,0xd2,0x21,0xa7,0xd4,0x6b,0xcd,0xe8,0x6c,0x90,0xe4,0x92,0x84,0xeb,0x15}\n  * - b1 =     -{0xe4,0x43,0x7e,0xd6,0x01,0x0e,0x88,0x28,0x6f,0x54,0x7f,0xa9,0x0a,0xbf,0xe4,0xc3}\n  * - a2 = {0x01,0x14,0xca,0x50,0xf7,0xa8,0xe2,0xf3,0xf6,0x57,0xc1,0x10,0x8d,0x9d,0x44,0xcf,0xd8}\n  * - b2 =      {0x30,0x86,0xd2,0x21,0xa7,0xd4,0x6b,0xcd,0xe8,0x6c,0x90,0xe4,0x92,0x84,0xeb,0x15}\n  *\n- * The algorithm then computes c1 = round(b1 * k / n) and c2 = round(b2 * k / n), and gives\n+ * \"Guide to Elliptic Curve Cryptography\" (Hankerson, Menezes, Vanstone) gives an algorithm\n+ * (algorithm 3.74) to find k1 and k2 given k, such that k1 + k2 * lambda == k mod n, and k1\n+ * and k2 are small in absolute value.\n+ *\n+ * The algorithm computes c1 = round(b2 * k / n) and c2 = round((-b1) * k / n), and gives\n  * k1 = k - (c1*a1 + c2*a2) and k2 = -(c1*b1 + c2*b2). Instead, we use modular arithmetic, and\n- * compute k1 as k - k2 * lambda, avoiding the need for constants a1 and a2.\n+ * compute r2 = k2 mod n, and r1 = k1 mod n = (k - r2 * lambda) mod n, avoiding the need for\n+ * the constants a1 and a2.\n  *\n  * g1, g2 are precomputed constants used to replace division with a rounded multiplication\n  * when decomposing the scalar for an endomorphism-based point multiplication.\n@@ -294,21 +326,21 @@ static void secp256k1_scalar_split_lambda(secp256k1_scalar *r1, secp256k1_scalar\n  * Cryptography on Sensor Networks Using the MSP430X Microcontroller\" (Gouvea, Oliveira, Lopez),\n  * Section 4.3 (here we use a somewhat higher-precision estimate):\n  * d = a1*b2 - b1*a2\n- * g1 = round((2^272)*b2/d)\n- * g2 = round((2^272)*b1/d)\n+ * g1 = round(2^384 * b2/d)\n+ * g2 = round(2^384 * (-b1)/d)\n  *\n- * (Note that 'd' is also equal to the curve order here because [a1,b1] and [a2,b2] are found\n- * as outputs of the Extended Euclidean Algorithm on inputs 'order' and 'lambda').\n+ * (Note that d is also equal to the curve order, n, here because [a1,b1] and [a2,b2]\n+ * can be found as outputs of the Extended Euclidean Algorithm on inputs n and lambda).\n  *\n- * The function below splits a in r1 and r2, such that r1 + lambda * r2 == a (mod order).\n+ * The function below splits k into r1 and r2, such that\n+ * - r1 + lambda * r2 == k (mod n)\n+ * - either r1 < 2^128 or -r1 mod n < 2^128\n+ * - either r2 < 2^128 or -r2 mod n < 2^128\n+ *\n+ * See proof below.\n  */\n-\n-static void secp256k1_scalar_split_lambda(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *a) {\n+static void secp256k1_scalar_split_lambda(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *k) {\n     secp256k1_scalar c1, c2;\n-    static const secp256k1_scalar minus_lambda = SECP256K1_SCALAR_CONST(\n-        0xAC9C52B3UL, 0x3FA3CF1FUL, 0x5AD9E3FDUL, 0x77ED9BA4UL,\n-        0xA880B9FCUL, 0x8EC739C2UL, 0xE0CFC810UL, 0xB51283CFUL\n-    );\n     static const secp256k1_scalar minus_b1 = SECP256K1_SCALAR_CONST(\n         0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n         0xE4437ED6UL, 0x010E8828UL, 0x6F547FA9UL, 0x0ABFE4C3UL\n@@ -318,25 +350,167 @@ static void secp256k1_scalar_split_lambda(secp256k1_scalar *r1, secp256k1_scalar\n         0x8A280AC5UL, 0x0774346DUL, 0xD765CDA8UL, 0x3DB1562CUL\n     );\n     static const secp256k1_scalar g1 = SECP256K1_SCALAR_CONST(\n-        0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00003086UL,\n-        0xD221A7D4UL, 0x6BCDE86CUL, 0x90E49284UL, 0xEB153DABUL\n+        0x3086D221UL, 0xA7D46BCDUL, 0xE86C90E4UL, 0x9284EB15UL,\n+        0x3DAA8A14UL, 0x71E8CA7FUL, 0xE893209AUL, 0x45DBB031UL\n     );\n     static const secp256k1_scalar g2 = SECP256K1_SCALAR_CONST(\n-        0x00000000UL, 0x00000000UL, 0x00000000UL, 0x0000E443UL,\n-        0x7ED6010EUL, 0x88286F54UL, 0x7FA90ABFUL, 0xE4C42212UL\n+        0xE4437ED6UL, 0x010E8828UL, 0x6F547FA9UL, 0x0ABFE4C4UL,\n+        0x221208ACUL, 0x9DF506C6UL, 0x1571B4AEUL, 0x8AC47F71UL\n     );\n-    VERIFY_CHECK(r1 != a);\n-    VERIFY_CHECK(r2 != a);\n+    VERIFY_CHECK(r1 != k);\n+    VERIFY_CHECK(r2 != k);\n     /* these _var calls are constant time since the shift amount is constant */\n-    secp256k1_scalar_mul_shift_var(&c1, a, &g1, 272);\n-    secp256k1_scalar_mul_shift_var(&c2, a, &g2, 272);\n+    secp256k1_scalar_mul_shift_var(&c1, k, &g1, 384);\n+    secp256k1_scalar_mul_shift_var(&c2, k, &g2, 384);\n     secp256k1_scalar_mul(&c1, &c1, &minus_b1);\n     secp256k1_scalar_mul(&c2, &c2, &minus_b2);\n     secp256k1_scalar_add(r2, &c1, &c2);\n-    secp256k1_scalar_mul(r1, r2, &minus_lambda);\n-    secp256k1_scalar_add(r1, r1, a);\n-}\n-#endif\n+    secp256k1_scalar_mul(r1, r2, &secp256k1_const_lambda);\n+    secp256k1_scalar_negate(r1, r1);\n+    secp256k1_scalar_add(r1, r1, k);\n+\n+#ifdef VERIFY\n+    secp256k1_scalar_split_lambda_verify(r1, r2, k);\n #endif\n+}\n+\n+#ifdef VERIFY\n+/*\n+ * Proof for secp256k1_scalar_split_lambda's bounds.\n+ *\n+ * Let\n+ *  - epsilon1 = 2^256 * |g1/2^384 - b2/d|\n+ *  - epsilon2 = 2^256 * |g2/2^384 - (-b1)/d|\n+ *  - c1 = round(k*g1/2^384)\n+ *  - c2 = round(k*g2/2^384)\n+ *\n+ * Lemma 1: |c1 - k*b2/d| < 2^-1 + epsilon1\n+ *\n+ *    |c1 - k*b2/d|\n+ *  =\n+ *    |c1 - k*g1/2^384 + k*g1/2^384 - k*b2/d|\n+ * <=   {triangle inequality}\n+ *    |c1 - k*g1/2^384| + |k*g1/2^384 - k*b2/d|\n+ *  =\n+ *    |c1 - k*g1/2^384| + k*|g1/2^384 - b2/d|\n+ * <    {rounding in c1 and 0 <= k < 2^256}\n+ *    2^-1 + 2^256 * |g1/2^384 - b2/d|\n+ *  =   {definition of epsilon1}\n+ *    2^-1 + epsilon1\n+ *\n+ * Lemma 2: |c2 - k*(-b1)/d| < 2^-1 + epsilon2\n+ *\n+ *    |c2 - k*(-b1)/d|\n+ *  =\n+ *    |c2 - k*g2/2^384 + k*g2/2^384 - k*(-b1)/d|\n+ * <=   {triangle inequality}\n+ *    |c2 - k*g2/2^384| + |k*g2/2^384 - k*(-b1)/d|\n+ *  =\n+ *    |c2 - k*g2/2^384| + k*|g2/2^384 - (-b1)/d|\n+ * <    {rounding in c2 and 0 <= k < 2^256}\n+ *    2^-1 + 2^256 * |g2/2^384 - (-b1)/d|\n+ *  =   {definition of epsilon2}\n+ *    2^-1 + epsilon2\n+ *\n+ * Let\n+ *  - k1 = k - c1*a1 - c2*a2\n+ *  - k2 = - c1*b1 - c2*b2\n+ *\n+ * Lemma 3: |k1| < (a1 + a2 + 1)/2 < 2^128\n+ *\n+ *    |k1|\n+ *  =   {definition of k1}\n+ *    |k - c1*a1 - c2*a2|\n+ *  =   {(a1*b2 - b1*a2)/n = 1}\n+ *    |k*(a1*b2 - b1*a2)/n - c1*a1 - c2*a2|\n+ *  =\n+ *    |a1*(k*b2/n - c1) + a2*(k*(-b1)/n - c2)|\n+ * <=   {triangle inequality}\n+ *    a1*|k*b2/n - c1| + a2*|k*(-b1)/n - c2|\n+ * <    {Lemma 1 and Lemma 2}\n+ *    a1*(2^-1 + epslion1) + a2*(2^-1 + epsilon2)\n+ * <    {rounding up to an integer}\n+ *    (a1 + a2 + 1)/2\n+ * <    {rounding up to a power of 2}\n+ *    2^128\n+ *\n+ * Lemma 4: |k2| < (-b1 + b2)/2 + 1 < 2^128\n+ *\n+ *    |k2|\n+ *  =   {definition of k2}\n+ *    |- c1*a1 - c2*a2|\n+ *  =   {(b1*b2 - b1*b2)/n = 0}\n+ *    |k*(b1*b2 - b1*b2)/n - c1*b1 - c2*b2|\n+ *  =\n+ *    |b1*(k*b2/n - c1) + b2*(k*(-b1)/n - c2)|\n+ * <=   {triangle inequality}\n+ *    (-b1)*|k*b2/n - c1| + b2*|k*(-b1)/n - c2|\n+ * <    {Lemma 1 and Lemma 2}\n+ *    (-b1)*(2^-1 + epslion1) + b2*(2^-1 + epsilon2)\n+ * <    {rounding up to an integer}\n+ *    (-b1 + b2)/2 + 1\n+ * <    {rounding up to a power of 2}\n+ *    2^128\n+ *\n+ * Let\n+ *  - r2 = k2 mod n\n+ *  - r1 = k - r2*lambda mod n.\n+ *\n+ * Notice that r1 is defined such that r1 + r2 * lambda == k (mod n).\n+ *\n+ * Lemma 5: r1 == k1 mod n.\n+ *\n+ *    r1\n+ * ==   {definition of r1 and r2}\n+ *    k - k2*lambda\n+ * ==   {definition of k2}\n+ *    k - (- c1*b1 - c2*b2)*lambda\n+ * ==\n+ *    k + c1*b1*lambda + c2*b2*lambda\n+ * ==  {a1 + b1*lambda == 0 mod n and a2 + b2*lambda == 0 mod n}\n+ *    k - c1*a1 - c2*a2\n+ * ==  {definition of k1}\n+ *    k1\n+ *\n+ * From Lemma 3, Lemma 4, Lemma 5 and the definition of r2, we can conclude that\n+ *\n+ *  - either r1 < 2^128 or -r1 mod n < 2^128\n+ *  - either r2 < 2^128 or -r2 mod n < 2^128.\n+ *\n+ * Q.E.D.\n+ */\n+static void secp256k1_scalar_split_lambda_verify(const secp256k1_scalar *r1, const secp256k1_scalar *r2, const secp256k1_scalar *k) {\n+    secp256k1_scalar s;\n+    unsigned char buf1[32];\n+    unsigned char buf2[32];\n+\n+    /* (a1 + a2 + 1)/2 is 0xa2a8918ca85bafe22016d0b917e4dd77 */\n+    static const unsigned char k1_bound[32] = {\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0xa2, 0xa8, 0x91, 0x8c, 0xa8, 0x5b, 0xaf, 0xe2, 0x20, 0x16, 0xd0, 0xb9, 0x17, 0xe4, 0xdd, 0x77\n+    };\n+\n+    /* (-b1 + b2)/2 + 1 is 0x8a65287bd47179fb2be08846cea267ed */\n+    static const unsigned char k2_bound[32] = {\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0x8a, 0x65, 0x28, 0x7b, 0xd4, 0x71, 0x79, 0xfb, 0x2b, 0xe0, 0x88, 0x46, 0xce, 0xa2, 0x67, 0xed\n+    };\n+\n+    secp256k1_scalar_mul(&s, &secp256k1_const_lambda, r2);\n+    secp256k1_scalar_add(&s, &s, r1);\n+    VERIFY_CHECK(secp256k1_scalar_eq(&s, k));\n+\n+    secp256k1_scalar_negate(&s, r1);\n+    secp256k1_scalar_get_b32(buf1, r1);\n+    secp256k1_scalar_get_b32(buf2, &s);\n+    VERIFY_CHECK(secp256k1_memcmp_var(buf1, k1_bound, 32) < 0 || secp256k1_memcmp_var(buf2, k1_bound, 32) < 0);\n+\n+    secp256k1_scalar_negate(&s, r2);\n+    secp256k1_scalar_get_b32(buf1, r2);\n+    secp256k1_scalar_get_b32(buf2, &s);\n+    VERIFY_CHECK(secp256k1_memcmp_var(buf1, k2_bound, 32) < 0 || secp256k1_memcmp_var(buf2, k2_bound, 32) < 0);\n+}\n+#endif /* VERIFY */\n+#endif /* !defined(EXHAUSTIVE_TEST_ORDER) */\n \n #endif /* SECP256K1_SCALAR_IMPL_H */"
      },
      {
        "sha": "a615ec074b2b45fa1d0d4fb08e918c1f6e91e929",
        "filename": "src/scalar_low_impl.h",
        "status": "modified",
        "additions": 7,
        "deletions": 4,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/scalar_low_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/scalar_low_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_low_impl.h?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -48,14 +48,17 @@ static void secp256k1_scalar_cadd_bit(secp256k1_scalar *r, unsigned int bit, int\n }\n \n static void secp256k1_scalar_set_b32(secp256k1_scalar *r, const unsigned char *b32, int *overflow) {\n-    const int base = 0x100 % EXHAUSTIVE_TEST_ORDER;\n     int i;\n+    int over = 0;\n     *r = 0;\n     for (i = 0; i < 32; i++) {\n-       *r = ((*r * base) + b32[i]) % EXHAUSTIVE_TEST_ORDER;\n+        *r = (*r * 0x100) + b32[i];\n+        if (*r >= EXHAUSTIVE_TEST_ORDER) {\n+            over = 1;\n+            *r %= EXHAUSTIVE_TEST_ORDER;\n+        }\n     }\n-    /* just deny overflow, it basically always happens */\n-    if (overflow) *overflow = 0;\n+    if (overflow) *overflow = over;\n }\n \n static void secp256k1_scalar_get_b32(unsigned char *bin, const secp256k1_scalar* a) {"
      },
      {
        "sha": "f381e2e3227441a8f71c4c7e183ee7c4f4137986",
        "filename": "src/scratch_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/scratch_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/scratch_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scratch_impl.h?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -26,7 +26,7 @@ static secp256k1_scratch* secp256k1_scratch_create(const secp256k1_callback* err\n static void secp256k1_scratch_destroy(const secp256k1_callback* error_callback, secp256k1_scratch* scratch) {\n     if (scratch != NULL) {\n         VERIFY_CHECK(scratch->alloc_size == 0); /* all checkpoints should be applied */\n-        if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+        if (secp256k1_memcmp_var(scratch->magic, \"scratch\", 8) != 0) {\n             secp256k1_callback_call(error_callback, \"invalid scratch space\");\n             return;\n         }\n@@ -36,15 +36,15 @@ static void secp256k1_scratch_destroy(const secp256k1_callback* error_callback,\n }\n \n static size_t secp256k1_scratch_checkpoint(const secp256k1_callback* error_callback, const secp256k1_scratch* scratch) {\n-    if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+    if (secp256k1_memcmp_var(scratch->magic, \"scratch\", 8) != 0) {\n         secp256k1_callback_call(error_callback, \"invalid scratch space\");\n         return 0;\n     }\n     return scratch->alloc_size;\n }\n \n static void secp256k1_scratch_apply_checkpoint(const secp256k1_callback* error_callback, secp256k1_scratch* scratch, size_t checkpoint) {\n-    if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+    if (secp256k1_memcmp_var(scratch->magic, \"scratch\", 8) != 0) {\n         secp256k1_callback_call(error_callback, \"invalid scratch space\");\n         return;\n     }\n@@ -56,7 +56,7 @@ static void secp256k1_scratch_apply_checkpoint(const secp256k1_callback* error_c\n }\n \n static size_t secp256k1_scratch_max_allocation(const secp256k1_callback* error_callback, const secp256k1_scratch* scratch, size_t objects) {\n-    if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+    if (secp256k1_memcmp_var(scratch->magic, \"scratch\", 8) != 0) {\n         secp256k1_callback_call(error_callback, \"invalid scratch space\");\n         return 0;\n     }\n@@ -81,7 +81,7 @@ static void *secp256k1_scratch_alloc(const secp256k1_callback* error_callback, s\n     }\n     size = rounded_size;\n \n-    if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+    if (secp256k1_memcmp_var(scratch->magic, \"scratch\", 8) != 0) {\n         secp256k1_callback_call(error_callback, \"invalid scratch space\");\n         return NULL;\n     }"
      },
      {
        "sha": "dae506d08c946ee00cef7c3b56a7a84617322663",
        "filename": "src/secp256k1.c",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1.c?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -284,6 +284,9 @@ int secp256k1_ec_pubkey_parse(const secp256k1_context* ctx, secp256k1_pubkey* pu\n     if (!secp256k1_eckey_pubkey_parse(&Q, input, inputlen)) {\n         return 0;\n     }\n+    if (!secp256k1_ge_is_in_correct_subgroup(&Q)) {\n+        return 0;\n+    }\n     secp256k1_pubkey_save(pubkey, &Q);\n     secp256k1_ge_clear(&Q);\n     return 1;"
      },
      {
        "sha": "0e37510c1e95a1d62d61d25dadf15ee5dd06021e",
        "filename": "src/selftest.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/selftest.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/selftest.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/selftest.h?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -22,7 +22,7 @@ static int secp256k1_selftest_sha256(void) {\n     secp256k1_sha256_initialize(&hasher);\n     secp256k1_sha256_write(&hasher, (const unsigned char*)input63, 63);\n     secp256k1_sha256_finalize(&hasher, out);\n-    return memcmp(out, output32, 32) == 0;\n+    return secp256k1_memcmp_var(out, output32, 32) == 0;\n }\n \n static int secp256k1_selftest(void) {"
      },
      {
        "sha": "a76003d5b8e17a0bcda3a55eb4a727d878067304",
        "filename": "src/testrand.h",
        "status": "modified",
        "additions": 14,
        "deletions": 8,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/testrand.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/testrand.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/testrand.h?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -14,28 +14,34 @@\n /* A non-cryptographic RNG used only for test infrastructure. */\n \n /** Seed the pseudorandom number generator for testing. */\n-SECP256K1_INLINE static void secp256k1_rand_seed(const unsigned char *seed16);\n+SECP256K1_INLINE static void secp256k1_testrand_seed(const unsigned char *seed16);\n \n /** Generate a pseudorandom number in the range [0..2**32-1]. */\n-static uint32_t secp256k1_rand32(void);\n+static uint32_t secp256k1_testrand32(void);\n \n /** Generate a pseudorandom number in the range [0..2**bits-1]. Bits must be 1 or\n  *  more. */\n-static uint32_t secp256k1_rand_bits(int bits);\n+static uint32_t secp256k1_testrand_bits(int bits);\n \n /** Generate a pseudorandom number in the range [0..range-1]. */\n-static uint32_t secp256k1_rand_int(uint32_t range);\n+static uint32_t secp256k1_testrand_int(uint32_t range);\n \n /** Generate a pseudorandom 32-byte array. */\n-static void secp256k1_rand256(unsigned char *b32);\n+static void secp256k1_testrand256(unsigned char *b32);\n \n /** Generate a pseudorandom 32-byte array with long sequences of zero and one bits. */\n-static void secp256k1_rand256_test(unsigned char *b32);\n+static void secp256k1_testrand256_test(unsigned char *b32);\n \n /** Generate pseudorandom bytes with long sequences of zero and one bits. */\n-static void secp256k1_rand_bytes_test(unsigned char *bytes, size_t len);\n+static void secp256k1_testrand_bytes_test(unsigned char *bytes, size_t len);\n \n /** Flip a single random bit in a byte array */\n-static void secp256k1_rand_flip(unsigned char *b, size_t len);\n+static void secp256k1_testrand_flip(unsigned char *b, size_t len);\n+\n+/** Initialize the test RNG using (hex encoded) array up to 16 bytes, or randomly if hexseed is NULL. */\n+static void secp256k1_testrand_init(const char* hexseed);\n+\n+/** Print final test information. */\n+static void secp256k1_testrand_finish(void);\n \n #endif /* SECP256K1_TESTRAND_H */"
      },
      {
        "sha": "3392566329818938005aba204a7183ed014857dd",
        "filename": "src/testrand_impl.h",
        "status": "modified",
        "additions": 58,
        "deletions": 14,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/testrand_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/testrand_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/testrand_impl.h?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -8,6 +8,7 @@\n #define SECP256K1_TESTRAND_IMPL_H\n \n #include <stdint.h>\n+#include <stdio.h>\n #include <string.h>\n \n #include \"testrand.h\"\n@@ -19,22 +20,22 @@ static int secp256k1_test_rng_precomputed_used = 8;\n static uint64_t secp256k1_test_rng_integer;\n static int secp256k1_test_rng_integer_bits_left = 0;\n \n-SECP256K1_INLINE static void secp256k1_rand_seed(const unsigned char *seed16) {\n+SECP256K1_INLINE static void secp256k1_testrand_seed(const unsigned char *seed16) {\n     secp256k1_rfc6979_hmac_sha256_initialize(&secp256k1_test_rng, seed16, 16);\n }\n \n-SECP256K1_INLINE static uint32_t secp256k1_rand32(void) {\n+SECP256K1_INLINE static uint32_t secp256k1_testrand32(void) {\n     if (secp256k1_test_rng_precomputed_used == 8) {\n         secp256k1_rfc6979_hmac_sha256_generate(&secp256k1_test_rng, (unsigned char*)(&secp256k1_test_rng_precomputed[0]), sizeof(secp256k1_test_rng_precomputed));\n         secp256k1_test_rng_precomputed_used = 0;\n     }\n     return secp256k1_test_rng_precomputed[secp256k1_test_rng_precomputed_used++];\n }\n \n-static uint32_t secp256k1_rand_bits(int bits) {\n+static uint32_t secp256k1_testrand_bits(int bits) {\n     uint32_t ret;\n     if (secp256k1_test_rng_integer_bits_left < bits) {\n-        secp256k1_test_rng_integer |= (((uint64_t)secp256k1_rand32()) << secp256k1_test_rng_integer_bits_left);\n+        secp256k1_test_rng_integer |= (((uint64_t)secp256k1_testrand32()) << secp256k1_test_rng_integer_bits_left);\n         secp256k1_test_rng_integer_bits_left += 32;\n     }\n     ret = secp256k1_test_rng_integer;\n@@ -44,7 +45,7 @@ static uint32_t secp256k1_rand_bits(int bits) {\n     return ret;\n }\n \n-static uint32_t secp256k1_rand_int(uint32_t range) {\n+static uint32_t secp256k1_testrand_int(uint32_t range) {\n     /* We want a uniform integer between 0 and range-1, inclusive.\n      * B is the smallest number such that range <= 2**B.\n      * two mechanisms implemented here:\n@@ -76,25 +77,25 @@ static uint32_t secp256k1_rand_int(uint32_t range) {\n         mult = 1;\n     }\n     while(1) {\n-        uint32_t x = secp256k1_rand_bits(bits);\n+        uint32_t x = secp256k1_testrand_bits(bits);\n         if (x < trange) {\n             return (mult == 1) ? x : (x % range);\n         }\n     }\n }\n \n-static void secp256k1_rand256(unsigned char *b32) {\n+static void secp256k1_testrand256(unsigned char *b32) {\n     secp256k1_rfc6979_hmac_sha256_generate(&secp256k1_test_rng, b32, 32);\n }\n \n-static void secp256k1_rand_bytes_test(unsigned char *bytes, size_t len) {\n+static void secp256k1_testrand_bytes_test(unsigned char *bytes, size_t len) {\n     size_t bits = 0;\n     memset(bytes, 0, len);\n     while (bits < len * 8) {\n         int now;\n         uint32_t val;\n-        now = 1 + (secp256k1_rand_bits(6) * secp256k1_rand_bits(5) + 16) / 31;\n-        val = secp256k1_rand_bits(1);\n+        now = 1 + (secp256k1_testrand_bits(6) * secp256k1_testrand_bits(5) + 16) / 31;\n+        val = secp256k1_testrand_bits(1);\n         while (now > 0 && bits < len * 8) {\n             bytes[bits / 8] |= val << (bits % 8);\n             now--;\n@@ -103,12 +104,55 @@ static void secp256k1_rand_bytes_test(unsigned char *bytes, size_t len) {\n     }\n }\n \n-static void secp256k1_rand256_test(unsigned char *b32) {\n-    secp256k1_rand_bytes_test(b32, 32);\n+static void secp256k1_testrand256_test(unsigned char *b32) {\n+    secp256k1_testrand_bytes_test(b32, 32);\n }\n \n-static void secp256k1_rand_flip(unsigned char *b, size_t len) {\n-    b[secp256k1_rand_int(len)] ^= (1 << secp256k1_rand_int(8));\n+static void secp256k1_testrand_flip(unsigned char *b, size_t len) {\n+    b[secp256k1_testrand_int(len)] ^= (1 << secp256k1_testrand_int(8));\n+}\n+\n+static void secp256k1_testrand_init(const char* hexseed) {\n+    unsigned char seed16[16] = {0};\n+    if (hexseed && strlen(hexseed) != 0) {\n+        int pos = 0;\n+        while (pos < 16 && hexseed[0] != 0 && hexseed[1] != 0) {\n+            unsigned short sh;\n+            if ((sscanf(hexseed, \"%2hx\", &sh)) == 1) {\n+                seed16[pos] = sh;\n+            } else {\n+                break;\n+            }\n+            hexseed += 2;\n+            pos++;\n+        }\n+    } else {\n+        FILE *frand = fopen(\"/dev/urandom\", \"r\");\n+        if ((frand == NULL) || fread(&seed16, 1, sizeof(seed16), frand) != sizeof(seed16)) {\n+            uint64_t t = time(NULL) * (uint64_t)1337;\n+            fprintf(stderr, \"WARNING: could not read 16 bytes from /dev/urandom; falling back to insecure PRNG\\n\");\n+            seed16[0] ^= t;\n+            seed16[1] ^= t >> 8;\n+            seed16[2] ^= t >> 16;\n+            seed16[3] ^= t >> 24;\n+            seed16[4] ^= t >> 32;\n+            seed16[5] ^= t >> 40;\n+            seed16[6] ^= t >> 48;\n+            seed16[7] ^= t >> 56;\n+        }\n+        if (frand) {\n+            fclose(frand);\n+        }\n+    }\n+\n+    printf(\"random seed = %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\", seed16[0], seed16[1], seed16[2], seed16[3], seed16[4], seed16[5], seed16[6], seed16[7], seed16[8], seed16[9], seed16[10], seed16[11], seed16[12], seed16[13], seed16[14], seed16[15]);\n+    secp256k1_testrand_seed(seed16);\n+}\n+\n+static void secp256k1_testrand_finish(void) {\n+    unsigned char run32[32];\n+    secp256k1_testrand256(run32);\n+    printf(\"random run = %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\", run32[0], run32[1], run32[2], run32[3], run32[4], run32[5], run32[6], run32[7], run32[8], run32[9], run32[10], run32[11], run32[12], run32[13], run32[14], run32[15]);\n }\n \n #endif /* SECP256K1_TESTRAND_IMPL_H */"
      },
      {
        "sha": "bb4b5b4c077e8d4ed9ee1289daa065904d268712",
        "filename": "src/tests.c",
        "status": "modified",
        "additions": 301,
        "deletions": 254,
        "changes": 555,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests.c?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -54,7 +54,7 @@ static void uncounting_illegal_callback_fn(const char* str, void* data) {\n void random_field_element_test(secp256k1_fe *fe) {\n     do {\n         unsigned char b32[32];\n-        secp256k1_rand256_test(b32);\n+        secp256k1_testrand256_test(b32);\n         if (secp256k1_fe_set_b32(fe, b32)) {\n             break;\n         }\n@@ -63,7 +63,7 @@ void random_field_element_test(secp256k1_fe *fe) {\n \n void random_field_element_magnitude(secp256k1_fe *fe) {\n     secp256k1_fe zero;\n-    int n = secp256k1_rand_int(9);\n+    int n = secp256k1_testrand_int(9);\n     secp256k1_fe_normalize(fe);\n     if (n == 0) {\n         return;\n@@ -81,11 +81,12 @@ void random_group_element_test(secp256k1_ge *ge) {\n     secp256k1_fe fe;\n     do {\n         random_field_element_test(&fe);\n-        if (secp256k1_ge_set_xo_var(ge, &fe, secp256k1_rand_bits(1))) {\n+        if (secp256k1_ge_set_xo_var(ge, &fe, secp256k1_testrand_bits(1))) {\n             secp256k1_fe_normalize(&ge->y);\n             break;\n         }\n     } while(1);\n+    ge->infinity = 0;\n }\n \n void random_group_element_jacobian_test(secp256k1_gej *gej, const secp256k1_ge *ge) {\n@@ -107,7 +108,7 @@ void random_scalar_order_test(secp256k1_scalar *num) {\n     do {\n         unsigned char b32[32];\n         int overflow = 0;\n-        secp256k1_rand256_test(b32);\n+        secp256k1_testrand256_test(b32);\n         secp256k1_scalar_set_b32(num, b32, &overflow);\n         if (overflow || secp256k1_scalar_is_zero(num)) {\n             continue;\n@@ -120,7 +121,7 @@ void random_scalar_order(secp256k1_scalar *num) {\n     do {\n         unsigned char b32[32];\n         int overflow = 0;\n-        secp256k1_rand256(b32);\n+        secp256k1_testrand256(b32);\n         secp256k1_scalar_set_b32(num, b32, &overflow);\n         if (overflow || secp256k1_scalar_is_zero(num)) {\n             continue;\n@@ -441,14 +442,14 @@ void run_sha256_tests(void) {\n         secp256k1_sha256_initialize(&hasher);\n         secp256k1_sha256_write(&hasher, (const unsigned char*)(inputs[i]), strlen(inputs[i]));\n         secp256k1_sha256_finalize(&hasher, out);\n-        CHECK(memcmp(out, outputs[i], 32) == 0);\n+        CHECK(secp256k1_memcmp_var(out, outputs[i], 32) == 0);\n         if (strlen(inputs[i]) > 0) {\n-            int split = secp256k1_rand_int(strlen(inputs[i]));\n+            int split = secp256k1_testrand_int(strlen(inputs[i]));\n             secp256k1_sha256_initialize(&hasher);\n             secp256k1_sha256_write(&hasher, (const unsigned char*)(inputs[i]), split);\n             secp256k1_sha256_write(&hasher, (const unsigned char*)(inputs[i] + split), strlen(inputs[i]) - split);\n             secp256k1_sha256_finalize(&hasher, out);\n-            CHECK(memcmp(out, outputs[i], 32) == 0);\n+            CHECK(secp256k1_memcmp_var(out, outputs[i], 32) == 0);\n         }\n     }\n }\n@@ -485,14 +486,14 @@ void run_hmac_sha256_tests(void) {\n         secp256k1_hmac_sha256_initialize(&hasher, (const unsigned char*)(keys[i]), strlen(keys[i]));\n         secp256k1_hmac_sha256_write(&hasher, (const unsigned char*)(inputs[i]), strlen(inputs[i]));\n         secp256k1_hmac_sha256_finalize(&hasher, out);\n-        CHECK(memcmp(out, outputs[i], 32) == 0);\n+        CHECK(secp256k1_memcmp_var(out, outputs[i], 32) == 0);\n         if (strlen(inputs[i]) > 0) {\n-            int split = secp256k1_rand_int(strlen(inputs[i]));\n+            int split = secp256k1_testrand_int(strlen(inputs[i]));\n             secp256k1_hmac_sha256_initialize(&hasher, (const unsigned char*)(keys[i]), strlen(keys[i]));\n             secp256k1_hmac_sha256_write(&hasher, (const unsigned char*)(inputs[i]), split);\n             secp256k1_hmac_sha256_write(&hasher, (const unsigned char*)(inputs[i] + split), strlen(inputs[i]) - split);\n             secp256k1_hmac_sha256_finalize(&hasher, out);\n-            CHECK(memcmp(out, outputs[i], 32) == 0);\n+            CHECK(secp256k1_memcmp_var(out, outputs[i], 32) == 0);\n         }\n     }\n }\n@@ -519,21 +520,21 @@ void run_rfc6979_hmac_sha256_tests(void) {\n     secp256k1_rfc6979_hmac_sha256_initialize(&rng, key1, 64);\n     for (i = 0; i < 3; i++) {\n         secp256k1_rfc6979_hmac_sha256_generate(&rng, out, 32);\n-        CHECK(memcmp(out, out1[i], 32) == 0);\n+        CHECK(secp256k1_memcmp_var(out, out1[i], 32) == 0);\n     }\n     secp256k1_rfc6979_hmac_sha256_finalize(&rng);\n \n     secp256k1_rfc6979_hmac_sha256_initialize(&rng, key1, 65);\n     for (i = 0; i < 3; i++) {\n         secp256k1_rfc6979_hmac_sha256_generate(&rng, out, 32);\n-        CHECK(memcmp(out, out1[i], 32) != 0);\n+        CHECK(secp256k1_memcmp_var(out, out1[i], 32) != 0);\n     }\n     secp256k1_rfc6979_hmac_sha256_finalize(&rng);\n \n     secp256k1_rfc6979_hmac_sha256_initialize(&rng, key2, 64);\n     for (i = 0; i < 3; i++) {\n         secp256k1_rfc6979_hmac_sha256_generate(&rng, out, 32);\n-        CHECK(memcmp(out, out2[i], 32) == 0);\n+        CHECK(secp256k1_memcmp_var(out, out2[i], 32) == 0);\n     }\n     secp256k1_rfc6979_hmac_sha256_finalize(&rng);\n }\n@@ -557,7 +558,7 @@ void test_rand_bits(int rand32, int bits) {\n     /* Multiply the output of all rand calls with the odd number m, which\n        should not change the uniformity of its distribution. */\n     for (i = 0; i < rounds[usebits]; i++) {\n-        uint32_t r = (rand32 ? secp256k1_rand32() : secp256k1_rand_bits(bits));\n+        uint32_t r = (rand32 ? secp256k1_testrand32() : secp256k1_testrand_bits(bits));\n         CHECK((((uint64_t)r) >> bits) == 0);\n         for (m = 0; m < sizeof(mults) / sizeof(mults[0]); m++) {\n             uint32_t rm = r * mults[m];\n@@ -582,7 +583,7 @@ void test_rand_int(uint32_t range, uint32_t subrange) {\n     uint64_t x = 0;\n     CHECK((range % subrange) == 0);\n     for (i = 0; i < rounds; i++) {\n-        uint32_t r = secp256k1_rand_int(range);\n+        uint32_t r = secp256k1_testrand_int(range);\n         CHECK(r < range);\n         r = r % subrange;\n         x |= (((uint64_t)1) << r);\n@@ -614,7 +615,7 @@ void run_rand_int(void) {\n \n #ifndef USE_NUM_NONE\n void random_num_negate(secp256k1_num *num) {\n-    if (secp256k1_rand_bits(1)) {\n+    if (secp256k1_testrand_bits(1)) {\n         secp256k1_num_negate(num);\n     }\n }\n@@ -658,11 +659,11 @@ void test_num_add_sub(void) {\n     secp256k1_num n2;\n     secp256k1_num n1p2, n2p1, n1m2, n2m1;\n     random_num_order_test(&n1); /* n1 = R1 */\n-    if (secp256k1_rand_bits(1)) {\n+    if (secp256k1_testrand_bits(1)) {\n         random_num_negate(&n1);\n     }\n     random_num_order_test(&n2); /* n2 = R2 */\n-    if (secp256k1_rand_bits(1)) {\n+    if (secp256k1_testrand_bits(1)) {\n         random_num_negate(&n2);\n     }\n     secp256k1_num_add(&n1p2, &n1, &n2); /* n1p2 = R1 + R2 */\n@@ -853,7 +854,7 @@ void scalar_test(void) {\n         while (i < 256) {\n             secp256k1_scalar t;\n             int j;\n-            int now = secp256k1_rand_int(15) + 1;\n+            int now = secp256k1_testrand_int(15) + 1;\n             if (now + i > 256) {\n                 now = 256 - i;\n             }\n@@ -930,7 +931,7 @@ void scalar_test(void) {\n         secp256k1_num rnum;\n         secp256k1_num rnum2;\n         unsigned char cone[1] = {0x01};\n-        unsigned int shift = 256 + secp256k1_rand_int(257);\n+        unsigned int shift = 256 + secp256k1_testrand_int(257);\n         secp256k1_scalar_mul_shift_var(&r, &s1, &s2, shift);\n         secp256k1_num_mul(&rnum, &s1num, &s2num);\n         secp256k1_num_shift(&rnum, shift - 1);\n@@ -948,7 +949,7 @@ void scalar_test(void) {\n         random_scalar_order_test(&r);\n         for (i = 0; i < 100; ++i) {\n             int low;\n-            int shift = 1 + secp256k1_rand_int(15);\n+            int shift = 1 + secp256k1_testrand_int(15);\n             int expected = r.d[0] % (1 << shift);\n             low = secp256k1_scalar_shr_int(&r, shift);\n             CHECK(expected == low);\n@@ -996,7 +997,7 @@ void scalar_test(void) {\n         secp256k1_scalar b;\n         int i;\n         /* Test add_bit. */\n-        int bit = secp256k1_rand_bits(8);\n+        int bit = secp256k1_testrand_bits(8);\n         secp256k1_scalar_set_int(&b, 1);\n         CHECK(secp256k1_scalar_is_one(&b));\n         for (i = 0; i < bit; i++) {\n@@ -1157,7 +1158,7 @@ void run_scalar_tests(void) {\n         secp256k1_scalar_set_b32(&scalar, bin, &overflow);\n         CHECK(overflow == 0);\n         secp256k1_scalar_get_b32(bin_tmp, &scalar);\n-        CHECK(memcmp(bin, bin_tmp, 32) == 0);\n+        CHECK(secp256k1_memcmp_var(bin, bin_tmp, 32) == 0);\n \n         /* A scalar set to all 1s should overflow. */\n         memset(bin, 0xFF, 32);\n@@ -1767,7 +1768,7 @@ void run_scalar_tests(void) {\n void random_fe(secp256k1_fe *x) {\n     unsigned char bin[32];\n     do {\n-        secp256k1_rand256(bin);\n+        secp256k1_testrand256(bin);\n         if (secp256k1_fe_set_b32(x, bin)) {\n             return;\n         }\n@@ -1777,7 +1778,7 @@ void random_fe(secp256k1_fe *x) {\n void random_fe_test(secp256k1_fe *x) {\n     unsigned char bin[32];\n     do {\n-        secp256k1_rand256_test(bin);\n+        secp256k1_testrand256_test(bin);\n         if (secp256k1_fe_set_b32(x, bin)) {\n             return;\n         }\n@@ -1845,18 +1846,18 @@ void run_field_convert(void) {\n     CHECK(secp256k1_fe_equal_var(&fe, &fe2));\n     /* Check conversion from fe. */\n     secp256k1_fe_get_b32(b322, &fe);\n-    CHECK(memcmp(b322, b32, 32) == 0);\n+    CHECK(secp256k1_memcmp_var(b322, b32, 32) == 0);\n     secp256k1_fe_to_storage(&fes2, &fe);\n-    CHECK(memcmp(&fes2, &fes, sizeof(fes)) == 0);\n+    CHECK(secp256k1_memcmp_var(&fes2, &fes, sizeof(fes)) == 0);\n }\n \n-int fe_memcmp(const secp256k1_fe *a, const secp256k1_fe *b) {\n+int fe_secp256k1_memcmp_var(const secp256k1_fe *a, const secp256k1_fe *b) {\n     secp256k1_fe t = *b;\n #ifdef VERIFY\n     t.magnitude = a->magnitude;\n     t.normalized = a->normalized;\n #endif\n-    return memcmp(a, &t, sizeof(secp256k1_fe));\n+    return secp256k1_memcmp_var(a, &t, sizeof(secp256k1_fe));\n }\n \n void run_field_misc(void) {\n@@ -1882,13 +1883,13 @@ void run_field_misc(void) {\n         CHECK(x.normalized && x.magnitude == 1);\n #endif\n         secp256k1_fe_cmov(&x, &x, 1);\n-        CHECK(fe_memcmp(&x, &z) != 0);\n-        CHECK(fe_memcmp(&x, &q) == 0);\n+        CHECK(fe_secp256k1_memcmp_var(&x, &z) != 0);\n+        CHECK(fe_secp256k1_memcmp_var(&x, &q) == 0);\n         secp256k1_fe_cmov(&q, &z, 1);\n #ifdef VERIFY\n         CHECK(!q.normalized && q.magnitude == z.magnitude);\n #endif\n-        CHECK(fe_memcmp(&q, &z) == 0);\n+        CHECK(fe_secp256k1_memcmp_var(&q, &z) == 0);\n         secp256k1_fe_normalize_var(&x);\n         secp256k1_fe_normalize_var(&z);\n         CHECK(!secp256k1_fe_equal_var(&x, &z));\n@@ -1912,9 +1913,9 @@ void run_field_misc(void) {\n         secp256k1_fe_to_storage(&zs, &z);\n         secp256k1_fe_storage_cmov(&zs, &xs, 0);\n         secp256k1_fe_storage_cmov(&zs, &zs, 1);\n-        CHECK(memcmp(&xs, &zs, sizeof(xs)) != 0);\n+        CHECK(secp256k1_memcmp_var(&xs, &zs, sizeof(xs)) != 0);\n         secp256k1_fe_storage_cmov(&ys, &xs, 1);\n-        CHECK(memcmp(&xs, &ys, sizeof(xs)) == 0);\n+        CHECK(secp256k1_memcmp_var(&xs, &ys, sizeof(xs)) == 0);\n         secp256k1_fe_from_storage(&x, &xs);\n         secp256k1_fe_from_storage(&y, &ys);\n         secp256k1_fe_from_storage(&z, &zs);\n@@ -1970,7 +1971,7 @@ void run_field_inv_all_var(void) {\n     secp256k1_fe_inv_all_var(xi, x, 0);\n     for (i = 0; i < count; i++) {\n         size_t j;\n-        size_t len = secp256k1_rand_int(15) + 1;\n+        size_t len = secp256k1_testrand_int(15) + 1;\n         for (j = 0; j < len; j++) {\n             random_fe_non_zero(&x[j]);\n         }\n@@ -2101,17 +2102,12 @@ void ge_equals_gej(const secp256k1_ge *a, const secp256k1_gej *b) {\n \n void test_ge(void) {\n     int i, i1;\n-#ifdef USE_ENDOMORPHISM\n     int runs = 6;\n-#else\n-    int runs = 4;\n-#endif\n-    /* Points: (infinity, p1, p1, -p1, -p1, p2, p2, -p2, -p2, p3, p3, -p3, -p3, p4, p4, -p4, -p4).\n-     * The second in each pair of identical points uses a random Z coordinate in the Jacobian form.\n-     * All magnitudes are randomized.\n-     * All 17*17 combinations of points are added to each other, using all applicable methods.\n-     *\n-     * When the endomorphism code is compiled in, p5 = lambda*p1 and p6 = lambda^2*p1 are added as well.\n+    /* 25 points are used:\n+     * - infinity\n+     * - for each of four random points p1 p2 p3 p4, we add the point, its\n+     *   negation, and then those two again but with randomized Z coordinate.\n+     * - The same is then done for lambda*p1 and lambda^2*p1.\n      */\n     secp256k1_ge *ge = (secp256k1_ge *)checked_malloc(&ctx->error_callback, sizeof(secp256k1_ge) * (1 + 4 * runs));\n     secp256k1_gej *gej = (secp256k1_gej *)checked_malloc(&ctx->error_callback, sizeof(secp256k1_gej) * (1 + 4 * runs));\n@@ -2126,14 +2122,12 @@ void test_ge(void) {\n         int j;\n         secp256k1_ge g;\n         random_group_element_test(&g);\n-#ifdef USE_ENDOMORPHISM\n         if (i >= runs - 2) {\n             secp256k1_ge_mul_lambda(&g, &ge[1]);\n         }\n         if (i >= runs - 1) {\n             secp256k1_ge_mul_lambda(&g, &g);\n         }\n-#endif\n         ge[1 + 4 * i] = g;\n         ge[2 + 4 * i] = g;\n         secp256k1_ge_neg(&ge[3 + 4 * i], &g);\n@@ -2262,7 +2256,7 @@ void test_ge(void) {\n             gej_shuffled[i] = gej[i];\n         }\n         for (i = 0; i < 4 * runs + 1; i++) {\n-            int swap = i + secp256k1_rand_int(4 * runs + 1 - i);\n+            int swap = i + secp256k1_testrand_int(4 * runs + 1 - i);\n             if (swap != i) {\n                 secp256k1_gej t = gej_shuffled[i];\n                 gej_shuffled[i] = gej_shuffled[swap];\n@@ -2448,7 +2442,7 @@ void test_ec_combine(void) {\n         secp256k1_ge_set_gej(&Q, &Qj);\n         secp256k1_pubkey_save(&sd, &Q);\n         CHECK(secp256k1_ec_pubkey_combine(ctx, &sd2, d, i) == 1);\n-        CHECK(memcmp(&sd, &sd2, sizeof(sd)) == 0);\n+        CHECK(secp256k1_memcmp_var(&sd, &sd2, sizeof(sd)) == 0);\n     }\n }\n \n@@ -2614,7 +2608,6 @@ void test_point_times_order(const secp256k1_gej *point) {\n     secp256k1_ecmult(&ctx->ecmult_ctx, &res2, point, &nx, &nx); /* calc res2 = (order - x) * point + (order - x) * G; */\n     secp256k1_gej_add_var(&res1, &res1, &res2, NULL);\n     CHECK(secp256k1_gej_is_infinity(&res1));\n-    CHECK(secp256k1_gej_is_valid_var(&res1) == 0);\n     secp256k1_ge_set_gej(&res3, &res1);\n     CHECK(secp256k1_ge_is_infinity(&res3));\n     CHECK(secp256k1_ge_is_valid_var(&res3) == 0);\n@@ -2633,6 +2626,87 @@ void test_point_times_order(const secp256k1_gej *point) {\n     ge_equals_ge(&res3, &secp256k1_ge_const_g);\n }\n \n+/* These scalars reach large (in absolute value) outputs when fed to secp256k1_scalar_split_lambda.\n+ *\n+ * They are computed as:\n+ * - For a in [-2, -1, 0, 1, 2]:\n+ *   - For b in [-3, -1, 1, 3]:\n+ *     - Output (a*LAMBDA + (ORDER+b)/2) % ORDER\n+ */\n+static const secp256k1_scalar scalars_near_split_bounds[20] = {\n+    SECP256K1_SCALAR_CONST(0xd938a566, 0x7f479e3e, 0xb5b3c7fa, 0xefdb3749, 0x3aa0585c, 0xc5ea2367, 0xe1b660db, 0x0209e6fc),\n+    SECP256K1_SCALAR_CONST(0xd938a566, 0x7f479e3e, 0xb5b3c7fa, 0xefdb3749, 0x3aa0585c, 0xc5ea2367, 0xe1b660db, 0x0209e6fd),\n+    SECP256K1_SCALAR_CONST(0xd938a566, 0x7f479e3e, 0xb5b3c7fa, 0xefdb3749, 0x3aa0585c, 0xc5ea2367, 0xe1b660db, 0x0209e6fe),\n+    SECP256K1_SCALAR_CONST(0xd938a566, 0x7f479e3e, 0xb5b3c7fa, 0xefdb3749, 0x3aa0585c, 0xc5ea2367, 0xe1b660db, 0x0209e6ff),\n+    SECP256K1_SCALAR_CONST(0x2c9c52b3, 0x3fa3cf1f, 0x5ad9e3fd, 0x77ed9ba5, 0xb294b893, 0x3722e9a5, 0x00e698ca, 0x4cf7632d),\n+    SECP256K1_SCALAR_CONST(0x2c9c52b3, 0x3fa3cf1f, 0x5ad9e3fd, 0x77ed9ba5, 0xb294b893, 0x3722e9a5, 0x00e698ca, 0x4cf7632e),\n+    SECP256K1_SCALAR_CONST(0x2c9c52b3, 0x3fa3cf1f, 0x5ad9e3fd, 0x77ed9ba5, 0xb294b893, 0x3722e9a5, 0x00e698ca, 0x4cf7632f),\n+    SECP256K1_SCALAR_CONST(0x2c9c52b3, 0x3fa3cf1f, 0x5ad9e3fd, 0x77ed9ba5, 0xb294b893, 0x3722e9a5, 0x00e698ca, 0x4cf76330),\n+    SECP256K1_SCALAR_CONST(0x7fffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xd576e735, 0x57a4501d, 0xdfe92f46, 0x681b209f),\n+    SECP256K1_SCALAR_CONST(0x7fffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xd576e735, 0x57a4501d, 0xdfe92f46, 0x681b20a0),\n+    SECP256K1_SCALAR_CONST(0x7fffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xd576e735, 0x57a4501d, 0xdfe92f46, 0x681b20a1),\n+    SECP256K1_SCALAR_CONST(0x7fffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xd576e735, 0x57a4501d, 0xdfe92f46, 0x681b20a2),\n+    SECP256K1_SCALAR_CONST(0xd363ad4c, 0xc05c30e0, 0xa5261c02, 0x88126459, 0xf85915d7, 0x7825b696, 0xbeebc5c2, 0x833ede11),\n+    SECP256K1_SCALAR_CONST(0xd363ad4c, 0xc05c30e0, 0xa5261c02, 0x88126459, 0xf85915d7, 0x7825b696, 0xbeebc5c2, 0x833ede12),\n+    SECP256K1_SCALAR_CONST(0xd363ad4c, 0xc05c30e0, 0xa5261c02, 0x88126459, 0xf85915d7, 0x7825b696, 0xbeebc5c2, 0x833ede13),\n+    SECP256K1_SCALAR_CONST(0xd363ad4c, 0xc05c30e0, 0xa5261c02, 0x88126459, 0xf85915d7, 0x7825b696, 0xbeebc5c2, 0x833ede14),\n+    SECP256K1_SCALAR_CONST(0x26c75a99, 0x80b861c1, 0x4a4c3805, 0x1024c8b4, 0x704d760e, 0xe95e7cd3, 0xde1bfdb1, 0xce2c5a42),\n+    SECP256K1_SCALAR_CONST(0x26c75a99, 0x80b861c1, 0x4a4c3805, 0x1024c8b4, 0x704d760e, 0xe95e7cd3, 0xde1bfdb1, 0xce2c5a43),\n+    SECP256K1_SCALAR_CONST(0x26c75a99, 0x80b861c1, 0x4a4c3805, 0x1024c8b4, 0x704d760e, 0xe95e7cd3, 0xde1bfdb1, 0xce2c5a44),\n+    SECP256K1_SCALAR_CONST(0x26c75a99, 0x80b861c1, 0x4a4c3805, 0x1024c8b4, 0x704d760e, 0xe95e7cd3, 0xde1bfdb1, 0xce2c5a45)\n+};\n+\n+void test_ecmult_target(const secp256k1_scalar* target, int mode) {\n+    /* Mode: 0=ecmult_gen, 1=ecmult, 2=ecmult_const */\n+    secp256k1_scalar n1, n2;\n+    secp256k1_ge p;\n+    secp256k1_gej pj, p1j, p2j, ptj;\n+    static const secp256k1_scalar zero = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 0);\n+\n+    /* Generate random n1,n2 such that n1+n2 = -target. */\n+    random_scalar_order_test(&n1);\n+    secp256k1_scalar_add(&n2, &n1, target);\n+    secp256k1_scalar_negate(&n2, &n2);\n+\n+    /* Generate a random input point. */\n+    if (mode != 0) {\n+        random_group_element_test(&p);\n+        secp256k1_gej_set_ge(&pj, &p);\n+    }\n+\n+    /* EC multiplications */\n+    if (mode == 0) {\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &p1j, &n1);\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &p2j, &n2);\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &ptj, target);\n+    } else if (mode == 1) {\n+        secp256k1_ecmult(&ctx->ecmult_ctx, &p1j, &pj, &n1, &zero);\n+        secp256k1_ecmult(&ctx->ecmult_ctx, &p2j, &pj, &n2, &zero);\n+        secp256k1_ecmult(&ctx->ecmult_ctx, &ptj, &pj, target, &zero);\n+    } else {\n+        secp256k1_ecmult_const(&p1j, &p, &n1, 256);\n+        secp256k1_ecmult_const(&p2j, &p, &n2, 256);\n+        secp256k1_ecmult_const(&ptj, &p, target, 256);\n+    }\n+\n+    /* Add them all up: n1*P + n2*P + target*P = (n1+n2+target)*P = (n1+n1-n1-n2)*P = 0. */\n+    secp256k1_gej_add_var(&ptj, &ptj, &p1j, NULL);\n+    secp256k1_gej_add_var(&ptj, &ptj, &p2j, NULL);\n+    CHECK(secp256k1_gej_is_infinity(&ptj));\n+}\n+\n+void run_ecmult_near_split_bound(void) {\n+    int i;\n+    unsigned j;\n+    for (i = 0; i < 4*count; ++i) {\n+        for (j = 0; j < sizeof(scalars_near_split_bounds) / sizeof(scalars_near_split_bounds[0]); ++j) {\n+            test_ecmult_target(&scalars_near_split_bounds[j], 0);\n+            test_ecmult_target(&scalars_near_split_bounds[j], 1);\n+            test_ecmult_target(&scalars_near_split_bounds[j], 2);\n+        }\n+    }\n+}\n+\n void run_point_times_order(void) {\n     int i;\n     secp256k1_fe x = SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 2);\n@@ -2646,7 +2720,6 @@ void run_point_times_order(void) {\n             secp256k1_gej j;\n             CHECK(secp256k1_ge_is_valid_var(&p));\n             secp256k1_gej_set_ge(&j, &p);\n-            CHECK(secp256k1_gej_is_valid_var(&j));\n             test_point_times_order(&j);\n         }\n         secp256k1_fe_sqr(&x, &x);\n@@ -3042,12 +3115,10 @@ void test_secp256k1_pippenger_bucket_window_inv(void) {\n \n     CHECK(secp256k1_pippenger_bucket_window_inv(0) == 0);\n     for(i = 1; i <= PIPPENGER_MAX_BUCKET_WINDOW; i++) {\n-#ifdef USE_ENDOMORPHISM\n         /* Bucket_window of 8 is not used with endo */\n         if (i == 8) {\n             continue;\n         }\n-#endif\n         CHECK(secp256k1_pippenger_bucket_window(secp256k1_pippenger_bucket_window_inv(i)) == i);\n         if (i != PIPPENGER_MAX_BUCKET_WINDOW) {\n             CHECK(secp256k1_pippenger_bucket_window(secp256k1_pippenger_bucket_window_inv(i)+1) > i);\n@@ -3060,7 +3131,7 @@ void test_secp256k1_pippenger_bucket_window_inv(void) {\n  * for a given scratch space.\n  */\n void test_ecmult_multi_pippenger_max_points(void) {\n-    size_t scratch_size = secp256k1_rand_int(256);\n+    size_t scratch_size = secp256k1_testrand_int(256);\n     size_t max_size = secp256k1_pippenger_scratch_size(secp256k1_pippenger_bucket_window_inv(PIPPENGER_MAX_BUCKET_WINDOW-1)+512, 12);\n     secp256k1_scratch *scratch;\n     size_t n_points_supported;\n@@ -3290,13 +3361,10 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n \n     secp256k1_scalar_set_int(&x, 0);\n     secp256k1_scalar_set_int(&shift, 1 << w);\n-    /* With USE_ENDOMORPHISM on we only consider 128-bit numbers */\n-#ifdef USE_ENDOMORPHISM\n     for (i = 0; i < 16; ++i) {\n         secp256k1_scalar_shr_int(&num, 8);\n     }\n     bits = 128;\n-#endif\n     skew = secp256k1_wnaf_const(wnaf, &num, w, bits);\n \n     for (i = WNAF_SIZE_BITS(bits, w); i >= 0; --i) {\n@@ -3331,12 +3399,9 @@ void test_fixed_wnaf(const secp256k1_scalar *number, int w) {\n \n     secp256k1_scalar_set_int(&x, 0);\n     secp256k1_scalar_set_int(&shift, 1 << w);\n-    /* With USE_ENDOMORPHISM on we only consider 128-bit numbers */\n-#ifdef USE_ENDOMORPHISM\n     for (i = 0; i < 16; ++i) {\n         secp256k1_scalar_shr_int(&num, 8);\n     }\n-#endif\n     skew = secp256k1_wnaf_fixed(wnaf, &num, w);\n \n     for (i = WNAF_SIZE(w)-1; i >= 0; --i) {\n@@ -3520,7 +3585,7 @@ void test_ecmult_gen_blind(void) {\n     secp256k1_ge pge;\n     random_scalar_order_test(&key);\n     secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pgej, &key);\n-    secp256k1_rand256(seed32);\n+    secp256k1_testrand256(seed32);\n     b = ctx->ecmult_gen_ctx.blind;\n     i = ctx->ecmult_gen_ctx.initial;\n     secp256k1_ecmult_gen_blind(&ctx->ecmult_gen_ctx, seed32);\n@@ -3552,16 +3617,18 @@ void run_ecmult_gen_blind(void) {\n     }\n }\n \n-#ifdef USE_ENDOMORPHISM\n /***** ENDOMORPHISH TESTS *****/\n-void test_scalar_split(void) {\n-    secp256k1_scalar full;\n-    secp256k1_scalar s1, slam;\n+void test_scalar_split(const secp256k1_scalar* full) {\n+    secp256k1_scalar s, s1, slam;\n     const unsigned char zero[32] = {0};\n     unsigned char tmp[32];\n \n-    random_scalar_order_test(&full);\n-    secp256k1_scalar_split_lambda(&s1, &slam, &full);\n+    secp256k1_scalar_split_lambda(&s1, &slam, full);\n+\n+    /* check slam*lambda + s1 == full */\n+    secp256k1_scalar_mul(&s, &secp256k1_const_lambda, &slam);\n+    secp256k1_scalar_add(&s, &s, &s1);\n+    CHECK(secp256k1_scalar_eq(&s, full));\n \n     /* check that both are <= 128 bits in size */\n     if (secp256k1_scalar_is_high(&s1)) {\n@@ -3572,15 +3639,32 @@ void test_scalar_split(void) {\n     }\n \n     secp256k1_scalar_get_b32(tmp, &s1);\n-    CHECK(memcmp(zero, tmp, 16) == 0);\n+    CHECK(secp256k1_memcmp_var(zero, tmp, 16) == 0);\n     secp256k1_scalar_get_b32(tmp, &slam);\n-    CHECK(memcmp(zero, tmp, 16) == 0);\n+    CHECK(secp256k1_memcmp_var(zero, tmp, 16) == 0);\n }\n \n+\n void run_endomorphism_tests(void) {\n-    test_scalar_split();\n+    unsigned i;\n+    static secp256k1_scalar s;\n+    test_scalar_split(&secp256k1_scalar_zero);\n+    test_scalar_split(&secp256k1_scalar_one);\n+    secp256k1_scalar_negate(&s,&secp256k1_scalar_one);\n+    test_scalar_split(&s);\n+    test_scalar_split(&secp256k1_const_lambda);\n+    secp256k1_scalar_add(&s, &secp256k1_const_lambda, &secp256k1_scalar_one);\n+    test_scalar_split(&s);\n+\n+    for (i = 0; i < 100U * count; ++i) {\n+        secp256k1_scalar full;\n+        random_scalar_order_test(&full);\n+        test_scalar_split(&full);\n+    }\n+    for (i = 0; i < sizeof(scalars_near_split_bounds) / sizeof(scalars_near_split_bounds[0]); ++i) {\n+        test_scalar_split(&scalars_near_split_bounds[i]);\n+    }\n }\n-#endif\n \n void ec_pubkey_parse_pointtest(const unsigned char *input, int xvalid, int yvalid) {\n     unsigned char pubkeyc[65];\n@@ -3622,7 +3706,7 @@ void ec_pubkey_parse_pointtest(const unsigned char *input, int xvalid, int yvali\n                 CHECK(secp256k1_ec_pubkey_serialize(ctx, pubkeyo, &outl, &pubkey, SECP256K1_EC_COMPRESSED) == 1);\n                 VG_CHECK(pubkeyo, outl);\n                 CHECK(outl == 33);\n-                CHECK(memcmp(&pubkeyo[1], &pubkeyc[1], 32) == 0);\n+                CHECK(secp256k1_memcmp_var(&pubkeyo[1], &pubkeyc[1], 32) == 0);\n                 CHECK((pubkeyclen != 33) || (pubkeyo[0] == pubkeyc[0]));\n                 if (ypass) {\n                     /* This test isn't always done because we decode with alternative signs, so the y won't match. */\n@@ -3638,7 +3722,7 @@ void ec_pubkey_parse_pointtest(const unsigned char *input, int xvalid, int yvali\n                     VG_CHECK(pubkeyo, outl);\n                     CHECK(outl == 65);\n                     CHECK(pubkeyo[0] == 4);\n-                    CHECK(memcmp(&pubkeyo[1], input, 64) == 0);\n+                    CHECK(secp256k1_memcmp_var(&pubkeyo[1], input, 64) == 0);\n                 }\n                 CHECK(ecount == 0);\n             } else {\n@@ -4007,31 +4091,31 @@ void run_eckey_edge_case_test(void) {\n     VG_UNDEF(&pubkey, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey, orderc) == 0);\n     VG_CHECK(&pubkey, sizeof(pubkey));\n-    CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n     /* Maximum value is too large, reject. */\n     memset(ctmp, 255, 32);\n     CHECK(secp256k1_ec_seckey_verify(ctx, ctmp) == 0);\n     memset(&pubkey, 1, sizeof(pubkey));\n     VG_UNDEF(&pubkey, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey, ctmp) == 0);\n     VG_CHECK(&pubkey, sizeof(pubkey));\n-    CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n     /* Zero is too small, reject. */\n     memset(ctmp, 0, 32);\n     CHECK(secp256k1_ec_seckey_verify(ctx, ctmp) == 0);\n     memset(&pubkey, 1, sizeof(pubkey));\n     VG_UNDEF(&pubkey, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey, ctmp) == 0);\n     VG_CHECK(&pubkey, sizeof(pubkey));\n-    CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n     /* One must be accepted. */\n     ctmp[31] = 0x01;\n     CHECK(secp256k1_ec_seckey_verify(ctx, ctmp) == 1);\n     memset(&pubkey, 0, sizeof(pubkey));\n     VG_UNDEF(&pubkey, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey, ctmp) == 1);\n     VG_CHECK(&pubkey, sizeof(pubkey));\n-    CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) > 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(secp256k1_pubkey)) > 0);\n     pubkey_one = pubkey;\n     /* Group order + 1 is too large, reject. */\n     memcpy(ctmp, orderc, 32);\n@@ -4041,28 +4125,28 @@ void run_eckey_edge_case_test(void) {\n     VG_UNDEF(&pubkey, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey, ctmp) == 0);\n     VG_CHECK(&pubkey, sizeof(pubkey));\n-    CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n     /* -1 must be accepted. */\n     ctmp[31] = 0x40;\n     CHECK(secp256k1_ec_seckey_verify(ctx, ctmp) == 1);\n     memset(&pubkey, 0, sizeof(pubkey));\n     VG_UNDEF(&pubkey, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey, ctmp) == 1);\n     VG_CHECK(&pubkey, sizeof(pubkey));\n-    CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) > 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(secp256k1_pubkey)) > 0);\n     pubkey_negone = pubkey;\n     /* Tweak of zero leaves the value unchanged. */\n     memset(ctmp2, 0, 32);\n     CHECK(secp256k1_ec_seckey_tweak_add(ctx, ctmp, ctmp2) == 1);\n-    CHECK(memcmp(orderc, ctmp, 31) == 0 && ctmp[31] == 0x40);\n+    CHECK(secp256k1_memcmp_var(orderc, ctmp, 31) == 0 && ctmp[31] == 0x40);\n     memcpy(&pubkey2, &pubkey, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, ctmp2) == 1);\n-    CHECK(memcmp(&pubkey, &pubkey2, sizeof(pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, &pubkey2, sizeof(pubkey)) == 0);\n     /* Multiply tweak of zero zeroizes the output. */\n     CHECK(secp256k1_ec_seckey_tweak_mul(ctx, ctmp, ctmp2) == 0);\n-    CHECK(memcmp(zeros, ctmp, 32) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros, ctmp, 32) == 0);\n     CHECK(secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, ctmp2) == 0);\n-    CHECK(memcmp(&pubkey, zeros, sizeof(pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(pubkey)) == 0);\n     memcpy(&pubkey, &pubkey2, sizeof(pubkey));\n     /* If seckey_tweak_add or seckey_tweak_mul are called with an overflowing\n     seckey, the seckey is zeroized. */\n@@ -4072,29 +4156,29 @@ void run_eckey_edge_case_test(void) {\n     CHECK(secp256k1_ec_seckey_verify(ctx, ctmp2) == 1);\n     CHECK(secp256k1_ec_seckey_verify(ctx, ctmp) == 0);\n     CHECK(secp256k1_ec_seckey_tweak_add(ctx, ctmp, ctmp2) == 0);\n-    CHECK(memcmp(zeros, ctmp, 32) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros, ctmp, 32) == 0);\n     memcpy(ctmp, orderc, 32);\n     CHECK(secp256k1_ec_seckey_tweak_mul(ctx, ctmp, ctmp2) == 0);\n-    CHECK(memcmp(zeros, ctmp, 32) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros, ctmp, 32) == 0);\n     /* If seckey_tweak_add or seckey_tweak_mul are called with an overflowing\n     tweak, the seckey is zeroized. */\n     memcpy(ctmp, orderc, 32);\n     ctmp[31] = 0x40;\n     CHECK(secp256k1_ec_seckey_tweak_add(ctx, ctmp, orderc) == 0);\n-    CHECK(memcmp(zeros, ctmp, 32) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros, ctmp, 32) == 0);\n     memcpy(ctmp, orderc, 32);\n     ctmp[31] = 0x40;\n     CHECK(secp256k1_ec_seckey_tweak_mul(ctx, ctmp, orderc) == 0);\n-    CHECK(memcmp(zeros, ctmp, 32) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros, ctmp, 32) == 0);\n     memcpy(ctmp, orderc, 32);\n     ctmp[31] = 0x40;\n     /* If pubkey_tweak_add or pubkey_tweak_mul are called with an overflowing\n     tweak, the pubkey is zeroized. */\n     CHECK(secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, orderc) == 0);\n-    CHECK(memcmp(&pubkey, zeros, sizeof(pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(pubkey)) == 0);\n     memcpy(&pubkey, &pubkey2, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, orderc) == 0);\n-    CHECK(memcmp(&pubkey, zeros, sizeof(pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(pubkey)) == 0);\n     memcpy(&pubkey, &pubkey2, sizeof(pubkey));\n     /* If the resulting key in secp256k1_ec_seckey_tweak_add and\n      * secp256k1_ec_pubkey_tweak_add is 0 the functions fail and in the latter\n@@ -4104,25 +4188,25 @@ void run_eckey_edge_case_test(void) {\n     memset(ctmp2, 0, 32);\n     ctmp2[31] = 1;\n     CHECK(secp256k1_ec_seckey_tweak_add(ctx, ctmp2, ctmp) == 0);\n-    CHECK(memcmp(zeros, ctmp2, 32) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros, ctmp2, 32) == 0);\n     ctmp2[31] = 1;\n     CHECK(secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, ctmp2) == 0);\n-    CHECK(memcmp(&pubkey, zeros, sizeof(pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(pubkey)) == 0);\n     memcpy(&pubkey, &pubkey2, sizeof(pubkey));\n     /* Tweak computation wraps and results in a key of 1. */\n     ctmp2[31] = 2;\n     CHECK(secp256k1_ec_seckey_tweak_add(ctx, ctmp2, ctmp) == 1);\n-    CHECK(memcmp(ctmp2, zeros, 31) == 0 && ctmp2[31] == 1);\n+    CHECK(secp256k1_memcmp_var(ctmp2, zeros, 31) == 0 && ctmp2[31] == 1);\n     ctmp2[31] = 2;\n     CHECK(secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, ctmp2) == 1);\n     ctmp2[31] = 1;\n     CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey2, ctmp2) == 1);\n-    CHECK(memcmp(&pubkey, &pubkey2, sizeof(pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, &pubkey2, sizeof(pubkey)) == 0);\n     /* Tweak mul * 2 = 1+1. */\n     CHECK(secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, ctmp2) == 1);\n     ctmp2[31] = 2;\n     CHECK(secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey2, ctmp2) == 1);\n-    CHECK(memcmp(&pubkey, &pubkey2, sizeof(pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, &pubkey2, sizeof(pubkey)) == 0);\n     /* Test argument errors. */\n     ecount = 0;\n     secp256k1_context_set_illegal_callback(ctx, counting_illegal_callback_fn, &ecount);\n@@ -4131,12 +4215,12 @@ void run_eckey_edge_case_test(void) {\n     memset(&pubkey, 0, 32);\n     CHECK(secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, ctmp2) == 0);\n     CHECK(ecount == 1);\n-    CHECK(memcmp(&pubkey, zeros, sizeof(pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(pubkey)) == 0);\n     memcpy(&pubkey, &pubkey2, sizeof(pubkey));\n     memset(&pubkey2, 0, 32);\n     CHECK(secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey2, ctmp2) == 0);\n     CHECK(ecount == 2);\n-    CHECK(memcmp(&pubkey2, zeros, sizeof(pubkey2)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey2, zeros, sizeof(pubkey2)) == 0);\n     /* Plain argument errors. */\n     ecount = 0;\n     CHECK(secp256k1_ec_seckey_verify(ctx, ctmp) == 1);\n@@ -4176,7 +4260,7 @@ void run_eckey_edge_case_test(void) {\n     memset(&pubkey, 1, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey, NULL) == 0);\n     CHECK(ecount == 2);\n-    CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n     /* secp256k1_ec_pubkey_combine tests. */\n     ecount = 0;\n     pubkeys[0] = &pubkey_one;\n@@ -4187,56 +4271,56 @@ void run_eckey_edge_case_test(void) {\n     VG_UNDEF(&pubkey, sizeof(secp256k1_pubkey));\n     CHECK(secp256k1_ec_pubkey_combine(ctx, &pubkey, pubkeys, 0) == 0);\n     VG_CHECK(&pubkey, sizeof(secp256k1_pubkey));\n-    CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n     CHECK(ecount == 1);\n     CHECK(secp256k1_ec_pubkey_combine(ctx, NULL, pubkeys, 1) == 0);\n-    CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n     CHECK(ecount == 2);\n     memset(&pubkey, 255, sizeof(secp256k1_pubkey));\n     VG_UNDEF(&pubkey, sizeof(secp256k1_pubkey));\n     CHECK(secp256k1_ec_pubkey_combine(ctx, &pubkey, NULL, 1) == 0);\n     VG_CHECK(&pubkey, sizeof(secp256k1_pubkey));\n-    CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n     CHECK(ecount == 3);\n     pubkeys[0] = &pubkey_negone;\n     memset(&pubkey, 255, sizeof(secp256k1_pubkey));\n     VG_UNDEF(&pubkey, sizeof(secp256k1_pubkey));\n     CHECK(secp256k1_ec_pubkey_combine(ctx, &pubkey, pubkeys, 1) == 1);\n     VG_CHECK(&pubkey, sizeof(secp256k1_pubkey));\n-    CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) > 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(secp256k1_pubkey)) > 0);\n     CHECK(ecount == 3);\n     len = 33;\n     CHECK(secp256k1_ec_pubkey_serialize(ctx, ctmp, &len, &pubkey, SECP256K1_EC_COMPRESSED) == 1);\n     CHECK(secp256k1_ec_pubkey_serialize(ctx, ctmp2, &len, &pubkey_negone, SECP256K1_EC_COMPRESSED) == 1);\n-    CHECK(memcmp(ctmp, ctmp2, 33) == 0);\n+    CHECK(secp256k1_memcmp_var(ctmp, ctmp2, 33) == 0);\n     /* Result is infinity. */\n     pubkeys[0] = &pubkey_one;\n     pubkeys[1] = &pubkey_negone;\n     memset(&pubkey, 255, sizeof(secp256k1_pubkey));\n     VG_UNDEF(&pubkey, sizeof(secp256k1_pubkey));\n     CHECK(secp256k1_ec_pubkey_combine(ctx, &pubkey, pubkeys, 2) == 0);\n     VG_CHECK(&pubkey, sizeof(secp256k1_pubkey));\n-    CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n     CHECK(ecount == 3);\n     /* Passes through infinity but comes out one. */\n     pubkeys[2] = &pubkey_one;\n     memset(&pubkey, 255, sizeof(secp256k1_pubkey));\n     VG_UNDEF(&pubkey, sizeof(secp256k1_pubkey));\n     CHECK(secp256k1_ec_pubkey_combine(ctx, &pubkey, pubkeys, 3) == 1);\n     VG_CHECK(&pubkey, sizeof(secp256k1_pubkey));\n-    CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) > 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(secp256k1_pubkey)) > 0);\n     CHECK(ecount == 3);\n     len = 33;\n     CHECK(secp256k1_ec_pubkey_serialize(ctx, ctmp, &len, &pubkey, SECP256K1_EC_COMPRESSED) == 1);\n     CHECK(secp256k1_ec_pubkey_serialize(ctx, ctmp2, &len, &pubkey_one, SECP256K1_EC_COMPRESSED) == 1);\n-    CHECK(memcmp(ctmp, ctmp2, 33) == 0);\n+    CHECK(secp256k1_memcmp_var(ctmp, ctmp2, 33) == 0);\n     /* Adds to two. */\n     pubkeys[1] = &pubkey_one;\n     memset(&pubkey, 255, sizeof(secp256k1_pubkey));\n     VG_UNDEF(&pubkey, sizeof(secp256k1_pubkey));\n     CHECK(secp256k1_ec_pubkey_combine(ctx, &pubkey, pubkeys, 2) == 1);\n     VG_CHECK(&pubkey, sizeof(secp256k1_pubkey));\n-    CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) > 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(secp256k1_pubkey)) > 0);\n     CHECK(ecount == 3);\n     secp256k1_context_set_illegal_callback(ctx, NULL, NULL);\n }\n@@ -4250,21 +4334,21 @@ void run_eckey_negate_test(void) {\n \n     /* Verify negation changes the key and changes it back */\n     CHECK(secp256k1_ec_seckey_negate(ctx, seckey) == 1);\n-    CHECK(memcmp(seckey, seckey_tmp, 32) != 0);\n+    CHECK(secp256k1_memcmp_var(seckey, seckey_tmp, 32) != 0);\n     CHECK(secp256k1_ec_seckey_negate(ctx, seckey) == 1);\n-    CHECK(memcmp(seckey, seckey_tmp, 32) == 0);\n+    CHECK(secp256k1_memcmp_var(seckey, seckey_tmp, 32) == 0);\n \n     /* Check that privkey alias gives same result */\n     CHECK(secp256k1_ec_seckey_negate(ctx, seckey) == 1);\n     CHECK(secp256k1_ec_privkey_negate(ctx, seckey_tmp) == 1);\n-    CHECK(memcmp(seckey, seckey_tmp, 32) == 0);\n+    CHECK(secp256k1_memcmp_var(seckey, seckey_tmp, 32) == 0);\n \n     /* Negating all 0s fails */\n     memset(seckey, 0, 32);\n     memset(seckey_tmp, 0, 32);\n     CHECK(secp256k1_ec_seckey_negate(ctx, seckey) == 0);\n     /* Check that seckey is not modified */\n-    CHECK(memcmp(seckey, seckey_tmp, 32) == 0);\n+    CHECK(secp256k1_memcmp_var(seckey, seckey_tmp, 32) == 0);\n \n     /* Negating an overflowing seckey fails and the seckey is zeroed. In this\n      * test, the seckey has 16 random bytes to ensure that ec_seckey_negate\n@@ -4273,7 +4357,7 @@ void run_eckey_negate_test(void) {\n     memset(seckey, 0xFF, 16);\n     memset(seckey_tmp, 0, 32);\n     CHECK(secp256k1_ec_seckey_negate(ctx, seckey) == 0);\n-    CHECK(memcmp(seckey, seckey_tmp, 32) == 0);\n+    CHECK(secp256k1_memcmp_var(seckey, seckey_tmp, 32) == 0);\n }\n \n void random_sign(secp256k1_scalar *sigr, secp256k1_scalar *sigs, const secp256k1_scalar *key, const secp256k1_scalar *msg, int *recid) {\n@@ -4295,7 +4379,7 @@ void test_ecdsa_sign_verify(void) {\n     random_scalar_order_test(&key);\n     secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pubj, &key);\n     secp256k1_ge_set_gej(&pub, &pubj);\n-    getrec = secp256k1_rand_bits(1);\n+    getrec = secp256k1_testrand_bits(1);\n     random_sign(&sigr, &sigs, &key, &msg, getrec?&recid:NULL);\n     if (getrec) {\n         CHECK(recid >= 0 && recid < 4);\n@@ -4362,7 +4446,7 @@ static int nonce_function_test_retry(unsigned char *nonce32, const unsigned char\n \n int is_empty_signature(const secp256k1_ecdsa_signature *sig) {\n     static const unsigned char res[sizeof(secp256k1_ecdsa_signature)] = {0};\n-    return memcmp(sig, res, sizeof(secp256k1_ecdsa_signature)) == 0;\n+    return secp256k1_memcmp_var(sig, res, sizeof(secp256k1_ecdsa_signature)) == 0;\n }\n \n void test_ecdsa_end_to_end(void) {\n@@ -4395,31 +4479,31 @@ void test_ecdsa_end_to_end(void) {\n     CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey, privkey) == 1);\n \n     /* Verify exporting and importing public key. */\n-    CHECK(secp256k1_ec_pubkey_serialize(ctx, pubkeyc, &pubkeyclen, &pubkey, secp256k1_rand_bits(1) == 1 ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED));\n+    CHECK(secp256k1_ec_pubkey_serialize(ctx, pubkeyc, &pubkeyclen, &pubkey, secp256k1_testrand_bits(1) == 1 ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED));\n     memset(&pubkey, 0, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, pubkeyc, pubkeyclen) == 1);\n \n     /* Verify negation changes the key and changes it back */\n     memcpy(&pubkey_tmp, &pubkey, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_negate(ctx, &pubkey_tmp) == 1);\n-    CHECK(memcmp(&pubkey_tmp, &pubkey, sizeof(pubkey)) != 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey_tmp, &pubkey, sizeof(pubkey)) != 0);\n     CHECK(secp256k1_ec_pubkey_negate(ctx, &pubkey_tmp) == 1);\n-    CHECK(memcmp(&pubkey_tmp, &pubkey, sizeof(pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey_tmp, &pubkey, sizeof(pubkey)) == 0);\n \n     /* Verify private key import and export. */\n-    CHECK(ec_privkey_export_der(ctx, seckey, &seckeylen, privkey, secp256k1_rand_bits(1) == 1));\n+    CHECK(ec_privkey_export_der(ctx, seckey, &seckeylen, privkey, secp256k1_testrand_bits(1) == 1));\n     CHECK(ec_privkey_import_der(ctx, privkey2, seckey, seckeylen) == 1);\n-    CHECK(memcmp(privkey, privkey2, 32) == 0);\n+    CHECK(secp256k1_memcmp_var(privkey, privkey2, 32) == 0);\n \n     /* Optionally tweak the keys using addition. */\n-    if (secp256k1_rand_int(3) == 0) {\n+    if (secp256k1_testrand_int(3) == 0) {\n         int ret1;\n         int ret2;\n         int ret3;\n         unsigned char rnd[32];\n         unsigned char privkey_tmp[32];\n         secp256k1_pubkey pubkey2;\n-        secp256k1_rand256_test(rnd);\n+        secp256k1_testrand256_test(rnd);\n         memcpy(privkey_tmp, privkey, 32);\n         ret1 = secp256k1_ec_seckey_tweak_add(ctx, privkey, rnd);\n         ret2 = secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, rnd);\n@@ -4430,20 +4514,20 @@ void test_ecdsa_end_to_end(void) {\n         if (ret1 == 0) {\n             return;\n         }\n-        CHECK(memcmp(privkey, privkey_tmp, 32) == 0);\n+        CHECK(secp256k1_memcmp_var(privkey, privkey_tmp, 32) == 0);\n         CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey2, privkey) == 1);\n-        CHECK(memcmp(&pubkey, &pubkey2, sizeof(pubkey)) == 0);\n+        CHECK(secp256k1_memcmp_var(&pubkey, &pubkey2, sizeof(pubkey)) == 0);\n     }\n \n     /* Optionally tweak the keys using multiplication. */\n-    if (secp256k1_rand_int(3) == 0) {\n+    if (secp256k1_testrand_int(3) == 0) {\n         int ret1;\n         int ret2;\n         int ret3;\n         unsigned char rnd[32];\n         unsigned char privkey_tmp[32];\n         secp256k1_pubkey pubkey2;\n-        secp256k1_rand256_test(rnd);\n+        secp256k1_testrand256_test(rnd);\n         memcpy(privkey_tmp, privkey, 32);\n         ret1 = secp256k1_ec_seckey_tweak_mul(ctx, privkey, rnd);\n         ret2 = secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, rnd);\n@@ -4454,9 +4538,9 @@ void test_ecdsa_end_to_end(void) {\n         if (ret1 == 0) {\n             return;\n         }\n-        CHECK(memcmp(privkey, privkey_tmp, 32) == 0);\n+        CHECK(secp256k1_memcmp_var(privkey, privkey_tmp, 32) == 0);\n         CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey2, privkey) == 1);\n-        CHECK(memcmp(&pubkey, &pubkey2, sizeof(pubkey)) == 0);\n+        CHECK(secp256k1_memcmp_var(&pubkey, &pubkey2, sizeof(pubkey)) == 0);\n     }\n \n     /* Sign. */\n@@ -4468,13 +4552,13 @@ void test_ecdsa_end_to_end(void) {\n     extra[31] = 0;\n     extra[0] = 1;\n     CHECK(secp256k1_ecdsa_sign(ctx, &signature[3], message, privkey, NULL, extra) == 1);\n-    CHECK(memcmp(&signature[0], &signature[4], sizeof(signature[0])) == 0);\n-    CHECK(memcmp(&signature[0], &signature[1], sizeof(signature[0])) != 0);\n-    CHECK(memcmp(&signature[0], &signature[2], sizeof(signature[0])) != 0);\n-    CHECK(memcmp(&signature[0], &signature[3], sizeof(signature[0])) != 0);\n-    CHECK(memcmp(&signature[1], &signature[2], sizeof(signature[0])) != 0);\n-    CHECK(memcmp(&signature[1], &signature[3], sizeof(signature[0])) != 0);\n-    CHECK(memcmp(&signature[2], &signature[3], sizeof(signature[0])) != 0);\n+    CHECK(secp256k1_memcmp_var(&signature[0], &signature[4], sizeof(signature[0])) == 0);\n+    CHECK(secp256k1_memcmp_var(&signature[0], &signature[1], sizeof(signature[0])) != 0);\n+    CHECK(secp256k1_memcmp_var(&signature[0], &signature[2], sizeof(signature[0])) != 0);\n+    CHECK(secp256k1_memcmp_var(&signature[0], &signature[3], sizeof(signature[0])) != 0);\n+    CHECK(secp256k1_memcmp_var(&signature[1], &signature[2], sizeof(signature[0])) != 0);\n+    CHECK(secp256k1_memcmp_var(&signature[1], &signature[3], sizeof(signature[0])) != 0);\n+    CHECK(secp256k1_memcmp_var(&signature[2], &signature[3], sizeof(signature[0])) != 0);\n     /* Verify. */\n     CHECK(secp256k1_ecdsa_verify(ctx, &signature[0], message, &pubkey) == 1);\n     CHECK(secp256k1_ecdsa_verify(ctx, &signature[1], message, &pubkey) == 1);\n@@ -4495,7 +4579,7 @@ void test_ecdsa_end_to_end(void) {\n     secp256k1_ecdsa_signature_save(&signature[5], &r, &s);\n     CHECK(!secp256k1_ecdsa_signature_normalize(ctx, NULL, &signature[5]));\n     CHECK(secp256k1_ecdsa_verify(ctx, &signature[5], message, &pubkey) == 1);\n-    CHECK(memcmp(&signature[5], &signature[0], 64) == 0);\n+    CHECK(secp256k1_memcmp_var(&signature[5], &signature[0], 64) == 0);\n \n     /* Serialize/parse DER and verify again */\n     CHECK(secp256k1_ecdsa_signature_serialize_der(ctx, sig, &siglen, &signature[0]) == 1);\n@@ -4505,7 +4589,7 @@ void test_ecdsa_end_to_end(void) {\n     /* Serialize/destroy/parse DER and verify again. */\n     siglen = 74;\n     CHECK(secp256k1_ecdsa_signature_serialize_der(ctx, sig, &siglen, &signature[0]) == 1);\n-    sig[secp256k1_rand_int(siglen)] += 1 + secp256k1_rand_int(255);\n+    sig[secp256k1_testrand_int(siglen)] += 1 + secp256k1_testrand_int(255);\n     CHECK(secp256k1_ecdsa_signature_parse_der(ctx, &signature[0], sig, siglen) == 0 ||\n           secp256k1_ecdsa_verify(ctx, &signature[0], message, &pubkey) == 0);\n }\n@@ -4515,23 +4599,23 @@ void test_random_pubkeys(void) {\n     secp256k1_ge elem2;\n     unsigned char in[65];\n     /* Generate some randomly sized pubkeys. */\n-    size_t len = secp256k1_rand_bits(2) == 0 ? 65 : 33;\n-    if (secp256k1_rand_bits(2) == 0) {\n-        len = secp256k1_rand_bits(6);\n+    size_t len = secp256k1_testrand_bits(2) == 0 ? 65 : 33;\n+    if (secp256k1_testrand_bits(2) == 0) {\n+        len = secp256k1_testrand_bits(6);\n     }\n     if (len == 65) {\n-      in[0] = secp256k1_rand_bits(1) ? 4 : (secp256k1_rand_bits(1) ? 6 : 7);\n+      in[0] = secp256k1_testrand_bits(1) ? 4 : (secp256k1_testrand_bits(1) ? 6 : 7);\n     } else {\n-      in[0] = secp256k1_rand_bits(1) ? 2 : 3;\n+      in[0] = secp256k1_testrand_bits(1) ? 2 : 3;\n     }\n-    if (secp256k1_rand_bits(3) == 0) {\n-        in[0] = secp256k1_rand_bits(8);\n+    if (secp256k1_testrand_bits(3) == 0) {\n+        in[0] = secp256k1_testrand_bits(8);\n     }\n     if (len > 1) {\n-        secp256k1_rand256(&in[1]);\n+        secp256k1_testrand256(&in[1]);\n     }\n     if (len > 33) {\n-        secp256k1_rand256(&in[33]);\n+        secp256k1_testrand256(&in[33]);\n     }\n     if (secp256k1_eckey_pubkey_parse(&elem, in, len)) {\n         unsigned char out[65];\n@@ -4542,7 +4626,7 @@ void test_random_pubkeys(void) {\n         /* If the pubkey can be parsed, it should round-trip... */\n         CHECK(secp256k1_eckey_pubkey_serialize(&elem, out, &size, len == 33));\n         CHECK(size == len);\n-        CHECK(memcmp(&in[1], &out[1], len-1) == 0);\n+        CHECK(secp256k1_memcmp_var(&in[1], &out[1], len-1) == 0);\n         /* ... except for the type of hybrid inputs. */\n         if ((in[0] != 6) && (in[0] != 7)) {\n             CHECK(in[0] == out[0]);\n@@ -4553,7 +4637,7 @@ void test_random_pubkeys(void) {\n         CHECK(secp256k1_eckey_pubkey_parse(&elem2, in, size));\n         ge_equals_ge(&elem,&elem2);\n         /* Check that the X9.62 hybrid type is checked. */\n-        in[0] = secp256k1_rand_bits(1) ? 6 : 7;\n+        in[0] = secp256k1_testrand_bits(1) ? 6 : 7;\n         res = secp256k1_eckey_pubkey_parse(&elem2, in, size);\n         if (firstb == 2 || firstb == 3) {\n             if (in[0] == firstb + 4) {\n@@ -4565,7 +4649,7 @@ void test_random_pubkeys(void) {\n         if (res) {\n             ge_equals_ge(&elem,&elem2);\n             CHECK(secp256k1_eckey_pubkey_serialize(&elem, out, &size, 0));\n-            CHECK(memcmp(&in[1], &out[1], 64) == 0);\n+            CHECK(secp256k1_memcmp_var(&in[1], &out[1], 64) == 0);\n         }\n     }\n }\n@@ -4621,21 +4705,21 @@ int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_\n     parsed_der = secp256k1_ecdsa_signature_parse_der(ctx, &sig_der, sig, siglen);\n     if (parsed_der) {\n         ret |= (!secp256k1_ecdsa_signature_serialize_compact(ctx, compact_der, &sig_der)) << 0;\n-        valid_der = (memcmp(compact_der, zeroes, 32) != 0) && (memcmp(compact_der + 32, zeroes, 32) != 0);\n+        valid_der = (secp256k1_memcmp_var(compact_der, zeroes, 32) != 0) && (secp256k1_memcmp_var(compact_der + 32, zeroes, 32) != 0);\n     }\n     if (valid_der) {\n         ret |= (!secp256k1_ecdsa_signature_serialize_der(ctx, roundtrip_der, &len_der, &sig_der)) << 1;\n-        roundtrips_der = (len_der == siglen) && memcmp(roundtrip_der, sig, siglen) == 0;\n+        roundtrips_der = (len_der == siglen) && secp256k1_memcmp_var(roundtrip_der, sig, siglen) == 0;\n     }\n \n     parsed_der_lax = ecdsa_signature_parse_der_lax(ctx, &sig_der_lax, sig, siglen);\n     if (parsed_der_lax) {\n         ret |= (!secp256k1_ecdsa_signature_serialize_compact(ctx, compact_der_lax, &sig_der_lax)) << 10;\n-        valid_der_lax = (memcmp(compact_der_lax, zeroes, 32) != 0) && (memcmp(compact_der_lax + 32, zeroes, 32) != 0);\n+        valid_der_lax = (secp256k1_memcmp_var(compact_der_lax, zeroes, 32) != 0) && (secp256k1_memcmp_var(compact_der_lax + 32, zeroes, 32) != 0);\n     }\n     if (valid_der_lax) {\n         ret |= (!secp256k1_ecdsa_signature_serialize_der(ctx, roundtrip_der_lax, &len_der_lax, &sig_der_lax)) << 11;\n-        roundtrips_der_lax = (len_der_lax == siglen) && memcmp(roundtrip_der_lax, sig, siglen) == 0;\n+        roundtrips_der_lax = (len_der_lax == siglen) && secp256k1_memcmp_var(roundtrip_der_lax, sig, siglen) == 0;\n     }\n \n     if (certainly_der) {\n@@ -4651,7 +4735,7 @@ int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_\n     if (valid_der) {\n         ret |= (!roundtrips_der_lax) << 12;\n         ret |= (len_der != len_der_lax) << 13;\n-        ret |= ((len_der != len_der_lax) || (memcmp(roundtrip_der_lax, roundtrip_der, len_der) != 0)) << 14;\n+        ret |= ((len_der != len_der_lax) || (secp256k1_memcmp_var(roundtrip_der_lax, roundtrip_der, len_der) != 0)) << 14;\n     }\n     ret |= (roundtrips_der != roundtrips_der_lax) << 15;\n     if (parsed_der) {\n@@ -4668,19 +4752,19 @@ int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_\n         if (valid_openssl) {\n             unsigned char tmp[32] = {0};\n             BN_bn2bin(r, tmp + 32 - BN_num_bytes(r));\n-            valid_openssl = memcmp(tmp, max_scalar, 32) < 0;\n+            valid_openssl = secp256k1_memcmp_var(tmp, max_scalar, 32) < 0;\n         }\n         if (valid_openssl) {\n             unsigned char tmp[32] = {0};\n             BN_bn2bin(s, tmp + 32 - BN_num_bytes(s));\n-            valid_openssl = memcmp(tmp, max_scalar, 32) < 0;\n+            valid_openssl = secp256k1_memcmp_var(tmp, max_scalar, 32) < 0;\n         }\n     }\n     len_openssl = i2d_ECDSA_SIG(sig_openssl, NULL);\n     if (len_openssl <= 2048) {\n         unsigned char *ptr = roundtrip_openssl;\n         CHECK(i2d_ECDSA_SIG(sig_openssl, &ptr) == len_openssl);\n-        roundtrips_openssl = valid_openssl && ((size_t)len_openssl == siglen) && (memcmp(roundtrip_openssl, sig, siglen) == 0);\n+        roundtrips_openssl = valid_openssl && ((size_t)len_openssl == siglen) && (secp256k1_memcmp_var(roundtrip_openssl, sig, siglen) == 0);\n     } else {\n         len_openssl = 0;\n     }\n@@ -4692,7 +4776,7 @@ int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_\n     ret |= (roundtrips_der != roundtrips_openssl) << 7;\n     if (roundtrips_openssl) {\n         ret |= (len_der != (size_t)len_openssl) << 8;\n-        ret |= ((len_der != (size_t)len_openssl) || (memcmp(roundtrip_der, roundtrip_openssl, len_der) != 0)) << 9;\n+        ret |= ((len_der != (size_t)len_openssl) || (secp256k1_memcmp_var(roundtrip_der, roundtrip_openssl, len_der) != 0)) << 9;\n     }\n #endif\n     return ret;\n@@ -4712,27 +4796,27 @@ static void assign_big_endian(unsigned char *ptr, size_t ptrlen, uint32_t val) {\n \n static void damage_array(unsigned char *sig, size_t *len) {\n     int pos;\n-    int action = secp256k1_rand_bits(3);\n+    int action = secp256k1_testrand_bits(3);\n     if (action < 1 && *len > 3) {\n         /* Delete a byte. */\n-        pos = secp256k1_rand_int(*len);\n+        pos = secp256k1_testrand_int(*len);\n         memmove(sig + pos, sig + pos + 1, *len - pos - 1);\n         (*len)--;\n         return;\n     } else if (action < 2 && *len < 2048) {\n         /* Insert a byte. */\n-        pos = secp256k1_rand_int(1 + *len);\n+        pos = secp256k1_testrand_int(1 + *len);\n         memmove(sig + pos + 1, sig + pos, *len - pos);\n-        sig[pos] = secp256k1_rand_bits(8);\n+        sig[pos] = secp256k1_testrand_bits(8);\n         (*len)++;\n         return;\n     } else if (action < 4) {\n         /* Modify a byte. */\n-        sig[secp256k1_rand_int(*len)] += 1 + secp256k1_rand_int(255);\n+        sig[secp256k1_testrand_int(*len)] += 1 + secp256k1_testrand_int(255);\n         return;\n     } else { /* action < 8 */\n         /* Modify a bit. */\n-        sig[secp256k1_rand_int(*len)] ^= 1 << secp256k1_rand_bits(3);\n+        sig[secp256k1_testrand_int(*len)] ^= 1 << secp256k1_testrand_bits(3);\n         return;\n     }\n }\n@@ -4745,23 +4829,23 @@ static void random_ber_signature(unsigned char *sig, size_t *len, int* certainly\n     int n;\n \n     *len = 0;\n-    der = secp256k1_rand_bits(2) == 0;\n+    der = secp256k1_testrand_bits(2) == 0;\n     *certainly_der = der;\n     *certainly_not_der = 0;\n-    indet = der ? 0 : secp256k1_rand_int(10) == 0;\n+    indet = der ? 0 : secp256k1_testrand_int(10) == 0;\n \n     for (n = 0; n < 2; n++) {\n         /* We generate two classes of numbers: nlow==1 \"low\" ones (up to 32 bytes), nlow==0 \"high\" ones (32 bytes with 129 top bits set, or larger than 32 bytes) */\n-        nlow[n] = der ? 1 : (secp256k1_rand_bits(3) != 0);\n+        nlow[n] = der ? 1 : (secp256k1_testrand_bits(3) != 0);\n         /* The length of the number in bytes (the first byte of which will always be nonzero) */\n-        nlen[n] = nlow[n] ? secp256k1_rand_int(33) : 32 + secp256k1_rand_int(200) * secp256k1_rand_int(8) / 8;\n+        nlen[n] = nlow[n] ? secp256k1_testrand_int(33) : 32 + secp256k1_testrand_int(200) * secp256k1_testrand_int(8) / 8;\n         CHECK(nlen[n] <= 232);\n         /* The top bit of the number. */\n-        nhbit[n] = (nlow[n] == 0 && nlen[n] == 32) ? 1 : (nlen[n] == 0 ? 0 : secp256k1_rand_bits(1));\n+        nhbit[n] = (nlow[n] == 0 && nlen[n] == 32) ? 1 : (nlen[n] == 0 ? 0 : secp256k1_testrand_bits(1));\n         /* The top byte of the number (after the potential hardcoded 16 0xFF characters for \"high\" 32 bytes numbers) */\n-        nhbyte[n] = nlen[n] == 0 ? 0 : (nhbit[n] ? 128 + secp256k1_rand_bits(7) : 1 + secp256k1_rand_int(127));\n+        nhbyte[n] = nlen[n] == 0 ? 0 : (nhbit[n] ? 128 + secp256k1_testrand_bits(7) : 1 + secp256k1_testrand_int(127));\n         /* The number of zero bytes in front of the number (which is 0 or 1 in case of DER, otherwise we extend up to 300 bytes) */\n-        nzlen[n] = der ? ((nlen[n] == 0 || nhbit[n]) ? 1 : 0) : (nlow[n] ? secp256k1_rand_int(3) : secp256k1_rand_int(300 - nlen[n]) * secp256k1_rand_int(8) / 8);\n+        nzlen[n] = der ? ((nlen[n] == 0 || nhbit[n]) ? 1 : 0) : (nlow[n] ? secp256k1_testrand_int(3) : secp256k1_testrand_int(300 - nlen[n]) * secp256k1_testrand_int(8) / 8);\n         if (nzlen[n] > ((nlen[n] == 0 || nhbit[n]) ? 1 : 0)) {\n             *certainly_not_der = 1;\n         }\n@@ -4770,7 +4854,7 @@ static void random_ber_signature(unsigned char *sig, size_t *len, int* certainly\n         nlenlen[n] = nlen[n] + nzlen[n] < 128 ? 0 : (nlen[n] + nzlen[n] < 256 ? 1 : 2);\n         if (!der) {\n             /* nlenlen[n] max 127 bytes */\n-            int add = secp256k1_rand_int(127 - nlenlen[n]) * secp256k1_rand_int(16) * secp256k1_rand_int(16) / 256;\n+            int add = secp256k1_testrand_int(127 - nlenlen[n]) * secp256k1_testrand_int(16) * secp256k1_testrand_int(16) / 256;\n             nlenlen[n] += add;\n             if (add != 0) {\n                 *certainly_not_der = 1;\n@@ -4784,15 +4868,15 @@ static void random_ber_signature(unsigned char *sig, size_t *len, int* certainly\n     CHECK(tlen <= 856);\n \n     /* The length of the garbage inside the tuple. */\n-    elen = (der || indet) ? 0 : secp256k1_rand_int(980 - tlen) * secp256k1_rand_int(8) / 8;\n+    elen = (der || indet) ? 0 : secp256k1_testrand_int(980 - tlen) * secp256k1_testrand_int(8) / 8;\n     if (elen != 0) {\n         *certainly_not_der = 1;\n     }\n     tlen += elen;\n     CHECK(tlen <= 980);\n \n     /* The length of the garbage after the end of the tuple. */\n-    glen = der ? 0 : secp256k1_rand_int(990 - tlen) * secp256k1_rand_int(8) / 8;\n+    glen = der ? 0 : secp256k1_testrand_int(990 - tlen) * secp256k1_testrand_int(8) / 8;\n     if (glen != 0) {\n         *certainly_not_der = 1;\n     }\n@@ -4807,7 +4891,7 @@ static void random_ber_signature(unsigned char *sig, size_t *len, int* certainly\n     } else {\n         int tlenlen = tlen < 128 ? 0 : (tlen < 256 ? 1 : 2);\n         if (!der) {\n-            int add = secp256k1_rand_int(127 - tlenlen) * secp256k1_rand_int(16) * secp256k1_rand_int(16) / 256;\n+            int add = secp256k1_testrand_int(127 - tlenlen) * secp256k1_testrand_int(16) * secp256k1_testrand_int(16) / 256;\n             tlenlen += add;\n             if (add != 0) {\n                 *certainly_not_der = 1;\n@@ -4858,13 +4942,13 @@ static void random_ber_signature(unsigned char *sig, size_t *len, int* certainly\n             nlen[n]--;\n         }\n         /* Generate remaining random bytes of number */\n-        secp256k1_rand_bytes_test(sig + *len, nlen[n]);\n+        secp256k1_testrand_bytes_test(sig + *len, nlen[n]);\n         *len += nlen[n];\n         nlen[n] = 0;\n     }\n \n     /* Generate random garbage inside tuple. */\n-    secp256k1_rand_bytes_test(sig + *len, elen);\n+    secp256k1_testrand_bytes_test(sig + *len, elen);\n     *len += elen;\n \n     /* Generate end-of-contents bytes. */\n@@ -4876,7 +4960,7 @@ static void random_ber_signature(unsigned char *sig, size_t *len, int* certainly\n     CHECK(tlen + glen <= 1121);\n \n     /* Generate random garbage outside tuple. */\n-    secp256k1_rand_bytes_test(sig + *len, glen);\n+    secp256k1_testrand_bytes_test(sig + *len, glen);\n     *len += glen;\n     tlen += glen;\n     CHECK(tlen <= 1121);\n@@ -5208,11 +5292,11 @@ void test_ecdsa_edge_cases(void) {\n         CHECK(!is_empty_signature(&sig));\n         CHECK(secp256k1_ecdsa_sign(ctx, &sig2, msg, key, nonce_function_rfc6979, extra) == 1);\n         CHECK(!is_empty_signature(&sig2));\n-        CHECK(memcmp(&sig, &sig2, sizeof(sig)) == 0);\n+        CHECK(secp256k1_memcmp_var(&sig, &sig2, sizeof(sig)) == 0);\n         /* The default nonce function is deterministic. */\n         CHECK(secp256k1_ecdsa_sign(ctx, &sig2, msg, key, NULL, extra) == 1);\n         CHECK(!is_empty_signature(&sig2));\n-        CHECK(memcmp(&sig, &sig2, sizeof(sig)) == 0);\n+        CHECK(secp256k1_memcmp_var(&sig, &sig2, sizeof(sig)) == 0);\n         /* The default nonce function changes output with different messages. */\n         for(i = 0; i < 256; i++) {\n             int j;\n@@ -5259,12 +5343,12 @@ void test_ecdsa_edge_cases(void) {\n         VG_CHECK(nonce3,32);\n         CHECK(nonce_function_rfc6979(nonce4, zeros, zeros, zeros, (void *)zeros, 0) == 1);\n         VG_CHECK(nonce4,32);\n-        CHECK(memcmp(nonce, nonce2, 32) != 0);\n-        CHECK(memcmp(nonce, nonce3, 32) != 0);\n-        CHECK(memcmp(nonce, nonce4, 32) != 0);\n-        CHECK(memcmp(nonce2, nonce3, 32) != 0);\n-        CHECK(memcmp(nonce2, nonce4, 32) != 0);\n-        CHECK(memcmp(nonce3, nonce4, 32) != 0);\n+        CHECK(secp256k1_memcmp_var(nonce, nonce2, 32) != 0);\n+        CHECK(secp256k1_memcmp_var(nonce, nonce3, 32) != 0);\n+        CHECK(secp256k1_memcmp_var(nonce, nonce4, 32) != 0);\n+        CHECK(secp256k1_memcmp_var(nonce2, nonce3, 32) != 0);\n+        CHECK(secp256k1_memcmp_var(nonce2, nonce4, 32) != 0);\n+        CHECK(secp256k1_memcmp_var(nonce3, nonce4, 32) != 0);\n     }\n \n \n@@ -5293,7 +5377,7 @@ EC_KEY *get_openssl_key(const unsigned char *key32) {\n     unsigned char privkey[300];\n     size_t privkeylen;\n     const unsigned char* pbegin = privkey;\n-    int compr = secp256k1_rand_bits(1);\n+    int compr = secp256k1_testrand_bits(1);\n     EC_KEY *ec_key = EC_KEY_new_by_curve_name(NID_secp256k1);\n     CHECK(ec_privkey_export_der(ctx, privkey, &privkeylen, key32, compr));\n     CHECK(d2i_ECPrivateKey(&ec_key, &pbegin, privkeylen));\n@@ -5314,7 +5398,7 @@ void test_ecdsa_openssl(void) {\n     unsigned char message[32];\n     unsigned char signature[80];\n     unsigned char key32[32];\n-    secp256k1_rand256_test(message);\n+    secp256k1_testrand256_test(message);\n     secp256k1_scalar_set_b32(&msg, message, NULL);\n     random_scalar_order_test(&key);\n     secp256k1_scalar_get_b32(key32, &key);\n@@ -5367,12 +5451,12 @@ void run_memczero_test(void) {\n     /* memczero(..., ..., 0) is a noop. */\n     memcpy(buf2, buf1, sizeof(buf1));\n     memczero(buf1, sizeof(buf1), 0);\n-    CHECK(memcmp(buf1, buf2, sizeof(buf1)) == 0);\n+    CHECK(secp256k1_memcmp_var(buf1, buf2, sizeof(buf1)) == 0);\n \n     /* memczero(..., ..., 1) zeros the buffer. */\n     memset(buf2, 0, sizeof(buf2));\n     memczero(buf1, sizeof(buf1) , 1);\n-    CHECK(memcmp(buf1, buf2, sizeof(buf1)) == 0);\n+    CHECK(secp256k1_memcmp_var(buf1, buf2, sizeof(buf1)) == 0);\n }\n \n void int_cmov_test(void) {\n@@ -5411,23 +5495,23 @@ void fe_cmov_test(void) {\n     secp256k1_fe a = zero;\n \n     secp256k1_fe_cmov(&r, &a, 0);\n-    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &max, sizeof(r)) == 0);\n \n     r = zero; a = max;\n     secp256k1_fe_cmov(&r, &a, 1);\n-    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &max, sizeof(r)) == 0);\n \n     a = zero;\n     secp256k1_fe_cmov(&r, &a, 1);\n-    CHECK(memcmp(&r, &zero, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &zero, sizeof(r)) == 0);\n \n     a = one;\n     secp256k1_fe_cmov(&r, &a, 1);\n-    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &one, sizeof(r)) == 0);\n \n     r = one; a = zero;\n     secp256k1_fe_cmov(&r, &a, 0);\n-    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &one, sizeof(r)) == 0);\n }\n \n void fe_storage_cmov_test(void) {\n@@ -5441,23 +5525,23 @@ void fe_storage_cmov_test(void) {\n     secp256k1_fe_storage a = zero;\n \n     secp256k1_fe_storage_cmov(&r, &a, 0);\n-    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &max, sizeof(r)) == 0);\n \n     r = zero; a = max;\n     secp256k1_fe_storage_cmov(&r, &a, 1);\n-    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &max, sizeof(r)) == 0);\n \n     a = zero;\n     secp256k1_fe_storage_cmov(&r, &a, 1);\n-    CHECK(memcmp(&r, &zero, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &zero, sizeof(r)) == 0);\n \n     a = one;\n     secp256k1_fe_storage_cmov(&r, &a, 1);\n-    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &one, sizeof(r)) == 0);\n \n     r = one; a = zero;\n     secp256k1_fe_storage_cmov(&r, &a, 0);\n-    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &one, sizeof(r)) == 0);\n }\n \n void scalar_cmov_test(void) {\n@@ -5471,23 +5555,23 @@ void scalar_cmov_test(void) {\n     secp256k1_scalar a = zero;\n \n     secp256k1_scalar_cmov(&r, &a, 0);\n-    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &max, sizeof(r)) == 0);\n \n     r = zero; a = max;\n     secp256k1_scalar_cmov(&r, &a, 1);\n-    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &max, sizeof(r)) == 0);\n \n     a = zero;\n     secp256k1_scalar_cmov(&r, &a, 1);\n-    CHECK(memcmp(&r, &zero, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &zero, sizeof(r)) == 0);\n \n     a = one;\n     secp256k1_scalar_cmov(&r, &a, 1);\n-    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &one, sizeof(r)) == 0);\n \n     r = one; a = zero;\n     secp256k1_scalar_cmov(&r, &a, 0);\n-    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &one, sizeof(r)) == 0);\n }\n \n void ge_storage_cmov_test(void) {\n@@ -5503,23 +5587,23 @@ void ge_storage_cmov_test(void) {\n     secp256k1_ge_storage a = zero;\n \n     secp256k1_ge_storage_cmov(&r, &a, 0);\n-    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &max, sizeof(r)) == 0);\n \n     r = zero; a = max;\n     secp256k1_ge_storage_cmov(&r, &a, 1);\n-    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &max, sizeof(r)) == 0);\n \n     a = zero;\n     secp256k1_ge_storage_cmov(&r, &a, 1);\n-    CHECK(memcmp(&r, &zero, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &zero, sizeof(r)) == 0);\n \n     a = one;\n     secp256k1_ge_storage_cmov(&r, &a, 1);\n-    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &one, sizeof(r)) == 0);\n \n     r = one; a = zero;\n     secp256k1_ge_storage_cmov(&r, &a, 0);\n-    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &one, sizeof(r)) == 0);\n }\n \n void run_cmov_tests(void) {\n@@ -5531,9 +5615,6 @@ void run_cmov_tests(void) {\n }\n \n int main(int argc, char **argv) {\n-    unsigned char seed16[16] = {0};\n-    unsigned char run32[32] = {0};\n-\n     /* Disable buffering for stdout to improve reliability of getting\n      * diagnostic information. Happens right at the start of main because\n      * setbuf must be used before any other operation on the stream. */\n@@ -5546,52 +5627,20 @@ int main(int argc, char **argv) {\n     if (argc > 1) {\n         count = strtol(argv[1], NULL, 0);\n     }\n+    printf(\"test count = %i\\n\", count);\n \n     /* find random seed */\n-    if (argc > 2) {\n-        int pos = 0;\n-        const char* ch = argv[2];\n-        while (pos < 16 && ch[0] != 0 && ch[1] != 0) {\n-            unsigned short sh;\n-            if ((sscanf(ch, \"%2hx\", &sh)) == 1) {\n-                seed16[pos] = sh;\n-            } else {\n-                break;\n-            }\n-            ch += 2;\n-            pos++;\n-        }\n-    } else {\n-        FILE *frand = fopen(\"/dev/urandom\", \"r\");\n-        if ((frand == NULL) || fread(&seed16, 1, sizeof(seed16), frand) != sizeof(seed16)) {\n-            uint64_t t = time(NULL) * (uint64_t)1337;\n-            fprintf(stderr, \"WARNING: could not read 16 bytes from /dev/urandom; falling back to insecure PRNG\\n\");\n-            seed16[0] ^= t;\n-            seed16[1] ^= t >> 8;\n-            seed16[2] ^= t >> 16;\n-            seed16[3] ^= t >> 24;\n-            seed16[4] ^= t >> 32;\n-            seed16[5] ^= t >> 40;\n-            seed16[6] ^= t >> 48;\n-            seed16[7] ^= t >> 56;\n-        }\n-        if (frand) {\n-            fclose(frand);\n-        }\n-    }\n-    secp256k1_rand_seed(seed16);\n-\n-    printf(\"test count = %i\\n\", count);\n-    printf(\"random seed = %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\", seed16[0], seed16[1], seed16[2], seed16[3], seed16[4], seed16[5], seed16[6], seed16[7], seed16[8], seed16[9], seed16[10], seed16[11], seed16[12], seed16[13], seed16[14], seed16[15]);\n+    secp256k1_testrand_init(argc > 2 ? argv[2] : NULL);\n \n     /* initialize */\n     run_context_tests(0);\n     run_context_tests(1);\n     run_scratch_tests();\n     ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n-    if (secp256k1_rand_bits(1)) {\n-        secp256k1_rand256(run32);\n-        CHECK(secp256k1_context_randomize(ctx, secp256k1_rand_bits(1) ? run32 : NULL));\n+    if (secp256k1_testrand_bits(1)) {\n+        unsigned char rand32[32];\n+        secp256k1_testrand256(rand32);\n+        CHECK(secp256k1_context_randomize(ctx, secp256k1_testrand_bits(1) ? rand32 : NULL));\n     }\n \n     run_rand_bits();\n@@ -5625,6 +5674,7 @@ int main(int argc, char **argv) {\n     /* ecmult tests */\n     run_wnaf();\n     run_point_times_order();\n+    run_ecmult_near_split_bound();\n     run_ecmult_chain();\n     run_ecmult_constants();\n     run_ecmult_gen_blind();\n@@ -5633,9 +5683,7 @@ int main(int argc, char **argv) {\n     run_ec_combine();\n \n     /* endomorphism tests */\n-#ifdef USE_ENDOMORPHISM\n     run_endomorphism_tests();\n-#endif\n \n     /* EC point parser test */\n     run_ec_pubkey_parse_test();\n@@ -5679,8 +5727,7 @@ int main(int argc, char **argv) {\n \n     run_cmov_tests();\n \n-    secp256k1_rand256(run32);\n-    printf(\"random run = %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\", run32[0], run32[1], run32[2], run32[3], run32[4], run32[5], run32[6], run32[7], run32[8], run32[9], run32[10], run32[11], run32[12], run32[13], run32[14], run32[15]);\n+    secp256k1_testrand_finish();\n \n     /* shutdown */\n     secp256k1_context_destroy(ctx);"
      },
      {
        "sha": "f4d5b8e1765b47c046a53516cb5c72ed8fb6f8da",
        "filename": "src/tests_exhaustive.c",
        "status": "modified",
        "additions": 159,
        "deletions": 215,
        "changes": 374,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests_exhaustive.c?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -18,7 +18,6 @@\n #ifndef EXHAUSTIVE_TEST_ORDER\n /* see group_impl.h for allowable values */\n #define EXHAUSTIVE_TEST_ORDER 13\n-#define EXHAUSTIVE_TEST_LAMBDA 9   /* cube root of 1 mod 13 */\n #endif\n \n #include \"include/secp256k1.h\"\n@@ -27,10 +26,7 @@\n #include \"secp256k1.c\"\n #include \"testrand_impl.h\"\n \n-#ifdef ENABLE_MODULE_RECOVERY\n-#include \"src/modules/recovery/main_impl.h\"\n-#include \"include/secp256k1_recovery.h\"\n-#endif\n+static int count = 2;\n \n /** stolen from tests.c */\n void ge_equals_ge(const secp256k1_ge *a, const secp256k1_ge *b) {\n@@ -62,14 +58,23 @@ void ge_equals_gej(const secp256k1_ge *a, const secp256k1_gej *b) {\n void random_fe(secp256k1_fe *x) {\n     unsigned char bin[32];\n     do {\n-        secp256k1_rand256(bin);\n+        secp256k1_testrand256(bin);\n         if (secp256k1_fe_set_b32(x, bin)) {\n             return;\n         }\n     } while(1);\n }\n /** END stolen from tests.c */\n \n+static uint32_t num_cores = 1;\n+static uint32_t this_core = 0;\n+\n+SECP256K1_INLINE static int skip_section(uint64_t* iter) {\n+    if (num_cores == 1) return 0;\n+    *iter += 0xe7037ed1a0b428dbULL;\n+    return ((((uint32_t)*iter ^ (*iter >> 32)) * num_cores) >> 32) != this_core;\n+}\n+\n int secp256k1_nonce_function_smallint(unsigned char *nonce32, const unsigned char *msg32,\n                                       const unsigned char *key32, const unsigned char *algo16,\n                                       void *data, unsigned int attempt) {\n@@ -90,91 +95,93 @@ int secp256k1_nonce_function_smallint(unsigned char *nonce32, const unsigned cha\n     return 1;\n }\n \n-#ifdef USE_ENDOMORPHISM\n-void test_exhaustive_endomorphism(const secp256k1_ge *group, int order) {\n+void test_exhaustive_endomorphism(const secp256k1_ge *group) {\n     int i;\n-    for (i = 0; i < order; i++) {\n+    for (i = 0; i < EXHAUSTIVE_TEST_ORDER; i++) {\n         secp256k1_ge res;\n         secp256k1_ge_mul_lambda(&res, &group[i]);\n         ge_equals_ge(&group[i * EXHAUSTIVE_TEST_LAMBDA % EXHAUSTIVE_TEST_ORDER], &res);\n     }\n }\n-#endif\n \n-void test_exhaustive_addition(const secp256k1_ge *group, const secp256k1_gej *groupj, int order) {\n+void test_exhaustive_addition(const secp256k1_ge *group, const secp256k1_gej *groupj) {\n     int i, j;\n+    uint64_t iter = 0;\n \n     /* Sanity-check (and check infinity functions) */\n     CHECK(secp256k1_ge_is_infinity(&group[0]));\n     CHECK(secp256k1_gej_is_infinity(&groupj[0]));\n-    for (i = 1; i < order; i++) {\n+    for (i = 1; i < EXHAUSTIVE_TEST_ORDER; i++) {\n         CHECK(!secp256k1_ge_is_infinity(&group[i]));\n         CHECK(!secp256k1_gej_is_infinity(&groupj[i]));\n     }\n \n     /* Check all addition formulae */\n-    for (j = 0; j < order; j++) {\n+    for (j = 0; j < EXHAUSTIVE_TEST_ORDER; j++) {\n         secp256k1_fe fe_inv;\n+        if (skip_section(&iter)) continue;\n         secp256k1_fe_inv(&fe_inv, &groupj[j].z);\n-        for (i = 0; i < order; i++) {\n+        for (i = 0; i < EXHAUSTIVE_TEST_ORDER; i++) {\n             secp256k1_ge zless_gej;\n             secp256k1_gej tmp;\n             /* add_var */\n             secp256k1_gej_add_var(&tmp, &groupj[i], &groupj[j], NULL);\n-            ge_equals_gej(&group[(i + j) % order], &tmp);\n+            ge_equals_gej(&group[(i + j) % EXHAUSTIVE_TEST_ORDER], &tmp);\n             /* add_ge */\n             if (j > 0) {\n                 secp256k1_gej_add_ge(&tmp, &groupj[i], &group[j]);\n-                ge_equals_gej(&group[(i + j) % order], &tmp);\n+                ge_equals_gej(&group[(i + j) % EXHAUSTIVE_TEST_ORDER], &tmp);\n             }\n             /* add_ge_var */\n             secp256k1_gej_add_ge_var(&tmp, &groupj[i], &group[j], NULL);\n-            ge_equals_gej(&group[(i + j) % order], &tmp);\n+            ge_equals_gej(&group[(i + j) % EXHAUSTIVE_TEST_ORDER], &tmp);\n             /* add_zinv_var */\n             zless_gej.infinity = groupj[j].infinity;\n             zless_gej.x = groupj[j].x;\n             zless_gej.y = groupj[j].y;\n             secp256k1_gej_add_zinv_var(&tmp, &groupj[i], &zless_gej, &fe_inv);\n-            ge_equals_gej(&group[(i + j) % order], &tmp);\n+            ge_equals_gej(&group[(i + j) % EXHAUSTIVE_TEST_ORDER], &tmp);\n         }\n     }\n \n     /* Check doubling */\n-    for (i = 0; i < order; i++) {\n+    for (i = 0; i < EXHAUSTIVE_TEST_ORDER; i++) {\n         secp256k1_gej tmp;\n         secp256k1_gej_double(&tmp, &groupj[i]);\n-        ge_equals_gej(&group[(2 * i) % order], &tmp);\n+        ge_equals_gej(&group[(2 * i) % EXHAUSTIVE_TEST_ORDER], &tmp);\n         secp256k1_gej_double_var(&tmp, &groupj[i], NULL);\n-        ge_equals_gej(&group[(2 * i) % order], &tmp);\n+        ge_equals_gej(&group[(2 * i) % EXHAUSTIVE_TEST_ORDER], &tmp);\n     }\n \n     /* Check negation */\n-    for (i = 1; i < order; i++) {\n+    for (i = 1; i < EXHAUSTIVE_TEST_ORDER; i++) {\n         secp256k1_ge tmp;\n         secp256k1_gej tmpj;\n         secp256k1_ge_neg(&tmp, &group[i]);\n-        ge_equals_ge(&group[order - i], &tmp);\n+        ge_equals_ge(&group[EXHAUSTIVE_TEST_ORDER - i], &tmp);\n         secp256k1_gej_neg(&tmpj, &groupj[i]);\n-        ge_equals_gej(&group[order - i], &tmpj);\n+        ge_equals_gej(&group[EXHAUSTIVE_TEST_ORDER - i], &tmpj);\n     }\n }\n \n-void test_exhaustive_ecmult(const secp256k1_context *ctx, const secp256k1_ge *group, const secp256k1_gej *groupj, int order) {\n+void test_exhaustive_ecmult(const secp256k1_context *ctx, const secp256k1_ge *group, const secp256k1_gej *groupj) {\n     int i, j, r_log;\n-    for (r_log = 1; r_log < order; r_log++) {\n-        for (j = 0; j < order; j++) {\n-            for (i = 0; i < order; i++) {\n+    uint64_t iter = 0;\n+    for (r_log = 1; r_log < EXHAUSTIVE_TEST_ORDER; r_log++) {\n+        for (j = 0; j < EXHAUSTIVE_TEST_ORDER; j++) {\n+            if (skip_section(&iter)) continue;\n+            for (i = 0; i < EXHAUSTIVE_TEST_ORDER; i++) {\n                 secp256k1_gej tmp;\n                 secp256k1_scalar na, ng;\n                 secp256k1_scalar_set_int(&na, i);\n                 secp256k1_scalar_set_int(&ng, j);\n \n                 secp256k1_ecmult(&ctx->ecmult_ctx, &tmp, &groupj[r_log], &na, &ng);\n-                ge_equals_gej(&group[(i * r_log + j) % order], &tmp);\n+                ge_equals_gej(&group[(i * r_log + j) % EXHAUSTIVE_TEST_ORDER], &tmp);\n \n                 if (i > 0) {\n                     secp256k1_ecmult_const(&tmp, &group[i], &ng, 256);\n-                    ge_equals_gej(&group[(i * j) % order], &tmp);\n+                    ge_equals_gej(&group[(i * j) % EXHAUSTIVE_TEST_ORDER], &tmp);\n                 }\n             }\n         }\n@@ -193,14 +200,16 @@ static int ecmult_multi_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t\n     return 1;\n }\n \n-void test_exhaustive_ecmult_multi(const secp256k1_context *ctx, const secp256k1_ge *group, int order) {\n+void test_exhaustive_ecmult_multi(const secp256k1_context *ctx, const secp256k1_ge *group) {\n     int i, j, k, x, y;\n+    uint64_t iter = 0;\n     secp256k1_scratch *scratch = secp256k1_scratch_create(&ctx->error_callback, 4096);\n-    for (i = 0; i < order; i++) {\n-        for (j = 0; j < order; j++) {\n-            for (k = 0; k < order; k++) {\n-                for (x = 0; x < order; x++) {\n-                    for (y = 0; y < order; y++) {\n+    for (i = 0; i < EXHAUSTIVE_TEST_ORDER; i++) {\n+        for (j = 0; j < EXHAUSTIVE_TEST_ORDER; j++) {\n+            for (k = 0; k < EXHAUSTIVE_TEST_ORDER; k++) {\n+                for (x = 0; x < EXHAUSTIVE_TEST_ORDER; x++) {\n+                    if (skip_section(&iter)) continue;\n+                    for (y = 0; y < EXHAUSTIVE_TEST_ORDER; y++) {\n                         secp256k1_gej tmp;\n                         secp256k1_scalar g_sc;\n                         ecmult_multi_data data;\n@@ -212,7 +221,7 @@ void test_exhaustive_ecmult_multi(const secp256k1_context *ctx, const secp256k1_\n                         data.pt[1] = group[y];\n \n                         secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &tmp, &g_sc, ecmult_multi_callback, &data, 2);\n-                        ge_equals_gej(&group[(i * x + j * y + k) % order], &tmp);\n+                        ge_equals_gej(&group[(i * x + j * y + k) % EXHAUSTIVE_TEST_ORDER], &tmp);\n                     }\n                 }\n             }\n@@ -221,22 +230,23 @@ void test_exhaustive_ecmult_multi(const secp256k1_context *ctx, const secp256k1_\n     secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n }\n \n-void r_from_k(secp256k1_scalar *r, const secp256k1_ge *group, int k) {\n+void r_from_k(secp256k1_scalar *r, const secp256k1_ge *group, int k, int* overflow) {\n     secp256k1_fe x;\n     unsigned char x_bin[32];\n     k %= EXHAUSTIVE_TEST_ORDER;\n     x = group[k].x;\n     secp256k1_fe_normalize(&x);\n     secp256k1_fe_get_b32(x_bin, &x);\n-    secp256k1_scalar_set_b32(r, x_bin, NULL);\n+    secp256k1_scalar_set_b32(r, x_bin, overflow);\n }\n \n-void test_exhaustive_verify(const secp256k1_context *ctx, const secp256k1_ge *group, int order) {\n+void test_exhaustive_verify(const secp256k1_context *ctx, const secp256k1_ge *group) {\n     int s, r, msg, key;\n-    for (s = 1; s < order; s++) {\n-        for (r = 1; r < order; r++) {\n-            for (msg = 1; msg < order; msg++) {\n-                for (key = 1; key < order; key++) {\n+    uint64_t iter = 0;\n+    for (s = 1; s < EXHAUSTIVE_TEST_ORDER; s++) {\n+        for (r = 1; r < EXHAUSTIVE_TEST_ORDER; r++) {\n+            for (msg = 1; msg < EXHAUSTIVE_TEST_ORDER; msg++) {\n+                for (key = 1; key < EXHAUSTIVE_TEST_ORDER; key++) {\n                     secp256k1_ge nonconst_ge;\n                     secp256k1_ecdsa_signature sig;\n                     secp256k1_pubkey pk;\n@@ -245,6 +255,8 @@ void test_exhaustive_verify(const secp256k1_context *ctx, const secp256k1_ge *gr\n                     int k, should_verify;\n                     unsigned char msg32[32];\n \n+                    if (skip_section(&iter)) continue;\n+\n                     secp256k1_scalar_set_int(&s_s, s);\n                     secp256k1_scalar_set_int(&r_s, r);\n                     secp256k1_scalar_set_int(&msg_s, msg);\n@@ -254,9 +266,9 @@ void test_exhaustive_verify(const secp256k1_context *ctx, const secp256k1_ge *gr\n                     /* Run through every k value that gives us this r and check that *one* works.\n                      * Note there could be none, there could be multiple, ECDSA is weird. */\n                     should_verify = 0;\n-                    for (k = 0; k < order; k++) {\n+                    for (k = 0; k < EXHAUSTIVE_TEST_ORDER; k++) {\n                         secp256k1_scalar check_x_s;\n-                        r_from_k(&check_x_s, group, k);\n+                        r_from_k(&check_x_s, group, k, NULL);\n                         if (r_s == check_x_s) {\n                             secp256k1_scalar_set_int(&s_times_k_s, k);\n                             secp256k1_scalar_mul(&s_times_k_s, &s_times_k_s, &s_s);\n@@ -281,13 +293,15 @@ void test_exhaustive_verify(const secp256k1_context *ctx, const secp256k1_ge *gr\n     }\n }\n \n-void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *group, int order) {\n+void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *group) {\n     int i, j, k;\n+    uint64_t iter = 0;\n \n     /* Loop */\n-    for (i = 1; i < order; i++) {  /* message */\n-        for (j = 1; j < order; j++) {  /* key */\n-            for (k = 1; k < order; k++) {  /* nonce */\n+    for (i = 1; i < EXHAUSTIVE_TEST_ORDER; i++) {  /* message */\n+        for (j = 1; j < EXHAUSTIVE_TEST_ORDER; j++) {  /* key */\n+            if (skip_section(&iter)) continue;\n+            for (k = 1; k < EXHAUSTIVE_TEST_ORDER; k++) {  /* nonce */\n                 const int starting_k = k;\n                 secp256k1_ecdsa_signature sig;\n                 secp256k1_scalar sk, msg, r, s, expected_r;\n@@ -303,10 +317,10 @@ void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *grou\n                 /* Note that we compute expected_r *after* signing -- this is important\n                  * because our nonce-computing function function might change k during\n                  * signing. */\n-                r_from_k(&expected_r, group, k);\n+                r_from_k(&expected_r, group, k, NULL);\n                 CHECK(r == expected_r);\n-                CHECK((k * s) % order == (i + r * j) % order ||\n-                      (k * (EXHAUSTIVE_TEST_ORDER - s)) % order == (i + r * j) % order);\n+                CHECK((k * s) % EXHAUSTIVE_TEST_ORDER == (i + r * j) % EXHAUSTIVE_TEST_ORDER ||\n+                      (k * (EXHAUSTIVE_TEST_ORDER - s)) % EXHAUSTIVE_TEST_ORDER == (i + r * j) % EXHAUSTIVE_TEST_ORDER);\n \n                 /* Overflow means we've tried every possible nonce */\n                 if (k < starting_k) {\n@@ -327,184 +341,114 @@ void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *grou\n }\n \n #ifdef ENABLE_MODULE_RECOVERY\n-void test_exhaustive_recovery_sign(const secp256k1_context *ctx, const secp256k1_ge *group, int order) {\n-    int i, j, k;\n-\n-    /* Loop */\n-    for (i = 1; i < order; i++) {  /* message */\n-        for (j = 1; j < order; j++) {  /* key */\n-            for (k = 1; k < order; k++) {  /* nonce */\n-                const int starting_k = k;\n-                secp256k1_fe r_dot_y_normalized;\n-                secp256k1_ecdsa_recoverable_signature rsig;\n-                secp256k1_ecdsa_signature sig;\n-                secp256k1_scalar sk, msg, r, s, expected_r;\n-                unsigned char sk32[32], msg32[32];\n-                int expected_recid;\n-                int recid;\n-                secp256k1_scalar_set_int(&msg, i);\n-                secp256k1_scalar_set_int(&sk, j);\n-                secp256k1_scalar_get_b32(sk32, &sk);\n-                secp256k1_scalar_get_b32(msg32, &msg);\n-\n-                secp256k1_ecdsa_sign_recoverable(ctx, &rsig, msg32, sk32, secp256k1_nonce_function_smallint, &k);\n+#include \"src/modules/recovery/tests_exhaustive_impl.h\"\n+#endif\n \n-                /* Check directly */\n-                secp256k1_ecdsa_recoverable_signature_load(ctx, &r, &s, &recid, &rsig);\n-                r_from_k(&expected_r, group, k);\n-                CHECK(r == expected_r);\n-                CHECK((k * s) % order == (i + r * j) % order ||\n-                      (k * (EXHAUSTIVE_TEST_ORDER - s)) % order == (i + r * j) % order);\n-                /* In computing the recid, there is an overflow condition that is disabled in\n-                 * scalar_low_impl.h `secp256k1_scalar_set_b32` because almost every r.y value\n-                 * will exceed the group order, and our signing code always holds out for r\n-                 * values that don't overflow, so with a proper overflow check the tests would\n-                 * loop indefinitely. */\n-                r_dot_y_normalized = group[k].y;\n-                secp256k1_fe_normalize(&r_dot_y_normalized);\n-                /* Also the recovery id is flipped depending if we hit the low-s branch */\n-                if ((k * s) % order == (i + r * j) % order) {\n-                    expected_recid = secp256k1_fe_is_odd(&r_dot_y_normalized) ? 1 : 0;\n-                } else {\n-                    expected_recid = secp256k1_fe_is_odd(&r_dot_y_normalized) ? 0 : 1;\n-                }\n-                CHECK(recid == expected_recid);\n+#ifdef ENABLE_MODULE_EXTRAKEYS\n+#include \"src/modules/extrakeys/tests_exhaustive_impl.h\"\n+#endif\n \n-                /* Convert to a standard sig then check */\n-                secp256k1_ecdsa_recoverable_signature_convert(ctx, &sig, &rsig);\n-                secp256k1_ecdsa_signature_load(ctx, &r, &s, &sig);\n-                /* Note that we compute expected_r *after* signing -- this is important\n-                 * because our nonce-computing function function might change k during\n-                 * signing. */\n-                r_from_k(&expected_r, group, k);\n-                CHECK(r == expected_r);\n-                CHECK((k * s) % order == (i + r * j) % order ||\n-                      (k * (EXHAUSTIVE_TEST_ORDER - s)) % order == (i + r * j) % order);\n+#ifdef ENABLE_MODULE_SCHNORRSIG\n+#include \"src/modules/schnorrsig/tests_exhaustive_impl.h\"\n+#endif\n \n-                /* Overflow means we've tried every possible nonce */\n-                if (k < starting_k) {\n-                    break;\n-                }\n-            }\n+int main(int argc, char** argv) {\n+    int i;\n+    secp256k1_gej groupj[EXHAUSTIVE_TEST_ORDER];\n+    secp256k1_ge group[EXHAUSTIVE_TEST_ORDER];\n+    unsigned char rand32[32];\n+    secp256k1_context *ctx;\n+\n+    /* Disable buffering for stdout to improve reliability of getting\n+     * diagnostic information. Happens right at the start of main because\n+     * setbuf must be used before any other operation on the stream. */\n+    setbuf(stdout, NULL);\n+    /* Also disable buffering for stderr because it's not guaranteed that it's\n+     * unbuffered on all systems. */\n+    setbuf(stderr, NULL);\n+\n+    printf(\"Exhaustive tests for order %lu\\n\", (unsigned long)EXHAUSTIVE_TEST_ORDER);\n+\n+    /* find iteration count */\n+    if (argc > 1) {\n+        count = strtol(argv[1], NULL, 0);\n+    }\n+    printf(\"test count = %i\\n\", count);\n+\n+    /* find random seed */\n+    secp256k1_testrand_init(argc > 2 ? argv[2] : NULL);\n+\n+    /* set up split processing */\n+    if (argc > 4) {\n+        num_cores = strtol(argv[3], NULL, 0);\n+        this_core = strtol(argv[4], NULL, 0);\n+        if (num_cores < 1 || this_core >= num_cores) {\n+            fprintf(stderr, \"Usage: %s [count] [seed] [numcores] [thiscore]\\n\", argv[0]);\n+            return 1;\n         }\n+        printf(\"running tests for core %lu (out of [0..%lu])\\n\", (unsigned long)this_core, (unsigned long)num_cores - 1);\n     }\n-}\n-\n-void test_exhaustive_recovery_verify(const secp256k1_context *ctx, const secp256k1_ge *group, int order) {\n-    /* This is essentially a copy of test_exhaustive_verify, with recovery added */\n-    int s, r, msg, key;\n-    for (s = 1; s < order; s++) {\n-        for (r = 1; r < order; r++) {\n-            for (msg = 1; msg < order; msg++) {\n-                for (key = 1; key < order; key++) {\n-                    secp256k1_ge nonconst_ge;\n-                    secp256k1_ecdsa_recoverable_signature rsig;\n-                    secp256k1_ecdsa_signature sig;\n-                    secp256k1_pubkey pk;\n-                    secp256k1_scalar sk_s, msg_s, r_s, s_s;\n-                    secp256k1_scalar s_times_k_s, msg_plus_r_times_sk_s;\n-                    int recid = 0;\n-                    int k, should_verify;\n-                    unsigned char msg32[32];\n \n-                    secp256k1_scalar_set_int(&s_s, s);\n-                    secp256k1_scalar_set_int(&r_s, r);\n-                    secp256k1_scalar_set_int(&msg_s, msg);\n-                    secp256k1_scalar_set_int(&sk_s, key);\n-                    secp256k1_scalar_get_b32(msg32, &msg_s);\n+    while (count--) {\n+        /* Build context */\n+        ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+        secp256k1_testrand256(rand32);\n+        CHECK(secp256k1_context_randomize(ctx, rand32));\n+\n+        /* Generate the entire group */\n+        secp256k1_gej_set_infinity(&groupj[0]);\n+        secp256k1_ge_set_gej(&group[0], &groupj[0]);\n+        for (i = 1; i < EXHAUSTIVE_TEST_ORDER; i++) {\n+            secp256k1_gej_add_ge(&groupj[i], &groupj[i - 1], &secp256k1_ge_const_g);\n+            secp256k1_ge_set_gej(&group[i], &groupj[i]);\n+            if (count != 0) {\n+                /* Set a different random z-value for each Jacobian point, except z=1\n+                   is used in the last iteration. */\n+                secp256k1_fe z;\n+                random_fe(&z);\n+                secp256k1_gej_rescale(&groupj[i], &z);\n+            }\n \n-                    /* Verify by hand */\n-                    /* Run through every k value that gives us this r and check that *one* works.\n-                     * Note there could be none, there could be multiple, ECDSA is weird. */\n-                    should_verify = 0;\n-                    for (k = 0; k < order; k++) {\n-                        secp256k1_scalar check_x_s;\n-                        r_from_k(&check_x_s, group, k);\n-                        if (r_s == check_x_s) {\n-                            secp256k1_scalar_set_int(&s_times_k_s, k);\n-                            secp256k1_scalar_mul(&s_times_k_s, &s_times_k_s, &s_s);\n-                            secp256k1_scalar_mul(&msg_plus_r_times_sk_s, &r_s, &sk_s);\n-                            secp256k1_scalar_add(&msg_plus_r_times_sk_s, &msg_plus_r_times_sk_s, &msg_s);\n-                            should_verify |= secp256k1_scalar_eq(&s_times_k_s, &msg_plus_r_times_sk_s);\n-                        }\n-                    }\n-                    /* nb we have a \"high s\" rule */\n-                    should_verify &= !secp256k1_scalar_is_high(&s_s);\n+            /* Verify against ecmult_gen */\n+            {\n+                secp256k1_scalar scalar_i;\n+                secp256k1_gej generatedj;\n+                secp256k1_ge generated;\n \n-                    /* We would like to try recovering the pubkey and checking that it matches,\n-                     * but pubkey recovery is impossible in the exhaustive tests (the reason\n-                     * being that there are 12 nonzero r values, 12 nonzero points, and no\n-                     * overlap between the sets, so there are no valid signatures). */\n+                secp256k1_scalar_set_int(&scalar_i, i);\n+                secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &generatedj, &scalar_i);\n+                secp256k1_ge_set_gej(&generated, &generatedj);\n \n-                    /* Verify by converting to a standard signature and calling verify */\n-                    secp256k1_ecdsa_recoverable_signature_save(&rsig, &r_s, &s_s, recid);\n-                    secp256k1_ecdsa_recoverable_signature_convert(ctx, &sig, &rsig);\n-                    memcpy(&nonconst_ge, &group[sk_s], sizeof(nonconst_ge));\n-                    secp256k1_pubkey_save(&pk, &nonconst_ge);\n-                    CHECK(should_verify ==\n-                          secp256k1_ecdsa_verify(ctx, &sig, msg32, &pk));\n-                }\n+                CHECK(group[i].infinity == 0);\n+                CHECK(generated.infinity == 0);\n+                CHECK(secp256k1_fe_equal_var(&generated.x, &group[i].x));\n+                CHECK(secp256k1_fe_equal_var(&generated.y, &group[i].y));\n             }\n         }\n-    }\n-}\n-#endif\n-\n-int main(void) {\n-    int i;\n-    secp256k1_gej groupj[EXHAUSTIVE_TEST_ORDER];\n-    secp256k1_ge group[EXHAUSTIVE_TEST_ORDER];\n \n-    /* Build context */\n-    secp256k1_context *ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+        /* Run the tests */\n+        test_exhaustive_endomorphism(group);\n+        test_exhaustive_addition(group, groupj);\n+        test_exhaustive_ecmult(ctx, group, groupj);\n+        test_exhaustive_ecmult_multi(ctx, group);\n+        test_exhaustive_sign(ctx, group);\n+        test_exhaustive_verify(ctx, group);\n \n-    /* TODO set z = 1, then do num_tests runs with random z values */\n+#ifdef ENABLE_MODULE_RECOVERY\n+        test_exhaustive_recovery(ctx, group);\n+#endif\n+#ifdef ENABLE_MODULE_EXTRAKEYS\n+        test_exhaustive_extrakeys(ctx, group);\n+#endif\n+#ifdef ENABLE_MODULE_SCHNORRSIG\n+        test_exhaustive_schnorrsig(ctx);\n+#endif\n \n-    /* Generate the entire group */\n-    secp256k1_gej_set_infinity(&groupj[0]);\n-    secp256k1_ge_set_gej(&group[0], &groupj[0]);\n-    for (i = 1; i < EXHAUSTIVE_TEST_ORDER; i++) {\n-        /* Set a different random z-value for each Jacobian point */\n-        secp256k1_fe z;\n-        random_fe(&z);\n-\n-        secp256k1_gej_add_ge(&groupj[i], &groupj[i - 1], &secp256k1_ge_const_g);\n-        secp256k1_ge_set_gej(&group[i], &groupj[i]);\n-        secp256k1_gej_rescale(&groupj[i], &z);\n-\n-        /* Verify against ecmult_gen */\n-        {\n-            secp256k1_scalar scalar_i;\n-            secp256k1_gej generatedj;\n-            secp256k1_ge generated;\n-\n-            secp256k1_scalar_set_int(&scalar_i, i);\n-            secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &generatedj, &scalar_i);\n-            secp256k1_ge_set_gej(&generated, &generatedj);\n-\n-            CHECK(group[i].infinity == 0);\n-            CHECK(generated.infinity == 0);\n-            CHECK(secp256k1_fe_equal_var(&generated.x, &group[i].x));\n-            CHECK(secp256k1_fe_equal_var(&generated.y, &group[i].y));\n-        }\n+        secp256k1_context_destroy(ctx);\n     }\n \n-    /* Run the tests */\n-#ifdef USE_ENDOMORPHISM\n-    test_exhaustive_endomorphism(group, EXHAUSTIVE_TEST_ORDER);\n-#endif\n-    test_exhaustive_addition(group, groupj, EXHAUSTIVE_TEST_ORDER);\n-    test_exhaustive_ecmult(ctx, group, groupj, EXHAUSTIVE_TEST_ORDER);\n-    test_exhaustive_ecmult_multi(ctx, group, EXHAUSTIVE_TEST_ORDER);\n-    test_exhaustive_sign(ctx, group, EXHAUSTIVE_TEST_ORDER);\n-    test_exhaustive_verify(ctx, group, EXHAUSTIVE_TEST_ORDER);\n+    secp256k1_testrand_finish();\n \n-#ifdef ENABLE_MODULE_RECOVERY\n-    test_exhaustive_recovery_sign(ctx, group, EXHAUSTIVE_TEST_ORDER);\n-    test_exhaustive_recovery_verify(ctx, group, EXHAUSTIVE_TEST_ORDER);\n-#endif\n-\n-    secp256k1_context_destroy(ctx);\n+    printf(\"no problems found\\n\");\n     return 0;\n }\n-"
      },
      {
        "sha": "3a88a41bc61f79e2cef31870d4d3b01b147ee16f",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -216,6 +216,24 @@ static SECP256K1_INLINE void memczero(void *s, size_t len, int flag) {\n     }\n }\n \n+/** Semantics like memcmp. Variable-time.\n+ *\n+ * We use this to avoid possible compiler bugs with memcmp, e.g.\n+ * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95189\n+ */\n+static SECP256K1_INLINE int secp256k1_memcmp_var(const void *s1, const void *s2, size_t n) {\n+    const unsigned char *p1 = s1, *p2 = s2;\n+    size_t i;\n+\n+    for (i = 0; i < n; i++) {\n+        int diff = p1[i] - p2[i];\n+        if (diff != 0) {\n+            return diff;\n+        }\n+    }\n+    return 0;\n+}\n+\n /** If flag is true, set *r equal to *a; otherwise leave it. Constant-time.  Both *r and *a must be initialized and non-negative.*/\n static SECP256K1_INLINE void secp256k1_int_cmov(int *r, const int *a, int flag) {\n     unsigned int mask0, mask1, r_masked, a_masked;"
      },
      {
        "sha": "3169e3651c4044dcf865eea73b4f75ba8dca372b",
        "filename": "src/valgrind_ctime_test.c",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/valgrind_ctime_test.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52380bf304b1c02dda23f1e2fad0159e29b2f7a2/src/valgrind_ctime_test.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/valgrind_ctime_test.c?ref=52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "patch": "@@ -9,19 +9,19 @@\n #include \"assumptions.h\"\n #include \"util.h\"\n \n-#if ENABLE_MODULE_ECDH\n+#ifdef ENABLE_MODULE_ECDH\n # include \"include/secp256k1_ecdh.h\"\n #endif\n \n-#if ENABLE_MODULE_RECOVERY\n+#ifdef ENABLE_MODULE_RECOVERY\n # include \"include/secp256k1_recovery.h\"\n #endif\n \n-#if ENABLE_MODULE_EXTRAKEYS\n+#ifdef ENABLE_MODULE_EXTRAKEYS\n # include \"include/secp256k1_extrakeys.h\"\n #endif\n \n-#if ENABLE_MODULE_SCHNORRSIG\n+#ifdef ENABLE_MODULE_SCHNORRSIG\n #include \"include/secp256k1_schnorrsig.h\"\n #endif\n \n@@ -37,11 +37,11 @@ int main(void) {\n     unsigned char key[32];\n     unsigned char sig[74];\n     unsigned char spubkey[33];\n-#if ENABLE_MODULE_RECOVERY\n+#ifdef ENABLE_MODULE_RECOVERY\n     secp256k1_ecdsa_recoverable_signature recoverable_signature;\n     int recid;\n #endif\n-#if ENABLE_MODULE_EXTRAKEYS\n+#ifdef ENABLE_MODULE_EXTRAKEYS\n     secp256k1_keypair keypair;\n #endif\n \n@@ -81,15 +81,15 @@ int main(void) {\n     CHECK(ret);\n     CHECK(secp256k1_ecdsa_signature_serialize_der(ctx, sig, &siglen, &signature));\n \n-#if ENABLE_MODULE_ECDH\n+#ifdef ENABLE_MODULE_ECDH\n     /* Test ECDH. */\n     VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n     ret = secp256k1_ecdh(ctx, msg, &pubkey, key, NULL, NULL);\n     VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n     CHECK(ret == 1);\n #endif\n \n-#if ENABLE_MODULE_RECOVERY\n+#ifdef ENABLE_MODULE_RECOVERY\n     /* Test signing a recoverable signature. */\n     VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n     ret = secp256k1_ecdsa_sign_recoverable(ctx, &recoverable_signature, msg, key, NULL, NULL);\n@@ -129,7 +129,7 @@ int main(void) {\n     CHECK(ret);\n \n     /* Test keypair_create and keypair_xonly_tweak_add. */\n-#if ENABLE_MODULE_EXTRAKEYS\n+#ifdef ENABLE_MODULE_EXTRAKEYS\n     VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n     ret = secp256k1_keypair_create(ctx, &keypair, key);\n     VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n@@ -142,7 +142,7 @@ int main(void) {\n     CHECK(ret == 1);\n #endif\n \n-#if ENABLE_MODULE_SCHNORRSIG\n+#ifdef ENABLE_MODULE_SCHNORRSIG\n     VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n     ret = secp256k1_keypair_create(ctx, &keypair, key);\n     VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));"
      }
    ]
  },
  {
    "sha": "9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZTU2MjZkMmE4ZGRiYmQ3NjQwZmY1M2Y4OWYzYTcwMjFkNzQ3NjMz",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-14T18:41:15Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-14T18:41:15Z"
      },
      "message": "Update libsecp256k1 subtree to latest master",
      "tree": {
        "sha": "95085289012230285b6cc1bb551ebf8a217121a0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/95085289012230285b6cc1bb551ebf8a217121a0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c2c4dbaebd955ad2829364f7fa5b8169ca1ba6b9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c2c4dbaebd955ad2829364f7fa5b8169ca1ba6b9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c2c4dbaebd955ad2829364f7fa5b8169ca1ba6b9"
      },
      {
        "sha": "52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/52380bf304b1c02dda23f1e2fad0159e29b2f7a2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/52380bf304b1c02dda23f1e2fad0159e29b2f7a2"
      }
    ],
    "stats": {
      "total": 2533,
      "additions": 1586,
      "deletions": 947
    },
    "files": [
      {
        "sha": "bcc8c210f590523df3187091c54b0a37e40212a0",
        "filename": "src/secp256k1/.travis.yml",
        "status": "modified",
        "additions": 8,
        "deletions": 12,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.travis.yml?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -17,33 +17,29 @@ compiler:\n   - gcc\n env:\n   global:\n-    - WIDEMUL=auto  BIGNUM=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ECMULTGENPRECISION=auto  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no SCHNORRSIG=no EXPERIMENTAL=no CTIMETEST=yes BENCH=yes ITERS=2\n+    - WIDEMUL=auto  BIGNUM=auto  STATICPRECOMPUTATION=yes  ECMULTGENPRECISION=auto  ASM=no  BUILD=check  WITH_VALGRIND=yes RUN_VALGRIND=no EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no SCHNORRSIG=no EXPERIMENTAL=no CTIMETEST=yes BENCH=yes ITERS=2\n   matrix:\n     - WIDEMUL=int64   RECOVERY=yes\n     - WIDEMUL=int64   ECDH=yes  EXPERIMENTAL=yes SCHNORRSIG=yes\n-    - WIDEMUL=int64   ENDOMORPHISM=yes\n     - WIDEMUL=int128\n     - WIDEMUL=int128  RECOVERY=yes EXPERIMENTAL=yes SCHNORRSIG=yes\n-    - WIDEMUL=int128  ENDOMORPHISM=yes\n-    - WIDEMUL=int128  ENDOMORPHISM=yes  ECDH=yes EXPERIMENTAL=yes SCHNORRSIG=yes\n+    - WIDEMUL=int128  ECDH=yes EXPERIMENTAL=yes SCHNORRSIG=yes\n     - WIDEMUL=int128                    ASM=x86_64\n-    - WIDEMUL=int128  ENDOMORPHISM=yes  ASM=x86_64\n     - BIGNUM=no\n-    - BIGNUM=no       ENDOMORPHISM=yes RECOVERY=yes EXPERIMENTAL=yes SCHNORRSIG=yes\n+    - BIGNUM=no       RECOVERY=yes EXPERIMENTAL=yes SCHNORRSIG=yes\n     - BIGNUM=no       STATICPRECOMPUTATION=no\n-    - BUILD=distcheck CTIMETEST= BENCH=\n+    - BUILD=distcheck WITH_VALGRIND=no CTIMETEST=no BENCH=no\n     - CPPFLAGS=-DDETERMINISTIC\n-    - CFLAGS=-O0 CTIMETEST=\n+    - CFLAGS=-O0 CTIMETEST=no\n     - ECMULTGENPRECISION=2\n     - ECMULTGENPRECISION=8\n-    - VALGRIND=yes ENDOMORPHISM=yes BIGNUM=no ASM=x86_64 EXPERIMENTAL=yes ECDH=yes  RECOVERY=yes EXTRAFLAGS=\"--disable-openssl-tests\" CPPFLAGS=-DVALGRIND BUILD=\n-    - VALGRIND=yes                  BIGNUM=no ASM=x86_64 EXPERIMENTAL=yes ECDH=yes  RECOVERY=yes EXTRAFLAGS=\"--disable-openssl-tests\" CPPFLAGS=-DVALGRIND BUILD=\n+    - RUN_VALGRIND=yes BIGNUM=no ASM=x86_64 EXPERIMENTAL=yes ECDH=yes  RECOVERY=yes EXTRAFLAGS=\"--disable-openssl-tests\" BUILD=\n matrix:\n   fast_finish: true\n   include:\n     - compiler: clang\n       os: linux\n-      env: HOST=i686-linux-gnu ENDOMORPHISM=yes\n+      env: HOST=i686-linux-gnu\n       addons:\n         apt:\n           packages:\n@@ -63,7 +59,7 @@ matrix:\n             - libtool-bin\n             - libc6-dbg:i386\n     - compiler: gcc\n-      env: HOST=i686-linux-gnu ENDOMORPHISM=yes\n+      env: HOST=i686-linux-gnu\n       os: linux\n       addons:\n         apt:"
      },
      {
        "sha": "260247578704fd655971a04c2f322d012245bd94",
        "filename": "src/secp256k1/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/README.md?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -48,7 +48,7 @@ Implementation details\n   * Use wNAF notation for point multiplicands.\n   * Use a much larger window for multiples of G, using precomputed multiples.\n   * Use Shamir's trick to do the multiplication with the public key and the generator simultaneously.\n-  * Optionally (off by default) use secp256k1's efficiently-computable endomorphism to split the P multiplicand into 2 half-sized ones.\n+  * Use secp256k1's efficiently-computable endomorphism to split the P multiplicand into 2 half-sized ones.\n * Point multiplication for signing\n   * Use a precomputed table of multiples of powers of 16 multiplied with the generator, so general multiplication becomes a series of additions.\n   * Intended to be completely free of timing sidechannels for secret-key operations (on reasonable hardware/toolchains)"
      },
      {
        "sha": "5a078e6c819198c5b3ba01d361e8ee195461a706",
        "filename": "src/secp256k1/configure.ac",
        "status": "modified",
        "additions": 17,
        "deletions": 14,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/configure.ac?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -67,7 +67,7 @@ esac\n \n CFLAGS=\"-W $CFLAGS\"\n \n-warn_CFLAGS=\"-std=c89 -pedantic -Wall -Wextra -Wcast-align -Wnested-externs -Wshadow -Wstrict-prototypes -Wno-unused-function -Wno-long-long -Wno-overlength-strings\"\n+warn_CFLAGS=\"-std=c89 -pedantic -Wall -Wextra -Wcast-align -Wnested-externs -Wshadow -Wstrict-prototypes -Wundef -Wno-unused-function -Wno-long-long -Wno-overlength-strings\"\n saved_CFLAGS=\"$CFLAGS\"\n CFLAGS=\"$warn_CFLAGS $CFLAGS\"\n AC_MSG_CHECKING([if ${CC} supports ${warn_CFLAGS}])\n@@ -116,11 +116,6 @@ AC_ARG_ENABLE(exhaustive_tests,\n     [use_exhaustive_tests=$enableval],\n     [use_exhaustive_tests=yes])\n \n-AC_ARG_ENABLE(endomorphism,\n-    AS_HELP_STRING([--enable-endomorphism],[enable endomorphism [default=no]]),\n-    [use_endomorphism=$enableval],\n-    [use_endomorphism=no])\n-\n AC_ARG_ENABLE(ecmult_static_precomputation,\n     AS_HELP_STRING([--enable-ecmult-static-precomputation],[enable precomputed ecmult table for signing [default=auto]]),\n     [use_ecmult_static_precomputation=$enableval],\n@@ -164,8 +159,7 @@ AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|arm|no|auto],\n AC_ARG_WITH([ecmult-window], [AS_HELP_STRING([--with-ecmult-window=SIZE|auto],\n [window size for ecmult precomputation for verification, specified as integer in range [2..24].]\n [Larger values result in possibly better performance at the cost of an exponentially larger precomputed table.]\n-[The table will store 2^(SIZE-2) * 64 bytes of data but can be larger in memory due to platform-specific padding and alignment.]\n-[If the endomorphism optimization is enabled, two tables of this size are used instead of only one.]\n+[The table will store 2^(SIZE-1) * 64 bytes of data but can be larger in memory due to platform-specific padding and alignment.]\n [\"auto\" is a reasonable setting for desktop machines (currently 15). [default=auto]]\n )],\n [req_ecmult_window=$withval], [req_ecmult_window=auto])\n@@ -178,7 +172,21 @@ AC_ARG_WITH([ecmult-gen-precision], [AS_HELP_STRING([--with-ecmult-gen-precision\n )],\n [req_ecmult_gen_precision=$withval], [req_ecmult_gen_precision=auto])\n \n-AC_CHECK_HEADER([valgrind/memcheck.h], [enable_valgrind=yes], [enable_valgrind=no], [])\n+AC_ARG_WITH([valgrind], [AS_HELP_STRING([--with-valgrind=yes|no|auto],\n+[Build with extra checks for running inside Valgrind [default=auto]]\n+)],\n+[req_valgrind=$withval], [req_valgrind=auto])\n+\n+if test x\"$req_valgrind\" = x\"no\"; then\n+  enable_valgrind=no\n+else\n+  AC_CHECK_HEADER([valgrind/memcheck.h], [enable_valgrind=yes], [\n+    if test x\"$req_valgrind\" = x\"yes\"; then\n+      AC_MSG_ERROR([Valgrind support explicitly requested but valgrind/memcheck.h header not available])\n+    fi\n+    enable_valgrind=no\n+  ], [])\n+fi\n AM_CONDITIONAL([VALGRIND_ENABLED],[test \"$enable_valgrind\" = \"yes\"])\n \n if test x\"$enable_coverage\" = x\"yes\"; then\n@@ -415,10 +423,6 @@ if test x\"$set_bignum\" = x\"gmp\"; then\n   SECP_INCLUDES=\"$SECP_INCLUDES $GMP_CPPFLAGS\"\n fi\n \n-if test x\"$use_endomorphism\" = x\"yes\"; then\n-  AC_DEFINE(USE_ENDOMORPHISM, 1, [Define this symbol to use endomorphism optimization])\n-fi\n-\n if test x\"$set_precomp\" = x\"yes\"; then\n   AC_DEFINE(USE_ECMULT_STATIC_PRECOMPUTATION, 1, [Define this symbol to use a statically generated ecmult table])\n fi\n@@ -500,7 +504,6 @@ AC_OUTPUT\n \n echo\n echo \"Build Options:\"\n-echo \"  with endomorphism       = $use_endomorphism\"\n echo \"  with ecmult precomp     = $set_precomp\"\n echo \"  with external callbacks = $use_external_default_callbacks\"\n echo \"  with benchmarks         = $use_benchmark\""
      },
      {
        "sha": "24cc9315cb116939f7871b644e77a40544816e9d",
        "filename": "src/secp256k1/contrib/travis.sh",
        "status": "modified",
        "additions": 10,
        "deletions": 5,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/contrib/travis.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/contrib/travis.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/contrib/travis.sh?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -13,27 +13,28 @@ then\n fi\n \n ./configure \\\n-    --enable-experimental=\"$EXPERIMENTAL\" --enable-endomorphism=\"$ENDOMORPHISM\" \\\n+    --enable-experimental=\"$EXPERIMENTAL\" \\\n     --with-test-override-wide-multiply=\"$WIDEMUL\" --with-bignum=\"$BIGNUM\" --with-asm=\"$ASM\" \\\n     --enable-ecmult-static-precomputation=\"$STATICPRECOMPUTATION\" --with-ecmult-gen-precision=\"$ECMULTGENPRECISION\" \\\n     --enable-module-ecdh=\"$ECDH\" --enable-module-recovery=\"$RECOVERY\" \\\n     --enable-module-schnorrsig=\"$SCHNORRSIG\" \\\n+    --with-valgrind=\"$WITH_VALGRIND\" \\\n     --host=\"$HOST\" $EXTRAFLAGS\n \n if [ -n \"$BUILD\" ]\n then\n     make -j2 \"$BUILD\"\n fi\n-if [ -n \"$VALGRIND\" ]\n+if [ \"$RUN_VALGRIND\" = \"yes\" ]\n then\n     make -j2\n     # the `--error-exitcode` is required to make the test fail if valgrind found errors, otherwise it'll return 0 (http://valgrind.org/docs/manual/manual-core.html)\n     valgrind --error-exitcode=42 ./tests 16\n     valgrind --error-exitcode=42 ./exhaustive_tests\n fi\n-if [ -n \"$BENCH\" ]\n+if [ \"$BENCH\" = \"yes\" ]\n then\n-    if [ -n \"$VALGRIND\" ]\n+    if [ \"$RUN_VALGRIND\" = \"yes\" ]\n     then\n         # Using the local `libtool` because on macOS the system's libtool has nothing to do with GNU libtool\n         EXEC='./libtool --mode=execute valgrind --error-exitcode=42'\n@@ -56,8 +57,12 @@ then\n     then\n         $EXEC ./bench_ecdh >> bench.log 2>&1\n     fi\n+    if [ \"$SCHNORRSIG\" = \"yes\" ]\n+    then\n+        $EXEC ./bench_schnorrsig >> bench.log 2>&1\n+    fi\n fi\n-if [ -n \"$CTIMETEST\" ]\n+if [ \"$CTIMETEST\" = \"yes\" ]\n then\n     ./libtool --mode=execute valgrind --error-exitcode=42 ./valgrind_ctime_test > valgrind_ctime_test.log 2>&1\n fi"
      },
      {
        "sha": "3c3c984811e3a7cb101e4d6514cd55198a2f2a20",
        "filename": "src/secp256k1/sage/gen_exhaustive_groups.sage",
        "status": "added",
        "additions": 129,
        "deletions": 0,
        "changes": 129,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/sage/gen_exhaustive_groups.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/sage/gen_exhaustive_groups.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/sage/gen_exhaustive_groups.sage?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -0,0 +1,129 @@\n+# Define field size and field\n+P = 2^256 - 2^32 - 977\n+F = GF(P)\n+BETA = F(0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee)\n+\n+assert(BETA != F(1) and BETA^3 == F(1))\n+\n+orders_done = set()\n+results = {}\n+first = True\n+for b in range(1, P):\n+    # There are only 6 curves (up to isomorphism) of the form y^2=x^3+B. Stop once we have tried all.\n+    if len(orders_done) == 6:\n+        break\n+\n+    E = EllipticCurve(F, [0, b])\n+    print(\"Analyzing curve y^2 = x^3 + %i\" % b)\n+    n = E.order()\n+    # Skip curves with an order we've already tried\n+    if n in orders_done:\n+        print(\"- Isomorphic to earlier curve\")\n+        continue\n+    orders_done.add(n)\n+    # Skip curves isomorphic to the real secp256k1\n+    if n.is_pseudoprime():\n+        print(\" - Isomorphic to secp256k1\")\n+        continue\n+\n+    print(\"- Finding subgroups\")\n+\n+    # Find what prime subgroups exist\n+    for f, _ in n.factor():\n+        print(\"- Analyzing subgroup of order %i\" % f)\n+        # Skip subgroups of order >1000\n+        if f < 4 or f > 1000:\n+            print(\"  - Bad size\")\n+            continue\n+\n+        # Iterate over X coordinates until we find one that is on the curve, has order f,\n+        # and for which curve isomorphism exists that maps it to X coordinate 1.\n+        for x in range(1, P):\n+            # Skip X coordinates not on the curve, and construct the full point otherwise.\n+            if not E.is_x_coord(x):\n+                continue\n+            G = E.lift_x(F(x))\n+\n+            print(\"  - Analyzing (multiples of) point with X=%i\" % x)\n+\n+            # Skip points whose order is not a multiple of f. Project the point to have\n+            # order f otherwise.\n+            if (G.order() % f):\n+                print(\"    - Bad order\")\n+                continue\n+            G = G * (G.order() // f)\n+\n+            # Find lambda for endomorphism. Skip if none can be found.\n+            lam = None\n+            for l in Integers(f)(1).nth_root(3, all=True):\n+                if int(l)*G == E(BETA*G[0], G[1]):\n+                    lam = int(l)\n+                    break\n+            if lam is None:\n+                print(\"    - No endomorphism for this subgroup\")\n+                break\n+\n+            # Now look for an isomorphism of the curve that gives this point an X\n+            # coordinate equal to 1.\n+            # If (x,y) is on y^2 = x^3 + b, then (a^2*x, a^3*y) is on y^2 = x^3 + a^6*b.\n+            # So look for m=a^2=1/x.\n+            m = F(1)/G[0]\n+            if not m.is_square():\n+                print(\"    - No curve isomorphism maps it to a point with X=1\")\n+                continue\n+            a = m.sqrt()\n+            rb = a^6*b\n+            RE = EllipticCurve(F, [0, rb])\n+\n+            # Use as generator twice the image of G under the above isormorphism.\n+            # This means that generator*(1/2 mod f) will have X coordinate 1.\n+            RG = RE(1, a^3*G[1]) * 2\n+            # And even Y coordinate.\n+            if int(RG[1]) % 2:\n+                RG = -RG\n+            assert(RG.order() == f)\n+            assert(lam*RG == RE(BETA*RG[0], RG[1]))\n+\n+            # We have found curve RE:y^2=x^3+rb with generator RG of order f. Remember it\n+            results[f] = {\"b\": rb, \"G\": RG, \"lambda\": lam}\n+            print(\"    - Found solution\")\n+            break\n+\n+    print(\"\")\n+\n+print(\"\")\n+print(\"\")\n+print(\"/* To be put in src/group_impl.h: */\")\n+first = True\n+for f in sorted(results.keys()):\n+    b = results[f][\"b\"]\n+    G = results[f][\"G\"]\n+    print(\"#  %s EXHAUSTIVE_TEST_ORDER == %i\" % (\"if\" if first else \"elif\", f))\n+    first = False\n+    print(\"static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\")\n+    print(\"    0x%08x, 0x%08x, 0x%08x, 0x%08x,\" % tuple((int(G[0]) >> (32 * (7 - i))) & 0xffffffff for i in range(4)))\n+    print(\"    0x%08x, 0x%08x, 0x%08x, 0x%08x,\" % tuple((int(G[0]) >> (32 * (7 - i))) & 0xffffffff for i in range(4, 8)))\n+    print(\"    0x%08x, 0x%08x, 0x%08x, 0x%08x,\" % tuple((int(G[1]) >> (32 * (7 - i))) & 0xffffffff for i in range(4)))\n+    print(\"    0x%08x, 0x%08x, 0x%08x, 0x%08x\" % tuple((int(G[1]) >> (32 * (7 - i))) & 0xffffffff for i in range(4, 8)))\n+    print(\");\")\n+    print(\"static const secp256k1_fe secp256k1_fe_const_b = SECP256K1_FE_CONST(\")\n+    print(\"    0x%08x, 0x%08x, 0x%08x, 0x%08x,\" % tuple((int(b) >> (32 * (7 - i))) & 0xffffffff for i in range(4)))\n+    print(\"    0x%08x, 0x%08x, 0x%08x, 0x%08x\" % tuple((int(b) >> (32 * (7 - i))) & 0xffffffff for i in range(4, 8)))\n+    print(\");\")\n+print(\"#  else\")\n+print(\"#    error No known generator for the specified exhaustive test group order.\")\n+print(\"#  endif\")\n+\n+print(\"\")\n+print(\"\")\n+print(\"/* To be put in src/scalar_impl.h: */\")\n+first = True\n+for f in sorted(results.keys()):\n+    lam = results[f][\"lambda\"]\n+    print(\"#  %s EXHAUSTIVE_TEST_ORDER == %i\" % (\"if\" if first else \"elif\", f))\n+    first = False\n+    print(\"#    define EXHAUSTIVE_TEST_LAMBDA %i\" % lam)\n+print(\"#  else\")\n+print(\"#    error No known lambda for the specified exhaustive test group order.\")\n+print(\"#  endif\")\n+print(\"\")"
      },
      {
        "sha": "77204de2b89cf9761c5965ac6b155311956b1d13",
        "filename": "src/secp256k1/src/assumptions.h",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/assumptions.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/assumptions.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/assumptions.h?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -7,6 +7,8 @@\n #ifndef SECP256K1_ASSUMPTIONS_H\n #define SECP256K1_ASSUMPTIONS_H\n \n+#include <limits.h>\n+\n #include \"util.h\"\n \n /* This library, like most software, relies on a number of compiler implementation defined (but not undefined)\n@@ -19,7 +21,11 @@ struct secp256k1_assumption_checker {\n        allowed. */\n     int dummy_array[(\n         /* Bytes are 8 bits. */\n-        CHAR_BIT == 8 &&\n+        (CHAR_BIT == 8) &&\n+\n+        /* No integer promotion for uint32_t. This ensures that we can multiply uintXX_t values where XX >= 32\n+           without signed overflow, which would be undefined behaviour. */\n+        (UINT_MAX <= UINT32_MAX) &&\n \n         /* Conversions from unsigned to signed outside of the bounds of the signed type are\n            implementation-defined. Verify that they function as reinterpreting the lower"
      },
      {
        "sha": "b0d82e89b412d7bd735a411a0798cff92282c318",
        "filename": "src/secp256k1/src/basic-config.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/basic-config.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/basic-config.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/basic-config.h?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -11,7 +11,6 @@\n \n #undef USE_ASM_X86_64\n #undef USE_ECMULT_STATIC_PRECOMPUTATION\n-#undef USE_ENDOMORPHISM\n #undef USE_EXTERNAL_ASM\n #undef USE_EXTERNAL_DEFAULT_CALLBACKS\n #undef USE_FIELD_INV_BUILTIN"
      },
      {
        "sha": "5f2b7a9759319daded58478940b443924ebf7223",
        "filename": "src/secp256k1/src/bench_internal.c",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/bench_internal.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/bench_internal.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_internal.c?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -117,7 +117,6 @@ void bench_scalar_mul(void* arg, int iters) {\n     }\n }\n \n-#ifdef USE_ENDOMORPHISM\n void bench_scalar_split(void* arg, int iters) {\n     int i, j = 0;\n     bench_inv *data = (bench_inv*)arg;\n@@ -128,7 +127,6 @@ void bench_scalar_split(void* arg, int iters) {\n     }\n     CHECK(j <= iters);\n }\n-#endif\n \n void bench_scalar_inverse(void* arg, int iters) {\n     int i, j = 0;\n@@ -397,9 +395,7 @@ int main(int argc, char **argv) {\n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"negate\")) run_benchmark(\"scalar_negate\", bench_scalar_negate, bench_setup, NULL, &data, 10, iters*100);\n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"sqr\")) run_benchmark(\"scalar_sqr\", bench_scalar_sqr, bench_setup, NULL, &data, 10, iters*10);\n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"mul\")) run_benchmark(\"scalar_mul\", bench_scalar_mul, bench_setup, NULL, &data, 10, iters*10);\n-#ifdef USE_ENDOMORPHISM\n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"split\")) run_benchmark(\"scalar_split\", bench_scalar_split, bench_setup, NULL, &data, 10, iters);\n-#endif\n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"scalar_inverse\", bench_scalar_inverse, bench_setup, NULL, &data, 10, 2000);\n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"scalar_inverse_var\", bench_scalar_inverse_var, bench_setup, NULL, &data, 10, 2000);\n "
      },
      {
        "sha": "09e8146414b61d8fcef12695423229d52eb3b50d",
        "filename": "src/secp256k1/src/ecmult.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/ecmult.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/ecmult.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult.h?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -15,9 +15,7 @@\n typedef struct {\n     /* For accelerating the computation of a*P + b*G: */\n     secp256k1_ge_storage (*pre_g)[];    /* odd multiples of the generator */\n-#ifdef USE_ENDOMORPHISM\n     secp256k1_ge_storage (*pre_g_128)[]; /* odd multiples of 2^128*generator */\n-#endif\n } secp256k1_ecmult_context;\n \n static const size_t SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;"
      },
      {
        "sha": "bb9511108be7e84a595c8f9834bfc0fe1bb9c964",
        "filename": "src/secp256k1/src/ecmult_const_impl.h",
        "status": "modified",
        "additions": 0,
        "deletions": 20,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/ecmult_const_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/ecmult_const_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_const_impl.h?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -140,32 +140,26 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n     secp256k1_fe Z;\n \n     int skew_1;\n-#ifdef USE_ENDOMORPHISM\n     secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n     int wnaf_lam[1 + WNAF_SIZE(WINDOW_A - 1)];\n     int skew_lam;\n     secp256k1_scalar q_1, q_lam;\n-#endif\n     int wnaf_1[1 + WNAF_SIZE(WINDOW_A - 1)];\n \n     int i;\n \n     /* build wnaf representation for q. */\n     int rsize = size;\n-#ifdef USE_ENDOMORPHISM\n     if (size > 128) {\n         rsize = 128;\n         /* split q into q_1 and q_lam (where q = q_1 + q_lam*lambda, and q_1 and q_lam are ~128 bit) */\n         secp256k1_scalar_split_lambda(&q_1, &q_lam, scalar);\n         skew_1   = secp256k1_wnaf_const(wnaf_1,   &q_1,   WINDOW_A - 1, 128);\n         skew_lam = secp256k1_wnaf_const(wnaf_lam, &q_lam, WINDOW_A - 1, 128);\n     } else\n-#endif\n     {\n         skew_1   = secp256k1_wnaf_const(wnaf_1, scalar, WINDOW_A - 1, size);\n-#ifdef USE_ENDOMORPHISM\n         skew_lam = 0;\n-#endif\n     }\n \n     /* Calculate odd multiples of a.\n@@ -179,14 +173,12 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n     for (i = 0; i < ECMULT_TABLE_SIZE(WINDOW_A); i++) {\n         secp256k1_fe_normalize_weak(&pre_a[i].y);\n     }\n-#ifdef USE_ENDOMORPHISM\n     if (size > 128) {\n         for (i = 0; i < ECMULT_TABLE_SIZE(WINDOW_A); i++) {\n             secp256k1_ge_mul_lambda(&pre_a_lam[i], &pre_a[i]);\n         }\n \n     }\n-#endif\n \n     /* first loop iteration (separated out so we can directly set r, rather\n      * than having it start at infinity, get doubled several times, then have\n@@ -195,14 +187,12 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n     VERIFY_CHECK(i != 0);\n     ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a, i, WINDOW_A);\n     secp256k1_gej_set_ge(r, &tmpa);\n-#ifdef USE_ENDOMORPHISM\n     if (size > 128) {\n         i = wnaf_lam[WNAF_SIZE_BITS(rsize, WINDOW_A - 1)];\n         VERIFY_CHECK(i != 0);\n         ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a_lam, i, WINDOW_A);\n         secp256k1_gej_add_ge(r, r, &tmpa);\n     }\n-#endif\n     /* remaining loop iterations */\n     for (i = WNAF_SIZE_BITS(rsize, WINDOW_A - 1) - 1; i >= 0; i--) {\n         int n;\n@@ -215,14 +205,12 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n         ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a, n, WINDOW_A);\n         VERIFY_CHECK(n != 0);\n         secp256k1_gej_add_ge(r, r, &tmpa);\n-#ifdef USE_ENDOMORPHISM\n         if (size > 128) {\n             n = wnaf_lam[i];\n             ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a_lam, n, WINDOW_A);\n             VERIFY_CHECK(n != 0);\n             secp256k1_gej_add_ge(r, r, &tmpa);\n         }\n-#endif\n     }\n \n     secp256k1_fe_mul(&r->z, &r->z, &Z);\n@@ -231,43 +219,35 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n         /* Correct for wNAF skew */\n         secp256k1_ge correction = *a;\n         secp256k1_ge_storage correction_1_stor;\n-#ifdef USE_ENDOMORPHISM\n         secp256k1_ge_storage correction_lam_stor;\n-#endif\n         secp256k1_ge_storage a2_stor;\n         secp256k1_gej tmpj;\n         secp256k1_gej_set_ge(&tmpj, &correction);\n         secp256k1_gej_double_var(&tmpj, &tmpj, NULL);\n         secp256k1_ge_set_gej(&correction, &tmpj);\n         secp256k1_ge_to_storage(&correction_1_stor, a);\n-#ifdef USE_ENDOMORPHISM\n         if (size > 128) {\n             secp256k1_ge_to_storage(&correction_lam_stor, a);\n         }\n-#endif\n         secp256k1_ge_to_storage(&a2_stor, &correction);\n \n         /* For odd numbers this is 2a (so replace it), for even ones a (so no-op) */\n         secp256k1_ge_storage_cmov(&correction_1_stor, &a2_stor, skew_1 == 2);\n-#ifdef USE_ENDOMORPHISM\n         if (size > 128) {\n             secp256k1_ge_storage_cmov(&correction_lam_stor, &a2_stor, skew_lam == 2);\n         }\n-#endif\n \n         /* Apply the correction */\n         secp256k1_ge_from_storage(&correction, &correction_1_stor);\n         secp256k1_ge_neg(&correction, &correction);\n         secp256k1_gej_add_ge(r, r, &correction);\n \n-#ifdef USE_ENDOMORPHISM\n         if (size > 128) {\n             secp256k1_ge_from_storage(&correction, &correction_lam_stor);\n             secp256k1_ge_neg(&correction, &correction);\n             secp256k1_ge_mul_lambda(&correction, &correction);\n             secp256k1_gej_add_ge(r, r, &correction);\n         }\n-#endif\n     }\n }\n "
      },
      {
        "sha": "057a69cf73d7705dec94082caa91e03fed720b2d",
        "filename": "src/secp256k1/src/ecmult_impl.h",
        "status": "modified",
        "additions": 12,
        "deletions": 145,
        "changes": 157,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_impl.h?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -38,8 +38,8 @@\n  *      (1 << (WINDOW_G - 2)) * sizeof(secp256k1_ge_storage)  bytes,\n  *  where sizeof(secp256k1_ge_storage) is typically 64 bytes but can\n  *  be larger due to platform-specific padding and alignment.\n- *  If the endomorphism optimization is enabled (USE_ENDOMORMPHSIM)\n- *  two tables of this size are used instead of only one.\n+ *  Two tables of this size are used (due to the endomorphism\n+ *  optimization).\n  */\n #  define WINDOW_G ECMULT_WINDOW_SIZE\n #endif\n@@ -59,11 +59,7 @@\n #  error Set ECMULT_WINDOW_SIZE to an integer in range [2..24].\n #endif\n \n-#ifdef USE_ENDOMORPHISM\n-    #define WNAF_BITS 128\n-#else\n-    #define WNAF_BITS 256\n-#endif\n+#define WNAF_BITS 128\n #define WNAF_SIZE_BITS(bits, w) (((bits) + (w) - 1) / (w))\n #define WNAF_SIZE(w) WNAF_SIZE_BITS(WNAF_BITS, w)\n \n@@ -77,17 +73,9 @@\n #define PIPPENGER_MAX_BUCKET_WINDOW 12\n \n /* Minimum number of points for which pippenger_wnaf is faster than strauss wnaf */\n-#ifdef USE_ENDOMORPHISM\n-    #define ECMULT_PIPPENGER_THRESHOLD 88\n-#else\n-    #define ECMULT_PIPPENGER_THRESHOLD 160\n-#endif\n+#define ECMULT_PIPPENGER_THRESHOLD 88\n \n-#ifdef USE_ENDOMORPHISM\n-    #define ECMULT_MAX_POINTS_PER_BATCH 5000000\n-#else\n-    #define ECMULT_MAX_POINTS_PER_BATCH 10000000\n-#endif\n+#define ECMULT_MAX_POINTS_PER_BATCH 5000000\n \n /** Fill a table 'prej' with precomputed odd multiples of a. Prej will contain\n  *  the values [1*a,3*a,...,(2*n-1)*a], so it space for n values. zr[0] will\n@@ -313,16 +301,12 @@ static void secp256k1_ecmult_odd_multiples_table_storage_var(const int n, secp25\n \n static const size_t SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE =\n     ROUND_TO_ALIGN(sizeof((*((secp256k1_ecmult_context*) NULL)->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G))\n-#ifdef USE_ENDOMORPHISM\n     + ROUND_TO_ALIGN(sizeof((*((secp256k1_ecmult_context*) NULL)->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G))\n-#endif\n     ;\n \n static void secp256k1_ecmult_context_init(secp256k1_ecmult_context *ctx) {\n     ctx->pre_g = NULL;\n-#ifdef USE_ENDOMORPHISM\n     ctx->pre_g_128 = NULL;\n-#endif\n }\n \n static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, void **prealloc) {\n@@ -347,7 +331,6 @@ static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, void *\n     /* precompute the tables with odd multiples */\n     secp256k1_ecmult_odd_multiples_table_storage_var(ECMULT_TABLE_SIZE(WINDOW_G), *ctx->pre_g, &gj);\n \n-#ifdef USE_ENDOMORPHISM\n     {\n         secp256k1_gej g_128j;\n         int i;\n@@ -364,19 +347,16 @@ static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, void *\n         }\n         secp256k1_ecmult_odd_multiples_table_storage_var(ECMULT_TABLE_SIZE(WINDOW_G), *ctx->pre_g_128, &g_128j);\n     }\n-#endif\n }\n \n static void secp256k1_ecmult_context_finalize_memcpy(secp256k1_ecmult_context *dst, const secp256k1_ecmult_context *src) {\n     if (src->pre_g != NULL) {\n         /* We cast to void* first to suppress a -Wcast-align warning. */\n         dst->pre_g = (secp256k1_ge_storage (*)[])(void*)((unsigned char*)dst + ((unsigned char*)(src->pre_g) - (unsigned char*)src));\n     }\n-#ifdef USE_ENDOMORPHISM\n     if (src->pre_g_128 != NULL) {\n         dst->pre_g_128 = (secp256k1_ge_storage (*)[])(void*)((unsigned char*)dst + ((unsigned char*)(src->pre_g_128) - (unsigned char*)src));\n     }\n-#endif\n }\n \n static int secp256k1_ecmult_context_is_built(const secp256k1_ecmult_context *ctx) {\n@@ -447,43 +427,31 @@ static int secp256k1_ecmult_wnaf(int *wnaf, int len, const secp256k1_scalar *a,\n }\n \n struct secp256k1_strauss_point_state {\n-#ifdef USE_ENDOMORPHISM\n     secp256k1_scalar na_1, na_lam;\n-    int wnaf_na_1[130];\n-    int wnaf_na_lam[130];\n+    int wnaf_na_1[129];\n+    int wnaf_na_lam[129];\n     int bits_na_1;\n     int bits_na_lam;\n-#else\n-    int wnaf_na[256];\n-    int bits_na;\n-#endif\n     size_t input_pos;\n };\n \n struct secp256k1_strauss_state {\n     secp256k1_gej* prej;\n     secp256k1_fe* zr;\n     secp256k1_ge* pre_a;\n-#ifdef USE_ENDOMORPHISM\n     secp256k1_ge* pre_a_lam;\n-#endif\n     struct secp256k1_strauss_point_state* ps;\n };\n \n static void secp256k1_ecmult_strauss_wnaf(const secp256k1_ecmult_context *ctx, const struct secp256k1_strauss_state *state, secp256k1_gej *r, int num, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n     secp256k1_ge tmpa;\n     secp256k1_fe Z;\n-#ifdef USE_ENDOMORPHISM\n     /* Splitted G factors. */\n     secp256k1_scalar ng_1, ng_128;\n     int wnaf_ng_1[129];\n     int bits_ng_1 = 0;\n     int wnaf_ng_128[129];\n     int bits_ng_128 = 0;\n-#else\n-    int wnaf_ng[256];\n-    int bits_ng = 0;\n-#endif\n     int i;\n     int bits = 0;\n     int np;\n@@ -494,28 +462,20 @@ static void secp256k1_ecmult_strauss_wnaf(const secp256k1_ecmult_context *ctx, c\n             continue;\n         }\n         state->ps[no].input_pos = np;\n-#ifdef USE_ENDOMORPHISM\n         /* split na into na_1 and na_lam (where na = na_1 + na_lam*lambda, and na_1 and na_lam are ~128 bit) */\n         secp256k1_scalar_split_lambda(&state->ps[no].na_1, &state->ps[no].na_lam, &na[np]);\n \n         /* build wnaf representation for na_1 and na_lam. */\n-        state->ps[no].bits_na_1   = secp256k1_ecmult_wnaf(state->ps[no].wnaf_na_1,   130, &state->ps[no].na_1,   WINDOW_A);\n-        state->ps[no].bits_na_lam = secp256k1_ecmult_wnaf(state->ps[no].wnaf_na_lam, 130, &state->ps[no].na_lam, WINDOW_A);\n-        VERIFY_CHECK(state->ps[no].bits_na_1 <= 130);\n-        VERIFY_CHECK(state->ps[no].bits_na_lam <= 130);\n+        state->ps[no].bits_na_1   = secp256k1_ecmult_wnaf(state->ps[no].wnaf_na_1,   129, &state->ps[no].na_1,   WINDOW_A);\n+        state->ps[no].bits_na_lam = secp256k1_ecmult_wnaf(state->ps[no].wnaf_na_lam, 129, &state->ps[no].na_lam, WINDOW_A);\n+        VERIFY_CHECK(state->ps[no].bits_na_1 <= 129);\n+        VERIFY_CHECK(state->ps[no].bits_na_lam <= 129);\n         if (state->ps[no].bits_na_1 > bits) {\n             bits = state->ps[no].bits_na_1;\n         }\n         if (state->ps[no].bits_na_lam > bits) {\n             bits = state->ps[no].bits_na_lam;\n         }\n-#else\n-        /* build wnaf representation for na. */\n-        state->ps[no].bits_na     = secp256k1_ecmult_wnaf(state->ps[no].wnaf_na,     256, &na[np],      WINDOW_A);\n-        if (state->ps[no].bits_na > bits) {\n-            bits = state->ps[no].bits_na;\n-        }\n-#endif\n         ++no;\n     }\n \n@@ -547,7 +507,6 @@ static void secp256k1_ecmult_strauss_wnaf(const secp256k1_ecmult_context *ctx, c\n         secp256k1_fe_set_int(&Z, 1);\n     }\n \n-#ifdef USE_ENDOMORPHISM\n     for (np = 0; np < no; ++np) {\n         for (i = 0; i < ECMULT_TABLE_SIZE(WINDOW_A); i++) {\n             secp256k1_ge_mul_lambda(&state->pre_a_lam[np * ECMULT_TABLE_SIZE(WINDOW_A) + i], &state->pre_a[np * ECMULT_TABLE_SIZE(WINDOW_A) + i]);\n@@ -568,21 +527,12 @@ static void secp256k1_ecmult_strauss_wnaf(const secp256k1_ecmult_context *ctx, c\n             bits = bits_ng_128;\n         }\n     }\n-#else\n-    if (ng) {\n-        bits_ng     = secp256k1_ecmult_wnaf(wnaf_ng,     256, ng,      WINDOW_G);\n-        if (bits_ng > bits) {\n-            bits = bits_ng;\n-        }\n-    }\n-#endif\n \n     secp256k1_gej_set_infinity(r);\n \n     for (i = bits - 1; i >= 0; i--) {\n         int n;\n         secp256k1_gej_double_var(r, r, NULL);\n-#ifdef USE_ENDOMORPHISM\n         for (np = 0; np < no; ++np) {\n             if (i < state->ps[np].bits_na_1 && (n = state->ps[np].wnaf_na_1[i])) {\n                 ECMULT_TABLE_GET_GE(&tmpa, state->pre_a + np * ECMULT_TABLE_SIZE(WINDOW_A), n, WINDOW_A);\n@@ -601,18 +551,6 @@ static void secp256k1_ecmult_strauss_wnaf(const secp256k1_ecmult_context *ctx, c\n             ECMULT_TABLE_GET_GE_STORAGE(&tmpa, *ctx->pre_g_128, n, WINDOW_G);\n             secp256k1_gej_add_zinv_var(r, r, &tmpa, &Z);\n         }\n-#else\n-        for (np = 0; np < no; ++np) {\n-            if (i < state->ps[np].bits_na && (n = state->ps[np].wnaf_na[i])) {\n-                ECMULT_TABLE_GET_GE(&tmpa, state->pre_a + np * ECMULT_TABLE_SIZE(WINDOW_A), n, WINDOW_A);\n-                secp256k1_gej_add_ge_var(r, r, &tmpa, NULL);\n-            }\n-        }\n-        if (i < bits_ng && (n = wnaf_ng[i])) {\n-            ECMULT_TABLE_GET_GE_STORAGE(&tmpa, *ctx->pre_g, n, WINDOW_G);\n-            secp256k1_gej_add_zinv_var(r, r, &tmpa, &Z);\n-        }\n-#endif\n     }\n \n     if (!r->infinity) {\n@@ -625,27 +563,19 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n     secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n     struct secp256k1_strauss_point_state ps[1];\n-#ifdef USE_ENDOMORPHISM\n     secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n-#endif\n     struct secp256k1_strauss_state state;\n \n     state.prej = prej;\n     state.zr = zr;\n     state.pre_a = pre_a;\n-#ifdef USE_ENDOMORPHISM\n     state.pre_a_lam = pre_a_lam;\n-#endif\n     state.ps = ps;\n     secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n }\n \n static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n-#ifdef USE_ENDOMORPHISM\n     static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n-#else\n-    static const size_t point_size = (sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n-#endif\n     return n_points*point_size;\n }\n \n@@ -665,12 +595,8 @@ static int secp256k1_ecmult_strauss_batch(const secp256k1_callback* error_callba\n     scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(error_callback, scratch, n_points * sizeof(secp256k1_scalar));\n     state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(error_callback, scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n     state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(error_callback, scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n-#ifdef USE_ENDOMORPHISM\n     state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(error_callback, scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n     state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n-#else\n-    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(error_callback, scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n-#endif\n     state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(error_callback, scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n \n     if (points == NULL || scalars == NULL || state.prej == NULL || state.zr == NULL || state.pre_a == NULL) {\n@@ -868,7 +794,6 @@ static int secp256k1_ecmult_pippenger_wnaf(secp256k1_gej *buckets, int bucket_wi\n  * set of buckets) for a given number of points.\n  */\n static int secp256k1_pippenger_bucket_window(size_t n) {\n-#ifdef USE_ENDOMORPHISM\n     if (n <= 1) {\n         return 1;\n     } else if (n <= 4) {\n@@ -892,41 +817,13 @@ static int secp256k1_pippenger_bucket_window(size_t n) {\n     } else {\n         return PIPPENGER_MAX_BUCKET_WINDOW;\n     }\n-#else\n-    if (n <= 1) {\n-        return 1;\n-    } else if (n <= 11) {\n-        return 2;\n-    } else if (n <= 45) {\n-        return 3;\n-    } else if (n <= 100) {\n-        return 4;\n-    } else if (n <= 275) {\n-        return 5;\n-    } else if (n <= 625) {\n-        return 6;\n-    } else if (n <= 1850) {\n-        return 7;\n-    } else if (n <= 3400) {\n-        return 8;\n-    } else if (n <= 9630) {\n-        return 9;\n-    } else if (n <= 17900) {\n-        return 10;\n-    } else if (n <= 32800) {\n-        return 11;\n-    } else {\n-        return PIPPENGER_MAX_BUCKET_WINDOW;\n-    }\n-#endif\n }\n \n /**\n  * Returns the maximum optimal number of points for a bucket_window.\n  */\n static size_t secp256k1_pippenger_bucket_window_inv(int bucket_window) {\n     switch(bucket_window) {\n-#ifdef USE_ENDOMORPHISM\n         case 1: return 1;\n         case 2: return 4;\n         case 3: return 20;\n@@ -939,26 +836,11 @@ static size_t secp256k1_pippenger_bucket_window_inv(int bucket_window) {\n         case 10: return 7880;\n         case 11: return 16050;\n         case PIPPENGER_MAX_BUCKET_WINDOW: return SIZE_MAX;\n-#else\n-        case 1: return 1;\n-        case 2: return 11;\n-        case 3: return 45;\n-        case 4: return 100;\n-        case 5: return 275;\n-        case 6: return 625;\n-        case 7: return 1850;\n-        case 8: return 3400;\n-        case 9: return 9630;\n-        case 10: return 17900;\n-        case 11: return 32800;\n-        case PIPPENGER_MAX_BUCKET_WINDOW: return SIZE_MAX;\n-#endif\n     }\n     return 0;\n }\n \n \n-#ifdef USE_ENDOMORPHISM\n SECP256K1_INLINE static void secp256k1_ecmult_endo_split(secp256k1_scalar *s1, secp256k1_scalar *s2, secp256k1_ge *p1, secp256k1_ge *p2) {\n     secp256k1_scalar tmp = *s1;\n     secp256k1_scalar_split_lambda(s1, s2, &tmp);\n@@ -973,32 +855,23 @@ SECP256K1_INLINE static void secp256k1_ecmult_endo_split(secp256k1_scalar *s1, s\n         secp256k1_ge_neg(p2, p2);\n     }\n }\n-#endif\n \n /**\n  * Returns the scratch size required for a given number of points (excluding\n  * base point G) without considering alignment.\n  */\n static size_t secp256k1_pippenger_scratch_size(size_t n_points, int bucket_window) {\n-#ifdef USE_ENDOMORPHISM\n     size_t entries = 2*n_points + 2;\n-#else\n-    size_t entries = n_points + 1;\n-#endif\n     size_t entry_size = sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) + sizeof(struct secp256k1_pippenger_point_state) + (WNAF_SIZE(bucket_window+1)+1)*sizeof(int);\n     return (sizeof(secp256k1_gej) << bucket_window) + sizeof(struct secp256k1_pippenger_state) + entries * entry_size;\n }\n \n static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n     const size_t scratch_checkpoint = secp256k1_scratch_checkpoint(error_callback, scratch);\n-    /* Use 2(n+1) with the endomorphism, n+1 without, when calculating batch\n+    /* Use 2(n+1) with the endomorphism, when calculating batch\n      * sizes. The reason for +1 is that we add the G scalar to the list of\n      * other scalars. */\n-#ifdef USE_ENDOMORPHISM\n     size_t entries = 2*n_points + 2;\n-#else\n-    size_t entries = n_points + 1;\n-#endif\n     secp256k1_ge *points;\n     secp256k1_scalar *scalars;\n     secp256k1_gej *buckets;\n@@ -1035,10 +908,8 @@ static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_call\n         scalars[0] = *inp_g_sc;\n         points[0] = secp256k1_ge_const_g;\n         idx++;\n-#ifdef USE_ENDOMORPHISM\n         secp256k1_ecmult_endo_split(&scalars[0], &scalars[1], &points[0], &points[1]);\n         idx++;\n-#endif\n     }\n \n     while (point_idx < n_points) {\n@@ -1047,10 +918,8 @@ static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_call\n             return 0;\n         }\n         idx++;\n-#ifdef USE_ENDOMORPHISM\n         secp256k1_ecmult_endo_split(&scalars[idx - 1], &scalars[idx], &points[idx - 1], &points[idx]);\n         idx++;\n-#endif\n         point_idx++;\n     }\n \n@@ -1093,9 +962,7 @@ static size_t secp256k1_pippenger_max_points(const secp256k1_callback* error_cal\n         size_t space_overhead;\n         size_t entry_size = sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) + sizeof(struct secp256k1_pippenger_point_state) + (WNAF_SIZE(bucket_window+1)+1)*sizeof(int);\n \n-#ifdef USE_ENDOMORPHISM\n         entry_size = 2*entry_size;\n-#endif\n         space_overhead = (sizeof(secp256k1_gej) << bucket_window) + entry_size + sizeof(struct secp256k1_pippenger_state);\n         if (space_overhead > max_alloc) {\n             break;"
      },
      {
        "sha": "36e39ecf0f159ba6c3b234dfde8c06e267525b05",
        "filename": "src/secp256k1/src/group.h",
        "status": "modified",
        "additions": 12,
        "deletions": 2,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/group.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/group.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group.h?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -59,6 +59,7 @@ static int secp256k1_ge_is_infinity(const secp256k1_ge *a);\n /** Check whether a group element is valid (i.e., on the curve). */\n static int secp256k1_ge_is_valid_var(const secp256k1_ge *a);\n \n+/** Set r equal to the inverse of a (i.e., mirrored around the X axis) */\n static void secp256k1_ge_neg(secp256k1_ge *r, const secp256k1_ge *a);\n \n /** Set a group element equal to another which is given in jacobian coordinates */\n@@ -115,10 +116,8 @@ static void secp256k1_gej_add_ge_var(secp256k1_gej *r, const secp256k1_gej *a, c\n /** Set r equal to the sum of a and b (with the inverse of b's Z coordinate passed as bzinv). */\n static void secp256k1_gej_add_zinv_var(secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_ge *b, const secp256k1_fe *bzinv);\n \n-#ifdef USE_ENDOMORPHISM\n /** Set r to be equal to lambda times a, where lambda is chosen in a way such that this is very fast. */\n static void secp256k1_ge_mul_lambda(secp256k1_ge *r, const secp256k1_ge *a);\n-#endif\n \n /** Clear a secp256k1_gej to prevent leaking sensitive information. */\n static void secp256k1_gej_clear(secp256k1_gej *r);\n@@ -138,4 +137,15 @@ static void secp256k1_ge_storage_cmov(secp256k1_ge_storage *r, const secp256k1_g\n /** Rescale a jacobian point by b which must be non-zero. Constant-time. */\n static void secp256k1_gej_rescale(secp256k1_gej *r, const secp256k1_fe *b);\n \n+/** Determine if a point (which is assumed to be on the curve) is in the correct (sub)group of the curve.\n+ *\n+ * In normal mode, the used group is secp256k1, which has cofactor=1 meaning that every point on the curve is in the\n+ * group, and this function returns always true.\n+ *\n+ * When compiling in exhaustive test mode, a slightly different curve equation is used, leading to a group with a\n+ * (very) small subgroup, and that subgroup is what is used for all cryptographic operations. In that mode, this\n+ * function checks whether a point that is on the curve is in fact also in that subgroup.\n+ */\n+static int secp256k1_ge_is_in_correct_subgroup(const secp256k1_ge* ge);\n+\n #endif /* SECP256K1_GROUP_H */"
      },
      {
        "sha": "a5fbc91a0f88d2e9eddcb13072b95d9f5938c258",
        "filename": "src/secp256k1/src/group_impl.h",
        "status": "modified",
        "additions": 52,
        "deletions": 66,
        "changes": 118,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group_impl.h?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -11,49 +11,38 @@\n #include \"field.h\"\n #include \"group.h\"\n \n-/* These points can be generated in sage as follows:\n+/* These exhaustive group test orders and generators are chosen such that:\n+ * - The field size is equal to that of secp256k1, so field code is the same.\n+ * - The curve equation is of the form y^2=x^3+B for some constant B.\n+ * - The subgroup has a generator 2*P, where P.x=1.\n+ * - The subgroup has size less than 1000 to permit exhaustive testing.\n+ * - The subgroup admits an endomorphism of the form lambda*(x,y) == (beta*x,y).\n  *\n- * 0. Setup a worksheet with the following parameters.\n- *   b = 4  # whatever CURVE_B will be set to\n- *   F = FiniteField (0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F)\n- *   C = EllipticCurve ([F (0), F (b)])\n- *\n- * 1. Determine all the small orders available to you. (If there are\n- *    no satisfactory ones, go back and change b.)\n- *   print C.order().factor(limit=1000)\n- *\n- * 2. Choose an order as one of the prime factors listed in the above step.\n- *    (You can also multiply some to get a composite order, though the\n- *    tests will crash trying to invert scalars during signing.) We take a\n- *    random point and scale it to drop its order to the desired value.\n- *    There is some probability this won't work; just try again.\n- *   order = 199\n- *   P = C.random_point()\n- *   P = (int(P.order()) / int(order)) * P\n- *   assert(P.order() == order)\n- *\n- * 3. Print the values. You'll need to use a vim macro or something to\n- *    split the hex output into 4-byte chunks.\n- *   print \"%x %x\" % P.xy()\n+ * These parameters are generated using sage/gen_exhaustive_groups.sage.\n  */\n #if defined(EXHAUSTIVE_TEST_ORDER)\n-#  if EXHAUSTIVE_TEST_ORDER == 199\n+#  if EXHAUSTIVE_TEST_ORDER == 13\n static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n-    0xFA7CC9A7, 0x0737F2DB, 0xA749DD39, 0x2B4FB069,\n-    0x3B017A7D, 0xA808C2F1, 0xFB12940C, 0x9EA66C18,\n-    0x78AC123A, 0x5ED8AEF3, 0x8732BC91, 0x1F3A2868,\n-    0x48DF246C, 0x808DAE72, 0xCFE52572, 0x7F0501ED\n+    0xc3459c3d, 0x35326167, 0xcd86cce8, 0x07a2417f,\n+    0x5b8bd567, 0xde8538ee, 0x0d507b0c, 0xd128f5bb,\n+    0x8e467fec, 0xcd30000a, 0x6cc1184e, 0x25d382c2,\n+    0xa2f4494e, 0x2fbe9abc, 0x8b64abac, 0xd005fb24\n );\n-\n-static const int CURVE_B = 4;\n-#  elif EXHAUSTIVE_TEST_ORDER == 13\n+static const secp256k1_fe secp256k1_fe_const_b = SECP256K1_FE_CONST(\n+    0x3d3486b2, 0x159a9ca5, 0xc75638be, 0xb23a69bc,\n+    0x946a45ab, 0x24801247, 0xb4ed2b8e, 0x26b6a417\n+);\n+#  elif EXHAUSTIVE_TEST_ORDER == 199\n static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n-    0xedc60018, 0xa51a786b, 0x2ea91f4d, 0x4c9416c0,\n-    0x9de54c3b, 0xa1316554, 0x6cf4345c, 0x7277ef15,\n-    0x54cb1b6b, 0xdc8c1273, 0x087844ea, 0x43f4603e,\n-    0x0eaf9a43, 0xf6effe55, 0x939f806d, 0x37adf8ac\n+    0x226e653f, 0xc8df7744, 0x9bacbf12, 0x7d1dcbf9,\n+    0x87f05b2a, 0xe7edbd28, 0x1f564575, 0xc48dcf18,\n+    0xa13872c2, 0xe933bb17, 0x5d9ffd5b, 0xb5b6e10c,\n+    0x57fe3c00, 0xbaaaa15a, 0xe003ec3e, 0x9c269bae\n+);\n+static const secp256k1_fe secp256k1_fe_const_b = SECP256K1_FE_CONST(\n+    0x2cca28fa, 0xfc614b80, 0x2a3db42b, 0x00ba00b1,\n+    0xbea8d943, 0xdace9ab2, 0x9536daea, 0x0074defb\n );\n-static const int CURVE_B = 2;\n #  else\n #    error No known generator for the specified exhaustive test group order.\n #  endif\n@@ -68,7 +57,7 @@ static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n     0xFD17B448UL, 0xA6855419UL, 0x9C47D08FUL, 0xFB10D4B8UL\n );\n \n-static const int CURVE_B = 7;\n+static const secp256k1_fe secp256k1_fe_const_b = SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 7);\n #endif\n \n static void secp256k1_ge_set_gej_zinv(secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_fe *zi) {\n@@ -219,14 +208,13 @@ static void secp256k1_ge_clear(secp256k1_ge *r) {\n }\n \n static int secp256k1_ge_set_xquad(secp256k1_ge *r, const secp256k1_fe *x) {\n-    secp256k1_fe x2, x3, c;\n+    secp256k1_fe x2, x3;\n     r->x = *x;\n     secp256k1_fe_sqr(&x2, x);\n     secp256k1_fe_mul(&x3, x, &x2);\n     r->infinity = 0;\n-    secp256k1_fe_set_int(&c, CURVE_B);\n-    secp256k1_fe_add(&c, &x3);\n-    return secp256k1_fe_sqrt(&r->y, &c);\n+    secp256k1_fe_add(&x3, &secp256k1_fe_const_b);\n+    return secp256k1_fe_sqrt(&r->y, &x3);\n }\n \n static int secp256k1_ge_set_xo_var(secp256k1_ge *r, const secp256k1_fe *x, int odd) {\n@@ -269,36 +257,15 @@ static int secp256k1_gej_is_infinity(const secp256k1_gej *a) {\n     return a->infinity;\n }\n \n-static int secp256k1_gej_is_valid_var(const secp256k1_gej *a) {\n-    secp256k1_fe y2, x3, z2, z6;\n-    if (a->infinity) {\n-        return 0;\n-    }\n-    /** y^2 = x^3 + 7\n-     *  (Y/Z^3)^2 = (X/Z^2)^3 + 7\n-     *  Y^2 / Z^6 = X^3 / Z^6 + 7\n-     *  Y^2 = X^3 + 7*Z^6\n-     */\n-    secp256k1_fe_sqr(&y2, &a->y);\n-    secp256k1_fe_sqr(&x3, &a->x); secp256k1_fe_mul(&x3, &x3, &a->x);\n-    secp256k1_fe_sqr(&z2, &a->z);\n-    secp256k1_fe_sqr(&z6, &z2); secp256k1_fe_mul(&z6, &z6, &z2);\n-    secp256k1_fe_mul_int(&z6, CURVE_B);\n-    secp256k1_fe_add(&x3, &z6);\n-    secp256k1_fe_normalize_weak(&x3);\n-    return secp256k1_fe_equal_var(&y2, &x3);\n-}\n-\n static int secp256k1_ge_is_valid_var(const secp256k1_ge *a) {\n-    secp256k1_fe y2, x3, c;\n+    secp256k1_fe y2, x3;\n     if (a->infinity) {\n         return 0;\n     }\n     /* y^2 = x^3 + 7 */\n     secp256k1_fe_sqr(&y2, &a->y);\n     secp256k1_fe_sqr(&x3, &a->x); secp256k1_fe_mul(&x3, &x3, &a->x);\n-    secp256k1_fe_set_int(&c, CURVE_B);\n-    secp256k1_fe_add(&x3, &c);\n+    secp256k1_fe_add(&x3, &secp256k1_fe_const_b);\n     secp256k1_fe_normalize_weak(&x3);\n     return secp256k1_fe_equal_var(&y2, &x3);\n }\n@@ -679,7 +646,6 @@ static SECP256K1_INLINE void secp256k1_ge_storage_cmov(secp256k1_ge_storage *r,\n     secp256k1_fe_storage_cmov(&r->y, &a->y, flag);\n }\n \n-#ifdef USE_ENDOMORPHISM\n static void secp256k1_ge_mul_lambda(secp256k1_ge *r, const secp256k1_ge *a) {\n     static const secp256k1_fe beta = SECP256K1_FE_CONST(\n         0x7ae96a2bul, 0x657c0710ul, 0x6e64479eul, 0xac3434e9ul,\n@@ -688,7 +654,6 @@ static void secp256k1_ge_mul_lambda(secp256k1_ge *r, const secp256k1_ge *a) {\n     *r = *a;\n     secp256k1_fe_mul(&r->x, &r->x, &beta);\n }\n-#endif\n \n static int secp256k1_gej_has_quad_y_var(const secp256k1_gej *a) {\n     secp256k1_fe yz;\n@@ -704,4 +669,25 @@ static int secp256k1_gej_has_quad_y_var(const secp256k1_gej *a) {\n     return secp256k1_fe_is_quad_var(&yz);\n }\n \n+static int secp256k1_ge_is_in_correct_subgroup(const secp256k1_ge* ge) {\n+#ifdef EXHAUSTIVE_TEST_ORDER\n+    secp256k1_gej out;\n+    int i;\n+\n+    /* A very simple EC multiplication ladder that avoids a dependecy on ecmult. */\n+    secp256k1_gej_set_infinity(&out);\n+    for (i = 0; i < 32; ++i) {\n+        secp256k1_gej_double_var(&out, &out, NULL);\n+        if ((((uint32_t)EXHAUSTIVE_TEST_ORDER) >> (31 - i)) & 1) {\n+            secp256k1_gej_add_ge_var(&out, &out, ge, NULL);\n+        }\n+    }\n+    return secp256k1_gej_is_infinity(&out);\n+#else\n+    (void)ge;\n+    /* The real secp256k1 group has cofactor 1, so the subgroup is the entire curve. */\n+    return 1;\n+#endif\n+}\n+\n #endif /* SECP256K1_GROUP_IMPL_H */"
      },
      {
        "sha": "e8d2aeab9a59b25fbceabf87fa8c0aab7f01dfd5",
        "filename": "src/secp256k1/src/modules/ecdh/tests_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/modules/ecdh/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/modules/ecdh/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/ecdh/tests_impl.h?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -80,7 +80,7 @@ void test_ecdh_generator_basepoint(void) {\n         /* compute \"explicitly\" */\n         CHECK(secp256k1_ec_pubkey_serialize(ctx, point_ser, &point_ser_len, &point[1], SECP256K1_EC_UNCOMPRESSED) == 1);\n         /* compare */\n-        CHECK(memcmp(output_ecdh, point_ser, 65) == 0);\n+        CHECK(secp256k1_memcmp_var(output_ecdh, point_ser, 65) == 0);\n \n         /* compute using ECDH function with default hash function */\n         CHECK(secp256k1_ecdh(ctx, output_ecdh, &point[0], s_b32, NULL, NULL) == 1);\n@@ -90,7 +90,7 @@ void test_ecdh_generator_basepoint(void) {\n         secp256k1_sha256_write(&sha, point_ser, point_ser_len);\n         secp256k1_sha256_finalize(&sha, output_ser);\n         /* compare */\n-        CHECK(memcmp(output_ecdh, output_ser, 32) == 0);\n+        CHECK(secp256k1_memcmp_var(output_ecdh, output_ser, 32) == 0);\n     }\n }\n "
      },
      {
        "sha": "0d901ec1f4495a56bebb918dd5a351e9e52c7d92",
        "filename": "src/secp256k1/src/modules/extrakeys/Makefile.am.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/modules/extrakeys/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/modules/extrakeys/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/extrakeys/Makefile.am.include?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -1,3 +1,4 @@\n include_HEADERS += include/secp256k1_extrakeys.h\n noinst_HEADERS += src/modules/extrakeys/tests_impl.h\n+noinst_HEADERS += src/modules/extrakeys/tests_exhaustive_impl.h\n noinst_HEADERS += src/modules/extrakeys/main_impl.h"
      },
      {
        "sha": "5378d2f301bc9e79d88f04d7b823fbbd94bf8f95",
        "filename": "src/secp256k1/src/modules/extrakeys/main_impl.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/modules/extrakeys/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/modules/extrakeys/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/extrakeys/main_impl.h?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -33,6 +33,9 @@ int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_p\n     if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\n         return 0;\n     }\n+    if (!secp256k1_ge_is_in_correct_subgroup(&pk)) {\n+        return 0;\n+    }\n     secp256k1_xonly_pubkey_save(pubkey, &pk);\n     return 1;\n }\n@@ -121,7 +124,7 @@ int secp256k1_xonly_pubkey_tweak_add_check(const secp256k1_context* ctx, const u\n     secp256k1_fe_normalize_var(&pk.y);\n     secp256k1_fe_get_b32(pk_expected32, &pk.x);\n \n-    return memcmp(&pk_expected32, tweaked_pubkey32, 32) == 0\n+    return secp256k1_memcmp_var(&pk_expected32, tweaked_pubkey32, 32) == 0\n             && secp256k1_fe_is_odd(&pk.y) == tweaked_pk_parity;\n }\n "
      },
      {
        "sha": "0e29bc6b09d951f3fc3517d0f14470f6d8d29a48",
        "filename": "src/secp256k1/src/modules/extrakeys/tests_exhaustive_impl.h",
        "status": "added",
        "additions": 68,
        "deletions": 0,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/modules/extrakeys/tests_exhaustive_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/modules/extrakeys/tests_exhaustive_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/extrakeys/tests_exhaustive_impl.h?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -0,0 +1,68 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Pieter Wuille                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_EXTRAKEYS_TESTS_EXHAUSTIVE_\n+#define _SECP256K1_MODULE_EXTRAKEYS_TESTS_EXHAUSTIVE_\n+\n+#include \"src/modules/extrakeys/main_impl.h\"\n+#include \"include/secp256k1_extrakeys.h\"\n+\n+static void test_exhaustive_extrakeys(const secp256k1_context *ctx, const secp256k1_ge* group) {\n+    secp256k1_keypair keypair[EXHAUSTIVE_TEST_ORDER - 1];\n+    secp256k1_pubkey pubkey[EXHAUSTIVE_TEST_ORDER - 1];\n+    secp256k1_xonly_pubkey xonly_pubkey[EXHAUSTIVE_TEST_ORDER - 1];\n+    int parities[EXHAUSTIVE_TEST_ORDER - 1];\n+    unsigned char xonly_pubkey_bytes[EXHAUSTIVE_TEST_ORDER - 1][32];\n+    int i;\n+\n+    for (i = 1; i < EXHAUSTIVE_TEST_ORDER; i++) {\n+        secp256k1_fe fe;\n+        secp256k1_scalar scalar_i;\n+        unsigned char buf[33];\n+        int parity;\n+\n+        secp256k1_scalar_set_int(&scalar_i, i);\n+        secp256k1_scalar_get_b32(buf, &scalar_i);\n+\n+        /* Construct pubkey and keypair. */\n+        CHECK(secp256k1_keypair_create(ctx, &keypair[i - 1], buf));\n+        CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey[i - 1], buf));\n+\n+        /* Construct serialized xonly_pubkey from keypair. */\n+        CHECK(secp256k1_keypair_xonly_pub(ctx, &xonly_pubkey[i - 1], &parities[i - 1], &keypair[i - 1]));\n+        CHECK(secp256k1_xonly_pubkey_serialize(ctx, xonly_pubkey_bytes[i - 1], &xonly_pubkey[i - 1]));\n+\n+        /* Parse the xonly_pubkey back and verify it matches the previously serialized value. */\n+        CHECK(secp256k1_xonly_pubkey_parse(ctx, &xonly_pubkey[i - 1], xonly_pubkey_bytes[i - 1]));\n+        CHECK(secp256k1_xonly_pubkey_serialize(ctx, buf, &xonly_pubkey[i - 1]));\n+        CHECK(secp256k1_memcmp_var(xonly_pubkey_bytes[i - 1], buf, 32) == 0);\n+\n+        /* Construct the xonly_pubkey from the pubkey, and verify it matches the same. */\n+        CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &xonly_pubkey[i - 1], &parity, &pubkey[i - 1]));\n+        CHECK(parity == parities[i - 1]);\n+        CHECK(secp256k1_xonly_pubkey_serialize(ctx, buf, &xonly_pubkey[i - 1]));\n+        CHECK(secp256k1_memcmp_var(xonly_pubkey_bytes[i - 1], buf, 32) == 0);\n+\n+        /* Compare the xonly_pubkey bytes against the precomputed group. */\n+        secp256k1_fe_set_b32(&fe, xonly_pubkey_bytes[i - 1]);\n+        CHECK(secp256k1_fe_equal_var(&fe, &group[i].x));\n+\n+        /* Check the parity against the precomputed group. */\n+        fe = group[i].y;\n+        secp256k1_fe_normalize_var(&fe);\n+        CHECK(secp256k1_fe_is_odd(&fe) == parities[i - 1]);\n+\n+        /* Verify that the higher half is identical to the lower half mirrored. */\n+        if (i > EXHAUSTIVE_TEST_ORDER / 2) {\n+            CHECK(secp256k1_memcmp_var(xonly_pubkey_bytes[i - 1], xonly_pubkey_bytes[EXHAUSTIVE_TEST_ORDER - i - 1], 32) == 0);\n+            CHECK(parities[i - 1] == 1 - parities[EXHAUSTIVE_TEST_ORDER - i - 1]);\n+        }\n+    }\n+\n+    /* TODO: keypair/xonly_pubkey tweak tests */\n+}\n+\n+#endif"
      },
      {
        "sha": "5ee135849ef21682be45d3d177acbc02f66e10f0",
        "filename": "src/secp256k1/src/modules/extrakeys/tests_impl.h",
        "status": "modified",
        "additions": 48,
        "deletions": 48,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/modules/extrakeys/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/modules/extrakeys/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/extrakeys/tests_impl.h?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -35,9 +35,9 @@ void test_xonly_pubkey(void) {\n     secp256k1_context *sign = api_test_context(SECP256K1_CONTEXT_SIGN, &ecount);\n     secp256k1_context *verify = api_test_context(SECP256K1_CONTEXT_VERIFY, &ecount);\n \n-    secp256k1_rand256(sk);\n+    secp256k1_testrand256(sk);\n     memset(ones32, 0xFF, 32);\n-    secp256k1_rand256(xy_sk);\n+    secp256k1_testrand256(xy_sk);\n     CHECK(secp256k1_ec_pubkey_create(sign, &pk, sk) == 1);\n     CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &xonly_pk, &pk_parity, &pk) == 1);\n \n@@ -60,15 +60,15 @@ void test_xonly_pubkey(void) {\n     sk[0] = 1;\n     CHECK(secp256k1_ec_pubkey_create(ctx, &pk, sk) == 1);\n     CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &xonly_pk, &pk_parity, &pk) == 1);\n-    CHECK(memcmp(&pk, &xonly_pk, sizeof(pk)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pk, &xonly_pk, sizeof(pk)) == 0);\n     CHECK(pk_parity == 0);\n \n     /* Choose a secret key such that pubkey and xonly_pubkey are each others\n      * negation. */\n     sk[0] = 2;\n     CHECK(secp256k1_ec_pubkey_create(ctx, &pk, sk) == 1);\n     CHECK(secp256k1_xonly_pubkey_from_pubkey(ctx, &xonly_pk, &pk_parity, &pk) == 1);\n-    CHECK(memcmp(&xonly_pk, &pk, sizeof(xonly_pk)) != 0);\n+    CHECK(secp256k1_memcmp_var(&xonly_pk, &pk, sizeof(xonly_pk)) != 0);\n     CHECK(pk_parity == 1);\n     secp256k1_pubkey_load(ctx, &pk1, &pk);\n     secp256k1_pubkey_load(ctx, &pk2, (secp256k1_pubkey *) &xonly_pk);\n@@ -81,7 +81,7 @@ void test_xonly_pubkey(void) {\n     CHECK(secp256k1_xonly_pubkey_serialize(none, NULL, &xonly_pk) == 0);\n     CHECK(ecount == 1);\n     CHECK(secp256k1_xonly_pubkey_serialize(none, buf32, NULL) == 0);\n-    CHECK(memcmp(buf32, zeros64, 32) == 0);\n+    CHECK(secp256k1_memcmp_var(buf32, zeros64, 32) == 0);\n     CHECK(ecount == 2);\n     {\n         /* A pubkey filled with 0s will fail to serialize due to pubkey_load\n@@ -104,28 +104,28 @@ void test_xonly_pubkey(void) {\n     CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &xonly_pk, NULL, &pk) == 1);\n     CHECK(secp256k1_xonly_pubkey_serialize(ctx, buf32, &xonly_pk) == 1);\n     CHECK(secp256k1_xonly_pubkey_parse(ctx, &xonly_pk_tmp, buf32) == 1);\n-    CHECK(memcmp(&xonly_pk, &xonly_pk_tmp, sizeof(xonly_pk)) == 0);\n+    CHECK(secp256k1_memcmp_var(&xonly_pk, &xonly_pk_tmp, sizeof(xonly_pk)) == 0);\n \n     /* Test parsing invalid field elements */\n     memset(&xonly_pk, 1, sizeof(xonly_pk));\n     /* Overflowing field element */\n     CHECK(secp256k1_xonly_pubkey_parse(none, &xonly_pk, ones32) == 0);\n-    CHECK(memcmp(&xonly_pk, zeros64, sizeof(xonly_pk)) == 0);\n+    CHECK(secp256k1_memcmp_var(&xonly_pk, zeros64, sizeof(xonly_pk)) == 0);\n     memset(&xonly_pk, 1, sizeof(xonly_pk));\n     /* There's no point with x-coordinate 0 on secp256k1 */\n     CHECK(secp256k1_xonly_pubkey_parse(none, &xonly_pk, zeros64) == 0);\n-    CHECK(memcmp(&xonly_pk, zeros64, sizeof(xonly_pk)) == 0);\n+    CHECK(secp256k1_memcmp_var(&xonly_pk, zeros64, sizeof(xonly_pk)) == 0);\n     /* If a random 32-byte string can not be parsed with ec_pubkey_parse\n      * (because interpreted as X coordinate it does not correspond to a point on\n      * the curve) then xonly_pubkey_parse should fail as well. */\n     for (i = 0; i < count; i++) {\n         unsigned char rand33[33];\n-        secp256k1_rand256(&rand33[1]);\n+        secp256k1_testrand256(&rand33[1]);\n         rand33[0] = SECP256K1_TAG_PUBKEY_EVEN;\n         if (!secp256k1_ec_pubkey_parse(ctx, &pk, rand33, 33)) {\n             memset(&xonly_pk, 1, sizeof(xonly_pk));\n             CHECK(secp256k1_xonly_pubkey_parse(ctx, &xonly_pk, &rand33[1]) == 0);\n-            CHECK(memcmp(&xonly_pk, zeros64, sizeof(xonly_pk)) == 0);\n+            CHECK(secp256k1_memcmp_var(&xonly_pk, zeros64, sizeof(xonly_pk)) == 0);\n         } else {\n             CHECK(secp256k1_xonly_pubkey_parse(ctx, &xonly_pk, &rand33[1]) == 1);\n         }\n@@ -154,8 +154,8 @@ void test_xonly_pubkey_tweak(void) {\n     secp256k1_context *verify = api_test_context(SECP256K1_CONTEXT_VERIFY, &ecount);\n \n     memset(overflows, 0xff, sizeof(overflows));\n-    secp256k1_rand256(tweak);\n-    secp256k1_rand256(sk);\n+    secp256k1_testrand256(tweak);\n+    secp256k1_testrand256(sk);\n     CHECK(secp256k1_ec_pubkey_create(ctx, &internal_pk, sk) == 1);\n     CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &internal_xonly_pk, &pk_parity, &internal_pk) == 1);\n \n@@ -170,15 +170,15 @@ void test_xonly_pubkey_tweak(void) {\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, NULL, tweak) == 0);\n     CHECK(ecount == 4);\n     /* NULL internal_xonly_pk zeroes the output_pk */\n-    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk)) == 0);\n+    CHECK(secp256k1_memcmp_var(&output_pk, zeros64, sizeof(output_pk)) == 0);\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, NULL) == 0);\n     CHECK(ecount == 5);\n     /* NULL tweak zeroes the output_pk */\n-    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk)) == 0);\n+    CHECK(secp256k1_memcmp_var(&output_pk, zeros64, sizeof(output_pk)) == 0);\n \n     /* Invalid tweak zeroes the output_pk */\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, overflows) == 0);\n-    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk))  == 0);\n+    CHECK(secp256k1_memcmp_var(&output_pk, zeros64, sizeof(output_pk))  == 0);\n \n     /* A zero tweak is fine */\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, zeros64) == 1);\n@@ -193,16 +193,16 @@ void test_xonly_pubkey_tweak(void) {\n         secp256k1_scalar_get_b32(tweak, &scalar_tweak);\n         CHECK((secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, sk) == 0)\n               || (secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, tweak) == 0));\n-        CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk)) == 0);\n+        CHECK(secp256k1_memcmp_var(&output_pk, zeros64, sizeof(output_pk)) == 0);\n     }\n \n     /* Invalid pk with a valid tweak */\n     memset(&internal_xonly_pk, 0, sizeof(internal_xonly_pk));\n-    secp256k1_rand256(tweak);\n+    secp256k1_testrand256(tweak);\n     ecount = 0;\n     CHECK(secp256k1_xonly_pubkey_tweak_add(verify, &output_pk, &internal_xonly_pk, tweak) == 0);\n     CHECK(ecount == 1);\n-    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk))  == 0);\n+    CHECK(secp256k1_memcmp_var(&output_pk, zeros64, sizeof(output_pk))  == 0);\n \n     secp256k1_context_destroy(none);\n     secp256k1_context_destroy(sign);\n@@ -228,8 +228,8 @@ void test_xonly_pubkey_tweak_check(void) {\n     secp256k1_context *verify = api_test_context(SECP256K1_CONTEXT_VERIFY, &ecount);\n \n     memset(overflows, 0xff, sizeof(overflows));\n-    secp256k1_rand256(tweak);\n-    secp256k1_rand256(sk);\n+    secp256k1_testrand256(tweak);\n+    secp256k1_testrand256(sk);\n     CHECK(secp256k1_ec_pubkey_create(ctx, &internal_pk, sk) == 1);\n     CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &internal_xonly_pk, &pk_parity, &internal_pk) == 1);\n \n@@ -268,7 +268,7 @@ void test_xonly_pubkey_tweak_check(void) {\n     /* Overflowing tweak not allowed */\n     CHECK(secp256k1_xonly_pubkey_tweak_add_check(ctx, output_pk32, pk_parity, &internal_xonly_pk, overflows) == 0);\n     CHECK(secp256k1_xonly_pubkey_tweak_add(ctx, &output_pk, &internal_xonly_pk, overflows) == 0);\n-    CHECK(memcmp(&output_pk, zeros64, sizeof(output_pk)) == 0);\n+    CHECK(secp256k1_memcmp_var(&output_pk, zeros64, sizeof(output_pk)) == 0);\n     CHECK(ecount == 5);\n \n     secp256k1_context_destroy(none);\n@@ -287,7 +287,7 @@ void test_xonly_pubkey_tweak_recursive(void) {\n     unsigned char tweak[N_PUBKEYS - 1][32];\n     int i;\n \n-    secp256k1_rand256(sk);\n+    secp256k1_testrand256(sk);\n     CHECK(secp256k1_ec_pubkey_create(ctx, &pk[0], sk) == 1);\n     /* Add tweaks */\n     for (i = 0; i < N_PUBKEYS - 1; i++) {\n@@ -327,73 +327,73 @@ void test_keypair(void) {\n \n     /* Test keypair_create */\n     ecount = 0;\n-    secp256k1_rand256(sk);\n+    secp256k1_testrand256(sk);\n     CHECK(secp256k1_keypair_create(none, &keypair, sk) == 0);\n-    CHECK(memcmp(zeros96, &keypair, sizeof(keypair)) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros96, &keypair, sizeof(keypair)) == 0);\n     CHECK(ecount == 1);\n     CHECK(secp256k1_keypair_create(verify, &keypair, sk) == 0);\n-    CHECK(memcmp(zeros96, &keypair, sizeof(keypair)) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros96, &keypair, sizeof(keypair)) == 0);\n     CHECK(ecount == 2);\n     CHECK(secp256k1_keypair_create(sign, &keypair, sk) == 1);\n     CHECK(secp256k1_keypair_create(sign, NULL, sk) == 0);\n     CHECK(ecount == 3);\n     CHECK(secp256k1_keypair_create(sign, &keypair, NULL) == 0);\n-    CHECK(memcmp(zeros96, &keypair, sizeof(keypair)) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros96, &keypair, sizeof(keypair)) == 0);\n     CHECK(ecount == 4);\n \n     /* Invalid secret key */\n     CHECK(secp256k1_keypair_create(sign, &keypair, zeros96) == 0);\n-    CHECK(memcmp(zeros96, &keypair, sizeof(keypair)) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros96, &keypair, sizeof(keypair)) == 0);\n     CHECK(secp256k1_keypair_create(sign, &keypair, overflows) == 0);\n-    CHECK(memcmp(zeros96, &keypair, sizeof(keypair)) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros96, &keypair, sizeof(keypair)) == 0);\n \n     /* Test keypair_pub */\n     ecount = 0;\n-    secp256k1_rand256(sk);\n+    secp256k1_testrand256(sk);\n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n     CHECK(secp256k1_keypair_pub(none, &pk, &keypair) == 1);\n     CHECK(secp256k1_keypair_pub(none, NULL, &keypair) == 0);\n     CHECK(ecount == 1);\n     CHECK(secp256k1_keypair_pub(none, &pk, NULL) == 0);\n     CHECK(ecount == 2);\n-    CHECK(memcmp(zeros96, &pk, sizeof(pk)) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros96, &pk, sizeof(pk)) == 0);\n \n     /* Using an invalid keypair is fine for keypair_pub */\n     memset(&keypair, 0, sizeof(keypair));\n     CHECK(secp256k1_keypair_pub(none, &pk, &keypair) == 1);\n-    CHECK(memcmp(zeros96, &pk, sizeof(pk)) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros96, &pk, sizeof(pk)) == 0);\n \n     /* keypair holds the same pubkey as pubkey_create */\n     CHECK(secp256k1_ec_pubkey_create(sign, &pk, sk) == 1);\n     CHECK(secp256k1_keypair_create(sign, &keypair, sk) == 1);\n     CHECK(secp256k1_keypair_pub(none, &pk_tmp, &keypair) == 1);\n-    CHECK(memcmp(&pk, &pk_tmp, sizeof(pk)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pk, &pk_tmp, sizeof(pk)) == 0);\n \n     /** Test keypair_xonly_pub **/\n     ecount = 0;\n-    secp256k1_rand256(sk);\n+    secp256k1_testrand256(sk);\n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n     CHECK(secp256k1_keypair_xonly_pub(none, &xonly_pk, &pk_parity, &keypair) == 1);\n     CHECK(secp256k1_keypair_xonly_pub(none, NULL, &pk_parity, &keypair) == 0);\n     CHECK(ecount == 1);\n     CHECK(secp256k1_keypair_xonly_pub(none, &xonly_pk, NULL, &keypair) == 1);\n     CHECK(secp256k1_keypair_xonly_pub(none, &xonly_pk, &pk_parity, NULL) == 0);\n     CHECK(ecount == 2);\n-    CHECK(memcmp(zeros96, &xonly_pk, sizeof(xonly_pk)) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros96, &xonly_pk, sizeof(xonly_pk)) == 0);\n     /* Using an invalid keypair will set the xonly_pk to 0 (first reset\n      * xonly_pk). */\n     CHECK(secp256k1_keypair_xonly_pub(none, &xonly_pk, &pk_parity, &keypair) == 1);\n     memset(&keypair, 0, sizeof(keypair));\n     CHECK(secp256k1_keypair_xonly_pub(none, &xonly_pk, &pk_parity, &keypair) == 0);\n-    CHECK(memcmp(zeros96, &xonly_pk, sizeof(xonly_pk)) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros96, &xonly_pk, sizeof(xonly_pk)) == 0);\n     CHECK(ecount == 3);\n \n     /** keypair holds the same xonly pubkey as pubkey_create **/\n     CHECK(secp256k1_ec_pubkey_create(sign, &pk, sk) == 1);\n     CHECK(secp256k1_xonly_pubkey_from_pubkey(none, &xonly_pk, &pk_parity, &pk) == 1);\n     CHECK(secp256k1_keypair_create(sign, &keypair, sk) == 1);\n     CHECK(secp256k1_keypair_xonly_pub(none, &xonly_pk_tmp, &pk_parity_tmp, &keypair) == 1);\n-    CHECK(memcmp(&xonly_pk, &xonly_pk_tmp, sizeof(pk)) == 0);\n+    CHECK(secp256k1_memcmp_var(&xonly_pk, &xonly_pk_tmp, sizeof(pk)) == 0);\n     CHECK(pk_parity == pk_parity_tmp);\n \n     secp256k1_context_destroy(none);\n@@ -414,8 +414,8 @@ void test_keypair_add(void) {\n     secp256k1_context *verify = api_test_context(SECP256K1_CONTEXT_VERIFY, &ecount);\n \n     CHECK(sizeof(zeros96) == sizeof(keypair));\n-    secp256k1_rand256(sk);\n-    secp256k1_rand256(tweak);\n+    secp256k1_testrand256(sk);\n+    secp256k1_testrand256(tweak);\n     memset(overflows, 0xFF, 32);\n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n \n@@ -429,12 +429,12 @@ void test_keypair_add(void) {\n     CHECK(secp256k1_keypair_xonly_tweak_add(verify, &keypair, NULL) == 0);\n     CHECK(ecount == 4);\n     /* This does not set the keypair to zeroes */\n-    CHECK(memcmp(&keypair, zeros96, sizeof(keypair)) != 0);\n+    CHECK(secp256k1_memcmp_var(&keypair, zeros96, sizeof(keypair)) != 0);\n \n     /* Invalid tweak zeroes the keypair */\n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n     CHECK(secp256k1_keypair_xonly_tweak_add(ctx, &keypair, overflows) == 0);\n-    CHECK(memcmp(&keypair, zeros96, sizeof(keypair))  == 0);\n+    CHECK(secp256k1_memcmp_var(&keypair, zeros96, sizeof(keypair))  == 0);\n \n     /* A zero tweak is fine */\n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n@@ -444,7 +444,7 @@ void test_keypair_add(void) {\n     for (i = 0; i < count; i++) {\n         secp256k1_scalar scalar_tweak;\n         secp256k1_keypair keypair_tmp;\n-        secp256k1_rand256(sk);\n+        secp256k1_testrand256(sk);\n         CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n         memcpy(&keypair_tmp, &keypair, sizeof(keypair));\n         /* Because sk may be negated before adding, we need to try with tweak =\n@@ -454,17 +454,17 @@ void test_keypair_add(void) {\n         secp256k1_scalar_get_b32(tweak, &scalar_tweak);\n         CHECK((secp256k1_keypair_xonly_tweak_add(ctx, &keypair, sk) == 0)\n               || (secp256k1_keypair_xonly_tweak_add(ctx, &keypair_tmp, tweak) == 0));\n-        CHECK(memcmp(&keypair, zeros96, sizeof(keypair)) == 0\n-              || memcmp(&keypair_tmp, zeros96, sizeof(keypair_tmp)) == 0);\n+        CHECK(secp256k1_memcmp_var(&keypair, zeros96, sizeof(keypair)) == 0\n+              || secp256k1_memcmp_var(&keypair_tmp, zeros96, sizeof(keypair_tmp)) == 0);\n     }\n \n     /* Invalid keypair with a valid tweak */\n     memset(&keypair, 0, sizeof(keypair));\n-    secp256k1_rand256(tweak);\n+    secp256k1_testrand256(tweak);\n     ecount = 0;\n     CHECK(secp256k1_keypair_xonly_tweak_add(verify, &keypair, tweak) == 0);\n     CHECK(ecount == 1);\n-    CHECK(memcmp(&keypair, zeros96, sizeof(keypair))  == 0);\n+    CHECK(secp256k1_memcmp_var(&keypair, zeros96, sizeof(keypair))  == 0);\n     /* Only seckey part of keypair invalid */\n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n     memset(&keypair, 0, 32);\n@@ -486,7 +486,7 @@ void test_keypair_add(void) {\n         unsigned char pk32[32];\n         int pk_parity;\n \n-        secp256k1_rand256(tweak);\n+        secp256k1_testrand256(tweak);\n         CHECK(secp256k1_keypair_xonly_pub(ctx, &internal_pk, NULL, &keypair) == 1);\n         CHECK(secp256k1_keypair_xonly_tweak_add(ctx, &keypair, tweak) == 1);\n         CHECK(secp256k1_keypair_xonly_pub(ctx, &output_pk, &pk_parity, &keypair) == 1);\n@@ -498,11 +498,11 @@ void test_keypair_add(void) {\n         /* Check that the resulting pubkey matches xonly_pubkey_tweak_add */\n         CHECK(secp256k1_keypair_pub(ctx, &output_pk_xy, &keypair) == 1);\n         CHECK(secp256k1_xonly_pubkey_tweak_add(ctx, &output_pk_expected, &internal_pk, tweak) == 1);\n-        CHECK(memcmp(&output_pk_xy, &output_pk_expected, sizeof(output_pk_xy)) == 0);\n+        CHECK(secp256k1_memcmp_var(&output_pk_xy, &output_pk_expected, sizeof(output_pk_xy)) == 0);\n \n         /* Check that the secret key in the keypair is tweaked correctly */\n         CHECK(secp256k1_ec_pubkey_create(ctx, &output_pk_expected, &keypair.data[0]) == 1);\n-        CHECK(memcmp(&output_pk_xy, &output_pk_expected, sizeof(output_pk_xy)) == 0);\n+        CHECK(secp256k1_memcmp_var(&output_pk_xy, &output_pk_expected, sizeof(output_pk_xy)) == 0);\n     }\n     secp256k1_context_destroy(none);\n     secp256k1_context_destroy(sign);"
      },
      {
        "sha": "e2d3f1248d25c178c95902f9d609109063ada444",
        "filename": "src/secp256k1/src/modules/recovery/Makefile.am.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/modules/recovery/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/modules/recovery/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/Makefile.am.include?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -1,6 +1,7 @@\n include_HEADERS += include/secp256k1_recovery.h\n noinst_HEADERS += src/modules/recovery/main_impl.h\n noinst_HEADERS += src/modules/recovery/tests_impl.h\n+noinst_HEADERS += src/modules/recovery/tests_exhaustive_impl.h\n if USE_BENCHMARK\n noinst_PROGRAMS += bench_recover\n bench_recover_SOURCES = src/bench_recover.c"
      },
      {
        "sha": "a2f381d77a120c932cd297edc5d2eaf67dd28934",
        "filename": "src/secp256k1/src/modules/recovery/tests_exhaustive_impl.h",
        "status": "added",
        "additions": 149,
        "deletions": 0,
        "changes": 149,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/modules/recovery/tests_exhaustive_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/modules/recovery/tests_exhaustive_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/tests_exhaustive_impl.h?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -0,0 +1,149 @@\n+/**********************************************************************\n+ * Copyright (c) 2016 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_RECOVERY_EXHAUSTIVE_TESTS_H\n+#define SECP256K1_MODULE_RECOVERY_EXHAUSTIVE_TESTS_H\n+\n+#include \"src/modules/recovery/main_impl.h\"\n+#include \"include/secp256k1_recovery.h\"\n+\n+void test_exhaustive_recovery_sign(const secp256k1_context *ctx, const secp256k1_ge *group) {\n+    int i, j, k;\n+    uint64_t iter = 0;\n+\n+    /* Loop */\n+    for (i = 1; i < EXHAUSTIVE_TEST_ORDER; i++) {  /* message */\n+        for (j = 1; j < EXHAUSTIVE_TEST_ORDER; j++) {  /* key */\n+            if (skip_section(&iter)) continue;\n+            for (k = 1; k < EXHAUSTIVE_TEST_ORDER; k++) {  /* nonce */\n+                const int starting_k = k;\n+                secp256k1_fe r_dot_y_normalized;\n+                secp256k1_ecdsa_recoverable_signature rsig;\n+                secp256k1_ecdsa_signature sig;\n+                secp256k1_scalar sk, msg, r, s, expected_r;\n+                unsigned char sk32[32], msg32[32];\n+                int expected_recid;\n+                int recid;\n+                int overflow;\n+                secp256k1_scalar_set_int(&msg, i);\n+                secp256k1_scalar_set_int(&sk, j);\n+                secp256k1_scalar_get_b32(sk32, &sk);\n+                secp256k1_scalar_get_b32(msg32, &msg);\n+\n+                secp256k1_ecdsa_sign_recoverable(ctx, &rsig, msg32, sk32, secp256k1_nonce_function_smallint, &k);\n+\n+                /* Check directly */\n+                secp256k1_ecdsa_recoverable_signature_load(ctx, &r, &s, &recid, &rsig);\n+                r_from_k(&expected_r, group, k, &overflow);\n+                CHECK(r == expected_r);\n+                CHECK((k * s) % EXHAUSTIVE_TEST_ORDER == (i + r * j) % EXHAUSTIVE_TEST_ORDER ||\n+                      (k * (EXHAUSTIVE_TEST_ORDER - s)) % EXHAUSTIVE_TEST_ORDER == (i + r * j) % EXHAUSTIVE_TEST_ORDER);\n+                /* The recid's second bit is for conveying overflow (R.x value >= group order).\n+                 * In the actual secp256k1 this is an astronomically unlikely event, but in the\n+                 * small group used here, it will be the case for all points except the ones where\n+                 * R.x=1 (which the group is specifically selected to have).\n+                 * Note that this isn't actually useful; full recovery would need to convey\n+                 * floor(R.x / group_order), but only one bit is used as that is sufficient\n+                 * in the real group. */\n+                expected_recid = overflow ? 2 : 0;\n+                r_dot_y_normalized = group[k].y;\n+                secp256k1_fe_normalize(&r_dot_y_normalized);\n+                /* Also the recovery id is flipped depending if we hit the low-s branch */\n+                if ((k * s) % EXHAUSTIVE_TEST_ORDER == (i + r * j) % EXHAUSTIVE_TEST_ORDER) {\n+                    expected_recid |= secp256k1_fe_is_odd(&r_dot_y_normalized);\n+                } else {\n+                    expected_recid |= !secp256k1_fe_is_odd(&r_dot_y_normalized);\n+                }\n+                CHECK(recid == expected_recid);\n+\n+                /* Convert to a standard sig then check */\n+                secp256k1_ecdsa_recoverable_signature_convert(ctx, &sig, &rsig);\n+                secp256k1_ecdsa_signature_load(ctx, &r, &s, &sig);\n+                /* Note that we compute expected_r *after* signing -- this is important\n+                 * because our nonce-computing function function might change k during\n+                 * signing. */\n+                r_from_k(&expected_r, group, k, NULL);\n+                CHECK(r == expected_r);\n+                CHECK((k * s) % EXHAUSTIVE_TEST_ORDER == (i + r * j) % EXHAUSTIVE_TEST_ORDER ||\n+                      (k * (EXHAUSTIVE_TEST_ORDER - s)) % EXHAUSTIVE_TEST_ORDER == (i + r * j) % EXHAUSTIVE_TEST_ORDER);\n+\n+                /* Overflow means we've tried every possible nonce */\n+                if (k < starting_k) {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+void test_exhaustive_recovery_verify(const secp256k1_context *ctx, const secp256k1_ge *group) {\n+    /* This is essentially a copy of test_exhaustive_verify, with recovery added */\n+    int s, r, msg, key;\n+    uint64_t iter = 0;\n+    for (s = 1; s < EXHAUSTIVE_TEST_ORDER; s++) {\n+        for (r = 1; r < EXHAUSTIVE_TEST_ORDER; r++) {\n+            for (msg = 1; msg < EXHAUSTIVE_TEST_ORDER; msg++) {\n+                for (key = 1; key < EXHAUSTIVE_TEST_ORDER; key++) {\n+                    secp256k1_ge nonconst_ge;\n+                    secp256k1_ecdsa_recoverable_signature rsig;\n+                    secp256k1_ecdsa_signature sig;\n+                    secp256k1_pubkey pk;\n+                    secp256k1_scalar sk_s, msg_s, r_s, s_s;\n+                    secp256k1_scalar s_times_k_s, msg_plus_r_times_sk_s;\n+                    int recid = 0;\n+                    int k, should_verify;\n+                    unsigned char msg32[32];\n+\n+                    if (skip_section(&iter)) continue;\n+\n+                    secp256k1_scalar_set_int(&s_s, s);\n+                    secp256k1_scalar_set_int(&r_s, r);\n+                    secp256k1_scalar_set_int(&msg_s, msg);\n+                    secp256k1_scalar_set_int(&sk_s, key);\n+                    secp256k1_scalar_get_b32(msg32, &msg_s);\n+\n+                    /* Verify by hand */\n+                    /* Run through every k value that gives us this r and check that *one* works.\n+                     * Note there could be none, there could be multiple, ECDSA is weird. */\n+                    should_verify = 0;\n+                    for (k = 0; k < EXHAUSTIVE_TEST_ORDER; k++) {\n+                        secp256k1_scalar check_x_s;\n+                        r_from_k(&check_x_s, group, k, NULL);\n+                        if (r_s == check_x_s) {\n+                            secp256k1_scalar_set_int(&s_times_k_s, k);\n+                            secp256k1_scalar_mul(&s_times_k_s, &s_times_k_s, &s_s);\n+                            secp256k1_scalar_mul(&msg_plus_r_times_sk_s, &r_s, &sk_s);\n+                            secp256k1_scalar_add(&msg_plus_r_times_sk_s, &msg_plus_r_times_sk_s, &msg_s);\n+                            should_verify |= secp256k1_scalar_eq(&s_times_k_s, &msg_plus_r_times_sk_s);\n+                        }\n+                    }\n+                    /* nb we have a \"high s\" rule */\n+                    should_verify &= !secp256k1_scalar_is_high(&s_s);\n+\n+                    /* We would like to try recovering the pubkey and checking that it matches,\n+                     * but pubkey recovery is impossible in the exhaustive tests (the reason\n+                     * being that there are 12 nonzero r values, 12 nonzero points, and no\n+                     * overlap between the sets, so there are no valid signatures). */\n+\n+                    /* Verify by converting to a standard signature and calling verify */\n+                    secp256k1_ecdsa_recoverable_signature_save(&rsig, &r_s, &s_s, recid);\n+                    secp256k1_ecdsa_recoverable_signature_convert(ctx, &sig, &rsig);\n+                    memcpy(&nonconst_ge, &group[sk_s], sizeof(nonconst_ge));\n+                    secp256k1_pubkey_save(&pk, &nonconst_ge);\n+                    CHECK(should_verify ==\n+                          secp256k1_ecdsa_verify(ctx, &sig, msg32, &pk));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+static void test_exhaustive_recovery(const secp256k1_context *ctx, const secp256k1_ge *group) {\n+    test_exhaustive_recovery_sign(ctx, group);\n+    test_exhaustive_recovery_verify(ctx, group);\n+}\n+\n+#endif /* SECP256K1_MODULE_RECOVERY_EXHAUSTIVE_TESTS_H */"
      },
      {
        "sha": "09cae384035ff892d47a7d5c4f9f0c18273daa87",
        "filename": "src/secp256k1/src/modules/recovery/tests_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/modules/recovery/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/modules/recovery/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/tests_impl.h?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -25,7 +25,7 @@ static int recovery_test_nonce_function(unsigned char *nonce32, const unsigned c\n     }\n     /* On the next run, return a valid nonce, but flip a coin as to whether or not to fail signing. */\n     memset(nonce32, 1, 32);\n-    return secp256k1_rand_bits(1);\n+    return secp256k1_testrand_bits(1);\n }\n \n void test_ecdsa_recovery_api(void) {\n@@ -184,7 +184,7 @@ void test_ecdsa_recovery_end_to_end(void) {\n     CHECK(secp256k1_ecdsa_sign_recoverable(ctx, &rsignature[3], message, privkey, NULL, extra) == 1);\n     CHECK(secp256k1_ecdsa_recoverable_signature_serialize_compact(ctx, sig, &recid, &rsignature[4]) == 1);\n     CHECK(secp256k1_ecdsa_recoverable_signature_convert(ctx, &signature[4], &rsignature[4]) == 1);\n-    CHECK(memcmp(&signature[4], &signature[0], 64) == 0);\n+    CHECK(secp256k1_memcmp_var(&signature[4], &signature[0], 64) == 0);\n     CHECK(secp256k1_ecdsa_verify(ctx, &signature[4], message, &pubkey) == 1);\n     memset(&rsignature[4], 0, sizeof(rsignature[4]));\n     CHECK(secp256k1_ecdsa_recoverable_signature_parse_compact(ctx, &rsignature[4], sig, recid) == 1);\n@@ -193,16 +193,16 @@ void test_ecdsa_recovery_end_to_end(void) {\n     /* Parse compact (with recovery id) and recover. */\n     CHECK(secp256k1_ecdsa_recoverable_signature_parse_compact(ctx, &rsignature[4], sig, recid) == 1);\n     CHECK(secp256k1_ecdsa_recover(ctx, &recpubkey, &rsignature[4], message) == 1);\n-    CHECK(memcmp(&pubkey, &recpubkey, sizeof(pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, &recpubkey, sizeof(pubkey)) == 0);\n     /* Serialize/destroy/parse signature and verify again. */\n     CHECK(secp256k1_ecdsa_recoverable_signature_serialize_compact(ctx, sig, &recid, &rsignature[4]) == 1);\n-    sig[secp256k1_rand_bits(6)] += 1 + secp256k1_rand_int(255);\n+    sig[secp256k1_testrand_bits(6)] += 1 + secp256k1_testrand_int(255);\n     CHECK(secp256k1_ecdsa_recoverable_signature_parse_compact(ctx, &rsignature[4], sig, recid) == 1);\n     CHECK(secp256k1_ecdsa_recoverable_signature_convert(ctx, &signature[4], &rsignature[4]) == 1);\n     CHECK(secp256k1_ecdsa_verify(ctx, &signature[4], message, &pubkey) == 0);\n     /* Recover again */\n     CHECK(secp256k1_ecdsa_recover(ctx, &recpubkey, &rsignature[4], message) == 0 ||\n-          memcmp(&pubkey, &recpubkey, sizeof(pubkey)) != 0);\n+          secp256k1_memcmp_var(&pubkey, &recpubkey, sizeof(pubkey)) != 0);\n }\n \n /* Tests several edge cases. */"
      },
      {
        "sha": "568bcc35232d54f48a88f31e4d03c8163cf93a8a",
        "filename": "src/secp256k1/src/modules/schnorrsig/Makefile.am.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/modules/schnorrsig/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/modules/schnorrsig/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorrsig/Makefile.am.include?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -1,6 +1,7 @@\n include_HEADERS += include/secp256k1_schnorrsig.h\n noinst_HEADERS += src/modules/schnorrsig/main_impl.h\n noinst_HEADERS += src/modules/schnorrsig/tests_impl.h\n+noinst_HEADERS += src/modules/schnorrsig/tests_exhaustive_impl.h\n if USE_BENCHMARK\n noinst_PROGRAMS += bench_schnorrsig\n bench_schnorrsig_SOURCES = src/bench_schnorrsig.c"
      },
      {
        "sha": "b0d8481f9be347ace5b712e6b8d4cd1fc1965c0c",
        "filename": "src/secp256k1/src/modules/schnorrsig/main_impl.h",
        "status": "modified",
        "additions": 20,
        "deletions": 19,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/modules/schnorrsig/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/modules/schnorrsig/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorrsig/main_impl.h?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -68,7 +68,7 @@ static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *ms\n     /* Tag the hash with algo16 which is important to avoid nonce reuse across\n      * algorithms. If this nonce function is used in BIP-340 signing as defined\n      * in the spec, an optimized tagging implementation is used. */\n-    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+    if (secp256k1_memcmp_var(algo16, bip340_algo16, 16) == 0) {\n         secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n     } else {\n         int algo16_len = 16;\n@@ -108,14 +108,29 @@ static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n     sha->bytes = 64;\n }\n \n+static void secp256k1_schnorrsig_challenge(secp256k1_scalar* e, const unsigned char *r32, const unsigned char *msg32, const unsigned char *pubkey32)\n+{\n+    unsigned char buf[32];\n+    secp256k1_sha256 sha;\n+\n+    /* tagged hash(r.x, pk.x, msg32) */\n+    secp256k1_schnorrsig_sha256_tagged(&sha);\n+    secp256k1_sha256_write(&sha, r32, 32);\n+    secp256k1_sha256_write(&sha, pubkey32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, buf);\n+    /* Set scalar e to the challenge hash modulo the curve order as per\n+     * BIP340. */\n+    secp256k1_scalar_set_b32(e, buf, NULL);\n+}\n+\n int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n     secp256k1_scalar sk;\n     secp256k1_scalar e;\n     secp256k1_scalar k;\n     secp256k1_gej rj;\n     secp256k1_ge pk;\n     secp256k1_ge r;\n-    secp256k1_sha256 sha;\n     unsigned char buf[32] = { 0 };\n     unsigned char pk_buf[32];\n     unsigned char seckey[32];\n@@ -159,16 +174,7 @@ int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64\n     secp256k1_fe_normalize_var(&r.x);\n     secp256k1_fe_get_b32(&sig64[0], &r.x);\n \n-    /* tagged hash(r.x, pk.x, msg32) */\n-    secp256k1_schnorrsig_sha256_tagged(&sha);\n-    secp256k1_sha256_write(&sha, &sig64[0], 32);\n-    secp256k1_sha256_write(&sha, pk_buf, sizeof(pk_buf));\n-    secp256k1_sha256_write(&sha, msg32, 32);\n-    secp256k1_sha256_finalize(&sha, buf);\n-\n-    /* Set scalar e to the challenge hash modulo the curve order as per\n-     * BIP340. */\n-    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_schnorrsig_challenge(&e, &sig64[0], msg32, pk_buf);\n     secp256k1_scalar_mul(&e, &e, &sk);\n     secp256k1_scalar_add(&e, &e, &k);\n     secp256k1_scalar_get_b32(&sig64[32], &e);\n@@ -189,7 +195,6 @@ int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned cha\n     secp256k1_gej pkj;\n     secp256k1_fe rx;\n     secp256k1_ge r;\n-    secp256k1_sha256 sha;\n     unsigned char buf[32];\n     int overflow;\n \n@@ -212,13 +217,9 @@ int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned cha\n         return 0;\n     }\n \n-    secp256k1_schnorrsig_sha256_tagged(&sha);\n-    secp256k1_sha256_write(&sha, &sig64[0], 32);\n+    /* Compute e. */\n     secp256k1_fe_get_b32(buf, &pk.x);\n-    secp256k1_sha256_write(&sha, buf, sizeof(buf));\n-    secp256k1_sha256_write(&sha, msg32, 32);\n-    secp256k1_sha256_finalize(&sha, buf);\n-    secp256k1_scalar_set_b32(&e, buf, NULL);\n+    secp256k1_schnorrsig_challenge(&e, &sig64[0], msg32, buf);\n \n     /* Compute rj =  s*G + (-e)*pkj */\n     secp256k1_scalar_negate(&e, &e);"
      },
      {
        "sha": "4bf0bc1680feeb2366c7cafa10d70870ccdcd601",
        "filename": "src/secp256k1/src/modules/schnorrsig/tests_exhaustive_impl.h",
        "status": "added",
        "additions": 206,
        "deletions": 0,
        "changes": 206,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/modules/schnorrsig/tests_exhaustive_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/modules/schnorrsig/tests_exhaustive_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorrsig/tests_exhaustive_impl.h?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -0,0 +1,206 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Pieter Wuille                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_TESTS_EXHAUSTIVE_\n+#define _SECP256K1_MODULE_SCHNORRSIG_TESTS_EXHAUSTIVE_\n+\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"src/modules/schnorrsig/main_impl.h\"\n+\n+static const unsigned char invalid_pubkey_bytes[][32] = {\n+    /* 0 */\n+    {\n+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n+    },\n+    /* 2 */\n+    {\n+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2\n+    },\n+    /* order */\n+    {\n+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+        ((EXHAUSTIVE_TEST_ORDER + 0UL) >> 24) & 0xFF,\n+        ((EXHAUSTIVE_TEST_ORDER + 0UL) >> 16) & 0xFF,\n+        ((EXHAUSTIVE_TEST_ORDER + 0UL) >> 8) & 0xFF,\n+        (EXHAUSTIVE_TEST_ORDER + 0UL) & 0xFF\n+    },\n+    /* order + 1 */\n+    {\n+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+        ((EXHAUSTIVE_TEST_ORDER + 1UL) >> 24) & 0xFF,\n+        ((EXHAUSTIVE_TEST_ORDER + 1UL) >> 16) & 0xFF,\n+        ((EXHAUSTIVE_TEST_ORDER + 1UL) >> 8) & 0xFF,\n+        (EXHAUSTIVE_TEST_ORDER + 1UL) & 0xFF\n+    },\n+    /* field size */\n+    {\n+        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFC, 0x2F\n+    },\n+    /* field size + 1 (note that 1 is legal) */\n+    {\n+        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFC, 0x30\n+    },\n+    /* 2^256 - 1 */\n+    {\n+        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\n+    }\n+};\n+\n+#define NUM_INVALID_KEYS (sizeof(invalid_pubkey_bytes) / sizeof(invalid_pubkey_bytes[0]))\n+\n+static int secp256k1_hardened_nonce_function_smallint(unsigned char *nonce32, const unsigned char *msg32,\n+                                                      const unsigned char *key32, const unsigned char *xonly_pk32,\n+                                                      const unsigned char *algo16, void* data) {\n+    secp256k1_scalar s;\n+    int *idata = data;\n+    (void)msg32;\n+    (void)key32;\n+    (void)xonly_pk32;\n+    (void)algo16;\n+    secp256k1_scalar_set_int(&s, *idata);\n+    secp256k1_scalar_get_b32(nonce32, &s);\n+    return 1;\n+}\n+\n+static void test_exhaustive_schnorrsig_verify(const secp256k1_context *ctx, const secp256k1_xonly_pubkey* pubkeys, unsigned char (*xonly_pubkey_bytes)[32], const int* parities) {\n+    int d;\n+    uint64_t iter = 0;\n+    /* Iterate over the possible public keys to verify against (through their corresponding DL d). */\n+    for (d = 1; d <= EXHAUSTIVE_TEST_ORDER / 2; ++d) {\n+        int actual_d;\n+        unsigned k;\n+        unsigned char pk32[32];\n+        memcpy(pk32, xonly_pubkey_bytes[d - 1], 32);\n+        actual_d = parities[d - 1] ? EXHAUSTIVE_TEST_ORDER - d : d;\n+        /* Iterate over the possible valid first 32 bytes in the signature, through their corresponding DL k.\n+           Values above EXHAUSTIVE_TEST_ORDER/2 refer to the entries in invalid_pubkey_bytes. */\n+        for (k = 1; k <= EXHAUSTIVE_TEST_ORDER / 2 + NUM_INVALID_KEYS; ++k) {\n+            unsigned char sig64[64];\n+            int actual_k = -1;\n+            int e_done[EXHAUSTIVE_TEST_ORDER] = {0};\n+            int e_count_done = 0;\n+            if (skip_section(&iter)) continue;\n+            if (k <= EXHAUSTIVE_TEST_ORDER / 2) {\n+                memcpy(sig64, xonly_pubkey_bytes[k - 1], 32);\n+                actual_k = parities[k - 1] ? EXHAUSTIVE_TEST_ORDER - k : k;\n+            } else {\n+                memcpy(sig64, invalid_pubkey_bytes[k - 1 - EXHAUSTIVE_TEST_ORDER / 2], 32);\n+            }\n+            /* Randomly generate messages until all challenges have been hit. */\n+            while (e_count_done < EXHAUSTIVE_TEST_ORDER) {\n+                secp256k1_scalar e;\n+                unsigned char msg32[32];\n+                secp256k1_testrand256(msg32);\n+                secp256k1_schnorrsig_challenge(&e, sig64, msg32, pk32);\n+                /* Only do work if we hit a challenge we haven't tried before. */\n+                if (!e_done[e]) {\n+                    /* Iterate over the possible valid last 32 bytes in the signature.\n+                       0..order=that s value; order+1=random bytes */\n+                    int count_valid = 0, s;\n+                    for (s = 0; s <= EXHAUSTIVE_TEST_ORDER + 1; ++s) {\n+                        int expect_valid, valid;\n+                        if (s <= EXHAUSTIVE_TEST_ORDER) {\n+                            secp256k1_scalar s_s;\n+                            secp256k1_scalar_set_int(&s_s, s);\n+                            secp256k1_scalar_get_b32(sig64 + 32, &s_s);\n+                            expect_valid = actual_k != -1 && s != EXHAUSTIVE_TEST_ORDER &&\n+                                           (s_s == (actual_k + actual_d * e) % EXHAUSTIVE_TEST_ORDER);\n+                        } else {\n+                            secp256k1_testrand256(sig64 + 32);\n+                            expect_valid = 0;\n+                        }\n+                        valid = secp256k1_schnorrsig_verify(ctx, sig64, msg32, &pubkeys[d - 1]);\n+                        CHECK(valid == expect_valid);\n+                        count_valid += valid;\n+                    }\n+                    /* Exactly one s value must verify, unless R is illegal. */\n+                    CHECK(count_valid == (actual_k != -1));\n+                    /* Don't retry other messages that result in the same challenge. */\n+                    e_done[e] = 1;\n+                    ++e_count_done;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+static void test_exhaustive_schnorrsig_sign(const secp256k1_context *ctx, unsigned char (*xonly_pubkey_bytes)[32], const secp256k1_keypair* keypairs, const int* parities) {\n+    int d, k;\n+    uint64_t iter = 0;\n+    /* Loop over keys. */\n+    for (d = 1; d < EXHAUSTIVE_TEST_ORDER; ++d) {\n+        int actual_d = d;\n+        if (parities[d - 1]) actual_d = EXHAUSTIVE_TEST_ORDER - d;\n+        /* Loop over nonces. */\n+        for (k = 1; k < EXHAUSTIVE_TEST_ORDER; ++k) {\n+            int e_done[EXHAUSTIVE_TEST_ORDER] = {0};\n+            int e_count_done = 0;\n+            unsigned char msg32[32];\n+            unsigned char sig64[64];\n+            int actual_k = k;\n+            if (skip_section(&iter)) continue;\n+            if (parities[k - 1]) actual_k = EXHAUSTIVE_TEST_ORDER - k;\n+            /* Generate random messages until all challenges have been tried. */\n+            while (e_count_done < EXHAUSTIVE_TEST_ORDER) {\n+                secp256k1_scalar e;\n+                secp256k1_testrand256(msg32);\n+                secp256k1_schnorrsig_challenge(&e, xonly_pubkey_bytes[k - 1], msg32, xonly_pubkey_bytes[d - 1]);\n+                /* Only do work if we hit a challenge we haven't tried before. */\n+                if (!e_done[e]) {\n+                    secp256k1_scalar expected_s = (actual_k + e * actual_d) % EXHAUSTIVE_TEST_ORDER;\n+                    unsigned char expected_s_bytes[32];\n+                    secp256k1_scalar_get_b32(expected_s_bytes, &expected_s);\n+                    /* Invoke the real function to construct a signature. */\n+                    CHECK(secp256k1_schnorrsig_sign(ctx, sig64, msg32, &keypairs[d - 1], secp256k1_hardened_nonce_function_smallint, &k));\n+                    /* The first 32 bytes must match the xonly pubkey for the specified k. */\n+                    CHECK(secp256k1_memcmp_var(sig64, xonly_pubkey_bytes[k - 1], 32) == 0);\n+                    /* The last 32 bytes must match the expected s value. */\n+                    CHECK(secp256k1_memcmp_var(sig64 + 32, expected_s_bytes, 32) == 0);\n+                    /* Don't retry other messages that result in the same challenge. */\n+                    e_done[e] = 1;\n+                    ++e_count_done;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+static void test_exhaustive_schnorrsig(const secp256k1_context *ctx) {\n+    secp256k1_keypair keypair[EXHAUSTIVE_TEST_ORDER - 1];\n+    secp256k1_xonly_pubkey xonly_pubkey[EXHAUSTIVE_TEST_ORDER - 1];\n+    int parity[EXHAUSTIVE_TEST_ORDER - 1];\n+    unsigned char xonly_pubkey_bytes[EXHAUSTIVE_TEST_ORDER - 1][32];\n+    unsigned i;\n+\n+    /* Verify that all invalid_pubkey_bytes are actually invalid. */\n+    for (i = 0; i < NUM_INVALID_KEYS; ++i) {\n+        secp256k1_xonly_pubkey pk;\n+        CHECK(!secp256k1_xonly_pubkey_parse(ctx, &pk, invalid_pubkey_bytes[i]));\n+    }\n+\n+    /* Construct keypairs and xonly-pubkeys for the entire group. */\n+    for (i = 1; i < EXHAUSTIVE_TEST_ORDER; ++i) {\n+        secp256k1_scalar scalar_i;\n+        unsigned char buf[32];\n+        secp256k1_scalar_set_int(&scalar_i, i);\n+        secp256k1_scalar_get_b32(buf, &scalar_i);\n+        CHECK(secp256k1_keypair_create(ctx, &keypair[i - 1], buf));\n+        CHECK(secp256k1_keypair_xonly_pub(ctx, &xonly_pubkey[i - 1], &parity[i - 1], &keypair[i - 1]));\n+        CHECK(secp256k1_xonly_pubkey_serialize(ctx, xonly_pubkey_bytes[i - 1], &xonly_pubkey[i - 1]));\n+    }\n+\n+    test_exhaustive_schnorrsig_sign(ctx, xonly_pubkey_bytes, keypair, parity);\n+    test_exhaustive_schnorrsig_verify(ctx, xonly_pubkey, xonly_pubkey_bytes, parity);\n+}\n+\n+#endif"
      },
      {
        "sha": "f522fcb3208fffeac16409d11de2a8d3f1da9608",
        "filename": "src/secp256k1/src/modules/schnorrsig/tests_impl.h",
        "status": "modified",
        "additions": 26,
        "deletions": 26,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/modules/schnorrsig/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/modules/schnorrsig/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorrsig/tests_impl.h?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -15,9 +15,9 @@\n void nonce_function_bip340_bitflip(unsigned char **args, size_t n_flip, size_t n_bytes) {\n     unsigned char nonces[2][32];\n     CHECK(nonce_function_bip340(nonces[0], args[0], args[1], args[2], args[3], args[4]) == 1);\n-    secp256k1_rand_flip(args[n_flip], n_bytes);\n+    secp256k1_testrand_flip(args[n_flip], n_bytes);\n     CHECK(nonce_function_bip340(nonces[1], args[0], args[1], args[2], args[3], args[4]) == 1);\n-    CHECK(memcmp(nonces[0], nonces[1], 32) != 0);\n+    CHECK(secp256k1_memcmp_var(nonces[0], nonces[1], 32) != 0);\n }\n \n /* Tests for the equality of two sha256 structs. This function only produces a\n@@ -28,7 +28,7 @@ void test_sha256_eq(const secp256k1_sha256 *sha1, const secp256k1_sha256 *sha2)\n     CHECK((sha1->bytes & 0x3F) == 0);\n \n     CHECK(sha1->bytes == sha2->bytes);\n-    CHECK(memcmp(sha1->s, sha2->s, sizeof(sha1->s)) == 0);\n+    CHECK(secp256k1_memcmp_var(sha1->s, sha2->s, sizeof(sha1->s)) == 0);\n }\n \n void run_nonce_function_bip340_tests(void) {\n@@ -59,10 +59,10 @@ void run_nonce_function_bip340_tests(void) {\n     secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha_optimized);\n     test_sha256_eq(&sha, &sha_optimized);\n \n-    secp256k1_rand256(msg);\n-    secp256k1_rand256(key);\n-    secp256k1_rand256(pk);\n-    secp256k1_rand256(aux_rand);\n+    secp256k1_testrand256(msg);\n+    secp256k1_testrand256(key);\n+    secp256k1_testrand256(pk);\n+    secp256k1_testrand256(aux_rand);\n \n     /* Check that a bitflip in an argument results in different nonces. */\n     args[0] = msg;\n@@ -124,10 +124,10 @@ void test_schnorrsig_api(void) {\n     secp256k1_context_set_illegal_callback(vrfy, counting_illegal_callback_fn, &ecount);\n     secp256k1_context_set_illegal_callback(both, counting_illegal_callback_fn, &ecount);\n \n-    secp256k1_rand256(sk1);\n-    secp256k1_rand256(sk2);\n-    secp256k1_rand256(sk3);\n-    secp256k1_rand256(msg);\n+    secp256k1_testrand256(sk1);\n+    secp256k1_testrand256(sk2);\n+    secp256k1_testrand256(sk3);\n+    secp256k1_testrand256(msg);\n     CHECK(secp256k1_keypair_create(ctx, &keypairs[0], sk1) == 1);\n     CHECK(secp256k1_keypair_create(ctx, &keypairs[1], sk2) == 1);\n     CHECK(secp256k1_keypair_create(ctx, &keypairs[2], sk3) == 1);\n@@ -197,11 +197,11 @@ void test_schnorrsig_bip_vectors_check_signing(const unsigned char *sk, const un\n \n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk));\n     CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL, aux_rand));\n-    CHECK(memcmp(sig, expected_sig, 64) == 0);\n+    CHECK(secp256k1_memcmp_var(sig, expected_sig, 64) == 0);\n \n     CHECK(secp256k1_xonly_pubkey_parse(ctx, &pk_expected, pk_serialized));\n     CHECK(secp256k1_keypair_xonly_pub(ctx, &pk, NULL, &keypair));\n-    CHECK(memcmp(&pk, &pk_expected, sizeof(pk)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pk, &pk_expected, sizeof(pk)) == 0);\n     CHECK(secp256k1_schnorrsig_verify(ctx, sig, msg, &pk));\n }\n \n@@ -675,19 +675,19 @@ void test_schnorrsig_sign(void) {\n     unsigned char sig[64];\n     unsigned char zeros64[64] = { 0 };\n \n-    secp256k1_rand256(sk);\n+    secp256k1_testrand256(sk);\n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk));\n     CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL, NULL) == 1);\n \n     /* Test different nonce functions */\n     memset(sig, 1, sizeof(sig));\n     CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, nonce_function_failing, NULL) == 0);\n-    CHECK(memcmp(sig, zeros64, sizeof(sig)) == 0);\n+    CHECK(secp256k1_memcmp_var(sig, zeros64, sizeof(sig)) == 0);\n     memset(&sig, 1, sizeof(sig));\n     CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, nonce_function_0, NULL) == 0);\n-    CHECK(memcmp(sig, zeros64, sizeof(sig)) == 0);\n+    CHECK(secp256k1_memcmp_var(sig, zeros64, sizeof(sig)) == 0);\n     CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, nonce_function_overflowing, NULL) == 1);\n-    CHECK(memcmp(sig, zeros64, sizeof(sig)) != 0);\n+    CHECK(secp256k1_memcmp_var(sig, zeros64, sizeof(sig)) != 0);\n }\n \n #define N_SIGS 3\n@@ -703,32 +703,32 @@ void test_schnorrsig_sign_verify(void) {\n     secp256k1_xonly_pubkey pk;\n     secp256k1_scalar s;\n \n-    secp256k1_rand256(sk);\n+    secp256k1_testrand256(sk);\n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk));\n     CHECK(secp256k1_keypair_xonly_pub(ctx, &pk, NULL, &keypair));\n \n     for (i = 0; i < N_SIGS; i++) {\n-        secp256k1_rand256(msg[i]);\n+        secp256k1_testrand256(msg[i]);\n         CHECK(secp256k1_schnorrsig_sign(ctx, sig[i], msg[i], &keypair, NULL, NULL));\n         CHECK(secp256k1_schnorrsig_verify(ctx, sig[i], msg[i], &pk));\n     }\n \n     {\n         /* Flip a few bits in the signature and in the message and check that\n          * verify and verify_batch (TODO) fail */\n-        size_t sig_idx = secp256k1_rand_int(N_SIGS);\n-        size_t byte_idx = secp256k1_rand_int(32);\n-        unsigned char xorbyte = secp256k1_rand_int(254)+1;\n+        size_t sig_idx = secp256k1_testrand_int(N_SIGS);\n+        size_t byte_idx = secp256k1_testrand_int(32);\n+        unsigned char xorbyte = secp256k1_testrand_int(254)+1;\n         sig[sig_idx][byte_idx] ^= xorbyte;\n         CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], &pk));\n         sig[sig_idx][byte_idx] ^= xorbyte;\n \n-        byte_idx = secp256k1_rand_int(32);\n+        byte_idx = secp256k1_testrand_int(32);\n         sig[sig_idx][32+byte_idx] ^= xorbyte;\n         CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], &pk));\n         sig[sig_idx][32+byte_idx] ^= xorbyte;\n \n-        byte_idx = secp256k1_rand_int(32);\n+        byte_idx = secp256k1_testrand_int(32);\n         msg[sig_idx][byte_idx] ^= xorbyte;\n         CHECK(!secp256k1_schnorrsig_verify(ctx, sig[sig_idx], msg[sig_idx], &pk));\n         msg[sig_idx][byte_idx] ^= xorbyte;\n@@ -766,7 +766,7 @@ void test_schnorrsig_taproot(void) {\n     unsigned char sig[64];\n \n     /* Create output key */\n-    secp256k1_rand256(sk);\n+    secp256k1_testrand256(sk);\n     CHECK(secp256k1_keypair_create(ctx, &keypair, sk) == 1);\n     CHECK(secp256k1_keypair_xonly_pub(ctx, &internal_pk, NULL, &keypair) == 1);\n     /* In actual taproot the tweak would be hash of internal_pk */\n@@ -776,7 +776,7 @@ void test_schnorrsig_taproot(void) {\n     CHECK(secp256k1_xonly_pubkey_serialize(ctx, output_pk_bytes, &output_pk) == 1);\n \n     /* Key spend */\n-    secp256k1_rand256(msg);\n+    secp256k1_testrand256(msg);\n     CHECK(secp256k1_schnorrsig_sign(ctx, sig, msg, &keypair, NULL, NULL) == 1);\n     /* Verify key spend */\n     CHECK(secp256k1_xonly_pubkey_parse(ctx, &output_pk, output_pk_bytes) == 1);"
      },
      {
        "sha": "fb3fb187cec3fe7af90a6862f61f30b7541fce26",
        "filename": "src/secp256k1/src/scalar.h",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/scalar.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/scalar.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar.h?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -102,12 +102,11 @@ static void secp256k1_scalar_order_get_num(secp256k1_num *r);\n /** Compare two scalars. */\n static int secp256k1_scalar_eq(const secp256k1_scalar *a, const secp256k1_scalar *b);\n \n-#ifdef USE_ENDOMORPHISM\n-/** Find r1 and r2 such that r1+r2*2^128 = a. */\n-static void secp256k1_scalar_split_128(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *a);\n-/** Find r1 and r2 such that r1+r2*lambda = a, and r1 and r2 are maximum 128 bits long (see secp256k1_gej_mul_lambda). */\n-static void secp256k1_scalar_split_lambda(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *a);\n-#endif\n+/** Find r1 and r2 such that r1+r2*2^128 = k. */\n+static void secp256k1_scalar_split_128(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *k);\n+/** Find r1 and r2 such that r1+r2*lambda = k,\n+ * where r1 and r2 or their negations are maximum 128 bits long (see secp256k1_ge_mul_lambda). */\n+static void secp256k1_scalar_split_lambda(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *k);\n \n /** Multiply a and b (without taking the modulus!), divide by 2**shift, and round to the nearest integer. Shift must be at least 256. */\n static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r, const secp256k1_scalar *a, const secp256k1_scalar *b, unsigned int shift);"
      },
      {
        "sha": "73cbd5e18a4d6a69a9ba672f23210689d1532422",
        "filename": "src/secp256k1/src/scalar_4x64_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 7,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/scalar_4x64_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/scalar_4x64_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_4x64_impl.h?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -912,18 +912,16 @@ static void secp256k1_scalar_sqr(secp256k1_scalar *r, const secp256k1_scalar *a)\n     secp256k1_scalar_reduce_512(r, l);\n }\n \n-#ifdef USE_ENDOMORPHISM\n-static void secp256k1_scalar_split_128(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *a) {\n-    r1->d[0] = a->d[0];\n-    r1->d[1] = a->d[1];\n+static void secp256k1_scalar_split_128(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *k) {\n+    r1->d[0] = k->d[0];\n+    r1->d[1] = k->d[1];\n     r1->d[2] = 0;\n     r1->d[3] = 0;\n-    r2->d[0] = a->d[2];\n-    r2->d[1] = a->d[3];\n+    r2->d[0] = k->d[2];\n+    r2->d[1] = k->d[3];\n     r2->d[2] = 0;\n     r2->d[3] = 0;\n }\n-#endif\n \n SECP256K1_INLINE static int secp256k1_scalar_eq(const secp256k1_scalar *a, const secp256k1_scalar *b) {\n     return ((a->d[0] ^ b->d[0]) | (a->d[1] ^ b->d[1]) | (a->d[2] ^ b->d[2]) | (a->d[3] ^ b->d[3])) == 0;"
      },
      {
        "sha": "6853f79eccbe173bef6487e95a580a873aaf10f9",
        "filename": "src/secp256k1/src/scalar_8x32_impl.h",
        "status": "modified",
        "additions": 9,
        "deletions": 11,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/scalar_8x32_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/scalar_8x32_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_8x32_impl.h?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -672,26 +672,24 @@ static void secp256k1_scalar_sqr(secp256k1_scalar *r, const secp256k1_scalar *a)\n     secp256k1_scalar_reduce_512(r, l);\n }\n \n-#ifdef USE_ENDOMORPHISM\n-static void secp256k1_scalar_split_128(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *a) {\n-    r1->d[0] = a->d[0];\n-    r1->d[1] = a->d[1];\n-    r1->d[2] = a->d[2];\n-    r1->d[3] = a->d[3];\n+static void secp256k1_scalar_split_128(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *k) {\n+    r1->d[0] = k->d[0];\n+    r1->d[1] = k->d[1];\n+    r1->d[2] = k->d[2];\n+    r1->d[3] = k->d[3];\n     r1->d[4] = 0;\n     r1->d[5] = 0;\n     r1->d[6] = 0;\n     r1->d[7] = 0;\n-    r2->d[0] = a->d[4];\n-    r2->d[1] = a->d[5];\n-    r2->d[2] = a->d[6];\n-    r2->d[3] = a->d[7];\n+    r2->d[0] = k->d[4];\n+    r2->d[1] = k->d[5];\n+    r2->d[2] = k->d[6];\n+    r2->d[3] = k->d[7];\n     r2->d[4] = 0;\n     r2->d[5] = 0;\n     r2->d[6] = 0;\n     r2->d[7] = 0;\n }\n-#endif\n \n SECP256K1_INLINE static int secp256k1_scalar_eq(const secp256k1_scalar *a, const secp256k1_scalar *b) {\n     return ((a->d[0] ^ b->d[0]) | (a->d[1] ^ b->d[1]) | (a->d[2] ^ b->d[2]) | (a->d[3] ^ b->d[3]) | (a->d[4] ^ b->d[4]) | (a->d[5] ^ b->d[5]) | (a->d[6] ^ b->d[6]) | (a->d[7] ^ b->d[7])) == 0;"
      },
      {
        "sha": "fc758918180b660008d5829addfe8b84bae3be24",
        "filename": "src/secp256k1/src/scalar_impl.h",
        "status": "modified",
        "additions": 212,
        "deletions": 38,
        "changes": 250,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_impl.h?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -7,6 +7,10 @@\n #ifndef SECP256K1_SCALAR_IMPL_H\n #define SECP256K1_SCALAR_IMPL_H\n \n+#ifdef VERIFY\n+#include <string.h>\n+#endif\n+\n #include \"scalar.h\"\n #include \"util.h\"\n \n@@ -252,37 +256,65 @@ static void secp256k1_scalar_inverse_var(secp256k1_scalar *r, const secp256k1_sc\n #endif\n }\n \n-#ifdef USE_ENDOMORPHISM\n+/* These parameters are generated using sage/gen_exhaustive_groups.sage. */\n #if defined(EXHAUSTIVE_TEST_ORDER)\n+#  if EXHAUSTIVE_TEST_ORDER == 13\n+#    define EXHAUSTIVE_TEST_LAMBDA 9\n+#  elif EXHAUSTIVE_TEST_ORDER == 199\n+#    define EXHAUSTIVE_TEST_LAMBDA 92\n+#  else\n+#    error No known lambda for the specified exhaustive test group order.\n+#  endif\n+\n /**\n- * Find k1 and k2 given k, such that k1 + k2 * lambda == k mod n; unlike in the\n- * full case we don't bother making k1 and k2 be small, we just want them to be\n+ * Find r1 and r2 given k, such that r1 + r2 * lambda == k mod n; unlike in the\n+ * full case we don't bother making r1 and r2 be small, we just want them to be\n  * nontrivial to get full test coverage for the exhaustive tests. We therefore\n- * (arbitrarily) set k2 = k + 5 and k1 = k - k2 * lambda.\n+ * (arbitrarily) set r2 = k + 5 (mod n) and r1 = k - r2 * lambda (mod n).\n  */\n-static void secp256k1_scalar_split_lambda(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *a) {\n-    *r2 = (*a + 5) % EXHAUSTIVE_TEST_ORDER;\n-    *r1 = (*a + (EXHAUSTIVE_TEST_ORDER - *r2) * EXHAUSTIVE_TEST_LAMBDA) % EXHAUSTIVE_TEST_ORDER;\n+static void secp256k1_scalar_split_lambda(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *k) {\n+    *r2 = (*k + 5) % EXHAUSTIVE_TEST_ORDER;\n+    *r1 = (*k + (EXHAUSTIVE_TEST_ORDER - *r2) * EXHAUSTIVE_TEST_LAMBDA) % EXHAUSTIVE_TEST_ORDER;\n }\n #else\n /**\n  * The Secp256k1 curve has an endomorphism, where lambda * (x, y) = (beta * x, y), where\n- * lambda is {0x53,0x63,0xad,0x4c,0xc0,0x5c,0x30,0xe0,0xa5,0x26,0x1c,0x02,0x88,0x12,0x64,0x5a,\n- *            0x12,0x2e,0x22,0xea,0x20,0x81,0x66,0x78,0xdf,0x02,0x96,0x7c,0x1b,0x23,0xbd,0x72}\n+ * lambda is: */\n+static const secp256k1_scalar secp256k1_const_lambda = SECP256K1_SCALAR_CONST(\n+    0x5363AD4CUL, 0xC05C30E0UL, 0xA5261C02UL, 0x8812645AUL,\n+    0x122E22EAUL, 0x20816678UL, 0xDF02967CUL, 0x1B23BD72UL\n+);\n+\n+#ifdef VERIFY\n+static void secp256k1_scalar_split_lambda_verify(const secp256k1_scalar *r1, const secp256k1_scalar *r2, const secp256k1_scalar *k);\n+#endif\n+\n+/*\n+ * Both lambda and beta are primitive cube roots of unity.  That is lamba^3 == 1 mod n and\n+ * beta^3 == 1 mod p, where n is the curve order and p is the field order.\n  *\n- * \"Guide to Elliptic Curve Cryptography\" (Hankerson, Menezes, Vanstone) gives an algorithm\n- * (algorithm 3.74) to find k1 and k2 given k, such that k1 + k2 * lambda == k mod n, and k1\n- * and k2 have a small size.\n- * It relies on constants a1, b1, a2, b2. These constants for the value of lambda above are:\n+ * Futhermore, because (X^3 - 1) = (X - 1)(X^2 + X + 1), the primitive cube roots of unity are\n+ * roots of X^2 + X + 1.  Therefore lambda^2 + lamba == -1 mod n and beta^2 + beta == -1 mod p.\n+ * (The other primitive cube roots of unity are lambda^2 and beta^2 respectively.)\n+ *\n+ * Let l = -1/2 + i*sqrt(3)/2, the complex root of X^2 + X + 1. We can define a ring\n+ * homomorphism phi : Z[l] -> Z_n where phi(a + b*l) == a + b*lambda mod n. The kernel of phi\n+ * is a lattice over Z[l] (considering Z[l] as a Z-module). This lattice is generated by a\n+ * reduced basis {a1 + b1*l, a2 + b2*l} where\n  *\n  * - a1 =      {0x30,0x86,0xd2,0x21,0xa7,0xd4,0x6b,0xcd,0xe8,0x6c,0x90,0xe4,0x92,0x84,0xeb,0x15}\n  * - b1 =     -{0xe4,0x43,0x7e,0xd6,0x01,0x0e,0x88,0x28,0x6f,0x54,0x7f,0xa9,0x0a,0xbf,0xe4,0xc3}\n  * - a2 = {0x01,0x14,0xca,0x50,0xf7,0xa8,0xe2,0xf3,0xf6,0x57,0xc1,0x10,0x8d,0x9d,0x44,0xcf,0xd8}\n  * - b2 =      {0x30,0x86,0xd2,0x21,0xa7,0xd4,0x6b,0xcd,0xe8,0x6c,0x90,0xe4,0x92,0x84,0xeb,0x15}\n  *\n- * The algorithm then computes c1 = round(b1 * k / n) and c2 = round(b2 * k / n), and gives\n+ * \"Guide to Elliptic Curve Cryptography\" (Hankerson, Menezes, Vanstone) gives an algorithm\n+ * (algorithm 3.74) to find k1 and k2 given k, such that k1 + k2 * lambda == k mod n, and k1\n+ * and k2 are small in absolute value.\n+ *\n+ * The algorithm computes c1 = round(b2 * k / n) and c2 = round((-b1) * k / n), and gives\n  * k1 = k - (c1*a1 + c2*a2) and k2 = -(c1*b1 + c2*b2). Instead, we use modular arithmetic, and\n- * compute k1 as k - k2 * lambda, avoiding the need for constants a1 and a2.\n+ * compute r2 = k2 mod n, and r1 = k1 mod n = (k - r2 * lambda) mod n, avoiding the need for\n+ * the constants a1 and a2.\n  *\n  * g1, g2 are precomputed constants used to replace division with a rounded multiplication\n  * when decomposing the scalar for an endomorphism-based point multiplication.\n@@ -294,21 +326,21 @@ static void secp256k1_scalar_split_lambda(secp256k1_scalar *r1, secp256k1_scalar\n  * Cryptography on Sensor Networks Using the MSP430X Microcontroller\" (Gouvea, Oliveira, Lopez),\n  * Section 4.3 (here we use a somewhat higher-precision estimate):\n  * d = a1*b2 - b1*a2\n- * g1 = round((2^272)*b2/d)\n- * g2 = round((2^272)*b1/d)\n+ * g1 = round(2^384 * b2/d)\n+ * g2 = round(2^384 * (-b1)/d)\n  *\n- * (Note that 'd' is also equal to the curve order here because [a1,b1] and [a2,b2] are found\n- * as outputs of the Extended Euclidean Algorithm on inputs 'order' and 'lambda').\n+ * (Note that d is also equal to the curve order, n, here because [a1,b1] and [a2,b2]\n+ * can be found as outputs of the Extended Euclidean Algorithm on inputs n and lambda).\n  *\n- * The function below splits a in r1 and r2, such that r1 + lambda * r2 == a (mod order).\n+ * The function below splits k into r1 and r2, such that\n+ * - r1 + lambda * r2 == k (mod n)\n+ * - either r1 < 2^128 or -r1 mod n < 2^128\n+ * - either r2 < 2^128 or -r2 mod n < 2^128\n+ *\n+ * See proof below.\n  */\n-\n-static void secp256k1_scalar_split_lambda(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *a) {\n+static void secp256k1_scalar_split_lambda(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *k) {\n     secp256k1_scalar c1, c2;\n-    static const secp256k1_scalar minus_lambda = SECP256K1_SCALAR_CONST(\n-        0xAC9C52B3UL, 0x3FA3CF1FUL, 0x5AD9E3FDUL, 0x77ED9BA4UL,\n-        0xA880B9FCUL, 0x8EC739C2UL, 0xE0CFC810UL, 0xB51283CFUL\n-    );\n     static const secp256k1_scalar minus_b1 = SECP256K1_SCALAR_CONST(\n         0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n         0xE4437ED6UL, 0x010E8828UL, 0x6F547FA9UL, 0x0ABFE4C3UL\n@@ -318,25 +350,167 @@ static void secp256k1_scalar_split_lambda(secp256k1_scalar *r1, secp256k1_scalar\n         0x8A280AC5UL, 0x0774346DUL, 0xD765CDA8UL, 0x3DB1562CUL\n     );\n     static const secp256k1_scalar g1 = SECP256K1_SCALAR_CONST(\n-        0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00003086UL,\n-        0xD221A7D4UL, 0x6BCDE86CUL, 0x90E49284UL, 0xEB153DABUL\n+        0x3086D221UL, 0xA7D46BCDUL, 0xE86C90E4UL, 0x9284EB15UL,\n+        0x3DAA8A14UL, 0x71E8CA7FUL, 0xE893209AUL, 0x45DBB031UL\n     );\n     static const secp256k1_scalar g2 = SECP256K1_SCALAR_CONST(\n-        0x00000000UL, 0x00000000UL, 0x00000000UL, 0x0000E443UL,\n-        0x7ED6010EUL, 0x88286F54UL, 0x7FA90ABFUL, 0xE4C42212UL\n+        0xE4437ED6UL, 0x010E8828UL, 0x6F547FA9UL, 0x0ABFE4C4UL,\n+        0x221208ACUL, 0x9DF506C6UL, 0x1571B4AEUL, 0x8AC47F71UL\n     );\n-    VERIFY_CHECK(r1 != a);\n-    VERIFY_CHECK(r2 != a);\n+    VERIFY_CHECK(r1 != k);\n+    VERIFY_CHECK(r2 != k);\n     /* these _var calls are constant time since the shift amount is constant */\n-    secp256k1_scalar_mul_shift_var(&c1, a, &g1, 272);\n-    secp256k1_scalar_mul_shift_var(&c2, a, &g2, 272);\n+    secp256k1_scalar_mul_shift_var(&c1, k, &g1, 384);\n+    secp256k1_scalar_mul_shift_var(&c2, k, &g2, 384);\n     secp256k1_scalar_mul(&c1, &c1, &minus_b1);\n     secp256k1_scalar_mul(&c2, &c2, &minus_b2);\n     secp256k1_scalar_add(r2, &c1, &c2);\n-    secp256k1_scalar_mul(r1, r2, &minus_lambda);\n-    secp256k1_scalar_add(r1, r1, a);\n-}\n-#endif\n+    secp256k1_scalar_mul(r1, r2, &secp256k1_const_lambda);\n+    secp256k1_scalar_negate(r1, r1);\n+    secp256k1_scalar_add(r1, r1, k);\n+\n+#ifdef VERIFY\n+    secp256k1_scalar_split_lambda_verify(r1, r2, k);\n #endif\n+}\n+\n+#ifdef VERIFY\n+/*\n+ * Proof for secp256k1_scalar_split_lambda's bounds.\n+ *\n+ * Let\n+ *  - epsilon1 = 2^256 * |g1/2^384 - b2/d|\n+ *  - epsilon2 = 2^256 * |g2/2^384 - (-b1)/d|\n+ *  - c1 = round(k*g1/2^384)\n+ *  - c2 = round(k*g2/2^384)\n+ *\n+ * Lemma 1: |c1 - k*b2/d| < 2^-1 + epsilon1\n+ *\n+ *    |c1 - k*b2/d|\n+ *  =\n+ *    |c1 - k*g1/2^384 + k*g1/2^384 - k*b2/d|\n+ * <=   {triangle inequality}\n+ *    |c1 - k*g1/2^384| + |k*g1/2^384 - k*b2/d|\n+ *  =\n+ *    |c1 - k*g1/2^384| + k*|g1/2^384 - b2/d|\n+ * <    {rounding in c1 and 0 <= k < 2^256}\n+ *    2^-1 + 2^256 * |g1/2^384 - b2/d|\n+ *  =   {definition of epsilon1}\n+ *    2^-1 + epsilon1\n+ *\n+ * Lemma 2: |c2 - k*(-b1)/d| < 2^-1 + epsilon2\n+ *\n+ *    |c2 - k*(-b1)/d|\n+ *  =\n+ *    |c2 - k*g2/2^384 + k*g2/2^384 - k*(-b1)/d|\n+ * <=   {triangle inequality}\n+ *    |c2 - k*g2/2^384| + |k*g2/2^384 - k*(-b1)/d|\n+ *  =\n+ *    |c2 - k*g2/2^384| + k*|g2/2^384 - (-b1)/d|\n+ * <    {rounding in c2 and 0 <= k < 2^256}\n+ *    2^-1 + 2^256 * |g2/2^384 - (-b1)/d|\n+ *  =   {definition of epsilon2}\n+ *    2^-1 + epsilon2\n+ *\n+ * Let\n+ *  - k1 = k - c1*a1 - c2*a2\n+ *  - k2 = - c1*b1 - c2*b2\n+ *\n+ * Lemma 3: |k1| < (a1 + a2 + 1)/2 < 2^128\n+ *\n+ *    |k1|\n+ *  =   {definition of k1}\n+ *    |k - c1*a1 - c2*a2|\n+ *  =   {(a1*b2 - b1*a2)/n = 1}\n+ *    |k*(a1*b2 - b1*a2)/n - c1*a1 - c2*a2|\n+ *  =\n+ *    |a1*(k*b2/n - c1) + a2*(k*(-b1)/n - c2)|\n+ * <=   {triangle inequality}\n+ *    a1*|k*b2/n - c1| + a2*|k*(-b1)/n - c2|\n+ * <    {Lemma 1 and Lemma 2}\n+ *    a1*(2^-1 + epslion1) + a2*(2^-1 + epsilon2)\n+ * <    {rounding up to an integer}\n+ *    (a1 + a2 + 1)/2\n+ * <    {rounding up to a power of 2}\n+ *    2^128\n+ *\n+ * Lemma 4: |k2| < (-b1 + b2)/2 + 1 < 2^128\n+ *\n+ *    |k2|\n+ *  =   {definition of k2}\n+ *    |- c1*a1 - c2*a2|\n+ *  =   {(b1*b2 - b1*b2)/n = 0}\n+ *    |k*(b1*b2 - b1*b2)/n - c1*b1 - c2*b2|\n+ *  =\n+ *    |b1*(k*b2/n - c1) + b2*(k*(-b1)/n - c2)|\n+ * <=   {triangle inequality}\n+ *    (-b1)*|k*b2/n - c1| + b2*|k*(-b1)/n - c2|\n+ * <    {Lemma 1 and Lemma 2}\n+ *    (-b1)*(2^-1 + epslion1) + b2*(2^-1 + epsilon2)\n+ * <    {rounding up to an integer}\n+ *    (-b1 + b2)/2 + 1\n+ * <    {rounding up to a power of 2}\n+ *    2^128\n+ *\n+ * Let\n+ *  - r2 = k2 mod n\n+ *  - r1 = k - r2*lambda mod n.\n+ *\n+ * Notice that r1 is defined such that r1 + r2 * lambda == k (mod n).\n+ *\n+ * Lemma 5: r1 == k1 mod n.\n+ *\n+ *    r1\n+ * ==   {definition of r1 and r2}\n+ *    k - k2*lambda\n+ * ==   {definition of k2}\n+ *    k - (- c1*b1 - c2*b2)*lambda\n+ * ==\n+ *    k + c1*b1*lambda + c2*b2*lambda\n+ * ==  {a1 + b1*lambda == 0 mod n and a2 + b2*lambda == 0 mod n}\n+ *    k - c1*a1 - c2*a2\n+ * ==  {definition of k1}\n+ *    k1\n+ *\n+ * From Lemma 3, Lemma 4, Lemma 5 and the definition of r2, we can conclude that\n+ *\n+ *  - either r1 < 2^128 or -r1 mod n < 2^128\n+ *  - either r2 < 2^128 or -r2 mod n < 2^128.\n+ *\n+ * Q.E.D.\n+ */\n+static void secp256k1_scalar_split_lambda_verify(const secp256k1_scalar *r1, const secp256k1_scalar *r2, const secp256k1_scalar *k) {\n+    secp256k1_scalar s;\n+    unsigned char buf1[32];\n+    unsigned char buf2[32];\n+\n+    /* (a1 + a2 + 1)/2 is 0xa2a8918ca85bafe22016d0b917e4dd77 */\n+    static const unsigned char k1_bound[32] = {\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0xa2, 0xa8, 0x91, 0x8c, 0xa8, 0x5b, 0xaf, 0xe2, 0x20, 0x16, 0xd0, 0xb9, 0x17, 0xe4, 0xdd, 0x77\n+    };\n+\n+    /* (-b1 + b2)/2 + 1 is 0x8a65287bd47179fb2be08846cea267ed */\n+    static const unsigned char k2_bound[32] = {\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0x8a, 0x65, 0x28, 0x7b, 0xd4, 0x71, 0x79, 0xfb, 0x2b, 0xe0, 0x88, 0x46, 0xce, 0xa2, 0x67, 0xed\n+    };\n+\n+    secp256k1_scalar_mul(&s, &secp256k1_const_lambda, r2);\n+    secp256k1_scalar_add(&s, &s, r1);\n+    VERIFY_CHECK(secp256k1_scalar_eq(&s, k));\n+\n+    secp256k1_scalar_negate(&s, r1);\n+    secp256k1_scalar_get_b32(buf1, r1);\n+    secp256k1_scalar_get_b32(buf2, &s);\n+    VERIFY_CHECK(secp256k1_memcmp_var(buf1, k1_bound, 32) < 0 || secp256k1_memcmp_var(buf2, k1_bound, 32) < 0);\n+\n+    secp256k1_scalar_negate(&s, r2);\n+    secp256k1_scalar_get_b32(buf1, r2);\n+    secp256k1_scalar_get_b32(buf2, &s);\n+    VERIFY_CHECK(secp256k1_memcmp_var(buf1, k2_bound, 32) < 0 || secp256k1_memcmp_var(buf2, k2_bound, 32) < 0);\n+}\n+#endif /* VERIFY */\n+#endif /* !defined(EXHAUSTIVE_TEST_ORDER) */\n \n #endif /* SECP256K1_SCALAR_IMPL_H */"
      },
      {
        "sha": "a615ec074b2b45fa1d0d4fb08e918c1f6e91e929",
        "filename": "src/secp256k1/src/scalar_low_impl.h",
        "status": "modified",
        "additions": 7,
        "deletions": 4,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/scalar_low_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/scalar_low_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_low_impl.h?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -48,14 +48,17 @@ static void secp256k1_scalar_cadd_bit(secp256k1_scalar *r, unsigned int bit, int\n }\n \n static void secp256k1_scalar_set_b32(secp256k1_scalar *r, const unsigned char *b32, int *overflow) {\n-    const int base = 0x100 % EXHAUSTIVE_TEST_ORDER;\n     int i;\n+    int over = 0;\n     *r = 0;\n     for (i = 0; i < 32; i++) {\n-       *r = ((*r * base) + b32[i]) % EXHAUSTIVE_TEST_ORDER;\n+        *r = (*r * 0x100) + b32[i];\n+        if (*r >= EXHAUSTIVE_TEST_ORDER) {\n+            over = 1;\n+            *r %= EXHAUSTIVE_TEST_ORDER;\n+        }\n     }\n-    /* just deny overflow, it basically always happens */\n-    if (overflow) *overflow = 0;\n+    if (overflow) *overflow = over;\n }\n \n static void secp256k1_scalar_get_b32(unsigned char *bin, const secp256k1_scalar* a) {"
      },
      {
        "sha": "f381e2e3227441a8f71c4c7e183ee7c4f4137986",
        "filename": "src/secp256k1/src/scratch_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/scratch_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/scratch_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scratch_impl.h?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -26,7 +26,7 @@ static secp256k1_scratch* secp256k1_scratch_create(const secp256k1_callback* err\n static void secp256k1_scratch_destroy(const secp256k1_callback* error_callback, secp256k1_scratch* scratch) {\n     if (scratch != NULL) {\n         VERIFY_CHECK(scratch->alloc_size == 0); /* all checkpoints should be applied */\n-        if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+        if (secp256k1_memcmp_var(scratch->magic, \"scratch\", 8) != 0) {\n             secp256k1_callback_call(error_callback, \"invalid scratch space\");\n             return;\n         }\n@@ -36,15 +36,15 @@ static void secp256k1_scratch_destroy(const secp256k1_callback* error_callback,\n }\n \n static size_t secp256k1_scratch_checkpoint(const secp256k1_callback* error_callback, const secp256k1_scratch* scratch) {\n-    if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+    if (secp256k1_memcmp_var(scratch->magic, \"scratch\", 8) != 0) {\n         secp256k1_callback_call(error_callback, \"invalid scratch space\");\n         return 0;\n     }\n     return scratch->alloc_size;\n }\n \n static void secp256k1_scratch_apply_checkpoint(const secp256k1_callback* error_callback, secp256k1_scratch* scratch, size_t checkpoint) {\n-    if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+    if (secp256k1_memcmp_var(scratch->magic, \"scratch\", 8) != 0) {\n         secp256k1_callback_call(error_callback, \"invalid scratch space\");\n         return;\n     }\n@@ -56,7 +56,7 @@ static void secp256k1_scratch_apply_checkpoint(const secp256k1_callback* error_c\n }\n \n static size_t secp256k1_scratch_max_allocation(const secp256k1_callback* error_callback, const secp256k1_scratch* scratch, size_t objects) {\n-    if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+    if (secp256k1_memcmp_var(scratch->magic, \"scratch\", 8) != 0) {\n         secp256k1_callback_call(error_callback, \"invalid scratch space\");\n         return 0;\n     }\n@@ -81,7 +81,7 @@ static void *secp256k1_scratch_alloc(const secp256k1_callback* error_callback, s\n     }\n     size = rounded_size;\n \n-    if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+    if (secp256k1_memcmp_var(scratch->magic, \"scratch\", 8) != 0) {\n         secp256k1_callback_call(error_callback, \"invalid scratch space\");\n         return NULL;\n     }"
      },
      {
        "sha": "dae506d08c946ee00cef7c3b56a7a84617322663",
        "filename": "src/secp256k1/src/secp256k1.c",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/secp256k1.c?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -284,6 +284,9 @@ int secp256k1_ec_pubkey_parse(const secp256k1_context* ctx, secp256k1_pubkey* pu\n     if (!secp256k1_eckey_pubkey_parse(&Q, input, inputlen)) {\n         return 0;\n     }\n+    if (!secp256k1_ge_is_in_correct_subgroup(&Q)) {\n+        return 0;\n+    }\n     secp256k1_pubkey_save(pubkey, &Q);\n     secp256k1_ge_clear(&Q);\n     return 1;"
      },
      {
        "sha": "0e37510c1e95a1d62d61d25dadf15ee5dd06021e",
        "filename": "src/secp256k1/src/selftest.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/selftest.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/selftest.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/selftest.h?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -22,7 +22,7 @@ static int secp256k1_selftest_sha256(void) {\n     secp256k1_sha256_initialize(&hasher);\n     secp256k1_sha256_write(&hasher, (const unsigned char*)input63, 63);\n     secp256k1_sha256_finalize(&hasher, out);\n-    return memcmp(out, output32, 32) == 0;\n+    return secp256k1_memcmp_var(out, output32, 32) == 0;\n }\n \n static int secp256k1_selftest(void) {"
      },
      {
        "sha": "a76003d5b8e17a0bcda3a55eb4a727d878067304",
        "filename": "src/secp256k1/src/testrand.h",
        "status": "modified",
        "additions": 14,
        "deletions": 8,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/testrand.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/testrand.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/testrand.h?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -14,28 +14,34 @@\n /* A non-cryptographic RNG used only for test infrastructure. */\n \n /** Seed the pseudorandom number generator for testing. */\n-SECP256K1_INLINE static void secp256k1_rand_seed(const unsigned char *seed16);\n+SECP256K1_INLINE static void secp256k1_testrand_seed(const unsigned char *seed16);\n \n /** Generate a pseudorandom number in the range [0..2**32-1]. */\n-static uint32_t secp256k1_rand32(void);\n+static uint32_t secp256k1_testrand32(void);\n \n /** Generate a pseudorandom number in the range [0..2**bits-1]. Bits must be 1 or\n  *  more. */\n-static uint32_t secp256k1_rand_bits(int bits);\n+static uint32_t secp256k1_testrand_bits(int bits);\n \n /** Generate a pseudorandom number in the range [0..range-1]. */\n-static uint32_t secp256k1_rand_int(uint32_t range);\n+static uint32_t secp256k1_testrand_int(uint32_t range);\n \n /** Generate a pseudorandom 32-byte array. */\n-static void secp256k1_rand256(unsigned char *b32);\n+static void secp256k1_testrand256(unsigned char *b32);\n \n /** Generate a pseudorandom 32-byte array with long sequences of zero and one bits. */\n-static void secp256k1_rand256_test(unsigned char *b32);\n+static void secp256k1_testrand256_test(unsigned char *b32);\n \n /** Generate pseudorandom bytes with long sequences of zero and one bits. */\n-static void secp256k1_rand_bytes_test(unsigned char *bytes, size_t len);\n+static void secp256k1_testrand_bytes_test(unsigned char *bytes, size_t len);\n \n /** Flip a single random bit in a byte array */\n-static void secp256k1_rand_flip(unsigned char *b, size_t len);\n+static void secp256k1_testrand_flip(unsigned char *b, size_t len);\n+\n+/** Initialize the test RNG using (hex encoded) array up to 16 bytes, or randomly if hexseed is NULL. */\n+static void secp256k1_testrand_init(const char* hexseed);\n+\n+/** Print final test information. */\n+static void secp256k1_testrand_finish(void);\n \n #endif /* SECP256K1_TESTRAND_H */"
      },
      {
        "sha": "3392566329818938005aba204a7183ed014857dd",
        "filename": "src/secp256k1/src/testrand_impl.h",
        "status": "modified",
        "additions": 58,
        "deletions": 14,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/testrand_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/testrand_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/testrand_impl.h?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -8,6 +8,7 @@\n #define SECP256K1_TESTRAND_IMPL_H\n \n #include <stdint.h>\n+#include <stdio.h>\n #include <string.h>\n \n #include \"testrand.h\"\n@@ -19,22 +20,22 @@ static int secp256k1_test_rng_precomputed_used = 8;\n static uint64_t secp256k1_test_rng_integer;\n static int secp256k1_test_rng_integer_bits_left = 0;\n \n-SECP256K1_INLINE static void secp256k1_rand_seed(const unsigned char *seed16) {\n+SECP256K1_INLINE static void secp256k1_testrand_seed(const unsigned char *seed16) {\n     secp256k1_rfc6979_hmac_sha256_initialize(&secp256k1_test_rng, seed16, 16);\n }\n \n-SECP256K1_INLINE static uint32_t secp256k1_rand32(void) {\n+SECP256K1_INLINE static uint32_t secp256k1_testrand32(void) {\n     if (secp256k1_test_rng_precomputed_used == 8) {\n         secp256k1_rfc6979_hmac_sha256_generate(&secp256k1_test_rng, (unsigned char*)(&secp256k1_test_rng_precomputed[0]), sizeof(secp256k1_test_rng_precomputed));\n         secp256k1_test_rng_precomputed_used = 0;\n     }\n     return secp256k1_test_rng_precomputed[secp256k1_test_rng_precomputed_used++];\n }\n \n-static uint32_t secp256k1_rand_bits(int bits) {\n+static uint32_t secp256k1_testrand_bits(int bits) {\n     uint32_t ret;\n     if (secp256k1_test_rng_integer_bits_left < bits) {\n-        secp256k1_test_rng_integer |= (((uint64_t)secp256k1_rand32()) << secp256k1_test_rng_integer_bits_left);\n+        secp256k1_test_rng_integer |= (((uint64_t)secp256k1_testrand32()) << secp256k1_test_rng_integer_bits_left);\n         secp256k1_test_rng_integer_bits_left += 32;\n     }\n     ret = secp256k1_test_rng_integer;\n@@ -44,7 +45,7 @@ static uint32_t secp256k1_rand_bits(int bits) {\n     return ret;\n }\n \n-static uint32_t secp256k1_rand_int(uint32_t range) {\n+static uint32_t secp256k1_testrand_int(uint32_t range) {\n     /* We want a uniform integer between 0 and range-1, inclusive.\n      * B is the smallest number such that range <= 2**B.\n      * two mechanisms implemented here:\n@@ -76,25 +77,25 @@ static uint32_t secp256k1_rand_int(uint32_t range) {\n         mult = 1;\n     }\n     while(1) {\n-        uint32_t x = secp256k1_rand_bits(bits);\n+        uint32_t x = secp256k1_testrand_bits(bits);\n         if (x < trange) {\n             return (mult == 1) ? x : (x % range);\n         }\n     }\n }\n \n-static void secp256k1_rand256(unsigned char *b32) {\n+static void secp256k1_testrand256(unsigned char *b32) {\n     secp256k1_rfc6979_hmac_sha256_generate(&secp256k1_test_rng, b32, 32);\n }\n \n-static void secp256k1_rand_bytes_test(unsigned char *bytes, size_t len) {\n+static void secp256k1_testrand_bytes_test(unsigned char *bytes, size_t len) {\n     size_t bits = 0;\n     memset(bytes, 0, len);\n     while (bits < len * 8) {\n         int now;\n         uint32_t val;\n-        now = 1 + (secp256k1_rand_bits(6) * secp256k1_rand_bits(5) + 16) / 31;\n-        val = secp256k1_rand_bits(1);\n+        now = 1 + (secp256k1_testrand_bits(6) * secp256k1_testrand_bits(5) + 16) / 31;\n+        val = secp256k1_testrand_bits(1);\n         while (now > 0 && bits < len * 8) {\n             bytes[bits / 8] |= val << (bits % 8);\n             now--;\n@@ -103,12 +104,55 @@ static void secp256k1_rand_bytes_test(unsigned char *bytes, size_t len) {\n     }\n }\n \n-static void secp256k1_rand256_test(unsigned char *b32) {\n-    secp256k1_rand_bytes_test(b32, 32);\n+static void secp256k1_testrand256_test(unsigned char *b32) {\n+    secp256k1_testrand_bytes_test(b32, 32);\n }\n \n-static void secp256k1_rand_flip(unsigned char *b, size_t len) {\n-    b[secp256k1_rand_int(len)] ^= (1 << secp256k1_rand_int(8));\n+static void secp256k1_testrand_flip(unsigned char *b, size_t len) {\n+    b[secp256k1_testrand_int(len)] ^= (1 << secp256k1_testrand_int(8));\n+}\n+\n+static void secp256k1_testrand_init(const char* hexseed) {\n+    unsigned char seed16[16] = {0};\n+    if (hexseed && strlen(hexseed) != 0) {\n+        int pos = 0;\n+        while (pos < 16 && hexseed[0] != 0 && hexseed[1] != 0) {\n+            unsigned short sh;\n+            if ((sscanf(hexseed, \"%2hx\", &sh)) == 1) {\n+                seed16[pos] = sh;\n+            } else {\n+                break;\n+            }\n+            hexseed += 2;\n+            pos++;\n+        }\n+    } else {\n+        FILE *frand = fopen(\"/dev/urandom\", \"r\");\n+        if ((frand == NULL) || fread(&seed16, 1, sizeof(seed16), frand) != sizeof(seed16)) {\n+            uint64_t t = time(NULL) * (uint64_t)1337;\n+            fprintf(stderr, \"WARNING: could not read 16 bytes from /dev/urandom; falling back to insecure PRNG\\n\");\n+            seed16[0] ^= t;\n+            seed16[1] ^= t >> 8;\n+            seed16[2] ^= t >> 16;\n+            seed16[3] ^= t >> 24;\n+            seed16[4] ^= t >> 32;\n+            seed16[5] ^= t >> 40;\n+            seed16[6] ^= t >> 48;\n+            seed16[7] ^= t >> 56;\n+        }\n+        if (frand) {\n+            fclose(frand);\n+        }\n+    }\n+\n+    printf(\"random seed = %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\", seed16[0], seed16[1], seed16[2], seed16[3], seed16[4], seed16[5], seed16[6], seed16[7], seed16[8], seed16[9], seed16[10], seed16[11], seed16[12], seed16[13], seed16[14], seed16[15]);\n+    secp256k1_testrand_seed(seed16);\n+}\n+\n+static void secp256k1_testrand_finish(void) {\n+    unsigned char run32[32];\n+    secp256k1_testrand256(run32);\n+    printf(\"random run = %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\", run32[0], run32[1], run32[2], run32[3], run32[4], run32[5], run32[6], run32[7], run32[8], run32[9], run32[10], run32[11], run32[12], run32[13], run32[14], run32[15]);\n }\n \n #endif /* SECP256K1_TESTRAND_IMPL_H */"
      },
      {
        "sha": "bb4b5b4c077e8d4ed9ee1289daa065904d268712",
        "filename": "src/secp256k1/src/tests.c",
        "status": "modified",
        "additions": 301,
        "deletions": 254,
        "changes": 555,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests.c?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -54,7 +54,7 @@ static void uncounting_illegal_callback_fn(const char* str, void* data) {\n void random_field_element_test(secp256k1_fe *fe) {\n     do {\n         unsigned char b32[32];\n-        secp256k1_rand256_test(b32);\n+        secp256k1_testrand256_test(b32);\n         if (secp256k1_fe_set_b32(fe, b32)) {\n             break;\n         }\n@@ -63,7 +63,7 @@ void random_field_element_test(secp256k1_fe *fe) {\n \n void random_field_element_magnitude(secp256k1_fe *fe) {\n     secp256k1_fe zero;\n-    int n = secp256k1_rand_int(9);\n+    int n = secp256k1_testrand_int(9);\n     secp256k1_fe_normalize(fe);\n     if (n == 0) {\n         return;\n@@ -81,11 +81,12 @@ void random_group_element_test(secp256k1_ge *ge) {\n     secp256k1_fe fe;\n     do {\n         random_field_element_test(&fe);\n-        if (secp256k1_ge_set_xo_var(ge, &fe, secp256k1_rand_bits(1))) {\n+        if (secp256k1_ge_set_xo_var(ge, &fe, secp256k1_testrand_bits(1))) {\n             secp256k1_fe_normalize(&ge->y);\n             break;\n         }\n     } while(1);\n+    ge->infinity = 0;\n }\n \n void random_group_element_jacobian_test(secp256k1_gej *gej, const secp256k1_ge *ge) {\n@@ -107,7 +108,7 @@ void random_scalar_order_test(secp256k1_scalar *num) {\n     do {\n         unsigned char b32[32];\n         int overflow = 0;\n-        secp256k1_rand256_test(b32);\n+        secp256k1_testrand256_test(b32);\n         secp256k1_scalar_set_b32(num, b32, &overflow);\n         if (overflow || secp256k1_scalar_is_zero(num)) {\n             continue;\n@@ -120,7 +121,7 @@ void random_scalar_order(secp256k1_scalar *num) {\n     do {\n         unsigned char b32[32];\n         int overflow = 0;\n-        secp256k1_rand256(b32);\n+        secp256k1_testrand256(b32);\n         secp256k1_scalar_set_b32(num, b32, &overflow);\n         if (overflow || secp256k1_scalar_is_zero(num)) {\n             continue;\n@@ -441,14 +442,14 @@ void run_sha256_tests(void) {\n         secp256k1_sha256_initialize(&hasher);\n         secp256k1_sha256_write(&hasher, (const unsigned char*)(inputs[i]), strlen(inputs[i]));\n         secp256k1_sha256_finalize(&hasher, out);\n-        CHECK(memcmp(out, outputs[i], 32) == 0);\n+        CHECK(secp256k1_memcmp_var(out, outputs[i], 32) == 0);\n         if (strlen(inputs[i]) > 0) {\n-            int split = secp256k1_rand_int(strlen(inputs[i]));\n+            int split = secp256k1_testrand_int(strlen(inputs[i]));\n             secp256k1_sha256_initialize(&hasher);\n             secp256k1_sha256_write(&hasher, (const unsigned char*)(inputs[i]), split);\n             secp256k1_sha256_write(&hasher, (const unsigned char*)(inputs[i] + split), strlen(inputs[i]) - split);\n             secp256k1_sha256_finalize(&hasher, out);\n-            CHECK(memcmp(out, outputs[i], 32) == 0);\n+            CHECK(secp256k1_memcmp_var(out, outputs[i], 32) == 0);\n         }\n     }\n }\n@@ -485,14 +486,14 @@ void run_hmac_sha256_tests(void) {\n         secp256k1_hmac_sha256_initialize(&hasher, (const unsigned char*)(keys[i]), strlen(keys[i]));\n         secp256k1_hmac_sha256_write(&hasher, (const unsigned char*)(inputs[i]), strlen(inputs[i]));\n         secp256k1_hmac_sha256_finalize(&hasher, out);\n-        CHECK(memcmp(out, outputs[i], 32) == 0);\n+        CHECK(secp256k1_memcmp_var(out, outputs[i], 32) == 0);\n         if (strlen(inputs[i]) > 0) {\n-            int split = secp256k1_rand_int(strlen(inputs[i]));\n+            int split = secp256k1_testrand_int(strlen(inputs[i]));\n             secp256k1_hmac_sha256_initialize(&hasher, (const unsigned char*)(keys[i]), strlen(keys[i]));\n             secp256k1_hmac_sha256_write(&hasher, (const unsigned char*)(inputs[i]), split);\n             secp256k1_hmac_sha256_write(&hasher, (const unsigned char*)(inputs[i] + split), strlen(inputs[i]) - split);\n             secp256k1_hmac_sha256_finalize(&hasher, out);\n-            CHECK(memcmp(out, outputs[i], 32) == 0);\n+            CHECK(secp256k1_memcmp_var(out, outputs[i], 32) == 0);\n         }\n     }\n }\n@@ -519,21 +520,21 @@ void run_rfc6979_hmac_sha256_tests(void) {\n     secp256k1_rfc6979_hmac_sha256_initialize(&rng, key1, 64);\n     for (i = 0; i < 3; i++) {\n         secp256k1_rfc6979_hmac_sha256_generate(&rng, out, 32);\n-        CHECK(memcmp(out, out1[i], 32) == 0);\n+        CHECK(secp256k1_memcmp_var(out, out1[i], 32) == 0);\n     }\n     secp256k1_rfc6979_hmac_sha256_finalize(&rng);\n \n     secp256k1_rfc6979_hmac_sha256_initialize(&rng, key1, 65);\n     for (i = 0; i < 3; i++) {\n         secp256k1_rfc6979_hmac_sha256_generate(&rng, out, 32);\n-        CHECK(memcmp(out, out1[i], 32) != 0);\n+        CHECK(secp256k1_memcmp_var(out, out1[i], 32) != 0);\n     }\n     secp256k1_rfc6979_hmac_sha256_finalize(&rng);\n \n     secp256k1_rfc6979_hmac_sha256_initialize(&rng, key2, 64);\n     for (i = 0; i < 3; i++) {\n         secp256k1_rfc6979_hmac_sha256_generate(&rng, out, 32);\n-        CHECK(memcmp(out, out2[i], 32) == 0);\n+        CHECK(secp256k1_memcmp_var(out, out2[i], 32) == 0);\n     }\n     secp256k1_rfc6979_hmac_sha256_finalize(&rng);\n }\n@@ -557,7 +558,7 @@ void test_rand_bits(int rand32, int bits) {\n     /* Multiply the output of all rand calls with the odd number m, which\n        should not change the uniformity of its distribution. */\n     for (i = 0; i < rounds[usebits]; i++) {\n-        uint32_t r = (rand32 ? secp256k1_rand32() : secp256k1_rand_bits(bits));\n+        uint32_t r = (rand32 ? secp256k1_testrand32() : secp256k1_testrand_bits(bits));\n         CHECK((((uint64_t)r) >> bits) == 0);\n         for (m = 0; m < sizeof(mults) / sizeof(mults[0]); m++) {\n             uint32_t rm = r * mults[m];\n@@ -582,7 +583,7 @@ void test_rand_int(uint32_t range, uint32_t subrange) {\n     uint64_t x = 0;\n     CHECK((range % subrange) == 0);\n     for (i = 0; i < rounds; i++) {\n-        uint32_t r = secp256k1_rand_int(range);\n+        uint32_t r = secp256k1_testrand_int(range);\n         CHECK(r < range);\n         r = r % subrange;\n         x |= (((uint64_t)1) << r);\n@@ -614,7 +615,7 @@ void run_rand_int(void) {\n \n #ifndef USE_NUM_NONE\n void random_num_negate(secp256k1_num *num) {\n-    if (secp256k1_rand_bits(1)) {\n+    if (secp256k1_testrand_bits(1)) {\n         secp256k1_num_negate(num);\n     }\n }\n@@ -658,11 +659,11 @@ void test_num_add_sub(void) {\n     secp256k1_num n2;\n     secp256k1_num n1p2, n2p1, n1m2, n2m1;\n     random_num_order_test(&n1); /* n1 = R1 */\n-    if (secp256k1_rand_bits(1)) {\n+    if (secp256k1_testrand_bits(1)) {\n         random_num_negate(&n1);\n     }\n     random_num_order_test(&n2); /* n2 = R2 */\n-    if (secp256k1_rand_bits(1)) {\n+    if (secp256k1_testrand_bits(1)) {\n         random_num_negate(&n2);\n     }\n     secp256k1_num_add(&n1p2, &n1, &n2); /* n1p2 = R1 + R2 */\n@@ -853,7 +854,7 @@ void scalar_test(void) {\n         while (i < 256) {\n             secp256k1_scalar t;\n             int j;\n-            int now = secp256k1_rand_int(15) + 1;\n+            int now = secp256k1_testrand_int(15) + 1;\n             if (now + i > 256) {\n                 now = 256 - i;\n             }\n@@ -930,7 +931,7 @@ void scalar_test(void) {\n         secp256k1_num rnum;\n         secp256k1_num rnum2;\n         unsigned char cone[1] = {0x01};\n-        unsigned int shift = 256 + secp256k1_rand_int(257);\n+        unsigned int shift = 256 + secp256k1_testrand_int(257);\n         secp256k1_scalar_mul_shift_var(&r, &s1, &s2, shift);\n         secp256k1_num_mul(&rnum, &s1num, &s2num);\n         secp256k1_num_shift(&rnum, shift - 1);\n@@ -948,7 +949,7 @@ void scalar_test(void) {\n         random_scalar_order_test(&r);\n         for (i = 0; i < 100; ++i) {\n             int low;\n-            int shift = 1 + secp256k1_rand_int(15);\n+            int shift = 1 + secp256k1_testrand_int(15);\n             int expected = r.d[0] % (1 << shift);\n             low = secp256k1_scalar_shr_int(&r, shift);\n             CHECK(expected == low);\n@@ -996,7 +997,7 @@ void scalar_test(void) {\n         secp256k1_scalar b;\n         int i;\n         /* Test add_bit. */\n-        int bit = secp256k1_rand_bits(8);\n+        int bit = secp256k1_testrand_bits(8);\n         secp256k1_scalar_set_int(&b, 1);\n         CHECK(secp256k1_scalar_is_one(&b));\n         for (i = 0; i < bit; i++) {\n@@ -1157,7 +1158,7 @@ void run_scalar_tests(void) {\n         secp256k1_scalar_set_b32(&scalar, bin, &overflow);\n         CHECK(overflow == 0);\n         secp256k1_scalar_get_b32(bin_tmp, &scalar);\n-        CHECK(memcmp(bin, bin_tmp, 32) == 0);\n+        CHECK(secp256k1_memcmp_var(bin, bin_tmp, 32) == 0);\n \n         /* A scalar set to all 1s should overflow. */\n         memset(bin, 0xFF, 32);\n@@ -1767,7 +1768,7 @@ void run_scalar_tests(void) {\n void random_fe(secp256k1_fe *x) {\n     unsigned char bin[32];\n     do {\n-        secp256k1_rand256(bin);\n+        secp256k1_testrand256(bin);\n         if (secp256k1_fe_set_b32(x, bin)) {\n             return;\n         }\n@@ -1777,7 +1778,7 @@ void random_fe(secp256k1_fe *x) {\n void random_fe_test(secp256k1_fe *x) {\n     unsigned char bin[32];\n     do {\n-        secp256k1_rand256_test(bin);\n+        secp256k1_testrand256_test(bin);\n         if (secp256k1_fe_set_b32(x, bin)) {\n             return;\n         }\n@@ -1845,18 +1846,18 @@ void run_field_convert(void) {\n     CHECK(secp256k1_fe_equal_var(&fe, &fe2));\n     /* Check conversion from fe. */\n     secp256k1_fe_get_b32(b322, &fe);\n-    CHECK(memcmp(b322, b32, 32) == 0);\n+    CHECK(secp256k1_memcmp_var(b322, b32, 32) == 0);\n     secp256k1_fe_to_storage(&fes2, &fe);\n-    CHECK(memcmp(&fes2, &fes, sizeof(fes)) == 0);\n+    CHECK(secp256k1_memcmp_var(&fes2, &fes, sizeof(fes)) == 0);\n }\n \n-int fe_memcmp(const secp256k1_fe *a, const secp256k1_fe *b) {\n+int fe_secp256k1_memcmp_var(const secp256k1_fe *a, const secp256k1_fe *b) {\n     secp256k1_fe t = *b;\n #ifdef VERIFY\n     t.magnitude = a->magnitude;\n     t.normalized = a->normalized;\n #endif\n-    return memcmp(a, &t, sizeof(secp256k1_fe));\n+    return secp256k1_memcmp_var(a, &t, sizeof(secp256k1_fe));\n }\n \n void run_field_misc(void) {\n@@ -1882,13 +1883,13 @@ void run_field_misc(void) {\n         CHECK(x.normalized && x.magnitude == 1);\n #endif\n         secp256k1_fe_cmov(&x, &x, 1);\n-        CHECK(fe_memcmp(&x, &z) != 0);\n-        CHECK(fe_memcmp(&x, &q) == 0);\n+        CHECK(fe_secp256k1_memcmp_var(&x, &z) != 0);\n+        CHECK(fe_secp256k1_memcmp_var(&x, &q) == 0);\n         secp256k1_fe_cmov(&q, &z, 1);\n #ifdef VERIFY\n         CHECK(!q.normalized && q.magnitude == z.magnitude);\n #endif\n-        CHECK(fe_memcmp(&q, &z) == 0);\n+        CHECK(fe_secp256k1_memcmp_var(&q, &z) == 0);\n         secp256k1_fe_normalize_var(&x);\n         secp256k1_fe_normalize_var(&z);\n         CHECK(!secp256k1_fe_equal_var(&x, &z));\n@@ -1912,9 +1913,9 @@ void run_field_misc(void) {\n         secp256k1_fe_to_storage(&zs, &z);\n         secp256k1_fe_storage_cmov(&zs, &xs, 0);\n         secp256k1_fe_storage_cmov(&zs, &zs, 1);\n-        CHECK(memcmp(&xs, &zs, sizeof(xs)) != 0);\n+        CHECK(secp256k1_memcmp_var(&xs, &zs, sizeof(xs)) != 0);\n         secp256k1_fe_storage_cmov(&ys, &xs, 1);\n-        CHECK(memcmp(&xs, &ys, sizeof(xs)) == 0);\n+        CHECK(secp256k1_memcmp_var(&xs, &ys, sizeof(xs)) == 0);\n         secp256k1_fe_from_storage(&x, &xs);\n         secp256k1_fe_from_storage(&y, &ys);\n         secp256k1_fe_from_storage(&z, &zs);\n@@ -1970,7 +1971,7 @@ void run_field_inv_all_var(void) {\n     secp256k1_fe_inv_all_var(xi, x, 0);\n     for (i = 0; i < count; i++) {\n         size_t j;\n-        size_t len = secp256k1_rand_int(15) + 1;\n+        size_t len = secp256k1_testrand_int(15) + 1;\n         for (j = 0; j < len; j++) {\n             random_fe_non_zero(&x[j]);\n         }\n@@ -2101,17 +2102,12 @@ void ge_equals_gej(const secp256k1_ge *a, const secp256k1_gej *b) {\n \n void test_ge(void) {\n     int i, i1;\n-#ifdef USE_ENDOMORPHISM\n     int runs = 6;\n-#else\n-    int runs = 4;\n-#endif\n-    /* Points: (infinity, p1, p1, -p1, -p1, p2, p2, -p2, -p2, p3, p3, -p3, -p3, p4, p4, -p4, -p4).\n-     * The second in each pair of identical points uses a random Z coordinate in the Jacobian form.\n-     * All magnitudes are randomized.\n-     * All 17*17 combinations of points are added to each other, using all applicable methods.\n-     *\n-     * When the endomorphism code is compiled in, p5 = lambda*p1 and p6 = lambda^2*p1 are added as well.\n+    /* 25 points are used:\n+     * - infinity\n+     * - for each of four random points p1 p2 p3 p4, we add the point, its\n+     *   negation, and then those two again but with randomized Z coordinate.\n+     * - The same is then done for lambda*p1 and lambda^2*p1.\n      */\n     secp256k1_ge *ge = (secp256k1_ge *)checked_malloc(&ctx->error_callback, sizeof(secp256k1_ge) * (1 + 4 * runs));\n     secp256k1_gej *gej = (secp256k1_gej *)checked_malloc(&ctx->error_callback, sizeof(secp256k1_gej) * (1 + 4 * runs));\n@@ -2126,14 +2122,12 @@ void test_ge(void) {\n         int j;\n         secp256k1_ge g;\n         random_group_element_test(&g);\n-#ifdef USE_ENDOMORPHISM\n         if (i >= runs - 2) {\n             secp256k1_ge_mul_lambda(&g, &ge[1]);\n         }\n         if (i >= runs - 1) {\n             secp256k1_ge_mul_lambda(&g, &g);\n         }\n-#endif\n         ge[1 + 4 * i] = g;\n         ge[2 + 4 * i] = g;\n         secp256k1_ge_neg(&ge[3 + 4 * i], &g);\n@@ -2262,7 +2256,7 @@ void test_ge(void) {\n             gej_shuffled[i] = gej[i];\n         }\n         for (i = 0; i < 4 * runs + 1; i++) {\n-            int swap = i + secp256k1_rand_int(4 * runs + 1 - i);\n+            int swap = i + secp256k1_testrand_int(4 * runs + 1 - i);\n             if (swap != i) {\n                 secp256k1_gej t = gej_shuffled[i];\n                 gej_shuffled[i] = gej_shuffled[swap];\n@@ -2448,7 +2442,7 @@ void test_ec_combine(void) {\n         secp256k1_ge_set_gej(&Q, &Qj);\n         secp256k1_pubkey_save(&sd, &Q);\n         CHECK(secp256k1_ec_pubkey_combine(ctx, &sd2, d, i) == 1);\n-        CHECK(memcmp(&sd, &sd2, sizeof(sd)) == 0);\n+        CHECK(secp256k1_memcmp_var(&sd, &sd2, sizeof(sd)) == 0);\n     }\n }\n \n@@ -2614,7 +2608,6 @@ void test_point_times_order(const secp256k1_gej *point) {\n     secp256k1_ecmult(&ctx->ecmult_ctx, &res2, point, &nx, &nx); /* calc res2 = (order - x) * point + (order - x) * G; */\n     secp256k1_gej_add_var(&res1, &res1, &res2, NULL);\n     CHECK(secp256k1_gej_is_infinity(&res1));\n-    CHECK(secp256k1_gej_is_valid_var(&res1) == 0);\n     secp256k1_ge_set_gej(&res3, &res1);\n     CHECK(secp256k1_ge_is_infinity(&res3));\n     CHECK(secp256k1_ge_is_valid_var(&res3) == 0);\n@@ -2633,6 +2626,87 @@ void test_point_times_order(const secp256k1_gej *point) {\n     ge_equals_ge(&res3, &secp256k1_ge_const_g);\n }\n \n+/* These scalars reach large (in absolute value) outputs when fed to secp256k1_scalar_split_lambda.\n+ *\n+ * They are computed as:\n+ * - For a in [-2, -1, 0, 1, 2]:\n+ *   - For b in [-3, -1, 1, 3]:\n+ *     - Output (a*LAMBDA + (ORDER+b)/2) % ORDER\n+ */\n+static const secp256k1_scalar scalars_near_split_bounds[20] = {\n+    SECP256K1_SCALAR_CONST(0xd938a566, 0x7f479e3e, 0xb5b3c7fa, 0xefdb3749, 0x3aa0585c, 0xc5ea2367, 0xe1b660db, 0x0209e6fc),\n+    SECP256K1_SCALAR_CONST(0xd938a566, 0x7f479e3e, 0xb5b3c7fa, 0xefdb3749, 0x3aa0585c, 0xc5ea2367, 0xe1b660db, 0x0209e6fd),\n+    SECP256K1_SCALAR_CONST(0xd938a566, 0x7f479e3e, 0xb5b3c7fa, 0xefdb3749, 0x3aa0585c, 0xc5ea2367, 0xe1b660db, 0x0209e6fe),\n+    SECP256K1_SCALAR_CONST(0xd938a566, 0x7f479e3e, 0xb5b3c7fa, 0xefdb3749, 0x3aa0585c, 0xc5ea2367, 0xe1b660db, 0x0209e6ff),\n+    SECP256K1_SCALAR_CONST(0x2c9c52b3, 0x3fa3cf1f, 0x5ad9e3fd, 0x77ed9ba5, 0xb294b893, 0x3722e9a5, 0x00e698ca, 0x4cf7632d),\n+    SECP256K1_SCALAR_CONST(0x2c9c52b3, 0x3fa3cf1f, 0x5ad9e3fd, 0x77ed9ba5, 0xb294b893, 0x3722e9a5, 0x00e698ca, 0x4cf7632e),\n+    SECP256K1_SCALAR_CONST(0x2c9c52b3, 0x3fa3cf1f, 0x5ad9e3fd, 0x77ed9ba5, 0xb294b893, 0x3722e9a5, 0x00e698ca, 0x4cf7632f),\n+    SECP256K1_SCALAR_CONST(0x2c9c52b3, 0x3fa3cf1f, 0x5ad9e3fd, 0x77ed9ba5, 0xb294b893, 0x3722e9a5, 0x00e698ca, 0x4cf76330),\n+    SECP256K1_SCALAR_CONST(0x7fffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xd576e735, 0x57a4501d, 0xdfe92f46, 0x681b209f),\n+    SECP256K1_SCALAR_CONST(0x7fffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xd576e735, 0x57a4501d, 0xdfe92f46, 0x681b20a0),\n+    SECP256K1_SCALAR_CONST(0x7fffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xd576e735, 0x57a4501d, 0xdfe92f46, 0x681b20a1),\n+    SECP256K1_SCALAR_CONST(0x7fffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xd576e735, 0x57a4501d, 0xdfe92f46, 0x681b20a2),\n+    SECP256K1_SCALAR_CONST(0xd363ad4c, 0xc05c30e0, 0xa5261c02, 0x88126459, 0xf85915d7, 0x7825b696, 0xbeebc5c2, 0x833ede11),\n+    SECP256K1_SCALAR_CONST(0xd363ad4c, 0xc05c30e0, 0xa5261c02, 0x88126459, 0xf85915d7, 0x7825b696, 0xbeebc5c2, 0x833ede12),\n+    SECP256K1_SCALAR_CONST(0xd363ad4c, 0xc05c30e0, 0xa5261c02, 0x88126459, 0xf85915d7, 0x7825b696, 0xbeebc5c2, 0x833ede13),\n+    SECP256K1_SCALAR_CONST(0xd363ad4c, 0xc05c30e0, 0xa5261c02, 0x88126459, 0xf85915d7, 0x7825b696, 0xbeebc5c2, 0x833ede14),\n+    SECP256K1_SCALAR_CONST(0x26c75a99, 0x80b861c1, 0x4a4c3805, 0x1024c8b4, 0x704d760e, 0xe95e7cd3, 0xde1bfdb1, 0xce2c5a42),\n+    SECP256K1_SCALAR_CONST(0x26c75a99, 0x80b861c1, 0x4a4c3805, 0x1024c8b4, 0x704d760e, 0xe95e7cd3, 0xde1bfdb1, 0xce2c5a43),\n+    SECP256K1_SCALAR_CONST(0x26c75a99, 0x80b861c1, 0x4a4c3805, 0x1024c8b4, 0x704d760e, 0xe95e7cd3, 0xde1bfdb1, 0xce2c5a44),\n+    SECP256K1_SCALAR_CONST(0x26c75a99, 0x80b861c1, 0x4a4c3805, 0x1024c8b4, 0x704d760e, 0xe95e7cd3, 0xde1bfdb1, 0xce2c5a45)\n+};\n+\n+void test_ecmult_target(const secp256k1_scalar* target, int mode) {\n+    /* Mode: 0=ecmult_gen, 1=ecmult, 2=ecmult_const */\n+    secp256k1_scalar n1, n2;\n+    secp256k1_ge p;\n+    secp256k1_gej pj, p1j, p2j, ptj;\n+    static const secp256k1_scalar zero = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 0);\n+\n+    /* Generate random n1,n2 such that n1+n2 = -target. */\n+    random_scalar_order_test(&n1);\n+    secp256k1_scalar_add(&n2, &n1, target);\n+    secp256k1_scalar_negate(&n2, &n2);\n+\n+    /* Generate a random input point. */\n+    if (mode != 0) {\n+        random_group_element_test(&p);\n+        secp256k1_gej_set_ge(&pj, &p);\n+    }\n+\n+    /* EC multiplications */\n+    if (mode == 0) {\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &p1j, &n1);\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &p2j, &n2);\n+        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &ptj, target);\n+    } else if (mode == 1) {\n+        secp256k1_ecmult(&ctx->ecmult_ctx, &p1j, &pj, &n1, &zero);\n+        secp256k1_ecmult(&ctx->ecmult_ctx, &p2j, &pj, &n2, &zero);\n+        secp256k1_ecmult(&ctx->ecmult_ctx, &ptj, &pj, target, &zero);\n+    } else {\n+        secp256k1_ecmult_const(&p1j, &p, &n1, 256);\n+        secp256k1_ecmult_const(&p2j, &p, &n2, 256);\n+        secp256k1_ecmult_const(&ptj, &p, target, 256);\n+    }\n+\n+    /* Add them all up: n1*P + n2*P + target*P = (n1+n2+target)*P = (n1+n1-n1-n2)*P = 0. */\n+    secp256k1_gej_add_var(&ptj, &ptj, &p1j, NULL);\n+    secp256k1_gej_add_var(&ptj, &ptj, &p2j, NULL);\n+    CHECK(secp256k1_gej_is_infinity(&ptj));\n+}\n+\n+void run_ecmult_near_split_bound(void) {\n+    int i;\n+    unsigned j;\n+    for (i = 0; i < 4*count; ++i) {\n+        for (j = 0; j < sizeof(scalars_near_split_bounds) / sizeof(scalars_near_split_bounds[0]); ++j) {\n+            test_ecmult_target(&scalars_near_split_bounds[j], 0);\n+            test_ecmult_target(&scalars_near_split_bounds[j], 1);\n+            test_ecmult_target(&scalars_near_split_bounds[j], 2);\n+        }\n+    }\n+}\n+\n void run_point_times_order(void) {\n     int i;\n     secp256k1_fe x = SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 2);\n@@ -2646,7 +2720,6 @@ void run_point_times_order(void) {\n             secp256k1_gej j;\n             CHECK(secp256k1_ge_is_valid_var(&p));\n             secp256k1_gej_set_ge(&j, &p);\n-            CHECK(secp256k1_gej_is_valid_var(&j));\n             test_point_times_order(&j);\n         }\n         secp256k1_fe_sqr(&x, &x);\n@@ -3042,12 +3115,10 @@ void test_secp256k1_pippenger_bucket_window_inv(void) {\n \n     CHECK(secp256k1_pippenger_bucket_window_inv(0) == 0);\n     for(i = 1; i <= PIPPENGER_MAX_BUCKET_WINDOW; i++) {\n-#ifdef USE_ENDOMORPHISM\n         /* Bucket_window of 8 is not used with endo */\n         if (i == 8) {\n             continue;\n         }\n-#endif\n         CHECK(secp256k1_pippenger_bucket_window(secp256k1_pippenger_bucket_window_inv(i)) == i);\n         if (i != PIPPENGER_MAX_BUCKET_WINDOW) {\n             CHECK(secp256k1_pippenger_bucket_window(secp256k1_pippenger_bucket_window_inv(i)+1) > i);\n@@ -3060,7 +3131,7 @@ void test_secp256k1_pippenger_bucket_window_inv(void) {\n  * for a given scratch space.\n  */\n void test_ecmult_multi_pippenger_max_points(void) {\n-    size_t scratch_size = secp256k1_rand_int(256);\n+    size_t scratch_size = secp256k1_testrand_int(256);\n     size_t max_size = secp256k1_pippenger_scratch_size(secp256k1_pippenger_bucket_window_inv(PIPPENGER_MAX_BUCKET_WINDOW-1)+512, 12);\n     secp256k1_scratch *scratch;\n     size_t n_points_supported;\n@@ -3290,13 +3361,10 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n \n     secp256k1_scalar_set_int(&x, 0);\n     secp256k1_scalar_set_int(&shift, 1 << w);\n-    /* With USE_ENDOMORPHISM on we only consider 128-bit numbers */\n-#ifdef USE_ENDOMORPHISM\n     for (i = 0; i < 16; ++i) {\n         secp256k1_scalar_shr_int(&num, 8);\n     }\n     bits = 128;\n-#endif\n     skew = secp256k1_wnaf_const(wnaf, &num, w, bits);\n \n     for (i = WNAF_SIZE_BITS(bits, w); i >= 0; --i) {\n@@ -3331,12 +3399,9 @@ void test_fixed_wnaf(const secp256k1_scalar *number, int w) {\n \n     secp256k1_scalar_set_int(&x, 0);\n     secp256k1_scalar_set_int(&shift, 1 << w);\n-    /* With USE_ENDOMORPHISM on we only consider 128-bit numbers */\n-#ifdef USE_ENDOMORPHISM\n     for (i = 0; i < 16; ++i) {\n         secp256k1_scalar_shr_int(&num, 8);\n     }\n-#endif\n     skew = secp256k1_wnaf_fixed(wnaf, &num, w);\n \n     for (i = WNAF_SIZE(w)-1; i >= 0; --i) {\n@@ -3520,7 +3585,7 @@ void test_ecmult_gen_blind(void) {\n     secp256k1_ge pge;\n     random_scalar_order_test(&key);\n     secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pgej, &key);\n-    secp256k1_rand256(seed32);\n+    secp256k1_testrand256(seed32);\n     b = ctx->ecmult_gen_ctx.blind;\n     i = ctx->ecmult_gen_ctx.initial;\n     secp256k1_ecmult_gen_blind(&ctx->ecmult_gen_ctx, seed32);\n@@ -3552,16 +3617,18 @@ void run_ecmult_gen_blind(void) {\n     }\n }\n \n-#ifdef USE_ENDOMORPHISM\n /***** ENDOMORPHISH TESTS *****/\n-void test_scalar_split(void) {\n-    secp256k1_scalar full;\n-    secp256k1_scalar s1, slam;\n+void test_scalar_split(const secp256k1_scalar* full) {\n+    secp256k1_scalar s, s1, slam;\n     const unsigned char zero[32] = {0};\n     unsigned char tmp[32];\n \n-    random_scalar_order_test(&full);\n-    secp256k1_scalar_split_lambda(&s1, &slam, &full);\n+    secp256k1_scalar_split_lambda(&s1, &slam, full);\n+\n+    /* check slam*lambda + s1 == full */\n+    secp256k1_scalar_mul(&s, &secp256k1_const_lambda, &slam);\n+    secp256k1_scalar_add(&s, &s, &s1);\n+    CHECK(secp256k1_scalar_eq(&s, full));\n \n     /* check that both are <= 128 bits in size */\n     if (secp256k1_scalar_is_high(&s1)) {\n@@ -3572,15 +3639,32 @@ void test_scalar_split(void) {\n     }\n \n     secp256k1_scalar_get_b32(tmp, &s1);\n-    CHECK(memcmp(zero, tmp, 16) == 0);\n+    CHECK(secp256k1_memcmp_var(zero, tmp, 16) == 0);\n     secp256k1_scalar_get_b32(tmp, &slam);\n-    CHECK(memcmp(zero, tmp, 16) == 0);\n+    CHECK(secp256k1_memcmp_var(zero, tmp, 16) == 0);\n }\n \n+\n void run_endomorphism_tests(void) {\n-    test_scalar_split();\n+    unsigned i;\n+    static secp256k1_scalar s;\n+    test_scalar_split(&secp256k1_scalar_zero);\n+    test_scalar_split(&secp256k1_scalar_one);\n+    secp256k1_scalar_negate(&s,&secp256k1_scalar_one);\n+    test_scalar_split(&s);\n+    test_scalar_split(&secp256k1_const_lambda);\n+    secp256k1_scalar_add(&s, &secp256k1_const_lambda, &secp256k1_scalar_one);\n+    test_scalar_split(&s);\n+\n+    for (i = 0; i < 100U * count; ++i) {\n+        secp256k1_scalar full;\n+        random_scalar_order_test(&full);\n+        test_scalar_split(&full);\n+    }\n+    for (i = 0; i < sizeof(scalars_near_split_bounds) / sizeof(scalars_near_split_bounds[0]); ++i) {\n+        test_scalar_split(&scalars_near_split_bounds[i]);\n+    }\n }\n-#endif\n \n void ec_pubkey_parse_pointtest(const unsigned char *input, int xvalid, int yvalid) {\n     unsigned char pubkeyc[65];\n@@ -3622,7 +3706,7 @@ void ec_pubkey_parse_pointtest(const unsigned char *input, int xvalid, int yvali\n                 CHECK(secp256k1_ec_pubkey_serialize(ctx, pubkeyo, &outl, &pubkey, SECP256K1_EC_COMPRESSED) == 1);\n                 VG_CHECK(pubkeyo, outl);\n                 CHECK(outl == 33);\n-                CHECK(memcmp(&pubkeyo[1], &pubkeyc[1], 32) == 0);\n+                CHECK(secp256k1_memcmp_var(&pubkeyo[1], &pubkeyc[1], 32) == 0);\n                 CHECK((pubkeyclen != 33) || (pubkeyo[0] == pubkeyc[0]));\n                 if (ypass) {\n                     /* This test isn't always done because we decode with alternative signs, so the y won't match. */\n@@ -3638,7 +3722,7 @@ void ec_pubkey_parse_pointtest(const unsigned char *input, int xvalid, int yvali\n                     VG_CHECK(pubkeyo, outl);\n                     CHECK(outl == 65);\n                     CHECK(pubkeyo[0] == 4);\n-                    CHECK(memcmp(&pubkeyo[1], input, 64) == 0);\n+                    CHECK(secp256k1_memcmp_var(&pubkeyo[1], input, 64) == 0);\n                 }\n                 CHECK(ecount == 0);\n             } else {\n@@ -4007,31 +4091,31 @@ void run_eckey_edge_case_test(void) {\n     VG_UNDEF(&pubkey, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey, orderc) == 0);\n     VG_CHECK(&pubkey, sizeof(pubkey));\n-    CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n     /* Maximum value is too large, reject. */\n     memset(ctmp, 255, 32);\n     CHECK(secp256k1_ec_seckey_verify(ctx, ctmp) == 0);\n     memset(&pubkey, 1, sizeof(pubkey));\n     VG_UNDEF(&pubkey, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey, ctmp) == 0);\n     VG_CHECK(&pubkey, sizeof(pubkey));\n-    CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n     /* Zero is too small, reject. */\n     memset(ctmp, 0, 32);\n     CHECK(secp256k1_ec_seckey_verify(ctx, ctmp) == 0);\n     memset(&pubkey, 1, sizeof(pubkey));\n     VG_UNDEF(&pubkey, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey, ctmp) == 0);\n     VG_CHECK(&pubkey, sizeof(pubkey));\n-    CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n     /* One must be accepted. */\n     ctmp[31] = 0x01;\n     CHECK(secp256k1_ec_seckey_verify(ctx, ctmp) == 1);\n     memset(&pubkey, 0, sizeof(pubkey));\n     VG_UNDEF(&pubkey, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey, ctmp) == 1);\n     VG_CHECK(&pubkey, sizeof(pubkey));\n-    CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) > 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(secp256k1_pubkey)) > 0);\n     pubkey_one = pubkey;\n     /* Group order + 1 is too large, reject. */\n     memcpy(ctmp, orderc, 32);\n@@ -4041,28 +4125,28 @@ void run_eckey_edge_case_test(void) {\n     VG_UNDEF(&pubkey, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey, ctmp) == 0);\n     VG_CHECK(&pubkey, sizeof(pubkey));\n-    CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n     /* -1 must be accepted. */\n     ctmp[31] = 0x40;\n     CHECK(secp256k1_ec_seckey_verify(ctx, ctmp) == 1);\n     memset(&pubkey, 0, sizeof(pubkey));\n     VG_UNDEF(&pubkey, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey, ctmp) == 1);\n     VG_CHECK(&pubkey, sizeof(pubkey));\n-    CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) > 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(secp256k1_pubkey)) > 0);\n     pubkey_negone = pubkey;\n     /* Tweak of zero leaves the value unchanged. */\n     memset(ctmp2, 0, 32);\n     CHECK(secp256k1_ec_seckey_tweak_add(ctx, ctmp, ctmp2) == 1);\n-    CHECK(memcmp(orderc, ctmp, 31) == 0 && ctmp[31] == 0x40);\n+    CHECK(secp256k1_memcmp_var(orderc, ctmp, 31) == 0 && ctmp[31] == 0x40);\n     memcpy(&pubkey2, &pubkey, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, ctmp2) == 1);\n-    CHECK(memcmp(&pubkey, &pubkey2, sizeof(pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, &pubkey2, sizeof(pubkey)) == 0);\n     /* Multiply tweak of zero zeroizes the output. */\n     CHECK(secp256k1_ec_seckey_tweak_mul(ctx, ctmp, ctmp2) == 0);\n-    CHECK(memcmp(zeros, ctmp, 32) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros, ctmp, 32) == 0);\n     CHECK(secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, ctmp2) == 0);\n-    CHECK(memcmp(&pubkey, zeros, sizeof(pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(pubkey)) == 0);\n     memcpy(&pubkey, &pubkey2, sizeof(pubkey));\n     /* If seckey_tweak_add or seckey_tweak_mul are called with an overflowing\n     seckey, the seckey is zeroized. */\n@@ -4072,29 +4156,29 @@ void run_eckey_edge_case_test(void) {\n     CHECK(secp256k1_ec_seckey_verify(ctx, ctmp2) == 1);\n     CHECK(secp256k1_ec_seckey_verify(ctx, ctmp) == 0);\n     CHECK(secp256k1_ec_seckey_tweak_add(ctx, ctmp, ctmp2) == 0);\n-    CHECK(memcmp(zeros, ctmp, 32) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros, ctmp, 32) == 0);\n     memcpy(ctmp, orderc, 32);\n     CHECK(secp256k1_ec_seckey_tweak_mul(ctx, ctmp, ctmp2) == 0);\n-    CHECK(memcmp(zeros, ctmp, 32) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros, ctmp, 32) == 0);\n     /* If seckey_tweak_add or seckey_tweak_mul are called with an overflowing\n     tweak, the seckey is zeroized. */\n     memcpy(ctmp, orderc, 32);\n     ctmp[31] = 0x40;\n     CHECK(secp256k1_ec_seckey_tweak_add(ctx, ctmp, orderc) == 0);\n-    CHECK(memcmp(zeros, ctmp, 32) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros, ctmp, 32) == 0);\n     memcpy(ctmp, orderc, 32);\n     ctmp[31] = 0x40;\n     CHECK(secp256k1_ec_seckey_tweak_mul(ctx, ctmp, orderc) == 0);\n-    CHECK(memcmp(zeros, ctmp, 32) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros, ctmp, 32) == 0);\n     memcpy(ctmp, orderc, 32);\n     ctmp[31] = 0x40;\n     /* If pubkey_tweak_add or pubkey_tweak_mul are called with an overflowing\n     tweak, the pubkey is zeroized. */\n     CHECK(secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, orderc) == 0);\n-    CHECK(memcmp(&pubkey, zeros, sizeof(pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(pubkey)) == 0);\n     memcpy(&pubkey, &pubkey2, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, orderc) == 0);\n-    CHECK(memcmp(&pubkey, zeros, sizeof(pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(pubkey)) == 0);\n     memcpy(&pubkey, &pubkey2, sizeof(pubkey));\n     /* If the resulting key in secp256k1_ec_seckey_tweak_add and\n      * secp256k1_ec_pubkey_tweak_add is 0 the functions fail and in the latter\n@@ -4104,25 +4188,25 @@ void run_eckey_edge_case_test(void) {\n     memset(ctmp2, 0, 32);\n     ctmp2[31] = 1;\n     CHECK(secp256k1_ec_seckey_tweak_add(ctx, ctmp2, ctmp) == 0);\n-    CHECK(memcmp(zeros, ctmp2, 32) == 0);\n+    CHECK(secp256k1_memcmp_var(zeros, ctmp2, 32) == 0);\n     ctmp2[31] = 1;\n     CHECK(secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, ctmp2) == 0);\n-    CHECK(memcmp(&pubkey, zeros, sizeof(pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(pubkey)) == 0);\n     memcpy(&pubkey, &pubkey2, sizeof(pubkey));\n     /* Tweak computation wraps and results in a key of 1. */\n     ctmp2[31] = 2;\n     CHECK(secp256k1_ec_seckey_tweak_add(ctx, ctmp2, ctmp) == 1);\n-    CHECK(memcmp(ctmp2, zeros, 31) == 0 && ctmp2[31] == 1);\n+    CHECK(secp256k1_memcmp_var(ctmp2, zeros, 31) == 0 && ctmp2[31] == 1);\n     ctmp2[31] = 2;\n     CHECK(secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, ctmp2) == 1);\n     ctmp2[31] = 1;\n     CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey2, ctmp2) == 1);\n-    CHECK(memcmp(&pubkey, &pubkey2, sizeof(pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, &pubkey2, sizeof(pubkey)) == 0);\n     /* Tweak mul * 2 = 1+1. */\n     CHECK(secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, ctmp2) == 1);\n     ctmp2[31] = 2;\n     CHECK(secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey2, ctmp2) == 1);\n-    CHECK(memcmp(&pubkey, &pubkey2, sizeof(pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, &pubkey2, sizeof(pubkey)) == 0);\n     /* Test argument errors. */\n     ecount = 0;\n     secp256k1_context_set_illegal_callback(ctx, counting_illegal_callback_fn, &ecount);\n@@ -4131,12 +4215,12 @@ void run_eckey_edge_case_test(void) {\n     memset(&pubkey, 0, 32);\n     CHECK(secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, ctmp2) == 0);\n     CHECK(ecount == 1);\n-    CHECK(memcmp(&pubkey, zeros, sizeof(pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(pubkey)) == 0);\n     memcpy(&pubkey, &pubkey2, sizeof(pubkey));\n     memset(&pubkey2, 0, 32);\n     CHECK(secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey2, ctmp2) == 0);\n     CHECK(ecount == 2);\n-    CHECK(memcmp(&pubkey2, zeros, sizeof(pubkey2)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey2, zeros, sizeof(pubkey2)) == 0);\n     /* Plain argument errors. */\n     ecount = 0;\n     CHECK(secp256k1_ec_seckey_verify(ctx, ctmp) == 1);\n@@ -4176,7 +4260,7 @@ void run_eckey_edge_case_test(void) {\n     memset(&pubkey, 1, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey, NULL) == 0);\n     CHECK(ecount == 2);\n-    CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n     /* secp256k1_ec_pubkey_combine tests. */\n     ecount = 0;\n     pubkeys[0] = &pubkey_one;\n@@ -4187,56 +4271,56 @@ void run_eckey_edge_case_test(void) {\n     VG_UNDEF(&pubkey, sizeof(secp256k1_pubkey));\n     CHECK(secp256k1_ec_pubkey_combine(ctx, &pubkey, pubkeys, 0) == 0);\n     VG_CHECK(&pubkey, sizeof(secp256k1_pubkey));\n-    CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n     CHECK(ecount == 1);\n     CHECK(secp256k1_ec_pubkey_combine(ctx, NULL, pubkeys, 1) == 0);\n-    CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n     CHECK(ecount == 2);\n     memset(&pubkey, 255, sizeof(secp256k1_pubkey));\n     VG_UNDEF(&pubkey, sizeof(secp256k1_pubkey));\n     CHECK(secp256k1_ec_pubkey_combine(ctx, &pubkey, NULL, 1) == 0);\n     VG_CHECK(&pubkey, sizeof(secp256k1_pubkey));\n-    CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n     CHECK(ecount == 3);\n     pubkeys[0] = &pubkey_negone;\n     memset(&pubkey, 255, sizeof(secp256k1_pubkey));\n     VG_UNDEF(&pubkey, sizeof(secp256k1_pubkey));\n     CHECK(secp256k1_ec_pubkey_combine(ctx, &pubkey, pubkeys, 1) == 1);\n     VG_CHECK(&pubkey, sizeof(secp256k1_pubkey));\n-    CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) > 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(secp256k1_pubkey)) > 0);\n     CHECK(ecount == 3);\n     len = 33;\n     CHECK(secp256k1_ec_pubkey_serialize(ctx, ctmp, &len, &pubkey, SECP256K1_EC_COMPRESSED) == 1);\n     CHECK(secp256k1_ec_pubkey_serialize(ctx, ctmp2, &len, &pubkey_negone, SECP256K1_EC_COMPRESSED) == 1);\n-    CHECK(memcmp(ctmp, ctmp2, 33) == 0);\n+    CHECK(secp256k1_memcmp_var(ctmp, ctmp2, 33) == 0);\n     /* Result is infinity. */\n     pubkeys[0] = &pubkey_one;\n     pubkeys[1] = &pubkey_negone;\n     memset(&pubkey, 255, sizeof(secp256k1_pubkey));\n     VG_UNDEF(&pubkey, sizeof(secp256k1_pubkey));\n     CHECK(secp256k1_ec_pubkey_combine(ctx, &pubkey, pubkeys, 2) == 0);\n     VG_CHECK(&pubkey, sizeof(secp256k1_pubkey));\n-    CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(secp256k1_pubkey)) == 0);\n     CHECK(ecount == 3);\n     /* Passes through infinity but comes out one. */\n     pubkeys[2] = &pubkey_one;\n     memset(&pubkey, 255, sizeof(secp256k1_pubkey));\n     VG_UNDEF(&pubkey, sizeof(secp256k1_pubkey));\n     CHECK(secp256k1_ec_pubkey_combine(ctx, &pubkey, pubkeys, 3) == 1);\n     VG_CHECK(&pubkey, sizeof(secp256k1_pubkey));\n-    CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) > 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(secp256k1_pubkey)) > 0);\n     CHECK(ecount == 3);\n     len = 33;\n     CHECK(secp256k1_ec_pubkey_serialize(ctx, ctmp, &len, &pubkey, SECP256K1_EC_COMPRESSED) == 1);\n     CHECK(secp256k1_ec_pubkey_serialize(ctx, ctmp2, &len, &pubkey_one, SECP256K1_EC_COMPRESSED) == 1);\n-    CHECK(memcmp(ctmp, ctmp2, 33) == 0);\n+    CHECK(secp256k1_memcmp_var(ctmp, ctmp2, 33) == 0);\n     /* Adds to two. */\n     pubkeys[1] = &pubkey_one;\n     memset(&pubkey, 255, sizeof(secp256k1_pubkey));\n     VG_UNDEF(&pubkey, sizeof(secp256k1_pubkey));\n     CHECK(secp256k1_ec_pubkey_combine(ctx, &pubkey, pubkeys, 2) == 1);\n     VG_CHECK(&pubkey, sizeof(secp256k1_pubkey));\n-    CHECK(memcmp(&pubkey, zeros, sizeof(secp256k1_pubkey)) > 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey, zeros, sizeof(secp256k1_pubkey)) > 0);\n     CHECK(ecount == 3);\n     secp256k1_context_set_illegal_callback(ctx, NULL, NULL);\n }\n@@ -4250,21 +4334,21 @@ void run_eckey_negate_test(void) {\n \n     /* Verify negation changes the key and changes it back */\n     CHECK(secp256k1_ec_seckey_negate(ctx, seckey) == 1);\n-    CHECK(memcmp(seckey, seckey_tmp, 32) != 0);\n+    CHECK(secp256k1_memcmp_var(seckey, seckey_tmp, 32) != 0);\n     CHECK(secp256k1_ec_seckey_negate(ctx, seckey) == 1);\n-    CHECK(memcmp(seckey, seckey_tmp, 32) == 0);\n+    CHECK(secp256k1_memcmp_var(seckey, seckey_tmp, 32) == 0);\n \n     /* Check that privkey alias gives same result */\n     CHECK(secp256k1_ec_seckey_negate(ctx, seckey) == 1);\n     CHECK(secp256k1_ec_privkey_negate(ctx, seckey_tmp) == 1);\n-    CHECK(memcmp(seckey, seckey_tmp, 32) == 0);\n+    CHECK(secp256k1_memcmp_var(seckey, seckey_tmp, 32) == 0);\n \n     /* Negating all 0s fails */\n     memset(seckey, 0, 32);\n     memset(seckey_tmp, 0, 32);\n     CHECK(secp256k1_ec_seckey_negate(ctx, seckey) == 0);\n     /* Check that seckey is not modified */\n-    CHECK(memcmp(seckey, seckey_tmp, 32) == 0);\n+    CHECK(secp256k1_memcmp_var(seckey, seckey_tmp, 32) == 0);\n \n     /* Negating an overflowing seckey fails and the seckey is zeroed. In this\n      * test, the seckey has 16 random bytes to ensure that ec_seckey_negate\n@@ -4273,7 +4357,7 @@ void run_eckey_negate_test(void) {\n     memset(seckey, 0xFF, 16);\n     memset(seckey_tmp, 0, 32);\n     CHECK(secp256k1_ec_seckey_negate(ctx, seckey) == 0);\n-    CHECK(memcmp(seckey, seckey_tmp, 32) == 0);\n+    CHECK(secp256k1_memcmp_var(seckey, seckey_tmp, 32) == 0);\n }\n \n void random_sign(secp256k1_scalar *sigr, secp256k1_scalar *sigs, const secp256k1_scalar *key, const secp256k1_scalar *msg, int *recid) {\n@@ -4295,7 +4379,7 @@ void test_ecdsa_sign_verify(void) {\n     random_scalar_order_test(&key);\n     secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pubj, &key);\n     secp256k1_ge_set_gej(&pub, &pubj);\n-    getrec = secp256k1_rand_bits(1);\n+    getrec = secp256k1_testrand_bits(1);\n     random_sign(&sigr, &sigs, &key, &msg, getrec?&recid:NULL);\n     if (getrec) {\n         CHECK(recid >= 0 && recid < 4);\n@@ -4362,7 +4446,7 @@ static int nonce_function_test_retry(unsigned char *nonce32, const unsigned char\n \n int is_empty_signature(const secp256k1_ecdsa_signature *sig) {\n     static const unsigned char res[sizeof(secp256k1_ecdsa_signature)] = {0};\n-    return memcmp(sig, res, sizeof(secp256k1_ecdsa_signature)) == 0;\n+    return secp256k1_memcmp_var(sig, res, sizeof(secp256k1_ecdsa_signature)) == 0;\n }\n \n void test_ecdsa_end_to_end(void) {\n@@ -4395,31 +4479,31 @@ void test_ecdsa_end_to_end(void) {\n     CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey, privkey) == 1);\n \n     /* Verify exporting and importing public key. */\n-    CHECK(secp256k1_ec_pubkey_serialize(ctx, pubkeyc, &pubkeyclen, &pubkey, secp256k1_rand_bits(1) == 1 ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED));\n+    CHECK(secp256k1_ec_pubkey_serialize(ctx, pubkeyc, &pubkeyclen, &pubkey, secp256k1_testrand_bits(1) == 1 ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED));\n     memset(&pubkey, 0, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, pubkeyc, pubkeyclen) == 1);\n \n     /* Verify negation changes the key and changes it back */\n     memcpy(&pubkey_tmp, &pubkey, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_negate(ctx, &pubkey_tmp) == 1);\n-    CHECK(memcmp(&pubkey_tmp, &pubkey, sizeof(pubkey)) != 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey_tmp, &pubkey, sizeof(pubkey)) != 0);\n     CHECK(secp256k1_ec_pubkey_negate(ctx, &pubkey_tmp) == 1);\n-    CHECK(memcmp(&pubkey_tmp, &pubkey, sizeof(pubkey)) == 0);\n+    CHECK(secp256k1_memcmp_var(&pubkey_tmp, &pubkey, sizeof(pubkey)) == 0);\n \n     /* Verify private key import and export. */\n-    CHECK(ec_privkey_export_der(ctx, seckey, &seckeylen, privkey, secp256k1_rand_bits(1) == 1));\n+    CHECK(ec_privkey_export_der(ctx, seckey, &seckeylen, privkey, secp256k1_testrand_bits(1) == 1));\n     CHECK(ec_privkey_import_der(ctx, privkey2, seckey, seckeylen) == 1);\n-    CHECK(memcmp(privkey, privkey2, 32) == 0);\n+    CHECK(secp256k1_memcmp_var(privkey, privkey2, 32) == 0);\n \n     /* Optionally tweak the keys using addition. */\n-    if (secp256k1_rand_int(3) == 0) {\n+    if (secp256k1_testrand_int(3) == 0) {\n         int ret1;\n         int ret2;\n         int ret3;\n         unsigned char rnd[32];\n         unsigned char privkey_tmp[32];\n         secp256k1_pubkey pubkey2;\n-        secp256k1_rand256_test(rnd);\n+        secp256k1_testrand256_test(rnd);\n         memcpy(privkey_tmp, privkey, 32);\n         ret1 = secp256k1_ec_seckey_tweak_add(ctx, privkey, rnd);\n         ret2 = secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, rnd);\n@@ -4430,20 +4514,20 @@ void test_ecdsa_end_to_end(void) {\n         if (ret1 == 0) {\n             return;\n         }\n-        CHECK(memcmp(privkey, privkey_tmp, 32) == 0);\n+        CHECK(secp256k1_memcmp_var(privkey, privkey_tmp, 32) == 0);\n         CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey2, privkey) == 1);\n-        CHECK(memcmp(&pubkey, &pubkey2, sizeof(pubkey)) == 0);\n+        CHECK(secp256k1_memcmp_var(&pubkey, &pubkey2, sizeof(pubkey)) == 0);\n     }\n \n     /* Optionally tweak the keys using multiplication. */\n-    if (secp256k1_rand_int(3) == 0) {\n+    if (secp256k1_testrand_int(3) == 0) {\n         int ret1;\n         int ret2;\n         int ret3;\n         unsigned char rnd[32];\n         unsigned char privkey_tmp[32];\n         secp256k1_pubkey pubkey2;\n-        secp256k1_rand256_test(rnd);\n+        secp256k1_testrand256_test(rnd);\n         memcpy(privkey_tmp, privkey, 32);\n         ret1 = secp256k1_ec_seckey_tweak_mul(ctx, privkey, rnd);\n         ret2 = secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, rnd);\n@@ -4454,9 +4538,9 @@ void test_ecdsa_end_to_end(void) {\n         if (ret1 == 0) {\n             return;\n         }\n-        CHECK(memcmp(privkey, privkey_tmp, 32) == 0);\n+        CHECK(secp256k1_memcmp_var(privkey, privkey_tmp, 32) == 0);\n         CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey2, privkey) == 1);\n-        CHECK(memcmp(&pubkey, &pubkey2, sizeof(pubkey)) == 0);\n+        CHECK(secp256k1_memcmp_var(&pubkey, &pubkey2, sizeof(pubkey)) == 0);\n     }\n \n     /* Sign. */\n@@ -4468,13 +4552,13 @@ void test_ecdsa_end_to_end(void) {\n     extra[31] = 0;\n     extra[0] = 1;\n     CHECK(secp256k1_ecdsa_sign(ctx, &signature[3], message, privkey, NULL, extra) == 1);\n-    CHECK(memcmp(&signature[0], &signature[4], sizeof(signature[0])) == 0);\n-    CHECK(memcmp(&signature[0], &signature[1], sizeof(signature[0])) != 0);\n-    CHECK(memcmp(&signature[0], &signature[2], sizeof(signature[0])) != 0);\n-    CHECK(memcmp(&signature[0], &signature[3], sizeof(signature[0])) != 0);\n-    CHECK(memcmp(&signature[1], &signature[2], sizeof(signature[0])) != 0);\n-    CHECK(memcmp(&signature[1], &signature[3], sizeof(signature[0])) != 0);\n-    CHECK(memcmp(&signature[2], &signature[3], sizeof(signature[0])) != 0);\n+    CHECK(secp256k1_memcmp_var(&signature[0], &signature[4], sizeof(signature[0])) == 0);\n+    CHECK(secp256k1_memcmp_var(&signature[0], &signature[1], sizeof(signature[0])) != 0);\n+    CHECK(secp256k1_memcmp_var(&signature[0], &signature[2], sizeof(signature[0])) != 0);\n+    CHECK(secp256k1_memcmp_var(&signature[0], &signature[3], sizeof(signature[0])) != 0);\n+    CHECK(secp256k1_memcmp_var(&signature[1], &signature[2], sizeof(signature[0])) != 0);\n+    CHECK(secp256k1_memcmp_var(&signature[1], &signature[3], sizeof(signature[0])) != 0);\n+    CHECK(secp256k1_memcmp_var(&signature[2], &signature[3], sizeof(signature[0])) != 0);\n     /* Verify. */\n     CHECK(secp256k1_ecdsa_verify(ctx, &signature[0], message, &pubkey) == 1);\n     CHECK(secp256k1_ecdsa_verify(ctx, &signature[1], message, &pubkey) == 1);\n@@ -4495,7 +4579,7 @@ void test_ecdsa_end_to_end(void) {\n     secp256k1_ecdsa_signature_save(&signature[5], &r, &s);\n     CHECK(!secp256k1_ecdsa_signature_normalize(ctx, NULL, &signature[5]));\n     CHECK(secp256k1_ecdsa_verify(ctx, &signature[5], message, &pubkey) == 1);\n-    CHECK(memcmp(&signature[5], &signature[0], 64) == 0);\n+    CHECK(secp256k1_memcmp_var(&signature[5], &signature[0], 64) == 0);\n \n     /* Serialize/parse DER and verify again */\n     CHECK(secp256k1_ecdsa_signature_serialize_der(ctx, sig, &siglen, &signature[0]) == 1);\n@@ -4505,7 +4589,7 @@ void test_ecdsa_end_to_end(void) {\n     /* Serialize/destroy/parse DER and verify again. */\n     siglen = 74;\n     CHECK(secp256k1_ecdsa_signature_serialize_der(ctx, sig, &siglen, &signature[0]) == 1);\n-    sig[secp256k1_rand_int(siglen)] += 1 + secp256k1_rand_int(255);\n+    sig[secp256k1_testrand_int(siglen)] += 1 + secp256k1_testrand_int(255);\n     CHECK(secp256k1_ecdsa_signature_parse_der(ctx, &signature[0], sig, siglen) == 0 ||\n           secp256k1_ecdsa_verify(ctx, &signature[0], message, &pubkey) == 0);\n }\n@@ -4515,23 +4599,23 @@ void test_random_pubkeys(void) {\n     secp256k1_ge elem2;\n     unsigned char in[65];\n     /* Generate some randomly sized pubkeys. */\n-    size_t len = secp256k1_rand_bits(2) == 0 ? 65 : 33;\n-    if (secp256k1_rand_bits(2) == 0) {\n-        len = secp256k1_rand_bits(6);\n+    size_t len = secp256k1_testrand_bits(2) == 0 ? 65 : 33;\n+    if (secp256k1_testrand_bits(2) == 0) {\n+        len = secp256k1_testrand_bits(6);\n     }\n     if (len == 65) {\n-      in[0] = secp256k1_rand_bits(1) ? 4 : (secp256k1_rand_bits(1) ? 6 : 7);\n+      in[0] = secp256k1_testrand_bits(1) ? 4 : (secp256k1_testrand_bits(1) ? 6 : 7);\n     } else {\n-      in[0] = secp256k1_rand_bits(1) ? 2 : 3;\n+      in[0] = secp256k1_testrand_bits(1) ? 2 : 3;\n     }\n-    if (secp256k1_rand_bits(3) == 0) {\n-        in[0] = secp256k1_rand_bits(8);\n+    if (secp256k1_testrand_bits(3) == 0) {\n+        in[0] = secp256k1_testrand_bits(8);\n     }\n     if (len > 1) {\n-        secp256k1_rand256(&in[1]);\n+        secp256k1_testrand256(&in[1]);\n     }\n     if (len > 33) {\n-        secp256k1_rand256(&in[33]);\n+        secp256k1_testrand256(&in[33]);\n     }\n     if (secp256k1_eckey_pubkey_parse(&elem, in, len)) {\n         unsigned char out[65];\n@@ -4542,7 +4626,7 @@ void test_random_pubkeys(void) {\n         /* If the pubkey can be parsed, it should round-trip... */\n         CHECK(secp256k1_eckey_pubkey_serialize(&elem, out, &size, len == 33));\n         CHECK(size == len);\n-        CHECK(memcmp(&in[1], &out[1], len-1) == 0);\n+        CHECK(secp256k1_memcmp_var(&in[1], &out[1], len-1) == 0);\n         /* ... except for the type of hybrid inputs. */\n         if ((in[0] != 6) && (in[0] != 7)) {\n             CHECK(in[0] == out[0]);\n@@ -4553,7 +4637,7 @@ void test_random_pubkeys(void) {\n         CHECK(secp256k1_eckey_pubkey_parse(&elem2, in, size));\n         ge_equals_ge(&elem,&elem2);\n         /* Check that the X9.62 hybrid type is checked. */\n-        in[0] = secp256k1_rand_bits(1) ? 6 : 7;\n+        in[0] = secp256k1_testrand_bits(1) ? 6 : 7;\n         res = secp256k1_eckey_pubkey_parse(&elem2, in, size);\n         if (firstb == 2 || firstb == 3) {\n             if (in[0] == firstb + 4) {\n@@ -4565,7 +4649,7 @@ void test_random_pubkeys(void) {\n         if (res) {\n             ge_equals_ge(&elem,&elem2);\n             CHECK(secp256k1_eckey_pubkey_serialize(&elem, out, &size, 0));\n-            CHECK(memcmp(&in[1], &out[1], 64) == 0);\n+            CHECK(secp256k1_memcmp_var(&in[1], &out[1], 64) == 0);\n         }\n     }\n }\n@@ -4621,21 +4705,21 @@ int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_\n     parsed_der = secp256k1_ecdsa_signature_parse_der(ctx, &sig_der, sig, siglen);\n     if (parsed_der) {\n         ret |= (!secp256k1_ecdsa_signature_serialize_compact(ctx, compact_der, &sig_der)) << 0;\n-        valid_der = (memcmp(compact_der, zeroes, 32) != 0) && (memcmp(compact_der + 32, zeroes, 32) != 0);\n+        valid_der = (secp256k1_memcmp_var(compact_der, zeroes, 32) != 0) && (secp256k1_memcmp_var(compact_der + 32, zeroes, 32) != 0);\n     }\n     if (valid_der) {\n         ret |= (!secp256k1_ecdsa_signature_serialize_der(ctx, roundtrip_der, &len_der, &sig_der)) << 1;\n-        roundtrips_der = (len_der == siglen) && memcmp(roundtrip_der, sig, siglen) == 0;\n+        roundtrips_der = (len_der == siglen) && secp256k1_memcmp_var(roundtrip_der, sig, siglen) == 0;\n     }\n \n     parsed_der_lax = ecdsa_signature_parse_der_lax(ctx, &sig_der_lax, sig, siglen);\n     if (parsed_der_lax) {\n         ret |= (!secp256k1_ecdsa_signature_serialize_compact(ctx, compact_der_lax, &sig_der_lax)) << 10;\n-        valid_der_lax = (memcmp(compact_der_lax, zeroes, 32) != 0) && (memcmp(compact_der_lax + 32, zeroes, 32) != 0);\n+        valid_der_lax = (secp256k1_memcmp_var(compact_der_lax, zeroes, 32) != 0) && (secp256k1_memcmp_var(compact_der_lax + 32, zeroes, 32) != 0);\n     }\n     if (valid_der_lax) {\n         ret |= (!secp256k1_ecdsa_signature_serialize_der(ctx, roundtrip_der_lax, &len_der_lax, &sig_der_lax)) << 11;\n-        roundtrips_der_lax = (len_der_lax == siglen) && memcmp(roundtrip_der_lax, sig, siglen) == 0;\n+        roundtrips_der_lax = (len_der_lax == siglen) && secp256k1_memcmp_var(roundtrip_der_lax, sig, siglen) == 0;\n     }\n \n     if (certainly_der) {\n@@ -4651,7 +4735,7 @@ int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_\n     if (valid_der) {\n         ret |= (!roundtrips_der_lax) << 12;\n         ret |= (len_der != len_der_lax) << 13;\n-        ret |= ((len_der != len_der_lax) || (memcmp(roundtrip_der_lax, roundtrip_der, len_der) != 0)) << 14;\n+        ret |= ((len_der != len_der_lax) || (secp256k1_memcmp_var(roundtrip_der_lax, roundtrip_der, len_der) != 0)) << 14;\n     }\n     ret |= (roundtrips_der != roundtrips_der_lax) << 15;\n     if (parsed_der) {\n@@ -4668,19 +4752,19 @@ int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_\n         if (valid_openssl) {\n             unsigned char tmp[32] = {0};\n             BN_bn2bin(r, tmp + 32 - BN_num_bytes(r));\n-            valid_openssl = memcmp(tmp, max_scalar, 32) < 0;\n+            valid_openssl = secp256k1_memcmp_var(tmp, max_scalar, 32) < 0;\n         }\n         if (valid_openssl) {\n             unsigned char tmp[32] = {0};\n             BN_bn2bin(s, tmp + 32 - BN_num_bytes(s));\n-            valid_openssl = memcmp(tmp, max_scalar, 32) < 0;\n+            valid_openssl = secp256k1_memcmp_var(tmp, max_scalar, 32) < 0;\n         }\n     }\n     len_openssl = i2d_ECDSA_SIG(sig_openssl, NULL);\n     if (len_openssl <= 2048) {\n         unsigned char *ptr = roundtrip_openssl;\n         CHECK(i2d_ECDSA_SIG(sig_openssl, &ptr) == len_openssl);\n-        roundtrips_openssl = valid_openssl && ((size_t)len_openssl == siglen) && (memcmp(roundtrip_openssl, sig, siglen) == 0);\n+        roundtrips_openssl = valid_openssl && ((size_t)len_openssl == siglen) && (secp256k1_memcmp_var(roundtrip_openssl, sig, siglen) == 0);\n     } else {\n         len_openssl = 0;\n     }\n@@ -4692,7 +4776,7 @@ int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_\n     ret |= (roundtrips_der != roundtrips_openssl) << 7;\n     if (roundtrips_openssl) {\n         ret |= (len_der != (size_t)len_openssl) << 8;\n-        ret |= ((len_der != (size_t)len_openssl) || (memcmp(roundtrip_der, roundtrip_openssl, len_der) != 0)) << 9;\n+        ret |= ((len_der != (size_t)len_openssl) || (secp256k1_memcmp_var(roundtrip_der, roundtrip_openssl, len_der) != 0)) << 9;\n     }\n #endif\n     return ret;\n@@ -4712,27 +4796,27 @@ static void assign_big_endian(unsigned char *ptr, size_t ptrlen, uint32_t val) {\n \n static void damage_array(unsigned char *sig, size_t *len) {\n     int pos;\n-    int action = secp256k1_rand_bits(3);\n+    int action = secp256k1_testrand_bits(3);\n     if (action < 1 && *len > 3) {\n         /* Delete a byte. */\n-        pos = secp256k1_rand_int(*len);\n+        pos = secp256k1_testrand_int(*len);\n         memmove(sig + pos, sig + pos + 1, *len - pos - 1);\n         (*len)--;\n         return;\n     } else if (action < 2 && *len < 2048) {\n         /* Insert a byte. */\n-        pos = secp256k1_rand_int(1 + *len);\n+        pos = secp256k1_testrand_int(1 + *len);\n         memmove(sig + pos + 1, sig + pos, *len - pos);\n-        sig[pos] = secp256k1_rand_bits(8);\n+        sig[pos] = secp256k1_testrand_bits(8);\n         (*len)++;\n         return;\n     } else if (action < 4) {\n         /* Modify a byte. */\n-        sig[secp256k1_rand_int(*len)] += 1 + secp256k1_rand_int(255);\n+        sig[secp256k1_testrand_int(*len)] += 1 + secp256k1_testrand_int(255);\n         return;\n     } else { /* action < 8 */\n         /* Modify a bit. */\n-        sig[secp256k1_rand_int(*len)] ^= 1 << secp256k1_rand_bits(3);\n+        sig[secp256k1_testrand_int(*len)] ^= 1 << secp256k1_testrand_bits(3);\n         return;\n     }\n }\n@@ -4745,23 +4829,23 @@ static void random_ber_signature(unsigned char *sig, size_t *len, int* certainly\n     int n;\n \n     *len = 0;\n-    der = secp256k1_rand_bits(2) == 0;\n+    der = secp256k1_testrand_bits(2) == 0;\n     *certainly_der = der;\n     *certainly_not_der = 0;\n-    indet = der ? 0 : secp256k1_rand_int(10) == 0;\n+    indet = der ? 0 : secp256k1_testrand_int(10) == 0;\n \n     for (n = 0; n < 2; n++) {\n         /* We generate two classes of numbers: nlow==1 \"low\" ones (up to 32 bytes), nlow==0 \"high\" ones (32 bytes with 129 top bits set, or larger than 32 bytes) */\n-        nlow[n] = der ? 1 : (secp256k1_rand_bits(3) != 0);\n+        nlow[n] = der ? 1 : (secp256k1_testrand_bits(3) != 0);\n         /* The length of the number in bytes (the first byte of which will always be nonzero) */\n-        nlen[n] = nlow[n] ? secp256k1_rand_int(33) : 32 + secp256k1_rand_int(200) * secp256k1_rand_int(8) / 8;\n+        nlen[n] = nlow[n] ? secp256k1_testrand_int(33) : 32 + secp256k1_testrand_int(200) * secp256k1_testrand_int(8) / 8;\n         CHECK(nlen[n] <= 232);\n         /* The top bit of the number. */\n-        nhbit[n] = (nlow[n] == 0 && nlen[n] == 32) ? 1 : (nlen[n] == 0 ? 0 : secp256k1_rand_bits(1));\n+        nhbit[n] = (nlow[n] == 0 && nlen[n] == 32) ? 1 : (nlen[n] == 0 ? 0 : secp256k1_testrand_bits(1));\n         /* The top byte of the number (after the potential hardcoded 16 0xFF characters for \"high\" 32 bytes numbers) */\n-        nhbyte[n] = nlen[n] == 0 ? 0 : (nhbit[n] ? 128 + secp256k1_rand_bits(7) : 1 + secp256k1_rand_int(127));\n+        nhbyte[n] = nlen[n] == 0 ? 0 : (nhbit[n] ? 128 + secp256k1_testrand_bits(7) : 1 + secp256k1_testrand_int(127));\n         /* The number of zero bytes in front of the number (which is 0 or 1 in case of DER, otherwise we extend up to 300 bytes) */\n-        nzlen[n] = der ? ((nlen[n] == 0 || nhbit[n]) ? 1 : 0) : (nlow[n] ? secp256k1_rand_int(3) : secp256k1_rand_int(300 - nlen[n]) * secp256k1_rand_int(8) / 8);\n+        nzlen[n] = der ? ((nlen[n] == 0 || nhbit[n]) ? 1 : 0) : (nlow[n] ? secp256k1_testrand_int(3) : secp256k1_testrand_int(300 - nlen[n]) * secp256k1_testrand_int(8) / 8);\n         if (nzlen[n] > ((nlen[n] == 0 || nhbit[n]) ? 1 : 0)) {\n             *certainly_not_der = 1;\n         }\n@@ -4770,7 +4854,7 @@ static void random_ber_signature(unsigned char *sig, size_t *len, int* certainly\n         nlenlen[n] = nlen[n] + nzlen[n] < 128 ? 0 : (nlen[n] + nzlen[n] < 256 ? 1 : 2);\n         if (!der) {\n             /* nlenlen[n] max 127 bytes */\n-            int add = secp256k1_rand_int(127 - nlenlen[n]) * secp256k1_rand_int(16) * secp256k1_rand_int(16) / 256;\n+            int add = secp256k1_testrand_int(127 - nlenlen[n]) * secp256k1_testrand_int(16) * secp256k1_testrand_int(16) / 256;\n             nlenlen[n] += add;\n             if (add != 0) {\n                 *certainly_not_der = 1;\n@@ -4784,15 +4868,15 @@ static void random_ber_signature(unsigned char *sig, size_t *len, int* certainly\n     CHECK(tlen <= 856);\n \n     /* The length of the garbage inside the tuple. */\n-    elen = (der || indet) ? 0 : secp256k1_rand_int(980 - tlen) * secp256k1_rand_int(8) / 8;\n+    elen = (der || indet) ? 0 : secp256k1_testrand_int(980 - tlen) * secp256k1_testrand_int(8) / 8;\n     if (elen != 0) {\n         *certainly_not_der = 1;\n     }\n     tlen += elen;\n     CHECK(tlen <= 980);\n \n     /* The length of the garbage after the end of the tuple. */\n-    glen = der ? 0 : secp256k1_rand_int(990 - tlen) * secp256k1_rand_int(8) / 8;\n+    glen = der ? 0 : secp256k1_testrand_int(990 - tlen) * secp256k1_testrand_int(8) / 8;\n     if (glen != 0) {\n         *certainly_not_der = 1;\n     }\n@@ -4807,7 +4891,7 @@ static void random_ber_signature(unsigned char *sig, size_t *len, int* certainly\n     } else {\n         int tlenlen = tlen < 128 ? 0 : (tlen < 256 ? 1 : 2);\n         if (!der) {\n-            int add = secp256k1_rand_int(127 - tlenlen) * secp256k1_rand_int(16) * secp256k1_rand_int(16) / 256;\n+            int add = secp256k1_testrand_int(127 - tlenlen) * secp256k1_testrand_int(16) * secp256k1_testrand_int(16) / 256;\n             tlenlen += add;\n             if (add != 0) {\n                 *certainly_not_der = 1;\n@@ -4858,13 +4942,13 @@ static void random_ber_signature(unsigned char *sig, size_t *len, int* certainly\n             nlen[n]--;\n         }\n         /* Generate remaining random bytes of number */\n-        secp256k1_rand_bytes_test(sig + *len, nlen[n]);\n+        secp256k1_testrand_bytes_test(sig + *len, nlen[n]);\n         *len += nlen[n];\n         nlen[n] = 0;\n     }\n \n     /* Generate random garbage inside tuple. */\n-    secp256k1_rand_bytes_test(sig + *len, elen);\n+    secp256k1_testrand_bytes_test(sig + *len, elen);\n     *len += elen;\n \n     /* Generate end-of-contents bytes. */\n@@ -4876,7 +4960,7 @@ static void random_ber_signature(unsigned char *sig, size_t *len, int* certainly\n     CHECK(tlen + glen <= 1121);\n \n     /* Generate random garbage outside tuple. */\n-    secp256k1_rand_bytes_test(sig + *len, glen);\n+    secp256k1_testrand_bytes_test(sig + *len, glen);\n     *len += glen;\n     tlen += glen;\n     CHECK(tlen <= 1121);\n@@ -5208,11 +5292,11 @@ void test_ecdsa_edge_cases(void) {\n         CHECK(!is_empty_signature(&sig));\n         CHECK(secp256k1_ecdsa_sign(ctx, &sig2, msg, key, nonce_function_rfc6979, extra) == 1);\n         CHECK(!is_empty_signature(&sig2));\n-        CHECK(memcmp(&sig, &sig2, sizeof(sig)) == 0);\n+        CHECK(secp256k1_memcmp_var(&sig, &sig2, sizeof(sig)) == 0);\n         /* The default nonce function is deterministic. */\n         CHECK(secp256k1_ecdsa_sign(ctx, &sig2, msg, key, NULL, extra) == 1);\n         CHECK(!is_empty_signature(&sig2));\n-        CHECK(memcmp(&sig, &sig2, sizeof(sig)) == 0);\n+        CHECK(secp256k1_memcmp_var(&sig, &sig2, sizeof(sig)) == 0);\n         /* The default nonce function changes output with different messages. */\n         for(i = 0; i < 256; i++) {\n             int j;\n@@ -5259,12 +5343,12 @@ void test_ecdsa_edge_cases(void) {\n         VG_CHECK(nonce3,32);\n         CHECK(nonce_function_rfc6979(nonce4, zeros, zeros, zeros, (void *)zeros, 0) == 1);\n         VG_CHECK(nonce4,32);\n-        CHECK(memcmp(nonce, nonce2, 32) != 0);\n-        CHECK(memcmp(nonce, nonce3, 32) != 0);\n-        CHECK(memcmp(nonce, nonce4, 32) != 0);\n-        CHECK(memcmp(nonce2, nonce3, 32) != 0);\n-        CHECK(memcmp(nonce2, nonce4, 32) != 0);\n-        CHECK(memcmp(nonce3, nonce4, 32) != 0);\n+        CHECK(secp256k1_memcmp_var(nonce, nonce2, 32) != 0);\n+        CHECK(secp256k1_memcmp_var(nonce, nonce3, 32) != 0);\n+        CHECK(secp256k1_memcmp_var(nonce, nonce4, 32) != 0);\n+        CHECK(secp256k1_memcmp_var(nonce2, nonce3, 32) != 0);\n+        CHECK(secp256k1_memcmp_var(nonce2, nonce4, 32) != 0);\n+        CHECK(secp256k1_memcmp_var(nonce3, nonce4, 32) != 0);\n     }\n \n \n@@ -5293,7 +5377,7 @@ EC_KEY *get_openssl_key(const unsigned char *key32) {\n     unsigned char privkey[300];\n     size_t privkeylen;\n     const unsigned char* pbegin = privkey;\n-    int compr = secp256k1_rand_bits(1);\n+    int compr = secp256k1_testrand_bits(1);\n     EC_KEY *ec_key = EC_KEY_new_by_curve_name(NID_secp256k1);\n     CHECK(ec_privkey_export_der(ctx, privkey, &privkeylen, key32, compr));\n     CHECK(d2i_ECPrivateKey(&ec_key, &pbegin, privkeylen));\n@@ -5314,7 +5398,7 @@ void test_ecdsa_openssl(void) {\n     unsigned char message[32];\n     unsigned char signature[80];\n     unsigned char key32[32];\n-    secp256k1_rand256_test(message);\n+    secp256k1_testrand256_test(message);\n     secp256k1_scalar_set_b32(&msg, message, NULL);\n     random_scalar_order_test(&key);\n     secp256k1_scalar_get_b32(key32, &key);\n@@ -5367,12 +5451,12 @@ void run_memczero_test(void) {\n     /* memczero(..., ..., 0) is a noop. */\n     memcpy(buf2, buf1, sizeof(buf1));\n     memczero(buf1, sizeof(buf1), 0);\n-    CHECK(memcmp(buf1, buf2, sizeof(buf1)) == 0);\n+    CHECK(secp256k1_memcmp_var(buf1, buf2, sizeof(buf1)) == 0);\n \n     /* memczero(..., ..., 1) zeros the buffer. */\n     memset(buf2, 0, sizeof(buf2));\n     memczero(buf1, sizeof(buf1) , 1);\n-    CHECK(memcmp(buf1, buf2, sizeof(buf1)) == 0);\n+    CHECK(secp256k1_memcmp_var(buf1, buf2, sizeof(buf1)) == 0);\n }\n \n void int_cmov_test(void) {\n@@ -5411,23 +5495,23 @@ void fe_cmov_test(void) {\n     secp256k1_fe a = zero;\n \n     secp256k1_fe_cmov(&r, &a, 0);\n-    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &max, sizeof(r)) == 0);\n \n     r = zero; a = max;\n     secp256k1_fe_cmov(&r, &a, 1);\n-    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &max, sizeof(r)) == 0);\n \n     a = zero;\n     secp256k1_fe_cmov(&r, &a, 1);\n-    CHECK(memcmp(&r, &zero, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &zero, sizeof(r)) == 0);\n \n     a = one;\n     secp256k1_fe_cmov(&r, &a, 1);\n-    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &one, sizeof(r)) == 0);\n \n     r = one; a = zero;\n     secp256k1_fe_cmov(&r, &a, 0);\n-    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &one, sizeof(r)) == 0);\n }\n \n void fe_storage_cmov_test(void) {\n@@ -5441,23 +5525,23 @@ void fe_storage_cmov_test(void) {\n     secp256k1_fe_storage a = zero;\n \n     secp256k1_fe_storage_cmov(&r, &a, 0);\n-    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &max, sizeof(r)) == 0);\n \n     r = zero; a = max;\n     secp256k1_fe_storage_cmov(&r, &a, 1);\n-    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &max, sizeof(r)) == 0);\n \n     a = zero;\n     secp256k1_fe_storage_cmov(&r, &a, 1);\n-    CHECK(memcmp(&r, &zero, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &zero, sizeof(r)) == 0);\n \n     a = one;\n     secp256k1_fe_storage_cmov(&r, &a, 1);\n-    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &one, sizeof(r)) == 0);\n \n     r = one; a = zero;\n     secp256k1_fe_storage_cmov(&r, &a, 0);\n-    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &one, sizeof(r)) == 0);\n }\n \n void scalar_cmov_test(void) {\n@@ -5471,23 +5555,23 @@ void scalar_cmov_test(void) {\n     secp256k1_scalar a = zero;\n \n     secp256k1_scalar_cmov(&r, &a, 0);\n-    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &max, sizeof(r)) == 0);\n \n     r = zero; a = max;\n     secp256k1_scalar_cmov(&r, &a, 1);\n-    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &max, sizeof(r)) == 0);\n \n     a = zero;\n     secp256k1_scalar_cmov(&r, &a, 1);\n-    CHECK(memcmp(&r, &zero, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &zero, sizeof(r)) == 0);\n \n     a = one;\n     secp256k1_scalar_cmov(&r, &a, 1);\n-    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &one, sizeof(r)) == 0);\n \n     r = one; a = zero;\n     secp256k1_scalar_cmov(&r, &a, 0);\n-    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &one, sizeof(r)) == 0);\n }\n \n void ge_storage_cmov_test(void) {\n@@ -5503,23 +5587,23 @@ void ge_storage_cmov_test(void) {\n     secp256k1_ge_storage a = zero;\n \n     secp256k1_ge_storage_cmov(&r, &a, 0);\n-    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &max, sizeof(r)) == 0);\n \n     r = zero; a = max;\n     secp256k1_ge_storage_cmov(&r, &a, 1);\n-    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &max, sizeof(r)) == 0);\n \n     a = zero;\n     secp256k1_ge_storage_cmov(&r, &a, 1);\n-    CHECK(memcmp(&r, &zero, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &zero, sizeof(r)) == 0);\n \n     a = one;\n     secp256k1_ge_storage_cmov(&r, &a, 1);\n-    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &one, sizeof(r)) == 0);\n \n     r = one; a = zero;\n     secp256k1_ge_storage_cmov(&r, &a, 0);\n-    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+    CHECK(secp256k1_memcmp_var(&r, &one, sizeof(r)) == 0);\n }\n \n void run_cmov_tests(void) {\n@@ -5531,9 +5615,6 @@ void run_cmov_tests(void) {\n }\n \n int main(int argc, char **argv) {\n-    unsigned char seed16[16] = {0};\n-    unsigned char run32[32] = {0};\n-\n     /* Disable buffering for stdout to improve reliability of getting\n      * diagnostic information. Happens right at the start of main because\n      * setbuf must be used before any other operation on the stream. */\n@@ -5546,52 +5627,20 @@ int main(int argc, char **argv) {\n     if (argc > 1) {\n         count = strtol(argv[1], NULL, 0);\n     }\n+    printf(\"test count = %i\\n\", count);\n \n     /* find random seed */\n-    if (argc > 2) {\n-        int pos = 0;\n-        const char* ch = argv[2];\n-        while (pos < 16 && ch[0] != 0 && ch[1] != 0) {\n-            unsigned short sh;\n-            if ((sscanf(ch, \"%2hx\", &sh)) == 1) {\n-                seed16[pos] = sh;\n-            } else {\n-                break;\n-            }\n-            ch += 2;\n-            pos++;\n-        }\n-    } else {\n-        FILE *frand = fopen(\"/dev/urandom\", \"r\");\n-        if ((frand == NULL) || fread(&seed16, 1, sizeof(seed16), frand) != sizeof(seed16)) {\n-            uint64_t t = time(NULL) * (uint64_t)1337;\n-            fprintf(stderr, \"WARNING: could not read 16 bytes from /dev/urandom; falling back to insecure PRNG\\n\");\n-            seed16[0] ^= t;\n-            seed16[1] ^= t >> 8;\n-            seed16[2] ^= t >> 16;\n-            seed16[3] ^= t >> 24;\n-            seed16[4] ^= t >> 32;\n-            seed16[5] ^= t >> 40;\n-            seed16[6] ^= t >> 48;\n-            seed16[7] ^= t >> 56;\n-        }\n-        if (frand) {\n-            fclose(frand);\n-        }\n-    }\n-    secp256k1_rand_seed(seed16);\n-\n-    printf(\"test count = %i\\n\", count);\n-    printf(\"random seed = %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\", seed16[0], seed16[1], seed16[2], seed16[3], seed16[4], seed16[5], seed16[6], seed16[7], seed16[8], seed16[9], seed16[10], seed16[11], seed16[12], seed16[13], seed16[14], seed16[15]);\n+    secp256k1_testrand_init(argc > 2 ? argv[2] : NULL);\n \n     /* initialize */\n     run_context_tests(0);\n     run_context_tests(1);\n     run_scratch_tests();\n     ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n-    if (secp256k1_rand_bits(1)) {\n-        secp256k1_rand256(run32);\n-        CHECK(secp256k1_context_randomize(ctx, secp256k1_rand_bits(1) ? run32 : NULL));\n+    if (secp256k1_testrand_bits(1)) {\n+        unsigned char rand32[32];\n+        secp256k1_testrand256(rand32);\n+        CHECK(secp256k1_context_randomize(ctx, secp256k1_testrand_bits(1) ? rand32 : NULL));\n     }\n \n     run_rand_bits();\n@@ -5625,6 +5674,7 @@ int main(int argc, char **argv) {\n     /* ecmult tests */\n     run_wnaf();\n     run_point_times_order();\n+    run_ecmult_near_split_bound();\n     run_ecmult_chain();\n     run_ecmult_constants();\n     run_ecmult_gen_blind();\n@@ -5633,9 +5683,7 @@ int main(int argc, char **argv) {\n     run_ec_combine();\n \n     /* endomorphism tests */\n-#ifdef USE_ENDOMORPHISM\n     run_endomorphism_tests();\n-#endif\n \n     /* EC point parser test */\n     run_ec_pubkey_parse_test();\n@@ -5679,8 +5727,7 @@ int main(int argc, char **argv) {\n \n     run_cmov_tests();\n \n-    secp256k1_rand256(run32);\n-    printf(\"random run = %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\", run32[0], run32[1], run32[2], run32[3], run32[4], run32[5], run32[6], run32[7], run32[8], run32[9], run32[10], run32[11], run32[12], run32[13], run32[14], run32[15]);\n+    secp256k1_testrand_finish();\n \n     /* shutdown */\n     secp256k1_context_destroy(ctx);"
      },
      {
        "sha": "f4d5b8e1765b47c046a53516cb5c72ed8fb6f8da",
        "filename": "src/secp256k1/src/tests_exhaustive.c",
        "status": "modified",
        "additions": 159,
        "deletions": 215,
        "changes": 374,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests_exhaustive.c?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -18,7 +18,6 @@\n #ifndef EXHAUSTIVE_TEST_ORDER\n /* see group_impl.h for allowable values */\n #define EXHAUSTIVE_TEST_ORDER 13\n-#define EXHAUSTIVE_TEST_LAMBDA 9   /* cube root of 1 mod 13 */\n #endif\n \n #include \"include/secp256k1.h\"\n@@ -27,10 +26,7 @@\n #include \"secp256k1.c\"\n #include \"testrand_impl.h\"\n \n-#ifdef ENABLE_MODULE_RECOVERY\n-#include \"src/modules/recovery/main_impl.h\"\n-#include \"include/secp256k1_recovery.h\"\n-#endif\n+static int count = 2;\n \n /** stolen from tests.c */\n void ge_equals_ge(const secp256k1_ge *a, const secp256k1_ge *b) {\n@@ -62,14 +58,23 @@ void ge_equals_gej(const secp256k1_ge *a, const secp256k1_gej *b) {\n void random_fe(secp256k1_fe *x) {\n     unsigned char bin[32];\n     do {\n-        secp256k1_rand256(bin);\n+        secp256k1_testrand256(bin);\n         if (secp256k1_fe_set_b32(x, bin)) {\n             return;\n         }\n     } while(1);\n }\n /** END stolen from tests.c */\n \n+static uint32_t num_cores = 1;\n+static uint32_t this_core = 0;\n+\n+SECP256K1_INLINE static int skip_section(uint64_t* iter) {\n+    if (num_cores == 1) return 0;\n+    *iter += 0xe7037ed1a0b428dbULL;\n+    return ((((uint32_t)*iter ^ (*iter >> 32)) * num_cores) >> 32) != this_core;\n+}\n+\n int secp256k1_nonce_function_smallint(unsigned char *nonce32, const unsigned char *msg32,\n                                       const unsigned char *key32, const unsigned char *algo16,\n                                       void *data, unsigned int attempt) {\n@@ -90,91 +95,93 @@ int secp256k1_nonce_function_smallint(unsigned char *nonce32, const unsigned cha\n     return 1;\n }\n \n-#ifdef USE_ENDOMORPHISM\n-void test_exhaustive_endomorphism(const secp256k1_ge *group, int order) {\n+void test_exhaustive_endomorphism(const secp256k1_ge *group) {\n     int i;\n-    for (i = 0; i < order; i++) {\n+    for (i = 0; i < EXHAUSTIVE_TEST_ORDER; i++) {\n         secp256k1_ge res;\n         secp256k1_ge_mul_lambda(&res, &group[i]);\n         ge_equals_ge(&group[i * EXHAUSTIVE_TEST_LAMBDA % EXHAUSTIVE_TEST_ORDER], &res);\n     }\n }\n-#endif\n \n-void test_exhaustive_addition(const secp256k1_ge *group, const secp256k1_gej *groupj, int order) {\n+void test_exhaustive_addition(const secp256k1_ge *group, const secp256k1_gej *groupj) {\n     int i, j;\n+    uint64_t iter = 0;\n \n     /* Sanity-check (and check infinity functions) */\n     CHECK(secp256k1_ge_is_infinity(&group[0]));\n     CHECK(secp256k1_gej_is_infinity(&groupj[0]));\n-    for (i = 1; i < order; i++) {\n+    for (i = 1; i < EXHAUSTIVE_TEST_ORDER; i++) {\n         CHECK(!secp256k1_ge_is_infinity(&group[i]));\n         CHECK(!secp256k1_gej_is_infinity(&groupj[i]));\n     }\n \n     /* Check all addition formulae */\n-    for (j = 0; j < order; j++) {\n+    for (j = 0; j < EXHAUSTIVE_TEST_ORDER; j++) {\n         secp256k1_fe fe_inv;\n+        if (skip_section(&iter)) continue;\n         secp256k1_fe_inv(&fe_inv, &groupj[j].z);\n-        for (i = 0; i < order; i++) {\n+        for (i = 0; i < EXHAUSTIVE_TEST_ORDER; i++) {\n             secp256k1_ge zless_gej;\n             secp256k1_gej tmp;\n             /* add_var */\n             secp256k1_gej_add_var(&tmp, &groupj[i], &groupj[j], NULL);\n-            ge_equals_gej(&group[(i + j) % order], &tmp);\n+            ge_equals_gej(&group[(i + j) % EXHAUSTIVE_TEST_ORDER], &tmp);\n             /* add_ge */\n             if (j > 0) {\n                 secp256k1_gej_add_ge(&tmp, &groupj[i], &group[j]);\n-                ge_equals_gej(&group[(i + j) % order], &tmp);\n+                ge_equals_gej(&group[(i + j) % EXHAUSTIVE_TEST_ORDER], &tmp);\n             }\n             /* add_ge_var */\n             secp256k1_gej_add_ge_var(&tmp, &groupj[i], &group[j], NULL);\n-            ge_equals_gej(&group[(i + j) % order], &tmp);\n+            ge_equals_gej(&group[(i + j) % EXHAUSTIVE_TEST_ORDER], &tmp);\n             /* add_zinv_var */\n             zless_gej.infinity = groupj[j].infinity;\n             zless_gej.x = groupj[j].x;\n             zless_gej.y = groupj[j].y;\n             secp256k1_gej_add_zinv_var(&tmp, &groupj[i], &zless_gej, &fe_inv);\n-            ge_equals_gej(&group[(i + j) % order], &tmp);\n+            ge_equals_gej(&group[(i + j) % EXHAUSTIVE_TEST_ORDER], &tmp);\n         }\n     }\n \n     /* Check doubling */\n-    for (i = 0; i < order; i++) {\n+    for (i = 0; i < EXHAUSTIVE_TEST_ORDER; i++) {\n         secp256k1_gej tmp;\n         secp256k1_gej_double(&tmp, &groupj[i]);\n-        ge_equals_gej(&group[(2 * i) % order], &tmp);\n+        ge_equals_gej(&group[(2 * i) % EXHAUSTIVE_TEST_ORDER], &tmp);\n         secp256k1_gej_double_var(&tmp, &groupj[i], NULL);\n-        ge_equals_gej(&group[(2 * i) % order], &tmp);\n+        ge_equals_gej(&group[(2 * i) % EXHAUSTIVE_TEST_ORDER], &tmp);\n     }\n \n     /* Check negation */\n-    for (i = 1; i < order; i++) {\n+    for (i = 1; i < EXHAUSTIVE_TEST_ORDER; i++) {\n         secp256k1_ge tmp;\n         secp256k1_gej tmpj;\n         secp256k1_ge_neg(&tmp, &group[i]);\n-        ge_equals_ge(&group[order - i], &tmp);\n+        ge_equals_ge(&group[EXHAUSTIVE_TEST_ORDER - i], &tmp);\n         secp256k1_gej_neg(&tmpj, &groupj[i]);\n-        ge_equals_gej(&group[order - i], &tmpj);\n+        ge_equals_gej(&group[EXHAUSTIVE_TEST_ORDER - i], &tmpj);\n     }\n }\n \n-void test_exhaustive_ecmult(const secp256k1_context *ctx, const secp256k1_ge *group, const secp256k1_gej *groupj, int order) {\n+void test_exhaustive_ecmult(const secp256k1_context *ctx, const secp256k1_ge *group, const secp256k1_gej *groupj) {\n     int i, j, r_log;\n-    for (r_log = 1; r_log < order; r_log++) {\n-        for (j = 0; j < order; j++) {\n-            for (i = 0; i < order; i++) {\n+    uint64_t iter = 0;\n+    for (r_log = 1; r_log < EXHAUSTIVE_TEST_ORDER; r_log++) {\n+        for (j = 0; j < EXHAUSTIVE_TEST_ORDER; j++) {\n+            if (skip_section(&iter)) continue;\n+            for (i = 0; i < EXHAUSTIVE_TEST_ORDER; i++) {\n                 secp256k1_gej tmp;\n                 secp256k1_scalar na, ng;\n                 secp256k1_scalar_set_int(&na, i);\n                 secp256k1_scalar_set_int(&ng, j);\n \n                 secp256k1_ecmult(&ctx->ecmult_ctx, &tmp, &groupj[r_log], &na, &ng);\n-                ge_equals_gej(&group[(i * r_log + j) % order], &tmp);\n+                ge_equals_gej(&group[(i * r_log + j) % EXHAUSTIVE_TEST_ORDER], &tmp);\n \n                 if (i > 0) {\n                     secp256k1_ecmult_const(&tmp, &group[i], &ng, 256);\n-                    ge_equals_gej(&group[(i * j) % order], &tmp);\n+                    ge_equals_gej(&group[(i * j) % EXHAUSTIVE_TEST_ORDER], &tmp);\n                 }\n             }\n         }\n@@ -193,14 +200,16 @@ static int ecmult_multi_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t\n     return 1;\n }\n \n-void test_exhaustive_ecmult_multi(const secp256k1_context *ctx, const secp256k1_ge *group, int order) {\n+void test_exhaustive_ecmult_multi(const secp256k1_context *ctx, const secp256k1_ge *group) {\n     int i, j, k, x, y;\n+    uint64_t iter = 0;\n     secp256k1_scratch *scratch = secp256k1_scratch_create(&ctx->error_callback, 4096);\n-    for (i = 0; i < order; i++) {\n-        for (j = 0; j < order; j++) {\n-            for (k = 0; k < order; k++) {\n-                for (x = 0; x < order; x++) {\n-                    for (y = 0; y < order; y++) {\n+    for (i = 0; i < EXHAUSTIVE_TEST_ORDER; i++) {\n+        for (j = 0; j < EXHAUSTIVE_TEST_ORDER; j++) {\n+            for (k = 0; k < EXHAUSTIVE_TEST_ORDER; k++) {\n+                for (x = 0; x < EXHAUSTIVE_TEST_ORDER; x++) {\n+                    if (skip_section(&iter)) continue;\n+                    for (y = 0; y < EXHAUSTIVE_TEST_ORDER; y++) {\n                         secp256k1_gej tmp;\n                         secp256k1_scalar g_sc;\n                         ecmult_multi_data data;\n@@ -212,7 +221,7 @@ void test_exhaustive_ecmult_multi(const secp256k1_context *ctx, const secp256k1_\n                         data.pt[1] = group[y];\n \n                         secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &tmp, &g_sc, ecmult_multi_callback, &data, 2);\n-                        ge_equals_gej(&group[(i * x + j * y + k) % order], &tmp);\n+                        ge_equals_gej(&group[(i * x + j * y + k) % EXHAUSTIVE_TEST_ORDER], &tmp);\n                     }\n                 }\n             }\n@@ -221,22 +230,23 @@ void test_exhaustive_ecmult_multi(const secp256k1_context *ctx, const secp256k1_\n     secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n }\n \n-void r_from_k(secp256k1_scalar *r, const secp256k1_ge *group, int k) {\n+void r_from_k(secp256k1_scalar *r, const secp256k1_ge *group, int k, int* overflow) {\n     secp256k1_fe x;\n     unsigned char x_bin[32];\n     k %= EXHAUSTIVE_TEST_ORDER;\n     x = group[k].x;\n     secp256k1_fe_normalize(&x);\n     secp256k1_fe_get_b32(x_bin, &x);\n-    secp256k1_scalar_set_b32(r, x_bin, NULL);\n+    secp256k1_scalar_set_b32(r, x_bin, overflow);\n }\n \n-void test_exhaustive_verify(const secp256k1_context *ctx, const secp256k1_ge *group, int order) {\n+void test_exhaustive_verify(const secp256k1_context *ctx, const secp256k1_ge *group) {\n     int s, r, msg, key;\n-    for (s = 1; s < order; s++) {\n-        for (r = 1; r < order; r++) {\n-            for (msg = 1; msg < order; msg++) {\n-                for (key = 1; key < order; key++) {\n+    uint64_t iter = 0;\n+    for (s = 1; s < EXHAUSTIVE_TEST_ORDER; s++) {\n+        for (r = 1; r < EXHAUSTIVE_TEST_ORDER; r++) {\n+            for (msg = 1; msg < EXHAUSTIVE_TEST_ORDER; msg++) {\n+                for (key = 1; key < EXHAUSTIVE_TEST_ORDER; key++) {\n                     secp256k1_ge nonconst_ge;\n                     secp256k1_ecdsa_signature sig;\n                     secp256k1_pubkey pk;\n@@ -245,6 +255,8 @@ void test_exhaustive_verify(const secp256k1_context *ctx, const secp256k1_ge *gr\n                     int k, should_verify;\n                     unsigned char msg32[32];\n \n+                    if (skip_section(&iter)) continue;\n+\n                     secp256k1_scalar_set_int(&s_s, s);\n                     secp256k1_scalar_set_int(&r_s, r);\n                     secp256k1_scalar_set_int(&msg_s, msg);\n@@ -254,9 +266,9 @@ void test_exhaustive_verify(const secp256k1_context *ctx, const secp256k1_ge *gr\n                     /* Run through every k value that gives us this r and check that *one* works.\n                      * Note there could be none, there could be multiple, ECDSA is weird. */\n                     should_verify = 0;\n-                    for (k = 0; k < order; k++) {\n+                    for (k = 0; k < EXHAUSTIVE_TEST_ORDER; k++) {\n                         secp256k1_scalar check_x_s;\n-                        r_from_k(&check_x_s, group, k);\n+                        r_from_k(&check_x_s, group, k, NULL);\n                         if (r_s == check_x_s) {\n                             secp256k1_scalar_set_int(&s_times_k_s, k);\n                             secp256k1_scalar_mul(&s_times_k_s, &s_times_k_s, &s_s);\n@@ -281,13 +293,15 @@ void test_exhaustive_verify(const secp256k1_context *ctx, const secp256k1_ge *gr\n     }\n }\n \n-void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *group, int order) {\n+void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *group) {\n     int i, j, k;\n+    uint64_t iter = 0;\n \n     /* Loop */\n-    for (i = 1; i < order; i++) {  /* message */\n-        for (j = 1; j < order; j++) {  /* key */\n-            for (k = 1; k < order; k++) {  /* nonce */\n+    for (i = 1; i < EXHAUSTIVE_TEST_ORDER; i++) {  /* message */\n+        for (j = 1; j < EXHAUSTIVE_TEST_ORDER; j++) {  /* key */\n+            if (skip_section(&iter)) continue;\n+            for (k = 1; k < EXHAUSTIVE_TEST_ORDER; k++) {  /* nonce */\n                 const int starting_k = k;\n                 secp256k1_ecdsa_signature sig;\n                 secp256k1_scalar sk, msg, r, s, expected_r;\n@@ -303,10 +317,10 @@ void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *grou\n                 /* Note that we compute expected_r *after* signing -- this is important\n                  * because our nonce-computing function function might change k during\n                  * signing. */\n-                r_from_k(&expected_r, group, k);\n+                r_from_k(&expected_r, group, k, NULL);\n                 CHECK(r == expected_r);\n-                CHECK((k * s) % order == (i + r * j) % order ||\n-                      (k * (EXHAUSTIVE_TEST_ORDER - s)) % order == (i + r * j) % order);\n+                CHECK((k * s) % EXHAUSTIVE_TEST_ORDER == (i + r * j) % EXHAUSTIVE_TEST_ORDER ||\n+                      (k * (EXHAUSTIVE_TEST_ORDER - s)) % EXHAUSTIVE_TEST_ORDER == (i + r * j) % EXHAUSTIVE_TEST_ORDER);\n \n                 /* Overflow means we've tried every possible nonce */\n                 if (k < starting_k) {\n@@ -327,184 +341,114 @@ void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *grou\n }\n \n #ifdef ENABLE_MODULE_RECOVERY\n-void test_exhaustive_recovery_sign(const secp256k1_context *ctx, const secp256k1_ge *group, int order) {\n-    int i, j, k;\n-\n-    /* Loop */\n-    for (i = 1; i < order; i++) {  /* message */\n-        for (j = 1; j < order; j++) {  /* key */\n-            for (k = 1; k < order; k++) {  /* nonce */\n-                const int starting_k = k;\n-                secp256k1_fe r_dot_y_normalized;\n-                secp256k1_ecdsa_recoverable_signature rsig;\n-                secp256k1_ecdsa_signature sig;\n-                secp256k1_scalar sk, msg, r, s, expected_r;\n-                unsigned char sk32[32], msg32[32];\n-                int expected_recid;\n-                int recid;\n-                secp256k1_scalar_set_int(&msg, i);\n-                secp256k1_scalar_set_int(&sk, j);\n-                secp256k1_scalar_get_b32(sk32, &sk);\n-                secp256k1_scalar_get_b32(msg32, &msg);\n-\n-                secp256k1_ecdsa_sign_recoverable(ctx, &rsig, msg32, sk32, secp256k1_nonce_function_smallint, &k);\n+#include \"src/modules/recovery/tests_exhaustive_impl.h\"\n+#endif\n \n-                /* Check directly */\n-                secp256k1_ecdsa_recoverable_signature_load(ctx, &r, &s, &recid, &rsig);\n-                r_from_k(&expected_r, group, k);\n-                CHECK(r == expected_r);\n-                CHECK((k * s) % order == (i + r * j) % order ||\n-                      (k * (EXHAUSTIVE_TEST_ORDER - s)) % order == (i + r * j) % order);\n-                /* In computing the recid, there is an overflow condition that is disabled in\n-                 * scalar_low_impl.h `secp256k1_scalar_set_b32` because almost every r.y value\n-                 * will exceed the group order, and our signing code always holds out for r\n-                 * values that don't overflow, so with a proper overflow check the tests would\n-                 * loop indefinitely. */\n-                r_dot_y_normalized = group[k].y;\n-                secp256k1_fe_normalize(&r_dot_y_normalized);\n-                /* Also the recovery id is flipped depending if we hit the low-s branch */\n-                if ((k * s) % order == (i + r * j) % order) {\n-                    expected_recid = secp256k1_fe_is_odd(&r_dot_y_normalized) ? 1 : 0;\n-                } else {\n-                    expected_recid = secp256k1_fe_is_odd(&r_dot_y_normalized) ? 0 : 1;\n-                }\n-                CHECK(recid == expected_recid);\n+#ifdef ENABLE_MODULE_EXTRAKEYS\n+#include \"src/modules/extrakeys/tests_exhaustive_impl.h\"\n+#endif\n \n-                /* Convert to a standard sig then check */\n-                secp256k1_ecdsa_recoverable_signature_convert(ctx, &sig, &rsig);\n-                secp256k1_ecdsa_signature_load(ctx, &r, &s, &sig);\n-                /* Note that we compute expected_r *after* signing -- this is important\n-                 * because our nonce-computing function function might change k during\n-                 * signing. */\n-                r_from_k(&expected_r, group, k);\n-                CHECK(r == expected_r);\n-                CHECK((k * s) % order == (i + r * j) % order ||\n-                      (k * (EXHAUSTIVE_TEST_ORDER - s)) % order == (i + r * j) % order);\n+#ifdef ENABLE_MODULE_SCHNORRSIG\n+#include \"src/modules/schnorrsig/tests_exhaustive_impl.h\"\n+#endif\n \n-                /* Overflow means we've tried every possible nonce */\n-                if (k < starting_k) {\n-                    break;\n-                }\n-            }\n+int main(int argc, char** argv) {\n+    int i;\n+    secp256k1_gej groupj[EXHAUSTIVE_TEST_ORDER];\n+    secp256k1_ge group[EXHAUSTIVE_TEST_ORDER];\n+    unsigned char rand32[32];\n+    secp256k1_context *ctx;\n+\n+    /* Disable buffering for stdout to improve reliability of getting\n+     * diagnostic information. Happens right at the start of main because\n+     * setbuf must be used before any other operation on the stream. */\n+    setbuf(stdout, NULL);\n+    /* Also disable buffering for stderr because it's not guaranteed that it's\n+     * unbuffered on all systems. */\n+    setbuf(stderr, NULL);\n+\n+    printf(\"Exhaustive tests for order %lu\\n\", (unsigned long)EXHAUSTIVE_TEST_ORDER);\n+\n+    /* find iteration count */\n+    if (argc > 1) {\n+        count = strtol(argv[1], NULL, 0);\n+    }\n+    printf(\"test count = %i\\n\", count);\n+\n+    /* find random seed */\n+    secp256k1_testrand_init(argc > 2 ? argv[2] : NULL);\n+\n+    /* set up split processing */\n+    if (argc > 4) {\n+        num_cores = strtol(argv[3], NULL, 0);\n+        this_core = strtol(argv[4], NULL, 0);\n+        if (num_cores < 1 || this_core >= num_cores) {\n+            fprintf(stderr, \"Usage: %s [count] [seed] [numcores] [thiscore]\\n\", argv[0]);\n+            return 1;\n         }\n+        printf(\"running tests for core %lu (out of [0..%lu])\\n\", (unsigned long)this_core, (unsigned long)num_cores - 1);\n     }\n-}\n-\n-void test_exhaustive_recovery_verify(const secp256k1_context *ctx, const secp256k1_ge *group, int order) {\n-    /* This is essentially a copy of test_exhaustive_verify, with recovery added */\n-    int s, r, msg, key;\n-    for (s = 1; s < order; s++) {\n-        for (r = 1; r < order; r++) {\n-            for (msg = 1; msg < order; msg++) {\n-                for (key = 1; key < order; key++) {\n-                    secp256k1_ge nonconst_ge;\n-                    secp256k1_ecdsa_recoverable_signature rsig;\n-                    secp256k1_ecdsa_signature sig;\n-                    secp256k1_pubkey pk;\n-                    secp256k1_scalar sk_s, msg_s, r_s, s_s;\n-                    secp256k1_scalar s_times_k_s, msg_plus_r_times_sk_s;\n-                    int recid = 0;\n-                    int k, should_verify;\n-                    unsigned char msg32[32];\n \n-                    secp256k1_scalar_set_int(&s_s, s);\n-                    secp256k1_scalar_set_int(&r_s, r);\n-                    secp256k1_scalar_set_int(&msg_s, msg);\n-                    secp256k1_scalar_set_int(&sk_s, key);\n-                    secp256k1_scalar_get_b32(msg32, &msg_s);\n+    while (count--) {\n+        /* Build context */\n+        ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+        secp256k1_testrand256(rand32);\n+        CHECK(secp256k1_context_randomize(ctx, rand32));\n+\n+        /* Generate the entire group */\n+        secp256k1_gej_set_infinity(&groupj[0]);\n+        secp256k1_ge_set_gej(&group[0], &groupj[0]);\n+        for (i = 1; i < EXHAUSTIVE_TEST_ORDER; i++) {\n+            secp256k1_gej_add_ge(&groupj[i], &groupj[i - 1], &secp256k1_ge_const_g);\n+            secp256k1_ge_set_gej(&group[i], &groupj[i]);\n+            if (count != 0) {\n+                /* Set a different random z-value for each Jacobian point, except z=1\n+                   is used in the last iteration. */\n+                secp256k1_fe z;\n+                random_fe(&z);\n+                secp256k1_gej_rescale(&groupj[i], &z);\n+            }\n \n-                    /* Verify by hand */\n-                    /* Run through every k value that gives us this r and check that *one* works.\n-                     * Note there could be none, there could be multiple, ECDSA is weird. */\n-                    should_verify = 0;\n-                    for (k = 0; k < order; k++) {\n-                        secp256k1_scalar check_x_s;\n-                        r_from_k(&check_x_s, group, k);\n-                        if (r_s == check_x_s) {\n-                            secp256k1_scalar_set_int(&s_times_k_s, k);\n-                            secp256k1_scalar_mul(&s_times_k_s, &s_times_k_s, &s_s);\n-                            secp256k1_scalar_mul(&msg_plus_r_times_sk_s, &r_s, &sk_s);\n-                            secp256k1_scalar_add(&msg_plus_r_times_sk_s, &msg_plus_r_times_sk_s, &msg_s);\n-                            should_verify |= secp256k1_scalar_eq(&s_times_k_s, &msg_plus_r_times_sk_s);\n-                        }\n-                    }\n-                    /* nb we have a \"high s\" rule */\n-                    should_verify &= !secp256k1_scalar_is_high(&s_s);\n+            /* Verify against ecmult_gen */\n+            {\n+                secp256k1_scalar scalar_i;\n+                secp256k1_gej generatedj;\n+                secp256k1_ge generated;\n \n-                    /* We would like to try recovering the pubkey and checking that it matches,\n-                     * but pubkey recovery is impossible in the exhaustive tests (the reason\n-                     * being that there are 12 nonzero r values, 12 nonzero points, and no\n-                     * overlap between the sets, so there are no valid signatures). */\n+                secp256k1_scalar_set_int(&scalar_i, i);\n+                secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &generatedj, &scalar_i);\n+                secp256k1_ge_set_gej(&generated, &generatedj);\n \n-                    /* Verify by converting to a standard signature and calling verify */\n-                    secp256k1_ecdsa_recoverable_signature_save(&rsig, &r_s, &s_s, recid);\n-                    secp256k1_ecdsa_recoverable_signature_convert(ctx, &sig, &rsig);\n-                    memcpy(&nonconst_ge, &group[sk_s], sizeof(nonconst_ge));\n-                    secp256k1_pubkey_save(&pk, &nonconst_ge);\n-                    CHECK(should_verify ==\n-                          secp256k1_ecdsa_verify(ctx, &sig, msg32, &pk));\n-                }\n+                CHECK(group[i].infinity == 0);\n+                CHECK(generated.infinity == 0);\n+                CHECK(secp256k1_fe_equal_var(&generated.x, &group[i].x));\n+                CHECK(secp256k1_fe_equal_var(&generated.y, &group[i].y));\n             }\n         }\n-    }\n-}\n-#endif\n-\n-int main(void) {\n-    int i;\n-    secp256k1_gej groupj[EXHAUSTIVE_TEST_ORDER];\n-    secp256k1_ge group[EXHAUSTIVE_TEST_ORDER];\n \n-    /* Build context */\n-    secp256k1_context *ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+        /* Run the tests */\n+        test_exhaustive_endomorphism(group);\n+        test_exhaustive_addition(group, groupj);\n+        test_exhaustive_ecmult(ctx, group, groupj);\n+        test_exhaustive_ecmult_multi(ctx, group);\n+        test_exhaustive_sign(ctx, group);\n+        test_exhaustive_verify(ctx, group);\n \n-    /* TODO set z = 1, then do num_tests runs with random z values */\n+#ifdef ENABLE_MODULE_RECOVERY\n+        test_exhaustive_recovery(ctx, group);\n+#endif\n+#ifdef ENABLE_MODULE_EXTRAKEYS\n+        test_exhaustive_extrakeys(ctx, group);\n+#endif\n+#ifdef ENABLE_MODULE_SCHNORRSIG\n+        test_exhaustive_schnorrsig(ctx);\n+#endif\n \n-    /* Generate the entire group */\n-    secp256k1_gej_set_infinity(&groupj[0]);\n-    secp256k1_ge_set_gej(&group[0], &groupj[0]);\n-    for (i = 1; i < EXHAUSTIVE_TEST_ORDER; i++) {\n-        /* Set a different random z-value for each Jacobian point */\n-        secp256k1_fe z;\n-        random_fe(&z);\n-\n-        secp256k1_gej_add_ge(&groupj[i], &groupj[i - 1], &secp256k1_ge_const_g);\n-        secp256k1_ge_set_gej(&group[i], &groupj[i]);\n-        secp256k1_gej_rescale(&groupj[i], &z);\n-\n-        /* Verify against ecmult_gen */\n-        {\n-            secp256k1_scalar scalar_i;\n-            secp256k1_gej generatedj;\n-            secp256k1_ge generated;\n-\n-            secp256k1_scalar_set_int(&scalar_i, i);\n-            secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &generatedj, &scalar_i);\n-            secp256k1_ge_set_gej(&generated, &generatedj);\n-\n-            CHECK(group[i].infinity == 0);\n-            CHECK(generated.infinity == 0);\n-            CHECK(secp256k1_fe_equal_var(&generated.x, &group[i].x));\n-            CHECK(secp256k1_fe_equal_var(&generated.y, &group[i].y));\n-        }\n+        secp256k1_context_destroy(ctx);\n     }\n \n-    /* Run the tests */\n-#ifdef USE_ENDOMORPHISM\n-    test_exhaustive_endomorphism(group, EXHAUSTIVE_TEST_ORDER);\n-#endif\n-    test_exhaustive_addition(group, groupj, EXHAUSTIVE_TEST_ORDER);\n-    test_exhaustive_ecmult(ctx, group, groupj, EXHAUSTIVE_TEST_ORDER);\n-    test_exhaustive_ecmult_multi(ctx, group, EXHAUSTIVE_TEST_ORDER);\n-    test_exhaustive_sign(ctx, group, EXHAUSTIVE_TEST_ORDER);\n-    test_exhaustive_verify(ctx, group, EXHAUSTIVE_TEST_ORDER);\n+    secp256k1_testrand_finish();\n \n-#ifdef ENABLE_MODULE_RECOVERY\n-    test_exhaustive_recovery_sign(ctx, group, EXHAUSTIVE_TEST_ORDER);\n-    test_exhaustive_recovery_verify(ctx, group, EXHAUSTIVE_TEST_ORDER);\n-#endif\n-\n-    secp256k1_context_destroy(ctx);\n+    printf(\"no problems found\\n\");\n     return 0;\n }\n-"
      },
      {
        "sha": "3a88a41bc61f79e2cef31870d4d3b01b147ee16f",
        "filename": "src/secp256k1/src/util.h",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/util.h?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -216,6 +216,24 @@ static SECP256K1_INLINE void memczero(void *s, size_t len, int flag) {\n     }\n }\n \n+/** Semantics like memcmp. Variable-time.\n+ *\n+ * We use this to avoid possible compiler bugs with memcmp, e.g.\n+ * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95189\n+ */\n+static SECP256K1_INLINE int secp256k1_memcmp_var(const void *s1, const void *s2, size_t n) {\n+    const unsigned char *p1 = s1, *p2 = s2;\n+    size_t i;\n+\n+    for (i = 0; i < n; i++) {\n+        int diff = p1[i] - p2[i];\n+        if (diff != 0) {\n+            return diff;\n+        }\n+    }\n+    return 0;\n+}\n+\n /** If flag is true, set *r equal to *a; otherwise leave it. Constant-time.  Both *r and *a must be initialized and non-negative.*/\n static SECP256K1_INLINE void secp256k1_int_cmov(int *r, const int *a, int flag) {\n     unsigned int mask0, mask1, r_masked, a_masked;"
      },
      {
        "sha": "3169e3651c4044dcf865eea73b4f75ba8dca372b",
        "filename": "src/secp256k1/src/valgrind_ctime_test.c",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/valgrind_ctime_test.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e5626d2a8ddbbd7640ff53f89f3a7021d747633/src/secp256k1/src/valgrind_ctime_test.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/valgrind_ctime_test.c?ref=9e5626d2a8ddbbd7640ff53f89f3a7021d747633",
        "patch": "@@ -9,19 +9,19 @@\n #include \"assumptions.h\"\n #include \"util.h\"\n \n-#if ENABLE_MODULE_ECDH\n+#ifdef ENABLE_MODULE_ECDH\n # include \"include/secp256k1_ecdh.h\"\n #endif\n \n-#if ENABLE_MODULE_RECOVERY\n+#ifdef ENABLE_MODULE_RECOVERY\n # include \"include/secp256k1_recovery.h\"\n #endif\n \n-#if ENABLE_MODULE_EXTRAKEYS\n+#ifdef ENABLE_MODULE_EXTRAKEYS\n # include \"include/secp256k1_extrakeys.h\"\n #endif\n \n-#if ENABLE_MODULE_SCHNORRSIG\n+#ifdef ENABLE_MODULE_SCHNORRSIG\n #include \"include/secp256k1_schnorrsig.h\"\n #endif\n \n@@ -37,11 +37,11 @@ int main(void) {\n     unsigned char key[32];\n     unsigned char sig[74];\n     unsigned char spubkey[33];\n-#if ENABLE_MODULE_RECOVERY\n+#ifdef ENABLE_MODULE_RECOVERY\n     secp256k1_ecdsa_recoverable_signature recoverable_signature;\n     int recid;\n #endif\n-#if ENABLE_MODULE_EXTRAKEYS\n+#ifdef ENABLE_MODULE_EXTRAKEYS\n     secp256k1_keypair keypair;\n #endif\n \n@@ -81,15 +81,15 @@ int main(void) {\n     CHECK(ret);\n     CHECK(secp256k1_ecdsa_signature_serialize_der(ctx, sig, &siglen, &signature));\n \n-#if ENABLE_MODULE_ECDH\n+#ifdef ENABLE_MODULE_ECDH\n     /* Test ECDH. */\n     VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n     ret = secp256k1_ecdh(ctx, msg, &pubkey, key, NULL, NULL);\n     VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n     CHECK(ret == 1);\n #endif\n \n-#if ENABLE_MODULE_RECOVERY\n+#ifdef ENABLE_MODULE_RECOVERY\n     /* Test signing a recoverable signature. */\n     VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n     ret = secp256k1_ecdsa_sign_recoverable(ctx, &recoverable_signature, msg, key, NULL, NULL);\n@@ -129,7 +129,7 @@ int main(void) {\n     CHECK(ret);\n \n     /* Test keypair_create and keypair_xonly_tweak_add. */\n-#if ENABLE_MODULE_EXTRAKEYS\n+#ifdef ENABLE_MODULE_EXTRAKEYS\n     VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n     ret = secp256k1_keypair_create(ctx, &keypair, key);\n     VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n@@ -142,7 +142,7 @@ int main(void) {\n     CHECK(ret == 1);\n #endif\n \n-#if ENABLE_MODULE_SCHNORRSIG\n+#ifdef ENABLE_MODULE_SCHNORRSIG\n     VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n     ret = secp256k1_keypair_create(ctx, &keypair, key);\n     VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));"
      }
    ]
  }
]