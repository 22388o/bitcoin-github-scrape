[
  {
    "sha": "46d955d196043cc297834baeebce31ff778dff80",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NmQ5NTVkMTk2MDQzY2MyOTc4MzRiYWVlYmNlMzFmZjc3OGRmZjgw",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "j@rubin.io",
        "date": "2020-01-21T21:48:57Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "j@rubin.io",
        "date": "2020-09-04T16:46:44Z"
      },
      "message": "Remove mapLinks in favor of entry inlined structs with iterator type erasure",
      "tree": {
        "sha": "d150833644522ec9070c75c845da4fe58eb30a1d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d150833644522ec9070c75c845da4fe58eb30a1d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/46d955d196043cc297834baeebce31ff778dff80",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/46d955d196043cc297834baeebce31ff778dff80",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/46d955d196043cc297834baeebce31ff778dff80",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/46d955d196043cc297834baeebce31ff778dff80/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "23d3ae7accfc690298b1b0bac9615155f485c5ad",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/23d3ae7accfc690298b1b0bac9615155f485c5ad",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/23d3ae7accfc690298b1b0bac9615155f485c5ad"
      }
    ],
    "stats": {
      "total": 240,
      "additions": 128,
      "deletions": 112
    },
    "files": [
      {
        "sha": "bb7a30b1840c68ee0f4c37648e212530989b80f6",
        "filename": "src/miner.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46d955d196043cc297834baeebce31ff778dff80/src/miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46d955d196043cc297834baeebce31ff778dff80/src/miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.h?ref=46d955d196043cc297834baeebce31ff778dff80",
        "patch": "@@ -84,7 +84,7 @@ struct CompareTxIterByAncestorCount {\n     {\n         if (a->GetCountWithAncestors() != b->GetCountWithAncestors())\n             return a->GetCountWithAncestors() < b->GetCountWithAncestors();\n-        return CTxMemPool::CompareIteratorByHash()(a, b);\n+        return CompareIteratorByHash()(a, b);\n     }\n };\n "
      },
      {
        "sha": "7057610434d67230a08966bbe4e9ff21c81f267b",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46d955d196043cc297834baeebce31ff778dff80/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46d955d196043cc297834baeebce31ff778dff80/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=46d955d196043cc297834baeebce31ff778dff80",
        "patch": "@@ -1776,11 +1776,11 @@ void static ProcessGetData(CNode& pfrom, const CChainParams& chainparams, CConnm\n                 LOCK(mempool.cs);\n                 auto txiter = mempool.GetIter(tx->GetHash());\n                 if (txiter) {\n-                    const CTxMemPool::setEntries& parents = mempool.GetMemPoolParents(*txiter);\n+                    const CTxMemPoolEntry::Parents& parents = (*txiter)->GetMemPoolParentsConst();\n                     parent_ids_to_add.reserve(parents.size());\n-                    for (CTxMemPool::txiter parent_iter : parents) {\n-                        if (parent_iter->GetTime() > now - UNCONDITIONAL_RELAY_DELAY) {\n-                            parent_ids_to_add.push_back(parent_iter->GetTx().GetHash());\n+                    for (const CTxMemPoolEntry& parent : parents) {\n+                        if (parent.GetTime() > now - UNCONDITIONAL_RELAY_DELAY) {\n+                            parent_ids_to_add.push_back(parent.GetTx().GetHash());\n                         }\n                     }\n                 }"
      },
      {
        "sha": "04b9c6b1cc46f693a6beeb5d12f3d0eb829f4c36",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46d955d196043cc297834baeebce31ff778dff80/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46d955d196043cc297834baeebce31ff778dff80/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=46d955d196043cc297834baeebce31ff778dff80",
        "patch": "@@ -463,9 +463,9 @@ static void entryToJSON(const CTxMemPool& pool, UniValue& info, const CTxMemPool\n \n     UniValue spent(UniValue::VARR);\n     const CTxMemPool::txiter& it = pool.mapTx.find(tx.GetHash());\n-    const CTxMemPool::setEntries& setChildren = pool.GetMemPoolChildren(it);\n-    for (CTxMemPool::txiter childiter : setChildren) {\n-        spent.push_back(childiter->GetTx().GetHash().ToString());\n+    const CTxMemPoolEntry::Children& children = it->GetMemPoolChildrenConst();\n+    for (const CTxMemPoolEntry& child : children) {\n+        spent.push_back(child.GetTx().GetHash().ToString());\n     }\n \n     info.pushKV(\"spentby\", spent);"
      },
      {
        "sha": "e24d8d7b9811da3068c5a94d163ae7ee4d8d879d",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 91,
        "deletions": 90,
        "changes": 181,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46d955d196043cc297834baeebce31ff778dff80/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46d955d196043cc297834baeebce31ff778dff80/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=46d955d196043cc297834baeebce31ff778dff80",
        "patch": "@@ -55,45 +55,45 @@ size_t CTxMemPoolEntry::GetTxSize() const\n }\n \n // Update the given tx for any in-mempool descendants.\n-// Assumes that setMemPoolChildren is correct for the given tx and all\n+// Assumes that CTxMemPool::m_children is correct for the given tx and all\n // descendants.\n void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n+    CTxMemPoolEntry::Children stageEntries, descendants;\n+    stageEntries = updateIt->GetMemPoolChildrenConst();\n \n     while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n+        const CTxMemPoolEntry& descendant = *stageEntries.begin();\n+        descendants.insert(descendant);\n+        stageEntries.erase(descendant);\n+        const CTxMemPoolEntry::Children& children = descendant.GetMemPoolChildrenConst();\n+        for (const CTxMemPoolEntry& childEntry : children) {\n+            cacheMap::iterator cacheIt = cachedDescendants.find(mapTx.iterator_to(childEntry));\n             if (cacheIt != cachedDescendants.end()) {\n                 // We've already calculated this one, just add the entries for this set\n                 // but don't traverse again.\n                 for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+                    descendants.insert(*cacheEntry);\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else if (!descendants.count(childEntry)) {\n                 // Schedule for later processing\n                 stageEntries.insert(childEntry);\n             }\n         }\n     }\n-    // setAllDescendants now contains all in-mempool descendants of updateIt.\n+    // descendants now contains all in-mempool descendants of updateIt.\n     // Update and add to cached descendant map\n     int64_t modifySize = 0;\n     CAmount modifyFee = 0;\n     int64_t modifyCount = 0;\n-    for (txiter cit : setAllDescendants) {\n-        if (!setExclude.count(cit->GetTx().GetHash())) {\n-            modifySize += cit->GetTxSize();\n-            modifyFee += cit->GetModifiedFee();\n+    for (const CTxMemPoolEntry& descendant : descendants) {\n+        if (!setExclude.count(descendant.GetTx().GetHash())) {\n+            modifySize += descendant.GetTxSize();\n+            modifyFee += descendant.GetModifiedFee();\n             modifyCount++;\n-            cachedDescendants[updateIt].insert(cit);\n+            cachedDescendants[updateIt].insert(mapTx.iterator_to(descendant));\n             // Update ancestor state for each descendant\n-            mapTx.modify(cit, update_ancestor_state(updateIt->GetTxSize(), updateIt->GetModifiedFee(), 1, updateIt->GetSigOpCost()));\n+            mapTx.modify(mapTx.iterator_to(descendant), update_ancestor_state(updateIt->GetTxSize(), updateIt->GetModifiedFee(), 1, updateIt->GetSigOpCost()));\n         }\n     }\n     mapTx.modify(updateIt, update_descendant_state(modifySize, modifyFee, modifyCount));\n@@ -119,7 +119,7 @@ void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<uint256> &vHashes\n     // Iterate in reverse, so that whenever we are looking at a transaction\n     // we are sure that all in-mempool descendants have already been processed.\n     // This maximizes the benefit of the descendant cache and guarantees that\n-    // setMemPoolChildren will be updated, an assumption made in\n+    // CTxMemPool::m_children will be updated, an assumption made in\n     // UpdateForDescendants.\n     for (const uint256 &hash : reverse_iterate(vHashesToUpdate)) {\n         // calculate children from mapNextTx\n@@ -128,8 +128,8 @@ void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<uint256> &vHashes\n             continue;\n         }\n         auto iter = mapNextTx.lower_bound(COutPoint(hash, 0));\n-        // First calculate the children, and update setMemPoolChildren to\n-        // include them, and update their setMemPoolParents to include this tx.\n+        // First calculate the children, and update CTxMemPool::m_children to\n+        // include them, and update their CTxMemPoolEntry::m_parents to include this tx.\n         // we cache the in-mempool children to avoid duplicate updates\n         {\n             const auto epoch = GetFreshEpoch();\n@@ -151,7 +151,7 @@ void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<uint256> &vHashes\n \n bool CTxMemPool::CalculateMemPoolAncestors(const CTxMemPoolEntry &entry, setEntries &setAncestors, uint64_t limitAncestorCount, uint64_t limitAncestorSize, uint64_t limitDescendantCount, uint64_t limitDescendantSize, std::string &errString, bool fSearchForParents /* = true */) const\n {\n-    setEntries parentHashes;\n+    CTxMemPoolEntry::Parents staged_ancestors;\n     const CTransaction &tx = entry.GetTx();\n \n     if (fSearchForParents) {\n@@ -161,8 +161,8 @@ bool CTxMemPool::CalculateMemPoolAncestors(const CTxMemPoolEntry &entry, setEntr\n         for (unsigned int i = 0; i < tx.vin.size(); i++) {\n             Optional<txiter> piter = GetIter(tx.vin[i].prevout.hash);\n             if (piter) {\n-                parentHashes.insert(*piter);\n-                if (parentHashes.size() + 1 > limitAncestorCount) {\n+                staged_ancestors.insert(**piter);\n+                if (staged_ancestors.size() + 1 > limitAncestorCount) {\n                     errString = strprintf(\"too many unconfirmed parents [limit: %u]\", limitAncestorCount);\n                     return false;\n                 }\n@@ -172,16 +172,17 @@ bool CTxMemPool::CalculateMemPoolAncestors(const CTxMemPoolEntry &entry, setEntr\n         // If we're not searching for parents, we require this to be an\n         // entry in the mempool already.\n         txiter it = mapTx.iterator_to(entry);\n-        parentHashes = GetMemPoolParents(it);\n+        staged_ancestors = it->GetMemPoolParentsConst();\n     }\n \n     size_t totalSizeWithAncestors = entry.GetTxSize();\n \n-    while (!parentHashes.empty()) {\n-        txiter stageit = *parentHashes.begin();\n+    while (!staged_ancestors.empty()) {\n+        const CTxMemPoolEntry& stage = staged_ancestors.begin()->get();\n+        txiter stageit = mapTx.iterator_to(stage);\n \n         setAncestors.insert(stageit);\n-        parentHashes.erase(stageit);\n+        staged_ancestors.erase(stage);\n         totalSizeWithAncestors += stageit->GetTxSize();\n \n         if (stageit->GetSizeWithDescendants() + entry.GetTxSize() > limitDescendantSize) {\n@@ -195,13 +196,15 @@ bool CTxMemPool::CalculateMemPoolAncestors(const CTxMemPoolEntry &entry, setEntr\n             return false;\n         }\n \n-        const setEntries & setMemPoolParents = GetMemPoolParents(stageit);\n-        for (txiter phash : setMemPoolParents) {\n+        const CTxMemPoolEntry::Parents& parents = stageit->GetMemPoolParentsConst();\n+        for (const CTxMemPoolEntry& parent : parents) {\n+            txiter parent_it = mapTx.iterator_to(parent);\n+\n             // If this is a new ancestor, add it.\n-            if (setAncestors.count(phash) == 0) {\n-                parentHashes.insert(phash);\n+            if (setAncestors.count(parent_it) == 0) {\n+                staged_ancestors.insert(parent);\n             }\n-            if (parentHashes.size() + setAncestors.size() + 1 > limitAncestorCount) {\n+            if (staged_ancestors.size() + setAncestors.size() + 1 > limitAncestorCount) {\n                 errString = strprintf(\"too many unconfirmed ancestors [limit: %u]\", limitAncestorCount);\n                 return false;\n             }\n@@ -213,10 +216,10 @@ bool CTxMemPool::CalculateMemPoolAncestors(const CTxMemPoolEntry &entry, setEntr\n \n void CTxMemPool::UpdateAncestorsOf(bool add, txiter it, setEntries &setAncestors)\n {\n-    setEntries parentIters = GetMemPoolParents(it);\n+    CTxMemPoolEntry::Parents parents = it->GetMemPoolParents();\n     // add or remove this tx as a child of each parent\n-    for (txiter piter : parentIters) {\n-        UpdateChild(piter, it, add);\n+    for (const CTxMemPoolEntry& parent : parents) {\n+        UpdateChild(mapTx.iterator_to(parent), it, add);\n     }\n     const int64_t updateCount = (add ? 1 : -1);\n     const int64_t updateSize = updateCount * it->GetTxSize();\n@@ -242,9 +245,9 @@ void CTxMemPool::UpdateEntryForAncestors(txiter it, const setEntries &setAncesto\n \n void CTxMemPool::UpdateChildrenForRemoval(txiter it)\n {\n-    const setEntries &setMemPoolChildren = GetMemPoolChildren(it);\n-    for (txiter updateIt : setMemPoolChildren) {\n-        UpdateParent(updateIt, it, false);\n+    const CTxMemPoolEntry::Children& children = it->GetMemPoolChildrenConst();\n+    for (const CTxMemPoolEntry& updateIt : children) {\n+        UpdateParent(mapTx.iterator_to(updateIt), it, false);\n     }\n }\n \n@@ -257,9 +260,9 @@ void CTxMemPool::UpdateForRemoveFromMempool(const setEntries &entriesToRemove, b\n         // updateDescendants should be true whenever we're not recursively\n         // removing a tx and all its descendants, eg when a transaction is\n         // confirmed in a block.\n-        // Here we only update statistics and not data in mapLinks (which\n-        // we need to preserve until we're finished with all operations that\n-        // need to traverse the mempool).\n+        // Here we only update statistics and not data in CTxMemPool::Parents\n+        // and CTxMemPoolEntry::Children (which we need to preserve until we're\n+        // finished with all operations that need to traverse the mempool).\n         for (txiter removeIt : entriesToRemove) {\n             setEntries setDescendants;\n             CalculateDescendants(removeIt, setDescendants);\n@@ -282,24 +285,26 @@ void CTxMemPool::UpdateForRemoveFromMempool(const setEntries &entriesToRemove, b\n         // should be a bit faster.\n         // However, if we happen to be in the middle of processing a reorg, then\n         // the mempool can be in an inconsistent state.  In this case, the set\n-        // of ancestors reachable via mapLinks will be the same as the set of\n-        // ancestors whose packages include this transaction, because when we\n-        // add a new transaction to the mempool in addUnchecked(), we assume it\n-        // has no children, and in the case of a reorg where that assumption is\n-        // false, the in-mempool children aren't linked to the in-block tx's\n-        // until UpdateTransactionsFromBlock() is called.\n+        // of ancestors reachable via GetMemPoolParents()/GetMemPoolChildren()\n+        // will be the same as the set of ancestors whose packages include this\n+        // transaction, because when we add a new transaction to the mempool in\n+        // addUnchecked(), we assume it has no children, and in the case of a\n+        // reorg where that assumption is false, the in-mempool children aren't\n+        // linked to the in-block tx's until UpdateTransactionsFromBlock() is\n+        // called.\n         // So if we're being called during a reorg, ie before\n-        // UpdateTransactionsFromBlock() has been called, then mapLinks[] will\n-        // differ from the set of mempool parents we'd calculate by searching,\n-        // and it's important that we use the mapLinks[] notion of ancestor\n-        // transactions as the set of things to update for removal.\n+        // UpdateTransactionsFromBlock() has been called, then\n+        // GetMemPoolParents()/GetMemPoolChildren() will differ from the set of\n+        // mempool parents we'd calculate by searching, and it's important that\n+        // we use the cached notion of ancestor transactions as the set of\n+        // things to update for removal.\n         CalculateMemPoolAncestors(entry, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy, false);\n         // Note that UpdateAncestorsOf severs the child links that point to\n         // removeIt in the entries for the parents of removeIt.\n         UpdateAncestorsOf(false, removeIt, setAncestors);\n     }\n     // After updating all the ancestor sizes, we can now sever the link between each\n-    // transaction being removed and any mempool children (ie, update setMemPoolParents\n+    // transaction being removed and any mempool children (ie, update CTxMemPoolEntry::m_parents\n     // for each direct child of a transaction being removed).\n     for (txiter removeIt : entriesToRemove) {\n         UpdateChildrenForRemoval(removeIt);\n@@ -359,7 +364,6 @@ void CTxMemPool::addUnchecked(const CTxMemPoolEntry &entry, setEntries &setAnces\n     // Used by AcceptToMemoryPool(), which DOES do\n     // all the appropriate checks.\n     indexed_transaction_set::iterator newit = mapTx.insert(entry).first;\n-    mapLinks.insert(make_pair(newit, TxLinks()));\n \n     // Update transaction for any feeDelta created by PrioritiseTransaction\n     // TODO: refactor so that the fee delta is calculated before inserting\n@@ -430,15 +434,14 @@ void CTxMemPool::removeUnchecked(txiter it, MemPoolRemovalReason reason)\n \n     totalTxSize -= it->GetTxSize();\n     cachedInnerUsage -= it->DynamicMemoryUsage();\n-    cachedInnerUsage -= memusage::DynamicUsage(mapLinks[it].parents) + memusage::DynamicUsage(mapLinks[it].children);\n-    mapLinks.erase(it);\n+    cachedInnerUsage -= memusage::DynamicUsage(it->GetMemPoolParentsConst()) + memusage::DynamicUsage(it->GetMemPoolChildrenConst());\n     mapTx.erase(it);\n     nTransactionsUpdated++;\n     if (minerPolicyEstimator) {minerPolicyEstimator->removeTx(hash, false);}\n }\n \n // Calculates descendants of entry that are not already in setDescendants, and adds to\n-// setDescendants. Assumes entryit is already a tx in the mempool and setMemPoolChildren\n+// setDescendants. Assumes entryit is already a tx in the mempool and CTxMemPoolEntry::m_children\n // is correct for tx and all descendants.\n // Also assumes that if an entry is in setDescendants already, then all\n // in-mempool descendants of it are already in setDescendants as well, so that we\n@@ -457,8 +460,9 @@ void CTxMemPool::CalculateDescendants(txiter entryit, setEntries& setDescendants\n         setDescendants.insert(it);\n         stage.erase(it);\n \n-        const setEntries &setChildren = GetMemPoolChildren(it);\n-        for (txiter childiter : setChildren) {\n+        const CTxMemPoolEntry::Children& children = it->GetMemPoolChildrenConst();\n+        for (const CTxMemPoolEntry& child : children) {\n+            txiter childiter = mapTx.iterator_to(child);\n             if (!setDescendants.count(childiter)) {\n                 stage.insert(childiter);\n             }\n@@ -584,7 +588,6 @@ void CTxMemPool::removeForBlock(const std::vector<CTransactionRef>& vtx, unsigne\n \n void CTxMemPool::_clear()\n {\n-    mapLinks.clear();\n     mapTx.clear();\n     mapNextTx.clear();\n     totalTxSize = 0;\n@@ -633,20 +636,17 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n         checkTotal += it->GetTxSize();\n         innerUsage += it->DynamicMemoryUsage();\n         const CTransaction& tx = it->GetTx();\n-        txlinksMap::const_iterator linksiter = mapLinks.find(it);\n-        assert(linksiter != mapLinks.end());\n-        const TxLinks &links = linksiter->second;\n-        innerUsage += memusage::DynamicUsage(links.parents) + memusage::DynamicUsage(links.children);\n+        innerUsage += memusage::DynamicUsage(it->GetMemPoolParentsConst()) + memusage::DynamicUsage(it->GetMemPoolChildrenConst());\n         bool fDependsWait = false;\n-        setEntries setParentCheck;\n+        CTxMemPoolEntry::Parents setParentCheck;\n         for (const CTxIn &txin : tx.vin) {\n             // Check that every mempool transaction's inputs refer to available coins, or other mempool tx's.\n             indexed_transaction_set::const_iterator it2 = mapTx.find(txin.prevout.hash);\n             if (it2 != mapTx.end()) {\n                 const CTransaction& tx2 = it2->GetTx();\n                 assert(tx2.vout.size() > txin.prevout.n && !tx2.vout[txin.prevout.n].IsNull());\n                 fDependsWait = true;\n-                setParentCheck.insert(it2);\n+                setParentCheck.insert(*it2);\n             } else {\n                 assert(pcoins->HaveCoin(txin.prevout));\n             }\n@@ -657,7 +657,11 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n             assert(it3->second == &tx);\n             i++;\n         }\n-        assert(setParentCheck == GetMemPoolParents(it));\n+        auto comp = [](const CTxMemPoolEntry& a, const CTxMemPoolEntry& b) -> bool {\n+            return a.GetTx().GetHash() == b.GetTx().GetHash();\n+        };\n+        assert(setParentCheck.size() == it->GetMemPoolParentsConst().size());\n+        assert(std::equal(setParentCheck.begin(), setParentCheck.end(), it->GetMemPoolParentsConst().begin(), comp));\n         // Verify ancestor state is correct.\n         setEntries setAncestors;\n         uint64_t nNoLimit = std::numeric_limits<uint64_t>::max();\n@@ -680,17 +684,18 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n         assert(it->GetModFeesWithAncestors() == nFeesCheck);\n \n         // Check children against mapNextTx\n-        CTxMemPool::setEntries setChildrenCheck;\n+        CTxMemPoolEntry::Children setChildrenCheck;\n         auto iter = mapNextTx.lower_bound(COutPoint(it->GetTx().GetHash(), 0));\n         uint64_t child_sizes = 0;\n         for (; iter != mapNextTx.end() && iter->first->hash == it->GetTx().GetHash(); ++iter) {\n             txiter childit = mapTx.find(iter->second->GetHash());\n             assert(childit != mapTx.end()); // mapNextTx points to in-mempool transactions\n-            if (setChildrenCheck.insert(childit).second) {\n+            if (setChildrenCheck.insert(*childit).second) {\n                 child_sizes += childit->GetTxSize();\n             }\n         }\n-        assert(setChildrenCheck == GetMemPoolChildren(it));\n+        assert(setChildrenCheck.size() == it->GetMemPoolChildrenConst().size());\n+        assert(std::equal(setChildrenCheck.begin(), setChildrenCheck.end(), it->GetMemPoolChildrenConst().begin(), comp));\n         // Also check to make sure size is greater than sum with immediate children.\n         // just a sanity check, not definitive that this calc is correct...\n         assert(it->GetSizeWithDescendants() >= child_sizes + it->GetTxSize());\n@@ -920,7 +925,7 @@ bool CCoinsViewMemPool::GetCoin(const COutPoint &outpoint, Coin &coin) const {\n size_t CTxMemPool::DynamicMemoryUsage() const {\n     LOCK(cs);\n     // Estimate the overhead of mapTx to be 15 pointers + an allocation, as no exact formula for boost::multi_index_contained is implemented.\n-    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 15 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + memusage::DynamicUsage(mapLinks) + memusage::DynamicUsage(vTxHashes) + cachedInnerUsage;\n+    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 15 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + memusage::DynamicUsage(vTxHashes) + cachedInnerUsage;\n }\n \n void CTxMemPool::RemoveUnbroadcastTx(const uint256& txid, const bool unchecked) {\n@@ -969,39 +974,35 @@ void CTxMemPool::addUnchecked(const CTxMemPoolEntry &entry, bool validFeeEstimat\n void CTxMemPool::UpdateChild(txiter entry, txiter child, bool add)\n {\n     AssertLockHeld(cs);\n-    setEntries s;\n-    if (add && mapLinks[entry].children.insert(child).second) {\n+    CTxMemPoolEntry::Children s;\n+    if (add && entry->GetMemPoolChildren().insert(*child).second) {\n         cachedInnerUsage += memusage::IncrementalDynamicUsage(s);\n-    } else if (!add && mapLinks[entry].children.erase(child)) {\n+    } else if (!add && entry->GetMemPoolChildren().erase(*child)) {\n         cachedInnerUsage -= memusage::IncrementalDynamicUsage(s);\n     }\n }\n \n void CTxMemPool::UpdateParent(txiter entry, txiter parent, bool add)\n {\n     AssertLockHeld(cs);\n-    setEntries s;\n-    if (add && mapLinks[entry].parents.insert(parent).second) {\n+    CTxMemPoolEntry::Parents s;\n+    if (add && entry->GetMemPoolParents().insert(*parent).second) {\n         cachedInnerUsage += memusage::IncrementalDynamicUsage(s);\n-    } else if (!add && mapLinks[entry].parents.erase(parent)) {\n+    } else if (!add && entry->GetMemPoolParents().erase(*parent)) {\n         cachedInnerUsage -= memusage::IncrementalDynamicUsage(s);\n     }\n }\n \n-const CTxMemPool::setEntries & CTxMemPool::GetMemPoolParents(txiter entry) const\n+const CTxMemPoolEntry::Parents & CTxMemPool::GetMemPoolParents(txiter entry) const\n {\n-    assert (entry != mapTx.end());\n-    txlinksMap::const_iterator it = mapLinks.find(entry);\n-    assert(it != mapLinks.end());\n-    return it->second.parents;\n+    assert(entry != mapTx.end());\n+    return entry->GetMemPoolParentsConst();\n }\n \n-const CTxMemPool::setEntries & CTxMemPool::GetMemPoolChildren(txiter entry) const\n+const CTxMemPoolEntry::Children & CTxMemPool::GetMemPoolChildren(txiter entry) const\n {\n-    assert (entry != mapTx.end());\n-    txlinksMap::const_iterator it = mapLinks.find(entry);\n-    assert(it != mapLinks.end());\n-    return it->second.children;\n+    assert(entry != mapTx.end());\n+    return entry->GetMemPoolChildrenConst();\n }\n \n CFeeRate CTxMemPool::GetMinFee(size_t sizelimit) const {\n@@ -1089,12 +1090,12 @@ uint64_t CTxMemPool::CalculateDescendantMaximum(txiter entry) const {\n         txiter candidate = candidates.back();\n         candidates.pop_back();\n         if (!counted.insert(candidate).second) continue;\n-        const setEntries& parents = GetMemPoolParents(candidate);\n+        const CTxMemPoolEntry::Parents& parents = candidate->GetMemPoolParentsConst();\n         if (parents.size() == 0) {\n             maximum = std::max(maximum, candidate->GetCountWithDescendants());\n         } else {\n-            for (txiter i : parents) {\n-                candidates.push_back(i);\n+            for (const CTxMemPoolEntry& i : parents) {\n+                candidates.push_back(mapTx.iterator_to(i));\n             }\n         }\n     }"
      },
      {
        "sha": "94179021208220d2358a2a18e504bbc61d17fcf4",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 29,
        "deletions": 14,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46d955d196043cc297834baeebce31ff778dff80/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46d955d196043cc297834baeebce31ff778dff80/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=46d955d196043cc297834baeebce31ff778dff80",
        "patch": "@@ -49,6 +49,20 @@ struct LockPoints\n     LockPoints() : height(0), time(0), maxInputBlock(nullptr) { }\n };\n \n+struct CompareIteratorByHash {\n+    // SFINAE for T where T is either a pointer type (e.g., a txiter) or a reference_wrapper<T>\n+    // (e.g. a wrapped CTxMemPoolEntry&)\n+    template <typename T>\n+    bool operator()(const std::reference_wrapper<T>& a, const std::reference_wrapper<T>& b) const\n+    {\n+        return a.get().GetTx().GetHash() < b.get().GetTx().GetHash();\n+    }\n+    template <typename T>\n+    bool operator()(const T& a, const T& b) const\n+    {\n+        return a->GetTx().GetHash() < b->GetTx().GetHash();\n+    }\n+};\n /** \\class CTxMemPoolEntry\n  *\n  * CTxMemPoolEntry stores data about the corresponding transaction, as well\n@@ -63,8 +77,16 @@ struct LockPoints\n \n class CTxMemPoolEntry\n {\n+public:\n+    typedef std::reference_wrapper<const CTxMemPoolEntry> CTxMemPoolEntryRef;\n+    // two aliases, should the types ever diverge\n+    typedef std::set<CTxMemPoolEntryRef, CompareIteratorByHash> Parents;\n+    typedef std::set<CTxMemPoolEntryRef, CompareIteratorByHash> Children;\n+\n private:\n     const CTransactionRef tx;\n+    mutable Parents m_parents;\n+    mutable Children m_children;\n     const CAmount nFee;             //!< Cached to avoid expensive parent-transaction lookups\n     const size_t nTxWeight;         //!< ... and avoid recomputing tx weight (also used for GetTxSize())\n     const size_t nUsageSize;        //!< ... and total memory usage\n@@ -127,6 +149,11 @@ class CTxMemPoolEntry\n     CAmount GetModFeesWithAncestors() const { return nModFeesWithAncestors; }\n     int64_t GetSigOpCostWithAncestors() const { return nSigOpCostWithAncestors; }\n \n+    const Parents& GetMemPoolParentsConst() const { return m_parents; }\n+    const Children& GetMemPoolChildrenConst() const { return m_children; }\n+    Parents& GetMemPoolParents() const { return m_parents; }\n+    Children& GetMemPoolChildren() const { return m_children; }\n+\n     mutable size_t vTxHashesIdx; //!< Index in mempool's vTxHashes\n     mutable uint64_t m_epoch; //!< epoch when last touched, useful for graph algorithms\n };\n@@ -547,26 +574,14 @@ class CTxMemPool\n     using txiter = indexed_transaction_set::nth_index<0>::type::const_iterator;\n     std::vector<std::pair<uint256, txiter>> vTxHashes GUARDED_BY(cs); //!< All tx witness hashes/entries in mapTx, in random order\n \n-    struct CompareIteratorByHash {\n-        bool operator()(const txiter &a, const txiter &b) const {\n-            return a->GetTx().GetHash() < b->GetTx().GetHash();\n-        }\n-    };\n     typedef std::set<txiter, CompareIteratorByHash> setEntries;\n \n-    const setEntries & GetMemPoolParents(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n-    const setEntries & GetMemPoolChildren(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    const CTxMemPoolEntry::Parents & GetMemPoolParents(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    const CTxMemPoolEntry::Children & GetMemPoolChildren(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n     uint64_t CalculateDescendantMaximum(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n private:\n     typedef std::map<txiter, setEntries, CompareIteratorByHash> cacheMap;\n \n-    struct TxLinks {\n-        setEntries parents;\n-        setEntries children;\n-    };\n-\n-    typedef std::map<txiter, TxLinks, CompareIteratorByHash> txlinksMap;\n-    txlinksMap mapLinks;\n \n     void UpdateParent(txiter entry, txiter parent, bool add) EXCLUSIVE_LOCKS_REQUIRED(cs);\n     void UpdateChild(txiter entry, txiter child, bool add) EXCLUSIVE_LOCKS_REQUIRED(cs);"
      }
    ]
  },
  {
    "sha": "296be8f58e02b39a58f017c52294aceed22c3ffd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyOTZiZThmNThlMDJiMzlhNThmMDE3YzUyMjk0YWNlZWQyMmMzZmZk",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "j@rubin.io",
        "date": "2020-01-22T00:24:42Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "j@rubin.io",
        "date": "2020-09-04T16:46:44Z"
      },
      "message": "Get rid of unused functions CTxMemPool::GetMemPoolChildren, CTxMemPool::GetMemPoolParents",
      "tree": {
        "sha": "77fbf2801efa44539fb9425acf18ffe46aa564db",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/77fbf2801efa44539fb9425acf18ffe46aa564db"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/296be8f58e02b39a58f017c52294aceed22c3ffd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/296be8f58e02b39a58f017c52294aceed22c3ffd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/296be8f58e02b39a58f017c52294aceed22c3ffd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/296be8f58e02b39a58f017c52294aceed22c3ffd/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "46d955d196043cc297834baeebce31ff778dff80",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/46d955d196043cc297834baeebce31ff778dff80",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/46d955d196043cc297834baeebce31ff778dff80"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 0,
      "deletions": 14
    },
    "files": [
      {
        "sha": "6a525c97db29d99a9cd2e81ccd940e5f2e6e4a67",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 12,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/296be8f58e02b39a58f017c52294aceed22c3ffd/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/296be8f58e02b39a58f017c52294aceed22c3ffd/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=296be8f58e02b39a58f017c52294aceed22c3ffd",
        "patch": "@@ -993,18 +993,6 @@ void CTxMemPool::UpdateParent(txiter entry, txiter parent, bool add)\n     }\n }\n \n-const CTxMemPoolEntry::Parents & CTxMemPool::GetMemPoolParents(txiter entry) const\n-{\n-    assert(entry != mapTx.end());\n-    return entry->GetMemPoolParentsConst();\n-}\n-\n-const CTxMemPoolEntry::Children & CTxMemPool::GetMemPoolChildren(txiter entry) const\n-{\n-    assert(entry != mapTx.end());\n-    return entry->GetMemPoolChildrenConst();\n-}\n-\n CFeeRate CTxMemPool::GetMinFee(size_t sizelimit) const {\n     LOCK(cs);\n     if (!blockSinceLastRollingFeeBump || rollingMinimumFeeRate == 0)"
      },
      {
        "sha": "8764bbcf13616ebe71dfa9efe4017c875875e5ab",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/296be8f58e02b39a58f017c52294aceed22c3ffd/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/296be8f58e02b39a58f017c52294aceed22c3ffd/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=296be8f58e02b39a58f017c52294aceed22c3ffd",
        "patch": "@@ -576,8 +576,6 @@ class CTxMemPool\n \n     typedef std::set<txiter, CompareIteratorByHash> setEntries;\n \n-    const CTxMemPoolEntry::Parents & GetMemPoolParents(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n-    const CTxMemPoolEntry::Children & GetMemPoolChildren(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n     uint64_t CalculateDescendantMaximum(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n private:\n     typedef std::map<txiter, setEntries, CompareIteratorByHash> cacheMap;"
      }
    ]
  }
]