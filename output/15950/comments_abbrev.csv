sipa,2019-05-03 23:08:37,Rewritten; a much simpler change was possible to accomplish the same.,https://github.com/bitcoin/bitcoin/pull/15950#issuecomment-489266711,489266711,
gmaxwell,2019-05-04 01:33:56,sha1 and ripemd160 need the same treatment.,https://github.com/bitcoin/bitcoin/pull/15950#issuecomment-489282920,489282920,
practicalswift,2019-05-04 08:48:33,"Very nice find! Thanks for fixing!\n\nSimilar issues:\n\nhttps://github.com/bitcoin/bitcoin/blob/f19a3b2ded4b86d859c0a464f550e0743af78ae3/src/uint256.cpp#L44-L52\n\nhttps://github.com/bitcoin/bitcoin/blob/f19a3b2ded4b86d859c0a464f550e0743af78ae3/src/crypto/sha1.cpp#L166\n\nhttps://github.com/bitcoin/bitcoin/blob/f19a3b2ded4b86d859c0a464f550e0743af78ae3/src/crypto/ripemd160.cpp#L259\n\nWh",https://github.com/bitcoin/bitcoin/pull/15950#issuecomment-489307953,489307953,
sipa,2019-05-04 21:05:04,@gmaxwell Extended to SHA1 and RIPEMD160.,https://github.com/bitcoin/bitcoin/pull/15950#issuecomment-489365507,489365507,
sipa,2019-05-04 21:07:15,"@practicalswift I don't see the issue with the uint256 code (as far as I can see, all pointers are to objects or one-past the object which is legal). I also can't find a reference for requiring that the `memset` argument needs to be a writable pointer if length is 0 (it needs to be a valid pointer, but it is; just not a writable one).\n\nAlso no reason to explain me why fixing UB is a good idea;",https://github.com/bitcoin/bitcoin/pull/15950#issuecomment-489365660,489365660,
l2a5b1,2019-05-05 18:54:36,"Concept ACK\n\n> I don't see the issue with the uint256 code (as far as I can see, all pointers are to objects or one-past the object which is legal)\n\n@sipa see  #14734",https://github.com/bitcoin/bitcoin/pull/15950#issuecomment-489453257,489453257,
practicalswift,2019-05-05 20:44:09,"> I don't see the issue with the uint256 code (as far as I can see, all pointers are to objects or one-past the object which is legal).\n\nConsider the case `SetHex(""1000000000000000000000000000000000000000000000000000000000000000"")`:\n\nWhen the reverse processing reaches the leading `1` we have `psz == pbegin` and the following happens:\n\n```\n*p1 |= ((unsigned char)HexDigit(*psz--) << 4",https://github.com/bitcoin/bitcoin/pull/15950#issuecomment-489461791,489461791,
laanwj,2019-05-06 09:47:11,utACK 7a3426096fede34607695ee1523b795784a3a40f,https://github.com/bitcoin/bitcoin/pull/15950#issuecomment-489565294,489565294,
jonasschnelli,2019-05-06 09:57:58,utACK 7a3426096fede34607695ee1523b795784a3a40f,https://github.com/bitcoin/bitcoin/pull/15950#issuecomment-489568004,489568004,
MarcoFalke,2019-05-06 13:32:18,"> Consider the case SetHex(""1000000000000000000000000000000000000000000000000000000000000000""):\n\nCould add a unit testcase for this if that exact code path is not already covered?",https://github.com/bitcoin/bitcoin/pull/15950#issuecomment-489621530,489621530,
sipa,2019-05-06 22:12:05,"Ok, let's discuss the uint256 issue further in #14734.",https://github.com/bitcoin/bitcoin/pull/15950#issuecomment-489802253,489802253,
practicalswift,2019-05-07 11:37:13,utACK c01c065b9ded3399a6a480f15543827dd5e8eb4d,https://github.com/bitcoin/bitcoin/pull/15950#issuecomment-490043040,490043040,
gmaxwell,2019-05-08 20:24:05,ACK,https://github.com/bitcoin/bitcoin/pull/15950#issuecomment-490637241,490637241,
promag,2019-05-06 17:52:42,"nit, space",https://github.com/bitcoin/bitcoin/pull/15950#discussion_r281289266,281289266,src/crypto/sha1.cpp
sipa,2019-05-06 22:11:39,Fixed.,https://github.com/bitcoin/bitcoin/pull/15950#discussion_r281382996,281382996,src/crypto/sha1.cpp
