[
  {
    "sha": "4b82ff11135a0fb3000148f8ba2502c2b9417fbc",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0YjgyZmYxMTEzNWEwZmIzMDAwMTQ4ZjhiYTI1MDJjMmI5NDE3ZmJj",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2011-06-07T22:28:53Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2011-06-09T13:11:03Z"
      },
      "message": "Add wallet privkey encryption.\n\nThis commit adds support for ekeys, or encrypted private keys, to the wallet.\nAll keys are stored in memory in their encrypted form and thus the passphrase\nis required from the user to spend coins, or to create new addresses.\n\nKeys are encrypted with AES-256-CBC through OpenSSL's EVP library. The key is\ncalculated via EVP_BytesToKey using AES256 with 1000 rounds.\n\nWhen the user is attempting to call RPC functions which require the password\nto unlock the wallet, an error will be returned unless they call\nwalletpassword <password> <time to keep key in memory> first.\n\nA topupkeypool command has been added which tops up the users keypool\n(requiring the password via walletpassword first).\nkeypoolsize has been added to the output of getinfo to show the user the\nnumber of keys left before they need to specify their password and call\ntopupkeypool.\n\nA walletpasswordchange <oldpassword> <newpassword> has been added to allow\nthe user to change their password via RPC.\n\nWhenever keying material (unencrypted private keys, the user's password, the\nwallet's AES key) is stored unencrypted in memory, any reasonable attempt is\nmade to mlock/VirtualLock that memory before storing the keying material.\nThis is not true in several (commented) cases where mlock/VirtualLocking the\nmemory is not possible.\n\nAlthough encryption of private keys in memory can be very useful on desktop\nsystems (as some small amount of protection against stupid viruses), on an\nRPC server, the password is entered fairly insecurely. Thus, the only main\nadvantage encryption has for RPC servers is for RPC servers that do not spend\ncoins, except in rare cases, eg. a webserver of a merchant which only receives\npayment except for cases of manual intervention.\n\nThanks to jgarzik for the original patch and sipa for all his input.",
      "tree": {
        "sha": "1ff864ed3af2b909118c008d29977e1490f226a9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1ff864ed3af2b909118c008d29977e1490f226a9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4b82ff11135a0fb3000148f8ba2502c2b9417fbc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4b82ff11135a0fb3000148f8ba2502c2b9417fbc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4b82ff11135a0fb3000148f8ba2502c2b9417fbc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "60152827e35102cd6faf450ba5400ed4364c2e62",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/60152827e35102cd6faf450ba5400ed4364c2e62",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/60152827e35102cd6faf450ba5400ed4364c2e62"
      }
    ],
    "stats": {
      "total": 1463,
      "additions": 1392,
      "deletions": 71
    },
    "files": [
      {
        "sha": "3bd3918a56fa3e67899cf6ba9c7f22a965cc9696",
        "filename": "share/uiproject.fbp",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/share/uiproject.fbp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/share/uiproject.fbp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/uiproject.fbp?ref=4b82ff11135a0fb3000148f8ba2502c2b9417fbc",
        "patch": "@@ -162,6 +162,21 @@\n                         <event name=\"OnMenuSelection\">OnMenuOptionsChangeYourAddress</event>\r\n                         <event name=\"OnUpdateUI\"></event>\r\n                     </object>\r\n+                    <object class=\"wxMenuItem\" expanded=\"1\">\r\n+                        <property name=\"bitmap\"></property>\r\n+                        <property name=\"checked\">0</property>\r\n+                        <property name=\"enabled\">1</property>\r\n+                        <property name=\"help\"></property>\r\n+                        <property name=\"id\">wxID_ANY</property>\r\n+                        <property name=\"kind\">wxITEM_NORMAL</property>\r\n+                        <property name=\"label\">Change Wallet &amp;Password...</property>\r\n+                        <property name=\"name\">m_menuOptionsChangeWalletPassword</property>\r\n+                        <property name=\"permission\">none</property>\r\n+                        <property name=\"shortcut\"></property>\r\n+                        <property name=\"unchecked_bitmap\"></property>\r\n+                        <event name=\"OnMenuSelection\">OnMenuOptionsChangeWalletPassword</event>\r\n+                        <event name=\"OnUpdateUI\"></event>\r\n+                    </object>\r\n                     <object class=\"wxMenuItem\" expanded=\"1\">\r\n                         <property name=\"bitmap\"></property>\r\n                         <property name=\"checked\">0</property>\r"
      },
      {
        "sha": "699eb55a1bf4d1f2f846f70bd7d37db3cfef81c5",
        "filename": "src/crypter.cpp",
        "status": "added",
        "additions": 176,
        "deletions": 0,
        "changes": 176,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/crypter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/crypter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypter.cpp?ref=4b82ff11135a0fb3000148f8ba2502c2b9417fbc",
        "patch": "@@ -0,0 +1,176 @@\n+#include <openssl/aes.h>\n+#include <openssl/evp.h>\n+#include <vector>\n+#include <string>\n+#ifdef __WXMSW__\n+#include <windows.h>\n+#else\n+#include <sys/mman.h>\n+#endif\n+\n+#include \"crypter.h\"\n+#include \"main.h\"\n+#include \"util.h\"\n+\n+bool CCrypter::SetKey(const std::string &strKeyData)\n+{\n+    std::vector<unsigned char> vchKeyData(strKeyData.size());\n+    unsigned char chNotIV[32];\n+\n+    // Try to keep the keydata out of swap (and be a bit over-careful to keep the IV that we don't even use out of swap)\n+    // Note that this does nothing about suspend-to-disk (which will put all our key data on disk)\n+    // Note as well that at no point in this program is any attempt made to prevent stealing of keys by reading the memory of the running process.  \n+    MLOCK(vchKeyData[0], vchKeyData.size());\n+    MLOCK(chNotIV[0], sizeof chNotIV);\n+    MLOCK(chKey[0], sizeof chKey);\n+\n+    memcpy(&vchKeyData[0], &strKeyData[0], strKeyData.size());\n+\n+    int i = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha256(), (unsigned char *)\"bitcoin is fun! and I prefer much longer salts, though I don't think they offer any real advantage\",\n+                           (unsigned char *)&vchKeyData[0], vchKeyData.size(), 1000, chKey, chNotIV);\n+\n+    std::fill(vchKeyData.begin(), vchKeyData.end(), '\\0');\n+    memset(&chNotIV, 0, sizeof chNotIV);\n+\n+    if (i != 32)\n+    {\n+        memset(&chKey, 0, sizeof chKey);\n+        return false;\n+    }\n+\n+    fCorrectKey = false;\n+    fKeySet = true;\n+    return true;\n+}\n+\n+bool CCrypter::Encrypt(const std::vector<unsigned char> &vchPlaintext, const unsigned char chIV[32], std::vector<unsigned char> &vchCiphertext)\n+{\n+    if (!fKeySet)\n+        return false;\n+\n+    // max ciphertext len for a n bytes of plaintext is\n+    // n + AES_BLOCK_SIZE - 1 bytes\n+    int nLen = vchPlaintext.size();\n+    int nCLen = nLen + AES_BLOCK_SIZE, nFLen = 0;\n+    vchCiphertext = std::vector<unsigned char> (nCLen);\n+\n+    EVP_CIPHER_CTX ctx;\n+\n+    EVP_CIPHER_CTX_init(&ctx);\n+    EVP_EncryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV);\n+\n+    EVP_EncryptUpdate(&ctx, &vchCiphertext[0], &nCLen, &vchPlaintext[0], nLen);\n+    EVP_EncryptFinal_ex(&ctx, (&vchCiphertext[0])+nCLen, &nFLen);\n+\n+    EVP_CIPHER_CTX_cleanup(&ctx);\n+\n+    vchCiphertext.resize(nCLen + nFLen);\n+    return true;\n+}\n+\n+bool CCrypter::Decrypt(const std::vector<unsigned char> &vchCiphertext, const unsigned char chIV[32], std::vector<unsigned char> &vchPlaintext)\n+{\n+    if (!fKeySet)\n+        return false;\n+\n+    // plaintext will always be equal to or lesser than length of ciphertext\n+    int nLen = vchCiphertext.size();\n+    int nPLen = nLen, nFLen = 0;\n+\n+    vchPlaintext = std::vector<unsigned char> (nPLen);\n+    MLOCK(vchPlaintext[0], vchPlaintext.size());\n+\n+    EVP_CIPHER_CTX ctx;\n+\n+    EVP_CIPHER_CTX_init(&ctx);\n+    EVP_DecryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV);\n+\n+    EVP_DecryptUpdate(&ctx, &vchPlaintext[0], &nPLen, &vchCiphertext[0], nLen);\n+    EVP_DecryptFinal_ex(&ctx, (&vchPlaintext[0])+nPLen, &nFLen);\n+\n+    EVP_CIPHER_CTX_cleanup(&ctx);\n+\n+    vchPlaintext.resize(nPLen + nFLen);\n+    return true;\n+}\n+\n+bool CheckKeyOnPrivKey(PubToPrivKeyMap::iterator &pairFirstKey)\n+{\n+    uint256 hashPubKey = Hash((*pairFirstKey).first.begin(), (*pairFirstKey).first.end());\n+    unsigned char chIV[32];\n+    memcpy(&chIV, &hashPubKey, 32);\n+\n+    std::vector<unsigned char> vchPlaintext;\n+    std::vector<unsigned char> vchCiphertext;\n+    vchCiphertext.resize((*pairFirstKey).second.size());\n+    memcpy(&vchCiphertext[0], &(*pairFirstKey).second[0], vchCiphertext.size());\n+\n+    if (!cWalletCrypter.Decrypt(vchCiphertext, chIV, vchPlaintext)) //mlock()s vchPlaintext for us\n+        return false;\n+\n+    CPrivKey vchPrivKey;\n+    vchPrivKey.resize(vchPlaintext.size());\n+    MLOCK(vchPrivKey[0], vchPrivKey.size());\n+\n+    memcpy(&vchPrivKey[0], &vchPlaintext[0], vchPlaintext.size());\n+    std::fill(vchPlaintext.begin(), vchPlaintext.end(), '\\0');\n+\n+    CKey key;\n+    if (!key.SetPrivKey(vchPrivKey))\n+    {\n+        std::fill(vchPrivKey.begin(), vchPrivKey.end(), '\\0');\n+        return false;\n+    }\n+    std::vector<unsigned char> vchDerivedPubKey = key.GetPubKey();\n+    if (vchDerivedPubKey.size() < 1 || vchDerivedPubKey != (*pairFirstKey).first)\n+    {\n+        std::fill(vchPrivKey.begin(), vchPrivKey.end(), '\\0');\n+        return false;\n+    }\n+\n+    std::fill(vchPrivKey.begin(), vchPrivKey.end(), '\\0');\n+    return true;\n+}\n+\n+bool CCrypter::CheckKey(const bool fVerifyAllAddresses)\n+{\n+    if (fCorrectKeyForAllKeys)\n+        return true;\n+    if (fCorrectKey && !fVerifyAllAddresses)\n+        return true;\n+\n+    if (mapKeys.size() == 0)\n+    {\n+        fCorrectKey = true;\n+        return true;\n+    }\n+\n+    PubToPrivKeyMap::iterator pairFirstKey = mapKeys.begin();\n+\n+    if (!fVerifyAllAddresses)\n+    {\n+        fCorrectKey = CheckKeyOnPrivKey(pairFirstKey);\n+        return fCorrectKey;\n+    }\n+    else\n+    {\n+        fCorrectKeyForAllKeys = true;\n+        fCorrectKey = true;\n+        for (; pairFirstKey != mapKeys.end(); pairFirstKey++)\n+        {\n+            fCorrectKeyForAllKeys = CheckKeyOnPrivKey(pairFirstKey);\n+            fCorrectKey = fCorrectKeyForAllKeys;\n+            if (!fCorrectKey)\n+                return false;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+void CCrypter::CleanKey()\n+{\n+    memset(&chKey, 0, sizeof chKey);\n+    fCorrectKey = false;\n+    fKeySet = false;\n+}"
      },
      {
        "sha": "31a088cd8a842214c118f77cdba73ec2c35c70b5",
        "filename": "src/crypter.h",
        "status": "added",
        "additions": 33,
        "deletions": 0,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/crypter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/crypter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypter.h?ref=4b82ff11135a0fb3000148f8ba2502c2b9417fbc",
        "patch": "@@ -0,0 +1,33 @@\n+#ifndef __CRYPTER_H__\n+#define __CRYPTER_H__\n+\n+class CCrypter\n+{\n+private:\n+    unsigned char chKey[32];\n+    bool fCorrectKey;\n+    bool fCorrectKeyForAllKeys;\n+\n+public:\n+    bool fKeySet;\n+    bool SetKey(const std::string &strKeyData);\n+    bool Encrypt(const std::vector<unsigned char> &vchPlaintext, const unsigned char chIV[32], std::vector<unsigned char> &vchCiphertext);\n+    bool Decrypt(const std::vector<unsigned char> &vchCiphertext, const unsigned char chIV[32], std::vector<unsigned char> &vchPlaintext);\n+\n+    // Only call after wallet has been loaded\n+    bool CheckKey(const bool fVerifyAllAddresses = false);\n+\n+    void CleanKey();\n+    CCrypter()\n+    {\n+        fCorrectKey = false;\n+        fKeySet = false;\n+    }\n+\n+    ~CCrypter()\n+    {\n+        CleanKey();\n+    }\n+};\n+\n+#endif /* __CRYPTER_H__ */"
      },
      {
        "sha": "627bd130d13426c1ae71b8b3343649fa1bdf8110",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 378,
        "deletions": 31,
        "changes": 409,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=4b82ff11135a0fb3000148f8ba2502c2b9417fbc",
        "patch": "@@ -747,16 +747,52 @@ bool CWalletDB::LoadWallet()\n                 if (nNumber > nAccountingEntryNumber)\n                     nAccountingEntryNumber = nNumber;\n             }\n+            else if (strType == \"ekey\")\n+            {\n+                vector<unsigned char> vchPubKey;\n+                ssKey >> vchPubKey;\n+\n+                vector<unsigned char> vchCiphertext;\n+                ssValue >> vchCiphertext;\n+\n+                CPrivKey vchEncPrivKey;\n+                vchEncPrivKey.resize(vchCiphertext.size());\n+                memcpy(&vchEncPrivKey[0], &vchCiphertext[0], vchCiphertext.size());\n+\n+                mapKeys[vchPubKey] = vchEncPrivKey;\n+                mapPubKeys[Hash160(vchPubKey)] = vchPubKey;\n+            }\n             else if (strType == \"key\" || strType == \"wkey\")\n             {\n                 vector<unsigned char> vchPubKey;\n                 ssKey >> vchPubKey;\n                 CWalletKey wkey;\n                 if (strType == \"key\")\n-                    ssValue >> wkey.vchPrivKey;\n+                    ssValue >> wkey.vchPrivKey; //WARNING: Key might end up in swap here\n                 else\n                     ssValue >> wkey;\n \n+                if (!GetBoolArg(\"-nocrypt\"))\n+                {\n+                    MLOCK(wkey.vchPrivKey[0], wkey.vchPrivKey.size());\n+\n+                    uint256 hashPubKey = Hash(vchPubKey.begin(), vchPubKey.end());\n+                    unsigned char chIV[32];\n+                    memcpy(&chIV, &hashPubKey, 32);\n+\n+                    vector<unsigned char> vchPlaintext(wkey.vchPrivKey.size());\n+                    MLOCK(vchPlaintext[0], vchPlaintext.size());\n+\n+                    memcpy(&vchPlaintext[0], &wkey.vchPrivKey[0], wkey.vchPrivKey.size());\n+                    fill(wkey.vchPrivKey.begin(), wkey.vchPrivKey.end(), '\\0');\n+\n+                    vector<unsigned char> vchCiphertext;\n+                    cWalletCrypter.Encrypt(vchPlaintext, chIV, vchCiphertext);\n+                    fill(vchPlaintext.begin(), vchPlaintext.end(), '\\0');\n+                    wkey.vchPrivKey = CPrivKey(vchCiphertext.size());\n+                    memcpy(&wkey.vchPrivKey[0], &vchCiphertext[0], vchCiphertext.size());\n+                }\n+\n                 mapKeys[vchPubKey] = wkey.vchPrivKey;\n                 mapPubKeys[Hash160(vchPubKey)] = vchPubKey;\n             }\n@@ -835,27 +871,288 @@ bool LoadWallet(bool& fFirstRunRet)\n         return false;\n     fFirstRunRet = vchDefaultKey.empty();\n \n-    if (mapKeys.count(vchDefaultKey))\n+    if (!mapKeys.count(vchDefaultKey))\n     {\n-        // Set keyUser\n-        keyUser.SetPubKey(vchDefaultKey);\n-        keyUser.SetPrivKey(mapKeys[vchDefaultKey]);\n+        // Create new Key and set as default key\n+        vchDefaultKey = GenerateNewKey();\n+        if (!SetAddressBookName(PubKeyToAddress(vchDefaultKey), \"\"))\n+            return false;\n+        CWalletDB().WriteDefaultKey(vchDefaultKey);\n+    }\n+\n+    CreateThread(ThreadFlushWalletDB, NULL);\n+    return true;\n+}\n+\n+void CWalletDB::WalletKeyStatus(bool& fHaveUnencKeys, bool& fHaveEncKeys)\n+{\n+    // Get cursor\n+    Dbc* pcursor = GetCursor();\n+\n+    if (!pcursor)\n+        return;\n+\n+    fHaveUnencKeys = false;\n+    fHaveEncKeys = false;\n+\n+    loop\n+    {\n+        // Read next record\n+        CDataStream ssKey;\n+        CDataStream ssValue;\n+        int ret = ReadAtCursor(pcursor, ssKey, ssValue);\n+        if (ret == DB_NOTFOUND)\n+            break;\n+        else if (ret != 0)\n+            return;\n+\n+        // Unserialize\n+        // Taking advantage of the fact that pair serialization\n+        // is just the two items serialized one after the other\n+        string strType;\n+        ssKey >> strType;\n+        if (strType == \"key\" || strType == \"wkey\")\n+            fHaveUnencKeys = true;\n+        else if (strType == \"ekey\")\n+            fHaveEncKeys = true;\n+    }\n+    pcursor->close();\n+\n+    return;\n+}\n+\n+void WalletStatus(bool& fHaveUnencKeys, bool& fHaveEncKeys, bool& fWalletExists)\n+{\n+    string dataDir = GetDataDir() + \"/wallet.dat\";\n+    FILE* pFile = fopen(dataDir.c_str(), \"r\");\n+    if (pFile==NULL)\n+    {\n+        fHaveUnencKeys = false;\n+        fHaveEncKeys = false;\n+        fWalletExists = false;\n     }\n     else\n     {\n-        // Create new keyUser and set as default key\n-        RandAddSeedPerfmon();\n+        fWalletExists = true;\n+        fclose(pFile);\n+        CWalletDB().WalletKeyStatus(fHaveUnencKeys, fHaveEncKeys);\n+    }\n+}\n \n-        CWalletDB walletdb;\n-        vchDefaultKey = GetKeyFromKeyPool();\n-        walletdb.WriteDefaultKey(vchDefaultKey);\n-        walletdb.WriteName(PubKeyToAddress(vchDefaultKey), \"\");\n+bool CWalletDB::EncryptUnencKeys()\n+{\n+    if (GetBoolArg(\"-nocrypt\"))\n+        return false;\n+\n+    // Get cursor\n+    Dbc* pcursor = GetCursor();\n+    if (!pcursor)\n+        return false;\n+\n+    vector< vector <unsigned char> > keysToWrite;\n+\n+    loop\n+    {\n+        // Read next record\n+        CDataStream ssKey;\n+        CDataStream ssValue;\n+        int ret = ReadAtCursor(pcursor, ssKey, ssValue);\n+        if (ret == DB_NOTFOUND)\n+            break;\n+        else if (ret != 0)\n+            return false;\n+\n+        // Unserialize\n+        // Taking advantage of the fact that pair serialization\n+        // is just the two items serialized one after the other\n+        string strType;\n+        ssKey >> strType;\n+        if (strType == \"key\" || strType == \"wkey\")\n+        {\n+            vector<unsigned char> vchPubKey;\n+            ssKey >> vchPubKey;\n+            vector<unsigned char> vchPrivKey;\n+            if (strType == \"key\")\n+            {\n+                ssValue >> vchPrivKey; //WARNING: Key might end up in swap here\n+                MLOCK(vchPrivKey[0], vchPrivKey.size());\n+            }\n+            else\n+            {\n+                CWalletKey wkey;\n+                ssValue >> wkey; //WARNING: Key might end up in swap here\n+                MLOCK(wkey.vchPrivKey[0], wkey.vchPrivKey.size());\n+\n+                vchPrivKey = vector<unsigned char>(wkey.vchPrivKey.size());\n+                MLOCK(vchPrivKey[0], vchPrivKey.size());\n+                memcpy(&vchPrivKey[0], &wkey.vchPrivKey[0], wkey.vchPrivKey.size());\n+                fill(wkey.vchPrivKey.begin(), wkey.vchPrivKey.end(), '\\0');\n+            }\n+\n+            uint256 pubKeyHash = Hash(vchPubKey.begin(), vchPubKey.end());\n+            unsigned char chIV[32];\n+            memcpy(&chIV, &pubKeyHash, 32);\n+\n+            vector<unsigned char> vchCiphertext;\n+            if (!cWalletCrypter.Encrypt(vchPrivKey, chIV, vchCiphertext))\n+                return false;\n+\n+            fill(vchPrivKey.begin(), vchPrivKey.end(), '\\0');\n+\n+            keysToWrite.push_back(vchPubKey);\n+            keysToWrite.push_back(vchCiphertext);\n+        }\n+    }\n+    pcursor->close();\n+\n+    TxnBegin();\n+    for (int i = 0; i < keysToWrite.size()-1; i+=2)\n+    {\n+        WriteKey(keysToWrite[i], keysToWrite[i+1]);\n+        Erase(make_pair(string(\"key\"), keysToWrite[i]));\n+        Erase(make_pair(string(\"wkey\"), keysToWrite[i]));\n+    }\n+    TxnCommit();\n+\n+    return true;\n+}\n+\n+bool EncryptUnencKeys()\n+{\n+    return CWalletDB().EncryptUnencKeys();\n+}\n+\n+bool CWalletDB::ChangeWalletPass(CCrypter& cNewWalletCrypter)\n+{\n+    if (GetBoolArg(\"-nocrypt\"))\n+        return false;\n+\n+    // Get cursor\n+    Dbc* pcursor = GetCursor();\n+    if (!pcursor)\n+        return false;\n+\n+    vector< vector <unsigned char> > keysToWrite;\n+\n+    loop\n+    {\n+        // Read next record\n+        CDataStream ssKey;\n+        CDataStream ssValue;\n+        int ret = ReadAtCursor(pcursor, ssKey, ssValue);\n+        if (ret == DB_NOTFOUND)\n+            break;\n+        else if (ret != 0)\n+            return false;\n+\n+        // Unserialize\n+        // Taking advantage of the fact that pair serialization\n+        // is just the two items serialized one after the other\n+        string strType;\n+        ssKey >> strType;\n+        if (strType == \"ekey\")\n+        {\n+            vector<unsigned char> vchPubKey;\n+            ssKey >> vchPubKey;\n+\n+            vector<unsigned char> vchCiphertext;\n+            ssValue >> vchCiphertext;\n+\n+            uint256 hashPubKey = Hash(vchPubKey.begin(), vchPubKey.end());\n+            unsigned char chIV[32];\n+            memcpy(&chIV, &hashPubKey, 32);\n+\n+            vector<unsigned char> vchPlaintext;\n+            if (!cWalletCrypter.Decrypt(vchCiphertext, chIV, vchPlaintext)) //mlock()s vchPlaintext for us\n+                return false;\n+\n+            try\n+            {\n+                CPrivKey vchPrivKey;\n+                vchPrivKey.resize(vchPlaintext.size());\n+                MLOCK(vchPrivKey[0], vchPrivKey.size());\n+                memcpy(&vchPrivKey[0], &vchPlaintext[0], vchPlaintext.size());\n+\n+                CKey key;\n+                if (!key.SetPrivKey(vchPrivKey))\n+                {\n+                    fill(vchPlaintext.begin(), vchPlaintext.end(), '\\0');\n+                    fill(vchPrivKey.begin(), vchPrivKey.end(), '\\0');\n+                    return false;\n+                }\n+                vector<unsigned char> vchDerivedPubKey = key.GetPubKey();\n+                if (vchDerivedPubKey.size() < 1 || vchDerivedPubKey != vchPubKey)\n+                {\n+                    fill(vchPlaintext.begin(), vchPlaintext.end(), '\\0');\n+                    fill(vchPrivKey.begin(), vchPrivKey.end(), '\\0');\n+                    return false;\n+                }\n+                fill(vchPrivKey.begin(), vchPrivKey.end(), '\\0');\n+            }\n+            catch (key_error e)\n+            {\n+                return false;\n+            }\n+\n+            if (!cNewWalletCrypter.Encrypt(vchPlaintext, chIV, vchCiphertext))\n+            {\n+                fill(vchPlaintext.begin(), vchPlaintext.end(), '\\0');\n+                return false;\n+            }\n+\n+            fill(vchPlaintext.begin(), vchPlaintext.end(), '\\0');\n+\n+            keysToWrite.push_back(vchPubKey);\n+            keysToWrite.push_back(vchCiphertext);\n+        }\n+    }\n+    pcursor->close();\n+\n+    TxnBegin();\n+    for (int i = 0; i < keysToWrite.size()-1; i+=2)\n+    {\n+        Erase(make_pair(string(\"ekey\"), keysToWrite[i]));\n+        WriteKey(keysToWrite[i], keysToWrite[i+1]);\n+    }\n+    TxnCommit();\n+\n+    BOOST_FOREACH(PubToPrivKeyMap::value_type pairKey, mapKeys)\n+    {\n+        uint256 hashPubKey = Hash(pairKey.first.begin(), pairKey.first.end());\n+        unsigned char chIV[32];\n+        memcpy(&chIV, &hashPubKey, 32);\n+\n+        std::vector<unsigned char> vchPlaintext;\n+        std::vector<unsigned char> vchCiphertext;\n+        vchCiphertext.resize(pairKey.second.size());\n+        memcpy(&vchCiphertext[0], &pairKey.second[0], vchCiphertext.size());\n+\n+        if (!cWalletCrypter.Decrypt(vchCiphertext, chIV, vchPlaintext))\n+            throw 1;\n+\n+        if (!cNewWalletCrypter.Encrypt(vchPlaintext, chIV, vchCiphertext))\n+        {\n+            fill(vchPlaintext.begin(), vchPlaintext.end(), '\\0');\n+            throw 1;\n+        }\n+        fill(vchPlaintext.begin(), vchPlaintext.end(), '\\0');\n+\n+        CPrivKey vchPrivKey(vchCiphertext.size());\n+        memcpy(&vchPrivKey[0], &vchCiphertext[0], vchCiphertext.size());\n+        mapKeys[pairKey.first] = vchPrivKey;\n     }\n \n-    CreateThread(ThreadFlushWalletDB, NULL);\n     return true;\n }\n \n+bool ChangeWalletPass(CCrypter& cNewWalletCrypter)\n+{\n+    if (!cWalletCrypter.CheckKey(true))\n+        return false;\n+\n+    return CWalletDB().ChangeWalletPass(cNewWalletCrypter);\n+}\n+\n void ThreadFlushWalletDB(void* parg)\n {\n     static bool fOneThread;\n@@ -950,39 +1247,78 @@ void BackupWallet(const string& strDest)\n     }\n }\n \n-\n-void CWalletDB::ReserveKeyFromKeyPool(int64& nIndex, CKeyPool& keypool)\n+bool CWalletDB::TopUpKeyPool()\n {\n-    nIndex = -1;\n-    keypool.vchPubKey.clear();\n+    if (!GetBoolArg(\"-nocrypt\") && (!cWalletCrypter.fKeySet || !cWalletCrypter.CheckKey()))\n+        return false;\n+\n     CRITICAL_BLOCK(cs_main)\n     CRITICAL_BLOCK(cs_mapWallet)\n     CRITICAL_BLOCK(cs_setKeyPool)\n     {\n         // Top up key pool\n-        int64 nTargetSize = max(GetArg(\"-keypool\", 100), (int64)0);\n+        int64 nTargetSize = max(GetArg(\"-keypool\", 100), GetBoolArg(\"-nocrypt\") ? (int64)0 : (int64)1);\n         while (setKeyPool.size() < nTargetSize+1)\n         {\n             int64 nEnd = 1;\n             if (!setKeyPool.empty())\n                 nEnd = *(--setKeyPool.end()) + 1;\n             if (!Write(make_pair(string(\"pool\"), nEnd), CKeyPool(GenerateNewKey())))\n-                throw runtime_error(\"ReserveKeyFromKeyPool() : writing generated key failed\");\n+                throw runtime_error(\"TopUpKeyPool() : writing generated key failed\");\n             setKeyPool.insert(nEnd);\n             printf(\"keypool added key %\"PRI64d\", size=%d\\n\", nEnd, setKeyPool.size());\n         }\n+    }\n+    return true;\n+}\n+\n+bool TopUpKeyPool()\n+{\n+    return CWalletDB().TopUpKeyPool();\n+}\n+\n+void ThreadTopUpKeyPool(void* parg)\n+{\n+    static bool fOneKeyPoolThread;\n+    if (fOneKeyPoolThread)\n+        return;\n+    fOneKeyPoolThread = true;\n+    CRITICAL_BLOCK(cs_setKeyPool)\n+    {\n+        TopUpKeyPool();\n+        if (*((bool*)parg))\n+            cWalletCrypter.CleanKey();\n+    }\n+    free(parg);\n+}\n+\n \n+bool CWalletDB::ReserveKeyFromKeyPool(int64& nIndex, CKeyPool& keypool)\n+{\n+    nIndex = -1;\n+    keypool.vchPubKey.clear();\n+    CRITICAL_BLOCK(cs_main)\n+    CRITICAL_BLOCK(cs_mapWallet)\n+    CRITICAL_BLOCK(cs_setKeyPool)\n+    {\n         // Get the oldest key\n-        assert(!setKeyPool.empty());\n-        nIndex = *(setKeyPool.begin());\n-        setKeyPool.erase(setKeyPool.begin());\n-        if (!Read(make_pair(string(\"pool\"), nIndex), keypool))\n+        if (setKeyPool.empty() && !GetBoolArg(\"-nocrypt\"))\n+            return false;\n+        else\n+        {\n+            if (GetBoolArg(\"-nocrypt\"))\n+                TopUpKeyPool();\n+            nIndex = *(setKeyPool.begin());\n+            setKeyPool.erase(setKeyPool.begin());\n+            if (!Read(make_pair(string(\"pool\"), nIndex), keypool))\n             throw runtime_error(\"ReserveKeyFromKeyPool() : read failed\");\n-        if (!mapKeys.count(keypool.vchPubKey))\n-            throw runtime_error(\"ReserveKeyFromKeyPool() : unknown key in key pool\");\n-        assert(!keypool.vchPubKey.empty());\n-        printf(\"keypool reserve %\"PRI64d\"\\n\", nIndex);\n+            if (!mapKeys.count(keypool.vchPubKey))\n+                throw runtime_error(\"ReserveKeyFromKeyPool() : unknown key in key pool\");\n+            assert(!keypool.vchPubKey.empty());\n+            printf(\"keypool reserve %\"PRI64d\"\\n\", nIndex);\n+        }\n     }\n+    return true;\n }\n \n void CWalletDB::KeepKey(int64 nIndex)\n@@ -1004,13 +1340,17 @@ void CWalletDB::ReturnKey(int64 nIndex)\n     printf(\"keypool return %\"PRI64d\"\\n\", nIndex);\n }\n \n-vector<unsigned char> GetKeyFromKeyPool()\n+vector<unsigned char> GetOrReuseKeyFromPool()\n {\n     CWalletDB walletdb;\n     int64 nIndex = 0;\n     CKeyPool keypool;\n-    walletdb.ReserveKeyFromKeyPool(nIndex, keypool);\n-    walletdb.KeepKey(nIndex);\n+    if (walletdb.ReserveKeyFromKeyPool(nIndex, keypool))\n+        walletdb.KeepKey(nIndex);\n+    else\n+    {\n+        return vchDefaultKey;\n+    }\n     return keypool.vchPubKey;\n }\n \n@@ -1019,7 +1359,14 @@ int64 GetOldestKeyPoolTime()\n     CWalletDB walletdb;\n     int64 nIndex = 0;\n     CKeyPool keypool;\n-    walletdb.ReserveKeyFromKeyPool(nIndex, keypool);\n-    walletdb.ReturnKey(nIndex);\n+    if (walletdb.ReserveKeyFromKeyPool(nIndex, keypool))\n+        walletdb.ReturnKey(nIndex);\n+    else\n+        return GetTime();\n     return keypool.nTime;\n }\n+\n+int GetKeyPoolSize()\n+{\n+    return setKeyPool.size();\n+}"
      },
      {
        "sha": "5a8c4aa30b89bc18e79beef80ccfaf10247f0536",
        "filename": "src/db.h",
        "status": "modified",
        "additions": 32,
        "deletions": 4,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.h?ref=4b82ff11135a0fb3000148f8ba2502c2b9417fbc",
        "patch": "@@ -37,7 +37,7 @@ extern DbEnv dbenv;\n \n \n extern void DBFlush(bool fShutdown);\n-extern std::vector<unsigned char> GetKeyFromKeyPool();\n+extern std::vector<unsigned char> GetOrReuseKeyFromPool();\n extern int64 GetOldestKeyPoolTime();\n \n \n@@ -410,6 +410,12 @@ class CWalletDB : public CDB\n         return Read(std::make_pair(std::string(\"key\"), vchPubKey), vchPrivKey);\n     }\n \n+    bool WriteKey(const std::vector<unsigned char>& vchPubKey, const std::vector<unsigned char>& vchCiphertext)\n+    {\n+        nWalletDBUpdated++;\n+        return Write(std::make_pair(std::string(\"ekey\"), vchPubKey), vchCiphertext,false);\n+    }\n+\n     bool WriteKey(const std::vector<unsigned char>& vchPubKey, const CPrivKey& vchPrivKey)\n     {\n         nWalletDBUpdated++;\n@@ -460,17 +466,28 @@ class CWalletDB : public CDB\n     void ListAccountCreditDebit(const std::string& strAccount, std::list<CAccountingEntry>& acentries);\n \n     bool LoadWallet();\n+    void WalletKeyStatus(bool& fHaveUnencKeys, bool& fHaveEncKeys);\n+    bool EncryptUnencKeys();\n+    bool ChangeWalletPass(CCrypter& cNewWalletCrypter);\n+    bool TopUpKeyPool();\n+\n protected:\n-    void ReserveKeyFromKeyPool(int64& nIndex, CKeyPool& keypool);\n+    bool ReserveKeyFromKeyPool(int64& nIndex, CKeyPool& keypool);\n     void KeepKey(int64 nIndex);\n     static void ReturnKey(int64 nIndex);\n     friend class CReserveKey;\n-    friend std::vector<unsigned char> GetKeyFromKeyPool();\n+    friend std::vector<unsigned char> GetOrReuseKeyFromPool();\n     friend int64 GetOldestKeyPoolTime();\n };\n \n bool LoadWallet(bool& fFirstRunRet);\n+void WalletStatus(bool& fHaveUnencKeys, bool& fHaveEncKeys, bool& fWalletExists);\n+bool EncryptUnencKeys();\n+bool ChangeWalletPass(CCrypter& cNewWalletCrypter);\n void BackupWallet(const std::string& strDest);\n+bool TopUpKeyPool();\n+void ThreadTopUpKeyPool(void* parg);\n+int GetKeyPoolSize();\n \n inline bool SetAddressBookName(const std::string& strAddress, const std::string& strName)\n {\n@@ -482,6 +499,7 @@ class CReserveKey\n protected:\n     int64 nIndex;\n     std::vector<unsigned char> vchPubKey;\n+    bool fIsFromKeyPool;\n public:\n     CReserveKey()\n     {\n@@ -499,15 +517,23 @@ class CReserveKey\n         if (nIndex == -1)\n         {\n             CKeyPool keypool;\n-            CWalletDB().ReserveKeyFromKeyPool(nIndex, keypool);\n+            fIsFromKeyPool = CWalletDB().ReserveKeyFromKeyPool(nIndex, keypool);\n+            if (!fIsFromKeyPool)\n+            {\n+                vchPubKey = vchDefaultKey;\n+                return vchDefaultKey;\n+            }\n             vchPubKey = keypool.vchPubKey;\n         }\n         assert(!vchPubKey.empty());\n+        fIsFromKeyPool = true;\n         return vchPubKey;\n     }\n \n     void KeepKey()\n     {\n+        if (!fIsFromKeyPool)\n+            return;\n         if (nIndex != -1)\n             CWalletDB().KeepKey(nIndex);\n         nIndex = -1;\n@@ -516,6 +542,8 @@ class CReserveKey\n \n     void ReturnKey()\n     {\n+        if (!fIsFromKeyPool)\n+            return;\n         if (nIndex != -1)\n             CWalletDB::ReturnKey(nIndex);\n         nIndex = -1;"
      },
      {
        "sha": "902c3be8e1a4be0bf1d335be5fbfac0936fe17aa",
        "filename": "src/headers.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/headers.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/headers.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/headers.h?ref=4b82ff11135a0fb3000148f8ba2502c2b9417fbc",
        "patch": "@@ -115,6 +115,7 @@\n #include \"uint256.h\"\n #include \"util.h\"\n #include \"key.h\"\n+#include \"crypter.h\"\n #include \"bignum.h\"\n #include \"base58.h\"\n #include \"script.h\""
      },
      {
        "sha": "4b1d33a756bca56c8b02fd34d347d8d2c849ef19",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 101,
        "deletions": 1,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=4b82ff11135a0fb3000148f8ba2502c2b9417fbc",
        "patch": "@@ -178,7 +178,9 @@ bool AppInit2(int argc, char* argv[])\n             \"  -rpcallowip=<ip> \\t\\t  \" + _(\"Allow JSON-RPC connections from specified IP address\\n\") +\n             \"  -rpcconnect=<ip> \\t  \"   + _(\"Send commands to node running on <ip> (default: 127.0.0.1)\\n\") +\n             \"  -keypool=<n>     \\t  \"   + _(\"Set key pool size to <n> (default: 100)\\n\") +\n-            \"  -rescan          \\t  \"   + _(\"Rescan the block chain for missing wallet transactions\\n\");\n+            \"  -rescan          \\t  \"   + _(\"Rescan the block chain for missing wallet transactions\\n\") +\n+            \"  -nocrypt         \\t  \"   + _(\"Don't encrypt the private keys in the wallet.\\n\") +\n+            \"  -encryptkeys     \\t  \"   + _(\"Automatically encrypt old, unencrypted keys.\\n\");\n \n #ifdef USE_SSL\n         strUsage += string() +\n@@ -365,10 +367,101 @@ bool AppInit2(int argc, char* argv[])\n     printf(\"Loading wallet...\\n\");\n     nStart = GetTimeMillis();\n     bool fFirstRun;\n+    bool fHaveUnencKeysInWallet;\n+    bool fHaveEncKeysInWallet;\n+    bool fWalletExists;\n+\n+    WalletStatus(fHaveUnencKeysInWallet, fHaveEncKeysInWallet, fWalletExists);\n+    if ((fHaveUnencKeysInWallet || !fWalletExists) && !GetBoolArg(\"-nocrypt\"))\n+    {\n+        // obtain wallet encrypt/decrypt key, from passphrase\n+        string strWalletPass = \"\";\n+        strWalletPass.reserve(100);\n+        // keep the passphrase out of swap (or atleast the first 100 characters of it)\n+        // note that this doesn't account for the possibility of suspend-to-disk\n+        // the password could still touch swap while being entered in wxGetPasswordFromUser (below)\n+        // or by sitting in the environment/being copied from the environment.\n+        MLOCK(strWalletPass[0], strWalletPass.capacity());\n+\n+        if (getenv(\"WALLET_PASSPHRASE\") != NULL)\n+            strWalletPass = getenv(\"WALLET_PASSPHRASE\");\n+\n+#ifdef GUI\n+        if (!strWalletPass.size())\n+        {\n+            strWalletPass = wxGetPasswordFromUser(_(\"Enter a password to encrypt/decrypt all addresses created after this point.\\nIf you do not want to encrypt new private keys, please start the client with the -nocrypt flag set.\\nWARNING: If you lose this password, no one, not even the Bitcoin developers can get you your Bitcoins back.\"),\n+                                                  _(\"Password\"));\n+        }\n+#endif\n+\n+        if (!strWalletPass.size())\n+        {\n+#ifdef GUI\n+            wxMessageBox(_(\"Please supply a wallet encryption/decryption password.\"), \"Bitcoin\");\n+#else\n+            fprintf(stderr, \"Please supply a wallet encryption password via the WALLET_PASSPHRASE environment varible to encrypt keys in memory.\\n\");\n+#endif\n+            return false;\n+        }\n+\n+        if (!cWalletCrypter.SetKey(strWalletPass))\n+        {\n+#ifdef GUI\n+            wxMessageBox(_(\"Wallet decryption setup failed\"), \"Bitcoin\");\n+#else\n+            fprintf(stderr, \"Wallet decryption setup failed\\n\");\n+#endif\n+            fill(strWalletPass.begin(), strWalletPass.end(), '\\0');\n+            return false;\n+        }\n+\n+        fill(strWalletPass.begin(), strWalletPass.end(), '\\0');\n+    }\n+\n+    if (GetBoolArg(\"-nocrypt\") && fHaveEncKeysInWallet)\n+    {\n+#ifdef GUI\n+        wxMessageBox(_(\"You specified the -nocrypt option, but the wallet has encrypted private keys, bitcoin will now exit.\"), \"Bitcoin\");\n+#else\n+        fprintf(stderr, \"Error: -nocrypt was specified, but the wallet has encrypted private keys.\\n\");\n+#endif\n+        return false;\n+    }\n+\n     if (!LoadWallet(fFirstRun))\n         strErrors += _(\"Error loading wallet.dat      \\n\");\n     printf(\" wallet      %15\"PRI64d\"ms\\n\", GetTimeMillis() - nStart);\n \n+    if ((fHaveUnencKeysInWallet || !fWalletExists) && !GetBoolArg(\"-nocrypt\") && !cWalletCrypter.CheckKey(true))\n+    {\n+#ifdef GUI\n+        wxMessageBox(_(\"The password entered for the wallet decryption was incorrect.\"), \"Bitcoin\");\n+#else\n+        fprintf(stderr, \"Error: The password entered for the wallet decryption was incorrect.\\n\");\n+#endif\n+        return false;\n+    }\n+\n+    if (fHaveUnencKeysInWallet && !GetBoolArg(\"-nocrypt\"))\n+    {\n+#ifdef GUI\n+        int nResponse = wxMessageBox(_(\"Would you like to encrypt the remaining unencrypted keys in your wallet (Recommended)?\\nNote: This means older version of Bitcoin will not be able to read any of your wallet.\"),\n+                                     \"Bitcoin\", wxYES_NO);\n+\n+        if (nResponse == wxYES || GetBoolArg(\"-encryptkeys\"))\n+        {\n+            EncryptUnencKeys();\n+        }\n+#else\n+        if (GetBoolArg(\"-encryptkeys\"))\n+        {\n+            EncryptUnencKeys();\n+        }\n+        else\n+            fprintf(stderr, \"It is recommended that you restart bitcoin with -encryptkeys to automatically encrypt the existing unencrypted keys in your wallet.\\n\");\n+#endif\n+    }\n+\n     CBlockIndex *pindexRescan = pindexBest;\n     if (GetBoolArg(\"-rescan\"))\n         pindexRescan = pindexGenesisBlock;\n@@ -511,6 +604,13 @@ bool AppInit2(int argc, char* argv[])\n         SetStartOnSystemStartup(true);\n #endif\n \n+    if ((cWalletCrypter.fKeySet && !GetBoolArg(\"-nocrypt\")) || GetBoolArg(\"-nocrypt\"))\n+    {\n+        //topup the keypool here as we already have the key\n+        bool *fCleanKey = new bool(true);\n+        CreateThread(ThreadTopUpKeyPool, fCleanKey);\n+    }\n+\n #ifndef GUI\n     while (1)\n         Sleep(5000);"
      },
      {
        "sha": "d45ffa69edb6b4d408b696fc88a6de1976369094",
        "filename": "src/key.h",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/key.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/key.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.h?ref=4b82ff11135a0fb3000148f8ba2502c2b9417fbc",
        "patch": "@@ -102,16 +102,17 @@ class CKey\n         return true;\n     }\n \n-    CPrivKey GetPrivKey() const\n+    bool GetPrivKey(CPrivKey& vchPrivKeyRet) const\n     {\n         unsigned int nSize = i2d_ECPrivateKey(pkey, NULL);\n         if (!nSize)\n             throw key_error(\"CKey::GetPrivKey() : i2d_ECPrivateKey failed\");\n-        CPrivKey vchPrivKey(nSize, 0);\n-        unsigned char* pbegin = &vchPrivKey[0];\n+        vchPrivKeyRet = CPrivKey (nSize, 0);\n+        MLOCK(vchPrivKeyRet[0], vchPrivKeyRet.size());\n+        unsigned char* pbegin = &vchPrivKeyRet[0];\n         if (i2d_ECPrivateKey(pkey, &pbegin) != nSize)\n             throw key_error(\"CKey::GetPrivKey() : i2d_ECPrivateKey returned unexpected size\");\n-        return vchPrivKey;\n+        return true;\n     }\n \n     bool SetPubKey(const std::vector<unsigned char>& vchPubKey)"
      },
      {
        "sha": "68152ebc12f4616f7ceb89ebe9114d5a9b2874f7",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 53,
        "deletions": 9,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=4b82ff11135a0fb3000148f8ba2502c2b9417fbc",
        "patch": "@@ -39,10 +39,11 @@ map<uint256, CWalletTx> mapWallet;\n vector<uint256> vWalletUpdated;\n CCriticalSection cs_mapWallet;\n \n+CCrypter cWalletCrypter;\n+CCriticalSection cs_walletCrypter;\n map<vector<unsigned char>, CPrivKey> mapKeys;\n map<uint160, vector<unsigned char> > mapPubKeys;\n CCriticalSection cs_mapKeys;\n-CKey keyUser;\n \n map<uint256, int> mapRequestCount;\n CCriticalSection cs_mapRequestCount;\n@@ -82,19 +83,62 @@ int fUseUPnP = false;\n \n bool AddKey(const CKey& key)\n {\n-    CRITICAL_BLOCK(cs_mapKeys)\n+    if (!GetBoolArg(\"-nocrypt\"))\n     {\n-        mapKeys[key.GetPubKey()] = key.GetPrivKey();\n-        mapPubKeys[Hash160(key.GetPubKey())] = key.GetPubKey();\n+        if (!cWalletCrypter.fKeySet || !cWalletCrypter.CheckKey())\n+            return false;\n+\n+        CPrivKey vchPrivKey;\n+        if (!key.GetPrivKey(vchPrivKey)) //mlock()s vchPrivKey for us\n+            return false;\n+        vector<unsigned char> vchPlaintext(vchPrivKey.size());\n+        MLOCK(vchPlaintext[0], vchPlaintext.size());\n+        memcpy(&vchPlaintext[0], &vchPrivKey[0], vchPrivKey.size());\n+        fill(vchPrivKey.begin(), vchPrivKey.end(), '\\0');\n+\n+        vector<unsigned char> pubKey = key.GetPubKey();\n+        uint256 pubKeyHash = Hash(pubKey.begin(), pubKey.end());\n+        unsigned char chIV[32];\n+        memcpy(&chIV, &pubKeyHash, 32);\n+\n+        vector<unsigned char> vchCiphertext;\n+        if (!cWalletCrypter.Encrypt(vchPlaintext, chIV, vchCiphertext))\n+        {\n+            fill(vchPlaintext.begin(), vchPlaintext.end(), '\\0');\n+            return false;\n+        }\n+        fill(vchPlaintext.begin(), vchPlaintext.end(), '\\0');\n+\n+        CPrivKey vchEncPrivKey(vchCiphertext.size());\n+        memcpy(&vchEncPrivKey[0], &vchCiphertext[0], vchCiphertext.size());\n+\n+        CRITICAL_BLOCK(cs_mapKeys)\n+        {\n+            mapKeys[key.GetPubKey()] = vchEncPrivKey;\n+            mapPubKeys[Hash160(key.GetPubKey())] = key.GetPubKey();\n+        }\n+\n+        return CWalletDB().WriteKey(key.GetPubKey(), vchCiphertext);\n+    }\n+    else\n+    {\n+        CPrivKey vchPrivKey;\n+        if (!key.GetPrivKey(vchPrivKey))\n+            return false;\n+        CRITICAL_BLOCK(cs_mapKeys)\n+        {\n+            mapKeys[key.GetPubKey()] = vchPrivKey;\n+            mapPubKeys[Hash160(key.GetPubKey())] = key.GetPubKey();\n+        }\n+        return CWalletDB().WriteKey(key.GetPubKey(), vchPrivKey);\n     }\n-    return CWalletDB().WriteKey(key.GetPubKey(), key.GetPrivKey());\n }\n \n vector<unsigned char> GenerateNewKey()\n {\n     RandAddSeedPerfmon();\n     CKey key;\n-    key.MakeNewKey();\n+    key.MakeNewKey(); //WARNING: Key might end up in swap here as OpenSSL/CKey does not mlock keys\n     if (!AddKey(key))\n         throw runtime_error(\"GenerateNewKey() : AddKey failed\");\n     return key.GetPubKey();\n@@ -156,10 +200,10 @@ bool AddToWallet(const CWalletTx& wtxIn)\n         scriptDefaultKey.SetBitcoinAddress(vchDefaultKey);\n         BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n         {\n-            if (txout.scriptPubKey == scriptDefaultKey)\n+            if (txout.scriptPubKey == scriptDefaultKey && ((!GetBoolArg(\"-nocrypt\") && GetKeyPoolSize() != 0) || GetBoolArg(\"-nocrypt\")))\n             {\n                 CWalletDB walletdb;\n-                vchDefaultKey = GetKeyFromKeyPool();\n+                vchDefaultKey = GetOrReuseKeyFromPool();\n                 walletdb.WriteDefaultKey(vchDefaultKey);\n                 walletdb.WriteName(PubKeyToAddress(vchDefaultKey), \"\");\n             }\n@@ -2784,7 +2828,7 @@ bool ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n         // Keep giving the same key to the same ip until they use it\n         if (!mapReuseKey.count(pfrom->addr.ip))\n-            mapReuseKey[pfrom->addr.ip] = GetKeyFromKeyPool();\n+            mapReuseKey[pfrom->addr.ip] = GetOrReuseKeyFromPool();\n \n         // Send back approval of order and pubkey to use\n         CScript scriptPubKey;"
      },
      {
        "sha": "691c8f31252f96c10a4ec5c75dea3942f88073d8",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=4b82ff11135a0fb3000148f8ba2502c2b9417fbc",
        "patch": "@@ -63,6 +63,7 @@ extern CCriticalSection cs_mapAddressBook;\n extern std::vector<unsigned char> vchDefaultKey;\n extern double dHashesPerSec;\n extern int64 nHPSTimerStart;\n+extern CCrypter cWalletCrypter;\n \n // Settings\n extern int fGenerateBitcoins;\n@@ -2058,9 +2059,10 @@ extern std::map<uint256, CTransaction> mapTransactions;\n extern std::map<uint256, CWalletTx> mapWallet;\n extern std::vector<uint256> vWalletUpdated;\n extern CCriticalSection cs_mapWallet;\n-extern std::map<std::vector<unsigned char>, CPrivKey> mapKeys;\n+extern CCriticalSection cs_walletCrypter;\n+typedef std::map<std::vector<unsigned char>, CPrivKey> PubToPrivKeyMap;\n+extern PubToPrivKeyMap mapKeys;\n extern std::map<uint160, std::vector<unsigned char> > mapPubKeys;\n extern CCriticalSection cs_mapKeys;\n-extern CKey keyUser;\n \n #endif"
      },
      {
        "sha": "1e655ad0e767063f7abe8e05bca9a648207c69b1",
        "filename": "src/makefile.mingw",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/makefile.mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/makefile.mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.mingw?ref=4b82ff11135a0fb3000148f8ba2502c2b9417fbc",
        "patch": "@@ -33,7 +33,7 @@ DEFS=-DWIN32 -D__WXMSW__ -D_WINDOWS -DNOPCH -DUSE_SSL\n DEBUGFLAGS=-g -D__WXDEBUG__\n CFLAGS=-mthreads -O2 -w -Wno-invalid-offsetof -Wformat $(DEBUGFLAGS) $(DEFS) $(INCLUDEPATHS)\n HEADERS=headers.h strlcpy.h serialize.h uint256.h util.h key.h bignum.h base58.h \\\n-    script.h db.h net.h irc.h main.h rpc.h uibase.h ui.h noui.h init.h\n+    script.h db.h net.h irc.h main.h rpc.h uibase.h ui.h noui.h init.h crypter.h\n \n ifdef USE_UPNP\n  INCLUDEPATHS += -I\"C:\\upnpc-exe-win32-20110215\"\n@@ -53,6 +53,7 @@ OBJS= \\\n     obj/main.o \\\n     obj/rpc.o \\\n     obj/init.o \\\n+    obj/crypter.o \\\n     cryptopp/obj/sha.o \\\n     cryptopp/obj/cpu.o\n "
      },
      {
        "sha": "67684e1212bb370832da0fb08c60181ae00c5195",
        "filename": "src/makefile.osx",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/makefile.osx",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/makefile.osx",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.osx?ref=4b82ff11135a0fb3000148f8ba2502c2b9417fbc",
        "patch": "@@ -33,7 +33,7 @@ DEBUGFLAGS=-g -DwxDEBUG_LEVEL=0\n # ppc doesn't work because we don't support big-endian\n CFLAGS=-mmacosx-version-min=10.5 -arch i386 -arch x86_64 -O3 -Wno-invalid-offsetof -Wformat $(DEBUGFLAGS) $(DEFS) $(INCLUDEPATHS)\n HEADERS=headers.h strlcpy.h serialize.h uint256.h util.h key.h bignum.h base58.h \\\n-    script.h db.h net.h irc.h main.h rpc.h uibase.h ui.h noui.h init.h\n+    script.h db.h net.h irc.h main.h rpc.h uibase.h ui.h noui.h init.h crypter.h\n \n OBJS= \\\n     obj/util.o \\\n@@ -44,6 +44,7 @@ OBJS= \\\n     obj/main.o \\\n     obj/rpc.o \\\n     obj/init.o \\\n+    obj/crypter.o \\\n     cryptopp/obj/sha.o \\\n     cryptopp/obj/cpu.o\n "
      },
      {
        "sha": "aae5a053d396e62ece8c97a08ab46e583260207b",
        "filename": "src/makefile.unix",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/makefile.unix",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/makefile.unix",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.unix?ref=4b82ff11135a0fb3000148f8ba2502c2b9417fbc",
        "patch": "@@ -39,7 +39,7 @@ LIBS+= \\\n DEBUGFLAGS=-g -D__WXDEBUG__\n CXXFLAGS=-O2 -Wno-invalid-offsetof -Wformat $(DEBUGFLAGS) $(DEFS)\n HEADERS=headers.h strlcpy.h serialize.h uint256.h util.h key.h bignum.h base58.h \\\n-    script.h db.h net.h irc.h main.h rpc.h uibase.h ui.h noui.h init.h\n+    script.h db.h net.h irc.h main.h rpc.h uibase.h ui.h noui.h init.h crypter.h\n \n OBJS= \\\n     obj/util.o \\\n@@ -50,6 +50,7 @@ OBJS= \\\n     obj/main.o \\\n     obj/rpc.o \\\n     obj/init.o \\\n+    obj/crypter.o \\\n     cryptopp/obj/sha.o \\\n     cryptopp/obj/cpu.o\n "
      },
      {
        "sha": "831eabac25c7f23dd9f665a0df3fbab003240c2a",
        "filename": "src/rpc.cpp",
        "status": "modified",
        "additions": 250,
        "deletions": 9,
        "changes": 259,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc.cpp?ref=4b82ff11135a0fb3000148f8ba2502c2b9417fbc",
        "patch": "@@ -303,6 +303,7 @@ Value getinfo(const Array& params, bool fHelp)\n     obj.push_back(Pair(\"hashespersec\",  gethashespersec(params, false)));\n     obj.push_back(Pair(\"testnet\",       fTestNet));\n     obj.push_back(Pair(\"keypoololdest\", (boost::int64_t)GetOldestKeyPoolTime()));\n+    obj.push_back(Pair(\"keypoolsize\",   GetKeyPoolSize()));\n     obj.push_back(Pair(\"paytxfee\",      ValueFromAmount(nTransactionFee)));\n     obj.push_back(Pair(\"errors\",        GetWarnings(\"statusbar\")));\n     return obj;\n@@ -318,13 +319,16 @@ Value getnewaddress(const Array& params, bool fHelp)\n             \"If [account] is specified (recommended), it is added to the address book \"\n             \"so payments received with the address will be credited to [account].\");\n \n+    if (GetKeyPoolSize() < 1)\n+        throw JSONRPCError(-12, \"Error: Keypool ran out, please call topupkeypool first\");\n+\n     // Parse the account first so we don't generate a key if there's an error\n     string strAccount;\n     if (params.size() > 0)\n         strAccount = AccountFromValue(params[0]);\n \n     // Generate a new key that is added to wallet\n-    string strAddress = PubKeyToAddress(GetKeyFromKeyPool());\n+    string strAddress = PubKeyToAddress(GetOrReuseKeyFromPool());\n \n     SetAddressBookName(strAddress, strAccount);\n     return strAddress;\n@@ -361,10 +365,16 @@ string GetAccountAddress(string strAccount, bool bForceNew=false)\n     // Generate a new key\n     if (account.vchPubKey.empty() || bForceNew)\n     {\n-        account.vchPubKey = GetKeyFromKeyPool();\n-        string strAddress = PubKeyToAddress(account.vchPubKey);\n-        SetAddressBookName(strAddress, strAccount);\n-        walletdb.WriteAccount(strAccount, account);\n+        if (!GetBoolArg(\"-nocrypt\") && GetKeyPoolSize() == 0)\n+            if (!walletdb.ReadAccount(strAccount, account))\n+                throw JSONRPCError(-13, \"Error: Please enter the wallet password with walletpassword first.\");\n+        else\n+        {\n+            account.vchPubKey = GetOrReuseKeyFromPool();\n+            string strAddress = PubKeyToAddress(account.vchPubKey);\n+            SetAddressBookName(strAddress, strAccount);\n+            walletdb.WriteAccount(strAccount, account);\n+        }\n     }\n \n     walletdb.TxnCommit();\n@@ -499,7 +509,12 @@ Value settxfee(const Array& params, bool fHelp)\n \n Value sendtoaddress(const Array& params, bool fHelp)\n {\n-    if (fHelp || params.size() < 2 || params.size() > 4)\n+    if (!GetBoolArg(\"-nocrypt\") && (fHelp || params.size() < 2 || params.size() > 4))\n+        throw runtime_error(\n+            \"sendtoaddress <bitcoinaddress> <amount> [comment] [comment-to]\\n\"\n+            \"<amount> is a real and is rounded to the nearest 0.00000001\\n\"\n+            \"requires wallet password to be set with walletpassword first\");\n+    if (GetBoolArg(\"-nocrypt\") && (fHelp || params.size() < 2 || params.size() > 4))\n         throw runtime_error(\n             \"sendtoaddress <bitcoinaddress> <amount> [comment] [comment-to]\\n\"\n             \"<amount> is a real and is rounded to the nearest 0.00000001\");\n@@ -517,7 +532,12 @@ Value sendtoaddress(const Array& params, bool fHelp)\n         wtx.mapValue[\"to\"]      = params[3].get_str();\n \n     CRITICAL_BLOCK(cs_main)\n+    CRITICAL_BLOCK(cs_walletCrypter)\n     {\n+        if (!cWalletCrypter.fKeySet)\n+            throw JSONRPCError(-13, \"Error: Please enter the wallet password with walletpassword first.\");\n+        if (!cWalletCrypter.CheckKey())\n+            throw JSONRPCError(-14, \"Error: The wallet password entered was incorrect.\");\n         string strError = SendMoneyToBitcoinAddress(strAddress, nAmount, wtx);\n         if (strError != \"\")\n             throw JSONRPCError(-4, strError);\n@@ -762,10 +782,15 @@ Value movecmd(const Array& params, bool fHelp)\n \n Value sendfrom(const Array& params, bool fHelp)\n {\n-    if (fHelp || params.size() < 3 || params.size() > 6)\n+    if (!GetBoolArg(\"-nocrypt\") && (fHelp || params.size() < 3 || params.size() > 6))\n         throw runtime_error(\n             \"sendfrom <fromaccount> <tobitcoinaddress> <amount> [minconf=1] [comment] [comment-to]\\n\"\n-            \"<amount> is a real and is rounded to the nearest 0.00000001\");\n+            \"<amount> is a real and is rounded to the nearest 0.00000001\\n\"\n+            \"requires wallet password to be set with walletpassword first\");\n+    if (GetBoolArg(\"-nocrypt\") && (fHelp || params.size() < 3 || params.size() > 6))\n+        throw runtime_error(\n+            \"sendfrom <fromaccount> <tobitcoinaddress> <amount> [minconf=1] [comment] [comment-to]\\n\"\n+            \"<amount> is a real and is rounded to the nearest 0.00000001\\n\");\n \n     string strAccount = AccountFromValue(params[0]);\n     string strAddress = params[1].get_str();\n@@ -783,7 +808,13 @@ Value sendfrom(const Array& params, bool fHelp)\n \n     CRITICAL_BLOCK(cs_main)\n     CRITICAL_BLOCK(cs_mapWallet)\n+    CRITICAL_BLOCK(cs_walletCrypter)\n     {\n+        if (!cWalletCrypter.fKeySet)\n+            throw JSONRPCError(-13, \"Error: Please enter the wallet password with walletpassword first.\");\n+        if (!cWalletCrypter.CheckKey())\n+            throw JSONRPCError(-14, \"Error: The wallet password entered was incorrect.\");\n+\n         // Check funds\n         int64 nBalance = GetAccountBalance(strAccount, nMinDepth);\n         if (nAmount > nBalance)\n@@ -798,12 +829,18 @@ Value sendfrom(const Array& params, bool fHelp)\n     return wtx.GetHash().GetHex();\n }\n \n+\n Value sendmany(const Array& params, bool fHelp)\n {\n-    if (fHelp || params.size() < 2 || params.size() > 4)\n+    if (GetBoolArg(\"-nocrypt\") && (fHelp || params.size() < 2 || params.size() > 4))\n         throw runtime_error(\n             \"sendmany <fromaccount> {address:amount,...} [minconf=1] [comment]\\n\"\n             \"amounts are double-precision floating point numbers\");\n+    if (!GetBoolArg(\"-nocrypt\") && (fHelp || params.size() < 2 || params.size() > 4))\n+        throw runtime_error(\n+            \"sendmany <fromaccount> {address:amount,...} [minconf=1] [comment]\\n\"\n+            \"amounts are double-precision floating point numbers\\n\"\n+            \"requires wallet password to be set with walletpassword first\");\n \n     string strAccount = AccountFromValue(params[0]);\n     Object sendTo = params[1].get_obj();\n@@ -840,7 +877,13 @@ Value sendmany(const Array& params, bool fHelp)\n \n     CRITICAL_BLOCK(cs_main)\n     CRITICAL_BLOCK(cs_mapWallet)\n+    CRITICAL_BLOCK(cs_walletCrypter)\n     {\n+        if (!cWalletCrypter.fKeySet)\n+            throw JSONRPCError(-13, \"Error: Please enter the wallet password with walletpassword first.\");\n+        if (!cWalletCrypter.CheckKey())\n+            throw JSONRPCError(-14, \"Error: The wallet password entered was incorrect.\");\n+\n         // Check funds\n         int64 nBalance = GetAccountBalance(strAccount, nMinDepth);\n         if (totalAmount > nBalance)\n@@ -1270,6 +1313,199 @@ Value backupwallet(const Array& params, bool fHelp)\n }\n \n \n+Value topupkeypool(const Array& params, bool fHelp)\n+{\n+    if (!GetBoolArg(\"-nocrypt\") && (fHelp || params.size() > 0))\n+        throw runtime_error(\n+            \"topupkeypool\\n\"\n+            \"Fills the keypool, requires wallet password to be set.\");\n+    if (GetBoolArg(\"-nocrypt\") && (fHelp || params.size() > 0))\n+        throw runtime_error(\n+            \"topupkeypool\\n\"\n+            \"Fills the keypool.\");\n+\n+    if (!GetBoolArg(\"-nocrypt\"))\n+    {\n+        CRITICAL_BLOCK(cs_walletCrypter)\n+        {\n+            if (!cWalletCrypter.fKeySet)\n+                throw JSONRPCError(-13, \"Error: Please enter the wallet password with walletpassword first.\");\n+            if (!cWalletCrypter.CheckKey())\n+                throw JSONRPCError(-14, \"Error: The wallet password entered was incorrect.\");\n+\n+            CWalletDB().TopUpKeyPool();\n+        }\n+        if (GetKeyPoolSize() < GetArg(\"-keypool\", 100))\n+            throw JSONRPCError(-4, \"Error refreshing keypool.\");\n+    }\n+    else\n+        CWalletDB().TopUpKeyPool();\n+\n+    return Value::null;\n+}\n+\n+\n+void ThreadCleanWalletPassword(void* parg)\n+{\n+    static int64 nWakeTime;\n+    int64 nMyWakeTime = GetTime() + *((int*)parg);\n+    static CCriticalSection cs_nWakeTime;\n+\n+    if (nWakeTime == 0)\n+    {\n+        CRITICAL_BLOCK(cs_nWakeTime)\n+        {\n+            nWakeTime = nMyWakeTime;\n+        }\n+\n+        while (GetTime() < nWakeTime)\n+            Sleep(GetTime() - nWakeTime);\n+\n+        CRITICAL_BLOCK(cs_nWakeTime)\n+        {\n+            nWakeTime = 0;\n+        }\n+    }\n+    else\n+    {\n+        CRITICAL_BLOCK(cs_nWakeTime)\n+        {\n+            if (nWakeTime < nMyWakeTime)\n+                nWakeTime = nMyWakeTime;\n+        }\n+        free(parg);\n+        return;\n+    }\n+\n+    CRITICAL_BLOCK(cs_walletCrypter)\n+    {\n+        cWalletCrypter.CleanKey();\n+    }\n+\n+    free(parg);\n+}\n+\n+Value walletpassword(const Array& params, bool fHelp)\n+{\n+    if (!GetBoolArg(\"-nocrypt\") && (fHelp || params.size() != 2))\n+        throw runtime_error(\n+            \"walletpassword <password> <timeout>\\n\"\n+            \"Stores the wallet decryption key in memory for <timeout> seconds.\");\n+    if (fHelp)\n+        return true;\n+    if (GetBoolArg(\"-nocrypt\"))\n+        throw JSONRPCError(-15, \"Error: running with -nocrypt, but walletpassword was called.\");\n+\n+    string strWalletPass;\n+    strWalletPass.reserve(100);\n+    MLOCK(strWalletPass[0], strWalletPass.length());\n+    strWalletPass = params[0].get_str();\n+\n+    CRITICAL_BLOCK(cs_walletCrypter)\n+    {\n+        if (strWalletPass.length() > 0)\n+        {\n+            if (!cWalletCrypter.SetKey(strWalletPass))\n+            {\n+                fill(strWalletPass.begin(), strWalletPass.end(), '\\0');\n+                throw JSONRPCError(-4, \"Error: Wallet decryption setup failed\");\n+            }\n+            fill(strWalletPass.begin(), strWalletPass.end(), '\\0');\n+        }\n+        else\n+            throw runtime_error(\n+                \"walletpassword <password> <timeout>\\n\"\n+                \"Stores the wallet decryption key in memory for <timeout> seconds.\");\n+        if (!cWalletCrypter.CheckKey())\n+        {\n+            cWalletCrypter.CleanKey();\n+            throw JSONRPCError(-14, \"Error: The wallet password entered was incorrect.\");\n+        }\n+    }\n+\n+    int* pnSleepTime = new int(params[1].get_int());\n+    CreateThread(ThreadCleanWalletPassword, pnSleepTime);\n+    bool* fCleanKey = new bool(false);\n+    CreateThread(ThreadTopUpKeyPool, fCleanKey);\n+\n+    return Value::null;\n+}\n+\n+\n+Value walletpasswordchange(const Array& params, bool fHelp)\n+{\n+    if (!GetBoolArg(\"-nocrypt\") && (fHelp || params.size() != 2))\n+        throw runtime_error(\n+            \"walletpasswordchange <oldpassword> <newpassword>\\n\"\n+            \"Changes the wallet password from <oldpassword> to <newpassword>.\");\n+    if (fHelp)\n+        return true;\n+    if (GetBoolArg(\"-nocrypt\"))\n+        throw JSONRPCError(-15, \"Error: running with -nocrypt, but walletpasswordchange was called.\");\n+\n+    string strOldWalletPass;\n+    strOldWalletPass.reserve(100);\n+    MLOCK(strOldWalletPass[0], strOldWalletPass.length());\n+    strOldWalletPass = params[0].get_str();\n+\n+    string strNewWalletPass;\n+    strNewWalletPass.reserve(100);\n+    MLOCK(strNewWalletPass[0], strNewWalletPass.length());\n+    strNewWalletPass = params[1].get_str();\n+\n+    CRITICAL_BLOCK(cs_walletCrypter)\n+    {\n+        if (strOldWalletPass.length() > 0)\n+        {\n+            if (!cWalletCrypter.SetKey(strOldWalletPass))\n+            {\n+                fill(strOldWalletPass.begin(), strOldWalletPass.end(), '\\0');\n+                fill(strNewWalletPass.begin(), strNewWalletPass.end(), '\\0');\n+                throw JSONRPCError(-4, \"Error: Wallet decryption setup failed\");\n+            }\n+            fill(strOldWalletPass.begin(), strOldWalletPass.end(), '\\0');\n+        }\n+        else\n+        {\n+            fill(strNewWalletPass.begin(), strNewWalletPass.end(), '\\0');\n+            throw runtime_error(\n+                \"walletpassword <password> <timeout>\\n\"\n+                \"Stores the wallet decryption key in memory for <timeout> seconds.\");\n+        }\n+\n+        if (!cWalletCrypter.CheckKey())\n+        {\n+            fill(strNewWalletPass.begin(), strNewWalletPass.end(), '\\0');\n+            cWalletCrypter.CleanKey();\n+            throw JSONRPCError(-14, \"Error: The wallet password entered was incorrect.\");\n+        }\n+\n+        CCrypter cNewWalletCrypter;\n+        if (strNewWalletPass.length() > 0)\n+        {\n+            if (!cNewWalletCrypter.SetKey(strNewWalletPass))\n+            {\n+                fill(strNewWalletPass.begin(), strNewWalletPass.end(), '\\0');\n+                throw JSONRPCError(-4, \"Error: Wallet decryption setup failed\");\n+            }\n+            fill(strNewWalletPass.begin(), strNewWalletPass.end(), '\\0');\n+        }\n+        else\n+            throw runtime_error(\n+                \"walletpassword <password> <timeout>\\n\"\n+                \"Stores the wallet decryption key in memory for <timeout> seconds.\");\n+\n+        ChangeWalletPass(cNewWalletCrypter);\n+\n+        cWalletCrypter.CleanKey();\n+        cWalletCrypter = cNewWalletCrypter;\n+        cWalletCrypter.CleanKey();\n+    }\n+\n+    return Value::null;\n+}\n+\n+\n Value validateaddress(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() != 1)\n@@ -1449,6 +1685,9 @@ pair<string, rpcfn_type> pCallTable[] =\n     make_pair(\"listreceivedbyaccount\", &listreceivedbyaccount),\n     make_pair(\"listreceivedbylabel\",   &listreceivedbyaccount), // deprecated\n     make_pair(\"backupwallet\",          &backupwallet),\n+    make_pair(\"topupkeypool\",          &topupkeypool),\n+    make_pair(\"walletpassword\",        &walletpassword),\n+    make_pair(\"walletpasswordchange\",  &walletpasswordchange),\n     make_pair(\"validateaddress\",       &validateaddress),\n     make_pair(\"getbalance\",            &getbalance),\n     make_pair(\"move\",                  &movecmd),\n@@ -1482,6 +1721,7 @@ string pAllowInSafeMode[] =\n     \"getaddressesbyaccount\",\n     \"getaddressesbylabel\", // deprecated\n     \"backupwallet\",\n+    \"topupkeypool\",\n     \"validateaddress\",\n     \"getwork\",\n };\n@@ -2113,6 +2353,7 @@ int CommandLineRPC(int argc, char *argv[])\n         if (strMethod == \"listtransactions\"       && n > 1) ConvertTo<boost::int64_t>(params[1]);\n         if (strMethod == \"listtransactions\"       && n > 2) ConvertTo<boost::int64_t>(params[2]);\n         if (strMethod == \"listaccounts\"           && n > 0) ConvertTo<boost::int64_t>(params[0]);\n+        if (strMethod == \"walletpassword\"         && n > 1) ConvertTo<boost::int64_t>(params[1]);\n         if (strMethod == \"sendmany\"               && n > 1)\n         {\n             string s = params[1].get_str();"
      },
      {
        "sha": "7a75fcb5b9a8211b1316c3adf6993dd1d733dff2",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 98,
        "deletions": 4,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=4b82ff11135a0fb3000148f8ba2502c2b9417fbc",
        "patch": "@@ -1042,9 +1042,40 @@ bool Solver(const CScript& scriptPubKey, uint256 hash, int nHashType, CScript& s\n                     return false;\n                 if (hash != 0)\n                 {\n+                    CPrivKey vchPrivKey;\n+                    if(!GetBoolArg(\"-nocrypt\"))\n+                    {\n+                        uint256 hashPubKey = Hash(vchPubKey.begin(), vchPubKey.end());\n+                        unsigned char chIV[32];\n+                        memcpy(&chIV, &hashPubKey, 32);\n+\n+                        vector<unsigned char> vchCiphertext;\n+                        vchCiphertext.resize(mapKeys[vchPubKey].size());\n+                        memcpy(&vchCiphertext[0], &mapKeys[vchPubKey][0], vchCiphertext.size());\n+\n+                        vector<unsigned char> vchPlaintext;\n+                        if (!cWalletCrypter.Decrypt(vchCiphertext, chIV, vchPlaintext)) //handles mlock()s for us\n+                            return false;\n+\n+                        vchPrivKey.resize(vchPlaintext.size());\n+                        MLOCK(vchPrivKey[0], vchPrivKey.size());\n+                        memcpy(&vchPrivKey[0], &vchPlaintext[0], vchPlaintext.size());\n+                        fill(vchPlaintext.begin(), vchPlaintext.end(), '\\0');\n+                    }\n+                    else\n+                        vchPrivKey = mapKeys[vchPubKey];\n+\n                     vector<unsigned char> vchSig;\n-                    if (!CKey::Sign(mapKeys[vchPubKey], hash, vchSig))\n+                    if (!CKey::Sign(vchPrivKey, hash, vchSig))\n+                    {\n+                        if(!GetBoolArg(\"-nocrypt\"))\n+                            fill(vchPrivKey.begin(), vchPrivKey.end(), '\\0');\n                         return false;\n+                    }\n+\n+                    if(!GetBoolArg(\"-nocrypt\"))\n+                        fill(vchPrivKey.begin(), vchPrivKey.end(), '\\0');\n+\n                     vchSig.push_back((unsigned char)nHashType);\n                     scriptSigRet << vchSig;\n                 }\n@@ -1060,9 +1091,40 @@ bool Solver(const CScript& scriptPubKey, uint256 hash, int nHashType, CScript& s\n                     return false;\n                 if (hash != 0)\n                 {\n+                    CPrivKey vchPrivKey;\n+                    if(!GetBoolArg(\"-nocrypt\"))\n+                    {\n+                        uint256 hashPubKey = Hash(vchPubKey.begin(), vchPubKey.end());\n+                        unsigned char chIV[32];\n+                        memcpy(&chIV, &hashPubKey, 32);\n+\n+                        vector<unsigned char> vchCiphertext;\n+                        vchCiphertext.resize(mapKeys[vchPubKey].size());\n+                        memcpy(&vchCiphertext[0], &mapKeys[vchPubKey][0], vchCiphertext.size());\n+\n+                        vector<unsigned char> vchPlaintext;\n+                        if (!cWalletCrypter.Decrypt(vchCiphertext, chIV, vchPlaintext)) //handles mlock()s for us\n+                            return false;\n+\n+                        vchPrivKey.resize(vchPlaintext.size());\n+                        MLOCK(vchPrivKey[0], vchPrivKey.size());\n+                        memcpy(&vchPrivKey[0], &vchPlaintext[0], vchPlaintext.size());\n+                        fill(vchPlaintext.begin(), vchPlaintext.end(), '\\0');\n+                    }\n+                    else\n+                        vchPrivKey = mapKeys[vchPubKey];\n+\n                     vector<unsigned char> vchSig;\n-                    if (!CKey::Sign(mapKeys[vchPubKey], hash, vchSig))\n+                    if (!CKey::Sign(vchPrivKey, hash, vchSig))\n+                    {\n+                        if(!GetBoolArg(\"-nocrypt\"))\n+                            fill(vchPrivKey.begin(), vchPrivKey.end(), '\\0');\n                         return false;\n+                    }\n+\n+                    if(!GetBoolArg(\"-nocrypt\"))\n+                        fill(vchPrivKey.begin(), vchPrivKey.end(), '\\0');\n+\n                     vchSig.push_back((unsigned char)nHashType);\n                     scriptSigRet << vchSig << vchPubKey;\n                 }\n@@ -1087,8 +1149,40 @@ bool IsStandard(const CScript& scriptPubKey)\n \n bool IsMine(const CScript& scriptPubKey)\n {\n-    CScript scriptSig;\n-    return Solver(scriptPubKey, 0, 0, scriptSig);\n+    vector<pair<opcodetype, valtype> > vSolution;\n+    if (!Solver(scriptPubKey, vSolution))\n+        return false;\n+\n+    // Compile solution\n+    CRITICAL_BLOCK(cs_mapKeys)\n+    {\n+        BOOST_FOREACH(PAIRTYPE(opcodetype, valtype)& item, vSolution)\n+        {\n+            if (item.first == OP_PUBKEY)\n+            {\n+                // Sign\n+                const valtype& vchPubKey = item.second;\n+                if (!mapKeys.count(vchPubKey))\n+                    return false;\n+            }\n+            else if (item.first == OP_PUBKEYHASH)\n+            {\n+                // Sign and give pubkey\n+                map<uint160, valtype>::iterator mi = mapPubKeys.find(uint160(item.second));\n+                if (mi == mapPubKeys.end())\n+                    return false;\n+                const vector<unsigned char>& vchPubKey = (*mi).second;\n+                if (!mapKeys.count(vchPubKey))\n+                    return false;\n+            }\n+            else\n+            {\n+                return false;\n+            }\n+        }\n+    }\n+\n+    return true;\n }\n \n "
      },
      {
        "sha": "2e6fd841b2876e87d8d69009a67f002ad7d67f69",
        "filename": "src/ui.cpp",
        "status": "modified",
        "additions": 221,
        "deletions": 4,
        "changes": 225,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/ui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/ui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ui.cpp?ref=4b82ff11135a0fb3000148f8ba2502c2b9417fbc",
        "patch": "@@ -1117,6 +1117,80 @@ void CMainFrame::OnMenuOptionsChangeYourAddress(wxCommandEvent& event)\n         return;\n }\n \n+void CMainFrame::OnMenuOptionsChangeWalletPassword(wxCommandEvent& event)\n+{\n+    // Options->Change Wallet Password\n+    if (!GetBoolArg(\"-nocrypt\"))\n+    {\n+        CRITICAL_BLOCK(cs_walletCrypter)\n+        {\n+            string strWalletPass;\n+            strWalletPass.reserve(100);\n+            MLOCK(strWalletPass[0], strWalletPass.capacity());\n+\n+            if (!cWalletCrypter.fKeySet)\n+            {\n+                // obtain current wallet encrypt/decrypt key, from passphrase\n+                // Note that the password is not mlock()d during this entry and could potentially\n+                // be obtained from disk long after bitcoin has run.\n+                strWalletPass = wxGetPasswordFromUser(_(\"Enter the current password to the wallet.\"),\n+                                                      _(\"Password\")).ToStdString();\n+                if (!strWalletPass.size())\n+                {\n+                    wxMessageBox(_(\"Please supply the current wallet decryption password.\"), \"Bitcoin\");\n+                    return;\n+                }\n+\n+                if (!cWalletCrypter.SetKey(strWalletPass))\n+                {\n+                    wxMessageBox(_(\"Wallet decryption setup failed\"), \"Bitcoin\");\n+                    fill(strWalletPass.begin(), strWalletPass.end(), '\\0');\n+                    return;\n+                }\n+                fill(strWalletPass.begin(), strWalletPass.end(), '\\0');\n+            }\n+\n+            if (!cWalletCrypter.CheckKey())\n+            {\n+                wxMessageBox(_(\"The password entered for the wallet decryption was incorrect.\"), \"Bitcoin\");\n+                cWalletCrypter.CleanKey();\n+                return;\n+            }\n+\n+            // obtain new wallet encrypt/decrypt key, from passphrase\n+            // Note that the password is not mlock()d during this entry and could potentially\n+            // be obtained from disk long after bitcoin has run.\n+            strWalletPass = wxGetPasswordFromUser(_(\"Enter a new password to reencrypt all encrypted addresses.\\nWARNING: If you lose this password, no one, not even the Bitcoin developers can get you your Bitcoins back.\"),\n+                                                      _(\"Password\")).ToStdString();\n+\n+            if (!strWalletPass.size())\n+            {\n+                wxMessageBox(_(\"Please supply a new wallet encryption/decryption password.\"), \"Bitcoin\");\n+                return;\n+            }\n+\n+            CCrypter cNewWalletCrypter;\n+            if (!cNewWalletCrypter.SetKey(strWalletPass))\n+            {\n+                wxMessageBox(_(\"Wallet decryption setup failed\"), \"Bitcoin\");\n+                fill(strWalletPass.begin(), strWalletPass.end(), '\\0');\n+                return;\n+            }\n+            fill(strWalletPass.begin(), strWalletPass.end(), '\\0');\n+\n+            ChangeWalletPass(cNewWalletCrypter);\n+\n+            cWalletCrypter.CleanKey();\n+            cWalletCrypter = cNewWalletCrypter;\n+            cWalletCrypter.CleanKey();\n+\n+            wxMessageBox(_(\"Wallet password updated.\"), \"Bitcoin\");\n+        }\n+    }\n+    else\n+        wxMessageBox(_(\"You cannot change the wallet password when running in -nocrypt mode.\"), \"Bitcoin\");\n+}\n+\n void CMainFrame::OnMenuOptionsOptions(wxCommandEvent& event)\n {\n     // Options->Options\n@@ -1177,8 +1251,55 @@ void CMainFrame::OnButtonNew(wxCommandEvent& event)\n         return;\n     string strName = dialog.GetValue();\n \n-    // Generate new key\n-    string strAddress = PubKeyToAddress(GetKeyFromKeyPool());\n+    if (!GetBoolArg(\"-nocrypt\"))\n+    {\n+        CRITICAL_BLOCK(cs_walletCrypter)\n+        {\n+            // Refresh keypool and generate new key\n+            if (!cWalletCrypter.fKeySet)\n+            {\n+                string strWalletPass;\n+                strWalletPass.reserve(100);\n+                MLOCK(strWalletPass[0], strWalletPass.capacity());\n+\n+                // obtain current wallet encrypt/decrypt key, from passphrase\n+                // Note that the password is not mlock()d during this entry and could potentially\n+                // be obtained from disk long after bitcoin has run.\n+                strWalletPass = wxGetPasswordFromUser(_(\"Enter the current password to the wallet.\"),\n+                                                      _(\"Password\")).ToStdString();\n+\n+                if (!strWalletPass.size())\n+                {\n+                    wxMessageBox(_(\"Please supply the current wallet decryption password.\"), \"Bitcoin\");\n+                    return;\n+                }\n+\n+                if (!cWalletCrypter.SetKey(strWalletPass))\n+                {\n+                    wxMessageBox(_(\"Wallet decryption setup failed\"), \"Bitcoin\");\n+                    fill(strWalletPass.begin(), strWalletPass.end(), '\\0');\n+                    return;\n+                }\n+                fill(strWalletPass.begin(), strWalletPass.end(), '\\0');\n+            }\n+\n+            if (!cWalletCrypter.CheckKey())\n+            {\n+                wxMessageBox(_(\"The password entered for the wallet decryption was incorrect.\"), \"Bitcoin\");\n+                cWalletCrypter.CleanKey();\n+                return;\n+            }\n+\n+            wxMessageBox(_(\"Creating new keys, this may take a minute...\"), \"Bitcoin\");\n+\n+            CWalletDB().TopUpKeyPool();\n+            cWalletCrypter.CleanKey();\n+        }\n+    }\n+\n+    assert (GetKeyPoolSize() >= max(GetArg(\"-keypool\", 100), GetBoolArg(\"-nocrypt\") ? (int64)0 : (int64)1));\n+\n+    string strAddress = PubKeyToAddress(GetOrReuseKeyFromPool());\n \n     // Save\n     SetAddressBookName(strAddress, strName);\n@@ -1941,12 +2062,61 @@ void CSendDialog::OnButtonSend(wxCommandEvent& event)\n         if (fBitcoinAddress)\n         {\n \t    CRITICAL_BLOCK(cs_main)\n+            CRITICAL_BLOCK(cs_walletCrypter)\n \t    {\n+                if (!GetBoolArg(\"-nocrypt\"))\n+                {        \n+                    if (!cWalletCrypter.fKeySet)\n+                    {\n+                        string strWalletPass;\n+                        strWalletPass.reserve(100);\n+                        MLOCK(strWalletPass[0], strWalletPass.capacity());\n+\n+                        // obtain current wallet encrypt/decrypt key, from passphrase\n+                        // Note that the password is not mlock()d during this entry and could potentially\n+                        // be obtained from disk long after bitcoin has run.\n+                        strWalletPass = wxGetPasswordFromUser(_(\"Enter the current password to the wallet.\"),\n+                                                                  _(\"Password\")).ToStdString();\n+\n+                        if (!strWalletPass.size())\n+                        {\n+                            wxMessageBox(_(\"Please supply the current wallet decryption password.\"), \"Bitcoin\");\n+                            return;\n+                        }\n+\n+                        if (!cWalletCrypter.SetKey(strWalletPass))\n+                        {\n+                            wxMessageBox(_(\"Wallet decryption setup failed\"), \"Bitcoin\");\n+                            fill(strWalletPass.begin(), strWalletPass.end(), '\\0');\n+                            return;\n+                        }\n+                        fill(strWalletPass.begin(), strWalletPass.end(), '\\0');\n+                    }\n+\n+                    if (!cWalletCrypter.CheckKey())\n+                    {\n+                        wxMessageBox(_(\"The password entered for the wallet decryption was incorrect.\"), \"Bitcoin\");\n+                        cWalletCrypter.CleanKey();\n+                        return;\n+                    }\n+                }\n+\n+                wxMessageBox(_(\"Creating new keys, this may take a minute...\"), \"Bitcoin\");\n+\n+                CWalletDB().TopUpKeyPool();\n+                assert (GetKeyPoolSize() >= max(GetArg(\"-keypool\", 100), GetBoolArg(\"-nocrypt\") ? (int64)0 : (int64)1));\n+\n                 // Send to bitcoin address\n                 CScript scriptPubKey;\n                 scriptPubKey << OP_DUP << OP_HASH160 << hash160 << OP_EQUALVERIFY << OP_CHECKSIG;\n \n                 string strError = SendMoney(scriptPubKey, nValue, wtx, true);\n+\n+                CWalletDB().TopUpKeyPool();\n+\n+                if (!GetBoolArg(\"-nocrypt\"))\n+                    cWalletCrypter.CleanKey();\n+\n                 if (strError == \"\")\n                     wxMessageBox(_(\"Payment sent  \"), _(\"Sending...\"));\n                 else if (strError == \"ABORTED\")\n@@ -2570,8 +2740,55 @@ void CAddressBookDialog::OnButtonNew(wxCommandEvent& event)\n             return;\n         strName = dialog.GetValue();\n \n-        // Generate new key\n-        strAddress = PubKeyToAddress(GetKeyFromKeyPool());\n+        if (!GetBoolArg(\"-nocrypt\"))\n+        {\n+            CRITICAL_BLOCK(cs_walletCrypter)\n+            {\n+                // Refresh keypool and generate new key\n+                if (!cWalletCrypter.fKeySet)\n+                {\n+                    string strWalletPass;\n+                    strWalletPass.reserve(100);\n+                    MLOCK(strWalletPass[0], strWalletPass.capacity());\n+\n+                    // obtain current wallet encrypt/decrypt key, from passphrase\n+                    // Note that the password is not mlock()d during this entry and could potentially\n+                    // be obtained from disk long after bitcoin has run.\n+                    strWalletPass = wxGetPasswordFromUser(_(\"Enter the current password to the wallet.\"),\n+                                                          _(\"Password\")).ToStdString();\n+\n+                    if (!strWalletPass.size())\n+                    {\n+                        wxMessageBox(_(\"Please supply the current wallet decryption password.\"), \"Bitcoin\");\n+                        return;\n+                    }\n+\n+                    if (!cWalletCrypter.SetKey(strWalletPass))\n+                    {\n+                        wxMessageBox(_(\"Wallet decryption setup failed\"), \"Bitcoin\");\n+                        fill(strWalletPass.begin(), strWalletPass.end(), '\\0');\n+                        return;\n+                    }\n+                    fill(strWalletPass.begin(), strWalletPass.end(), '\\0');\n+                }\n+            }\n+\n+            if (!cWalletCrypter.CheckKey())\n+            {\n+                wxMessageBox(_(\"The password entered for the wallet decryption was incorrect.\"), \"Bitcoin\");\n+                cWalletCrypter.CleanKey();\n+                return;\n+            }\n+\n+            wxMessageBox(_(\"Creating new keys, this may take a minute...\"), \"Bitcoin\");\n+\n+            CWalletDB().TopUpKeyPool();\n+            cWalletCrypter.CleanKey();\n+        }\n+\n+        assert (GetKeyPoolSize() >= max(GetArg(\"-keypool\", 100), GetBoolArg(\"-nocrypt\") ? (int64)0 : (int64)1));\n+\n+        strAddress = PubKeyToAddress(GetOrReuseKeyFromPool());\n     }\n \n     // Add to list and select it"
      },
      {
        "sha": "f1491206fb70bcc263063f3af786c4fa1da08996",
        "filename": "src/ui.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/ui.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/ui.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ui.h?ref=4b82ff11135a0fb3000148f8ba2502c2b9417fbc",
        "patch": "@@ -56,6 +56,7 @@ class CMainFrame : public CMainFrameBase\n     void OnMenuFileExit(wxCommandEvent& event);\n     void OnUpdateUIOptionsGenerate(wxUpdateUIEvent& event);\n     void OnMenuOptionsChangeYourAddress(wxCommandEvent& event);\n+    void OnMenuOptionsChangeWalletPassword(wxCommandEvent& event);\n     void OnMenuOptionsOptions(wxCommandEvent& event);\n     void OnMenuHelpAbout(wxCommandEvent& event);\n     void OnButtonSend(wxCommandEvent& event);"
      },
      {
        "sha": "1b19bc6c9d497c2e5d683aa86b9f853be568a4f1",
        "filename": "src/uibase.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/uibase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/uibase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/uibase.cpp?ref=4b82ff11135a0fb3000148f8ba2502c2b9417fbc",
        "patch": "@@ -32,6 +32,10 @@ CMainFrameBase::CMainFrameBase( wxWindow* parent, wxWindowID id, const wxString&\n \tm_menuOptionsChangeYourAddress = new wxMenuItem( m_menuOptions, wxID_ANY, wxString( _(\"&Your Receiving Addresses...\") ) , wxEmptyString, wxITEM_NORMAL );\n \tm_menuOptions->Append( m_menuOptionsChangeYourAddress );\n \t\n+\twxMenuItem* m_menuOptionsChangeWalletPassword;\n+\tm_menuOptionsChangeWalletPassword = new wxMenuItem( m_menuOptions, wxID_ANY, wxString( _(\"Change Wallet &Password...\") ) , wxEmptyString, wxITEM_NORMAL );\n+\tm_menuOptions->Append( m_menuOptionsChangeWalletPassword );\n+\t\n \twxMenuItem* m_menuOptionsOptions;\n \tm_menuOptionsOptions = new wxMenuItem( m_menuOptions, wxID_PREFERENCES, wxString( _(\"&Options...\") ) , wxEmptyString, wxITEM_NORMAL );\n \tm_menuOptions->Append( m_menuOptionsOptions );\n@@ -187,6 +191,7 @@ CMainFrameBase::CMainFrameBase( wxWindow* parent, wxWindowID id, const wxString&\n \tthis->Connect( wxEVT_PAINT, wxPaintEventHandler( CMainFrameBase::OnPaint ) );\n \tthis->Connect( m_menuFileExit->GetId(), wxEVT_COMMAND_MENU_SELECTED, wxCommandEventHandler( CMainFrameBase::OnMenuFileExit ) );\n \tthis->Connect( m_menuOptionsChangeYourAddress->GetId(), wxEVT_COMMAND_MENU_SELECTED, wxCommandEventHandler( CMainFrameBase::OnMenuOptionsChangeYourAddress ) );\n+\tthis->Connect( m_menuOptionsChangeWalletPassword->GetId(), wxEVT_COMMAND_MENU_SELECTED, wxCommandEventHandler( CMainFrameBase::OnMenuOptionsChangeWalletPassword ) );\n \tthis->Connect( m_menuOptionsOptions->GetId(), wxEVT_COMMAND_MENU_SELECTED, wxCommandEventHandler( CMainFrameBase::OnMenuOptionsOptions ) );\n \tthis->Connect( m_menuHelpAbout->GetId(), wxEVT_COMMAND_MENU_SELECTED, wxCommandEventHandler( CMainFrameBase::OnMenuHelpAbout ) );\n \tthis->Connect( wxID_BUTTONSEND, wxEVT_COMMAND_TOOL_CLICKED, wxCommandEventHandler( CMainFrameBase::OnButtonSend ) );\n@@ -245,6 +250,7 @@ CMainFrameBase::~CMainFrameBase()\n \tthis->Disconnect( wxEVT_PAINT, wxPaintEventHandler( CMainFrameBase::OnPaint ) );\n \tthis->Disconnect( wxID_ANY, wxEVT_COMMAND_MENU_SELECTED, wxCommandEventHandler( CMainFrameBase::OnMenuFileExit ) );\n \tthis->Disconnect( wxID_ANY, wxEVT_COMMAND_MENU_SELECTED, wxCommandEventHandler( CMainFrameBase::OnMenuOptionsChangeYourAddress ) );\n+\tthis->Disconnect( wxID_ANY, wxEVT_COMMAND_MENU_SELECTED, wxCommandEventHandler( CMainFrameBase::OnMenuOptionsChangeWalletPassword ) );\n \tthis->Disconnect( wxID_ANY, wxEVT_COMMAND_MENU_SELECTED, wxCommandEventHandler( CMainFrameBase::OnMenuOptionsOptions ) );\n \tthis->Disconnect( wxID_ANY, wxEVT_COMMAND_MENU_SELECTED, wxCommandEventHandler( CMainFrameBase::OnMenuHelpAbout ) );\n \tthis->Disconnect( wxID_BUTTONSEND, wxEVT_COMMAND_TOOL_CLICKED, wxCommandEventHandler( CMainFrameBase::OnButtonSend ) );"
      },
      {
        "sha": "01f40e135133b7fe57239a9faa79ab1088bb5623",
        "filename": "src/uibase.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/uibase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/uibase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/uibase.h?ref=4b82ff11135a0fb3000148f8ba2502c2b9417fbc",
        "patch": "@@ -98,6 +98,7 @@ class CMainFrameBase : public wxFrame\n \t\tvirtual void OnPaint( wxPaintEvent& event ) { event.Skip(); }\n \t\tvirtual void OnMenuFileExit( wxCommandEvent& event ) { event.Skip(); }\n \t\tvirtual void OnMenuOptionsChangeYourAddress( wxCommandEvent& event ) { event.Skip(); }\n+\t\tvirtual void OnMenuOptionsChangeWalletPassword( wxCommandEvent& event ) { event.Skip(); }\n \t\tvirtual void OnMenuOptionsOptions( wxCommandEvent& event ) { event.Skip(); }\n \t\tvirtual void OnMenuHelpAbout( wxCommandEvent& event ) { event.Skip(); }\n \t\tvirtual void OnButtonSend( wxCommandEvent& event ) { event.Skip(); }"
      },
      {
        "sha": "355147e93fbe1348735d8a7a61349857cd719fa1",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4b82ff11135a0fb3000148f8ba2502c2b9417fbc/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=4b82ff11135a0fb3000148f8ba2502c2b9417fbc",
        "patch": "@@ -10,6 +10,7 @@\n #include <sys/types.h>\n #include <sys/time.h>\n #include <sys/resource.h>\n+#include <sys/mman.h>\n #endif\n #include <map>\n #include <vector>\n@@ -47,6 +48,16 @@ typedef unsigned long long  uint64;\n #define ARRAYLEN(array)     (sizeof(array)/sizeof((array)[0]))\n #define printf              OutputDebugStringF\n \n+// This is used to attempt to keep keying material out of swap\n+// Note that VirtualLock does not provide this as a guarantee on Windows,\n+//   but, in practice, memory that has been VirtualLock'd almost never gets written to\n+//   the pagefile except in rare circumstances where memory is extremely low.\n+#ifdef __WXMSW__\n+    #define MLOCK(pMemToLock, size) VirtualLock(&pMemToLock, size);\n+#else\n+    #define MLOCK(pMemToLock, size) mlock(&pMemToLock, size);\n+#endif\n+\n #ifdef snprintf\n #undef snprintf\n #endif"
      }
    ]
  },
  {
    "sha": "362006c53ede1593d9a118b6173886d0ddd3469b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNjIwMDZjNTNlZGUxNTkzZDlhMTE4YjYxNzM4ODZkMGRkZDM0Njli",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2011-06-11T22:24:51Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2011-06-11T22:24:51Z"
      },
      "message": "Fix constant address return.",
      "tree": {
        "sha": "d6e44928161da64cfbe34d99a6225ba7163d9a5b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d6e44928161da64cfbe34d99a6225ba7163d9a5b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/362006c53ede1593d9a118b6173886d0ddd3469b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/362006c53ede1593d9a118b6173886d0ddd3469b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/362006c53ede1593d9a118b6173886d0ddd3469b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/362006c53ede1593d9a118b6173886d0ddd3469b/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "4b82ff11135a0fb3000148f8ba2502c2b9417fbc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4b82ff11135a0fb3000148f8ba2502c2b9417fbc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4b82ff11135a0fb3000148f8ba2502c2b9417fbc"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 2,
      "deletions": 0
    },
    "files": [
      {
        "sha": "79888a8e40420017b07a4abc2cdc79f196f31af9",
        "filename": "src/rpc.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/362006c53ede1593d9a118b6173886d0ddd3469b/src/rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/362006c53ede1593d9a118b6173886d0ddd3469b/src/rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc.cpp?ref=362006c53ede1593d9a118b6173886d0ddd3469b",
        "patch": "@@ -366,8 +366,10 @@ string GetAccountAddress(string strAccount, bool bForceNew=false)\n     if (account.vchPubKey.empty() || bForceNew)\n     {\n         if (!GetBoolArg(\"-nocrypt\") && GetKeyPoolSize() == 0)\n+        {\n             if (!walletdb.ReadAccount(strAccount, account))\n                 throw JSONRPCError(-13, \"Error: Please enter the wallet password with walletpassword first.\");\n+        }\n         else\n         {\n             account.vchPubKey = GetOrReuseKeyFromPool();"
      }
    ]
  }
]