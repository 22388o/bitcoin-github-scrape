[
  {
    "sha": "31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozMWQ2YjFkNWYwNDE0ZDhiMzU2ZDhjYjljOTk5NjFkOGEwNGQ2YzBh",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-05-31T17:05:52Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-07-31T17:24:07Z"
      },
      "message": "net: Split resolving out of CNetAddr",
      "tree": {
        "sha": "e1044a96d479c66c639528276d54f674b5103ae8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e1044a96d479c66c639528276d54f674b5103ae8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6caf3ee061a86d89b965dc8a61a95d1f34015805",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6caf3ee061a86d89b965dc8a61a95d1f34015805",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6caf3ee061a86d89b965dc8a61a95d1f34015805"
      }
    ],
    "stats": {
      "total": 272,
      "additions": 153,
      "deletions": 119
    },
    "files": [
      {
        "sha": "8725346fe89f3ab0405ab565027faadc541a7ffd",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 3,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a",
        "patch": "@@ -1396,8 +1396,11 @@ void ThreadMapPort()\n             {\n                 if(externalIPAddress[0])\n                 {\n-                    LogPrintf(\"UPnP: ExternalIPAddress = %s\\n\", externalIPAddress);\n-                    AddLocal(CNetAddr(externalIPAddress), LOCAL_UPNP);\n+                    CNetAddr resolved;\n+                    if(LookupHost(externalIPAddress, resolved, false)) {\n+                        LogPrintf(\"UPnP: ExternalIPAddress = %s\\n\", resolved.ToString().c_str());\n+                        AddLocal(resolved, LOCAL_UPNP);\n+                    }\n                 }\n                 else\n                     LogPrintf(\"UPnP: GetExternalIPAddress failed.\\n\");\n@@ -1623,7 +1626,9 @@ void ThreadOpenConnections()\n             static bool done = false;\n             if (!done) {\n                 LogPrintf(\"Adding fixed seed nodes as DNS doesn't seem to be available.\\n\");\n-                addrman.Add(convertSeed6(Params().FixedSeeds()), CNetAddr(\"127.0.0.1\"));\n+                CNetAddr local;\n+                LookupHost(\"127.0.0.1\", local, false);\n+                addrman.Add(convertSeed6(Params().FixedSeeds()), local);\n                 done = true;\n             }\n         }"
      },
      {
        "sha": "bb16dd0439cd28926cfcb201883ddcbe3dcb8f72",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 16,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a",
        "patch": "@@ -195,6 +195,16 @@ bool LookupHost(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nM\n     return LookupIntern(strHost.c_str(), vIP, nMaxSolutions, fAllowLookup);\n }\n \n+bool LookupHost(const char *pszName, CNetAddr& addr, bool fAllowLookup)\n+{\n+    std::vector<CNetAddr> vIP;\n+    LookupHost(pszName, vIP, 1, fAllowLookup);\n+    if(vIP.empty())\n+        return false;\n+    addr = vIP.front();\n+    return true;\n+}\n+\n bool Lookup(const char *pszName, std::vector<CService>& vAddr, int portDefault, bool fAllowLookup, unsigned int nMaxSolutions)\n {\n     if (pszName[0] == 0)\n@@ -695,22 +705,6 @@ CNetAddr::CNetAddr(const struct in6_addr& ipv6Addr, const uint32_t scope)\n     scopeId = scope;\n }\n \n-CNetAddr::CNetAddr(const char *pszIp)\n-{\n-    Init();\n-    std::vector<CNetAddr> vIP;\n-    if (LookupHost(pszIp, vIP, 1, false))\n-        *this = vIP[0];\n-}\n-\n-CNetAddr::CNetAddr(const std::string &strIp)\n-{\n-    Init();\n-    std::vector<CNetAddr> vIP;\n-    if (LookupHost(strIp.c_str(), vIP, 1, false))\n-        *this = vIP[0];\n-}\n-\n unsigned int CNetAddr::GetByte(int n) const\n {\n     return ip[15-n];"
      },
      {
        "sha": "0deca02ca669a8374de9a78a7d52a30d95531a6f",
        "filename": "src/netbase.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a/src/netbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a/src/netbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.h?ref=31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a",
        "patch": "@@ -49,8 +49,6 @@ class CNetAddr\n     public:\n         CNetAddr();\n         CNetAddr(const struct in_addr& ipv4Addr);\n-        explicit CNetAddr(const char *pszIp);\n-        explicit CNetAddr(const std::string &strIp);\n         void Init();\n         void SetIP(const CNetAddr& ip);\n \n@@ -207,6 +205,7 @@ bool IsProxy(const CNetAddr &addr);\n bool SetNameProxy(const proxyType &addrProxy);\n bool HaveNameProxy();\n bool LookupHost(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup);\n+bool LookupHost(const char *pszName, CNetAddr& addr, bool fAllowLookup);\n bool Lookup(const char *pszName, CService& addr, int portDefault, bool fAllowLookup);\n bool Lookup(const char *pszName, std::vector<CService>& vAddr, int portDefault, bool fAllowLookup, unsigned int nMaxSolutions);\n bool LookupNumeric(const char *pszName, CService& addr, int portDefault = 0);"
      },
      {
        "sha": "e7df4f2dfafce081d91e0b3d4c8bf0b6cbfc18a9",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a",
        "patch": "@@ -898,7 +898,10 @@ void RPCConsole::banSelectedNode(int bantime)\n         int port = 0;\n         SplitHostPort(nStr, port, addr);\n \n-        CNode::Ban(CNetAddr(addr), BanReasonManuallyAdded, bantime);\n+        CNetAddr resolved;\n+        if(!LookupHost(addr.c_str(), resolved, false))\n+            return;\n+        CNode::Ban(resolved, BanReasonManuallyAdded, bantime);\n \n         clearSelectedNode();\n         clientModel->getBanTableModel()->refresh();"
      },
      {
        "sha": "c23becd4a97de46a1d80b806f4d4c35ef6298605",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a",
        "patch": "@@ -494,8 +494,11 @@ UniValue setban(const UniValue& params, bool fHelp)\n     if (params[0].get_str().find(\"/\") != string::npos)\n         isSubnet = true;\n \n-    if (!isSubnet)\n-        netAddr = CNetAddr(params[0].get_str());\n+    if (!isSubnet) {\n+        CNetAddr resolved;\n+        LookupHost(params[0].get_str().c_str(), resolved, false);\n+        netAddr = resolved;\n+    }\n     else\n         subNet = CSubNet(params[0].get_str());\n "
      },
      {
        "sha": "fd9666f532e986fec9a7f27a8eb0c1c6d8500e1f",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 25,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a",
        "patch": "@@ -50,6 +50,18 @@ class CAddrManTest : public CAddrMan\n     }\n };\n \n+static CNetAddr ResolveIP(const char* ip)\n+{\n+    CNetAddr addr;\n+    BOOST_CHECK_MESSAGE(LookupHost(ip, addr, false), strprintf(\"failed to resolve: %s\", ip));\n+    return addr;\n+}\n+\n+static CNetAddr ResolveIP(std::string ip)\n+{\n+    return ResolveIP(ip.c_str());\n+}\n+\n BOOST_FIXTURE_TEST_SUITE(addrman_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(addrman_simple)\n@@ -59,7 +71,7 @@ BOOST_AUTO_TEST_CASE(addrman_simple)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    CNetAddr source = CNetAddr(\"252.2.2.2\");\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n     // Test 1: Does Addrman respond correctly when empty.\n     BOOST_CHECK(addrman.size() == 0);\n@@ -100,7 +112,7 @@ BOOST_AUTO_TEST_CASE(addrman_ports)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    CNetAddr source = CNetAddr(\"252.2.2.2\");\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n     BOOST_CHECK(addrman.size() == 0);\n \n@@ -132,7 +144,7 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    CNetAddr source = CNetAddr(\"252.2.2.2\");\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n     // Test 9: Select from new with 1 addr in new.\n     CService addr1 = CService(\"250.1.1.1\", 8333);\n@@ -160,20 +172,20 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     CService addr3 = CService(\"250.3.2.2\", 9999);\n     CService addr4 = CService(\"250.3.3.3\", 9999);\n \n-    addrman.Add(CAddress(addr2, NODE_NONE), CService(\"250.3.1.1\", 8333));\n-    addrman.Add(CAddress(addr3, NODE_NONE), CService(\"250.3.1.1\", 8333));\n-    addrman.Add(CAddress(addr4, NODE_NONE), CService(\"250.4.1.1\", 8333));\n+    addrman.Add(CAddress(addr2, NODE_NONE), CService(\"250.3.1.1\", 8333), NODE_NONE);\n+    addrman.Add(CAddress(addr3, NODE_NONE), CService(\"250.3.1.1\", 8333), NODE_NONE);\n+    addrman.Add(CAddress(addr4, NODE_NONE), CService(\"250.4.1.1\", 8333), NODE_NONE);\n \n     // Add three addresses to tried table.\n     CService addr5 = CService(\"250.4.4.4\", 8333);\n     CService addr6 = CService(\"250.4.5.5\", 7777);\n     CService addr7 = CService(\"250.4.6.6\", 8333);\n \n-    addrman.Add(CAddress(addr5, NODE_NONE), CService(\"250.3.1.1\", 8333));\n+    addrman.Add(CAddress(addr5, NODE_NONE), CService(\"250.3.1.1\", 8333), NODE_NONE);\n     addrman.Good(CAddress(addr5, NODE_NONE));\n-    addrman.Add(CAddress(addr6, NODE_NONE), CService(\"250.3.1.1\", 8333));\n+    addrman.Add(CAddress(addr6, NODE_NONE), CService(\"250.3.1.1\", 8333), NODE_NONE);\n     addrman.Good(CAddress(addr6, NODE_NONE));\n-    addrman.Add(CAddress(addr7, NODE_NONE), CService(\"250.1.1.3\", 8333));\n+    addrman.Add(CAddress(addr7, NODE_NONE), CService(\"250.1.1.3\", 8333), NODE_NONE);\n     addrman.Good(CAddress(addr7, NODE_NONE));\n \n     // Test 11: 6 addrs + 1 addr from last test = 7.\n@@ -193,7 +205,7 @@ BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    CNetAddr source = CNetAddr(\"252.2.2.2\");\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n     BOOST_CHECK(addrman.size() == 0);\n \n@@ -222,7 +234,7 @@ BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    CNetAddr source = CNetAddr(\"252.2.2.2\");\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n     BOOST_CHECK(addrman.size() == 0);\n \n@@ -259,8 +271,8 @@ BOOST_AUTO_TEST_CASE(addrman_find)\n     CAddress addr2 = CAddress(CService(\"250.1.2.1\", 9999), NODE_NONE);\n     CAddress addr3 = CAddress(CService(\"251.255.2.1\", 8333), NODE_NONE);\n \n-    CNetAddr source1 = CNetAddr(\"250.1.2.1\");\n-    CNetAddr source2 = CNetAddr(\"250.1.2.2\");\n+    CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n+    CNetAddr source2 = ResolveIP(\"250.1.2.2\");\n \n     addrman.Add(addr1, source1);\n     addrman.Add(addr2, source2);\n@@ -295,7 +307,7 @@ BOOST_AUTO_TEST_CASE(addrman_create)\n     BOOST_CHECK(addrman.size() == 0);\n \n     CAddress addr1 = CAddress(CService(\"250.1.2.1\", 8333), NODE_NONE);\n-    CNetAddr source1 = CNetAddr(\"250.1.2.1\");\n+    CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n \n     int nId;\n     CAddrInfo* pinfo = addrman.Create(addr1, source1, &nId);\n@@ -318,7 +330,7 @@ BOOST_AUTO_TEST_CASE(addrman_delete)\n     BOOST_CHECK(addrman.size() == 0);\n \n     CAddress addr1 = CAddress(CService(\"250.1.2.1\", 8333), NODE_NONE);\n-    CNetAddr source1 = CNetAddr(\"250.1.2.1\");\n+    CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n \n     int nId;\n     addrman.Create(addr1, source1, &nId);\n@@ -354,8 +366,8 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n     addr4.nTime = GetAdjustedTime();\n     CAddress addr5 = CAddress(CService(\"252.254.4.5\", 8333), NODE_NONE);\n     addr5.nTime = GetAdjustedTime();\n-    CNetAddr source1 = CNetAddr(\"250.1.2.1\");\n-    CNetAddr source2 = CNetAddr(\"250.2.3.3\");\n+    CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n+    CNetAddr source2 = ResolveIP(\"250.2.3.3\");\n \n     // Test 23: Ensure GetAddr works with new addresses.\n     addrman.Add(addr1, source1);\n@@ -382,7 +394,7 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n         \n         // Ensure that for all addrs in addrman, isTerrible == false.\n         addr.nTime = GetAdjustedTime();\n-        addrman.Add(addr, CNetAddr(strAddr));\n+        addrman.Add(addr, ResolveIP(strAddr));\n         if (i % 8 == 0)\n             addrman.Good(addr);\n     }\n@@ -406,7 +418,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n     CAddress addr1 = CAddress(CService(\"250.1.1.1\", 8333), NODE_NONE);\n     CAddress addr2 = CAddress(CService(\"250.1.1.1\", 9999), NODE_NONE);\n \n-    CNetAddr source1 = CNetAddr(\"250.1.1.1\");\n+    CNetAddr source1 = ResolveIP(\"250.1.1.1\");\n \n \n     CAddrInfo info1 = CAddrInfo(addr1, source1);\n@@ -432,7 +444,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n     for (int i = 0; i < 255; i++) {\n         CAddrInfo infoi = CAddrInfo(\n             CAddress(CService(\"250.1.1.\" + boost::to_string(i)), NODE_NONE),\n-            CNetAddr(\"250.1.1.\" + boost::to_string(i)));\n+            ResolveIP(\"250.1.1.\" + boost::to_string(i)));\n         int bucket = infoi.GetTriedBucket(nKey1);\n         buckets.insert(bucket);\n     }\n@@ -444,7 +456,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n     for (int j = 0; j < 255; j++) {\n         CAddrInfo infoj = CAddrInfo(\n             CAddress(CService(\"250.\" + boost::to_string(j) + \".1.1\"), NODE_NONE),\n-            CNetAddr(\"250.\" + boost::to_string(j) + \".1.1\"));\n+            ResolveIP(\"250.\" + boost::to_string(j) + \".1.1\"));\n         int bucket = infoj.GetTriedBucket(nKey1);\n         buckets.insert(bucket);\n     }\n@@ -463,7 +475,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     CAddress addr1 = CAddress(CService(\"250.1.2.1\", 8333), NODE_NONE);\n     CAddress addr2 = CAddress(CService(\"250.1.2.1\", 9999), NODE_NONE);\n \n-    CNetAddr source1 = CNetAddr(\"250.1.2.1\");\n+    CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n \n     CAddrInfo info1 = CAddrInfo(addr1, source1);\n \n@@ -485,7 +497,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     for (int i = 0; i < 255; i++) {\n         CAddrInfo infoi = CAddrInfo(\n             CAddress(CService(\"250.1.1.\" + boost::to_string(i)), NODE_NONE),\n-            CNetAddr(\"250.1.1.\" + boost::to_string(i)));\n+            ResolveIP(\"250.1.1.\" + boost::to_string(i)));\n         int bucket = infoi.GetNewBucket(nKey1);\n         buckets.insert(bucket);\n     }\n@@ -498,7 +510,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n         CAddrInfo infoj = CAddrInfo(CAddress(\n                                         CService(\n                                             boost::to_string(250 + (j / 255)) + \".\" + boost::to_string(j % 256) + \".1.1\"), NODE_NONE),\n-            CNetAddr(\"251.4.1.1\"));\n+            ResolveIP(\"251.4.1.1\"));\n         int bucket = infoj.GetNewBucket(nKey1);\n         buckets.insert(bucket);\n     }\n@@ -510,7 +522,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     for (int p = 0; p < 255; p++) {\n         CAddrInfo infoj = CAddrInfo(\n             CAddress(CService(\"250.1.1.1\"), NODE_NONE),\n-            CNetAddr(\"250.\" + boost::to_string(p) + \".1.1\"));\n+            ResolveIP(\"250.\" + boost::to_string(p) + \".1.1\"));\n         int bucket = infoj.GetNewBucket(nKey1);\n         buckets.insert(bucket);\n     }"
      },
      {
        "sha": "511073499e245b6422704d9f79d6adac493aa1d9",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a",
        "patch": "@@ -52,7 +52,9 @@ class CAddrManCorrupted : public CAddrManSerializationMock\n         s << nUBuckets;\n \n         CAddress addr = CAddress(CService(\"252.1.1.1\", 7777), NODE_NONE);\n-        CAddrInfo info = CAddrInfo(addr, CNetAddr(\"252.2.2.2\"));\n+        CNetAddr resolved;\n+        LookupHost(\"252.2.2.2\", resolved, false);\n+        CAddrInfo info = CAddrInfo(addr, resolved);\n         s << info;\n     }\n };"
      },
      {
        "sha": "556c64f2297fa16595bf9c47821a7c51a1f8be66",
        "filename": "src/test/netbase_tests.cpp",
        "status": "modified",
        "additions": 85,
        "deletions": 69,
        "changes": 154,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a/src/test/netbase_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a/src/test/netbase_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/netbase_tests.cpp?ref=31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a",
        "patch": "@@ -14,37 +14,47 @@ using namespace std;\n \n BOOST_FIXTURE_TEST_SUITE(netbase_tests, BasicTestingSetup)\n \n+static CNetAddr ResolveIP(const char* ip)\n+{\n+    CNetAddr addr;\n+    LookupHost(ip, addr, false);\n+    return addr;\n+}\n+\n BOOST_AUTO_TEST_CASE(netbase_networks)\n {\n-    BOOST_CHECK(CNetAddr(\"127.0.0.1\").GetNetwork()                              == NET_UNROUTABLE);\n-    BOOST_CHECK(CNetAddr(\"::1\").GetNetwork()                                    == NET_UNROUTABLE);\n-    BOOST_CHECK(CNetAddr(\"8.8.8.8\").GetNetwork()                                == NET_IPV4);\n-    BOOST_CHECK(CNetAddr(\"2001::8888\").GetNetwork()                             == NET_IPV6);\n-    BOOST_CHECK(CNetAddr(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\").GetNetwork() == NET_TOR);\n+    BOOST_CHECK(ResolveIP(\"127.0.0.1\").GetNetwork()                              == NET_UNROUTABLE);\n+    BOOST_CHECK(ResolveIP(\"::1\").GetNetwork()                                    == NET_UNROUTABLE);\n+    BOOST_CHECK(ResolveIP(\"8.8.8.8\").GetNetwork()                                == NET_IPV4);\n+    BOOST_CHECK(ResolveIP(\"2001::8888\").GetNetwork()                             == NET_IPV6);\n+    BOOST_CHECK(ResolveIP(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\").GetNetwork() == NET_TOR);\n+\n }\n \n BOOST_AUTO_TEST_CASE(netbase_properties)\n {\n-    BOOST_CHECK(CNetAddr(\"127.0.0.1\").IsIPv4());\n-    BOOST_CHECK(CNetAddr(\"::FFFF:192.168.1.1\").IsIPv4());\n-    BOOST_CHECK(CNetAddr(\"::1\").IsIPv6());\n-    BOOST_CHECK(CNetAddr(\"10.0.0.1\").IsRFC1918());\n-    BOOST_CHECK(CNetAddr(\"192.168.1.1\").IsRFC1918());\n-    BOOST_CHECK(CNetAddr(\"172.31.255.255\").IsRFC1918());\n-    BOOST_CHECK(CNetAddr(\"2001:0DB8::\").IsRFC3849());\n-    BOOST_CHECK(CNetAddr(\"169.254.1.1\").IsRFC3927());\n-    BOOST_CHECK(CNetAddr(\"2002::1\").IsRFC3964());\n-    BOOST_CHECK(CNetAddr(\"FC00::\").IsRFC4193());\n-    BOOST_CHECK(CNetAddr(\"2001::2\").IsRFC4380());\n-    BOOST_CHECK(CNetAddr(\"2001:10::\").IsRFC4843());\n-    BOOST_CHECK(CNetAddr(\"FE80::\").IsRFC4862());\n-    BOOST_CHECK(CNetAddr(\"64:FF9B::\").IsRFC6052());\n-    BOOST_CHECK(CNetAddr(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\").IsTor());\n-    BOOST_CHECK(CNetAddr(\"127.0.0.1\").IsLocal());\n-    BOOST_CHECK(CNetAddr(\"::1\").IsLocal());\n-    BOOST_CHECK(CNetAddr(\"8.8.8.8\").IsRoutable());\n-    BOOST_CHECK(CNetAddr(\"2001::1\").IsRoutable());\n-    BOOST_CHECK(CNetAddr(\"127.0.0.1\").IsValid());\n+\n+    BOOST_CHECK(ResolveIP(\"127.0.0.1\").IsIPv4());\n+    BOOST_CHECK(ResolveIP(\"::FFFF:192.168.1.1\").IsIPv4());\n+    BOOST_CHECK(ResolveIP(\"::1\").IsIPv6());\n+    BOOST_CHECK(ResolveIP(\"10.0.0.1\").IsRFC1918());\n+    BOOST_CHECK(ResolveIP(\"192.168.1.1\").IsRFC1918());\n+    BOOST_CHECK(ResolveIP(\"172.31.255.255\").IsRFC1918());\n+    BOOST_CHECK(ResolveIP(\"2001:0DB8::\").IsRFC3849());\n+    BOOST_CHECK(ResolveIP(\"169.254.1.1\").IsRFC3927());\n+    BOOST_CHECK(ResolveIP(\"2002::1\").IsRFC3964());\n+    BOOST_CHECK(ResolveIP(\"FC00::\").IsRFC4193());\n+    BOOST_CHECK(ResolveIP(\"2001::2\").IsRFC4380());\n+    BOOST_CHECK(ResolveIP(\"2001:10::\").IsRFC4843());\n+    BOOST_CHECK(ResolveIP(\"FE80::\").IsRFC4862());\n+    BOOST_CHECK(ResolveIP(\"64:FF9B::\").IsRFC6052());\n+    BOOST_CHECK(ResolveIP(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\").IsTor());\n+    BOOST_CHECK(ResolveIP(\"127.0.0.1\").IsLocal());\n+    BOOST_CHECK(ResolveIP(\"::1\").IsLocal());\n+    BOOST_CHECK(ResolveIP(\"8.8.8.8\").IsRoutable());\n+    BOOST_CHECK(ResolveIP(\"2001::1\").IsRoutable());\n+    BOOST_CHECK(ResolveIP(\"127.0.0.1\").IsValid());\n+\n }\n \n bool static TestSplitHost(string test, string host, int port)\n@@ -95,44 +105,47 @@ BOOST_AUTO_TEST_CASE(netbase_lookupnumeric)\n \n BOOST_AUTO_TEST_CASE(onioncat_test)\n {\n+\n     // values from https://web.archive.org/web/20121122003543/http://www.cypherpunk.at/onioncat/wiki/OnionCat\n-    CNetAddr addr1(\"5wyqrzbvrdsumnok.onion\");\n-    CNetAddr addr2(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\");\n+    CNetAddr addr1(ResolveIP(\"5wyqrzbvrdsumnok.onion\"));\n+    CNetAddr addr2(ResolveIP(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\"));\n     BOOST_CHECK(addr1 == addr2);\n     BOOST_CHECK(addr1.IsTor());\n     BOOST_CHECK(addr1.ToStringIP() == \"5wyqrzbvrdsumnok.onion\");\n     BOOST_CHECK(addr1.IsRoutable());\n+\n }\n \n BOOST_AUTO_TEST_CASE(subnet_test)\n {\n+\n     BOOST_CHECK(CSubNet(\"1.2.3.0/24\") == CSubNet(\"1.2.3.0/255.255.255.0\"));\n     BOOST_CHECK(CSubNet(\"1.2.3.0/24\") != CSubNet(\"1.2.4.0/255.255.255.0\"));\n-    BOOST_CHECK(CSubNet(\"1.2.3.0/24\").Match(CNetAddr(\"1.2.3.4\")));\n-    BOOST_CHECK(!CSubNet(\"1.2.2.0/24\").Match(CNetAddr(\"1.2.3.4\")));\n-    BOOST_CHECK(CSubNet(\"1.2.3.4\").Match(CNetAddr(\"1.2.3.4\")));\n-    BOOST_CHECK(CSubNet(\"1.2.3.4/32\").Match(CNetAddr(\"1.2.3.4\")));\n-    BOOST_CHECK(!CSubNet(\"1.2.3.4\").Match(CNetAddr(\"5.6.7.8\")));\n-    BOOST_CHECK(!CSubNet(\"1.2.3.4/32\").Match(CNetAddr(\"5.6.7.8\")));\n-    BOOST_CHECK(CSubNet(\"::ffff:127.0.0.1\").Match(CNetAddr(\"127.0.0.1\")));\n-    BOOST_CHECK(CSubNet(\"1:2:3:4:5:6:7:8\").Match(CNetAddr(\"1:2:3:4:5:6:7:8\")));\n-    BOOST_CHECK(!CSubNet(\"1:2:3:4:5:6:7:8\").Match(CNetAddr(\"1:2:3:4:5:6:7:9\")));\n-    BOOST_CHECK(CSubNet(\"1:2:3:4:5:6:7:0/112\").Match(CNetAddr(\"1:2:3:4:5:6:7:1234\")));\n-    BOOST_CHECK(CSubNet(\"192.168.0.1/24\").Match(CNetAddr(\"192.168.0.2\")));\n-    BOOST_CHECK(CSubNet(\"192.168.0.20/29\").Match(CNetAddr(\"192.168.0.18\")));\n-    BOOST_CHECK(CSubNet(\"1.2.2.1/24\").Match(CNetAddr(\"1.2.2.4\")));\n-    BOOST_CHECK(CSubNet(\"1.2.2.110/31\").Match(CNetAddr(\"1.2.2.111\")));\n-    BOOST_CHECK(CSubNet(\"1.2.2.20/26\").Match(CNetAddr(\"1.2.2.63\")));\n+    BOOST_CHECK(CSubNet(\"1.2.3.0/24\").Match(ResolveIP(\"1.2.3.4\")));\n+    BOOST_CHECK(!CSubNet(\"1.2.2.0/24\").Match(ResolveIP(\"1.2.3.4\")));\n+    BOOST_CHECK(CSubNet(\"1.2.3.4\").Match(ResolveIP(\"1.2.3.4\")));\n+    BOOST_CHECK(CSubNet(\"1.2.3.4/32\").Match(ResolveIP(\"1.2.3.4\")));\n+    BOOST_CHECK(!CSubNet(\"1.2.3.4\").Match(ResolveIP(\"5.6.7.8\")));\n+    BOOST_CHECK(!CSubNet(\"1.2.3.4/32\").Match(ResolveIP(\"5.6.7.8\")));\n+    BOOST_CHECK(CSubNet(\"::ffff:127.0.0.1\").Match(ResolveIP(\"127.0.0.1\")));\n+    BOOST_CHECK(CSubNet(\"1:2:3:4:5:6:7:8\").Match(ResolveIP(\"1:2:3:4:5:6:7:8\")));\n+    BOOST_CHECK(!CSubNet(\"1:2:3:4:5:6:7:8\").Match(ResolveIP(\"1:2:3:4:5:6:7:9\")));\n+    BOOST_CHECK(CSubNet(\"1:2:3:4:5:6:7:0/112\").Match(ResolveIP(\"1:2:3:4:5:6:7:1234\")));\n+    BOOST_CHECK(CSubNet(\"192.168.0.1/24\").Match(ResolveIP(\"192.168.0.2\")));\n+    BOOST_CHECK(CSubNet(\"192.168.0.20/29\").Match(ResolveIP(\"192.168.0.18\")));\n+    BOOST_CHECK(CSubNet(\"1.2.2.1/24\").Match(ResolveIP(\"1.2.2.4\")));\n+    BOOST_CHECK(CSubNet(\"1.2.2.110/31\").Match(ResolveIP(\"1.2.2.111\")));\n+    BOOST_CHECK(CSubNet(\"1.2.2.20/26\").Match(ResolveIP(\"1.2.2.63\")));\n     // All-Matching IPv6 Matches arbitrary IPv4 and IPv6\n-    BOOST_CHECK(CSubNet(\"::/0\").Match(CNetAddr(\"1:2:3:4:5:6:7:1234\")));\n-    BOOST_CHECK(CSubNet(\"::/0\").Match(CNetAddr(\"1.2.3.4\")));\n+    BOOST_CHECK(CSubNet(\"::/0\").Match(ResolveIP(\"1:2:3:4:5:6:7:1234\")));\n+    BOOST_CHECK(CSubNet(\"::/0\").Match(ResolveIP(\"1.2.3.4\")));\n     // All-Matching IPv4 does not Match IPv6\n-    BOOST_CHECK(!CSubNet(\"0.0.0.0/0\").Match(CNetAddr(\"1:2:3:4:5:6:7:1234\")));\n+    BOOST_CHECK(!CSubNet(\"0.0.0.0/0\").Match(ResolveIP(\"1:2:3:4:5:6:7:1234\")));\n     // Invalid subnets Match nothing (not even invalid addresses)\n-    BOOST_CHECK(!CSubNet().Match(CNetAddr(\"1.2.3.4\")));\n-    BOOST_CHECK(!CSubNet(\"\").Match(CNetAddr(\"4.5.6.7\")));\n-    BOOST_CHECK(!CSubNet(\"bloop\").Match(CNetAddr(\"0.0.0.0\")));\n-    BOOST_CHECK(!CSubNet(\"bloop\").Match(CNetAddr(\"hab\")));\n+    BOOST_CHECK(!CSubNet().Match(ResolveIP(\"1.2.3.4\")));\n+    BOOST_CHECK(!CSubNet(\"\").Match(ResolveIP(\"4.5.6.7\")));\n+    BOOST_CHECK(!CSubNet(\"bloop\").Match(ResolveIP(\"0.0.0.0\")));\n+    BOOST_CHECK(!CSubNet(\"bloop\").Match(ResolveIP(\"hab\")));\n     // Check valid/invalid\n     BOOST_CHECK(CSubNet(\"1.2.3.0/0\").IsValid());\n     BOOST_CHECK(!CSubNet(\"1.2.3.0/-1\").IsValid());\n@@ -146,15 +159,15 @@ BOOST_AUTO_TEST_CASE(subnet_test)\n     BOOST_CHECK(!CSubNet(\"fuzzy\").IsValid());\n \n     //CNetAddr constructor test\n-    BOOST_CHECK(CSubNet(CNetAddr(\"127.0.0.1\")).IsValid());\n-    BOOST_CHECK(CSubNet(CNetAddr(\"127.0.0.1\")).Match(CNetAddr(\"127.0.0.1\")));\n-    BOOST_CHECK(!CSubNet(CNetAddr(\"127.0.0.1\")).Match(CNetAddr(\"127.0.0.2\")));\n-    BOOST_CHECK(CSubNet(CNetAddr(\"127.0.0.1\")).ToString() == \"127.0.0.1/32\");\n+    BOOST_CHECK(CSubNet(ResolveIP(\"127.0.0.1\")).IsValid());\n+    BOOST_CHECK(CSubNet(ResolveIP(\"127.0.0.1\")).Match(ResolveIP(\"127.0.0.1\")));\n+    BOOST_CHECK(!CSubNet(ResolveIP(\"127.0.0.1\")).Match(ResolveIP(\"127.0.0.2\")));\n+    BOOST_CHECK(CSubNet(ResolveIP(\"127.0.0.1\")).ToString() == \"127.0.0.1/32\");\n \n-    BOOST_CHECK(CSubNet(CNetAddr(\"1:2:3:4:5:6:7:8\")).IsValid());\n-    BOOST_CHECK(CSubNet(CNetAddr(\"1:2:3:4:5:6:7:8\")).Match(CNetAddr(\"1:2:3:4:5:6:7:8\")));\n-    BOOST_CHECK(!CSubNet(CNetAddr(\"1:2:3:4:5:6:7:8\")).Match(CNetAddr(\"1:2:3:4:5:6:7:9\")));\n-    BOOST_CHECK(CSubNet(CNetAddr(\"1:2:3:4:5:6:7:8\")).ToString() == \"1:2:3:4:5:6:7:8/128\");\n+    BOOST_CHECK(CSubNet(ResolveIP(\"1:2:3:4:5:6:7:8\")).IsValid());\n+    BOOST_CHECK(CSubNet(ResolveIP(\"1:2:3:4:5:6:7:8\")).Match(ResolveIP(\"1:2:3:4:5:6:7:8\")));\n+    BOOST_CHECK(!CSubNet(ResolveIP(\"1:2:3:4:5:6:7:8\")).Match(ResolveIP(\"1:2:3:4:5:6:7:9\")));\n+    BOOST_CHECK(CSubNet(ResolveIP(\"1:2:3:4:5:6:7:8\")).ToString() == \"1:2:3:4:5:6:7:8/128\");\n \n     CSubNet subnet = CSubNet(\"1.2.3.4/255.255.255.255\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.4/32\");\n@@ -233,22 +246,25 @@ BOOST_AUTO_TEST_CASE(subnet_test)\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/255.255.232.0\");\n     subnet = CSubNet(\"1:2:3:4:5:6:7:8/ffff:ffff:ffff:fffe:ffff:ffff:ffff:ff0f\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1:2:3:4:5:6:7:8/ffff:ffff:ffff:fffe:ffff:ffff:ffff:ff0f\");\n+\n }\n \n BOOST_AUTO_TEST_CASE(netbase_getgroup)\n {\n-    BOOST_CHECK(CNetAddr(\"127.0.0.1\").GetGroup() == boost::assign::list_of(0)); // Local -> !Routable()\n-    BOOST_CHECK(CNetAddr(\"257.0.0.1\").GetGroup() == boost::assign::list_of(0)); // !Valid -> !Routable()\n-    BOOST_CHECK(CNetAddr(\"10.0.0.1\").GetGroup() == boost::assign::list_of(0)); // RFC1918 -> !Routable()\n-    BOOST_CHECK(CNetAddr(\"169.254.1.1\").GetGroup() == boost::assign::list_of(0)); // RFC3927 -> !Routable()\n-    BOOST_CHECK(CNetAddr(\"1.2.3.4\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // IPv4\n-    BOOST_CHECK(CNetAddr(\"::FFFF:0:102:304\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // RFC6145\n-    BOOST_CHECK(CNetAddr(\"64:FF9B::102:304\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // RFC6052\n-    BOOST_CHECK(CNetAddr(\"2002:102:304:9999:9999:9999:9999:9999\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // RFC3964\n-    BOOST_CHECK(CNetAddr(\"2001:0:9999:9999:9999:9999:FEFD:FCFB\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // RFC4380\n-    BOOST_CHECK(CNetAddr(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\").GetGroup() == boost::assign::list_of((unsigned char)NET_TOR)(239)); // Tor\n-    BOOST_CHECK(CNetAddr(\"2001:470:abcd:9999:9999:9999:9999:9999\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV6)(32)(1)(4)(112)(175)); //he.net\n-    BOOST_CHECK(CNetAddr(\"2001:2001:9999:9999:9999:9999:9999:9999\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV6)(32)(1)(32)(1)); //IPv6\n+\n+    BOOST_CHECK(ResolveIP(\"127.0.0.1\").GetGroup() == boost::assign::list_of(0)); // Local -> !Routable()\n+    BOOST_CHECK(ResolveIP(\"257.0.0.1\").GetGroup() == boost::assign::list_of(0)); // !Valid -> !Routable()\n+    BOOST_CHECK(ResolveIP(\"10.0.0.1\").GetGroup() == boost::assign::list_of(0)); // RFC1918 -> !Routable()\n+    BOOST_CHECK(ResolveIP(\"169.254.1.1\").GetGroup() == boost::assign::list_of(0)); // RFC3927 -> !Routable()\n+    BOOST_CHECK(ResolveIP(\"1.2.3.4\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // IPv4\n+    BOOST_CHECK(ResolveIP(\"::FFFF:0:102:304\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // RFC6145\n+    BOOST_CHECK(ResolveIP(\"64:FF9B::102:304\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // RFC6052\n+    BOOST_CHECK(ResolveIP(\"2002:102:304:9999:9999:9999:9999:9999\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // RFC3964\n+    BOOST_CHECK(ResolveIP(\"2001:0:9999:9999:9999:9999:FEFD:FCFB\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // RFC4380\n+    BOOST_CHECK(ResolveIP(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\").GetGroup() == boost::assign::list_of((unsigned char)NET_TOR)(239)); // Tor\n+    BOOST_CHECK(ResolveIP(\"2001:470:abcd:9999:9999:9999:9999:9999\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV6)(32)(1)(4)(112)(175)); //he.net\n+    BOOST_CHECK(ResolveIP(\"2001:2001:9999:9999:9999:9999:9999:9999\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV6)(32)(1)(32)(1)); //IPv6\n+\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "f96c7c4d91f3c09d26658bc9c15aa561689fa2d4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmOTZjN2M0ZDkxZjNjMDlkMjY2NThiYzljMTVhYTU2MTY4OWZhMmQ0",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-05-31T17:51:11Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-07-31T17:24:07Z"
      },
      "message": "net: Split resolving out of CService",
      "tree": {
        "sha": "4fc6bff63eff752e4791ae3fb64de77b427afeee",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4fc6bff63eff752e4791ae3fb64de77b427afeee"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f96c7c4d91f3c09d26658bc9c15aa561689fa2d4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f96c7c4d91f3c09d26658bc9c15aa561689fa2d4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f96c7c4d91f3c09d26658bc9c15aa561689fa2d4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f96c7c4d91f3c09d26658bc9c15aa561689fa2d4/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/31d6b1d5f0414d8b356d8cb9c99961d8a04d6c0a"
      }
    ],
    "stats": {
      "total": 195,
      "additions": 94,
      "deletions": 101
    },
    "files": [
      {
        "sha": "57aa134b38fc37b5c76279ccb7366099ef4d5b11",
        "filename": "src/httpserver.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f96c7c4d91f3c09d26658bc9c15aa561689fa2d4/src/httpserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f96c7c4d91f3c09d26658bc9c15aa561689fa2d4/src/httpserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.cpp?ref=f96c7c4d91f3c09d26658bc9c15aa561689fa2d4",
        "patch": "@@ -614,7 +614,7 @@ CService HTTPRequest::GetPeer()\n         const char* address = \"\";\n         uint16_t port = 0;\n         evhttp_connection_get_peer(con, (char**)&address, &port);\n-        peer = CService(address, port);\n+        LookupNumeric(address, peer, port);\n     }\n     return peer;\n }"
      },
      {
        "sha": "77ecf05f1db90bbe1413e6c558beed022259b2e0",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f96c7c4d91f3c09d26658bc9c15aa561689fa2d4/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f96c7c4d91f3c09d26658bc9c15aa561689fa2d4/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=f96c7c4d91f3c09d26658bc9c15aa561689fa2d4",
        "patch": "@@ -1096,7 +1096,9 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n     std::string proxyArg = GetArg(\"-proxy\", \"\");\n     SetLimited(NET_TOR);\n     if (proxyArg != \"\" && proxyArg != \"0\") {\n-        proxyType addrProxy = proxyType(CService(proxyArg, 9050), proxyRandomize);\n+        CService resolved;\n+        LookupNumeric(proxyArg.c_str(), resolved, 9050);\n+        proxyType addrProxy = proxyType(resolved, proxyRandomize);\n         if (!addrProxy.IsValid())\n             return InitError(strprintf(_(\"Invalid -proxy address: '%s'\"), proxyArg));\n \n@@ -1115,7 +1117,9 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n         if (onionArg == \"0\") { // Handle -noonion/-onion=0\n             SetLimited(NET_TOR); // set onions as unreachable\n         } else {\n-            proxyType addrOnion = proxyType(CService(onionArg, 9050), proxyRandomize);\n+            CService resolved;\n+            LookupNumeric(onionArg.c_str(), resolved, 9050);\n+            proxyType addrOnion = proxyType(resolved, proxyRandomize);\n             if (!addrOnion.IsValid())\n                 return InitError(strprintf(_(\"Invalid -onion address: '%s'\"), onionArg));\n             SetProxy(NET_TOR, addrOnion);"
      },
      {
        "sha": "e44bdafc79889cb8d4eee35e7e94b596a92327bf",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 6,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f96c7c4d91f3c09d26658bc9c15aa561689fa2d4/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f96c7c4d91f3c09d26658bc9c15aa561689fa2d4/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=f96c7c4d91f3c09d26658bc9c15aa561689fa2d4",
        "patch": "@@ -175,7 +175,7 @@ static std::vector<CAddress> convertSeed6(const std::vector<SeedSpec6> &vSeedsIn\n // one by discovery.\n CAddress GetLocalAddress(const CNetAddr *paddrPeer)\n {\n-    CAddress ret(CService(\"0.0.0.0\",GetListenPort()), NODE_NONE);\n+    CAddress ret(CService(CNetAddr(),GetListenPort()), NODE_NONE);\n     CService addr;\n     if (GetLocal(addr, paddrPeer))\n     {\n@@ -494,7 +494,7 @@ void CNode::PushVersion()\n     int nBestHeight = GetNodeSignals().GetHeight().get_value_or(0);\n \n     int64_t nTime = (fInbound ? GetAdjustedTime() : GetTime());\n-    CAddress addrYou = (addr.IsRoutable() && !IsProxy(addr) ? addr : CAddress(CService(\"0.0.0.0\", 0), addr.nServices));\n+    CAddress addrYou = (addr.IsRoutable() && !IsProxy(addr) ? addr : CAddress(CService(), addr.nServices));\n     CAddress addrMe = GetLocalAddress(&addr);\n     GetRandBytes((unsigned char*)&nLocalHostNonce, sizeof(nLocalHostNonce));\n     if (fLogIPs)\n@@ -1727,7 +1727,8 @@ std::vector<AddedNodeInfo> GetAddedNodeInfo()\n     }\n \n     BOOST_FOREACH(const std::string& strAddNode, lAddresses) {\n-        CService service(strAddNode, Params().GetDefaultPort());\n+        CService service;\n+        LookupNumeric(strAddNode.c_str(), service, Params().GetDefaultPort());\n         if (service.IsValid()) {\n             // strAddNode is an IP:port\n             auto it = mapConnected.find(service);\n@@ -1765,7 +1766,8 @@ void ThreadOpenAddedConnections()\n                 CSemaphoreGrant grant(*semOutbound);\n                 // If strAddedNode is an IP/port, decode it immediately, so\n                 // OpenNetworkConnection can detect existing connections to that IP/port.\n-                CService service(info.strAddedNode, Params().GetDefaultPort());\n+                CService service;\n+                LookupNumeric(info.strAddedNode.c_str(), service, Params().GetDefaultPort());\n                 OpenNetworkConnection(CAddress(service, NODE_NONE), false, &grant, info.strAddedNode.c_str(), false);\n                 MilliSleep(500);\n             }\n@@ -2063,8 +2065,11 @@ void StartNode(boost::thread_group& threadGroup, CScheduler& scheduler)\n         semOutbound = new CSemaphore(nMaxOutbound);\n     }\n \n-    if (pnodeLocalHost == NULL)\n-        pnodeLocalHost = new CNode(INVALID_SOCKET, CAddress(CService(\"127.0.0.1\", 0), nLocalServices));\n+    if (pnodeLocalHost == NULL) {\n+        CNetAddr local;\n+        LookupHost(\"127.0.0.1\", local, false);\n+        pnodeLocalHost = new CNode(INVALID_SOCKET, CAddress(CService(local, 0), nLocalServices));\n+    }\n \n     Discover(threadGroup);\n "
      },
      {
        "sha": "2e7a4f758a39e4d02ef5b998f504c25aee0cc573",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 33,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f96c7c4d91f3c09d26658bc9c15aa561689fa2d4/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f96c7c4d91f3c09d26658bc9c15aa561689fa2d4/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=f96c7c4d91f3c09d26658bc9c15aa561689fa2d4",
        "patch": "@@ -639,7 +639,7 @@ bool ConnectSocketByName(CService &addr, SOCKET& hSocketRet, const char *pszDest\n         }\n     }\n \n-    addr = CService(\"0.0.0.0:0\");\n+    addr = CService();\n \n     if (!HaveNameProxy())\n         return false;\n@@ -1124,38 +1124,6 @@ bool CService::SetSockAddr(const struct sockaddr *paddr)\n     }\n }\n \n-CService::CService(const char *pszIpPort)\n-{\n-    Init();\n-    CService ip;\n-    if (Lookup(pszIpPort, ip, 0, false))\n-        *this = ip;\n-}\n-\n-CService::CService(const char *pszIpPort, int portDefault)\n-{\n-    Init();\n-    CService ip;\n-    if (Lookup(pszIpPort, ip, portDefault, false))\n-        *this = ip;\n-}\n-\n-CService::CService(const std::string &strIpPort)\n-{\n-    Init();\n-    CService ip;\n-    if (Lookup(strIpPort.c_str(), ip, 0, false))\n-        *this = ip;\n-}\n-\n-CService::CService(const std::string &strIpPort, int portDefault)\n-{\n-    Init();\n-    CService ip;\n-    if (Lookup(strIpPort.c_str(), ip, portDefault, false))\n-        *this = ip;\n-}\n-\n unsigned short CService::GetPort() const\n {\n     return port;"
      },
      {
        "sha": "97b96f69cc55eebcc70ada1bc34b0b519c93d5a0",
        "filename": "src/netbase.h",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f96c7c4d91f3c09d26658bc9c15aa561689fa2d4/src/netbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f96c7c4d91f3c09d26658bc9c15aa561689fa2d4/src/netbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.h?ref=f96c7c4d91f3c09d26658bc9c15aa561689fa2d4",
        "patch": "@@ -152,10 +152,6 @@ class CService : public CNetAddr\n         CService(const CNetAddr& ip, unsigned short port);\n         CService(const struct in_addr& ipv4Addr, unsigned short port);\n         CService(const struct sockaddr_in& addr);\n-        explicit CService(const char *pszIpPort, int portDefault);\n-        explicit CService(const char *pszIpPort);\n-        explicit CService(const std::string& strIpPort, int portDefault);\n-        explicit CService(const std::string& strIpPort);\n         void Init();\n         void SetPort(unsigned short portIn);\n         unsigned short GetPort() const;"
      },
      {
        "sha": "e419e4d9ee5794afd8b7f9bcbdfcb07f5c1548d3",
        "filename": "src/qt/optionsdialog.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f96c7c4d91f3c09d26658bc9c15aa561689fa2d4/src/qt/optionsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f96c7c4d91f3c09d26658bc9c15aa561689fa2d4/src/qt/optionsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsdialog.cpp?ref=f96c7c4d91f3c09d26658bc9c15aa561689fa2d4",
        "patch": "@@ -327,7 +327,9 @@ QValidator::State ProxyAddressValidator::validate(QString &input, int &pos) cons\n {\n     Q_UNUSED(pos);\n     // Validate the proxy\n-    proxyType addrProxy = proxyType(CService(input.toStdString(), 9050), true);\n+    CService serv;\n+    LookupNumeric(input.toStdString().c_str(), serv, 9050);\n+    proxyType addrProxy = proxyType(serv, true);\n     if (addrProxy.IsValid())\n         return QValidator::Acceptable;\n "
      },
      {
        "sha": "b84d00856bd66acf85458d0b7939eaf7bcb868f1",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 56,
        "deletions": 44,
        "changes": 100,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f96c7c4d91f3c09d26658bc9c15aa561689fa2d4/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f96c7c4d91f3c09d26658bc9c15aa561689fa2d4/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=f96c7c4d91f3c09d26658bc9c15aa561689fa2d4",
        "patch": "@@ -62,6 +62,18 @@ static CNetAddr ResolveIP(std::string ip)\n     return ResolveIP(ip.c_str());\n }\n \n+static CService ResolveService(const char* ip, int port = 0)\n+{\n+    CService serv;\n+    BOOST_CHECK_MESSAGE(Lookup(ip, serv, port, false), strprintf(\"failed to resolve: %s:%i\", ip, port));\n+    return serv;\n+}\n+\n+static CService ResolveService(std::string ip, int port = 0)\n+{\n+    return ResolveService(ip.c_str(), port);\n+}\n+\n BOOST_FIXTURE_TEST_SUITE(addrman_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(addrman_simple)\n@@ -79,22 +91,22 @@ BOOST_AUTO_TEST_CASE(addrman_simple)\n     BOOST_CHECK(addr_null.ToString() == \"[::]:0\");\n \n     // Test 2: Does Addrman::Add work as expected.\n-    CService addr1 = CService(\"250.1.1.1\", 8333);\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n     BOOST_CHECK(addrman.size() == 1);\n     CAddrInfo addr_ret1 = addrman.Select();\n     BOOST_CHECK(addr_ret1.ToString() == \"250.1.1.1:8333\");\n \n     // Test 3: Does IP address deduplication work correctly.\n     //  Expected dup IP should not be added.\n-    CService addr1_dup = CService(\"250.1.1.1\", 8333);\n+    CService addr1_dup = ResolveService(\"250.1.1.1\", 8333);\n     addrman.Add(CAddress(addr1_dup, NODE_NONE), source);\n     BOOST_CHECK(addrman.size() == 1);\n \n \n     // Test 5: New table has one addr and we add a diff addr we should\n     //  have two addrs.\n-    CService addr2 = CService(\"250.1.1.2\", 8333);\n+    CService addr2 = ResolveService(\"250.1.1.2\", 8333);\n     addrman.Add(CAddress(addr2, NODE_NONE), source);\n     BOOST_CHECK(addrman.size() == 2);\n \n@@ -117,11 +129,11 @@ BOOST_AUTO_TEST_CASE(addrman_ports)\n     BOOST_CHECK(addrman.size() == 0);\n \n     // Test 7; Addr with same IP but diff port does not replace existing addr.\n-    CService addr1 = CService(\"250.1.1.1\", 8333);\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n     BOOST_CHECK(addrman.size() == 1);\n \n-    CService addr1_port = CService(\"250.1.1.1\", 8334);\n+    CService addr1_port = ResolveService(\"250.1.1.1\", 8334);\n     addrman.Add(CAddress(addr1_port, NODE_NONE), source);\n     BOOST_CHECK(addrman.size() == 1);\n     CAddrInfo addr_ret2 = addrman.Select();\n@@ -147,7 +159,7 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n     // Test 9: Select from new with 1 addr in new.\n-    CService addr1 = CService(\"250.1.1.1\", 8333);\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n     BOOST_CHECK(addrman.size() == 1);\n \n@@ -168,24 +180,24 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n \n \n     // Add three addresses to new table.\n-    CService addr2 = CService(\"250.3.1.1\", 8333);\n-    CService addr3 = CService(\"250.3.2.2\", 9999);\n-    CService addr4 = CService(\"250.3.3.3\", 9999);\n+    CService addr2 = ResolveService(\"250.3.1.1\", 8333);\n+    CService addr3 = ResolveService(\"250.3.2.2\", 9999);\n+    CService addr4 = ResolveService(\"250.3.3.3\", 9999);\n \n-    addrman.Add(CAddress(addr2, NODE_NONE), CService(\"250.3.1.1\", 8333), NODE_NONE);\n-    addrman.Add(CAddress(addr3, NODE_NONE), CService(\"250.3.1.1\", 8333), NODE_NONE);\n-    addrman.Add(CAddress(addr4, NODE_NONE), CService(\"250.4.1.1\", 8333), NODE_NONE);\n+    addrman.Add(CAddress(addr2, NODE_NONE), ResolveService(\"250.3.1.1\", 8333));\n+    addrman.Add(CAddress(addr3, NODE_NONE), ResolveService(\"250.3.1.1\", 8333));\n+    addrman.Add(CAddress(addr4, NODE_NONE), ResolveService(\"250.4.1.1\", 8333));\n \n     // Add three addresses to tried table.\n-    CService addr5 = CService(\"250.4.4.4\", 8333);\n-    CService addr6 = CService(\"250.4.5.5\", 7777);\n-    CService addr7 = CService(\"250.4.6.6\", 8333);\n+    CService addr5 = ResolveService(\"250.4.4.4\", 8333);\n+    CService addr6 = ResolveService(\"250.4.5.5\", 7777);\n+    CService addr7 = ResolveService(\"250.4.6.6\", 8333);\n \n-    addrman.Add(CAddress(addr5, NODE_NONE), CService(\"250.3.1.1\", 8333), NODE_NONE);\n+    addrman.Add(CAddress(addr5, NODE_NONE), ResolveService(\"250.3.1.1\", 8333));\n     addrman.Good(CAddress(addr5, NODE_NONE));\n-    addrman.Add(CAddress(addr6, NODE_NONE), CService(\"250.3.1.1\", 8333), NODE_NONE);\n+    addrman.Add(CAddress(addr6, NODE_NONE), ResolveService(\"250.3.1.1\", 8333));\n     addrman.Good(CAddress(addr6, NODE_NONE));\n-    addrman.Add(CAddress(addr7, NODE_NONE), CService(\"250.1.1.3\", 8333), NODE_NONE);\n+    addrman.Add(CAddress(addr7, NODE_NONE), ResolveService(\"250.1.1.3\", 8333));\n     addrman.Good(CAddress(addr7, NODE_NONE));\n \n     // Test 11: 6 addrs + 1 addr from last test = 7.\n@@ -210,19 +222,19 @@ BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n     BOOST_CHECK(addrman.size() == 0);\n \n     for (unsigned int i = 1; i < 18; i++) {\n-        CService addr = CService(\"250.1.1.\" + boost::to_string(i));\n+        CService addr = ResolveService(\"250.1.1.\" + boost::to_string(i));\n         addrman.Add(CAddress(addr, NODE_NONE), source);\n \n         //Test 13: No collision in new table yet.\n         BOOST_CHECK(addrman.size() == i);\n     }\n \n     //Test 14: new table collision!\n-    CService addr1 = CService(\"250.1.1.18\");\n+    CService addr1 = ResolveService(\"250.1.1.18\");\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n     BOOST_CHECK(addrman.size() == 17);\n \n-    CService addr2 = CService(\"250.1.1.19\");\n+    CService addr2 = ResolveService(\"250.1.1.19\");\n     addrman.Add(CAddress(addr2, NODE_NONE), source);\n     BOOST_CHECK(addrman.size() == 18);\n }\n@@ -239,7 +251,7 @@ BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n     BOOST_CHECK(addrman.size() == 0);\n \n     for (unsigned int i = 1; i < 80; i++) {\n-        CService addr = CService(\"250.1.1.\" + boost::to_string(i));\n+        CService addr = ResolveService(\"250.1.1.\" + boost::to_string(i));\n         addrman.Add(CAddress(addr, NODE_NONE), source);\n         addrman.Good(CAddress(addr, NODE_NONE));\n \n@@ -249,11 +261,11 @@ BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n     }\n \n     //Test 16: tried table collision!\n-    CService addr1 = CService(\"250.1.1.80\");\n+    CService addr1 = ResolveService(\"250.1.1.80\");\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n     BOOST_CHECK(addrman.size() == 79);\n \n-    CService addr2 = CService(\"250.1.1.81\");\n+    CService addr2 = ResolveService(\"250.1.1.81\");\n     addrman.Add(CAddress(addr2, NODE_NONE), source);\n     BOOST_CHECK(addrman.size() == 80);\n }\n@@ -267,9 +279,9 @@ BOOST_AUTO_TEST_CASE(addrman_find)\n \n     BOOST_CHECK(addrman.size() == 0);\n \n-    CAddress addr1 = CAddress(CService(\"250.1.2.1\", 8333), NODE_NONE);\n-    CAddress addr2 = CAddress(CService(\"250.1.2.1\", 9999), NODE_NONE);\n-    CAddress addr3 = CAddress(CService(\"251.255.2.1\", 8333), NODE_NONE);\n+    CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n+    CAddress addr2 = CAddress(ResolveService(\"250.1.2.1\", 9999), NODE_NONE);\n+    CAddress addr3 = CAddress(ResolveService(\"251.255.2.1\", 8333), NODE_NONE);\n \n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n     CNetAddr source2 = ResolveIP(\"250.1.2.2\");\n@@ -306,7 +318,7 @@ BOOST_AUTO_TEST_CASE(addrman_create)\n \n     BOOST_CHECK(addrman.size() == 0);\n \n-    CAddress addr1 = CAddress(CService(\"250.1.2.1\", 8333), NODE_NONE);\n+    CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n \n     int nId;\n@@ -329,7 +341,7 @@ BOOST_AUTO_TEST_CASE(addrman_delete)\n \n     BOOST_CHECK(addrman.size() == 0);\n \n-    CAddress addr1 = CAddress(CService(\"250.1.2.1\", 8333), NODE_NONE);\n+    CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n \n     int nId;\n@@ -356,15 +368,15 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n     vector<CAddress> vAddr1 = addrman.GetAddr();\n     BOOST_CHECK(vAddr1.size() == 0);\n \n-    CAddress addr1 = CAddress(CService(\"250.250.2.1\", 8333), NODE_NONE);\n+    CAddress addr1 = CAddress(ResolveService(\"250.250.2.1\", 8333), NODE_NONE);\n     addr1.nTime = GetAdjustedTime(); // Set time so isTerrible = false\n-    CAddress addr2 = CAddress(CService(\"250.251.2.2\", 9999), NODE_NONE);\n+    CAddress addr2 = CAddress(ResolveService(\"250.251.2.2\", 9999), NODE_NONE);\n     addr2.nTime = GetAdjustedTime();\n-    CAddress addr3 = CAddress(CService(\"251.252.2.3\", 8333), NODE_NONE);\n+    CAddress addr3 = CAddress(ResolveService(\"251.252.2.3\", 8333), NODE_NONE);\n     addr3.nTime = GetAdjustedTime();\n-    CAddress addr4 = CAddress(CService(\"252.253.3.4\", 8333), NODE_NONE);\n+    CAddress addr4 = CAddress(ResolveService(\"252.253.3.4\", 8333), NODE_NONE);\n     addr4.nTime = GetAdjustedTime();\n-    CAddress addr5 = CAddress(CService(\"252.254.4.5\", 8333), NODE_NONE);\n+    CAddress addr5 = CAddress(ResolveService(\"252.254.4.5\", 8333), NODE_NONE);\n     addr5.nTime = GetAdjustedTime();\n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n     CNetAddr source2 = ResolveIP(\"250.2.3.3\");\n@@ -390,7 +402,7 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n         int octet2 = (i / 256) % 256;\n         int octet3 = (i / (256 * 2)) % 256;\n         string strAddr = boost::to_string(octet1) + \".\" + boost::to_string(octet2) + \".\" + boost::to_string(octet3) + \".23\";\n-        CAddress addr = CAddress(CService(strAddr), NODE_NONE);\n+        CAddress addr = CAddress(ResolveService(strAddr), NODE_NONE);\n         \n         // Ensure that for all addrs in addrman, isTerrible == false.\n         addr.nTime = GetAdjustedTime();\n@@ -415,8 +427,8 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    CAddress addr1 = CAddress(CService(\"250.1.1.1\", 8333), NODE_NONE);\n-    CAddress addr2 = CAddress(CService(\"250.1.1.1\", 9999), NODE_NONE);\n+    CAddress addr1 = CAddress(ResolveService(\"250.1.1.1\", 8333), NODE_NONE);\n+    CAddress addr2 = CAddress(ResolveService(\"250.1.1.1\", 9999), NODE_NONE);\n \n     CNetAddr source1 = ResolveIP(\"250.1.1.1\");\n \n@@ -443,7 +455,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n     set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n         CAddrInfo infoi = CAddrInfo(\n-            CAddress(CService(\"250.1.1.\" + boost::to_string(i)), NODE_NONE),\n+            CAddress(ResolveService(\"250.1.1.\" + boost::to_string(i)), NODE_NONE),\n             ResolveIP(\"250.1.1.\" + boost::to_string(i)));\n         int bucket = infoi.GetTriedBucket(nKey1);\n         buckets.insert(bucket);\n@@ -455,7 +467,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n     buckets.clear();\n     for (int j = 0; j < 255; j++) {\n         CAddrInfo infoj = CAddrInfo(\n-            CAddress(CService(\"250.\" + boost::to_string(j) + \".1.1\"), NODE_NONE),\n+            CAddress(ResolveService(\"250.\" + boost::to_string(j) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"250.\" + boost::to_string(j) + \".1.1\"));\n         int bucket = infoj.GetTriedBucket(nKey1);\n         buckets.insert(bucket);\n@@ -472,8 +484,8 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    CAddress addr1 = CAddress(CService(\"250.1.2.1\", 8333), NODE_NONE);\n-    CAddress addr2 = CAddress(CService(\"250.1.2.1\", 9999), NODE_NONE);\n+    CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n+    CAddress addr2 = CAddress(ResolveService(\"250.1.2.1\", 9999), NODE_NONE);\n \n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n \n@@ -496,7 +508,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n         CAddrInfo infoi = CAddrInfo(\n-            CAddress(CService(\"250.1.1.\" + boost::to_string(i)), NODE_NONE),\n+            CAddress(ResolveService(\"250.1.1.\" + boost::to_string(i)), NODE_NONE),\n             ResolveIP(\"250.1.1.\" + boost::to_string(i)));\n         int bucket = infoi.GetNewBucket(nKey1);\n         buckets.insert(bucket);\n@@ -508,7 +520,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     buckets.clear();\n     for (int j = 0; j < 4 * 255; j++) {\n         CAddrInfo infoj = CAddrInfo(CAddress(\n-                                        CService(\n+                                        ResolveService(\n                                             boost::to_string(250 + (j / 255)) + \".\" + boost::to_string(j % 256) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"251.4.1.1\"));\n         int bucket = infoj.GetNewBucket(nKey1);\n@@ -521,7 +533,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     buckets.clear();\n     for (int p = 0; p < 255; p++) {\n         CAddrInfo infoj = CAddrInfo(\n-            CAddress(CService(\"250.1.1.1\"), NODE_NONE),\n+            CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE),\n             ResolveIP(\"250.\" + boost::to_string(p) + \".1.1\"));\n         int bucket = infoj.GetNewBucket(nKey1);\n         buckets.insert(bucket);"
      },
      {
        "sha": "fca1a16b2dc81b00a61b4a02ba955b19fde58e4b",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 7,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f96c7c4d91f3c09d26658bc9c15aa561689fa2d4/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f96c7c4d91f3c09d26658bc9c15aa561689fa2d4/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=f96c7c4d91f3c09d26658bc9c15aa561689fa2d4",
        "patch": "@@ -51,7 +51,9 @@ class CAddrManCorrupted : public CAddrManSerializationMock\n         int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);\n         s << nUBuckets;\n \n-        CAddress addr = CAddress(CService(\"252.1.1.1\", 7777), NODE_NONE);\n+        CService serv;\n+        Lookup(\"252.1.1.1\", serv, 7777, false);\n+        CAddress addr = CAddress(serv, NODE_NONE);\n         CNetAddr resolved;\n         LookupHost(\"252.2.2.2\", resolved, false);\n         CAddrInfo info = CAddrInfo(addr, resolved);\n@@ -76,14 +78,17 @@ BOOST_AUTO_TEST_CASE(caddrdb_read)\n     CAddrManUncorrupted addrmanUncorrupted;\n     addrmanUncorrupted.MakeDeterministic();\n \n-    CService addr1 = CService(\"250.7.1.1\", 8333);\n-    CService addr2 = CService(\"250.7.2.2\", 9999);\n-    CService addr3 = CService(\"250.7.3.3\", 9999);\n+    CService addr1, addr2, addr3;\n+    Lookup(\"250.7.1.1\", addr1, 8333, false);\n+    Lookup(\"250.7.2.2\", addr2, 9999, false);\n+    Lookup(\"250.7.3.3\", addr3, 9999, false);\n \n     // Add three addresses to new table.\n-    addrmanUncorrupted.Add(CAddress(addr1, NODE_NONE), CService(\"252.5.1.1\", 8333));\n-    addrmanUncorrupted.Add(CAddress(addr2, NODE_NONE), CService(\"252.5.1.1\", 8333));\n-    addrmanUncorrupted.Add(CAddress(addr3, NODE_NONE), CService(\"252.5.1.1\", 8333));\n+    CService source;\n+    Lookup(\"252.5.1.1\", source, 8333, false);\n+    addrmanUncorrupted.Add(CAddress(addr1, NODE_NONE), source);\n+    addrmanUncorrupted.Add(CAddress(addr2, NODE_NONE), source);\n+    addrmanUncorrupted.Add(CAddress(addr3, NODE_NONE), source);\n \n     // Test that the de-serialization does not throw an exception.\n     CDataStream ssPeers1 = AddrmanToStream(addrmanUncorrupted);"
      },
      {
        "sha": "d3d782747fd2c7bab0c83c1a042ef40f18ebd15c",
        "filename": "src/torcontrol.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f96c7c4d91f3c09d26658bc9c15aa561689fa2d4/src/torcontrol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f96c7c4d91f3c09d26658bc9c15aa561689fa2d4/src/torcontrol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/torcontrol.cpp?ref=f96c7c4d91f3c09d26658bc9c15aa561689fa2d4",
        "patch": "@@ -437,8 +437,7 @@ void TorController::add_onion_cb(TorControlConnection& conn, const TorControlRep\n             if ((i = m.find(\"PrivateKey\")) != m.end())\n                 private_key = i->second;\n         }\n-\n-        service = CService(service_id+\".onion\", GetListenPort());\n+        LookupNumeric(std::string(service_id+\".onion\").c_str(), service, GetListenPort());\n         LogPrintf(\"tor: Got service ID %s, advertising service %s\\n\", service_id, service.ToString());\n         if (WriteBinaryFile(GetPrivateKeyFile(), private_key)) {\n             LogPrint(\"tor\", \"tor: Cached service private key to %s\\n\", GetPrivateKeyFile());\n@@ -462,7 +461,9 @@ void TorController::auth_cb(TorControlConnection& conn, const TorControlReply& r\n         // Now that we know Tor is running setup the proxy for onion addresses\n         // if -onion isn't set to something else.\n         if (GetArg(\"-onion\", \"\") == \"\") {\n-            proxyType addrOnion = proxyType(CService(\"127.0.0.1\", 9050), true);\n+            CService resolved;\n+            assert(LookupNumeric(\"127.0.0.1\", resolved, 9050));\n+            proxyType addrOnion = proxyType(resolved, true);\n             SetProxy(NET_TOR, addrOnion);\n             SetLimited(NET_TOR, false);\n         }"
      }
    ]
  },
  {
    "sha": "b6c3ff3daed432e71d1c5bfe2357c4bb9fdc862a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNmMzZmYzZGFlZDQzMmU3MWQxYzViZmUyMzU3YzRiYjlmZGM4NjJh",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-05-31T19:50:24Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-07-31T18:01:43Z"
      },
      "message": "net: Split resolving out of CSubNet",
      "tree": {
        "sha": "102e1236181b8fd21235e31154c160cc9a393757",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/102e1236181b8fd21235e31154c160cc9a393757"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b6c3ff3daed432e71d1c5bfe2357c4bb9fdc862a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b6c3ff3daed432e71d1c5bfe2357c4bb9fdc862a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b6c3ff3daed432e71d1c5bfe2357c4bb9fdc862a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b6c3ff3daed432e71d1c5bfe2357c4bb9fdc862a/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f96c7c4d91f3c09d26658bc9c15aa561689fa2d4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f96c7c4d91f3c09d26658bc9c15aa561689fa2d4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f96c7c4d91f3c09d26658bc9c15aa561689fa2d4"
      }
    ],
    "stats": {
      "total": 266,
      "additions": 152,
      "deletions": 114
    },
    "files": [
      {
        "sha": "2c5bc2c7923c3ae7d06cd1c11648a2e823acf6a5",
        "filename": "src/httpserver.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 3,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b6c3ff3daed432e71d1c5bfe2357c4bb9fdc862a/src/httpserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b6c3ff3daed432e71d1c5bfe2357c4bb9fdc862a/src/httpserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.cpp?ref=b6c3ff3daed432e71d1c5bfe2357c4bb9fdc862a",
        "patch": "@@ -197,12 +197,17 @@ static bool ClientAllowed(const CNetAddr& netaddr)\n static bool InitHTTPAllowList()\n {\n     rpc_allow_subnets.clear();\n-    rpc_allow_subnets.push_back(CSubNet(\"127.0.0.0/8\")); // always allow IPv4 local subnet\n-    rpc_allow_subnets.push_back(CSubNet(\"::1\"));         // always allow IPv6 localhost\n+    CNetAddr localv4;\n+    CNetAddr localv6;\n+    LookupHost(\"127.0.0.1\", localv4, false);\n+    LookupHost(\"::1\", localv6, false);\n+    rpc_allow_subnets.push_back(CSubNet(localv4, 8)); // always allow IPv4 local subnet\n+    rpc_allow_subnets.push_back(CSubNet(localv6));         // always allow IPv6 localhost\n     if (mapMultiArgs.count(\"-rpcallowip\")) {\n         const std::vector<std::string>& vAllow = mapMultiArgs[\"-rpcallowip\"];\n         for (std::string strAllow : vAllow) {\n-            CSubNet subnet(strAllow);\n+            CSubNet subnet;\n+            LookupSubNet(strAllow.c_str(), subnet);\n             if (!subnet.IsValid()) {\n                 uiInterface.ThreadSafeMessageBox(\n                     strprintf(\"Invalid -rpcallowip subnet specification: %s. Valid are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24).\", strAllow),"
      },
      {
        "sha": "8b94e2dbfb1263b118c8fab5fa589d6dc0a60f59",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b6c3ff3daed432e71d1c5bfe2357c4bb9fdc862a/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b6c3ff3daed432e71d1c5bfe2357c4bb9fdc862a/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=b6c3ff3daed432e71d1c5bfe2357c4bb9fdc862a",
        "patch": "@@ -1083,7 +1083,8 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n \n     if (mapArgs.count(\"-whitelist\")) {\n         BOOST_FOREACH(const std::string& net, mapMultiArgs[\"-whitelist\"]) {\n-            CSubNet subnet(net);\n+            CSubNet subnet;\n+            LookupSubNet(net.c_str(), subnet);\n             if (!subnet.IsValid())\n                 return InitError(strprintf(_(\"Invalid netmask specified in -whitelist: '%s'\"), net));\n             CNode::AddWhitelistedRange(subnet);"
      },
      {
        "sha": "52badcd98f5f8a30a7c1e9fbc9b7f8abc4aafe17",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 58,
        "deletions": 36,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b6c3ff3daed432e71d1c5bfe2357c4bb9fdc862a/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b6c3ff3daed432e71d1c5bfe2357c4bb9fdc862a/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=b6c3ff3daed432e71d1c5bfe2357c4bb9fdc862a",
        "patch": "@@ -1214,63 +1214,85 @@ CSubNet::CSubNet():\n     memset(netmask, 0, sizeof(netmask));\n }\n \n-CSubNet::CSubNet(const std::string &strSubnet)\n+CSubNet::CSubNet(const CNetAddr &addr, int32_t mask)\n {\n-    size_t slash = strSubnet.find_last_of('/');\n-    std::vector<CNetAddr> vIP;\n+    valid = true;\n+    network = addr;\n+    // Default to /32 (IPv4) or /128 (IPv6), i.e. match single address\n+    memset(netmask, 255, sizeof(netmask));\n \n+    // IPv4 addresses start at offset 12, and first 12 bytes must match, so just offset n\n+    const int astartofs = network.IsIPv4() ? 12 : 0;\n+\n+    int32_t n = mask;\n+    if(n >= 0 && n <= (128 - astartofs*8)) // Only valid if in range of bits of address\n+    {\n+        n += astartofs*8;\n+        // Clear bits [n..127]\n+        for (; n < 128; ++n)\n+            netmask[n>>3] &= ~(1<<(7-(n&7)));\n+    } else\n+        valid = false;\n+\n+    // Normalize network according to netmask\n+    for(int x=0; x<16; ++x)\n+        network.ip[x] &= netmask[x];\n+}\n+\n+CSubNet::CSubNet(const CNetAddr &addr, const CNetAddr &mask)\n+{\n     valid = true;\n+    network = addr;\n     // Default to /32 (IPv4) or /128 (IPv6), i.e. match single address\n     memset(netmask, 255, sizeof(netmask));\n \n+    // IPv4 addresses start at offset 12, and first 12 bytes must match, so just offset n\n+    const int astartofs = network.IsIPv4() ? 12 : 0;\n+\n+    for(int x=astartofs; x<16; ++x)\n+        netmask[x] = mask.ip[x];\n+\n+    // Normalize network according to netmask\n+    for(int x=0; x<16; ++x)\n+        network.ip[x] &= netmask[x];\n+}\n+\n+\n+bool LookupSubNet(const char* pszName, CSubNet& ret)\n+{\n+    std::string strSubnet(pszName);\n+    size_t slash = strSubnet.find_last_of('/');\n+    std::vector<CNetAddr> vIP;\n+\n     std::string strAddress = strSubnet.substr(0, slash);\n     if (LookupHost(strAddress.c_str(), vIP, 1, false))\n     {\n-        network = vIP[0];\n+        CNetAddr network = vIP[0];\n         if (slash != strSubnet.npos)\n         {\n             std::string strNetmask = strSubnet.substr(slash + 1);\n             int32_t n;\n             // IPv4 addresses start at offset 12, and first 12 bytes must match, so just offset n\n-            const int astartofs = network.IsIPv4() ? 12 : 0;\n-            if (ParseInt32(strNetmask, &n)) // If valid number, assume /24 symtex\n-            {\n-                if(n >= 0 && n <= (128 - astartofs*8)) // Only valid if in range of bits of address\n-                {\n-                    n += astartofs*8;\n-                    // Clear bits [n..127]\n-                    for (; n < 128; ++n)\n-                        netmask[n>>3] &= ~(1<<(7-(n&7)));\n-                }\n-                else\n-                {\n-                    valid = false;\n-                }\n+            if (ParseInt32(strNetmask, &n)) { // If valid number, assume /24 syntax\n+                ret = CSubNet(network, n);\n+                return ret.IsValid();\n             }\n             else // If not a valid number, try full netmask syntax\n             {\n-                if (LookupHost(strNetmask.c_str(), vIP, 1, false)) // Never allow lookup for netmask\n-                {\n-                    // Copy only the *last* four bytes in case of IPv4, the rest of the mask should stay 1's as\n-                    // we don't want pchIPv4 to be part of the mask.\n-                    for(int x=astartofs; x<16; ++x)\n-                        netmask[x] = vIP[0].ip[x];\n-                }\n-                else\n-                {\n-                    valid = false;\n+                // Never allow lookup for netmask\n+                if (LookupHost(strNetmask.c_str(), vIP, 1, false)) {\n+                    ret = CSubNet(network, vIP[0]);\n+                    return ret.IsValid();\n                 }\n             }\n         }\n+        else\n+        {\n+            ret = CSubNet(network);\n+            return ret.IsValid();\n+        }\n     }\n-    else\n-    {\n-        valid = false;\n-    }\n-\n-    // Normalize network according to netmask\n-    for(int x=0; x<16; ++x)\n-        network.ip[x] &= netmask[x];\n+    return false;\n }\n \n CSubNet::CSubNet(const CNetAddr &addr):"
      },
      {
        "sha": "26807ae69733af717b9b5715370f63c2f8b186b4",
        "filename": "src/netbase.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b6c3ff3daed432e71d1c5bfe2357c4bb9fdc862a/src/netbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b6c3ff3daed432e71d1c5bfe2357c4bb9fdc862a/src/netbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.h?ref=b6c3ff3daed432e71d1c5bfe2357c4bb9fdc862a",
        "patch": "@@ -117,7 +117,8 @@ class CSubNet\n \n     public:\n         CSubNet();\n-        explicit CSubNet(const std::string &strSubnet);\n+        CSubNet(const CNetAddr &addr, int32_t mask);\n+        CSubNet(const CNetAddr &addr, const CNetAddr &mask);\n \n         //constructor for single ip subnet (<ipv4>/32 or <ipv6>/128)\n         explicit CSubNet(const CNetAddr &addr);\n@@ -205,6 +206,7 @@ bool LookupHost(const char *pszName, CNetAddr& addr, bool fAllowLookup);\n bool Lookup(const char *pszName, CService& addr, int portDefault, bool fAllowLookup);\n bool Lookup(const char *pszName, std::vector<CService>& vAddr, int portDefault, bool fAllowLookup, unsigned int nMaxSolutions);\n bool LookupNumeric(const char *pszName, CService& addr, int portDefault = 0);\n+bool LookupSubNet(const char *pszName, CSubNet& subnet);\n bool ConnectSocket(const CService &addr, SOCKET& hSocketRet, int nTimeout, bool *outProxyConnectionFailed = 0);\n bool ConnectSocketByName(CService &addr, SOCKET& hSocketRet, const char *pszDest, int portDefault, int nTimeout, bool *outProxyConnectionFailed = 0);\n /** Return readable error string for a network error code */"
      },
      {
        "sha": "21eda07ddffd0f7c9d8950bf217c9c1aeee3aead",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b6c3ff3daed432e71d1c5bfe2357c4bb9fdc862a/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b6c3ff3daed432e71d1c5bfe2357c4bb9fdc862a/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=b6c3ff3daed432e71d1c5bfe2357c4bb9fdc862a",
        "patch": "@@ -915,8 +915,9 @@ void RPCConsole::unbanSelectedNode()\n \n     // Get currently selected ban address\n     QString strNode = GUIUtil::getEntryData(ui->banlistWidget, 0, BanTableModel::Address);\n-    CSubNet possibleSubnet(strNode.toStdString());\n+    CSubNet possibleSubnet;\n \n+    LookupSubNet(strNode.toStdString().c_str(), possibleSubnet);\n     if (possibleSubnet.IsValid())\n     {\n         CNode::Unban(possibleSubnet);"
      },
      {
        "sha": "58cf4a56e05ec3bf20119cde1cb2af6c6bd12618",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b6c3ff3daed432e71d1c5bfe2357c4bb9fdc862a/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b6c3ff3daed432e71d1c5bfe2357c4bb9fdc862a/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=b6c3ff3daed432e71d1c5bfe2357c4bb9fdc862a",
        "patch": "@@ -500,7 +500,7 @@ UniValue setban(const UniValue& params, bool fHelp)\n         netAddr = resolved;\n     }\n     else\n-        subNet = CSubNet(params[0].get_str());\n+        LookupSubNet(params[0].get_str().c_str(), subNet);\n \n     if (! (isSubnet ? subNet.IsValid() : netAddr.IsValid()) )\n         throw JSONRPCError(RPC_CLIENT_NODE_ALREADY_ADDED, \"Error: Invalid IP/Subnet\");"
      },
      {
        "sha": "34b1ebb7a428d7594ef1e36af1d7b7a884f1c721",
        "filename": "src/test/netbase_tests.cpp",
        "status": "modified",
        "additions": 78,
        "deletions": 71,
        "changes": 149,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b6c3ff3daed432e71d1c5bfe2357c4bb9fdc862a/src/test/netbase_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b6c3ff3daed432e71d1c5bfe2357c4bb9fdc862a/src/test/netbase_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/netbase_tests.cpp?ref=b6c3ff3daed432e71d1c5bfe2357c4bb9fdc862a",
        "patch": "@@ -21,6 +21,13 @@ static CNetAddr ResolveIP(const char* ip)\n     return addr;\n }\n \n+static CSubNet ResolveSubNet(const char* subnet)\n+{\n+    CSubNet ret;\n+    LookupSubNet(subnet, ret);\n+    return ret;\n+}\n+\n BOOST_AUTO_TEST_CASE(netbase_networks)\n {\n     BOOST_CHECK(ResolveIP(\"127.0.0.1\").GetNetwork()                              == NET_UNROUTABLE);\n@@ -119,44 +126,44 @@ BOOST_AUTO_TEST_CASE(onioncat_test)\n BOOST_AUTO_TEST_CASE(subnet_test)\n {\n \n-    BOOST_CHECK(CSubNet(\"1.2.3.0/24\") == CSubNet(\"1.2.3.0/255.255.255.0\"));\n-    BOOST_CHECK(CSubNet(\"1.2.3.0/24\") != CSubNet(\"1.2.4.0/255.255.255.0\"));\n-    BOOST_CHECK(CSubNet(\"1.2.3.0/24\").Match(ResolveIP(\"1.2.3.4\")));\n-    BOOST_CHECK(!CSubNet(\"1.2.2.0/24\").Match(ResolveIP(\"1.2.3.4\")));\n-    BOOST_CHECK(CSubNet(\"1.2.3.4\").Match(ResolveIP(\"1.2.3.4\")));\n-    BOOST_CHECK(CSubNet(\"1.2.3.4/32\").Match(ResolveIP(\"1.2.3.4\")));\n-    BOOST_CHECK(!CSubNet(\"1.2.3.4\").Match(ResolveIP(\"5.6.7.8\")));\n-    BOOST_CHECK(!CSubNet(\"1.2.3.4/32\").Match(ResolveIP(\"5.6.7.8\")));\n-    BOOST_CHECK(CSubNet(\"::ffff:127.0.0.1\").Match(ResolveIP(\"127.0.0.1\")));\n-    BOOST_CHECK(CSubNet(\"1:2:3:4:5:6:7:8\").Match(ResolveIP(\"1:2:3:4:5:6:7:8\")));\n-    BOOST_CHECK(!CSubNet(\"1:2:3:4:5:6:7:8\").Match(ResolveIP(\"1:2:3:4:5:6:7:9\")));\n-    BOOST_CHECK(CSubNet(\"1:2:3:4:5:6:7:0/112\").Match(ResolveIP(\"1:2:3:4:5:6:7:1234\")));\n-    BOOST_CHECK(CSubNet(\"192.168.0.1/24\").Match(ResolveIP(\"192.168.0.2\")));\n-    BOOST_CHECK(CSubNet(\"192.168.0.20/29\").Match(ResolveIP(\"192.168.0.18\")));\n-    BOOST_CHECK(CSubNet(\"1.2.2.1/24\").Match(ResolveIP(\"1.2.2.4\")));\n-    BOOST_CHECK(CSubNet(\"1.2.2.110/31\").Match(ResolveIP(\"1.2.2.111\")));\n-    BOOST_CHECK(CSubNet(\"1.2.2.20/26\").Match(ResolveIP(\"1.2.2.63\")));\n+    BOOST_CHECK(ResolveSubNet(\"1.2.3.0/24\") == ResolveSubNet(\"1.2.3.0/255.255.255.0\"));\n+    BOOST_CHECK(ResolveSubNet(\"1.2.3.0/24\") != ResolveSubNet(\"1.2.4.0/255.255.255.0\"));\n+    BOOST_CHECK(ResolveSubNet(\"1.2.3.0/24\").Match(ResolveIP(\"1.2.3.4\")));\n+    BOOST_CHECK(!ResolveSubNet(\"1.2.2.0/24\").Match(ResolveIP(\"1.2.3.4\")));\n+    BOOST_CHECK(ResolveSubNet(\"1.2.3.4\").Match(ResolveIP(\"1.2.3.4\")));\n+    BOOST_CHECK(ResolveSubNet(\"1.2.3.4/32\").Match(ResolveIP(\"1.2.3.4\")));\n+    BOOST_CHECK(!ResolveSubNet(\"1.2.3.4\").Match(ResolveIP(\"5.6.7.8\")));\n+    BOOST_CHECK(!ResolveSubNet(\"1.2.3.4/32\").Match(ResolveIP(\"5.6.7.8\")));\n+    BOOST_CHECK(ResolveSubNet(\"::ffff:127.0.0.1\").Match(ResolveIP(\"127.0.0.1\")));\n+    BOOST_CHECK(ResolveSubNet(\"1:2:3:4:5:6:7:8\").Match(ResolveIP(\"1:2:3:4:5:6:7:8\")));\n+    BOOST_CHECK(!ResolveSubNet(\"1:2:3:4:5:6:7:8\").Match(ResolveIP(\"1:2:3:4:5:6:7:9\")));\n+    BOOST_CHECK(ResolveSubNet(\"1:2:3:4:5:6:7:0/112\").Match(ResolveIP(\"1:2:3:4:5:6:7:1234\")));\n+    BOOST_CHECK(ResolveSubNet(\"192.168.0.1/24\").Match(ResolveIP(\"192.168.0.2\")));\n+    BOOST_CHECK(ResolveSubNet(\"192.168.0.20/29\").Match(ResolveIP(\"192.168.0.18\")));\n+    BOOST_CHECK(ResolveSubNet(\"1.2.2.1/24\").Match(ResolveIP(\"1.2.2.4\")));\n+    BOOST_CHECK(ResolveSubNet(\"1.2.2.110/31\").Match(ResolveIP(\"1.2.2.111\")));\n+    BOOST_CHECK(ResolveSubNet(\"1.2.2.20/26\").Match(ResolveIP(\"1.2.2.63\")));\n     // All-Matching IPv6 Matches arbitrary IPv4 and IPv6\n-    BOOST_CHECK(CSubNet(\"::/0\").Match(ResolveIP(\"1:2:3:4:5:6:7:1234\")));\n-    BOOST_CHECK(CSubNet(\"::/0\").Match(ResolveIP(\"1.2.3.4\")));\n+    BOOST_CHECK(ResolveSubNet(\"::/0\").Match(ResolveIP(\"1:2:3:4:5:6:7:1234\")));\n+    BOOST_CHECK(ResolveSubNet(\"::/0\").Match(ResolveIP(\"1.2.3.4\")));\n     // All-Matching IPv4 does not Match IPv6\n-    BOOST_CHECK(!CSubNet(\"0.0.0.0/0\").Match(ResolveIP(\"1:2:3:4:5:6:7:1234\")));\n+    BOOST_CHECK(!ResolveSubNet(\"0.0.0.0/0\").Match(ResolveIP(\"1:2:3:4:5:6:7:1234\")));\n     // Invalid subnets Match nothing (not even invalid addresses)\n     BOOST_CHECK(!CSubNet().Match(ResolveIP(\"1.2.3.4\")));\n-    BOOST_CHECK(!CSubNet(\"\").Match(ResolveIP(\"4.5.6.7\")));\n-    BOOST_CHECK(!CSubNet(\"bloop\").Match(ResolveIP(\"0.0.0.0\")));\n-    BOOST_CHECK(!CSubNet(\"bloop\").Match(ResolveIP(\"hab\")));\n+    BOOST_CHECK(!ResolveSubNet(\"\").Match(ResolveIP(\"4.5.6.7\")));\n+    BOOST_CHECK(!ResolveSubNet(\"bloop\").Match(ResolveIP(\"0.0.0.0\")));\n+    BOOST_CHECK(!ResolveSubNet(\"bloop\").Match(ResolveIP(\"hab\")));\n     // Check valid/invalid\n-    BOOST_CHECK(CSubNet(\"1.2.3.0/0\").IsValid());\n-    BOOST_CHECK(!CSubNet(\"1.2.3.0/-1\").IsValid());\n-    BOOST_CHECK(CSubNet(\"1.2.3.0/32\").IsValid());\n-    BOOST_CHECK(!CSubNet(\"1.2.3.0/33\").IsValid());\n-    BOOST_CHECK(CSubNet(\"1:2:3:4:5:6:7:8/0\").IsValid());\n-    BOOST_CHECK(CSubNet(\"1:2:3:4:5:6:7:8/33\").IsValid());\n-    BOOST_CHECK(!CSubNet(\"1:2:3:4:5:6:7:8/-1\").IsValid());\n-    BOOST_CHECK(CSubNet(\"1:2:3:4:5:6:7:8/128\").IsValid());\n-    BOOST_CHECK(!CSubNet(\"1:2:3:4:5:6:7:8/129\").IsValid());\n-    BOOST_CHECK(!CSubNet(\"fuzzy\").IsValid());\n+    BOOST_CHECK(ResolveSubNet(\"1.2.3.0/0\").IsValid());\n+    BOOST_CHECK(!ResolveSubNet(\"1.2.3.0/-1\").IsValid());\n+    BOOST_CHECK(ResolveSubNet(\"1.2.3.0/32\").IsValid());\n+    BOOST_CHECK(!ResolveSubNet(\"1.2.3.0/33\").IsValid());\n+    BOOST_CHECK(ResolveSubNet(\"1:2:3:4:5:6:7:8/0\").IsValid());\n+    BOOST_CHECK(ResolveSubNet(\"1:2:3:4:5:6:7:8/33\").IsValid());\n+    BOOST_CHECK(!ResolveSubNet(\"1:2:3:4:5:6:7:8/-1\").IsValid());\n+    BOOST_CHECK(ResolveSubNet(\"1:2:3:4:5:6:7:8/128\").IsValid());\n+    BOOST_CHECK(!ResolveSubNet(\"1:2:3:4:5:6:7:8/129\").IsValid());\n+    BOOST_CHECK(!ResolveSubNet(\"fuzzy\").IsValid());\n \n     //CNetAddr constructor test\n     BOOST_CHECK(CSubNet(ResolveIP(\"127.0.0.1\")).IsValid());\n@@ -169,82 +176,82 @@ BOOST_AUTO_TEST_CASE(subnet_test)\n     BOOST_CHECK(!CSubNet(ResolveIP(\"1:2:3:4:5:6:7:8\")).Match(ResolveIP(\"1:2:3:4:5:6:7:9\")));\n     BOOST_CHECK(CSubNet(ResolveIP(\"1:2:3:4:5:6:7:8\")).ToString() == \"1:2:3:4:5:6:7:8/128\");\n \n-    CSubNet subnet = CSubNet(\"1.2.3.4/255.255.255.255\");\n+    CSubNet subnet = ResolveSubNet(\"1.2.3.4/255.255.255.255\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.4/32\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.255.254\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.255.254\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.4/31\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.255.252\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.255.252\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.4/30\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.255.248\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.255.248\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.0/29\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.255.240\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.255.240\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.0/28\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.255.224\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.255.224\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.0/27\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.255.192\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.255.192\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.0/26\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.255.128\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.255.128\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.0/25\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.255.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.255.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.0/24\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.254.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.254.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.2.0/23\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.252.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.252.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/22\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.248.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.248.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/21\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.240.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.240.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/20\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.224.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.224.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/19\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.192.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.192.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/18\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.128.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.128.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/17\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/16\");\n-    subnet = CSubNet(\"1.2.3.4/255.254.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.254.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/15\");\n-    subnet = CSubNet(\"1.2.3.4/255.252.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.252.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/14\");\n-    subnet = CSubNet(\"1.2.3.4/255.248.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.248.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/13\");\n-    subnet = CSubNet(\"1.2.3.4/255.240.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.240.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/12\");\n-    subnet = CSubNet(\"1.2.3.4/255.224.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.224.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/11\");\n-    subnet = CSubNet(\"1.2.3.4/255.192.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.192.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/10\");\n-    subnet = CSubNet(\"1.2.3.4/255.128.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.128.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/9\");\n-    subnet = CSubNet(\"1.2.3.4/255.0.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.0.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/8\");\n-    subnet = CSubNet(\"1.2.3.4/254.0.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/254.0.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/7\");\n-    subnet = CSubNet(\"1.2.3.4/252.0.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/252.0.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/6\");\n-    subnet = CSubNet(\"1.2.3.4/248.0.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/248.0.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/5\");\n-    subnet = CSubNet(\"1.2.3.4/240.0.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/240.0.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/4\");\n-    subnet = CSubNet(\"1.2.3.4/224.0.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/224.0.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/3\");\n-    subnet = CSubNet(\"1.2.3.4/192.0.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/192.0.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/2\");\n-    subnet = CSubNet(\"1.2.3.4/128.0.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/128.0.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/1\");\n-    subnet = CSubNet(\"1.2.3.4/0.0.0.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/0.0.0.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/0\");\n \n-    subnet = CSubNet(\"1:2:3:4:5:6:7:8/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\");\n+    subnet = ResolveSubNet(\"1:2:3:4:5:6:7:8/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1:2:3:4:5:6:7:8/128\");\n-    subnet = CSubNet(\"1:2:3:4:5:6:7:8/ffff:0000:0000:0000:0000:0000:0000:0000\");\n+    subnet = ResolveSubNet(\"1:2:3:4:5:6:7:8/ffff:0000:0000:0000:0000:0000:0000:0000\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1::/16\");\n-    subnet = CSubNet(\"1:2:3:4:5:6:7:8/0000:0000:0000:0000:0000:0000:0000:0000\");\n+    subnet = ResolveSubNet(\"1:2:3:4:5:6:7:8/0000:0000:0000:0000:0000:0000:0000:0000\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"::/0\");\n-    subnet = CSubNet(\"1.2.3.4/255.255.232.0\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.232.0\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/255.255.232.0\");\n-    subnet = CSubNet(\"1:2:3:4:5:6:7:8/ffff:ffff:ffff:fffe:ffff:ffff:ffff:ff0f\");\n+    subnet = ResolveSubNet(\"1:2:3:4:5:6:7:8/ffff:ffff:ffff:fffe:ffff:ffff:ffff:ff0f\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1:2:3:4:5:6:7:8/ffff:ffff:ffff:fffe:ffff:ffff:ffff:ff0f\");\n \n }"
      }
    ]
  },
  {
    "sha": "1017b8a960d8bca41adebdad9982511a479689ce",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMDE3YjhhOTYwZDhiY2E0MWFkZWJkYWQ5OTgyNTExYTQ3OTY4OWNl",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-05-31T22:18:41Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-07-31T18:01:43Z"
      },
      "message": "net: Add direct tests for new CSubNet constructors",
      "tree": {
        "sha": "2f9f2818c566bb874c50ccbd5aaaf1165d59c445",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2f9f2818c566bb874c50ccbd5aaaf1165d59c445"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1017b8a960d8bca41adebdad9982511a479689ce",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1017b8a960d8bca41adebdad9982511a479689ce",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1017b8a960d8bca41adebdad9982511a479689ce",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1017b8a960d8bca41adebdad9982511a479689ce/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b6c3ff3daed432e71d1c5bfe2357c4bb9fdc862a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b6c3ff3daed432e71d1c5bfe2357c4bb9fdc862a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b6c3ff3daed432e71d1c5bfe2357c4bb9fdc862a"
      }
    ],
    "stats": {
      "total": 16,
      "additions": 15,
      "deletions": 1
    },
    "files": [
      {
        "sha": "7a8584f0f43222bd8b7c4a304fe0b13dfa466706",
        "filename": "src/test/netbase_tests.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 1,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1017b8a960d8bca41adebdad9982511a479689ce/src/test/netbase_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1017b8a960d8bca41adebdad9982511a479689ce/src/test/netbase_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/netbase_tests.cpp?ref=1017b8a960d8bca41adebdad9982511a479689ce",
        "patch": "@@ -171,12 +171,26 @@ BOOST_AUTO_TEST_CASE(subnet_test)\n     BOOST_CHECK(!CSubNet(ResolveIP(\"127.0.0.1\")).Match(ResolveIP(\"127.0.0.2\")));\n     BOOST_CHECK(CSubNet(ResolveIP(\"127.0.0.1\")).ToString() == \"127.0.0.1/32\");\n \n+    CSubNet subnet = CSubNet(ResolveIP(\"1.2.3.4\"), 32);\n+    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.4/32\");\n+    subnet = CSubNet(ResolveIP(\"1.2.3.4\"), 8);\n+    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/8\");\n+    subnet = CSubNet(ResolveIP(\"1.2.3.4\"), 0);\n+    BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/0\");\n+\n+    subnet = CSubNet(ResolveIP(\"1.2.3.4\"), ResolveIP(\"255.255.255.255\"));\n+    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.4/32\");\n+    subnet = CSubNet(ResolveIP(\"1.2.3.4\"), ResolveIP(\"255.0.0.0\"));\n+    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.0.0.0/8\");\n+    subnet = CSubNet(ResolveIP(\"1.2.3.4\"), ResolveIP(\"0.0.0.0\"));\n+    BOOST_CHECK_EQUAL(subnet.ToString(), \"0.0.0.0/0\");\n+\n     BOOST_CHECK(CSubNet(ResolveIP(\"1:2:3:4:5:6:7:8\")).IsValid());\n     BOOST_CHECK(CSubNet(ResolveIP(\"1:2:3:4:5:6:7:8\")).Match(ResolveIP(\"1:2:3:4:5:6:7:8\")));\n     BOOST_CHECK(!CSubNet(ResolveIP(\"1:2:3:4:5:6:7:8\")).Match(ResolveIP(\"1:2:3:4:5:6:7:9\")));\n     BOOST_CHECK(CSubNet(ResolveIP(\"1:2:3:4:5:6:7:8\")).ToString() == \"1:2:3:4:5:6:7:8/128\");\n \n-    CSubNet subnet = ResolveSubNet(\"1.2.3.4/255.255.255.255\");\n+    subnet = ResolveSubNet(\"1.2.3.4/255.255.255.255\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.4/32\");\n     subnet = ResolveSubNet(\"1.2.3.4/255.255.255.254\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.4/31\");"
      }
    ]
  },
  {
    "sha": "21e5b96ff417f304e624052f629e2b030984180f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMWU1Yjk2ZmY0MTdmMzA0ZTYyNDA1MmY2MjllMmIwMzA5ODQxODBm",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-05-31T21:25:03Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-07-31T18:01:44Z"
      },
      "message": "net: move CNetAddr/CService/CSubNet out of netbase",
      "tree": {
        "sha": "cd1f5a9592afc64ac48c12337ad4943f9fc8c907",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cd1f5a9592afc64ac48c12337ad4943f9fc8c907"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/21e5b96ff417f304e624052f629e2b030984180f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/21e5b96ff417f304e624052f629e2b030984180f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/21e5b96ff417f304e624052f629e2b030984180f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/21e5b96ff417f304e624052f629e2b030984180f/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1017b8a960d8bca41adebdad9982511a479689ce",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1017b8a960d8bca41adebdad9982511a479689ce",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1017b8a960d8bca41adebdad9982511a479689ce"
      }
    ],
    "stats": {
      "total": 1752,
      "additions": 890,
      "deletions": 862
    },
    "files": [
      {
        "sha": "0a35a052c24abce0b6f7389b9f6e4264a042c1c3",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21e5b96ff417f304e624052f629e2b030984180f/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21e5b96ff417f304e624052f629e2b030984180f/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=21e5b96ff417f304e624052f629e2b030984180f",
        "patch": "@@ -106,6 +106,7 @@ BITCOIN_CORE_H = \\\n   miner.h \\\n   net.h \\\n   netbase.h \\\n+  netaddress.h \\\n   noui.h \\\n   policy/fees.h \\\n   policy/policy.h \\\n@@ -289,6 +290,7 @@ libbitcoin_common_a_SOURCES = \\\n   core_write.cpp \\\n   key.cpp \\\n   keystore.cpp \\\n+  netaddress.cpp \\\n   netbase.cpp \\\n   protocol.cpp \\\n   scheduler.cpp \\"
      },
      {
        "sha": "7000ce3f0accec588451f9fedb35b999337b4526",
        "filename": "src/netaddress.cpp",
        "status": "added",
        "additions": 716,
        "deletions": 0,
        "changes": 716,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21e5b96ff417f304e624052f629e2b030984180f/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21e5b96ff417f304e624052f629e2b030984180f/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=21e5b96ff417f304e624052f629e2b030984180f",
        "patch": "@@ -0,0 +1,716 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifdef HAVE_CONFIG_H\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#include \"netaddress.h\"\n+#include \"hash.h\"\n+#include \"utilstrencodings.h\"\n+#include \"tinyformat.h\"\n+\n+static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n+static const unsigned char pchOnionCat[] = {0xFD,0x87,0xD8,0x7E,0xEB,0x43};\n+\n+void CNetAddr::Init()\n+{\n+    memset(ip, 0, sizeof(ip));\n+    scopeId = 0;\n+}\n+\n+void CNetAddr::SetIP(const CNetAddr& ipIn)\n+{\n+    memcpy(ip, ipIn.ip, sizeof(ip));\n+}\n+\n+void CNetAddr::SetRaw(Network network, const uint8_t *ip_in)\n+{\n+    switch(network)\n+    {\n+        case NET_IPV4:\n+            memcpy(ip, pchIPv4, 12);\n+            memcpy(ip+12, ip_in, 4);\n+            break;\n+        case NET_IPV6:\n+            memcpy(ip, ip_in, 16);\n+            break;\n+        default:\n+            assert(!\"invalid network\");\n+    }\n+}\n+\n+bool CNetAddr::SetSpecial(const std::string &strName)\n+{\n+    if (strName.size()>6 && strName.substr(strName.size() - 6, 6) == \".onion\") {\n+        std::vector<unsigned char> vchAddr = DecodeBase32(strName.substr(0, strName.size() - 6).c_str());\n+        if (vchAddr.size() != 16-sizeof(pchOnionCat))\n+            return false;\n+        memcpy(ip, pchOnionCat, sizeof(pchOnionCat));\n+        for (unsigned int i=0; i<16-sizeof(pchOnionCat); i++)\n+            ip[i + sizeof(pchOnionCat)] = vchAddr[i];\n+        return true;\n+    }\n+    return false;\n+}\n+\n+CNetAddr::CNetAddr()\n+{\n+    Init();\n+}\n+\n+CNetAddr::CNetAddr(const struct in_addr& ipv4Addr)\n+{\n+    SetRaw(NET_IPV4, (const uint8_t*)&ipv4Addr);\n+}\n+\n+CNetAddr::CNetAddr(const struct in6_addr& ipv6Addr, const uint32_t scope)\n+{\n+    SetRaw(NET_IPV6, (const uint8_t*)&ipv6Addr);\n+    scopeId = scope;\n+}\n+\n+unsigned int CNetAddr::GetByte(int n) const\n+{\n+    return ip[15-n];\n+}\n+\n+bool CNetAddr::IsIPv4() const\n+{\n+    return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n+}\n+\n+bool CNetAddr::IsIPv6() const\n+{\n+    return (!IsIPv4() && !IsTor());\n+}\n+\n+bool CNetAddr::IsRFC1918() const\n+{\n+    return IsIPv4() && (\n+        GetByte(3) == 10 ||\n+        (GetByte(3) == 192 && GetByte(2) == 168) ||\n+        (GetByte(3) == 172 && (GetByte(2) >= 16 && GetByte(2) <= 31)));\n+}\n+\n+bool CNetAddr::IsRFC2544() const\n+{\n+    return IsIPv4() && GetByte(3) == 198 && (GetByte(2) == 18 || GetByte(2) == 19);\n+}\n+\n+bool CNetAddr::IsRFC3927() const\n+{\n+    return IsIPv4() && (GetByte(3) == 169 && GetByte(2) == 254);\n+}\n+\n+bool CNetAddr::IsRFC6598() const\n+{\n+    return IsIPv4() && GetByte(3) == 100 && GetByte(2) >= 64 && GetByte(2) <= 127;\n+}\n+\n+bool CNetAddr::IsRFC5737() const\n+{\n+    return IsIPv4() && ((GetByte(3) == 192 && GetByte(2) == 0 && GetByte(1) == 2) ||\n+        (GetByte(3) == 198 && GetByte(2) == 51 && GetByte(1) == 100) ||\n+        (GetByte(3) == 203 && GetByte(2) == 0 && GetByte(1) == 113));\n+}\n+\n+bool CNetAddr::IsRFC3849() const\n+{\n+    return GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x0D && GetByte(12) == 0xB8;\n+}\n+\n+bool CNetAddr::IsRFC3964() const\n+{\n+    return (GetByte(15) == 0x20 && GetByte(14) == 0x02);\n+}\n+\n+bool CNetAddr::IsRFC6052() const\n+{\n+    static const unsigned char pchRFC6052[] = {0,0x64,0xFF,0x9B,0,0,0,0,0,0,0,0};\n+    return (memcmp(ip, pchRFC6052, sizeof(pchRFC6052)) == 0);\n+}\n+\n+bool CNetAddr::IsRFC4380() const\n+{\n+    return (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0 && GetByte(12) == 0);\n+}\n+\n+bool CNetAddr::IsRFC4862() const\n+{\n+    static const unsigned char pchRFC4862[] = {0xFE,0x80,0,0,0,0,0,0};\n+    return (memcmp(ip, pchRFC4862, sizeof(pchRFC4862)) == 0);\n+}\n+\n+bool CNetAddr::IsRFC4193() const\n+{\n+    return ((GetByte(15) & 0xFE) == 0xFC);\n+}\n+\n+bool CNetAddr::IsRFC6145() const\n+{\n+    static const unsigned char pchRFC6145[] = {0,0,0,0,0,0,0,0,0xFF,0xFF,0,0};\n+    return (memcmp(ip, pchRFC6145, sizeof(pchRFC6145)) == 0);\n+}\n+\n+bool CNetAddr::IsRFC4843() const\n+{\n+    return (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x00 && (GetByte(12) & 0xF0) == 0x10);\n+}\n+\n+bool CNetAddr::IsTor() const\n+{\n+    return (memcmp(ip, pchOnionCat, sizeof(pchOnionCat)) == 0);\n+}\n+\n+bool CNetAddr::IsLocal() const\n+{\n+    // IPv4 loopback\n+   if (IsIPv4() && (GetByte(3) == 127 || GetByte(3) == 0))\n+       return true;\n+\n+   // IPv6 loopback (::1/128)\n+   static const unsigned char pchLocal[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1};\n+   if (memcmp(ip, pchLocal, 16) == 0)\n+       return true;\n+\n+   return false;\n+}\n+\n+bool CNetAddr::IsMulticast() const\n+{\n+    return    (IsIPv4() && (GetByte(3) & 0xF0) == 0xE0)\n+           || (GetByte(15) == 0xFF);\n+}\n+\n+bool CNetAddr::IsValid() const\n+{\n+    // Cleanup 3-byte shifted addresses caused by garbage in size field\n+    // of addr messages from versions before 0.2.9 checksum.\n+    // Two consecutive addr messages look like this:\n+    // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n+    // so if the first length field is garbled, it reads the second batch\n+    // of addr misaligned by 3 bytes.\n+    if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n+        return false;\n+\n+    // unspecified IPv6 address (::/128)\n+    unsigned char ipNone[16] = {};\n+    if (memcmp(ip, ipNone, 16) == 0)\n+        return false;\n+\n+    // documentation IPv6 address\n+    if (IsRFC3849())\n+        return false;\n+\n+    if (IsIPv4())\n+    {\n+        // INADDR_NONE\n+        uint32_t ipNone = INADDR_NONE;\n+        if (memcmp(ip+12, &ipNone, 4) == 0)\n+            return false;\n+\n+        // 0\n+        ipNone = 0;\n+        if (memcmp(ip+12, &ipNone, 4) == 0)\n+            return false;\n+    }\n+\n+    return true;\n+}\n+\n+bool CNetAddr::IsRoutable() const\n+{\n+    return IsValid() && !(IsRFC1918() || IsRFC2544() || IsRFC3927() || IsRFC4862() || IsRFC6598() || IsRFC5737() || (IsRFC4193() && !IsTor()) || IsRFC4843() || IsLocal());\n+}\n+\n+enum Network CNetAddr::GetNetwork() const\n+{\n+    if (!IsRoutable())\n+        return NET_UNROUTABLE;\n+\n+    if (IsIPv4())\n+        return NET_IPV4;\n+\n+    if (IsTor())\n+        return NET_TOR;\n+\n+    return NET_IPV6;\n+}\n+\n+std::string CNetAddr::ToStringIP() const\n+{\n+    if (IsTor())\n+        return EncodeBase32(&ip[6], 10) + \".onion\";\n+    CService serv(*this, 0);\n+    struct sockaddr_storage sockaddr;\n+    socklen_t socklen = sizeof(sockaddr);\n+    if (serv.GetSockAddr((struct sockaddr*)&sockaddr, &socklen)) {\n+        char name[1025] = \"\";\n+        if (!getnameinfo((const struct sockaddr*)&sockaddr, socklen, name, sizeof(name), NULL, 0, NI_NUMERICHOST))\n+            return std::string(name);\n+    }\n+    if (IsIPv4())\n+        return strprintf(\"%u.%u.%u.%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0));\n+    else\n+        return strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n+                         GetByte(15) << 8 | GetByte(14), GetByte(13) << 8 | GetByte(12),\n+                         GetByte(11) << 8 | GetByte(10), GetByte(9) << 8 | GetByte(8),\n+                         GetByte(7) << 8 | GetByte(6), GetByte(5) << 8 | GetByte(4),\n+                         GetByte(3) << 8 | GetByte(2), GetByte(1) << 8 | GetByte(0));\n+}\n+\n+std::string CNetAddr::ToString() const\n+{\n+    return ToStringIP();\n+}\n+\n+bool operator==(const CNetAddr& a, const CNetAddr& b)\n+{\n+    return (memcmp(a.ip, b.ip, 16) == 0);\n+}\n+\n+bool operator!=(const CNetAddr& a, const CNetAddr& b)\n+{\n+    return (memcmp(a.ip, b.ip, 16) != 0);\n+}\n+\n+bool operator<(const CNetAddr& a, const CNetAddr& b)\n+{\n+    return (memcmp(a.ip, b.ip, 16) < 0);\n+}\n+\n+bool CNetAddr::GetInAddr(struct in_addr* pipv4Addr) const\n+{\n+    if (!IsIPv4())\n+        return false;\n+    memcpy(pipv4Addr, ip+12, 4);\n+    return true;\n+}\n+\n+bool CNetAddr::GetIn6Addr(struct in6_addr* pipv6Addr) const\n+{\n+    memcpy(pipv6Addr, ip, 16);\n+    return true;\n+}\n+\n+// get canonical identifier of an address' group\n+// no two connections will be attempted to addresses with the same group\n+std::vector<unsigned char> CNetAddr::GetGroup() const\n+{\n+    std::vector<unsigned char> vchRet;\n+    int nClass = NET_IPV6;\n+    int nStartByte = 0;\n+    int nBits = 16;\n+\n+    // all local addresses belong to the same group\n+    if (IsLocal())\n+    {\n+        nClass = 255;\n+        nBits = 0;\n+    }\n+\n+    // all unroutable addresses belong to the same group\n+    if (!IsRoutable())\n+    {\n+        nClass = NET_UNROUTABLE;\n+        nBits = 0;\n+    }\n+    // for IPv4 addresses, '1' + the 16 higher-order bits of the IP\n+    // includes mapped IPv4, SIIT translated IPv4, and the well-known prefix\n+    else if (IsIPv4() || IsRFC6145() || IsRFC6052())\n+    {\n+        nClass = NET_IPV4;\n+        nStartByte = 12;\n+    }\n+    // for 6to4 tunnelled addresses, use the encapsulated IPv4 address\n+    else if (IsRFC3964())\n+    {\n+        nClass = NET_IPV4;\n+        nStartByte = 2;\n+    }\n+    // for Teredo-tunnelled IPv6 addresses, use the encapsulated IPv4 address\n+    else if (IsRFC4380())\n+    {\n+        vchRet.push_back(NET_IPV4);\n+        vchRet.push_back(GetByte(3) ^ 0xFF);\n+        vchRet.push_back(GetByte(2) ^ 0xFF);\n+        return vchRet;\n+    }\n+    else if (IsTor())\n+    {\n+        nClass = NET_TOR;\n+        nStartByte = 6;\n+        nBits = 4;\n+    }\n+    // for he.net, use /36 groups\n+    else if (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x04 && GetByte(12) == 0x70)\n+        nBits = 36;\n+    // for the rest of the IPv6 network, use /32 groups\n+    else\n+        nBits = 32;\n+\n+    vchRet.push_back(nClass);\n+    while (nBits >= 8)\n+    {\n+        vchRet.push_back(GetByte(15 - nStartByte));\n+        nStartByte++;\n+        nBits -= 8;\n+    }\n+    if (nBits > 0)\n+        vchRet.push_back(GetByte(15 - nStartByte) | ((1 << (8 - nBits)) - 1));\n+\n+    return vchRet;\n+}\n+\n+uint64_t CNetAddr::GetHash() const\n+{\n+    uint256 hash = Hash(&ip[0], &ip[16]);\n+    uint64_t nRet;\n+    memcpy(&nRet, &hash, sizeof(nRet));\n+    return nRet;\n+}\n+\n+// private extensions to enum Network, only returned by GetExtNetwork,\n+// and only used in GetReachabilityFrom\n+static const int NET_UNKNOWN = NET_MAX + 0;\n+static const int NET_TEREDO  = NET_MAX + 1;\n+int static GetExtNetwork(const CNetAddr *addr)\n+{\n+    if (addr == NULL)\n+        return NET_UNKNOWN;\n+    if (addr->IsRFC4380())\n+        return NET_TEREDO;\n+    return addr->GetNetwork();\n+}\n+\n+/** Calculates a metric for how reachable (*this) is from a given partner */\n+int CNetAddr::GetReachabilityFrom(const CNetAddr *paddrPartner) const\n+{\n+    enum Reachability {\n+        REACH_UNREACHABLE,\n+        REACH_DEFAULT,\n+        REACH_TEREDO,\n+        REACH_IPV6_WEAK,\n+        REACH_IPV4,\n+        REACH_IPV6_STRONG,\n+        REACH_PRIVATE\n+    };\n+\n+    if (!IsRoutable())\n+        return REACH_UNREACHABLE;\n+\n+    int ourNet = GetExtNetwork(this);\n+    int theirNet = GetExtNetwork(paddrPartner);\n+    bool fTunnel = IsRFC3964() || IsRFC6052() || IsRFC6145();\n+\n+    switch(theirNet) {\n+    case NET_IPV4:\n+        switch(ourNet) {\n+        default:       return REACH_DEFAULT;\n+        case NET_IPV4: return REACH_IPV4;\n+        }\n+    case NET_IPV6:\n+        switch(ourNet) {\n+        default:         return REACH_DEFAULT;\n+        case NET_TEREDO: return REACH_TEREDO;\n+        case NET_IPV4:   return REACH_IPV4;\n+        case NET_IPV6:   return fTunnel ? REACH_IPV6_WEAK : REACH_IPV6_STRONG; // only prefer giving our IPv6 address if it's not tunnelled\n+        }\n+    case NET_TOR:\n+        switch(ourNet) {\n+        default:         return REACH_DEFAULT;\n+        case NET_IPV4:   return REACH_IPV4; // Tor users can connect to IPv4 as well\n+        case NET_TOR:    return REACH_PRIVATE;\n+        }\n+    case NET_TEREDO:\n+        switch(ourNet) {\n+        default:          return REACH_DEFAULT;\n+        case NET_TEREDO:  return REACH_TEREDO;\n+        case NET_IPV6:    return REACH_IPV6_WEAK;\n+        case NET_IPV4:    return REACH_IPV4;\n+        }\n+    case NET_UNKNOWN:\n+    case NET_UNROUTABLE:\n+    default:\n+        switch(ourNet) {\n+        default:          return REACH_DEFAULT;\n+        case NET_TEREDO:  return REACH_TEREDO;\n+        case NET_IPV6:    return REACH_IPV6_WEAK;\n+        case NET_IPV4:    return REACH_IPV4;\n+        case NET_TOR:     return REACH_PRIVATE; // either from Tor, or don't care about our address\n+        }\n+    }\n+}\n+\n+void CService::Init()\n+{\n+    port = 0;\n+}\n+\n+CService::CService()\n+{\n+    Init();\n+}\n+\n+CService::CService(const CNetAddr& cip, unsigned short portIn) : CNetAddr(cip), port(portIn)\n+{\n+}\n+\n+CService::CService(const struct in_addr& ipv4Addr, unsigned short portIn) : CNetAddr(ipv4Addr), port(portIn)\n+{\n+}\n+\n+CService::CService(const struct in6_addr& ipv6Addr, unsigned short portIn) : CNetAddr(ipv6Addr), port(portIn)\n+{\n+}\n+\n+CService::CService(const struct sockaddr_in& addr) : CNetAddr(addr.sin_addr), port(ntohs(addr.sin_port))\n+{\n+    assert(addr.sin_family == AF_INET);\n+}\n+\n+CService::CService(const struct sockaddr_in6 &addr) : CNetAddr(addr.sin6_addr, addr.sin6_scope_id), port(ntohs(addr.sin6_port))\n+{\n+   assert(addr.sin6_family == AF_INET6);\n+}\n+\n+bool CService::SetSockAddr(const struct sockaddr *paddr)\n+{\n+    switch (paddr->sa_family) {\n+    case AF_INET:\n+        *this = CService(*(const struct sockaddr_in*)paddr);\n+        return true;\n+    case AF_INET6:\n+        *this = CService(*(const struct sockaddr_in6*)paddr);\n+        return true;\n+    default:\n+        return false;\n+    }\n+}\n+\n+unsigned short CService::GetPort() const\n+{\n+    return port;\n+}\n+\n+bool operator==(const CService& a, const CService& b)\n+{\n+    return (CNetAddr)a == (CNetAddr)b && a.port == b.port;\n+}\n+\n+bool operator!=(const CService& a, const CService& b)\n+{\n+    return (CNetAddr)a != (CNetAddr)b || a.port != b.port;\n+}\n+\n+bool operator<(const CService& a, const CService& b)\n+{\n+    return (CNetAddr)a < (CNetAddr)b || ((CNetAddr)a == (CNetAddr)b && a.port < b.port);\n+}\n+\n+bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n+{\n+    if (IsIPv4()) {\n+        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n+            return false;\n+        *addrlen = sizeof(struct sockaddr_in);\n+        struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n+        memset(paddrin, 0, *addrlen);\n+        if (!GetInAddr(&paddrin->sin_addr))\n+            return false;\n+        paddrin->sin_family = AF_INET;\n+        paddrin->sin_port = htons(port);\n+        return true;\n+    }\n+    if (IsIPv6()) {\n+        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n+            return false;\n+        *addrlen = sizeof(struct sockaddr_in6);\n+        struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n+        memset(paddrin6, 0, *addrlen);\n+        if (!GetIn6Addr(&paddrin6->sin6_addr))\n+            return false;\n+        paddrin6->sin6_scope_id = scopeId;\n+        paddrin6->sin6_family = AF_INET6;\n+        paddrin6->sin6_port = htons(port);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+std::vector<unsigned char> CService::GetKey() const\n+{\n+     std::vector<unsigned char> vKey;\n+     vKey.resize(18);\n+     memcpy(&vKey[0], ip, 16);\n+     vKey[16] = port / 0x100;\n+     vKey[17] = port & 0x0FF;\n+     return vKey;\n+}\n+\n+std::string CService::ToStringPort() const\n+{\n+    return strprintf(\"%u\", port);\n+}\n+\n+std::string CService::ToStringIPPort() const\n+{\n+    if (IsIPv4() || IsTor()) {\n+        return ToStringIP() + \":\" + ToStringPort();\n+    } else {\n+        return \"[\" + ToStringIP() + \"]:\" + ToStringPort();\n+    }\n+}\n+\n+std::string CService::ToString() const\n+{\n+    return ToStringIPPort();\n+}\n+\n+void CService::SetPort(unsigned short portIn)\n+{\n+    port = portIn;\n+}\n+\n+CSubNet::CSubNet():\n+    valid(false)\n+{\n+    memset(netmask, 0, sizeof(netmask));\n+}\n+\n+CSubNet::CSubNet(const CNetAddr &addr, int32_t mask)\n+{\n+    valid = true;\n+    network = addr;\n+    // Default to /32 (IPv4) or /128 (IPv6), i.e. match single address\n+    memset(netmask, 255, sizeof(netmask));\n+\n+    // IPv4 addresses start at offset 12, and first 12 bytes must match, so just offset n\n+    const int astartofs = network.IsIPv4() ? 12 : 0;\n+\n+    int32_t n = mask;\n+    if(n >= 0 && n <= (128 - astartofs*8)) // Only valid if in range of bits of address\n+    {\n+        n += astartofs*8;\n+        // Clear bits [n..127]\n+        for (; n < 128; ++n)\n+            netmask[n>>3] &= ~(1<<(7-(n&7)));\n+    } else\n+        valid = false;\n+\n+    // Normalize network according to netmask\n+    for(int x=0; x<16; ++x)\n+        network.ip[x] &= netmask[x];\n+}\n+\n+CSubNet::CSubNet(const CNetAddr &addr, const CNetAddr &mask)\n+{\n+    valid = true;\n+    network = addr;\n+    // Default to /32 (IPv4) or /128 (IPv6), i.e. match single address\n+    memset(netmask, 255, sizeof(netmask));\n+\n+    // IPv4 addresses start at offset 12, and first 12 bytes must match, so just offset n\n+    const int astartofs = network.IsIPv4() ? 12 : 0;\n+\n+    for(int x=astartofs; x<16; ++x)\n+        netmask[x] = mask.ip[x];\n+\n+    // Normalize network according to netmask\n+    for(int x=0; x<16; ++x)\n+        network.ip[x] &= netmask[x];\n+}\n+\n+CSubNet::CSubNet(const CNetAddr &addr):\n+    valid(addr.IsValid())\n+{\n+    memset(netmask, 255, sizeof(netmask));\n+    network = addr;\n+}\n+\n+bool CSubNet::Match(const CNetAddr &addr) const\n+{\n+    if (!valid || !addr.IsValid())\n+        return false;\n+    for(int x=0; x<16; ++x)\n+        if ((addr.ip[x] & netmask[x]) != network.ip[x])\n+            return false;\n+    return true;\n+}\n+\n+static inline int NetmaskBits(uint8_t x)\n+{\n+    switch(x) {\n+    case 0x00: return 0; break;\n+    case 0x80: return 1; break;\n+    case 0xc0: return 2; break;\n+    case 0xe0: return 3; break;\n+    case 0xf0: return 4; break;\n+    case 0xf8: return 5; break;\n+    case 0xfc: return 6; break;\n+    case 0xfe: return 7; break;\n+    case 0xff: return 8; break;\n+    default: return -1; break;\n+    }\n+}\n+\n+std::string CSubNet::ToString() const\n+{\n+    /* Parse binary 1{n}0{N-n} to see if mask can be represented as /n */\n+    int cidr = 0;\n+    bool valid_cidr = true;\n+    int n = network.IsIPv4() ? 12 : 0;\n+    for (; n < 16 && netmask[n] == 0xff; ++n)\n+        cidr += 8;\n+    if (n < 16) {\n+        int bits = NetmaskBits(netmask[n]);\n+        if (bits < 0)\n+            valid_cidr = false;\n+        else\n+            cidr += bits;\n+        ++n;\n+    }\n+    for (; n < 16 && valid_cidr; ++n)\n+        if (netmask[n] != 0x00)\n+            valid_cidr = false;\n+\n+    /* Format output */\n+    std::string strNetmask;\n+    if (valid_cidr) {\n+        strNetmask = strprintf(\"%u\", cidr);\n+    } else {\n+        if (network.IsIPv4())\n+            strNetmask = strprintf(\"%u.%u.%u.%u\", netmask[12], netmask[13], netmask[14], netmask[15]);\n+        else\n+            strNetmask = strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n+                             netmask[0] << 8 | netmask[1], netmask[2] << 8 | netmask[3],\n+                             netmask[4] << 8 | netmask[5], netmask[6] << 8 | netmask[7],\n+                             netmask[8] << 8 | netmask[9], netmask[10] << 8 | netmask[11],\n+                             netmask[12] << 8 | netmask[13], netmask[14] << 8 | netmask[15]);\n+    }\n+\n+    return network.ToString() + \"/\" + strNetmask;\n+}\n+\n+bool CSubNet::IsValid() const\n+{\n+    return valid;\n+}\n+\n+bool operator==(const CSubNet& a, const CSubNet& b)\n+{\n+    return a.valid == b.valid && a.network == b.network && !memcmp(a.netmask, b.netmask, 16);\n+}\n+\n+bool operator!=(const CSubNet& a, const CSubNet& b)\n+{\n+    return !(a==b);\n+}\n+\n+bool operator<(const CSubNet& a, const CSubNet& b)\n+{\n+    return (a.network < b.network || (a.network == b.network && memcmp(a.netmask, b.netmask, 16) < 0));\n+}"
      },
      {
        "sha": "9330fe33285821ac294ef221e20359884b454cf8",
        "filename": "src/netaddress.h",
        "status": "added",
        "additions": 171,
        "deletions": 0,
        "changes": 171,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21e5b96ff417f304e624052f629e2b030984180f/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21e5b96ff417f304e624052f629e2b030984180f/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=21e5b96ff417f304e624052f629e2b030984180f",
        "patch": "@@ -0,0 +1,171 @@\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NETADDRESS_H\n+#define BITCOIN_NETADDRESS_H\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#include \"compat.h\"\n+#include \"serialize.h\"\n+\n+#include <stdint.h>\n+#include <string>\n+#include <vector>\n+\n+enum Network\n+{\n+    NET_UNROUTABLE = 0,\n+    NET_IPV4,\n+    NET_IPV6,\n+    NET_TOR,\n+\n+    NET_MAX,\n+};\n+\n+/** IP address (IPv6, or IPv4 using mapped IPv6 range (::FFFF:0:0/96)) */\n+class CNetAddr\n+{\n+    protected:\n+        unsigned char ip[16]; // in network byte order\n+        uint32_t scopeId; // for scoped/link-local ipv6 addresses\n+\n+    public:\n+        CNetAddr();\n+        CNetAddr(const struct in_addr& ipv4Addr);\n+        void Init();\n+        void SetIP(const CNetAddr& ip);\n+\n+        /**\n+         * Set raw IPv4 or IPv6 address (in network byte order)\n+         * @note Only NET_IPV4 and NET_IPV6 are allowed for network.\n+         */\n+        void SetRaw(Network network, const uint8_t *data);\n+\n+        bool SetSpecial(const std::string &strName); // for Tor addresses\n+        bool IsIPv4() const;    // IPv4 mapped address (::FFFF:0:0/96, 0.0.0.0/0)\n+        bool IsIPv6() const;    // IPv6 address (not mapped IPv4, not Tor)\n+        bool IsRFC1918() const; // IPv4 private networks (10.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12)\n+        bool IsRFC2544() const; // IPv4 inter-network communcations (192.18.0.0/15)\n+        bool IsRFC6598() const; // IPv4 ISP-level NAT (100.64.0.0/10)\n+        bool IsRFC5737() const; // IPv4 documentation addresses (192.0.2.0/24, 198.51.100.0/24, 203.0.113.0/24)\n+        bool IsRFC3849() const; // IPv6 documentation address (2001:0DB8::/32)\n+        bool IsRFC3927() const; // IPv4 autoconfig (169.254.0.0/16)\n+        bool IsRFC3964() const; // IPv6 6to4 tunnelling (2002::/16)\n+        bool IsRFC4193() const; // IPv6 unique local (FC00::/7)\n+        bool IsRFC4380() const; // IPv6 Teredo tunnelling (2001::/32)\n+        bool IsRFC4843() const; // IPv6 ORCHID (2001:10::/28)\n+        bool IsRFC4862() const; // IPv6 autoconfig (FE80::/64)\n+        bool IsRFC6052() const; // IPv6 well-known prefix (64:FF9B::/96)\n+        bool IsRFC6145() const; // IPv6 IPv4-translated address (::FFFF:0:0:0/96)\n+        bool IsTor() const;\n+        bool IsLocal() const;\n+        bool IsRoutable() const;\n+        bool IsValid() const;\n+        bool IsMulticast() const;\n+        enum Network GetNetwork() const;\n+        std::string ToString() const;\n+        std::string ToStringIP() const;\n+        unsigned int GetByte(int n) const;\n+        uint64_t GetHash() const;\n+        bool GetInAddr(struct in_addr* pipv4Addr) const;\n+        std::vector<unsigned char> GetGroup() const;\n+        int GetReachabilityFrom(const CNetAddr *paddrPartner = NULL) const;\n+\n+        CNetAddr(const struct in6_addr& pipv6Addr, const uint32_t scope = 0);\n+        bool GetIn6Addr(struct in6_addr* pipv6Addr) const;\n+\n+        friend bool operator==(const CNetAddr& a, const CNetAddr& b);\n+        friend bool operator!=(const CNetAddr& a, const CNetAddr& b);\n+        friend bool operator<(const CNetAddr& a, const CNetAddr& b);\n+\n+        ADD_SERIALIZE_METHODS;\n+\n+        template <typename Stream, typename Operation>\n+        inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+            READWRITE(FLATDATA(ip));\n+        }\n+\n+        friend class CSubNet;\n+};\n+\n+class CSubNet\n+{\n+    protected:\n+        /// Network (base) address\n+        CNetAddr network;\n+        /// Netmask, in network byte order\n+        uint8_t netmask[16];\n+        /// Is this value valid? (only used to signal parse errors)\n+        bool valid;\n+\n+    public:\n+        CSubNet();\n+        CSubNet(const CNetAddr &addr, int32_t mask);\n+        CSubNet(const CNetAddr &addr, const CNetAddr &mask);\n+\n+        //constructor for single ip subnet (<ipv4>/32 or <ipv6>/128)\n+        explicit CSubNet(const CNetAddr &addr);\n+\n+        bool Match(const CNetAddr &addr) const;\n+\n+        std::string ToString() const;\n+        bool IsValid() const;\n+\n+        friend bool operator==(const CSubNet& a, const CSubNet& b);\n+        friend bool operator!=(const CSubNet& a, const CSubNet& b);\n+        friend bool operator<(const CSubNet& a, const CSubNet& b);\n+\n+        ADD_SERIALIZE_METHODS;\n+\n+        template <typename Stream, typename Operation>\n+        inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+            READWRITE(network);\n+            READWRITE(FLATDATA(netmask));\n+            READWRITE(FLATDATA(valid));\n+        }\n+};\n+\n+/** A combination of a network address (CNetAddr) and a (TCP) port */\n+class CService : public CNetAddr\n+{\n+    protected:\n+        unsigned short port; // host order\n+\n+    public:\n+        CService();\n+        CService(const CNetAddr& ip, unsigned short port);\n+        CService(const struct in_addr& ipv4Addr, unsigned short port);\n+        CService(const struct sockaddr_in& addr);\n+        void Init();\n+        void SetPort(unsigned short portIn);\n+        unsigned short GetPort() const;\n+        bool GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const;\n+        bool SetSockAddr(const struct sockaddr* paddr);\n+        friend bool operator==(const CService& a, const CService& b);\n+        friend bool operator!=(const CService& a, const CService& b);\n+        friend bool operator<(const CService& a, const CService& b);\n+        std::vector<unsigned char> GetKey() const;\n+        std::string ToString() const;\n+        std::string ToStringPort() const;\n+        std::string ToStringIPPort() const;\n+\n+        CService(const struct in6_addr& ipv6Addr, unsigned short port);\n+        CService(const struct sockaddr_in6& addr);\n+\n+        ADD_SERIALIZE_METHODS;\n+\n+        template <typename Stream, typename Operation>\n+        inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+            READWRITE(FLATDATA(ip));\n+            unsigned short portN = htons(port);\n+            READWRITE(FLATDATA(portN));\n+            if (ser_action.ForRead())\n+                 port = ntohs(portN);\n+        }\n+};\n+\n+#endif // BITCOIN_NETADDRESS_H"
      },
      {
        "sha": "c2294a078da5170f8f8ea7e6541ce26e4ebee1d1",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 705,
        "changes": 705,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21e5b96ff417f304e624052f629e2b030984180f/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21e5b96ff417f304e624052f629e2b030984180f/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=21e5b96ff417f304e624052f629e2b030984180f",
        "patch": "@@ -42,8 +42,6 @@ static CCriticalSection cs_proxyInfos;\n int nConnectTimeout = DEFAULT_CONNECT_TIMEOUT;\n bool fNameLookup = DEFAULT_NAME_LOOKUP;\n \n-static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n-\n // Need ample time for negotiation for very slow proxies such as Tor (milliseconds)\n static const int SOCKS5_RECV_TIMEOUT = 20 * 1000;\n \n@@ -646,618 +644,6 @@ bool ConnectSocketByName(CService &addr, SOCKET& hSocketRet, const char *pszDest\n     return ConnectThroughProxy(nameProxy, strDest, port, hSocketRet, nTimeout, outProxyConnectionFailed);\n }\n \n-void CNetAddr::Init()\n-{\n-    memset(ip, 0, sizeof(ip));\n-    scopeId = 0;\n-}\n-\n-void CNetAddr::SetIP(const CNetAddr& ipIn)\n-{\n-    memcpy(ip, ipIn.ip, sizeof(ip));\n-}\n-\n-void CNetAddr::SetRaw(Network network, const uint8_t *ip_in)\n-{\n-    switch(network)\n-    {\n-        case NET_IPV4:\n-            memcpy(ip, pchIPv4, 12);\n-            memcpy(ip+12, ip_in, 4);\n-            break;\n-        case NET_IPV6:\n-            memcpy(ip, ip_in, 16);\n-            break;\n-        default:\n-            assert(!\"invalid network\");\n-    }\n-}\n-\n-static const unsigned char pchOnionCat[] = {0xFD,0x87,0xD8,0x7E,0xEB,0x43};\n-\n-bool CNetAddr::SetSpecial(const std::string &strName)\n-{\n-    if (strName.size()>6 && strName.substr(strName.size() - 6, 6) == \".onion\") {\n-        std::vector<unsigned char> vchAddr = DecodeBase32(strName.substr(0, strName.size() - 6).c_str());\n-        if (vchAddr.size() != 16-sizeof(pchOnionCat))\n-            return false;\n-        memcpy(ip, pchOnionCat, sizeof(pchOnionCat));\n-        for (unsigned int i=0; i<16-sizeof(pchOnionCat); i++)\n-            ip[i + sizeof(pchOnionCat)] = vchAddr[i];\n-        return true;\n-    }\n-    return false;\n-}\n-\n-CNetAddr::CNetAddr()\n-{\n-    Init();\n-}\n-\n-CNetAddr::CNetAddr(const struct in_addr& ipv4Addr)\n-{\n-    SetRaw(NET_IPV4, (const uint8_t*)&ipv4Addr);\n-}\n-\n-CNetAddr::CNetAddr(const struct in6_addr& ipv6Addr, const uint32_t scope)\n-{\n-    SetRaw(NET_IPV6, (const uint8_t*)&ipv6Addr);\n-    scopeId = scope;\n-}\n-\n-unsigned int CNetAddr::GetByte(int n) const\n-{\n-    return ip[15-n];\n-}\n-\n-bool CNetAddr::IsIPv4() const\n-{\n-    return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n-}\n-\n-bool CNetAddr::IsIPv6() const\n-{\n-    return (!IsIPv4() && !IsTor());\n-}\n-\n-bool CNetAddr::IsRFC1918() const\n-{\n-    return IsIPv4() && (\n-        GetByte(3) == 10 ||\n-        (GetByte(3) == 192 && GetByte(2) == 168) ||\n-        (GetByte(3) == 172 && (GetByte(2) >= 16 && GetByte(2) <= 31)));\n-}\n-\n-bool CNetAddr::IsRFC2544() const\n-{\n-    return IsIPv4() && GetByte(3) == 198 && (GetByte(2) == 18 || GetByte(2) == 19);\n-}\n-\n-bool CNetAddr::IsRFC3927() const\n-{\n-    return IsIPv4() && (GetByte(3) == 169 && GetByte(2) == 254);\n-}\n-\n-bool CNetAddr::IsRFC6598() const\n-{\n-    return IsIPv4() && GetByte(3) == 100 && GetByte(2) >= 64 && GetByte(2) <= 127;\n-}\n-\n-bool CNetAddr::IsRFC5737() const\n-{\n-    return IsIPv4() && ((GetByte(3) == 192 && GetByte(2) == 0 && GetByte(1) == 2) ||\n-        (GetByte(3) == 198 && GetByte(2) == 51 && GetByte(1) == 100) ||\n-        (GetByte(3) == 203 && GetByte(2) == 0 && GetByte(1) == 113));\n-}\n-\n-bool CNetAddr::IsRFC3849() const\n-{\n-    return GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x0D && GetByte(12) == 0xB8;\n-}\n-\n-bool CNetAddr::IsRFC3964() const\n-{\n-    return (GetByte(15) == 0x20 && GetByte(14) == 0x02);\n-}\n-\n-bool CNetAddr::IsRFC6052() const\n-{\n-    static const unsigned char pchRFC6052[] = {0,0x64,0xFF,0x9B,0,0,0,0,0,0,0,0};\n-    return (memcmp(ip, pchRFC6052, sizeof(pchRFC6052)) == 0);\n-}\n-\n-bool CNetAddr::IsRFC4380() const\n-{\n-    return (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0 && GetByte(12) == 0);\n-}\n-\n-bool CNetAddr::IsRFC4862() const\n-{\n-    static const unsigned char pchRFC4862[] = {0xFE,0x80,0,0,0,0,0,0};\n-    return (memcmp(ip, pchRFC4862, sizeof(pchRFC4862)) == 0);\n-}\n-\n-bool CNetAddr::IsRFC4193() const\n-{\n-    return ((GetByte(15) & 0xFE) == 0xFC);\n-}\n-\n-bool CNetAddr::IsRFC6145() const\n-{\n-    static const unsigned char pchRFC6145[] = {0,0,0,0,0,0,0,0,0xFF,0xFF,0,0};\n-    return (memcmp(ip, pchRFC6145, sizeof(pchRFC6145)) == 0);\n-}\n-\n-bool CNetAddr::IsRFC4843() const\n-{\n-    return (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x00 && (GetByte(12) & 0xF0) == 0x10);\n-}\n-\n-bool CNetAddr::IsTor() const\n-{\n-    return (memcmp(ip, pchOnionCat, sizeof(pchOnionCat)) == 0);\n-}\n-\n-bool CNetAddr::IsLocal() const\n-{\n-    // IPv4 loopback\n-   if (IsIPv4() && (GetByte(3) == 127 || GetByte(3) == 0))\n-       return true;\n-\n-   // IPv6 loopback (::1/128)\n-   static const unsigned char pchLocal[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1};\n-   if (memcmp(ip, pchLocal, 16) == 0)\n-       return true;\n-\n-   return false;\n-}\n-\n-bool CNetAddr::IsMulticast() const\n-{\n-    return    (IsIPv4() && (GetByte(3) & 0xF0) == 0xE0)\n-           || (GetByte(15) == 0xFF);\n-}\n-\n-bool CNetAddr::IsValid() const\n-{\n-    // Cleanup 3-byte shifted addresses caused by garbage in size field\n-    // of addr messages from versions before 0.2.9 checksum.\n-    // Two consecutive addr messages look like this:\n-    // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n-    // so if the first length field is garbled, it reads the second batch\n-    // of addr misaligned by 3 bytes.\n-    if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n-        return false;\n-\n-    // unspecified IPv6 address (::/128)\n-    unsigned char ipNone[16] = {};\n-    if (memcmp(ip, ipNone, 16) == 0)\n-        return false;\n-\n-    // documentation IPv6 address\n-    if (IsRFC3849())\n-        return false;\n-\n-    if (IsIPv4())\n-    {\n-        // INADDR_NONE\n-        uint32_t ipNone = INADDR_NONE;\n-        if (memcmp(ip+12, &ipNone, 4) == 0)\n-            return false;\n-\n-        // 0\n-        ipNone = 0;\n-        if (memcmp(ip+12, &ipNone, 4) == 0)\n-            return false;\n-    }\n-\n-    return true;\n-}\n-\n-bool CNetAddr::IsRoutable() const\n-{\n-    return IsValid() && !(IsRFC1918() || IsRFC2544() || IsRFC3927() || IsRFC4862() || IsRFC6598() || IsRFC5737() || (IsRFC4193() && !IsTor()) || IsRFC4843() || IsLocal());\n-}\n-\n-enum Network CNetAddr::GetNetwork() const\n-{\n-    if (!IsRoutable())\n-        return NET_UNROUTABLE;\n-\n-    if (IsIPv4())\n-        return NET_IPV4;\n-\n-    if (IsTor())\n-        return NET_TOR;\n-\n-    return NET_IPV6;\n-}\n-\n-std::string CNetAddr::ToStringIP() const\n-{\n-    if (IsTor())\n-        return EncodeBase32(&ip[6], 10) + \".onion\";\n-    CService serv(*this, 0);\n-    struct sockaddr_storage sockaddr;\n-    socklen_t socklen = sizeof(sockaddr);\n-    if (serv.GetSockAddr((struct sockaddr*)&sockaddr, &socklen)) {\n-        char name[1025] = \"\";\n-        if (!getnameinfo((const struct sockaddr*)&sockaddr, socklen, name, sizeof(name), NULL, 0, NI_NUMERICHOST))\n-            return std::string(name);\n-    }\n-    if (IsIPv4())\n-        return strprintf(\"%u.%u.%u.%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0));\n-    else\n-        return strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n-                         GetByte(15) << 8 | GetByte(14), GetByte(13) << 8 | GetByte(12),\n-                         GetByte(11) << 8 | GetByte(10), GetByte(9) << 8 | GetByte(8),\n-                         GetByte(7) << 8 | GetByte(6), GetByte(5) << 8 | GetByte(4),\n-                         GetByte(3) << 8 | GetByte(2), GetByte(1) << 8 | GetByte(0));\n-}\n-\n-std::string CNetAddr::ToString() const\n-{\n-    return ToStringIP();\n-}\n-\n-bool operator==(const CNetAddr& a, const CNetAddr& b)\n-{\n-    return (memcmp(a.ip, b.ip, 16) == 0);\n-}\n-\n-bool operator!=(const CNetAddr& a, const CNetAddr& b)\n-{\n-    return (memcmp(a.ip, b.ip, 16) != 0);\n-}\n-\n-bool operator<(const CNetAddr& a, const CNetAddr& b)\n-{\n-    return (memcmp(a.ip, b.ip, 16) < 0);\n-}\n-\n-bool CNetAddr::GetInAddr(struct in_addr* pipv4Addr) const\n-{\n-    if (!IsIPv4())\n-        return false;\n-    memcpy(pipv4Addr, ip+12, 4);\n-    return true;\n-}\n-\n-bool CNetAddr::GetIn6Addr(struct in6_addr* pipv6Addr) const\n-{\n-    memcpy(pipv6Addr, ip, 16);\n-    return true;\n-}\n-\n-// get canonical identifier of an address' group\n-// no two connections will be attempted to addresses with the same group\n-std::vector<unsigned char> CNetAddr::GetGroup() const\n-{\n-    std::vector<unsigned char> vchRet;\n-    int nClass = NET_IPV6;\n-    int nStartByte = 0;\n-    int nBits = 16;\n-\n-    // all local addresses belong to the same group\n-    if (IsLocal())\n-    {\n-        nClass = 255;\n-        nBits = 0;\n-    }\n-\n-    // all unroutable addresses belong to the same group\n-    if (!IsRoutable())\n-    {\n-        nClass = NET_UNROUTABLE;\n-        nBits = 0;\n-    }\n-    // for IPv4 addresses, '1' + the 16 higher-order bits of the IP\n-    // includes mapped IPv4, SIIT translated IPv4, and the well-known prefix\n-    else if (IsIPv4() || IsRFC6145() || IsRFC6052())\n-    {\n-        nClass = NET_IPV4;\n-        nStartByte = 12;\n-    }\n-    // for 6to4 tunnelled addresses, use the encapsulated IPv4 address\n-    else if (IsRFC3964())\n-    {\n-        nClass = NET_IPV4;\n-        nStartByte = 2;\n-    }\n-    // for Teredo-tunnelled IPv6 addresses, use the encapsulated IPv4 address\n-    else if (IsRFC4380())\n-    {\n-        vchRet.push_back(NET_IPV4);\n-        vchRet.push_back(GetByte(3) ^ 0xFF);\n-        vchRet.push_back(GetByte(2) ^ 0xFF);\n-        return vchRet;\n-    }\n-    else if (IsTor())\n-    {\n-        nClass = NET_TOR;\n-        nStartByte = 6;\n-        nBits = 4;\n-    }\n-    // for he.net, use /36 groups\n-    else if (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x04 && GetByte(12) == 0x70)\n-        nBits = 36;\n-    // for the rest of the IPv6 network, use /32 groups\n-    else\n-        nBits = 32;\n-\n-    vchRet.push_back(nClass);\n-    while (nBits >= 8)\n-    {\n-        vchRet.push_back(GetByte(15 - nStartByte));\n-        nStartByte++;\n-        nBits -= 8;\n-    }\n-    if (nBits > 0)\n-        vchRet.push_back(GetByte(15 - nStartByte) | ((1 << (8 - nBits)) - 1));\n-\n-    return vchRet;\n-}\n-\n-uint64_t CNetAddr::GetHash() const\n-{\n-    uint256 hash = Hash(&ip[0], &ip[16]);\n-    uint64_t nRet;\n-    memcpy(&nRet, &hash, sizeof(nRet));\n-    return nRet;\n-}\n-\n-// private extensions to enum Network, only returned by GetExtNetwork,\n-// and only used in GetReachabilityFrom\n-static const int NET_UNKNOWN = NET_MAX + 0;\n-static const int NET_TEREDO  = NET_MAX + 1;\n-int static GetExtNetwork(const CNetAddr *addr)\n-{\n-    if (addr == NULL)\n-        return NET_UNKNOWN;\n-    if (addr->IsRFC4380())\n-        return NET_TEREDO;\n-    return addr->GetNetwork();\n-}\n-\n-/** Calculates a metric for how reachable (*this) is from a given partner */\n-int CNetAddr::GetReachabilityFrom(const CNetAddr *paddrPartner) const\n-{\n-    enum Reachability {\n-        REACH_UNREACHABLE,\n-        REACH_DEFAULT,\n-        REACH_TEREDO,\n-        REACH_IPV6_WEAK,\n-        REACH_IPV4,\n-        REACH_IPV6_STRONG,\n-        REACH_PRIVATE\n-    };\n-\n-    if (!IsRoutable())\n-        return REACH_UNREACHABLE;\n-\n-    int ourNet = GetExtNetwork(this);\n-    int theirNet = GetExtNetwork(paddrPartner);\n-    bool fTunnel = IsRFC3964() || IsRFC6052() || IsRFC6145();\n-\n-    switch(theirNet) {\n-    case NET_IPV4:\n-        switch(ourNet) {\n-        default:       return REACH_DEFAULT;\n-        case NET_IPV4: return REACH_IPV4;\n-        }\n-    case NET_IPV6:\n-        switch(ourNet) {\n-        default:         return REACH_DEFAULT;\n-        case NET_TEREDO: return REACH_TEREDO;\n-        case NET_IPV4:   return REACH_IPV4;\n-        case NET_IPV6:   return fTunnel ? REACH_IPV6_WEAK : REACH_IPV6_STRONG; // only prefer giving our IPv6 address if it's not tunnelled\n-        }\n-    case NET_TOR:\n-        switch(ourNet) {\n-        default:         return REACH_DEFAULT;\n-        case NET_IPV4:   return REACH_IPV4; // Tor users can connect to IPv4 as well\n-        case NET_TOR:    return REACH_PRIVATE;\n-        }\n-    case NET_TEREDO:\n-        switch(ourNet) {\n-        default:          return REACH_DEFAULT;\n-        case NET_TEREDO:  return REACH_TEREDO;\n-        case NET_IPV6:    return REACH_IPV6_WEAK;\n-        case NET_IPV4:    return REACH_IPV4;\n-        }\n-    case NET_UNKNOWN:\n-    case NET_UNROUTABLE:\n-    default:\n-        switch(ourNet) {\n-        default:          return REACH_DEFAULT;\n-        case NET_TEREDO:  return REACH_TEREDO;\n-        case NET_IPV6:    return REACH_IPV6_WEAK;\n-        case NET_IPV4:    return REACH_IPV4;\n-        case NET_TOR:     return REACH_PRIVATE; // either from Tor, or don't care about our address\n-        }\n-    }\n-}\n-\n-void CService::Init()\n-{\n-    port = 0;\n-}\n-\n-CService::CService()\n-{\n-    Init();\n-}\n-\n-CService::CService(const CNetAddr& cip, unsigned short portIn) : CNetAddr(cip), port(portIn)\n-{\n-}\n-\n-CService::CService(const struct in_addr& ipv4Addr, unsigned short portIn) : CNetAddr(ipv4Addr), port(portIn)\n-{\n-}\n-\n-CService::CService(const struct in6_addr& ipv6Addr, unsigned short portIn) : CNetAddr(ipv6Addr), port(portIn)\n-{\n-}\n-\n-CService::CService(const struct sockaddr_in& addr) : CNetAddr(addr.sin_addr), port(ntohs(addr.sin_port))\n-{\n-    assert(addr.sin_family == AF_INET);\n-}\n-\n-CService::CService(const struct sockaddr_in6 &addr) : CNetAddr(addr.sin6_addr, addr.sin6_scope_id), port(ntohs(addr.sin6_port))\n-{\n-   assert(addr.sin6_family == AF_INET6);\n-}\n-\n-bool CService::SetSockAddr(const struct sockaddr *paddr)\n-{\n-    switch (paddr->sa_family) {\n-    case AF_INET:\n-        *this = CService(*(const struct sockaddr_in*)paddr);\n-        return true;\n-    case AF_INET6:\n-        *this = CService(*(const struct sockaddr_in6*)paddr);\n-        return true;\n-    default:\n-        return false;\n-    }\n-}\n-\n-unsigned short CService::GetPort() const\n-{\n-    return port;\n-}\n-\n-bool operator==(const CService& a, const CService& b)\n-{\n-    return (CNetAddr)a == (CNetAddr)b && a.port == b.port;\n-}\n-\n-bool operator!=(const CService& a, const CService& b)\n-{\n-    return (CNetAddr)a != (CNetAddr)b || a.port != b.port;\n-}\n-\n-bool operator<(const CService& a, const CService& b)\n-{\n-    return (CNetAddr)a < (CNetAddr)b || ((CNetAddr)a == (CNetAddr)b && a.port < b.port);\n-}\n-\n-bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n-{\n-    if (IsIPv4()) {\n-        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n-            return false;\n-        *addrlen = sizeof(struct sockaddr_in);\n-        struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n-        memset(paddrin, 0, *addrlen);\n-        if (!GetInAddr(&paddrin->sin_addr))\n-            return false;\n-        paddrin->sin_family = AF_INET;\n-        paddrin->sin_port = htons(port);\n-        return true;\n-    }\n-    if (IsIPv6()) {\n-        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n-            return false;\n-        *addrlen = sizeof(struct sockaddr_in6);\n-        struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n-        memset(paddrin6, 0, *addrlen);\n-        if (!GetIn6Addr(&paddrin6->sin6_addr))\n-            return false;\n-        paddrin6->sin6_scope_id = scopeId;\n-        paddrin6->sin6_family = AF_INET6;\n-        paddrin6->sin6_port = htons(port);\n-        return true;\n-    }\n-    return false;\n-}\n-\n-std::vector<unsigned char> CService::GetKey() const\n-{\n-     std::vector<unsigned char> vKey;\n-     vKey.resize(18);\n-     memcpy(&vKey[0], ip, 16);\n-     vKey[16] = port / 0x100;\n-     vKey[17] = port & 0x0FF;\n-     return vKey;\n-}\n-\n-std::string CService::ToStringPort() const\n-{\n-    return strprintf(\"%u\", port);\n-}\n-\n-std::string CService::ToStringIPPort() const\n-{\n-    if (IsIPv4() || IsTor()) {\n-        return ToStringIP() + \":\" + ToStringPort();\n-    } else {\n-        return \"[\" + ToStringIP() + \"]:\" + ToStringPort();\n-    }\n-}\n-\n-std::string CService::ToString() const\n-{\n-    return ToStringIPPort();\n-}\n-\n-void CService::SetPort(unsigned short portIn)\n-{\n-    port = portIn;\n-}\n-\n-CSubNet::CSubNet():\n-    valid(false)\n-{\n-    memset(netmask, 0, sizeof(netmask));\n-}\n-\n-CSubNet::CSubNet(const CNetAddr &addr, int32_t mask)\n-{\n-    valid = true;\n-    network = addr;\n-    // Default to /32 (IPv4) or /128 (IPv6), i.e. match single address\n-    memset(netmask, 255, sizeof(netmask));\n-\n-    // IPv4 addresses start at offset 12, and first 12 bytes must match, so just offset n\n-    const int astartofs = network.IsIPv4() ? 12 : 0;\n-\n-    int32_t n = mask;\n-    if(n >= 0 && n <= (128 - astartofs*8)) // Only valid if in range of bits of address\n-    {\n-        n += astartofs*8;\n-        // Clear bits [n..127]\n-        for (; n < 128; ++n)\n-            netmask[n>>3] &= ~(1<<(7-(n&7)));\n-    } else\n-        valid = false;\n-\n-    // Normalize network according to netmask\n-    for(int x=0; x<16; ++x)\n-        network.ip[x] &= netmask[x];\n-}\n-\n-CSubNet::CSubNet(const CNetAddr &addr, const CNetAddr &mask)\n-{\n-    valid = true;\n-    network = addr;\n-    // Default to /32 (IPv4) or /128 (IPv6), i.e. match single address\n-    memset(netmask, 255, sizeof(netmask));\n-\n-    // IPv4 addresses start at offset 12, and first 12 bytes must match, so just offset n\n-    const int astartofs = network.IsIPv4() ? 12 : 0;\n-\n-    for(int x=astartofs; x<16; ++x)\n-        netmask[x] = mask.ip[x];\n-\n-    // Normalize network according to netmask\n-    for(int x=0; x<16; ++x)\n-        network.ip[x] &= netmask[x];\n-}\n-\n-\n bool LookupSubNet(const char* pszName, CSubNet& ret)\n {\n     std::string strSubnet(pszName);\n@@ -1295,97 +681,6 @@ bool LookupSubNet(const char* pszName, CSubNet& ret)\n     return false;\n }\n \n-CSubNet::CSubNet(const CNetAddr &addr):\n-    valid(addr.IsValid())\n-{\n-    memset(netmask, 255, sizeof(netmask));\n-    network = addr;\n-}\n-\n-bool CSubNet::Match(const CNetAddr &addr) const\n-{\n-    if (!valid || !addr.IsValid())\n-        return false;\n-    for(int x=0; x<16; ++x)\n-        if ((addr.ip[x] & netmask[x]) != network.ip[x])\n-            return false;\n-    return true;\n-}\n-\n-static inline int NetmaskBits(uint8_t x)\n-{\n-    switch(x) {\n-    case 0x00: return 0; break;\n-    case 0x80: return 1; break;\n-    case 0xc0: return 2; break;\n-    case 0xe0: return 3; break;\n-    case 0xf0: return 4; break;\n-    case 0xf8: return 5; break;\n-    case 0xfc: return 6; break;\n-    case 0xfe: return 7; break;\n-    case 0xff: return 8; break;\n-    default: return -1; break;\n-    }\n-}\n-\n-std::string CSubNet::ToString() const\n-{\n-    /* Parse binary 1{n}0{N-n} to see if mask can be represented as /n */\n-    int cidr = 0;\n-    bool valid_cidr = true;\n-    int n = network.IsIPv4() ? 12 : 0;\n-    for (; n < 16 && netmask[n] == 0xff; ++n)\n-        cidr += 8;\n-    if (n < 16) {\n-        int bits = NetmaskBits(netmask[n]);\n-        if (bits < 0)\n-            valid_cidr = false;\n-        else\n-            cidr += bits;\n-        ++n;\n-    }\n-    for (; n < 16 && valid_cidr; ++n)\n-        if (netmask[n] != 0x00)\n-            valid_cidr = false;\n-\n-    /* Format output */\n-    std::string strNetmask;\n-    if (valid_cidr) {\n-        strNetmask = strprintf(\"%u\", cidr);\n-    } else {\n-        if (network.IsIPv4())\n-            strNetmask = strprintf(\"%u.%u.%u.%u\", netmask[12], netmask[13], netmask[14], netmask[15]);\n-        else\n-            strNetmask = strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n-                             netmask[0] << 8 | netmask[1], netmask[2] << 8 | netmask[3],\n-                             netmask[4] << 8 | netmask[5], netmask[6] << 8 | netmask[7],\n-                             netmask[8] << 8 | netmask[9], netmask[10] << 8 | netmask[11],\n-                             netmask[12] << 8 | netmask[13], netmask[14] << 8 | netmask[15]);\n-    }\n-\n-    return network.ToString() + \"/\" + strNetmask;\n-}\n-\n-bool CSubNet::IsValid() const\n-{\n-    return valid;\n-}\n-\n-bool operator==(const CSubNet& a, const CSubNet& b)\n-{\n-    return a.valid == b.valid && a.network == b.network && !memcmp(a.netmask, b.netmask, 16);\n-}\n-\n-bool operator!=(const CSubNet& a, const CSubNet& b)\n-{\n-    return !(a==b);\n-}\n-\n-bool operator<(const CSubNet& a, const CSubNet& b)\n-{\n-    return (a.network < b.network || (a.network == b.network && memcmp(a.netmask, b.netmask, 16) < 0));\n-}\n-\n #ifdef WIN32\n std::string NetworkErrorString(int err)\n {"
      },
      {
        "sha": "d0abd5e954ef4ae636bf635b9f9c4d98da2a5230",
        "filename": "src/netbase.h",
        "status": "modified",
        "additions": 1,
        "deletions": 157,
        "changes": 158,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21e5b96ff417f304e624052f629e2b030984180f/src/netbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21e5b96ff417f304e624052f629e2b030984180f/src/netbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.h?ref=21e5b96ff417f304e624052f629e2b030984180f",
        "patch": "@@ -10,6 +10,7 @@\n #endif\n \n #include \"compat.h\"\n+#include \"netaddress.h\"\n #include \"serialize.h\"\n \n #include <stdint.h>\n@@ -24,163 +25,6 @@ static const int DEFAULT_CONNECT_TIMEOUT = 5000;\n //! -dns default\n static const int DEFAULT_NAME_LOOKUP = true;\n \n-#ifdef WIN32\n-// In MSVC, this is defined as a macro, undefine it to prevent a compile and link error\n-#undef SetPort\n-#endif\n-\n-enum Network\n-{\n-    NET_UNROUTABLE = 0,\n-    NET_IPV4,\n-    NET_IPV6,\n-    NET_TOR,\n-\n-    NET_MAX,\n-};\n-\n-/** IP address (IPv6, or IPv4 using mapped IPv6 range (::FFFF:0:0/96)) */\n-class CNetAddr\n-{\n-    protected:\n-        unsigned char ip[16]; // in network byte order\n-        uint32_t scopeId; // for scoped/link-local ipv6 addresses\n-\n-    public:\n-        CNetAddr();\n-        CNetAddr(const struct in_addr& ipv4Addr);\n-        void Init();\n-        void SetIP(const CNetAddr& ip);\n-\n-        /**\n-         * Set raw IPv4 or IPv6 address (in network byte order)\n-         * @note Only NET_IPV4 and NET_IPV6 are allowed for network.\n-         */\n-        void SetRaw(Network network, const uint8_t *data);\n-\n-        bool SetSpecial(const std::string &strName); // for Tor addresses\n-        bool IsIPv4() const;    // IPv4 mapped address (::FFFF:0:0/96, 0.0.0.0/0)\n-        bool IsIPv6() const;    // IPv6 address (not mapped IPv4, not Tor)\n-        bool IsRFC1918() const; // IPv4 private networks (10.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12)\n-        bool IsRFC2544() const; // IPv4 inter-network communcations (192.18.0.0/15)\n-        bool IsRFC6598() const; // IPv4 ISP-level NAT (100.64.0.0/10)\n-        bool IsRFC5737() const; // IPv4 documentation addresses (192.0.2.0/24, 198.51.100.0/24, 203.0.113.0/24)\n-        bool IsRFC3849() const; // IPv6 documentation address (2001:0DB8::/32)\n-        bool IsRFC3927() const; // IPv4 autoconfig (169.254.0.0/16)\n-        bool IsRFC3964() const; // IPv6 6to4 tunnelling (2002::/16)\n-        bool IsRFC4193() const; // IPv6 unique local (FC00::/7)\n-        bool IsRFC4380() const; // IPv6 Teredo tunnelling (2001::/32)\n-        bool IsRFC4843() const; // IPv6 ORCHID (2001:10::/28)\n-        bool IsRFC4862() const; // IPv6 autoconfig (FE80::/64)\n-        bool IsRFC6052() const; // IPv6 well-known prefix (64:FF9B::/96)\n-        bool IsRFC6145() const; // IPv6 IPv4-translated address (::FFFF:0:0:0/96)\n-        bool IsTor() const;\n-        bool IsLocal() const;\n-        bool IsRoutable() const;\n-        bool IsValid() const;\n-        bool IsMulticast() const;\n-        enum Network GetNetwork() const;\n-        std::string ToString() const;\n-        std::string ToStringIP() const;\n-        unsigned int GetByte(int n) const;\n-        uint64_t GetHash() const;\n-        bool GetInAddr(struct in_addr* pipv4Addr) const;\n-        std::vector<unsigned char> GetGroup() const;\n-        int GetReachabilityFrom(const CNetAddr *paddrPartner = NULL) const;\n-\n-        CNetAddr(const struct in6_addr& pipv6Addr, const uint32_t scope = 0);\n-        bool GetIn6Addr(struct in6_addr* pipv6Addr) const;\n-\n-        friend bool operator==(const CNetAddr& a, const CNetAddr& b);\n-        friend bool operator!=(const CNetAddr& a, const CNetAddr& b);\n-        friend bool operator<(const CNetAddr& a, const CNetAddr& b);\n-\n-        ADD_SERIALIZE_METHODS;\n-\n-        template <typename Stream, typename Operation>\n-        inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n-            READWRITE(FLATDATA(ip));\n-        }\n-\n-        friend class CSubNet;\n-};\n-\n-class CSubNet\n-{\n-    protected:\n-        /// Network (base) address\n-        CNetAddr network;\n-        /// Netmask, in network byte order\n-        uint8_t netmask[16];\n-        /// Is this value valid? (only used to signal parse errors)\n-        bool valid;\n-\n-    public:\n-        CSubNet();\n-        CSubNet(const CNetAddr &addr, int32_t mask);\n-        CSubNet(const CNetAddr &addr, const CNetAddr &mask);\n-\n-        //constructor for single ip subnet (<ipv4>/32 or <ipv6>/128)\n-        explicit CSubNet(const CNetAddr &addr);\n-\n-        bool Match(const CNetAddr &addr) const;\n-\n-        std::string ToString() const;\n-        bool IsValid() const;\n-\n-        friend bool operator==(const CSubNet& a, const CSubNet& b);\n-        friend bool operator!=(const CSubNet& a, const CSubNet& b);\n-        friend bool operator<(const CSubNet& a, const CSubNet& b);\n-\n-        ADD_SERIALIZE_METHODS;\n-\n-        template <typename Stream, typename Operation>\n-        inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n-            READWRITE(network);\n-            READWRITE(FLATDATA(netmask));\n-            READWRITE(FLATDATA(valid));\n-        }\n-};\n-\n-/** A combination of a network address (CNetAddr) and a (TCP) port */\n-class CService : public CNetAddr\n-{\n-    protected:\n-        unsigned short port; // host order\n-\n-    public:\n-        CService();\n-        CService(const CNetAddr& ip, unsigned short port);\n-        CService(const struct in_addr& ipv4Addr, unsigned short port);\n-        CService(const struct sockaddr_in& addr);\n-        void Init();\n-        void SetPort(unsigned short portIn);\n-        unsigned short GetPort() const;\n-        bool GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const;\n-        bool SetSockAddr(const struct sockaddr* paddr);\n-        friend bool operator==(const CService& a, const CService& b);\n-        friend bool operator!=(const CService& a, const CService& b);\n-        friend bool operator<(const CService& a, const CService& b);\n-        std::vector<unsigned char> GetKey() const;\n-        std::string ToString() const;\n-        std::string ToStringPort() const;\n-        std::string ToStringIPPort() const;\n-\n-        CService(const struct in6_addr& ipv6Addr, unsigned short port);\n-        CService(const struct sockaddr_in6& addr);\n-\n-        ADD_SERIALIZE_METHODS;\n-\n-        template <typename Stream, typename Operation>\n-        inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n-            READWRITE(FLATDATA(ip));\n-            unsigned short portN = htons(port);\n-            READWRITE(FLATDATA(portN));\n-            if (ser_action.ForRead())\n-                 port = ntohs(portN);\n-        }\n-};\n-\n class proxyType\n {\n public:"
      }
    ]
  },
  {
    "sha": "21ba407a7369a0229b8a8554dee0da63a64e6639",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMWJhNDA3YTczNjlhMDIyOWI4YTg1NTRkZWUwZGE2M2E2NGU2NjM5",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-05-31T21:42:38Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-07-31T18:01:44Z"
      },
      "message": "net: narrow include scope after moving to netaddress\n\nNet functionality is no longer needed for CAddress/CAddrman/etc. now that\nCNetAddr/CService/CSubNet are dumb storage classes.",
      "tree": {
        "sha": "8a7298261bac9cc41951fcaf899455a784e7b759",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8a7298261bac9cc41951fcaf899455a784e7b759"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/21ba407a7369a0229b8a8554dee0da63a64e6639",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/21ba407a7369a0229b8a8554dee0da63a64e6639",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/21ba407a7369a0229b8a8554dee0da63a64e6639",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/21ba407a7369a0229b8a8554dee0da63a64e6639/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "21e5b96ff417f304e624052f629e2b030984180f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/21e5b96ff417f304e624052f629e2b030984180f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/21e5b96ff417f304e624052f629e2b030984180f"
      }
    ],
    "stats": {
      "total": 16,
      "additions": 11,
      "deletions": 5
    },
    "files": [
      {
        "sha": "9bab39049d7ab2ed886ceb62e19156d63dc78d6e",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21ba407a7369a0229b8a8554dee0da63a64e6639/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21ba407a7369a0229b8a8554dee0da63a64e6639/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=21ba407a7369a0229b8a8554dee0da63a64e6639",
        "patch": "@@ -6,7 +6,7 @@\n #ifndef BITCOIN_ADDRMAN_H\n #define BITCOIN_ADDRMAN_H\n \n-#include \"netbase.h\"\n+#include \"netaddress.h\"\n #include \"protocol.h\"\n #include \"random.h\"\n #include \"sync.h\""
      },
      {
        "sha": "4f5eeeffe67e705f8a9eed581975602e13943b64",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21ba407a7369a0229b8a8554dee0da63a64e6639/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21ba407a7369a0229b8a8554dee0da63a64e6639/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=21ba407a7369a0229b8a8554dee0da63a64e6639",
        "patch": "@@ -21,6 +21,7 @@\n #include \"key.h\"\n #include \"main.h\"\n #include \"miner.h\"\n+#include \"netbase.h\"\n #include \"net.h\"\n #include \"policy/policy.h\"\n #include \"rpc/server.h\""
      },
      {
        "sha": "e9bb406e976c5e2d378458911b9315fb9e64d4de",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21ba407a7369a0229b8a8554dee0da63a64e6639/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21ba407a7369a0229b8a8554dee0da63a64e6639/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=21ba407a7369a0229b8a8554dee0da63a64e6639",
        "patch": "@@ -17,6 +17,7 @@\n #include \"crypto/sha256.h\"\n #include \"hash.h\"\n #include \"primitives/transaction.h\"\n+#include \"netbase.h\"\n #include \"scheduler.h\"\n #include \"ui_interface.h\"\n #include \"utilstrencodings.h\""
      },
      {
        "sha": "ea03defc408cf683e3cb8572cf22764b3bde38b4",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21ba407a7369a0229b8a8554dee0da63a64e6639/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21ba407a7369a0229b8a8554dee0da63a64e6639/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=21ba407a7369a0229b8a8554dee0da63a64e6639",
        "patch": "@@ -10,7 +10,7 @@\n #include \"bloom.h\"\n #include \"compat.h\"\n #include \"limitedmap.h\"\n-#include \"netbase.h\"\n+#include \"netaddress.h\"\n #include \"protocol.h\"\n #include \"random.h\"\n #include \"streams.h\""
      },
      {
        "sha": "015215b2a668b2757db2a0718062fda7d1d3d171",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21ba407a7369a0229b8a8554dee0da63a64e6639/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21ba407a7369a0229b8a8554dee0da63a64e6639/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=21ba407a7369a0229b8a8554dee0da63a64e6639",
        "patch": "@@ -10,7 +10,7 @@\n #ifndef BITCOIN_PROTOCOL_H\n #define BITCOIN_PROTOCOL_H\n \n-#include \"netbase.h\"\n+#include \"netaddress.h\"\n #include \"serialize.h\"\n #include \"uint256.h\"\n #include \"version.h\""
      },
      {
        "sha": "d33ab682770f0005d88c365a394e962b364c8ac6",
        "filename": "src/qt/optionsmodel.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21ba407a7369a0229b8a8554dee0da63a64e6639/src/qt/optionsmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21ba407a7369a0229b8a8554dee0da63a64e6639/src/qt/optionsmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsmodel.cpp?ref=21ba407a7369a0229b8a8554dee0da63a64e6639",
        "patch": "@@ -15,6 +15,7 @@\n #include \"init.h\"\n #include \"main.h\" // For DEFAULT_SCRIPTCHECK_THREADS\n #include \"net.h\"\n+#include \"netbase.h\"\n #include \"txdb.h\" // for -dbcache defaults\n \n #ifdef ENABLE_WALLET"
      },
      {
        "sha": "bcaa9164c91ba9b80f447b45e256e58560118dd7",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21ba407a7369a0229b8a8554dee0da63a64e6639/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21ba407a7369a0229b8a8554dee0da63a64e6639/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=21ba407a7369a0229b8a8554dee0da63a64e6639",
        "patch": "@@ -16,6 +16,7 @@\n #include \"bantablemodel.h\"\n \n #include \"chainparams.h\"\n+#include \"netbase.h\"\n #include \"rpc/server.h\"\n #include \"rpc/client.h\"\n #include \"util.h\""
      },
      {
        "sha": "5f150e4812af5220d51c22c751a28fad1d030a9d",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21ba407a7369a0229b8a8554dee0da63a64e6639/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21ba407a7369a0229b8a8554dee0da63a64e6639/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=21ba407a7369a0229b8a8554dee0da63a64e6639",
        "patch": "@@ -7,6 +7,7 @@\n #include <boost/test/unit_test.hpp>\n \n #include \"hash.h\"\n+#include \"netbase.h\"\n #include \"random.h\"\n \n using namespace std;"
      },
      {
        "sha": "6511e6ffa24f14e48d45241da057d0c62226024f",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21ba407a7369a0229b8a8554dee0da63a64e6639/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21ba407a7369a0229b8a8554dee0da63a64e6639/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=21ba407a7369a0229b8a8554dee0da63a64e6639",
        "patch": "@@ -9,6 +9,7 @@\n #include \"serialize.h\"\n #include \"streams.h\"\n #include \"net.h\"\n+#include \"netbase.h\"\n #include \"chainparams.h\"\n \n using namespace std;"
      },
      {
        "sha": "25fc494121d4debbd00f91fb8af6674beb600dca",
        "filename": "src/timedata.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21ba407a7369a0229b8a8554dee0da63a64e6639/src/timedata.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21ba407a7369a0229b8a8554dee0da63a64e6639/src/timedata.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timedata.cpp?ref=21ba407a7369a0229b8a8554dee0da63a64e6639",
        "patch": "@@ -8,7 +8,7 @@\n \n #include \"timedata.h\"\n \n-#include \"netbase.h\"\n+#include \"netaddress.h\"\n #include \"sync.h\"\n #include \"ui_interface.h\"\n #include \"util.h\""
      },
      {
        "sha": "c7f96270050ac0b2b94b02dc3a7e78307c2cb310",
        "filename": "src/torcontrol.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21ba407a7369a0229b8a8554dee0da63a64e6639/src/torcontrol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21ba407a7369a0229b8a8554dee0da63a64e6639/src/torcontrol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/torcontrol.cpp?ref=21ba407a7369a0229b8a8554dee0da63a64e6639",
        "patch": "@@ -4,6 +4,7 @@\n \n #include \"torcontrol.h\"\n #include \"utilstrencodings.h\"\n+#include \"netbase.h\"\n #include \"net.h\"\n #include \"util.h\"\n #include \"crypto/hmac_sha256.h\""
      },
      {
        "sha": "aa0a9374c19917d8692b258731f949cebeebfc1a",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/21ba407a7369a0229b8a8554dee0da63a64e6639/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/21ba407a7369a0229b8a8554dee0da63a64e6639/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=21ba407a7369a0229b8a8554dee0da63a64e6639",
        "patch": "@@ -10,7 +10,6 @@\n #include \"init.h\"\n #include \"main.h\"\n #include \"net.h\"\n-#include \"netbase.h\"\n #include \"policy/rbf.h\"\n #include \"rpc/server.h\"\n #include \"timedata.h\""
      }
    ]
  },
  {
    "sha": "8945384bca00f74ba85c98a52925c254c49025a5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4OTQ1Mzg0YmNhMDBmNzRiYTg1Yzk4YTUyOTI1YzI1NGM0OTAyNWE1",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-08-04T20:37:49Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-08-04T20:41:39Z"
      },
      "message": "net: Have LookupNumeric return a CService directly\n\nAlso fix up a few small issues:\n- Lookup with \"badip:port\" now sets the port to 0\n- Don't allow assert to have side-effects",
      "tree": {
        "sha": "c5479d77e5feb28ed75b53715073bcf3b46c1ffe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c5479d77e5feb28ed75b53715073bcf3b46c1ffe"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8945384bca00f74ba85c98a52925c254c49025a5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8945384bca00f74ba85c98a52925c254c49025a5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8945384bca00f74ba85c98a52925c254c49025a5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8945384bca00f74ba85c98a52925c254c49025a5/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "21ba407a7369a0229b8a8554dee0da63a64e6639",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/21ba407a7369a0229b8a8554dee0da63a64e6639",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/21ba407a7369a0229b8a8554dee0da63a64e6639"
      }
    ],
    "stats": {
      "total": 39,
      "additions": 18,
      "deletions": 21
    },
    "files": [
      {
        "sha": "2bb4be564ea94a65b4759326cdc7bb88fef3658f",
        "filename": "src/httpserver.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8945384bca00f74ba85c98a52925c254c49025a5/src/httpserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8945384bca00f74ba85c98a52925c254c49025a5/src/httpserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.cpp?ref=8945384bca00f74ba85c98a52925c254c49025a5",
        "patch": "@@ -619,7 +619,7 @@ CService HTTPRequest::GetPeer()\n         const char* address = \"\";\n         uint16_t port = 0;\n         evhttp_connection_get_peer(con, (char**)&address, &port);\n-        LookupNumeric(address, peer, port);\n+        peer = LookupNumeric(address, port);\n     }\n     return peer;\n }"
      },
      {
        "sha": "04d7ed0ea3ff18a8bdee9a771f7a665093eb6250",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8945384bca00f74ba85c98a52925c254c49025a5/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8945384bca00f74ba85c98a52925c254c49025a5/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=8945384bca00f74ba85c98a52925c254c49025a5",
        "patch": "@@ -1098,8 +1098,7 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n     std::string proxyArg = GetArg(\"-proxy\", \"\");\n     SetLimited(NET_TOR);\n     if (proxyArg != \"\" && proxyArg != \"0\") {\n-        CService resolved;\n-        LookupNumeric(proxyArg.c_str(), resolved, 9050);\n+        CService resolved(LookupNumeric(proxyArg.c_str(), 9050));\n         proxyType addrProxy = proxyType(resolved, proxyRandomize);\n         if (!addrProxy.IsValid())\n             return InitError(strprintf(_(\"Invalid -proxy address: '%s'\"), proxyArg));\n@@ -1119,8 +1118,7 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n         if (onionArg == \"0\") { // Handle -noonion/-onion=0\n             SetLimited(NET_TOR); // set onions as unreachable\n         } else {\n-            CService resolved;\n-            LookupNumeric(onionArg.c_str(), resolved, 9050);\n+            CService resolved(LookupNumeric(onionArg.c_str(), 9050));\n             proxyType addrOnion = proxyType(resolved, proxyRandomize);\n             if (!addrOnion.IsValid())\n                 return InitError(strprintf(_(\"Invalid -onion address: '%s'\"), onionArg));"
      },
      {
        "sha": "fc44a0f17cb2003168df532eb7177e836a81ebbe",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8945384bca00f74ba85c98a52925c254c49025a5/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8945384bca00f74ba85c98a52925c254c49025a5/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=8945384bca00f74ba85c98a52925c254c49025a5",
        "patch": "@@ -1728,8 +1728,7 @@ std::vector<AddedNodeInfo> GetAddedNodeInfo()\n     }\n \n     BOOST_FOREACH(const std::string& strAddNode, lAddresses) {\n-        CService service;\n-        LookupNumeric(strAddNode.c_str(), service, Params().GetDefaultPort());\n+        CService service(LookupNumeric(strAddNode.c_str(), Params().GetDefaultPort()));\n         if (service.IsValid()) {\n             // strAddNode is an IP:port\n             auto it = mapConnected.find(service);\n@@ -1767,8 +1766,7 @@ void ThreadOpenAddedConnections()\n                 CSemaphoreGrant grant(*semOutbound);\n                 // If strAddedNode is an IP/port, decode it immediately, so\n                 // OpenNetworkConnection can detect existing connections to that IP/port.\n-                CService service;\n-                LookupNumeric(info.strAddedNode.c_str(), service, Params().GetDefaultPort());\n+                CService service(LookupNumeric(info.strAddedNode.c_str(), Params().GetDefaultPort()));\n                 OpenNetworkConnection(CAddress(service, NODE_NONE), false, &grant, info.strAddedNode.c_str(), false);\n                 MilliSleep(500);\n             }"
      },
      {
        "sha": "4f243ec6f539746ed80d57a592158d4a7e85dad6",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 2,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8945384bca00f74ba85c98a52925c254c49025a5/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8945384bca00f74ba85c98a52925c254c49025a5/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=8945384bca00f74ba85c98a52925c254c49025a5",
        "patch": "@@ -231,9 +231,14 @@ bool Lookup(const char *pszName, CService& addr, int portDefault, bool fAllowLoo\n     return true;\n }\n \n-bool LookupNumeric(const char *pszName, CService& addr, int portDefault)\n+CService LookupNumeric(const char *pszName, int portDefault)\n {\n-    return Lookup(pszName, addr, portDefault, false);\n+    CService addr;\n+    // \"1.2:345\" will fail to resolve the ip, but will still set the port.\n+    // If the ip fails to resolve, re-init the result.\n+    if(!Lookup(pszName, addr, portDefault, false))\n+        addr = CService();\n+    return addr;\n }\n \n struct timeval MillisToTimeval(int64_t nTimeout)"
      },
      {
        "sha": "bb12019a8216b0ccc592552762f1dced63c75390",
        "filename": "src/netbase.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8945384bca00f74ba85c98a52925c254c49025a5/src/netbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8945384bca00f74ba85c98a52925c254c49025a5/src/netbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.h?ref=8945384bca00f74ba85c98a52925c254c49025a5",
        "patch": "@@ -49,7 +49,7 @@ bool LookupHost(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nM\n bool LookupHost(const char *pszName, CNetAddr& addr, bool fAllowLookup);\n bool Lookup(const char *pszName, CService& addr, int portDefault, bool fAllowLookup);\n bool Lookup(const char *pszName, std::vector<CService>& vAddr, int portDefault, bool fAllowLookup, unsigned int nMaxSolutions);\n-bool LookupNumeric(const char *pszName, CService& addr, int portDefault = 0);\n+CService LookupNumeric(const char *pszName, int portDefault = 0);\n bool LookupSubNet(const char *pszName, CSubNet& subnet);\n bool ConnectSocket(const CService &addr, SOCKET& hSocketRet, int nTimeout, bool *outProxyConnectionFailed = 0);\n bool ConnectSocketByName(CService &addr, SOCKET& hSocketRet, const char *pszDest, int portDefault, int nTimeout, bool *outProxyConnectionFailed = 0);"
      },
      {
        "sha": "f73bb87064088013bea026311a71c606d8410277",
        "filename": "src/qt/optionsdialog.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8945384bca00f74ba85c98a52925c254c49025a5/src/qt/optionsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8945384bca00f74ba85c98a52925c254c49025a5/src/qt/optionsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsdialog.cpp?ref=8945384bca00f74ba85c98a52925c254c49025a5",
        "patch": "@@ -327,8 +327,7 @@ QValidator::State ProxyAddressValidator::validate(QString &input, int &pos) cons\n {\n     Q_UNUSED(pos);\n     // Validate the proxy\n-    CService serv;\n-    LookupNumeric(input.toStdString().c_str(), serv, 9050);\n+    CService serv(LookupNumeric(input.toStdString().c_str(), 9050));\n     proxyType addrProxy = proxyType(serv, true);\n     if (addrProxy.IsValid())\n         return QValidator::Acceptable;"
      },
      {
        "sha": "18ad5dc90bf4ed4e7b655ff421ddf6af878b2a53",
        "filename": "src/test/netbase_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8945384bca00f74ba85c98a52925c254c49025a5/src/test/netbase_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8945384bca00f74ba85c98a52925c254c49025a5/src/test/netbase_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/netbase_tests.cpp?ref=8945384bca00f74ba85c98a52925c254c49025a5",
        "patch": "@@ -93,9 +93,7 @@ BOOST_AUTO_TEST_CASE(netbase_splithost)\n \n bool static TestParse(string src, string canon)\n {\n-    CService addr;\n-    if (!LookupNumeric(src.c_str(), addr, 65535))\n-        return canon == \"\";\n+    CService addr(LookupNumeric(src.c_str(), 65535));\n     return canon == addr.ToString();\n }\n \n@@ -107,7 +105,7 @@ BOOST_AUTO_TEST_CASE(netbase_lookupnumeric)\n     BOOST_CHECK(TestParse(\"::\", \"[::]:65535\"));\n     BOOST_CHECK(TestParse(\"[::]:8333\", \"[::]:8333\"));\n     BOOST_CHECK(TestParse(\"[127.0.0.1]\", \"127.0.0.1:65535\"));\n-    BOOST_CHECK(TestParse(\":::\", \"\"));\n+    BOOST_CHECK(TestParse(\":::\", \"[::]:0\"));\n }\n \n BOOST_AUTO_TEST_CASE(onioncat_test)"
      },
      {
        "sha": "99c45d489cb2146c5f1e0a70ba88c03021c680e5",
        "filename": "src/torcontrol.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8945384bca00f74ba85c98a52925c254c49025a5/src/torcontrol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8945384bca00f74ba85c98a52925c254c49025a5/src/torcontrol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/torcontrol.cpp?ref=8945384bca00f74ba85c98a52925c254c49025a5",
        "patch": "@@ -438,7 +438,7 @@ void TorController::add_onion_cb(TorControlConnection& conn, const TorControlRep\n             if ((i = m.find(\"PrivateKey\")) != m.end())\n                 private_key = i->second;\n         }\n-        LookupNumeric(std::string(service_id+\".onion\").c_str(), service, GetListenPort());\n+        service = LookupNumeric(std::string(service_id+\".onion\").c_str(), GetListenPort());\n         LogPrintf(\"tor: Got service ID %s, advertising service %s\\n\", service_id, service.ToString());\n         if (WriteBinaryFile(GetPrivateKeyFile(), private_key)) {\n             LogPrint(\"tor\", \"tor: Cached service private key to %s\\n\", GetPrivateKeyFile());\n@@ -462,8 +462,7 @@ void TorController::auth_cb(TorControlConnection& conn, const TorControlReply& r\n         // Now that we know Tor is running setup the proxy for onion addresses\n         // if -onion isn't set to something else.\n         if (GetArg(\"-onion\", \"\") == \"\") {\n-            CService resolved;\n-            assert(LookupNumeric(\"127.0.0.1\", resolved, 9050));\n+            CService resolved(LookupNumeric(\"127.0.0.1\", 9050));\n             proxyType addrOnion = proxyType(resolved, true);\n             SetProxy(NET_TOR, addrOnion);\n             SetLimited(NET_TOR, false);"
      }
    ]
  },
  {
    "sha": "9e9d644f5178da8b5743ea3ddc3b779a2c8d1cd4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZTlkNjQ0ZjUxNzhkYThiNTc0M2VhM2RkYzNiNzc5YTJjOGQxY2Q0",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-08-12T18:21:50Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-08-12T18:22:49Z"
      },
      "message": "net: fixup nits",
      "tree": {
        "sha": "a13eb176cda47f65897fc8d0a4b6efc5e1ada66c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a13eb176cda47f65897fc8d0a4b6efc5e1ada66c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9e9d644f5178da8b5743ea3ddc3b779a2c8d1cd4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9e9d644f5178da8b5743ea3ddc3b779a2c8d1cd4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9e9d644f5178da8b5743ea3ddc3b779a2c8d1cd4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9e9d644f5178da8b5743ea3ddc3b779a2c8d1cd4/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8945384bca00f74ba85c98a52925c254c49025a5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8945384bca00f74ba85c98a52925c254c49025a5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8945384bca00f74ba85c98a52925c254c49025a5"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 2,
      "deletions": 2
    },
    "files": [
      {
        "sha": "03fac5bf979ac84da16de762cc9fc6dac52078fd",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e9d644f5178da8b5743ea3ddc3b779a2c8d1cd4/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e9d644f5178da8b5743ea3ddc3b779a2c8d1cd4/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=9e9d644f5178da8b5743ea3ddc3b779a2c8d1cd4",
        "patch": "@@ -105,8 +105,8 @@ BITCOIN_CORE_H = \\\n   merkleblock.h \\\n   miner.h \\\n   net.h \\\n-  netbase.h \\\n   netaddress.h \\\n+  netbase.h \\\n   noui.h \\\n   policy/fees.h \\\n   policy/policy.h \\"
      },
      {
        "sha": "f921305fcc36b824c9bda95ecd20165afecf6787",
        "filename": "src/httpserver.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e9d644f5178da8b5743ea3ddc3b779a2c8d1cd4/src/httpserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e9d644f5178da8b5743ea3ddc3b779a2c8d1cd4/src/httpserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.cpp?ref=9e9d644f5178da8b5743ea3ddc3b779a2c8d1cd4",
        "patch": "@@ -201,7 +201,7 @@ static bool InitHTTPAllowList()\n     CNetAddr localv6;\n     LookupHost(\"127.0.0.1\", localv4, false);\n     LookupHost(\"::1\", localv6, false);\n-    rpc_allow_subnets.push_back(CSubNet(localv4, 8)); // always allow IPv4 local subnet\n+    rpc_allow_subnets.push_back(CSubNet(localv4, 8));      // always allow IPv4 local subnet\n     rpc_allow_subnets.push_back(CSubNet(localv6));         // always allow IPv6 localhost\n     if (mapMultiArgs.count(\"-rpcallowip\")) {\n         const std::vector<std::string>& vAllow = mapMultiArgs[\"-rpcallowip\"];"
      }
    ]
  }
]