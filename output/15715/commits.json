[
  {
    "sha": "621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MjFlYTJmMjdjNDRjOTkwM2VhMjFkNmM0NDJkMmY3YmJkY2FhNDVk",
    "commit": {
      "author": {
        "name": "Julian Fleischer",
        "email": "julian@thirdhash.com",
        "date": "2019-04-01T12:45:38Z"
      },
      "committer": {
        "name": "Julian Fleischer",
        "email": "julian@thirdhash.com",
        "date": "2019-04-01T13:03:22Z"
      },
      "message": "Replace curly braces with digraphs",
      "tree": {
        "sha": "19932473495b9959ce914d220b4a35b0b6511378",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/19932473495b9959ce914d220b4a35b0b6511378"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/comments",
    "author": {
      "login": "scravy",
      "id": 295504,
      "node_id": "MDQ6VXNlcjI5NTUwNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/295504?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/scravy",
      "html_url": "https://github.com/scravy",
      "followers_url": "https://api.github.com/users/scravy/followers",
      "following_url": "https://api.github.com/users/scravy/following{/other_user}",
      "gists_url": "https://api.github.com/users/scravy/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/scravy/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/scravy/subscriptions",
      "organizations_url": "https://api.github.com/users/scravy/orgs",
      "repos_url": "https://api.github.com/users/scravy/repos",
      "events_url": "https://api.github.com/users/scravy/events{/privacy}",
      "received_events_url": "https://api.github.com/users/scravy/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "scravy",
      "id": 295504,
      "node_id": "MDQ6VXNlcjI5NTUwNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/295504?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/scravy",
      "html_url": "https://github.com/scravy",
      "followers_url": "https://api.github.com/users/scravy/followers",
      "following_url": "https://api.github.com/users/scravy/following{/other_user}",
      "gists_url": "https://api.github.com/users/scravy/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/scravy/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/scravy/subscriptions",
      "organizations_url": "https://api.github.com/users/scravy/orgs",
      "repos_url": "https://api.github.com/users/scravy/repos",
      "events_url": "https://api.github.com/users/scravy/events{/privacy}",
      "received_events_url": "https://api.github.com/users/scravy/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "79c345a0114c9a83fd40e01150519373c017b130",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/79c345a0114c9a83fd40e01150519373c017b130",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/79c345a0114c9a83fd40e01150519373c017b130"
      }
    ],
    "stats": {
      "total": 63840,
      "additions": 31920,
      "deletions": 31920
    },
    "files": [
      {
        "sha": "de5e085a6a93b4dfde5b33f94d0a8af1c5e70083",
        "filename": "src/addrdb.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 37,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/addrdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/addrdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -14,27 +14,27 @@\n #include <tinyformat.h>\n #include <util/system.h>\n \n-namespace {\n+namespace <%\n \n template <typename Stream, typename Data>\n bool SerializeDB(Stream& stream, const Data& data)\n-{\n+<%\n     // Write and commit header, data\n-    try {\n+    try <%\n         CHashWriter hasher(SER_DISK, CLIENT_VERSION);\n         stream << Params().MessageStart() << data;\n         hasher << Params().MessageStart() << data;\n         stream << hasher.GetHash();\n-    } catch (const std::exception& e) {\n+    %> catch (const std::exception& e) <%\n         return error(\"%s: Serialize or I/O error - %s\", __func__, e.what());\n-    }\n+    %>\n \n     return true;\n-}\n+%>\n \n template <typename Data>\n bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)\n-{\n+<%\n     // Generate random temporary filename\n     unsigned short randv = 0;\n     GetRandBytes((unsigned char*)&randv, sizeof(randv));\n@@ -58,12 +58,12 @@ bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data\n         return error(\"%s: Rename-into-place failed\", __func__);\n \n     return true;\n-}\n+%>\n \n template <typename Stream, typename Data>\n bool DeserializeDB(Stream& stream, Data& data, bool fCheckSum = true)\n-{\n-    try {\n+<%\n+    try <%\n         CHashVerifier<Stream> verifier(&stream);\n         // de-serialize file header (network specific magic number) and ..\n         unsigned char pchMsgTmp[4];\n@@ -76,70 +76,70 @@ bool DeserializeDB(Stream& stream, Data& data, bool fCheckSum = true)\n         verifier >> data;\n \n         // verify checksum\n-        if (fCheckSum) {\n+        if (fCheckSum) <%\n             uint256 hashTmp;\n             stream >> hashTmp;\n-            if (hashTmp != verifier.GetHash()) {\n+            if (hashTmp != verifier.GetHash()) <%\n                 return error(\"%s: Checksum mismatch, data corrupted\", __func__);\n-            }\n-        }\n-    }\n-    catch (const std::exception& e) {\n+            %>\n+        %>\n+    %>\n+    catch (const std::exception& e) <%\n         return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n-    }\n+    %>\n \n     return true;\n-}\n+%>\n \n template <typename Data>\n bool DeserializeFileDB(const fs::path& path, Data& data)\n-{\n+<%\n     // open input file, and associate with CAutoFile\n     FILE *file = fsbridge::fopen(path, \"rb\");\n     CAutoFile filein(file, SER_DISK, CLIENT_VERSION);\n     if (filein.IsNull())\n         return error(\"%s: Failed to open file %s\", __func__, path.string());\n \n     return DeserializeDB(filein, data);\n-}\n+%>\n \n-}\n+%>\n \n CBanDB::CBanDB(fs::path ban_list_path) : m_ban_list_path(std::move(ban_list_path))\n-{\n-}\n+<%\n+%>\n \n bool CBanDB::Write(const banmap_t& banSet)\n-{\n+<%\n     return SerializeFileDB(\"banlist\", m_ban_list_path, banSet);\n-}\n+%>\n \n bool CBanDB::Read(banmap_t& banSet)\n-{\n+<%\n     return DeserializeFileDB(m_ban_list_path, banSet);\n-}\n+%>\n \n CAddrDB::CAddrDB()\n-{\n+<%\n     pathAddr = GetDataDir() / \"peers.dat\";\n-}\n+%>\n \n bool CAddrDB::Write(const CAddrMan& addr)\n-{\n+<%\n     return SerializeFileDB(\"peers\", pathAddr, addr);\n-}\n+%>\n \n bool CAddrDB::Read(CAddrMan& addr)\n-{\n+<%\n     return DeserializeFileDB(pathAddr, addr);\n-}\n+%>\n \n bool CAddrDB::Read(CAddrMan& addr, CDataStream& ssPeers)\n-{\n+<%\n     bool ret = DeserializeDB(ssPeers, addr, false);\n-    if (!ret) {\n+    if (!ret) <%\n         // Ensure addrman is left in a clean state\n         addr.Clear();\n-    }\n+    %>\n     return ret;\n-}\n+%>"
      },
      {
        "sha": "2b9a7c43fc361ca23f82771d6be4abad142b1d48",
        "filename": "src/addrdb.h",
        "status": "modified",
        "additions": 22,
        "deletions": 22,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/addrdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/addrdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -17,14 +17,14 @@ class CAddrMan;\n class CDataStream;\n \n typedef enum BanReason\n-{\n+<%\n     BanReasonUnknown          = 0,\n     BanReasonNodeMisbehaving  = 1,\n     BanReasonManuallyAdded    = 2\n-} BanReason;\n+%> BanReason;\n \n class CBanEntry\n-{\n+<%\n public:\n     static const int CURRENT_VERSION=1;\n     int nVersion;\n@@ -33,75 +33,75 @@ class CBanEntry\n     uint8_t banReason;\n \n     CBanEntry()\n-    {\n+    <%\n         SetNull();\n-    }\n+    %>\n \n     explicit CBanEntry(int64_t nCreateTimeIn)\n-    {\n+    <%\n         SetNull();\n         nCreateTime = nCreateTimeIn;\n-    }\n+    %>\n \n     explicit CBanEntry(int64_t n_create_time_in, BanReason ban_reason_in) : CBanEntry(n_create_time_in)\n-    {\n+    <%\n         banReason = ban_reason_in;\n-    }\n+    %>\n \n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action) {\n+    inline void SerializationOp(Stream& s, Operation ser_action) <%\n         READWRITE(this->nVersion);\n         READWRITE(nCreateTime);\n         READWRITE(nBanUntil);\n         READWRITE(banReason);\n-    }\n+    %>\n \n     void SetNull()\n-    {\n+    <%\n         nVersion = CBanEntry::CURRENT_VERSION;\n         nCreateTime = 0;\n         nBanUntil = 0;\n         banReason = BanReasonUnknown;\n-    }\n+    %>\n \n     std::string banReasonToString() const\n-    {\n-        switch (banReason) {\n+    <%\n+        switch (banReason) <%\n         case BanReasonNodeMisbehaving:\n             return \"node misbehaving\";\n         case BanReasonManuallyAdded:\n             return \"manually added\";\n         default:\n             return \"unknown\";\n-        }\n-    }\n-};\n+        %>\n+    %>\n+%>;\n \n typedef std::map<CSubNet, CBanEntry> banmap_t;\n \n /** Access to the (IP) address database (peers.dat) */\n class CAddrDB\n-{\n+<%\n private:\n     fs::path pathAddr;\n public:\n     CAddrDB();\n     bool Write(const CAddrMan& addr);\n     bool Read(CAddrMan& addr);\n     static bool Read(CAddrMan& addr, CDataStream& ssPeers);\n-};\n+%>;\n \n /** Access to the banlist database (banlist.dat) */\n class CBanDB\n-{\n+<%\n private:\n     const fs::path m_ban_list_path;\n public:\n     explicit CBanDB(fs::path ban_list_path);\n     bool Write(const banmap_t& banSet);\n     bool Read(banmap_t& banSet);\n-};\n+%>;\n \n #endif // BITCOIN_ADDRDB_H"
      },
      {
        "sha": "71564fc77b6046d78e3221f763464f96599f8cbe",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 129,
        "deletions": 129,
        "changes": 258,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -10,28 +10,28 @@\n #include <streams.h>\n \n int CAddrInfo::GetTriedBucket(const uint256& nKey) const\n-{\n+<%\n     uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetKey()).GetCheapHash();\n     uint64_t hash2 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup() << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP)).GetCheapHash();\n     return hash2 % ADDRMAN_TRIED_BUCKET_COUNT;\n-}\n+%>\n \n int CAddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src) const\n-{\n+<%\n     std::vector<unsigned char> vchSourceGroupKey = src.GetGroup();\n     uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup() << vchSourceGroupKey).GetCheapHash();\n     uint64_t hash2 = (CHashWriter(SER_GETHASH, 0) << nKey << vchSourceGroupKey << (hash1 % ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP)).GetCheapHash();\n     return hash2 % ADDRMAN_NEW_BUCKET_COUNT;\n-}\n+%>\n \n int CAddrInfo::GetBucketPosition(const uint256 &nKey, bool fNew, int nBucket) const\n-{\n+<%\n     uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << (fNew ? 'N' : 'K') << nBucket << GetKey()).GetCheapHash();\n     return hash1 % ADDRMAN_BUCKET_SIZE;\n-}\n+%>\n \n bool CAddrInfo::IsTerrible(int64_t nNow) const\n-{\n+<%\n     if (nLastTry && nLastTry >= nNow - 60) // never remove things tried in the last minute\n         return false;\n \n@@ -48,10 +48,10 @@ bool CAddrInfo::IsTerrible(int64_t nNow) const\n         return true;\n \n     return false;\n-}\n+%>\n \n double CAddrInfo::GetChance(int64_t nNow) const\n-{\n+<%\n     double fChance = 1.0;\n     int64_t nSinceLastTry = std::max<int64_t>(nNow - nLastTry, 0);\n \n@@ -63,10 +63,10 @@ double CAddrInfo::GetChance(int64_t nNow) const\n     fChance *= pow(0.66, std::min(nAttempts, 8));\n \n     return fChance;\n-}\n+%>\n \n CAddrInfo* CAddrMan::Find(const CNetAddr& addr, int* pnId)\n-{\n+<%\n     std::map<CNetAddr, int>::iterator it = mapAddr.find(addr);\n     if (it == mapAddr.end())\n         return nullptr;\n@@ -76,10 +76,10 @@ CAddrInfo* CAddrMan::Find(const CNetAddr& addr, int* pnId)\n     if (it2 != mapInfo.end())\n         return &(*it2).second;\n     return nullptr;\n-}\n+%>\n \n CAddrInfo* CAddrMan::Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId)\n-{\n+<%\n     int nId = nIdCount++;\n     mapInfo[nId] = CAddrInfo(addr, addrSource);\n     mapAddr[addr] = nId;\n@@ -88,10 +88,10 @@ CAddrInfo* CAddrMan::Create(const CAddress& addr, const CNetAddr& addrSource, in\n     if (pnId)\n         *pnId = nId;\n     return &mapInfo[nId];\n-}\n+%>\n \n void CAddrMan::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2)\n-{\n+<%\n     if (nRndPos1 == nRndPos2)\n         return;\n \n@@ -108,10 +108,10 @@ void CAddrMan::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2)\n \n     vRandom[nRndPos1] = nId2;\n     vRandom[nRndPos2] = nId1;\n-}\n+%>\n \n void CAddrMan::Delete(int nId)\n-{\n+<%\n     assert(mapInfo.count(nId) != 0);\n     CAddrInfo& info = mapInfo[nId];\n     assert(!info.fInTried);\n@@ -122,33 +122,33 @@ void CAddrMan::Delete(int nId)\n     mapAddr.erase(info);\n     mapInfo.erase(nId);\n     nNew--;\n-}\n+%>\n \n void CAddrMan::ClearNew(int nUBucket, int nUBucketPos)\n-{\n+<%\n     // if there is an entry in the specified bucket, delete it.\n-    if (vvNew[nUBucket][nUBucketPos] != -1) {\n+    if (vvNew[nUBucket][nUBucketPos] != -1) <%\n         int nIdDelete = vvNew[nUBucket][nUBucketPos];\n         CAddrInfo& infoDelete = mapInfo[nIdDelete];\n         assert(infoDelete.nRefCount > 0);\n         infoDelete.nRefCount--;\n         vvNew[nUBucket][nUBucketPos] = -1;\n-        if (infoDelete.nRefCount == 0) {\n+        if (infoDelete.nRefCount == 0) <%\n             Delete(nIdDelete);\n-        }\n-    }\n-}\n+        %>\n+    %>\n+%>\n \n void CAddrMan::MakeTried(CAddrInfo& info, int nId)\n-{\n+<%\n     // remove the entry from all new buckets\n-    for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {\n+    for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) <%\n         int pos = info.GetBucketPosition(nKey, true, bucket);\n-        if (vvNew[bucket][pos] == nId) {\n+        if (vvNew[bucket][pos] == nId) <%\n             vvNew[bucket][pos] = -1;\n             info.nRefCount--;\n-        }\n-    }\n+        %>\n+    %>\n     nNew--;\n \n     assert(info.nRefCount == 0);\n@@ -158,7 +158,7 @@ void CAddrMan::MakeTried(CAddrInfo& info, int nId)\n     int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);\n \n     // first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).\n-    if (vvTried[nKBucket][nKBucketPos] != -1) {\n+    if (vvTried[nKBucket][nKBucketPos] != -1) <%\n         // find an item to evict\n         int nIdEvict = vvTried[nKBucket][nKBucketPos];\n         assert(mapInfo.count(nIdEvict) == 1);\n@@ -179,16 +179,16 @@ void CAddrMan::MakeTried(CAddrInfo& info, int nId)\n         infoOld.nRefCount = 1;\n         vvNew[nUBucket][nUBucketPos] = nIdEvict;\n         nNew++;\n-    }\n+    %>\n     assert(vvTried[nKBucket][nKBucketPos] == -1);\n \n     vvTried[nKBucket][nKBucketPos] = nId;\n     nTried++;\n     info.fInTried = true;\n-}\n+%>\n \n void CAddrMan::Good_(const CService& addr, bool test_before_evict, int64_t nTime)\n-{\n+<%\n     int nId;\n \n     nLastGood = nTime;\n@@ -219,14 +219,14 @@ void CAddrMan::Good_(const CService& addr, bool test_before_evict, int64_t nTime\n     // find a bucket it is in now\n     int nRnd = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n     int nUBucket = -1;\n-    for (unsigned int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {\n+    for (unsigned int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) <%\n         int nB = (n + nRnd) % ADDRMAN_NEW_BUCKET_COUNT;\n         int nBpos = info.GetBucketPosition(nKey, true, nB);\n-        if (vvNew[nB][nBpos] == nId) {\n+        if (vvNew[nB][nBpos] == nId) <%\n             nUBucket = nB;\n             break;\n-        }\n-    }\n+        %>\n+    %>\n \n     // if no bucket is found, something bad happened;\n     // TODO: maybe re-add the node, but for now, just bail out\n@@ -238,23 +238,23 @@ void CAddrMan::Good_(const CService& addr, bool test_before_evict, int64_t nTime\n     int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);\n \n     // Will moving this address into tried evict another entry?\n-    if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) {\n+    if (test_before_evict && (vvTried[tried_bucket][tried_bucket_pos] != -1)) <%\n         // Output the entry we'd be colliding with, for debugging purposes\n         auto colliding_entry = mapInfo.find(vvTried[tried_bucket][tried_bucket_pos]);\n         LogPrint(BCLog::ADDRMAN, \"Collision inserting element into tried table (%s), moving %s to m_tried_collisions=%d\\n\", colliding_entry != mapInfo.end() ? colliding_entry->second.ToString() : \"\", addr.ToString(), m_tried_collisions.size());\n-        if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) {\n+        if (m_tried_collisions.size() < ADDRMAN_SET_TRIED_COLLISION_SIZE) <%\n             m_tried_collisions.insert(nId);\n-        }\n-    } else {\n+        %>\n+    %> else <%\n         LogPrint(BCLog::ADDRMAN, \"Moving %s to tried\\n\", addr.ToString());\n \n         // move nId to the tried tables\n         MakeTried(info, nId);\n-    }\n-}\n+    %>\n+%>\n \n bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimePenalty)\n-{\n+<%\n     if (!addr.IsRoutable())\n         return false;\n \n@@ -263,11 +263,11 @@ bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimeP\n     CAddrInfo* pinfo = Find(addr, &nId);\n \n     // Do not set a penalty for a source's self-announcement\n-    if (addr == source) {\n+    if (addr == source) <%\n         nTimePenalty = 0;\n-    }\n+    %>\n \n-    if (pinfo) {\n+    if (pinfo) <%\n         // periodically update nTime\n         bool fCurrentlyOnline = (GetAdjustedTime() - addr.nTime < 24 * 60 * 60);\n         int64_t nUpdateInterval = (fCurrentlyOnline ? 60 * 60 : 24 * 60 * 60);\n@@ -295,39 +295,39 @@ bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimeP\n             nFactor *= 2;\n         if (nFactor > 1 && (insecure_rand.randrange(nFactor) != 0))\n             return false;\n-    } else {\n+    %> else <%\n         pinfo = Create(addr, source, &nId);\n         pinfo->nTime = std::max((int64_t)0, (int64_t)pinfo->nTime - nTimePenalty);\n         nNew++;\n         fNew = true;\n-    }\n+    %>\n \n     int nUBucket = pinfo->GetNewBucket(nKey, source);\n     int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);\n-    if (vvNew[nUBucket][nUBucketPos] != nId) {\n+    if (vvNew[nUBucket][nUBucketPos] != nId) <%\n         bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;\n-        if (!fInsert) {\n+        if (!fInsert) <%\n             CAddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];\n-            if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {\n+            if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) <%\n                 // Overwrite the existing new table entry.\n                 fInsert = true;\n-            }\n-        }\n-        if (fInsert) {\n+            %>\n+        %>\n+        if (fInsert) <%\n             ClearNew(nUBucket, nUBucketPos);\n             pinfo->nRefCount++;\n             vvNew[nUBucket][nUBucketPos] = nId;\n-        } else {\n-            if (pinfo->nRefCount == 0) {\n+        %> else <%\n+            if (pinfo->nRefCount == 0) <%\n                 Delete(nId);\n-            }\n-        }\n-    }\n+            %>\n+        %>\n+    %>\n     return fNew;\n-}\n+%>\n \n void CAddrMan::Attempt_(const CService& addr, bool fCountFailure, int64_t nTime)\n-{\n+<%\n     CAddrInfo* pinfo = Find(addr);\n \n     // if not found, bail out\n@@ -342,14 +342,14 @@ void CAddrMan::Attempt_(const CService& addr, bool fCountFailure, int64_t nTime)\n \n     // update info\n     info.nLastTry = nTime;\n-    if (fCountFailure && info.nLastCountAttempt < nLastGood) {\n+    if (fCountFailure && info.nLastCountAttempt < nLastGood) <%\n         info.nLastCountAttempt = nTime;\n         info.nAttempts++;\n-    }\n-}\n+    %>\n+%>\n \n CAddrInfo CAddrMan::Select_(bool newOnly)\n-{\n+<%\n     if (size() == 0)\n         return CAddrInfo();\n \n@@ -358,68 +358,68 @@ CAddrInfo CAddrMan::Select_(bool newOnly)\n \n     // Use a 50% chance for choosing between tried and new table entries.\n     if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n+       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) <%\n         // use a tried node\n         double fChanceFactor = 1.0;\n-        while (1) {\n+        while (1) <%\n             int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n             int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            while (vvTried[nKBucket][nKBucketPos] == -1) {\n+            while (vvTried[nKBucket][nKBucketPos] == -1) <%\n                 nKBucket = (nKBucket + insecure_rand.randbits(ADDRMAN_TRIED_BUCKET_COUNT_LOG2)) % ADDRMAN_TRIED_BUCKET_COUNT;\n                 nKBucketPos = (nKBucketPos + insecure_rand.randbits(ADDRMAN_BUCKET_SIZE_LOG2)) % ADDRMAN_BUCKET_SIZE;\n-            }\n+            %>\n             int nId = vvTried[nKBucket][nKBucketPos];\n             assert(mapInfo.count(nId) == 1);\n             CAddrInfo& info = mapInfo[nId];\n             if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30))\n                 return info;\n             fChanceFactor *= 1.2;\n-        }\n-    } else {\n+        %>\n+    %> else <%\n         // use a new node\n         double fChanceFactor = 1.0;\n-        while (1) {\n+        while (1) <%\n             int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n             int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            while (vvNew[nUBucket][nUBucketPos] == -1) {\n+            while (vvNew[nUBucket][nUBucketPos] == -1) <%\n                 nUBucket = (nUBucket + insecure_rand.randbits(ADDRMAN_NEW_BUCKET_COUNT_LOG2)) % ADDRMAN_NEW_BUCKET_COUNT;\n                 nUBucketPos = (nUBucketPos + insecure_rand.randbits(ADDRMAN_BUCKET_SIZE_LOG2)) % ADDRMAN_BUCKET_SIZE;\n-            }\n+            %>\n             int nId = vvNew[nUBucket][nUBucketPos];\n             assert(mapInfo.count(nId) == 1);\n             CAddrInfo& info = mapInfo[nId];\n             if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30))\n                 return info;\n             fChanceFactor *= 1.2;\n-        }\n-    }\n-}\n+        %>\n+    %>\n+%>\n \n #ifdef DEBUG_ADDRMAN\n int CAddrMan::Check_()\n-{\n+<%\n     std::set<int> setTried;\n     std::map<int, int> mapNew;\n \n     if (vRandom.size() != (size_t)(nTried + nNew))\n         return -7;\n \n-    for (const auto& entry : mapInfo) {\n+    for (const auto& entry : mapInfo) <%\n         int n = entry.first;\n         const CAddrInfo& info = entry.second;\n-        if (info.fInTried) {\n+        if (info.fInTried) <%\n             if (!info.nLastSuccess)\n                 return -1;\n             if (info.nRefCount)\n                 return -2;\n             setTried.insert(n);\n-        } else {\n+        %> else <%\n             if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)\n                 return -3;\n             if (!info.nRefCount)\n                 return -4;\n             mapNew[n] = info.nRefCount;\n-        }\n+        %>\n         if (mapAddr[info] != n)\n             return -5;\n         if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)\n@@ -428,39 +428,39 @@ int CAddrMan::Check_()\n             return -6;\n         if (info.nLastSuccess < 0)\n             return -8;\n-    }\n+    %>\n \n     if (setTried.size() != (size_t)nTried)\n         return -9;\n     if (mapNew.size() != (size_t)nNew)\n         return -10;\n \n-    for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {\n-        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n-             if (vvTried[n][i] != -1) {\n+    for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) <%\n+        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) <%\n+             if (vvTried[n][i] != -1) <%\n                  if (!setTried.count(vvTried[n][i]))\n                      return -11;\n                  if (mapInfo[vvTried[n][i]].GetTriedBucket(nKey) != n)\n                      return -17;\n                  if (mapInfo[vvTried[n][i]].GetBucketPosition(nKey, false, n) != i)\n                      return -18;\n                  setTried.erase(vvTried[n][i]);\n-             }\n-        }\n-    }\n+             %>\n+        %>\n+    %>\n \n-    for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {\n-        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n-            if (vvNew[n][i] != -1) {\n+    for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) <%\n+        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) <%\n+            if (vvNew[n][i] != -1) <%\n                 if (!mapNew.count(vvNew[n][i]))\n                     return -12;\n                 if (mapInfo[vvNew[n][i]].GetBucketPosition(nKey, true, n) != i)\n                     return -19;\n                 if (--mapNew[vvNew[n][i]] == 0)\n                     mapNew.erase(vvNew[n][i]);\n-            }\n-        }\n-    }\n+            %>\n+        %>\n+    %>\n \n     if (setTried.size())\n         return -13;\n@@ -470,17 +470,17 @@ int CAddrMan::Check_()\n         return -16;\n \n     return 0;\n-}\n+%>\n #endif\n \n void CAddrMan::GetAddr_(std::vector<CAddress>& vAddr)\n-{\n+<%\n     unsigned int nNodes = ADDRMAN_GETADDR_MAX_PCT * vRandom.size() / 100;\n     if (nNodes > ADDRMAN_GETADDR_MAX)\n         nNodes = ADDRMAN_GETADDR_MAX;\n \n     // gather a list of random nodes, skipping those of low quality\n-    for (unsigned int n = 0; n < vRandom.size(); n++) {\n+    for (unsigned int n = 0; n < vRandom.size(); n++) <%\n         if (vAddr.size() >= nNodes)\n             break;\n \n@@ -491,11 +491,11 @@ void CAddrMan::GetAddr_(std::vector<CAddress>& vAddr)\n         const CAddrInfo& ai = mapInfo[vRandom[n]];\n         if (!ai.IsTerrible())\n             vAddr.push_back(ai);\n-    }\n-}\n+    %>\n+%>\n \n void CAddrMan::Connected_(const CService& addr, int64_t nTime)\n-{\n+<%\n     CAddrInfo* pinfo = Find(addr);\n \n     // if not found, bail out\n@@ -512,10 +512,10 @@ void CAddrMan::Connected_(const CService& addr, int64_t nTime)\n     int64_t nUpdateInterval = 20 * 60;\n     if (nTime - info.nTime > nUpdateInterval)\n         info.nTime = nTime;\n-}\n+%>\n \n void CAddrMan::SetServices_(const CService& addr, ServiceFlags nServices)\n-{\n+<%\n     CAddrInfo* pinfo = Find(addr);\n \n     // if not found, bail out\n@@ -530,69 +530,69 @@ void CAddrMan::SetServices_(const CService& addr, ServiceFlags nServices)\n \n     // update info\n     info.nServices = nServices;\n-}\n+%>\n \n void CAddrMan::ResolveCollisions_()\n-{\n-    for (std::set<int>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) {\n+<%\n+    for (std::set<int>::iterator it = m_tried_collisions.begin(); it != m_tried_collisions.end();) <%\n         int id_new = *it;\n \n         bool erase_collision = false;\n \n         // If id_new not found in mapInfo remove it from m_tried_collisions\n-        if (mapInfo.count(id_new) != 1) {\n+        if (mapInfo.count(id_new) != 1) <%\n             erase_collision = true;\n-        } else {\n+        %> else <%\n             CAddrInfo& info_new = mapInfo[id_new];\n \n             // Which tried bucket to move the entry to.\n             int tried_bucket = info_new.GetTriedBucket(nKey);\n             int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);\n-            if (!info_new.IsValid()) { // id_new may no longer map to a valid address\n+            if (!info_new.IsValid()) <% // id_new may no longer map to a valid address\n                 erase_collision = true;\n-            } else if (vvTried[tried_bucket][tried_bucket_pos] != -1) { // The position in the tried bucket is not empty\n+            %> else if (vvTried[tried_bucket][tried_bucket_pos] != -1) <% // The position in the tried bucket is not empty\n \n                 // Get the to-be-evicted address that is being tested\n                 int id_old = vvTried[tried_bucket][tried_bucket_pos];\n                 CAddrInfo& info_old = mapInfo[id_old];\n \n                 // Has successfully connected in last X hours\n-                if (GetAdjustedTime() - info_old.nLastSuccess < ADDRMAN_REPLACEMENT_HOURS*(60*60)) {\n+                if (GetAdjustedTime() - info_old.nLastSuccess < ADDRMAN_REPLACEMENT_HOURS*(60*60)) <%\n                     erase_collision = true;\n-                } else if (GetAdjustedTime() - info_old.nLastTry < ADDRMAN_REPLACEMENT_HOURS*(60*60)) { // attempted to connect and failed in last X hours\n+                %> else if (GetAdjustedTime() - info_old.nLastTry < ADDRMAN_REPLACEMENT_HOURS*(60*60)) <% // attempted to connect and failed in last X hours\n \n                     // Give address at least 60 seconds to successfully connect\n-                    if (GetAdjustedTime() - info_old.nLastTry > 60) {\n+                    if (GetAdjustedTime() - info_old.nLastTry > 60) <%\n                         LogPrint(BCLog::ADDRMAN, \"Replacing %s with %s in tried table\\n\", info_old.ToString(), info_new.ToString());\n \n                         // Replaces an existing address already in the tried table with the new address\n                         Good_(info_new, false, GetAdjustedTime());\n                         erase_collision = true;\n-                    }\n-                } else if (GetAdjustedTime() - info_new.nLastSuccess > ADDRMAN_TEST_WINDOW) {\n+                    %>\n+                %> else if (GetAdjustedTime() - info_new.nLastSuccess > ADDRMAN_TEST_WINDOW) <%\n                     // If the collision hasn't resolved in some reasonable amount of time,\n                     // just evict the old entry -- we must not be able to\n                     // connect to it for some reason.\n                     LogPrint(BCLog::ADDRMAN, \"Unable to test; replacing %s with %s in tried table anyway\\n\", info_old.ToString(), info_new.ToString());\n                     Good_(info_new, false, GetAdjustedTime());\n                     erase_collision = true;\n-                }\n-            } else { // Collision is not actually a collision anymore\n+                %>\n+            %> else <% // Collision is not actually a collision anymore\n                 Good_(info_new, false, GetAdjustedTime());\n                 erase_collision = true;\n-            }\n-        }\n+            %>\n+        %>\n \n-        if (erase_collision) {\n+        if (erase_collision) <%\n             m_tried_collisions.erase(it++);\n-        } else {\n+        %> else <%\n             it++;\n-        }\n-    }\n-}\n+        %>\n+    %>\n+%>\n \n CAddrInfo CAddrMan::SelectTriedCollision_()\n-{\n+<%\n     if (m_tried_collisions.size() == 0) return CAddrInfo();\n \n     std::set<int>::iterator it = m_tried_collisions.begin();\n@@ -602,10 +602,10 @@ CAddrInfo CAddrMan::SelectTriedCollision_()\n     int id_new = *it;\n \n     // If id_new not found in mapInfo remove it from m_tried_collisions\n-    if (mapInfo.count(id_new) != 1) {\n+    if (mapInfo.count(id_new) != 1) <%\n         m_tried_collisions.erase(it);\n         return CAddrInfo();\n-    }\n+    %>\n \n     CAddrInfo& newInfo = mapInfo[id_new];\n \n@@ -616,4 +616,4 @@ CAddrInfo CAddrMan::SelectTriedCollision_()\n     int id_old = vvTried[tried_bucket][tried_bucket_pos];\n \n     return mapInfo[id_old];\n-}\n+%>"
      },
      {
        "sha": "f412d04d0ee104d9950e41cd15cdcfca2896a57d",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 121,
        "deletions": 121,
        "changes": 242,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -22,32 +22,32 @@\n  * Extended statistics about a CAddress\n  */\n class CAddrInfo : public CAddress\n-{\n+<%\n public:\n     //! last try whatsoever by us (memory only)\n-    int64_t nLastTry{0};\n+    int64_t nLastTry<%0%>;\n \n     //! last counted attempt (memory only)\n-    int64_t nLastCountAttempt{0};\n+    int64_t nLastCountAttempt<%0%>;\n \n private:\n     //! where knowledge about this address first came from\n     CNetAddr source;\n \n     //! last successful connection by us\n-    int64_t nLastSuccess{0};\n+    int64_t nLastSuccess<%0%>;\n \n     //! connection attempts since last successful attempt\n-    int nAttempts{0};\n+    int nAttempts<%0%>;\n \n     //! reference count in new sets (memory only)\n-    int nRefCount{0};\n+    int nRefCount<%0%>;\n \n     //! in tried set? (memory only)\n-    bool fInTried{false};\n+    bool fInTried<%false%>;\n \n     //! position in vRandom\n-    int nRandomPos{-1};\n+    int nRandomPos<%-1%>;\n \n     friend class CAddrMan;\n \n@@ -56,20 +56,20 @@ class CAddrInfo : public CAddress\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action) {\n+    inline void SerializationOp(Stream& s, Operation ser_action) <%\n         READWRITEAS(CAddress, *this);\n         READWRITE(source);\n         READWRITE(nLastSuccess);\n         READWRITE(nAttempts);\n-    }\n+    %>\n \n     CAddrInfo(const CAddress &addrIn, const CNetAddr &addrSource) : CAddress(addrIn), source(addrSource)\n-    {\n-    }\n+    <%\n+    %>\n \n     CAddrInfo() : CAddress(), source()\n-    {\n-    }\n+    <%\n+    %>\n \n     //! Calculate in which \"tried\" bucket this entry belongs\n     int GetTriedBucket(const uint256 &nKey) const;\n@@ -79,9 +79,9 @@ class CAddrInfo : public CAddress\n \n     //! Calculate in which \"new\" bucket this entry belongs, using its default source\n     int GetNewBucket(const uint256 &nKey) const\n-    {\n+    <%\n         return GetNewBucket(nKey, source);\n-    }\n+    %>\n \n     //! Calculate in which position of a bucket to store this entry.\n     int GetBucketPosition(const uint256 &nKey, bool fNew, int nBucket) const;\n@@ -91,7 +91,7 @@ class CAddrInfo : public CAddress\n \n     //! Calculate the relative chance this entry should be given when selecting nodes to connect to\n     double GetChance(int64_t nNow = GetAdjustedTime()) const;\n-};\n+%>;\n \n /** Stochastic address manager\n  *\n@@ -173,7 +173,7 @@ static const int64_t ADDRMAN_TEST_WINDOW = 40*60; // 40 minutes\n  * Stochastical (IP) address manager\n  */\n class CAddrMan\n-{\n+<%\n protected:\n     //! critical section to protect the inner data structures\n     mutable CCriticalSection cs;\n@@ -299,7 +299,7 @@ class CAddrMan\n      */\n     template<typename Stream>\n     void Serialize(Stream &s) const\n-    {\n+    <%\n         LOCK(cs);\n \n         unsigned char nVersion = 1;\n@@ -313,43 +313,43 @@ class CAddrMan\n         s << nUBuckets;\n         std::map<int, int> mapUnkIds;\n         int nIds = 0;\n-        for (const auto& entry : mapInfo) {\n+        for (const auto& entry : mapInfo) <%\n             mapUnkIds[entry.first] = nIds;\n             const CAddrInfo &info = entry.second;\n-            if (info.nRefCount) {\n+            if (info.nRefCount) <%\n                 assert(nIds != nNew); // this means nNew was wrong, oh ow\n                 s << info;\n                 nIds++;\n-            }\n-        }\n+            %>\n+        %>\n         nIds = 0;\n-        for (const auto& entry : mapInfo) {\n+        for (const auto& entry : mapInfo) <%\n             const CAddrInfo &info = entry.second;\n-            if (info.fInTried) {\n+            if (info.fInTried) <%\n                 assert(nIds != nTried); // this means nTried was wrong, oh ow\n                 s << info;\n                 nIds++;\n-            }\n-        }\n-        for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {\n+            %>\n+        %>\n+        for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) <%\n             int nSize = 0;\n-            for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n+            for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) <%\n                 if (vvNew[bucket][i] != -1)\n                     nSize++;\n-            }\n+            %>\n             s << nSize;\n-            for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n-                if (vvNew[bucket][i] != -1) {\n+            for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) <%\n+                if (vvNew[bucket][i] != -1) <%\n                     int nIndex = mapUnkIds[vvNew[bucket][i]];\n                     s << nIndex;\n-                }\n-            }\n-        }\n-    }\n+                %>\n+            %>\n+        %>\n+    %>\n \n     template<typename Stream>\n     void Unserialize(Stream& s)\n-    {\n+    <%\n         LOCK(cs);\n \n         Clear();\n@@ -364,263 +364,263 @@ class CAddrMan\n         s >> nTried;\n         int nUBuckets = 0;\n         s >> nUBuckets;\n-        if (nVersion != 0) {\n+        if (nVersion != 0) <%\n             nUBuckets ^= (1 << 30);\n-        }\n+        %>\n \n-        if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE) {\n+        if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE) <%\n             throw std::ios_base::failure(\"Corrupt CAddrMan serialization, nNew exceeds limit.\");\n-        }\n+        %>\n \n-        if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE) {\n+        if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE) <%\n             throw std::ios_base::failure(\"Corrupt CAddrMan serialization, nTried exceeds limit.\");\n-        }\n+        %>\n \n         // Deserialize entries from the new table.\n-        for (int n = 0; n < nNew; n++) {\n+        for (int n = 0; n < nNew; n++) <%\n             CAddrInfo &info = mapInfo[n];\n             s >> info;\n             mapAddr[info] = n;\n             info.nRandomPos = vRandom.size();\n             vRandom.push_back(n);\n-            if (nVersion != 1 || nUBuckets != ADDRMAN_NEW_BUCKET_COUNT) {\n+            if (nVersion != 1 || nUBuckets != ADDRMAN_NEW_BUCKET_COUNT) <%\n                 // In case the new table data cannot be used (nVersion unknown, or bucket count wrong),\n                 // immediately try to give them a reference based on their primary source address.\n                 int nUBucket = info.GetNewBucket(nKey);\n                 int nUBucketPos = info.GetBucketPosition(nKey, true, nUBucket);\n-                if (vvNew[nUBucket][nUBucketPos] == -1) {\n+                if (vvNew[nUBucket][nUBucketPos] == -1) <%\n                     vvNew[nUBucket][nUBucketPos] = n;\n                     info.nRefCount++;\n-                }\n-            }\n-        }\n+                %>\n+            %>\n+        %>\n         nIdCount = nNew;\n \n         // Deserialize entries from the tried table.\n         int nLost = 0;\n-        for (int n = 0; n < nTried; n++) {\n+        for (int n = 0; n < nTried; n++) <%\n             CAddrInfo info;\n             s >> info;\n             int nKBucket = info.GetTriedBucket(nKey);\n             int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);\n-            if (vvTried[nKBucket][nKBucketPos] == -1) {\n+            if (vvTried[nKBucket][nKBucketPos] == -1) <%\n                 info.nRandomPos = vRandom.size();\n                 info.fInTried = true;\n                 vRandom.push_back(nIdCount);\n                 mapInfo[nIdCount] = info;\n                 mapAddr[info] = nIdCount;\n                 vvTried[nKBucket][nKBucketPos] = nIdCount;\n                 nIdCount++;\n-            } else {\n+            %> else <%\n                 nLost++;\n-            }\n-        }\n+            %>\n+        %>\n         nTried -= nLost;\n \n         // Deserialize positions in the new table (if possible).\n-        for (int bucket = 0; bucket < nUBuckets; bucket++) {\n+        for (int bucket = 0; bucket < nUBuckets; bucket++) <%\n             int nSize = 0;\n             s >> nSize;\n-            for (int n = 0; n < nSize; n++) {\n+            for (int n = 0; n < nSize; n++) <%\n                 int nIndex = 0;\n                 s >> nIndex;\n-                if (nIndex >= 0 && nIndex < nNew) {\n+                if (nIndex >= 0 && nIndex < nNew) <%\n                     CAddrInfo &info = mapInfo[nIndex];\n                     int nUBucketPos = info.GetBucketPosition(nKey, true, bucket);\n-                    if (nVersion == 1 && nUBuckets == ADDRMAN_NEW_BUCKET_COUNT && vvNew[bucket][nUBucketPos] == -1 && info.nRefCount < ADDRMAN_NEW_BUCKETS_PER_ADDRESS) {\n+                    if (nVersion == 1 && nUBuckets == ADDRMAN_NEW_BUCKET_COUNT && vvNew[bucket][nUBucketPos] == -1 && info.nRefCount < ADDRMAN_NEW_BUCKETS_PER_ADDRESS) <%\n                         info.nRefCount++;\n                         vvNew[bucket][nUBucketPos] = nIndex;\n-                    }\n-                }\n-            }\n-        }\n+                    %>\n+                %>\n+            %>\n+        %>\n \n         // Prune new entries with refcount 0 (as a result of collisions).\n         int nLostUnk = 0;\n-        for (std::map<int, CAddrInfo>::const_iterator it = mapInfo.begin(); it != mapInfo.end(); ) {\n-            if (it->second.fInTried == false && it->second.nRefCount == 0) {\n+        for (std::map<int, CAddrInfo>::const_iterator it = mapInfo.begin(); it != mapInfo.end(); ) <%\n+            if (it->second.fInTried == false && it->second.nRefCount == 0) <%\n                 std::map<int, CAddrInfo>::const_iterator itCopy = it++;\n                 Delete(itCopy->first);\n                 nLostUnk++;\n-            } else {\n+            %> else <%\n                 it++;\n-            }\n-        }\n-        if (nLost + nLostUnk > 0) {\n+            %>\n+        %>\n+        if (nLost + nLostUnk > 0) <%\n             LogPrint(BCLog::ADDRMAN, \"addrman lost %i new and %i tried addresses due to collisions\\n\", nLostUnk, nLost);\n-        }\n+        %>\n \n         Check();\n-    }\n+    %>\n \n     void Clear()\n-    {\n+    <%\n         LOCK(cs);\n         std::vector<int>().swap(vRandom);\n         nKey = insecure_rand.rand256();\n-        for (size_t bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {\n-            for (size_t entry = 0; entry < ADDRMAN_BUCKET_SIZE; entry++) {\n+        for (size_t bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) <%\n+            for (size_t entry = 0; entry < ADDRMAN_BUCKET_SIZE; entry++) <%\n                 vvNew[bucket][entry] = -1;\n-            }\n-        }\n-        for (size_t bucket = 0; bucket < ADDRMAN_TRIED_BUCKET_COUNT; bucket++) {\n-            for (size_t entry = 0; entry < ADDRMAN_BUCKET_SIZE; entry++) {\n+            %>\n+        %>\n+        for (size_t bucket = 0; bucket < ADDRMAN_TRIED_BUCKET_COUNT; bucket++) <%\n+            for (size_t entry = 0; entry < ADDRMAN_BUCKET_SIZE; entry++) <%\n                 vvTried[bucket][entry] = -1;\n-            }\n-        }\n+            %>\n+        %>\n \n         nIdCount = 0;\n         nTried = 0;\n         nNew = 0;\n         nLastGood = 1; //Initially at 1 so that \"never\" is strictly worse.\n         mapInfo.clear();\n         mapAddr.clear();\n-    }\n+    %>\n \n     CAddrMan()\n-    {\n+    <%\n         Clear();\n-    }\n+    %>\n \n     ~CAddrMan()\n-    {\n+    <%\n         nKey.SetNull();\n-    }\n+    %>\n \n     //! Return the number of (unique) addresses in all tables.\n     size_t size() const\n-    {\n+    <%\n         LOCK(cs); // TODO: Cache this in an atomic to avoid this overhead\n         return vRandom.size();\n-    }\n+    %>\n \n     //! Consistency check\n     void Check()\n-    {\n+    <%\n #ifdef DEBUG_ADDRMAN\n-        {\n+        <%\n             LOCK(cs);\n             int err;\n             if ((err=Check_()))\n                 LogPrintf(\"ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\\n\", err);\n-        }\n+        %>\n #endif\n-    }\n+    %>\n \n     //! Add a single address.\n     bool Add(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty = 0)\n-    {\n+    <%\n         LOCK(cs);\n         bool fRet = false;\n         Check();\n         fRet |= Add_(addr, source, nTimePenalty);\n         Check();\n-        if (fRet) {\n+        if (fRet) <%\n             LogPrint(BCLog::ADDRMAN, \"Added %s from %s: %i tried, %i new\\n\", addr.ToStringIPPort(), source.ToString(), nTried, nNew);\n-        }\n+        %>\n         return fRet;\n-    }\n+    %>\n \n     //! Add multiple addresses.\n     bool Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty = 0)\n-    {\n+    <%\n         LOCK(cs);\n         int nAdd = 0;\n         Check();\n         for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++)\n             nAdd += Add_(*it, source, nTimePenalty) ? 1 : 0;\n         Check();\n-        if (nAdd) {\n+        if (nAdd) <%\n             LogPrint(BCLog::ADDRMAN, \"Added %i addresses from %s: %i tried, %i new\\n\", nAdd, source.ToString(), nTried, nNew);\n-        }\n+        %>\n         return nAdd > 0;\n-    }\n+    %>\n \n     //! Mark an entry as accessible.\n     void Good(const CService &addr, bool test_before_evict = true, int64_t nTime = GetAdjustedTime())\n-    {\n+    <%\n         LOCK(cs);\n         Check();\n         Good_(addr, test_before_evict, nTime);\n         Check();\n-    }\n+    %>\n \n     //! Mark an entry as connection attempted to.\n     void Attempt(const CService &addr, bool fCountFailure, int64_t nTime = GetAdjustedTime())\n-    {\n+    <%\n         LOCK(cs);\n         Check();\n         Attempt_(addr, fCountFailure, nTime);\n         Check();\n-    }\n+    %>\n \n     //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n     void ResolveCollisions()\n-    {\n+    <%\n         LOCK(cs);\n         Check();\n         ResolveCollisions_();\n         Check();\n-    }\n+    %>\n \n     //! Randomly select an address in tried that another address is attempting to evict.\n     CAddrInfo SelectTriedCollision()\n-    {\n+    <%\n         CAddrInfo ret;\n-        {\n+        <%\n             LOCK(cs);\n             Check();\n             ret = SelectTriedCollision_();\n             Check();\n-        }\n+        %>\n         return ret;\n-    }\n+    %>\n \n     /**\n      * Choose an address to connect to.\n      */\n     CAddrInfo Select(bool newOnly = false)\n-    {\n+    <%\n         CAddrInfo addrRet;\n-        {\n+        <%\n             LOCK(cs);\n             Check();\n             addrRet = Select_(newOnly);\n             Check();\n-        }\n+        %>\n         return addrRet;\n-    }\n+    %>\n \n     //! Return a bunch of addresses, selected at random.\n     std::vector<CAddress> GetAddr()\n-    {\n+    <%\n         Check();\n         std::vector<CAddress> vAddr;\n-        {\n+        <%\n             LOCK(cs);\n             GetAddr_(vAddr);\n-        }\n+        %>\n         Check();\n         return vAddr;\n-    }\n+    %>\n \n     //! Mark an entry as currently-connected-to.\n     void Connected(const CService &addr, int64_t nTime = GetAdjustedTime())\n-    {\n+    <%\n         LOCK(cs);\n         Check();\n         Connected_(addr, nTime);\n         Check();\n-    }\n+    %>\n \n     void SetServices(const CService &addr, ServiceFlags nServices)\n-    {\n+    <%\n         LOCK(cs);\n         Check();\n         SetServices_(addr, nServices);\n         Check();\n-    }\n+    %>\n \n-};\n+%>;\n \n #endif // BITCOIN_ADDRMAN_H"
      },
      {
        "sha": "b1eac1ee84ef840e471c94d832e3de0b3dc75fa7",
        "filename": "src/amount.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/amount.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/amount.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/amount.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -23,6 +23,6 @@ static const CAmount COIN = 100000000;\n  * for the creation of coins out of thin air modification could lead to a fork.\n  * */\n static const CAmount MAX_MONEY = 21000000 * COIN;\n-inline bool MoneyRange(const CAmount& nValue) { return (nValue >= 0 && nValue <= MAX_MONEY); }\n+inline bool MoneyRange(const CAmount& nValue) <% return (nValue >= 0 && nValue <= MAX_MONEY); %>\n \n #endif //  BITCOIN_AMOUNT_H"
      },
      {
        "sha": "6bbc625b3d8c2d1288f0046c063648c4c44e94a1",
        "filename": "src/arith_uint256.cpp",
        "status": "modified",
        "additions": 70,
        "deletions": 70,
        "changes": 140,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/arith_uint256.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/arith_uint256.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/arith_uint256.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -14,77 +14,77 @@\n \n template <unsigned int BITS>\n base_uint<BITS>::base_uint(const std::string& str)\n-{\n+<%\n     static_assert(BITS/32 > 0 && BITS%32 == 0, \"Template parameter BITS must be a positive multiple of 32.\");\n \n     SetHex(str);\n-}\n+%>\n \n template <unsigned int BITS>\n base_uint<BITS>& base_uint<BITS>::operator<<=(unsigned int shift)\n-{\n+<%\n     base_uint<BITS> a(*this);\n     for (int i = 0; i < WIDTH; i++)\n         pn[i] = 0;\n     int k = shift / 32;\n     shift = shift % 32;\n-    for (int i = 0; i < WIDTH; i++) {\n+    for (int i = 0; i < WIDTH; i++) <%\n         if (i + k + 1 < WIDTH && shift != 0)\n             pn[i + k + 1] |= (a.pn[i] >> (32 - shift));\n         if (i + k < WIDTH)\n             pn[i + k] |= (a.pn[i] << shift);\n-    }\n+    %>\n     return *this;\n-}\n+%>\n \n template <unsigned int BITS>\n base_uint<BITS>& base_uint<BITS>::operator>>=(unsigned int shift)\n-{\n+<%\n     base_uint<BITS> a(*this);\n     for (int i = 0; i < WIDTH; i++)\n         pn[i] = 0;\n     int k = shift / 32;\n     shift = shift % 32;\n-    for (int i = 0; i < WIDTH; i++) {\n+    for (int i = 0; i < WIDTH; i++) <%\n         if (i - k - 1 >= 0 && shift != 0)\n             pn[i - k - 1] |= (a.pn[i] << (32 - shift));\n         if (i - k >= 0)\n             pn[i - k] |= (a.pn[i] >> shift);\n-    }\n+    %>\n     return *this;\n-}\n+%>\n \n template <unsigned int BITS>\n base_uint<BITS>& base_uint<BITS>::operator*=(uint32_t b32)\n-{\n+<%\n     uint64_t carry = 0;\n-    for (int i = 0; i < WIDTH; i++) {\n+    for (int i = 0; i < WIDTH; i++) <%\n         uint64_t n = carry + (uint64_t)b32 * pn[i];\n         pn[i] = n & 0xffffffff;\n         carry = n >> 32;\n-    }\n+    %>\n     return *this;\n-}\n+%>\n \n template <unsigned int BITS>\n base_uint<BITS>& base_uint<BITS>::operator*=(const base_uint& b)\n-{\n+<%\n     base_uint<BITS> a;\n-    for (int j = 0; j < WIDTH; j++) {\n+    for (int j = 0; j < WIDTH; j++) <%\n         uint64_t carry = 0;\n-        for (int i = 0; i + j < WIDTH; i++) {\n+        for (int i = 0; i + j < WIDTH; i++) <%\n             uint64_t n = carry + a.pn[i + j] + (uint64_t)pn[j] * b.pn[i];\n             a.pn[i + j] = n & 0xffffffff;\n             carry = n >> 32;\n-        }\n-    }\n+        %>\n+    %>\n     *this = a;\n     return *this;\n-}\n+%>\n \n template <unsigned int BITS>\n base_uint<BITS>& base_uint<BITS>::operator/=(const base_uint& b)\n-{\n+<%\n     base_uint<BITS> div = b;     // make a copy, so we can shift.\n     base_uint<BITS> num = *this; // make a copy, so we can subtract.\n     *this = 0;                   // the quotient.\n@@ -96,94 +96,94 @@ base_uint<BITS>& base_uint<BITS>::operator/=(const base_uint& b)\n         return *this;\n     int shift = num_bits - div_bits;\n     div <<= shift; // shift so that div and num align.\n-    while (shift >= 0) {\n-        if (num >= div) {\n+    while (shift >= 0) <%\n+        if (num >= div) <%\n             num -= div;\n             pn[shift / 32] |= (1 << (shift & 31)); // set a bit of the result.\n-        }\n+        %>\n         div >>= 1; // shift back.\n         shift--;\n-    }\n+    %>\n     // num now contains the remainder of the division.\n     return *this;\n-}\n+%>\n \n template <unsigned int BITS>\n int base_uint<BITS>::CompareTo(const base_uint<BITS>& b) const\n-{\n-    for (int i = WIDTH - 1; i >= 0; i--) {\n+<%\n+    for (int i = WIDTH - 1; i >= 0; i--) <%\n         if (pn[i] < b.pn[i])\n             return -1;\n         if (pn[i] > b.pn[i])\n             return 1;\n-    }\n+    %>\n     return 0;\n-}\n+%>\n \n template <unsigned int BITS>\n bool base_uint<BITS>::EqualTo(uint64_t b) const\n-{\n-    for (int i = WIDTH - 1; i >= 2; i--) {\n+<%\n+    for (int i = WIDTH - 1; i >= 2; i--) <%\n         if (pn[i])\n             return false;\n-    }\n+    %>\n     if (pn[1] != (b >> 32))\n         return false;\n     if (pn[0] != (b & 0xfffffffful))\n         return false;\n     return true;\n-}\n+%>\n \n template <unsigned int BITS>\n double base_uint<BITS>::getdouble() const\n-{\n+<%\n     double ret = 0.0;\n     double fact = 1.0;\n-    for (int i = 0; i < WIDTH; i++) {\n+    for (int i = 0; i < WIDTH; i++) <%\n         ret += fact * pn[i];\n         fact *= 4294967296.0;\n-    }\n+    %>\n     return ret;\n-}\n+%>\n \n template <unsigned int BITS>\n std::string base_uint<BITS>::GetHex() const\n-{\n+<%\n     return ArithToUint256(*this).GetHex();\n-}\n+%>\n \n template <unsigned int BITS>\n void base_uint<BITS>::SetHex(const char* psz)\n-{\n+<%\n     *this = UintToArith256(uint256S(psz));\n-}\n+%>\n \n template <unsigned int BITS>\n void base_uint<BITS>::SetHex(const std::string& str)\n-{\n+<%\n     SetHex(str.c_str());\n-}\n+%>\n \n template <unsigned int BITS>\n std::string base_uint<BITS>::ToString() const\n-{\n+<%\n     return (GetHex());\n-}\n+%>\n \n template <unsigned int BITS>\n unsigned int base_uint<BITS>::bits() const\n-{\n-    for (int pos = WIDTH - 1; pos >= 0; pos--) {\n-        if (pn[pos]) {\n-            for (int nbits = 31; nbits > 0; nbits--) {\n+<%\n+    for (int pos = WIDTH - 1; pos >= 0; pos--) <%\n+        if (pn[pos]) <%\n+            for (int nbits = 31; nbits > 0; nbits--) <%\n                 if (pn[pos] & 1U << nbits)\n                     return 32 * pos + nbits + 1;\n-            }\n+            %>\n             return 32 * pos + 1;\n-        }\n-    }\n+        %>\n+    %>\n     return 0;\n-}\n+%>\n \n // Explicit instantiations for base_uint<256>\n template base_uint<256>::base_uint(const std::string&);\n@@ -204,59 +204,59 @@ template unsigned int base_uint<256>::bits() const;\n // This implementation directly uses shifts instead of going\n // through an intermediate MPI representation.\n arith_uint256& arith_uint256::SetCompact(uint32_t nCompact, bool* pfNegative, bool* pfOverflow)\n-{\n+<%\n     int nSize = nCompact >> 24;\n     uint32_t nWord = nCompact & 0x007fffff;\n-    if (nSize <= 3) {\n+    if (nSize <= 3) <%\n         nWord >>= 8 * (3 - nSize);\n         *this = nWord;\n-    } else {\n+    %> else <%\n         *this = nWord;\n         *this <<= 8 * (nSize - 3);\n-    }\n+    %>\n     if (pfNegative)\n         *pfNegative = nWord != 0 && (nCompact & 0x00800000) != 0;\n     if (pfOverflow)\n         *pfOverflow = nWord != 0 && ((nSize > 34) ||\n                                      (nWord > 0xff && nSize > 33) ||\n                                      (nWord > 0xffff && nSize > 32));\n     return *this;\n-}\n+%>\n \n uint32_t arith_uint256::GetCompact(bool fNegative) const\n-{\n+<%\n     int nSize = (bits() + 7) / 8;\n     uint32_t nCompact = 0;\n-    if (nSize <= 3) {\n+    if (nSize <= 3) <%\n         nCompact = GetLow64() << 8 * (3 - nSize);\n-    } else {\n+    %> else <%\n         arith_uint256 bn = *this >> 8 * (nSize - 3);\n         nCompact = bn.GetLow64();\n-    }\n+    %>\n     // The 0x00800000 bit denotes the sign.\n     // Thus, if it is already set, divide the mantissa by 256 and increase the exponent.\n-    if (nCompact & 0x00800000) {\n+    if (nCompact & 0x00800000) <%\n         nCompact >>= 8;\n         nSize++;\n-    }\n+    %>\n     assert((nCompact & ~0x007fffff) == 0);\n     assert(nSize < 256);\n     nCompact |= nSize << 24;\n     nCompact |= (fNegative && (nCompact & 0x007fffff) ? 0x00800000 : 0);\n     return nCompact;\n-}\n+%>\n \n uint256 ArithToUint256(const arith_uint256 &a)\n-{\n+<%\n     uint256 b;\n     for(int x=0; x<a.WIDTH; ++x)\n         WriteLE32(b.begin() + x*4, a.pn[x]);\n     return b;\n-}\n+%>\n arith_uint256 UintToArith256(const uint256 &a)\n-{\n+<%\n     arith_uint256 b;\n     for(int x=0; x<b.WIDTH; ++x)\n         b.pn[x] = ReadLE32(a.begin() + x*4);\n     return b;\n-}\n+%>"
      },
      {
        "sha": "6dd3c9b7272f9c9676ad1053e1700d3f43bd201b",
        "filename": "src/arith_uint256.h",
        "status": "modified",
        "additions": 75,
        "deletions": 75,
        "changes": 150,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/arith_uint256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/arith_uint256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/arith_uint256.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -16,224 +16,224 @@\n \n class uint256;\n \n-class uint_error : public std::runtime_error {\n+class uint_error : public std::runtime_error <%\n public:\n-    explicit uint_error(const std::string& str) : std::runtime_error(str) {}\n-};\n+    explicit uint_error(const std::string& str) : std::runtime_error(str) <%%>\n+%>;\n \n /** Template base class for unsigned big integers. */\n template<unsigned int BITS>\n class base_uint\n-{\n+<%\n protected:\n     static constexpr int WIDTH = BITS / 32;\n     uint32_t pn[WIDTH];\n public:\n \n     base_uint()\n-    {\n+    <%\n         static_assert(BITS/32 > 0 && BITS%32 == 0, \"Template parameter BITS must be a positive multiple of 32.\");\n \n         for (int i = 0; i < WIDTH; i++)\n             pn[i] = 0;\n-    }\n+    %>\n \n     base_uint(const base_uint& b)\n-    {\n+    <%\n         static_assert(BITS/32 > 0 && BITS%32 == 0, \"Template parameter BITS must be a positive multiple of 32.\");\n \n         for (int i = 0; i < WIDTH; i++)\n             pn[i] = b.pn[i];\n-    }\n+    %>\n \n     base_uint& operator=(const base_uint& b)\n-    {\n+    <%\n         for (int i = 0; i < WIDTH; i++)\n             pn[i] = b.pn[i];\n         return *this;\n-    }\n+    %>\n \n     base_uint(uint64_t b)\n-    {\n+    <%\n         static_assert(BITS/32 > 0 && BITS%32 == 0, \"Template parameter BITS must be a positive multiple of 32.\");\n \n         pn[0] = (unsigned int)b;\n         pn[1] = (unsigned int)(b >> 32);\n         for (int i = 2; i < WIDTH; i++)\n             pn[i] = 0;\n-    }\n+    %>\n \n     explicit base_uint(const std::string& str);\n \n     const base_uint operator~() const\n-    {\n+    <%\n         base_uint ret;\n         for (int i = 0; i < WIDTH; i++)\n             ret.pn[i] = ~pn[i];\n         return ret;\n-    }\n+    %>\n \n     const base_uint operator-() const\n-    {\n+    <%\n         base_uint ret;\n         for (int i = 0; i < WIDTH; i++)\n             ret.pn[i] = ~pn[i];\n         ++ret;\n         return ret;\n-    }\n+    %>\n \n     double getdouble() const;\n \n     base_uint& operator=(uint64_t b)\n-    {\n+    <%\n         pn[0] = (unsigned int)b;\n         pn[1] = (unsigned int)(b >> 32);\n         for (int i = 2; i < WIDTH; i++)\n             pn[i] = 0;\n         return *this;\n-    }\n+    %>\n \n     base_uint& operator^=(const base_uint& b)\n-    {\n+    <%\n         for (int i = 0; i < WIDTH; i++)\n             pn[i] ^= b.pn[i];\n         return *this;\n-    }\n+    %>\n \n     base_uint& operator&=(const base_uint& b)\n-    {\n+    <%\n         for (int i = 0; i < WIDTH; i++)\n             pn[i] &= b.pn[i];\n         return *this;\n-    }\n+    %>\n \n     base_uint& operator|=(const base_uint& b)\n-    {\n+    <%\n         for (int i = 0; i < WIDTH; i++)\n             pn[i] |= b.pn[i];\n         return *this;\n-    }\n+    %>\n \n     base_uint& operator^=(uint64_t b)\n-    {\n+    <%\n         pn[0] ^= (unsigned int)b;\n         pn[1] ^= (unsigned int)(b >> 32);\n         return *this;\n-    }\n+    %>\n \n     base_uint& operator|=(uint64_t b)\n-    {\n+    <%\n         pn[0] |= (unsigned int)b;\n         pn[1] |= (unsigned int)(b >> 32);\n         return *this;\n-    }\n+    %>\n \n     base_uint& operator<<=(unsigned int shift);\n     base_uint& operator>>=(unsigned int shift);\n \n     base_uint& operator+=(const base_uint& b)\n-    {\n+    <%\n         uint64_t carry = 0;\n         for (int i = 0; i < WIDTH; i++)\n-        {\n+        <%\n             uint64_t n = carry + pn[i] + b.pn[i];\n             pn[i] = n & 0xffffffff;\n             carry = n >> 32;\n-        }\n+        %>\n         return *this;\n-    }\n+    %>\n \n     base_uint& operator-=(const base_uint& b)\n-    {\n+    <%\n         *this += -b;\n         return *this;\n-    }\n+    %>\n \n     base_uint& operator+=(uint64_t b64)\n-    {\n+    <%\n         base_uint b;\n         b = b64;\n         *this += b;\n         return *this;\n-    }\n+    %>\n \n     base_uint& operator-=(uint64_t b64)\n-    {\n+    <%\n         base_uint b;\n         b = b64;\n         *this += -b;\n         return *this;\n-    }\n+    %>\n \n     base_uint& operator*=(uint32_t b32);\n     base_uint& operator*=(const base_uint& b);\n     base_uint& operator/=(const base_uint& b);\n \n     base_uint& operator++()\n-    {\n+    <%\n         // prefix operator\n         int i = 0;\n         while (i < WIDTH && ++pn[i] == 0)\n             i++;\n         return *this;\n-    }\n+    %>\n \n     const base_uint operator++(int)\n-    {\n+    <%\n         // postfix operator\n         const base_uint ret = *this;\n         ++(*this);\n         return ret;\n-    }\n+    %>\n \n     base_uint& operator--()\n-    {\n+    <%\n         // prefix operator\n         int i = 0;\n         while (i < WIDTH && --pn[i] == std::numeric_limits<uint32_t>::max())\n             i++;\n         return *this;\n-    }\n+    %>\n \n     const base_uint operator--(int)\n-    {\n+    <%\n         // postfix operator\n         const base_uint ret = *this;\n         --(*this);\n         return ret;\n-    }\n+    %>\n \n     int CompareTo(const base_uint& b) const;\n     bool EqualTo(uint64_t b) const;\n \n-    friend inline const base_uint operator+(const base_uint& a, const base_uint& b) { return base_uint(a) += b; }\n-    friend inline const base_uint operator-(const base_uint& a, const base_uint& b) { return base_uint(a) -= b; }\n-    friend inline const base_uint operator*(const base_uint& a, const base_uint& b) { return base_uint(a) *= b; }\n-    friend inline const base_uint operator/(const base_uint& a, const base_uint& b) { return base_uint(a) /= b; }\n-    friend inline const base_uint operator|(const base_uint& a, const base_uint& b) { return base_uint(a) |= b; }\n-    friend inline const base_uint operator&(const base_uint& a, const base_uint& b) { return base_uint(a) &= b; }\n-    friend inline const base_uint operator^(const base_uint& a, const base_uint& b) { return base_uint(a) ^= b; }\n-    friend inline const base_uint operator>>(const base_uint& a, int shift) { return base_uint(a) >>= shift; }\n-    friend inline const base_uint operator<<(const base_uint& a, int shift) { return base_uint(a) <<= shift; }\n-    friend inline const base_uint operator*(const base_uint& a, uint32_t b) { return base_uint(a) *= b; }\n-    friend inline bool operator==(const base_uint& a, const base_uint& b) { return memcmp(a.pn, b.pn, sizeof(a.pn)) == 0; }\n-    friend inline bool operator!=(const base_uint& a, const base_uint& b) { return memcmp(a.pn, b.pn, sizeof(a.pn)) != 0; }\n-    friend inline bool operator>(const base_uint& a, const base_uint& b) { return a.CompareTo(b) > 0; }\n-    friend inline bool operator<(const base_uint& a, const base_uint& b) { return a.CompareTo(b) < 0; }\n-    friend inline bool operator>=(const base_uint& a, const base_uint& b) { return a.CompareTo(b) >= 0; }\n-    friend inline bool operator<=(const base_uint& a, const base_uint& b) { return a.CompareTo(b) <= 0; }\n-    friend inline bool operator==(const base_uint& a, uint64_t b) { return a.EqualTo(b); }\n-    friend inline bool operator!=(const base_uint& a, uint64_t b) { return !a.EqualTo(b); }\n+    friend inline const base_uint operator+(const base_uint& a, const base_uint& b) <% return base_uint(a) += b; %>\n+    friend inline const base_uint operator-(const base_uint& a, const base_uint& b) <% return base_uint(a) -= b; %>\n+    friend inline const base_uint operator*(const base_uint& a, const base_uint& b) <% return base_uint(a) *= b; %>\n+    friend inline const base_uint operator/(const base_uint& a, const base_uint& b) <% return base_uint(a) /= b; %>\n+    friend inline const base_uint operator|(const base_uint& a, const base_uint& b) <% return base_uint(a) |= b; %>\n+    friend inline const base_uint operator&(const base_uint& a, const base_uint& b) <% return base_uint(a) &= b; %>\n+    friend inline const base_uint operator^(const base_uint& a, const base_uint& b) <% return base_uint(a) ^= b; %>\n+    friend inline const base_uint operator>>(const base_uint& a, int shift) <% return base_uint(a) >>= shift; %>\n+    friend inline const base_uint operator<<(const base_uint& a, int shift) <% return base_uint(a) <<= shift; %>\n+    friend inline const base_uint operator*(const base_uint& a, uint32_t b) <% return base_uint(a) *= b; %>\n+    friend inline bool operator==(const base_uint& a, const base_uint& b) <% return memcmp(a.pn, b.pn, sizeof(a.pn)) == 0; %>\n+    friend inline bool operator!=(const base_uint& a, const base_uint& b) <% return memcmp(a.pn, b.pn, sizeof(a.pn)) != 0; %>\n+    friend inline bool operator>(const base_uint& a, const base_uint& b) <% return a.CompareTo(b) > 0; %>\n+    friend inline bool operator<(const base_uint& a, const base_uint& b) <% return a.CompareTo(b) < 0; %>\n+    friend inline bool operator>=(const base_uint& a, const base_uint& b) <% return a.CompareTo(b) >= 0; %>\n+    friend inline bool operator<=(const base_uint& a, const base_uint& b) <% return a.CompareTo(b) <= 0; %>\n+    friend inline bool operator==(const base_uint& a, uint64_t b) <% return a.EqualTo(b); %>\n+    friend inline bool operator!=(const base_uint& a, uint64_t b) <% return !a.EqualTo(b); %>\n \n     std::string GetHex() const;\n     void SetHex(const char* psz);\n     void SetHex(const std::string& str);\n     std::string ToString() const;\n \n     unsigned int size() const\n-    {\n+    <%\n         return sizeof(pn);\n-    }\n+    %>\n \n     /**\n      * Returns the position of the highest bit set plus one, or zero if the\n@@ -242,19 +242,19 @@ class base_uint\n     unsigned int bits() const;\n \n     uint64_t GetLow64() const\n-    {\n+    <%\n         static_assert(WIDTH >= 2, \"Assertion WIDTH >= 2 failed (WIDTH = BITS / 32). BITS is a template parameter.\");\n         return pn[0] | (uint64_t)pn[1] << 32;\n-    }\n-};\n+    %>\n+%>;\n \n /** 256-bit unsigned big integer. */\n-class arith_uint256 : public base_uint<256> {\n+class arith_uint256 : public base_uint<256> <%\n public:\n-    arith_uint256() {}\n-    arith_uint256(const base_uint<256>& b) : base_uint<256>(b) {}\n-    arith_uint256(uint64_t b) : base_uint<256>(b) {}\n-    explicit arith_uint256(const std::string& str) : base_uint<256>(str) {}\n+    arith_uint256() <%%>\n+    arith_uint256(const base_uint<256>& b) : base_uint<256>(b) <%%>\n+    arith_uint256(uint64_t b) : base_uint<256>(b) <%%>\n+    explicit arith_uint256(const std::string& str) : base_uint<256>(str) <%%>\n \n     /**\n      * The \"compact\" format is a representation of a whole\n@@ -281,7 +281,7 @@ class arith_uint256 : public base_uint<256> {\n \n     friend uint256 ArithToUint256(const arith_uint256 &);\n     friend arith_uint256 UintToArith256(const uint256 &);\n-};\n+%>;\n \n uint256 ArithToUint256(const arith_uint256 &);\n arith_uint256 UintToArith256(const uint256 &);"
      },
      {
        "sha": "dc8553896aa0949a78112b7a64a3cdf6c4373016",
        "filename": "src/banman.cpp",
        "status": "modified",
        "additions": 67,
        "deletions": 67,
        "changes": 134,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/banman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/banman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/banman.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -13,33 +13,33 @@\n \n BanMan::BanMan(fs::path ban_file, CClientUIInterface* client_interface, int64_t default_ban_time)\n     : m_client_interface(client_interface), m_ban_db(std::move(ban_file)), m_default_ban_time(default_ban_time)\n-{\n+<%\n     if (m_client_interface) m_client_interface->InitMessage(_(\"Loading banlist...\"));\n \n     int64_t n_start = GetTimeMillis();\n     m_is_dirty = false;\n     banmap_t banmap;\n-    if (m_ban_db.Read(banmap)) {\n+    if (m_ban_db.Read(banmap)) <%\n         SetBanned(banmap);        // thread save setter\n         SetBannedSetDirty(false); // no need to write down, just read data\n         SweepBanned();            // sweep out unused entries\n \n         LogPrint(BCLog::NET, \"Loaded %d banned node ips/subnets from banlist.dat  %dms\\n\",\n             banmap.size(), GetTimeMillis() - n_start);\n-    } else {\n+    %> else <%\n         LogPrintf(\"Invalid or missing banlist.dat; recreating\\n\");\n         SetBannedSetDirty(true); // force write\n         DumpBanlist();\n-    }\n-}\n+    %>\n+%>\n \n BanMan::~BanMan()\n-{\n+<%\n     DumpBanlist();\n-}\n+%>\n \n void BanMan::DumpBanlist()\n-{\n+<%\n     SweepBanned(); // clean unused entries (if bantime has expired)\n \n     if (!BannedSetIsDirty()) return;\n@@ -48,173 +48,173 @@ void BanMan::DumpBanlist()\n \n     banmap_t banmap;\n     GetBanned(banmap);\n-    if (m_ban_db.Write(banmap)) {\n+    if (m_ban_db.Write(banmap)) <%\n         SetBannedSetDirty(false);\n-    }\n+    %>\n \n     LogPrint(BCLog::NET, \"Flushed %d banned node ips/subnets to banlist.dat  %dms\\n\",\n         banmap.size(), GetTimeMillis() - n_start);\n-}\n+%>\n \n void BanMan::ClearBanned()\n-{\n-    {\n+<%\n+    <%\n         LOCK(m_cs_banned);\n         m_banned.clear();\n         m_is_dirty = true;\n-    }\n+    %>\n     DumpBanlist(); //store banlist to disk\n     if (m_client_interface) m_client_interface->BannedListChanged();\n-}\n+%>\n \n int BanMan::IsBannedLevel(CNetAddr net_addr)\n-{\n+<%\n     // Returns the most severe level of banning that applies to this address.\n     // 0 - Not banned\n     // 1 - Automatic misbehavior ban\n     // 2 - Any other ban\n     int level = 0;\n     auto current_time = GetTime();\n     LOCK(m_cs_banned);\n-    for (const auto& it : m_banned) {\n+    for (const auto& it : m_banned) <%\n         CSubNet sub_net = it.first;\n         CBanEntry ban_entry = it.second;\n \n-        if (current_time < ban_entry.nBanUntil && sub_net.Match(net_addr)) {\n+        if (current_time < ban_entry.nBanUntil && sub_net.Match(net_addr)) <%\n             if (ban_entry.banReason != BanReasonNodeMisbehaving) return 2;\n             level = 1;\n-        }\n-    }\n+        %>\n+    %>\n     return level;\n-}\n+%>\n \n bool BanMan::IsBanned(CNetAddr net_addr)\n-{\n+<%\n     auto current_time = GetTime();\n     LOCK(m_cs_banned);\n-    for (const auto& it : m_banned) {\n+    for (const auto& it : m_banned) <%\n         CSubNet sub_net = it.first;\n         CBanEntry ban_entry = it.second;\n \n-        if (current_time < ban_entry.nBanUntil && sub_net.Match(net_addr)) {\n+        if (current_time < ban_entry.nBanUntil && sub_net.Match(net_addr)) <%\n             return true;\n-        }\n-    }\n+        %>\n+    %>\n     return false;\n-}\n+%>\n \n bool BanMan::IsBanned(CSubNet sub_net)\n-{\n+<%\n     auto current_time = GetTime();\n     LOCK(m_cs_banned);\n     banmap_t::iterator i = m_banned.find(sub_net);\n-    if (i != m_banned.end()) {\n+    if (i != m_banned.end()) <%\n         CBanEntry ban_entry = (*i).second;\n-        if (current_time < ban_entry.nBanUntil) {\n+        if (current_time < ban_entry.nBanUntil) <%\n             return true;\n-        }\n-    }\n+        %>\n+    %>\n     return false;\n-}\n+%>\n \n void BanMan::Ban(const CNetAddr& net_addr, const BanReason& ban_reason, int64_t ban_time_offset, bool since_unix_epoch)\n-{\n+<%\n     CSubNet sub_net(net_addr);\n     Ban(sub_net, ban_reason, ban_time_offset, since_unix_epoch);\n-}\n+%>\n \n void BanMan::Ban(const CSubNet& sub_net, const BanReason& ban_reason, int64_t ban_time_offset, bool since_unix_epoch)\n-{\n+<%\n     CBanEntry ban_entry(GetTime(), ban_reason);\n \n     int64_t normalized_ban_time_offset = ban_time_offset;\n     bool normalized_since_unix_epoch = since_unix_epoch;\n-    if (ban_time_offset <= 0) {\n+    if (ban_time_offset <= 0) <%\n         normalized_ban_time_offset = m_default_ban_time;\n         normalized_since_unix_epoch = false;\n-    }\n+    %>\n     ban_entry.nBanUntil = (normalized_since_unix_epoch ? 0 : GetTime()) + normalized_ban_time_offset;\n \n-    {\n+    <%\n         LOCK(m_cs_banned);\n-        if (m_banned[sub_net].nBanUntil < ban_entry.nBanUntil) {\n+        if (m_banned[sub_net].nBanUntil < ban_entry.nBanUntil) <%\n             m_banned[sub_net] = ban_entry;\n             m_is_dirty = true;\n-        } else\n+        %> else\n             return;\n-    }\n+    %>\n     if (m_client_interface) m_client_interface->BannedListChanged();\n \n     //store banlist to disk immediately if user requested ban\n     if (ban_reason == BanReasonManuallyAdded) DumpBanlist();\n-}\n+%>\n \n bool BanMan::Unban(const CNetAddr& net_addr)\n-{\n+<%\n     CSubNet sub_net(net_addr);\n     return Unban(sub_net);\n-}\n+%>\n \n bool BanMan::Unban(const CSubNet& sub_net)\n-{\n-    {\n+<%\n+    <%\n         LOCK(m_cs_banned);\n         if (m_banned.erase(sub_net) == 0) return false;\n         m_is_dirty = true;\n-    }\n+    %>\n     if (m_client_interface) m_client_interface->BannedListChanged();\n     DumpBanlist(); //store banlist to disk immediately\n     return true;\n-}\n+%>\n \n void BanMan::GetBanned(banmap_t& banmap)\n-{\n+<%\n     LOCK(m_cs_banned);\n     // Sweep the banlist so expired bans are not returned\n     SweepBanned();\n     banmap = m_banned; //create a thread safe copy\n-}\n+%>\n \n void BanMan::SetBanned(const banmap_t& banmap)\n-{\n+<%\n     LOCK(m_cs_banned);\n     m_banned = banmap;\n     m_is_dirty = true;\n-}\n+%>\n \n void BanMan::SweepBanned()\n-{\n+<%\n     int64_t now = GetTime();\n     bool notify_ui = false;\n-    {\n+    <%\n         LOCK(m_cs_banned);\n         banmap_t::iterator it = m_banned.begin();\n-        while (it != m_banned.end()) {\n+        while (it != m_banned.end()) <%\n             CSubNet sub_net = (*it).first;\n             CBanEntry ban_entry = (*it).second;\n-            if (now > ban_entry.nBanUntil) {\n+            if (now > ban_entry.nBanUntil) <%\n                 m_banned.erase(it++);\n                 m_is_dirty = true;\n                 notify_ui = true;\n                 LogPrint(BCLog::NET, \"%s: Removed banned node ip/subnet from banlist.dat: %s\\n\", __func__, sub_net.ToString());\n-            } else\n+            %> else\n                 ++it;\n-        }\n-    }\n+        %>\n+    %>\n     // update UI\n-    if (notify_ui && m_client_interface) {\n+    if (notify_ui && m_client_interface) <%\n         m_client_interface->BannedListChanged();\n-    }\n-}\n+    %>\n+%>\n \n bool BanMan::BannedSetIsDirty()\n-{\n+<%\n     LOCK(m_cs_banned);\n     return m_is_dirty;\n-}\n+%>\n \n void BanMan::SetBannedSetDirty(bool dirty)\n-{\n+<%\n     LOCK(m_cs_banned); //reuse m_banned lock for the m_is_dirty flag\n     m_is_dirty = dirty;\n-}\n+%>"
      },
      {
        "sha": "2f4fe9db6bee83128dbee9232edf14f7357239a1",
        "filename": "src/banman.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/banman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/banman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/banman.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -35,7 +35,7 @@ class CSubNet;\n // new code.\n \n class BanMan\n-{\n+<%\n public:\n     ~BanMan();\n     BanMan(fs::path ban_file, CClientUIInterface* client_interface, int64_t default_ban_time);\n@@ -64,7 +64,7 @@ class BanMan\n     CClientUIInterface* m_client_interface = nullptr;\n     CBanDB m_ban_db;\n     const int64_t m_default_ban_time;\n-};\n+%>;\n \n extern std::unique_ptr<BanMan> g_banman;\n #endif"
      },
      {
        "sha": "82ba8f094bd0bc6fe931b88349e0cb4dcfefb051",
        "filename": "src/base58.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 32,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/base58.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/base58.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -13,7 +13,7 @@\n \n /** All alphanumeric characters except for \"0\", \"I\", \"O\", and \"l\" */\n static const char* pszBase58 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n-static const int8_t mapBase58[256] = {\n+static const int8_t mapBase58[256] = <%\n     -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,\n     -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,\n     -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,\n@@ -30,40 +30,40 @@ static const int8_t mapBase58[256] = {\n     -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,\n     -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,\n     -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,\n-};\n+%>;\n \n bool DecodeBase58(const char* psz, std::vector<unsigned char>& vch)\n-{\n+<%\n     // Skip leading spaces.\n     while (*psz && IsSpace(*psz))\n         psz++;\n     // Skip and count leading '1's.\n     int zeroes = 0;\n     int length = 0;\n-    while (*psz == '1') {\n+    while (*psz == '1') <%\n         zeroes++;\n         psz++;\n-    }\n+    %>\n     // Allocate enough space in big-endian base256 representation.\n     int size = strlen(psz) * 733 /1000 + 1; // log(58) / log(256), rounded up.\n     std::vector<unsigned char> b256(size);\n     // Process the characters.\n     static_assert(sizeof(mapBase58)/sizeof(mapBase58[0]) == 256, \"mapBase58.size() should be 256\"); // guarantee not out of range\n-    while (*psz && !IsSpace(*psz)) {\n+    while (*psz && !IsSpace(*psz)) <%\n         // Decode base58 character\n         int carry = mapBase58[(uint8_t)*psz];\n         if (carry == -1)  // Invalid b58 character\n             return false;\n         int i = 0;\n-        for (std::vector<unsigned char>::reverse_iterator it = b256.rbegin(); (carry != 0 || i < length) && (it != b256.rend()); ++it, ++i) {\n+        for (std::vector<unsigned char>::reverse_iterator it = b256.rbegin(); (carry != 0 || i < length) && (it != b256.rend()); ++it, ++i) <%\n             carry += 58 * (*it);\n             *it = carry % 256;\n             carry /= 256;\n-        }\n+        %>\n         assert(carry == 0);\n         length = i;\n         psz++;\n-    }\n+    %>\n     // Skip trailing spaces.\n     while (IsSpace(*psz))\n         psz++;\n@@ -79,35 +79,35 @@ bool DecodeBase58(const char* psz, std::vector<unsigned char>& vch)\n     while (it != b256.end())\n         vch.push_back(*(it++));\n     return true;\n-}\n+%>\n \n std::string EncodeBase58(const unsigned char* pbegin, const unsigned char* pend)\n-{\n+<%\n     // Skip & count leading zeroes.\n     int zeroes = 0;\n     int length = 0;\n-    while (pbegin != pend && *pbegin == 0) {\n+    while (pbegin != pend && *pbegin == 0) <%\n         pbegin++;\n         zeroes++;\n-    }\n+    %>\n     // Allocate enough space in big-endian base58 representation.\n     int size = (pend - pbegin) * 138 / 100 + 1; // log(256) / log(58), rounded up.\n     std::vector<unsigned char> b58(size);\n     // Process the bytes.\n-    while (pbegin != pend) {\n+    while (pbegin != pend) <%\n         int carry = *pbegin;\n         int i = 0;\n         // Apply \"b58 = b58 * 256 + ch\".\n-        for (std::vector<unsigned char>::reverse_iterator it = b58.rbegin(); (carry != 0 || i < length) && (it != b58.rend()); it++, i++) {\n+        for (std::vector<unsigned char>::reverse_iterator it = b58.rbegin(); (carry != 0 || i < length) && (it != b58.rend()); it++, i++) <%\n             carry += 256 * (*it);\n             *it = carry % 58;\n             carry /= 58;\n-        }\n+        %>\n \n         assert(carry == 0);\n         length = i;\n         pbegin++;\n-    }\n+    %>\n     // Skip leading zeroes in base58 result.\n     std::vector<unsigned char>::iterator it = b58.begin() + (size - length);\n     while (it != b58.end() && *it == 0)\n@@ -119,45 +119,45 @@ std::string EncodeBase58(const unsigned char* pbegin, const unsigned char* pend)\n     while (it != b58.end())\n         str += pszBase58[*(it++)];\n     return str;\n-}\n+%>\n \n std::string EncodeBase58(const std::vector<unsigned char>& vch)\n-{\n+<%\n     return EncodeBase58(vch.data(), vch.data() + vch.size());\n-}\n+%>\n \n bool DecodeBase58(const std::string& str, std::vector<unsigned char>& vchRet)\n-{\n+<%\n     return DecodeBase58(str.c_str(), vchRet);\n-}\n+%>\n \n std::string EncodeBase58Check(const std::vector<unsigned char>& vchIn)\n-{\n+<%\n     // add 4-byte hash check to the end\n     std::vector<unsigned char> vch(vchIn);\n     uint256 hash = Hash(vch.begin(), vch.end());\n     vch.insert(vch.end(), (unsigned char*)&hash, (unsigned char*)&hash + 4);\n     return EncodeBase58(vch);\n-}\n+%>\n \n bool DecodeBase58Check(const char* psz, std::vector<unsigned char>& vchRet)\n-{\n+<%\n     if (!DecodeBase58(psz, vchRet) ||\n-        (vchRet.size() < 4)) {\n+        (vchRet.size() < 4)) <%\n         vchRet.clear();\n         return false;\n-    }\n+    %>\n     // re-calculate the checksum, ensure it matches the included 4-byte checksum\n     uint256 hash = Hash(vchRet.begin(), vchRet.end() - 4);\n-    if (memcmp(&hash, &vchRet[vchRet.size() - 4], 4) != 0) {\n+    if (memcmp(&hash, &vchRet[vchRet.size() - 4], 4) != 0) <%\n         vchRet.clear();\n         return false;\n-    }\n+    %>\n     vchRet.resize(vchRet.size() - 4);\n     return true;\n-}\n+%>\n \n bool DecodeBase58Check(const std::string& str, std::vector<unsigned char>& vchRet)\n-{\n+<%\n     return DecodeBase58Check(str.c_str(), vchRet);\n-}\n+%>"
      },
      {
        "sha": "be1428cbf1ce467e845fb2e71fba28c43765e509",
        "filename": "src/bech32.cpp",
        "status": "modified",
        "additions": 49,
        "deletions": 49,
        "changes": 98,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bech32.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bech32.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bech32.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -5,15 +5,15 @@\n #include <bech32.h>\n \n namespace\n-{\n+<%\n \n typedef std::vector<uint8_t> data;\n \n /** The Bech32 character set for encoding. */\n const char* CHARSET = \"qpzry9x8gf2tvdw0s3jn54khce6mua7l\";\n \n /** The Bech32 character set for decoding. */\n-const int8_t CHARSET_REV[128] = {\n+const int8_t CHARSET_REV[128] = <%\n     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n@@ -22,20 +22,20 @@ const int8_t CHARSET_REV[128] = {\n      1,  0,  3, 16, 11, 28, 12, 14,  6,  4,  2, -1, -1, -1, -1, -1,\n     -1, 29, -1, 24, 13, 25,  9,  8, 23, -1, 18, 22, 31, 27, 19, -1,\n      1,  0,  3, 16, 11, 28, 12, 14,  6,  4,  2, -1, -1, -1, -1, -1\n-};\n+%>;\n \n /** Concatenate two byte arrays. */\n data Cat(data x, const data& y)\n-{\n+<%\n     x.insert(x.end(), y.begin(), y.end());\n     return x;\n-}\n+%>\n \n /** This function will compute what 6 5-bit values to XOR into the last 6 input values, in order to\n  *  make the checksum 0. These 6 values are packed together in a single 30-bit integer. The higher\n  *  bits correspond to earlier values. */\n uint32_t PolyMod(const data& v)\n-{\n+<%\n     // The input is interpreted as a list of coefficients of a polynomial over F = GF(32), with an\n     // implicit 1 in front. If the input is [v0,v1,v2,v3,v4], that polynomial is v(x) =\n     // 1*x^5 + v0*x^4 + v1*x^3 + v2*x^2 + v3*x + v4. The implicit 1 guarantees that\n@@ -62,7 +62,7 @@ uint32_t PolyMod(const data& v)\n     // v, it corresponds to x^2 + v0*x + v1 mod g(x). As 1 mod g(x) = 1, that is the starting value\n     // for `c`.\n     uint32_t c = 1;\n-    for (const auto v_i : v) {\n+    for (const auto v_i : v) <%\n         // We want to update `c` to correspond to a polynomial with one extra term. If the initial\n         // value of `c` consists of the coefficients of c(x) = f(x) mod g(x), we modify it to\n         // correspond to c'(x) = (f(x) * x + v_i) mod g(x), where v_i is the next input to\n@@ -89,104 +89,104 @@ uint32_t PolyMod(const data& v)\n         if (c0 & 4)  c ^= 0x1ea119fa; //  {4}k(x) = {15}x^5 + {10}x^4 +  {2}x^3 +  {6}x^2 + {15}x + {26}\n         if (c0 & 8)  c ^= 0x3d4233dd; //  {8}k(x) = {30}x^5 + {20}x^4 +  {4}x^3 + {12}x^2 + {30}x + {29}\n         if (c0 & 16) c ^= 0x2a1462b3; // {16}k(x) = {21}x^5 +     x^4 +  {8}x^3 + {24}x^2 + {21}x + {19}\n-    }\n+    %>\n     return c;\n-}\n+%>\n \n /** Convert to lower case. */\n inline unsigned char LowerCase(unsigned char c)\n-{\n+<%\n     return (c >= 'A' && c <= 'Z') ? (c - 'A') + 'a' : c;\n-}\n+%>\n \n /** Expand a HRP for use in checksum computation. */\n data ExpandHRP(const std::string& hrp)\n-{\n+<%\n     data ret;\n     ret.reserve(hrp.size() + 90);\n     ret.resize(hrp.size() * 2 + 1);\n-    for (size_t i = 0; i < hrp.size(); ++i) {\n+    for (size_t i = 0; i < hrp.size(); ++i) <%\n         unsigned char c = hrp[i];\n         ret[i] = c >> 5;\n         ret[i + hrp.size() + 1] = c & 0x1f;\n-    }\n+    %>\n     ret[hrp.size()] = 0;\n     return ret;\n-}\n+%>\n \n /** Verify a checksum. */\n bool VerifyChecksum(const std::string& hrp, const data& values)\n-{\n+<%\n     // PolyMod computes what value to xor into the final values to make the checksum 0. However,\n     // if we required that the checksum was 0, it would be the case that appending a 0 to a valid\n     // list of values would result in a new valid list. For that reason, Bech32 requires the\n     // resulting checksum to be 1 instead.\n     return PolyMod(Cat(ExpandHRP(hrp), values)) == 1;\n-}\n+%>\n \n /** Create a checksum. */\n data CreateChecksum(const std::string& hrp, const data& values)\n-{\n+<%\n     data enc = Cat(ExpandHRP(hrp), values);\n     enc.resize(enc.size() + 6); // Append 6 zeroes\n     uint32_t mod = PolyMod(enc) ^ 1; // Determine what to XOR into those 6 zeroes.\n     data ret(6);\n-    for (size_t i = 0; i < 6; ++i) {\n+    for (size_t i = 0; i < 6; ++i) <%\n         // Convert the 5-bit groups in mod to checksum values.\n         ret[i] = (mod >> (5 * (5 - i))) & 31;\n-    }\n+    %>\n     return ret;\n-}\n+%>\n \n-} // namespace\n+%> // namespace\n \n namespace bech32\n-{\n+<%\n \n /** Encode a Bech32 string. */\n-std::string Encode(const std::string& hrp, const data& values) {\n+std::string Encode(const std::string& hrp, const data& values) <%\n     data checksum = CreateChecksum(hrp, values);\n     data combined = Cat(values, checksum);\n     std::string ret = hrp + '1';\n     ret.reserve(ret.size() + combined.size());\n-    for (const auto c : combined) {\n+    for (const auto c : combined) <%\n         ret += CHARSET[c];\n-    }\n+    %>\n     return ret;\n-}\n+%>\n \n /** Decode a Bech32 string. */\n-std::pair<std::string, data> Decode(const std::string& str) {\n+std::pair<std::string, data> Decode(const std::string& str) <%\n     bool lower = false, upper = false;\n-    for (size_t i = 0; i < str.size(); ++i) {\n+    for (size_t i = 0; i < str.size(); ++i) <%\n         unsigned char c = str[i];\n         if (c >= 'a' && c <= 'z') lower = true;\n         else if (c >= 'A' && c <= 'Z') upper = true;\n-        else if (c < 33 || c > 126) return {};\n-    }\n-    if (lower && upper) return {};\n+        else if (c < 33 || c > 126) return <%%>;\n+    %>\n+    if (lower && upper) return <%%>;\n     size_t pos = str.rfind('1');\n-    if (str.size() > 90 || pos == str.npos || pos == 0 || pos + 7 > str.size()) {\n-        return {};\n-    }\n+    if (str.size() > 90 || pos == str.npos || pos == 0 || pos + 7 > str.size()) <%\n+        return <%%>;\n+    %>\n     data values(str.size() - 1 - pos);\n-    for (size_t i = 0; i < str.size() - 1 - pos; ++i) {\n+    for (size_t i = 0; i < str.size() - 1 - pos; ++i) <%\n         unsigned char c = str[i + pos + 1];\n         int8_t rev = CHARSET_REV[c];\n \n-        if (rev == -1) {\n-            return {};\n-        }\n+        if (rev == -1) <%\n+            return <%%>;\n+        %>\n         values[i] = rev;\n-    }\n+    %>\n     std::string hrp;\n-    for (size_t i = 0; i < pos; ++i) {\n+    for (size_t i = 0; i < pos; ++i) <%\n         hrp += LowerCase(str[i]);\n-    }\n-    if (!VerifyChecksum(hrp, values)) {\n-        return {};\n-    }\n-    return {hrp, data(values.begin(), values.end() - 6)};\n-}\n-\n-} // namespace bech32\n+    %>\n+    if (!VerifyChecksum(hrp, values)) <%\n+        return <%%>;\n+    %>\n+    return <%hrp, data(values.begin(), values.end() - 6)%>;\n+%>\n+\n+%> // namespace bech32"
      },
      {
        "sha": "6f7d12d2ef9f7c2200e32e224fe9472460a3c2b5",
        "filename": "src/bech32.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bech32.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bech32.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bech32.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -17,14 +17,14 @@\n #include <vector>\n \n namespace bech32\n-{\n+<%\n \n /** Encode a Bech32 string. Returns the empty string in case of failure. */\n std::string Encode(const std::string& hrp, const std::vector<uint8_t>& values);\n \n /** Decode a Bech32 string. Returns (hrp, data). Empty hrp means failure. */\n std::pair<std::string, std::vector<uint8_t>> Decode(const std::string& str);\n \n-} // namespace bech32\n+%> // namespace bech32\n \n #endif // BITCOIN_BECH32_H"
      },
      {
        "sha": "9b0ef515a4211924fe6930cdf6e9a533b6e9ae37",
        "filename": "src/bench/base58.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 20,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/base58.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/base58.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/base58.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -13,45 +13,45 @@\n \n \n static void Base58Encode(benchmark::State& state)\n-{\n-    static const std::array<unsigned char, 32> buff = {\n-        {\n+<%\n+    static const std::array<unsigned char, 32> buff = <%\n+        <%\n             17, 79, 8, 99, 150, 189, 208, 162, 22, 23, 203, 163, 36, 58, 147,\n             227, 139, 2, 215, 100, 91, 38, 11, 141, 253, 40, 117, 21, 16, 90,\n             200, 24\n-        }\n-    };\n-    while (state.KeepRunning()) {\n+        %>\n+    %>;\n+    while (state.KeepRunning()) <%\n         EncodeBase58(buff.data(), buff.data() + buff.size());\n-    }\n-}\n+    %>\n+%>\n \n \n static void Base58CheckEncode(benchmark::State& state)\n-{\n-    static const std::array<unsigned char, 32> buff = {\n-        {\n+<%\n+    static const std::array<unsigned char, 32> buff = <%\n+        <%\n             17, 79, 8, 99, 150, 189, 208, 162, 22, 23, 203, 163, 36, 58, 147,\n             227, 139, 2, 215, 100, 91, 38, 11, 141, 253, 40, 117, 21, 16, 90,\n             200, 24\n-        }\n-    };\n+        %>\n+    %>;\n     std::vector<unsigned char> vch;\n     vch.assign(buff.begin(), buff.end());\n-    while (state.KeepRunning()) {\n+    while (state.KeepRunning()) <%\n         EncodeBase58Check(vch);\n-    }\n-}\n+    %>\n+%>\n \n \n static void Base58Decode(benchmark::State& state)\n-{\n+<%\n     const char* addr = \"17VZNX1SN5NtKa8UQFxwQbFeFc3iqRYhem\";\n     std::vector<unsigned char> vch;\n-    while (state.KeepRunning()) {\n+    while (state.KeepRunning()) <%\n         (void) DecodeBase58(addr, vch);\n-    }\n-}\n+    %>\n+%>\n \n \n BENCHMARK(Base58Encode, 470 * 1000);"
      },
      {
        "sha": "9b0330820da374191d31915c0cd9abffd8a2b2c5",
        "filename": "src/bench/bech32.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/bech32.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/bech32.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bech32.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -13,24 +13,24 @@\n \n \n static void Bech32Encode(benchmark::State& state)\n-{\n+<%\n     std::vector<uint8_t> v = ParseHex(\"c97f5a67ec381b760aeaf67573bc164845ff39a3bb26a1cee401ac67243b48db\");\n-    std::vector<unsigned char> tmp = {0};\n+    std::vector<unsigned char> tmp = <%0%>;\n     tmp.reserve(1 + 32 * 8 / 5);\n-    ConvertBits<8, 5, true>([&](unsigned char c) { tmp.push_back(c); }, v.begin(), v.end());\n-    while (state.KeepRunning()) {\n+    ConvertBits<8, 5, true>([&](unsigned char c) <% tmp.push_back(c); %>, v.begin(), v.end());\n+    while (state.KeepRunning()) <%\n         bech32::Encode(\"bc\", tmp);\n-    }\n-}\n+    %>\n+%>\n \n \n static void Bech32Decode(benchmark::State& state)\n-{\n+<%\n     std::string addr = \"bc1qkallence7tjawwvy0dwt4twc62qjgaw8f4vlhyd006d99f09\";\n-    while (state.KeepRunning()) {\n+    while (state.KeepRunning()) <%\n         bech32::Decode(addr);\n-    }\n-}\n+    %>\n+%>\n \n \n BENCHMARK(Bech32Encode, 800 * 1000);"
      },
      {
        "sha": "58123fa5b5bcd053ceae94b7ebea3a849fd38634",
        "filename": "src/bench/bench.cpp",
        "status": "modified",
        "additions": 42,
        "deletions": 42,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/bench.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/bench.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -12,12 +12,12 @@\n #include <numeric>\n \n void benchmark::ConsolePrinter::header()\n-{\n+<%\n     std::cout << \"# Benchmark, evals, iterations, total, min, max, median\" << std::endl;\n-}\n+%>\n \n void benchmark::ConsolePrinter::result(const State& state)\n-{\n+<%\n     auto results = state.m_elapsed_results;\n     std::sort(results.begin(), results.end());\n \n@@ -27,77 +27,77 @@ void benchmark::ConsolePrinter::result(const State& state)\n     double back = 0;\n     double median = 0;\n \n-    if (!results.empty()) {\n+    if (!results.empty()) <%\n         front = results.front();\n         back = results.back();\n \n         size_t mid = results.size() / 2;\n         median = results[mid];\n-        if (0 == results.size() % 2) {\n+        if (0 == results.size() % 2) <%\n             median = (results[mid] + results[mid + 1]) / 2;\n-        }\n-    }\n+        %>\n+    %>\n \n     std::cout << std::setprecision(6);\n     std::cout << state.m_name << \", \" << state.m_num_evals << \", \" << state.m_num_iters << \", \" << total << \", \" << front << \", \" << back << \", \" << median << std::endl;\n-}\n+%>\n \n-void benchmark::ConsolePrinter::footer() {}\n+void benchmark::ConsolePrinter::footer() <%%>\n benchmark::PlotlyPrinter::PlotlyPrinter(std::string plotly_url, int64_t width, int64_t height)\n     : m_plotly_url(plotly_url), m_width(width), m_height(height)\n-{\n-}\n+<%\n+%>\n \n void benchmark::PlotlyPrinter::header()\n-{\n+<%\n     std::cout << \"<html><head>\"\n               << \"<script src=\\\"\" << m_plotly_url << \"\\\"></script>\"\n               << \"</head><body><div id=\\\"myDiv\\\" style=\\\"width:\" << m_width << \"px; height:\" << m_height << \"px\\\"></div>\"\n               << \"<script> var data = [\"\n               << std::endl;\n-}\n+%>\n \n void benchmark::PlotlyPrinter::result(const State& state)\n-{\n+<%\n     std::cout << \"{ \" << std::endl\n               << \"  name: '\" << state.m_name << \"', \" << std::endl\n               << \"  y: [\";\n \n     const char* prefix = \"\";\n-    for (const auto& e : state.m_elapsed_results) {\n+    for (const auto& e : state.m_elapsed_results) <%\n         std::cout << prefix << std::setprecision(6) << e;\n         prefix = \", \";\n-    }\n+    %>\n     std::cout << \"],\" << std::endl\n               << \"  boxpoints: 'all', jitter: 0.3, pointpos: 0, type: 'box',\"\n               << std::endl\n               << \"},\" << std::endl;\n-}\n+%>\n \n void benchmark::PlotlyPrinter::footer()\n-{\n+<%\n     std::cout << \"]; var layout = { showlegend: false, yaxis: { rangemode: 'tozero', autorange: true } };\"\n               << \"Plotly.newPlot('myDiv', data, layout);\"\n               << \"</script></body></html>\";\n-}\n+%>\n \n \n benchmark::BenchRunner::BenchmarkMap& benchmark::BenchRunner::benchmarks()\n-{\n+<%\n     static std::map<std::string, Bench> benchmarks_map;\n     return benchmarks_map;\n-}\n+%>\n \n benchmark::BenchRunner::BenchRunner(std::string name, benchmark::BenchFunction func, uint64_t num_iters_for_one_second)\n-{\n-    benchmarks().insert(std::make_pair(name, Bench{func, num_iters_for_one_second}));\n-}\n+<%\n+    benchmarks().insert(std::make_pair(name, Bench<%func, num_iters_for_one_second%>));\n+%>\n \n void benchmark::BenchRunner::RunAll(Printer& printer, uint64_t num_evals, double scaling, const std::string& filter, bool is_list_only)\n-{\n-    if (!std::ratio_less_equal<benchmark::clock::period, std::micro>::value) {\n+<%\n+    if (!std::ratio_less_equal<benchmark::clock::period, std::micro>::value) <%\n         std::cerr << \"WARNING: Clock precision is worse than microsecond - benchmarks may be less accurate!\\n\";\n-    }\n+    %>\n #ifdef DEBUG\n     std::cerr << \"WARNING: This is a debug build - may result in slower benchmarks.\\n\";\n #endif\n@@ -107,36 +107,36 @@ void benchmark::BenchRunner::RunAll(Printer& printer, uint64_t num_evals, double\n \n     printer.header();\n \n-    for (const auto& p : benchmarks()) {\n-        if (!std::regex_match(p.first, baseMatch, reFilter)) {\n+    for (const auto& p : benchmarks()) <%\n+        if (!std::regex_match(p.first, baseMatch, reFilter)) <%\n             continue;\n-        }\n+        %>\n \n         uint64_t num_iters = static_cast<uint64_t>(p.second.num_iters_for_one_second * scaling);\n-        if (0 == num_iters) {\n+        if (0 == num_iters) <%\n             num_iters = 1;\n-        }\n+        %>\n         State state(p.first, num_evals, num_iters, printer);\n-        if (!is_list_only) {\n+        if (!is_list_only) <%\n             p.second.func(state);\n-        }\n+        %>\n         printer.result(state);\n-    }\n+    %>\n \n     printer.footer();\n-}\n+%>\n \n bool benchmark::State::UpdateTimer(const benchmark::time_point current_time)\n-{\n-    if (m_start_time != time_point()) {\n+<%\n+    if (m_start_time != time_point()) <%\n         std::chrono::duration<double> diff = current_time - m_start_time;\n         m_elapsed_results.push_back(diff.count() / m_num_iters);\n \n-        if (m_elapsed_results.size() == m_num_evals) {\n+        if (m_elapsed_results.size() == m_num_evals) <%\n             return false;\n-        }\n-    }\n+        %>\n+    %>\n \n     m_num_iters_left = m_num_iters - 1;\n     return true;\n-}\n+%>"
      },
      {
        "sha": "3d583a386229ba0a67acb9feaa5bb54c0ab06f39",
        "filename": "src/bench/bench.h",
        "status": "modified",
        "additions": 23,
        "deletions": 23,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/bench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/bench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -38,21 +38,21 @@ BENCHMARK(CODE_TO_TIME, 5000);\n \n  */\n \n-namespace benchmark {\n+namespace benchmark <%\n // In case high_resolution_clock is steady, prefer that, otherwise use steady_clock.\n-struct best_clock {\n+struct best_clock <%\n     using hi_res_clock = std::chrono::high_resolution_clock;\n     using steady_clock = std::chrono::steady_clock;\n     using type = std::conditional<hi_res_clock::is_steady, hi_res_clock, steady_clock>::type;\n-};\n+%>;\n using clock = best_clock::type;\n using time_point = clock::time_point;\n using duration = clock::duration;\n \n class Printer;\n \n class State\n-{\n+<%\n public:\n     std::string m_name;\n     uint64_t m_num_iters_left;\n@@ -64,61 +64,61 @@ class State\n     bool UpdateTimer(time_point finish_time);\n \n     State(std::string name, uint64_t num_evals, double num_iters, Printer& printer) : m_name(name), m_num_iters_left(0), m_num_iters(num_iters), m_num_evals(num_evals)\n-    {\n-    }\n+    <%\n+    %>\n \n     inline bool KeepRunning()\n-    {\n-        if (m_num_iters_left--) {\n+    <%\n+        if (m_num_iters_left--) <%\n             return true;\n-        }\n+        %>\n \n         bool result = UpdateTimer(clock::now());\n         // measure again so runtime of UpdateTimer is not included\n         m_start_time = clock::now();\n         return result;\n-    }\n-};\n+    %>\n+%>;\n \n typedef std::function<void(State&)> BenchFunction;\n \n class BenchRunner\n-{\n-    struct Bench {\n+<%\n+    struct Bench <%\n         BenchFunction func;\n         uint64_t num_iters_for_one_second;\n-    };\n+    %>;\n     typedef std::map<std::string, Bench> BenchmarkMap;\n     static BenchmarkMap& benchmarks();\n \n public:\n     BenchRunner(std::string name, BenchFunction func, uint64_t num_iters_for_one_second);\n \n     static void RunAll(Printer& printer, uint64_t num_evals, double scaling, const std::string& filter, bool is_list_only);\n-};\n+%>;\n \n // interface to output benchmark results.\n class Printer\n-{\n+<%\n public:\n-    virtual ~Printer() {}\n+    virtual ~Printer() <%%>\n     virtual void header() = 0;\n     virtual void result(const State& state) = 0;\n     virtual void footer() = 0;\n-};\n+%>;\n \n // default printer to console, shows min, max, median.\n class ConsolePrinter : public Printer\n-{\n+<%\n public:\n     void header() override;\n     void result(const State& state) override;\n     void footer() override;\n-};\n+%>;\n \n // creates box plot with plotly.js\n class PlotlyPrinter : public Printer\n-{\n+<%\n public:\n     PlotlyPrinter(std::string plotly_url, int64_t width, int64_t height);\n     void header() override;\n@@ -129,8 +129,8 @@ class PlotlyPrinter : public Printer\n     std::string m_plotly_url;\n     int64_t m_width;\n     int64_t m_height;\n-};\n-}\n+%>;\n+%>\n \n \n // BENCHMARK(foo, num_iters_for_one_second) expands to:  benchmark::BenchRunner bench_11foo(\"foo\", num_iterations);"
      },
      {
        "sha": "68bb470018e7fd411ed91689e0f262c62a0fcdb2",
        "filename": "src/bench/bench_bitcoin.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 15,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/bench_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/bench_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench_bitcoin.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -23,7 +23,7 @@ static const int64_t DEFAULT_PLOT_WIDTH = 1024;\n static const int64_t DEFAULT_PLOT_HEIGHT = 768;\n \n static void SetupBenchArgs()\n-{\n+<%\n     SetupHelpOptions(gArgs);\n \n     gArgs.AddArg(\"-list\", \"List benchmarks without executing them. Can be combined with -scaling and -filter\", false, OptionsCategory::OPTIONS);\n@@ -34,33 +34,33 @@ static void SetupBenchArgs()\n     gArgs.AddArg(\"-plot-plotlyurl=<uri>\", strprintf(\"URL to use for plotly.js (default: %s)\", DEFAULT_PLOT_PLOTLYURL), false, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-plot-width=<x>\", strprintf(\"Plot width in pixel (default: %u)\", DEFAULT_PLOT_WIDTH), false, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-plot-height=<x>\", strprintf(\"Plot height in pixel (default: %u)\", DEFAULT_PLOT_HEIGHT), false, OptionsCategory::OPTIONS);\n-}\n+%>\n \n static fs::path SetDataDir()\n-{\n+<%\n     fs::path ret = fs::temp_directory_path() / \"bench_bitcoin\" / fs::unique_path();\n     fs::create_directories(ret);\n     gArgs.ForceSetArg(\"-datadir\", ret.string());\n     return ret;\n-}\n+%>\n \n int main(int argc, char** argv)\n-{\n+<%\n     SetupBenchArgs();\n     std::string error;\n-    if (!gArgs.ParseParameters(argc, argv, error)) {\n+    if (!gArgs.ParseParameters(argc, argv, error)) <%\n         fprintf(stderr, \"Error parsing command line arguments: %s\\n\", error.c_str());\n         return EXIT_FAILURE;\n-    }\n+    %>\n \n-    if (HelpRequested(gArgs)) {\n+    if (HelpRequested(gArgs)) <%\n         std::cout << gArgs.GetHelpMessage();\n \n         return EXIT_SUCCESS;\n-    }\n+    %>\n \n     // Set the datadir after parsing the bench options\n-    const fs::path bench_datadir{SetDataDir()};\n+    const fs::path bench_datadir<%SetDataDir()%>;\n \n     SHA256AutoDetect();\n     ECC_Start();\n@@ -72,19 +72,19 @@ int main(int argc, char** argv)\n     bool is_list_only = gArgs.GetBoolArg(\"-list\", false);\n \n     double scaling_factor;\n-    if (!ParseDouble(scaling_str, &scaling_factor)) {\n+    if (!ParseDouble(scaling_str, &scaling_factor)) <%\n         fprintf(stderr, \"Error parsing scaling factor as double: %s\\n\", scaling_str.c_str());\n         return EXIT_FAILURE;\n-    }\n+    %>\n \n     std::unique_ptr<benchmark::Printer> printer = MakeUnique<benchmark::ConsolePrinter>();\n     std::string printer_arg = gArgs.GetArg(\"-printer\", DEFAULT_BENCH_PRINTER);\n-    if (\"plot\" == printer_arg) {\n+    if (\"plot\" == printer_arg) <%\n         printer.reset(new benchmark::PlotlyPrinter(\n             gArgs.GetArg(\"-plot-plotlyurl\", DEFAULT_PLOT_PLOTLYURL),\n             gArgs.GetArg(\"-plot-width\", DEFAULT_PLOT_WIDTH),\n             gArgs.GetArg(\"-plot-height\", DEFAULT_PLOT_HEIGHT)));\n-    }\n+    %>\n \n     benchmark::BenchRunner::RunAll(*printer, evaluations, scaling_factor, regex_filter, is_list_only);\n \n@@ -93,4 +93,4 @@ int main(int argc, char** argv)\n     ECC_Stop();\n \n     return EXIT_SUCCESS;\n-}\n+%>"
      },
      {
        "sha": "c2490f457fa89db9de1ada9abf909d1c7e0c9561",
        "filename": "src/bench/block_assemble.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 28,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/block_assemble.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/block_assemble.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/block_assemble.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -24,45 +24,45 @@\n #include <vector>\n \n static std::shared_ptr<CBlock> PrepareBlock(const CScript& coinbase_scriptPubKey)\n-{\n+<%\n     auto block = std::make_shared<CBlock>(\n-        BlockAssembler{Params()}\n+        BlockAssembler<%Params()%>\n             .CreateNewBlock(coinbase_scriptPubKey)\n             ->block);\n \n     block->nTime = ::chainActive.Tip()->GetMedianTimePast() + 1;\n     block->hashMerkleRoot = BlockMerkleRoot(*block);\n \n     return block;\n-}\n+%>\n \n \n static CTxIn MineBlock(const CScript& coinbase_scriptPubKey)\n-{\n+<%\n     auto block = PrepareBlock(coinbase_scriptPubKey);\n \n-    while (!CheckProofOfWork(block->GetHash(), block->nBits, Params().GetConsensus())) {\n+    while (!CheckProofOfWork(block->GetHash(), block->nBits, Params().GetConsensus())) <%\n         ++block->nNonce;\n         assert(block->nNonce);\n-    }\n+    %>\n \n-    bool processed{ProcessNewBlock(Params(), block, true, nullptr)};\n+    bool processed<%ProcessNewBlock(Params(), block, true, nullptr)%>;\n     assert(processed);\n \n-    return CTxIn{block->vtx[0]->GetHash(), 0};\n-}\n+    return CTxIn<%block->vtx[0]->GetHash(), 0%>;\n+%>\n \n \n static void AssembleBlock(benchmark::State& state)\n-{\n-    const std::vector<unsigned char> op_true{OP_TRUE};\n+<%\n+    const std::vector<unsigned char> op_true<%OP_TRUE%>;\n     CScriptWitness witness;\n     witness.stack.push_back(op_true);\n \n     uint256 witness_program;\n     CSHA256().Write(&op_true[0], op_true.size()).Finalize(witness_program.begin());\n \n-    const CScript SCRIPT_PUB{CScript(OP_0) << std::vector<unsigned char>{witness_program.begin(), witness_program.end()}};\n+    const CScript SCRIPT_PUB<%CScript(OP_0) << std::vector<unsigned char><%witness_program.begin(), witness_program.end()%>%>;\n \n     // Switch to regtest so we can mine faster\n     // Also segwit is active, so we can include witness transactions\n@@ -72,53 +72,53 @@ static void AssembleBlock(benchmark::State& state)\n \n     boost::thread_group thread_group;\n     CScheduler scheduler;\n-    {\n+    <%\n         LOCK(cs_main);\n         ::pblocktree.reset(new CBlockTreeDB(1 << 20, true));\n         ::pcoinsdbview.reset(new CCoinsViewDB(1 << 23, true));\n         ::pcoinsTip.reset(new CCoinsViewCache(pcoinsdbview.get()));\n-    }\n-    {\n+    %>\n+    <%\n         const CChainParams& chainparams = Params();\n         thread_group.create_thread(std::bind(&CScheduler::serviceQueue, &scheduler));\n         GetMainSignals().RegisterBackgroundSignalScheduler(scheduler);\n         LoadGenesisBlock(chainparams);\n         CValidationState state;\n         ActivateBestChain(state, chainparams);\n         assert(::chainActive.Tip() != nullptr);\n-        const bool witness_enabled{IsWitnessEnabled(::chainActive.Tip(), chainparams.GetConsensus())};\n+        const bool witness_enabled<%IsWitnessEnabled(::chainActive.Tip(), chainparams.GetConsensus())%>;\n         assert(witness_enabled);\n-    }\n+    %>\n \n     // Collect some loose transactions that spend the coinbases of our mined blocks\n-    constexpr size_t NUM_BLOCKS{200};\n+    constexpr size_t NUM_BLOCKS<%200%>;\n     std::array<CTransactionRef, NUM_BLOCKS - COINBASE_MATURITY + 1> txs;\n-    for (size_t b{0}; b < NUM_BLOCKS; ++b) {\n+    for (size_t b<%0%>; b < NUM_BLOCKS; ++b) <%\n         CMutableTransaction tx;\n         tx.vin.push_back(MineBlock(SCRIPT_PUB));\n         tx.vin.back().scriptWitness = witness;\n         tx.vout.emplace_back(1337, SCRIPT_PUB);\n         if (NUM_BLOCKS - b >= COINBASE_MATURITY)\n             txs.at(b) = MakeTransactionRef(tx);\n-    }\n-    {\n+    %>\n+    <%\n         LOCK(::cs_main); // Required for ::AcceptToMemoryPool.\n \n-        for (const auto& txr : txs) {\n+        for (const auto& txr : txs) <%\n             CValidationState state;\n-            bool ret{::AcceptToMemoryPool(::mempool, state, txr, nullptr /* pfMissingInputs */, nullptr /* plTxnReplaced */, false /* bypass_limits */, /* nAbsurdFee */ 0)};\n+            bool ret<%::AcceptToMemoryPool(::mempool, state, txr, nullptr /* pfMissingInputs */, nullptr /* plTxnReplaced */, false /* bypass_limits */, /* nAbsurdFee */ 0)%>;\n             assert(ret);\n-        }\n-    }\n+        %>\n+    %>\n \n-    while (state.KeepRunning()) {\n+    while (state.KeepRunning()) <%\n         PrepareBlock(SCRIPT_PUB);\n-    }\n+    %>\n \n     thread_group.interrupt_all();\n     thread_group.join_all();\n     GetMainSignals().FlushBackgroundCallbacks();\n     GetMainSignals().UnregisterBackgroundSignalScheduler();\n-}\n+%>\n \n BENCHMARK(AssembleBlock, 700);"
      },
      {
        "sha": "3173342687f425c91633c6ae33ea25121c92ba75",
        "filename": "src/bench/ccoins_caching.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/ccoins_caching.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/ccoins_caching.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/ccoins_caching.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -18,16 +18,16 @@\n //\n static std::vector<CMutableTransaction>\n SetupDummyInputs(CBasicKeyStore& keystoreRet, CCoinsViewCache& coinsRet)\n-{\n+<%\n     std::vector<CMutableTransaction> dummyTransactions;\n     dummyTransactions.resize(2);\n \n     // Add some keys to the keystore:\n     CKey key[4];\n-    for (int i = 0; i < 4; i++) {\n+    for (int i = 0; i < 4; i++) <%\n         key[i].MakeNewKey(i % 2);\n         keystoreRet.AddKey(key[i]);\n-    }\n+    %>\n \n     // Create some dummy input transactions\n     dummyTransactions[0].vout.resize(2);\n@@ -45,7 +45,7 @@ SetupDummyInputs(CBasicKeyStore& keystoreRet, CCoinsViewCache& coinsRet)\n     AddCoins(coinsRet, CTransaction(dummyTransactions[1]), 0);\n \n     return dummyTransactions;\n-}\n+%>\n \n // Microbenchmark for simple accesses to a CCoinsViewCache database. Note from\n // laanwj, \"replicating the actual usage patterns of the client is hard though,\n@@ -54,7 +54,7 @@ SetupDummyInputs(CBasicKeyStore& keystoreRet, CCoinsViewCache& coinsRet)\n // every benchmark.\"\n // (https://github.com/bitcoin/bitcoin/issues/7883#issuecomment-224807484)\n static void CCoinsCaching(benchmark::State& state)\n-{\n+<%\n     CBasicKeyStore keystore;\n     CCoinsView coinsDummy;\n     CCoinsViewCache coins(&coinsDummy);\n@@ -77,12 +77,12 @@ static void CCoinsCaching(benchmark::State& state)\n \n     // Benchmark.\n     const CTransaction tx_1(t1);\n-    while (state.KeepRunning()) {\n+    while (state.KeepRunning()) <%\n         bool success = AreInputsStandard(tx_1, coins);\n         assert(success);\n         CAmount value = coins.GetValueIn(tx_1);\n         assert(value == (50 + 21 + 22) * COIN);\n-    }\n-}\n+    %>\n+%>\n \n BENCHMARK(CCoinsCaching, 170 * 1000);"
      },
      {
        "sha": "fc5e7a330f9a9f6f42584b98c4b9a576bc45863e",
        "filename": "src/bench/checkblock.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/checkblock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/checkblock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkblock.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -9,32 +9,32 @@\n #include <streams.h>\n #include <consensus/validation.h>\n \n-namespace block_bench {\n+namespace block_bench <%\n #include <bench/data/block413567.raw.h>\n-} // namespace block_bench\n+%> // namespace block_bench\n \n // These are the two major time-sinks which happen after we have fully received\n // a block off the wire, but before we can relay the block on to peers using\n // compact block relay.\n \n static void DeserializeBlockTest(benchmark::State& state)\n-{\n+<%\n     CDataStream stream((const char*)block_bench::block413567,\n             (const char*)block_bench::block413567 + sizeof(block_bench::block413567),\n             SER_NETWORK, PROTOCOL_VERSION);\n     char a = '\\0';\n     stream.write(&a, 1); // Prevent compaction\n \n-    while (state.KeepRunning()) {\n+    while (state.KeepRunning()) <%\n         CBlock block;\n         stream >> block;\n         bool rewound = stream.Rewind(sizeof(block_bench::block413567));\n         assert(rewound);\n-    }\n-}\n+    %>\n+%>\n \n static void DeserializeAndCheckBlockTest(benchmark::State& state)\n-{\n+<%\n     CDataStream stream((const char*)block_bench::block413567,\n             (const char*)block_bench::block413567 + sizeof(block_bench::block413567),\n             SER_NETWORK, PROTOCOL_VERSION);\n@@ -43,7 +43,7 @@ static void DeserializeAndCheckBlockTest(benchmark::State& state)\n \n     const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n \n-    while (state.KeepRunning()) {\n+    while (state.KeepRunning()) <%\n         CBlock block; // Note that CBlock caches its checked state, so we need to recreate it here\n         stream >> block;\n         bool rewound = stream.Rewind(sizeof(block_bench::block413567));\n@@ -52,8 +52,8 @@ static void DeserializeAndCheckBlockTest(benchmark::State& state)\n         CValidationState validationState;\n         bool checked = CheckBlock(block, validationState, chainParams->GetConsensus());\n         assert(checked);\n-    }\n-}\n+    %>\n+%>\n \n BENCHMARK(DeserializeBlockTest, 130);\n BENCHMARK(DeserializeAndCheckBlockTest, 160);"
      },
      {
        "sha": "e61c52a0cf75f5d6b3acca96756697efba17ed1a",
        "filename": "src/bench/checkqueue.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 19,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/checkqueue.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/checkqueue.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkqueue.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -22,41 +22,41 @@ static const unsigned int QUEUE_BATCH_SIZE = 128;\n // where checks all contain a prevector that is indirect 50% of the time\n // and there is a little bit of work done between calls to Add.\n static void CCheckQueueSpeedPrevectorJob(benchmark::State& state)\n-{\n-    struct PrevectorJob {\n+<%\n+    struct PrevectorJob <%\n         prevector<PREVECTOR_SIZE, uint8_t> p;\n-        PrevectorJob(){\n-        }\n-        explicit PrevectorJob(FastRandomContext& insecure_rand){\n+        PrevectorJob()<%\n+        %>\n+        explicit PrevectorJob(FastRandomContext& insecure_rand)<%\n             p.resize(insecure_rand.randrange(PREVECTOR_SIZE*2));\n-        }\n+        %>\n         bool operator()()\n-        {\n+        <%\n             return true;\n-        }\n-        void swap(PrevectorJob& x){p.swap(x.p);};\n-    };\n-    CCheckQueue<PrevectorJob> queue {QUEUE_BATCH_SIZE};\n+        %>\n+        void swap(PrevectorJob& x)<%p.swap(x.p);%>;\n+    %>;\n+    CCheckQueue<PrevectorJob> queue <%QUEUE_BATCH_SIZE%>;\n     boost::thread_group tg;\n-    for (auto x = 0; x < std::max(MIN_CORES, GetNumCores()); ++x) {\n-       tg.create_thread([&]{queue.Thread();});\n-    }\n-    while (state.KeepRunning()) {\n+    for (auto x = 0; x < std::max(MIN_CORES, GetNumCores()); ++x) <%\n+       tg.create_thread([&]<%queue.Thread();%>);\n+    %>\n+    while (state.KeepRunning()) <%\n         // Make insecure_rand here so that each iteration is identical.\n         FastRandomContext insecure_rand(true);\n         CCheckQueueControl<PrevectorJob> control(&queue);\n         std::vector<std::vector<PrevectorJob>> vBatches(BATCHES);\n-        for (auto& vChecks : vBatches) {\n+        for (auto& vChecks : vBatches) <%\n             vChecks.reserve(BATCH_SIZE);\n             for (size_t x = 0; x < BATCH_SIZE; ++x)\n                 vChecks.emplace_back(insecure_rand);\n             control.Add(vChecks);\n-        }\n+        %>\n         // control waits for completion by RAII, but\n         // it is done explicitly here for clarity\n         control.Wait();\n-    }\n+    %>\n     tg.interrupt_all();\n     tg.join_all();\n-}\n+%>\n BENCHMARK(CCheckQueueSpeedPrevectorJob, 1400);"
      },
      {
        "sha": "f4187b938618d314d38f2557abaa13c7ca94c840",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 20,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -10,14 +10,14 @@\n #include <set>\n \n static void addCoin(const CAmount& nValue, const CWallet& wallet, std::vector<std::unique_ptr<CWalletTx>>& wtxs)\n-{\n+<%\n     static int nextLockTime = 0;\n     CMutableTransaction tx;\n     tx.nLockTime = nextLockTime++; // so all transactions get different hashes\n     tx.vout.resize(1);\n     tx.vout[0].nValue = nValue;\n     wtxs.push_back(MakeUnique<CWalletTx>(&wallet, MakeTransactionRef(std::move(tx))));\n-}\n+%>\n \n // Simple benchmark for wallet coin selection. Note that it maybe be necessary\n // to build up more complicated scenarios in order to get meaningful\n@@ -27,37 +27,37 @@ static void addCoin(const CAmount& nValue, const CWallet& wallet, std::vector<st\n // either for measurements.\"\n // (https://github.com/bitcoin/bitcoin/issues/7883#issuecomment-224807484)\n static void CoinSelection(benchmark::State& state)\n-{\n+<%\n     auto chain = interfaces::MakeChain();\n     const CWallet wallet(*chain, WalletLocation(), WalletDatabase::CreateDummy());\n     std::vector<std::unique_ptr<CWalletTx>> wtxs;\n     LOCK(wallet.cs_wallet);\n \n     // Add coins.\n-    for (int i = 0; i < 1000; ++i) {\n+    for (int i = 0; i < 1000; ++i) <%\n         addCoin(1000 * COIN, wallet, wtxs);\n-    }\n+    %>\n     addCoin(3 * COIN, wallet, wtxs);\n \n     // Create groups\n     std::vector<OutputGroup> groups;\n-    for (const auto& wtx : wtxs) {\n+    for (const auto& wtx : wtxs) <%\n         COutput output(wtx.get(), 0 /* iIn */, 6 * 24 /* nDepthIn */, true /* spendable */, true /* solvable */, true /* safe */);\n         groups.emplace_back(output.GetInputCoin(), 6, false, 0, 0);\n-    }\n+    %>\n \n     const CoinEligibilityFilter filter_standard(1, 6, 0);\n     const CoinSelectionParams coin_selection_params(true, 34, 148, CFeeRate(0), 0);\n-    while (state.KeepRunning()) {\n+    while (state.KeepRunning()) <%\n         std::set<CInputCoin> setCoinsRet;\n         CAmount nValueRet;\n         bool bnb_used;\n         bool success = wallet.SelectCoinsMinConf(1003 * COIN, filter_standard, groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used);\n         assert(success);\n         assert(nValueRet == 1003 * COIN);\n         assert(setCoinsRet.size() == 2);\n-    }\n-}\n+    %>\n+%>\n \n typedef std::set<CInputCoin> CoinSet;\n static auto testChain = interfaces::MakeChain();\n@@ -66,45 +66,45 @@ std::vector<std::unique_ptr<CWalletTx>> wtxn;\n \n // Copied from src/wallet/test/coinselector_tests.cpp\n static void add_coin(const CAmount& nValue, int nInput, std::vector<OutputGroup>& set)\n-{\n+<%\n     CMutableTransaction tx;\n     tx.vout.resize(nInput + 1);\n     tx.vout[nInput].nValue = nValue;\n     std::unique_ptr<CWalletTx> wtx = MakeUnique<CWalletTx>(&testWallet, MakeTransactionRef(std::move(tx)));\n     set.emplace_back(COutput(wtx.get(), nInput, 0, true, true, true).GetInputCoin(), 0, true, 0, 0);\n     wtxn.emplace_back(std::move(wtx));\n-}\n+%>\n // Copied from src/wallet/test/coinselector_tests.cpp\n static CAmount make_hard_case(int utxos, std::vector<OutputGroup>& utxo_pool)\n-{\n+<%\n     utxo_pool.clear();\n     CAmount target = 0;\n-    for (int i = 0; i < utxos; ++i) {\n+    for (int i = 0; i < utxos; ++i) <%\n         target += (CAmount)1 << (utxos+i);\n         add_coin((CAmount)1 << (utxos+i), 2*i, utxo_pool);\n         add_coin(((CAmount)1 << (utxos+i)) + ((CAmount)1 << (utxos-1-i)), 2*i + 1, utxo_pool);\n-    }\n+    %>\n     return target;\n-}\n+%>\n \n static void BnBExhaustion(benchmark::State& state)\n-{\n+<%\n     // Setup\n     std::vector<OutputGroup> utxo_pool;\n     CoinSet selection;\n     CAmount value_ret = 0;\n     CAmount not_input_fees = 0;\n \n-    while (state.KeepRunning()) {\n+    while (state.KeepRunning()) <%\n         // Benchmark\n         CAmount target = make_hard_case(17, utxo_pool);\n         SelectCoinsBnB(utxo_pool, target, 0, selection, value_ret, not_input_fees); // Should exhaust\n \n         // Cleanup\n         utxo_pool.clear();\n         selection.clear();\n-    }\n-}\n+    %>\n+%>\n \n BENCHMARK(CoinSelection, 650);\n BENCHMARK(BnBExhaustion, 650);"
      },
      {
        "sha": "0164db6337a7dcd336dd832f0b57bc4f01d61759",
        "filename": "src/bench/crypto_hash.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 28,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/crypto_hash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/crypto_hash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/crypto_hash.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -20,79 +20,79 @@\n static const uint64_t BUFFER_SIZE = 1000*1000;\n \n static void RIPEMD160(benchmark::State& state)\n-{\n+<%\n     uint8_t hash[CRIPEMD160::OUTPUT_SIZE];\n     std::vector<uint8_t> in(BUFFER_SIZE,0);\n     while (state.KeepRunning())\n         CRIPEMD160().Write(in.data(), in.size()).Finalize(hash);\n-}\n+%>\n \n static void SHA1(benchmark::State& state)\n-{\n+<%\n     uint8_t hash[CSHA1::OUTPUT_SIZE];\n     std::vector<uint8_t> in(BUFFER_SIZE,0);\n     while (state.KeepRunning())\n         CSHA1().Write(in.data(), in.size()).Finalize(hash);\n-}\n+%>\n \n static void SHA256(benchmark::State& state)\n-{\n+<%\n     uint8_t hash[CSHA256::OUTPUT_SIZE];\n     std::vector<uint8_t> in(BUFFER_SIZE,0);\n     while (state.KeepRunning())\n         CSHA256().Write(in.data(), in.size()).Finalize(hash);\n-}\n+%>\n \n static void SHA256_32b(benchmark::State& state)\n-{\n+<%\n     std::vector<uint8_t> in(32,0);\n-    while (state.KeepRunning()) {\n+    while (state.KeepRunning()) <%\n         CSHA256()\n             .Write(in.data(), in.size())\n             .Finalize(in.data());\n-    }\n-}\n+    %>\n+%>\n \n static void SHA256D64_1024(benchmark::State& state)\n-{\n+<%\n     std::vector<uint8_t> in(64 * 1024, 0);\n-    while (state.KeepRunning()) {\n+    while (state.KeepRunning()) <%\n         SHA256D64(in.data(), in.data(), 1024);\n-    }\n-}\n+    %>\n+%>\n \n static void SHA512(benchmark::State& state)\n-{\n+<%\n     uint8_t hash[CSHA512::OUTPUT_SIZE];\n     std::vector<uint8_t> in(BUFFER_SIZE,0);\n     while (state.KeepRunning())\n         CSHA512().Write(in.data(), in.size()).Finalize(hash);\n-}\n+%>\n \n static void SipHash_32b(benchmark::State& state)\n-{\n+<%\n     uint256 x;\n     uint64_t k1 = 0;\n-    while (state.KeepRunning()) {\n+    while (state.KeepRunning()) <%\n         *((uint64_t*)x.begin()) = SipHashUint256(0, ++k1, x);\n-    }\n-}\n+    %>\n+%>\n \n static void FastRandom_32bit(benchmark::State& state)\n-{\n+<%\n     FastRandomContext rng(true);\n-    while (state.KeepRunning()) {\n+    while (state.KeepRunning()) <%\n         rng.rand32();\n-    }\n-}\n+    %>\n+%>\n \n static void FastRandom_1bit(benchmark::State& state)\n-{\n+<%\n     FastRandomContext rng(true);\n-    while (state.KeepRunning()) {\n+    while (state.KeepRunning()) <%\n         rng.randbool();\n-    }\n-}\n+    %>\n+%>\n \n BENCHMARK(RIPEMD160, 440);\n BENCHMARK(SHA1, 570);"
      },
      {
        "sha": "7e0c55e1327f88494cc793df8fdc76d67efc727f",
        "filename": "src/bench/duplicate_inputs.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/duplicate_inputs.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/duplicate_inputs.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/duplicate_inputs.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -24,8 +24,8 @@\n \n \n static void DuplicateInputs(benchmark::State& state)\n-{\n-    const CScript SCRIPT_PUB{CScript(OP_TRUE)};\n+<%\n+    const CScript SCRIPT_PUB<%CScript(OP_TRUE)%>;\n \n     // Switch to regtest so we can mine faster\n     // Also segwit is active, so we can include witness transactions\n@@ -36,26 +36,26 @@ static void DuplicateInputs(benchmark::State& state)\n     boost::thread_group thread_group;\n     CScheduler scheduler;\n     const CChainParams& chainparams = Params();\n-    {\n+    <%\n         LOCK(cs_main);\n         ::pblocktree.reset(new CBlockTreeDB(1 << 20, true));\n         ::pcoinsdbview.reset(new CCoinsViewDB(1 << 23, true));\n         ::pcoinsTip.reset(new CCoinsViewCache(pcoinsdbview.get()));\n-    }\n-    {\n+    %>\n+    <%\n         thread_group.create_thread(std::bind(&CScheduler::serviceQueue, &scheduler));\n         GetMainSignals().RegisterBackgroundSignalScheduler(scheduler);\n         LoadGenesisBlock(chainparams);\n         CValidationState cvstate;\n         ActivateBestChain(cvstate, chainparams);\n         assert(::chainActive.Tip() != nullptr);\n-        const bool witness_enabled{IsWitnessEnabled(::chainActive.Tip(), chainparams.GetConsensus())};\n+        const bool witness_enabled<%IsWitnessEnabled(::chainActive.Tip(), chainparams.GetConsensus())%>;\n         assert(witness_enabled);\n-    }\n+    %>\n \n-    CBlock block{};\n-    CMutableTransaction coinbaseTx{};\n-    CMutableTransaction naughtyTx{};\n+    CBlock block<%%>;\n+    CMutableTransaction coinbaseTx<%%>;\n+    CMutableTransaction naughtyTx<%%>;\n \n     CBlockIndex* pindexPrev = ::chainActive.Tip();\n     assert(pindexPrev != nullptr);\n@@ -77,26 +77,26 @@ static void DuplicateInputs(benchmark::State& state)\n     naughtyTx.vout[0].scriptPubKey = SCRIPT_PUB;\n \n     uint64_t n_inputs = (((MAX_BLOCK_SERIALIZED_SIZE / WITNESS_SCALE_FACTOR) - (CTransaction(coinbaseTx).GetTotalSize() + CTransaction(naughtyTx).GetTotalSize())) / 41) - 100;\n-    for (uint64_t x = 0; x < (n_inputs - 1); ++x) {\n+    for (uint64_t x = 0; x < (n_inputs - 1); ++x) <%\n         naughtyTx.vin.emplace_back(GetRandHash(), 0, CScript(), 0);\n-    }\n+    %>\n     naughtyTx.vin.emplace_back(naughtyTx.vin.back());\n \n     block.vtx.push_back(MakeTransactionRef(std::move(coinbaseTx)));\n     block.vtx.push_back(MakeTransactionRef(std::move(naughtyTx)));\n \n     block.hashMerkleRoot = BlockMerkleRoot(block);\n \n-    while (state.KeepRunning()) {\n-        CValidationState cvstate{};\n+    while (state.KeepRunning()) <%\n+        CValidationState cvstate<%%>;\n         assert(!CheckBlock(block, cvstate, chainparams.GetConsensus(), false, false));\n         assert(cvstate.GetRejectReason() == \"bad-txns-inputs-duplicate\");\n-    }\n+    %>\n \n     thread_group.interrupt_all();\n     thread_group.join_all();\n     GetMainSignals().FlushBackgroundCallbacks();\n     GetMainSignals().UnregisterBackgroundSignalScheduler();\n-}\n+%>\n \n BENCHMARK(DuplicateInputs, 10);"
      },
      {
        "sha": "718884ff3439588c8f8321f288e52bae15b8767e",
        "filename": "src/bench/examples.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/examples.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/examples.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/examples.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -9,11 +9,11 @@\n // Sanity test: this should loop ten times, and\n // min/max/average should be close to 100ms.\n static void Sleep100ms(benchmark::State& state)\n-{\n-    while (state.KeepRunning()) {\n+<%\n+    while (state.KeepRunning()) <%\n         MilliSleep(100);\n-    }\n-}\n+    %>\n+%>\n \n BENCHMARK(Sleep100ms, 10);\n \n@@ -23,12 +23,12 @@ BENCHMARK(Sleep100ms, 10);\n volatile double sum = 0.0; // volatile, global so not optimized away\n \n static void Trig(benchmark::State& state)\n-{\n+<%\n     double d = 0.01;\n-    while (state.KeepRunning()) {\n+    while (state.KeepRunning()) <%\n         sum += sin(d);\n         d += 0.000001;\n-    }\n-}\n+    %>\n+%>\n \n BENCHMARK(Trig, 12 * 1000 * 1000);"
      },
      {
        "sha": "1464a05ca9b90bf93e360496e9c547eb2f1d3d52",
        "filename": "src/bench/gcs_filter.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/gcs_filter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/gcs_filter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/gcs_filter.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -6,38 +6,38 @@\n #include <blockfilter.h>\n \n static void ConstructGCSFilter(benchmark::State& state)\n-{\n+<%\n     GCSFilter::ElementSet elements;\n-    for (int i = 0; i < 10000; ++i) {\n+    for (int i = 0; i < 10000; ++i) <%\n         GCSFilter::Element element(32);\n         element[0] = static_cast<unsigned char>(i);\n         element[1] = static_cast<unsigned char>(i >> 8);\n         elements.insert(std::move(element));\n-    }\n+    %>\n \n     uint64_t siphash_k0 = 0;\n-    while (state.KeepRunning()) {\n-        GCSFilter filter({siphash_k0, 0, 20, 1 << 20}, elements);\n+    while (state.KeepRunning()) <%\n+        GCSFilter filter(<%siphash_k0, 0, 20, 1 << 20%>, elements);\n \n         siphash_k0++;\n-    }\n-}\n+    %>\n+%>\n \n static void MatchGCSFilter(benchmark::State& state)\n-{\n+<%\n     GCSFilter::ElementSet elements;\n-    for (int i = 0; i < 10000; ++i) {\n+    for (int i = 0; i < 10000; ++i) <%\n         GCSFilter::Element element(32);\n         element[0] = static_cast<unsigned char>(i);\n         element[1] = static_cast<unsigned char>(i >> 8);\n         elements.insert(std::move(element));\n-    }\n-    GCSFilter filter({0, 0, 20, 1 << 20}, elements);\n+    %>\n+    GCSFilter filter(<%0, 0, 20, 1 << 20%>, elements);\n \n-    while (state.KeepRunning()) {\n+    while (state.KeepRunning()) <%\n         filter.Match(GCSFilter::Element());\n-    }\n-}\n+    %>\n+%>\n \n BENCHMARK(ConstructGCSFilter, 1000);\n BENCHMARK(MatchGCSFilter, 50 * 1000);"
      },
      {
        "sha": "d7f297f8b35b0e92e3da2d1bf78cec737cb91985",
        "filename": "src/bench/lockedpool.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/lockedpool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/lockedpool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/lockedpool.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -14,7 +14,7 @@\n #define MSIZE 2048\n \n static void BenchLockedPool(benchmark::State& state)\n-{\n+<%\n     void *synth_base = reinterpret_cast<void*>(0x08000000);\n     const size_t synth_size = 1024*1024;\n     Arena b(synth_base, synth_size, 16);\n@@ -23,24 +23,24 @@ static void BenchLockedPool(benchmark::State& state)\n     for (int x=0; x<ASIZE; ++x)\n         addr.push_back(nullptr);\n     uint32_t s = 0x12345678;\n-    while (state.KeepRunning()) {\n-        for (int x=0; x<BITER; ++x) {\n+    while (state.KeepRunning()) <%\n+        for (int x=0; x<BITER; ++x) <%\n             int idx = s & (addr.size()-1);\n-            if (s & 0x80000000) {\n+            if (s & 0x80000000) <%\n                 b.free(addr[idx]);\n                 addr[idx] = nullptr;\n-            } else if(!addr[idx]) {\n+            %> else if(!addr[idx]) <%\n                 addr[idx] = b.alloc((s >> 16) & (MSIZE-1));\n-            }\n+            %>\n             bool lsb = s & 1;\n             s >>= 1;\n             if (lsb)\n                 s ^= 0xf00f00f0; // LFSR period 0xf7ffffe0\n-        }\n-    }\n+        %>\n+    %>\n     for (void *ptr: addr)\n         b.free(ptr);\n     addr.clear();\n-}\n+%>\n \n BENCHMARK(BenchLockedPool, 1300);"
      },
      {
        "sha": "efe7e393d84998b99a83d18aa078109b136b1121",
        "filename": "src/bench/mempool_eviction.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 24,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/mempool_eviction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/mempool_eviction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/mempool_eviction.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -10,7 +10,7 @@\n #include <vector>\n \n static void AddTx(const CTransactionRef& tx, const CAmount& nFee, CTxMemPool& pool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n-{\n+<%\n     int64_t nTime = 0;\n     unsigned int nHeight = 1;\n     bool spendsCoinbase = false;\n@@ -19,25 +19,25 @@ static void AddTx(const CTransactionRef& tx, const CAmount& nFee, CTxMemPool& po\n     pool.addUnchecked(CTxMemPoolEntry(\n                                          tx, nFee, nTime, nHeight,\n                                          spendsCoinbase, sigOpCost, lp));\n-}\n+%>\n \n // Right now this is only testing eviction performance in an extremely small\n // mempool. Code needs to be written to generate a much wider variety of\n // unique transactions for a more meaningful performance measurement.\n static void MempoolEviction(benchmark::State& state)\n-{\n+<%\n     CMutableTransaction tx1 = CMutableTransaction();\n     tx1.vin.resize(1);\n     tx1.vin[0].scriptSig = CScript() << OP_1;\n-    tx1.vin[0].scriptWitness.stack.push_back({1});\n+    tx1.vin[0].scriptWitness.stack.push_back(<%1%>);\n     tx1.vout.resize(1);\n     tx1.vout[0].scriptPubKey = CScript() << OP_1 << OP_EQUAL;\n     tx1.vout[0].nValue = 10 * COIN;\n \n     CMutableTransaction tx2 = CMutableTransaction();\n     tx2.vin.resize(1);\n     tx2.vin[0].scriptSig = CScript() << OP_2;\n-    tx2.vin[0].scriptWitness.stack.push_back({2});\n+    tx2.vin[0].scriptWitness.stack.push_back(<%2%>);\n     tx2.vout.resize(1);\n     tx2.vout[0].scriptPubKey = CScript() << OP_2 << OP_EQUAL;\n     tx2.vout[0].nValue = 10 * COIN;\n@@ -46,7 +46,7 @@ static void MempoolEviction(benchmark::State& state)\n     tx3.vin.resize(1);\n     tx3.vin[0].prevout = COutPoint(tx2.GetHash(), 0);\n     tx3.vin[0].scriptSig = CScript() << OP_2;\n-    tx3.vin[0].scriptWitness.stack.push_back({3});\n+    tx3.vin[0].scriptWitness.stack.push_back(<%3%>);\n     tx3.vout.resize(1);\n     tx3.vout[0].scriptPubKey = CScript() << OP_3 << OP_EQUAL;\n     tx3.vout[0].nValue = 10 * COIN;\n@@ -55,10 +55,10 @@ static void MempoolEviction(benchmark::State& state)\n     tx4.vin.resize(2);\n     tx4.vin[0].prevout.SetNull();\n     tx4.vin[0].scriptSig = CScript() << OP_4;\n-    tx4.vin[0].scriptWitness.stack.push_back({4});\n+    tx4.vin[0].scriptWitness.stack.push_back(<%4%>);\n     tx4.vin[1].prevout.SetNull();\n     tx4.vin[1].scriptSig = CScript() << OP_4;\n-    tx4.vin[1].scriptWitness.stack.push_back({4});\n+    tx4.vin[1].scriptWitness.stack.push_back(<%4%>);\n     tx4.vout.resize(2);\n     tx4.vout[0].scriptPubKey = CScript() << OP_4 << OP_EQUAL;\n     tx4.vout[0].nValue = 10 * COIN;\n@@ -69,10 +69,10 @@ static void MempoolEviction(benchmark::State& state)\n     tx5.vin.resize(2);\n     tx5.vin[0].prevout = COutPoint(tx4.GetHash(), 0);\n     tx5.vin[0].scriptSig = CScript() << OP_4;\n-    tx5.vin[0].scriptWitness.stack.push_back({4});\n+    tx5.vin[0].scriptWitness.stack.push_back(<%4%>);\n     tx5.vin[1].prevout.SetNull();\n     tx5.vin[1].scriptSig = CScript() << OP_5;\n-    tx5.vin[1].scriptWitness.stack.push_back({5});\n+    tx5.vin[1].scriptWitness.stack.push_back(<%5%>);\n     tx5.vout.resize(2);\n     tx5.vout[0].scriptPubKey = CScript() << OP_5 << OP_EQUAL;\n     tx5.vout[0].nValue = 10 * COIN;\n@@ -83,10 +83,10 @@ static void MempoolEviction(benchmark::State& state)\n     tx6.vin.resize(2);\n     tx6.vin[0].prevout = COutPoint(tx4.GetHash(), 1);\n     tx6.vin[0].scriptSig = CScript() << OP_4;\n-    tx6.vin[0].scriptWitness.stack.push_back({4});\n+    tx6.vin[0].scriptWitness.stack.push_back(<%4%>);\n     tx6.vin[1].prevout.SetNull();\n     tx6.vin[1].scriptSig = CScript() << OP_6;\n-    tx6.vin[1].scriptWitness.stack.push_back({6});\n+    tx6.vin[1].scriptWitness.stack.push_back(<%6%>);\n     tx6.vout.resize(2);\n     tx6.vout[0].scriptPubKey = CScript() << OP_6 << OP_EQUAL;\n     tx6.vout[0].nValue = 10 * COIN;\n@@ -97,10 +97,10 @@ static void MempoolEviction(benchmark::State& state)\n     tx7.vin.resize(2);\n     tx7.vin[0].prevout = COutPoint(tx5.GetHash(), 0);\n     tx7.vin[0].scriptSig = CScript() << OP_5;\n-    tx7.vin[0].scriptWitness.stack.push_back({5});\n+    tx7.vin[0].scriptWitness.stack.push_back(<%5%>);\n     tx7.vin[1].prevout = COutPoint(tx6.GetHash(), 0);\n     tx7.vin[1].scriptSig = CScript() << OP_6;\n-    tx7.vin[1].scriptWitness.stack.push_back({6});\n+    tx7.vin[1].scriptWitness.stack.push_back(<%6%>);\n     tx7.vout.resize(2);\n     tx7.vout[0].scriptPubKey = CScript() << OP_7 << OP_EQUAL;\n     tx7.vout[0].nValue = 10 * COIN;\n@@ -110,15 +110,15 @@ static void MempoolEviction(benchmark::State& state)\n     CTxMemPool pool;\n     LOCK2(cs_main, pool.cs);\n     // Create transaction references outside the \"hot loop\"\n-    const CTransactionRef tx1_r{MakeTransactionRef(tx1)};\n-    const CTransactionRef tx2_r{MakeTransactionRef(tx2)};\n-    const CTransactionRef tx3_r{MakeTransactionRef(tx3)};\n-    const CTransactionRef tx4_r{MakeTransactionRef(tx4)};\n-    const CTransactionRef tx5_r{MakeTransactionRef(tx5)};\n-    const CTransactionRef tx6_r{MakeTransactionRef(tx6)};\n-    const CTransactionRef tx7_r{MakeTransactionRef(tx7)};\n+    const CTransactionRef tx1_r<%MakeTransactionRef(tx1)%>;\n+    const CTransactionRef tx2_r<%MakeTransactionRef(tx2)%>;\n+    const CTransactionRef tx3_r<%MakeTransactionRef(tx3)%>;\n+    const CTransactionRef tx4_r<%MakeTransactionRef(tx4)%>;\n+    const CTransactionRef tx5_r<%MakeTransactionRef(tx5)%>;\n+    const CTransactionRef tx6_r<%MakeTransactionRef(tx6)%>;\n+    const CTransactionRef tx7_r<%MakeTransactionRef(tx7)%>;\n \n-    while (state.KeepRunning()) {\n+    while (state.KeepRunning()) <%\n         AddTx(tx1_r, 10000LL, pool);\n         AddTx(tx2_r, 5000LL, pool);\n         AddTx(tx3_r, 20000LL, pool);\n@@ -128,7 +128,7 @@ static void MempoolEviction(benchmark::State& state)\n         AddTx(tx7_r, 9000LL, pool);\n         pool.TrimToSize(pool.DynamicMemoryUsage() * 3 / 4);\n         pool.TrimToSize(GetVirtualTransactionSize(*tx1_r));\n-    }\n-}\n+    %>\n+%>\n \n BENCHMARK(MempoolEviction, 41000);"
      },
      {
        "sha": "0f3fce3727c8becc5aacc6d05b2f8679ae2cfa8f",
        "filename": "src/bench/merkle_root.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/merkle_root.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/merkle_root.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/merkle_root.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -9,18 +9,18 @@\n #include <consensus/merkle.h>\n \n static void MerkleRoot(benchmark::State& state)\n-{\n+<%\n     FastRandomContext rng(true);\n     std::vector<uint256> leaves;\n     leaves.resize(9001);\n-    for (auto& item : leaves) {\n+    for (auto& item : leaves) <%\n         item = rng.rand256();\n-    }\n-    while (state.KeepRunning()) {\n+    %>\n+    while (state.KeepRunning()) <%\n         bool mutation = false;\n         uint256 hash = ComputeMerkleRoot(std::vector<uint256>(leaves), &mutation);\n         leaves[mutation] = hash;\n-    }\n-}\n+    %>\n+%>\n \n BENCHMARK(MerkleRoot, 800);"
      },
      {
        "sha": "0a00ded1ca24f3b7bfcb2310965237a52ce53754",
        "filename": "src/bench/poly1305.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/poly1305.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/poly1305.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/poly1305.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -13,28 +13,28 @@ static constexpr uint64_t BUFFER_SIZE_SMALL = 256;\n static constexpr uint64_t BUFFER_SIZE_LARGE = 1024*1024;\n \n static void POLY1305(benchmark::State& state, size_t buffersize)\n-{\n+<%\n     std::vector<unsigned char> tag(POLY1305_TAGLEN, 0);\n     std::vector<unsigned char> key(POLY1305_KEYLEN, 0);\n     std::vector<unsigned char> in(buffersize, 0);\n     while (state.KeepRunning())\n         poly1305_auth(tag.data(), in.data(), in.size(), key.data());\n-}\n+%>\n \n static void POLY1305_64BYTES(benchmark::State& state)\n-{\n+<%\n     POLY1305(state, BUFFER_SIZE_TINY);\n-}\n+%>\n \n static void POLY1305_256BYTES(benchmark::State& state)\n-{\n+<%\n     POLY1305(state, BUFFER_SIZE_SMALL);\n-}\n+%>\n \n static void POLY1305_1MB(benchmark::State& state)\n-{\n+<%\n     POLY1305(state, BUFFER_SIZE_LARGE);\n-}\n+%>\n \n BENCHMARK(POLY1305_64BYTES, 500000);\n BENCHMARK(POLY1305_256BYTES, 250000);"
      },
      {
        "sha": "3cfa9e687b30883d5c84e4876e818aa443b1863e",
        "filename": "src/bench/prevector.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 36,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/prevector.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/prevector.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/prevector.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -17,13 +17,13 @@\n #define IS_TRIVIALLY_CONSTRUCTIBLE std::is_trivially_default_constructible\n #endif\n \n-struct nontrivial_t {\n+struct nontrivial_t <%\n     int x;\n-    nontrivial_t() :x(-1) {}\n+    nontrivial_t() :x(-1) <%%>\n     ADD_SERIALIZE_METHODS\n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action) {READWRITE(x);}\n-};\n+    inline void SerializationOp(Stream& s, Operation ser_action) <%READWRITE(x);%>\n+%>;\n static_assert(!IS_TRIVIALLY_CONSTRUCTIBLE<nontrivial_t>::value,\n               \"expected nontrivial_t to not be trivially constructible\");\n \n@@ -33,78 +33,78 @@ static_assert(IS_TRIVIALLY_CONSTRUCTIBLE<trivial_t>::value,\n \n template <typename T>\n static void PrevectorDestructor(benchmark::State& state)\n-{\n-    while (state.KeepRunning()) {\n-        for (auto x = 0; x < 1000; ++x) {\n+<%\n+    while (state.KeepRunning()) <%\n+        for (auto x = 0; x < 1000; ++x) <%\n             prevector<28, T> t0;\n             prevector<28, T> t1;\n             t0.resize(28);\n             t1.resize(29);\n-        }\n-    }\n-}\n+        %>\n+    %>\n+%>\n \n template <typename T>\n static void PrevectorClear(benchmark::State& state)\n-{\n+<%\n \n-    while (state.KeepRunning()) {\n-        for (auto x = 0; x < 1000; ++x) {\n+    while (state.KeepRunning()) <%\n+        for (auto x = 0; x < 1000; ++x) <%\n             prevector<28, T> t0;\n             prevector<28, T> t1;\n             t0.resize(28);\n             t0.clear();\n             t1.resize(29);\n             t1.clear();\n-        }\n-    }\n-}\n+        %>\n+    %>\n+%>\n \n template <typename T>\n static void PrevectorResize(benchmark::State& state)\n-{\n-    while (state.KeepRunning()) {\n+<%\n+    while (state.KeepRunning()) <%\n         prevector<28, T> t0;\n         prevector<28, T> t1;\n-        for (auto x = 0; x < 1000; ++x) {\n+        for (auto x = 0; x < 1000; ++x) <%\n             t0.resize(28);\n             t0.resize(0);\n             t1.resize(29);\n             t1.resize(0);\n-        }\n-    }\n-}\n+        %>\n+    %>\n+%>\n \n template <typename T>\n static void PrevectorDeserialize(benchmark::State& state)\n-{\n+<%\n     CDataStream s0(SER_NETWORK, 0);\n     prevector<28, T> t0;\n     t0.resize(28);\n-    for (auto x = 0; x < 900; ++x) {\n+    for (auto x = 0; x < 900; ++x) <%\n         s0 << t0;\n-    }\n+    %>\n     t0.resize(100);\n-    for (auto x = 0; x < 101; ++x) {\n+    for (auto x = 0; x < 101; ++x) <%\n         s0 << t0;\n-    }\n-    while (state.KeepRunning()) {\n+    %>\n+    while (state.KeepRunning()) <%\n         prevector<28, T> t1;\n-        for (auto x = 0; x < 1000; ++x) {\n+        for (auto x = 0; x < 1000; ++x) <%\n             s0 >> t1;\n-        }\n+        %>\n         s0.Init(SER_NETWORK, 0);\n-    }\n-}\n+    %>\n+%>\n \n #define PREVECTOR_TEST(name, nontrivops, trivops)                       \\\n-    static void Prevector ## name ## Nontrivial(benchmark::State& state) { \\\n+    static void Prevector ## name ## Nontrivial(benchmark::State& state) <% \\\n         Prevector ## name<nontrivial_t>(state);                         \\\n-    }                                                                   \\\n+    %>                                                                   \\\n     BENCHMARK(Prevector ## name ## Nontrivial, nontrivops);             \\\n-    static void Prevector ## name ## Trivial(benchmark::State& state) { \\\n+    static void Prevector ## name ## Trivial(benchmark::State& state) <% \\\n         Prevector ## name<trivial_t>(state);                            \\\n-    }                                                                   \\\n+    %>                                                                   \\\n     BENCHMARK(Prevector ## name ## Trivial, trivops);\n \n PREVECTOR_TEST(Clear, 28300, 88600)"
      },
      {
        "sha": "82813a0bc3da5c4ee144fe4da0cda2078e3271e9",
        "filename": "src/bench/rollingbloom.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/rollingbloom.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/rollingbloom.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/rollingbloom.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -8,11 +8,11 @@\n #include <bloom.h>\n \n static void RollingBloom(benchmark::State& state)\n-{\n+<%\n     CRollingBloomFilter filter(120000, 0.000001);\n     std::vector<unsigned char> data(32);\n     uint32_t count = 0;\n-    while (state.KeepRunning()) {\n+    while (state.KeepRunning()) <%\n         count++;\n         data[0] = count;\n         data[1] = count >> 8;\n@@ -25,7 +25,7 @@ static void RollingBloom(benchmark::State& state)\n         data[2] = count >> 8;\n         data[3] = count;\n         filter.contains(data);\n-    }\n-}\n+    %>\n+%>\n \n BENCHMARK(RollingBloom, 1500 * 1000);"
      },
      {
        "sha": "78727e28feec752b212d288315ddb33942cbf648",
        "filename": "src/bench/rpc_mempool.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/rpc_mempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/rpc_mempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/rpc_mempool.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -13,31 +13,31 @@\n #include <vector>\n \n static void AddTx(const CTransactionRef& tx, const CAmount& fee, CTxMemPool& pool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n-{\n+<%\n     LockPoints lp;\n     pool.addUnchecked(CTxMemPoolEntry(tx, fee, /* time */ 0, /* height */ 1, /* spendsCoinbase */ false, /* sigOpCost */ 4, lp));\n-}\n+%>\n \n static void RpcMempool(benchmark::State& state)\n-{\n+<%\n     CTxMemPool pool;\n     LOCK2(cs_main, pool.cs);\n \n-    for (int i = 0; i < 1000; ++i) {\n+    for (int i = 0; i < 1000; ++i) <%\n         CMutableTransaction tx = CMutableTransaction();\n         tx.vin.resize(1);\n         tx.vin[0].scriptSig = CScript() << OP_1;\n-        tx.vin[0].scriptWitness.stack.push_back({1});\n+        tx.vin[0].scriptWitness.stack.push_back(<%1%>);\n         tx.vout.resize(1);\n         tx.vout[0].scriptPubKey = CScript() << OP_1 << OP_EQUAL;\n         tx.vout[0].nValue = i;\n-        const CTransactionRef tx_r{MakeTransactionRef(tx)};\n+        const CTransactionRef tx_r<%MakeTransactionRef(tx)%>;\n         AddTx(tx_r, /* fee */ i, pool);\n-    }\n+    %>\n \n-    while (state.KeepRunning()) {\n+    while (state.KeepRunning()) <%\n         (void)MempoolToJSON(pool, /*verbose*/ true);\n-    }\n-}\n+    %>\n+%>\n \n BENCHMARK(RpcMempool, 40);"
      },
      {
        "sha": "d4454444a4569b095349861d034b80f3b002c056",
        "filename": "src/bench/verify_script.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/verify_script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bench/verify_script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/verify_script.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -16,7 +16,7 @@\n \n // FIXME: Dedup with BuildCreditingTransaction in test/script_tests.cpp.\n static CMutableTransaction BuildCreditingTransaction(const CScript& scriptPubKey)\n-{\n+<%\n     CMutableTransaction txCredit;\n     txCredit.nVersion = 1;\n     txCredit.nLockTime = 0;\n@@ -29,11 +29,11 @@ static CMutableTransaction BuildCreditingTransaction(const CScript& scriptPubKey\n     txCredit.vout[0].nValue = 1;\n \n     return txCredit;\n-}\n+%>\n \n // FIXME: Dedup with BuildSpendingTransaction in test/script_tests.cpp.\n static CMutableTransaction BuildSpendingTransaction(const CScript& scriptSig, const CMutableTransaction& txCredit)\n-{\n+<%\n     CMutableTransaction txSpend;\n     txSpend.nVersion = 1;\n     txSpend.nLockTime = 0;\n@@ -47,22 +47,22 @@ static CMutableTransaction BuildSpendingTransaction(const CScript& scriptSig, co\n     txSpend.vout[0].nValue = txCredit.vout[0].nValue;\n \n     return txSpend;\n-}\n+%>\n \n // Microbenchmark for verification of a basic P2WPKH script. Can be easily\n // modified to measure performance of other types of scripts.\n static void VerifyScriptBench(benchmark::State& state)\n-{\n+<%\n     const int flags = SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH;\n     const int witnessversion = 0;\n \n     // Keypair.\n     CKey key;\n-    static const std::array<unsigned char, 32> vchKey = {\n-        {\n+    static const std::array<unsigned char, 32> vchKey = <%\n+        <%\n             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1\n-        }\n-    };\n+        %>\n+    %>;\n     key.Set(vchKey.begin(), vchKey.end(), false);\n     CPubKey pubkey = key.GetPubKey();\n     uint160 pubkeyHash;\n@@ -81,7 +81,7 @@ static void VerifyScriptBench(benchmark::State& state)\n     witness.stack.push_back(ToByteVector(pubkey));\n \n     // Benchmark.\n-    while (state.KeepRunning()) {\n+    while (state.KeepRunning()) <%\n         ScriptError err;\n         bool success = VerifyScript(\n             txSpend.vin[0].scriptSig,\n@@ -103,7 +103,7 @@ static void VerifyScriptBench(benchmark::State& state)\n             (const unsigned char*)stream.data(), stream.size(), 0, flags, nullptr);\n         assert(csuccess == 1);\n #endif\n-    }\n-}\n+    %>\n+%>\n \n BENCHMARK(VerifyScriptBench, 6300);"
      },
      {
        "sha": "cb49b4ed37467b1619d68d77672333c4b2f66fc3",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 144,
        "deletions": 144,
        "changes": 288,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -33,7 +33,7 @@ static const bool DEFAULT_NAMED=false;\n static const int CONTINUE_EXECUTION=-1;\n \n static void SetupCliArgs()\n-{\n+<%\n     SetupHelpOptions(gArgs);\n \n     const auto defaultBaseParams = CreateBaseChainParams(CBaseChainParams::MAIN);\n@@ -56,19 +56,19 @@ static void SetupCliArgs()\n     gArgs.AddArg(\"-rpcwallet=<walletname>\", \"Send RPC for non-default wallet on RPC server (needs to exactly match corresponding -wallet option passed to bitcoind). This changes the RPC endpoint used, e.g. http://127.0.0.1:8332/wallet/<walletname>\", false, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-stdin\", \"Read extra arguments from standard input, one per line until EOF/Ctrl-D (recommended for sensitive information such as passphrases). When combined with -stdinrpcpass, the first line from standard input is used for the RPC password.\", false, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-stdinrpcpass\", \"Read RPC password from standard input as a single line. When combined with -stdin, the first line from standard input is used for the RPC password.\", false, OptionsCategory::OPTIONS);\n-}\n+%>\n \n /** libevent event log callback */\n static void libevent_log_cb(int severity, const char *msg)\n-{\n+<%\n #ifndef EVENT_LOG_ERR // EVENT_LOG_ERR was added in 2.0.19; but before then _EVENT_LOG_ERR existed.\n # define EVENT_LOG_ERR _EVENT_LOG_ERR\n #endif\n     // Ignore everything other than errors\n-    if (severity >= EVENT_LOG_ERR) {\n+    if (severity >= EVENT_LOG_ERR) <%\n         throw std::runtime_error(strprintf(\"libevent error: %s\", msg));\n-    }\n-}\n+    %>\n+%>\n \n //////////////////////////////////////////////////////////////////////////////\n //\n@@ -80,80 +80,80 @@ static void libevent_log_cb(int severity, const char *msg)\n // when to wait if -rpcwait is given.\n //\n class CConnectionFailed : public std::runtime_error\n-{\n+<%\n public:\n \n     explicit inline CConnectionFailed(const std::string& msg) :\n         std::runtime_error(msg)\n-    {}\n+    <%%>\n \n-};\n+%>;\n \n //\n // This function returns either one of EXIT_ codes when it's expected to stop the process or\n // CONTINUE_EXECUTION when it's expected to continue further.\n //\n static int AppInitRPC(int argc, char* argv[])\n-{\n+<%\n     //\n     // Parameters\n     //\n     SetupCliArgs();\n     std::string error;\n-    if (!gArgs.ParseParameters(argc, argv, error)) {\n+    if (!gArgs.ParseParameters(argc, argv, error)) <%\n         fprintf(stderr, \"Error parsing command line arguments: %s\\n\", error.c_str());\n         return EXIT_FAILURE;\n-    }\n-    if (argc < 2 || HelpRequested(gArgs) || gArgs.IsArgSet(\"-version\")) {\n+    %>\n+    if (argc < 2 || HelpRequested(gArgs) || gArgs.IsArgSet(\"-version\")) <%\n         std::string strUsage = PACKAGE_NAME \" RPC client version \" + FormatFullVersion() + \"\\n\";\n-        if (!gArgs.IsArgSet(\"-version\")) {\n+        if (!gArgs.IsArgSet(\"-version\")) <%\n             strUsage += \"\\n\"\n                 \"Usage:  bitcoin-cli [options] <command> [params]  Send command to \" PACKAGE_NAME \"\\n\"\n                 \"or:     bitcoin-cli [options] -named <command> [name=value]...  Send command to \" PACKAGE_NAME \" (with named arguments)\\n\"\n                 \"or:     bitcoin-cli [options] help                List commands\\n\"\n                 \"or:     bitcoin-cli [options] help <command>      Get help for a command\\n\";\n             strUsage += \"\\n\" + gArgs.GetHelpMessage();\n-        }\n+        %>\n \n         fprintf(stdout, \"%s\", strUsage.c_str());\n-        if (argc < 2) {\n+        if (argc < 2) <%\n             fprintf(stderr, \"Error: too few parameters\\n\");\n             return EXIT_FAILURE;\n-        }\n+        %>\n         return EXIT_SUCCESS;\n-    }\n-    if (!fs::is_directory(GetDataDir(false))) {\n+    %>\n+    if (!fs::is_directory(GetDataDir(false))) <%\n         fprintf(stderr, \"Error: Specified data directory \\\"%s\\\" does not exist.\\n\", gArgs.GetArg(\"-datadir\", \"\").c_str());\n         return EXIT_FAILURE;\n-    }\n-    if (!gArgs.ReadConfigFiles(error, true)) {\n+    %>\n+    if (!gArgs.ReadConfigFiles(error, true)) <%\n         fprintf(stderr, \"Error reading configuration file: %s\\n\", error.c_str());\n         return EXIT_FAILURE;\n-    }\n+    %>\n     // Check for -testnet or -regtest parameter (BaseParams() calls are only valid after this clause)\n-    try {\n+    try <%\n         SelectBaseParams(gArgs.GetChainName());\n-    } catch (const std::exception& e) {\n+    %> catch (const std::exception& e) <%\n         fprintf(stderr, \"Error: %s\\n\", e.what());\n         return EXIT_FAILURE;\n-    }\n+    %>\n     return CONTINUE_EXECUTION;\n-}\n+%>\n \n \n /** Reply structure for request_done to fill in */\n struct HTTPReply\n-{\n-    HTTPReply(): status(0), error(-1) {}\n+<%\n+    HTTPReply(): status(0), error(-1) <%%>\n \n     int status;\n     int error;\n     std::string body;\n-};\n+%>;\n \n static const char *http_errorstring(int code)\n-{\n-    switch(code) {\n+<%\n+    switch(code) <%\n #if LIBEVENT_VERSION_NUMBER >= 0x02010300\n     case EVREQ_HTTP_TIMEOUT:\n         return \"timeout reached\";\n@@ -170,87 +170,87 @@ static const char *http_errorstring(int code)\n #endif\n     default:\n         return \"unknown\";\n-    }\n-}\n+    %>\n+%>\n \n static void http_request_done(struct evhttp_request *req, void *ctx)\n-{\n+<%\n     HTTPReply *reply = static_cast<HTTPReply*>(ctx);\n \n-    if (req == nullptr) {\n+    if (req == nullptr) <%\n         /* If req is nullptr, it means an error occurred while connecting: the\n          * error code will have been passed to http_error_cb.\n          */\n         reply->status = 0;\n         return;\n-    }\n+    %>\n \n     reply->status = evhttp_request_get_response_code(req);\n \n     struct evbuffer *buf = evhttp_request_get_input_buffer(req);\n     if (buf)\n-    {\n+    <%\n         size_t size = evbuffer_get_length(buf);\n         const char *data = (const char*)evbuffer_pullup(buf, size);\n         if (data)\n             reply->body = std::string(data, size);\n         evbuffer_drain(buf, size);\n-    }\n-}\n+    %>\n+%>\n \n #if LIBEVENT_VERSION_NUMBER >= 0x02010300\n static void http_error_cb(enum evhttp_request_error err, void *ctx)\n-{\n+<%\n     HTTPReply *reply = static_cast<HTTPReply*>(ctx);\n     reply->error = err;\n-}\n+%>\n #endif\n \n /** Class that handles the conversion from a command-line to a JSON-RPC request,\n  * as well as converting back to a JSON object that can be shown as result.\n  */\n class BaseRequestHandler\n-{\n+<%\n public:\n-    virtual ~BaseRequestHandler() {}\n+    virtual ~BaseRequestHandler() <%%>\n     virtual UniValue PrepareRequest(const std::string& method, const std::vector<std::string>& args) = 0;\n     virtual UniValue ProcessReply(const UniValue &batch_in) = 0;\n-};\n+%>;\n \n /** Process getinfo requests */\n class GetinfoRequestHandler: public BaseRequestHandler\n-{\n+<%\n public:\n     const int ID_NETWORKINFO = 0;\n     const int ID_BLOCKCHAININFO = 1;\n     const int ID_WALLETINFO = 2;\n \n     /** Create a simulated `getinfo` request. */\n     UniValue PrepareRequest(const std::string& method, const std::vector<std::string>& args) override\n-    {\n-        if (!args.empty()) {\n+    <%\n+        if (!args.empty()) <%\n             throw std::runtime_error(\"-getinfo takes no arguments\");\n-        }\n+        %>\n         UniValue result(UniValue::VARR);\n         result.push_back(JSONRPCRequestObj(\"getnetworkinfo\", NullUniValue, ID_NETWORKINFO));\n         result.push_back(JSONRPCRequestObj(\"getblockchaininfo\", NullUniValue, ID_BLOCKCHAININFO));\n         result.push_back(JSONRPCRequestObj(\"getwalletinfo\", NullUniValue, ID_WALLETINFO));\n         return result;\n-    }\n+    %>\n \n     /** Collect values from the batch and form a simulated `getinfo` reply. */\n     UniValue ProcessReply(const UniValue &batch_in) override\n-    {\n+    <%\n         UniValue result(UniValue::VOBJ);\n         std::vector<UniValue> batch = JSONRPCProcessBatchReply(batch_in, 3);\n         // Errors in getnetworkinfo() and getblockchaininfo() are fatal, pass them on\n         // getwalletinfo() is allowed to fail in case there is no wallet.\n-        if (!batch[ID_NETWORKINFO][\"error\"].isNull()) {\n+        if (!batch[ID_NETWORKINFO][\"error\"].isNull()) <%\n             return batch[ID_NETWORKINFO];\n-        }\n-        if (!batch[ID_BLOCKCHAININFO][\"error\"].isNull()) {\n+        %>\n+        if (!batch[ID_BLOCKCHAININFO][\"error\"].isNull()) <%\n             return batch[ID_BLOCKCHAININFO];\n-        }\n+        %>\n         result.pushKV(\"version\", batch[ID_NETWORKINFO][\"result\"][\"version\"]);\n         result.pushKV(\"protocolversion\", batch[ID_NETWORKINFO][\"result\"][\"protocolversion\"]);\n         result.pushKV(\"blocks\", batch[ID_BLOCKCHAININFO][\"result\"][\"blocks\"]);\n@@ -259,44 +259,44 @@ class GetinfoRequestHandler: public BaseRequestHandler\n         result.pushKV(\"proxy\", batch[ID_NETWORKINFO][\"result\"][\"networks\"][0][\"proxy\"]);\n         result.pushKV(\"difficulty\", batch[ID_BLOCKCHAININFO][\"result\"][\"difficulty\"]);\n         result.pushKV(\"chain\", UniValue(batch[ID_BLOCKCHAININFO][\"result\"][\"chain\"]));\n-        if (!batch[ID_WALLETINFO].isNull()) {\n+        if (!batch[ID_WALLETINFO].isNull()) <%\n             result.pushKV(\"walletversion\", batch[ID_WALLETINFO][\"result\"][\"walletversion\"]);\n             result.pushKV(\"balance\", batch[ID_WALLETINFO][\"result\"][\"balance\"]);\n             result.pushKV(\"keypoololdest\", batch[ID_WALLETINFO][\"result\"][\"keypoololdest\"]);\n             result.pushKV(\"keypoolsize\", batch[ID_WALLETINFO][\"result\"][\"keypoolsize\"]);\n-            if (!batch[ID_WALLETINFO][\"result\"][\"unlocked_until\"].isNull()) {\n+            if (!batch[ID_WALLETINFO][\"result\"][\"unlocked_until\"].isNull()) <%\n                 result.pushKV(\"unlocked_until\", batch[ID_WALLETINFO][\"result\"][\"unlocked_until\"]);\n-            }\n+            %>\n             result.pushKV(\"paytxfee\", batch[ID_WALLETINFO][\"result\"][\"paytxfee\"]);\n-        }\n+        %>\n         result.pushKV(\"relayfee\", batch[ID_NETWORKINFO][\"result\"][\"relayfee\"]);\n         result.pushKV(\"warnings\", batch[ID_NETWORKINFO][\"result\"][\"warnings\"]);\n         return JSONRPCReplyObj(result, NullUniValue, 1);\n-    }\n-};\n+    %>\n+%>;\n \n /** Process default single requests */\n-class DefaultRequestHandler: public BaseRequestHandler {\n+class DefaultRequestHandler: public BaseRequestHandler <%\n public:\n     UniValue PrepareRequest(const std::string& method, const std::vector<std::string>& args) override\n-    {\n+    <%\n         UniValue params;\n-        if(gArgs.GetBoolArg(\"-named\", DEFAULT_NAMED)) {\n+        if(gArgs.GetBoolArg(\"-named\", DEFAULT_NAMED)) <%\n             params = RPCConvertNamedValues(method, args);\n-        } else {\n+        %> else <%\n             params = RPCConvertValues(method, args);\n-        }\n+        %>\n         return JSONRPCRequestObj(method, params, 1);\n-    }\n+    %>\n \n     UniValue ProcessReply(const UniValue &reply) override\n-    {\n+    <%\n         return reply.get_obj();\n-    }\n-};\n+    %>\n+%>;\n \n static UniValue CallRPC(BaseRequestHandler *rh, const std::string& strMethod, const std::vector<std::string>& args)\n-{\n+<%\n     std::string host;\n     // In preference order, we choose the following for the port:\n     //     1. -rpcport\n@@ -324,14 +324,14 @@ static UniValue CallRPC(BaseRequestHandler *rh, const std::string& strMethod, co\n     // Get credentials\n     std::string strRPCUserColonPass;\n     bool failedToGetAuthCookie = false;\n-    if (gArgs.GetArg(\"-rpcpassword\", \"\") == \"\") {\n+    if (gArgs.GetArg(\"-rpcpassword\", \"\") == \"\") <%\n         // Try fall back to cookie-based authentication if no password is provided\n-        if (!GetAuthCookie(&strRPCUserColonPass)) {\n+        if (!GetAuthCookie(&strRPCUserColonPass)) <%\n             failedToGetAuthCookie = true;\n-        }\n-    } else {\n+        %>\n+    %> else <%\n         strRPCUserColonPass = gArgs.GetArg(\"-rpcuser\", \"\") + \":\" + gArgs.GetArg(\"-rpcpassword\", \"\");\n-    }\n+    %>\n \n     struct evkeyvalq* output_headers = evhttp_request_get_output_headers(req.get());\n     assert(output_headers);\n@@ -347,40 +347,40 @@ static UniValue CallRPC(BaseRequestHandler *rh, const std::string& strMethod, co\n \n     // check if we should use a special wallet endpoint\n     std::string endpoint = \"/\";\n-    if (!gArgs.GetArgs(\"-rpcwallet\").empty()) {\n+    if (!gArgs.GetArgs(\"-rpcwallet\").empty()) <%\n         std::string walletName = gArgs.GetArg(\"-rpcwallet\", \"\");\n         char *encodedURI = evhttp_uriencode(walletName.c_str(), walletName.size(), false);\n-        if (encodedURI) {\n+        if (encodedURI) <%\n             endpoint = \"/wallet/\"+ std::string(encodedURI);\n             free(encodedURI);\n-        }\n-        else {\n+        %>\n+        else <%\n             throw CConnectionFailed(\"uri-encode failed\");\n-        }\n-    }\n+        %>\n+    %>\n     int r = evhttp_make_request(evcon.get(), req.get(), EVHTTP_REQ_POST, endpoint.c_str());\n     req.release(); // ownership moved to evcon in above call\n-    if (r != 0) {\n+    if (r != 0) <%\n         throw CConnectionFailed(\"send http request failed\");\n-    }\n+    %>\n \n     event_base_dispatch(base.get());\n \n-    if (response.status == 0) {\n+    if (response.status == 0) <%\n         std::string responseErrorMessage;\n-        if (response.error != -1) {\n+        if (response.error != -1) <%\n             responseErrorMessage = strprintf(\" (error code %d - \\\"%s\\\")\", response.error, http_errorstring(response.error));\n-        }\n+        %>\n         throw CConnectionFailed(strprintf(\"Could not connect to the server %s:%d%s\\n\\nMake sure the bitcoind server is running and that you are connecting to the correct RPC port.\", host, port, responseErrorMessage));\n-    } else if (response.status == HTTP_UNAUTHORIZED) {\n-        if (failedToGetAuthCookie) {\n+    %> else if (response.status == HTTP_UNAUTHORIZED) <%\n+        if (failedToGetAuthCookie) <%\n             throw std::runtime_error(strprintf(\n                 \"Could not locate RPC credentials. No authentication cookie could be found, and RPC password is not set.  See -rpcpassword and -stdinrpcpass.  Configuration file: (%s)\",\n                 GetConfigFile(gArgs.GetArg(\"-conf\", BITCOIN_CONF_FILENAME)).string().c_str()));\n-        } else {\n+        %> else <%\n             throw std::runtime_error(\"Authorization failed: Incorrect rpcuser or rpcpassword\");\n-        }\n-    } else if (response.status >= 400 && response.status != HTTP_BAD_REQUEST && response.status != HTTP_NOT_FOUND && response.status != HTTP_INTERNAL_SERVER_ERROR)\n+        %>\n+    %> else if (response.status >= 400 && response.status != HTTP_BAD_REQUEST && response.status != HTTP_NOT_FOUND && response.status != HTTP_INTERNAL_SERVER_ERROR)\n         throw std::runtime_error(strprintf(\"server returned HTTP error %d\", response.status));\n     else if (response.body.empty())\n         throw std::runtime_error(\"no response from server\");\n@@ -394,146 +394,146 @@ static UniValue CallRPC(BaseRequestHandler *rh, const std::string& strMethod, co\n         throw std::runtime_error(\"expected reply to have result, error and id properties\");\n \n     return reply;\n-}\n+%>\n \n static int CommandLineRPC(int argc, char *argv[])\n-{\n+<%\n     std::string strPrint;\n     int nRet = 0;\n-    try {\n+    try <%\n         // Skip switches\n-        while (argc > 1 && IsSwitchChar(argv[1][0])) {\n+        while (argc > 1 && IsSwitchChar(argv[1][0])) <%\n             argc--;\n             argv++;\n-        }\n+        %>\n         std::string rpcPass;\n-        if (gArgs.GetBoolArg(\"-stdinrpcpass\", false)) {\n-            if (!std::getline(std::cin, rpcPass)) {\n+        if (gArgs.GetBoolArg(\"-stdinrpcpass\", false)) <%\n+            if (!std::getline(std::cin, rpcPass)) <%\n                 throw std::runtime_error(\"-stdinrpcpass specified but failed to read from standard input\");\n-            }\n+            %>\n             gArgs.ForceSetArg(\"-rpcpassword\", rpcPass);\n-        }\n+        %>\n         std::vector<std::string> args = std::vector<std::string>(&argv[1], &argv[argc]);\n-        if (gArgs.GetBoolArg(\"-stdin\", false)) {\n+        if (gArgs.GetBoolArg(\"-stdin\", false)) <%\n             // Read one arg per line from stdin and append\n             std::string line;\n-            while (std::getline(std::cin, line)) {\n+            while (std::getline(std::cin, line)) <%\n                 args.push_back(line);\n-            }\n-        }\n+            %>\n+        %>\n         std::unique_ptr<BaseRequestHandler> rh;\n         std::string method;\n-        if (gArgs.GetBoolArg(\"-getinfo\", false)) {\n+        if (gArgs.GetBoolArg(\"-getinfo\", false)) <%\n             rh.reset(new GetinfoRequestHandler());\n             method = \"\";\n-        } else {\n+        %> else <%\n             rh.reset(new DefaultRequestHandler());\n-            if (args.size() < 1) {\n+            if (args.size() < 1) <%\n                 throw std::runtime_error(\"too few parameters (need at least command)\");\n-            }\n+            %>\n             method = args[0];\n             args.erase(args.begin()); // Remove trailing method name from arguments vector\n-        }\n+        %>\n \n         // Execute and handle connection failures with -rpcwait\n         const bool fWait = gArgs.GetBoolArg(\"-rpcwait\", false);\n-        do {\n-            try {\n+        do <%\n+            try <%\n                 const UniValue reply = CallRPC(rh.get(), method, args);\n \n                 // Parse reply\n                 const UniValue& result = find_value(reply, \"result\");\n                 const UniValue& error  = find_value(reply, \"error\");\n \n-                if (!error.isNull()) {\n+                if (!error.isNull()) <%\n                     // Error\n                     int code = error[\"code\"].get_int();\n                     if (fWait && code == RPC_IN_WARMUP)\n                         throw CConnectionFailed(\"server in warmup\");\n                     strPrint = \"error: \" + error.write();\n                     nRet = abs(code);\n                     if (error.isObject())\n-                    {\n+                    <%\n                         UniValue errCode = find_value(error, \"code\");\n                         UniValue errMsg  = find_value(error, \"message\");\n                         strPrint = errCode.isNull() ? \"\" : \"error code: \"+errCode.getValStr()+\"\\n\";\n \n                         if (errMsg.isStr())\n                             strPrint += \"error message:\\n\"+errMsg.get_str();\n \n-                        if (errCode.isNum() && errCode.get_int() == RPC_WALLET_NOT_SPECIFIED) {\n+                        if (errCode.isNum() && errCode.get_int() == RPC_WALLET_NOT_SPECIFIED) <%\n                             strPrint += \"\\nTry adding \\\"-rpcwallet=<filename>\\\" option to bitcoin-cli command line.\";\n-                        }\n-                    }\n-                } else {\n+                        %>\n+                    %>\n+                %> else <%\n                     // Result\n                     if (result.isNull())\n                         strPrint = \"\";\n                     else if (result.isStr())\n                         strPrint = result.get_str();\n                     else\n                         strPrint = result.write(2);\n-                }\n+                %>\n                 // Connection succeeded, no need to retry.\n                 break;\n-            }\n-            catch (const CConnectionFailed&) {\n+            %>\n+            catch (const CConnectionFailed&) <%\n                 if (fWait)\n                     MilliSleep(1000);\n                 else\n                     throw;\n-            }\n-        } while (fWait);\n-    }\n-    catch (const std::exception& e) {\n+            %>\n+        %> while (fWait);\n+    %>\n+    catch (const std::exception& e) <%\n         strPrint = std::string(\"error: \") + e.what();\n         nRet = EXIT_FAILURE;\n-    }\n-    catch (...) {\n+    %>\n+    catch (...) <%\n         PrintExceptionContinue(nullptr, \"CommandLineRPC()\");\n         throw;\n-    }\n+    %>\n \n-    if (strPrint != \"\") {\n+    if (strPrint != \"\") <%\n         fprintf((nRet == 0 ? stdout : stderr), \"%s\\n\", strPrint.c_str());\n-    }\n+    %>\n     return nRet;\n-}\n+%>\n \n int main(int argc, char* argv[])\n-{\n+<%\n #ifdef WIN32\n     util::WinCmdLineArgs winArgs;\n     std::tie(argc, argv) = winArgs.get();\n #endif\n     SetupEnvironment();\n-    if (!SetupNetworking()) {\n+    if (!SetupNetworking()) <%\n         fprintf(stderr, \"Error: Initializing networking failed\\n\");\n         return EXIT_FAILURE;\n-    }\n+    %>\n     event_set_log_callback(&libevent_log_cb);\n \n-    try {\n+    try <%\n         int ret = AppInitRPC(argc, argv);\n         if (ret != CONTINUE_EXECUTION)\n             return ret;\n-    }\n-    catch (const std::exception& e) {\n+    %>\n+    catch (const std::exception& e) <%\n         PrintExceptionContinue(&e, \"AppInitRPC()\");\n         return EXIT_FAILURE;\n-    } catch (...) {\n+    %> catch (...) <%\n         PrintExceptionContinue(nullptr, \"AppInitRPC()\");\n         return EXIT_FAILURE;\n-    }\n+    %>\n \n     int ret = EXIT_FAILURE;\n-    try {\n+    try <%\n         ret = CommandLineRPC(argc, argv);\n-    }\n-    catch (const std::exception& e) {\n+    %>\n+    catch (const std::exception& e) <%\n         PrintExceptionContinue(&e, \"CommandLineRPC()\");\n-    } catch (...) {\n+    %> catch (...) <%\n         PrintExceptionContinue(nullptr, \"CommandLineRPC()\");\n-    }\n+    %>\n     return ret;\n-}\n+%>"
      },
      {
        "sha": "14bb3e8dda23a84e58298c20782dd96aee5d1b0b",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 208,
        "deletions": 208,
        "changes": 416,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -34,7 +34,7 @@ static const int CONTINUE_EXECUTION=-1;\n const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n \n static void SetupBitcoinTxArgs()\n-{\n+<%\n     SetupHelpOptions(gArgs);\n \n     gArgs.AddArg(\"-create\", \"Create new, empty TX.\", false, OptionsCategory::OPTIONS);\n@@ -67,35 +67,35 @@ static void SetupBitcoinTxArgs()\n \n     gArgs.AddArg(\"load=NAME:FILENAME\", \"Load JSON file FILENAME into register NAME\", false, OptionsCategory::REGISTER_COMMANDS);\n     gArgs.AddArg(\"set=NAME:JSON-STRING\", \"Set register NAME to given JSON-STRING\", false, OptionsCategory::REGISTER_COMMANDS);\n-}\n+%>\n \n //\n // This function returns either one of EXIT_ codes when it's expected to stop the process or\n // CONTINUE_EXECUTION when it's expected to continue further.\n //\n static int AppInitRawTx(int argc, char* argv[])\n-{\n+<%\n     //\n     // Parameters\n     //\n     SetupBitcoinTxArgs();\n     std::string error;\n-    if (!gArgs.ParseParameters(argc, argv, error)) {\n+    if (!gArgs.ParseParameters(argc, argv, error)) <%\n         fprintf(stderr, \"Error parsing command line arguments: %s\\n\", error.c_str());\n         return EXIT_FAILURE;\n-    }\n+    %>\n \n     // Check for -testnet or -regtest parameter (Params() calls are only valid after this clause)\n-    try {\n+    try <%\n         SelectParams(gArgs.GetChainName());\n-    } catch (const std::exception& e) {\n+    %> catch (const std::exception& e) <%\n         fprintf(stderr, \"Error: %s\\n\", e.what());\n         return EXIT_FAILURE;\n-    }\n+    %>\n \n     fCreateBlank = gArgs.GetBoolArg(\"-create\", false);\n \n-    if (argc < 2 || HelpRequested(gArgs)) {\n+    if (argc < 2 || HelpRequested(gArgs)) <%\n         // First part of help message is specific to this utility\n         std::string strUsage = PACKAGE_NAME \" bitcoin-tx utility version \" + FormatFullVersion() + \"\\n\\n\" +\n             \"Usage:  bitcoin-tx [options] <hex-tx> [commands]  Update hex-encoded bitcoin transaction\\n\" +\n@@ -105,28 +105,28 @@ static int AppInitRawTx(int argc, char* argv[])\n \n         fprintf(stdout, \"%s\", strUsage.c_str());\n \n-        if (argc < 2) {\n+        if (argc < 2) <%\n             fprintf(stderr, \"Error: too few parameters\\n\");\n             return EXIT_FAILURE;\n-        }\n+        %>\n         return EXIT_SUCCESS;\n-    }\n+    %>\n     return CONTINUE_EXECUTION;\n-}\n+%>\n \n static void RegisterSetJson(const std::string& key, const std::string& rawJson)\n-{\n+<%\n     UniValue val;\n-    if (!val.read(rawJson)) {\n+    if (!val.read(rawJson)) <%\n         std::string strErr = \"Cannot parse JSON for key \" + key;\n         throw std::runtime_error(strErr);\n-    }\n+    %>\n \n     registers[key] = val;\n-}\n+%>\n \n static void RegisterSet(const std::string& strInput)\n-{\n+<%\n     // separate NAME:VALUE in string\n     size_t pos = strInput.find(':');\n     if ((pos == std::string::npos) ||\n@@ -138,10 +138,10 @@ static void RegisterSet(const std::string& strInput)\n     std::string valStr = strInput.substr(pos + 1, std::string::npos);\n \n     RegisterSetJson(key, valStr);\n-}\n+%>\n \n static void RegisterLoad(const std::string& strInput)\n-{\n+<%\n     // separate NAME:FILENAME in string\n     size_t pos = strInput.find(':');\n     if ((pos == std::string::npos) ||\n@@ -153,82 +153,82 @@ static void RegisterLoad(const std::string& strInput)\n     std::string filename = strInput.substr(pos + 1, std::string::npos);\n \n     FILE *f = fopen(filename.c_str(), \"r\");\n-    if (!f) {\n+    if (!f) <%\n         std::string strErr = \"Cannot open file \" + filename;\n         throw std::runtime_error(strErr);\n-    }\n+    %>\n \n     // load file chunks into one big buffer\n     std::string valStr;\n-    while ((!feof(f)) && (!ferror(f))) {\n+    while ((!feof(f)) && (!ferror(f))) <%\n         char buf[4096];\n         int bread = fread(buf, 1, sizeof(buf), f);\n         if (bread <= 0)\n             break;\n \n         valStr.insert(valStr.size(), buf, bread);\n-    }\n+    %>\n \n     int error = ferror(f);\n     fclose(f);\n \n-    if (error) {\n+    if (error) <%\n         std::string strErr = \"Error reading file \" + filename;\n         throw std::runtime_error(strErr);\n-    }\n+    %>\n \n     // evaluate as JSON buffer register\n     RegisterSetJson(key, valStr);\n-}\n+%>\n \n static CAmount ExtractAndValidateValue(const std::string& strValue)\n-{\n+<%\n     CAmount value;\n     if (!ParseMoney(strValue, value))\n         throw std::runtime_error(\"invalid TX output value\");\n     return value;\n-}\n+%>\n \n static void MutateTxVersion(CMutableTransaction& tx, const std::string& cmdVal)\n-{\n+<%\n     int64_t newVersion;\n     if (!ParseInt64(cmdVal, &newVersion) || newVersion < 1 || newVersion > CTransaction::MAX_STANDARD_VERSION)\n         throw std::runtime_error(\"Invalid TX version requested: '\" + cmdVal + \"'\");\n \n     tx.nVersion = (int) newVersion;\n-}\n+%>\n \n static void MutateTxLocktime(CMutableTransaction& tx, const std::string& cmdVal)\n-{\n+<%\n     int64_t newLocktime;\n     if (!ParseInt64(cmdVal, &newLocktime) || newLocktime < 0LL || newLocktime > 0xffffffffLL)\n         throw std::runtime_error(\"Invalid TX locktime requested: '\" + cmdVal + \"'\");\n \n     tx.nLockTime = (unsigned int) newLocktime;\n-}\n+%>\n \n static void MutateTxRBFOptIn(CMutableTransaction& tx, const std::string& strInIdx)\n-{\n+<%\n     // parse requested index\n     int64_t inIdx;\n-    if (!ParseInt64(strInIdx, &inIdx) || inIdx < 0 || inIdx >= static_cast<int64_t>(tx.vin.size())) {\n+    if (!ParseInt64(strInIdx, &inIdx) || inIdx < 0 || inIdx >= static_cast<int64_t>(tx.vin.size())) <%\n         throw std::runtime_error(\"Invalid TX input index '\" + strInIdx + \"'\");\n-    }\n+    %>\n \n     // set the nSequence to MAX_INT - 2 (= RBF opt in flag)\n     int cnt = 0;\n-    for (CTxIn& txin : tx.vin) {\n-        if (strInIdx == \"\" || cnt == inIdx) {\n-            if (txin.nSequence > MAX_BIP125_RBF_SEQUENCE) {\n+    for (CTxIn& txin : tx.vin) <%\n+        if (strInIdx == \"\" || cnt == inIdx) <%\n+            if (txin.nSequence > MAX_BIP125_RBF_SEQUENCE) <%\n                 txin.nSequence = MAX_BIP125_RBF_SEQUENCE;\n-            }\n-        }\n+            %>\n+        %>\n         ++cnt;\n-    }\n-}\n+    %>\n+%>\n \n static void MutateTxAddInput(CMutableTransaction& tx, const std::string& strInput)\n-{\n+<%\n     std::vector<std::string> vStrInputParts;\n     boost::split(vStrInputParts, strInput, boost::is_any_of(\":\"));\n \n@@ -238,9 +238,9 @@ static void MutateTxAddInput(CMutableTransaction& tx, const std::string& strInpu\n \n     // extract and validate TXID\n     uint256 txid;\n-    if (!ParseHashStr(vStrInputParts[0], txid)) {\n+    if (!ParseHashStr(vStrInputParts[0], txid)) <%\n         throw std::runtime_error(\"invalid TX input txid\");\n-    }\n+    %>\n \n     static const unsigned int minTxOutSz = 9;\n     static const unsigned int maxVout = MAX_BLOCK_WEIGHT / (WITNESS_SCALE_FACTOR * minTxOutSz);\n@@ -259,10 +259,10 @@ static void MutateTxAddInput(CMutableTransaction& tx, const std::string& strInpu\n     // append to transaction input list\n     CTxIn txin(txid, vout, CScript(), nSequenceIn);\n     tx.vin.push_back(txin);\n-}\n+%>\n \n static void MutateTxAddOutAddr(CMutableTransaction& tx, const std::string& strInput)\n-{\n+<%\n     // Separate into VALUE:ADDRESS\n     std::vector<std::string> vStrInputParts;\n     boost::split(vStrInputParts, strInput, boost::is_any_of(\":\"));\n@@ -276,18 +276,18 @@ static void MutateTxAddOutAddr(CMutableTransaction& tx, const std::string& strIn\n     // extract and validate ADDRESS\n     std::string strAddr = vStrInputParts[1];\n     CTxDestination destination = DecodeDestination(strAddr);\n-    if (!IsValidDestination(destination)) {\n+    if (!IsValidDestination(destination)) <%\n         throw std::runtime_error(\"invalid TX output address\");\n-    }\n+    %>\n     CScript scriptPubKey = GetScriptForDestination(destination);\n \n     // construct TxOut, append to transaction output list\n     CTxOut txout(value, scriptPubKey);\n     tx.vout.push_back(txout);\n-}\n+%>\n \n static void MutateTxAddOutPubKey(CMutableTransaction& tx, const std::string& strInput)\n-{\n+<%\n     // Separate into VALUE:PUBKEY[:FLAGS]\n     std::vector<std::string> vStrInputParts;\n     boost::split(vStrInputParts, strInput, boost::is_any_of(\":\"));\n@@ -307,31 +307,31 @@ static void MutateTxAddOutPubKey(CMutableTransaction& tx, const std::string& str\n     // Extract and validate FLAGS\n     bool bSegWit = false;\n     bool bScriptHash = false;\n-    if (vStrInputParts.size() == 3) {\n+    if (vStrInputParts.size() == 3) <%\n         std::string flags = vStrInputParts[2];\n         bSegWit = (flags.find('W') != std::string::npos);\n         bScriptHash = (flags.find('S') != std::string::npos);\n-    }\n+    %>\n \n-    if (bSegWit) {\n-        if (!pubkey.IsCompressed()) {\n+    if (bSegWit) <%\n+        if (!pubkey.IsCompressed()) <%\n             throw std::runtime_error(\"Uncompressed pubkeys are not useable for SegWit outputs\");\n-        }\n+        %>\n         // Call GetScriptForWitness() to build a P2WSH scriptPubKey\n         scriptPubKey = GetScriptForWitness(scriptPubKey);\n-    }\n-    if (bScriptHash) {\n+    %>\n+    if (bScriptHash) <%\n         // Get the ID for the script, and then construct a P2SH destination for it.\n         scriptPubKey = GetScriptForDestination(CScriptID(scriptPubKey));\n-    }\n+    %>\n \n     // construct TxOut, append to transaction output list\n     CTxOut txout(value, scriptPubKey);\n     tx.vout.push_back(txout);\n-}\n+%>\n \n static void MutateTxAddOutMultiSig(CMutableTransaction& tx, const std::string& strInput)\n-{\n+<%\n     // Separate into VALUE:REQUIRED:NUMKEYS:PUBKEY1:PUBKEY2:....[:FLAGS]\n     std::vector<std::string> vStrInputParts;\n     boost::split(vStrInputParts, strInput, boost::is_any_of(\":\"));\n@@ -359,53 +359,53 @@ static void MutateTxAddOutMultiSig(CMutableTransaction& tx, const std::string& s\n \n     // extract and validate PUBKEYs\n     std::vector<CPubKey> pubkeys;\n-    for(int pos = 1; pos <= int(numkeys); pos++) {\n+    for(int pos = 1; pos <= int(numkeys); pos++) <%\n         CPubKey pubkey(ParseHex(vStrInputParts[pos + 2]));\n         if (!pubkey.IsFullyValid())\n             throw std::runtime_error(\"invalid TX output pubkey\");\n         pubkeys.push_back(pubkey);\n-    }\n+    %>\n \n     // Extract FLAGS\n     bool bSegWit = false;\n     bool bScriptHash = false;\n-    if (vStrInputParts.size() == numkeys + 4) {\n+    if (vStrInputParts.size() == numkeys + 4) <%\n         std::string flags = vStrInputParts.back();\n         bSegWit = (flags.find('W') != std::string::npos);\n         bScriptHash = (flags.find('S') != std::string::npos);\n-    }\n-    else if (vStrInputParts.size() > numkeys + 4) {\n+    %>\n+    else if (vStrInputParts.size() > numkeys + 4) <%\n         // Validate that there were no more parameters passed\n         throw std::runtime_error(\"Too many parameters\");\n-    }\n+    %>\n \n     CScript scriptPubKey = GetScriptForMultisig(required, pubkeys);\n \n-    if (bSegWit) {\n-        for (const CPubKey& pubkey : pubkeys) {\n-            if (!pubkey.IsCompressed()) {\n+    if (bSegWit) <%\n+        for (const CPubKey& pubkey : pubkeys) <%\n+            if (!pubkey.IsCompressed()) <%\n                 throw std::runtime_error(\"Uncompressed pubkeys are not useable for SegWit outputs\");\n-            }\n-        }\n+            %>\n+        %>\n         // Call GetScriptForWitness() to build a P2WSH scriptPubKey\n         scriptPubKey = GetScriptForWitness(scriptPubKey);\n-    }\n-    if (bScriptHash) {\n-        if (scriptPubKey.size() > MAX_SCRIPT_ELEMENT_SIZE) {\n+    %>\n+    if (bScriptHash) <%\n+        if (scriptPubKey.size() > MAX_SCRIPT_ELEMENT_SIZE) <%\n             throw std::runtime_error(strprintf(\n                         \"redeemScript exceeds size limit: %d > %d\", scriptPubKey.size(), MAX_SCRIPT_ELEMENT_SIZE));\n-        }\n+        %>\n         // Get the ID for the script, and then construct a P2SH destination for it.\n         scriptPubKey = GetScriptForDestination(CScriptID(scriptPubKey));\n-    }\n+    %>\n \n     // construct TxOut, append to transaction output list\n     CTxOut txout(value, scriptPubKey);\n     tx.vout.push_back(txout);\n-}\n+%>\n \n static void MutateTxAddOutData(CMutableTransaction& tx, const std::string& strInput)\n-{\n+<%\n     CAmount value = 0;\n \n     // separate [VALUE:]DATA in string\n@@ -414,10 +414,10 @@ static void MutateTxAddOutData(CMutableTransaction& tx, const std::string& strIn\n     if (pos==0)\n         throw std::runtime_error(\"TX output value not specified\");\n \n-    if (pos != std::string::npos) {\n+    if (pos != std::string::npos) <%\n         // Extract and validate VALUE\n         value = ExtractAndValidateValue(strInput.substr(0, pos));\n-    }\n+    %>\n \n     // extract and validate DATA\n     std::string strData = strInput.substr(pos + 1, std::string::npos);\n@@ -429,10 +429,10 @@ static void MutateTxAddOutData(CMutableTransaction& tx, const std::string& strIn\n \n     CTxOut txout(value, CScript() << OP_RETURN << data);\n     tx.vout.push_back(txout);\n-}\n+%>\n \n static void MutateTxAddOutScript(CMutableTransaction& tx, const std::string& strInput)\n-{\n+<%\n     // separate VALUE:SCRIPT[:FLAGS]\n     std::vector<std::string> vStrInputParts;\n     boost::split(vStrInputParts, strInput, boost::is_any_of(\":\"));\n@@ -449,86 +449,86 @@ static void MutateTxAddOutScript(CMutableTransaction& tx, const std::string& str\n     // Extract FLAGS\n     bool bSegWit = false;\n     bool bScriptHash = false;\n-    if (vStrInputParts.size() == 3) {\n+    if (vStrInputParts.size() == 3) <%\n         std::string flags = vStrInputParts.back();\n         bSegWit = (flags.find('W') != std::string::npos);\n         bScriptHash = (flags.find('S') != std::string::npos);\n-    }\n+    %>\n \n-    if (scriptPubKey.size() > MAX_SCRIPT_SIZE) {\n+    if (scriptPubKey.size() > MAX_SCRIPT_SIZE) <%\n         throw std::runtime_error(strprintf(\n                     \"script exceeds size limit: %d > %d\", scriptPubKey.size(), MAX_SCRIPT_SIZE));\n-    }\n+    %>\n \n-    if (bSegWit) {\n+    if (bSegWit) <%\n         scriptPubKey = GetScriptForWitness(scriptPubKey);\n-    }\n-    if (bScriptHash) {\n-        if (scriptPubKey.size() > MAX_SCRIPT_ELEMENT_SIZE) {\n+    %>\n+    if (bScriptHash) <%\n+        if (scriptPubKey.size() > MAX_SCRIPT_ELEMENT_SIZE) <%\n             throw std::runtime_error(strprintf(\n                         \"redeemScript exceeds size limit: %d > %d\", scriptPubKey.size(), MAX_SCRIPT_ELEMENT_SIZE));\n-        }\n+        %>\n         scriptPubKey = GetScriptForDestination(CScriptID(scriptPubKey));\n-    }\n+    %>\n \n     // construct TxOut, append to transaction output list\n     CTxOut txout(value, scriptPubKey);\n     tx.vout.push_back(txout);\n-}\n+%>\n \n static void MutateTxDelInput(CMutableTransaction& tx, const std::string& strInIdx)\n-{\n+<%\n     // parse requested deletion index\n     int64_t inIdx;\n-    if (!ParseInt64(strInIdx, &inIdx) || inIdx < 0 || inIdx >= static_cast<int64_t>(tx.vin.size())) {\n+    if (!ParseInt64(strInIdx, &inIdx) || inIdx < 0 || inIdx >= static_cast<int64_t>(tx.vin.size())) <%\n         throw std::runtime_error(\"Invalid TX input index '\" + strInIdx + \"'\");\n-    }\n+    %>\n \n     // delete input from transaction\n     tx.vin.erase(tx.vin.begin() + inIdx);\n-}\n+%>\n \n static void MutateTxDelOutput(CMutableTransaction& tx, const std::string& strOutIdx)\n-{\n+<%\n     // parse requested deletion index\n     int64_t outIdx;\n-    if (!ParseInt64(strOutIdx, &outIdx) || outIdx < 0 || outIdx >= static_cast<int64_t>(tx.vout.size())) {\n+    if (!ParseInt64(strOutIdx, &outIdx) || outIdx < 0 || outIdx >= static_cast<int64_t>(tx.vout.size())) <%\n         throw std::runtime_error(\"Invalid TX output index '\" + strOutIdx + \"'\");\n-    }\n+    %>\n \n     // delete output from transaction\n     tx.vout.erase(tx.vout.begin() + outIdx);\n-}\n+%>\n \n static const unsigned int N_SIGHASH_OPTS = 6;\n-static const struct {\n+static const struct <%\n     const char *flagStr;\n     int flags;\n-} sighashOptions[N_SIGHASH_OPTS] = {\n-    {\"ALL\", SIGHASH_ALL},\n-    {\"NONE\", SIGHASH_NONE},\n-    {\"SINGLE\", SIGHASH_SINGLE},\n-    {\"ALL|ANYONECANPAY\", SIGHASH_ALL|SIGHASH_ANYONECANPAY},\n-    {\"NONE|ANYONECANPAY\", SIGHASH_NONE|SIGHASH_ANYONECANPAY},\n-    {\"SINGLE|ANYONECANPAY\", SIGHASH_SINGLE|SIGHASH_ANYONECANPAY},\n-};\n+%> sighashOptions[N_SIGHASH_OPTS] = <%\n+    <%\"ALL\", SIGHASH_ALL%>,\n+    <%\"NONE\", SIGHASH_NONE%>,\n+    <%\"SINGLE\", SIGHASH_SINGLE%>,\n+    <%\"ALL|ANYONECANPAY\", SIGHASH_ALL|SIGHASH_ANYONECANPAY%>,\n+    <%\"NONE|ANYONECANPAY\", SIGHASH_NONE|SIGHASH_ANYONECANPAY%>,\n+    <%\"SINGLE|ANYONECANPAY\", SIGHASH_SINGLE|SIGHASH_ANYONECANPAY%>,\n+%>;\n \n static bool findSighashFlags(int& flags, const std::string& flagStr)\n-{\n+<%\n     flags = 0;\n \n-    for (unsigned int i = 0; i < N_SIGHASH_OPTS; i++) {\n-        if (flagStr == sighashOptions[i].flagStr) {\n+    for (unsigned int i = 0; i < N_SIGHASH_OPTS; i++) <%\n+        if (flagStr == sighashOptions[i].flagStr) <%\n             flags = sighashOptions[i].flags;\n             return true;\n-        }\n-    }\n+        %>\n+    %>\n \n     return false;\n-}\n+%>\n \n static CAmount AmountFromValue(const UniValue& value)\n-{\n+<%\n     if (!value.isNum() && !value.isStr())\n         throw std::runtime_error(\"Amount is not a number or string\");\n     CAmount amount;\n@@ -537,10 +537,10 @@ static CAmount AmountFromValue(const UniValue& value)\n     if (!MoneyRange(amount))\n         throw std::runtime_error(\"Amount out of range\");\n     return amount;\n-}\n+%>\n \n static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n-{\n+<%\n     int nHashType = SIGHASH_ALL;\n \n     if (flagStr.size() > 0)\n@@ -549,8 +549,8 @@ static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n \n     // mergedTx will end up with all the signatures; it\n     // starts as a clone of the raw tx:\n-    CMutableTransaction mergedTx{tx};\n-    const CMutableTransaction txv{tx};\n+    CMutableTransaction mergedTx<%tx%>;\n+    const CMutableTransaction txv<%tx%>;\n     CCoinsView viewDummy;\n     CCoinsViewCache view(&viewDummy);\n \n@@ -559,38 +559,38 @@ static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n     CBasicKeyStore tempKeystore;\n     UniValue keysObj = registers[\"privatekeys\"];\n \n-    for (unsigned int kidx = 0; kidx < keysObj.size(); kidx++) {\n+    for (unsigned int kidx = 0; kidx < keysObj.size(); kidx++) <%\n         if (!keysObj[kidx].isStr())\n             throw std::runtime_error(\"privatekey not a std::string\");\n         CKey key = DecodeSecret(keysObj[kidx].getValStr());\n-        if (!key.IsValid()) {\n+        if (!key.IsValid()) <%\n             throw std::runtime_error(\"privatekey not valid\");\n-        }\n+        %>\n         tempKeystore.AddKey(key);\n-    }\n+    %>\n \n     // Add previous txouts given in the RPC call:\n     if (!registers.count(\"prevtxs\"))\n         throw std::runtime_error(\"prevtxs register variable must be set.\");\n     UniValue prevtxsObj = registers[\"prevtxs\"];\n-    {\n-        for (unsigned int previdx = 0; previdx < prevtxsObj.size(); previdx++) {\n+    <%\n+        for (unsigned int previdx = 0; previdx < prevtxsObj.size(); previdx++) <%\n             UniValue prevOut = prevtxsObj[previdx];\n             if (!prevOut.isObject())\n                 throw std::runtime_error(\"expected prevtxs internal object\");\n \n-            std::map<std::string, UniValue::VType> types = {\n-                {\"txid\", UniValue::VSTR},\n-                {\"vout\", UniValue::VNUM},\n-                {\"scriptPubKey\", UniValue::VSTR},\n-            };\n+            std::map<std::string, UniValue::VType> types = <%\n+                <%\"txid\", UniValue::VSTR%>,\n+                <%\"vout\", UniValue::VNUM%>,\n+                <%\"scriptPubKey\", UniValue::VSTR%>,\n+            %>;\n             if (!prevOut.checkObject(types))\n                 throw std::runtime_error(\"prevtxs internal object typecheck fail\");\n \n             uint256 txid;\n-            if (!ParseHashStr(prevOut[\"txid\"].get_str(), txid)) {\n+            if (!ParseHashStr(prevOut[\"txid\"].get_str(), txid)) <%\n                 throw std::runtime_error(\"txid must be hexadecimal string (not '\" + prevOut[\"txid\"].get_str() + \"')\");\n-            }\n+            %>\n \n             const int nOut = prevOut[\"vout\"].get_int();\n             if (nOut < 0)\n@@ -600,47 +600,47 @@ static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n             std::vector<unsigned char> pkData(ParseHexUV(prevOut[\"scriptPubKey\"], \"scriptPubKey\"));\n             CScript scriptPubKey(pkData.begin(), pkData.end());\n \n-            {\n+            <%\n                 const Coin& coin = view.AccessCoin(out);\n-                if (!coin.IsSpent() && coin.out.scriptPubKey != scriptPubKey) {\n+                if (!coin.IsSpent() && coin.out.scriptPubKey != scriptPubKey) <%\n                     std::string err(\"Previous output scriptPubKey mismatch:\\n\");\n                     err = err + ScriptToAsmStr(coin.out.scriptPubKey) + \"\\nvs:\\n\"+\n                         ScriptToAsmStr(scriptPubKey);\n                     throw std::runtime_error(err);\n-                }\n+                %>\n                 Coin newcoin;\n                 newcoin.out.scriptPubKey = scriptPubKey;\n                 newcoin.out.nValue = 0;\n-                if (prevOut.exists(\"amount\")) {\n+                if (prevOut.exists(\"amount\")) <%\n                     newcoin.out.nValue = AmountFromValue(prevOut[\"amount\"]);\n-                }\n+                %>\n                 newcoin.nHeight = 1;\n                 view.AddCoin(out, std::move(newcoin), true);\n-            }\n+            %>\n \n             // if redeemScript given and private keys given,\n             // add redeemScript to the tempKeystore so it can be signed:\n             if ((scriptPubKey.IsPayToScriptHash() || scriptPubKey.IsPayToWitnessScriptHash()) &&\n-                prevOut.exists(\"redeemScript\")) {\n+                prevOut.exists(\"redeemScript\")) <%\n                 UniValue v = prevOut[\"redeemScript\"];\n                 std::vector<unsigned char> rsData(ParseHexUV(v, \"redeemScript\"));\n                 CScript redeemScript(rsData.begin(), rsData.end());\n                 tempKeystore.AddCScript(redeemScript);\n-            }\n-        }\n-    }\n+            %>\n+        %>\n+    %>\n \n     const CKeyStore& keystore = tempKeystore;\n \n     bool fHashSingle = ((nHashType & ~SIGHASH_ANYONECANPAY) == SIGHASH_SINGLE);\n \n     // Sign what we can:\n-    for (unsigned int i = 0; i < mergedTx.vin.size(); i++) {\n+    for (unsigned int i = 0; i < mergedTx.vin.size(); i++) <%\n         CTxIn& txin = mergedTx.vin[i];\n         const Coin& coin = view.AccessCoin(txin.prevout);\n-        if (coin.IsSpent()) {\n+        if (coin.IsSpent()) <%\n             continue;\n-        }\n+        %>\n         const CScript& prevPubKey = coin.out.scriptPubKey;\n         const CAmount& amount = coin.out.nValue;\n \n@@ -650,36 +650,36 @@ static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n             ProduceSignature(keystore, MutableTransactionSignatureCreator(&mergedTx, i, amount, nHashType), prevPubKey, sigdata);\n \n         UpdateInput(txin, sigdata);\n-    }\n+    %>\n \n     tx = mergedTx;\n-}\n+%>\n \n class Secp256k1Init\n-{\n+<%\n     ECCVerifyHandle globalVerifyHandle;\n \n public:\n-    Secp256k1Init() {\n+    Secp256k1Init() <%\n         ECC_Start();\n-    }\n-    ~Secp256k1Init() {\n+    %>\n+    ~Secp256k1Init() <%\n         ECC_Stop();\n-    }\n-};\n+    %>\n+%>;\n \n static void MutateTx(CMutableTransaction& tx, const std::string& command,\n                      const std::string& commandVal)\n-{\n+<%\n     std::unique_ptr<Secp256k1Init> ecc;\n \n     if (command == \"nversion\")\n         MutateTxVersion(tx, commandVal);\n     else if (command == \"locktime\")\n         MutateTxLocktime(tx, commandVal);\n-    else if (command == \"replaceable\") {\n+    else if (command == \"replaceable\") <%\n         MutateTxRBFOptIn(tx, commandVal);\n-    }\n+    %>\n \n     else if (command == \"delin\")\n         MutateTxDelInput(tx, commandVal);\n@@ -690,21 +690,21 @@ static void MutateTx(CMutableTransaction& tx, const std::string& command,\n         MutateTxDelOutput(tx, commandVal);\n     else if (command == \"outaddr\")\n         MutateTxAddOutAddr(tx, commandVal);\n-    else if (command == \"outpubkey\") {\n+    else if (command == \"outpubkey\") <%\n         ecc.reset(new Secp256k1Init());\n         MutateTxAddOutPubKey(tx, commandVal);\n-    } else if (command == \"outmultisig\") {\n+    %> else if (command == \"outmultisig\") <%\n         ecc.reset(new Secp256k1Init());\n         MutateTxAddOutMultiSig(tx, commandVal);\n-    } else if (command == \"outscript\")\n+    %> else if (command == \"outscript\")\n         MutateTxAddOutScript(tx, commandVal);\n     else if (command == \"outdata\")\n         MutateTxAddOutData(tx, commandVal);\n \n-    else if (command == \"sign\") {\n+    else if (command == \"sign\") <%\n         ecc.reset(new Secp256k1Init());\n         MutateTxSign(tx, commandVal);\n-    }\n+    %>\n \n     else if (command == \"load\")\n         RegisterLoad(commandVal);\n@@ -714,77 +714,77 @@ static void MutateTx(CMutableTransaction& tx, const std::string& command,\n \n     else\n         throw std::runtime_error(\"unknown command\");\n-}\n+%>\n \n static void OutputTxJSON(const CTransaction& tx)\n-{\n+<%\n     UniValue entry(UniValue::VOBJ);\n     TxToUniv(tx, uint256(), entry);\n \n     std::string jsonOutput = entry.write(4);\n     fprintf(stdout, \"%s\\n\", jsonOutput.c_str());\n-}\n+%>\n \n static void OutputTxHash(const CTransaction& tx)\n-{\n+<%\n     std::string strHexHash = tx.GetHash().GetHex(); // the hex-encoded transaction hash (aka the transaction id)\n \n     fprintf(stdout, \"%s\\n\", strHexHash.c_str());\n-}\n+%>\n \n static void OutputTxHex(const CTransaction& tx)\n-{\n+<%\n     std::string strHex = EncodeHexTx(tx);\n \n     fprintf(stdout, \"%s\\n\", strHex.c_str());\n-}\n+%>\n \n static void OutputTx(const CTransaction& tx)\n-{\n+<%\n     if (gArgs.GetBoolArg(\"-json\", false))\n         OutputTxJSON(tx);\n     else if (gArgs.GetBoolArg(\"-txid\", false))\n         OutputTxHash(tx);\n     else\n         OutputTxHex(tx);\n-}\n+%>\n \n static std::string readStdin()\n-{\n+<%\n     char buf[4096];\n     std::string ret;\n \n-    while (!feof(stdin)) {\n+    while (!feof(stdin)) <%\n         size_t bread = fread(buf, 1, sizeof(buf), stdin);\n         ret.append(buf, bread);\n         if (bread < sizeof(buf))\n             break;\n-    }\n+    %>\n \n     if (ferror(stdin))\n         throw std::runtime_error(\"error reading stdin\");\n \n     boost::algorithm::trim_right(ret);\n \n     return ret;\n-}\n+%>\n \n static int CommandLineRawTx(int argc, char* argv[])\n-{\n+<%\n     std::string strPrint;\n     int nRet = 0;\n-    try {\n+    try <%\n         // Skip switches; Permit common stdin convention \"-\"\n         while (argc > 1 && IsSwitchChar(argv[1][0]) &&\n-               (argv[1][1] != 0)) {\n+               (argv[1][1] != 0)) <%\n             argc--;\n             argv++;\n-        }\n+        %>\n \n         CMutableTransaction tx;\n         int startArg;\n \n-        if (!fCreateBlank) {\n+        if (!fCreateBlank) <%\n             // require at least one param\n             if (argc < 2)\n                 throw std::runtime_error(\"too few parameters\");\n@@ -798,65 +798,65 @@ static int CommandLineRawTx(int argc, char* argv[])\n                 throw std::runtime_error(\"invalid transaction encoding\");\n \n             startArg = 2;\n-        } else\n+        %> else\n             startArg = 1;\n \n-        for (int i = startArg; i < argc; i++) {\n+        for (int i = startArg; i < argc; i++) <%\n             std::string arg = argv[i];\n             std::string key, value;\n             size_t eqpos = arg.find('=');\n             if (eqpos == std::string::npos)\n                 key = arg;\n-            else {\n+            else <%\n                 key = arg.substr(0, eqpos);\n                 value = arg.substr(eqpos + 1);\n-            }\n+            %>\n \n             MutateTx(tx, key, value);\n-        }\n+        %>\n \n         OutputTx(CTransaction(tx));\n-    }\n-    catch (const std::exception& e) {\n+    %>\n+    catch (const std::exception& e) <%\n         strPrint = std::string(\"error: \") + e.what();\n         nRet = EXIT_FAILURE;\n-    }\n-    catch (...) {\n+    %>\n+    catch (...) <%\n         PrintExceptionContinue(nullptr, \"CommandLineRawTx()\");\n         throw;\n-    }\n+    %>\n \n-    if (strPrint != \"\") {\n+    if (strPrint != \"\") <%\n         fprintf((nRet == 0 ? stdout : stderr), \"%s\\n\", strPrint.c_str());\n-    }\n+    %>\n     return nRet;\n-}\n+%>\n \n int main(int argc, char* argv[])\n-{\n+<%\n     SetupEnvironment();\n \n-    try {\n+    try <%\n         int ret = AppInitRawTx(argc, argv);\n         if (ret != CONTINUE_EXECUTION)\n             return ret;\n-    }\n-    catch (const std::exception& e) {\n+    %>\n+    catch (const std::exception& e) <%\n         PrintExceptionContinue(&e, \"AppInitRawTx()\");\n         return EXIT_FAILURE;\n-    } catch (...) {\n+    %> catch (...) <%\n         PrintExceptionContinue(nullptr, \"AppInitRawTx()\");\n         return EXIT_FAILURE;\n-    }\n+    %>\n \n     int ret = EXIT_FAILURE;\n-    try {\n+    try <%\n         ret = CommandLineRawTx(argc, argv);\n-    }\n-    catch (const std::exception& e) {\n+    %>\n+    catch (const std::exception& e) <%\n         PrintExceptionContinue(&e, \"CommandLineRawTx()\");\n-    } catch (...) {\n+    %> catch (...) <%\n         PrintExceptionContinue(nullptr, \"CommandLineRawTx()\");\n-    }\n+    %>\n     return ret;\n-}\n+%>"
      },
      {
        "sha": "268625d512932d049b4c8a753b18de11f5a5904e",
        "filename": "src/bitcoin-wallet.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 27,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bitcoin-wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bitcoin-wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-wallet.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -19,7 +19,7 @@\n const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n \n static void SetupWalletToolArgs()\n-{\n+<%\n     SetupHelpOptions(gArgs);\n     SetupChainParamsBaseOptions();\n \n@@ -30,17 +30,17 @@ static void SetupWalletToolArgs()\n \n     gArgs.AddArg(\"info\", \"Get wallet info\", false, OptionsCategory::COMMANDS);\n     gArgs.AddArg(\"create\", \"Create new wallet file\", false, OptionsCategory::COMMANDS);\n-}\n+%>\n \n static bool WalletAppInit(int argc, char* argv[])\n-{\n+<%\n     SetupWalletToolArgs();\n     std::string error_message;\n-    if (!gArgs.ParseParameters(argc, argv, error_message)) {\n+    if (!gArgs.ParseParameters(argc, argv, error_message)) <%\n         fprintf(stderr, \"Error parsing command line arguments: %s\\n\", error_message.c_str());\n         return false;\n-    }\n-    if (argc < 2 || HelpRequested(gArgs)) {\n+    %>\n+    if (argc < 2 || HelpRequested(gArgs)) <%\n         std::string usage = strprintf(\"%s bitcoin-wallet version\", PACKAGE_NAME) + \" \" + FormatFullVersion() + \"\\n\\n\" +\n                                       \"wallet-tool is an offline tool for creating and interacting with Bitcoin Core wallet files.\\n\" +\n                                       \"By default wallet-tool will act on wallets in the default mainnet wallet directory in the datadir.\\n\" +\n@@ -51,60 +51,60 @@ static bool WalletAppInit(int argc, char* argv[])\n \n         fprintf(stdout, \"%s\", usage.c_str());\n         return false;\n-    }\n+    %>\n \n     // check for printtoconsole, allow -debug\n     LogInstance().m_print_to_console = gArgs.GetBoolArg(\"-printtoconsole\", gArgs.GetBoolArg(\"-debug\", false));\n \n-    if (!fs::is_directory(GetDataDir(false))) {\n+    if (!fs::is_directory(GetDataDir(false))) <%\n         fprintf(stderr, \"Error: Specified data directory \\\"%s\\\" does not exist.\\n\", gArgs.GetArg(\"-datadir\", \"\").c_str());\n         return false;\n-    }\n+    %>\n     // Check for -testnet or -regtest parameter (Params() calls are only valid after this clause)\n     SelectParams(gArgs.GetChainName());\n \n     return true;\n-}\n+%>\n \n int main(int argc, char* argv[])\n-{\n+<%\n #ifdef WIN32\n     util::WinCmdLineArgs winArgs;\n     std::tie(argc, argv) = winArgs.get();\n #endif\n     SetupEnvironment();\n     RandomInit();\n-    try {\n+    try <%\n         if (!WalletAppInit(argc, argv)) return EXIT_FAILURE;\n-    } catch (const std::exception& e) {\n+    %> catch (const std::exception& e) <%\n         PrintExceptionContinue(&e, \"WalletAppInit()\");\n         return EXIT_FAILURE;\n-    } catch (...) {\n+    %> catch (...) <%\n         PrintExceptionContinue(nullptr, \"WalletAppInit()\");\n         return EXIT_FAILURE;\n-    }\n+    %>\n \n-    std::string method {};\n-    for(int i = 1; i < argc; ++i) {\n-        if (!IsSwitchChar(argv[i][0])) {\n-            if (!method.empty()) {\n+    std::string method <%%>;\n+    for(int i = 1; i < argc; ++i) <%\n+        if (!IsSwitchChar(argv[i][0])) <%\n+            if (!method.empty()) <%\n                 fprintf(stderr, \"Error: two methods provided (%s and %s). Only one method should be provided.\\n\", method.c_str(), argv[i]);\n                 return EXIT_FAILURE;\n-            }\n+            %>\n             method = argv[i];\n-        }\n-    }\n+        %>\n+    %>\n \n-    if (method.empty()) {\n+    if (method.empty()) <%\n         fprintf(stderr, \"No method provided. Run `bitcoin-wallet -help` for valid methods.\\n\");\n         return EXIT_FAILURE;\n-    }\n+    %>\n \n     // A name must be provided when creating a file\n-    if (method == \"create\" && !gArgs.IsArgSet(\"-wallet\")) {\n+    if (method == \"create\" && !gArgs.IsArgSet(\"-wallet\")) <%\n         fprintf(stderr, \"Wallet name must be provided when creating a new wallet.\\n\");\n         return EXIT_FAILURE;\n-    }\n+    %>\n \n     std::string name = gArgs.GetArg(\"-wallet\", \"\");\n \n@@ -114,4 +114,4 @@ int main(int argc, char* argv[])\n         return EXIT_FAILURE;\n     ECC_Stop();\n     return EXIT_SUCCESS;\n-}\n+%>"
      },
      {
        "sha": "43d4cb5ea2a8ac192744e702d3980d6f6ab9e3a7",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 47,
        "deletions": 47,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -45,20 +45,20 @@ const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n  */\n \n static void WaitForShutdown()\n-{\n+<%\n     while (!ShutdownRequested())\n-    {\n+    <%\n         MilliSleep(200);\n-    }\n+    %>\n     Interrupt();\n-}\n+%>\n \n //////////////////////////////////////////////////////////////////////////////\n //\n // Start\n //\n static bool AppInit(int argc, char* argv[])\n-{\n+<%\n     InitInterfaces interfaces;\n     interfaces.chain = interfaces::MakeChain();\n \n@@ -70,78 +70,78 @@ static bool AppInit(int argc, char* argv[])\n     // If Qt is used, parameters/bitcoin.conf are parsed in qt/bitcoin.cpp's main()\n     SetupServerArgs();\n     std::string error;\n-    if (!gArgs.ParseParameters(argc, argv, error)) {\n+    if (!gArgs.ParseParameters(argc, argv, error)) <%\n         fprintf(stderr, \"Error parsing command line arguments: %s\\n\", error.c_str());\n         return false;\n-    }\n+    %>\n \n     // Process help and version before taking care about datadir\n-    if (HelpRequested(gArgs) || gArgs.IsArgSet(\"-version\")) {\n+    if (HelpRequested(gArgs) || gArgs.IsArgSet(\"-version\")) <%\n         std::string strUsage = PACKAGE_NAME \" Daemon version \" + FormatFullVersion() + \"\\n\";\n \n         if (gArgs.IsArgSet(\"-version\"))\n-        {\n+        <%\n             strUsage += FormatParagraph(LicenseInfo()) + \"\\n\";\n-        }\n+        %>\n         else\n-        {\n+        <%\n             strUsage += \"\\nUsage:  bitcoind [options]                     Start \" PACKAGE_NAME \" Daemon\\n\";\n             strUsage += \"\\n\" + gArgs.GetHelpMessage();\n-        }\n+        %>\n \n         fprintf(stdout, \"%s\", strUsage.c_str());\n         return true;\n-    }\n+    %>\n \n     try\n-    {\n+    <%\n         if (!fs::is_directory(GetDataDir(false)))\n-        {\n+        <%\n             fprintf(stderr, \"Error: Specified data directory \\\"%s\\\" does not exist.\\n\", gArgs.GetArg(\"-datadir\", \"\").c_str());\n             return false;\n-        }\n-        if (!gArgs.ReadConfigFiles(error, true)) {\n+        %>\n+        if (!gArgs.ReadConfigFiles(error, true)) <%\n             fprintf(stderr, \"Error reading configuration file: %s\\n\", error.c_str());\n             return false;\n-        }\n+        %>\n         // Check for -testnet or -regtest parameter (Params() calls are only valid after this clause)\n-        try {\n+        try <%\n             SelectParams(gArgs.GetChainName());\n-        } catch (const std::exception& e) {\n+        %> catch (const std::exception& e) <%\n             fprintf(stderr, \"Error: %s\\n\", e.what());\n             return false;\n-        }\n+        %>\n \n         // Error out when loose non-argument tokens are encountered on command line\n-        for (int i = 1; i < argc; i++) {\n-            if (!IsSwitchChar(argv[i][0])) {\n+        for (int i = 1; i < argc; i++) <%\n+            if (!IsSwitchChar(argv[i][0])) <%\n                 fprintf(stderr, \"Error: Command line contains unexpected token '%s', see bitcoind -h for a list of options.\\n\", argv[i]);\n                 return false;\n-            }\n-        }\n+            %>\n+        %>\n \n         // -server defaults to true for bitcoind but not for the GUI so do this here\n         gArgs.SoftSetBoolArg(\"-server\", true);\n         // Set this early so that parameter interactions go to console\n         InitLogging();\n         InitParameterInteraction();\n         if (!AppInitBasicSetup())\n-        {\n+        <%\n             // InitError will have been called with detailed error, which ends up on console\n             return false;\n-        }\n+        %>\n         if (!AppInitParameterInteraction())\n-        {\n+        <%\n             // InitError will have been called with detailed error, which ends up on console\n             return false;\n-        }\n+        %>\n         if (!AppInitSanityChecks())\n-        {\n+        <%\n             // InitError will have been called with detailed error, which ends up on console\n             return false;\n-        }\n+        %>\n         if (gArgs.GetBoolArg(\"-daemon\", false))\n-        {\n+        <%\n #if HAVE_DECL_DAEMON\n #if defined(MAC_OSX)\n #pragma GCC diagnostic push\n@@ -150,45 +150,45 @@ static bool AppInit(int argc, char* argv[])\n             fprintf(stdout, \"Bitcoin server starting\\n\");\n \n             // Daemonize\n-            if (daemon(1, 0)) { // don't chdir (1), do close FDs (0)\n+            if (daemon(1, 0)) <% // don't chdir (1), do close FDs (0)\n                 fprintf(stderr, \"Error: daemon() failed: %s\\n\", strerror(errno));\n                 return false;\n-            }\n+            %>\n #if defined(MAC_OSX)\n #pragma GCC diagnostic pop\n #endif\n #else\n             fprintf(stderr, \"Error: -daemon is not supported on this operating system\\n\");\n             return false;\n #endif // HAVE_DECL_DAEMON\n-        }\n+        %>\n         // Lock data directory after daemonization\n         if (!AppInitLockDataDirectory())\n-        {\n+        <%\n             // If locking the data directory failed, exit immediately\n             return false;\n-        }\n+        %>\n         fRet = AppInitMain(interfaces);\n-    }\n-    catch (const std::exception& e) {\n+    %>\n+    catch (const std::exception& e) <%\n         PrintExceptionContinue(&e, \"AppInit()\");\n-    } catch (...) {\n+    %> catch (...) <%\n         PrintExceptionContinue(nullptr, \"AppInit()\");\n-    }\n+    %>\n \n     if (!fRet)\n-    {\n+    <%\n         Interrupt();\n-    } else {\n+    %> else <%\n         WaitForShutdown();\n-    }\n+    %>\n     Shutdown(interfaces);\n \n     return fRet;\n-}\n+%>\n \n int main(int argc, char* argv[])\n-{\n+<%\n #ifdef WIN32\n     util::WinCmdLineArgs winArgs;\n     std::tie(argc, argv) = winArgs.get();\n@@ -199,4 +199,4 @@ int main(int argc, char* argv[])\n     noui_connect();\n \n     return (AppInit(argc, argv) ? EXIT_SUCCESS : EXIT_FAILURE);\n-}\n+%>"
      },
      {
        "sha": "610e9b294bf47e135405c7c3007a8c762bafc84a",
        "filename": "src/blockencodings.cpp",
        "status": "modified",
        "additions": 51,
        "deletions": 51,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/blockencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/blockencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockencodings.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -18,17 +18,17 @@\n \n CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block, bool fUseWTXID) :\n         nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n-        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) <%\n     FillShortTxIDSelector();\n     //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n-    prefilledtxn[0] = {0, block.vtx[0]};\n-    for (size_t i = 1; i < block.vtx.size(); i++) {\n+    prefilledtxn[0] = <%0, block.vtx[0]%>;\n+    for (size_t i = 1; i < block.vtx.size(); i++) <%\n         const CTransaction& tx = *block.vtx[i];\n         shorttxids[i - 1] = GetShortID(fUseWTXID ? tx.GetWitnessHash() : tx.GetHash());\n-    }\n-}\n+    %>\n+%>\n \n-void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const <%\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n     stream << header << nonce;\n     CSHA256 hasher;\n@@ -37,16 +37,16 @@ void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n     hasher.Finalize(shorttxidhash.begin());\n     shorttxidk0 = shorttxidhash.GetUint64(0);\n     shorttxidk1 = shorttxidhash.GetUint64(1);\n-}\n+%>\n \n-uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const <%\n     static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n     return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n-}\n+%>\n \n \n \n-ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock, const std::vector<std::pair<uint256, CTransactionRef>>& extra_txn) {\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock, const std::vector<std::pair<uint256, CTransactionRef>>& extra_txn) <%\n     if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n         return READ_STATUS_INVALID;\n     if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_WEIGHT / MIN_SERIALIZABLE_TRANSACTION_WEIGHT)\n@@ -57,21 +57,21 @@ ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& c\n     txn_available.resize(cmpctblock.BlockTxCount());\n \n     int32_t lastprefilledindex = -1;\n-    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) <%\n         if (cmpctblock.prefilledtxn[i].tx->IsNull())\n             return READ_STATUS_INVALID;\n \n         lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1; //index is a uint16_t, so can't overflow here\n         if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n             return READ_STATUS_INVALID;\n-        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i) {\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i) <%\n             // If we are inserting a tx at an index greater than our full list of shorttxids\n             // plus the number of prefilled txn we've inserted, then we have txn for which we\n             // have neither a prefilled txn or a shorttxid!\n             return READ_STATUS_INVALID;\n-        }\n+        %>\n         txn_available[lastprefilledindex] = cmpctblock.prefilledtxn[i].tx;\n-    }\n+    %>\n     prefilled_count = cmpctblock.prefilledtxn.size();\n \n     // Calculate map of txids -> positions and check mempool to see what we have (or don't)\n@@ -80,7 +80,7 @@ ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& c\n     // READ_STATUS_FAILED.\n     std::unordered_map<uint64_t, uint16_t> shorttxids(cmpctblock.shorttxids.size());\n     uint16_t index_offset = 0;\n-    for (size_t i = 0; i < cmpctblock.shorttxids.size(); i++) {\n+    for (size_t i = 0; i < cmpctblock.shorttxids.size(); i++) <%\n         while (txn_available[i + index_offset])\n             index_offset++;\n         shorttxids[cmpctblock.shorttxids[i]] = i + index_offset;\n@@ -96,99 +96,99 @@ ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& c\n         // only fail once per ~1 million block transfers (per peer and connection).\n         if (shorttxids.bucket_size(shorttxids.bucket(cmpctblock.shorttxids[i])) > 12)\n             return READ_STATUS_FAILED;\n-    }\n+    %>\n     // TODO: in the shortid-collision case, we should instead request both transactions\n     // which collided. Falling back to full-block-request here is overkill.\n     if (shorttxids.size() != cmpctblock.shorttxids.size())\n         return READ_STATUS_FAILED; // Short ID collision\n \n     std::vector<bool> have_txn(txn_available.size());\n-    {\n+    <%\n     LOCK(pool->cs);\n     const std::vector<std::pair<uint256, CTxMemPool::txiter> >& vTxHashes = pool->vTxHashes;\n-    for (size_t i = 0; i < vTxHashes.size(); i++) {\n+    for (size_t i = 0; i < vTxHashes.size(); i++) <%\n         uint64_t shortid = cmpctblock.GetShortID(vTxHashes[i].first);\n         std::unordered_map<uint64_t, uint16_t>::iterator idit = shorttxids.find(shortid);\n-        if (idit != shorttxids.end()) {\n-            if (!have_txn[idit->second]) {\n+        if (idit != shorttxids.end()) <%\n+            if (!have_txn[idit->second]) <%\n                 txn_available[idit->second] = vTxHashes[i].second->GetSharedTx();\n                 have_txn[idit->second]  = true;\n                 mempool_count++;\n-            } else {\n+            %> else <%\n                 // If we find two mempool txn that match the short id, just request it.\n                 // This should be rare enough that the extra bandwidth doesn't matter,\n                 // but eating a round-trip due to FillBlock failure would be annoying\n-                if (txn_available[idit->second]) {\n+                if (txn_available[idit->second]) <%\n                     txn_available[idit->second].reset();\n                     mempool_count--;\n-                }\n-            }\n-        }\n+                %>\n+            %>\n+        %>\n         // Though ideally we'd continue scanning for the two-txn-match-shortid case,\n         // the performance win of an early exit here is too good to pass up and worth\n         // the extra risk.\n         if (mempool_count == shorttxids.size())\n             break;\n-    }\n-    }\n+    %>\n+    %>\n \n-    for (size_t i = 0; i < extra_txn.size(); i++) {\n+    for (size_t i = 0; i < extra_txn.size(); i++) <%\n         uint64_t shortid = cmpctblock.GetShortID(extra_txn[i].first);\n         std::unordered_map<uint64_t, uint16_t>::iterator idit = shorttxids.find(shortid);\n-        if (idit != shorttxids.end()) {\n-            if (!have_txn[idit->second]) {\n+        if (idit != shorttxids.end()) <%\n+            if (!have_txn[idit->second]) <%\n                 txn_available[idit->second] = extra_txn[i].second;\n                 have_txn[idit->second]  = true;\n                 mempool_count++;\n                 extra_count++;\n-            } else {\n+            %> else <%\n                 // If we find two mempool/extra txn that match the short id, just\n                 // request it.\n                 // This should be rare enough that the extra bandwidth doesn't matter,\n                 // but eating a round-trip due to FillBlock failure would be annoying\n                 // Note that we don't want duplication between extra_txn and mempool to\n                 // trigger this case, so we compare witness hashes first\n                 if (txn_available[idit->second] &&\n-                        txn_available[idit->second]->GetWitnessHash() != extra_txn[i].second->GetWitnessHash()) {\n+                        txn_available[idit->second]->GetWitnessHash() != extra_txn[i].second->GetWitnessHash()) <%\n                     txn_available[idit->second].reset();\n                     mempool_count--;\n                     extra_count--;\n-                }\n-            }\n-        }\n+                %>\n+            %>\n+        %>\n         // Though ideally we'd continue scanning for the two-txn-match-shortid case,\n         // the performance win of an early exit here is too good to pass up and worth\n         // the extra risk.\n         if (mempool_count == shorttxids.size())\n             break;\n-    }\n+    %>\n \n     LogPrint(BCLog::CMPCTBLOCK, \"Initialized PartiallyDownloadedBlock for block %s using a cmpctblock of size %lu\\n\", cmpctblock.header.GetHash().ToString(), GetSerializeSize(cmpctblock, PROTOCOL_VERSION));\n \n     return READ_STATUS_OK;\n-}\n+%>\n \n-bool PartiallyDownloadedBlock::IsTxAvailable(size_t index) const {\n+bool PartiallyDownloadedBlock::IsTxAvailable(size_t index) const <%\n     assert(!header.IsNull());\n     assert(index < txn_available.size());\n     return txn_available[index] != nullptr;\n-}\n+%>\n \n-ReadStatus PartiallyDownloadedBlock::FillBlock(CBlock& block, const std::vector<CTransactionRef>& vtx_missing) {\n+ReadStatus PartiallyDownloadedBlock::FillBlock(CBlock& block, const std::vector<CTransactionRef>& vtx_missing) <%\n     assert(!header.IsNull());\n     uint256 hash = header.GetHash();\n     block = header;\n     block.vtx.resize(txn_available.size());\n \n     size_t tx_missing_offset = 0;\n-    for (size_t i = 0; i < txn_available.size(); i++) {\n-        if (!txn_available[i]) {\n+    for (size_t i = 0; i < txn_available.size(); i++) <%\n+        if (!txn_available[i]) <%\n             if (vtx_missing.size() <= tx_missing_offset)\n                 return READ_STATUS_INVALID;\n             block.vtx[i] = vtx_missing[tx_missing_offset++];\n-        } else\n+        %> else\n             block.vtx[i] = std::move(txn_available[i]);\n-    }\n+    %>\n \n     // Make sure we can't call FillBlock again.\n     header.SetNull();\n@@ -198,22 +198,22 @@ ReadStatus PartiallyDownloadedBlock::FillBlock(CBlock& block, const std::vector<\n         return READ_STATUS_INVALID;\n \n     CValidationState state;\n-    if (!CheckBlock(block, state, Params().GetConsensus())) {\n+    if (!CheckBlock(block, state, Params().GetConsensus())) <%\n         // TODO: We really want to just check merkle tree manually here,\n         // but that is expensive, and CheckBlock caches a block's\n         // \"checked-status\" (in the CBlock?). CBlock should be able to\n         // check its own merkle root and cache that check.\n         if (state.CorruptionPossible())\n             return READ_STATUS_FAILED; // Possible Short ID collision\n         return READ_STATUS_CHECKBLOCK_FAILED;\n-    }\n+    %>\n \n     LogPrint(BCLog::CMPCTBLOCK, \"Successfully reconstructed block %s with %lu txn prefilled, %lu txn from mempool (incl at least %lu from extra pool) and %lu txn requested\\n\", hash.ToString(), prefilled_count, mempool_count, extra_count, vtx_missing.size());\n-    if (vtx_missing.size() < 5) {\n-        for (const auto& tx : vtx_missing) {\n+    if (vtx_missing.size() < 5) <%\n+        for (const auto& tx : vtx_missing) <%\n             LogPrint(BCLog::CMPCTBLOCK, \"Reconstructed block %s required tx %s\\n\", hash.ToString(), tx->GetHash().ToString());\n-        }\n-    }\n+        %>\n+    %>\n \n     return READ_STATUS_OK;\n-}\n+%>"
      },
      {
        "sha": "aa45f1db965332c95b5547f308cd9fba9efbfeb0",
        "filename": "src/blockencodings.h",
        "status": "modified",
        "additions": 55,
        "deletions": 55,
        "changes": 110,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/blockencodings.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/blockencodings.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockencodings.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -12,21 +12,21 @@\n class CTxMemPool;\n \n // Dumb helper to handle CTransaction compression at serialize-time\n-struct TransactionCompressor {\n+struct TransactionCompressor <%\n private:\n     CTransactionRef& tx;\n public:\n-    explicit TransactionCompressor(CTransactionRef& txIn) : tx(txIn) {}\n+    explicit TransactionCompressor(CTransactionRef& txIn) : tx(txIn) <%%>\n \n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action) {\n+    inline void SerializationOp(Stream& s, Operation ser_action) <%\n         READWRITE(tx); //TODO: Compress tx encoding\n-    }\n-};\n+    %>\n+%>;\n \n-class BlockTransactionsRequest {\n+class BlockTransactionsRequest <%\n public:\n     // A BlockTransactionsRequest message\n     uint256 blockhash;\n@@ -35,72 +35,72 @@ class BlockTransactionsRequest {\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action) {\n+    inline void SerializationOp(Stream& s, Operation ser_action) <%\n         READWRITE(blockhash);\n         uint64_t indexes_size = (uint64_t)indexes.size();\n         READWRITE(COMPACTSIZE(indexes_size));\n-        if (ser_action.ForRead()) {\n+        if (ser_action.ForRead()) <%\n             size_t i = 0;\n-            while (indexes.size() < indexes_size) {\n+            while (indexes.size() < indexes_size) <%\n                 indexes.resize(std::min((uint64_t)(1000 + indexes.size()), indexes_size));\n-                for (; i < indexes.size(); i++) {\n+                for (; i < indexes.size(); i++) <%\n                     uint64_t index = 0;\n                     READWRITE(COMPACTSIZE(index));\n                     if (index > std::numeric_limits<uint16_t>::max())\n                         throw std::ios_base::failure(\"index overflowed 16 bits\");\n                     indexes[i] = index;\n-                }\n-            }\n+                %>\n+            %>\n \n             int32_t offset = 0;\n-            for (size_t j = 0; j < indexes.size(); j++) {\n+            for (size_t j = 0; j < indexes.size(); j++) <%\n                 if (int32_t(indexes[j]) + offset > std::numeric_limits<uint16_t>::max())\n                     throw std::ios_base::failure(\"indexes overflowed 16 bits\");\n                 indexes[j] = indexes[j] + offset;\n                 offset = int32_t(indexes[j]) + 1;\n-            }\n-        } else {\n-            for (size_t i = 0; i < indexes.size(); i++) {\n+            %>\n+        %> else <%\n+            for (size_t i = 0; i < indexes.size(); i++) <%\n                 uint64_t index = indexes[i] - (i == 0 ? 0 : (indexes[i - 1] + 1));\n                 READWRITE(COMPACTSIZE(index));\n-            }\n-        }\n-    }\n-};\n+            %>\n+        %>\n+    %>\n+%>;\n \n-class BlockTransactions {\n+class BlockTransactions <%\n public:\n     // A BlockTransactions message\n     uint256 blockhash;\n     std::vector<CTransactionRef> txn;\n \n-    BlockTransactions() {}\n+    BlockTransactions() <%%>\n     explicit BlockTransactions(const BlockTransactionsRequest& req) :\n-        blockhash(req.blockhash), txn(req.indexes.size()) {}\n+        blockhash(req.blockhash), txn(req.indexes.size()) <%%>\n \n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action) {\n+    inline void SerializationOp(Stream& s, Operation ser_action) <%\n         READWRITE(blockhash);\n         uint64_t txn_size = (uint64_t)txn.size();\n         READWRITE(COMPACTSIZE(txn_size));\n-        if (ser_action.ForRead()) {\n+        if (ser_action.ForRead()) <%\n             size_t i = 0;\n-            while (txn.size() < txn_size) {\n+            while (txn.size() < txn_size) <%\n                 txn.resize(std::min((uint64_t)(1000 + txn.size()), txn_size));\n                 for (; i < txn.size(); i++)\n                     READWRITE(TransactionCompressor(txn[i]));\n-            }\n-        } else {\n+            %>\n+        %> else <%\n             for (size_t i = 0; i < txn.size(); i++)\n                 READWRITE(TransactionCompressor(txn[i]));\n-        }\n-    }\n-};\n+        %>\n+    %>\n+%>;\n \n // Dumb serialization/storage-helper for CBlockHeaderAndShortTxIDs and PartiallyDownloadedBlock\n-struct PrefilledTransaction {\n+struct PrefilledTransaction <%\n     // Used as an offset since last prefilled tx in CBlockHeaderAndShortTxIDs,\n     // as a proper transaction-in-block-index in PartiallyDownloadedBlock\n     uint16_t index;\n@@ -109,26 +109,26 @@ struct PrefilledTransaction {\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action) {\n+    inline void SerializationOp(Stream& s, Operation ser_action) <%\n         uint64_t idx = index;\n         READWRITE(COMPACTSIZE(idx));\n         if (idx > std::numeric_limits<uint16_t>::max())\n             throw std::ios_base::failure(\"index overflowed 16-bits\");\n         index = idx;\n         READWRITE(TransactionCompressor(tx));\n-    }\n-};\n+    %>\n+%>;\n \n typedef enum ReadStatus_t\n-{\n+<%\n     READ_STATUS_OK,\n     READ_STATUS_INVALID, // Invalid object, peer is sending bogus crap\n     READ_STATUS_FAILED, // Failed to process object\n     READ_STATUS_CHECKBLOCK_FAILED, // Used only by FillBlock to indicate a\n                                    // failure in CheckBlock.\n-} ReadStatus;\n+%> ReadStatus;\n \n-class CBlockHeaderAndShortTxIDs {\n+class CBlockHeaderAndShortTxIDs <%\n private:\n     mutable uint64_t shorttxidk0, shorttxidk1;\n     uint64_t nonce;\n@@ -146,43 +146,43 @@ class CBlockHeaderAndShortTxIDs {\n     CBlockHeader header;\n \n     // Dummy for deserialization\n-    CBlockHeaderAndShortTxIDs() {}\n+    CBlockHeaderAndShortTxIDs() <%%>\n \n     CBlockHeaderAndShortTxIDs(const CBlock& block, bool fUseWTXID);\n \n     uint64_t GetShortID(const uint256& txhash) const;\n \n-    size_t BlockTxCount() const { return shorttxids.size() + prefilledtxn.size(); }\n+    size_t BlockTxCount() const <% return shorttxids.size() + prefilledtxn.size(); %>\n \n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action) {\n+    inline void SerializationOp(Stream& s, Operation ser_action) <%\n         READWRITE(header);\n         READWRITE(nonce);\n \n         uint64_t shorttxids_size = (uint64_t)shorttxids.size();\n         READWRITE(COMPACTSIZE(shorttxids_size));\n-        if (ser_action.ForRead()) {\n+        if (ser_action.ForRead()) <%\n             size_t i = 0;\n-            while (shorttxids.size() < shorttxids_size) {\n+            while (shorttxids.size() < shorttxids_size) <%\n                 shorttxids.resize(std::min((uint64_t)(1000 + shorttxids.size()), shorttxids_size));\n-                for (; i < shorttxids.size(); i++) {\n+                for (; i < shorttxids.size(); i++) <%\n                     uint32_t lsb = 0; uint16_t msb = 0;\n                     READWRITE(lsb);\n                     READWRITE(msb);\n                     shorttxids[i] = (uint64_t(msb) << 32) | uint64_t(lsb);\n                     static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids serialization assumes 6-byte shorttxids\");\n-                }\n-            }\n-        } else {\n-            for (size_t i = 0; i < shorttxids.size(); i++) {\n+                %>\n+            %>\n+        %> else <%\n+            for (size_t i = 0; i < shorttxids.size(); i++) <%\n                 uint32_t lsb = shorttxids[i] & 0xffffffff;\n                 uint16_t msb = (shorttxids[i] >> 32) & 0xffff;\n                 READWRITE(lsb);\n                 READWRITE(msb);\n-            }\n-        }\n+            %>\n+        %>\n \n         READWRITE(prefilledtxn);\n \n@@ -191,22 +191,22 @@ class CBlockHeaderAndShortTxIDs {\n \n         if (ser_action.ForRead())\n             FillShortTxIDSelector();\n-    }\n-};\n+    %>\n+%>;\n \n-class PartiallyDownloadedBlock {\n+class PartiallyDownloadedBlock <%\n protected:\n     std::vector<CTransactionRef> txn_available;\n     size_t prefilled_count = 0, mempool_count = 0, extra_count = 0;\n     CTxMemPool* pool;\n public:\n     CBlockHeader header;\n-    explicit PartiallyDownloadedBlock(CTxMemPool* poolIn) : pool(poolIn) {}\n+    explicit PartiallyDownloadedBlock(CTxMemPool* poolIn) : pool(poolIn) <%%>\n \n     // extra_txn is a list of extra transactions to look at, in <witness hash, reference> form\n     ReadStatus InitData(const CBlockHeaderAndShortTxIDs& cmpctblock, const std::vector<std::pair<uint256, CTransactionRef>>& extra_txn);\n     bool IsTxAvailable(size_t index) const;\n     ReadStatus FillBlock(CBlock& block, const std::vector<CTransactionRef>& vtx_missing);\n-};\n+%>;\n \n #endif // BITCOIN_BLOCKENCODINGS_H"
      },
      {
        "sha": "f79b2b04032a9260aea18942b54654b49f1f0ac4",
        "filename": "src/blockfilter.cpp",
        "status": "modified",
        "additions": 74,
        "deletions": 74,
        "changes": 148,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/blockfilter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/blockfilter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockfilter.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -17,42 +17,42 @@ static constexpr int GCS_SER_VERSION = 0;\n \n template <typename OStream>\n static void GolombRiceEncode(BitStreamWriter<OStream>& bitwriter, uint8_t P, uint64_t x)\n-{\n+<%\n     // Write quotient as unary-encoded: q 1's followed by one 0.\n     uint64_t q = x >> P;\n-    while (q > 0) {\n+    while (q > 0) <%\n         int nbits = q <= 64 ? static_cast<int>(q) : 64;\n         bitwriter.Write(~0ULL, nbits);\n         q -= nbits;\n-    }\n+    %>\n     bitwriter.Write(0, 1);\n \n     // Write the remainder in P bits. Since the remainder is just the bottom\n     // P bits of x, there is no need to mask first.\n     bitwriter.Write(x, P);\n-}\n+%>\n \n template <typename IStream>\n static uint64_t GolombRiceDecode(BitStreamReader<IStream>& bitreader, uint8_t P)\n-{\n+<%\n     // Read unary-encoded quotient: q 1's followed by one 0.\n     uint64_t q = 0;\n-    while (bitreader.Read(1) == 1) {\n+    while (bitreader.Read(1) == 1) <%\n         ++q;\n-    }\n+    %>\n \n     uint64_t r = bitreader.Read(P);\n \n     return (q << P) + r;\n-}\n+%>\n \n // Map a value x that is uniformly distributed in the range [0, 2^64) to a\n // value uniformly distributed in [0, n) by returning the upper 64 bits of\n // x * n.\n //\n // See: https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/\n static uint64_t MapIntoRange(uint64_t x, uint64_t n)\n-{\n+<%\n #ifdef __SIZEOF_INT128__\n     return (static_cast<unsigned __int128>(x) * static_cast<unsigned __int128>(n)) >> 64;\n #else\n@@ -75,86 +75,86 @@ static uint64_t MapIntoRange(uint64_t x, uint64_t n)\n     uint64_t upper64 = ac + (bc >> 32) + (ad >> 32) + (mid34 >> 32);\n     return upper64;\n #endif\n-}\n+%>\n \n uint64_t GCSFilter::HashToRange(const Element& element) const\n-{\n+<%\n     uint64_t hash = CSipHasher(m_params.m_siphash_k0, m_params.m_siphash_k1)\n         .Write(element.data(), element.size())\n         .Finalize();\n     return MapIntoRange(hash, m_F);\n-}\n+%>\n \n std::vector<uint64_t> GCSFilter::BuildHashedSet(const ElementSet& elements) const\n-{\n+<%\n     std::vector<uint64_t> hashed_elements;\n     hashed_elements.reserve(elements.size());\n-    for (const Element& element : elements) {\n+    for (const Element& element : elements) <%\n         hashed_elements.push_back(HashToRange(element));\n-    }\n+    %>\n     std::sort(hashed_elements.begin(), hashed_elements.end());\n     return hashed_elements;\n-}\n+%>\n \n GCSFilter::GCSFilter(const Params& params)\n-    : m_params(params), m_N(0), m_F(0), m_encoded{0}\n-{}\n+    : m_params(params), m_N(0), m_F(0), m_encoded<%0%>\n+<%%>\n \n GCSFilter::GCSFilter(const Params& params, std::vector<unsigned char> encoded_filter)\n     : m_params(params), m_encoded(std::move(encoded_filter))\n-{\n+<%\n     VectorReader stream(GCS_SER_TYPE, GCS_SER_VERSION, m_encoded, 0);\n \n     uint64_t N = ReadCompactSize(stream);\n     m_N = static_cast<uint32_t>(N);\n-    if (m_N != N) {\n+    if (m_N != N) <%\n         throw std::ios_base::failure(\"N must be <2^32\");\n-    }\n+    %>\n     m_F = static_cast<uint64_t>(m_N) * static_cast<uint64_t>(m_params.m_M);\n \n     // Verify that the encoded filter contains exactly N elements. If it has too much or too little\n     // data, a std::ios_base::failure exception will be raised.\n     BitStreamReader<VectorReader> bitreader(stream);\n-    for (uint64_t i = 0; i < m_N; ++i) {\n+    for (uint64_t i = 0; i < m_N; ++i) <%\n         GolombRiceDecode(bitreader, m_params.m_P);\n-    }\n-    if (!stream.empty()) {\n+    %>\n+    if (!stream.empty()) <%\n         throw std::ios_base::failure(\"encoded_filter contains excess data\");\n-    }\n-}\n+    %>\n+%>\n \n GCSFilter::GCSFilter(const Params& params, const ElementSet& elements)\n     : m_params(params)\n-{\n+<%\n     size_t N = elements.size();\n     m_N = static_cast<uint32_t>(N);\n-    if (m_N != N) {\n+    if (m_N != N) <%\n         throw std::invalid_argument(\"N must be <2^32\");\n-    }\n+    %>\n     m_F = static_cast<uint64_t>(m_N) * static_cast<uint64_t>(m_params.m_M);\n \n     CVectorWriter stream(GCS_SER_TYPE, GCS_SER_VERSION, m_encoded, 0);\n \n     WriteCompactSize(stream, m_N);\n \n-    if (elements.empty()) {\n+    if (elements.empty()) <%\n         return;\n-    }\n+    %>\n \n     BitStreamWriter<CVectorWriter> bitwriter(stream);\n \n     uint64_t last_value = 0;\n-    for (uint64_t value : BuildHashedSet(elements)) {\n+    for (uint64_t value : BuildHashedSet(elements)) <%\n         uint64_t delta = value - last_value;\n         GolombRiceEncode(bitwriter, m_params.m_P, delta);\n         last_value = value;\n-    }\n+    %>\n \n     bitwriter.Flush();\n-}\n+%>\n \n bool GCSFilter::MatchInternal(const uint64_t* element_hashes, size_t size) const\n-{\n+<%\n     VectorReader stream(GCS_SER_TYPE, GCS_SER_VERSION, m_encoded, 0);\n \n     // Seek forward by size of N\n@@ -165,86 +165,86 @@ bool GCSFilter::MatchInternal(const uint64_t* element_hashes, size_t size) const\n \n     uint64_t value = 0;\n     size_t hashes_index = 0;\n-    for (uint32_t i = 0; i < m_N; ++i) {\n+    for (uint32_t i = 0; i < m_N; ++i) <%\n         uint64_t delta = GolombRiceDecode(bitreader, m_params.m_P);\n         value += delta;\n \n-        while (true) {\n-            if (hashes_index == size) {\n+        while (true) <%\n+            if (hashes_index == size) <%\n                 return false;\n-            } else if (element_hashes[hashes_index] == value) {\n+            %> else if (element_hashes[hashes_index] == value) <%\n                 return true;\n-            } else if (element_hashes[hashes_index] > value) {\n+            %> else if (element_hashes[hashes_index] > value) <%\n                 break;\n-            }\n+            %>\n \n             hashes_index++;\n-        }\n-    }\n+        %>\n+    %>\n \n     return false;\n-}\n+%>\n \n bool GCSFilter::Match(const Element& element) const\n-{\n+<%\n     uint64_t query = HashToRange(element);\n     return MatchInternal(&query, 1);\n-}\n+%>\n \n bool GCSFilter::MatchAny(const ElementSet& elements) const\n-{\n+<%\n     const std::vector<uint64_t> queries = BuildHashedSet(elements);\n     return MatchInternal(queries.data(), queries.size());\n-}\n+%>\n \n static GCSFilter::ElementSet BasicFilterElements(const CBlock& block,\n                                                  const CBlockUndo& block_undo)\n-{\n+<%\n     GCSFilter::ElementSet elements;\n \n-    for (const CTransactionRef& tx : block.vtx) {\n-        for (const CTxOut& txout : tx->vout) {\n+    for (const CTransactionRef& tx : block.vtx) <%\n+        for (const CTxOut& txout : tx->vout) <%\n             const CScript& script = txout.scriptPubKey;\n             if (script.empty() || script[0] == OP_RETURN) continue;\n             elements.emplace(script.begin(), script.end());\n-        }\n-    }\n+        %>\n+    %>\n \n-    for (const CTxUndo& tx_undo : block_undo.vtxundo) {\n-        for (const Coin& prevout : tx_undo.vprevout) {\n+    for (const CTxUndo& tx_undo : block_undo.vtxundo) <%\n+        for (const Coin& prevout : tx_undo.vprevout) <%\n             const CScript& script = prevout.out.scriptPubKey;\n             if (script.empty()) continue;\n             elements.emplace(script.begin(), script.end());\n-        }\n-    }\n+        %>\n+    %>\n \n     return elements;\n-}\n+%>\n \n BlockFilter::BlockFilter(BlockFilterType filter_type, const uint256& block_hash,\n                          std::vector<unsigned char> filter)\n     : m_filter_type(filter_type), m_block_hash(block_hash)\n-{\n+<%\n     GCSFilter::Params params;\n-    if (!BuildParams(params)) {\n+    if (!BuildParams(params)) <%\n         throw std::invalid_argument(\"unknown filter_type\");\n-    }\n+    %>\n     m_filter = GCSFilter(params, std::move(filter));\n-}\n+%>\n \n BlockFilter::BlockFilter(BlockFilterType filter_type, const CBlock& block, const CBlockUndo& block_undo)\n     : m_filter_type(filter_type), m_block_hash(block.GetHash())\n-{\n+<%\n     GCSFilter::Params params;\n-    if (!BuildParams(params)) {\n+    if (!BuildParams(params)) <%\n         throw std::invalid_argument(\"unknown filter_type\");\n-    }\n+    %>\n     m_filter = GCSFilter(params, BasicFilterElements(block, block_undo));\n-}\n+%>\n \n bool BlockFilter::BuildParams(GCSFilter::Params& params) const\n-{\n-    switch (m_filter_type) {\n+<%\n+    switch (m_filter_type) <%\n     case BlockFilterType::BASIC:\n         params.m_siphash_k0 = m_block_hash.GetUint64(0);\n         params.m_siphash_k1 = m_block_hash.GetUint64(1);\n@@ -253,22 +253,22 @@ bool BlockFilter::BuildParams(GCSFilter::Params& params) const\n         return true;\n     case BlockFilterType::INVALID:\n         return false;\n-    }\n+    %>\n \n     return false;\n-}\n+%>\n \n uint256 BlockFilter::GetHash() const\n-{\n+<%\n     const std::vector<unsigned char>& data = GetEncodedFilter();\n \n     uint256 result;\n     CHash256().Write(data.data(), data.size()).Finalize(result.begin());\n     return result;\n-}\n+%>\n \n uint256 BlockFilter::ComputeHeader(const uint256& prev_header) const\n-{\n+<%\n     const uint256& filter_hash = GetHash();\n \n     uint256 result;\n@@ -277,4 +277,4 @@ uint256 BlockFilter::ComputeHeader(const uint256& prev_header) const\n         .Write(prev_header.begin(), prev_header.size())\n         .Finalize(result.begin());\n     return result;\n-}\n+%>"
      },
      {
        "sha": "17363f7f02f560239b13869f4524df441266e235",
        "filename": "src/blockfilter.h",
        "status": "modified",
        "additions": 23,
        "deletions": 23,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/blockfilter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/blockfilter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockfilter.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -20,22 +20,22 @@\n  * compact, probabilistic data structure for testing set membership.\n  */\n class GCSFilter\n-{\n+<%\n public:\n     typedef std::vector<unsigned char> Element;\n     typedef std::unordered_set<Element, ByteVectorHash> ElementSet;\n \n     struct Params\n-    {\n+    <%\n         uint64_t m_siphash_k0;\n         uint64_t m_siphash_k1;\n         uint8_t m_P;  //!< Golomb-Rice coding parameter\n         uint32_t m_M;  //!< Inverse false positive rate\n \n         Params(uint64_t siphash_k0 = 0, uint64_t siphash_k1 = 0, uint8_t P = 0, uint32_t M = 1)\n             : m_siphash_k0(siphash_k0), m_siphash_k1(siphash_k1), m_P(P), m_M(M)\n-        {}\n-    };\n+        <%%>\n+    %>;\n \n private:\n     Params m_params;\n@@ -62,9 +62,9 @@ class GCSFilter\n     /** Builds a new filter from the params and set of elements. */\n     GCSFilter(const Params& params, const ElementSet& elements);\n \n-    uint32_t GetN() const { return m_N; }\n-    const Params& GetParams() const { return m_params; }\n-    const std::vector<unsigned char>& GetEncoded() const { return m_encoded; }\n+    uint32_t GetN() const <% return m_N; %>\n+    const Params& GetParams() const <% return m_params; %>\n+    const std::vector<unsigned char>& GetEncoded() const <% return m_encoded; %>\n \n     /**\n      * Checks if the element may be in the set. False positives are possible\n@@ -78,23 +78,23 @@ class GCSFilter\n      * efficient that checking Match on multiple elements separately.\n      */\n     bool MatchAny(const ElementSet& elements) const;\n-};\n+%>;\n \n constexpr uint8_t BASIC_FILTER_P = 19;\n constexpr uint32_t BASIC_FILTER_M = 784931;\n \n enum class BlockFilterType : uint8_t\n-{\n+<%\n     BASIC = 0,\n     INVALID = 255,\n-};\n+%>;\n \n /**\n  * Complete block filter struct as defined in BIP 157. Serialization matches\n  * payload of \"cfilter\" messages.\n  */\n class BlockFilter\n-{\n+<%\n private:\n     BlockFilterType m_filter_type = BlockFilterType::INVALID;\n     uint256 m_block_hash;\n@@ -113,14 +113,14 @@ class BlockFilter\n     //! Construct a new BlockFilter of the specified type from a block.\n     BlockFilter(BlockFilterType filter_type, const CBlock& block, const CBlockUndo& block_undo);\n \n-    BlockFilterType GetFilterType() const { return m_filter_type; }\n-    const uint256& GetBlockHash() const { return m_block_hash; }\n-    const GCSFilter& GetFilter() const { return m_filter; }\n+    BlockFilterType GetFilterType() const <% return m_filter_type; %>\n+    const uint256& GetBlockHash() const <% return m_block_hash; %>\n+    const GCSFilter& GetFilter() const <% return m_filter; %>\n \n     const std::vector<unsigned char>& GetEncodedFilter() const\n-    {\n+    <%\n         return m_filter.GetEncoded();\n-    }\n+    %>\n \n     //! Compute the filter hash.\n     uint256 GetHash() const;\n@@ -129,14 +129,14 @@ class BlockFilter\n     uint256 ComputeHeader(const uint256& prev_header) const;\n \n     template <typename Stream>\n-    void Serialize(Stream& s) const {\n+    void Serialize(Stream& s) const <%\n         s << m_block_hash\n           << static_cast<uint8_t>(m_filter_type)\n           << m_filter.GetEncoded();\n-    }\n+    %>\n \n     template <typename Stream>\n-    void Unserialize(Stream& s) {\n+    void Unserialize(Stream& s) <%\n         std::vector<unsigned char> encoded_filter;\n         uint8_t filter_type;\n \n@@ -147,11 +147,11 @@ class BlockFilter\n         m_filter_type = static_cast<BlockFilterType>(filter_type);\n \n         GCSFilter::Params params;\n-        if (!BuildParams(params)) {\n+        if (!BuildParams(params)) <%\n             throw std::ios_base::failure(\"unknown filter_type\");\n-        }\n+        %>\n         m_filter = GCSFilter(params, std::move(encoded_filter));\n-    }\n-};\n+    %>\n+%>;\n \n #endif // BITCOIN_BLOCKFILTER_H"
      },
      {
        "sha": "1073954eadaa37cd5022cdf33e3c2ffb725247f9",
        "filename": "src/bloom.cpp",
        "status": "modified",
        "additions": 76,
        "deletions": 76,
        "changes": 152,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bloom.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bloom.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -35,92 +35,92 @@ CBloomFilter::CBloomFilter(const unsigned int nElements, const double nFPRate, c\n     nHashFuncs(std::min((unsigned int)(vData.size() * 8 / nElements * LN2), MAX_HASH_FUNCS)),\n     nTweak(nTweakIn),\n     nFlags(nFlagsIn)\n-{\n-}\n+<%\n+%>\n \n inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n-{\n+<%\n     // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n     return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n-}\n+%>\n \n void CBloomFilter::insert(const std::vector<unsigned char>& vKey)\n-{\n+<%\n     if (isFull)\n         return;\n     for (unsigned int i = 0; i < nHashFuncs; i++)\n-    {\n+    <%\n         unsigned int nIndex = Hash(i, vKey);\n         // Sets bit nIndex of vData\n         vData[nIndex >> 3] |= (1 << (7 & nIndex));\n-    }\n+    %>\n     isEmpty = false;\n-}\n+%>\n \n void CBloomFilter::insert(const COutPoint& outpoint)\n-{\n+<%\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n     stream << outpoint;\n     std::vector<unsigned char> data(stream.begin(), stream.end());\n     insert(data);\n-}\n+%>\n \n void CBloomFilter::insert(const uint256& hash)\n-{\n+<%\n     std::vector<unsigned char> data(hash.begin(), hash.end());\n     insert(data);\n-}\n+%>\n \n bool CBloomFilter::contains(const std::vector<unsigned char>& vKey) const\n-{\n+<%\n     if (isFull)\n         return true;\n     if (isEmpty)\n         return false;\n     for (unsigned int i = 0; i < nHashFuncs; i++)\n-    {\n+    <%\n         unsigned int nIndex = Hash(i, vKey);\n         // Checks bit nIndex of vData\n         if (!(vData[nIndex >> 3] & (1 << (7 & nIndex))))\n             return false;\n-    }\n+    %>\n     return true;\n-}\n+%>\n \n bool CBloomFilter::contains(const COutPoint& outpoint) const\n-{\n+<%\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n     stream << outpoint;\n     std::vector<unsigned char> data(stream.begin(), stream.end());\n     return contains(data);\n-}\n+%>\n \n bool CBloomFilter::contains(const uint256& hash) const\n-{\n+<%\n     std::vector<unsigned char> data(hash.begin(), hash.end());\n     return contains(data);\n-}\n+%>\n \n void CBloomFilter::clear()\n-{\n+<%\n     vData.assign(vData.size(),0);\n     isFull = false;\n     isEmpty = true;\n-}\n+%>\n \n void CBloomFilter::reset(const unsigned int nNewTweak)\n-{\n+<%\n     clear();\n     nTweak = nNewTweak;\n-}\n+%>\n \n bool CBloomFilter::IsWithinSizeConstraints() const\n-{\n+<%\n     return vData.size() <= MAX_BLOOM_FILTER_SIZE && nHashFuncs <= MAX_HASH_FUNCS;\n-}\n+%>\n \n bool CBloomFilter::IsRelevantAndUpdate(const CTransaction& tx)\n-{\n+<%\n     bool fFound = false;\n     // Match if the filter contains the hash of tx\n     //  for finding tx when they appear in a block\n@@ -133,7 +133,7 @@ bool CBloomFilter::IsRelevantAndUpdate(const CTransaction& tx)\n         fFound = true;\n \n     for (unsigned int i = 0; i < tx.vout.size(); i++)\n-    {\n+    <%\n         const CTxOut& txout = tx.vout[i];\n         // Match if the filter contains any arbitrary script data element in any scriptPubKey in tx\n         // If this matches, also add the specific output that was matched.\n@@ -142,33 +142,33 @@ bool CBloomFilter::IsRelevantAndUpdate(const CTransaction& tx)\n         CScript::const_iterator pc = txout.scriptPubKey.begin();\n         std::vector<unsigned char> data;\n         while (pc < txout.scriptPubKey.end())\n-        {\n+        <%\n             opcodetype opcode;\n             if (!txout.scriptPubKey.GetOp(pc, opcode, data))\n                 break;\n             if (data.size() != 0 && contains(data))\n-            {\n+            <%\n                 fFound = true;\n                 if ((nFlags & BLOOM_UPDATE_MASK) == BLOOM_UPDATE_ALL)\n                     insert(COutPoint(hash, i));\n                 else if ((nFlags & BLOOM_UPDATE_MASK) == BLOOM_UPDATE_P2PUBKEY_ONLY)\n-                {\n+                <%\n                     std::vector<std::vector<unsigned char> > vSolutions;\n                     txnouttype type = Solver(txout.scriptPubKey, vSolutions);\n-                    if (type == TX_PUBKEY || type == TX_MULTISIG) {\n+                    if (type == TX_PUBKEY || type == TX_MULTISIG) <%\n                         insert(COutPoint(hash, i));\n-                    }\n-                }\n+                    %>\n+                %>\n                 break;\n-            }\n-        }\n-    }\n+            %>\n+        %>\n+    %>\n \n     if (fFound)\n         return true;\n \n     for (const CTxIn& txin : tx.vin)\n-    {\n+    <%\n         // Match if the filter contains an outpoint tx spends\n         if (contains(txin.prevout))\n             return true;\n@@ -177,33 +177,33 @@ bool CBloomFilter::IsRelevantAndUpdate(const CTransaction& tx)\n         CScript::const_iterator pc = txin.scriptSig.begin();\n         std::vector<unsigned char> data;\n         while (pc < txin.scriptSig.end())\n-        {\n+        <%\n             opcodetype opcode;\n             if (!txin.scriptSig.GetOp(pc, opcode, data))\n                 break;\n             if (data.size() != 0 && contains(data))\n                 return true;\n-        }\n-    }\n+        %>\n+    %>\n \n     return false;\n-}\n+%>\n \n void CBloomFilter::UpdateEmptyFull()\n-{\n+<%\n     bool full = true;\n     bool empty = true;\n     for (unsigned int i = 0; i < vData.size(); i++)\n-    {\n+    <%\n         full &= vData[i] == 0xff;\n         empty &= vData[i] == 0;\n-    }\n+    %>\n     isFull = full;\n     isEmpty = empty;\n-}\n+%>\n \n CRollingBloomFilter::CRollingBloomFilter(const unsigned int nElements, const double fpRate)\n-{\n+<%\n     double logFpRate = log(fpRate);\n     /* The optimal number of hash functions is log(fpRate) / log(0.5), but\n      * restrict it to the range 1-50. */\n@@ -227,84 +227,84 @@ CRollingBloomFilter::CRollingBloomFilter(const unsigned int nElements, const dou\n      * (P & 63) of the integers data[(P >> 6) * 2] and data[(P >> 6) * 2 + 1]. */\n     data.resize(((nFilterBits + 63) / 64) << 1);\n     reset();\n-}\n+%>\n \n /* Similar to CBloomFilter::Hash */\n-static inline uint32_t RollingBloomHash(unsigned int nHashNum, uint32_t nTweak, const std::vector<unsigned char>& vDataToHash) {\n+static inline uint32_t RollingBloomHash(unsigned int nHashNum, uint32_t nTweak, const std::vector<unsigned char>& vDataToHash) <%\n     return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash);\n-}\n+%>\n \n \n // A replacement for x % n. This assumes that x and n are 32bit integers, and x is a uniformly random distributed 32bit value\n // which should be the case for a good hash.\n // See https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/\n-static inline uint32_t FastMod(uint32_t x, size_t n) {\n+static inline uint32_t FastMod(uint32_t x, size_t n) <%\n     return ((uint64_t)x * (uint64_t)n) >> 32;\n-}\n+%>\n \n void CRollingBloomFilter::insert(const std::vector<unsigned char>& vKey)\n-{\n-    if (nEntriesThisGeneration == nEntriesPerGeneration) {\n+<%\n+    if (nEntriesThisGeneration == nEntriesPerGeneration) <%\n         nEntriesThisGeneration = 0;\n         nGeneration++;\n-        if (nGeneration == 4) {\n+        if (nGeneration == 4) <%\n             nGeneration = 1;\n-        }\n+        %>\n         uint64_t nGenerationMask1 = 0 - (uint64_t)(nGeneration & 1);\n         uint64_t nGenerationMask2 = 0 - (uint64_t)(nGeneration >> 1);\n         /* Wipe old entries that used this generation number. */\n-        for (uint32_t p = 0; p < data.size(); p += 2) {\n+        for (uint32_t p = 0; p < data.size(); p += 2) <%\n             uint64_t p1 = data[p], p2 = data[p + 1];\n             uint64_t mask = (p1 ^ nGenerationMask1) | (p2 ^ nGenerationMask2);\n             data[p] = p1 & mask;\n             data[p + 1] = p2 & mask;\n-        }\n-    }\n+        %>\n+    %>\n     nEntriesThisGeneration++;\n \n-    for (int n = 0; n < nHashFuncs; n++) {\n+    for (int n = 0; n < nHashFuncs; n++) <%\n         uint32_t h = RollingBloomHash(n, nTweak, vKey);\n         int bit = h & 0x3F;\n         /* FastMod works with the upper bits of h, so it is safe to ignore that the lower bits of h are already used for bit. */\n         uint32_t pos = FastMod(h, data.size());\n         /* The lowest bit of pos is ignored, and set to zero for the first bit, and to one for the second. */\n         data[pos & ~1] = (data[pos & ~1] & ~(((uint64_t)1) << bit)) | ((uint64_t)(nGeneration & 1)) << bit;\n         data[pos | 1] = (data[pos | 1] & ~(((uint64_t)1) << bit)) | ((uint64_t)(nGeneration >> 1)) << bit;\n-    }\n-}\n+    %>\n+%>\n \n void CRollingBloomFilter::insert(const uint256& hash)\n-{\n+<%\n     std::vector<unsigned char> vData(hash.begin(), hash.end());\n     insert(vData);\n-}\n+%>\n \n bool CRollingBloomFilter::contains(const std::vector<unsigned char>& vKey) const\n-{\n-    for (int n = 0; n < nHashFuncs; n++) {\n+<%\n+    for (int n = 0; n < nHashFuncs; n++) <%\n         uint32_t h = RollingBloomHash(n, nTweak, vKey);\n         int bit = h & 0x3F;\n         uint32_t pos = FastMod(h, data.size());\n         /* If the relevant bit is not set in either data[pos & ~1] or data[pos | 1], the filter does not contain vKey */\n-        if (!(((data[pos & ~1] | data[pos | 1]) >> bit) & 1)) {\n+        if (!(((data[pos & ~1] | data[pos | 1]) >> bit) & 1)) <%\n             return false;\n-        }\n-    }\n+        %>\n+    %>\n     return true;\n-}\n+%>\n \n bool CRollingBloomFilter::contains(const uint256& hash) const\n-{\n+<%\n     std::vector<unsigned char> vData(hash.begin(), hash.end());\n     return contains(vData);\n-}\n+%>\n \n void CRollingBloomFilter::reset()\n-{\n+<%\n     nTweak = GetRand(std::numeric_limits<unsigned int>::max());\n     nEntriesThisGeneration = 0;\n     nGeneration = 1;\n-    for (std::vector<uint64_t>::iterator it = data.begin(); it != data.end(); it++) {\n+    for (std::vector<uint64_t>::iterator it = data.begin(); it != data.end(); it++) <%\n         *it = 0;\n-    }\n-}\n+    %>\n+%>"
      },
      {
        "sha": "3b9acf7d4b67a591b9f8bf298dc667ef7a6e5454",
        "filename": "src/bloom.h",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bloom.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/bloom.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -22,13 +22,13 @@ static const unsigned int MAX_HASH_FUNCS = 50;\n  * The remaining bits are reserved\n  */\n enum bloomflags\n-{\n+<%\n     BLOOM_UPDATE_NONE = 0,\n     BLOOM_UPDATE_ALL = 1,\n     // Only adds outpoints to the filter if the output is a pay-to-pubkey/pay-to-multisig script\n     BLOOM_UPDATE_P2PUBKEY_ONLY = 2,\n     BLOOM_UPDATE_MASK = 3,\n-};\n+%>;\n \n /**\n  * BloomFilter is a probabilistic filter which SPV clients provide\n@@ -42,7 +42,7 @@ enum bloomflags\n  * keys are controlled by them.\n  */\n class CBloomFilter\n-{\n+<%\n private:\n     std::vector<unsigned char> vData;\n     bool isFull;\n@@ -64,17 +64,17 @@ class CBloomFilter\n      * nFlags should be one of the BLOOM_UPDATE_* enums (not _MASK)\n      */\n     CBloomFilter(const unsigned int nElements, const double nFPRate, const unsigned int nTweak, unsigned char nFlagsIn);\n-    CBloomFilter() : isFull(true), isEmpty(false), nHashFuncs(0), nTweak(0), nFlags(0) {}\n+    CBloomFilter() : isFull(true), isEmpty(false), nHashFuncs(0), nTweak(0), nFlags(0) <%%>\n \n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action) {\n+    inline void SerializationOp(Stream& s, Operation ser_action) <%\n         READWRITE(vData);\n         READWRITE(nHashFuncs);\n         READWRITE(nTweak);\n         READWRITE(nFlags);\n-    }\n+    %>\n \n     void insert(const std::vector<unsigned char>& vKey);\n     void insert(const COutPoint& outpoint);\n@@ -96,7 +96,7 @@ class CBloomFilter\n \n     //! Checks for empty and full filters to avoid wasting cpu\n     void UpdateEmptyFull();\n-};\n+%>;\n \n /**\n  * RollingBloomFilter is a probabilistic \"keep track of most recently inserted\" set.\n@@ -113,7 +113,7 @@ class CBloomFilter\n  * (More accurately: 3/(log(256)*log(2)) * log(1/fpRate) * nElements bytes)\n  */\n class CRollingBloomFilter\n-{\n+<%\n public:\n     // A random bloom filter calls GetRand() at creation time.\n     // Don't create global CRollingBloomFilter objects, as they may be\n@@ -134,6 +134,6 @@ class CRollingBloomFilter\n     std::vector<uint64_t> data;\n     unsigned int nTweak;\n     int nHashFuncs;\n-};\n+%>;\n \n #endif // BITCOIN_BLOOM_H"
      },
      {
        "sha": "848027ddaf8a6be3baf5f46306866adbfb87ee29",
        "filename": "src/chain.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 52,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -8,118 +8,118 @@\n /**\n  * CChain implementation\n  */\n-void CChain::SetTip(CBlockIndex *pindex) {\n-    if (pindex == nullptr) {\n+void CChain::SetTip(CBlockIndex *pindex) <%\n+    if (pindex == nullptr) <%\n         vChain.clear();\n         return;\n-    }\n+    %>\n     vChain.resize(pindex->nHeight + 1);\n-    while (pindex && vChain[pindex->nHeight] != pindex) {\n+    while (pindex && vChain[pindex->nHeight] != pindex) <%\n         vChain[pindex->nHeight] = pindex;\n         pindex = pindex->pprev;\n-    }\n-}\n+    %>\n+%>\n \n-CBlockLocator CChain::GetLocator(const CBlockIndex *pindex) const {\n+CBlockLocator CChain::GetLocator(const CBlockIndex *pindex) const <%\n     int nStep = 1;\n     std::vector<uint256> vHave;\n     vHave.reserve(32);\n \n     if (!pindex)\n         pindex = Tip();\n-    while (pindex) {\n+    while (pindex) <%\n         vHave.push_back(pindex->GetBlockHash());\n         // Stop when we have added the genesis block.\n         if (pindex->nHeight == 0)\n             break;\n         // Exponentially larger steps back, plus the genesis block.\n         int nHeight = std::max(pindex->nHeight - nStep, 0);\n-        if (Contains(pindex)) {\n+        if (Contains(pindex)) <%\n             // Use O(1) CChain index if possible.\n             pindex = (*this)[nHeight];\n-        } else {\n+        %> else <%\n             // Otherwise, use O(log n) skiplist.\n             pindex = pindex->GetAncestor(nHeight);\n-        }\n+        %>\n         if (vHave.size() > 10)\n             nStep *= 2;\n-    }\n+    %>\n \n     return CBlockLocator(vHave);\n-}\n+%>\n \n-const CBlockIndex *CChain::FindFork(const CBlockIndex *pindex) const {\n-    if (pindex == nullptr) {\n+const CBlockIndex *CChain::FindFork(const CBlockIndex *pindex) const <%\n+    if (pindex == nullptr) <%\n         return nullptr;\n-    }\n+    %>\n     if (pindex->nHeight > Height())\n         pindex = pindex->GetAncestor(Height());\n     while (pindex && !Contains(pindex))\n         pindex = pindex->pprev;\n     return pindex;\n-}\n+%>\n \n CBlockIndex* CChain::FindEarliestAtLeast(int64_t nTime) const\n-{\n+<%\n     std::vector<CBlockIndex*>::const_iterator lower = std::lower_bound(vChain.begin(), vChain.end(), nTime,\n-        [](CBlockIndex* pBlock, const int64_t& time) -> bool { return pBlock->GetBlockTimeMax() < time; });\n+        [](CBlockIndex* pBlock, const int64_t& time) -> bool <% return pBlock->GetBlockTimeMax() < time; %>);\n     return (lower == vChain.end() ? nullptr : *lower);\n-}\n+%>\n \n /** Turn the lowest '1' bit in the binary representation of a number into a '0'. */\n-int static inline InvertLowestOne(int n) { return n & (n - 1); }\n+int static inline InvertLowestOne(int n) <% return n & (n - 1); %>\n \n /** Compute what height to jump back to with the CBlockIndex::pskip pointer. */\n-int static inline GetSkipHeight(int height) {\n+int static inline GetSkipHeight(int height) <%\n     if (height < 2)\n         return 0;\n \n     // Determine which height to jump back to. Any number strictly lower than height is acceptable,\n     // but the following expression seems to perform well in simulations (max 110 steps to go back\n     // up to 2**18 blocks).\n     return (height & 1) ? InvertLowestOne(InvertLowestOne(height - 1)) + 1 : InvertLowestOne(height);\n-}\n+%>\n \n const CBlockIndex* CBlockIndex::GetAncestor(int height) const\n-{\n-    if (height > nHeight || height < 0) {\n+<%\n+    if (height > nHeight || height < 0) <%\n         return nullptr;\n-    }\n+    %>\n \n     const CBlockIndex* pindexWalk = this;\n     int heightWalk = nHeight;\n-    while (heightWalk > height) {\n+    while (heightWalk > height) <%\n         int heightSkip = GetSkipHeight(heightWalk);\n         int heightSkipPrev = GetSkipHeight(heightWalk - 1);\n         if (pindexWalk->pskip != nullptr &&\n             (heightSkip == height ||\n              (heightSkip > height && !(heightSkipPrev < heightSkip - 2 &&\n-                                       heightSkipPrev >= height)))) {\n+                                       heightSkipPrev >= height)))) <%\n             // Only follow pskip if pprev->pskip isn't better than pskip->pprev.\n             pindexWalk = pindexWalk->pskip;\n             heightWalk = heightSkip;\n-        } else {\n+        %> else <%\n             assert(pindexWalk->pprev);\n             pindexWalk = pindexWalk->pprev;\n             heightWalk--;\n-        }\n-    }\n+        %>\n+    %>\n     return pindexWalk;\n-}\n+%>\n \n CBlockIndex* CBlockIndex::GetAncestor(int height)\n-{\n+<%\n     return const_cast<CBlockIndex*>(static_cast<const CBlockIndex*>(this)->GetAncestor(height));\n-}\n+%>\n \n void CBlockIndex::BuildSkip()\n-{\n+<%\n     if (pprev)\n         pskip = pprev->GetAncestor(GetSkipHeight(nHeight));\n-}\n+%>\n \n arith_uint256 GetBlockProof(const CBlockIndex& block)\n-{\n+<%\n     arith_uint256 bnTarget;\n     bool fNegative;\n     bool fOverflow;\n@@ -131,40 +131,40 @@ arith_uint256 GetBlockProof(const CBlockIndex& block)\n     // as bnTarget+1, it is equal to ((2**256 - bnTarget - 1) / (bnTarget+1)) + 1,\n     // or ~bnTarget / (bnTarget+1) + 1.\n     return (~bnTarget / (bnTarget + 1)) + 1;\n-}\n+%>\n \n int64_t GetBlockProofEquivalentTime(const CBlockIndex& to, const CBlockIndex& from, const CBlockIndex& tip, const Consensus::Params& params)\n-{\n+<%\n     arith_uint256 r;\n     int sign = 1;\n-    if (to.nChainWork > from.nChainWork) {\n+    if (to.nChainWork > from.nChainWork) <%\n         r = to.nChainWork - from.nChainWork;\n-    } else {\n+    %> else <%\n         r = from.nChainWork - to.nChainWork;\n         sign = -1;\n-    }\n+    %>\n     r = r * arith_uint256(params.nPowTargetSpacing) / GetBlockProof(tip);\n-    if (r.bits() > 63) {\n+    if (r.bits() > 63) <%\n         return sign * std::numeric_limits<int64_t>::max();\n-    }\n+    %>\n     return sign * r.GetLow64();\n-}\n+%>\n \n /** Find the last common ancestor two blocks have.\n  *  Both pa and pb must be non-nullptr. */\n-const CBlockIndex* LastCommonAncestor(const CBlockIndex* pa, const CBlockIndex* pb) {\n-    if (pa->nHeight > pb->nHeight) {\n+const CBlockIndex* LastCommonAncestor(const CBlockIndex* pa, const CBlockIndex* pb) <%\n+    if (pa->nHeight > pb->nHeight) <%\n         pa = pa->GetAncestor(pb->nHeight);\n-    } else if (pb->nHeight > pa->nHeight) {\n+    %> else if (pb->nHeight > pa->nHeight) <%\n         pb = pb->GetAncestor(pa->nHeight);\n-    }\n+    %>\n \n-    while (pa != pb && pa && pb) {\n+    while (pa != pb && pa && pb) <%\n         pa = pa->pprev;\n         pb = pb->pprev;\n-    }\n+    %>\n \n     // Eventually all chain branches meet at the genesis block.\n     assert(pa == pb);\n     return pa;\n-}\n+%>"
      },
      {
        "sha": "a760fca35ccd6f5c3f1fee0d92bb54362314f9d6",
        "filename": "src/chain.h",
        "status": "modified",
        "additions": 75,
        "deletions": 75,
        "changes": 150,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -38,7 +38,7 @@ static constexpr int64_t TIMESTAMP_WINDOW = MAX_FUTURE_BLOCK_TIME;\n static constexpr int64_t MAX_BLOCK_TIME_GAP = 90 * 60;\n \n class CBlockFileInfo\n-{\n+<%\n public:\n     unsigned int nBlocks;      //!< number of blocks stored in file\n     unsigned int nSize;        //!< number of used bytes of block file\n@@ -51,34 +51,34 @@ class CBlockFileInfo\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action) {\n+    inline void SerializationOp(Stream& s, Operation ser_action) <%\n         READWRITE(VARINT(nBlocks));\n         READWRITE(VARINT(nSize));\n         READWRITE(VARINT(nUndoSize));\n         READWRITE(VARINT(nHeightFirst));\n         READWRITE(VARINT(nHeightLast));\n         READWRITE(VARINT(nTimeFirst));\n         READWRITE(VARINT(nTimeLast));\n-    }\n+    %>\n \n-     void SetNull() {\n+     void SetNull() <%\n          nBlocks = 0;\n          nSize = 0;\n          nUndoSize = 0;\n          nHeightFirst = 0;\n          nHeightLast = 0;\n          nTimeFirst = 0;\n          nTimeLast = 0;\n-     }\n+     %>\n \n-     CBlockFileInfo() {\n+     CBlockFileInfo() <%\n          SetNull();\n-     }\n+     %>\n \n      std::string ToString() const;\n \n      /** update statistics (does not update nSize) */\n-     void AddBlock(unsigned int nHeightIn, uint64_t nTimeIn) {\n+     void AddBlock(unsigned int nHeightIn, uint64_t nTimeIn) <%\n          if (nBlocks==0 || nHeightFirst > nHeightIn)\n              nHeightFirst = nHeightIn;\n          if (nBlocks==0 || nTimeFirst > nTimeIn)\n@@ -88,10 +88,10 @@ class CBlockFileInfo\n              nHeightLast = nHeightIn;\n          if (nTimeIn > nTimeLast)\n              nTimeLast = nTimeIn;\n-     }\n-};\n+     %>\n+%>;\n \n-enum BlockStatus: uint32_t {\n+enum BlockStatus: uint32_t <%\n     //! Unused.\n     BLOCK_VALID_UNKNOWN      =    0,\n \n@@ -129,15 +129,15 @@ enum BlockStatus: uint32_t {\n     BLOCK_FAILED_MASK        =   BLOCK_FAILED_VALID | BLOCK_FAILED_CHILD,\n \n     BLOCK_OPT_WITNESS       =   128, //!< block data in blk*.data was received with a witness-enforcing client\n-};\n+%>;\n \n /** The block chain is a tree shaped structure starting with the\n  * genesis block at the root, with each block potentially having multiple\n  * candidates to be the next block. A blockindex may have multiple pprev pointing\n  * to it, but at most one of them can be part of the currently active branch.\n  */\n class CBlockIndex\n-{\n+<%\n public:\n     //! pointer to the hash of the block, if any. Memory is owned by this CBlockIndex\n     const uint256* phashBlock;\n@@ -189,7 +189,7 @@ class CBlockIndex\n     unsigned int nTimeMax;\n \n     void SetNull()\n-    {\n+    <%\n         phashBlock = nullptr;\n         pprev = nullptr;\n         pskip = nullptr;\n@@ -209,44 +209,44 @@ class CBlockIndex\n         nTime          = 0;\n         nBits          = 0;\n         nNonce         = 0;\n-    }\n+    %>\n \n     CBlockIndex()\n-    {\n+    <%\n         SetNull();\n-    }\n+    %>\n \n     explicit CBlockIndex(const CBlockHeader& block)\n-    {\n+    <%\n         SetNull();\n \n         nVersion       = block.nVersion;\n         hashMerkleRoot = block.hashMerkleRoot;\n         nTime          = block.nTime;\n         nBits          = block.nBits;\n         nNonce         = block.nNonce;\n-    }\n+    %>\n \n-    FlatFilePos GetBlockPos() const {\n+    FlatFilePos GetBlockPos() const <%\n         FlatFilePos ret;\n-        if (nStatus & BLOCK_HAVE_DATA) {\n+        if (nStatus & BLOCK_HAVE_DATA) <%\n             ret.nFile = nFile;\n             ret.nPos  = nDataPos;\n-        }\n+        %>\n         return ret;\n-    }\n+    %>\n \n-    FlatFilePos GetUndoPos() const {\n+    FlatFilePos GetUndoPos() const <%\n         FlatFilePos ret;\n-        if (nStatus & BLOCK_HAVE_UNDO) {\n+        if (nStatus & BLOCK_HAVE_UNDO) <%\n             ret.nFile = nFile;\n             ret.nPos  = nUndoPos;\n-        }\n+        %>\n         return ret;\n-    }\n+    %>\n \n     CBlockHeader GetBlockHeader() const\n-    {\n+    <%\n         CBlockHeader block;\n         block.nVersion       = nVersion;\n         if (pprev)\n@@ -256,12 +256,12 @@ class CBlockIndex\n         block.nBits          = nBits;\n         block.nNonce         = nNonce;\n         return block;\n-    }\n+    %>\n \n     uint256 GetBlockHash() const\n-    {\n+    <%\n         return *phashBlock;\n-    }\n+    %>\n \n     /**\n      * Check whether this block's and all previous blocks' transactions have been\n@@ -270,22 +270,22 @@ class CBlockIndex\n      * Does not imply the transactions are consensus-valid (ConnectTip might fail)\n      * Does not imply the transactions are still stored on disk. (IsBlockPruned might return true)\n      */\n-    bool HaveTxsDownloaded() const { return nChainTx != 0; }\n+    bool HaveTxsDownloaded() const <% return nChainTx != 0; %>\n \n     int64_t GetBlockTime() const\n-    {\n+    <%\n         return (int64_t)nTime;\n-    }\n+    %>\n \n     int64_t GetBlockTimeMax() const\n-    {\n+    <%\n         return (int64_t)nTimeMax;\n-    }\n+    %>\n \n     static constexpr int nMedianTimeSpan = 11;\n \n     int64_t GetMedianTimePast() const\n-    {\n+    <%\n         int64_t pmedian[nMedianTimeSpan];\n         int64_t* pbegin = &pmedian[nMedianTimeSpan];\n         int64_t* pend = &pmedian[nMedianTimeSpan];\n@@ -296,46 +296,46 @@ class CBlockIndex\n \n         std::sort(pbegin, pend);\n         return pbegin[(pend - pbegin)/2];\n-    }\n+    %>\n \n     std::string ToString() const\n-    {\n+    <%\n         return strprintf(\"CBlockIndex(pprev=%p, nHeight=%d, merkle=%s, hashBlock=%s)\",\n             pprev, nHeight,\n             hashMerkleRoot.ToString(),\n             GetBlockHash().ToString());\n-    }\n+    %>\n \n     //! Check whether this block index entry is valid up to the passed validity level.\n     bool IsValid(enum BlockStatus nUpTo = BLOCK_VALID_TRANSACTIONS) const\n-    {\n+    <%\n         assert(!(nUpTo & ~BLOCK_VALID_MASK)); // Only validity flags allowed.\n         if (nStatus & BLOCK_FAILED_MASK)\n             return false;\n         return ((nStatus & BLOCK_VALID_MASK) >= nUpTo);\n-    }\n+    %>\n \n     //! Raise the validity level of this block index entry.\n     //! Returns true if the validity was changed.\n     bool RaiseValidity(enum BlockStatus nUpTo)\n-    {\n+    <%\n         assert(!(nUpTo & ~BLOCK_VALID_MASK)); // Only validity flags allowed.\n         if (nStatus & BLOCK_FAILED_MASK)\n             return false;\n-        if ((nStatus & BLOCK_VALID_MASK) < nUpTo) {\n+        if ((nStatus & BLOCK_VALID_MASK) < nUpTo) <%\n             nStatus = (nStatus & ~BLOCK_VALID_MASK) | nUpTo;\n             return true;\n-        }\n+        %>\n         return false;\n-    }\n+    %>\n \n     //! Build the skiplist pointer for this entry.\n     void BuildSkip();\n \n     //! Efficiently find an ancestor of this block.\n     CBlockIndex* GetAncestor(int height);\n     const CBlockIndex* GetAncestor(int height) const;\n-};\n+%>;\n \n arith_uint256 GetBlockProof(const CBlockIndex& block);\n /** Return the time it would take to redo the work difference between from and to, assuming the current hashrate corresponds to the difficulty at tip, in seconds. */\n@@ -346,22 +346,22 @@ const CBlockIndex* LastCommonAncestor(const CBlockIndex* pa, const CBlockIndex*\n \n /** Used to marshal pointers into hashes for db storage. */\n class CDiskBlockIndex : public CBlockIndex\n-{\n+<%\n public:\n     uint256 hashPrev;\n \n-    CDiskBlockIndex() {\n+    CDiskBlockIndex() <%\n         hashPrev = uint256();\n-    }\n+    %>\n \n-    explicit CDiskBlockIndex(const CBlockIndex* pindex) : CBlockIndex(*pindex) {\n+    explicit CDiskBlockIndex(const CBlockIndex* pindex) : CBlockIndex(*pindex) <%\n         hashPrev = (pprev ? pprev->GetBlockHash() : uint256());\n-    }\n+    %>\n \n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action) {\n+    inline void SerializationOp(Stream& s, Operation ser_action) <%\n         int _nVersion = s.GetVersion();\n         if (!(s.GetType() & SER_GETHASH))\n             READWRITE(VARINT(_nVersion, VarIntMode::NONNEGATIVE_SIGNED));\n@@ -383,10 +383,10 @@ class CDiskBlockIndex : public CBlockIndex\n         READWRITE(nTime);\n         READWRITE(nBits);\n         READWRITE(nNonce);\n-    }\n+    %>\n \n     uint256 GetBlockHash() const\n-    {\n+    <%\n         CBlockHeader block;\n         block.nVersion        = nVersion;\n         block.hashPrevBlock   = hashPrev;\n@@ -395,66 +395,66 @@ class CDiskBlockIndex : public CBlockIndex\n         block.nBits           = nBits;\n         block.nNonce          = nNonce;\n         return block.GetHash();\n-    }\n+    %>\n \n \n     std::string ToString() const\n-    {\n+    <%\n         std::string str = \"CDiskBlockIndex(\";\n         str += CBlockIndex::ToString();\n         str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s)\",\n             GetBlockHash().ToString(),\n             hashPrev.ToString());\n         return str;\n-    }\n-};\n+    %>\n+%>;\n \n /** An in-memory indexed chain of blocks. */\n-class CChain {\n+class CChain <%\n private:\n     std::vector<CBlockIndex*> vChain;\n \n public:\n     /** Returns the index entry for the genesis block of this chain, or nullptr if none. */\n-    CBlockIndex *Genesis() const {\n+    CBlockIndex *Genesis() const <%\n         return vChain.size() > 0 ? vChain[0] : nullptr;\n-    }\n+    %>\n \n     /** Returns the index entry for the tip of this chain, or nullptr if none. */\n-    CBlockIndex *Tip() const {\n+    CBlockIndex *Tip() const <%\n         return vChain.size() > 0 ? vChain[vChain.size() - 1] : nullptr;\n-    }\n+    %>\n \n     /** Returns the index entry at a particular height in this chain, or nullptr if no such height exists. */\n-    CBlockIndex *operator[](int nHeight) const {\n+    CBlockIndex *operator[](int nHeight) const <%\n         if (nHeight < 0 || nHeight >= (int)vChain.size())\n             return nullptr;\n         return vChain[nHeight];\n-    }\n+    %>\n \n     /** Compare two chains efficiently. */\n-    friend bool operator==(const CChain &a, const CChain &b) {\n+    friend bool operator==(const CChain &a, const CChain &b) <%\n         return a.vChain.size() == b.vChain.size() &&\n                a.vChain[a.vChain.size() - 1] == b.vChain[b.vChain.size() - 1];\n-    }\n+    %>\n \n     /** Efficiently check whether a block is present in this chain. */\n-    bool Contains(const CBlockIndex *pindex) const {\n+    bool Contains(const CBlockIndex *pindex) const <%\n         return (*this)[pindex->nHeight] == pindex;\n-    }\n+    %>\n \n     /** Find the successor of a block in this chain, or nullptr if the given index is not found or is the tip. */\n-    CBlockIndex *Next(const CBlockIndex *pindex) const {\n+    CBlockIndex *Next(const CBlockIndex *pindex) const <%\n         if (Contains(pindex))\n             return (*this)[pindex->nHeight + 1];\n         else\n             return nullptr;\n-    }\n+    %>\n \n     /** Return the maximal height in the chain. Is equal to chain.Tip() ? chain.Tip()->nHeight : -1. */\n-    int Height() const {\n+    int Height() const <%\n         return vChain.size() - 1;\n-    }\n+    %>\n \n     /** Set/initialize a chain with a given tip. */\n     void SetTip(CBlockIndex *pindex);\n@@ -467,6 +467,6 @@ class CChain {\n \n     /** Find the earliest block with timestamp equal or greater than the given. */\n     CBlockIndex* FindEarliestAtLeast(int64_t nTime) const;\n-};\n+%>;\n \n #endif // BITCOIN_CHAIN_H"
      },
      {
        "sha": "e2d680e5e2c408e3c1589ca1cb14fa93c2a76e8e",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 80,
        "deletions": 80,
        "changes": 160,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -18,7 +18,7 @@\n #include <boost/algorithm/string/split.hpp>\n \n static CBlock CreateGenesisBlock(const char* pszTimestamp, const CScript& genesisOutputScript, uint32_t nTime, uint32_t nNonce, uint32_t nBits, int32_t nVersion, const CAmount& genesisReward)\n-{\n+<%\n     CMutableTransaction txNew;\n     txNew.nVersion = 1;\n     txNew.vin.resize(1);\n@@ -36,7 +36,7 @@ static CBlock CreateGenesisBlock(const char* pszTimestamp, const CScript& genesi\n     genesis.hashPrevBlock.SetNull();\n     genesis.hashMerkleRoot = BlockMerkleRoot(genesis);\n     return genesis;\n-}\n+%>\n \n /**\n  * Build the genesis block. Note that the output of its generation\n@@ -50,18 +50,18 @@ static CBlock CreateGenesisBlock(const char* pszTimestamp, const CScript& genesi\n  *   vMerkleTree: 4a5e1e\n  */\n static CBlock CreateGenesisBlock(uint32_t nTime, uint32_t nNonce, uint32_t nBits, int32_t nVersion, const CAmount& genesisReward)\n-{\n+<%\n     const char* pszTimestamp = \"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks\";\n     const CScript genesisOutputScript = CScript() << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\") << OP_CHECKSIG;\n     return CreateGenesisBlock(pszTimestamp, genesisOutputScript, nTime, nNonce, nBits, nVersion, genesisReward);\n-}\n+%>\n \n /**\n  * Main network\n  */\n-class CMainParams : public CChainParams {\n+class CMainParams : public CChainParams <%\n public:\n-    CMainParams() {\n+    CMainParams() <%\n         strNetworkID = \"main\";\n         consensus.nSubsidyHalvingInterval = 210000;\n         consensus.BIP16Exception = uint256S(\"0x00000000000002dc756eebf4f49723ed8d30cc28a5f108eb94b1ba88ac4f9c22\");\n@@ -132,8 +132,8 @@ class CMainParams : public CChainParams {\n         base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,0);\n         base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,5);\n         base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,128);\n-        base58Prefixes[EXT_PUBLIC_KEY] = {0x04, 0x88, 0xB2, 0x1E};\n-        base58Prefixes[EXT_SECRET_KEY] = {0x04, 0x88, 0xAD, 0xE4};\n+        base58Prefixes[EXT_PUBLIC_KEY] = <%0x04, 0x88, 0xB2, 0x1E%>;\n+        base58Prefixes[EXT_SECRET_KEY] = <%0x04, 0x88, 0xAD, 0xE4%>;\n \n         bech32_hrp = \"bc\";\n \n@@ -143,42 +143,42 @@ class CMainParams : public CChainParams {\n         fRequireStandard = true;\n         fMineBlocksOnDemand = false;\n \n-        checkpointData = {\n-            {\n-                { 11111, uint256S(\"0x0000000069e244f73d78e8fd29ba2fd2ed618bd6fa2ee92559f542fdb26e7c1d\")},\n-                { 33333, uint256S(\"0x000000002dd5588a74784eaa7ab0507a18ad16a236e7b1ce69f00d7ddfb5d0a6\")},\n-                { 74000, uint256S(\"0x0000000000573993a3c9e41ce34471c079dcf5f52a0e824a81e7f953b8661a20\")},\n-                {105000, uint256S(\"0x00000000000291ce28027faea320c8d2b054b2e0fe44a773f3eefb151d6bdc97\")},\n-                {134444, uint256S(\"0x00000000000005b12ffd4cd315cd34ffd4a594f430ac814c91184a0d42d2b0fe\")},\n-                {168000, uint256S(\"0x000000000000099e61ea72015e79632f216fe6cb33d7899acb35b75c8303b763\")},\n-                {193000, uint256S(\"0x000000000000059f452a5f7340de6682a977387c17010ff6e6c3bd83ca8b1317\")},\n-                {210000, uint256S(\"0x000000000000048b95347e83192f69cf0366076336c639f9b7228e9ba171342e\")},\n-                {216116, uint256S(\"0x00000000000001b4f4b433e81ee46494af945cf96014816a4e2370f11b23df4e\")},\n-                {225430, uint256S(\"0x00000000000001c108384350f74090433e7fcf79a606b8e797f065b130575932\")},\n-                {250000, uint256S(\"0x000000000000003887df1f29024b06fc2200b55f8af8f35453d7be294df2d214\")},\n-                {279000, uint256S(\"0x0000000000000001ae8c72a0b0c301f67e3afca10e819efa9041e458e9bd7e40\")},\n-                {295000, uint256S(\"0x00000000000000004d9b4ef50f0f9d686fd69db2e03af35a100370c64632a983\")},\n-            }\n-        };\n-\n-        chainTxData = ChainTxData{\n+        checkpointData = <%\n+            <%\n+                <% 11111, uint256S(\"0x0000000069e244f73d78e8fd29ba2fd2ed618bd6fa2ee92559f542fdb26e7c1d\")%>,\n+                <% 33333, uint256S(\"0x000000002dd5588a74784eaa7ab0507a18ad16a236e7b1ce69f00d7ddfb5d0a6\")%>,\n+                <% 74000, uint256S(\"0x0000000000573993a3c9e41ce34471c079dcf5f52a0e824a81e7f953b8661a20\")%>,\n+                <%105000, uint256S(\"0x00000000000291ce28027faea320c8d2b054b2e0fe44a773f3eefb151d6bdc97\")%>,\n+                <%134444, uint256S(\"0x00000000000005b12ffd4cd315cd34ffd4a594f430ac814c91184a0d42d2b0fe\")%>,\n+                <%168000, uint256S(\"0x000000000000099e61ea72015e79632f216fe6cb33d7899acb35b75c8303b763\")%>,\n+                <%193000, uint256S(\"0x000000000000059f452a5f7340de6682a977387c17010ff6e6c3bd83ca8b1317\")%>,\n+                <%210000, uint256S(\"0x000000000000048b95347e83192f69cf0366076336c639f9b7228e9ba171342e\")%>,\n+                <%216116, uint256S(\"0x00000000000001b4f4b433e81ee46494af945cf96014816a4e2370f11b23df4e\")%>,\n+                <%225430, uint256S(\"0x00000000000001c108384350f74090433e7fcf79a606b8e797f065b130575932\")%>,\n+                <%250000, uint256S(\"0x000000000000003887df1f29024b06fc2200b55f8af8f35453d7be294df2d214\")%>,\n+                <%279000, uint256S(\"0x0000000000000001ae8c72a0b0c301f67e3afca10e819efa9041e458e9bd7e40\")%>,\n+                <%295000, uint256S(\"0x00000000000000004d9b4ef50f0f9d686fd69db2e03af35a100370c64632a983\")%>,\n+            %>\n+        %>;\n+\n+        chainTxData = ChainTxData<%\n             // Data from rpc: getchaintxstats 4096 0000000000000000000f1c54590ee18d15ec70e68c8cd4cfbadb1b4f11697eee\n             /* nTime    */ 1550374134,\n             /* nTxCount */ 383732546,\n             /* dTxRate  */ 3.685496590998308\n-        };\n+        %>;\n \n         /* disable fallback fee on mainnet */\n         m_fallback_fee_enabled = false;\n-    }\n-};\n+    %>\n+%>;\n \n /**\n  * Testnet (v3)\n  */\n-class CTestNetParams : public CChainParams {\n+class CTestNetParams : public CChainParams <%\n public:\n-    CTestNetParams() {\n+    CTestNetParams() <%\n         strNetworkID = \"test\";\n         consensus.nSubsidyHalvingInterval = 210000;\n         consensus.BIP16Exception = uint256S(\"0x00000000dd30457c001f4095d208cc1296b0eed002427aa599874af7a432b105\");\n@@ -238,8 +238,8 @@ class CTestNetParams : public CChainParams {\n         base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,111);\n         base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,196);\n         base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,239);\n-        base58Prefixes[EXT_PUBLIC_KEY] = {0x04, 0x35, 0x87, 0xCF};\n-        base58Prefixes[EXT_SECRET_KEY] = {0x04, 0x35, 0x83, 0x94};\n+        base58Prefixes[EXT_PUBLIC_KEY] = <%0x04, 0x35, 0x87, 0xCF%>;\n+        base58Prefixes[EXT_SECRET_KEY] = <%0x04, 0x35, 0x83, 0x94%>;\n \n         bech32_hrp = \"tb\";\n \n@@ -250,30 +250,30 @@ class CTestNetParams : public CChainParams {\n         fMineBlocksOnDemand = false;\n \n \n-        checkpointData = {\n-            {\n-                {546, uint256S(\"000000002a936ca763904c3c35fce2f3556c559c0214345d31b1bcebf76acb70\")},\n-            }\n-        };\n+        checkpointData = <%\n+            <%\n+                <%546, uint256S(\"000000002a936ca763904c3c35fce2f3556c559c0214345d31b1bcebf76acb70\")%>,\n+            %>\n+        %>;\n \n-        chainTxData = ChainTxData{\n+        chainTxData = ChainTxData<%\n             // Data from rpc: getchaintxstats 4096 0000000000000037a8cd3e06cd5edbfe9dd1dbcc5dacab279376ef7cfc2b4c75\n             /* nTime    */ 1531929919,\n             /* nTxCount */ 19438708,\n             /* dTxRate  */ 0.626\n-        };\n+        %>;\n \n         /* enable fallback fee on testnet */\n         m_fallback_fee_enabled = true;\n-    }\n-};\n+    %>\n+%>;\n \n /**\n  * Regression test\n  */\n-class CRegTestParams : public CChainParams {\n+class CRegTestParams : public CChainParams <%\n public:\n-    explicit CRegTestParams(const ArgsManager& args) {\n+    explicit CRegTestParams(const ArgsManager& args) <%\n         strNetworkID = \"regtest\";\n         consensus.nSubsidyHalvingInterval = 150;\n         consensus.BIP16Exception = uint256();\n@@ -327,93 +327,93 @@ class CRegTestParams : public CChainParams {\n         fRequireStandard = false;\n         fMineBlocksOnDemand = true;\n \n-        checkpointData = {\n-            {\n-                {0, uint256S(\"0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\")},\n-            }\n-        };\n+        checkpointData = <%\n+            <%\n+                <%0, uint256S(\"0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\")%>,\n+            %>\n+        %>;\n \n-        chainTxData = ChainTxData{\n+        chainTxData = ChainTxData<%\n             0,\n             0,\n             0\n-        };\n+        %>;\n \n         base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,111);\n         base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,196);\n         base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,239);\n-        base58Prefixes[EXT_PUBLIC_KEY] = {0x04, 0x35, 0x87, 0xCF};\n-        base58Prefixes[EXT_SECRET_KEY] = {0x04, 0x35, 0x83, 0x94};\n+        base58Prefixes[EXT_PUBLIC_KEY] = <%0x04, 0x35, 0x87, 0xCF%>;\n+        base58Prefixes[EXT_SECRET_KEY] = <%0x04, 0x35, 0x83, 0x94%>;\n \n         bech32_hrp = \"bcrt\";\n \n         /* enable fallback fee on regtest */\n         m_fallback_fee_enabled = true;\n-    }\n+    %>\n \n     /**\n      * Allows modifying the Version Bits regtest parameters.\n      */\n     void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)\n-    {\n+    <%\n         consensus.vDeployments[d].nStartTime = nStartTime;\n         consensus.vDeployments[d].nTimeout = nTimeout;\n-    }\n+    %>\n     void UpdateVersionBitsParametersFromArgs(const ArgsManager& args);\n-};\n+%>;\n \n void CRegTestParams::UpdateVersionBitsParametersFromArgs(const ArgsManager& args)\n-{\n+<%\n     if (!args.IsArgSet(\"-vbparams\")) return;\n \n-    for (const std::string& strDeployment : args.GetArgs(\"-vbparams\")) {\n+    for (const std::string& strDeployment : args.GetArgs(\"-vbparams\")) <%\n         std::vector<std::string> vDeploymentParams;\n         boost::split(vDeploymentParams, strDeployment, boost::is_any_of(\":\"));\n-        if (vDeploymentParams.size() != 3) {\n+        if (vDeploymentParams.size() != 3) <%\n             throw std::runtime_error(\"Version bits parameters malformed, expecting deployment:start:end\");\n-        }\n+        %>\n         int64_t nStartTime, nTimeout;\n-        if (!ParseInt64(vDeploymentParams[1], &nStartTime)) {\n+        if (!ParseInt64(vDeploymentParams[1], &nStartTime)) <%\n             throw std::runtime_error(strprintf(\"Invalid nStartTime (%s)\", vDeploymentParams[1]));\n-        }\n-        if (!ParseInt64(vDeploymentParams[2], &nTimeout)) {\n+        %>\n+        if (!ParseInt64(vDeploymentParams[2], &nTimeout)) <%\n             throw std::runtime_error(strprintf(\"Invalid nTimeout (%s)\", vDeploymentParams[2]));\n-        }\n+        %>\n         bool found = false;\n-        for (int j=0; j < (int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j) {\n-            if (vDeploymentParams[0] == VersionBitsDeploymentInfo[j].name) {\n+        for (int j=0; j < (int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j) <%\n+            if (vDeploymentParams[0] == VersionBitsDeploymentInfo[j].name) <%\n                 UpdateVersionBitsParameters(Consensus::DeploymentPos(j), nStartTime, nTimeout);\n                 found = true;\n                 LogPrintf(\"Setting version bits activation parameters for %s to start=%ld, timeout=%ld\\n\", vDeploymentParams[0], nStartTime, nTimeout);\n                 break;\n-            }\n-        }\n-        if (!found) {\n+            %>\n+        %>\n+        if (!found) <%\n             throw std::runtime_error(strprintf(\"Invalid deployment (%s)\", vDeploymentParams[0]));\n-        }\n-    }\n-}\n+        %>\n+    %>\n+%>\n \n static std::unique_ptr<const CChainParams> globalChainParams;\n \n-const CChainParams &Params() {\n+const CChainParams &Params() <%\n     assert(globalChainParams);\n     return *globalChainParams;\n-}\n+%>\n \n std::unique_ptr<const CChainParams> CreateChainParams(const std::string& chain)\n-{\n+<%\n     if (chain == CBaseChainParams::MAIN)\n         return std::unique_ptr<CChainParams>(new CMainParams());\n     else if (chain == CBaseChainParams::TESTNET)\n         return std::unique_ptr<CChainParams>(new CTestNetParams());\n     else if (chain == CBaseChainParams::REGTEST)\n         return std::unique_ptr<CChainParams>(new CRegTestParams(gArgs));\n     throw std::runtime_error(strprintf(\"%s: Unknown chain %s.\", __func__, chain));\n-}\n+%>\n \n void SelectParams(const std::string& network)\n-{\n+<%\n     SelectBaseParams(network);\n     globalChainParams = CreateChainParams(network);\n-}\n+%>"
      },
      {
        "sha": "92dd0bb5efb92acb07eca9604c7de890be6bcf40",
        "filename": "src/chainparams.h",
        "status": "modified",
        "additions": 29,
        "deletions": 29,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/chainparams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/chainparams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -14,28 +14,28 @@\n #include <memory>\n #include <vector>\n \n-struct SeedSpec6 {\n+struct SeedSpec6 <%\n     uint8_t addr[16];\n     uint16_t port;\n-};\n+%>;\n \n typedef std::map<int, uint256> MapCheckpoints;\n \n-struct CCheckpointData {\n+struct CCheckpointData <%\n     MapCheckpoints mapCheckpoints;\n-};\n+%>;\n \n /**\n  * Holds various statistics on transactions within a chain. Used to estimate\n  * verification progress during chain sync.\n  *\n  * See also: CChainParams::TxData, GuessVerificationProgress.\n  */\n-struct ChainTxData {\n+struct ChainTxData <%\n     int64_t nTime;    //!< UNIX timestamp of last known number of transactions\n     int64_t nTxCount; //!< total number of transactions between genesis and that timestamp\n     double dTxRate;   //!< estimated number of transactions per second after that timestamp\n-};\n+%>;\n \n /**\n  * CChainParams defines various tweakable parameters of a given instance of the\n@@ -45,47 +45,47 @@ struct ChainTxData {\n  * minimal difficulty to ensure that blocks can be found instantly.\n  */\n class CChainParams\n-{\n+<%\n public:\n-    enum Base58Type {\n+    enum Base58Type <%\n         PUBKEY_ADDRESS,\n         SCRIPT_ADDRESS,\n         SECRET_KEY,\n         EXT_PUBLIC_KEY,\n         EXT_SECRET_KEY,\n \n         MAX_BASE58_TYPES\n-    };\n+    %>;\n \n-    const Consensus::Params& GetConsensus() const { return consensus; }\n-    const CMessageHeader::MessageStartChars& MessageStart() const { return pchMessageStart; }\n-    int GetDefaultPort() const { return nDefaultPort; }\n+    const Consensus::Params& GetConsensus() const <% return consensus; %>\n+    const CMessageHeader::MessageStartChars& MessageStart() const <% return pchMessageStart; %>\n+    int GetDefaultPort() const <% return nDefaultPort; %>\n \n-    const CBlock& GenesisBlock() const { return genesis; }\n+    const CBlock& GenesisBlock() const <% return genesis; %>\n     /** Default value for -checkmempool and -checkblockindex argument */\n-    bool DefaultConsistencyChecks() const { return fDefaultConsistencyChecks; }\n+    bool DefaultConsistencyChecks() const <% return fDefaultConsistencyChecks; %>\n     /** Policy: Filter transactions that do not match well-defined patterns */\n-    bool RequireStandard() const { return fRequireStandard; }\n-    uint64_t PruneAfterHeight() const { return nPruneAfterHeight; }\n+    bool RequireStandard() const <% return fRequireStandard; %>\n+    uint64_t PruneAfterHeight() const <% return nPruneAfterHeight; %>\n     /** Minimum free space (in GB) needed for data directory */\n-    uint64_t AssumedBlockchainSize() const { return m_assumed_blockchain_size; }\n+    uint64_t AssumedBlockchainSize() const <% return m_assumed_blockchain_size; %>\n     /** Minimum free space (in GB) needed for data directory when pruned; Does not include prune target*/\n-    uint64_t AssumedChainStateSize() const { return m_assumed_chain_state_size; }\n+    uint64_t AssumedChainStateSize() const <% return m_assumed_chain_state_size; %>\n     /** Make miner stop after a block is found. In RPC, don't return until nGenProcLimit blocks are generated */\n-    bool MineBlocksOnDemand() const { return fMineBlocksOnDemand; }\n+    bool MineBlocksOnDemand() const <% return fMineBlocksOnDemand; %>\n     /** Return the BIP70 network string (main, test or regtest) */\n-    std::string NetworkIDString() const { return strNetworkID; }\n+    std::string NetworkIDString() const <% return strNetworkID; %>\n     /** Return true if the fallback fee is by default enabled for this network */\n-    bool IsFallbackFeeEnabled() const { return m_fallback_fee_enabled; }\n+    bool IsFallbackFeeEnabled() const <% return m_fallback_fee_enabled; %>\n     /** Return the list of hostnames to look up for DNS seeds */\n-    const std::vector<std::string>& DNSSeeds() const { return vSeeds; }\n-    const std::vector<unsigned char>& Base58Prefix(Base58Type type) const { return base58Prefixes[type]; }\n-    const std::string& Bech32HRP() const { return bech32_hrp; }\n-    const std::vector<SeedSpec6>& FixedSeeds() const { return vFixedSeeds; }\n-    const CCheckpointData& Checkpoints() const { return checkpointData; }\n-    const ChainTxData& TxData() const { return chainTxData; }\n+    const std::vector<std::string>& DNSSeeds() const <% return vSeeds; %>\n+    const std::vector<unsigned char>& Base58Prefix(Base58Type type) const <% return base58Prefixes[type]; %>\n+    const std::string& Bech32HRP() const <% return bech32_hrp; %>\n+    const std::vector<SeedSpec6>& FixedSeeds() const <% return vFixedSeeds; %>\n+    const CCheckpointData& Checkpoints() const <% return checkpointData; %>\n+    const ChainTxData& TxData() const <% return chainTxData; %>\n protected:\n-    CChainParams() {}\n+    CChainParams() <%%>\n \n     Consensus::Params consensus;\n     CMessageHeader::MessageStartChars pchMessageStart;\n@@ -105,7 +105,7 @@ class CChainParams\n     CCheckpointData checkpointData;\n     ChainTxData chainTxData;\n     bool m_fallback_fee_enabled;\n-};\n+%>;\n \n /**\n  * Creates and returns a std::unique_ptr<CChainParams> of the chosen chain."
      },
      {
        "sha": "bf4a68c5c10a3cf6542d4a58a5ee103fe9d965cb",
        "filename": "src/chainparamsbase.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/chainparamsbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/chainparamsbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsbase.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -16,23 +16,23 @@ const std::string CBaseChainParams::TESTNET = \"test\";\n const std::string CBaseChainParams::REGTEST = \"regtest\";\n \n void SetupChainParamsBaseOptions()\n-{\n+<%\n     gArgs.AddArg(\"-regtest\", \"Enter regression test mode, which uses a special chain in which blocks can be solved instantly. \"\n                                    \"This is intended for regression testing tools and app development.\", true, OptionsCategory::CHAINPARAMS);\n     gArgs.AddArg(\"-testnet\", \"Use the test chain\", false, OptionsCategory::CHAINPARAMS);\n     gArgs.AddArg(\"-vbparams=deployment:start:end\", \"Use given start/end times for specified version bits deployment (regtest-only)\", true, OptionsCategory::CHAINPARAMS);\n-}\n+%>\n \n static std::unique_ptr<CBaseChainParams> globalChainBaseParams;\n \n const CBaseChainParams& BaseParams()\n-{\n+<%\n     assert(globalChainBaseParams);\n     return *globalChainBaseParams;\n-}\n+%>\n \n std::unique_ptr<CBaseChainParams> CreateBaseChainParams(const std::string& chain)\n-{\n+<%\n     if (chain == CBaseChainParams::MAIN)\n         return MakeUnique<CBaseChainParams>(\"\", 8332);\n     else if (chain == CBaseChainParams::TESTNET)\n@@ -41,10 +41,10 @@ std::unique_ptr<CBaseChainParams> CreateBaseChainParams(const std::string& chain\n         return MakeUnique<CBaseChainParams>(\"regtest\", 18443);\n     else\n         throw std::runtime_error(strprintf(\"%s: Unknown chain %s.\", __func__, chain));\n-}\n+%>\n \n void SelectBaseParams(const std::string& chain)\n-{\n+<%\n     globalChainBaseParams = CreateBaseChainParams(chain);\n     gArgs.SelectConfigNetwork(chain);\n-}\n+%>"
      },
      {
        "sha": "97d5931e4b5c53680acbaf9ca46718f61e3bf282",
        "filename": "src/chainparamsbase.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/chainparamsbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/chainparamsbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsbase.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -14,23 +14,23 @@\n  * of a given instance of the Bitcoin system.\n  */\n class CBaseChainParams\n-{\n+<%\n public:\n     /** BIP70 chain name strings (main, test or regtest) */\n     static const std::string MAIN;\n     static const std::string TESTNET;\n     static const std::string REGTEST;\n \n-    const std::string& DataDir() const { return strDataDir; }\n-    int RPCPort() const { return nRPCPort; }\n+    const std::string& DataDir() const <% return strDataDir; %>\n+    int RPCPort() const <% return nRPCPort; %>\n \n     CBaseChainParams() = delete;\n-    CBaseChainParams(const std::string& data_dir, int rpc_port) : nRPCPort(rpc_port), strDataDir(data_dir) {}\n+    CBaseChainParams(const std::string& data_dir, int rpc_port) : nRPCPort(rpc_port), strDataDir(data_dir) <%%>\n \n private:\n     int nRPCPort;\n     std::string strDataDir;\n-};\n+%>;\n \n /**\n  * Creates and returns a std::unique_ptr<CBaseChainParams> of the chosen chain."
      },
      {
        "sha": "1c22bd1fcdf8fd14d2a266b2b736d2721ceac46e",
        "filename": "src/chainparamsseeds.h",
        "status": "modified",
        "additions": 1279,
        "deletions": 1279,
        "changes": 2558,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/chainparamsseeds.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/chainparamsseeds.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsseeds.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "b9a307e4cc7ecd2ff50037d4dede330e581eb1dc",
        "filename": "src/checkpoints.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/checkpoints.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/checkpoints.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkpoints.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -12,21 +12,21 @@\n #include <stdint.h>\n \n \n-namespace Checkpoints {\n+namespace Checkpoints <%\n \n     CBlockIndex* GetLastCheckpoint(const CCheckpointData& data)\n-    {\n+    <%\n         const MapCheckpoints& checkpoints = data.mapCheckpoints;\n \n         for (const MapCheckpoints::value_type& i : reverse_iterate(checkpoints))\n-        {\n+        <%\n             const uint256& hash = i.second;\n             CBlockIndex* pindex = LookupBlockIndex(hash);\n-            if (pindex) {\n+            if (pindex) <%\n                 return pindex;\n-            }\n-        }\n+            %>\n+        %>\n         return nullptr;\n-    }\n+    %>\n \n-} // namespace Checkpoints\n+%> // namespace Checkpoints"
      },
      {
        "sha": "8c034947d7529eed9438fe8b31dfc07b7bc9f09a",
        "filename": "src/checkpoints.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/checkpoints.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/checkpoints.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkpoints.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -17,11 +17,11 @@ struct CCheckpointData;\n  * They are updated every release or three.\n  */\n namespace Checkpoints\n-{\n+<%\n \n //! Returns last CBlockIndex* that is a checkpoint\n CBlockIndex* GetLastCheckpoint(const CCheckpointData& data);\n \n-} //namespace Checkpoints\n+%> //namespace Checkpoints\n \n #endif // BITCOIN_CHECKPOINTS_H"
      },
      {
        "sha": "e84e38d68339b3343f296e3c9fc6cd0d974c2cf1",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 42,
        "deletions": 42,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -28,7 +28,7 @@ class CCheckQueueControl;\n   */\n template <typename T>\n class CCheckQueue\n-{\n+<%\n private:\n     //! Mutex to protect the inner state\n     boost::mutex mutex;\n@@ -64,112 +64,112 @@ class CCheckQueue\n \n     /** Internal function that does bulk of the verification work. */\n     bool Loop(bool fMaster = false)\n-    {\n+    <%\n         boost::condition_variable& cond = fMaster ? condMaster : condWorker;\n         std::vector<T> vChecks;\n         vChecks.reserve(nBatchSize);\n         unsigned int nNow = 0;\n         bool fOk = true;\n-        do {\n-            {\n+        do <%\n+            <%\n                 boost::unique_lock<boost::mutex> lock(mutex);\n                 // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n-                if (nNow) {\n+                if (nNow) <%\n                     fAllOk &= fOk;\n                     nTodo -= nNow;\n                     if (nTodo == 0 && !fMaster)\n                         // We processed the last element; inform the master it can exit and return the result\n                         condMaster.notify_one();\n-                } else {\n+                %> else <%\n                     // first iteration\n                     nTotal++;\n-                }\n+                %>\n                 // logically, the do loop starts here\n-                while (queue.empty()) {\n-                    if (fMaster && nTodo == 0) {\n+                while (queue.empty()) <%\n+                    if (fMaster && nTodo == 0) <%\n                         nTotal--;\n                         bool fRet = fAllOk;\n                         // reset the status for new work later\n                         if (fMaster)\n                             fAllOk = true;\n                         // return the current status\n                         return fRet;\n-                    }\n+                    %>\n                     nIdle++;\n                     cond.wait(lock); // wait\n                     nIdle--;\n-                }\n+                %>\n                 // Decide how many work units to process now.\n                 // * Do not try to do everything at once, but aim for increasingly smaller batches so\n                 //   all workers finish approximately simultaneously.\n                 // * Try to account for idle jobs which will instantly start helping.\n                 // * Don't do batches smaller than 1 (duh), or larger than nBatchSize.\n                 nNow = std::max(1U, std::min(nBatchSize, (unsigned int)queue.size() / (nTotal + nIdle + 1)));\n                 vChecks.resize(nNow);\n-                for (unsigned int i = 0; i < nNow; i++) {\n+                for (unsigned int i = 0; i < nNow; i++) <%\n                     // We want the lock on the mutex to be as short as possible, so swap jobs from the global\n                     // queue to the local batch vector instead of copying.\n                     vChecks[i].swap(queue.back());\n                     queue.pop_back();\n-                }\n+                %>\n                 // Check whether we need to do work at all\n                 fOk = fAllOk;\n-            }\n+            %>\n             // execute work\n             for (T& check : vChecks)\n                 if (fOk)\n                     fOk = check();\n             vChecks.clear();\n-        } while (true);\n-    }\n+        %> while (true);\n+    %>\n \n public:\n     //! Mutex to ensure only one concurrent CCheckQueueControl\n     boost::mutex ControlMutex;\n \n     //! Create a new check queue\n-    explicit CCheckQueue(unsigned int nBatchSizeIn) : nIdle(0), nTotal(0), fAllOk(true), nTodo(0), nBatchSize(nBatchSizeIn) {}\n+    explicit CCheckQueue(unsigned int nBatchSizeIn) : nIdle(0), nTotal(0), fAllOk(true), nTodo(0), nBatchSize(nBatchSizeIn) <%%>\n \n     //! Worker thread\n     void Thread()\n-    {\n+    <%\n         Loop();\n-    }\n+    %>\n \n     //! Wait until execution finishes, and return whether all evaluations were successful.\n     bool Wait()\n-    {\n+    <%\n         return Loop(true);\n-    }\n+    %>\n \n     //! Add a batch of checks to the queue\n     void Add(std::vector<T>& vChecks)\n-    {\n+    <%\n         boost::unique_lock<boost::mutex> lock(mutex);\n-        for (T& check : vChecks) {\n+        for (T& check : vChecks) <%\n             queue.push_back(T());\n             check.swap(queue.back());\n-        }\n+        %>\n         nTodo += vChecks.size();\n         if (vChecks.size() == 1)\n             condWorker.notify_one();\n         else if (vChecks.size() > 1)\n             condWorker.notify_all();\n-    }\n+    %>\n \n     ~CCheckQueue()\n-    {\n-    }\n+    <%\n+    %>\n \n-};\n+%>;\n \n /**\n  * RAII-style controller object for a CCheckQueue that guarantees the passed\n  * queue is finished before continuing.\n  */\n template <typename T>\n class CCheckQueueControl\n-{\n+<%\n private:\n     CCheckQueue<T> * const pqueue;\n     bool fDone;\n@@ -179,36 +179,36 @@ class CCheckQueueControl\n     CCheckQueueControl(const CCheckQueueControl&) = delete;\n     CCheckQueueControl& operator=(const CCheckQueueControl&) = delete;\n     explicit CCheckQueueControl(CCheckQueue<T> * const pqueueIn) : pqueue(pqueueIn), fDone(false)\n-    {\n+    <%\n         // passed queue is supposed to be unused, or nullptr\n-        if (pqueue != nullptr) {\n+        if (pqueue != nullptr) <%\n             ENTER_CRITICAL_SECTION(pqueue->ControlMutex);\n-        }\n-    }\n+        %>\n+    %>\n \n     bool Wait()\n-    {\n+    <%\n         if (pqueue == nullptr)\n             return true;\n         bool fRet = pqueue->Wait();\n         fDone = true;\n         return fRet;\n-    }\n+    %>\n \n     void Add(std::vector<T>& vChecks)\n-    {\n+    <%\n         if (pqueue != nullptr)\n             pqueue->Add(vChecks);\n-    }\n+    %>\n \n     ~CCheckQueueControl()\n-    {\n+    <%\n         if (!fDone)\n             Wait();\n-        if (pqueue != nullptr) {\n+        if (pqueue != nullptr) <%\n             LEAVE_CRITICAL_SECTION(pqueue->ControlMutex);\n-        }\n-    }\n-};\n+        %>\n+    %>\n+%>;\n \n #endif // BITCOIN_CHECKQUEUE_H"
      },
      {
        "sha": "d434d5dc3d1824d2a616115452d95a126c423744",
        "filename": "src/clientversion.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/clientversion.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/clientversion.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/clientversion.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -69,34 +69,34 @@ const std::string CLIENT_NAME(\"Satoshi\");\n const std::string CLIENT_BUILD(BUILD_DESC CLIENT_VERSION_SUFFIX);\n \n static std::string FormatVersion(int nVersion)\n-{\n+<%\n     if (nVersion % 100 == 0)\n         return strprintf(\"%d.%d.%d\", nVersion / 1000000, (nVersion / 10000) % 100, (nVersion / 100) % 100);\n     else\n         return strprintf(\"%d.%d.%d.%d\", nVersion / 1000000, (nVersion / 10000) % 100, (nVersion / 100) % 100, nVersion % 100);\n-}\n+%>\n \n std::string FormatFullVersion()\n-{\n+<%\n     return CLIENT_BUILD;\n-}\n+%>\n \n /**\n  * Format the subversion field according to BIP 14 spec (https://github.com/bitcoin/bips/blob/master/bip-0014.mediawiki)\n  */\n std::string FormatSubVersion(const std::string& name, int nClientVersion, const std::vector<std::string>& comments)\n-{\n+<%\n     std::ostringstream ss;\n     ss << \"/\";\n     ss << name << \":\" << FormatVersion(nClientVersion);\n     if (!comments.empty())\n-    {\n+    <%\n         std::vector<std::string>::const_iterator it(comments.begin());\n         ss << \"(\" << *it;\n         for(++it; it != comments.end(); ++it)\n             ss << \"; \" << *it;\n         ss << \")\";\n-    }\n+    %>\n     ss << \"/\";\n     return ss.str();\n-}\n+%>"
      },
      {
        "sha": "5a9ad90a3a9a1ad7e0c0318e99f8ffd3a6958a5a",
        "filename": "src/coins.cpp",
        "status": "modified",
        "additions": 100,
        "deletions": 100,
        "changes": 200,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/coins.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/coins.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -8,152 +8,152 @@\n #include <random.h>\n #include <version.h>\n \n-bool CCoinsView::GetCoin(const COutPoint &outpoint, Coin &coin) const { return false; }\n-uint256 CCoinsView::GetBestBlock() const { return uint256(); }\n-std::vector<uint256> CCoinsView::GetHeadBlocks() const { return std::vector<uint256>(); }\n-bool CCoinsView::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) { return false; }\n-CCoinsViewCursor *CCoinsView::Cursor() const { return nullptr; }\n+bool CCoinsView::GetCoin(const COutPoint &outpoint, Coin &coin) const <% return false; %>\n+uint256 CCoinsView::GetBestBlock() const <% return uint256(); %>\n+std::vector<uint256> CCoinsView::GetHeadBlocks() const <% return std::vector<uint256>(); %>\n+bool CCoinsView::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) <% return false; %>\n+CCoinsViewCursor *CCoinsView::Cursor() const <% return nullptr; %>\n \n bool CCoinsView::HaveCoin(const COutPoint &outpoint) const\n-{\n+<%\n     Coin coin;\n     return GetCoin(outpoint, coin);\n-}\n+%>\n \n-CCoinsViewBacked::CCoinsViewBacked(CCoinsView *viewIn) : base(viewIn) { }\n-bool CCoinsViewBacked::GetCoin(const COutPoint &outpoint, Coin &coin) const { return base->GetCoin(outpoint, coin); }\n-bool CCoinsViewBacked::HaveCoin(const COutPoint &outpoint) const { return base->HaveCoin(outpoint); }\n-uint256 CCoinsViewBacked::GetBestBlock() const { return base->GetBestBlock(); }\n-std::vector<uint256> CCoinsViewBacked::GetHeadBlocks() const { return base->GetHeadBlocks(); }\n-void CCoinsViewBacked::SetBackend(CCoinsView &viewIn) { base = &viewIn; }\n-bool CCoinsViewBacked::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) { return base->BatchWrite(mapCoins, hashBlock); }\n-CCoinsViewCursor *CCoinsViewBacked::Cursor() const { return base->Cursor(); }\n-size_t CCoinsViewBacked::EstimateSize() const { return base->EstimateSize(); }\n+CCoinsViewBacked::CCoinsViewBacked(CCoinsView *viewIn) : base(viewIn) <% %>\n+bool CCoinsViewBacked::GetCoin(const COutPoint &outpoint, Coin &coin) const <% return base->GetCoin(outpoint, coin); %>\n+bool CCoinsViewBacked::HaveCoin(const COutPoint &outpoint) const <% return base->HaveCoin(outpoint); %>\n+uint256 CCoinsViewBacked::GetBestBlock() const <% return base->GetBestBlock(); %>\n+std::vector<uint256> CCoinsViewBacked::GetHeadBlocks() const <% return base->GetHeadBlocks(); %>\n+void CCoinsViewBacked::SetBackend(CCoinsView &viewIn) <% base = &viewIn; %>\n+bool CCoinsViewBacked::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) <% return base->BatchWrite(mapCoins, hashBlock); %>\n+CCoinsViewCursor *CCoinsViewBacked::Cursor() const <% return base->Cursor(); %>\n+size_t CCoinsViewBacked::EstimateSize() const <% return base->EstimateSize(); %>\n \n-SaltedOutpointHasher::SaltedOutpointHasher() : k0(GetRand(std::numeric_limits<uint64_t>::max())), k1(GetRand(std::numeric_limits<uint64_t>::max())) {}\n+SaltedOutpointHasher::SaltedOutpointHasher() : k0(GetRand(std::numeric_limits<uint64_t>::max())), k1(GetRand(std::numeric_limits<uint64_t>::max())) <%%>\n \n-CCoinsViewCache::CCoinsViewCache(CCoinsView *baseIn) : CCoinsViewBacked(baseIn), cachedCoinsUsage(0) {}\n+CCoinsViewCache::CCoinsViewCache(CCoinsView *baseIn) : CCoinsViewBacked(baseIn), cachedCoinsUsage(0) <%%>\n \n-size_t CCoinsViewCache::DynamicMemoryUsage() const {\n+size_t CCoinsViewCache::DynamicMemoryUsage() const <%\n     return memusage::DynamicUsage(cacheCoins) + cachedCoinsUsage;\n-}\n+%>\n \n-CCoinsMap::iterator CCoinsViewCache::FetchCoin(const COutPoint &outpoint) const {\n+CCoinsMap::iterator CCoinsViewCache::FetchCoin(const COutPoint &outpoint) const <%\n     CCoinsMap::iterator it = cacheCoins.find(outpoint);\n     if (it != cacheCoins.end())\n         return it;\n     Coin tmp;\n     if (!base->GetCoin(outpoint, tmp))\n         return cacheCoins.end();\n     CCoinsMap::iterator ret = cacheCoins.emplace(std::piecewise_construct, std::forward_as_tuple(outpoint), std::forward_as_tuple(std::move(tmp))).first;\n-    if (ret->second.coin.IsSpent()) {\n+    if (ret->second.coin.IsSpent()) <%\n         // The parent only has an empty entry for this outpoint; we can consider our\n         // version as fresh.\n         ret->second.flags = CCoinsCacheEntry::FRESH;\n-    }\n+    %>\n     cachedCoinsUsage += ret->second.coin.DynamicMemoryUsage();\n     return ret;\n-}\n+%>\n \n-bool CCoinsViewCache::GetCoin(const COutPoint &outpoint, Coin &coin) const {\n+bool CCoinsViewCache::GetCoin(const COutPoint &outpoint, Coin &coin) const <%\n     CCoinsMap::const_iterator it = FetchCoin(outpoint);\n-    if (it != cacheCoins.end()) {\n+    if (it != cacheCoins.end()) <%\n         coin = it->second.coin;\n         return !coin.IsSpent();\n-    }\n+    %>\n     return false;\n-}\n+%>\n \n-void CCoinsViewCache::AddCoin(const COutPoint &outpoint, Coin&& coin, bool possible_overwrite) {\n+void CCoinsViewCache::AddCoin(const COutPoint &outpoint, Coin&& coin, bool possible_overwrite) <%\n     assert(!coin.IsSpent());\n     if (coin.out.scriptPubKey.IsUnspendable()) return;\n     CCoinsMap::iterator it;\n     bool inserted;\n     std::tie(it, inserted) = cacheCoins.emplace(std::piecewise_construct, std::forward_as_tuple(outpoint), std::tuple<>());\n     bool fresh = false;\n-    if (!inserted) {\n+    if (!inserted) <%\n         cachedCoinsUsage -= it->second.coin.DynamicMemoryUsage();\n-    }\n-    if (!possible_overwrite) {\n-        if (!it->second.coin.IsSpent()) {\n+    %>\n+    if (!possible_overwrite) <%\n+        if (!it->second.coin.IsSpent()) <%\n             throw std::logic_error(\"Adding new coin that replaces non-pruned entry\");\n-        }\n+        %>\n         fresh = !(it->second.flags & CCoinsCacheEntry::DIRTY);\n-    }\n+    %>\n     it->second.coin = std::move(coin);\n     it->second.flags |= CCoinsCacheEntry::DIRTY | (fresh ? CCoinsCacheEntry::FRESH : 0);\n     cachedCoinsUsage += it->second.coin.DynamicMemoryUsage();\n-}\n+%>\n \n-void AddCoins(CCoinsViewCache& cache, const CTransaction &tx, int nHeight, bool check) {\n+void AddCoins(CCoinsViewCache& cache, const CTransaction &tx, int nHeight, bool check) <%\n     bool fCoinbase = tx.IsCoinBase();\n     const uint256& txid = tx.GetHash();\n-    for (size_t i = 0; i < tx.vout.size(); ++i) {\n+    for (size_t i = 0; i < tx.vout.size(); ++i) <%\n         bool overwrite = check ? cache.HaveCoin(COutPoint(txid, i)) : fCoinbase;\n         // Always set the possible_overwrite flag to AddCoin for coinbase txn, in order to correctly\n         // deal with the pre-BIP30 occurrences of duplicate coinbase transactions.\n         cache.AddCoin(COutPoint(txid, i), Coin(tx.vout[i], nHeight, fCoinbase), overwrite);\n-    }\n-}\n+    %>\n+%>\n \n-bool CCoinsViewCache::SpendCoin(const COutPoint &outpoint, Coin* moveout) {\n+bool CCoinsViewCache::SpendCoin(const COutPoint &outpoint, Coin* moveout) <%\n     CCoinsMap::iterator it = FetchCoin(outpoint);\n     if (it == cacheCoins.end()) return false;\n     cachedCoinsUsage -= it->second.coin.DynamicMemoryUsage();\n-    if (moveout) {\n+    if (moveout) <%\n         *moveout = std::move(it->second.coin);\n-    }\n-    if (it->second.flags & CCoinsCacheEntry::FRESH) {\n+    %>\n+    if (it->second.flags & CCoinsCacheEntry::FRESH) <%\n         cacheCoins.erase(it);\n-    } else {\n+    %> else <%\n         it->second.flags |= CCoinsCacheEntry::DIRTY;\n         it->second.coin.Clear();\n-    }\n+    %>\n     return true;\n-}\n+%>\n \n static const Coin coinEmpty;\n \n-const Coin& CCoinsViewCache::AccessCoin(const COutPoint &outpoint) const {\n+const Coin& CCoinsViewCache::AccessCoin(const COutPoint &outpoint) const <%\n     CCoinsMap::const_iterator it = FetchCoin(outpoint);\n-    if (it == cacheCoins.end()) {\n+    if (it == cacheCoins.end()) <%\n         return coinEmpty;\n-    } else {\n+    %> else <%\n         return it->second.coin;\n-    }\n-}\n+    %>\n+%>\n \n-bool CCoinsViewCache::HaveCoin(const COutPoint &outpoint) const {\n+bool CCoinsViewCache::HaveCoin(const COutPoint &outpoint) const <%\n     CCoinsMap::const_iterator it = FetchCoin(outpoint);\n     return (it != cacheCoins.end() && !it->second.coin.IsSpent());\n-}\n+%>\n \n-bool CCoinsViewCache::HaveCoinInCache(const COutPoint &outpoint) const {\n+bool CCoinsViewCache::HaveCoinInCache(const COutPoint &outpoint) const <%\n     CCoinsMap::const_iterator it = cacheCoins.find(outpoint);\n     return (it != cacheCoins.end() && !it->second.coin.IsSpent());\n-}\n+%>\n \n-uint256 CCoinsViewCache::GetBestBlock() const {\n+uint256 CCoinsViewCache::GetBestBlock() const <%\n     if (hashBlock.IsNull())\n         hashBlock = base->GetBestBlock();\n     return hashBlock;\n-}\n+%>\n \n-void CCoinsViewCache::SetBestBlock(const uint256 &hashBlockIn) {\n+void CCoinsViewCache::SetBestBlock(const uint256 &hashBlockIn) <%\n     hashBlock = hashBlockIn;\n-}\n+%>\n \n-bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn) {\n-    for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end(); it = mapCoins.erase(it)) {\n+bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn) <%\n+    for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end(); it = mapCoins.erase(it)) <%\n         // Ignore non-dirty entries (optimization).\n-        if (!(it->second.flags & CCoinsCacheEntry::DIRTY)) {\n+        if (!(it->second.flags & CCoinsCacheEntry::DIRTY)) <%\n             continue;\n-        }\n+        %>\n         CCoinsMap::iterator itUs = cacheCoins.find(it->first);\n-        if (itUs == cacheCoins.end()) {\n+        if (itUs == cacheCoins.end()) <%\n             // The parent cache does not have an entry, while the child does\n             // We can ignore it if it's both FRESH and pruned in the child\n-            if (!(it->second.flags & CCoinsCacheEntry::FRESH && it->second.coin.IsSpent())) {\n+            if (!(it->second.flags & CCoinsCacheEntry::FRESH && it->second.coin.IsSpent())) <%\n                 // Otherwise we will need to create it in the parent\n                 // and move the data up and mark it as dirty\n                 CCoinsCacheEntry& entry = cacheCoins[it->first];\n@@ -163,27 +163,27 @@ bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn\n                 // We can mark it FRESH in the parent if it was FRESH in the child\n                 // Otherwise it might have just been flushed from the parent's cache\n                 // and already exist in the grandparent\n-                if (it->second.flags & CCoinsCacheEntry::FRESH) {\n+                if (it->second.flags & CCoinsCacheEntry::FRESH) <%\n                     entry.flags |= CCoinsCacheEntry::FRESH;\n-                }\n-            }\n-        } else {\n+                %>\n+            %>\n+        %> else <%\n             // Assert that the child cache entry was not marked FRESH if the\n             // parent cache entry has unspent outputs. If this ever happens,\n             // it means the FRESH flag was misapplied and there is a logic\n             // error in the calling code.\n-            if ((it->second.flags & CCoinsCacheEntry::FRESH) && !itUs->second.coin.IsSpent()) {\n+            if ((it->second.flags & CCoinsCacheEntry::FRESH) && !itUs->second.coin.IsSpent()) <%\n                 throw std::logic_error(\"FRESH flag misapplied to cache entry for base transaction with spendable outputs\");\n-            }\n+            %>\n \n             // Found the entry in the parent cache\n-            if ((itUs->second.flags & CCoinsCacheEntry::FRESH) && it->second.coin.IsSpent()) {\n+            if ((itUs->second.flags & CCoinsCacheEntry::FRESH) && it->second.coin.IsSpent()) <%\n                 // The grandparent does not have an entry, and the child is\n                 // modified and being pruned. This means we can just delete\n                 // it from the parent.\n                 cachedCoinsUsage -= itUs->second.coin.DynamicMemoryUsage();\n                 cacheCoins.erase(itUs);\n-            } else {\n+            %> else <%\n                 // A normal modification.\n                 cachedCoinsUsage -= itUs->second.coin.DynamicMemoryUsage();\n                 itUs->second.coin = std::move(it->second.coin);\n@@ -194,35 +194,35 @@ bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn\n                 // we must not copy that FRESH flag to the parent as that\n                 // pruned state likely still needs to be communicated to the\n                 // grandparent.\n-            }\n-        }\n-    }\n+            %>\n+        %>\n+    %>\n     hashBlock = hashBlockIn;\n     return true;\n-}\n+%>\n \n-bool CCoinsViewCache::Flush() {\n+bool CCoinsViewCache::Flush() <%\n     bool fOk = base->BatchWrite(cacheCoins, hashBlock);\n     cacheCoins.clear();\n     cachedCoinsUsage = 0;\n     return fOk;\n-}\n+%>\n \n void CCoinsViewCache::Uncache(const COutPoint& hash)\n-{\n+<%\n     CCoinsMap::iterator it = cacheCoins.find(hash);\n-    if (it != cacheCoins.end() && it->second.flags == 0) {\n+    if (it != cacheCoins.end() && it->second.flags == 0) <%\n         cachedCoinsUsage -= it->second.coin.DynamicMemoryUsage();\n         cacheCoins.erase(it);\n-    }\n-}\n+    %>\n+%>\n \n-unsigned int CCoinsViewCache::GetCacheSize() const {\n+unsigned int CCoinsViewCache::GetCacheSize() const <%\n     return cacheCoins.size();\n-}\n+%>\n \n CAmount CCoinsViewCache::GetValueIn(const CTransaction& tx) const\n-{\n+<%\n     if (tx.IsCoinBase())\n         return 0;\n \n@@ -231,30 +231,30 @@ CAmount CCoinsViewCache::GetValueIn(const CTransaction& tx) const\n         nResult += AccessCoin(tx.vin[i].prevout).out.nValue;\n \n     return nResult;\n-}\n+%>\n \n bool CCoinsViewCache::HaveInputs(const CTransaction& tx) const\n-{\n-    if (!tx.IsCoinBase()) {\n-        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n-            if (!HaveCoin(tx.vin[i].prevout)) {\n+<%\n+    if (!tx.IsCoinBase()) <%\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) <%\n+            if (!HaveCoin(tx.vin[i].prevout)) <%\n                 return false;\n-            }\n-        }\n-    }\n+            %>\n+        %>\n+    %>\n     return true;\n-}\n+%>\n \n static const size_t MIN_TRANSACTION_OUTPUT_WEIGHT = WITNESS_SCALE_FACTOR * ::GetSerializeSize(CTxOut(), PROTOCOL_VERSION);\n static const size_t MAX_OUTPUTS_PER_BLOCK = MAX_BLOCK_WEIGHT / MIN_TRANSACTION_OUTPUT_WEIGHT;\n \n const Coin& AccessByTxid(const CCoinsViewCache& view, const uint256& txid)\n-{\n+<%\n     COutPoint iter(txid, 0);\n-    while (iter.n < MAX_OUTPUTS_PER_BLOCK) {\n+    while (iter.n < MAX_OUTPUTS_PER_BLOCK) <%\n         const Coin& alternate = view.AccessCoin(iter);\n         if (!alternate.IsSpent()) return alternate;\n         ++iter.n;\n-    }\n+    %>\n     return coinEmpty;\n-}\n+%>"
      },
      {
        "sha": "0d7d29eb2a6d85b06d22284e205d6d3b5ddb7352",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 42,
        "deletions": 42,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -27,7 +27,7 @@\n  * - the non-spent CTxOut (via CTxOutCompressor)\n  */\n class Coin\n-{\n+<%\n public:\n     //! unspent transaction output\n     CTxOut out;\n@@ -39,50 +39,50 @@ class Coin\n     uint32_t nHeight : 31;\n \n     //! construct a Coin from a CTxOut and height/coinbase information.\n-    Coin(CTxOut&& outIn, int nHeightIn, bool fCoinBaseIn) : out(std::move(outIn)), fCoinBase(fCoinBaseIn), nHeight(nHeightIn) {}\n-    Coin(const CTxOut& outIn, int nHeightIn, bool fCoinBaseIn) : out(outIn), fCoinBase(fCoinBaseIn),nHeight(nHeightIn) {}\n+    Coin(CTxOut&& outIn, int nHeightIn, bool fCoinBaseIn) : out(std::move(outIn)), fCoinBase(fCoinBaseIn), nHeight(nHeightIn) <%%>\n+    Coin(const CTxOut& outIn, int nHeightIn, bool fCoinBaseIn) : out(outIn), fCoinBase(fCoinBaseIn),nHeight(nHeightIn) <%%>\n \n-    void Clear() {\n+    void Clear() <%\n         out.SetNull();\n         fCoinBase = false;\n         nHeight = 0;\n-    }\n+    %>\n \n     //! empty constructor\n-    Coin() : fCoinBase(false), nHeight(0) { }\n+    Coin() : fCoinBase(false), nHeight(0) <% %>\n \n-    bool IsCoinBase() const {\n+    bool IsCoinBase() const <%\n         return fCoinBase;\n-    }\n+    %>\n \n     template<typename Stream>\n-    void Serialize(Stream &s) const {\n+    void Serialize(Stream &s) const <%\n         assert(!IsSpent());\n         uint32_t code = nHeight * 2 + fCoinBase;\n         ::Serialize(s, VARINT(code));\n         ::Serialize(s, CTxOutCompressor(REF(out)));\n-    }\n+    %>\n \n     template<typename Stream>\n-    void Unserialize(Stream &s) {\n+    void Unserialize(Stream &s) <%\n         uint32_t code = 0;\n         ::Unserialize(s, VARINT(code));\n         nHeight = code >> 1;\n         fCoinBase = code & 1;\n         ::Unserialize(s, CTxOutCompressor(out));\n-    }\n+    %>\n \n-    bool IsSpent() const {\n+    bool IsSpent() const <%\n         return out.IsNull();\n-    }\n+    %>\n \n-    size_t DynamicMemoryUsage() const {\n+    size_t DynamicMemoryUsage() const <%\n         return memusage::DynamicUsage(out.scriptPubKey);\n-    }\n-};\n+    %>\n+%>;\n \n class SaltedOutpointHasher\n-{\n+<%\n private:\n     /** Salt */\n     const uint64_t k0, k1;\n@@ -95,38 +95,38 @@ class SaltedOutpointHasher\n      * unordered_map will behave unpredictably if the custom hasher returns a\n      * uint64_t, resulting in failures when syncing the chain (#4634).\n      */\n-    size_t operator()(const COutPoint& id) const {\n+    size_t operator()(const COutPoint& id) const <%\n         return SipHashUint256Extra(k0, k1, id.hash, id.n);\n-    }\n-};\n+    %>\n+%>;\n \n struct CCoinsCacheEntry\n-{\n+<%\n     Coin coin; // The actual cached data.\n     unsigned char flags;\n \n-    enum Flags {\n+    enum Flags <%\n         DIRTY = (1 << 0), // This cache entry is potentially different from the version in the parent view.\n         FRESH = (1 << 1), // The parent view does not have this entry (or it is pruned).\n         /* Note that FRESH is a performance optimization with which we can\n          * erase coins that are fully spent if we know we do not need to\n          * flush the changes to the parent cache.  It is always safe to\n          * not mark FRESH if that condition is not guaranteed.\n          */\n-    };\n+    %>;\n \n-    CCoinsCacheEntry() : flags(0) {}\n-    explicit CCoinsCacheEntry(Coin&& coin_) : coin(std::move(coin_)), flags(0) {}\n-};\n+    CCoinsCacheEntry() : flags(0) <%%>\n+    explicit CCoinsCacheEntry(Coin&& coin_) : coin(std::move(coin_)), flags(0) <%%>\n+%>;\n \n typedef std::unordered_map<COutPoint, CCoinsCacheEntry, SaltedOutpointHasher> CCoinsMap;\n \n /** Cursor for iterating over CoinsView state */\n class CCoinsViewCursor\n-{\n+<%\n public:\n-    CCoinsViewCursor(const uint256 &hashBlockIn): hashBlock(hashBlockIn) {}\n-    virtual ~CCoinsViewCursor() {}\n+    CCoinsViewCursor(const uint256 &hashBlockIn): hashBlock(hashBlockIn) <%%>\n+    virtual ~CCoinsViewCursor() <%%>\n \n     virtual bool GetKey(COutPoint &key) const = 0;\n     virtual bool GetValue(Coin &coin) const = 0;\n@@ -136,14 +136,14 @@ class CCoinsViewCursor\n     virtual void Next() = 0;\n \n     //! Get best block at the time this cursor was created\n-    const uint256 &GetBestBlock() const { return hashBlock; }\n+    const uint256 &GetBestBlock() const <% return hashBlock; %>\n private:\n     uint256 hashBlock;\n-};\n+%>;\n \n /** Abstract view on the open txout dataset. */\n class CCoinsView\n-{\n+<%\n public:\n     /** Retrieve the Coin (unspent transaction output) for a given outpoint.\n      *  Returns true only when an unspent coin was found, which is returned in coin.\n@@ -171,16 +171,16 @@ class CCoinsView\n     virtual CCoinsViewCursor *Cursor() const;\n \n     //! As we use CCoinsViews polymorphically, have a virtual destructor\n-    virtual ~CCoinsView() {}\n+    virtual ~CCoinsView() <%%>\n \n     //! Estimate database size (0 if not implemented)\n-    virtual size_t EstimateSize() const { return 0; }\n-};\n+    virtual size_t EstimateSize() const <% return 0; %>\n+%>;\n \n \n /** CCoinsView backed by another CCoinsView */\n class CCoinsViewBacked : public CCoinsView\n-{\n+<%\n protected:\n     CCoinsView *base;\n \n@@ -194,12 +194,12 @@ class CCoinsViewBacked : public CCoinsView\n     bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) override;\n     CCoinsViewCursor *Cursor() const override;\n     size_t EstimateSize() const override;\n-};\n+%>;\n \n \n /** CCoinsView that adds a memory cache for transactions to another CCoinsView */\n class CCoinsViewCache : public CCoinsViewBacked\n-{\n+<%\n protected:\n     /**\n      * Make mutable so that we can \"fill the cache\" even from Get-methods\n@@ -225,9 +225,9 @@ class CCoinsViewCache : public CCoinsViewBacked\n     uint256 GetBestBlock() const override;\n     void SetBestBlock(const uint256 &hashBlock);\n     bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) override;\n-    CCoinsViewCursor* Cursor() const override {\n+    CCoinsViewCursor* Cursor() const override <%\n         throw std::logic_error(\"CCoinsViewCache cursor iteration not supported.\");\n-    }\n+    %>\n \n     /**\n      * Check if we have the given utxo already loaded in this cache.\n@@ -295,7 +295,7 @@ class CCoinsViewCache : public CCoinsViewBacked\n \n private:\n     CCoinsMap::iterator FetchCoin(const COutPoint &outpoint) const;\n-};\n+%>;\n \n //! Utility function to add all of a transaction's outputs to a cache.\n //! When check is false, this assumes that overwrites are only possible for coinbase transactions."
      },
      {
        "sha": "ad2dfc0456c309fafd26c62b71cceefc7ffd735e",
        "filename": "src/compat.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/compat.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/compat.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -95,12 +95,12 @@ typedef char* sockopt_arg_type;\n #define USE_POLL\n #endif\n \n-bool static inline IsSelectableSocket(const SOCKET& s) {\n+bool static inline IsSelectableSocket(const SOCKET& s) <%\n #if defined(USE_POLL) || defined(WIN32)\n     return true;\n #else\n     return (s < FD_SETSIZE);\n #endif\n-}\n+%>\n \n #endif // BITCOIN_COMPAT_H"
      },
      {
        "sha": "8f89aa090e3b8d3b22c9bc204266710699a43d54",
        "filename": "src/compat/byteswap.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/compat/byteswap.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/compat/byteswap.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/byteswap.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -34,22 +34,22 @@\n \n #if HAVE_DECL_BSWAP_16 == 0\n inline uint16_t bswap_16(uint16_t x)\n-{\n+<%\n     return (x >> 8) | (x << 8);\n-}\n+%>\n #endif // HAVE_DECL_BSWAP16 == 0\n \n #if HAVE_DECL_BSWAP_32 == 0\n inline uint32_t bswap_32(uint32_t x)\n-{\n+<%\n     return (((x & 0xff000000U) >> 24) | ((x & 0x00ff0000U) >>  8) |\n             ((x & 0x0000ff00U) <<  8) | ((x & 0x000000ffU) << 24));\n-}\n+%>\n #endif // HAVE_DECL_BSWAP32 == 0\n \n #if HAVE_DECL_BSWAP_64 == 0\n inline uint64_t bswap_64(uint64_t x)\n-{\n+<%\n      return (((x & 0xff00000000000000ull) >> 56)\n           | ((x & 0x00ff000000000000ull) >> 40)\n           | ((x & 0x0000ff0000000000ull) >> 24)\n@@ -58,7 +58,7 @@ inline uint64_t bswap_64(uint64_t x)\n           | ((x & 0x0000000000ff0000ull) << 24)\n           | ((x & 0x000000000000ff00ull) << 40)\n           | ((x & 0x00000000000000ffull) << 56));\n-}\n+%>\n #endif // HAVE_DECL_BSWAP64 == 0\n \n #endif // defined(MAC_OSX)"
      },
      {
        "sha": "540d5076456360c7fd6d34a4906d9d3138798a96",
        "filename": "src/compat/endian.h",
        "status": "modified",
        "additions": 48,
        "deletions": 48,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/compat/endian.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/compat/endian.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/endian.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -68,172 +68,172 @@\n \n #if HAVE_DECL_HTOBE16 == 0\n inline uint16_t htobe16(uint16_t host_16bits)\n-{\n+<%\n     return host_16bits;\n-}\n+%>\n #endif // HAVE_DECL_HTOBE16\n \n #if HAVE_DECL_HTOLE16 == 0\n inline uint16_t htole16(uint16_t host_16bits)\n-{\n+<%\n     return bswap_16(host_16bits);\n-}\n+%>\n #endif // HAVE_DECL_HTOLE16\n \n #if HAVE_DECL_BE16TOH == 0\n inline uint16_t be16toh(uint16_t big_endian_16bits)\n-{\n+<%\n     return big_endian_16bits;\n-}\n+%>\n #endif // HAVE_DECL_BE16TOH\n \n #if HAVE_DECL_LE16TOH == 0\n inline uint16_t le16toh(uint16_t little_endian_16bits)\n-{\n+<%\n     return bswap_16(little_endian_16bits);\n-}\n+%>\n #endif // HAVE_DECL_LE16TOH\n \n #if HAVE_DECL_HTOBE32 == 0\n inline uint32_t htobe32(uint32_t host_32bits)\n-{\n+<%\n     return host_32bits;\n-}\n+%>\n #endif // HAVE_DECL_HTOBE32\n \n #if HAVE_DECL_HTOLE32 == 0\n inline uint32_t htole32(uint32_t host_32bits)\n-{\n+<%\n     return bswap_32(host_32bits);\n-}\n+%>\n #endif // HAVE_DECL_HTOLE32\n \n #if HAVE_DECL_BE32TOH == 0\n inline uint32_t be32toh(uint32_t big_endian_32bits)\n-{\n+<%\n     return big_endian_32bits;\n-}\n+%>\n #endif // HAVE_DECL_BE32TOH\n \n #if HAVE_DECL_LE32TOH == 0\n inline uint32_t le32toh(uint32_t little_endian_32bits)\n-{\n+<%\n     return bswap_32(little_endian_32bits);\n-}\n+%>\n #endif // HAVE_DECL_LE32TOH\n \n #if HAVE_DECL_HTOBE64 == 0\n inline uint64_t htobe64(uint64_t host_64bits)\n-{\n+<%\n     return host_64bits;\n-}\n+%>\n #endif // HAVE_DECL_HTOBE64\n \n #if HAVE_DECL_HTOLE64 == 0\n inline uint64_t htole64(uint64_t host_64bits)\n-{\n+<%\n     return bswap_64(host_64bits);\n-}\n+%>\n #endif // HAVE_DECL_HTOLE64\n \n #if HAVE_DECL_BE64TOH == 0\n inline uint64_t be64toh(uint64_t big_endian_64bits)\n-{\n+<%\n     return big_endian_64bits;\n-}\n+%>\n #endif // HAVE_DECL_BE64TOH\n \n #if HAVE_DECL_LE64TOH == 0\n inline uint64_t le64toh(uint64_t little_endian_64bits)\n-{\n+<%\n     return bswap_64(little_endian_64bits);\n-}\n+%>\n #endif // HAVE_DECL_LE64TOH\n \n #else // WORDS_BIGENDIAN\n \n #if HAVE_DECL_HTOBE16 == 0\n inline uint16_t htobe16(uint16_t host_16bits)\n-{\n+<%\n     return bswap_16(host_16bits);\n-}\n+%>\n #endif // HAVE_DECL_HTOBE16\n \n #if HAVE_DECL_HTOLE16 == 0\n inline uint16_t htole16(uint16_t host_16bits)\n-{\n+<%\n     return host_16bits;\n-}\n+%>\n #endif // HAVE_DECL_HTOLE16\n \n #if HAVE_DECL_BE16TOH == 0\n inline uint16_t be16toh(uint16_t big_endian_16bits)\n-{\n+<%\n     return bswap_16(big_endian_16bits);\n-}\n+%>\n #endif // HAVE_DECL_BE16TOH\n \n #if HAVE_DECL_LE16TOH == 0\n inline uint16_t le16toh(uint16_t little_endian_16bits)\n-{\n+<%\n     return little_endian_16bits;\n-}\n+%>\n #endif // HAVE_DECL_LE16TOH\n \n #if HAVE_DECL_HTOBE32 == 0\n inline uint32_t htobe32(uint32_t host_32bits)\n-{\n+<%\n     return bswap_32(host_32bits);\n-}\n+%>\n #endif // HAVE_DECL_HTOBE32\n \n #if HAVE_DECL_HTOLE32 == 0\n inline uint32_t htole32(uint32_t host_32bits)\n-{\n+<%\n     return host_32bits;\n-}\n+%>\n #endif // HAVE_DECL_HTOLE32\n \n #if HAVE_DECL_BE32TOH == 0\n inline uint32_t be32toh(uint32_t big_endian_32bits)\n-{\n+<%\n     return bswap_32(big_endian_32bits);\n-}\n+%>\n #endif // HAVE_DECL_BE32TOH\n \n #if HAVE_DECL_LE32TOH == 0\n inline uint32_t le32toh(uint32_t little_endian_32bits)\n-{\n+<%\n     return little_endian_32bits;\n-}\n+%>\n #endif // HAVE_DECL_LE32TOH\n \n #if HAVE_DECL_HTOBE64 == 0\n inline uint64_t htobe64(uint64_t host_64bits)\n-{\n+<%\n     return bswap_64(host_64bits);\n-}\n+%>\n #endif // HAVE_DECL_HTOBE64\n \n #if HAVE_DECL_HTOLE64 == 0\n inline uint64_t htole64(uint64_t host_64bits)\n-{\n+<%\n     return host_64bits;\n-}\n+%>\n #endif // HAVE_DECL_HTOLE64\n \n #if HAVE_DECL_BE64TOH == 0\n inline uint64_t be64toh(uint64_t big_endian_64bits)\n-{\n+<%\n     return bswap_64(big_endian_64bits);\n-}\n+%>\n #endif // HAVE_DECL_BE64TOH\n \n #if HAVE_DECL_LE64TOH == 0\n inline uint64_t le64toh(uint64_t little_endian_64bits)\n-{\n+<%\n     return little_endian_64bits;\n-}\n+%>\n #endif // HAVE_DECL_LE64TOH\n \n #endif // WORDS_BIGENDIAN"
      },
      {
        "sha": "1726851fc231b965b1a0db1ed5e0319196d18b31",
        "filename": "src/compat/glibc_compat.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/compat/glibc_compat.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/compat/glibc_compat.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/glibc_compat.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -16,36 +16,36 @@\n // Prior to GLIBC_2.14, memcpy was aliased to memmove.\n extern \"C\" void* memmove(void* a, const void* b, size_t c);\n extern \"C\" void* memcpy(void* a, const void* b, size_t c)\n-{\n+<%\n     return memmove(a, b, c);\n-}\n+%>\n \n extern \"C\" void __chk_fail(void) __attribute__((__noreturn__));\n extern \"C\" FDELT_TYPE __fdelt_warn(FDELT_TYPE a)\n-{\n+<%\n     if (a >= FD_SETSIZE)\n         __chk_fail();\n     return a / __NFDBITS;\n-}\n+%>\n extern \"C\" FDELT_TYPE __fdelt_chk(FDELT_TYPE) __attribute__((weak, alias(\"__fdelt_warn\")));\n \n #if defined(__i386__) || defined(__arm__)\n \n extern \"C\" int64_t __udivmoddi4(uint64_t u, uint64_t v, uint64_t* rp);\n \n extern \"C\" int64_t __wrap___divmoddi4(int64_t u, int64_t v, int64_t* rp)\n-{\n+<%\n     int32_t c1 = 0, c2 = 0;\n     int64_t uu = u, vv = v;\n     int64_t w;\n     int64_t r;\n \n-    if (uu < 0) {\n+    if (uu < 0) <%\n         c1 = ~c1, c2 = ~c2, uu = -uu;\n-    }\n-    if (vv < 0) {\n+    %>\n+    if (vv < 0) <%\n         c1 = ~c1, vv = -vv;\n-    }\n+    %>\n \n     w = __udivmoddi4(uu, vv, (uint64_t*)&r);\n     if (c1)\n@@ -55,7 +55,7 @@ extern \"C\" int64_t __wrap___divmoddi4(int64_t u, int64_t v, int64_t* rp)\n \n     *rp = r;\n     return w;\n-}\n+%>\n #endif\n \n extern \"C\" float log2f_old(float x);\n@@ -71,6 +71,6 @@ __asm(\".symver log2f_old,log2f@GLIBC_2.17\");\n __asm(\".symver log2f_old,log2f@GLIBC_2.27\");\n #endif\n extern \"C\" float __wrap_log2f(float x)\n-{\n+<%\n     return log2f_old(x);\n-}\n+%>"
      },
      {
        "sha": "a1905dab74266e201b7a2c3fdab4b7f0a9f74736",
        "filename": "src/compat/glibc_sanity.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/compat/glibc_sanity.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/compat/glibc_sanity.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/glibc_sanity.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -14,55 +14,55 @@\n \n extern \"C\" void* memcpy(void* a, const void* b, size_t c);\n void* memcpy_int(void* a, const void* b, size_t c)\n-{\n+<%\n     return memcpy(a, b, c);\n-}\n+%>\n \n namespace\n-{\n+<%\n // trigger: Use the memcpy_int wrapper which calls our internal memcpy.\n //   A direct call to memcpy may be optimized away by the compiler.\n // test: Fill an array with a sequence of integers. memcpy to a new empty array.\n //   Verify that the arrays are equal. Use an odd size to decrease the odds of\n //   the call being optimized away.\n template <unsigned int T>\n bool sanity_test_memcpy()\n-{\n+<%\n     unsigned int memcpy_test[T];\n-    unsigned int memcpy_verify[T] = {};\n+    unsigned int memcpy_verify[T] = <%%>;\n     for (unsigned int i = 0; i != T; ++i)\n         memcpy_test[i] = i;\n \n     memcpy_int(memcpy_verify, memcpy_test, sizeof(memcpy_test));\n \n-    for (unsigned int i = 0; i != T; ++i) {\n+    for (unsigned int i = 0; i != T; ++i) <%\n         if (memcpy_verify[i] != i)\n             return false;\n-    }\n+    %>\n     return true;\n-}\n+%>\n \n #if defined(HAVE_SYS_SELECT_H)\n // trigger: Call FD_SET to trigger __fdelt_chk. FORTIFY_SOURCE must be defined\n //   as >0 and optimizations must be set to at least -O2.\n // test: Add a file descriptor to an empty fd_set. Verify that it has been\n //   correctly added.\n bool sanity_test_fdelt()\n-{\n+<%\n     fd_set fds;\n     FD_ZERO(&fds);\n     FD_SET(0, &fds);\n     return FD_ISSET(0, &fds);\n-}\n+%>\n #endif\n \n-} // namespace\n+%> // namespace\n \n bool glibc_sanity_test()\n-{\n+<%\n #if defined(HAVE_SYS_SELECT_H)\n     if (!sanity_test_fdelt())\n         return false;\n #endif\n     return sanity_test_memcpy<1025>();\n-}\n+%>"
      },
      {
        "sha": "6487604aba54c03d5dfa004d53a5544f4ab91721",
        "filename": "src/compat/glibcxx_sanity.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/compat/glibcxx_sanity.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/compat/glibcxx_sanity.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/glibcxx_sanity.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -7,55 +7,55 @@\n #include <stdexcept>\n \n namespace\n-{\n+<%\n // trigger: use ctype<char>::widen to trigger ctype<char>::_M_widen_init().\n // test: convert a char from narrow to wide and back. Verify that the result\n //   matches the original.\n bool sanity_test_widen(char testchar)\n-{\n+<%\n     const std::ctype<char>& test(std::use_facet<std::ctype<char> >(std::locale()));\n     return test.narrow(test.widen(testchar), 'b') == testchar;\n-}\n+%>\n \n // trigger: use list::push_back and list::pop_back to trigger _M_hook and\n //   _M_unhook.\n // test: Push a sequence of integers into a list. Pop them off and verify that\n //   they match the original sequence.\n bool sanity_test_list(unsigned int size)\n-{\n+<%\n     std::list<unsigned int> test;\n     for (unsigned int i = 0; i != size; ++i)\n         test.push_back(i + 1);\n \n     if (test.size() != size)\n         return false;\n \n-    while (!test.empty()) {\n+    while (!test.empty()) <%\n         if (test.back() != test.size())\n             return false;\n         test.pop_back();\n-    }\n+    %>\n     return true;\n-}\n+%>\n \n-} // namespace\n+%> // namespace\n \n // trigger: string::at(x) on an empty string to trigger __throw_out_of_range_fmt.\n // test: force std::string to throw an out_of_range exception. Verify that\n //   it's caught correctly.\n bool sanity_test_range_fmt()\n-{\n+<%\n     std::string test;\n-    try {\n+    try <%\n         test.at(1);\n-    } catch (const std::out_of_range&) {\n+    %> catch (const std::out_of_range&) <%\n         return true;\n-    } catch (...) {\n-    }\n+    %> catch (...) <%\n+    %>\n     return false;\n-}\n+%>\n \n bool glibcxx_sanity_test()\n-{\n+<%\n     return sanity_test_widen('a') && sanity_test_list(100) && sanity_test_range_fmt();\n-}\n+%>"
      },
      {
        "sha": "a1168aa8cc47b7b5124b982836bcfad25d678008",
        "filename": "src/compat/strnlen.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/compat/strnlen.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/compat/strnlen.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/strnlen.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -10,9 +10,9 @@\n \n #if HAVE_DECL_STRNLEN == 0\n size_t strnlen( const char *start, size_t max_len)\n-{\n+<%\n     const char *end = (const char *)memchr(start, '\\0', max_len);\n \n     return end ? (size_t)(end - start) : max_len;\n-}\n+%>\n #endif // HAVE_DECL_STRNLEN"
      },
      {
        "sha": "d58724f687bce7fb439d816b5f24b84c8192ad86",
        "filename": "src/compressor.cpp",
        "status": "modified",
        "additions": 46,
        "deletions": 46,
        "changes": 92,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/compressor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/compressor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compressor.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -18,84 +18,84 @@\n  */\n \n static bool IsToKeyID(const CScript& script, CKeyID &hash)\n-{\n+<%\n     if (script.size() == 25 && script[0] == OP_DUP && script[1] == OP_HASH160\n                             && script[2] == 20 && script[23] == OP_EQUALVERIFY\n-                            && script[24] == OP_CHECKSIG) {\n+                            && script[24] == OP_CHECKSIG) <%\n         memcpy(&hash, &script[3], 20);\n         return true;\n-    }\n+    %>\n     return false;\n-}\n+%>\n \n static bool IsToScriptID(const CScript& script, CScriptID &hash)\n-{\n+<%\n     if (script.size() == 23 && script[0] == OP_HASH160 && script[1] == 20\n-                            && script[22] == OP_EQUAL) {\n+                            && script[22] == OP_EQUAL) <%\n         memcpy(&hash, &script[2], 20);\n         return true;\n-    }\n+    %>\n     return false;\n-}\n+%>\n \n static bool IsToPubKey(const CScript& script, CPubKey &pubkey)\n-{\n+<%\n     if (script.size() == 35 && script[0] == 33 && script[34] == OP_CHECKSIG\n-                            && (script[1] == 0x02 || script[1] == 0x03)) {\n+                            && (script[1] == 0x02 || script[1] == 0x03)) <%\n         pubkey.Set(&script[1], &script[34]);\n         return true;\n-    }\n+    %>\n     if (script.size() == 67 && script[0] == 65 && script[66] == OP_CHECKSIG\n-                            && script[1] == 0x04) {\n+                            && script[1] == 0x04) <%\n         pubkey.Set(&script[1], &script[66]);\n         return pubkey.IsFullyValid(); // if not fully valid, a case that would not be compressible\n-    }\n+    %>\n     return false;\n-}\n+%>\n \n bool CompressScript(const CScript& script, std::vector<unsigned char> &out)\n-{\n+<%\n     CKeyID keyID;\n-    if (IsToKeyID(script, keyID)) {\n+    if (IsToKeyID(script, keyID)) <%\n         out.resize(21);\n         out[0] = 0x00;\n         memcpy(&out[1], &keyID, 20);\n         return true;\n-    }\n+    %>\n     CScriptID scriptID;\n-    if (IsToScriptID(script, scriptID)) {\n+    if (IsToScriptID(script, scriptID)) <%\n         out.resize(21);\n         out[0] = 0x01;\n         memcpy(&out[1], &scriptID, 20);\n         return true;\n-    }\n+    %>\n     CPubKey pubkey;\n-    if (IsToPubKey(script, pubkey)) {\n+    if (IsToPubKey(script, pubkey)) <%\n         out.resize(33);\n         memcpy(&out[1], &pubkey[1], 32);\n-        if (pubkey[0] == 0x02 || pubkey[0] == 0x03) {\n+        if (pubkey[0] == 0x02 || pubkey[0] == 0x03) <%\n             out[0] = pubkey[0];\n             return true;\n-        } else if (pubkey[0] == 0x04) {\n+        %> else if (pubkey[0] == 0x04) <%\n             out[0] = 0x04 | (pubkey[64] & 0x01);\n             return true;\n-        }\n-    }\n+        %>\n+    %>\n     return false;\n-}\n+%>\n \n unsigned int GetSpecialScriptSize(unsigned int nSize)\n-{\n+<%\n     if (nSize == 0 || nSize == 1)\n         return 20;\n     if (nSize == 2 || nSize == 3 || nSize == 4 || nSize == 5)\n         return 32;\n     return 0;\n-}\n+%>\n \n bool DecompressScript(CScript& script, unsigned int nSize, const std::vector<unsigned char> &in)\n-{\n-    switch(nSize) {\n+<%\n+    switch(nSize) <%\n     case 0x00:\n         script.resize(25);\n         script[0] = OP_DUP;\n@@ -122,7 +122,7 @@ bool DecompressScript(CScript& script, unsigned int nSize, const std::vector<uns\n         return true;\n     case 0x04:\n     case 0x05:\n-        unsigned char vch[33] = {};\n+        unsigned char vch[33] = <%%>;\n         vch[0] = nSize - 2;\n         memcpy(&vch[1], in.data(), 32);\n         CPubKey pubkey(&vch[0], &vch[33]);\n@@ -134,9 +134,9 @@ bool DecompressScript(CScript& script, unsigned int nSize, const std::vector<uns\n         memcpy(&script[1], pubkey.begin(), 65);\n         script[66] = OP_CHECKSIG;\n         return true;\n-    }\n+    %>\n     return false;\n-}\n+%>\n \n // Amount compression:\n // * If the amount is 0, output 0\n@@ -148,26 +148,26 @@ bool DecompressScript(CScript& script, unsigned int nSize, const std::vector<uns\n // (this is decodable, as d is in [1-9] and e is in [0-9])\n \n uint64_t CompressAmount(uint64_t n)\n-{\n+<%\n     if (n == 0)\n         return 0;\n     int e = 0;\n-    while (((n % 10) == 0) && e < 9) {\n+    while (((n % 10) == 0) && e < 9) <%\n         n /= 10;\n         e++;\n-    }\n-    if (e < 9) {\n+    %>\n+    if (e < 9) <%\n         int d = (n % 10);\n         assert(d >= 1 && d <= 9);\n         n /= 10;\n         return 1 + (n*9 + d - 1)*10 + e;\n-    } else {\n+    %> else <%\n         return 1 + (n - 1)*10 + 9;\n-    }\n-}\n+    %>\n+%>\n \n uint64_t DecompressAmount(uint64_t x)\n-{\n+<%\n     // x = 0  OR  x = 1+10*(9*n + d - 1) + e  OR  x = 1+10*(n - 1) + 9\n     if (x == 0)\n         return 0;\n@@ -176,18 +176,18 @@ uint64_t DecompressAmount(uint64_t x)\n     int e = x % 10;\n     x /= 10;\n     uint64_t n = 0;\n-    if (e < 9) {\n+    if (e < 9) <%\n         // x = 9*n + d - 1\n         int d = (x % 9) + 1;\n         x /= 9;\n         // x = n\n         n = x*10 + d;\n-    } else {\n+    %> else <%\n         n = x+1;\n-    }\n-    while (e) {\n+    %>\n+    while (e) <%\n         n *= 10;\n         e--;\n-    }\n+    %>\n     return n;\n-}\n+%>"
      },
      {
        "sha": "36b004448acbf81deaaad4fc18f81cb2ffe15b6f",
        "filename": "src/compressor.h",
        "status": "modified",
        "additions": 22,
        "deletions": 22,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/compressor.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/compressor.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compressor.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -34,7 +34,7 @@ uint64_t DecompressAmount(uint64_t nAmount);\n  *  that, scripts up to 16505 bytes require 2 bytes + script length.\n  */\n class CScriptCompressor\n-{\n+<%\n private:\n     /**\n      * make this static for now (there are only 6 special scripts defined)\n@@ -46,66 +46,66 @@ class CScriptCompressor\n \n     CScript &script;\n public:\n-    explicit CScriptCompressor(CScript &scriptIn) : script(scriptIn) { }\n+    explicit CScriptCompressor(CScript &scriptIn) : script(scriptIn) <% %>\n \n     template<typename Stream>\n-    void Serialize(Stream &s) const {\n+    void Serialize(Stream &s) const <%\n         std::vector<unsigned char> compr;\n-        if (CompressScript(script, compr)) {\n+        if (CompressScript(script, compr)) <%\n             s << MakeSpan(compr);\n             return;\n-        }\n+        %>\n         unsigned int nSize = script.size() + nSpecialScripts;\n         s << VARINT(nSize);\n         s << MakeSpan(script);\n-    }\n+    %>\n \n     template<typename Stream>\n-    void Unserialize(Stream &s) {\n+    void Unserialize(Stream &s) <%\n         unsigned int nSize = 0;\n         s >> VARINT(nSize);\n-        if (nSize < nSpecialScripts) {\n+        if (nSize < nSpecialScripts) <%\n             std::vector<unsigned char> vch(GetSpecialScriptSize(nSize), 0x00);\n             s >> MakeSpan(vch);\n             DecompressScript(script, nSize, vch);\n             return;\n-        }\n+        %>\n         nSize -= nSpecialScripts;\n-        if (nSize > MAX_SCRIPT_SIZE) {\n+        if (nSize > MAX_SCRIPT_SIZE) <%\n             // Overly long script, replace with a short invalid one\n             script << OP_RETURN;\n             s.ignore(nSize);\n-        } else {\n+        %> else <%\n             script.resize(nSize);\n             s >> MakeSpan(script);\n-        }\n-    }\n-};\n+        %>\n+    %>\n+%>;\n \n /** wrapper for CTxOut that provides a more compact serialization */\n class CTxOutCompressor\n-{\n+<%\n private:\n     CTxOut &txout;\n \n public:\n-    explicit CTxOutCompressor(CTxOut &txoutIn) : txout(txoutIn) { }\n+    explicit CTxOutCompressor(CTxOut &txoutIn) : txout(txoutIn) <% %>\n \n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action) {\n-        if (!ser_action.ForRead()) {\n+    inline void SerializationOp(Stream& s, Operation ser_action) <%\n+        if (!ser_action.ForRead()) <%\n             uint64_t nVal = CompressAmount(txout.nValue);\n             READWRITE(VARINT(nVal));\n-        } else {\n+        %> else <%\n             uint64_t nVal = 0;\n             READWRITE(VARINT(nVal));\n             txout.nValue = DecompressAmount(nVal);\n-        }\n+        %>\n         CScriptCompressor cscript(REF(txout.scriptPubKey));\n         READWRITE(cscript);\n-    }\n-};\n+    %>\n+%>;\n \n #endif // BITCOIN_COMPRESSOR_H"
      },
      {
        "sha": "b7bb66784e591c0991f83b29ebde62968e9a503e",
        "filename": "src/consensus/merkle.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 18,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/consensus/merkle.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/consensus/merkle.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/merkle.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -43,44 +43,44 @@\n */\n \n \n-uint256 ComputeMerkleRoot(std::vector<uint256> hashes, bool* mutated) {\n+uint256 ComputeMerkleRoot(std::vector<uint256> hashes, bool* mutated) <%\n     bool mutation = false;\n-    while (hashes.size() > 1) {\n-        if (mutated) {\n-            for (size_t pos = 0; pos + 1 < hashes.size(); pos += 2) {\n+    while (hashes.size() > 1) <%\n+        if (mutated) <%\n+            for (size_t pos = 0; pos + 1 < hashes.size(); pos += 2) <%\n                 if (hashes[pos] == hashes[pos + 1]) mutation = true;\n-            }\n-        }\n-        if (hashes.size() & 1) {\n+            %>\n+        %>\n+        if (hashes.size() & 1) <%\n             hashes.push_back(hashes.back());\n-        }\n+        %>\n         SHA256D64(hashes[0].begin(), hashes[0].begin(), hashes.size() / 2);\n         hashes.resize(hashes.size() / 2);\n-    }\n+    %>\n     if (mutated) *mutated = mutation;\n     if (hashes.size() == 0) return uint256();\n     return hashes[0];\n-}\n+%>\n \n \n uint256 BlockMerkleRoot(const CBlock& block, bool* mutated)\n-{\n+<%\n     std::vector<uint256> leaves;\n     leaves.resize(block.vtx.size());\n-    for (size_t s = 0; s < block.vtx.size(); s++) {\n+    for (size_t s = 0; s < block.vtx.size(); s++) <%\n         leaves[s] = block.vtx[s]->GetHash();\n-    }\n+    %>\n     return ComputeMerkleRoot(std::move(leaves), mutated);\n-}\n+%>\n \n uint256 BlockWitnessMerkleRoot(const CBlock& block, bool* mutated)\n-{\n+<%\n     std::vector<uint256> leaves;\n     leaves.resize(block.vtx.size());\n     leaves[0].SetNull(); // The witness hash of the coinbase is 0.\n-    for (size_t s = 1; s < block.vtx.size(); s++) {\n+    for (size_t s = 1; s < block.vtx.size(); s++) <%\n         leaves[s] = block.vtx[s]->GetWitnessHash();\n-    }\n+    %>\n     return ComputeMerkleRoot(std::move(leaves), mutated);\n-}\n+%>\n "
      },
      {
        "sha": "cba88b5efc437a8d8a4eb19dfaaa568dfd45df89",
        "filename": "src/consensus/params.h",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/consensus/params.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/consensus/params.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/params.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -11,21 +11,21 @@\n #include <map>\n #include <string>\n \n-namespace Consensus {\n+namespace Consensus <%\n \n enum DeploymentPos\n-{\n+<%\n     DEPLOYMENT_TESTDUMMY,\n     DEPLOYMENT_CSV, // Deployment of BIP68, BIP112, and BIP113.\n     DEPLOYMENT_SEGWIT, // Deployment of BIP141, BIP143, and BIP147.\n     // NOTE: Also add new deployments to VersionBitsDeploymentInfo in versionbits.cpp\n     MAX_VERSION_BITS_DEPLOYMENTS\n-};\n+%>;\n \n /**\n  * Struct for each individual consensus rule change using BIP9.\n  */\n-struct BIP9Deployment {\n+struct BIP9Deployment <%\n     /** Bit position to select the particular bit in nVersion. */\n     int bit;\n     /** Start MedianTime for version bits miner confirmation. Can be a date in the past */\n@@ -41,12 +41,12 @@ struct BIP9Deployment {\n      *  process (which takes at least 3 BIP9 intervals). Only tests that specifically test the\n      *  behaviour during activation cannot use this. */\n     static constexpr int64_t ALWAYS_ACTIVE = -1;\n-};\n+%>;\n \n /**\n  * Parameters that influence chain consensus.\n  */\n-struct Params {\n+struct Params <%\n     uint256 hashGenesisBlock;\n     int nSubsidyHalvingInterval;\n     /* Block hash that is excepted from BIP16 enforcement */\n@@ -72,10 +72,10 @@ struct Params {\n     bool fPowNoRetargeting;\n     int64_t nPowTargetSpacing;\n     int64_t nPowTargetTimespan;\n-    int64_t DifficultyAdjustmentInterval() const { return nPowTargetTimespan / nPowTargetSpacing; }\n+    int64_t DifficultyAdjustmentInterval() const <% return nPowTargetTimespan / nPowTargetSpacing; %>\n     uint256 nMinimumChainWork;\n     uint256 defaultAssumeValid;\n-};\n-} // namespace Consensus\n+%>;\n+%> // namespace Consensus\n \n #endif // BITCOIN_CONSENSUS_PARAMS_H"
      },
      {
        "sha": "c18c1cc34ddd0883a92d2f8e88e40e094d078e28",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 61,
        "deletions": 61,
        "changes": 122,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -15,20 +15,20 @@\n #include <util/moneystr.h>\n \n bool IsFinalTx(const CTransaction &tx, int nBlockHeight, int64_t nBlockTime)\n-{\n+<%\n     if (tx.nLockTime == 0)\n         return true;\n     if ((int64_t)tx.nLockTime < ((int64_t)tx.nLockTime < LOCKTIME_THRESHOLD ? (int64_t)nBlockHeight : nBlockTime))\n         return true;\n-    for (const auto& txin : tx.vin) {\n+    for (const auto& txin : tx.vin) <%\n         if (!(txin.nSequence == CTxIn::SEQUENCE_FINAL))\n             return false;\n-    }\n+    %>\n     return true;\n-}\n+%>\n \n std::pair<int, int64_t> CalculateSequenceLocks(const CTransaction &tx, int flags, std::vector<int>* prevHeights, const CBlockIndex& block)\n-{\n+<%\n     assert(prevHeights->size() == tx.vin.size());\n \n     // Will be set to the equivalent height- and time-based nLockTime\n@@ -47,25 +47,25 @@ std::pair<int, int64_t> CalculateSequenceLocks(const CTransaction &tx, int flags\n \n     // Do not enforce sequence numbers as a relative lock time\n     // unless we have been instructed to\n-    if (!fEnforceBIP68) {\n+    if (!fEnforceBIP68) <%\n         return std::make_pair(nMinHeight, nMinTime);\n-    }\n+    %>\n \n-    for (size_t txinIndex = 0; txinIndex < tx.vin.size(); txinIndex++) {\n+    for (size_t txinIndex = 0; txinIndex < tx.vin.size(); txinIndex++) <%\n         const CTxIn& txin = tx.vin[txinIndex];\n \n         // Sequence numbers with the most significant bit set are not\n         // treated as relative lock-times, nor are they given any\n         // consensus-enforced meaning at this point.\n-        if (txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_DISABLE_FLAG) {\n+        if (txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_DISABLE_FLAG) <%\n             // The height of this input is not relevant for sequence locks\n             (*prevHeights)[txinIndex] = 0;\n             continue;\n-        }\n+        %>\n \n         int nCoinHeight = (*prevHeights)[txinIndex];\n \n-        if (txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG) {\n+        if (txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG) <%\n             int64_t nCoinTime = block.GetAncestor(std::max(nCoinHeight-1, 0))->GetMedianTimePast();\n             // NOTE: Subtract 1 to maintain nLockTime semantics\n             // BIP 68 relative lock times have the semantics of calculating\n@@ -81,83 +81,83 @@ std::pair<int, int64_t> CalculateSequenceLocks(const CTransaction &tx, int flags\n             // txout being spent, which is the median time past of the\n             // block prior.\n             nMinTime = std::max(nMinTime, nCoinTime + (int64_t)((txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_MASK) << CTxIn::SEQUENCE_LOCKTIME_GRANULARITY) - 1);\n-        } else {\n+        %> else <%\n             nMinHeight = std::max(nMinHeight, nCoinHeight + (int)(txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_MASK) - 1);\n-        }\n-    }\n+        %>\n+    %>\n \n     return std::make_pair(nMinHeight, nMinTime);\n-}\n+%>\n \n bool EvaluateSequenceLocks(const CBlockIndex& block, std::pair<int, int64_t> lockPair)\n-{\n+<%\n     assert(block.pprev);\n     int64_t nBlockTime = block.pprev->GetMedianTimePast();\n     if (lockPair.first >= block.nHeight || lockPair.second >= nBlockTime)\n         return false;\n \n     return true;\n-}\n+%>\n \n bool SequenceLocks(const CTransaction &tx, int flags, std::vector<int>* prevHeights, const CBlockIndex& block)\n-{\n+<%\n     return EvaluateSequenceLocks(block, CalculateSequenceLocks(tx, flags, prevHeights, block));\n-}\n+%>\n \n unsigned int GetLegacySigOpCount(const CTransaction& tx)\n-{\n+<%\n     unsigned int nSigOps = 0;\n     for (const auto& txin : tx.vin)\n-    {\n+    <%\n         nSigOps += txin.scriptSig.GetSigOpCount(false);\n-    }\n+    %>\n     for (const auto& txout : tx.vout)\n-    {\n+    <%\n         nSigOps += txout.scriptPubKey.GetSigOpCount(false);\n-    }\n+    %>\n     return nSigOps;\n-}\n+%>\n \n unsigned int GetP2SHSigOpCount(const CTransaction& tx, const CCoinsViewCache& inputs)\n-{\n+<%\n     if (tx.IsCoinBase())\n         return 0;\n \n     unsigned int nSigOps = 0;\n     for (unsigned int i = 0; i < tx.vin.size(); i++)\n-    {\n+    <%\n         const Coin& coin = inputs.AccessCoin(tx.vin[i].prevout);\n         assert(!coin.IsSpent());\n         const CTxOut &prevout = coin.out;\n         if (prevout.scriptPubKey.IsPayToScriptHash())\n             nSigOps += prevout.scriptPubKey.GetSigOpCount(tx.vin[i].scriptSig);\n-    }\n+    %>\n     return nSigOps;\n-}\n+%>\n \n int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& inputs, int flags)\n-{\n+<%\n     int64_t nSigOps = GetLegacySigOpCount(tx) * WITNESS_SCALE_FACTOR;\n \n     if (tx.IsCoinBase())\n         return nSigOps;\n \n-    if (flags & SCRIPT_VERIFY_P2SH) {\n+    if (flags & SCRIPT_VERIFY_P2SH) <%\n         nSigOps += GetP2SHSigOpCount(tx, inputs) * WITNESS_SCALE_FACTOR;\n-    }\n+    %>\n \n     for (unsigned int i = 0; i < tx.vin.size(); i++)\n-    {\n+    <%\n         const Coin& coin = inputs.AccessCoin(tx.vin[i].prevout);\n         assert(!coin.IsSpent());\n         const CTxOut &prevout = coin.out;\n         nSigOps += CountWitnessSigOps(tx.vin[i].scriptSig, prevout.scriptPubKey, &tx.vin[i].scriptWitness, flags);\n-    }\n+    %>\n     return nSigOps;\n-}\n+%>\n \n bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fCheckDuplicateInputs)\n-{\n+<%\n     // Basic checks that don't depend on any context\n     if (tx.vin.empty())\n         return state.DoS(10, false, REJECT_INVALID, \"bad-txns-vin-empty\");\n@@ -170,81 +170,81 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n     // Check for negative or overflow output values\n     CAmount nValueOut = 0;\n     for (const auto& txout : tx.vout)\n-    {\n+    <%\n         if (txout.nValue < 0)\n             return state.DoS(100, false, REJECT_INVALID, \"bad-txns-vout-negative\");\n         if (txout.nValue > MAX_MONEY)\n             return state.DoS(100, false, REJECT_INVALID, \"bad-txns-vout-toolarge\");\n         nValueOut += txout.nValue;\n         if (!MoneyRange(nValueOut))\n             return state.DoS(100, false, REJECT_INVALID, \"bad-txns-txouttotal-toolarge\");\n-    }\n+    %>\n \n     // Check for duplicate inputs - note that this check is slow so we skip it in CheckBlock\n-    if (fCheckDuplicateInputs) {\n+    if (fCheckDuplicateInputs) <%\n         std::set<COutPoint> vInOutPoints;\n         for (const auto& txin : tx.vin)\n-        {\n+        <%\n             if (!vInOutPoints.insert(txin.prevout).second)\n                 return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n-        }\n-    }\n+        %>\n+    %>\n \n     if (tx.IsCoinBase())\n-    {\n+    <%\n         if (tx.vin[0].scriptSig.size() < 2 || tx.vin[0].scriptSig.size() > 100)\n             return state.DoS(100, false, REJECT_INVALID, \"bad-cb-length\");\n-    }\n+    %>\n     else\n-    {\n+    <%\n         for (const auto& txin : tx.vin)\n             if (txin.prevout.IsNull())\n                 return state.DoS(10, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n-    }\n+    %>\n \n     return true;\n-}\n+%>\n \n bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, const CCoinsViewCache& inputs, int nSpendHeight, CAmount& txfee)\n-{\n+<%\n     // are the actual inputs available?\n-    if (!inputs.HaveInputs(tx)) {\n+    if (!inputs.HaveInputs(tx)) <%\n         return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-missingorspent\", false,\n                          strprintf(\"%s: inputs missing/spent\", __func__));\n-    }\n+    %>\n \n     CAmount nValueIn = 0;\n-    for (unsigned int i = 0; i < tx.vin.size(); ++i) {\n+    for (unsigned int i = 0; i < tx.vin.size(); ++i) <%\n         const COutPoint &prevout = tx.vin[i].prevout;\n         const Coin& coin = inputs.AccessCoin(prevout);\n         assert(!coin.IsSpent());\n \n         // If prev is coinbase, check that it's matured\n-        if (coin.IsCoinBase() && nSpendHeight - coin.nHeight < COINBASE_MATURITY) {\n+        if (coin.IsCoinBase() && nSpendHeight - coin.nHeight < COINBASE_MATURITY) <%\n             return state.Invalid(false,\n                 REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\",\n                 strprintf(\"tried to spend coinbase at depth %d\", nSpendHeight - coin.nHeight));\n-        }\n+        %>\n \n         // Check for negative or overflow input values\n         nValueIn += coin.out.nValue;\n-        if (!MoneyRange(coin.out.nValue) || !MoneyRange(nValueIn)) {\n+        if (!MoneyRange(coin.out.nValue) || !MoneyRange(nValueIn)) <%\n             return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputvalues-outofrange\");\n-        }\n-    }\n+        %>\n+    %>\n \n     const CAmount value_out = tx.GetValueOut();\n-    if (nValueIn < value_out) {\n+    if (nValueIn < value_out) <%\n         return state.DoS(100, false, REJECT_INVALID, \"bad-txns-in-belowout\", false,\n             strprintf(\"value in (%s) < value out (%s)\", FormatMoney(nValueIn), FormatMoney(value_out)));\n-    }\n+    %>\n \n     // Tally transaction fees\n     const CAmount txfee_aux = nValueIn - value_out;\n-    if (!MoneyRange(txfee_aux)) {\n+    if (!MoneyRange(txfee_aux)) <%\n         return state.DoS(100, false, REJECT_INVALID, \"bad-txns-fee-outofrange\");\n-    }\n+    %>\n \n     txfee = txfee_aux;\n     return true;\n-}\n+%>"
      },
      {
        "sha": "d9db32ee6dc12f4068173479f83b3cc41bb5083d",
        "filename": "src/consensus/tx_verify.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/consensus/tx_verify.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/consensus/tx_verify.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -20,15 +20,15 @@ class CValidationState;\n /** Context-independent validity checks */\n bool CheckTransaction(const CTransaction& tx, CValidationState& state, bool fCheckDuplicateInputs=true);\n \n-namespace Consensus {\n+namespace Consensus <%\n /**\n  * Check whether all inputs of this transaction are valid (no double spends and amounts)\n  * This does not modify the UTXO set. This does not check scripts and sigs.\n  * @param[out] txfee Set to the transaction fee if successful.\n  * Preconditions: tx.IsCoinBase() is false.\n  */\n bool CheckTxInputs(const CTransaction& tx, CValidationState& state, const CCoinsViewCache& inputs, int nSpendHeight, CAmount& txfee);\n-} // namespace Consensus\n+%> // namespace Consensus\n \n /** Auxiliary functions for transaction validation (ideally should not be exposed) */\n "
      },
      {
        "sha": "1bcef6f85f5a56b13326f213986a4a6a9f8cb0d3",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 34,
        "deletions": 34,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -23,24 +23,24 @@ static const unsigned char REJECT_INSUFFICIENTFEE = 0x42;\n static const unsigned char REJECT_CHECKPOINT = 0x43;\n \n /** Capture information about block/transaction validation */\n-class CValidationState {\n+class CValidationState <%\n private:\n-    enum mode_state {\n+    enum mode_state <%\n         MODE_VALID,   //!< everything ok\n         MODE_INVALID, //!< network rule violation (DoS value may be set)\n         MODE_ERROR,   //!< run-time error\n-    } mode;\n+    %> mode;\n     int nDoS;\n     std::string strRejectReason;\n     unsigned int chRejectCode;\n     bool corruptionPossible;\n     std::string strDebugMessage;\n public:\n-    CValidationState() : mode(MODE_VALID), nDoS(0), chRejectCode(0), corruptionPossible(false) {}\n+    CValidationState() : mode(MODE_VALID), nDoS(0), chRejectCode(0), corruptionPossible(false) <%%>\n     bool DoS(int level, bool ret = false,\n              unsigned int chRejectCodeIn=0, const std::string &strRejectReasonIn=\"\",\n              bool corruptionIn=false,\n-             const std::string &strDebugMessageIn=\"\") {\n+             const std::string &strDebugMessageIn=\"\") <%\n         chRejectCode = chRejectCodeIn;\n         strRejectReason = strRejectReasonIn;\n         corruptionPossible = corruptionIn;\n@@ -50,61 +50,61 @@ class CValidationState {\n         nDoS += level;\n         mode = MODE_INVALID;\n         return ret;\n-    }\n+    %>\n     bool Invalid(bool ret = false,\n                  unsigned int _chRejectCode=0, const std::string &_strRejectReason=\"\",\n-                 const std::string &_strDebugMessage=\"\") {\n+                 const std::string &_strDebugMessage=\"\") <%\n         return DoS(0, ret, _chRejectCode, _strRejectReason, false, _strDebugMessage);\n-    }\n-    bool Error(const std::string& strRejectReasonIn) {\n+    %>\n+    bool Error(const std::string& strRejectReasonIn) <%\n         if (mode == MODE_VALID)\n             strRejectReason = strRejectReasonIn;\n         mode = MODE_ERROR;\n         return false;\n-    }\n-    bool IsValid() const {\n+    %>\n+    bool IsValid() const <%\n         return mode == MODE_VALID;\n-    }\n-    bool IsInvalid() const {\n+    %>\n+    bool IsInvalid() const <%\n         return mode == MODE_INVALID;\n-    }\n-    bool IsError() const {\n+    %>\n+    bool IsError() const <%\n         return mode == MODE_ERROR;\n-    }\n-    bool IsInvalid(int &nDoSOut) const {\n-        if (IsInvalid()) {\n+    %>\n+    bool IsInvalid(int &nDoSOut) const <%\n+        if (IsInvalid()) <%\n             nDoSOut = nDoS;\n             return true;\n-        }\n+        %>\n         return false;\n-    }\n-    bool CorruptionPossible() const {\n+    %>\n+    bool CorruptionPossible() const <%\n         return corruptionPossible;\n-    }\n-    void SetCorruptionPossible() {\n+    %>\n+    void SetCorruptionPossible() <%\n         corruptionPossible = true;\n-    }\n-    unsigned int GetRejectCode() const { return chRejectCode; }\n-    std::string GetRejectReason() const { return strRejectReason; }\n-    std::string GetDebugMessage() const { return strDebugMessage; }\n-};\n+    %>\n+    unsigned int GetRejectCode() const <% return chRejectCode; %>\n+    std::string GetRejectReason() const <% return strRejectReason; %>\n+    std::string GetDebugMessage() const <% return strDebugMessage; %>\n+%>;\n \n // These implement the weight = (stripped_size * 4) + witness_size formula,\n // using only serialization with and without witness data. As witness_size\n // is equal to total_size - stripped_size, this formula is identical to:\n // weight = (stripped_size * 3) + total_size.\n static inline int64_t GetTransactionWeight(const CTransaction& tx)\n-{\n+<%\n     return ::GetSerializeSize(tx, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(tx, PROTOCOL_VERSION);\n-}\n+%>\n static inline int64_t GetBlockWeight(const CBlock& block)\n-{\n+<%\n     return ::GetSerializeSize(block, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(block, PROTOCOL_VERSION);\n-}\n+%>\n static inline int64_t GetTransactionInputWeight(const CTxIn& txin)\n-{\n+<%\n     // scriptWitness size is added here because witnesses and txins are split up in segwit serialization.\n     return ::GetSerializeSize(txin, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(txin, PROTOCOL_VERSION) + ::GetSerializeSize(txin.scriptWitness.stack, PROTOCOL_VERSION);\n-}\n+%>\n \n #endif // BITCOIN_CONSENSUS_VALIDATION_H"
      },
      {
        "sha": "a0ee6754806463e86bc2f6b83fc0d5993b159292",
        "filename": "src/core_memusage.h",
        "status": "modified",
        "additions": 30,
        "deletions": 30,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/core_memusage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/core_memusage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_memusage.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -9,63 +9,63 @@\n #include <primitives/block.h>\n #include <memusage.h>\n \n-static inline size_t RecursiveDynamicUsage(const CScript& script) {\n+static inline size_t RecursiveDynamicUsage(const CScript& script) <%\n     return memusage::DynamicUsage(script);\n-}\n+%>\n \n-static inline size_t RecursiveDynamicUsage(const COutPoint& out) {\n+static inline size_t RecursiveDynamicUsage(const COutPoint& out) <%\n     return 0;\n-}\n+%>\n \n-static inline size_t RecursiveDynamicUsage(const CTxIn& in) {\n+static inline size_t RecursiveDynamicUsage(const CTxIn& in) <%\n     size_t mem = RecursiveDynamicUsage(in.scriptSig) + RecursiveDynamicUsage(in.prevout) + memusage::DynamicUsage(in.scriptWitness.stack);\n-    for (std::vector<std::vector<unsigned char> >::const_iterator it = in.scriptWitness.stack.begin(); it != in.scriptWitness.stack.end(); it++) {\n+    for (std::vector<std::vector<unsigned char> >::const_iterator it = in.scriptWitness.stack.begin(); it != in.scriptWitness.stack.end(); it++) <%\n          mem += memusage::DynamicUsage(*it);\n-    }\n+    %>\n     return mem;\n-}\n+%>\n \n-static inline size_t RecursiveDynamicUsage(const CTxOut& out) {\n+static inline size_t RecursiveDynamicUsage(const CTxOut& out) <%\n     return RecursiveDynamicUsage(out.scriptPubKey);\n-}\n+%>\n \n-static inline size_t RecursiveDynamicUsage(const CTransaction& tx) {\n+static inline size_t RecursiveDynamicUsage(const CTransaction& tx) <%\n     size_t mem = memusage::DynamicUsage(tx.vin) + memusage::DynamicUsage(tx.vout);\n-    for (std::vector<CTxIn>::const_iterator it = tx.vin.begin(); it != tx.vin.end(); it++) {\n+    for (std::vector<CTxIn>::const_iterator it = tx.vin.begin(); it != tx.vin.end(); it++) <%\n         mem += RecursiveDynamicUsage(*it);\n-    }\n-    for (std::vector<CTxOut>::const_iterator it = tx.vout.begin(); it != tx.vout.end(); it++) {\n+    %>\n+    for (std::vector<CTxOut>::const_iterator it = tx.vout.begin(); it != tx.vout.end(); it++) <%\n         mem += RecursiveDynamicUsage(*it);\n-    }\n+    %>\n     return mem;\n-}\n+%>\n \n-static inline size_t RecursiveDynamicUsage(const CMutableTransaction& tx) {\n+static inline size_t RecursiveDynamicUsage(const CMutableTransaction& tx) <%\n     size_t mem = memusage::DynamicUsage(tx.vin) + memusage::DynamicUsage(tx.vout);\n-    for (std::vector<CTxIn>::const_iterator it = tx.vin.begin(); it != tx.vin.end(); it++) {\n+    for (std::vector<CTxIn>::const_iterator it = tx.vin.begin(); it != tx.vin.end(); it++) <%\n         mem += RecursiveDynamicUsage(*it);\n-    }\n-    for (std::vector<CTxOut>::const_iterator it = tx.vout.begin(); it != tx.vout.end(); it++) {\n+    %>\n+    for (std::vector<CTxOut>::const_iterator it = tx.vout.begin(); it != tx.vout.end(); it++) <%\n         mem += RecursiveDynamicUsage(*it);\n-    }\n+    %>\n     return mem;\n-}\n+%>\n \n-static inline size_t RecursiveDynamicUsage(const CBlock& block) {\n+static inline size_t RecursiveDynamicUsage(const CBlock& block) <%\n     size_t mem = memusage::DynamicUsage(block.vtx);\n-    for (const auto& tx : block.vtx) {\n+    for (const auto& tx : block.vtx) <%\n         mem += memusage::DynamicUsage(tx) + RecursiveDynamicUsage(*tx);\n-    }\n+    %>\n     return mem;\n-}\n+%>\n \n-static inline size_t RecursiveDynamicUsage(const CBlockLocator& locator) {\n+static inline size_t RecursiveDynamicUsage(const CBlockLocator& locator) <%\n     return memusage::DynamicUsage(locator.vHave);\n-}\n+%>\n \n template<typename X>\n-static inline size_t RecursiveDynamicUsage(const std::shared_ptr<X>& p) {\n+static inline size_t RecursiveDynamicUsage(const std::shared_ptr<X>& p) <%\n     return p ? memusage::DynamicUsage(p) + RecursiveDynamicUsage(*p) : 0;\n-}\n+%>\n \n #endif // BITCOIN_CORE_MEMUSAGE_H"
      },
      {
        "sha": "6f147668ece3e9162c5294dfed7688ec48ed5ea1",
        "filename": "src/core_read.cpp",
        "status": "modified",
        "additions": 92,
        "deletions": 92,
        "changes": 184,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/core_read.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/core_read.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_read.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -23,15 +23,15 @@\n #include <algorithm>\n \n CScript ParseScript(const std::string& s)\n-{\n+<%\n     CScript result;\n \n     static std::map<std::string, opcodetype> mapOpNames;\n \n     if (mapOpNames.empty())\n-    {\n+    <%\n         for (unsigned int op = 0; op <= MAX_OPCODE; op++)\n-        {\n+        <%\n             // Allow OP_RESERVED to get into mapOpNames\n             if (op < OP_NOP && op != OP_RESERVED)\n                 continue;\n@@ -44,204 +44,204 @@ CScript ParseScript(const std::string& s)\n             // Convenience: OP_ADD and just ADD are both recognized:\n             boost::algorithm::replace_first(strName, \"OP_\", \"\");\n             mapOpNames[strName] = static_cast<opcodetype>(op);\n-        }\n-    }\n+        %>\n+    %>\n \n     std::vector<std::string> words;\n     boost::algorithm::split(words, s, boost::algorithm::is_any_of(\" \\t\\n\"), boost::algorithm::token_compress_on);\n \n     for (std::vector<std::string>::const_iterator w = words.begin(); w != words.end(); ++w)\n-    {\n+    <%\n         if (w->empty())\n-        {\n+        <%\n             // Empty string, ignore. (boost::split given '' will return one word)\n-        }\n+        %>\n         else if (std::all_of(w->begin(), w->end(), ::IsDigit) ||\n             (w->front() == '-' && w->size() > 1 && std::all_of(w->begin()+1, w->end(), ::IsDigit)))\n-        {\n+        <%\n             // Number\n             int64_t n = atoi64(*w);\n             result << n;\n-        }\n+        %>\n         else if (w->substr(0,2) == \"0x\" && w->size() > 2 && IsHex(std::string(w->begin()+2, w->end())))\n-        {\n+        <%\n             // Raw hex data, inserted NOT pushed onto stack:\n             std::vector<unsigned char> raw = ParseHex(std::string(w->begin()+2, w->end()));\n             result.insert(result.end(), raw.begin(), raw.end());\n-        }\n+        %>\n         else if (w->size() >= 2 && w->front() == '\\'' && w->back() == '\\'')\n-        {\n+        <%\n             // Single-quoted string, pushed as data. NOTE: this is poor-man's\n             // parsing, spaces/tabs/newlines in single-quoted strings won't work.\n             std::vector<unsigned char> value(w->begin()+1, w->end()-1);\n             result << value;\n-        }\n+        %>\n         else if (mapOpNames.count(*w))\n-        {\n+        <%\n             // opcode, e.g. OP_ADD or ADD:\n             result << mapOpNames[*w];\n-        }\n+        %>\n         else\n-        {\n+        <%\n             throw std::runtime_error(\"script parse error\");\n-        }\n-    }\n+        %>\n+    %>\n \n     return result;\n-}\n+%>\n \n // Check that all of the input and output scripts of a transaction contains valid opcodes\n static bool CheckTxScriptsSanity(const CMutableTransaction& tx)\n-{\n+<%\n     // Check input scripts for non-coinbase txs\n-    if (!CTransaction(tx).IsCoinBase()) {\n-        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n-            if (!tx.vin[i].scriptSig.HasValidOps() || tx.vin[i].scriptSig.size() > MAX_SCRIPT_SIZE) {\n+    if (!CTransaction(tx).IsCoinBase()) <%\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) <%\n+            if (!tx.vin[i].scriptSig.HasValidOps() || tx.vin[i].scriptSig.size() > MAX_SCRIPT_SIZE) <%\n                 return false;\n-            }\n-        }\n-    }\n+            %>\n+        %>\n+    %>\n     // Check output scripts\n-    for (unsigned int i = 0; i < tx.vout.size(); i++) {\n-        if (!tx.vout[i].scriptPubKey.HasValidOps() || tx.vout[i].scriptPubKey.size() > MAX_SCRIPT_SIZE) {\n+    for (unsigned int i = 0; i < tx.vout.size(); i++) <%\n+        if (!tx.vout[i].scriptPubKey.HasValidOps() || tx.vout[i].scriptPubKey.size() > MAX_SCRIPT_SIZE) <%\n             return false;\n-        }\n-    }\n+        %>\n+    %>\n \n     return true;\n-}\n+%>\n \n bool DecodeHexTx(CMutableTransaction& tx, const std::string& hex_tx, bool try_no_witness, bool try_witness)\n-{\n-    if (!IsHex(hex_tx)) {\n+<%\n+    if (!IsHex(hex_tx)) <%\n         return false;\n-    }\n+    %>\n \n     std::vector<unsigned char> txData(ParseHex(hex_tx));\n \n-    if (try_no_witness) {\n+    if (try_no_witness) <%\n         CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS);\n-        try {\n+        try <%\n             ssData >> tx;\n-            if (ssData.eof() && (!try_witness || CheckTxScriptsSanity(tx))) {\n+            if (ssData.eof() && (!try_witness || CheckTxScriptsSanity(tx))) <%\n                 return true;\n-            }\n-        } catch (const std::exception&) {\n+            %>\n+        %> catch (const std::exception&) <%\n             // Fall through.\n-        }\n-    }\n+        %>\n+    %>\n \n-    if (try_witness) {\n+    if (try_witness) <%\n         CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n-        try {\n+        try <%\n             ssData >> tx;\n-            if (ssData.empty()) {\n+            if (ssData.empty()) <%\n                 return true;\n-            }\n-        } catch (const std::exception&) {\n+            %>\n+        %> catch (const std::exception&) <%\n             // Fall through.\n-        }\n-    }\n+        %>\n+    %>\n \n     return false;\n-}\n+%>\n \n bool DecodeHexBlockHeader(CBlockHeader& header, const std::string& hex_header)\n-{\n+<%\n     if (!IsHex(hex_header)) return false;\n \n-    const std::vector<unsigned char> header_data{ParseHex(hex_header)};\n+    const std::vector<unsigned char> header_data<%ParseHex(hex_header)%>;\n     CDataStream ser_header(header_data, SER_NETWORK, PROTOCOL_VERSION);\n-    try {\n+    try <%\n         ser_header >> header;\n-    } catch (const std::exception&) {\n+    %> catch (const std::exception&) <%\n         return false;\n-    }\n+    %>\n     return true;\n-}\n+%>\n \n bool DecodeHexBlk(CBlock& block, const std::string& strHexBlk)\n-{\n+<%\n     if (!IsHex(strHexBlk))\n         return false;\n \n     std::vector<unsigned char> blockData(ParseHex(strHexBlk));\n     CDataStream ssBlock(blockData, SER_NETWORK, PROTOCOL_VERSION);\n-    try {\n+    try <%\n         ssBlock >> block;\n-    }\n-    catch (const std::exception&) {\n+    %>\n+    catch (const std::exception&) <%\n         return false;\n-    }\n+    %>\n \n     return true;\n-}\n+%>\n \n bool DecodeBase64PSBT(PartiallySignedTransaction& psbt, const std::string& base64_tx, std::string& error)\n-{\n+<%\n     bool invalid;\n     std::string tx_data = DecodeBase64(base64_tx, &invalid);\n-    if (invalid) {\n+    if (invalid) <%\n         error = \"invalid base64\";\n         return false;\n-    }\n+    %>\n     return DecodeRawPSBT(psbt, tx_data, error);\n-}\n+%>\n \n bool DecodeRawPSBT(PartiallySignedTransaction& psbt, const std::string& tx_data, std::string& error)\n-{\n+<%\n     CDataStream ss_data(tx_data.data(), tx_data.data() + tx_data.size(), SER_NETWORK, PROTOCOL_VERSION);\n-    try {\n+    try <%\n         ss_data >> psbt;\n-        if (!ss_data.empty()) {\n+        if (!ss_data.empty()) <%\n             error = \"extra data after PSBT\";\n             return false;\n-        }\n-    } catch (const std::exception& e) {\n+        %>\n+    %> catch (const std::exception& e) <%\n         error = e.what();\n         return false;\n-    }\n+    %>\n     return true;\n-}\n+%>\n \n bool ParseHashStr(const std::string& strHex, uint256& result)\n-{\n+<%\n     if ((strHex.size() != 64) || !IsHex(strHex))\n         return false;\n \n     result.SetHex(strHex);\n     return true;\n-}\n+%>\n \n std::vector<unsigned char> ParseHexUV(const UniValue& v, const std::string& strName)\n-{\n+<%\n     std::string strHex;\n     if (v.isStr())\n         strHex = v.getValStr();\n     if (!IsHex(strHex))\n         throw std::runtime_error(strName + \" must be hexadecimal string (not '\" + strHex + \"')\");\n     return ParseHex(strHex);\n-}\n+%>\n \n int ParseSighashString(const UniValue& sighash)\n-{\n+<%\n     int hash_type = SIGHASH_ALL;\n-    if (!sighash.isNull()) {\n-        static std::map<std::string, int> map_sighash_values = {\n-            {std::string(\"ALL\"), int(SIGHASH_ALL)},\n-            {std::string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY)},\n-            {std::string(\"NONE\"), int(SIGHASH_NONE)},\n-            {std::string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY)},\n-            {std::string(\"SINGLE\"), int(SIGHASH_SINGLE)},\n-            {std::string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY)},\n-        };\n+    if (!sighash.isNull()) <%\n+        static std::map<std::string, int> map_sighash_values = <%\n+            <%std::string(\"ALL\"), int(SIGHASH_ALL)%>,\n+            <%std::string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY)%>,\n+            <%std::string(\"NONE\"), int(SIGHASH_NONE)%>,\n+            <%std::string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY)%>,\n+            <%std::string(\"SINGLE\"), int(SIGHASH_SINGLE)%>,\n+            <%std::string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY)%>,\n+        %>;\n         std::string strHashType = sighash.get_str();\n         const auto& it = map_sighash_values.find(strHashType);\n-        if (it != map_sighash_values.end()) {\n+        if (it != map_sighash_values.end()) <%\n             hash_type = it->second;\n-        } else {\n+        %> else <%\n             throw std::runtime_error(strHashType + \" is not a valid sighash parameter.\");\n-        }\n-    }\n+        %>\n+    %>\n     return hash_type;\n-}\n+%>"
      },
      {
        "sha": "d53ea388640f27aec2aa39f4a6120c81c0ad9346",
        "filename": "src/core_write.cpp",
        "status": "modified",
        "additions": 74,
        "deletions": 74,
        "changes": 148,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/core_write.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/core_write.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_write.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -17,65 +17,65 @@\n #include <util/strencodings.h>\n \n UniValue ValueFromAmount(const CAmount& amount)\n-{\n+<%\n     bool sign = amount < 0;\n     int64_t n_abs = (sign ? -amount : amount);\n     int64_t quotient = n_abs / COIN;\n     int64_t remainder = n_abs % COIN;\n     return UniValue(UniValue::VNUM,\n             strprintf(\"%s%d.%08d\", sign ? \"-\" : \"\", quotient, remainder));\n-}\n+%>\n \n std::string FormatScript(const CScript& script)\n-{\n+<%\n     std::string ret;\n     CScript::const_iterator it = script.begin();\n     opcodetype op;\n-    while (it != script.end()) {\n+    while (it != script.end()) <%\n         CScript::const_iterator it2 = it;\n         std::vector<unsigned char> vch;\n-        if (script.GetOp(it, op, vch)) {\n-            if (op == OP_0) {\n+        if (script.GetOp(it, op, vch)) <%\n+            if (op == OP_0) <%\n                 ret += \"0 \";\n                 continue;\n-            } else if ((op >= OP_1 && op <= OP_16) || op == OP_1NEGATE) {\n+            %> else if ((op >= OP_1 && op <= OP_16) || op == OP_1NEGATE) <%\n                 ret += strprintf(\"%i \", op - OP_1NEGATE - 1);\n                 continue;\n-            } else if (op >= OP_NOP && op <= OP_NOP10) {\n+            %> else if (op >= OP_NOP && op <= OP_NOP10) <%\n                 std::string str(GetOpName(op));\n-                if (str.substr(0, 3) == std::string(\"OP_\")) {\n+                if (str.substr(0, 3) == std::string(\"OP_\")) <%\n                     ret += str.substr(3, std::string::npos) + \" \";\n                     continue;\n-                }\n-            }\n-            if (vch.size() > 0) {\n+                %>\n+            %>\n+            if (vch.size() > 0) <%\n                 ret += strprintf(\"0x%x 0x%x \", HexStr(it2, it - vch.size()), HexStr(it - vch.size(), it));\n-            } else {\n+            %> else <%\n                 ret += strprintf(\"0x%x \", HexStr(it2, it));\n-            }\n+            %>\n             continue;\n-        }\n+        %>\n         ret += strprintf(\"0x%x \", HexStr(it2, script.end()));\n         break;\n-    }\n+    %>\n     return ret.substr(0, ret.size() - 1);\n-}\n+%>\n \n-const std::map<unsigned char, std::string> mapSigHashTypes = {\n-    {static_cast<unsigned char>(SIGHASH_ALL), std::string(\"ALL\")},\n-    {static_cast<unsigned char>(SIGHASH_ALL|SIGHASH_ANYONECANPAY), std::string(\"ALL|ANYONECANPAY\")},\n-    {static_cast<unsigned char>(SIGHASH_NONE), std::string(\"NONE\")},\n-    {static_cast<unsigned char>(SIGHASH_NONE|SIGHASH_ANYONECANPAY), std::string(\"NONE|ANYONECANPAY\")},\n-    {static_cast<unsigned char>(SIGHASH_SINGLE), std::string(\"SINGLE\")},\n-    {static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY), std::string(\"SINGLE|ANYONECANPAY\")},\n-};\n+const std::map<unsigned char, std::string> mapSigHashTypes = <%\n+    <%static_cast<unsigned char>(SIGHASH_ALL), std::string(\"ALL\")%>,\n+    <%static_cast<unsigned char>(SIGHASH_ALL|SIGHASH_ANYONECANPAY), std::string(\"ALL|ANYONECANPAY\")%>,\n+    <%static_cast<unsigned char>(SIGHASH_NONE), std::string(\"NONE\")%>,\n+    <%static_cast<unsigned char>(SIGHASH_NONE|SIGHASH_ANYONECANPAY), std::string(\"NONE|ANYONECANPAY\")%>,\n+    <%static_cast<unsigned char>(SIGHASH_SINGLE), std::string(\"SINGLE\")%>,\n+    <%static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY), std::string(\"SINGLE|ANYONECANPAY\")%>,\n+%>;\n \n std::string SighashToStr(unsigned char sighash_type)\n-{\n+<%\n     const auto& it = mapSigHashTypes.find(sighash_type);\n     if (it == mapSigHashTypes.end()) return \"\";\n     return it->second;\n-}\n+%>\n \n /**\n  * Create the assembly string representation of a CScript object.\n@@ -85,58 +85,58 @@ std::string SighashToStr(unsigned char sighash_type)\n  *                                     pass false, or omit the this argument (defaults to false), for scriptPubKeys.\n  */\n std::string ScriptToAsmStr(const CScript& script, const bool fAttemptSighashDecode)\n-{\n+<%\n     std::string str;\n     opcodetype opcode;\n     std::vector<unsigned char> vch;\n     CScript::const_iterator pc = script.begin();\n-    while (pc < script.end()) {\n-        if (!str.empty()) {\n+    while (pc < script.end()) <%\n+        if (!str.empty()) <%\n             str += \" \";\n-        }\n-        if (!script.GetOp(pc, opcode, vch)) {\n+        %>\n+        if (!script.GetOp(pc, opcode, vch)) <%\n             str += \"[error]\";\n             return str;\n-        }\n-        if (0 <= opcode && opcode <= OP_PUSHDATA4) {\n-            if (vch.size() <= static_cast<std::vector<unsigned char>::size_type>(4)) {\n+        %>\n+        if (0 <= opcode && opcode <= OP_PUSHDATA4) <%\n+            if (vch.size() <= static_cast<std::vector<unsigned char>::size_type>(4)) <%\n                 str += strprintf(\"%d\", CScriptNum(vch, false).getint());\n-            } else {\n+            %> else <%\n                 // the IsUnspendable check makes sure not to try to decode OP_RETURN data that may match the format of a signature\n-                if (fAttemptSighashDecode && !script.IsUnspendable()) {\n+                if (fAttemptSighashDecode && !script.IsUnspendable()) <%\n                     std::string strSigHashDecode;\n                     // goal: only attempt to decode a defined sighash type from data that looks like a signature within a scriptSig.\n                     // this won't decode correctly formatted public keys in Pubkey or Multisig scripts due to\n                     // the restrictions on the pubkey formats (see IsCompressedOrUncompressedPubKey) being incongruous with the\n                     // checks in CheckSignatureEncoding.\n-                    if (CheckSignatureEncoding(vch, SCRIPT_VERIFY_STRICTENC, nullptr)) {\n+                    if (CheckSignatureEncoding(vch, SCRIPT_VERIFY_STRICTENC, nullptr)) <%\n                         const unsigned char chSigHashType = vch.back();\n-                        if (mapSigHashTypes.count(chSigHashType)) {\n+                        if (mapSigHashTypes.count(chSigHashType)) <%\n                             strSigHashDecode = \"[\" + mapSigHashTypes.find(chSigHashType)->second + \"]\";\n                             vch.pop_back(); // remove the sighash type byte. it will be replaced by the decode.\n-                        }\n-                    }\n+                        %>\n+                    %>\n                     str += HexStr(vch) + strSigHashDecode;\n-                } else {\n+                %> else <%\n                     str += HexStr(vch);\n-                }\n-            }\n-        } else {\n+                %>\n+            %>\n+        %> else <%\n             str += GetOpName(opcode);\n-        }\n-    }\n+        %>\n+    %>\n     return str;\n-}\n+%>\n \n std::string EncodeHexTx(const CTransaction& tx, const int serializeFlags)\n-{\n+<%\n     CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION | serializeFlags);\n     ssTx << tx;\n     return HexStr(ssTx.begin(), ssTx.end());\n-}\n+%>\n \n void ScriptToUniv(const CScript& script, UniValue& out, bool include_address)\n-{\n+<%\n     out.pushKV(\"asm\", ScriptToAsmStr(script));\n     out.pushKV(\"hex\", HexStr(script.begin(), script.end()));\n \n@@ -145,14 +145,14 @@ void ScriptToUniv(const CScript& script, UniValue& out, bool include_address)\n     out.pushKV(\"type\", GetTxnOutputType(type));\n \n     CTxDestination address;\n-    if (include_address && ExtractDestination(script, address)) {\n+    if (include_address && ExtractDestination(script, address)) <%\n         out.pushKV(\"address\", EncodeDestination(address));\n-    }\n-}\n+    %>\n+%>\n \n void ScriptPubKeyToUniv(const CScript& scriptPubKey,\n                         UniValue& out, bool fIncludeHex)\n-{\n+<%\n     txnouttype type;\n     std::vector<CTxDestination> addresses;\n     int nRequired;\n@@ -161,23 +161,23 @@ void ScriptPubKeyToUniv(const CScript& scriptPubKey,\n     if (fIncludeHex)\n         out.pushKV(\"hex\", HexStr(scriptPubKey.begin(), scriptPubKey.end()));\n \n-    if (!ExtractDestinations(scriptPubKey, type, addresses, nRequired)) {\n+    if (!ExtractDestinations(scriptPubKey, type, addresses, nRequired)) <%\n         out.pushKV(\"type\", GetTxnOutputType(type));\n         return;\n-    }\n+    %>\n \n     out.pushKV(\"reqSigs\", nRequired);\n     out.pushKV(\"type\", GetTxnOutputType(type));\n \n     UniValue a(UniValue::VARR);\n-    for (const CTxDestination& addr : addresses) {\n+    for (const CTxDestination& addr : addresses) <%\n         a.push_back(EncodeDestination(addr));\n-    }\n+    %>\n     out.pushKV(\"addresses\", a);\n-}\n+%>\n \n void TxToUniv(const CTransaction& tx, const uint256& hashBlock, UniValue& entry, bool include_hex, int serialize_flags)\n-{\n+<%\n     entry.pushKV(\"txid\", tx.GetHash().GetHex());\n     entry.pushKV(\"hash\", tx.GetWitnessHash().GetHex());\n     entry.pushKV(\"version\", tx.nVersion);\n@@ -187,33 +187,33 @@ void TxToUniv(const CTransaction& tx, const uint256& hashBlock, UniValue& entry,\n     entry.pushKV(\"locktime\", (int64_t)tx.nLockTime);\n \n     UniValue vin(UniValue::VARR);\n-    for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+    for (unsigned int i = 0; i < tx.vin.size(); i++) <%\n         const CTxIn& txin = tx.vin[i];\n         UniValue in(UniValue::VOBJ);\n         if (tx.IsCoinBase())\n             in.pushKV(\"coinbase\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end()));\n-        else {\n+        else <%\n             in.pushKV(\"txid\", txin.prevout.hash.GetHex());\n             in.pushKV(\"vout\", (int64_t)txin.prevout.n);\n             UniValue o(UniValue::VOBJ);\n             o.pushKV(\"asm\", ScriptToAsmStr(txin.scriptSig, true));\n             o.pushKV(\"hex\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end()));\n             in.pushKV(\"scriptSig\", o);\n-            if (!tx.vin[i].scriptWitness.IsNull()) {\n+            if (!tx.vin[i].scriptWitness.IsNull()) <%\n                 UniValue txinwitness(UniValue::VARR);\n-                for (const auto& item : tx.vin[i].scriptWitness.stack) {\n+                for (const auto& item : tx.vin[i].scriptWitness.stack) <%\n                     txinwitness.push_back(HexStr(item.begin(), item.end()));\n-                }\n+                %>\n                 in.pushKV(\"txinwitness\", txinwitness);\n-            }\n-        }\n+            %>\n+        %>\n         in.pushKV(\"sequence\", (int64_t)txin.nSequence);\n         vin.push_back(in);\n-    }\n+    %>\n     entry.pushKV(\"vin\", vin);\n \n     UniValue vout(UniValue::VARR);\n-    for (unsigned int i = 0; i < tx.vout.size(); i++) {\n+    for (unsigned int i = 0; i < tx.vout.size(); i++) <%\n         const CTxOut& txout = tx.vout[i];\n \n         UniValue out(UniValue::VOBJ);\n@@ -225,13 +225,13 @@ void TxToUniv(const CTransaction& tx, const uint256& hashBlock, UniValue& entry,\n         ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n         out.pushKV(\"scriptPubKey\", o);\n         vout.push_back(out);\n-    }\n+    %>\n     entry.pushKV(\"vout\", vout);\n \n     if (!hashBlock.IsNull())\n         entry.pushKV(\"blockhash\", hashBlock.GetHex());\n \n-    if (include_hex) {\n+    if (include_hex) <%\n         entry.pushKV(\"hex\", EncodeHexTx(tx, serialize_flags)); // The hex-encoded transaction. Used the name \"hex\" to be consistent with the verbose output of \"getrawtransaction\".\n-    }\n-}\n+    %>\n+%>"
      },
      {
        "sha": "aff47eb12a647087cec4e59db0fa2a2f88767a83",
        "filename": "src/crypto/aes.cpp",
        "status": "modified",
        "additions": 38,
        "deletions": 38,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/aes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/aes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/aes.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -8,44 +8,44 @@\n #include <assert.h>\n #include <string.h>\n \n-extern \"C\" {\n+extern \"C\" <%\n #include <crypto/ctaes/ctaes.c>\n-}\n+%>\n \n AES256Encrypt::AES256Encrypt(const unsigned char key[32])\n-{\n+<%\n     AES256_init(&ctx, key);\n-}\n+%>\n \n AES256Encrypt::~AES256Encrypt()\n-{\n+<%\n     memset(&ctx, 0, sizeof(ctx));\n-}\n+%>\n \n void AES256Encrypt::Encrypt(unsigned char ciphertext[16], const unsigned char plaintext[16]) const\n-{\n+<%\n     AES256_encrypt(&ctx, 1, ciphertext, plaintext);\n-}\n+%>\n \n AES256Decrypt::AES256Decrypt(const unsigned char key[32])\n-{\n+<%\n     AES256_init(&ctx, key);\n-}\n+%>\n \n AES256Decrypt::~AES256Decrypt()\n-{\n+<%\n     memset(&ctx, 0, sizeof(ctx));\n-}\n+%>\n \n void AES256Decrypt::Decrypt(unsigned char plaintext[16], const unsigned char ciphertext[16]) const\n-{\n+<%\n     AES256_decrypt(&ctx, 1, plaintext, ciphertext);\n-}\n+%>\n \n \n template <typename T>\n static int CBCEncrypt(const T& enc, const unsigned char iv[AES_BLOCKSIZE], const unsigned char* data, int size, bool pad, unsigned char* out)\n-{\n+<%\n     int written = 0;\n     int padsize = size % AES_BLOCKSIZE;\n     unsigned char mixed[AES_BLOCKSIZE];\n@@ -59,14 +59,14 @@ static int CBCEncrypt(const T& enc, const unsigned char iv[AES_BLOCKSIZE], const\n     memcpy(mixed, iv, AES_BLOCKSIZE);\n \n     // Write all but the last block\n-    while (written + AES_BLOCKSIZE <= size) {\n+    while (written + AES_BLOCKSIZE <= size) <%\n         for (int i = 0; i != AES_BLOCKSIZE; i++)\n             mixed[i] ^= *data++;\n         enc.Encrypt(out + written, mixed);\n         memcpy(mixed, out + written, AES_BLOCKSIZE);\n         written += AES_BLOCKSIZE;\n-    }\n-    if (pad) {\n+    %>\n+    if (pad) <%\n         // For all that remains, pad each byte with the value of the remaining\n         // space. If there is none, pad by a full block.\n         for (int i = 0; i != padsize; i++)\n@@ -75,13 +75,13 @@ static int CBCEncrypt(const T& enc, const unsigned char iv[AES_BLOCKSIZE], const\n             mixed[i] ^= AES_BLOCKSIZE - padsize;\n         enc.Encrypt(out + written, mixed);\n         written += AES_BLOCKSIZE;\n-    }\n+    %>\n     return written;\n-}\n+%>\n \n template <typename T>\n static int CBCDecrypt(const T& dec, const unsigned char iv[AES_BLOCKSIZE], const unsigned char* data, int size, bool pad, unsigned char* out)\n-{\n+<%\n     int written = 0;\n     bool fail = false;\n     const unsigned char* prev = iv;\n@@ -93,16 +93,16 @@ static int CBCDecrypt(const T& dec, const unsigned char iv[AES_BLOCKSIZE], const\n         return 0;\n \n     // Decrypt all data. Padding will be checked in the output.\n-    while (written != size) {\n+    while (written != size) <%\n         dec.Decrypt(out, data + written);\n         for (int i = 0; i != AES_BLOCKSIZE; i++)\n             *out++ ^= prev[i];\n         prev = data + written;\n         written += AES_BLOCKSIZE;\n-    }\n+    %>\n \n     // When decrypting padding, attempt to run in constant-time\n-    if (pad) {\n+    if (pad) <%\n         // If used, padding size is the value of the last decrypted byte. For\n         // it to be valid, It must be between 1 and AES_BLOCKSIZE.\n         unsigned char padsize = *--out;\n@@ -116,39 +116,39 @@ static int CBCDecrypt(const T& dec, const unsigned char iv[AES_BLOCKSIZE], const\n             fail |= ((i > AES_BLOCKSIZE - padsize) & (*out-- != padsize));\n \n         written -= padsize;\n-    }\n+    %>\n     return written * !fail;\n-}\n+%>\n \n AES256CBCEncrypt::AES256CBCEncrypt(const unsigned char key[AES256_KEYSIZE], const unsigned char ivIn[AES_BLOCKSIZE], bool padIn)\n     : enc(key), pad(padIn)\n-{\n+<%\n     memcpy(iv, ivIn, AES_BLOCKSIZE);\n-}\n+%>\n \n int AES256CBCEncrypt::Encrypt(const unsigned char* data, int size, unsigned char* out) const\n-{\n+<%\n     return CBCEncrypt(enc, iv, data, size, pad, out);\n-}\n+%>\n \n AES256CBCEncrypt::~AES256CBCEncrypt()\n-{\n+<%\n     memset(iv, 0, sizeof(iv));\n-}\n+%>\n \n AES256CBCDecrypt::AES256CBCDecrypt(const unsigned char key[AES256_KEYSIZE], const unsigned char ivIn[AES_BLOCKSIZE], bool padIn)\n     : dec(key), pad(padIn)\n-{\n+<%\n     memcpy(iv, ivIn, AES_BLOCKSIZE);\n-}\n+%>\n \n \n int AES256CBCDecrypt::Decrypt(const unsigned char* data, int size, unsigned char* out) const\n-{\n+<%\n     return CBCDecrypt(dec, iv, data, size, pad, out);\n-}\n+%>\n \n AES256CBCDecrypt::~AES256CBCDecrypt()\n-{\n+<%\n     memset(iv, 0, sizeof(iv));\n-}\n+%>"
      },
      {
        "sha": "8e28a20e30cf3a4650c224e387989156f5bf50b5",
        "filename": "src/crypto/aes.h",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/aes.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/aes.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/aes.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -7,39 +7,39 @@\n #ifndef BITCOIN_CRYPTO_AES_H\n #define BITCOIN_CRYPTO_AES_H\n \n-extern \"C\" {\n+extern \"C\" <%\n #include <crypto/ctaes/ctaes.h>\n-}\n+%>\n \n static const int AES_BLOCKSIZE = 16;\n static const int AES256_KEYSIZE = 32;\n \n /** An encryption class for AES-256. */\n class AES256Encrypt\n-{\n+<%\n private:\n     AES256_ctx ctx;\n \n public:\n     explicit AES256Encrypt(const unsigned char key[32]);\n     ~AES256Encrypt();\n     void Encrypt(unsigned char ciphertext[16], const unsigned char plaintext[16]) const;\n-};\n+%>;\n \n /** A decryption class for AES-256. */\n class AES256Decrypt\n-{\n+<%\n private:\n     AES256_ctx ctx;\n \n public:\n     explicit AES256Decrypt(const unsigned char key[32]);\n     ~AES256Decrypt();\n     void Decrypt(unsigned char plaintext[16], const unsigned char ciphertext[16]) const;\n-};\n+%>;\n \n class AES256CBCEncrypt\n-{\n+<%\n public:\n     AES256CBCEncrypt(const unsigned char key[AES256_KEYSIZE], const unsigned char ivIn[AES_BLOCKSIZE], bool padIn);\n     ~AES256CBCEncrypt();\n@@ -49,10 +49,10 @@ class AES256CBCEncrypt\n     const AES256Encrypt enc;\n     const bool pad;\n     unsigned char iv[AES_BLOCKSIZE];\n-};\n+%>;\n \n class AES256CBCDecrypt\n-{\n+<%\n public:\n     AES256CBCDecrypt(const unsigned char key[AES256_KEYSIZE], const unsigned char ivIn[AES_BLOCKSIZE], bool padIn);\n     ~AES256CBCDecrypt();\n@@ -62,6 +62,6 @@ class AES256CBCDecrypt\n     const AES256Decrypt dec;\n     const bool pad;\n     unsigned char iv[AES_BLOCKSIZE];\n-};\n+%>;\n \n #endif // BITCOIN_CRYPTO_AES_H"
      },
      {
        "sha": "2c6737839319336ec9449e1c33db705b8640b0e5",
        "filename": "src/crypto/chacha20.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 26,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/chacha20.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/chacha20.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/chacha20.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -10,7 +10,7 @@\n \n #include <string.h>\n \n-constexpr static inline uint32_t rotl32(uint32_t v, int c) { return (v << c) | (v >> (32 - c)); }\n+constexpr static inline uint32_t rotl32(uint32_t v, int c) <% return (v << c) | (v >> (32 - c)); %>\n \n #define QUARTERROUND(a,b,c,d) \\\n   a += b; d = rotl32(d ^ a, 16); \\\n@@ -22,19 +22,19 @@ static const unsigned char sigma[] = \"expand 32-byte k\";\n static const unsigned char tau[] = \"expand 16-byte k\";\n \n void ChaCha20::SetKey(const unsigned char* k, size_t keylen)\n-{\n+<%\n     const unsigned char *constants;\n \n     input[4] = ReadLE32(k + 0);\n     input[5] = ReadLE32(k + 4);\n     input[6] = ReadLE32(k + 8);\n     input[7] = ReadLE32(k + 12);\n-    if (keylen == 32) { /* recommended */\n+    if (keylen == 32) <% /* recommended */\n         k += 16;\n         constants = sigma;\n-    } else { /* keylen == 16 */\n+    %> else <% /* keylen == 16 */\n         constants = tau;\n-    }\n+    %>\n     input[8] = ReadLE32(k + 0);\n     input[9] = ReadLE32(k + 4);\n     input[10] = ReadLE32(k + 8);\n@@ -47,32 +47,32 @@ void ChaCha20::SetKey(const unsigned char* k, size_t keylen)\n     input[13] = 0;\n     input[14] = 0;\n     input[15] = 0;\n-}\n+%>\n \n ChaCha20::ChaCha20()\n-{\n+<%\n     memset(input, 0, sizeof(input));\n-}\n+%>\n \n ChaCha20::ChaCha20(const unsigned char* k, size_t keylen)\n-{\n+<%\n     SetKey(k, keylen);\n-}\n+%>\n \n void ChaCha20::SetIV(uint64_t iv)\n-{\n+<%\n     input[14] = iv;\n     input[15] = iv >> 32;\n-}\n+%>\n \n void ChaCha20::Seek(uint64_t pos)\n-{\n+<%\n     input[12] = pos;\n     input[13] = pos >> 32;\n-}\n+%>\n \n void ChaCha20::Output(unsigned char* c, size_t bytes)\n-{\n+<%\n     uint32_t x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n     uint32_t j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n     unsigned char *ctarget = nullptr;\n@@ -98,11 +98,11 @@ void ChaCha20::Output(unsigned char* c, size_t bytes)\n     j14 = input[14];\n     j15 = input[15];\n \n-    for (;;) {\n-        if (bytes < 64) {\n+    for (;;) <%\n+        if (bytes < 64) <%\n             ctarget = c;\n             c = tmp;\n-        }\n+        %>\n         x0 = j0;\n         x1 = j1;\n         x2 = j2;\n@@ -119,7 +119,7 @@ void ChaCha20::Output(unsigned char* c, size_t bytes)\n         x13 = j13;\n         x14 = j14;\n         x15 = j15;\n-        for (i = 20;i > 0;i -= 2) {\n+        for (i = 20;i > 0;i -= 2) <%\n             QUARTERROUND( x0, x4, x8,x12)\n             QUARTERROUND( x1, x5, x9,x13)\n             QUARTERROUND( x2, x6,x10,x14)\n@@ -128,7 +128,7 @@ void ChaCha20::Output(unsigned char* c, size_t bytes)\n             QUARTERROUND( x1, x6,x11,x12)\n             QUARTERROUND( x2, x7, x8,x13)\n             QUARTERROUND( x3, x4, x9,x14)\n-        }\n+        %>\n         x0 += j0;\n         x1 += j1;\n         x2 += j2;\n@@ -166,15 +166,15 @@ void ChaCha20::Output(unsigned char* c, size_t bytes)\n         WriteLE32(c + 56, x14);\n         WriteLE32(c + 60, x15);\n \n-        if (bytes <= 64) {\n-            if (bytes < 64) {\n+        if (bytes <= 64) <%\n+            if (bytes < 64) <%\n                 for (i = 0;i < bytes;++i) ctarget[i] = c[i];\n-            }\n+            %>\n             input[12] = j12;\n             input[13] = j13;\n             return;\n-        }\n+        %>\n         bytes -= 64;\n         c += 64;\n-    }\n-}\n+    %>\n+%>"
      },
      {
        "sha": "a93f941295732af3e4787a721e19709c697d4f8a",
        "filename": "src/crypto/chacha20.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/chacha20.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/chacha20.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/chacha20.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -10,7 +10,7 @@\n \n /** A PRNG class for ChaCha20. */\n class ChaCha20\n-{\n+<%\n private:\n     uint32_t input[16];\n \n@@ -21,6 +21,6 @@ class ChaCha20\n     void SetIV(uint64_t iv);\n     void Seek(uint64_t pos);\n     void Output(unsigned char* output, size_t bytes);\n-};\n+%>;\n \n #endif // BITCOIN_CRYPTO_CHACHA20_H"
      },
      {
        "sha": "65e6c4656e861f5c9eef23accc8f9a362a8c17b3",
        "filename": "src/crypto/common.h",
        "status": "modified",
        "additions": 28,
        "deletions": 28,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/common.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/common.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/common.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -15,89 +15,89 @@\n #include <compat/endian.h>\n \n uint16_t static inline ReadLE16(const unsigned char* ptr)\n-{\n+<%\n     uint16_t x;\n     memcpy((char*)&x, ptr, 2);\n     return le16toh(x);\n-}\n+%>\n \n uint32_t static inline ReadLE32(const unsigned char* ptr)\n-{\n+<%\n     uint32_t x;\n     memcpy((char*)&x, ptr, 4);\n     return le32toh(x);\n-}\n+%>\n \n uint64_t static inline ReadLE64(const unsigned char* ptr)\n-{\n+<%\n     uint64_t x;\n     memcpy((char*)&x, ptr, 8);\n     return le64toh(x);\n-}\n+%>\n \n void static inline WriteLE16(unsigned char* ptr, uint16_t x)\n-{\n+<%\n     uint16_t v = htole16(x);\n     memcpy(ptr, (char*)&v, 2);\n-}\n+%>\n \n void static inline WriteLE32(unsigned char* ptr, uint32_t x)\n-{\n+<%\n     uint32_t v = htole32(x);\n     memcpy(ptr, (char*)&v, 4);\n-}\n+%>\n \n void static inline WriteLE64(unsigned char* ptr, uint64_t x)\n-{\n+<%\n     uint64_t v = htole64(x);\n     memcpy(ptr, (char*)&v, 8);\n-}\n+%>\n \n uint32_t static inline ReadBE32(const unsigned char* ptr)\n-{\n+<%\n     uint32_t x;\n     memcpy((char*)&x, ptr, 4);\n     return be32toh(x);\n-}\n+%>\n \n uint64_t static inline ReadBE64(const unsigned char* ptr)\n-{\n+<%\n     uint64_t x;\n     memcpy((char*)&x, ptr, 8);\n     return be64toh(x);\n-}\n+%>\n \n void static inline WriteBE32(unsigned char* ptr, uint32_t x)\n-{\n+<%\n     uint32_t v = htobe32(x);\n     memcpy(ptr, (char*)&v, 4);\n-}\n+%>\n \n void static inline WriteBE64(unsigned char* ptr, uint64_t x)\n-{\n+<%\n     uint64_t v = htobe64(x);\n     memcpy(ptr, (char*)&v, 8);\n-}\n+%>\n \n /** Return the smallest number n such that (x >> n) == 0 (or 64 if the highest bit in x is set. */\n uint64_t static inline CountBits(uint64_t x)\n-{\n+<%\n #if HAVE_DECL___BUILTIN_CLZL\n-    if (sizeof(unsigned long) >= sizeof(uint64_t)) {\n+    if (sizeof(unsigned long) >= sizeof(uint64_t)) <%\n         return x ? 8 * sizeof(unsigned long) - __builtin_clzl(x) : 0;\n-    }\n+    %>\n #endif\n #if HAVE_DECL___BUILTIN_CLZLL\n-    if (sizeof(unsigned long long) >= sizeof(uint64_t)) {\n+    if (sizeof(unsigned long long) >= sizeof(uint64_t)) <%\n         return x ? 8 * sizeof(unsigned long long) - __builtin_clzll(x) : 0;\n-    }\n+    %>\n #endif\n     int ret = 0;\n-    while (x) {\n+    while (x) <%\n         x >>= 1;\n         ++ret;\n-    }\n+    %>\n     return ret;\n-}\n+%>\n \n #endif // BITCOIN_CRYPTO_COMMON_H"
      },
      {
        "sha": "916012363ad5ebe6460629db40d9446909e8d092",
        "filename": "src/crypto/hmac_sha256.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/hmac_sha256.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/hmac_sha256.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/hmac_sha256.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -7,15 +7,15 @@\n #include <string.h>\n \n CHMAC_SHA256::CHMAC_SHA256(const unsigned char* key, size_t keylen)\n-{\n+<%\n     unsigned char rkey[64];\n-    if (keylen <= 64) {\n+    if (keylen <= 64) <%\n         memcpy(rkey, key, keylen);\n         memset(rkey + keylen, 0, 64 - keylen);\n-    } else {\n+    %> else <%\n         CSHA256().Write(key, keylen).Finalize(rkey);\n         memset(rkey + 32, 0, 32);\n-    }\n+    %>\n \n     for (int n = 0; n < 64; n++)\n         rkey[n] ^= 0x5c;\n@@ -24,11 +24,11 @@ CHMAC_SHA256::CHMAC_SHA256(const unsigned char* key, size_t keylen)\n     for (int n = 0; n < 64; n++)\n         rkey[n] ^= 0x5c ^ 0x36;\n     inner.Write(rkey, 64);\n-}\n+%>\n \n void CHMAC_SHA256::Finalize(unsigned char hash[OUTPUT_SIZE])\n-{\n+<%\n     unsigned char temp[32];\n     inner.Finalize(temp);\n     outer.Write(temp, 32).Finalize(hash);\n-}\n+%>"
      },
      {
        "sha": "20971128918b23e31582f2fc339efc0eb95c833d",
        "filename": "src/crypto/hmac_sha256.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/hmac_sha256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/hmac_sha256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/hmac_sha256.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -12,7 +12,7 @@\n \n /** A hasher class for HMAC-SHA-256. */\n class CHMAC_SHA256\n-{\n+<%\n private:\n     CSHA256 outer;\n     CSHA256 inner;\n@@ -22,11 +22,11 @@ class CHMAC_SHA256\n \n     CHMAC_SHA256(const unsigned char* key, size_t keylen);\n     CHMAC_SHA256& Write(const unsigned char* data, size_t len)\n-    {\n+    <%\n         inner.Write(data, len);\n         return *this;\n-    }\n+    %>\n     void Finalize(unsigned char hash[OUTPUT_SIZE]);\n-};\n+%>;\n \n #endif // BITCOIN_CRYPTO_HMAC_SHA256_H"
      },
      {
        "sha": "15976bdcb2dd46b9bb5655fc367650656c668ca0",
        "filename": "src/crypto/hmac_sha512.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/hmac_sha512.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/hmac_sha512.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/hmac_sha512.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -7,15 +7,15 @@\n #include <string.h>\n \n CHMAC_SHA512::CHMAC_SHA512(const unsigned char* key, size_t keylen)\n-{\n+<%\n     unsigned char rkey[128];\n-    if (keylen <= 128) {\n+    if (keylen <= 128) <%\n         memcpy(rkey, key, keylen);\n         memset(rkey + keylen, 0, 128 - keylen);\n-    } else {\n+    %> else <%\n         CSHA512().Write(key, keylen).Finalize(rkey);\n         memset(rkey + 64, 0, 64);\n-    }\n+    %>\n \n     for (int n = 0; n < 128; n++)\n         rkey[n] ^= 0x5c;\n@@ -24,11 +24,11 @@ CHMAC_SHA512::CHMAC_SHA512(const unsigned char* key, size_t keylen)\n     for (int n = 0; n < 128; n++)\n         rkey[n] ^= 0x5c ^ 0x36;\n     inner.Write(rkey, 128);\n-}\n+%>\n \n void CHMAC_SHA512::Finalize(unsigned char hash[OUTPUT_SIZE])\n-{\n+<%\n     unsigned char temp[64];\n     inner.Finalize(temp);\n     outer.Write(temp, 64).Finalize(hash);\n-}\n+%>"
      },
      {
        "sha": "ecc754881fb6ad527218fef8d8659e6ab39511a1",
        "filename": "src/crypto/hmac_sha512.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/hmac_sha512.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/hmac_sha512.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/hmac_sha512.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -12,7 +12,7 @@\n \n /** A hasher class for HMAC-SHA-512. */\n class CHMAC_SHA512\n-{\n+<%\n private:\n     CSHA512 outer;\n     CSHA512 inner;\n@@ -22,11 +22,11 @@ class CHMAC_SHA512\n \n     CHMAC_SHA512(const unsigned char* key, size_t keylen);\n     CHMAC_SHA512& Write(const unsigned char* data, size_t len)\n-    {\n+    <%\n         inner.Write(data, len);\n         return *this;\n-    }\n+    %>\n     void Finalize(unsigned char hash[OUTPUT_SIZE]);\n-};\n+%>;\n \n #endif // BITCOIN_CRYPTO_HMAC_SHA512_H"
      },
      {
        "sha": "2bae543bc3e45d79e26c5e0a2bdbdac731e04d18",
        "filename": "src/crypto/poly1305.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/poly1305.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/poly1305.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/poly1305.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -12,7 +12,7 @@\n \n #define mul32x32_64(a,b) ((uint64_t)(a) * (b))\n \n-void poly1305_auth(unsigned char out[POLY1305_TAGLEN], const unsigned char *m, size_t inlen, const unsigned char key[POLY1305_KEYLEN]) {\n+void poly1305_auth(unsigned char out[POLY1305_TAGLEN], const unsigned char *m, size_t inlen, const unsigned char key[POLY1305_KEYLEN]) <%\n     uint32_t t0,t1,t2,t3;\n     uint32_t h0,h1,h2,h3,h4;\n     uint32_t r0,r1,r2,r3,r4;\n@@ -138,4 +138,4 @@ void poly1305_auth(unsigned char out[POLY1305_TAGLEN], const unsigned char *m, s\n     WriteLE32(&out[ 4], f1); f2 += (f1 >> 32);\n     WriteLE32(&out[ 8], f2); f3 += (f2 >> 32);\n     WriteLE32(&out[12], f3);\n-}\n+%>"
      },
      {
        "sha": "779e9fa529d99b39a8a7b09ed90d0c470e0c9ae7",
        "filename": "src/crypto/ripemd160.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 41,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/ripemd160.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/ripemd160.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/ripemd160.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -10,49 +10,49 @@\n \n // Internal implementation code.\n namespace\n-{\n+<%\n /// Internal RIPEMD-160 implementation.\n namespace ripemd160\n-{\n-uint32_t inline f1(uint32_t x, uint32_t y, uint32_t z) { return x ^ y ^ z; }\n-uint32_t inline f2(uint32_t x, uint32_t y, uint32_t z) { return (x & y) | (~x & z); }\n-uint32_t inline f3(uint32_t x, uint32_t y, uint32_t z) { return (x | ~y) ^ z; }\n-uint32_t inline f4(uint32_t x, uint32_t y, uint32_t z) { return (x & z) | (y & ~z); }\n-uint32_t inline f5(uint32_t x, uint32_t y, uint32_t z) { return x ^ (y | ~z); }\n+<%\n+uint32_t inline f1(uint32_t x, uint32_t y, uint32_t z) <% return x ^ y ^ z; %>\n+uint32_t inline f2(uint32_t x, uint32_t y, uint32_t z) <% return (x & y) | (~x & z); %>\n+uint32_t inline f3(uint32_t x, uint32_t y, uint32_t z) <% return (x | ~y) ^ z; %>\n+uint32_t inline f4(uint32_t x, uint32_t y, uint32_t z) <% return (x & z) | (y & ~z); %>\n+uint32_t inline f5(uint32_t x, uint32_t y, uint32_t z) <% return x ^ (y | ~z); %>\n \n /** Initialize RIPEMD-160 state. */\n void inline Initialize(uint32_t* s)\n-{\n+<%\n     s[0] = 0x67452301ul;\n     s[1] = 0xEFCDAB89ul;\n     s[2] = 0x98BADCFEul;\n     s[3] = 0x10325476ul;\n     s[4] = 0xC3D2E1F0ul;\n-}\n+%>\n \n-uint32_t inline rol(uint32_t x, int i) { return (x << i) | (x >> (32 - i)); }\n+uint32_t inline rol(uint32_t x, int i) <% return (x << i) | (x >> (32 - i)); %>\n \n void inline Round(uint32_t& a, uint32_t b, uint32_t& c, uint32_t d, uint32_t e, uint32_t f, uint32_t x, uint32_t k, int r)\n-{\n+<%\n     a = rol(a + f + x + k, r) + e;\n     c = rol(c, 10);\n-}\n+%>\n \n-void inline R11(uint32_t& a, uint32_t b, uint32_t& c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f1(b, c, d), x, 0, r); }\n-void inline R21(uint32_t& a, uint32_t b, uint32_t& c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f2(b, c, d), x, 0x5A827999ul, r); }\n-void inline R31(uint32_t& a, uint32_t b, uint32_t& c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f3(b, c, d), x, 0x6ED9EBA1ul, r); }\n-void inline R41(uint32_t& a, uint32_t b, uint32_t& c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f4(b, c, d), x, 0x8F1BBCDCul, r); }\n-void inline R51(uint32_t& a, uint32_t b, uint32_t& c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f5(b, c, d), x, 0xA953FD4Eul, r); }\n+void inline R11(uint32_t& a, uint32_t b, uint32_t& c, uint32_t d, uint32_t e, uint32_t x, int r) <% Round(a, b, c, d, e, f1(b, c, d), x, 0, r); %>\n+void inline R21(uint32_t& a, uint32_t b, uint32_t& c, uint32_t d, uint32_t e, uint32_t x, int r) <% Round(a, b, c, d, e, f2(b, c, d), x, 0x5A827999ul, r); %>\n+void inline R31(uint32_t& a, uint32_t b, uint32_t& c, uint32_t d, uint32_t e, uint32_t x, int r) <% Round(a, b, c, d, e, f3(b, c, d), x, 0x6ED9EBA1ul, r); %>\n+void inline R41(uint32_t& a, uint32_t b, uint32_t& c, uint32_t d, uint32_t e, uint32_t x, int r) <% Round(a, b, c, d, e, f4(b, c, d), x, 0x8F1BBCDCul, r); %>\n+void inline R51(uint32_t& a, uint32_t b, uint32_t& c, uint32_t d, uint32_t e, uint32_t x, int r) <% Round(a, b, c, d, e, f5(b, c, d), x, 0xA953FD4Eul, r); %>\n \n-void inline R12(uint32_t& a, uint32_t b, uint32_t& c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f5(b, c, d), x, 0x50A28BE6ul, r); }\n-void inline R22(uint32_t& a, uint32_t b, uint32_t& c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f4(b, c, d), x, 0x5C4DD124ul, r); }\n-void inline R32(uint32_t& a, uint32_t b, uint32_t& c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f3(b, c, d), x, 0x6D703EF3ul, r); }\n-void inline R42(uint32_t& a, uint32_t b, uint32_t& c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f2(b, c, d), x, 0x7A6D76E9ul, r); }\n-void inline R52(uint32_t& a, uint32_t b, uint32_t& c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f1(b, c, d), x, 0, r); }\n+void inline R12(uint32_t& a, uint32_t b, uint32_t& c, uint32_t d, uint32_t e, uint32_t x, int r) <% Round(a, b, c, d, e, f5(b, c, d), x, 0x50A28BE6ul, r); %>\n+void inline R22(uint32_t& a, uint32_t b, uint32_t& c, uint32_t d, uint32_t e, uint32_t x, int r) <% Round(a, b, c, d, e, f4(b, c, d), x, 0x5C4DD124ul, r); %>\n+void inline R32(uint32_t& a, uint32_t b, uint32_t& c, uint32_t d, uint32_t e, uint32_t x, int r) <% Round(a, b, c, d, e, f3(b, c, d), x, 0x6D703EF3ul, r); %>\n+void inline R42(uint32_t& a, uint32_t b, uint32_t& c, uint32_t d, uint32_t e, uint32_t x, int r) <% Round(a, b, c, d, e, f2(b, c, d), x, 0x7A6D76E9ul, r); %>\n+void inline R52(uint32_t& a, uint32_t b, uint32_t& c, uint32_t d, uint32_t e, uint32_t x, int r) <% Round(a, b, c, d, e, f1(b, c, d), x, 0, r); %>\n \n /** Perform a RIPEMD-160 transformation, processing a 64-byte chunk. */\n void Transform(uint32_t* s, const unsigned char* chunk)\n-{\n+<%\n     uint32_t a1 = s[0], b1 = s[1], c1 = s[2], d1 = s[3], e1 = s[4];\n     uint32_t a2 = a1, b2 = b1, c2 = c1, d2 = d1, e2 = e1;\n     uint32_t w0 = ReadLE32(chunk + 0), w1 = ReadLE32(chunk + 4), w2 = ReadLE32(chunk + 8), w3 = ReadLE32(chunk + 12);\n@@ -231,48 +231,48 @@ void Transform(uint32_t* s, const unsigned char* chunk)\n     s[2] = s[3] + e1 + a2;\n     s[3] = s[4] + a1 + b2;\n     s[4] = t + b1 + c2;\n-}\n+%>\n \n-} // namespace ripemd160\n+%> // namespace ripemd160\n \n-} // namespace\n+%> // namespace\n \n ////// RIPEMD160\n \n CRIPEMD160::CRIPEMD160() : bytes(0)\n-{\n+<%\n     ripemd160::Initialize(s);\n-}\n+%>\n \n CRIPEMD160& CRIPEMD160::Write(const unsigned char* data, size_t len)\n-{\n+<%\n     const unsigned char* end = data + len;\n     size_t bufsize = bytes % 64;\n-    if (bufsize && bufsize + len >= 64) {\n+    if (bufsize && bufsize + len >= 64) <%\n         // Fill the buffer, and process it.\n         memcpy(buf + bufsize, data, 64 - bufsize);\n         bytes += 64 - bufsize;\n         data += 64 - bufsize;\n         ripemd160::Transform(s, buf);\n         bufsize = 0;\n-    }\n-    while (end >= data + 64) {\n+    %>\n+    while (end >= data + 64) <%\n         // Process full chunks directly from the source.\n         ripemd160::Transform(s, data);\n         bytes += 64;\n         data += 64;\n-    }\n-    if (end > data) {\n+    %>\n+    if (end > data) <%\n         // Fill the buffer with what remains.\n         memcpy(buf + bufsize, data, end - data);\n         bytes += end - data;\n-    }\n+    %>\n     return *this;\n-}\n+%>\n \n void CRIPEMD160::Finalize(unsigned char hash[OUTPUT_SIZE])\n-{\n-    static const unsigned char pad[64] = {0x80};\n+<%\n+    static const unsigned char pad[64] = <%0x80%>;\n     unsigned char sizedesc[8];\n     WriteLE64(sizedesc, bytes << 3);\n     Write(pad, 1 + ((119 - (bytes % 64)) % 64));\n@@ -282,11 +282,11 @@ void CRIPEMD160::Finalize(unsigned char hash[OUTPUT_SIZE])\n     WriteLE32(hash + 8, s[2]);\n     WriteLE32(hash + 12, s[3]);\n     WriteLE32(hash + 16, s[4]);\n-}\n+%>\n \n CRIPEMD160& CRIPEMD160::Reset()\n-{\n+<%\n     bytes = 0;\n     ripemd160::Initialize(s);\n     return *this;\n-}\n+%>"
      },
      {
        "sha": "0e8d37bcfea870d095d8256965015ad1b614161e",
        "filename": "src/crypto/ripemd160.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/ripemd160.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/ripemd160.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/ripemd160.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -10,7 +10,7 @@\n \n /** A hasher class for RIPEMD-160. */\n class CRIPEMD160\n-{\n+<%\n private:\n     uint32_t s[5];\n     unsigned char buf[64];\n@@ -23,6 +23,6 @@ class CRIPEMD160\n     CRIPEMD160& Write(const unsigned char* data, size_t len);\n     void Finalize(unsigned char hash[OUTPUT_SIZE]);\n     CRIPEMD160& Reset();\n-};\n+%>;\n \n #endif // BITCOIN_CRYPTO_RIPEMD160_H"
      },
      {
        "sha": "e98f8e76d702f662adc3d24ca94668a0336fcb7f",
        "filename": "src/crypto/sha1.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 29,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/sha1.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/sha1.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha1.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -10,32 +10,32 @@\n \n // Internal implementation code.\n namespace\n-{\n+<%\n /// Internal SHA-1 implementation.\n namespace sha1\n-{\n+<%\n /** One round of SHA-1. */\n void inline Round(uint32_t a, uint32_t& b, uint32_t c, uint32_t d, uint32_t& e, uint32_t f, uint32_t k, uint32_t w)\n-{\n+<%\n     e += ((a << 5) | (a >> 27)) + f + k + w;\n     b = (b << 30) | (b >> 2);\n-}\n+%>\n \n-uint32_t inline f1(uint32_t b, uint32_t c, uint32_t d) { return d ^ (b & (c ^ d)); }\n-uint32_t inline f2(uint32_t b, uint32_t c, uint32_t d) { return b ^ c ^ d; }\n-uint32_t inline f3(uint32_t b, uint32_t c, uint32_t d) { return (b & c) | (d & (b | c)); }\n+uint32_t inline f1(uint32_t b, uint32_t c, uint32_t d) <% return d ^ (b & (c ^ d)); %>\n+uint32_t inline f2(uint32_t b, uint32_t c, uint32_t d) <% return b ^ c ^ d; %>\n+uint32_t inline f3(uint32_t b, uint32_t c, uint32_t d) <% return (b & c) | (d & (b | c)); %>\n \n-uint32_t inline left(uint32_t x) { return (x << 1) | (x >> 31); }\n+uint32_t inline left(uint32_t x) <% return (x << 1) | (x >> 31); %>\n \n /** Initialize SHA-1 state. */\n void inline Initialize(uint32_t* s)\n-{\n+<%\n     s[0] = 0x67452301ul;\n     s[1] = 0xEFCDAB89ul;\n     s[2] = 0x98BADCFEul;\n     s[3] = 0x10325476ul;\n     s[4] = 0xC3D2E1F0ul;\n-}\n+%>\n \n const uint32_t k1 = 0x5A827999ul;\n const uint32_t k2 = 0x6ED9EBA1ul;\n@@ -44,7 +44,7 @@ const uint32_t k4 = 0xCA62C1D6ul;\n \n /** Perform a SHA-1 transformation, processing a 64-byte chunk. */\n void Transform(uint32_t* s, const unsigned char* chunk)\n-{\n+<%\n     uint32_t a = s[0], b = s[1], c = s[2], d = s[3], e = s[4];\n     uint32_t w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;\n \n@@ -138,48 +138,48 @@ void Transform(uint32_t* s, const unsigned char* chunk)\n     s[2] += c;\n     s[3] += d;\n     s[4] += e;\n-}\n+%>\n \n-} // namespace sha1\n+%> // namespace sha1\n \n-} // namespace\n+%> // namespace\n \n ////// SHA1\n \n CSHA1::CSHA1() : bytes(0)\n-{\n+<%\n     sha1::Initialize(s);\n-}\n+%>\n \n CSHA1& CSHA1::Write(const unsigned char* data, size_t len)\n-{\n+<%\n     const unsigned char* end = data + len;\n     size_t bufsize = bytes % 64;\n-    if (bufsize && bufsize + len >= 64) {\n+    if (bufsize && bufsize + len >= 64) <%\n         // Fill the buffer, and process it.\n         memcpy(buf + bufsize, data, 64 - bufsize);\n         bytes += 64 - bufsize;\n         data += 64 - bufsize;\n         sha1::Transform(s, buf);\n         bufsize = 0;\n-    }\n-    while (end >= data + 64) {\n+    %>\n+    while (end >= data + 64) <%\n         // Process full chunks directly from the source.\n         sha1::Transform(s, data);\n         bytes += 64;\n         data += 64;\n-    }\n-    if (end > data) {\n+    %>\n+    if (end > data) <%\n         // Fill the buffer with what remains.\n         memcpy(buf + bufsize, data, end - data);\n         bytes += end - data;\n-    }\n+    %>\n     return *this;\n-}\n+%>\n \n void CSHA1::Finalize(unsigned char hash[OUTPUT_SIZE])\n-{\n-    static const unsigned char pad[64] = {0x80};\n+<%\n+    static const unsigned char pad[64] = <%0x80%>;\n     unsigned char sizedesc[8];\n     WriteBE64(sizedesc, bytes << 3);\n     Write(pad, 1 + ((119 - (bytes % 64)) % 64));\n@@ -189,11 +189,11 @@ void CSHA1::Finalize(unsigned char hash[OUTPUT_SIZE])\n     WriteBE32(hash + 8, s[2]);\n     WriteBE32(hash + 12, s[3]);\n     WriteBE32(hash + 16, s[4]);\n-}\n+%>\n \n CSHA1& CSHA1::Reset()\n-{\n+<%\n     bytes = 0;\n     sha1::Initialize(s);\n     return *this;\n-}\n+%>"
      },
      {
        "sha": "371e6c2a885e88b93c265586df4257052a72f137",
        "filename": "src/crypto/sha1.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/sha1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/sha1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha1.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -10,7 +10,7 @@\n \n /** A hasher class for SHA1. */\n class CSHA1\n-{\n+<%\n private:\n     uint32_t s[5];\n     unsigned char buf[64];\n@@ -23,6 +23,6 @@ class CSHA1\n     CSHA1& Write(const unsigned char* data, size_t len);\n     void Finalize(unsigned char hash[OUTPUT_SIZE]);\n     CSHA1& Reset();\n-};\n+%>;\n \n #endif // BITCOIN_CRYPTO_SHA1_H"
      },
      {
        "sha": "fa097c26ac5ab0b8778688087919735ee5fa1bfd",
        "filename": "src/crypto/sha256.cpp",
        "status": "modified",
        "additions": 108,
        "deletions": 108,
        "changes": 216,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/sha256.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/sha256.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha256.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -13,57 +13,57 @@\n #if defined(USE_ASM)\n #include <cpuid.h>\n namespace sha256_sse4\n-{\n+<%\n void Transform(uint32_t* s, const unsigned char* chunk, size_t blocks);\n-}\n+%>\n #endif\n #endif\n \n namespace sha256d64_sse41\n-{\n+<%\n void Transform_4way(unsigned char* out, const unsigned char* in);\n-}\n+%>\n \n namespace sha256d64_avx2\n-{\n+<%\n void Transform_8way(unsigned char* out, const unsigned char* in);\n-}\n+%>\n \n namespace sha256d64_shani\n-{\n+<%\n void Transform_2way(unsigned char* out, const unsigned char* in);\n-}\n+%>\n \n namespace sha256_shani\n-{\n+<%\n void Transform(uint32_t* s, const unsigned char* chunk, size_t blocks);\n-}\n+%>\n \n // Internal implementation code.\n namespace\n-{\n+<%\n /// Internal SHA-256 implementation.\n namespace sha256\n-{\n-uint32_t inline Ch(uint32_t x, uint32_t y, uint32_t z) { return z ^ (x & (y ^ z)); }\n-uint32_t inline Maj(uint32_t x, uint32_t y, uint32_t z) { return (x & y) | (z & (x | y)); }\n-uint32_t inline Sigma0(uint32_t x) { return (x >> 2 | x << 30) ^ (x >> 13 | x << 19) ^ (x >> 22 | x << 10); }\n-uint32_t inline Sigma1(uint32_t x) { return (x >> 6 | x << 26) ^ (x >> 11 | x << 21) ^ (x >> 25 | x << 7); }\n-uint32_t inline sigma0(uint32_t x) { return (x >> 7 | x << 25) ^ (x >> 18 | x << 14) ^ (x >> 3); }\n-uint32_t inline sigma1(uint32_t x) { return (x >> 17 | x << 15) ^ (x >> 19 | x << 13) ^ (x >> 10); }\n+<%\n+uint32_t inline Ch(uint32_t x, uint32_t y, uint32_t z) <% return z ^ (x & (y ^ z)); %>\n+uint32_t inline Maj(uint32_t x, uint32_t y, uint32_t z) <% return (x & y) | (z & (x | y)); %>\n+uint32_t inline Sigma0(uint32_t x) <% return (x >> 2 | x << 30) ^ (x >> 13 | x << 19) ^ (x >> 22 | x << 10); %>\n+uint32_t inline Sigma1(uint32_t x) <% return (x >> 6 | x << 26) ^ (x >> 11 | x << 21) ^ (x >> 25 | x << 7); %>\n+uint32_t inline sigma0(uint32_t x) <% return (x >> 7 | x << 25) ^ (x >> 18 | x << 14) ^ (x >> 3); %>\n+uint32_t inline sigma1(uint32_t x) <% return (x >> 17 | x << 15) ^ (x >> 19 | x << 13) ^ (x >> 10); %>\n \n /** One round of SHA-256. */\n void inline Round(uint32_t a, uint32_t b, uint32_t c, uint32_t& d, uint32_t e, uint32_t f, uint32_t g, uint32_t& h, uint32_t k)\n-{\n+<%\n     uint32_t t1 = h + Sigma1(e) + Ch(e, f, g) + k;\n     uint32_t t2 = Sigma0(a) + Maj(a, b, c);\n     d += t1;\n     h = t1 + t2;\n-}\n+%>\n \n /** Initialize SHA-256 state. */\n void inline Initialize(uint32_t* s)\n-{\n+<%\n     s[0] = 0x6a09e667ul;\n     s[1] = 0xbb67ae85ul;\n     s[2] = 0x3c6ef372ul;\n@@ -72,12 +72,12 @@ void inline Initialize(uint32_t* s)\n     s[5] = 0x9b05688cul;\n     s[6] = 0x1f83d9abul;\n     s[7] = 0x5be0cd19ul;\n-}\n+%>\n \n /** Perform a number of SHA-256 transformations, processing 64-byte chunks. */\n void Transform(uint32_t* s, const unsigned char* chunk, size_t blocks)\n-{\n-    while (blocks--) {\n+<%\n+    while (blocks--) <%\n         uint32_t a = s[0], b = s[1], c = s[2], d = s[3], e = s[4], f = s[5], g = s[6], h = s[7];\n         uint32_t w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;\n \n@@ -158,11 +158,11 @@ void Transform(uint32_t* s, const unsigned char* chunk, size_t blocks)\n         s[6] += g;\n         s[7] += h;\n         chunk += 64;\n-    }\n-}\n+    %>\n+%>\n \n void TransformD64(unsigned char* out, const unsigned char* in)\n-{\n+<%\n     // Transform 1\n     uint32_t a = 0x6a09e667ul;\n     uint32_t b = 0xbb67ae85ul;\n@@ -410,29 +410,29 @@ void TransformD64(unsigned char* out, const unsigned char* in)\n     WriteBE32(out + 20, f + 0x9b05688cul);\n     WriteBE32(out + 24, g + 0x1f83d9abul);\n     WriteBE32(out + 28, h + 0x5be0cd19ul);\n-}\n+%>\n \n-} // namespace sha256\n+%> // namespace sha256\n \n typedef void (*TransformType)(uint32_t*, const unsigned char*, size_t);\n typedef void (*TransformD64Type)(unsigned char*, const unsigned char*);\n \n template<TransformType tr>\n void TransformD64Wrapper(unsigned char* out, const unsigned char* in)\n-{\n+<%\n     uint32_t s[8];\n-    static const unsigned char padding1[64] = {\n+    static const unsigned char padding1[64] = <%\n         0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n         0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n         0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n         0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0\n-    };\n-    unsigned char buffer2[64] = {\n+    %>;\n+    unsigned char buffer2[64] = <%\n         0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n         0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n         0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n         0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0\n-    };\n+    %>;\n     sha256::Initialize(s);\n     tr(s, in, 1);\n     tr(s, padding1, 1);\n@@ -454,19 +454,19 @@ void TransformD64Wrapper(unsigned char* out, const unsigned char* in)\n     WriteBE32(out + 20, s[5]);\n     WriteBE32(out + 24, s[6]);\n     WriteBE32(out + 28, s[7]);\n-}\n+%>\n \n TransformType Transform = sha256::Transform;\n TransformD64Type TransformD64 = sha256::TransformD64;\n TransformD64Type TransformD64_2way = nullptr;\n TransformD64Type TransformD64_4way = nullptr;\n TransformD64Type TransformD64_8way = nullptr;\n \n-bool SelfTest() {\n+bool SelfTest() <%\n     // Input state (equal to the initial SHA256 state)\n-    static const uint32_t init[8] = {\n+    static const uint32_t init[8] = <%\n         0x6a09e667ul, 0xbb67ae85ul, 0x3c6ef372ul, 0xa54ff53aul, 0x510e527ful, 0x9b05688cul, 0x1f83d9abul, 0x5be0cd19ul\n-    };\n+    %>;\n     // Some random input data to test with\n     static const unsigned char data[641] = \"-\" // Intentionally not aligned\n         \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do \"\n@@ -478,19 +478,19 @@ bool SelfTest() {\n         \" id velit. Telus in metus vulputate eu scelerisque felis. Mi tem\"\n         \"pus imperdiet nulla malesuada pellentesque. Tristique magna sit.\";\n     // Expected output state for hashing the i*64 first input bytes above (excluding SHA256 padding).\n-    static const uint32_t result[9][8] = {\n-        {0x6a09e667ul, 0xbb67ae85ul, 0x3c6ef372ul, 0xa54ff53aul, 0x510e527ful, 0x9b05688cul, 0x1f83d9abul, 0x5be0cd19ul},\n-        {0x91f8ec6bul, 0x4da10fe3ul, 0x1c9c292cul, 0x45e18185ul, 0x435cc111ul, 0x3ca26f09ul, 0xeb954caeul, 0x402a7069ul},\n-        {0xcabea5acul, 0x374fb97cul, 0x182ad996ul, 0x7bd69cbful, 0x450ff900ul, 0xc1d2be8aul, 0x6a41d505ul, 0xe6212dc3ul},\n-        {0xbcff09d6ul, 0x3e76f36eul, 0x3ecb2501ul, 0x78866e97ul, 0xe1c1e2fdul, 0x32f4eafful, 0x8aa6c4e5ul, 0xdfc024bcul},\n-        {0xa08c5d94ul, 0x0a862f93ul, 0x6b7f2f40ul, 0x8f9fae76ul, 0x6d40439ful, 0x79dcee0cul, 0x3e39ff3aul, 0xdc3bdbb1ul},\n-        {0x216a0895ul, 0x9f1a3662ul, 0xe99946f9ul, 0x87ba4364ul, 0x0fb5db2cul, 0x12bed3d3ul, 0x6689c0c7ul, 0x292f1b04ul},\n-        {0xca3067f8ul, 0xbc8c2656ul, 0x37cb7e0dul, 0x9b6b8b0ful, 0x46dc380bul, 0xf1287f57ul, 0xc42e4b23ul, 0x3fefe94dul},\n-        {0x3e4c4039ul, 0xbb6fca8cul, 0x6f27d2f7ul, 0x301e44a4ul, 0x8352ba14ul, 0x5769ce37ul, 0x48a1155ful, 0xc0e1c4c6ul},\n-        {0xfe2fa9ddul, 0x69d0862bul, 0x1ae0db23ul, 0x471f9244ul, 0xf55c0145ul, 0xc30f9c3bul, 0x40a84ea0ul, 0x5b8a266cul},\n-    };\n+    static const uint32_t result[9][8] = <%\n+        <%0x6a09e667ul, 0xbb67ae85ul, 0x3c6ef372ul, 0xa54ff53aul, 0x510e527ful, 0x9b05688cul, 0x1f83d9abul, 0x5be0cd19ul%>,\n+        <%0x91f8ec6bul, 0x4da10fe3ul, 0x1c9c292cul, 0x45e18185ul, 0x435cc111ul, 0x3ca26f09ul, 0xeb954caeul, 0x402a7069ul%>,\n+        <%0xcabea5acul, 0x374fb97cul, 0x182ad996ul, 0x7bd69cbful, 0x450ff900ul, 0xc1d2be8aul, 0x6a41d505ul, 0xe6212dc3ul%>,\n+        <%0xbcff09d6ul, 0x3e76f36eul, 0x3ecb2501ul, 0x78866e97ul, 0xe1c1e2fdul, 0x32f4eafful, 0x8aa6c4e5ul, 0xdfc024bcul%>,\n+        <%0xa08c5d94ul, 0x0a862f93ul, 0x6b7f2f40ul, 0x8f9fae76ul, 0x6d40439ful, 0x79dcee0cul, 0x3e39ff3aul, 0xdc3bdbb1ul%>,\n+        <%0x216a0895ul, 0x9f1a3662ul, 0xe99946f9ul, 0x87ba4364ul, 0x0fb5db2cul, 0x12bed3d3ul, 0x6689c0c7ul, 0x292f1b04ul%>,\n+        <%0xca3067f8ul, 0xbc8c2656ul, 0x37cb7e0dul, 0x9b6b8b0ful, 0x46dc380bul, 0xf1287f57ul, 0xc42e4b23ul, 0x3fefe94dul%>,\n+        <%0x3e4c4039ul, 0xbb6fca8cul, 0x6f27d2f7ul, 0x301e44a4ul, 0x8352ba14ul, 0x5769ce37ul, 0x48a1155ful, 0xc0e1c4c6ul%>,\n+        <%0xfe2fa9ddul, 0x69d0862bul, 0x1ae0db23ul, 0x471f9244ul, 0xf55c0145ul, 0xc30f9c3bul, 0x40a84ea0ul, 0x5b8a266cul%>,\n+    %>;\n     // Expected output for each of the individual 8 64-byte messages under full double SHA256 (including padding).\n-    static const unsigned char result_d64[256] = {\n+    static const unsigned char result_d64[256] = <%\n         0x09, 0x3a, 0xc4, 0xd0, 0x0f, 0xf7, 0x57, 0xe1, 0x72, 0x85, 0x79, 0x42, 0xfe, 0xe7, 0xe0, 0xa0,\n         0xfc, 0x52, 0xd7, 0xdb, 0x07, 0x63, 0x45, 0xfb, 0x53, 0x14, 0x7d, 0x17, 0x22, 0x86, 0xf0, 0x52,\n         0x48, 0xb6, 0x11, 0x9e, 0x6e, 0x48, 0x81, 0x6d, 0xcc, 0x57, 0x1f, 0xb2, 0x97, 0xa8, 0xd5, 0x25,\n@@ -507,71 +507,71 @@ bool SelfTest() {\n         0xb5, 0xac, 0x87, 0xa9, 0xf3, 0xff, 0x75, 0xf2, 0x34, 0xcd, 0x1a, 0x3b, 0x82, 0x2c, 0x2b, 0x4e,\n         0x6a, 0x46, 0x30, 0xa6, 0x89, 0x86, 0x23, 0xac, 0xf8, 0xa5, 0x15, 0xe9, 0x0a, 0xaa, 0x1e, 0x9a,\n         0xd7, 0x93, 0x6b, 0x28, 0xe4, 0x3b, 0xfd, 0x59, 0xc6, 0xed, 0x7c, 0x5f, 0xa5, 0x41, 0xcb, 0x51\n-    };\n+    %>;\n \n \n     // Test Transform() for 0 through 8 transformations.\n-    for (size_t i = 0; i <= 8; ++i) {\n+    for (size_t i = 0; i <= 8; ++i) <%\n         uint32_t state[8];\n         std::copy(init, init + 8, state);\n         Transform(state, data + 1, i);\n         if (!std::equal(state, state + 8, result[i])) return false;\n-    }\n+    %>\n \n     // Test TransformD64\n     unsigned char out[32];\n     TransformD64(out, data + 1);\n     if (!std::equal(out, out + 32, result_d64)) return false;\n \n     // Test TransformD64_2way, if available.\n-    if (TransformD64_2way) {\n+    if (TransformD64_2way) <%\n         unsigned char out[64];\n         TransformD64_2way(out, data + 1);\n         if (!std::equal(out, out + 64, result_d64)) return false;\n-    }\n+    %>\n \n     // Test TransformD64_4way, if available.\n-    if (TransformD64_4way) {\n+    if (TransformD64_4way) <%\n         unsigned char out[128];\n         TransformD64_4way(out, data + 1);\n         if (!std::equal(out, out + 128, result_d64)) return false;\n-    }\n+    %>\n \n     // Test TransformD64_8way, if available.\n-    if (TransformD64_8way) {\n+    if (TransformD64_8way) <%\n         unsigned char out[256];\n         TransformD64_8way(out, data + 1);\n         if (!std::equal(out, out + 256, result_d64)) return false;\n-    }\n+    %>\n \n     return true;\n-}\n+%>\n \n \n #if defined(USE_ASM) && (defined(__x86_64__) || defined(__amd64__) || defined(__i386__))\n // We can't use cpuid.h's __get_cpuid as it does not support subleafs.\n void inline cpuid(uint32_t leaf, uint32_t subleaf, uint32_t& a, uint32_t& b, uint32_t& c, uint32_t& d)\n-{\n+<%\n #ifdef __GNUC__\n     __cpuid_count(leaf, subleaf, a, b, c, d);\n #else\n   __asm__ (\"cpuid\" : \"=a\"(a), \"=b\"(b), \"=c\"(c), \"=d\"(d) : \"0\"(leaf), \"2\"(subleaf));\n #endif\n-}\n+%>\n \n /** Check whether the OS has enabled AVX registers. */\n bool AVXEnabled()\n-{\n+<%\n     uint32_t a, d;\n     __asm__(\"xgetbv\" : \"=a\"(a), \"=d\"(d) : \"c\"(0));\n     return (a & 6) == 6;\n-}\n+%>\n #endif\n-} // namespace\n+%> // namespace\n \n \n std::string SHA256AutoDetect()\n-{\n+<%\n     std::string ret = \"standard\";\n #if defined(USE_ASM) && (defined(__x86_64__) || defined(__amd64__) || defined(__i386__))\n     bool have_sse4 = false;\n@@ -594,27 +594,27 @@ std::string SHA256AutoDetect()\n     have_sse4 = (ecx >> 19) & 1;\n     have_xsave = (ecx >> 27) & 1;\n     have_avx = (ecx >> 28) & 1;\n-    if (have_xsave && have_avx) {\n+    if (have_xsave && have_avx) <%\n         enabled_avx = AVXEnabled();\n-    }\n-    if (have_sse4) {\n+    %>\n+    if (have_sse4) <%\n         cpuid(7, 0, eax, ebx, ecx, edx);\n         have_avx2 = (ebx >> 5) & 1;\n         have_shani = (ebx >> 29) & 1;\n-    }\n+    %>\n \n #if defined(ENABLE_SHANI) && !defined(BUILD_BITCOIN_INTERNAL)\n-    if (have_shani) {\n+    if (have_shani) <%\n         Transform = sha256_shani::Transform;\n         TransformD64 = TransformD64Wrapper<sha256_shani::Transform>;\n         TransformD64_2way = sha256d64_shani::Transform_2way;\n         ret = \"shani(1way,2way)\";\n         have_sse4 = false; // Disable SSE4/AVX2;\n         have_avx2 = false;\n-    }\n+    %>\n #endif\n \n-    if (have_sse4) {\n+    if (have_sse4) <%\n #if defined(__x86_64__) || defined(__amd64__)\n         Transform = sha256_sse4::Transform;\n         TransformD64 = TransformD64Wrapper<sha256_sse4::Transform>;\n@@ -624,56 +624,56 @@ std::string SHA256AutoDetect()\n         TransformD64_4way = sha256d64_sse41::Transform_4way;\n         ret += \",sse41(4way)\";\n #endif\n-    }\n+    %>\n \n #if defined(ENABLE_AVX2) && !defined(BUILD_BITCOIN_INTERNAL)\n-    if (have_avx2 && have_avx && enabled_avx) {\n+    if (have_avx2 && have_avx && enabled_avx) <%\n         TransformD64_8way = sha256d64_avx2::Transform_8way;\n         ret += \",avx2(8way)\";\n-    }\n+    %>\n #endif\n #endif\n \n     assert(SelfTest());\n     return ret;\n-}\n+%>\n \n ////// SHA-256\n \n CSHA256::CSHA256() : bytes(0)\n-{\n+<%\n     sha256::Initialize(s);\n-}\n+%>\n \n CSHA256& CSHA256::Write(const unsigned char* data, size_t len)\n-{\n+<%\n     const unsigned char* end = data + len;\n     size_t bufsize = bytes % 64;\n-    if (bufsize && bufsize + len >= 64) {\n+    if (bufsize && bufsize + len >= 64) <%\n         // Fill the buffer, and process it.\n         memcpy(buf + bufsize, data, 64 - bufsize);\n         bytes += 64 - bufsize;\n         data += 64 - bufsize;\n         Transform(s, buf, 1);\n         bufsize = 0;\n-    }\n-    if (end - data >= 64) {\n+    %>\n+    if (end - data >= 64) <%\n         size_t blocks = (end - data) / 64;\n         Transform(s, data, blocks);\n         data += 64 * blocks;\n         bytes += 64 * blocks;\n-    }\n-    if (end > data) {\n+    %>\n+    if (end > data) <%\n         // Fill the buffer with what remains.\n         memcpy(buf + bufsize, data, end - data);\n         bytes += end - data;\n-    }\n+    %>\n     return *this;\n-}\n+%>\n \n void CSHA256::Finalize(unsigned char hash[OUTPUT_SIZE])\n-{\n-    static const unsigned char pad[64] = {0x80};\n+<%\n+    static const unsigned char pad[64] = <%0x80%>;\n     unsigned char sizedesc[8];\n     WriteBE64(sizedesc, bytes << 3);\n     Write(pad, 1 + ((119 - (bytes % 64)) % 64));\n@@ -686,45 +686,45 @@ void CSHA256::Finalize(unsigned char hash[OUTPUT_SIZE])\n     WriteBE32(hash + 20, s[5]);\n     WriteBE32(hash + 24, s[6]);\n     WriteBE32(hash + 28, s[7]);\n-}\n+%>\n \n CSHA256& CSHA256::Reset()\n-{\n+<%\n     bytes = 0;\n     sha256::Initialize(s);\n     return *this;\n-}\n+%>\n \n void SHA256D64(unsigned char* out, const unsigned char* in, size_t blocks)\n-{\n-    if (TransformD64_8way) {\n-        while (blocks >= 8) {\n+<%\n+    if (TransformD64_8way) <%\n+        while (blocks >= 8) <%\n             TransformD64_8way(out, in);\n             out += 256;\n             in += 512;\n             blocks -= 8;\n-        }\n-    }\n-    if (TransformD64_4way) {\n-        while (blocks >= 4) {\n+        %>\n+    %>\n+    if (TransformD64_4way) <%\n+        while (blocks >= 4) <%\n             TransformD64_4way(out, in);\n             out += 128;\n             in += 256;\n             blocks -= 4;\n-        }\n-    }\n-    if (TransformD64_2way) {\n-        while (blocks >= 2) {\n+        %>\n+    %>\n+    if (TransformD64_2way) <%\n+        while (blocks >= 2) <%\n             TransformD64_2way(out, in);\n             out += 64;\n             in += 128;\n             blocks -= 2;\n-        }\n-    }\n-    while (blocks) {\n+        %>\n+    %>\n+    while (blocks) <%\n         TransformD64(out, in);\n         out += 32;\n         in += 64;\n         --blocks;\n-    }\n-}\n+    %>\n+%>"
      },
      {
        "sha": "867569fd2cd7c562d62eddacd3111601f7d6917c",
        "filename": "src/crypto/sha256.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/sha256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/sha256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha256.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -11,7 +11,7 @@\n \n /** A hasher class for SHA-256. */\n class CSHA256\n-{\n+<%\n private:\n     uint32_t s[8];\n     unsigned char buf[64];\n@@ -24,7 +24,7 @@ class CSHA256\n     CSHA256& Write(const unsigned char* data, size_t len);\n     void Finalize(unsigned char hash[OUTPUT_SIZE]);\n     CSHA256& Reset();\n-};\n+%>;\n \n /** Autodetect the best available SHA256 implementation.\n  *  Returns the name of the implementation."
      },
      {
        "sha": "88af148e35f46b8c8368841efa25c144477f72a5",
        "filename": "src/crypto/sha256_avx2.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 32,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/sha256_avx2.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/sha256_avx2.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha256_avx2.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -6,42 +6,42 @@\n #include <crypto/sha256.h>\n #include <crypto/common.h>\n \n-namespace sha256d64_avx2 {\n-namespace {\n+namespace sha256d64_avx2 <%\n+namespace <%\n \n-__m256i inline K(uint32_t x) { return _mm256_set1_epi32(x); }\n+__m256i inline K(uint32_t x) <% return _mm256_set1_epi32(x); %>\n \n-__m256i inline Add(__m256i x, __m256i y) { return _mm256_add_epi32(x, y); }\n-__m256i inline Add(__m256i x, __m256i y, __m256i z) { return Add(Add(x, y), z); }\n-__m256i inline Add(__m256i x, __m256i y, __m256i z, __m256i w) { return Add(Add(x, y), Add(z, w)); }\n-__m256i inline Add(__m256i x, __m256i y, __m256i z, __m256i w, __m256i v) { return Add(Add(x, y, z), Add(w, v)); }\n-__m256i inline Inc(__m256i& x, __m256i y) { x = Add(x, y); return x; }\n-__m256i inline Inc(__m256i& x, __m256i y, __m256i z) { x = Add(x, y, z); return x; }\n-__m256i inline Inc(__m256i& x, __m256i y, __m256i z, __m256i w) { x = Add(x, y, z, w); return x; }\n-__m256i inline Xor(__m256i x, __m256i y) { return _mm256_xor_si256(x, y); }\n-__m256i inline Xor(__m256i x, __m256i y, __m256i z) { return Xor(Xor(x, y), z); }\n-__m256i inline Or(__m256i x, __m256i y) { return _mm256_or_si256(x, y); }\n-__m256i inline And(__m256i x, __m256i y) { return _mm256_and_si256(x, y); }\n-__m256i inline ShR(__m256i x, int n) { return _mm256_srli_epi32(x, n); }\n-__m256i inline ShL(__m256i x, int n) { return _mm256_slli_epi32(x, n); }\n+__m256i inline Add(__m256i x, __m256i y) <% return _mm256_add_epi32(x, y); %>\n+__m256i inline Add(__m256i x, __m256i y, __m256i z) <% return Add(Add(x, y), z); %>\n+__m256i inline Add(__m256i x, __m256i y, __m256i z, __m256i w) <% return Add(Add(x, y), Add(z, w)); %>\n+__m256i inline Add(__m256i x, __m256i y, __m256i z, __m256i w, __m256i v) <% return Add(Add(x, y, z), Add(w, v)); %>\n+__m256i inline Inc(__m256i& x, __m256i y) <% x = Add(x, y); return x; %>\n+__m256i inline Inc(__m256i& x, __m256i y, __m256i z) <% x = Add(x, y, z); return x; %>\n+__m256i inline Inc(__m256i& x, __m256i y, __m256i z, __m256i w) <% x = Add(x, y, z, w); return x; %>\n+__m256i inline Xor(__m256i x, __m256i y) <% return _mm256_xor_si256(x, y); %>\n+__m256i inline Xor(__m256i x, __m256i y, __m256i z) <% return Xor(Xor(x, y), z); %>\n+__m256i inline Or(__m256i x, __m256i y) <% return _mm256_or_si256(x, y); %>\n+__m256i inline And(__m256i x, __m256i y) <% return _mm256_and_si256(x, y); %>\n+__m256i inline ShR(__m256i x, int n) <% return _mm256_srli_epi32(x, n); %>\n+__m256i inline ShL(__m256i x, int n) <% return _mm256_slli_epi32(x, n); %>\n \n-__m256i inline Ch(__m256i x, __m256i y, __m256i z) { return Xor(z, And(x, Xor(y, z))); }\n-__m256i inline Maj(__m256i x, __m256i y, __m256i z) { return Or(And(x, y), And(z, Or(x, y))); }\n-__m256i inline Sigma0(__m256i x) { return Xor(Or(ShR(x, 2), ShL(x, 30)), Or(ShR(x, 13), ShL(x, 19)), Or(ShR(x, 22), ShL(x, 10))); }\n-__m256i inline Sigma1(__m256i x) { return Xor(Or(ShR(x, 6), ShL(x, 26)), Or(ShR(x, 11), ShL(x, 21)), Or(ShR(x, 25), ShL(x, 7))); }\n-__m256i inline sigma0(__m256i x) { return Xor(Or(ShR(x, 7), ShL(x, 25)), Or(ShR(x, 18), ShL(x, 14)), ShR(x, 3)); }\n-__m256i inline sigma1(__m256i x) { return Xor(Or(ShR(x, 17), ShL(x, 15)), Or(ShR(x, 19), ShL(x, 13)), ShR(x, 10)); }\n+__m256i inline Ch(__m256i x, __m256i y, __m256i z) <% return Xor(z, And(x, Xor(y, z))); %>\n+__m256i inline Maj(__m256i x, __m256i y, __m256i z) <% return Or(And(x, y), And(z, Or(x, y))); %>\n+__m256i inline Sigma0(__m256i x) <% return Xor(Or(ShR(x, 2), ShL(x, 30)), Or(ShR(x, 13), ShL(x, 19)), Or(ShR(x, 22), ShL(x, 10))); %>\n+__m256i inline Sigma1(__m256i x) <% return Xor(Or(ShR(x, 6), ShL(x, 26)), Or(ShR(x, 11), ShL(x, 21)), Or(ShR(x, 25), ShL(x, 7))); %>\n+__m256i inline sigma0(__m256i x) <% return Xor(Or(ShR(x, 7), ShL(x, 25)), Or(ShR(x, 18), ShL(x, 14)), ShR(x, 3)); %>\n+__m256i inline sigma1(__m256i x) <% return Xor(Or(ShR(x, 17), ShL(x, 15)), Or(ShR(x, 19), ShL(x, 13)), ShR(x, 10)); %>\n \n /** One round of SHA-256. */\n void inline __attribute__((always_inline)) Round(__m256i a, __m256i b, __m256i c, __m256i& d, __m256i e, __m256i f, __m256i g, __m256i& h, __m256i k)\n-{\n+<%\n     __m256i t1 = Add(h, Sigma1(e), Ch(e, f, g), k);\n     __m256i t2 = Add(Sigma0(a), Maj(a, b, c));\n     d = Add(d, t1);\n     h = Add(t1, t2);\n-}\n+%>\n \n-__m256i inline Read8(const unsigned char* chunk, int offset) {\n+__m256i inline Read8(const unsigned char* chunk, int offset) <%\n     __m256i ret = _mm256_set_epi32(\n         ReadLE32(chunk + 0 + offset),\n         ReadLE32(chunk + 64 + offset),\n@@ -53,9 +53,9 @@ __m256i inline Read8(const unsigned char* chunk, int offset) {\n         ReadLE32(chunk + 448 + offset)\n     );\n     return _mm256_shuffle_epi8(ret, _mm256_set_epi32(0x0C0D0E0FUL, 0x08090A0BUL, 0x04050607UL, 0x00010203UL, 0x0C0D0E0FUL, 0x08090A0BUL, 0x04050607UL, 0x00010203UL));\n-}\n+%>\n \n-void inline Write8(unsigned char* out, int offset, __m256i v) {\n+void inline Write8(unsigned char* out, int offset, __m256i v) <%\n     v = _mm256_shuffle_epi8(v, _mm256_set_epi32(0x0C0D0E0FUL, 0x08090A0BUL, 0x04050607UL, 0x00010203UL, 0x0C0D0E0FUL, 0x08090A0BUL, 0x04050607UL, 0x00010203UL));\n     WriteLE32(out + 0 + offset, _mm256_extract_epi32(v, 7));\n     WriteLE32(out + 32 + offset, _mm256_extract_epi32(v, 6));\n@@ -65,12 +65,12 @@ void inline Write8(unsigned char* out, int offset, __m256i v) {\n     WriteLE32(out + 160 + offset, _mm256_extract_epi32(v, 2));\n     WriteLE32(out + 192 + offset, _mm256_extract_epi32(v, 1));\n     WriteLE32(out + 224 + offset, _mm256_extract_epi32(v, 0));\n-}\n+%>\n \n-}\n+%>\n \n void Transform_8way(unsigned char* out, const unsigned char* in)\n-{\n+<%\n     // Transform 1\n     __m256i a = K(0x6a09e667ul);\n     __m256i b = K(0xbb67ae85ul);\n@@ -318,8 +318,8 @@ void Transform_8way(unsigned char* out, const unsigned char* in)\n     Write8(out, 20, Add(f, K(0x9b05688cul)));\n     Write8(out, 24, Add(g, K(0x1f83d9abul)));\n     Write8(out, 28, Add(h, K(0x5be0cd19ul)));\n-}\n+%>\n \n-}\n+%>\n \n #endif"
      },
      {
        "sha": "59a53067db6a93fdfa822f3a710fa60485003ddd",
        "filename": "src/crypto/sha256_shani.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 30,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/sha256_shani.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/sha256_shani.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha256_shani.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -14,80 +14,80 @@\n #include <crypto/common.h>\n \n \n-namespace {\n+namespace <%\n \n const __m128i MASK = _mm_set_epi64x(0x0c0d0e0f08090a0bULL, 0x0405060700010203ULL);\n const __m128i INIT0 = _mm_set_epi64x(0x6a09e667bb67ae85ull, 0x510e527f9b05688cull);\n const __m128i INIT1 = _mm_set_epi64x(0x3c6ef372a54ff53aull, 0x1f83d9ab5be0cd19ull);\n \n void inline  __attribute__((always_inline)) QuadRound(__m128i& state0, __m128i& state1, uint64_t k1, uint64_t k0)\n-{\n+<%\n     const __m128i msg = _mm_set_epi64x(k1, k0);\n     state1 = _mm_sha256rnds2_epu32(state1, state0, msg);\n     state0 = _mm_sha256rnds2_epu32(state0, state1, _mm_shuffle_epi32(msg, 0x0e));\n-}\n+%>\n \n void inline  __attribute__((always_inline)) QuadRound(__m128i& state0, __m128i& state1, __m128i m, uint64_t k1, uint64_t k0)\n-{\n+<%\n     const __m128i msg = _mm_add_epi32(m, _mm_set_epi64x(k1, k0));\n     state1 = _mm_sha256rnds2_epu32(state1, state0, msg);\n     state0 = _mm_sha256rnds2_epu32(state0, state1, _mm_shuffle_epi32(msg, 0x0e));\n-}\n+%>\n \n void inline  __attribute__((always_inline)) ShiftMessageA(__m128i& m0, __m128i m1)\n-{\n+<%\n     m0 = _mm_sha256msg1_epu32(m0, m1);\n-}\n+%>\n \n void inline  __attribute__((always_inline)) ShiftMessageC(__m128i& m0, __m128i m1, __m128i& m2)\n-{\n+<%\n     m2 = _mm_sha256msg2_epu32(_mm_add_epi32(m2, _mm_alignr_epi8(m1, m0, 4)), m1);\n-}\n+%>\n \n void inline __attribute__((always_inline)) ShiftMessageB(__m128i& m0, __m128i m1, __m128i& m2)\n-{\n+<%\n     ShiftMessageC(m0, m1, m2);\n     ShiftMessageA(m0, m1);\n-}\n+%>\n \n void inline __attribute__((always_inline)) Shuffle(__m128i& s0, __m128i& s1)\n-{\n+<%\n     const __m128i t1 = _mm_shuffle_epi32(s0, 0xB1);\n     const __m128i t2 = _mm_shuffle_epi32(s1, 0x1B);\n     s0 = _mm_alignr_epi8(t1, t2, 0x08);\n     s1 = _mm_blend_epi16(t2, t1, 0xF0);\n-}\n+%>\n \n void inline __attribute__((always_inline)) Unshuffle(__m128i& s0, __m128i& s1)\n-{\n+<%\n     const __m128i t1 = _mm_shuffle_epi32(s0, 0x1B);\n     const __m128i t2 = _mm_shuffle_epi32(s1, 0xB1);\n     s0 = _mm_blend_epi16(t1, t2, 0xF0);\n     s1 = _mm_alignr_epi8(t2, t1, 0x08);\n-}\n+%>\n \n __m128i inline  __attribute__((always_inline)) Load(const unsigned char* in)\n-{\n+<%\n     return _mm_shuffle_epi8(_mm_loadu_si128((const __m128i*)in), MASK);\n-}\n+%>\n \n void inline  __attribute__((always_inline)) Save(unsigned char* out, __m128i s)\n-{\n+<%\n     _mm_storeu_si128((__m128i*)out, _mm_shuffle_epi8(s, MASK));\n-}\n-}\n+%>\n+%>\n \n-namespace sha256_shani {\n+namespace sha256_shani <%\n void Transform(uint32_t* s, const unsigned char* chunk, size_t blocks)\n-{\n+<%\n     __m128i m0, m1, m2, m3, s0, s1, so0, so1;\n \n     /* Load state */\n     s0 = _mm_loadu_si128((const __m128i*)s);\n     s1 = _mm_loadu_si128((const __m128i*)(s + 4));\n     Shuffle(s0, s1);\n \n-    while (blocks--) {\n+    while (blocks--) <%\n         /* Remember old state */\n         so0 = s0;\n         so1 = s1;\n@@ -134,18 +134,18 @@ void Transform(uint32_t* s, const unsigned char* chunk, size_t blocks)\n \n         /* Advance */\n         chunk += 64;\n-    }\n+    %>\n \n     Unshuffle(s0, s1);\n     _mm_storeu_si128((__m128i*)s, s0);\n     _mm_storeu_si128((__m128i*)(s + 4), s1);\n-}\n-}\n+%>\n+%>\n \n-namespace sha256d64_shani {\n+namespace sha256d64_shani <%\n \n void Transform_2way(unsigned char* out, const unsigned char* in)\n-{\n+<%\n     __m128i am0, am1, am2, am3, as0, as1, aso0, aso1;\n     __m128i bm0, bm1, bm2, bm3, bs0, bs1, bso0, bso1;\n \n@@ -352,8 +352,8 @@ void Transform_2way(unsigned char* out, const unsigned char* in)\n     Save(out + 16, as1);\n     Save(out + 32, bs0);\n     Save(out + 48, bs1);\n-}\n+%>\n \n-}\n+%>\n \n #endif"
      },
      {
        "sha": "7908b414dc6d2d8ecf6c635ae7047c8095841d81",
        "filename": "src/crypto/sha256_sse4.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/sha256_sse4.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/sha256_sse4.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha256_sse4.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -11,10 +11,10 @@\n #if defined(__x86_64__) || defined(__amd64__)\n \n namespace sha256_sse4\n-{\n+<%\n void Transform(uint32_t* s, const unsigned char* chunk, size_t blocks)\n-{\n-    static const uint32_t K256 alignas(16) [] = {\n+<%\n+    static const uint32_t K256 alignas(16) [] = <%\n         0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n         0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n         0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n@@ -31,10 +31,10 @@ void Transform(uint32_t* s, const unsigned char* chunk, size_t blocks)\n         0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n         0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n         0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,\n-    };\n-    static const uint32_t FLIP_MASK alignas(16) [] = {0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f};\n-    static const uint32_t SHUF_00BA alignas(16) [] = {0x03020100, 0x0b0a0908, 0xffffffff, 0xffffffff};\n-    static const uint32_t SHUF_DC00 alignas(16) [] = {0xffffffff, 0xffffffff, 0x03020100, 0x0b0a0908};\n+    %>;\n+    static const uint32_t FLIP_MASK alignas(16) [] = <%0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f%>;\n+    static const uint32_t SHUF_00BA alignas(16) [] = <%0x03020100, 0x0b0a0908, 0xffffffff, 0xffffffff%>;\n+    static const uint32_t SHUF_DC00 alignas(16) [] = <%0xffffffff, 0xffffffff, 0x03020100, 0x0b0a0908%>;\n     uint32_t a, b, c, d, f, g, h, y0, y1, y2;\n     uint64_t tbl;\n     uint64_t inp_end, inp;\n@@ -953,8 +953,8 @@ void Transform(uint32_t* s, const unsigned char* chunk, size_t blocks)\n         : \"m\"(K256), \"m\"(FLIP_MASK), \"m\"(SHUF_00BA), \"m\"(SHUF_DC00)\n         : \"cc\", \"memory\", \"xmm0\", \"xmm1\", \"xmm2\", \"xmm3\", \"xmm4\", \"xmm5\", \"xmm6\", \"xmm7\", \"xmm8\", \"xmm9\", \"xmm10\", \"xmm11\", \"xmm12\"\n    );\n-}\n-}\n+%>\n+%>\n \n /*\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"
      },
      {
        "sha": "7193554f2eeef23af22ab4c299e597667b2f6839",
        "filename": "src/crypto/sha256_sse41.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 32,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/sha256_sse41.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/sha256_sse41.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha256_sse41.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -6,63 +6,63 @@\n #include <crypto/sha256.h>\n #include <crypto/common.h>\n \n-namespace sha256d64_sse41 {\n-namespace {\n+namespace sha256d64_sse41 <%\n+namespace <%\n \n-__m128i inline K(uint32_t x) { return _mm_set1_epi32(x); }\n+__m128i inline K(uint32_t x) <% return _mm_set1_epi32(x); %>\n \n-__m128i inline Add(__m128i x, __m128i y) { return _mm_add_epi32(x, y); }\n-__m128i inline Add(__m128i x, __m128i y, __m128i z) { return Add(Add(x, y), z); }\n-__m128i inline Add(__m128i x, __m128i y, __m128i z, __m128i w) { return Add(Add(x, y), Add(z, w)); }\n-__m128i inline Add(__m128i x, __m128i y, __m128i z, __m128i w, __m128i v) { return Add(Add(x, y, z), Add(w, v)); }\n-__m128i inline Inc(__m128i& x, __m128i y) { x = Add(x, y); return x; }\n-__m128i inline Inc(__m128i& x, __m128i y, __m128i z) { x = Add(x, y, z); return x; }\n-__m128i inline Inc(__m128i& x, __m128i y, __m128i z, __m128i w) { x = Add(x, y, z, w); return x; }\n-__m128i inline Xor(__m128i x, __m128i y) { return _mm_xor_si128(x, y); }\n-__m128i inline Xor(__m128i x, __m128i y, __m128i z) { return Xor(Xor(x, y), z); }\n-__m128i inline Or(__m128i x, __m128i y) { return _mm_or_si128(x, y); }\n-__m128i inline And(__m128i x, __m128i y) { return _mm_and_si128(x, y); }\n-__m128i inline ShR(__m128i x, int n) { return _mm_srli_epi32(x, n); }\n-__m128i inline ShL(__m128i x, int n) { return _mm_slli_epi32(x, n); }\n+__m128i inline Add(__m128i x, __m128i y) <% return _mm_add_epi32(x, y); %>\n+__m128i inline Add(__m128i x, __m128i y, __m128i z) <% return Add(Add(x, y), z); %>\n+__m128i inline Add(__m128i x, __m128i y, __m128i z, __m128i w) <% return Add(Add(x, y), Add(z, w)); %>\n+__m128i inline Add(__m128i x, __m128i y, __m128i z, __m128i w, __m128i v) <% return Add(Add(x, y, z), Add(w, v)); %>\n+__m128i inline Inc(__m128i& x, __m128i y) <% x = Add(x, y); return x; %>\n+__m128i inline Inc(__m128i& x, __m128i y, __m128i z) <% x = Add(x, y, z); return x; %>\n+__m128i inline Inc(__m128i& x, __m128i y, __m128i z, __m128i w) <% x = Add(x, y, z, w); return x; %>\n+__m128i inline Xor(__m128i x, __m128i y) <% return _mm_xor_si128(x, y); %>\n+__m128i inline Xor(__m128i x, __m128i y, __m128i z) <% return Xor(Xor(x, y), z); %>\n+__m128i inline Or(__m128i x, __m128i y) <% return _mm_or_si128(x, y); %>\n+__m128i inline And(__m128i x, __m128i y) <% return _mm_and_si128(x, y); %>\n+__m128i inline ShR(__m128i x, int n) <% return _mm_srli_epi32(x, n); %>\n+__m128i inline ShL(__m128i x, int n) <% return _mm_slli_epi32(x, n); %>\n \n-__m128i inline Ch(__m128i x, __m128i y, __m128i z) { return Xor(z, And(x, Xor(y, z))); }\n-__m128i inline Maj(__m128i x, __m128i y, __m128i z) { return Or(And(x, y), And(z, Or(x, y))); }\n-__m128i inline Sigma0(__m128i x) { return Xor(Or(ShR(x, 2), ShL(x, 30)), Or(ShR(x, 13), ShL(x, 19)), Or(ShR(x, 22), ShL(x, 10))); }\n-__m128i inline Sigma1(__m128i x) { return Xor(Or(ShR(x, 6), ShL(x, 26)), Or(ShR(x, 11), ShL(x, 21)), Or(ShR(x, 25), ShL(x, 7))); }\n-__m128i inline sigma0(__m128i x) { return Xor(Or(ShR(x, 7), ShL(x, 25)), Or(ShR(x, 18), ShL(x, 14)), ShR(x, 3)); }\n-__m128i inline sigma1(__m128i x) { return Xor(Or(ShR(x, 17), ShL(x, 15)), Or(ShR(x, 19), ShL(x, 13)), ShR(x, 10)); }\n+__m128i inline Ch(__m128i x, __m128i y, __m128i z) <% return Xor(z, And(x, Xor(y, z))); %>\n+__m128i inline Maj(__m128i x, __m128i y, __m128i z) <% return Or(And(x, y), And(z, Or(x, y))); %>\n+__m128i inline Sigma0(__m128i x) <% return Xor(Or(ShR(x, 2), ShL(x, 30)), Or(ShR(x, 13), ShL(x, 19)), Or(ShR(x, 22), ShL(x, 10))); %>\n+__m128i inline Sigma1(__m128i x) <% return Xor(Or(ShR(x, 6), ShL(x, 26)), Or(ShR(x, 11), ShL(x, 21)), Or(ShR(x, 25), ShL(x, 7))); %>\n+__m128i inline sigma0(__m128i x) <% return Xor(Or(ShR(x, 7), ShL(x, 25)), Or(ShR(x, 18), ShL(x, 14)), ShR(x, 3)); %>\n+__m128i inline sigma1(__m128i x) <% return Xor(Or(ShR(x, 17), ShL(x, 15)), Or(ShR(x, 19), ShL(x, 13)), ShR(x, 10)); %>\n \n /** One round of SHA-256. */\n void inline __attribute__((always_inline)) Round(__m128i a, __m128i b, __m128i c, __m128i& d, __m128i e, __m128i f, __m128i g, __m128i& h, __m128i k)\n-{\n+<%\n     __m128i t1 = Add(h, Sigma1(e), Ch(e, f, g), k);\n     __m128i t2 = Add(Sigma0(a), Maj(a, b, c));\n     d = Add(d, t1);\n     h = Add(t1, t2);\n-}\n+%>\n \n-__m128i inline Read4(const unsigned char* chunk, int offset) {\n+__m128i inline Read4(const unsigned char* chunk, int offset) <%\n     __m128i ret = _mm_set_epi32(\n         ReadLE32(chunk + 0 + offset),\n         ReadLE32(chunk + 64 + offset),\n         ReadLE32(chunk + 128 + offset),\n         ReadLE32(chunk + 192 + offset)\n     );\n     return _mm_shuffle_epi8(ret, _mm_set_epi32(0x0C0D0E0FUL, 0x08090A0BUL, 0x04050607UL, 0x00010203UL));\n-}\n+%>\n \n-void inline Write4(unsigned char* out, int offset, __m128i v) {\n+void inline Write4(unsigned char* out, int offset, __m128i v) <%\n     v = _mm_shuffle_epi8(v, _mm_set_epi32(0x0C0D0E0FUL, 0x08090A0BUL, 0x04050607UL, 0x00010203UL));\n     WriteLE32(out + 0 + offset, _mm_extract_epi32(v, 3));\n     WriteLE32(out + 32 + offset, _mm_extract_epi32(v, 2));\n     WriteLE32(out + 64 + offset, _mm_extract_epi32(v, 1));\n     WriteLE32(out + 96 + offset, _mm_extract_epi32(v, 0));\n-}\n+%>\n \n-}\n+%>\n \n void Transform_4way(unsigned char* out, const unsigned char* in)\n-{\n+<%\n     // Transform 1\n     __m128i a = K(0x6a09e667ul);\n     __m128i b = K(0xbb67ae85ul);\n@@ -310,8 +310,8 @@ void Transform_4way(unsigned char* out, const unsigned char* in)\n     Write4(out, 20, Add(f, K(0x9b05688cul)));\n     Write4(out, 24, Add(g, K(0x1f83d9abul)));\n     Write4(out, 28, Add(h, K(0x5be0cd19ul)));\n-}\n+%>\n \n-}\n+%>\n \n #endif"
      },
      {
        "sha": "79e8c257912f646937de3baabb651c44a05d8746",
        "filename": "src/crypto/sha512.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 32,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/sha512.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/sha512.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha512.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -10,29 +10,29 @@\n \n // Internal implementation code.\n namespace\n-{\n+<%\n /// Internal SHA-512 implementation.\n namespace sha512\n-{\n-uint64_t inline Ch(uint64_t x, uint64_t y, uint64_t z) { return z ^ (x & (y ^ z)); }\n-uint64_t inline Maj(uint64_t x, uint64_t y, uint64_t z) { return (x & y) | (z & (x | y)); }\n-uint64_t inline Sigma0(uint64_t x) { return (x >> 28 | x << 36) ^ (x >> 34 | x << 30) ^ (x >> 39 | x << 25); }\n-uint64_t inline Sigma1(uint64_t x) { return (x >> 14 | x << 50) ^ (x >> 18 | x << 46) ^ (x >> 41 | x << 23); }\n-uint64_t inline sigma0(uint64_t x) { return (x >> 1 | x << 63) ^ (x >> 8 | x << 56) ^ (x >> 7); }\n-uint64_t inline sigma1(uint64_t x) { return (x >> 19 | x << 45) ^ (x >> 61 | x << 3) ^ (x >> 6); }\n+<%\n+uint64_t inline Ch(uint64_t x, uint64_t y, uint64_t z) <% return z ^ (x & (y ^ z)); %>\n+uint64_t inline Maj(uint64_t x, uint64_t y, uint64_t z) <% return (x & y) | (z & (x | y)); %>\n+uint64_t inline Sigma0(uint64_t x) <% return (x >> 28 | x << 36) ^ (x >> 34 | x << 30) ^ (x >> 39 | x << 25); %>\n+uint64_t inline Sigma1(uint64_t x) <% return (x >> 14 | x << 50) ^ (x >> 18 | x << 46) ^ (x >> 41 | x << 23); %>\n+uint64_t inline sigma0(uint64_t x) <% return (x >> 1 | x << 63) ^ (x >> 8 | x << 56) ^ (x >> 7); %>\n+uint64_t inline sigma1(uint64_t x) <% return (x >> 19 | x << 45) ^ (x >> 61 | x << 3) ^ (x >> 6); %>\n \n /** One round of SHA-512. */\n void inline Round(uint64_t a, uint64_t b, uint64_t c, uint64_t& d, uint64_t e, uint64_t f, uint64_t g, uint64_t& h, uint64_t k, uint64_t w)\n-{\n+<%\n     uint64_t t1 = h + Sigma1(e) + Ch(e, f, g) + k + w;\n     uint64_t t2 = Sigma0(a) + Maj(a, b, c);\n     d += t1;\n     h = t1 + t2;\n-}\n+%>\n \n /** Initialize SHA-256 state. */\n void inline Initialize(uint64_t* s)\n-{\n+<%\n     s[0] = 0x6a09e667f3bcc908ull;\n     s[1] = 0xbb67ae8584caa73bull;\n     s[2] = 0x3c6ef372fe94f82bull;\n@@ -41,11 +41,11 @@ void inline Initialize(uint64_t* s)\n     s[5] = 0x9b05688c2b3e6c1full;\n     s[6] = 0x1f83d9abfb41bd6bull;\n     s[7] = 0x5be0cd19137e2179ull;\n-}\n+%>\n \n /** Perform one SHA-512 transformation, processing a 128-byte chunk. */\n void Transform(uint64_t* s, const unsigned char* chunk)\n-{\n+<%\n     uint64_t a = s[0], b = s[1], c = s[2], d = s[3], e = s[4], f = s[5], g = s[6], h = s[7];\n     uint64_t w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;\n \n@@ -142,50 +142,50 @@ void Transform(uint64_t* s, const unsigned char* chunk)\n     s[5] += f;\n     s[6] += g;\n     s[7] += h;\n-}\n+%>\n \n-} // namespace sha512\n+%> // namespace sha512\n \n-} // namespace\n+%> // namespace\n \n \n ////// SHA-512\n \n CSHA512::CSHA512() : bytes(0)\n-{\n+<%\n     sha512::Initialize(s);\n-}\n+%>\n \n CSHA512& CSHA512::Write(const unsigned char* data, size_t len)\n-{\n+<%\n     const unsigned char* end = data + len;\n     size_t bufsize = bytes % 128;\n-    if (bufsize && bufsize + len >= 128) {\n+    if (bufsize && bufsize + len >= 128) <%\n         // Fill the buffer, and process it.\n         memcpy(buf + bufsize, data, 128 - bufsize);\n         bytes += 128 - bufsize;\n         data += 128 - bufsize;\n         sha512::Transform(s, buf);\n         bufsize = 0;\n-    }\n-    while (end >= data + 128) {\n+    %>\n+    while (end >= data + 128) <%\n         // Process full chunks directly from the source.\n         sha512::Transform(s, data);\n         data += 128;\n         bytes += 128;\n-    }\n-    if (end > data) {\n+    %>\n+    if (end > data) <%\n         // Fill the buffer with what remains.\n         memcpy(buf + bufsize, data, end - data);\n         bytes += end - data;\n-    }\n+    %>\n     return *this;\n-}\n+%>\n \n void CSHA512::Finalize(unsigned char hash[OUTPUT_SIZE])\n-{\n-    static const unsigned char pad[128] = {0x80};\n-    unsigned char sizedesc[16] = {0x00};\n+<%\n+    static const unsigned char pad[128] = <%0x80%>;\n+    unsigned char sizedesc[16] = <%0x00%>;\n     WriteBE64(sizedesc + 8, bytes << 3);\n     Write(pad, 1 + ((239 - (bytes % 128)) % 128));\n     Write(sizedesc, 16);\n@@ -197,11 +197,11 @@ void CSHA512::Finalize(unsigned char hash[OUTPUT_SIZE])\n     WriteBE64(hash + 40, s[5]);\n     WriteBE64(hash + 48, s[6]);\n     WriteBE64(hash + 56, s[7]);\n-}\n+%>\n \n CSHA512& CSHA512::Reset()\n-{\n+<%\n     bytes = 0;\n     sha512::Initialize(s);\n     return *this;\n-}\n+%>"
      },
      {
        "sha": "64cc577b2bc472d7639c22e6a94dba655d454abe",
        "filename": "src/crypto/sha512.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/sha512.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/sha512.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha512.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -10,7 +10,7 @@\n \n /** A hasher class for SHA-512. */\n class CSHA512\n-{\n+<%\n private:\n     uint64_t s[8];\n     unsigned char buf[128];\n@@ -23,6 +23,6 @@ class CSHA512\n     CSHA512& Write(const unsigned char* data, size_t len);\n     void Finalize(unsigned char hash[OUTPUT_SIZE]);\n     CSHA512& Reset();\n-};\n+%>;\n \n #endif // BITCOIN_CRYPTO_SHA512_H"
      },
      {
        "sha": "931c84fe405a78af51775571e3abc658a6295aab",
        "filename": "src/crypto/siphash.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 18,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/siphash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/siphash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/siphash.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -6,27 +6,27 @@\n \n #define ROTL(x, b) (uint64_t)(((x) << (b)) | ((x) >> (64 - (b))))\n \n-#define SIPROUND do { \\\n+#define SIPROUND do <% \\\n     v0 += v1; v1 = ROTL(v1, 13); v1 ^= v0; \\\n     v0 = ROTL(v0, 32); \\\n     v2 += v3; v3 = ROTL(v3, 16); v3 ^= v2; \\\n     v0 += v3; v3 = ROTL(v3, 21); v3 ^= v0; \\\n     v2 += v1; v1 = ROTL(v1, 17); v1 ^= v2; \\\n     v2 = ROTL(v2, 32); \\\n-} while (0)\n+%> while (0)\n \n CSipHasher::CSipHasher(uint64_t k0, uint64_t k1)\n-{\n+<%\n     v[0] = 0x736f6d6570736575ULL ^ k0;\n     v[1] = 0x646f72616e646f6dULL ^ k1;\n     v[2] = 0x6c7967656e657261ULL ^ k0;\n     v[3] = 0x7465646279746573ULL ^ k1;\n     count = 0;\n     tmp = 0;\n-}\n+%>\n \n CSipHasher& CSipHasher::Write(uint64_t data)\n-{\n+<%\n     uint64_t v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3];\n \n     assert(count % 8 == 0);\n@@ -43,25 +43,25 @@ CSipHasher& CSipHasher::Write(uint64_t data)\n \n     count += 8;\n     return *this;\n-}\n+%>\n \n CSipHasher& CSipHasher::Write(const unsigned char* data, size_t size)\n-{\n+<%\n     uint64_t v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3];\n     uint64_t t = tmp;\n     int c = count;\n \n-    while (size--) {\n+    while (size--) <%\n         t |= ((uint64_t)(*(data++))) << (8 * (c % 8));\n         c++;\n-        if ((c & 7) == 0) {\n+        if ((c & 7) == 0) <%\n             v3 ^= t;\n             SIPROUND;\n             SIPROUND;\n             v0 ^= t;\n             t = 0;\n-        }\n-    }\n+        %>\n+    %>\n \n     v[0] = v0;\n     v[1] = v1;\n@@ -71,10 +71,10 @@ CSipHasher& CSipHasher::Write(const unsigned char* data, size_t size)\n     tmp = t;\n \n     return *this;\n-}\n+%>\n \n uint64_t CSipHasher::Finalize() const\n-{\n+<%\n     uint64_t v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3];\n \n     uint64_t t = tmp | (((uint64_t)count) << 56);\n@@ -89,10 +89,10 @@ uint64_t CSipHasher::Finalize() const\n     SIPROUND;\n     SIPROUND;\n     return v0 ^ v1 ^ v2 ^ v3;\n-}\n+%>\n \n uint64_t SipHashUint256(uint64_t k0, uint64_t k1, const uint256& val)\n-{\n+<%\n     /* Specialized implementation for efficiency */\n     uint64_t d = val.GetUint64(0);\n \n@@ -129,10 +129,10 @@ uint64_t SipHashUint256(uint64_t k0, uint64_t k1, const uint256& val)\n     SIPROUND;\n     SIPROUND;\n     return v0 ^ v1 ^ v2 ^ v3;\n-}\n+%>\n \n uint64_t SipHashUint256Extra(uint64_t k0, uint64_t k1, const uint256& val, uint32_t extra)\n-{\n+<%\n     /* Specialized implementation for efficiency */\n     uint64_t d = val.GetUint64(0);\n \n@@ -170,4 +170,4 @@ uint64_t SipHashUint256Extra(uint64_t k0, uint64_t k1, const uint256& val, uint3\n     SIPROUND;\n     SIPROUND;\n     return v0 ^ v1 ^ v2 ^ v3;\n-}\n+%>"
      },
      {
        "sha": "d3063ae110a96ec6a1cacec2ba555424deab1037",
        "filename": "src/crypto/siphash.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/siphash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/crypto/siphash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/siphash.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -11,7 +11,7 @@\n \n /** SipHash-2-4 */\n class CSipHasher\n-{\n+<%\n private:\n     uint64_t v[4];\n     uint64_t tmp;\n@@ -29,7 +29,7 @@ class CSipHasher\n     CSipHasher& Write(const unsigned char* data, size_t size);\n     /** Compute the 64-bit SipHash-2-4 of the data written so far. The object remains untouched. */\n     uint64_t Finalize() const;\n-};\n+%>;\n \n /** Optimized SipHash-2-4 implementation for uint256.\n  *"
      },
      {
        "sha": "b8e3eacaf2d03e6ea5e4e7af4078813f79d103ed",
        "filename": "src/cuckoocache.h",
        "status": "modified",
        "additions": 50,
        "deletions": 50,
        "changes": 100,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/cuckoocache.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/cuckoocache.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/cuckoocache.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -25,7 +25,7 @@\n  * insert.\n  */\n namespace CuckooCache\n-{\n+<%\n /** bit_packed_atomic_flags implements a container for garbage collection flags\n  * that is only thread unsafe on calls to setup. This class bit-packs collection\n  * flags for memory efficiency.\n@@ -40,7 +40,7 @@ namespace CuckooCache\n  *\n  */\n class bit_packed_atomic_flags\n-{\n+<%\n     std::unique_ptr<std::atomic<uint8_t>[]> mem;\n \n public:\n@@ -59,13 +59,13 @@ class bit_packed_atomic_flags\n      * true.\n      */\n     explicit bit_packed_atomic_flags(uint32_t size)\n-    {\n+    <%\n         // pad out the size if needed\n         size = (size + 7) / 8;\n         mem.reset(new std::atomic<uint8_t>[size]);\n         for (uint32_t i = 0; i < size; ++i)\n             mem[i].store(0xFF);\n-    };\n+    %>;\n \n     /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n      * at least size entries\n@@ -77,10 +77,10 @@ class bit_packed_atomic_flags\n      * true.\n      */\n     inline void setup(uint32_t b)\n-    {\n+    <%\n         bit_packed_atomic_flags d(b);\n         std::swap(mem, d.mem);\n-    }\n+    %>\n \n     /** bit_set sets an entry as discardable.\n      *\n@@ -90,9 +90,9 @@ class bit_packed_atomic_flags\n      *\n      */\n     inline void bit_set(uint32_t s)\n-    {\n+    <%\n         mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n-    }\n+    %>\n \n     /**  bit_unset marks an entry as something that should not be overwritten\n      *\n@@ -101,20 +101,20 @@ class bit_packed_atomic_flags\n      * ordering) to bit_is_set(s) == false.\n      */\n     inline void bit_unset(uint32_t s)\n-    {\n+    <%\n         mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n-    }\n+    %>\n \n     /** bit_is_set queries the table for discardability at s\n      *\n      * @param s the index of the entry to read.\n      * @returns if the bit at index s was set.\n      * */\n     inline bool bit_is_set(uint32_t s) const\n-    {\n+    <%\n         return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n-    }\n-};\n+    %>\n+%>;\n \n /** cache implements a cache with properties similar to a cuckoo-set\n  *\n@@ -158,7 +158,7 @@ class bit_packed_atomic_flags\n  */\n template <typename Element, typename Hash>\n class cache\n-{\n+<%\n private:\n     /** table stores all the elements */\n     std::vector<Element> table;\n@@ -241,41 +241,41 @@ class cache\n      * @returns std::array<uint32_t, 8> of deterministic hashes derived from e\n      */\n     inline std::array<uint32_t, 8> compute_hashes(const Element& e) const\n-    {\n-        return {{(uint32_t)(((uint64_t)hash_function.template operator()<0>(e) * (uint64_t)size) >> 32),\n+    <%\n+        return <%<%(uint32_t)(((uint64_t)hash_function.template operator()<0>(e) * (uint64_t)size) >> 32),\n                  (uint32_t)(((uint64_t)hash_function.template operator()<1>(e) * (uint64_t)size) >> 32),\n                  (uint32_t)(((uint64_t)hash_function.template operator()<2>(e) * (uint64_t)size) >> 32),\n                  (uint32_t)(((uint64_t)hash_function.template operator()<3>(e) * (uint64_t)size) >> 32),\n                  (uint32_t)(((uint64_t)hash_function.template operator()<4>(e) * (uint64_t)size) >> 32),\n                  (uint32_t)(((uint64_t)hash_function.template operator()<5>(e) * (uint64_t)size) >> 32),\n                  (uint32_t)(((uint64_t)hash_function.template operator()<6>(e) * (uint64_t)size) >> 32),\n-                 (uint32_t)(((uint64_t)hash_function.template operator()<7>(e) * (uint64_t)size) >> 32)}};\n-    }\n+                 (uint32_t)(((uint64_t)hash_function.template operator()<7>(e) * (uint64_t)size) >> 32)%>%>;\n+    %>\n \n     /* end\n      * @returns a constexpr index that can never be inserted to */\n     constexpr uint32_t invalid() const\n-    {\n+    <%\n         return ~(uint32_t)0;\n-    }\n+    %>\n \n     /** allow_erase marks the element at index n as discardable. Threadsafe\n      * without any concurrent insert.\n      * @param n the index to allow erasure of\n      */\n     inline void allow_erase(uint32_t n) const\n-    {\n+    <%\n         collection_flags.bit_set(n);\n-    }\n+    %>\n \n     /** please_keep marks the element at index n as an entry that should be kept.\n      * Threadsafe without any concurrent insert.\n      * @param n the index to prioritize keeping\n      */\n     inline void please_keep(uint32_t n) const\n-    {\n+    <%\n         collection_flags.bit_unset(n);\n-    }\n+    %>\n \n     /** epoch_check handles the changing of epochs for elements stored in the\n      * cache. epoch_check should be run before every insert.\n@@ -287,11 +287,11 @@ class cache\n      * current epoch's elements would exceed the epoch_size.\n      */\n     void epoch_check()\n-    {\n-        if (epoch_heuristic_counter != 0) {\n+    <%\n+        if (epoch_heuristic_counter != 0) <%\n             --epoch_heuristic_counter;\n             return;\n-        }\n+        %>\n         // count the number of elements from the latest epoch which\n         // have not been erased.\n         uint32_t epoch_unused_count = 0;\n@@ -302,14 +302,14 @@ class cache\n         // epoch size, then allow_erase on all elements in the old epoch (marked\n         // false) and move all elements in the current epoch to the old epoch\n         // but do not call allow_erase on their indices.\n-        if (epoch_unused_count >= epoch_size) {\n+        if (epoch_unused_count >= epoch_size) <%\n             for (uint32_t i = 0; i < size; ++i)\n                 if (epoch_flags[i])\n                     epoch_flags[i] = false;\n                 else\n                     allow_erase(i);\n             epoch_heuristic_counter = epoch_size;\n-        } else\n+        %> else\n             // reset the epoch_heuristic_counter to next do a scan when worst\n             // case behavior (no intermittent erases) would exceed epoch size,\n             // with a reasonable minimum scan size.\n@@ -318,16 +318,16 @@ class cache\n             // < epoch_size` in this branch\n             epoch_heuristic_counter = std::max(1u, std::max(epoch_size / 16,\n                         epoch_size - epoch_unused_count));\n-    }\n+    %>\n \n public:\n     /** You must always construct a cache with some elements via a subsequent\n      * call to setup or setup_bytes, otherwise operations may segfault.\n      */\n     cache() : table(), size(), collection_flags(0), epoch_flags(),\n     epoch_heuristic_counter(), epoch_size(), depth_limit(0), hash_function()\n-    {\n-    }\n+    <%\n+    %>\n \n     /** setup initializes the container to store no more than new_size\n      * elements.\n@@ -338,7 +338,7 @@ class cache\n      * @returns the maximum number of elements storable\n      **/\n     uint32_t setup(uint32_t new_size)\n-    {\n+    <%\n         // depth_limit must be at least one otherwise errors can occur.\n         depth_limit = static_cast<uint8_t>(std::log2(static_cast<float>(std::max((uint32_t)2, new_size))));\n         size = std::max<uint32_t>(2, new_size);\n@@ -350,7 +350,7 @@ class cache\n         // Initially set to wait for a whole epoch\n         epoch_heuristic_counter = epoch_size;\n         return size;\n-    }\n+    %>\n \n     /** setup_bytes is a convenience function which accounts for internal memory\n      * usage when deciding how many elements to store. It isn't perfect because\n@@ -365,9 +365,9 @@ class cache\n      * documentation for more detail)\n      */\n     uint32_t setup_bytes(size_t bytes)\n-    {\n+    <%\n         return setup(bytes/sizeof(Element));\n-    }\n+    %>\n \n     /** insert loops at most depth_limit times trying to insert a hash\n      * at various locations in the table via a variant of the Cuckoo Algorithm\n@@ -390,29 +390,29 @@ class cache\n      *\n      */\n     inline void insert(Element e)\n-    {\n+    <%\n         epoch_check();\n         uint32_t last_loc = invalid();\n         bool last_epoch = true;\n         std::array<uint32_t, 8> locs = compute_hashes(e);\n         // Make sure we have not already inserted this element\n         // If we have, make sure that it does not get deleted\n         for (const uint32_t loc : locs)\n-            if (table[loc] == e) {\n+            if (table[loc] == e) <%\n                 please_keep(loc);\n                 epoch_flags[loc] = last_epoch;\n                 return;\n-            }\n-        for (uint8_t depth = 0; depth < depth_limit; ++depth) {\n+            %>\n+        for (uint8_t depth = 0; depth < depth_limit; ++depth) <%\n             // First try to insert to an empty slot, if one exists\n-            for (const uint32_t loc : locs) {\n+            for (const uint32_t loc : locs) <%\n                 if (!collection_flags.bit_is_set(loc))\n                     continue;\n                 table[loc] = std::move(e);\n                 please_keep(loc);\n                 epoch_flags[loc] = last_epoch;\n                 return;\n-            }\n+            %>\n             /** Swap with the element at the location that was\n             * not the last one looked at. Example:\n             *\n@@ -436,8 +436,8 @@ class cache\n \n             // Recompute the locs -- unfortunately happens one too many times!\n             locs = compute_hashes(e);\n-        }\n-    }\n+        %>\n+    %>\n \n     /* contains iterates through the hash locations for a given element\n      * and checks to see if it is present.\n@@ -465,17 +465,17 @@ class cache\n      * @returns true if the element is found, false otherwise\n      */\n     inline bool contains(const Element& e, const bool erase) const\n-    {\n+    <%\n         std::array<uint32_t, 8> locs = compute_hashes(e);\n         for (const uint32_t loc : locs)\n-            if (table[loc] == e) {\n+            if (table[loc] == e) <%\n                 if (erase)\n                     allow_erase(loc);\n                 return true;\n-            }\n+            %>\n         return false;\n-    }\n-};\n-} // namespace CuckooCache\n+    %>\n+%>;\n+%> // namespace CuckooCache\n \n #endif // BITCOIN_CUCKOOCACHE_H"
      },
      {
        "sha": "703580cf6e8dfa3cd54d08f9db5a5d0de64d05f1",
        "filename": "src/dbwrapper.cpp",
        "status": "modified",
        "additions": 69,
        "deletions": 69,
        "changes": 138,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/dbwrapper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/dbwrapper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dbwrapper.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -14,65 +14,65 @@\n #include <stdint.h>\n #include <algorithm>\n \n-class CBitcoinLevelDBLogger : public leveldb::Logger {\n+class CBitcoinLevelDBLogger : public leveldb::Logger <%\n public:\n     // This code is adapted from posix_logger.h, which is why it is using vsprintf.\n     // Please do not do this in normal code\n-    void Logv(const char * format, va_list ap) override {\n-            if (!LogAcceptCategory(BCLog::LEVELDB)) {\n+    void Logv(const char * format, va_list ap) override <%\n+            if (!LogAcceptCategory(BCLog::LEVELDB)) <%\n                 return;\n-            }\n+            %>\n             char buffer[500];\n-            for (int iter = 0; iter < 2; iter++) {\n+            for (int iter = 0; iter < 2; iter++) <%\n                 char* base;\n                 int bufsize;\n-                if (iter == 0) {\n+                if (iter == 0) <%\n                     bufsize = sizeof(buffer);\n                     base = buffer;\n-                }\n-                else {\n+                %>\n+                else <%\n                     bufsize = 30000;\n                     base = new char[bufsize];\n-                }\n+                %>\n                 char* p = base;\n                 char* limit = base + bufsize;\n \n                 // Print the message\n-                if (p < limit) {\n+                if (p < limit) <%\n                     va_list backup_ap;\n                     va_copy(backup_ap, ap);\n                     // Do not use vsnprintf elsewhere in bitcoin source code, see above.\n                     p += vsnprintf(p, limit - p, format, backup_ap);\n                     va_end(backup_ap);\n-                }\n+                %>\n \n                 // Truncate to available space if necessary\n-                if (p >= limit) {\n-                    if (iter == 0) {\n+                if (p >= limit) <%\n+                    if (iter == 0) <%\n                         continue;       // Try again with larger buffer\n-                    }\n-                    else {\n+                    %>\n+                    else <%\n                         p = limit - 1;\n-                    }\n-                }\n+                    %>\n+                %>\n \n                 // Add newline if necessary\n-                if (p == base || p[-1] != '\\n') {\n+                if (p == base || p[-1] != '\\n') <%\n                     *p++ = '\\n';\n-                }\n+                %>\n \n                 assert(p <= limit);\n                 base[std::min(bufsize - 1, (int)(p - base))] = '\\0';\n                 LogPrintf(\"leveldb: %s\", base);  /* Continued */\n-                if (base != buffer) {\n+                if (base != buffer) <%\n                     delete[] base;\n-                }\n+                %>\n                 break;\n-            }\n-    }\n-};\n+            %>\n+    %>\n+%>;\n \n-static void SetMaxOpenFiles(leveldb::Options *options) {\n+static void SetMaxOpenFiles(leveldb::Options *options) <%\n     // On most platforms the default setting of max_open_files (which is 1000)\n     // is optimal. On Windows using a large file count is OK because the handles\n     // do not interfere with select() loops. On 64-bit Unix hosts this value is\n@@ -89,69 +89,69 @@ static void SetMaxOpenFiles(leveldb::Options *options) {\n \n     int default_open_files = options->max_open_files;\n #ifndef WIN32\n-    if (sizeof(void*) < 8) {\n+    if (sizeof(void*) < 8) <%\n         options->max_open_files = 64;\n-    }\n+    %>\n #endif\n     LogPrint(BCLog::LEVELDB, \"LevelDB using max_open_files=%d (default=%d)\\n\",\n              options->max_open_files, default_open_files);\n-}\n+%>\n \n static leveldb::Options GetOptions(size_t nCacheSize)\n-{\n+<%\n     leveldb::Options options;\n     options.block_cache = leveldb::NewLRUCache(nCacheSize / 2);\n     options.write_buffer_size = nCacheSize / 4; // up to two write buffers may be held in memory simultaneously\n     options.filter_policy = leveldb::NewBloomFilterPolicy(10);\n     options.compression = leveldb::kNoCompression;\n     options.info_log = new CBitcoinLevelDBLogger();\n-    if (leveldb::kMajorVersion > 1 || (leveldb::kMajorVersion == 1 && leveldb::kMinorVersion >= 16)) {\n+    if (leveldb::kMajorVersion > 1 || (leveldb::kMajorVersion == 1 && leveldb::kMinorVersion >= 16)) <%\n         // LevelDB versions before 1.16 consider short writes to be corruption. Only trigger error\n         // on corruption in later versions.\n         options.paranoid_checks = true;\n-    }\n+    %>\n     SetMaxOpenFiles(&options);\n     return options;\n-}\n+%>\n \n CDBWrapper::CDBWrapper(const fs::path& path, size_t nCacheSize, bool fMemory, bool fWipe, bool obfuscate)\n     : m_name(fs::basename(path))\n-{\n+<%\n     penv = nullptr;\n     readoptions.verify_checksums = true;\n     iteroptions.verify_checksums = true;\n     iteroptions.fill_cache = false;\n     syncoptions.sync = true;\n     options = GetOptions(nCacheSize);\n     options.create_if_missing = true;\n-    if (fMemory) {\n+    if (fMemory) <%\n         penv = leveldb::NewMemEnv(leveldb::Env::Default());\n         options.env = penv;\n-    } else {\n-        if (fWipe) {\n+    %> else <%\n+        if (fWipe) <%\n             LogPrintf(\"Wiping LevelDB in %s\\n\", path.string());\n             leveldb::Status result = leveldb::DestroyDB(path.string(), options);\n             dbwrapper_private::HandleError(result);\n-        }\n+        %>\n         TryCreateDirectories(path);\n         LogPrintf(\"Opening LevelDB in %s\\n\", path.string());\n-    }\n+    %>\n     leveldb::Status status = leveldb::DB::Open(options, path.string(), &pdb);\n     dbwrapper_private::HandleError(status);\n     LogPrintf(\"Opened LevelDB successfully\\n\");\n \n-    if (gArgs.GetBoolArg(\"-forcecompactdb\", false)) {\n+    if (gArgs.GetBoolArg(\"-forcecompactdb\", false)) <%\n         LogPrintf(\"Starting database compaction of %s\\n\", path.string());\n         pdb->CompactRange(nullptr, nullptr);\n         LogPrintf(\"Finished database compaction of %s\\n\", path.string());\n-    }\n+    %>\n \n     // The base-case obfuscation key, which is a noop.\n     obfuscate_key = std::vector<unsigned char>(OBFUSCATE_KEY_NUM_BYTES, '\\000');\n \n     bool key_exists = Read(OBFUSCATE_KEY_KEY, obfuscate_key);\n \n-    if (!key_exists && obfuscate && IsEmpty()) {\n+    if (!key_exists && obfuscate && IsEmpty()) <%\n         // Initialize non-degenerate obfuscation if it won't upset\n         // existing, non-obfuscated data.\n         std::vector<unsigned char> new_key = CreateObfuscateKey();\n@@ -161,13 +161,13 @@ CDBWrapper::CDBWrapper(const fs::path& path, size_t nCacheSize, bool fMemory, bo\n         obfuscate_key = new_key;\n \n         LogPrintf(\"Wrote new obfuscate key for %s: %s\\n\", path.string(), HexStr(obfuscate_key));\n-    }\n+    %>\n \n     LogPrintf(\"Using obfuscation key for %s: %s\\n\", path.string(), HexStr(obfuscate_key));\n-}\n+%>\n \n CDBWrapper::~CDBWrapper()\n-{\n+<%\n     delete pdb;\n     pdb = nullptr;\n     delete options.filter_policy;\n@@ -178,33 +178,33 @@ CDBWrapper::~CDBWrapper()\n     options.block_cache = nullptr;\n     delete penv;\n     options.env = nullptr;\n-}\n+%>\n \n bool CDBWrapper::WriteBatch(CDBBatch& batch, bool fSync)\n-{\n+<%\n     const bool log_memory = LogAcceptCategory(BCLog::LEVELDB);\n     double mem_before = 0;\n-    if (log_memory) {\n+    if (log_memory) <%\n         mem_before = DynamicMemoryUsage() / 1024.0 / 1024;\n-    }\n+    %>\n     leveldb::Status status = pdb->Write(fSync ? syncoptions : writeoptions, &batch.batch);\n     dbwrapper_private::HandleError(status);\n-    if (log_memory) {\n+    if (log_memory) <%\n         double mem_after = DynamicMemoryUsage() / 1024.0 / 1024;\n         LogPrint(BCLog::LEVELDB, \"WriteBatch memory usage: db=%s, before=%.1fMiB, after=%.1fMiB\\n\",\n                  m_name, mem_before, mem_after);\n-    }\n+    %>\n     return true;\n-}\n+%>\n \n-size_t CDBWrapper::DynamicMemoryUsage() const {\n+size_t CDBWrapper::DynamicMemoryUsage() const <%\n     std::string memory;\n-    if (!pdb->GetProperty(\"leveldb.approximate-memory-usage\", &memory)) {\n+    if (!pdb->GetProperty(\"leveldb.approximate-memory-usage\", &memory)) <%\n         LogPrint(BCLog::LEVELDB, \"Failed to get approximate-memory-usage property\\n\");\n         return 0;\n-    }\n+    %>\n     return stoul(memory);\n-}\n+%>\n \n // Prefixed with null character to avoid collisions with other keys\n //\n@@ -219,40 +219,40 @@ const unsigned int CDBWrapper::OBFUSCATE_KEY_NUM_BYTES = 8;\n  * obfuscating XOR key.\n  */\n std::vector<unsigned char> CDBWrapper::CreateObfuscateKey() const\n-{\n+<%\n     unsigned char buff[OBFUSCATE_KEY_NUM_BYTES];\n     GetRandBytes(buff, OBFUSCATE_KEY_NUM_BYTES);\n     return std::vector<unsigned char>(&buff[0], &buff[OBFUSCATE_KEY_NUM_BYTES]);\n \n-}\n+%>\n \n bool CDBWrapper::IsEmpty()\n-{\n+<%\n     std::unique_ptr<CDBIterator> it(NewIterator());\n     it->SeekToFirst();\n     return !(it->Valid());\n-}\n+%>\n \n-CDBIterator::~CDBIterator() { delete piter; }\n-bool CDBIterator::Valid() const { return piter->Valid(); }\n-void CDBIterator::SeekToFirst() { piter->SeekToFirst(); }\n-void CDBIterator::Next() { piter->Next(); }\n+CDBIterator::~CDBIterator() <% delete piter; %>\n+bool CDBIterator::Valid() const <% return piter->Valid(); %>\n+void CDBIterator::SeekToFirst() <% piter->SeekToFirst(); %>\n+void CDBIterator::Next() <% piter->Next(); %>\n \n-namespace dbwrapper_private {\n+namespace dbwrapper_private <%\n \n void HandleError(const leveldb::Status& status)\n-{\n+<%\n     if (status.ok())\n         return;\n     const std::string errmsg = \"Fatal LevelDB error: \" + status.ToString();\n     LogPrintf(\"%s\\n\", errmsg);\n     LogPrintf(\"You can use -debug=leveldb to get more complete diagnostic messages\\n\");\n     throw dbwrapper_error(errmsg);\n-}\n+%>\n \n const std::vector<unsigned char>& GetObfuscateKey(const CDBWrapper &w)\n-{\n+<%\n     return w.obfuscate_key;\n-}\n+%>\n \n-} // namespace dbwrapper_private\n+%> // namespace dbwrapper_private"
      },
      {
        "sha": "e6aad7bb21e98a18174913272c85c67f556ee2ed",
        "filename": "src/dbwrapper.h",
        "status": "modified",
        "additions": 59,
        "deletions": 59,
        "changes": 118,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/dbwrapper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/dbwrapper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dbwrapper.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -20,16 +20,16 @@ static const size_t DBWRAPPER_PREALLOC_KEY_SIZE = 64;\n static const size_t DBWRAPPER_PREALLOC_VALUE_SIZE = 1024;\n \n class dbwrapper_error : public std::runtime_error\n-{\n+<%\n public:\n-    explicit dbwrapper_error(const std::string& msg) : std::runtime_error(msg) {}\n-};\n+    explicit dbwrapper_error(const std::string& msg) : std::runtime_error(msg) <%%>\n+%>;\n \n class CDBWrapper;\n \n /** These should be considered an implementation detail of the specific database.\n  */\n-namespace dbwrapper_private {\n+namespace dbwrapper_private <%\n \n /** Handle database error by throwing dbwrapper_error exception.\n  */\n@@ -41,11 +41,11 @@ void HandleError(const leveldb::Status& status);\n  */\n const std::vector<unsigned char>& GetObfuscateKey(const CDBWrapper &w);\n \n-};\n+%>;\n \n /** Batch of changes queued to be written to a CDBWrapper */\n class CDBBatch\n-{\n+<%\n     friend class CDBWrapper;\n \n private:\n@@ -61,17 +61,17 @@ class CDBBatch\n     /**\n      * @param[in] _parent   CDBWrapper that this batch is to be submitted to\n      */\n-    explicit CDBBatch(const CDBWrapper &_parent) : parent(_parent), ssKey(SER_DISK, CLIENT_VERSION), ssValue(SER_DISK, CLIENT_VERSION), size_estimate(0) { };\n+    explicit CDBBatch(const CDBWrapper &_parent) : parent(_parent), ssKey(SER_DISK, CLIENT_VERSION), ssValue(SER_DISK, CLIENT_VERSION), size_estimate(0) <% %>;\n \n     void Clear()\n-    {\n+    <%\n         batch.Clear();\n         size_estimate = 0;\n-    }\n+    %>\n \n     template <typename K, typename V>\n     void Write(const K& key, const V& value)\n-    {\n+    <%\n         ssKey.reserve(DBWRAPPER_PREALLOC_KEY_SIZE);\n         ssKey << key;\n         leveldb::Slice slKey(ssKey.data(), ssKey.size());\n@@ -92,11 +92,11 @@ class CDBBatch\n         size_estimate += 3 + (slKey.size() > 127) + slKey.size() + (slValue.size() > 127) + slValue.size();\n         ssKey.clear();\n         ssValue.clear();\n-    }\n+    %>\n \n     template <typename K>\n     void Erase(const K& key)\n-    {\n+    <%\n         ssKey.reserve(DBWRAPPER_PREALLOC_KEY_SIZE);\n         ssKey << key;\n         leveldb::Slice slKey(ssKey.data(), ssKey.size());\n@@ -109,13 +109,13 @@ class CDBBatch\n         // The formula below assumes the key is less than 16kB.\n         size_estimate += 2 + (slKey.size() > 127) + slKey.size();\n         ssKey.clear();\n-    }\n+    %>\n \n-    size_t SizeEstimate() const { return size_estimate; }\n-};\n+    size_t SizeEstimate() const <% return size_estimate; %>\n+%>;\n \n class CDBIterator\n-{\n+<%\n private:\n     const CDBWrapper &parent;\n     leveldb::Iterator *piter;\n@@ -127,54 +127,54 @@ class CDBIterator\n      * @param[in] _piter           The original leveldb iterator.\n      */\n     CDBIterator(const CDBWrapper &_parent, leveldb::Iterator *_piter) :\n-        parent(_parent), piter(_piter) { };\n+        parent(_parent), piter(_piter) <% %>;\n     ~CDBIterator();\n \n     bool Valid() const;\n \n     void SeekToFirst();\n \n-    template<typename K> void Seek(const K& key) {\n+    template<typename K> void Seek(const K& key) <%\n         CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n         ssKey.reserve(DBWRAPPER_PREALLOC_KEY_SIZE);\n         ssKey << key;\n         leveldb::Slice slKey(ssKey.data(), ssKey.size());\n         piter->Seek(slKey);\n-    }\n+    %>\n \n     void Next();\n \n-    template<typename K> bool GetKey(K& key) {\n+    template<typename K> bool GetKey(K& key) <%\n         leveldb::Slice slKey = piter->key();\n-        try {\n+        try <%\n             CDataStream ssKey(slKey.data(), slKey.data() + slKey.size(), SER_DISK, CLIENT_VERSION);\n             ssKey >> key;\n-        } catch (const std::exception&) {\n+        %> catch (const std::exception&) <%\n             return false;\n-        }\n+        %>\n         return true;\n-    }\n+    %>\n \n-    template<typename V> bool GetValue(V& value) {\n+    template<typename V> bool GetValue(V& value) <%\n         leveldb::Slice slValue = piter->value();\n-        try {\n+        try <%\n             CDataStream ssValue(slValue.data(), slValue.data() + slValue.size(), SER_DISK, CLIENT_VERSION);\n             ssValue.Xor(dbwrapper_private::GetObfuscateKey(parent));\n             ssValue >> value;\n-        } catch (const std::exception&) {\n+        %> catch (const std::exception&) <%\n             return false;\n-        }\n+        %>\n         return true;\n-    }\n+    %>\n \n-    unsigned int GetValueSize() {\n+    unsigned int GetValueSize() <%\n         return piter->value().size();\n-    }\n+    %>\n \n-};\n+%>;\n \n class CDBWrapper\n-{\n+<%\n     friend const std::vector<unsigned char>& dbwrapper_private::GetObfuscateKey(const CDBWrapper &w);\n private:\n     //! custom environment this database is using (may be nullptr in case of default environment)\n@@ -229,64 +229,64 @@ class CDBWrapper\n \n     template <typename K, typename V>\n     bool Read(const K& key, V& value) const\n-    {\n+    <%\n         CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n         ssKey.reserve(DBWRAPPER_PREALLOC_KEY_SIZE);\n         ssKey << key;\n         leveldb::Slice slKey(ssKey.data(), ssKey.size());\n \n         std::string strValue;\n         leveldb::Status status = pdb->Get(readoptions, slKey, &strValue);\n-        if (!status.ok()) {\n+        if (!status.ok()) <%\n             if (status.IsNotFound())\n                 return false;\n             LogPrintf(\"LevelDB read failure: %s\\n\", status.ToString());\n             dbwrapper_private::HandleError(status);\n-        }\n-        try {\n+        %>\n+        try <%\n             CDataStream ssValue(strValue.data(), strValue.data() + strValue.size(), SER_DISK, CLIENT_VERSION);\n             ssValue.Xor(obfuscate_key);\n             ssValue >> value;\n-        } catch (const std::exception&) {\n+        %> catch (const std::exception&) <%\n             return false;\n-        }\n+        %>\n         return true;\n-    }\n+    %>\n \n     template <typename K, typename V>\n     bool Write(const K& key, const V& value, bool fSync = false)\n-    {\n+    <%\n         CDBBatch batch(*this);\n         batch.Write(key, value);\n         return WriteBatch(batch, fSync);\n-    }\n+    %>\n \n     template <typename K>\n     bool Exists(const K& key) const\n-    {\n+    <%\n         CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n         ssKey.reserve(DBWRAPPER_PREALLOC_KEY_SIZE);\n         ssKey << key;\n         leveldb::Slice slKey(ssKey.data(), ssKey.size());\n \n         std::string strValue;\n         leveldb::Status status = pdb->Get(readoptions, slKey, &strValue);\n-        if (!status.ok()) {\n+        if (!status.ok()) <%\n             if (status.IsNotFound())\n                 return false;\n             LogPrintf(\"LevelDB read failure: %s\\n\", status.ToString());\n             dbwrapper_private::HandleError(status);\n-        }\n+        %>\n         return true;\n-    }\n+    %>\n \n     template <typename K>\n     bool Erase(const K& key, bool fSync = false)\n-    {\n+    <%\n         CDBBatch batch(*this);\n         batch.Erase(key);\n         return WriteBatch(batch, fSync);\n-    }\n+    %>\n \n     bool WriteBatch(CDBBatch& batch, bool fSync = false);\n \n@@ -295,20 +295,20 @@ class CDBWrapper\n \n     // not available for LevelDB; provide for compatibility with BDB\n     bool Flush()\n-    {\n+    <%\n         return true;\n-    }\n+    %>\n \n     bool Sync()\n-    {\n+    <%\n         CDBBatch batch(*this);\n         return WriteBatch(batch, true);\n-    }\n+    %>\n \n     CDBIterator *NewIterator()\n-    {\n+    <%\n         return new CDBIterator(*this, pdb->NewIterator(iteroptions));\n-    }\n+    %>\n \n     /**\n      * Return true if the database managed by this class contains no entries.\n@@ -317,7 +317,7 @@ class CDBWrapper\n \n     template<typename K>\n     size_t EstimateSize(const K& key_begin, const K& key_end) const\n-    {\n+    <%\n         CDataStream ssKey1(SER_DISK, CLIENT_VERSION), ssKey2(SER_DISK, CLIENT_VERSION);\n         ssKey1.reserve(DBWRAPPER_PREALLOC_KEY_SIZE);\n         ssKey2.reserve(DBWRAPPER_PREALLOC_KEY_SIZE);\n@@ -329,14 +329,14 @@ class CDBWrapper\n         leveldb::Range range(slKey1, slKey2);\n         pdb->GetApproximateSizes(&range, 1, &size);\n         return size;\n-    }\n+    %>\n \n     /**\n      * Compact a certain range of keys in the database.\n      */\n     template<typename K>\n     void CompactRange(const K& key_begin, const K& key_end) const\n-    {\n+    <%\n         CDataStream ssKey1(SER_DISK, CLIENT_VERSION), ssKey2(SER_DISK, CLIENT_VERSION);\n         ssKey1.reserve(DBWRAPPER_PREALLOC_KEY_SIZE);\n         ssKey2.reserve(DBWRAPPER_PREALLOC_KEY_SIZE);\n@@ -345,8 +345,8 @@ class CDBWrapper\n         leveldb::Slice slKey1(ssKey1.data(), ssKey1.size());\n         leveldb::Slice slKey2(ssKey2.data(), ssKey2.size());\n         pdb->CompactRange(&slKey1, &slKey2);\n-    }\n+    %>\n \n-};\n+%>;\n \n #endif // BITCOIN_DBWRAPPER_H"
      },
      {
        "sha": "da4a5d4be295961f565c760e209b23d9deedd3d4",
        "filename": "src/dummywallet.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 23,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/dummywallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/dummywallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dummywallet.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -8,57 +8,57 @@\n \n class CWallet;\n \n-namespace interfaces {\n+namespace interfaces <%\n class Chain;\n-}\n+%>\n \n-class DummyWalletInit : public WalletInitInterface {\n+class DummyWalletInit : public WalletInitInterface <%\n public:\n \n-    bool HasWalletSupport() const override {return false;}\n+    bool HasWalletSupport() const override <%return false;%>\n     void AddWalletOptions() const override;\n-    bool ParameterInteraction() const override {return true;}\n-    void Construct(InitInterfaces& interfaces) const override {LogPrintf(\"No wallet support compiled in!\\n\");}\n-};\n+    bool ParameterInteraction() const override <%return true;%>\n+    void Construct(InitInterfaces& interfaces) const override <%LogPrintf(\"No wallet support compiled in!\\n\");%>\n+%>;\n \n void DummyWalletInit::AddWalletOptions() const\n-{\n-    std::vector<std::string> opts = {\"-addresstype\", \"-changetype\", \"-disablewallet\", \"-discardfee=<amt>\", \"-fallbackfee=<amt>\",\n+<%\n+    std::vector<std::string> opts = <%\"-addresstype\", \"-changetype\", \"-disablewallet\", \"-discardfee=<amt>\", \"-fallbackfee=<amt>\",\n         \"-keypool=<n>\", \"-mintxfee=<amt>\", \"-paytxfee=<amt>\", \"-rescan\", \"-salvagewallet\", \"-spendzeroconfchange\",  \"-txconfirmtarget=<n>\",\n         \"-upgradewallet\", \"-wallet=<path>\", \"-walletbroadcast\", \"-walletdir=<dir>\", \"-walletnotify=<cmd>\", \"-walletrbf\", \"-zapwallettxes=<mode>\",\n-        \"-dblogsize=<n>\", \"-flushwallet\", \"-privdb\", \"-walletrejectlongchains\"};\n+        \"-dblogsize=<n>\", \"-flushwallet\", \"-privdb\", \"-walletrejectlongchains\"%>;\n     gArgs.AddHiddenArgs(opts);\n-}\n+%>\n \n const WalletInitInterface& g_wallet_init_interface = DummyWalletInit();\n \n fs::path GetWalletDir()\n-{\n+<%\n     throw std::logic_error(\"Wallet function called in non-wallet build.\");\n-}\n+%>\n \n std::vector<fs::path> ListWalletDir()\n-{\n+<%\n     throw std::logic_error(\"Wallet function called in non-wallet build.\");\n-}\n+%>\n \n std::vector<std::shared_ptr<CWallet>> GetWallets()\n-{\n+<%\n     throw std::logic_error(\"Wallet function called in non-wallet build.\");\n-}\n+%>\n \n std::shared_ptr<CWallet> LoadWallet(interfaces::Chain& chain, const std::string& name, std::string& error, std::string& warning)\n-{\n+<%\n     throw std::logic_error(\"Wallet function called in non-wallet build.\");\n-}\n+%>\n \n-namespace interfaces {\n+namespace interfaces <%\n \n class Wallet;\n \n std::unique_ptr<Wallet> MakeWallet(const std::shared_ptr<CWallet>& wallet)\n-{\n+<%\n     throw std::logic_error(\"Wallet function called in non-wallet build.\");\n-}\n+%>\n \n-} // namespace interfaces\n+%> // namespace interfaces"
      },
      {
        "sha": "7ef95707553fd40bb1f3fa6104de4928a3a83f3e",
        "filename": "src/flatfile.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 33,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/flatfile.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/flatfile.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/flatfile.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -14,85 +14,85 @@ FlatFileSeq::FlatFileSeq(fs::path dir, const char* prefix, size_t chunk_size) :\n     m_dir(std::move(dir)),\n     m_prefix(prefix),\n     m_chunk_size(chunk_size)\n-{\n-    if (chunk_size == 0) {\n+<%\n+    if (chunk_size == 0) <%\n         throw std::invalid_argument(\"chunk_size must be positive\");\n-    }\n-}\n+    %>\n+%>\n \n std::string FlatFilePos::ToString() const\n-{\n+<%\n     return strprintf(\"FlatFilePos(nFile=%i, nPos=%i)\", nFile, nPos);\n-}\n+%>\n \n fs::path FlatFileSeq::FileName(const FlatFilePos& pos) const\n-{\n+<%\n     return m_dir / strprintf(\"%s%05u.dat\", m_prefix, pos.nFile);\n-}\n+%>\n \n FILE* FlatFileSeq::Open(const FlatFilePos& pos, bool read_only)\n-{\n-    if (pos.IsNull()) {\n+<%\n+    if (pos.IsNull()) <%\n         return nullptr;\n-    }\n+    %>\n     fs::path path = FileName(pos);\n     fs::create_directories(path.parent_path());\n     FILE* file = fsbridge::fopen(path, read_only ? \"rb\": \"rb+\");\n     if (!file && !read_only)\n         file = fsbridge::fopen(path, \"wb+\");\n-    if (!file) {\n+    if (!file) <%\n         LogPrintf(\"Unable to open file %s\\n\", path.string());\n         return nullptr;\n-    }\n-    if (pos.nPos && fseek(file, pos.nPos, SEEK_SET)) {\n+    %>\n+    if (pos.nPos && fseek(file, pos.nPos, SEEK_SET)) <%\n         LogPrintf(\"Unable to seek to position %u of %s\\n\", pos.nPos, path.string());\n         fclose(file);\n         return nullptr;\n-    }\n+    %>\n     return file;\n-}\n+%>\n \n size_t FlatFileSeq::Allocate(const FlatFilePos& pos, size_t add_size, bool& out_of_space)\n-{\n+<%\n     out_of_space = false;\n \n     unsigned int n_old_chunks = (pos.nPos + m_chunk_size - 1) / m_chunk_size;\n     unsigned int n_new_chunks = (pos.nPos + add_size + m_chunk_size - 1) / m_chunk_size;\n-    if (n_new_chunks > n_old_chunks) {\n+    if (n_new_chunks > n_old_chunks) <%\n         size_t old_size = pos.nPos;\n         size_t new_size = n_new_chunks * m_chunk_size;\n         size_t inc_size = new_size - old_size;\n \n-        if (CheckDiskSpace(m_dir, inc_size)) {\n+        if (CheckDiskSpace(m_dir, inc_size)) <%\n             FILE *file = Open(pos);\n-            if (file) {\n+            if (file) <%\n                 LogPrintf(\"Pre-allocating up to position 0x%x in %s%05u.dat\\n\", new_size, m_prefix, pos.nFile);\n                 AllocateFileRange(file, pos.nPos, inc_size);\n                 fclose(file);\n                 return inc_size;\n-            }\n-        } else {\n+            %>\n+        %> else <%\n             out_of_space = true;\n-        }\n-    }\n+        %>\n+    %>\n     return 0;\n-}\n+%>\n \n bool FlatFileSeq::Flush(const FlatFilePos& pos, bool finalize)\n-{\n+<%\n     FILE* file = Open(FlatFilePos(pos.nFile, 0)); // Avoid fseek to nPos\n-    if (!file) {\n+    if (!file) <%\n         return error(\"%s: failed to open file %d\", __func__, pos.nFile);\n-    }\n-    if (finalize && !TruncateFile(file, pos.nPos)) {\n+    %>\n+    if (finalize && !TruncateFile(file, pos.nPos)) <%\n         fclose(file);\n         return error(\"%s: failed to truncate file %d\", __func__, pos.nFile);\n-    }\n-    if (!FileCommit(file)) {\n+    %>\n+    if (!FileCommit(file)) <%\n         fclose(file);\n         return error(\"%s: failed to commit file %d\", __func__, pos.nFile);\n-    }\n+    %>\n \n     fclose(file);\n     return true;\n-}\n+%>"
      },
      {
        "sha": "8ad46d4b26032bf6797b2bb56191a7cb73022af1",
        "filename": "src/flatfile.h",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/flatfile.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/flatfile.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/flatfile.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -12,45 +12,45 @@\n #include <serialize.h>\n \n struct FlatFilePos\n-{\n+<%\n     int nFile;\n     unsigned int nPos;\n \n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action) {\n+    inline void SerializationOp(Stream& s, Operation ser_action) <%\n         READWRITE(VARINT(nFile, VarIntMode::NONNEGATIVE_SIGNED));\n         READWRITE(VARINT(nPos));\n-    }\n+    %>\n \n-    FlatFilePos() : nFile(-1), nPos(0) {}\n+    FlatFilePos() : nFile(-1), nPos(0) <%%>\n \n     FlatFilePos(int nFileIn, unsigned int nPosIn) :\n         nFile(nFileIn),\n         nPos(nPosIn)\n-    {}\n+    <%%>\n \n-    friend bool operator==(const FlatFilePos &a, const FlatFilePos &b) {\n+    friend bool operator==(const FlatFilePos &a, const FlatFilePos &b) <%\n         return (a.nFile == b.nFile && a.nPos == b.nPos);\n-    }\n+    %>\n \n-    friend bool operator!=(const FlatFilePos &a, const FlatFilePos &b) {\n+    friend bool operator!=(const FlatFilePos &a, const FlatFilePos &b) <%\n         return !(a == b);\n-    }\n+    %>\n \n-    void SetNull() { nFile = -1; nPos = 0; }\n-    bool IsNull() const { return (nFile == -1); }\n+    void SetNull() <% nFile = -1; nPos = 0; %>\n+    bool IsNull() const <% return (nFile == -1); %>\n \n     std::string ToString() const;\n-};\n+%>;\n \n /**\n  * FlatFileSeq represents a sequence of numbered files storing raw data. This class facilitates\n  * access to and efficient management of these files.\n  */\n class FlatFileSeq\n-{\n+<%\n private:\n     const fs::path m_dir;\n     const char* const m_prefix;\n@@ -91,6 +91,6 @@ class FlatFileSeq\n      * @return true on success, false on failure.\n      */\n     bool Flush(const FlatFilePos& pos, bool finalize = false);\n-};\n+%>;\n \n #endif // BITCOIN_FLATFILE_H"
      },
      {
        "sha": "89900c3697cf571f563612227af33af8c229ab23",
        "filename": "src/fs.cpp",
        "status": "modified",
        "additions": 63,
        "deletions": 63,
        "changes": 126,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/fs.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/fs.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fs.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -8,98 +8,98 @@\n #include <windows.h>\n #endif\n \n-namespace fsbridge {\n+namespace fsbridge <%\n \n FILE *fopen(const fs::path& p, const char *mode)\n-{\n+<%\n #ifndef WIN32\n     return ::fopen(p.string().c_str(), mode);\n #else\n     std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>,wchar_t> utf8_cvt;\n     return ::_wfopen(p.wstring().c_str(), utf8_cvt.from_bytes(mode).c_str());\n #endif\n-}\n+%>\n \n #ifndef WIN32\n \n-static std::string GetErrorReason() {\n+static std::string GetErrorReason() <%\n     return std::strerror(errno);\n-}\n+%>\n \n FileLock::FileLock(const fs::path& file)\n-{\n+<%\n     fd = open(file.string().c_str(), O_RDWR);\n-    if (fd == -1) {\n+    if (fd == -1) <%\n         reason = GetErrorReason();\n-    }\n-}\n+    %>\n+%>\n \n FileLock::~FileLock()\n-{\n-    if (fd != -1) {\n+<%\n+    if (fd != -1) <%\n         close(fd);\n-    }\n-}\n+    %>\n+%>\n \n bool FileLock::TryLock()\n-{\n-    if (fd == -1) {\n+<%\n+    if (fd == -1) <%\n         return false;\n-    }\n+    %>\n     struct flock lock;\n     lock.l_type = F_WRLCK;\n     lock.l_whence = SEEK_SET;\n     lock.l_start = 0;\n     lock.l_len = 0;\n-    if (fcntl(fd, F_SETLK, &lock) == -1) {\n+    if (fcntl(fd, F_SETLK, &lock) == -1) <%\n         reason = GetErrorReason();\n         return false;\n-    }\n+    %>\n     return true;\n-}\n+%>\n #else\n \n-static std::string GetErrorReason() {\n+static std::string GetErrorReason() <%\n     wchar_t* err;\n     FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n         nullptr, GetLastError(), MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), reinterpret_cast<WCHAR*>(&err), 0, nullptr);\n     std::wstring err_str(err);\n     LocalFree(err);\n     return std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>>().to_bytes(err_str);\n-}\n+%>\n \n FileLock::FileLock(const fs::path& file)\n-{\n+<%\n     hFile = CreateFileW(file.wstring().c_str(),  GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n         nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);\n-    if (hFile == INVALID_HANDLE_VALUE) {\n+    if (hFile == INVALID_HANDLE_VALUE) <%\n         reason = GetErrorReason();\n-    }\n-}\n+    %>\n+%>\n \n FileLock::~FileLock()\n-{\n-    if (hFile != INVALID_HANDLE_VALUE) {\n+<%\n+    if (hFile != INVALID_HANDLE_VALUE) <%\n         CloseHandle(hFile);\n-    }\n-}\n+    %>\n+%>\n \n bool FileLock::TryLock()\n-{\n-    if (hFile == INVALID_HANDLE_VALUE) {\n+<%\n+    if (hFile == INVALID_HANDLE_VALUE) <%\n         return false;\n-    }\n-    _OVERLAPPED overlapped = {0};\n-    if (!LockFileEx(hFile, LOCKFILE_EXCLUSIVE_LOCK | LOCKFILE_FAIL_IMMEDIATELY, 0, std::numeric_limits<DWORD>::max(), std::numeric_limits<DWORD>::max(), &overlapped)) {\n+    %>\n+    _OVERLAPPED overlapped = <%0%>;\n+    if (!LockFileEx(hFile, LOCKFILE_EXCLUSIVE_LOCK | LOCKFILE_FAIL_IMMEDIATELY, 0, std::numeric_limits<DWORD>::max(), std::numeric_limits<DWORD>::max(), &overlapped)) <%\n         reason = GetErrorReason();\n         return false;\n-    }\n+    %>\n     return true;\n-}\n+%>\n #endif\n \n std::string get_filesystem_error_message(const fs::filesystem_error& e)\n-{\n+<%\n #ifndef WIN32\n     return e.what();\n #else\n@@ -112,16 +112,16 @@ std::string get_filesystem_error_message(const fs::filesystem_error& e)\n     // Convert from utf-16 to utf-8\n     return std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>, wchar_t>().to_bytes(utf16_string);\n #endif\n-}\n+%>\n \n #ifdef WIN32\n #ifdef __GLIBCXX__\n \n // reference: https://github.com/gcc-mirror/gcc/blob/gcc-7_3_0-release/libstdc%2B%2B-v3/include/std/fstream#L270\n \n static std::string openmodeToStr(std::ios_base::openmode mode)\n-{\n-    switch (mode & ~std::ios_base::ate) {\n+<%\n+    switch (mode & ~std::ios_base::ate) <%\n     case std::ios_base::out:\n     case std::ios_base::out | std::ios_base::trunc:\n         return \"w\";\n@@ -154,56 +154,56 @@ static std::string openmodeToStr(std::ios_base::openmode mode)\n         return \"a+b\";\n     default:\n         return std::string();\n-    }\n-}\n+    %>\n+%>\n \n void ifstream::open(const fs::path& p, std::ios_base::openmode mode)\n-{\n+<%\n     close();\n     mode |= std::ios_base::in;\n     m_file = fsbridge::fopen(p, openmodeToStr(mode).c_str());\n-    if (m_file == nullptr) {\n+    if (m_file == nullptr) <%\n         return;\n-    }\n+    %>\n     m_filebuf = __gnu_cxx::stdio_filebuf<char>(m_file, mode);\n     rdbuf(&m_filebuf);\n-    if (mode & std::ios_base::ate) {\n+    if (mode & std::ios_base::ate) <%\n         seekg(0, std::ios_base::end);\n-    }\n-}\n+    %>\n+%>\n \n void ifstream::close()\n-{\n-    if (m_file != nullptr) {\n+<%\n+    if (m_file != nullptr) <%\n         m_filebuf.close();\n         fclose(m_file);\n-    }\n+    %>\n     m_file = nullptr;\n-}\n+%>\n \n void ofstream::open(const fs::path& p, std::ios_base::openmode mode)\n-{\n+<%\n     close();\n     mode |= std::ios_base::out;\n     m_file = fsbridge::fopen(p, openmodeToStr(mode).c_str());\n-    if (m_file == nullptr) {\n+    if (m_file == nullptr) <%\n         return;\n-    }\n+    %>\n     m_filebuf = __gnu_cxx::stdio_filebuf<char>(m_file, mode);\n     rdbuf(&m_filebuf);\n-    if (mode & std::ios_base::ate) {\n+    if (mode & std::ios_base::ate) <%\n         seekp(0, std::ios_base::end);\n-    }\n-}\n+    %>\n+%>\n \n void ofstream::close()\n-{\n-    if (m_file != nullptr) {\n+<%\n+    if (m_file != nullptr) <%\n         m_filebuf.close();\n         fclose(m_file);\n-    }\n+    %>\n     m_file = nullptr;\n-}\n+%>\n #else // __GLIBCXX__\n \n static_assert(sizeof(*fs::path().BOOST_FILESYSTEM_C_STR) == sizeof(wchar_t),\n@@ -218,4 +218,4 @@ static_assert(sizeof(*fs::path().BOOST_FILESYSTEM_C_STR) == sizeof(wchar_t),\n #endif // __GLIBCXX__\n #endif // WIN32\n \n-} // fsbridge\n+%> // fsbridge"
      },
      {
        "sha": "222fd273eb3dee7466143597be85a6138aba8009",
        "filename": "src/fs.h",
        "status": "modified",
        "additions": 15,
        "deletions": 15,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/fs.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/fs.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fs.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -18,19 +18,19 @@\n namespace fs = boost::filesystem;\n \n /** Bridge operations to C stdio */\n-namespace fsbridge {\n+namespace fsbridge <%\n     FILE *fopen(const fs::path& p, const char *mode);\n \n     class FileLock\n-    {\n+    <%\n     public:\n         FileLock() = delete;\n         FileLock(const FileLock&) = delete;\n         FileLock(FileLock&&) = delete;\n         explicit FileLock(const fs::path& file);\n         ~FileLock();\n         bool TryLock();\n-        std::string GetReason() { return reason; }\n+        std::string GetReason() <% return reason; %>\n \n     private:\n         std::string reason;\n@@ -39,7 +39,7 @@ namespace fsbridge {\n #else\n         void* hFile = (void*)-1; // INVALID_HANDLE_VALUE\n #endif\n-    };\n+    %>;\n \n     std::string get_filesystem_error_message(const fs::filesystem_error& e);\n \n@@ -59,37 +59,37 @@ namespace fsbridge {\n \n #if defined WIN32 && defined __GLIBCXX__\n     class ifstream : public std::istream\n-    {\n+    <%\n     public:\n         ifstream() = default;\n-        explicit ifstream(const fs::path& p, std::ios_base::openmode mode = std::ios_base::in) { open(p, mode); }\n-        ~ifstream() { close(); }\n+        explicit ifstream(const fs::path& p, std::ios_base::openmode mode = std::ios_base::in) <% open(p, mode); %>\n+        ~ifstream() <% close(); %>\n         void open(const fs::path& p, std::ios_base::openmode mode = std::ios_base::in);\n-        bool is_open() { return m_filebuf.is_open(); }\n+        bool is_open() <% return m_filebuf.is_open(); %>\n         void close();\n \n     private:\n         __gnu_cxx::stdio_filebuf<char> m_filebuf;\n         FILE* m_file = nullptr;\n-    };\n+    %>;\n     class ofstream : public std::ostream\n-    {\n+    <%\n     public:\n         ofstream() = default;\n-        explicit ofstream(const fs::path& p, std::ios_base::openmode mode = std::ios_base::out) { open(p, mode); }\n-        ~ofstream() { close(); }\n+        explicit ofstream(const fs::path& p, std::ios_base::openmode mode = std::ios_base::out) <% open(p, mode); %>\n+        ~ofstream() <% close(); %>\n         void open(const fs::path& p, std::ios_base::openmode mode = std::ios_base::out);\n-        bool is_open() { return m_filebuf.is_open(); }\n+        bool is_open() <% return m_filebuf.is_open(); %>\n         void close();\n \n     private:\n         __gnu_cxx::stdio_filebuf<char> m_filebuf;\n         FILE* m_file = nullptr;\n-    };\n+    %>;\n #else  // !(WIN32 && __GLIBCXX__)\n     typedef fs::ifstream ifstream;\n     typedef fs::ofstream ofstream;\n #endif // WIN32 && __GLIBCXX__\n-};\n+%>;\n \n #endif // BITCOIN_FS_H"
      },
      {
        "sha": "c671be4a3a4804e77582bb4041c16b96711e1a19",
        "filename": "src/hash.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/hash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/hash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -8,12 +8,12 @@\n \n \n inline uint32_t ROTL32(uint32_t x, int8_t r)\n-{\n+<%\n     return (x << r) | (x >> (32 - r));\n-}\n+%>\n \n unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char>& vDataToHash)\n-{\n+<%\n     // The following is MurmurHash3 (x86_32), see http://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp\n     uint32_t h1 = nHashSeed;\n     const uint32_t c1 = 0xcc9e2d51;\n@@ -25,7 +25,7 @@ unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char\n     // body\n     const uint8_t* blocks = vDataToHash.data();\n \n-    for (int i = 0; i < nblocks; ++i) {\n+    for (int i = 0; i < nblocks; ++i) <%\n         uint32_t k1 = ReadLE32(blocks + i*4);\n \n         k1 *= c1;\n@@ -35,15 +35,15 @@ unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char\n         h1 ^= k1;\n         h1 = ROTL32(h1, 13);\n         h1 = h1 * 5 + 0xe6546b64;\n-    }\n+    %>\n \n     //----------\n     // tail\n     const uint8_t* tail = vDataToHash.data() + nblocks * 4;\n \n     uint32_t k1 = 0;\n \n-    switch (vDataToHash.size() & 3) {\n+    switch (vDataToHash.size() & 3) <%\n         case 3:\n             k1 ^= tail[2] << 16;\n         case 2:\n@@ -54,7 +54,7 @@ unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char\n             k1 = ROTL32(k1, 15);\n             k1 *= c2;\n             h1 ^= k1;\n-    }\n+    %>\n \n     //----------\n     // finalization\n@@ -66,14 +66,14 @@ unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char\n     h1 ^= h1 >> 16;\n \n     return h1;\n-}\n+%>\n \n void BIP32Hash(const ChainCode &chainCode, unsigned int nChild, unsigned char header, const unsigned char data[32], unsigned char output[64])\n-{\n+<%\n     unsigned char num[4];\n     num[0] = (nChild >> 24) & 0xFF;\n     num[1] = (nChild >> 16) & 0xFF;\n     num[2] = (nChild >>  8) & 0xFF;\n     num[3] = (nChild >>  0) & 0xFF;\n     CHMAC_SHA512(chainCode.begin(), chainCode.size()).Write(&header, 1).Write(data, 32).Write(num, 4).Finalize(output);\n-}\n+%>"
      },
      {
        "sha": "08b6358ae133e2f1bfe8a228ba11c3690492a3a9",
        "filename": "src/hash.h",
        "status": "modified",
        "additions": 55,
        "deletions": 55,
        "changes": 110,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -19,186 +19,186 @@\n typedef uint256 ChainCode;\n \n /** A hasher class for Bitcoin's 256-bit hash (double SHA-256). */\n-class CHash256 {\n+class CHash256 <%\n private:\n     CSHA256 sha;\n public:\n     static const size_t OUTPUT_SIZE = CSHA256::OUTPUT_SIZE;\n \n-    void Finalize(unsigned char hash[OUTPUT_SIZE]) {\n+    void Finalize(unsigned char hash[OUTPUT_SIZE]) <%\n         unsigned char buf[CSHA256::OUTPUT_SIZE];\n         sha.Finalize(buf);\n         sha.Reset().Write(buf, CSHA256::OUTPUT_SIZE).Finalize(hash);\n-    }\n+    %>\n \n-    CHash256& Write(const unsigned char *data, size_t len) {\n+    CHash256& Write(const unsigned char *data, size_t len) <%\n         sha.Write(data, len);\n         return *this;\n-    }\n+    %>\n \n-    CHash256& Reset() {\n+    CHash256& Reset() <%\n         sha.Reset();\n         return *this;\n-    }\n-};\n+    %>\n+%>;\n \n /** A hasher class for Bitcoin's 160-bit hash (SHA-256 + RIPEMD-160). */\n-class CHash160 {\n+class CHash160 <%\n private:\n     CSHA256 sha;\n public:\n     static const size_t OUTPUT_SIZE = CRIPEMD160::OUTPUT_SIZE;\n \n-    void Finalize(unsigned char hash[OUTPUT_SIZE]) {\n+    void Finalize(unsigned char hash[OUTPUT_SIZE]) <%\n         unsigned char buf[CSHA256::OUTPUT_SIZE];\n         sha.Finalize(buf);\n         CRIPEMD160().Write(buf, CSHA256::OUTPUT_SIZE).Finalize(hash);\n-    }\n+    %>\n \n-    CHash160& Write(const unsigned char *data, size_t len) {\n+    CHash160& Write(const unsigned char *data, size_t len) <%\n         sha.Write(data, len);\n         return *this;\n-    }\n+    %>\n \n-    CHash160& Reset() {\n+    CHash160& Reset() <%\n         sha.Reset();\n         return *this;\n-    }\n-};\n+    %>\n+%>;\n \n /** Compute the 256-bit hash of an object. */\n template<typename T1>\n inline uint256 Hash(const T1 pbegin, const T1 pend)\n-{\n-    static const unsigned char pblank[1] = {};\n+<%\n+    static const unsigned char pblank[1] = <%%>;\n     uint256 result;\n     CHash256().Write(pbegin == pend ? pblank : (const unsigned char*)&pbegin[0], (pend - pbegin) * sizeof(pbegin[0]))\n               .Finalize((unsigned char*)&result);\n     return result;\n-}\n+%>\n \n /** Compute the 256-bit hash of the concatenation of two objects. */\n template<typename T1, typename T2>\n inline uint256 Hash(const T1 p1begin, const T1 p1end,\n-                    const T2 p2begin, const T2 p2end) {\n-    static const unsigned char pblank[1] = {};\n+                    const T2 p2begin, const T2 p2end) <%\n+    static const unsigned char pblank[1] = <%%>;\n     uint256 result;\n     CHash256().Write(p1begin == p1end ? pblank : (const unsigned char*)&p1begin[0], (p1end - p1begin) * sizeof(p1begin[0]))\n               .Write(p2begin == p2end ? pblank : (const unsigned char*)&p2begin[0], (p2end - p2begin) * sizeof(p2begin[0]))\n               .Finalize((unsigned char*)&result);\n     return result;\n-}\n+%>\n \n /** Compute the 160-bit hash an object. */\n template<typename T1>\n inline uint160 Hash160(const T1 pbegin, const T1 pend)\n-{\n-    static unsigned char pblank[1] = {};\n+<%\n+    static unsigned char pblank[1] = <%%>;\n     uint160 result;\n     CHash160().Write(pbegin == pend ? pblank : (const unsigned char*)&pbegin[0], (pend - pbegin) * sizeof(pbegin[0]))\n               .Finalize((unsigned char*)&result);\n     return result;\n-}\n+%>\n \n /** Compute the 160-bit hash of a vector. */\n inline uint160 Hash160(const std::vector<unsigned char>& vch)\n-{\n+<%\n     return Hash160(vch.begin(), vch.end());\n-}\n+%>\n \n /** Compute the 160-bit hash of a vector. */\n template<unsigned int N>\n inline uint160 Hash160(const prevector<N, unsigned char>& vch)\n-{\n+<%\n     return Hash160(vch.begin(), vch.end());\n-}\n+%>\n \n /** A writer stream (for serialization) that computes a 256-bit hash. */\n class CHashWriter\n-{\n+<%\n private:\n     CHash256 ctx;\n \n     const int nType;\n     const int nVersion;\n public:\n \n-    CHashWriter(int nTypeIn, int nVersionIn) : nType(nTypeIn), nVersion(nVersionIn) {}\n+    CHashWriter(int nTypeIn, int nVersionIn) : nType(nTypeIn), nVersion(nVersionIn) <%%>\n \n-    int GetType() const { return nType; }\n-    int GetVersion() const { return nVersion; }\n+    int GetType() const <% return nType; %>\n+    int GetVersion() const <% return nVersion; %>\n \n-    void write(const char *pch, size_t size) {\n+    void write(const char *pch, size_t size) <%\n         ctx.Write((const unsigned char*)pch, size);\n-    }\n+    %>\n \n     // invalidates the object\n-    uint256 GetHash() {\n+    uint256 GetHash() <%\n         uint256 result;\n         ctx.Finalize((unsigned char*)&result);\n         return result;\n-    }\n+    %>\n \n     /**\n      * Returns the first 64 bits from the resulting hash.\n      */\n-    inline uint64_t GetCheapHash() {\n+    inline uint64_t GetCheapHash() <%\n         unsigned char result[CHash256::OUTPUT_SIZE];\n         ctx.Finalize(result);\n         return ReadLE64(result);\n-    }\n+    %>\n \n     template<typename T>\n-    CHashWriter& operator<<(const T& obj) {\n+    CHashWriter& operator<<(const T& obj) <%\n         // Serialize to this stream\n         ::Serialize(*this, obj);\n         return (*this);\n-    }\n-};\n+    %>\n+%>;\n \n /** Reads data from an underlying stream, while hashing the read data. */\n template<typename Source>\n class CHashVerifier : public CHashWriter\n-{\n+<%\n private:\n     Source* source;\n \n public:\n-    explicit CHashVerifier(Source* source_) : CHashWriter(source_->GetType(), source_->GetVersion()), source(source_) {}\n+    explicit CHashVerifier(Source* source_) : CHashWriter(source_->GetType(), source_->GetVersion()), source(source_) <%%>\n \n     void read(char* pch, size_t nSize)\n-    {\n+    <%\n         source->read(pch, nSize);\n         this->write(pch, nSize);\n-    }\n+    %>\n \n     void ignore(size_t nSize)\n-    {\n+    <%\n         char data[1024];\n-        while (nSize > 0) {\n+        while (nSize > 0) <%\n             size_t now = std::min<size_t>(nSize, 1024);\n             read(data, now);\n             nSize -= now;\n-        }\n-    }\n+        %>\n+    %>\n \n     template<typename T>\n     CHashVerifier<Source>& operator>>(T&& obj)\n-    {\n+    <%\n         // Unserialize from this stream\n         ::Unserialize(*this, obj);\n         return (*this);\n-    }\n-};\n+    %>\n+%>;\n \n /** Compute the 256-bit hash of an object's serialization. */\n template<typename T>\n uint256 SerializeHash(const T& obj, int nType=SER_GETHASH, int nVersion=PROTOCOL_VERSION)\n-{\n+<%\n     CHashWriter ss(nType, nVersion);\n     ss << obj;\n     return ss.GetHash();\n-}\n+%>\n \n unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char>& vDataToHash);\n "
      },
      {
        "sha": "bdec16e11f0d1f2cb633859e5caebe1a369be119",
        "filename": "src/httprpc.cpp",
        "status": "modified",
        "additions": 65,
        "deletions": 65,
        "changes": 130,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/httprpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/httprpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httprpc.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -29,37 +29,37 @@ static const char* WWW_AUTH_HEADER_DATA = \"Basic realm=\\\"jsonrpc\\\"\";\n  * re-lock the wallet.\n  */\n class HTTPRPCTimer : public RPCTimerBase\n-{\n+<%\n public:\n     HTTPRPCTimer(struct event_base* eventBase, std::function<void()>& func, int64_t millis) :\n         ev(eventBase, false, func)\n-    {\n+    <%\n         struct timeval tv;\n         tv.tv_sec = millis/1000;\n         tv.tv_usec = (millis%1000)*1000;\n         ev.trigger(&tv);\n-    }\n+    %>\n private:\n     HTTPEvent ev;\n-};\n+%>;\n \n class HTTPRPCTimerInterface : public RPCTimerInterface\n-{\n+<%\n public:\n     explicit HTTPRPCTimerInterface(struct event_base* _base) : base(_base)\n-    {\n-    }\n+    <%\n+    %>\n     const char* Name() override\n-    {\n+    <%\n         return \"HTTP\";\n-    }\n+    %>\n     RPCTimerBase* NewTimer(std::function<void()>& func, int64_t millis) override\n-    {\n+    <%\n         return new HTTPRPCTimer(base, func, millis);\n-    }\n+    %>\n private:\n     struct event_base* base;\n-};\n+%>;\n \n \n /* Pre-base64-encoded authentication token */\n@@ -68,7 +68,7 @@ static std::string strRPCUserColonPass;\n static std::unique_ptr<HTTPRPCTimerInterface> httpRPCTimerInterface;\n \n static void JSONErrorReply(HTTPRequest* req, const UniValue& objError, const UniValue& id)\n-{\n+<%\n     // Send error reply from json-rpc error object\n     int nStatus = HTTP_INTERNAL_SERVER_ERROR;\n     int code = find_value(objError, \"code\").get_int();\n@@ -82,31 +82,31 @@ static void JSONErrorReply(HTTPRequest* req, const UniValue& objError, const Uni\n \n     req->WriteHeader(\"Content-Type\", \"application/json\");\n     req->WriteReply(nStatus, strReply);\n-}\n+%>\n \n //This function checks username and password against -rpcauth\n //entries from config file.\n static bool multiUserAuthorized(std::string strUserPass)\n-{\n-    if (strUserPass.find(':') == std::string::npos) {\n+<%\n+    if (strUserPass.find(':') == std::string::npos) <%\n         return false;\n-    }\n+    %>\n     std::string strUser = strUserPass.substr(0, strUserPass.find(':'));\n     std::string strPass = strUserPass.substr(strUserPass.find(':') + 1);\n \n-    for (const std::string& strRPCAuth : gArgs.GetArgs(\"-rpcauth\")) {\n+    for (const std::string& strRPCAuth : gArgs.GetArgs(\"-rpcauth\")) <%\n         //Search for multi-user login/pass \"rpcauth\" from config\n         std::vector<std::string> vFields;\n         boost::split(vFields, strRPCAuth, boost::is_any_of(\":$\"));\n-        if (vFields.size() != 3) {\n+        if (vFields.size() != 3) <%\n             //Incorrect formatting in config file\n             continue;\n-        }\n+        %>\n \n         std::string strName = vFields[0];\n-        if (!TimingResistantEqual(strName, strUser)) {\n+        if (!TimingResistantEqual(strName, strUser)) <%\n             continue;\n-        }\n+        %>\n \n         std::string strSalt = vFields[1];\n         std::string strHash = vFields[2];\n@@ -118,15 +118,15 @@ static bool multiUserAuthorized(std::string strUserPass)\n         std::vector<unsigned char> hexvec(out, out+KEY_SIZE);\n         std::string strHashFromPass = HexStr(hexvec);\n \n-        if (TimingResistantEqual(strHashFromPass, strHash)) {\n+        if (TimingResistantEqual(strHashFromPass, strHash)) <%\n             return true;\n-        }\n-    }\n+        %>\n+    %>\n     return false;\n-}\n+%>\n \n static bool RPCAuthorized(const std::string& strAuth, std::string& strAuthUsernameOut)\n-{\n+<%\n     if (strRPCUserColonPass.empty()) // Belt-and-suspenders measure if InitRPCAuthentication was not called\n         return false;\n     if (strAuth.substr(0, 6) != \"Basic \")\n@@ -139,30 +139,30 @@ static bool RPCAuthorized(const std::string& strAuth, std::string& strAuthUserna\n         strAuthUsernameOut = strUserPass.substr(0, strUserPass.find(':'));\n \n     //Check if authorized under single-user field\n-    if (TimingResistantEqual(strUserPass, strRPCUserColonPass)) {\n+    if (TimingResistantEqual(strUserPass, strRPCUserColonPass)) <%\n         return true;\n-    }\n+    %>\n     return multiUserAuthorized(strUserPass);\n-}\n+%>\n \n static bool HTTPReq_JSONRPC(HTTPRequest* req, const std::string &)\n-{\n+<%\n     // JSONRPC handles only POST\n-    if (req->GetRequestMethod() != HTTPRequest::POST) {\n+    if (req->GetRequestMethod() != HTTPRequest::POST) <%\n         req->WriteReply(HTTP_BAD_METHOD, \"JSONRPC server handles only POST requests\");\n         return false;\n-    }\n+    %>\n     // Check authorization\n     std::pair<bool, std::string> authHeader = req->GetHeader(\"authorization\");\n-    if (!authHeader.first) {\n+    if (!authHeader.first) <%\n         req->WriteHeader(\"WWW-Authenticate\", WWW_AUTH_HEADER_DATA);\n         req->WriteReply(HTTP_UNAUTHORIZED);\n         return false;\n-    }\n+    %>\n \n     JSONRPCRequest jreq;\n     jreq.peerAddr = req->GetPeer().ToString();\n-    if (!RPCAuthorized(authHeader.second, jreq.authUser)) {\n+    if (!RPCAuthorized(authHeader.second, jreq.authUser)) <%\n         LogPrintf(\"ThreadRPCServer incorrect password attempt from %s\\n\", jreq.peerAddr);\n \n         /* Deter brute-forcing\n@@ -173,9 +173,9 @@ static bool HTTPReq_JSONRPC(HTTPRequest* req, const std::string &)\n         req->WriteHeader(\"WWW-Authenticate\", WWW_AUTH_HEADER_DATA);\n         req->WriteReply(HTTP_UNAUTHORIZED);\n         return false;\n-    }\n+    %>\n \n-    try {\n+    try <%\n         // Parse request\n         UniValue valRequest;\n         if (!valRequest.read(req->ReadBody()))\n@@ -186,7 +186,7 @@ static bool HTTPReq_JSONRPC(HTTPRequest* req, const std::string &)\n \n         std::string strReply;\n         // singleton request\n-        if (valRequest.isObject()) {\n+        if (valRequest.isObject()) <%\n             jreq.parse(valRequest);\n \n             UniValue result = tableRPC.execute(jreq);\n@@ -195,76 +195,76 @@ static bool HTTPReq_JSONRPC(HTTPRequest* req, const std::string &)\n             strReply = JSONRPCReply(result, NullUniValue, jreq.id);\n \n         // array of requests\n-        } else if (valRequest.isArray())\n+        %> else if (valRequest.isArray())\n             strReply = JSONRPCExecBatch(jreq, valRequest.get_array());\n         else\n             throw JSONRPCError(RPC_PARSE_ERROR, \"Top-level object parse error\");\n \n         req->WriteHeader(\"Content-Type\", \"application/json\");\n         req->WriteReply(HTTP_OK, strReply);\n-    } catch (const UniValue& objError) {\n+    %> catch (const UniValue& objError) <%\n         JSONErrorReply(req, objError, jreq.id);\n         return false;\n-    } catch (const std::exception& e) {\n+    %> catch (const std::exception& e) <%\n         JSONErrorReply(req, JSONRPCError(RPC_PARSE_ERROR, e.what()), jreq.id);\n         return false;\n-    }\n+    %>\n     return true;\n-}\n+%>\n \n static bool InitRPCAuthentication()\n-{\n+<%\n     if (gArgs.GetArg(\"-rpcpassword\", \"\") == \"\")\n-    {\n+    <%\n         LogPrintf(\"No rpcpassword set - using random cookie authentication.\\n\");\n-        if (!GenerateAuthCookie(&strRPCUserColonPass)) {\n+        if (!GenerateAuthCookie(&strRPCUserColonPass)) <%\n             uiInterface.ThreadSafeMessageBox(\n                 _(\"Error: A fatal internal error occurred, see debug.log for details\"), // Same message as AbortNode\n                 \"\", CClientUIInterface::MSG_ERROR);\n             return false;\n-        }\n-    } else {\n+        %>\n+    %> else <%\n         LogPrintf(\"Config options rpcuser and rpcpassword will soon be deprecated. Locally-run instances may remove rpcuser to use cookie-based auth, or may be replaced with rpcauth. Please see share/rpcauth for rpcauth auth generation.\\n\");\n         strRPCUserColonPass = gArgs.GetArg(\"-rpcuser\", \"\") + \":\" + gArgs.GetArg(\"-rpcpassword\", \"\");\n-    }\n+    %>\n     if (gArgs.GetArg(\"-rpcauth\",\"\") != \"\")\n-    {\n+    <%\n         LogPrintf(\"Using rpcauth authentication.\\n\");\n-    }\n+    %>\n     return true;\n-}\n+%>\n \n bool StartHTTPRPC()\n-{\n+<%\n     LogPrint(BCLog::RPC, \"Starting HTTP RPC server\\n\");\n     if (!InitRPCAuthentication())\n         return false;\n \n     RegisterHTTPHandler(\"/\", true, HTTPReq_JSONRPC);\n-    if (g_wallet_init_interface.HasWalletSupport()) {\n+    if (g_wallet_init_interface.HasWalletSupport()) <%\n         RegisterHTTPHandler(\"/wallet/\", false, HTTPReq_JSONRPC);\n-    }\n+    %>\n     struct event_base* eventBase = EventBase();\n     assert(eventBase);\n     httpRPCTimerInterface = MakeUnique<HTTPRPCTimerInterface>(eventBase);\n     RPCSetTimerInterface(httpRPCTimerInterface.get());\n     return true;\n-}\n+%>\n \n void InterruptHTTPRPC()\n-{\n+<%\n     LogPrint(BCLog::RPC, \"Interrupting HTTP RPC server\\n\");\n-}\n+%>\n \n void StopHTTPRPC()\n-{\n+<%\n     LogPrint(BCLog::RPC, \"Stopping HTTP RPC server\\n\");\n     UnregisterHTTPHandler(\"/\", true);\n-    if (g_wallet_init_interface.HasWalletSupport()) {\n+    if (g_wallet_init_interface.HasWalletSupport()) <%\n         UnregisterHTTPHandler(\"/wallet/\", false);\n-    }\n-    if (httpRPCTimerInterface) {\n+    %>\n+    if (httpRPCTimerInterface) <%\n         RPCUnsetTimerInterface(httpRPCTimerInterface.get());\n         httpRPCTimerInterface.reset();\n-    }\n-}\n+    %>\n+%>"
      },
      {
        "sha": "dc5896086c56b9392332e174ab3663e66ecacba2",
        "filename": "src/httpserver.cpp",
        "status": "modified",
        "additions": 178,
        "deletions": 178,
        "changes": 356,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/httpserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/httpserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -43,30 +43,30 @@ static const size_t MAX_HEADERS_SIZE = 8192;\n \n /** HTTP request work item */\n class HTTPWorkItem final : public HTTPClosure\n-{\n+<%\n public:\n     HTTPWorkItem(std::unique_ptr<HTTPRequest> _req, const std::string &_path, const HTTPRequestHandler& _func):\n         req(std::move(_req)), path(_path), func(_func)\n-    {\n-    }\n+    <%\n+    %>\n     void operator()() override\n-    {\n+    <%\n         func(req.get(), path);\n-    }\n+    %>\n \n     std::unique_ptr<HTTPRequest> req;\n \n private:\n     std::string path;\n     HTTPRequestHandler func;\n-};\n+%>;\n \n /** Simple work queue for distributing work over multiple threads.\n  * Work items are simply callable objects.\n  */\n template <typename WorkItem>\n class WorkQueue\n-{\n+<%\n private:\n     /** Mutex protects entire object */\n     Mutex cs;\n@@ -78,60 +78,60 @@ class WorkQueue\n public:\n     explicit WorkQueue(size_t _maxDepth) : running(true),\n                                  maxDepth(_maxDepth)\n-    {\n-    }\n+    <%\n+    %>\n     /** Precondition: worker threads have all stopped (they have been joined).\n      */\n     ~WorkQueue()\n-    {\n-    }\n+    <%\n+    %>\n     /** Enqueue a work item */\n     bool Enqueue(WorkItem* item)\n-    {\n+    <%\n         LOCK(cs);\n-        if (queue.size() >= maxDepth) {\n+        if (queue.size() >= maxDepth) <%\n             return false;\n-        }\n+        %>\n         queue.emplace_back(std::unique_ptr<WorkItem>(item));\n         cond.notify_one();\n         return true;\n-    }\n+    %>\n     /** Thread function */\n     void Run()\n-    {\n-        while (true) {\n+    <%\n+        while (true) <%\n             std::unique_ptr<WorkItem> i;\n-            {\n+            <%\n                 WAIT_LOCK(cs, lock);\n                 while (running && queue.empty())\n                     cond.wait(lock);\n                 if (!running)\n                     break;\n                 i = std::move(queue.front());\n                 queue.pop_front();\n-            }\n+            %>\n             (*i)();\n-        }\n-    }\n+        %>\n+    %>\n     /** Interrupt and exit loops */\n     void Interrupt()\n-    {\n+    <%\n         LOCK(cs);\n         running = false;\n         cond.notify_all();\n-    }\n-};\n+    %>\n+%>;\n \n struct HTTPPathHandler\n-{\n+<%\n     HTTPPathHandler(std::string _prefix, bool _exactMatch, HTTPRequestHandler _handler):\n         prefix(_prefix), exactMatch(_exactMatch), handler(_handler)\n-    {\n-    }\n+    <%\n+    %>\n     std::string prefix;\n     bool exactMatch;\n     HTTPRequestHandler handler;\n-};\n+%>;\n \n /** HTTP module state */\n \n@@ -150,47 +150,47 @@ std::vector<evhttp_bound_socket *> boundSockets;\n \n /** Check if a network address is allowed to access the HTTP server */\n static bool ClientAllowed(const CNetAddr& netaddr)\n-{\n+<%\n     if (!netaddr.IsValid())\n         return false;\n     for(const CSubNet& subnet : rpc_allow_subnets)\n         if (subnet.Match(netaddr))\n             return true;\n     return false;\n-}\n+%>\n \n /** Initialize ACL list for HTTP server */\n static bool InitHTTPAllowList()\n-{\n+<%\n     rpc_allow_subnets.clear();\n     CNetAddr localv4;\n     CNetAddr localv6;\n     LookupHost(\"127.0.0.1\", localv4, false);\n     LookupHost(\"::1\", localv6, false);\n     rpc_allow_subnets.push_back(CSubNet(localv4, 8));      // always allow IPv4 local subnet\n     rpc_allow_subnets.push_back(CSubNet(localv6));         // always allow IPv6 localhost\n-    for (const std::string& strAllow : gArgs.GetArgs(\"-rpcallowip\")) {\n+    for (const std::string& strAllow : gArgs.GetArgs(\"-rpcallowip\")) <%\n         CSubNet subnet;\n         LookupSubNet(strAllow.c_str(), subnet);\n-        if (!subnet.IsValid()) {\n+        if (!subnet.IsValid()) <%\n             uiInterface.ThreadSafeMessageBox(\n                 strprintf(\"Invalid -rpcallowip subnet specification: %s. Valid are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24).\", strAllow),\n                 \"\", CClientUIInterface::MSG_ERROR);\n             return false;\n-        }\n+        %>\n         rpc_allow_subnets.push_back(subnet);\n-    }\n+    %>\n     std::string strAllowed;\n     for (const CSubNet& subnet : rpc_allow_subnets)\n         strAllowed += subnet.ToString() + \" \";\n     LogPrint(BCLog::HTTP, \"Allowing HTTP connections from: %s\\n\", strAllowed);\n     return true;\n-}\n+%>\n \n /** HTTP request method as string - use for logging only */\n static std::string RequestMethodString(HTTPRequest::RequestMethod m)\n-{\n-    switch (m) {\n+<%\n+    switch (m) <%\n     case HTTPRequest::GET:\n         return \"GET\";\n         break;\n@@ -205,39 +205,39 @@ static std::string RequestMethodString(HTTPRequest::RequestMethod m)\n         break;\n     default:\n         return \"unknown\";\n-    }\n-}\n+    %>\n+%>\n \n /** HTTP request callback */\n static void http_request_cb(struct evhttp_request* req, void* arg)\n-{\n+<%\n     // Disable reading to work around a libevent bug, fixed in 2.2.0.\n-    if (event_get_version_number() >= 0x02010600 && event_get_version_number() < 0x02020001) {\n+    if (event_get_version_number() >= 0x02010600 && event_get_version_number() < 0x02020001) <%\n         evhttp_connection* conn = evhttp_request_get_connection(req);\n-        if (conn) {\n+        if (conn) <%\n             bufferevent* bev = evhttp_connection_get_bufferevent(conn);\n-            if (bev) {\n+            if (bev) <%\n                 bufferevent_disable(bev, EV_READ);\n-            }\n-        }\n-    }\n+            %>\n+        %>\n+    %>\n     std::unique_ptr<HTTPRequest> hreq(new HTTPRequest(req));\n \n     // Early address-based allow check\n-    if (!ClientAllowed(hreq->GetPeer())) {\n+    if (!ClientAllowed(hreq->GetPeer())) <%\n         LogPrint(BCLog::HTTP, \"HTTP request from %s rejected: Client network is not allowed RPC access\\n\",\n                  hreq->GetPeer().ToString());\n         hreq->WriteReply(HTTP_FORBIDDEN);\n         return;\n-    }\n+    %>\n \n     // Early reject unknown HTTP methods\n-    if (hreq->GetRequestMethod() == HTTPRequest::UNKNOWN) {\n+    if (hreq->GetRequestMethod() == HTTPRequest::UNKNOWN) <%\n         LogPrint(BCLog::HTTP, \"HTTP request from %s rejected: Unknown HTTP request method\\n\",\n                  hreq->GetPeer().ToString());\n         hreq->WriteReply(HTTP_BADMETHOD);\n         return;\n-    }\n+    %>\n \n     LogPrint(BCLog::HTTP, \"Received a %s request for %s from %s\\n\",\n              RequestMethodString(hreq->GetRequestMethod()), SanitizeString(hreq->GetURI(), SAFE_CHARS_URI).substr(0, 100), hreq->GetPeer().ToString());\n@@ -247,103 +247,103 @@ static void http_request_cb(struct evhttp_request* req, void* arg)\n     std::string path;\n     std::vector<HTTPPathHandler>::const_iterator i = pathHandlers.begin();\n     std::vector<HTTPPathHandler>::const_iterator iend = pathHandlers.end();\n-    for (; i != iend; ++i) {\n+    for (; i != iend; ++i) <%\n         bool match = false;\n         if (i->exactMatch)\n             match = (strURI == i->prefix);\n         else\n             match = (strURI.substr(0, i->prefix.size()) == i->prefix);\n-        if (match) {\n+        if (match) <%\n             path = strURI.substr(i->prefix.size());\n             break;\n-        }\n-    }\n+        %>\n+    %>\n \n     // Dispatch to worker thread\n-    if (i != iend) {\n+    if (i != iend) <%\n         std::unique_ptr<HTTPWorkItem> item(new HTTPWorkItem(std::move(hreq), path, i->handler));\n         assert(workQueue);\n         if (workQueue->Enqueue(item.get()))\n             item.release(); /* if true, queue took ownership */\n-        else {\n+        else <%\n             LogPrintf(\"WARNING: request rejected because http work queue depth exceeded, it can be increased with the -rpcworkqueue= setting\\n\");\n             item->req->WriteReply(HTTP_INTERNAL, \"Work queue depth exceeded\");\n-        }\n-    } else {\n+        %>\n+    %> else <%\n         hreq->WriteReply(HTTP_NOTFOUND);\n-    }\n-}\n+    %>\n+%>\n \n /** Callback to reject HTTP requests after shutdown. */\n static void http_reject_request_cb(struct evhttp_request* req, void*)\n-{\n+<%\n     LogPrint(BCLog::HTTP, \"Rejecting request while shutting down\\n\");\n     evhttp_send_error(req, HTTP_SERVUNAVAIL, nullptr);\n-}\n+%>\n \n /** Event dispatcher thread */\n static bool ThreadHTTP(struct event_base* base)\n-{\n+<%\n     RenameThread(\"bitcoin-http\");\n     LogPrint(BCLog::HTTP, \"Entering http event loop\\n\");\n     event_base_dispatch(base);\n     // Event loop will be interrupted by InterruptHTTPServer()\n     LogPrint(BCLog::HTTP, \"Exited http event loop\\n\");\n     return event_base_got_break(base) == 0;\n-}\n+%>\n \n /** Bind HTTP server to specified addresses */\n static bool HTTPBindAddresses(struct evhttp* http)\n-{\n+<%\n     int http_port = gArgs.GetArg(\"-rpcport\", BaseParams().RPCPort());\n     std::vector<std::pair<std::string, uint16_t> > endpoints;\n \n     // Determine what addresses to bind to\n-    if (!(gArgs.IsArgSet(\"-rpcallowip\") && gArgs.IsArgSet(\"-rpcbind\"))) { // Default to loopback if not allowing external IPs\n+    if (!(gArgs.IsArgSet(\"-rpcallowip\") && gArgs.IsArgSet(\"-rpcbind\"))) <% // Default to loopback if not allowing external IPs\n         endpoints.push_back(std::make_pair(\"::1\", http_port));\n         endpoints.push_back(std::make_pair(\"127.0.0.1\", http_port));\n-        if (gArgs.IsArgSet(\"-rpcallowip\")) {\n+        if (gArgs.IsArgSet(\"-rpcallowip\")) <%\n             LogPrintf(\"WARNING: option -rpcallowip was specified without -rpcbind; this doesn't usually make sense\\n\");\n-        }\n-        if (gArgs.IsArgSet(\"-rpcbind\")) {\n+        %>\n+        if (gArgs.IsArgSet(\"-rpcbind\")) <%\n             LogPrintf(\"WARNING: option -rpcbind was ignored because -rpcallowip was not specified, refusing to allow everyone to connect\\n\");\n-        }\n-    } else if (gArgs.IsArgSet(\"-rpcbind\")) { // Specific bind address\n-        for (const std::string& strRPCBind : gArgs.GetArgs(\"-rpcbind\")) {\n+        %>\n+    %> else if (gArgs.IsArgSet(\"-rpcbind\")) <% // Specific bind address\n+        for (const std::string& strRPCBind : gArgs.GetArgs(\"-rpcbind\")) <%\n             int port = http_port;\n             std::string host;\n             SplitHostPort(strRPCBind, port, host);\n             endpoints.push_back(std::make_pair(host, port));\n-        }\n-    }\n+        %>\n+    %>\n \n     // Bind addresses\n-    for (std::vector<std::pair<std::string, uint16_t> >::iterator i = endpoints.begin(); i != endpoints.end(); ++i) {\n+    for (std::vector<std::pair<std::string, uint16_t> >::iterator i = endpoints.begin(); i != endpoints.end(); ++i) <%\n         LogPrint(BCLog::HTTP, \"Binding RPC on address %s port %i\\n\", i->first, i->second);\n         evhttp_bound_socket *bind_handle = evhttp_bind_socket_with_handle(http, i->first.empty() ? nullptr : i->first.c_str(), i->second);\n-        if (bind_handle) {\n+        if (bind_handle) <%\n             CNetAddr addr;\n-            if (i->first.empty() || (LookupHost(i->first.c_str(), addr, false) && addr.IsBindAny())) {\n+            if (i->first.empty() || (LookupHost(i->first.c_str(), addr, false) && addr.IsBindAny())) <%\n                 LogPrintf(\"WARNING: the RPC server is not safe to expose to untrusted networks such as the public internet\\n\");\n-            }\n+            %>\n             boundSockets.push_back(bind_handle);\n-        } else {\n+        %> else <%\n             LogPrintf(\"Binding RPC on address %s port %i failed.\\n\", i->first, i->second);\n-        }\n-    }\n+        %>\n+    %>\n     return !boundSockets.empty();\n-}\n+%>\n \n /** Simple wrapper to set thread name and run work queue */\n static void HTTPWorkQueueRun(WorkQueue<HTTPClosure>* queue)\n-{\n+<%\n     RenameThread(\"bitcoin-httpworker\");\n     queue->Run();\n-}\n+%>\n \n /** libevent event log callback */\n static void libevent_log_cb(int severity, const char *msg)\n-{\n+<%\n #ifndef EVENT_LOG_WARN\n // EVENT_LOG_WARN was added in 2.0.19; but before then _EVENT_LOG_WARN existed.\n # define EVENT_LOG_WARN _EVENT_LOG_WARN\n@@ -352,10 +352,10 @@ static void libevent_log_cb(int severity, const char *msg)\n         LogPrintf(\"libevent: %s\\n\", msg);\n     else\n         LogPrint(BCLog::LIBEVENT, \"libevent: %s\\n\", msg);\n-}\n+%>\n \n bool InitHTTPServer()\n-{\n+<%\n     if (!InitHTTPAllowList())\n         return false;\n \n@@ -364,9 +364,9 @@ bool InitHTTPServer()\n     // Update libevent's log handling. Returns false if our version of\n     // libevent doesn't support debug logging, in which case we should\n     // clear the BCLog::LIBEVENT flag.\n-    if (!UpdateHTTPServerLogging(LogInstance().WillLogCategory(BCLog::LIBEVENT))) {\n+    if (!UpdateHTTPServerLogging(LogInstance().WillLogCategory(BCLog::LIBEVENT))) <%\n         LogInstance().DisableCategory(BCLog::LIBEVENT);\n-    }\n+    %>\n \n #ifdef WIN32\n     evthread_use_windows_threads();\n@@ -379,20 +379,20 @@ bool InitHTTPServer()\n     /* Create a new evhttp object to handle requests. */\n     raii_evhttp http_ctr = obtain_evhttp(base_ctr.get());\n     struct evhttp* http = http_ctr.get();\n-    if (!http) {\n+    if (!http) <%\n         LogPrintf(\"couldn't create evhttp. Exiting.\\n\");\n         return false;\n-    }\n+    %>\n \n     evhttp_set_timeout(http, gArgs.GetArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT));\n     evhttp_set_max_headers_size(http, MAX_HEADERS_SIZE);\n     evhttp_set_max_body_size(http, MAX_SIZE);\n     evhttp_set_gencb(http, http_request_cb, nullptr);\n \n-    if (!HTTPBindAddresses(http)) {\n+    if (!HTTPBindAddresses(http)) <%\n         LogPrintf(\"Unable to bind any endpoint for RPC server\\n\");\n         return false;\n-    }\n+    %>\n \n     LogPrint(BCLog::HTTP, \"Initialized HTTP server\\n\");\n     int workQueueDepth = std::max((long)gArgs.GetArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);\n@@ -403,139 +403,139 @@ bool InitHTTPServer()\n     eventBase = base_ctr.release();\n     eventHTTP = http_ctr.release();\n     return true;\n-}\n+%>\n \n-bool UpdateHTTPServerLogging(bool enable) {\n+bool UpdateHTTPServerLogging(bool enable) <%\n #if LIBEVENT_VERSION_NUMBER >= 0x02010100\n-    if (enable) {\n+    if (enable) <%\n         event_enable_debug_logging(EVENT_DBG_ALL);\n-    } else {\n+    %> else <%\n         event_enable_debug_logging(EVENT_DBG_NONE);\n-    }\n+    %>\n     return true;\n #else\n     // Can't update libevent logging if version < 02010100\n     return false;\n #endif\n-}\n+%>\n \n std::thread threadHTTP;\n static std::vector<std::thread> g_thread_http_workers;\n \n void StartHTTPServer()\n-{\n+<%\n     LogPrint(BCLog::HTTP, \"Starting HTTP server\\n\");\n     int rpcThreads = std::max((long)gArgs.GetArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n     LogPrintf(\"HTTP: starting %d worker threads\\n\", rpcThreads);\n     threadHTTP = std::thread(ThreadHTTP, eventBase);\n \n-    for (int i = 0; i < rpcThreads; i++) {\n+    for (int i = 0; i < rpcThreads; i++) <%\n         g_thread_http_workers.emplace_back(HTTPWorkQueueRun, workQueue);\n-    }\n-}\n+    %>\n+%>\n \n void InterruptHTTPServer()\n-{\n+<%\n     LogPrint(BCLog::HTTP, \"Interrupting HTTP server\\n\");\n-    if (eventHTTP) {\n+    if (eventHTTP) <%\n         // Reject requests on current connections\n         evhttp_set_gencb(eventHTTP, http_reject_request_cb, nullptr);\n-    }\n+    %>\n     if (workQueue)\n         workQueue->Interrupt();\n-}\n+%>\n \n void StopHTTPServer()\n-{\n+<%\n     LogPrint(BCLog::HTTP, \"Stopping HTTP server\\n\");\n-    if (workQueue) {\n+    if (workQueue) <%\n         LogPrint(BCLog::HTTP, \"Waiting for HTTP worker threads to exit\\n\");\n-        for (auto& thread: g_thread_http_workers) {\n+        for (auto& thread: g_thread_http_workers) <%\n             thread.join();\n-        }\n+        %>\n         g_thread_http_workers.clear();\n         delete workQueue;\n         workQueue = nullptr;\n-    }\n+    %>\n     // Unlisten sockets, these are what make the event loop running, which means\n     // that after this and all connections are closed the event loop will quit.\n-    for (evhttp_bound_socket *socket : boundSockets) {\n+    for (evhttp_bound_socket *socket : boundSockets) <%\n         evhttp_del_accept_socket(eventHTTP, socket);\n-    }\n+    %>\n     boundSockets.clear();\n-    if (eventBase) {\n+    if (eventBase) <%\n         LogPrint(BCLog::HTTP, \"Waiting for HTTP event thread to exit\\n\");\n         threadHTTP.join();\n-    }\n-    if (eventHTTP) {\n+    %>\n+    if (eventHTTP) <%\n         evhttp_free(eventHTTP);\n         eventHTTP = nullptr;\n-    }\n-    if (eventBase) {\n+    %>\n+    if (eventBase) <%\n         event_base_free(eventBase);\n         eventBase = nullptr;\n-    }\n+    %>\n     LogPrint(BCLog::HTTP, \"Stopped HTTP server\\n\");\n-}\n+%>\n \n struct event_base* EventBase()\n-{\n+<%\n     return eventBase;\n-}\n+%>\n \n static void httpevent_callback_fn(evutil_socket_t, short, void* data)\n-{\n+<%\n     // Static handler: simply call inner handler\n     HTTPEvent *self = static_cast<HTTPEvent*>(data);\n     self->handler();\n     if (self->deleteWhenTriggered)\n         delete self;\n-}\n+%>\n \n HTTPEvent::HTTPEvent(struct event_base* base, bool _deleteWhenTriggered, const std::function<void()>& _handler):\n     deleteWhenTriggered(_deleteWhenTriggered), handler(_handler)\n-{\n+<%\n     ev = event_new(base, -1, 0, httpevent_callback_fn, this);\n     assert(ev);\n-}\n+%>\n HTTPEvent::~HTTPEvent()\n-{\n+<%\n     event_free(ev);\n-}\n+%>\n void HTTPEvent::trigger(struct timeval* tv)\n-{\n+<%\n     if (tv == nullptr)\n         event_active(ev, 0, 0); // immediately trigger event in main thread\n     else\n         evtimer_add(ev, tv); // trigger after timeval passed\n-}\n+%>\n HTTPRequest::HTTPRequest(struct evhttp_request* _req) : req(_req),\n                                                        replySent(false)\n-{\n-}\n+<%\n+%>\n HTTPRequest::~HTTPRequest()\n-{\n-    if (!replySent) {\n+<%\n+    if (!replySent) <%\n         // Keep track of whether reply was sent to avoid request leaks\n         LogPrintf(\"%s: Unhandled request\\n\", __func__);\n         WriteReply(HTTP_INTERNAL, \"Unhandled request\");\n-    }\n+    %>\n     // evhttpd cleans up the request, as long as a reply was sent.\n-}\n+%>\n \n std::pair<bool, std::string> HTTPRequest::GetHeader(const std::string& hdr) const\n-{\n+<%\n     const struct evkeyvalq* headers = evhttp_request_get_input_headers(req);\n     assert(headers);\n     const char* val = evhttp_find_header(headers, hdr.c_str());\n     if (val)\n         return std::make_pair(true, val);\n     else\n         return std::make_pair(false, \"\");\n-}\n+%>\n \n std::string HTTPRequest::ReadBody()\n-{\n+<%\n     struct evbuffer* buf = evhttp_request_get_input_buffer(req);\n     if (!buf)\n         return \"\";\n@@ -552,72 +552,72 @@ std::string HTTPRequest::ReadBody()\n     std::string rv(data, size);\n     evbuffer_drain(buf, size);\n     return rv;\n-}\n+%>\n \n void HTTPRequest::WriteHeader(const std::string& hdr, const std::string& value)\n-{\n+<%\n     struct evkeyvalq* headers = evhttp_request_get_output_headers(req);\n     assert(headers);\n     evhttp_add_header(headers, hdr.c_str(), value.c_str());\n-}\n+%>\n \n /** Closure sent to main thread to request a reply to be sent to\n  * a HTTP request.\n  * Replies must be sent in the main loop in the main http thread,\n  * this cannot be done from worker threads.\n  */\n void HTTPRequest::WriteReply(int nStatus, const std::string& strReply)\n-{\n+<%\n     assert(!replySent && req);\n-    if (ShutdownRequested()) {\n+    if (ShutdownRequested()) <%\n         WriteHeader(\"Connection\", \"close\");\n-    }\n+    %>\n     // Send event to main http thread to send reply message\n     struct evbuffer* evb = evhttp_request_get_output_buffer(req);\n     assert(evb);\n     evbuffer_add(evb, strReply.data(), strReply.size());\n     auto req_copy = req;\n-    HTTPEvent* ev = new HTTPEvent(eventBase, true, [req_copy, nStatus]{\n+    HTTPEvent* ev = new HTTPEvent(eventBase, true, [req_copy, nStatus]<%\n         evhttp_send_reply(req_copy, nStatus, nullptr, nullptr);\n         // Re-enable reading from the socket. This is the second part of the libevent\n         // workaround above.\n-        if (event_get_version_number() >= 0x02010600 && event_get_version_number() < 0x02020001) {\n+        if (event_get_version_number() >= 0x02010600 && event_get_version_number() < 0x02020001) <%\n             evhttp_connection* conn = evhttp_request_get_connection(req_copy);\n-            if (conn) {\n+            if (conn) <%\n                 bufferevent* bev = evhttp_connection_get_bufferevent(conn);\n-                if (bev) {\n+                if (bev) <%\n                     bufferevent_enable(bev, EV_READ | EV_WRITE);\n-                }\n-            }\n-        }\n-    });\n+                %>\n+            %>\n+        %>\n+    %>);\n     ev->trigger(nullptr);\n     replySent = true;\n     req = nullptr; // transferred back to main thread\n-}\n+%>\n \n CService HTTPRequest::GetPeer() const\n-{\n+<%\n     evhttp_connection* con = evhttp_request_get_connection(req);\n     CService peer;\n-    if (con) {\n+    if (con) <%\n         // evhttp retains ownership over returned address string\n         const char* address = \"\";\n         uint16_t port = 0;\n         evhttp_connection_get_peer(con, (char**)&address, &port);\n         peer = LookupNumeric(address, port);\n-    }\n+    %>\n     return peer;\n-}\n+%>\n \n std::string HTTPRequest::GetURI() const\n-{\n+<%\n     return evhttp_request_get_uri(req);\n-}\n+%>\n \n HTTPRequest::RequestMethod HTTPRequest::GetRequestMethod() const\n-{\n-    switch (evhttp_request_get_command(req)) {\n+<%\n+    switch (evhttp_request_get_command(req)) <%\n     case EVHTTP_REQ_GET:\n         return GET;\n         break;\n@@ -633,37 +633,37 @@ HTTPRequest::RequestMethod HTTPRequest::GetRequestMethod() const\n     default:\n         return UNKNOWN;\n         break;\n-    }\n-}\n+    %>\n+%>\n \n void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n-{\n+<%\n     LogPrint(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n     pathHandlers.push_back(HTTPPathHandler(prefix, exactMatch, handler));\n-}\n+%>\n \n void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n-{\n+<%\n     std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n     std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n     for (; i != iend; ++i)\n         if (i->prefix == prefix && i->exactMatch == exactMatch)\n             break;\n     if (i != iend)\n-    {\n+    <%\n         LogPrint(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n         pathHandlers.erase(i);\n-    }\n-}\n+    %>\n+%>\n \n-std::string urlDecode(const std::string &urlEncoded) {\n+std::string urlDecode(const std::string &urlEncoded) <%\n     std::string res;\n-    if (!urlEncoded.empty()) {\n+    if (!urlEncoded.empty()) <%\n         char *decoded = evhttp_uridecode(urlEncoded.c_str(), false, nullptr);\n-        if (decoded) {\n+        if (decoded) <%\n             res = std::string(decoded);\n             free(decoded);\n-        }\n-    }\n+        %>\n+    %>\n     return res;\n-}\n+%>"
      },
      {
        "sha": "4a02fada19fb63f530b8d7d4eb592c715de3a9ea",
        "filename": "src/httpserver.h",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/httpserver.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/httpserver.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -55,7 +55,7 @@ struct event_base* EventBase();\n  * Thin C++ wrapper around evhttp_request.\n  */\n class HTTPRequest\n-{\n+<%\n private:\n     struct evhttp_request* req;\n     bool replySent;\n@@ -64,13 +64,13 @@ class HTTPRequest\n     explicit HTTPRequest(struct evhttp_request* req);\n     ~HTTPRequest();\n \n-    enum RequestMethod {\n+    enum RequestMethod <%\n         UNKNOWN,\n         GET,\n         POST,\n         HEAD,\n         PUT\n-    };\n+    %>;\n \n     /** Get requested URI.\n      */\n@@ -114,21 +114,21 @@ class HTTPRequest\n      * main thread, do not call any other HTTPRequest methods after calling this.\n      */\n     void WriteReply(int nStatus, const std::string& strReply = \"\");\n-};\n+%>;\n \n /** Event handler closure.\n  */\n class HTTPClosure\n-{\n+<%\n public:\n     virtual void operator()() = 0;\n-    virtual ~HTTPClosure() {}\n-};\n+    virtual ~HTTPClosure() <%%>\n+%>;\n \n /** Event class. This can be used either as a cross-thread trigger or as a timer.\n  */\n class HTTPEvent\n-{\n+<%\n public:\n     /** Create a new event.\n      * deleteWhenTriggered deletes this event object after the event is triggered (and the handler called)\n@@ -146,7 +146,7 @@ class HTTPEvent\n     std::function<void()> handler;\n private:\n     struct event* ev;\n-};\n+%>;\n \n std::string urlDecode(const std::string &urlEncoded);\n "
      },
      {
        "sha": "d5d0b5ebef6fdcade468f472acbf8c55bd048485",
        "filename": "src/index/base.cpp",
        "status": "modified",
        "additions": 95,
        "deletions": 95,
        "changes": 190,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/index/base.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/index/base.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/base.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -18,265 +18,265 @@ constexpr int64_t SYNC_LOCATOR_WRITE_INTERVAL = 30; // seconds\n \n template<typename... Args>\n static void FatalError(const char* fmt, const Args&... args)\n-{\n+<%\n     std::string strMessage = tfm::format(fmt, args...);\n     SetMiscWarning(strMessage);\n     LogPrintf(\"*** %s\\n\", strMessage);\n     uiInterface.ThreadSafeMessageBox(\n         \"Error: A fatal internal error occurred, see debug.log for details\",\n         \"\", CClientUIInterface::MSG_ERROR);\n     StartShutdown();\n-}\n+%>\n \n BaseIndex::DB::DB(const fs::path& path, size_t n_cache_size, bool f_memory, bool f_wipe, bool f_obfuscate) :\n     CDBWrapper(path, n_cache_size, f_memory, f_wipe, f_obfuscate)\n-{}\n+<%%>\n \n bool BaseIndex::DB::ReadBestBlock(CBlockLocator& locator) const\n-{\n+<%\n     bool success = Read(DB_BEST_BLOCK, locator);\n-    if (!success) {\n+    if (!success) <%\n         locator.SetNull();\n-    }\n+    %>\n     return success;\n-}\n+%>\n \n bool BaseIndex::DB::WriteBestBlock(const CBlockLocator& locator)\n-{\n+<%\n     return Write(DB_BEST_BLOCK, locator);\n-}\n+%>\n \n BaseIndex::~BaseIndex()\n-{\n+<%\n     Interrupt();\n     Stop();\n-}\n+%>\n \n bool BaseIndex::Init()\n-{\n+<%\n     CBlockLocator locator;\n-    if (!GetDB().ReadBestBlock(locator)) {\n+    if (!GetDB().ReadBestBlock(locator)) <%\n         locator.SetNull();\n-    }\n+    %>\n \n     LOCK(cs_main);\n-    if (locator.IsNull()) {\n+    if (locator.IsNull()) <%\n         m_best_block_index = nullptr;\n-    } else {\n+    %> else <%\n         m_best_block_index = FindForkInGlobalIndex(chainActive, locator);\n-    }\n+    %>\n     m_synced = m_best_block_index.load() == chainActive.Tip();\n     return true;\n-}\n+%>\n \n static const CBlockIndex* NextSyncBlock(const CBlockIndex* pindex_prev) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n+<%\n     AssertLockHeld(cs_main);\n \n-    if (!pindex_prev) {\n+    if (!pindex_prev) <%\n         return chainActive.Genesis();\n-    }\n+    %>\n \n     const CBlockIndex* pindex = chainActive.Next(pindex_prev);\n-    if (pindex) {\n+    if (pindex) <%\n         return pindex;\n-    }\n+    %>\n \n     return chainActive.Next(chainActive.FindFork(pindex_prev));\n-}\n+%>\n \n void BaseIndex::ThreadSync()\n-{\n+<%\n     const CBlockIndex* pindex = m_best_block_index.load();\n-    if (!m_synced) {\n+    if (!m_synced) <%\n         auto& consensus_params = Params().GetConsensus();\n \n         int64_t last_log_time = 0;\n         int64_t last_locator_write_time = 0;\n-        while (true) {\n-            if (m_interrupt) {\n+        while (true) <%\n+            if (m_interrupt) <%\n                 WriteBestBlock(pindex);\n                 return;\n-            }\n+            %>\n \n-            {\n+            <%\n                 LOCK(cs_main);\n                 const CBlockIndex* pindex_next = NextSyncBlock(pindex);\n-                if (!pindex_next) {\n+                if (!pindex_next) <%\n                     WriteBestBlock(pindex);\n                     m_best_block_index = pindex;\n                     m_synced = true;\n                     break;\n-                }\n+                %>\n                 pindex = pindex_next;\n-            }\n+            %>\n \n             int64_t current_time = GetTime();\n-            if (last_log_time + SYNC_LOG_INTERVAL < current_time) {\n+            if (last_log_time + SYNC_LOG_INTERVAL < current_time) <%\n                 LogPrintf(\"Syncing %s with block chain from height %d\\n\",\n                           GetName(), pindex->nHeight);\n                 last_log_time = current_time;\n-            }\n+            %>\n \n-            if (last_locator_write_time + SYNC_LOCATOR_WRITE_INTERVAL < current_time) {\n+            if (last_locator_write_time + SYNC_LOCATOR_WRITE_INTERVAL < current_time) <%\n                 WriteBestBlock(pindex);\n                 last_locator_write_time = current_time;\n-            }\n+            %>\n \n             CBlock block;\n-            if (!ReadBlockFromDisk(block, pindex, consensus_params)) {\n+            if (!ReadBlockFromDisk(block, pindex, consensus_params)) <%\n                 FatalError(\"%s: Failed to read block %s from disk\",\n                            __func__, pindex->GetBlockHash().ToString());\n                 return;\n-            }\n-            if (!WriteBlock(block, pindex)) {\n+            %>\n+            if (!WriteBlock(block, pindex)) <%\n                 FatalError(\"%s: Failed to write block %s to index database\",\n                            __func__, pindex->GetBlockHash().ToString());\n                 return;\n-            }\n-        }\n-    }\n+            %>\n+        %>\n+    %>\n \n-    if (pindex) {\n+    if (pindex) <%\n         LogPrintf(\"%s is enabled at height %d\\n\", GetName(), pindex->nHeight);\n-    } else {\n+    %> else <%\n         LogPrintf(\"%s is enabled\\n\", GetName());\n-    }\n-}\n+    %>\n+%>\n \n bool BaseIndex::WriteBestBlock(const CBlockIndex* block_index)\n-{\n+<%\n     LOCK(cs_main);\n-    if (!GetDB().WriteBestBlock(chainActive.GetLocator(block_index))) {\n+    if (!GetDB().WriteBestBlock(chainActive.GetLocator(block_index))) <%\n         return error(\"%s: Failed to write locator to disk\", __func__);\n-    }\n+    %>\n     return true;\n-}\n+%>\n \n void BaseIndex::BlockConnected(const std::shared_ptr<const CBlock>& block, const CBlockIndex* pindex,\n                                const std::vector<CTransactionRef>& txn_conflicted)\n-{\n-    if (!m_synced) {\n+<%\n+    if (!m_synced) <%\n         return;\n-    }\n+    %>\n \n     const CBlockIndex* best_block_index = m_best_block_index.load();\n-    if (!best_block_index) {\n-        if (pindex->nHeight != 0) {\n+    if (!best_block_index) <%\n+        if (pindex->nHeight != 0) <%\n             FatalError(\"%s: First block connected is not the genesis block (height=%d)\",\n                        __func__, pindex->nHeight);\n             return;\n-        }\n-    } else {\n+        %>\n+    %> else <%\n         // Ensure block connects to an ancestor of the current best block. This should be the case\n         // most of the time, but may not be immediately after the sync thread catches up and sets\n         // m_synced. Consider the case where there is a reorg and the blocks on the stale branch are\n         // in the ValidationInterface queue backlog even after the sync thread has caught up to the\n         // new chain tip. In this unlikely event, log a warning and let the queue clear.\n-        if (best_block_index->GetAncestor(pindex->nHeight - 1) != pindex->pprev) {\n+        if (best_block_index->GetAncestor(pindex->nHeight - 1) != pindex->pprev) <%\n             LogPrintf(\"%s: WARNING: Block %s does not connect to an ancestor of \" /* Continued */\n                       \"known best chain (tip=%s); not updating index\\n\",\n                       __func__, pindex->GetBlockHash().ToString(),\n                       best_block_index->GetBlockHash().ToString());\n             return;\n-        }\n-    }\n+        %>\n+    %>\n \n-    if (WriteBlock(*block, pindex)) {\n+    if (WriteBlock(*block, pindex)) <%\n         m_best_block_index = pindex;\n-    } else {\n+    %> else <%\n         FatalError(\"%s: Failed to write block %s to index\",\n                    __func__, pindex->GetBlockHash().ToString());\n         return;\n-    }\n-}\n+    %>\n+%>\n \n void BaseIndex::ChainStateFlushed(const CBlockLocator& locator)\n-{\n-    if (!m_synced) {\n+<%\n+    if (!m_synced) <%\n         return;\n-    }\n+    %>\n \n     const uint256& locator_tip_hash = locator.vHave.front();\n     const CBlockIndex* locator_tip_index;\n-    {\n+    <%\n         LOCK(cs_main);\n         locator_tip_index = LookupBlockIndex(locator_tip_hash);\n-    }\n+    %>\n \n-    if (!locator_tip_index) {\n+    if (!locator_tip_index) <%\n         FatalError(\"%s: First block (hash=%s) in locator was not found\",\n                    __func__, locator_tip_hash.ToString());\n         return;\n-    }\n+    %>\n \n     // This checks that ChainStateFlushed callbacks are received after BlockConnected. The check may fail\n     // immediately after the sync thread catches up and sets m_synced. Consider the case where\n     // there is a reorg and the blocks on the stale branch are in the ValidationInterface queue\n     // backlog even after the sync thread has caught up to the new chain tip. In this unlikely\n     // event, log a warning and let the queue clear.\n     const CBlockIndex* best_block_index = m_best_block_index.load();\n-    if (best_block_index->GetAncestor(locator_tip_index->nHeight) != locator_tip_index) {\n+    if (best_block_index->GetAncestor(locator_tip_index->nHeight) != locator_tip_index) <%\n         LogPrintf(\"%s: WARNING: Locator contains block (hash=%s) not on known best \" /* Continued */\n                   \"chain (tip=%s); not writing index locator\\n\",\n                   __func__, locator_tip_hash.ToString(),\n                   best_block_index->GetBlockHash().ToString());\n         return;\n-    }\n+    %>\n \n-    if (!GetDB().WriteBestBlock(locator)) {\n+    if (!GetDB().WriteBestBlock(locator)) <%\n         error(\"%s: Failed to write locator to disk\", __func__);\n-    }\n-}\n+    %>\n+%>\n \n bool BaseIndex::BlockUntilSyncedToCurrentChain()\n-{\n+<%\n     AssertLockNotHeld(cs_main);\n \n-    if (!m_synced) {\n+    if (!m_synced) <%\n         return false;\n-    }\n+    %>\n \n-    {\n+    <%\n         // Skip the queue-draining stuff if we know we're caught up with\n         // chainActive.Tip().\n         LOCK(cs_main);\n         const CBlockIndex* chain_tip = chainActive.Tip();\n         const CBlockIndex* best_block_index = m_best_block_index.load();\n-        if (best_block_index->GetAncestor(chain_tip->nHeight) == chain_tip) {\n+        if (best_block_index->GetAncestor(chain_tip->nHeight) == chain_tip) <%\n             return true;\n-        }\n-    }\n+        %>\n+    %>\n \n     LogPrintf(\"%s: %s is catching up on block notifications\\n\", __func__, GetName());\n     SyncWithValidationInterfaceQueue();\n     return true;\n-}\n+%>\n \n void BaseIndex::Interrupt()\n-{\n+<%\n     m_interrupt();\n-}\n+%>\n \n void BaseIndex::Start()\n-{\n+<%\n     // Need to register this ValidationInterface before running Init(), so that\n     // callbacks are not missed if Init sets m_synced to true.\n     RegisterValidationInterface(this);\n-    if (!Init()) {\n+    if (!Init()) <%\n         FatalError(\"%s: %s failed to initialize\", __func__, GetName());\n         return;\n-    }\n+    %>\n \n     m_thread_sync = std::thread(&TraceThread<std::function<void()>>, GetName(),\n                                 std::bind(&BaseIndex::ThreadSync, this));\n-}\n+%>\n \n void BaseIndex::Stop()\n-{\n+<%\n     UnregisterValidationInterface(this);\n \n-    if (m_thread_sync.joinable()) {\n+    if (m_thread_sync.joinable()) <%\n         m_thread_sync.join();\n-    }\n-}\n+    %>\n+%>"
      },
      {
        "sha": "bf169ca3b4c4967f1d7895d0539be5963c435391",
        "filename": "src/index/base.h",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/index/base.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/index/base.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/base.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -20,10 +20,10 @@ class CBlockIndex;\n  * to their position in the active chain.\n  */\n class BaseIndex : public CValidationInterface\n-{\n+<%\n protected:\n     class DB : public CDBWrapper\n-    {\n+    <%\n     public:\n         DB(const fs::path& path, size_t n_cache_size,\n            bool f_memory = false, bool f_wipe = false, bool f_obfuscate = false);\n@@ -33,16 +33,16 @@ class BaseIndex : public CValidationInterface\n \n         /// Write block locator of the chain that the txindex is in sync with.\n         bool WriteBestBlock(const CBlockLocator& locator);\n-    };\n+    %>;\n \n private:\n     /// Whether the index is in sync with the main chain. The flag is flipped\n     /// from false to true once, after which point this starts processing\n     /// ValidationInterface notifications to stay in sync.\n-    std::atomic<bool> m_synced{false};\n+    std::atomic<bool> m_synced<%false%>;\n \n     /// The last block in the chain that the index is in sync with.\n-    std::atomic<const CBlockIndex*> m_best_block_index{nullptr};\n+    std::atomic<const CBlockIndex*> m_best_block_index<%nullptr%>;\n \n     std::thread m_thread_sync;\n     CThreadInterrupt m_interrupt;\n@@ -67,7 +67,7 @@ class BaseIndex : public CValidationInterface\n     virtual bool Init();\n \n     /// Write update index entries for a newly connected block.\n-    virtual bool WriteBlock(const CBlock& block, const CBlockIndex* pindex) { return true; }\n+    virtual bool WriteBlock(const CBlock& block, const CBlockIndex* pindex) <% return true; %>\n \n     virtual DB& GetDB() const = 0;\n \n@@ -93,6 +93,6 @@ class BaseIndex : public CValidationInterface\n \n     /// Stops the instance from staying in sync with blockchain updates.\n     void Stop();\n-};\n+%>;\n \n #endif // BITCOIN_INDEX_BASE_H"
      },
      {
        "sha": "a5b7085424095a91560a6ff78c221c316cab65e9",
        "filename": "src/index/txindex.cpp",
        "status": "modified",
        "additions": 76,
        "deletions": 76,
        "changes": 152,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/index/txindex.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/index/txindex.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/txindex.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -17,29 +17,29 @@ constexpr char DB_TXINDEX_BLOCK = 'T';\n std::unique_ptr<TxIndex> g_txindex;\n \n struct CDiskTxPos : public FlatFilePos\n-{\n+<%\n     unsigned int nTxOffset; // after header\n \n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action) {\n+    inline void SerializationOp(Stream& s, Operation ser_action) <%\n         READWRITEAS(FlatFilePos, *this);\n         READWRITE(VARINT(nTxOffset));\n-    }\n+    %>\n \n-    CDiskTxPos(const FlatFilePos &blockIn, unsigned int nTxOffsetIn) : FlatFilePos(blockIn.nFile, blockIn.nPos), nTxOffset(nTxOffsetIn) {\n-    }\n+    CDiskTxPos(const FlatFilePos &blockIn, unsigned int nTxOffsetIn) : FlatFilePos(blockIn.nFile, blockIn.nPos), nTxOffset(nTxOffsetIn) <%\n+    %>\n \n-    CDiskTxPos() {\n+    CDiskTxPos() <%\n         SetNull();\n-    }\n+    %>\n \n-    void SetNull() {\n+    void SetNull() <%\n         FlatFilePos::SetNull();\n         nTxOffset = 0;\n-    }\n-};\n+    %>\n+%>;\n \n /**\n  * Access to the txindex database (indexes/txindex/)\n@@ -51,7 +51,7 @@ struct CDiskTxPos : public FlatFilePos\n  * is updated.\n  */\n class TxIndex::DB : public BaseIndex::DB\n-{\n+<%\n public:\n     explicit DB(size_t n_cache_size, bool f_memory = false, bool f_wipe = false);\n \n@@ -65,25 +65,25 @@ class TxIndex::DB : public BaseIndex::DB\n     /// Migrate txindex data from the block tree DB, where it may be for older nodes that have not\n     /// been upgraded yet to the new database.\n     bool MigrateData(CBlockTreeDB& block_tree_db, const CBlockLocator& best_locator);\n-};\n+%>;\n \n TxIndex::DB::DB(size_t n_cache_size, bool f_memory, bool f_wipe) :\n     BaseIndex::DB(GetDataDir() / \"indexes\" / \"txindex\", n_cache_size, f_memory, f_wipe)\n-{}\n+<%%>\n \n bool TxIndex::DB::ReadTxPos(const uint256 &txid, CDiskTxPos& pos) const\n-{\n+<%\n     return Read(std::make_pair(DB_TXINDEX, txid), pos);\n-}\n+%>\n \n bool TxIndex::DB::WriteTxs(const std::vector<std::pair<uint256, CDiskTxPos>>& v_pos)\n-{\n+<%\n     CDBBatch batch(*this);\n-    for (const auto& tuple : v_pos) {\n+    for (const auto& tuple : v_pos) <%\n         batch.Write(std::make_pair(DB_TXINDEX, tuple.first), tuple.second);\n-    }\n+    %>\n     return WriteBatch(batch);\n-}\n+%>\n \n /*\n  * Safely persist a transfer of data from the old txindex database to the new one, and compact the\n@@ -93,18 +93,18 @@ static void WriteTxIndexMigrationBatches(CDBWrapper& newdb, CDBWrapper& olddb,\n                                          CDBBatch& batch_newdb, CDBBatch& batch_olddb,\n                                          const std::pair<unsigned char, uint256>& begin_key,\n                                          const std::pair<unsigned char, uint256>& end_key)\n-{\n+<%\n     // Sync new DB changes to disk before deleting from old DB.\n     newdb.WriteBatch(batch_newdb, /*fSync=*/ true);\n     olddb.WriteBatch(batch_olddb);\n     olddb.CompactRange(begin_key, end_key);\n \n     batch_newdb.Clear();\n     batch_olddb.Clear();\n-}\n+%>\n \n bool TxIndex::DB::MigrateData(CBlockTreeDB& block_tree_db, const CBlockLocator& best_locator)\n-{\n+<%\n     // The prior implementation of txindex was always in sync with block index\n     // and presence was indicated with a boolean DB flag. If the flag is set,\n     // this means the txindex from a previous version is valid and in sync with\n@@ -121,19 +121,19 @@ bool TxIndex::DB::MigrateData(CBlockTreeDB& block_tree_db, const CBlockLocator&\n     // with hash DB_TXINDEX_BLOCK.\n     bool f_legacy_flag = false;\n     block_tree_db.ReadFlag(\"txindex\", f_legacy_flag);\n-    if (f_legacy_flag) {\n-        if (!block_tree_db.Write(DB_TXINDEX_BLOCK, best_locator)) {\n+    if (f_legacy_flag) <%\n+        if (!block_tree_db.Write(DB_TXINDEX_BLOCK, best_locator)) <%\n             return error(\"%s: cannot write block indicator\", __func__);\n-        }\n-        if (!block_tree_db.WriteFlag(\"txindex\", false)) {\n+        %>\n+        if (!block_tree_db.WriteFlag(\"txindex\", false)) <%\n             return error(\"%s: cannot write block index db flag\", __func__);\n-        }\n-    }\n+        %>\n+    %>\n \n     CBlockLocator locator;\n-    if (!block_tree_db.Read(DB_TXINDEX_BLOCK, locator)) {\n+    if (!block_tree_db.Read(DB_TXINDEX_BLOCK, locator)) <%\n         return true;\n-    }\n+    %>\n \n     int64_t count = 0;\n     LogPrintf(\"Upgrading txindex database... [0%%]\\n\");\n@@ -145,27 +145,27 @@ bool TxIndex::DB::MigrateData(CBlockTreeDB& block_tree_db, const CBlockLocator&\n     CDBBatch batch_olddb(block_tree_db);\n \n     std::pair<unsigned char, uint256> key;\n-    std::pair<unsigned char, uint256> begin_key{DB_TXINDEX, uint256()};\n+    std::pair<unsigned char, uint256> begin_key<%DB_TXINDEX, uint256()%>;\n     std::pair<unsigned char, uint256> prev_key = begin_key;\n \n     bool interrupted = false;\n     std::unique_ptr<CDBIterator> cursor(block_tree_db.NewIterator());\n-    for (cursor->Seek(begin_key); cursor->Valid(); cursor->Next()) {\n+    for (cursor->Seek(begin_key); cursor->Valid(); cursor->Next()) <%\n         boost::this_thread::interruption_point();\n-        if (ShutdownRequested()) {\n+        if (ShutdownRequested()) <%\n             interrupted = true;\n             break;\n-        }\n+        %>\n \n-        if (!cursor->GetKey(key)) {\n+        if (!cursor->GetKey(key)) <%\n             return error(\"%s: cannot get key from valid cursor\", __func__);\n-        }\n-        if (key.first != DB_TXINDEX) {\n+        %>\n+        if (key.first != DB_TXINDEX) <%\n             break;\n-        }\n+        %>\n \n         // Log progress every 10%.\n-        if (++count % 256 == 0) {\n+        if (++count % 256 == 0) <%\n             // Since txids are uniformly random and traversed in increasing order, the high 16 bits\n             // of the hash can be used to estimate the current progress.\n             const uint256& txid = key.second;\n@@ -175,115 +175,115 @@ bool TxIndex::DB::MigrateData(CBlockTreeDB& block_tree_db, const CBlockLocator&\n             int percentage_done = (int)(high_nibble * 100.0 / 65536.0 + 0.5);\n \n             uiInterface.ShowProgress(_(\"Upgrading txindex database\"), percentage_done, true);\n-            if (report_done < percentage_done/10) {\n+            if (report_done < percentage_done/10) <%\n                 LogPrintf(\"Upgrading txindex database... [%d%%]\\n\", percentage_done);\n                 report_done = percentage_done/10;\n-            }\n-        }\n+            %>\n+        %>\n \n         CDiskTxPos value;\n-        if (!cursor->GetValue(value)) {\n+        if (!cursor->GetValue(value)) <%\n             return error(\"%s: cannot parse txindex record\", __func__);\n-        }\n+        %>\n         batch_newdb.Write(key, value);\n         batch_olddb.Erase(key);\n \n-        if (batch_newdb.SizeEstimate() > batch_size || batch_olddb.SizeEstimate() > batch_size) {\n+        if (batch_newdb.SizeEstimate() > batch_size || batch_olddb.SizeEstimate() > batch_size) <%\n             // NOTE: it's OK to delete the key pointed at by the current DB cursor while iterating\n             // because LevelDB iterators are guaranteed to provide a consistent view of the\n             // underlying data, like a lightweight snapshot.\n             WriteTxIndexMigrationBatches(*this, block_tree_db,\n                                          batch_newdb, batch_olddb,\n                                          prev_key, key);\n             prev_key = key;\n-        }\n-    }\n+        %>\n+    %>\n \n     // If these final DB batches complete the migration, write the best block\n     // hash marker to the new database and delete from the old one. This signals\n     // that the former is fully caught up to that point in the blockchain and\n     // that all txindex entries have been removed from the latter.\n-    if (!interrupted) {\n+    if (!interrupted) <%\n         batch_olddb.Erase(DB_TXINDEX_BLOCK);\n         batch_newdb.Write(DB_BEST_BLOCK, locator);\n-    }\n+    %>\n \n     WriteTxIndexMigrationBatches(*this, block_tree_db,\n                                  batch_newdb, batch_olddb,\n                                  begin_key, key);\n \n-    if (interrupted) {\n+    if (interrupted) <%\n         LogPrintf(\"[CANCELLED].\\n\");\n         return false;\n-    }\n+    %>\n \n     uiInterface.ShowProgress(\"\", 100, false);\n \n     LogPrintf(\"[DONE].\\n\");\n     return true;\n-}\n+%>\n \n TxIndex::TxIndex(size_t n_cache_size, bool f_memory, bool f_wipe)\n     : m_db(MakeUnique<TxIndex::DB>(n_cache_size, f_memory, f_wipe))\n-{}\n+<%%>\n \n-TxIndex::~TxIndex() {}\n+TxIndex::~TxIndex() <%%>\n \n bool TxIndex::Init()\n-{\n+<%\n     LOCK(cs_main);\n \n     // Attempt to migrate txindex from the old database to the new one. Even if\n     // chain_tip is null, the node could be reindexing and we still want to\n     // delete txindex records in the old database.\n-    if (!m_db->MigrateData(*pblocktree, chainActive.GetLocator())) {\n+    if (!m_db->MigrateData(*pblocktree, chainActive.GetLocator())) <%\n         return false;\n-    }\n+    %>\n \n     return BaseIndex::Init();\n-}\n+%>\n \n bool TxIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)\n-{\n+<%\n     // Exclude genesis block transaction because outputs are not spendable.\n     if (pindex->nHeight == 0) return true;\n \n     CDiskTxPos pos(pindex->GetBlockPos(), GetSizeOfCompactSize(block.vtx.size()));\n     std::vector<std::pair<uint256, CDiskTxPos>> vPos;\n     vPos.reserve(block.vtx.size());\n-    for (const auto& tx : block.vtx) {\n+    for (const auto& tx : block.vtx) <%\n         vPos.emplace_back(tx->GetHash(), pos);\n         pos.nTxOffset += ::GetSerializeSize(*tx, CLIENT_VERSION);\n-    }\n+    %>\n     return m_db->WriteTxs(vPos);\n-}\n+%>\n \n-BaseIndex::DB& TxIndex::GetDB() const { return *m_db; }\n+BaseIndex::DB& TxIndex::GetDB() const <% return *m_db; %>\n \n bool TxIndex::FindTx(const uint256& tx_hash, uint256& block_hash, CTransactionRef& tx) const\n-{\n+<%\n     CDiskTxPos postx;\n-    if (!m_db->ReadTxPos(tx_hash, postx)) {\n+    if (!m_db->ReadTxPos(tx_hash, postx)) <%\n         return false;\n-    }\n+    %>\n \n     CAutoFile file(OpenBlockFile(postx, true), SER_DISK, CLIENT_VERSION);\n-    if (file.IsNull()) {\n+    if (file.IsNull()) <%\n         return error(\"%s: OpenBlockFile failed\", __func__);\n-    }\n+    %>\n     CBlockHeader header;\n-    try {\n+    try <%\n         file >> header;\n-        if (fseek(file.Get(), postx.nTxOffset, SEEK_CUR)) {\n+        if (fseek(file.Get(), postx.nTxOffset, SEEK_CUR)) <%\n             return error(\"%s: fseek(...) failed\", __func__);\n-        }\n+        %>\n         file >> tx;\n-    } catch (const std::exception& e) {\n+    %> catch (const std::exception& e) <%\n         return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n-    }\n-    if (tx->GetHash() != tx_hash) {\n+    %>\n+    if (tx->GetHash() != tx_hash) <%\n         return error(\"%s: txid mismatch\", __func__);\n-    }\n+    %>\n     block_hash = header.GetHash();\n     return true;\n-}\n+%>"
      },
      {
        "sha": "a0bf5eeb6dd83e52cbae3633abc00e6dc086fcf7",
        "filename": "src/index/txindex.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/index/txindex.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/index/txindex.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/txindex.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -15,7 +15,7 @@\n  * location of each transaction by transaction hash.\n  */\n class TxIndex final : public BaseIndex\n-{\n+<%\n protected:\n     class DB;\n \n@@ -30,7 +30,7 @@ class TxIndex final : public BaseIndex\n \n     BaseIndex::DB& GetDB() const override;\n \n-    const char* GetName() const override { return \"txindex\"; }\n+    const char* GetName() const override <% return \"txindex\"; %>\n \n public:\n     /// Constructs the index, which becomes available to be queried.\n@@ -46,7 +46,7 @@ class TxIndex final : public BaseIndex\n     /// @param[out]  tx  The transaction itself.\n     /// @return  true if transaction is found, false otherwise\n     bool FindTx(const uint256& tx_hash, uint256& block_hash, CTransactionRef& tx) const;\n-};\n+%>;\n \n /// The global transaction index, used in GetTransaction. May be null.\n extern std::unique_ptr<TxIndex> g_txindex;"
      },
      {
        "sha": "5dee5afded3b88cf2b9599d14018c2c938703a5b",
        "filename": "src/indirectmap.h",
        "status": "modified",
        "additions": 20,
        "deletions": 20,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/indirectmap.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/indirectmap.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/indirectmap.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -6,7 +6,7 @@\n #define BITCOIN_INDIRECTMAP_H\n \n template <class T>\n-struct DereferencingComparator { bool operator()(const T a, const T b) const { return *a < *b; } };\n+struct DereferencingComparator <% bool operator()(const T a, const T b) const <% return *a < *b; %> %>;\n \n /* Map whose keys are pointers, but are compared by their dereferenced values.\n  *\n@@ -19,7 +19,7 @@ struct DereferencingComparator { bool operator()(const T a, const T b) const { r\n  * result of DereferencingComparator.\n  */\n template <class K, class T>\n-class indirectmap {\n+class indirectmap <%\n private:\n     typedef std::map<const K*, T, DereferencingComparator<const K*> > base;\n     base m;\n@@ -30,27 +30,27 @@ class indirectmap {\n     typedef typename base::value_type value_type;\n \n     // passthrough (pointer interface)\n-    std::pair<iterator, bool> insert(const value_type& value) { return m.insert(value); }\n+    std::pair<iterator, bool> insert(const value_type& value) <% return m.insert(value); %>\n \n     // pass address (value interface)\n-    iterator find(const K& key)                     { return m.find(&key); }\n-    const_iterator find(const K& key) const         { return m.find(&key); }\n-    iterator lower_bound(const K& key)              { return m.lower_bound(&key); }\n-    const_iterator lower_bound(const K& key) const  { return m.lower_bound(&key); }\n-    size_type erase(const K& key)                   { return m.erase(&key); }\n-    size_type count(const K& key) const             { return m.count(&key); }\n+    iterator find(const K& key)                     <% return m.find(&key); %>\n+    const_iterator find(const K& key) const         <% return m.find(&key); %>\n+    iterator lower_bound(const K& key)              <% return m.lower_bound(&key); %>\n+    const_iterator lower_bound(const K& key) const  <% return m.lower_bound(&key); %>\n+    size_type erase(const K& key)                   <% return m.erase(&key); %>\n+    size_type count(const K& key) const             <% return m.count(&key); %>\n \n     // passthrough\n-    bool empty() const              { return m.empty(); }\n-    size_type size() const          { return m.size(); }\n-    size_type max_size() const      { return m.max_size(); }\n-    void clear()                    { m.clear(); }\n-    iterator begin()                { return m.begin(); }\n-    iterator end()                  { return m.end(); }\n-    const_iterator begin() const    { return m.begin(); }\n-    const_iterator end() const      { return m.end(); }\n-    const_iterator cbegin() const   { return m.cbegin(); }\n-    const_iterator cend() const     { return m.cend(); }\n-};\n+    bool empty() const              <% return m.empty(); %>\n+    size_type size() const          <% return m.size(); %>\n+    size_type max_size() const      <% return m.max_size(); %>\n+    void clear()                    <% m.clear(); %>\n+    iterator begin()                <% return m.begin(); %>\n+    iterator end()                  <% return m.end(); %>\n+    const_iterator begin() const    <% return m.begin(); %>\n+    const_iterator end() const      <% return m.end(); %>\n+    const_iterator cbegin() const   <% return m.cbegin(); %>\n+    const_iterator cend() const     <% return m.cend(); %>\n+%>;\n \n #endif // BITCOIN_INDIRECTMAP_H"
      },
      {
        "sha": "3077b62a0331184e7fd0fd3e964f5c0748fd1b3f",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 379,
        "deletions": 379,
        "changes": 758,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -100,25 +100,25 @@ static const char* FEE_ESTIMATES_FILENAME=\"fee_estimates.dat\";\n static const char* BITCOIN_PID_FILENAME = \"bitcoind.pid\";\n \n static fs::path GetPidFile()\n-{\n+<%\n     return AbsPathForConfigVal(fs::path(gArgs.GetArg(\"-pid\", BITCOIN_PID_FILENAME)));\n-}\n+%>\n \n NODISCARD static bool CreatePidFile()\n-{\n+<%\n     FILE* file = fsbridge::fopen(GetPidFile(), \"w\");\n-    if (file) {\n+    if (file) <%\n #ifdef WIN32\n         fprintf(file, \"%d\\n\", GetCurrentProcessId());\n #else\n         fprintf(file, \"%d\\n\", getpid());\n #endif\n         fclose(file);\n         return true;\n-    } else {\n+    %> else <%\n         return InitError(strprintf(_(\"Unable to create the PID file '%s': %s\"), GetPidFile().string(), std::strerror(errno)));\n-    }\n-}\n+    %>\n+%>\n \n //////////////////////////////////////////////////////////////////////////////\n //\n@@ -151,24 +151,24 @@ NODISCARD static bool CreatePidFile()\n  * between bitcoind, and bitcoin-qt and non-server tools.\n */\n class CCoinsViewErrorCatcher final : public CCoinsViewBacked\n-{\n+<%\n public:\n-    explicit CCoinsViewErrorCatcher(CCoinsView* view) : CCoinsViewBacked(view) {}\n-    bool GetCoin(const COutPoint &outpoint, Coin &coin) const override {\n-        try {\n+    explicit CCoinsViewErrorCatcher(CCoinsView* view) : CCoinsViewBacked(view) <%%>\n+    bool GetCoin(const COutPoint &outpoint, Coin &coin) const override <%\n+        try <%\n             return CCoinsViewBacked::GetCoin(outpoint, coin);\n-        } catch(const std::runtime_error& e) {\n+        %> catch(const std::runtime_error& e) <%\n             uiInterface.ThreadSafeMessageBox(_(\"Error reading from database, shutting down.\"), \"\", CClientUIInterface::MSG_ERROR);\n             LogPrintf(\"Error reading from database: %s\\n\", e.what());\n             // Starting the shutdown sequence and returning false to the caller would be\n             // interpreted as 'entry not found' (as opposed to unable to read data), and\n             // could lead to invalid interpretation. Just exit immediately, as we can't\n             // continue anyway, and all writes should be atomic.\n             abort();\n-        }\n-    }\n+        %>\n+    %>\n     // Writes do not need similar protection, as failure to write is handled by the caller.\n-};\n+%>;\n \n static std::unique_ptr<CCoinsViewErrorCatcher> pcoinscatcher;\n static std::unique_ptr<ECCVerifyHandle> globalVerifyHandle;\n@@ -177,7 +177,7 @@ static boost::thread_group threadGroup;\n static CScheduler scheduler;\n \n void Interrupt()\n-{\n+<%\n     InterruptHTTPServer();\n     InterruptHTTPRPC();\n     InterruptRPC();\n@@ -186,13 +186,13 @@ void Interrupt()\n     InterruptMapPort();\n     if (g_connman)\n         g_connman->Interrupt();\n-    if (g_txindex) {\n+    if (g_txindex) <%\n         g_txindex->Interrupt();\n-    }\n-}\n+    %>\n+%>\n \n void Shutdown(InitInterfaces& interfaces)\n-{\n+<%\n     LogPrintf(\"%s: In progress...\\n\", __func__);\n     static CCriticalSection cs_Shutdown;\n     TRY_LOCK(cs_Shutdown, lockShutdown);\n@@ -210,9 +210,9 @@ void Shutdown(InitInterfaces& interfaces)\n     StopREST();\n     StopRPC();\n     StopHTTPServer();\n-    for (const auto& client : interfaces.chain_clients) {\n+    for (const auto& client : interfaces.chain_clients) <%\n         client->flush();\n-    }\n+    %>\n     StopMapPort();\n \n     // Because these depend on each-other, we make sure that neither can be\n@@ -235,12 +235,12 @@ void Shutdown(InitInterfaces& interfaces)\n     g_banman.reset();\n     g_txindex.reset();\n \n-    if (g_is_mempool_loaded && gArgs.GetArg(\"-persistmempool\", DEFAULT_PERSIST_MEMPOOL)) {\n+    if (g_is_mempool_loaded && gArgs.GetArg(\"-persistmempool\", DEFAULT_PERSIST_MEMPOOL)) <%\n         DumpMempool();\n-    }\n+    %>\n \n     if (fFeeEstimatesInitialized)\n-    {\n+    <%\n         ::feeEstimator.FlushUnconfirmed();\n         fs::path est_path = GetDataDir() / FEE_ESTIMATES_FILENAME;\n         CAutoFile est_fileout(fsbridge::fopen(est_path, \"wb\"), SER_DISK, CLIENT_VERSION);\n@@ -249,12 +249,12 @@ void Shutdown(InitInterfaces& interfaces)\n         else\n             LogPrintf(\"%s: Failed to write fee estimates to %s\\n\", __func__, est_path.string());\n         fFeeEstimatesInitialized = false;\n-    }\n+    %>\n \n     // FlushStateToDisk generates a ChainStateFlushed callback, which we should avoid missing\n-    if (pcoinsTip != nullptr) {\n+    if (pcoinsTip != nullptr) <%\n         FlushStateToDisk();\n-    }\n+    %>\n \n     // After there are no more peers/RPC left to give us new data which may generate\n     // CValidationInterface callbacks, flush them...\n@@ -266,43 +266,43 @@ void Shutdown(InitInterfaces& interfaces)\n     // up with our current chain to avoid any strange pruning edge cases and make\n     // next startup faster by avoiding rescan.\n \n-    {\n+    <%\n         LOCK(cs_main);\n-        if (pcoinsTip != nullptr) {\n+        if (pcoinsTip != nullptr) <%\n             FlushStateToDisk();\n-        }\n+        %>\n         pcoinsTip.reset();\n         pcoinscatcher.reset();\n         pcoinsdbview.reset();\n         pblocktree.reset();\n-    }\n-    for (const auto& client : interfaces.chain_clients) {\n+    %>\n+    for (const auto& client : interfaces.chain_clients) <%\n         client->stop();\n-    }\n+    %>\n \n #if ENABLE_ZMQ\n-    if (g_zmq_notification_interface) {\n+    if (g_zmq_notification_interface) <%\n         UnregisterValidationInterface(g_zmq_notification_interface);\n         delete g_zmq_notification_interface;\n         g_zmq_notification_interface = nullptr;\n-    }\n+    %>\n #endif\n \n-    try {\n-        if (!fs::remove(GetPidFile())) {\n+    try <%\n+        if (!fs::remove(GetPidFile())) <%\n             LogPrintf(\"%s: Unable to remove PID file: File does not exist\\n\", __func__);\n-        }\n-    } catch (const fs::filesystem_error& e) {\n+        %>\n+    %> catch (const fs::filesystem_error& e) <%\n         LogPrintf(\"%s: Unable to remove PID file: %s\\n\", __func__, fsbridge::get_filesystem_error_message(e));\n-    }\n+    %>\n     interfaces.chain_clients.clear();\n     UnregisterAllValidationInterfaces();\n     GetMainSignals().UnregisterBackgroundSignalScheduler();\n     GetMainSignals().UnregisterWithMempoolSignals(mempool);\n     globalVerifyHandle.reset();\n     ECC_Stop();\n     LogPrintf(\"%s: done\\n\", __func__);\n-}\n+%>\n \n /**\n  * Signal handlers are very limited in what they are allowed to do.\n@@ -311,49 +311,49 @@ void Shutdown(InitInterfaces& interfaces)\n  */\n #ifndef WIN32\n static void HandleSIGTERM(int)\n-{\n+<%\n     StartShutdown();\n-}\n+%>\n \n static void HandleSIGHUP(int)\n-{\n+<%\n     LogInstance().m_reopen_file = true;\n-}\n+%>\n #else\n static BOOL WINAPI consoleCtrlHandler(DWORD dwCtrlType)\n-{\n+<%\n     StartShutdown();\n     Sleep(INFINITE);\n     return true;\n-}\n+%>\n #endif\n \n #ifndef WIN32\n static void registerSignalHandler(int signal, void(*handler)(int))\n-{\n+<%\n     struct sigaction sa;\n     sa.sa_handler = handler;\n     sigemptyset(&sa.sa_mask);\n     sa.sa_flags = 0;\n     sigaction(signal, &sa, nullptr);\n-}\n+%>\n #endif\n \n static void OnRPCStarted()\n-{\n+<%\n     uiInterface.NotifyBlockTip_connect(&RPCNotifyBlockChange);\n-}\n+%>\n \n static void OnRPCStopped()\n-{\n+<%\n     uiInterface.NotifyBlockTip_disconnect(&RPCNotifyBlockChange);\n     RPCNotifyBlockChange(false, nullptr);\n     g_best_block_cv.notify_all();\n     LogPrint(BCLog::RPC, \"RPC stopped.\\n\");\n-}\n+%>\n \n void SetupServerArgs()\n-{\n+<%\n     SetupHelpOptions(gArgs);\n     gArgs.AddArg(\"-help-debug\", \"Print help message with debugging options and exit\", false, OptionsCategory::DEBUG_TEST); // server-only for now\n \n@@ -365,10 +365,10 @@ void SetupServerArgs()\n     const auto regtestChainParams = CreateChainParams(CBaseChainParams::REGTEST);\n \n     // Hidden Options\n-    std::vector<std::string> hidden_args = {\n+    std::vector<std::string> hidden_args = <%\n         \"-dbcrashratio\", \"-forcecompactdb\",\n         // GUI args. These will be overwritten by SetupUIArgs for the GUI\n-        \"-allowselfsignedrootcertificates\", \"-choosedatadir\", \"-lang=<lang>\", \"-min\", \"-resetguisettings\", \"-rootcertificates=<file>\", \"-splash\", \"-uiplatform\"};\n+        \"-allowselfsignedrootcertificates\", \"-choosedatadir\", \"-lang=<lang>\", \"-min\", \"-resetguisettings\", \"-rootcertificates=<file>\", \"-splash\", \"-uiplatform\"%>;\n \n     gArgs.AddArg(\"-version\", \"Print version and exit\", false, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-alertnotify=<cmd>\", \"Execute command when a relevant alert is received or we see a really long fork (%s in cmd is replaced by message)\", false, OptionsCategory::OPTIONS);\n@@ -548,10 +548,10 @@ void SetupServerArgs()\n \n     // Add the hidden options\n     gArgs.AddHiddenArgs(hidden_args);\n-}\n+%>\n \n std::string LicenseInfo()\n-{\n+<%\n     const std::string URL_SOURCE_CODE = \"<https://github.com/bitcoin/bitcoin>\";\n     const std::string URL_WEBSITE = \"<https://bitcoincore.org>\";\n \n@@ -570,48 +570,48 @@ std::string LicenseInfo()\n            \"\\n\" +\n            strprintf(_(\"This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit %s and cryptographic software written by Eric Young and UPnP software written by Thomas Bernard.\"), \"<https://www.openssl.org>\") +\n            \"\\n\";\n-}\n+%>\n \n static void BlockNotifyCallback(bool initialSync, const CBlockIndex *pBlockIndex)\n-{\n+<%\n     if (initialSync || !pBlockIndex)\n         return;\n \n     std::string strCmd = gArgs.GetArg(\"-blocknotify\", \"\");\n-    if (!strCmd.empty()) {\n+    if (!strCmd.empty()) <%\n         boost::replace_all(strCmd, \"%s\", pBlockIndex->GetBlockHash().GetHex());\n         std::thread t(runCommand, strCmd);\n         t.detach(); // thread runs free\n-    }\n-}\n+    %>\n+%>\n \n static bool fHaveGenesis = false;\n static Mutex g_genesis_wait_mutex;\n static std::condition_variable g_genesis_wait_cv;\n \n static void BlockNotifyGenesisWait(bool, const CBlockIndex *pBlockIndex)\n-{\n-    if (pBlockIndex != nullptr) {\n-        {\n+<%\n+    if (pBlockIndex != nullptr) <%\n+        <%\n             LOCK(g_genesis_wait_mutex);\n             fHaveGenesis = true;\n-        }\n+        %>\n         g_genesis_wait_cv.notify_all();\n-    }\n-}\n+    %>\n+%>\n \n struct CImportingNow\n-{\n-    CImportingNow() {\n+<%\n+    CImportingNow() <%\n         assert(fImporting == false);\n         fImporting = true;\n-    }\n+    %>\n \n-    ~CImportingNow() {\n+    ~CImportingNow() <%\n         assert(fImporting == true);\n         fImporting = false;\n-    }\n-};\n+    %>\n+%>;\n \n \n // If we're using -prune with -reindex, then delete block files that will be ignored by the\n@@ -621,53 +621,53 @@ struct CImportingNow\n // is in sync with what's actually on disk by the time we start downloading, so that pruning\n // works correctly.\n static void CleanupBlockRevFiles()\n-{\n+<%\n     std::map<std::string, fs::path> mapBlockFiles;\n \n     // Glob all blk?????.dat and rev?????.dat files from the blocks directory.\n     // Remove the rev files immediately and insert the blk file paths into an\n     // ordered map keyed by block file index.\n     LogPrintf(\"Removing unusable blk?????.dat and rev?????.dat files for -reindex with -prune\\n\");\n     fs::path blocksdir = GetBlocksDir();\n-    for (fs::directory_iterator it(blocksdir); it != fs::directory_iterator(); it++) {\n+    for (fs::directory_iterator it(blocksdir); it != fs::directory_iterator(); it++) <%\n         if (fs::is_regular_file(*it) &&\n             it->path().filename().string().length() == 12 &&\n             it->path().filename().string().substr(8,4) == \".dat\")\n-        {\n+        <%\n             if (it->path().filename().string().substr(0,3) == \"blk\")\n                 mapBlockFiles[it->path().filename().string().substr(3,5)] = it->path();\n             else if (it->path().filename().string().substr(0,3) == \"rev\")\n                 remove(it->path());\n-        }\n-    }\n+        %>\n+    %>\n \n     // Remove all block files that aren't part of a contiguous set starting at\n     // zero by walking the ordered map (keys are block file indices) by\n     // keeping a separate counter.  Once we hit a gap (or if 0 doesn't exist)\n     // start removing block files.\n     int nContigCounter = 0;\n-    for (const std::pair<const std::string, fs::path>& item : mapBlockFiles) {\n-        if (atoi(item.first) == nContigCounter) {\n+    for (const std::pair<const std::string, fs::path>& item : mapBlockFiles) <%\n+        if (atoi(item.first) == nContigCounter) <%\n             nContigCounter++;\n             continue;\n-        }\n+        %>\n         remove(item.second);\n-    }\n-}\n+    %>\n+%>\n \n static void ThreadImport(std::vector<fs::path> vImportFiles)\n-{\n+<%\n     const CChainParams& chainparams = Params();\n     RenameThread(\"bitcoin-loadblk\");\n     ScheduleBatchPriority();\n \n-    {\n+    <%\n     CImportingNow imp;\n \n     // -reindex\n-    if (fReindex) {\n+    if (fReindex) <%\n         int nFile = 0;\n-        while (true) {\n+        while (true) <%\n             FlatFilePos pos(nFile, 0);\n             if (!fs::exists(GetBlockPosFilename(pos)))\n                 break; // No block files left to reindex\n@@ -677,83 +677,83 @@ static void ThreadImport(std::vector<fs::path> vImportFiles)\n             LogPrintf(\"Reindexing block file blk%05u.dat...\\n\", (unsigned int)nFile);\n             LoadExternalBlockFile(chainparams, file, &pos);\n             nFile++;\n-        }\n+        %>\n         pblocktree->WriteReindexing(false);\n         fReindex = false;\n         LogPrintf(\"Reindexing finished\\n\");\n         // To avoid ending up in a situation without genesis block, re-try initializing (no-op if reindexing worked):\n         LoadGenesisBlock(chainparams);\n-    }\n+    %>\n \n     // hardcoded $DATADIR/bootstrap.dat\n     fs::path pathBootstrap = GetDataDir() / \"bootstrap.dat\";\n-    if (fs::exists(pathBootstrap)) {\n+    if (fs::exists(pathBootstrap)) <%\n         FILE *file = fsbridge::fopen(pathBootstrap, \"rb\");\n-        if (file) {\n+        if (file) <%\n             fs::path pathBootstrapOld = GetDataDir() / \"bootstrap.dat.old\";\n             LogPrintf(\"Importing bootstrap.dat...\\n\");\n             LoadExternalBlockFile(chainparams, file);\n             RenameOver(pathBootstrap, pathBootstrapOld);\n-        } else {\n+        %> else <%\n             LogPrintf(\"Warning: Could not open bootstrap file %s\\n\", pathBootstrap.string());\n-        }\n-    }\n+        %>\n+    %>\n \n     // -loadblock=\n-    for (const fs::path& path : vImportFiles) {\n+    for (const fs::path& path : vImportFiles) <%\n         FILE *file = fsbridge::fopen(path, \"rb\");\n-        if (file) {\n+        if (file) <%\n             LogPrintf(\"Importing blocks file %s...\\n\", path.string());\n             LoadExternalBlockFile(chainparams, file);\n-        } else {\n+        %> else <%\n             LogPrintf(\"Warning: Could not open blocks file %s\\n\", path.string());\n-        }\n-    }\n+        %>\n+    %>\n \n     // scan for better chains in the block chain database, that are not yet connected in the active best chain\n     CValidationState state;\n-    if (!ActivateBestChain(state, chainparams)) {\n+    if (!ActivateBestChain(state, chainparams)) <%\n         LogPrintf(\"Failed to connect best block (%s)\\n\", FormatStateMessage(state));\n         StartShutdown();\n         return;\n-    }\n+    %>\n \n-    if (gArgs.GetBoolArg(\"-stopafterblockimport\", DEFAULT_STOPAFTERBLOCKIMPORT)) {\n+    if (gArgs.GetBoolArg(\"-stopafterblockimport\", DEFAULT_STOPAFTERBLOCKIMPORT)) <%\n         LogPrintf(\"Stopping after block import\\n\");\n         StartShutdown();\n         return;\n-    }\n-    } // End scope of CImportingNow\n-    if (gArgs.GetArg(\"-persistmempool\", DEFAULT_PERSIST_MEMPOOL)) {\n+    %>\n+    %> // End scope of CImportingNow\n+    if (gArgs.GetArg(\"-persistmempool\", DEFAULT_PERSIST_MEMPOOL)) <%\n         LoadMempool();\n-    }\n+    %>\n     g_is_mempool_loaded = !ShutdownRequested();\n-}\n+%>\n \n /** Sanity checks\n  *  Ensure that Bitcoin is running in a usable environment with all\n  *  necessary library support.\n  */\n static bool InitSanityCheck()\n-{\n-    if(!ECC_InitSanityCheck()) {\n+<%\n+    if(!ECC_InitSanityCheck()) <%\n         InitError(\"Elliptic curve cryptography sanity check failure. Aborting.\");\n         return false;\n-    }\n+    %>\n \n     if (!glibc_sanity_test() || !glibcxx_sanity_test())\n         return false;\n \n-    if (!Random_SanityCheck()) {\n+    if (!Random_SanityCheck()) <%\n         InitError(\"OS cryptographic RNG sanity check failure. Aborting.\");\n         return false;\n-    }\n+    %>\n \n     return true;\n-}\n+%>\n \n static bool AppInitServers()\n-{\n+<%\n     RPCServer::OnStarted(&OnRPCStarted);\n     RPCServer::OnStopped(&OnRPCStopped);\n     if (!InitHTTPServer())\n@@ -764,31 +764,31 @@ static bool AppInitServers()\n     if (gArgs.GetBoolArg(\"-rest\", DEFAULT_REST_ENABLE)) StartREST();\n     StartHTTPServer();\n     return true;\n-}\n+%>\n \n // Parameter interaction based on rules\n void InitParameterInteraction()\n-{\n+<%\n     // when specifying an explicit binding address, you want to listen on it\n     // even when -connect or -proxy is specified\n-    if (gArgs.IsArgSet(\"-bind\")) {\n+    if (gArgs.IsArgSet(\"-bind\")) <%\n         if (gArgs.SoftSetBoolArg(\"-listen\", true))\n             LogPrintf(\"%s: parameter interaction: -bind set -> setting -listen=1\\n\", __func__);\n-    }\n-    if (gArgs.IsArgSet(\"-whitebind\")) {\n+    %>\n+    if (gArgs.IsArgSet(\"-whitebind\")) <%\n         if (gArgs.SoftSetBoolArg(\"-listen\", true))\n             LogPrintf(\"%s: parameter interaction: -whitebind set -> setting -listen=1\\n\", __func__);\n-    }\n+    %>\n \n-    if (gArgs.IsArgSet(\"-connect\")) {\n+    if (gArgs.IsArgSet(\"-connect\")) <%\n         // when only connecting to trusted nodes, do not seed via DNS, or listen by default\n         if (gArgs.SoftSetBoolArg(\"-dnsseed\", false))\n             LogPrintf(\"%s: parameter interaction: -connect set -> setting -dnsseed=0\\n\", __func__);\n         if (gArgs.SoftSetBoolArg(\"-listen\", false))\n             LogPrintf(\"%s: parameter interaction: -connect set -> setting -listen=0\\n\", __func__);\n-    }\n+    %>\n \n-    if (gArgs.IsArgSet(\"-proxy\")) {\n+    if (gArgs.IsArgSet(\"-proxy\")) <%\n         // to protect privacy, do not listen by default if a default proxy server is specified\n         if (gArgs.SoftSetBoolArg(\"-listen\", false))\n             LogPrintf(\"%s: parameter interaction: -proxy set -> setting -listen=0\\n\", __func__);\n@@ -799,54 +799,54 @@ void InitParameterInteraction()\n         // to protect privacy, do not discover addresses by default\n         if (gArgs.SoftSetBoolArg(\"-discover\", false))\n             LogPrintf(\"%s: parameter interaction: -proxy set -> setting -discover=0\\n\", __func__);\n-    }\n+    %>\n \n-    if (!gArgs.GetBoolArg(\"-listen\", DEFAULT_LISTEN)) {\n+    if (!gArgs.GetBoolArg(\"-listen\", DEFAULT_LISTEN)) <%\n         // do not map ports or try to retrieve public IP when not listening (pointless)\n         if (gArgs.SoftSetBoolArg(\"-upnp\", false))\n             LogPrintf(\"%s: parameter interaction: -listen=0 -> setting -upnp=0\\n\", __func__);\n         if (gArgs.SoftSetBoolArg(\"-discover\", false))\n             LogPrintf(\"%s: parameter interaction: -listen=0 -> setting -discover=0\\n\", __func__);\n         if (gArgs.SoftSetBoolArg(\"-listenonion\", false))\n             LogPrintf(\"%s: parameter interaction: -listen=0 -> setting -listenonion=0\\n\", __func__);\n-    }\n+    %>\n \n-    if (gArgs.IsArgSet(\"-externalip\")) {\n+    if (gArgs.IsArgSet(\"-externalip\")) <%\n         // if an explicit public IP is specified, do not try to find others\n         if (gArgs.SoftSetBoolArg(\"-discover\", false))\n             LogPrintf(\"%s: parameter interaction: -externalip set -> setting -discover=0\\n\", __func__);\n-    }\n+    %>\n \n     // disable whitelistrelay in blocksonly mode\n-    if (gArgs.GetBoolArg(\"-blocksonly\", DEFAULT_BLOCKSONLY)) {\n+    if (gArgs.GetBoolArg(\"-blocksonly\", DEFAULT_BLOCKSONLY)) <%\n         if (gArgs.SoftSetBoolArg(\"-whitelistrelay\", false))\n             LogPrintf(\"%s: parameter interaction: -blocksonly=1 -> setting -whitelistrelay=0\\n\", __func__);\n-    }\n+    %>\n \n     // Forcing relay from whitelisted hosts implies we will accept relays from them in the first place.\n-    if (gArgs.GetBoolArg(\"-whitelistforcerelay\", DEFAULT_WHITELISTFORCERELAY)) {\n+    if (gArgs.GetBoolArg(\"-whitelistforcerelay\", DEFAULT_WHITELISTFORCERELAY)) <%\n         if (gArgs.SoftSetBoolArg(\"-whitelistrelay\", true))\n             LogPrintf(\"%s: parameter interaction: -whitelistforcerelay=1 -> setting -whitelistrelay=1\\n\", __func__);\n-    }\n+    %>\n \n     // Warn if network-specific options (-addnode, -connect, etc) are\n     // specified in default section of config file, but not overridden\n     // on the command line or in this network's section of the config file.\n     std::string network = gArgs.GetChainName();\n-    for (const auto& arg : gArgs.GetUnsuitableSectionOnlyArgs()) {\n+    for (const auto& arg : gArgs.GetUnsuitableSectionOnlyArgs()) <%\n         InitWarning(strprintf(_(\"Config setting for %s only applied on %s network when in [%s] section.\"), arg, network, network));\n-    }\n+    %>\n \n     // Warn if unrecognized section name are present in the config file.\n-    for (const auto& section : gArgs.GetUnrecognizedSections()) {\n+    for (const auto& section : gArgs.GetUnrecognizedSections()) <%\n         InitWarning(strprintf(\"%s:%i \" + _(\"Section [%s] is not recognized.\"), section.m_file, section.m_line, section.m_name));\n-    }\n-}\n+    %>\n+%>\n \n static std::string ResolveErrMsg(const char * const optname, const std::string& strBind)\n-{\n+<%\n     return strprintf(_(\"Cannot resolve -%s address: '%s'\"), optname, strBind);\n-}\n+%>\n \n /**\n  * Initialize global loggers.\n@@ -855,7 +855,7 @@ static std::string ResolveErrMsg(const char * const optname, const std::string&\n  * careful about what global state you rely on here.\n  */\n void InitLogging()\n-{\n+<%\n     LogInstance().m_print_to_file = !gArgs.IsArgNegated(\"-debuglogfile\");\n     LogInstance().m_file_path = AbsPathForConfigVal(gArgs.GetArg(\"-debuglogfile\", DEFAULT_DEBUGLOGFILE));\n \n@@ -877,20 +877,20 @@ void InitLogging()\n     version_string += \" (release build)\";\n #endif\n     LogPrintf(PACKAGE_NAME \" version %s\\n\", version_string);\n-}\n+%>\n \n-namespace { // Variables internal to initialization process only\n+namespace <% // Variables internal to initialization process only\n \n int nMaxConnections;\n int nUserMaxConnections;\n int nFD;\n ServiceFlags nLocalServices = ServiceFlags(NODE_NETWORK | NODE_NETWORK_LIMITED);\n int64_t peer_connect_timeout;\n \n-} // namespace\n+%> // namespace\n \n [[noreturn]] static void new_handler_terminate()\n-{\n+<%\n     // Rather than throwing std::bad-alloc if allocation fails, terminate\n     // immediately to (try to) avoid chain corruption.\n     // Since LogPrintf may itself allocate memory, set the handler directly\n@@ -900,10 +900,10 @@ int64_t peer_connect_timeout;\n \n     // The log was successful, terminate now.\n     std::terminate();\n-};\n+%>;\n \n bool AppInitBasicSetup()\n-{\n+<%\n     // ********************************************************* Step 1: setup\n #ifdef _MSC_VER\n     // Turn off Microsoft heap dump noise\n@@ -921,9 +921,9 @@ bool AppInitBasicSetup()\n         return InitError(\"Initializing networking failed\");\n \n #ifndef WIN32\n-    if (!gArgs.GetBoolArg(\"-sysperms\", false)) {\n+    if (!gArgs.GetBoolArg(\"-sysperms\", false)) <%\n         umask(077);\n-    }\n+    %>\n \n     // Clean shutdown on SIGTERM\n     registerSignalHandler(SIGTERM, HandleSIGTERM);\n@@ -941,30 +941,30 @@ bool AppInitBasicSetup()\n     std::set_new_handler(new_handler_terminate);\n \n     return true;\n-}\n+%>\n \n bool AppInitParameterInteraction()\n-{\n+<%\n     const CChainParams& chainparams = Params();\n     // ********************************************************* Step 2: parameter interactions\n \n     // also see: InitParameterInteraction()\n \n-    if (!fs::is_directory(GetBlocksDir())) {\n+    if (!fs::is_directory(GetBlocksDir())) <%\n         return InitError(strprintf(_(\"Specified blocks directory \\\"%s\\\" does not exist.\"), gArgs.GetArg(\"-blocksdir\", \"\").c_str()));\n-    }\n+    %>\n \n     // if using block pruning, then disallow txindex\n-    if (gArgs.GetArg(\"-prune\", 0)) {\n+    if (gArgs.GetArg(\"-prune\", 0)) <%\n         if (gArgs.GetBoolArg(\"-txindex\", DEFAULT_TXINDEX))\n             return InitError(_(\"Prune mode is incompatible with -txindex.\"));\n-    }\n+    %>\n \n     // -bind and -whitebind can't be set when not listening\n     size_t nUserBind = gArgs.GetArgs(\"-bind\").size() + gArgs.GetArgs(\"-whitebind\").size();\n-    if (nUserBind != 0 && !gArgs.GetBoolArg(\"-listen\", DEFAULT_LISTEN)) {\n+    if (nUserBind != 0 && !gArgs.GetBoolArg(\"-listen\", DEFAULT_LISTEN)) <%\n         return InitError(\"Cannot set -bind or -whitebind together with -listen=0\");\n-    }\n+    %>\n \n     // Make sure enough file descriptors are available\n     int nBind = std::max(nUserBind, size_t(1));\n@@ -988,32 +988,32 @@ bool AppInitParameterInteraction()\n         InitWarning(strprintf(_(\"Reducing -maxconnections from %d to %d, because of system limitations.\"), nUserMaxConnections, nMaxConnections));\n \n     // ********************************************************* Step 3: parameter-to-internal-flags\n-    if (gArgs.IsArgSet(\"-debug\")) {\n+    if (gArgs.IsArgSet(\"-debug\")) <%\n         // Special-case: if -debug=0/-nodebug is set, turn off debugging messages\n         const std::vector<std::string> categories = gArgs.GetArgs(\"-debug\");\n \n         if (std::none_of(categories.begin(), categories.end(),\n-            [](std::string cat){return cat == \"0\" || cat == \"none\";})) {\n-            for (const auto& cat : categories) {\n-                if (!LogInstance().EnableCategory(cat)) {\n+            [](std::string cat)<%return cat == \"0\" || cat == \"none\";%>)) <%\n+            for (const auto& cat : categories) <%\n+                if (!LogInstance().EnableCategory(cat)) <%\n                     InitWarning(strprintf(_(\"Unsupported logging category %s=%s.\"), \"-debug\", cat));\n-                }\n-            }\n-        }\n-    }\n+                %>\n+            %>\n+        %>\n+    %>\n \n     // Now remove the logging categories which were explicitly excluded\n-    for (const std::string& cat : gArgs.GetArgs(\"-debugexclude\")) {\n-        if (!LogInstance().DisableCategory(cat)) {\n+    for (const std::string& cat : gArgs.GetArgs(\"-debugexclude\")) <%\n+        if (!LogInstance().DisableCategory(cat)) <%\n             InitWarning(strprintf(_(\"Unsupported logging category %s=%s.\"), \"-debugexclude\", cat));\n-        }\n-    }\n+        %>\n+    %>\n \n     // Checkmempool and checkblockindex default to true in regtest mode\n     int ratio = std::min<int>(std::max<int>(gArgs.GetArg(\"-checkmempool\", chainparams.DefaultConsistencyChecks() ? 1 : 0), 0), 1000000);\n-    if (ratio != 0) {\n+    if (ratio != 0) <%\n         mempool.setSanityCheck(1.0 / ratio);\n-    }\n+    %>\n     fCheckBlockIndex = gArgs.GetBoolArg(\"-checkblockindex\", chainparams.DefaultConsistencyChecks());\n     fCheckpointsEnabled = gArgs.GetBoolArg(\"-checkpoints\", DEFAULT_CHECKPOINTS_ENABLED);\n \n@@ -1023,19 +1023,19 @@ bool AppInitParameterInteraction()\n     else\n         LogPrintf(\"Validating signatures for all blocks.\\n\");\n \n-    if (gArgs.IsArgSet(\"-minimumchainwork\")) {\n+    if (gArgs.IsArgSet(\"-minimumchainwork\")) <%\n         const std::string minChainWorkStr = gArgs.GetArg(\"-minimumchainwork\", \"\");\n-        if (!IsHexNumber(minChainWorkStr)) {\n+        if (!IsHexNumber(minChainWorkStr)) <%\n             return InitError(strprintf(\"Invalid non-hex (%s) minimum chain work value specified\", minChainWorkStr));\n-        }\n+        %>\n         nMinimumChainWork = UintToArith256(uint256S(minChainWorkStr));\n-    } else {\n+    %> else <%\n         nMinimumChainWork = UintToArith256(chainparams.GetConsensus().nMinimumChainWork);\n-    }\n+    %>\n     LogPrintf(\"Setting nMinimumChainWork=%s\\n\", nMinimumChainWork.GetHex());\n-    if (nMinimumChainWork < UintToArith256(chainparams.GetConsensus().nMinimumChainWork)) {\n+    if (nMinimumChainWork < UintToArith256(chainparams.GetConsensus().nMinimumChainWork)) <%\n         LogPrintf(\"Warning: nMinimumChainWork set below default value of %s\\n\", chainparams.GetConsensus().nMinimumChainWork.GetHex());\n-    }\n+    %>\n \n     // mempool limits\n     int64_t nMempoolSizeMax = gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n@@ -1045,12 +1045,12 @@ bool AppInitParameterInteraction()\n     // incremental relay fee sets the minimum feerate increase necessary for BIP 125 replacement in the mempool\n     // and the amount the mempool min fee increases above the feerate of txs evicted due to mempool limiting.\n     if (gArgs.IsArgSet(\"-incrementalrelayfee\"))\n-    {\n+    <%\n         CAmount n = 0;\n         if (!ParseMoney(gArgs.GetArg(\"-incrementalrelayfee\", \"\"), n))\n             return InitError(AmountErrMsg(\"incrementalrelayfee\", gArgs.GetArg(\"-incrementalrelayfee\", \"\")));\n         incrementalRelayFee = CFeeRate(n);\n-    }\n+    %>\n \n     // -par=0 means autodetect, but nScriptCheckThreads==0 means no concurrency\n     nScriptCheckThreads = gArgs.GetArg(\"-par\", DEFAULT_SCRIPTCHECK_THREADS);\n@@ -1063,79 +1063,79 @@ bool AppInitParameterInteraction()\n \n     // block pruning; get the amount of disk space (in MiB) to allot for block & undo files\n     int64_t nPruneArg = gArgs.GetArg(\"-prune\", 0);\n-    if (nPruneArg < 0) {\n+    if (nPruneArg < 0) <%\n         return InitError(_(\"Prune cannot be configured with a negative value.\"));\n-    }\n+    %>\n     nPruneTarget = (uint64_t) nPruneArg * 1024 * 1024;\n-    if (nPruneArg == 1) {  // manual pruning: -prune=1\n+    if (nPruneArg == 1) <%  // manual pruning: -prune=1\n         LogPrintf(\"Block pruning enabled.  Use RPC call pruneblockchain(height) to manually prune block and undo files.\\n\");\n         nPruneTarget = std::numeric_limits<uint64_t>::max();\n         fPruneMode = true;\n-    } else if (nPruneTarget) {\n-        if (nPruneTarget < MIN_DISK_SPACE_FOR_BLOCK_FILES) {\n+    %> else if (nPruneTarget) <%\n+        if (nPruneTarget < MIN_DISK_SPACE_FOR_BLOCK_FILES) <%\n             return InitError(strprintf(_(\"Prune configured below the minimum of %d MiB.  Please use a higher number.\"), MIN_DISK_SPACE_FOR_BLOCK_FILES / 1024 / 1024));\n-        }\n+        %>\n         LogPrintf(\"Prune configured to target %u MiB on disk for block and undo files.\\n\", nPruneTarget / 1024 / 1024);\n         fPruneMode = true;\n-    }\n+    %>\n \n     nConnectTimeout = gArgs.GetArg(\"-timeout\", DEFAULT_CONNECT_TIMEOUT);\n-    if (nConnectTimeout <= 0) {\n+    if (nConnectTimeout <= 0) <%\n         nConnectTimeout = DEFAULT_CONNECT_TIMEOUT;\n-    }\n+    %>\n \n     peer_connect_timeout = gArgs.GetArg(\"-peertimeout\", DEFAULT_PEER_CONNECT_TIMEOUT);\n-    if (peer_connect_timeout <= 0) {\n+    if (peer_connect_timeout <= 0) <%\n         return InitError(\"peertimeout cannot be configured with a negative value.\");\n-    }\n+    %>\n \n-    if (gArgs.IsArgSet(\"-minrelaytxfee\")) {\n+    if (gArgs.IsArgSet(\"-minrelaytxfee\")) <%\n         CAmount n = 0;\n-        if (!ParseMoney(gArgs.GetArg(\"-minrelaytxfee\", \"\"), n)) {\n+        if (!ParseMoney(gArgs.GetArg(\"-minrelaytxfee\", \"\"), n)) <%\n             return InitError(AmountErrMsg(\"minrelaytxfee\", gArgs.GetArg(\"-minrelaytxfee\", \"\")));\n-        }\n+        %>\n         // High fee check is done afterward in WalletParameterInteraction()\n         ::minRelayTxFee = CFeeRate(n);\n-    } else if (incrementalRelayFee > ::minRelayTxFee) {\n+    %> else if (incrementalRelayFee > ::minRelayTxFee) <%\n         // Allow only setting incrementalRelayFee to control both\n         ::minRelayTxFee = incrementalRelayFee;\n         LogPrintf(\"Increasing minrelaytxfee to %s to match incrementalrelayfee\\n\",::minRelayTxFee.ToString());\n-    }\n+    %>\n \n     // Sanity check argument for min fee for including tx in block\n     // TODO: Harmonize which arguments need sanity checking and where that happens\n     if (gArgs.IsArgSet(\"-blockmintxfee\"))\n-    {\n+    <%\n         CAmount n = 0;\n         if (!ParseMoney(gArgs.GetArg(\"-blockmintxfee\", \"\"), n))\n             return InitError(AmountErrMsg(\"blockmintxfee\", gArgs.GetArg(\"-blockmintxfee\", \"\")));\n-    }\n+    %>\n \n     // Feerate used to define dust.  Shouldn't be changed lightly as old\n     // implementations may inadvertently create non-standard transactions\n     if (gArgs.IsArgSet(\"-dustrelayfee\"))\n-    {\n+    <%\n         CAmount n = 0;\n         if (!ParseMoney(gArgs.GetArg(\"-dustrelayfee\", \"\"), n))\n             return InitError(AmountErrMsg(\"dustrelayfee\", gArgs.GetArg(\"-dustrelayfee\", \"\")));\n         dustRelayFee = CFeeRate(n);\n-    }\n+    %>\n \n     // This is required by both the wallet and node\n     if (gArgs.IsArgSet(\"-maxtxfee\"))\n-    {\n+    <%\n         CAmount nMaxFee = 0;\n         if (!ParseMoney(gArgs.GetArg(\"-maxtxfee\", \"\"), nMaxFee))\n             return InitError(AmountErrMsg(\"maxtxfee\", gArgs.GetArg(\"-maxtxfee\", \"\")));\n         if (nMaxFee > HIGH_MAX_TX_FEE)\n             InitWarning(_(\"-maxtxfee is set very high! Fees this large could be paid on a single transaction.\"));\n         maxTxFee = nMaxFee;\n         if (CFeeRate(maxTxFee, 1000) < ::minRelayTxFee)\n-        {\n+        <%\n             return InitError(strprintf(_(\"Invalid amount for -maxtxfee=<amount>: '%s' (must be at least the minrelay fee of %s to prevent stuck transactions)\"),\n                                        gArgs.GetArg(\"-maxtxfee\", \"\"), ::minRelayTxFee.ToString()));\n-        }\n-    }\n+        %>\n+    %>\n \n     fRequireStandard = !gArgs.GetBoolArg(\"-acceptnonstdtxn\", !chainparams.RequireStandard());\n     if (chainparams.RequireStandard() && !fRequireStandard)\n@@ -1163,32 +1163,32 @@ bool AppInitParameterInteraction()\n     nMaxTipAge = gArgs.GetArg(\"-maxtipage\", DEFAULT_MAX_TIP_AGE);\n \n     fEnableReplacement = gArgs.GetBoolArg(\"-mempoolreplacement\", DEFAULT_ENABLE_REPLACEMENT);\n-    if ((!fEnableReplacement) && gArgs.IsArgSet(\"-mempoolreplacement\")) {\n+    if ((!fEnableReplacement) && gArgs.IsArgSet(\"-mempoolreplacement\")) <%\n         // Minimal effort at forwards compatibility\n         std::string strReplacementModeList = gArgs.GetArg(\"-mempoolreplacement\", \"\");  // default is impossible\n         std::vector<std::string> vstrReplacementModes;\n         boost::split(vstrReplacementModes, strReplacementModeList, boost::is_any_of(\",\"));\n         fEnableReplacement = (std::find(vstrReplacementModes.begin(), vstrReplacementModes.end(), \"fee\") != vstrReplacementModes.end());\n-    }\n+    %>\n \n     return true;\n-}\n+%>\n \n static bool LockDataDirectory(bool probeOnly)\n-{\n+<%\n     // Make sure only a single Bitcoin process is using the data directory.\n     fs::path datadir = GetDataDir();\n-    if (!DirIsWritable(datadir)) {\n+    if (!DirIsWritable(datadir)) <%\n         return InitError(strprintf(_(\"Cannot write to data directory '%s'; check permissions.\"), datadir.string()));\n-    }\n-    if (!LockDirectory(datadir, \".lock\", probeOnly)) {\n+    %>\n+    if (!LockDirectory(datadir, \".lock\", probeOnly)) <%\n         return InitError(strprintf(_(\"Cannot obtain a lock on data directory %s. %s is probably already running.\"), datadir.string(), _(PACKAGE_NAME)));\n-    }\n+    %>\n     return true;\n-}\n+%>\n \n bool AppInitSanityChecks()\n-{\n+<%\n     // ********************************************************* Step 4: sanity checks\n \n     // Initialize elliptic curve code\n@@ -1206,39 +1206,39 @@ bool AppInitSanityChecks()\n     // We cannot hold the data directory lock here, as the forking for daemon() hasn't yet happened,\n     // and a fork will cause weird behavior to it.\n     return LockDataDirectory(true);\n-}\n+%>\n \n bool AppInitLockDataDirectory()\n-{\n+<%\n     // After daemonization get the data directory lock again and hold on to it until exit\n     // This creates a slight window for a race condition to happen, however this condition is harmless: it\n     // will at most make us exit without printing a message to console.\n-    if (!LockDataDirectory(false)) {\n+    if (!LockDataDirectory(false)) <%\n         // Detailed error printed inside LockDataDirectory\n         return false;\n-    }\n+    %>\n     return true;\n-}\n+%>\n \n bool AppInitMain(InitInterfaces& interfaces)\n-{\n+<%\n     const CChainParams& chainparams = Params();\n     // ********************************************************* Step 4a: application initialization\n-    if (!CreatePidFile()) {\n+    if (!CreatePidFile()) <%\n         // Detailed error printed inside CreatePidFile().\n         return false;\n-    }\n-    if (LogInstance().m_print_to_file) {\n-        if (gArgs.GetBoolArg(\"-shrinkdebugfile\", LogInstance().DefaultShrinkDebugFile())) {\n+    %>\n+    if (LogInstance().m_print_to_file) <%\n+        if (gArgs.GetBoolArg(\"-shrinkdebugfile\", LogInstance().DefaultShrinkDebugFile())) <%\n             // Do this first since it both loads a bunch of debug.log into memory,\n             // and because this needs to happen before any other debug.log printing\n             LogInstance().ShrinkDebugFile();\n-        }\n-        if (!LogInstance().OpenDebugLog()) {\n+        %>\n+        if (!LogInstance().OpenDebugLog()) <%\n             return InitError(strprintf(\"Could not open debug log file %s\",\n                 LogInstance().m_file_path.string()));\n-        }\n-    }\n+        %>\n+    %>\n \n     if (!LogInstance().m_log_timestamps)\n         LogPrintf(\"Startup time: %s\\n\", FormatISO8601DateTime(GetTime()));\n@@ -1247,35 +1247,35 @@ bool AppInitMain(InitInterfaces& interfaces)\n \n     // Only log conf file usage message if conf file actually exists.\n     fs::path config_file_path = GetConfigFile(gArgs.GetArg(\"-conf\", BITCOIN_CONF_FILENAME));\n-    if (fs::exists(config_file_path)) {\n+    if (fs::exists(config_file_path)) <%\n         LogPrintf(\"Config file: %s\\n\", config_file_path.string());\n-    } else if (gArgs.IsArgSet(\"-conf\")) {\n+    %> else if (gArgs.IsArgSet(\"-conf\")) <%\n         // Warn if no conf file exists at path provided by user\n         InitWarning(strprintf(_(\"The specified config file %s does not exist\\n\"), config_file_path.string()));\n-    } else {\n+    %> else <%\n         // Not categorizing as \"Warning\" because it's the default behavior\n         LogPrintf(\"Config file: %s (not found, skipping)\\n\", config_file_path.string());\n-    }\n+    %>\n \n     LogPrintf(\"Using at most %i automatic connections (%i file descriptors available)\\n\", nMaxConnections, nFD);\n \n     // Warn about relative -datadir path.\n-    if (gArgs.IsArgSet(\"-datadir\") && !fs::path(gArgs.GetArg(\"-datadir\", \"\")).is_absolute()) {\n+    if (gArgs.IsArgSet(\"-datadir\") && !fs::path(gArgs.GetArg(\"-datadir\", \"\")).is_absolute()) <%\n         LogPrintf(\"Warning: relative datadir option '%s' specified, which will be interpreted relative to the \" /* Continued */\n                   \"current working directory '%s'. This is fragile, because if bitcoin is started in the future \"\n                   \"from a different location, it will be unable to locate the current data files. There could \"\n                   \"also be data loss if bitcoin is started while in a temporary directory.\\n\",\n             gArgs.GetArg(\"-datadir\", \"\"), fs::current_path().string());\n-    }\n+    %>\n \n     InitSignatureCache();\n     InitScriptExecutionCache();\n \n     LogPrintf(\"Using %u threads for script verification\\n\", nScriptCheckThreads);\n-    if (nScriptCheckThreads) {\n+    if (nScriptCheckThreads) <%\n         for (int i=0; i<nScriptCheckThreads-1; i++)\n             threadGroup.create_thread(&ThreadScriptCheck);\n-    }\n+    %>\n \n     // Start the lightweight task scheduler thread\n     CScheduler::Function serviceLoop = std::bind(&CScheduler::serviceQueue, &scheduler);\n@@ -1294,9 +1294,9 @@ bool AppInitMain(InitInterfaces& interfaces)\n      * available in the GUI RPC console even if external calls are disabled.\n      */\n     RegisterAllCoreRPCCommands(tableRPC);\n-    for (const auto& client : interfaces.chain_clients) {\n+    for (const auto& client : interfaces.chain_clients) <%\n         client->registerRpcs();\n-    }\n+    %>\n     g_rpc_interfaces = &interfaces;\n #if ENABLE_ZMQ\n     RegisterZMQRPCCommands(tableRPC);\n@@ -1308,18 +1308,18 @@ bool AppInitMain(InitInterfaces& interfaces)\n      * be disabled when initialisation is finished.\n      */\n     if (gArgs.GetBoolArg(\"-server\", false))\n-    {\n+    <%\n         uiInterface.InitMessage_connect(SetRPCWarmupStatus);\n         if (!AppInitServers())\n             return InitError(_(\"Unable to start HTTP server. See debug log for details.\"));\n-    }\n+    %>\n \n     // ********************************************************* Step 5: verify wallet database integrity\n-    for (const auto& client : interfaces.chain_clients) {\n-        if (!client->verify()) {\n+    for (const auto& client : interfaces.chain_clients) <%\n+        if (!client->verify()) <%\n             return false;\n-        }\n-    }\n+        %>\n+    %>\n \n     // ********************************************************* Step 6: network initialization\n     // Note that we absolutely cannot open any actual connections\n@@ -1337,31 +1337,31 @@ bool AppInitMain(InitInterfaces& interfaces)\n \n     // sanitize comments per BIP-0014, format user agent and check total size\n     std::vector<std::string> uacomments;\n-    for (const std::string& cmt : gArgs.GetArgs(\"-uacomment\")) {\n+    for (const std::string& cmt : gArgs.GetArgs(\"-uacomment\")) <%\n         if (cmt != SanitizeString(cmt, SAFE_CHARS_UA_COMMENT))\n             return InitError(strprintf(_(\"User Agent comment (%s) contains unsafe characters.\"), cmt));\n         uacomments.push_back(cmt);\n-    }\n+    %>\n     strSubVersion = FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, uacomments);\n-    if (strSubVersion.size() > MAX_SUBVERSION_LENGTH) {\n+    if (strSubVersion.size() > MAX_SUBVERSION_LENGTH) <%\n         return InitError(strprintf(_(\"Total length of network version string (%i) exceeds maximum length (%i). Reduce the number or size of uacomments.\"),\n             strSubVersion.size(), MAX_SUBVERSION_LENGTH));\n-    }\n+    %>\n \n-    if (gArgs.IsArgSet(\"-onlynet\")) {\n+    if (gArgs.IsArgSet(\"-onlynet\")) <%\n         std::set<enum Network> nets;\n-        for (const std::string& snet : gArgs.GetArgs(\"-onlynet\")) {\n+        for (const std::string& snet : gArgs.GetArgs(\"-onlynet\")) <%\n             enum Network net = ParseNetwork(snet);\n             if (net == NET_UNROUTABLE)\n                 return InitError(strprintf(_(\"Unknown network specified in -onlynet: '%s'\"), snet));\n             nets.insert(net);\n-        }\n-        for (int n = 0; n < NET_MAX; n++) {\n+        %>\n+        for (int n = 0; n < NET_MAX; n++) <%\n             enum Network net = (enum Network)n;\n             if (!nets.count(net))\n                 SetReachable(net, false);\n-        }\n-    }\n+        %>\n+    %>\n \n     // Check for host lookup allowed before parsing any network related parameters\n     fNameLookup = gArgs.GetBoolArg(\"-dns\", DEFAULT_NAME_LOOKUP);\n@@ -1371,11 +1371,11 @@ bool AppInitMain(InitInterfaces& interfaces)\n     // -noproxy (or -proxy=0) as well as the empty string can be used to not set a proxy, this is the default\n     std::string proxyArg = gArgs.GetArg(\"-proxy\", \"\");\n     SetReachable(NET_ONION, false);\n-    if (proxyArg != \"\" && proxyArg != \"0\") {\n+    if (proxyArg != \"\" && proxyArg != \"0\") <%\n         CService proxyAddr;\n-        if (!Lookup(proxyArg.c_str(), proxyAddr, 9050, fNameLookup)) {\n+        if (!Lookup(proxyArg.c_str(), proxyAddr, 9050, fNameLookup)) <%\n             return InitError(strprintf(_(\"Invalid -proxy address or hostname: '%s'\"), proxyArg));\n-        }\n+        %>\n \n         proxyType addrProxy = proxyType(proxyAddr, proxyRandomize);\n         if (!addrProxy.IsValid())\n@@ -1386,54 +1386,54 @@ bool AppInitMain(InitInterfaces& interfaces)\n         SetProxy(NET_ONION, addrProxy);\n         SetNameProxy(addrProxy);\n         SetReachable(NET_ONION, true); // by default, -proxy sets onion as reachable, unless -noonion later\n-    }\n+    %>\n \n     // -onion can be used to set only a proxy for .onion, or override normal proxy for .onion addresses\n     // -noonion (or -onion=0) disables connecting to .onion entirely\n     // An empty string is used to not override the onion proxy (in which case it defaults to -proxy set above, or none)\n     std::string onionArg = gArgs.GetArg(\"-onion\", \"\");\n-    if (onionArg != \"\") {\n-        if (onionArg == \"0\") { // Handle -noonion/-onion=0\n+    if (onionArg != \"\") <%\n+        if (onionArg == \"0\") <% // Handle -noonion/-onion=0\n             SetReachable(NET_ONION, false);\n-        } else {\n+        %> else <%\n             CService onionProxy;\n-            if (!Lookup(onionArg.c_str(), onionProxy, 9050, fNameLookup)) {\n+            if (!Lookup(onionArg.c_str(), onionProxy, 9050, fNameLookup)) <%\n                 return InitError(strprintf(_(\"Invalid -onion address or hostname: '%s'\"), onionArg));\n-            }\n+            %>\n             proxyType addrOnion = proxyType(onionProxy, proxyRandomize);\n             if (!addrOnion.IsValid())\n                 return InitError(strprintf(_(\"Invalid -onion address or hostname: '%s'\"), onionArg));\n             SetProxy(NET_ONION, addrOnion);\n             SetReachable(NET_ONION, true);\n-        }\n-    }\n+        %>\n+    %>\n \n     // see Step 2: parameter interactions for more information about these\n     fListen = gArgs.GetBoolArg(\"-listen\", DEFAULT_LISTEN);\n     fDiscover = gArgs.GetBoolArg(\"-discover\", true);\n     fRelayTxes = !gArgs.GetBoolArg(\"-blocksonly\", DEFAULT_BLOCKSONLY);\n \n-    for (const std::string& strAddr : gArgs.GetArgs(\"-externalip\")) {\n+    for (const std::string& strAddr : gArgs.GetArgs(\"-externalip\")) <%\n         CService addrLocal;\n         if (Lookup(strAddr.c_str(), addrLocal, GetListenPort(), fNameLookup) && addrLocal.IsValid())\n             AddLocal(addrLocal, LOCAL_MANUAL);\n         else\n             return InitError(ResolveErrMsg(\"externalip\", strAddr));\n-    }\n+    %>\n \n #if ENABLE_ZMQ\n     g_zmq_notification_interface = CZMQNotificationInterface::Create();\n \n-    if (g_zmq_notification_interface) {\n+    if (g_zmq_notification_interface) <%\n         RegisterValidationInterface(g_zmq_notification_interface);\n-    }\n+    %>\n #endif\n     uint64_t nMaxOutboundLimit = 0; //unlimited unless -maxuploadtarget is set\n     uint64_t nMaxOutboundTimeframe = MAX_UPLOAD_TIMEFRAME;\n \n-    if (gArgs.IsArgSet(\"-maxuploadtarget\")) {\n+    if (gArgs.IsArgSet(\"-maxuploadtarget\")) <%\n         nMaxOutboundLimit = gArgs.GetArg(\"-maxuploadtarget\", DEFAULT_MAX_UPLOAD_TARGET)*1024*1024;\n-    }\n+    %>\n \n     // ********************************************************* Step 7: load block chain\n \n@@ -1455,23 +1455,23 @@ bool AppInitMain(InitInterfaces& interfaces)\n     int64_t nMempoolSizeMax = gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n     LogPrintf(\"Cache configuration:\\n\");\n     LogPrintf(\"* Using %.1f MiB for block index database\\n\", nBlockTreeDBCache * (1.0 / 1024 / 1024));\n-    if (gArgs.GetBoolArg(\"-txindex\", DEFAULT_TXINDEX)) {\n+    if (gArgs.GetBoolArg(\"-txindex\", DEFAULT_TXINDEX)) <%\n         LogPrintf(\"* Using %.1f MiB for transaction index database\\n\", nTxIndexCache * (1.0 / 1024 / 1024));\n-    }\n+    %>\n     LogPrintf(\"* Using %.1f MiB for chain state database\\n\", nCoinDBCache * (1.0 / 1024 / 1024));\n     LogPrintf(\"* Using %.1f MiB for in-memory UTXO set (plus up to %.1f MiB of unused mempool space)\\n\", nCoinCacheUsage * (1.0 / 1024 / 1024), nMempoolSizeMax * (1.0 / 1024 / 1024));\n \n     bool fLoaded = false;\n-    while (!fLoaded && !ShutdownRequested()) {\n+    while (!fLoaded && !ShutdownRequested()) <%\n         bool fReset = fReindex;\n         std::string strLoadError;\n \n         uiInterface.InitMessage(_(\"Loading block index...\"));\n \n-        do {\n+        do <%\n             const int64_t load_block_index_start_time = GetTimeMillis();\n             bool is_coinsview_empty;\n-            try {\n+            try <%\n                 LOCK(cs_main);\n                 UnloadBlockIndex();\n                 pcoinsTip.reset();\n@@ -1482,45 +1482,45 @@ bool AppInitMain(InitInterfaces& interfaces)\n                 pblocktree.reset();\n                 pblocktree.reset(new CBlockTreeDB(nBlockTreeDBCache, false, fReset));\n \n-                if (fReset) {\n+                if (fReset) <%\n                     pblocktree->WriteReindexing(true);\n                     //If we're reindexing in prune mode, wipe away unusable block files and all undo data files\n                     if (fPruneMode)\n                         CleanupBlockRevFiles();\n-                }\n+                %>\n \n                 if (ShutdownRequested()) break;\n \n                 // LoadBlockIndex will load fHavePruned if we've ever removed a\n                 // block file from disk.\n                 // Note that it also sets fReindex based on the disk flag!\n                 // From here on out fReindex and fReset mean something different!\n-                if (!LoadBlockIndex(chainparams)) {\n+                if (!LoadBlockIndex(chainparams)) <%\n                     strLoadError = _(\"Error loading block database\");\n                     break;\n-                }\n+                %>\n \n                 // If the loaded chain has a wrong genesis, bail out immediately\n                 // (we're likely using a testnet datadir, or the other way around).\n-                if (!mapBlockIndex.empty() && !LookupBlockIndex(chainparams.GetConsensus().hashGenesisBlock)) {\n+                if (!mapBlockIndex.empty() && !LookupBlockIndex(chainparams.GetConsensus().hashGenesisBlock)) <%\n                     return InitError(_(\"Incorrect or no genesis block found. Wrong datadir for network?\"));\n-                }\n+                %>\n \n                 // Check for changed -prune state.  What we are concerned about is a user who has pruned blocks\n                 // in the past, but is now trying to run unpruned.\n-                if (fHavePruned && !fPruneMode) {\n+                if (fHavePruned && !fPruneMode) <%\n                     strLoadError = _(\"You need to rebuild the database using -reindex to go back to unpruned mode.  This will redownload the entire blockchain\");\n                     break;\n-                }\n+                %>\n \n                 // At this point blocktree args are consistent with what's on disk.\n                 // If we're not mid-reindex (based on disk + args), add a genesis block on disk\n                 // (otherwise we use the one already on disk).\n                 // This is called again in ThreadImport after the reindex completes.\n-                if (!fReindex && !LoadGenesisBlock(chainparams)) {\n+                if (!fReindex && !LoadGenesisBlock(chainparams)) <%\n                     strLoadError = _(\"Error initializing block database\");\n                     break;\n-                }\n+                %>\n \n                 // At this point we're either in reindex or we've loaded a useful\n                 // block tree into mapBlockIndex!\n@@ -1530,107 +1530,107 @@ bool AppInitMain(InitInterfaces& interfaces)\n \n                 // If necessary, upgrade from older database format.\n                 // This is a no-op if we cleared the coinsviewdb with -reindex or -reindex-chainstate\n-                if (!pcoinsdbview->Upgrade()) {\n+                if (!pcoinsdbview->Upgrade()) <%\n                     strLoadError = _(\"Error upgrading chainstate database\");\n                     break;\n-                }\n+                %>\n \n                 // ReplayBlocks is a no-op if we cleared the coinsviewdb with -reindex or -reindex-chainstate\n-                if (!ReplayBlocks(chainparams, pcoinsdbview.get())) {\n+                if (!ReplayBlocks(chainparams, pcoinsdbview.get())) <%\n                     strLoadError = _(\"Unable to replay blocks. You will need to rebuild the database using -reindex-chainstate.\");\n                     break;\n-                }\n+                %>\n \n                 // The on-disk coinsdb is now in a good state, create the cache\n                 pcoinsTip.reset(new CCoinsViewCache(pcoinscatcher.get()));\n \n                 is_coinsview_empty = fReset || fReindexChainState || pcoinsTip->GetBestBlock().IsNull();\n-                if (!is_coinsview_empty) {\n+                if (!is_coinsview_empty) <%\n                     // LoadChainTip sets chainActive based on pcoinsTip's best block\n-                    if (!LoadChainTip(chainparams)) {\n+                    if (!LoadChainTip(chainparams)) <%\n                         strLoadError = _(\"Error initializing block database\");\n                         break;\n-                    }\n+                    %>\n                     assert(chainActive.Tip() != nullptr);\n-                }\n-            } catch (const std::exception& e) {\n+                %>\n+            %> catch (const std::exception& e) <%\n                 LogPrintf(\"%s\\n\", e.what());\n                 strLoadError = _(\"Error opening block database\");\n                 break;\n-            }\n+            %>\n \n-            if (!fReset) {\n+            if (!fReset) <%\n                 // Note that RewindBlockIndex MUST run even if we're about to -reindex-chainstate.\n                 // It both disconnects blocks based on chainActive, and drops block data in\n                 // mapBlockIndex based on lack of available witness data.\n                 uiInterface.InitMessage(_(\"Rewinding blocks...\"));\n-                if (!RewindBlockIndex(chainparams)) {\n+                if (!RewindBlockIndex(chainparams)) <%\n                     strLoadError = _(\"Unable to rewind the database to a pre-fork state. You will need to redownload the blockchain\");\n                     break;\n-                }\n-            }\n+                %>\n+            %>\n \n-            try {\n+            try <%\n                 LOCK(cs_main);\n-                if (!is_coinsview_empty) {\n+                if (!is_coinsview_empty) <%\n                     uiInterface.InitMessage(_(\"Verifying blocks...\"));\n-                    if (fHavePruned && gArgs.GetArg(\"-checkblocks\", DEFAULT_CHECKBLOCKS) > MIN_BLOCKS_TO_KEEP) {\n+                    if (fHavePruned && gArgs.GetArg(\"-checkblocks\", DEFAULT_CHECKBLOCKS) > MIN_BLOCKS_TO_KEEP) <%\n                         LogPrintf(\"Prune: pruned datadir may not have more than %d blocks; only checking available blocks\\n\",\n                             MIN_BLOCKS_TO_KEEP);\n-                    }\n+                    %>\n \n                     CBlockIndex* tip = chainActive.Tip();\n                     RPCNotifyBlockChange(true, tip);\n-                    if (tip && tip->nTime > GetAdjustedTime() + 2 * 60 * 60) {\n+                    if (tip && tip->nTime > GetAdjustedTime() + 2 * 60 * 60) <%\n                         strLoadError = _(\"The block database contains a block which appears to be from the future. \"\n                                 \"This may be due to your computer's date and time being set incorrectly. \"\n                                 \"Only rebuild the block database if you are sure that your computer's date and time are correct\");\n                         break;\n-                    }\n+                    %>\n \n                     if (!CVerifyDB().VerifyDB(chainparams, pcoinsdbview.get(), gArgs.GetArg(\"-checklevel\", DEFAULT_CHECKLEVEL),\n-                                  gArgs.GetArg(\"-checkblocks\", DEFAULT_CHECKBLOCKS))) {\n+                                  gArgs.GetArg(\"-checkblocks\", DEFAULT_CHECKBLOCKS))) <%\n                         strLoadError = _(\"Corrupted block database detected\");\n                         break;\n-                    }\n-                }\n-            } catch (const std::exception& e) {\n+                    %>\n+                %>\n+            %> catch (const std::exception& e) <%\n                 LogPrintf(\"%s\\n\", e.what());\n                 strLoadError = _(\"Error opening block database\");\n                 break;\n-            }\n+            %>\n \n             fLoaded = true;\n             LogPrintf(\" block index %15dms\\n\", GetTimeMillis() - load_block_index_start_time);\n-        } while(false);\n+        %> while(false);\n \n-        if (!fLoaded && !ShutdownRequested()) {\n+        if (!fLoaded && !ShutdownRequested()) <%\n             // first suggest a reindex\n-            if (!fReset) {\n+            if (!fReset) <%\n                 bool fRet = uiInterface.ThreadSafeQuestion(\n                     strLoadError + \".\\n\\n\" + _(\"Do you want to rebuild the block database now?\"),\n                     strLoadError + \".\\nPlease restart with -reindex or -reindex-chainstate to recover.\",\n                     \"\", CClientUIInterface::MSG_ERROR | CClientUIInterface::BTN_ABORT);\n-                if (fRet) {\n+                if (fRet) <%\n                     fReindex = true;\n                     AbortShutdown();\n-                } else {\n+                %> else <%\n                     LogPrintf(\"Aborted block database rebuild. Exiting.\\n\");\n                     return false;\n-                }\n-            } else {\n+                %>\n+            %> else <%\n                 return InitError(strLoadError);\n-            }\n-        }\n-    }\n+            %>\n+        %>\n+    %>\n \n     // As LoadBlockIndex can take several minutes, it's possible the user\n     // requested to kill the GUI during the last operation. If so, exit.\n     // As the program has not fully started yet, Shutdown() is possibly overkill.\n-    if (ShutdownRequested()) {\n+    if (ShutdownRequested()) <%\n         LogPrintf(\"Shutdown requested. Exiting.\\n\");\n         return false;\n-    }\n+    %>\n \n     fs::path est_path = GetDataDir() / FEE_ESTIMATES_FILENAME;\n     CAutoFile est_filein(fsbridge::fopen(est_path, \"rb\"), SER_DISK, CLIENT_VERSION);\n@@ -1640,95 +1640,95 @@ bool AppInitMain(InitInterfaces& interfaces)\n     fFeeEstimatesInitialized = true;\n \n     // ********************************************************* Step 8: start indexers\n-    if (gArgs.GetBoolArg(\"-txindex\", DEFAULT_TXINDEX)) {\n+    if (gArgs.GetBoolArg(\"-txindex\", DEFAULT_TXINDEX)) <%\n         g_txindex = MakeUnique<TxIndex>(nTxIndexCache, false, fReindex);\n         g_txindex->Start();\n-    }\n+    %>\n \n     // ********************************************************* Step 9: load wallet\n-    for (const auto& client : interfaces.chain_clients) {\n-        if (!client->load()) {\n+    for (const auto& client : interfaces.chain_clients) <%\n+        if (!client->load()) <%\n             return false;\n-        }\n-    }\n+        %>\n+    %>\n \n     // ********************************************************* Step 10: data directory maintenance\n \n     // if pruning, unset the service bit and perform the initial blockstore prune\n     // after any wallet rescanning has taken place.\n-    if (fPruneMode) {\n+    if (fPruneMode) <%\n         LogPrintf(\"Unsetting NODE_NETWORK on prune mode\\n\");\n         nLocalServices = ServiceFlags(nLocalServices & ~NODE_NETWORK);\n-        if (!fReindex) {\n+        if (!fReindex) <%\n             uiInterface.InitMessage(_(\"Pruning blockstore...\"));\n             PruneAndFlush();\n-        }\n-    }\n+        %>\n+    %>\n \n-    if (chainparams.GetConsensus().vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout != 0) {\n+    if (chainparams.GetConsensus().vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout != 0) <%\n         // Only advertise witness capabilities if they have a reasonable start time.\n         // This allows us to have the code merged without a defined softfork, by setting its\n         // end time to 0.\n         // Note that setting NODE_WITNESS is never required: the only downside from not\n         // doing so is that after activation, no upgraded nodes will fetch from you.\n         nLocalServices = ServiceFlags(nLocalServices | NODE_WITNESS);\n-    }\n+    %>\n \n     // ********************************************************* Step 11: import blocks\n \n-    if (!CheckDiskSpace(GetDataDir())) {\n+    if (!CheckDiskSpace(GetDataDir())) <%\n         InitError(strprintf(_(\"Error: Disk space is low for %s\"), GetDataDir()));\n         return false;\n-    }\n-    if (!CheckDiskSpace(GetBlocksDir())) {\n+    %>\n+    if (!CheckDiskSpace(GetBlocksDir())) <%\n         InitError(strprintf(_(\"Error: Disk space is low for %s\"), GetBlocksDir()));\n         return false;\n-    }\n+    %>\n \n     // Either install a handler to notify us when genesis activates, or set fHaveGenesis directly.\n     // No locking, as this happens before any background thread is started.\n-    if (chainActive.Tip() == nullptr) {\n+    if (chainActive.Tip() == nullptr) <%\n         uiInterface.NotifyBlockTip_connect(BlockNotifyGenesisWait);\n-    } else {\n+    %> else <%\n         fHaveGenesis = true;\n-    }\n+    %>\n \n     if (gArgs.IsArgSet(\"-blocknotify\"))\n         uiInterface.NotifyBlockTip_connect(BlockNotifyCallback);\n \n     std::vector<fs::path> vImportFiles;\n-    for (const std::string& strFile : gArgs.GetArgs(\"-loadblock\")) {\n+    for (const std::string& strFile : gArgs.GetArgs(\"-loadblock\")) <%\n         vImportFiles.push_back(strFile);\n-    }\n+    %>\n \n     threadGroup.create_thread(std::bind(&ThreadImport, vImportFiles));\n \n     // Wait for genesis block to be processed\n-    {\n+    <%\n         WAIT_LOCK(g_genesis_wait_mutex, lock);\n         // We previously could hang here if StartShutdown() is called prior to\n         // ThreadImport getting started, so instead we just wait on a timer to\n         // check ShutdownRequested() regularly.\n-        while (!fHaveGenesis && !ShutdownRequested()) {\n+        while (!fHaveGenesis && !ShutdownRequested()) <%\n             g_genesis_wait_cv.wait_for(lock, std::chrono::milliseconds(500));\n-        }\n+        %>\n         uiInterface.NotifyBlockTip_disconnect(BlockNotifyGenesisWait);\n-    }\n+    %>\n \n-    if (ShutdownRequested()) {\n+    if (ShutdownRequested()) <%\n         return false;\n-    }\n+    %>\n \n     // ********************************************************* Step 12: start node\n \n     int chain_active_height;\n \n     //// debug print\n-    {\n+    <%\n         LOCK(cs_main);\n         LogPrintf(\"mapBlockIndex.size() = %u\\n\", mapBlockIndex.size());\n         chain_active_height = chainActive.Height();\n-    }\n+    %>\n     LogPrintf(\"nBestHeight = %d\\n\", chain_active_height);\n \n     if (gArgs.GetBoolArg(\"-listenonion\", DEFAULT_LISTEN_ONION))\n@@ -1737,9 +1737,9 @@ bool AppInitMain(InitInterfaces& interfaces)\n     Discover();\n \n     // Map ports with UPnP\n-    if (gArgs.GetBoolArg(\"-upnp\", DEFAULT_UPNP)) {\n+    if (gArgs.GetBoolArg(\"-upnp\", DEFAULT_UPNP)) <%\n         StartMapPort();\n-    }\n+    %>\n \n     CConnman::Options connOptions;\n     connOptions.nLocalServices = nLocalServices;\n@@ -1759,58 +1759,58 @@ bool AppInitMain(InitInterfaces& interfaces)\n     connOptions.nMaxOutboundLimit = nMaxOutboundLimit;\n     connOptions.m_peer_connect_timeout = peer_connect_timeout;\n \n-    for (const std::string& strBind : gArgs.GetArgs(\"-bind\")) {\n+    for (const std::string& strBind : gArgs.GetArgs(\"-bind\")) <%\n         CService addrBind;\n-        if (!Lookup(strBind.c_str(), addrBind, GetListenPort(), false)) {\n+        if (!Lookup(strBind.c_str(), addrBind, GetListenPort(), false)) <%\n             return InitError(ResolveErrMsg(\"bind\", strBind));\n-        }\n+        %>\n         connOptions.vBinds.push_back(addrBind);\n-    }\n-    for (const std::string& strBind : gArgs.GetArgs(\"-whitebind\")) {\n+    %>\n+    for (const std::string& strBind : gArgs.GetArgs(\"-whitebind\")) <%\n         CService addrBind;\n-        if (!Lookup(strBind.c_str(), addrBind, 0, false)) {\n+        if (!Lookup(strBind.c_str(), addrBind, 0, false)) <%\n             return InitError(ResolveErrMsg(\"whitebind\", strBind));\n-        }\n-        if (addrBind.GetPort() == 0) {\n+        %>\n+        if (addrBind.GetPort() == 0) <%\n             return InitError(strprintf(_(\"Need to specify a port with -whitebind: '%s'\"), strBind));\n-        }\n+        %>\n         connOptions.vWhiteBinds.push_back(addrBind);\n-    }\n+    %>\n \n-    for (const auto& net : gArgs.GetArgs(\"-whitelist\")) {\n+    for (const auto& net : gArgs.GetArgs(\"-whitelist\")) <%\n         CSubNet subnet;\n         LookupSubNet(net.c_str(), subnet);\n         if (!subnet.IsValid())\n             return InitError(strprintf(_(\"Invalid netmask specified in -whitelist: '%s'\"), net));\n         connOptions.vWhitelistedRange.push_back(subnet);\n-    }\n+    %>\n \n     connOptions.vSeedNodes = gArgs.GetArgs(\"-seednode\");\n \n     // Initiate outbound connections unless connect=0\n     connOptions.m_use_addrman_outgoing = !gArgs.IsArgSet(\"-connect\");\n-    if (!connOptions.m_use_addrman_outgoing) {\n+    if (!connOptions.m_use_addrman_outgoing) <%\n         const auto connect = gArgs.GetArgs(\"-connect\");\n-        if (connect.size() != 1 || connect[0] != \"0\") {\n+        if (connect.size() != 1 || connect[0] != \"0\") <%\n             connOptions.m_specified_outgoing = connect;\n-        }\n-    }\n-    if (!g_connman->Start(scheduler, connOptions)) {\n+        %>\n+    %>\n+    if (!g_connman->Start(scheduler, connOptions)) <%\n         return false;\n-    }\n+    %>\n \n     // ********************************************************* Step 13: finished\n \n     SetRPCWarmupFinished();\n     uiInterface.InitMessage(_(\"Done loading\"));\n \n-    for (const auto& client : interfaces.chain_clients) {\n+    for (const auto& client : interfaces.chain_clients) <%\n         client->start(scheduler);\n-    }\n+    %>\n \n-    scheduler.scheduleEvery([]{\n+    scheduler.scheduleEvery([]<%\n         g_banman->DumpBanlist();\n-    }, DUMP_BANS_INTERVAL * 1000);\n+    %>, DUMP_BANS_INTERVAL * 1000);\n \n     return true;\n-}\n+%>"
      },
      {
        "sha": "44a304ff95db2c3c5f02565cab40c43c55f57045",
        "filename": "src/init.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/init.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/init.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -10,22 +10,22 @@\n #include <string>\n #include <util/system.h>\n \n-namespace interfaces {\n+namespace interfaces <%\n class Chain;\n class ChainClient;\n-} // namespace interfaces\n+%> // namespace interfaces\n \n //! Pointers to interfaces used during init and destroyed on shutdown.\n struct InitInterfaces\n-{\n+<%\n     std::unique_ptr<interfaces::Chain> chain;\n     std::vector<std::unique_ptr<interfaces::ChainClient>> chain_clients;\n-};\n+%>;\n \n namespace boost\n-{\n+<%\n class thread_group;\n-} // namespace boost\n+%> // namespace boost\n \n /** Interrupt threads */\n void Interrupt();"
      },
      {
        "sha": "56584c7af415cd01dfe5c744dee8f8e118089ea1",
        "filename": "src/interfaces/chain.cpp",
        "status": "modified",
        "additions": 161,
        "deletions": 161,
        "changes": 322,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/interfaces/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/interfaces/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -33,290 +33,290 @@\n #include <memory>\n #include <utility>\n \n-namespace interfaces {\n-namespace {\n+namespace interfaces <%\n+namespace <%\n \n class LockImpl : public Chain::Lock\n-{\n+<%\n     Optional<int> getHeight() override\n-    {\n+    <%\n         int height = ::chainActive.Height();\n-        if (height >= 0) {\n+        if (height >= 0) <%\n             return height;\n-        }\n+        %>\n         return nullopt;\n-    }\n+    %>\n     Optional<int> getBlockHeight(const uint256& hash) override\n-    {\n+    <%\n         CBlockIndex* block = LookupBlockIndex(hash);\n-        if (block && ::chainActive.Contains(block)) {\n+        if (block && ::chainActive.Contains(block)) <%\n             return block->nHeight;\n-        }\n+        %>\n         return nullopt;\n-    }\n+    %>\n     int getBlockDepth(const uint256& hash) override\n-    {\n+    <%\n         const Optional<int> tip_height = getHeight();\n         const Optional<int> height = getBlockHeight(hash);\n         return tip_height && height ? *tip_height - *height + 1 : 0;\n-    }\n+    %>\n     uint256 getBlockHash(int height) override\n-    {\n+    <%\n         CBlockIndex* block = ::chainActive[height];\n         assert(block != nullptr);\n         return block->GetBlockHash();\n-    }\n+    %>\n     int64_t getBlockTime(int height) override\n-    {\n+    <%\n         CBlockIndex* block = ::chainActive[height];\n         assert(block != nullptr);\n         return block->GetBlockTime();\n-    }\n+    %>\n     int64_t getBlockMedianTimePast(int height) override\n-    {\n+    <%\n         CBlockIndex* block = ::chainActive[height];\n         assert(block != nullptr);\n         return block->GetMedianTimePast();\n-    }\n+    %>\n     bool haveBlockOnDisk(int height) override\n-    {\n+    <%\n         CBlockIndex* block = ::chainActive[height];\n         return block && ((block->nStatus & BLOCK_HAVE_DATA) != 0) && block->nTx > 0;\n-    }\n+    %>\n     Optional<int> findFirstBlockWithTime(int64_t time, uint256* hash) override\n-    {\n+    <%\n         CBlockIndex* block = ::chainActive.FindEarliestAtLeast(time);\n-        if (block) {\n+        if (block) <%\n             if (hash) *hash = block->GetBlockHash();\n             return block->nHeight;\n-        }\n+        %>\n         return nullopt;\n-    }\n+    %>\n     Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height) override\n-    {\n+    <%\n         // TODO: Could update CChain::FindEarliestAtLeast() to take a height\n         // parameter and use it with std::lower_bound() to make this\n         // implementation more efficient and allow combining\n         // findFirstBlockWithTime and findFirstBlockWithTimeAndHeight into one\n         // method.\n-        for (CBlockIndex* block = ::chainActive[height]; block; block = ::chainActive.Next(block)) {\n-            if (block->GetBlockTime() >= time) {\n+        for (CBlockIndex* block = ::chainActive[height]; block; block = ::chainActive.Next(block)) <%\n+            if (block->GetBlockTime() >= time) <%\n                 return block->nHeight;\n-            }\n-        }\n+            %>\n+        %>\n         return nullopt;\n-    }\n+    %>\n     Optional<int> findPruned(int start_height, Optional<int> stop_height) override\n-    {\n-        if (::fPruneMode) {\n+    <%\n+        if (::fPruneMode) <%\n             CBlockIndex* block = stop_height ? ::chainActive[*stop_height] : ::chainActive.Tip();\n-            while (block && block->nHeight >= start_height) {\n-                if ((block->nStatus & BLOCK_HAVE_DATA) == 0) {\n+            while (block && block->nHeight >= start_height) <%\n+                if ((block->nStatus & BLOCK_HAVE_DATA) == 0) <%\n                     return block->nHeight;\n-                }\n+                %>\n                 block = block->pprev;\n-            }\n-        }\n+            %>\n+        %>\n         return nullopt;\n-    }\n+    %>\n     Optional<int> findFork(const uint256& hash, Optional<int>* height) override\n-    {\n+    <%\n         const CBlockIndex* block = LookupBlockIndex(hash);\n         const CBlockIndex* fork = block ? ::chainActive.FindFork(block) : nullptr;\n-        if (height) {\n-            if (block) {\n+        if (height) <%\n+            if (block) <%\n                 *height = block->nHeight;\n-            } else {\n+            %> else <%\n                 height->reset();\n-            }\n-        }\n-        if (fork) {\n+            %>\n+        %>\n+        if (fork) <%\n             return fork->nHeight;\n-        }\n+        %>\n         return nullopt;\n-    }\n+    %>\n     bool isPotentialTip(const uint256& hash) override\n-    {\n+    <%\n         if (::chainActive.Tip()->GetBlockHash() == hash) return true;\n         CBlockIndex* block = LookupBlockIndex(hash);\n         return block && block->GetAncestor(::chainActive.Height()) == ::chainActive.Tip();\n-    }\n-    CBlockLocator getTipLocator() override { return ::chainActive.GetLocator(); }\n+    %>\n+    CBlockLocator getTipLocator() override <% return ::chainActive.GetLocator(); %>\n     Optional<int> findLocatorFork(const CBlockLocator& locator) override\n-    {\n+    <%\n         LockAnnotation lock(::cs_main);\n-        if (CBlockIndex* fork = FindForkInGlobalIndex(::chainActive, locator)) {\n+        if (CBlockIndex* fork = FindForkInGlobalIndex(::chainActive, locator)) <%\n             return fork->nHeight;\n-        }\n+        %>\n         return nullopt;\n-    }\n+    %>\n     bool checkFinalTx(const CTransaction& tx) override\n-    {\n+    <%\n         LockAnnotation lock(::cs_main);\n         return CheckFinalTx(tx);\n-    }\n+    %>\n     bool submitToMemoryPool(const CTransactionRef& tx, CAmount absurd_fee, CValidationState& state) override\n-    {\n+    <%\n         LockAnnotation lock(::cs_main);\n         return AcceptToMemoryPool(::mempool, state, tx, nullptr /* missing inputs */, nullptr /* txn replaced */,\n             false /* bypass limits */, absurd_fee);\n-    }\n-};\n+    %>\n+%>;\n \n class LockingStateImpl : public LockImpl, public UniqueLock<CCriticalSection>\n-{\n+<%\n     using UniqueLock::UniqueLock;\n-};\n+%>;\n \n class NotificationsHandlerImpl : public Handler, CValidationInterface\n-{\n+<%\n public:\n     explicit NotificationsHandlerImpl(Chain& chain, Chain::Notifications& notifications)\n         : m_chain(chain), m_notifications(&notifications)\n-    {\n+    <%\n         RegisterValidationInterface(this);\n-    }\n-    ~NotificationsHandlerImpl() override { disconnect(); }\n+    %>\n+    ~NotificationsHandlerImpl() override <% disconnect(); %>\n     void disconnect() override\n-    {\n-        if (m_notifications) {\n+    <%\n+        if (m_notifications) <%\n             m_notifications = nullptr;\n             UnregisterValidationInterface(this);\n-        }\n-    }\n+        %>\n+    %>\n     void TransactionAddedToMempool(const CTransactionRef& tx) override\n-    {\n+    <%\n         m_notifications->TransactionAddedToMempool(tx);\n-    }\n+    %>\n     void TransactionRemovedFromMempool(const CTransactionRef& tx) override\n-    {\n+    <%\n         m_notifications->TransactionRemovedFromMempool(tx);\n-    }\n+    %>\n     void BlockConnected(const std::shared_ptr<const CBlock>& block,\n         const CBlockIndex* index,\n         const std::vector<CTransactionRef>& tx_conflicted) override\n-    {\n+    <%\n         m_notifications->BlockConnected(*block, tx_conflicted);\n-    }\n+    %>\n     void BlockDisconnected(const std::shared_ptr<const CBlock>& block) override\n-    {\n+    <%\n         m_notifications->BlockDisconnected(*block);\n-    }\n-    void ChainStateFlushed(const CBlockLocator& locator) override { m_notifications->ChainStateFlushed(locator); }\n+    %>\n+    void ChainStateFlushed(const CBlockLocator& locator) override <% m_notifications->ChainStateFlushed(locator); %>\n     void ResendWalletTransactions(int64_t best_block_time, CConnman*) override\n-    {\n+    <%\n         // `cs_main` is always held when this method is called, so it is safe to\n         // call `assumeLocked`. This is awkward, and the `assumeLocked` method\n         // should be able to be removed entirely if `ResendWalletTransactions`\n         // is replaced by a wallet timer as suggested in\n         // https://github.com/bitcoin/bitcoin/issues/15619\n         auto locked_chain = m_chain.assumeLocked();\n         m_notifications->ResendWalletTransactions(*locked_chain, best_block_time);\n-    }\n+    %>\n     Chain& m_chain;\n     Chain::Notifications* m_notifications;\n-};\n+%>;\n \n class RpcHandlerImpl : public Handler\n-{\n+<%\n public:\n     RpcHandlerImpl(const CRPCCommand& command) : m_command(command), m_wrapped_command(&command)\n-    {\n-        m_command.actor = [this](const JSONRPCRequest& request, UniValue& result, bool last_handler) {\n+    <%\n+        m_command.actor = [this](const JSONRPCRequest& request, UniValue& result, bool last_handler) <%\n             if (!m_wrapped_command) return false;\n-            try {\n+            try <%\n                 return m_wrapped_command->actor(request, result, last_handler);\n-            } catch (const UniValue& e) {\n+            %> catch (const UniValue& e) <%\n                 // If this is not the last handler and a wallet not found\n                 // exception was thrown, return false so the next handler can\n                 // try to handle the request. Otherwise, reraise the exception.\n-                if (!last_handler) {\n+                if (!last_handler) <%\n                     const UniValue& code = e[\"code\"];\n-                    if (code.isNum() && code.get_int() == RPC_WALLET_NOT_FOUND) {\n+                    if (code.isNum() && code.get_int() == RPC_WALLET_NOT_FOUND) <%\n                         return false;\n-                    }\n-                }\n+                    %>\n+                %>\n                 throw;\n-            }\n-        };\n+            %>\n+        %>;\n         ::tableRPC.appendCommand(m_command.name, &m_command);\n-    }\n+    %>\n \n     void disconnect() override final\n-    {\n-        if (m_wrapped_command) {\n+    <%\n+        if (m_wrapped_command) <%\n             m_wrapped_command = nullptr;\n             ::tableRPC.removeCommand(m_command.name, &m_command);\n-        }\n-    }\n+        %>\n+    %>\n \n-    ~RpcHandlerImpl() override { disconnect(); }\n+    ~RpcHandlerImpl() override <% disconnect(); %>\n \n     CRPCCommand m_command;\n     const CRPCCommand* m_wrapped_command;\n-};\n+%>;\n \n class ChainImpl : public Chain\n-{\n+<%\n public:\n     std::unique_ptr<Chain::Lock> lock(bool try_lock) override\n-    {\n+    <%\n         auto result = MakeUnique<LockingStateImpl>(::cs_main, \"cs_main\", __FILE__, __LINE__, try_lock);\n-        if (try_lock && result && !*result) return {};\n+        if (try_lock && result && !*result) return <%%>;\n         // std::move necessary on some compilers due to conversion from\n         // LockingStateImpl to Lock pointer\n         return std::move(result);\n-    }\n-    std::unique_ptr<Chain::Lock> assumeLocked() override { return MakeUnique<LockImpl>(); }\n+    %>\n+    std::unique_ptr<Chain::Lock> assumeLocked() override <% return MakeUnique<LockImpl>(); %>\n     bool findBlock(const uint256& hash, CBlock* block, int64_t* time, int64_t* time_max) override\n-    {\n+    <%\n         CBlockIndex* index;\n-        {\n+        <%\n             LOCK(cs_main);\n             index = LookupBlockIndex(hash);\n-            if (!index) {\n+            if (!index) <%\n                 return false;\n-            }\n-            if (time) {\n+            %>\n+            if (time) <%\n                 *time = index->GetBlockTime();\n-            }\n-            if (time_max) {\n+            %>\n+            if (time_max) <%\n                 *time_max = index->GetBlockTimeMax();\n-            }\n-        }\n-        if (block && !ReadBlockFromDisk(*block, index, Params().GetConsensus())) {\n+            %>\n+        %>\n+        if (block && !ReadBlockFromDisk(*block, index, Params().GetConsensus())) <%\n             block->SetNull();\n-        }\n+        %>\n         return true;\n-    }\n-    void findCoins(std::map<COutPoint, Coin>& coins) override { return FindCoins(coins); }\n+    %>\n+    void findCoins(std::map<COutPoint, Coin>& coins) override <% return FindCoins(coins); %>\n     double guessVerificationProgress(const uint256& block_hash) override\n-    {\n+    <%\n         LOCK(cs_main);\n         return GuessVerificationProgress(Params().TxData(), LookupBlockIndex(block_hash));\n-    }\n+    %>\n     RBFTransactionState isRBFOptIn(const CTransaction& tx) override\n-    {\n+    <%\n         LOCK(::mempool.cs);\n         return IsRBFOptIn(tx, ::mempool);\n-    }\n+    %>\n     bool hasDescendantsInMempool(const uint256& txid) override\n-    {\n+    <%\n         LOCK(::mempool.cs);\n         auto it = ::mempool.GetIter(txid);\n         return it && (*it)->GetCountWithDescendants() > 1;\n-    }\n+    %>\n     void relayTransaction(const uint256& txid) override\n-    {\n+    <%\n         CInv inv(MSG_TX, txid);\n-        g_connman->ForEachNode([&inv](CNode* node) { node->PushInventory(inv); });\n-    }\n+        g_connman->ForEachNode([&inv](CNode* node) <% node->PushInventory(inv); %>);\n+    %>\n     void getTransactionAncestry(const uint256& txid, size_t& ancestors, size_t& descendants) override\n-    {\n+    <%\n         ::mempool.GetTransactionAncestry(txid, ancestors, descendants);\n-    }\n+    %>\n     bool checkChainLimits(const CTransactionRef& tx) override\n-    {\n+    <%\n         LockPoints lp;\n         CTxMemPoolEntry entry(tx, 0, 0, 0, false, 0, lp);\n         CTxMemPool::setEntries ancestors;\n@@ -328,48 +328,48 @@ class ChainImpl : public Chain\n         LOCK(::mempool.cs);\n         return ::mempool.CalculateMemPoolAncestors(entry, ancestors, limit_ancestor_count, limit_ancestor_size,\n             limit_descendant_count, limit_descendant_size, unused_error_string);\n-    }\n+    %>\n     CFeeRate estimateSmartFee(int num_blocks, bool conservative, FeeCalculation* calc) override\n-    {\n+    <%\n         return ::feeEstimator.estimateSmartFee(num_blocks, calc, conservative);\n-    }\n+    %>\n     unsigned int estimateMaxBlocks() override\n-    {\n+    <%\n         return ::feeEstimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE);\n-    }\n+    %>\n     CFeeRate mempoolMinFee() override\n-    {\n+    <%\n         return ::mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n-    }\n-    CFeeRate relayMinFee() override { return ::minRelayTxFee; }\n-    CFeeRate relayIncrementalFee() override { return ::incrementalRelayFee; }\n-    CFeeRate relayDustFee() override { return ::dustRelayFee; }\n-    CAmount maxTxFee() override { return ::maxTxFee; }\n-    bool getPruneMode() override { return ::fPruneMode; }\n-    bool p2pEnabled() override { return g_connman != nullptr; }\n-    bool isInitialBlockDownload() override { return IsInitialBlockDownload(); }\n-    bool shutdownRequested() override { return ShutdownRequested(); }\n-    int64_t getAdjustedTime() override { return GetAdjustedTime(); }\n-    void initMessage(const std::string& message) override { ::uiInterface.InitMessage(message); }\n-    void initWarning(const std::string& message) override { InitWarning(message); }\n-    void initError(const std::string& message) override { InitError(message); }\n-    void loadWallet(std::unique_ptr<Wallet> wallet) override { ::uiInterface.LoadWallet(wallet); }\n+    %>\n+    CFeeRate relayMinFee() override <% return ::minRelayTxFee; %>\n+    CFeeRate relayIncrementalFee() override <% return ::incrementalRelayFee; %>\n+    CFeeRate relayDustFee() override <% return ::dustRelayFee; %>\n+    CAmount maxTxFee() override <% return ::maxTxFee; %>\n+    bool getPruneMode() override <% return ::fPruneMode; %>\n+    bool p2pEnabled() override <% return g_connman != nullptr; %>\n+    bool isInitialBlockDownload() override <% return IsInitialBlockDownload(); %>\n+    bool shutdownRequested() override <% return ShutdownRequested(); %>\n+    int64_t getAdjustedTime() override <% return GetAdjustedTime(); %>\n+    void initMessage(const std::string& message) override <% ::uiInterface.InitMessage(message); %>\n+    void initWarning(const std::string& message) override <% InitWarning(message); %>\n+    void initError(const std::string& message) override <% InitError(message); %>\n+    void loadWallet(std::unique_ptr<Wallet> wallet) override <% ::uiInterface.LoadWallet(wallet); %>\n     void showProgress(const std::string& title, int progress, bool resume_possible) override\n-    {\n+    <%\n         ::uiInterface.ShowProgress(title, progress, resume_possible);\n-    }\n+    %>\n     std::unique_ptr<Handler> handleNotifications(Notifications& notifications) override\n-    {\n+    <%\n         return MakeUnique<NotificationsHandlerImpl>(*this, notifications);\n-    }\n-    void waitForNotifications() override { SyncWithValidationInterfaceQueue(); }\n+    %>\n+    void waitForNotifications() override <% SyncWithValidationInterfaceQueue(); %>\n     std::unique_ptr<Handler> handleRpc(const CRPCCommand& command) override\n-    {\n+    <%\n         return MakeUnique<RpcHandlerImpl>(command);\n-    }\n-};\n-} // namespace\n+    %>\n+%>;\n+%> // namespace\n \n-std::unique_ptr<Chain> MakeChain() { return MakeUnique<ChainImpl>(); }\n+std::unique_ptr<Chain> MakeChain() <% return MakeUnique<ChainImpl>(); %>\n \n-} // namespace interfaces\n+%> // namespace interfaces"
      },
      {
        "sha": "9cdd9aeefc8cd09b692225ae9eece65563db59d2",
        "filename": "src/interfaces/chain.h",
        "status": "modified",
        "additions": 20,
        "deletions": 20,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/interfaces/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/interfaces/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -25,7 +25,7 @@ enum class RBFTransactionState;\n struct CBlockLocator;\n struct FeeCalculation;\n \n-namespace interfaces {\n+namespace interfaces <%\n \n class Handler;\n class Wallet;\n@@ -58,19 +58,19 @@ class Wallet;\n //!   communicate with each other without going through the node\n //!   (https://github.com/bitcoin/bitcoin/pull/15288#discussion_r253321096).\n class Chain\n-{\n+<%\n public:\n-    virtual ~Chain() {}\n+    virtual ~Chain() <%%>\n \n     //! Interface for querying locked chain state, used by legacy code that\n     //! assumes state won't change between calls. New code should avoid using\n     //! the Lock interface and instead call higher-level Chain methods\n     //! that return more information so the chain doesn't need to stay locked\n     //! between calls.\n     class Lock\n-    {\n+    <%\n     public:\n-        virtual ~Lock() {}\n+        virtual ~Lock() <%%>\n \n         //! Get current chain height, not including genesis block (returns 0 if\n         //! chain only contains genesis block, nullopt if chain does not contain\n@@ -147,7 +147,7 @@ class Chain\n         //! amount specified by absurd_fee. Returns false if the transaction\n         //! could not be added due to the fee or for another reason.\n         virtual bool submitToMemoryPool(const CTransactionRef& tx, CAmount absurd_fee, CValidationState& state) = 0;\n-    };\n+    %>;\n \n     //! Return Lock interface. Chain is locked when this is called, and\n     //! unlocked when the returned interface is freed.\n@@ -249,16 +249,16 @@ class Chain\n \n     //! Chain notifications.\n     class Notifications\n-    {\n+    <%\n     public:\n-        virtual ~Notifications() {}\n-        virtual void TransactionAddedToMempool(const CTransactionRef& tx) {}\n-        virtual void TransactionRemovedFromMempool(const CTransactionRef& ptx) {}\n-        virtual void BlockConnected(const CBlock& block, const std::vector<CTransactionRef>& tx_conflicted) {}\n-        virtual void BlockDisconnected(const CBlock& block) {}\n-        virtual void ChainStateFlushed(const CBlockLocator& locator) {}\n-        virtual void ResendWalletTransactions(Lock& locked_chain, int64_t best_block_time) {}\n-    };\n+        virtual ~Notifications() <%%>\n+        virtual void TransactionAddedToMempool(const CTransactionRef& tx) <%%>\n+        virtual void TransactionRemovedFromMempool(const CTransactionRef& ptx) <%%>\n+        virtual void BlockConnected(const CBlock& block, const std::vector<CTransactionRef>& tx_conflicted) <%%>\n+        virtual void BlockDisconnected(const CBlock& block) <%%>\n+        virtual void ChainStateFlushed(const CBlockLocator& locator) <%%>\n+        virtual void ResendWalletTransactions(Lock& locked_chain, int64_t best_block_time) <%%>\n+    %>;\n \n     //! Register handler for notifications.\n     virtual std::unique_ptr<Handler> handleNotifications(Notifications& notifications) = 0;\n@@ -269,14 +269,14 @@ class Chain\n     //! Register handler for RPC. Command is not copied, so reference\n     //! needs to remain valid until Handler is disconnected.\n     virtual std::unique_ptr<Handler> handleRpc(const CRPCCommand& command) = 0;\n-};\n+%>;\n \n //! Interface to let node manage chain clients (wallets, or maybe tools for\n //! monitoring and analysis in the future).\n class ChainClient\n-{\n+<%\n public:\n-    virtual ~ChainClient() {}\n+    virtual ~ChainClient() <%%>\n \n     //! Register rpcs.\n     virtual void registerRpcs() = 0;\n@@ -295,7 +295,7 @@ class ChainClient\n \n     //! Shut down client.\n     virtual void stop() = 0;\n-};\n+%>;\n \n //! Return implementation of Chain interface.\n std::unique_ptr<Chain> MakeChain();\n@@ -310,6 +310,6 @@ std::unique_ptr<Chain> MakeChain();\n //! interface.\n std::unique_ptr<ChainClient> MakeWalletClient(Chain& chain, std::vector<std::string> wallet_filenames);\n \n-} // namespace interfaces\n+%> // namespace interfaces\n \n #endif // BITCOIN_INTERFACES_CHAIN_H"
      },
      {
        "sha": "790b16459a9368eef6edeca72557281553fc652a",
        "filename": "src/interfaces/handler.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/interfaces/handler.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/interfaces/handler.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/handler.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -9,24 +9,24 @@\n #include <boost/signals2/connection.hpp>\n #include <utility>\n \n-namespace interfaces {\n-namespace {\n+namespace interfaces <%\n+namespace <%\n \n class HandlerImpl : public Handler\n-{\n+<%\n public:\n-    explicit HandlerImpl(boost::signals2::connection connection) : m_connection(std::move(connection)) {}\n+    explicit HandlerImpl(boost::signals2::connection connection) : m_connection(std::move(connection)) <%%>\n \n-    void disconnect() override { m_connection.disconnect(); }\n+    void disconnect() override <% m_connection.disconnect(); %>\n \n     boost::signals2::scoped_connection m_connection;\n-};\n+%>;\n \n-} // namespace\n+%> // namespace\n \n std::unique_ptr<Handler> MakeHandler(boost::signals2::connection connection)\n-{\n+<%\n     return MakeUnique<HandlerImpl>(std::move(connection));\n-}\n+%>\n \n-} // namespace interfaces\n+%> // namespace interfaces"
      },
      {
        "sha": "e3a8b8abba970ed492e7282df3eb6b2386c850c8",
        "filename": "src/interfaces/handler.h",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/interfaces/handler.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/interfaces/handler.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/handler.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "patch": "@@ -7,29 +7,29 @@\n \n #include <memory>\n \n-namespace boost {\n-namespace signals2 {\n+namespace boost <%\n+namespace signals2 <%\n class connection;\n-} // namespace signals2\n-} // namespace boost\n+%> // namespace signals2\n+%> // namespace boost\n \n-namespace interfaces {\n+namespace interfaces <%\n \n //! Generic interface for managing an event handler or callback function\n //! registered with another interface. Has a single disconnect method to cancel\n //! the registration and prevent any future notifications.\n class Handler\n-{\n+<%\n public:\n-    virtual ~Handler() {}\n+    virtual ~Handler() <%%>\n \n     //! Disconnect the handler.\n     virtual void disconnect() = 0;\n-};\n+%>;\n \n //! Return handler wrapping a boost signal connection.\n std::unique_ptr<Handler> MakeHandler(boost::signals2::connection connection);\n \n-} // namespace interfaces\n+%> // namespace interfaces\n \n #endif // BITCOIN_INTERFACES_HANDLER_H"
      },
      {
        "sha": "fd0df77505eaa3aca3539a32456cf3d4cc4456b2",
        "filename": "src/interfaces/node.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/interfaces/node.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/interfaces/node.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/node.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "36fad8f14a820068de80cc4ef45c32aced13afeb",
        "filename": "src/interfaces/node.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/interfaces/node.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/interfaces/node.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/node.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "77466e0c86e966b2629696d2d66bb7e09cd69938",
        "filename": "src/interfaces/wallet.cpp",
        "status": "modified",
        "additions": 195,
        "deletions": 195,
        "changes": 390,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/interfaces/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/interfaces/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/wallet.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "6489fd4549c8435bbbb0789a427e297cc64207c8",
        "filename": "src/interfaces/wallet.h",
        "status": "modified",
        "additions": 22,
        "deletions": 22,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/interfaces/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/interfaces/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/wallet.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "a481f083abf2fe2d5d484f8c1a44c99f7a201fbe",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 86,
        "deletions": 86,
        "changes": 172,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "6f5d2335a6cd9d79a2e06dbe2350a1b232a3e2ef",
        "filename": "src/key.h",
        "status": "modified",
        "additions": 25,
        "deletions": 25,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/key.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/key.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "41f8547f90c713dfc2d1f94d960ba84aba464047",
        "filename": "src/key_io.cpp",
        "status": "modified",
        "additions": 85,
        "deletions": 85,
        "changes": 170,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/key_io.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/key_io.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key_io.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "eba9ff60075974d31ef2aeb2f1d54fbbc18fe089",
        "filename": "src/keystore.cpp",
        "status": "modified",
        "additions": 62,
        "deletions": 62,
        "changes": 124,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/keystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/keystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "1ba57b58d6f76eff065be91dac3f283744560470",
        "filename": "src/keystore.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/keystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/keystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "fe044ba4a79b492ffe44b245b50fab3790c9207f",
        "filename": "src/limitedmap.h",
        "status": "modified",
        "additions": 29,
        "deletions": 29,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/limitedmap.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/limitedmap.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/limitedmap.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "f9e681846f9e47414bd9a0b3f3b5d6d1c70f21b2",
        "filename": "src/logging.cpp",
        "status": "modified",
        "additions": 104,
        "deletions": 104,
        "changes": 208,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/logging.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/logging.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "5134587df9d3feb3de2de909fc1a4827ea0433c8",
        "filename": "src/logging.h",
        "status": "modified",
        "additions": 26,
        "deletions": 26,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/logging.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/logging.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "59e98c64c6cbcf186a770357431c4eca78b8f96c",
        "filename": "src/memusage.h",
        "status": "modified",
        "additions": 51,
        "deletions": 51,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/memusage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/memusage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/memusage.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "7c6aaed9136c1d05593afbae320c2774ab528e19",
        "filename": "src/merkleblock.cpp",
        "status": "modified",
        "additions": 39,
        "deletions": 39,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/merkleblock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/merkleblock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/merkleblock.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "28ced3591b30e89e3cedd77f244f6582854ce5c9",
        "filename": "src/merkleblock.h",
        "status": "modified",
        "additions": 17,
        "deletions": 17,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/merkleblock.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/merkleblock.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/merkleblock.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "52cbf0e3a3b66dd0e836a9ff8aeef79eb961337e",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 83,
        "deletions": 83,
        "changes": 166,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "40f6abb6e3a9357366fc3106d62353919be68ba7",
        "filename": "src/miner.h",
        "status": "modified",
        "additions": 33,
        "deletions": 33,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "cc2dc9857db149aee7d86bb74031ef279cc6d9af",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 807,
        "deletions": 807,
        "changes": 1614,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "b1c0ae2c00923b279dbd7670820a8f3d540cca8f",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 152,
        "deletions": 152,
        "changes": 304,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "6055d5fadc65416f53890f79a3e08b698fc87488",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1038,
        "deletions": 1038,
        "changes": 2076,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "19672ea1b636b7eb5b19167515830728b1b1b78e",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "81615f03e2e0c1d1cc6ab7a971ae9e708e4957f7",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 201,
        "deletions": 201,
        "changes": 402,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "cfad19231c81f1aca4efd7496c58bd7b18069215",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 18,
        "deletions": 18,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "8f31cb700c2264f9806d3c427a541fdff16adde6",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 216,
        "deletions": 216,
        "changes": 432,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "c7efdd7d6a283117c3a247fee05fe88b33c42059",
        "filename": "src/netbase.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/netbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/netbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "72ec40bb825150d7581223cdc4d2790f47945eaf",
        "filename": "src/netmessagemaker.h",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/netmessagemaker.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/netmessagemaker.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netmessagemaker.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "17077362bab8ae53e7910b0688f74fc4e5bf6762",
        "filename": "src/node/coin.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/node/coin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/node/coin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/coin.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "8839ee05d1add93a6fd9df1cff9ee8c656f2a8ad",
        "filename": "src/node/transaction.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 28,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/node/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/node/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/transaction.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "c50ae1051a658a0a081147d654d948c0269d3e9e",
        "filename": "src/node/transaction.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/node/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/node/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/transaction.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "a77a427dc6af726d7fbaa89938ea8b530847af36",
        "filename": "src/noui.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/noui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/noui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/noui.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "9df438c1b51492570ee21c957b487e76e3872f63",
        "filename": "src/optional.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/optional.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/optional.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/optional.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "db912e6238f777dcaaf8fde104a940f41bd4957b",
        "filename": "src/outputtype.cpp",
        "status": "modified",
        "additions": 35,
        "deletions": 35,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/outputtype.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/outputtype.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/outputtype.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "c07b2cd4c16100d18b90585388cb2495b990b9b5",
        "filename": "src/outputtype.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/outputtype.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/outputtype.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/outputtype.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "4049ea2eb4a8038f60a1aa7279f95a1985471789",
        "filename": "src/policy/feerate.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/policy/feerate.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/policy/feerate.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/feerate.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "f36c2ed5681d07ac20a349c389b146a811bd6718",
        "filename": "src/policy/feerate.h",
        "status": "modified",
        "additions": 15,
        "deletions": 15,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/policy/feerate.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/policy/feerate.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/feerate.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "3189f0edeb367f20a8c335472629e469df4e2647",
        "filename": "src/policy/fees.cpp",
        "status": "modified",
        "additions": 277,
        "deletions": 277,
        "changes": 554,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/policy/fees.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/policy/fees.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "b1c33f0148a82a5abea1dea93ee6efb7a0cf6e0b",
        "filename": "src/policy/fees.h",
        "status": "modified",
        "additions": 19,
        "deletions": 19,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/policy/fees.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/policy/fees.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "74836792a03212474e7c01d02a01b0f75f5dfca2",
        "filename": "src/policy/policy.cpp",
        "status": "modified",
        "additions": 60,
        "deletions": 60,
        "changes": 120,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/policy/policy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/policy/policy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "a5f2504d54bfb47c49d842ac0fe4cb213258b1ff",
        "filename": "src/policy/rbf.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/policy/rbf.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/policy/rbf.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/rbf.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "9f2abf63fb2308150356cada5e6fe1269ac5fcff",
        "filename": "src/policy/rbf.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/policy/rbf.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/policy/rbf.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/rbf.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "9f177c00ba7d50b3253f0738f15e73143710f999",
        "filename": "src/pow.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/pow.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/pow.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "6bc745362915c1966a5653a933ac314ce8a0e919",
        "filename": "src/prevector.h",
        "status": "modified",
        "additions": 239,
        "deletions": 239,
        "changes": 478,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/prevector.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/prevector.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/prevector.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "78abad394fe1fdbdcc564a943d6daaa183655cd8",
        "filename": "src/primitives/block.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/primitives/block.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/primitives/block.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/block.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "e810890a9f6a7410f9ef76a4f9f860c431714289",
        "filename": "src/primitives/block.h",
        "status": "modified",
        "additions": 34,
        "deletions": 34,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/primitives/block.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/primitives/block.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/block.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "907a513128786a8cbd53f58fce17666afc0223ba",
        "filename": "src/primitives/transaction.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 33,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/primitives/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/primitives/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "c3f95416cbab7a0106243ea4cb8228484e16486b",
        "filename": "src/primitives/transaction.h",
        "status": "modified",
        "additions": 100,
        "deletions": 100,
        "changes": 200,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/primitives/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/primitives/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "15afb69b694f053e60af0d5135c51571a0006c78",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 46,
        "deletions": 46,
        "changes": 92,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "d84e27f51f976efafed904bdfa5b7289410f87cf",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 22,
        "deletions": 22,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "c346048d4f9a9ede51cd6bacbef46506e20cd14f",
        "filename": "src/psbt.cpp",
        "status": "modified",
        "additions": 123,
        "deletions": 123,
        "changes": 246,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/psbt.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/psbt.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/psbt.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "f37b6400d6264e7682b740e9cb35ea2133c1dace",
        "filename": "src/psbt.h",
        "status": "modified",
        "additions": 172,
        "deletions": 172,
        "changes": 344,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/psbt.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/psbt.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/psbt.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "1b8cce7264f3702a702003ae68f958121c3dfa52",
        "filename": "src/pubkey.cpp",
        "status": "modified",
        "additions": 103,
        "deletions": 103,
        "changes": 206,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/pubkey.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/pubkey.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "95401e1f526b64c528076931c50e9d54f0cacc04",
        "filename": "src/pubkey.h",
        "status": "modified",
        "additions": 58,
        "deletions": 58,
        "changes": 116,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/pubkey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/pubkey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "c154172772be63352453850280ca8e107d76176b",
        "filename": "src/qt/addressbookpage.cpp",
        "status": "modified",
        "additions": 69,
        "deletions": 69,
        "changes": 138,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/addressbookpage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/addressbookpage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addressbookpage.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "734d41b027bef002abdac3f9a97c55fe1832810e",
        "filename": "src/qt/addressbookpage.h",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/addressbookpage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/addressbookpage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addressbookpage.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "50de1c579e61ac16f34bc08dc28ec0cbd4bff73f",
        "filename": "src/qt/addresstablemodel.cpp",
        "status": "modified",
        "additions": 147,
        "deletions": 147,
        "changes": 294,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/addresstablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/addresstablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addresstablemodel.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "2786684232b90eec7bec12b091c2ee4643f34beb",
        "filename": "src/qt/addresstablemodel.h",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/addresstablemodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/addresstablemodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addresstablemodel.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "06e6e64c3d5d2457b3fdfe2aad82990fdee00c10",
        "filename": "src/qt/askpassphrasedialog.cpp",
        "status": "modified",
        "additions": 74,
        "deletions": 74,
        "changes": 148,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/askpassphrasedialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/askpassphrasedialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/askpassphrasedialog.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "cff5f939e1ac8d6fb03d29e0b3991a82cc29cb2f",
        "filename": "src/qt/askpassphrasedialog.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/askpassphrasedialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/askpassphrasedialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/askpassphrasedialog.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "40cc3ca3987114fc4c0a5e3c554f9f974789cbfd",
        "filename": "src/qt/bantablemodel.cpp",
        "status": "modified",
        "additions": 45,
        "deletions": 45,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/bantablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/bantablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bantablemodel.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "44ade70375475d86d31a472dcfff454deffd6ee8",
        "filename": "src/qt/bantablemodel.h",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/bantablemodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/bantablemodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bantablemodel.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "c149707834e2b956dde00c854eaf10eb21586569",
        "filename": "src/qt/bitcoin.cpp",
        "status": "modified",
        "additions": 94,
        "deletions": 94,
        "changes": 188,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "c52490b2123302c656dd8fc418b3aadf2f0675d2",
        "filename": "src/qt/bitcoin.h",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/bitcoin.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/bitcoin.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "09b3f369017e4b4a017056255b22f81c7368d3e9",
        "filename": "src/qt/bitcoinaddressvalidator.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 20,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/bitcoinaddressvalidator.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/bitcoinaddressvalidator.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoinaddressvalidator.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "280b2a44efdc2bfb0c0cefc0d6847504742ac061",
        "filename": "src/qt/bitcoinaddressvalidator.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/bitcoinaddressvalidator.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/bitcoinaddressvalidator.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoinaddressvalidator.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "dc4c17366397908a76fc36ba80de4ebd68b933a1",
        "filename": "src/qt/bitcoinamountfield.cpp",
        "status": "modified",
        "additions": 86,
        "deletions": 86,
        "changes": 172,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/bitcoinamountfield.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/bitcoinamountfield.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoinamountfield.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "22feb09820d120c398a8b8745f010e81b13ede01",
        "filename": "src/qt/bitcoinamountfield.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/bitcoinamountfield.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/bitcoinamountfield.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoinamountfield.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "0772710b17f320d5bbd84a0519882d24823f05e7",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 335,
        "deletions": 335,
        "changes": 670,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "5dc1d295e9cbd0a347bfc6f111c913ce330bb978",
        "filename": "src/qt/bitcoingui.h",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/bitcoingui.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/bitcoingui.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "4717c588d0b30b06f54d0357dde68160241259de",
        "filename": "src/qt/bitcoinstrings.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/bitcoinstrings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/bitcoinstrings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoinstrings.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "3f7ba21dce3dbf9f8a22365de2fb7ca74d7710c9",
        "filename": "src/qt/bitcoinunits.cpp",
        "status": "modified",
        "additions": 63,
        "deletions": 63,
        "changes": 126,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/bitcoinunits.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/bitcoinunits.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoinunits.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "bc55901d365e218cac317195e277c53866618d70",
        "filename": "src/qt/bitcoinunits.h",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/bitcoinunits.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/bitcoinunits.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoinunits.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "00d338b9179e351efce1f0f74d6c61988267b85d",
        "filename": "src/qt/clientmodel.cpp",
        "status": "modified",
        "additions": 74,
        "deletions": 74,
        "changes": 148,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/clientmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/clientmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "ccf3fe93003e526fa24f22ff0af3641a2b25fbad",
        "filename": "src/qt/clientmodel.h",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/clientmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/clientmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "a38cfe80e0605c2c5b5c0fafae1272025caf1231",
        "filename": "src/qt/coincontroldialog.cpp",
        "status": "modified",
        "additions": 130,
        "deletions": 130,
        "changes": 260,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/coincontroldialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/coincontroldialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroldialog.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "020116c3c1d0472efb60c07c0534784b9c9ca49c",
        "filename": "src/qt/coincontroldialog.h",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/coincontroldialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/coincontroldialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroldialog.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "d66bd4757476789863ba293d39244abaff71657c",
        "filename": "src/qt/coincontroltreewidget.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/coincontroltreewidget.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/coincontroltreewidget.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroltreewidget.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "b44aef7ae1d6dc6e22cf8275ce5f4b00bcf8c611",
        "filename": "src/qt/coincontroltreewidget.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/coincontroltreewidget.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/coincontroltreewidget.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroltreewidget.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "8b2fc71c8a7b880b7490d71f1bd968545b6d33e4",
        "filename": "src/qt/csvmodelwriter.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 26,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/csvmodelwriter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/csvmodelwriter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/csvmodelwriter.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "320136f871824a63665f1599fe8ce4d59e251741",
        "filename": "src/qt/csvmodelwriter.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/csvmodelwriter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/csvmodelwriter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/csvmodelwriter.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "9ff9a5b51dd44c8924bc47150d383df349a5f1f2",
        "filename": "src/qt/editaddressdialog.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 30,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/editaddressdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/editaddressdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/editaddressdialog.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "32d912649b87471d3e34fee8414a4d2d8a85418e",
        "filename": "src/qt/editaddressdialog.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/editaddressdialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/editaddressdialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/editaddressdialog.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "1fa9b47211167872b8df07dfbc83e9c778337a57",
        "filename": "src/qt/guiconstants.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/guiconstants.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/guiconstants.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiconstants.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "5b7a5e0a2ab4d4dc79327c78e788a9740b23b27e",
        "filename": "src/qt/guiutil.cpp",
        "status": "modified",
        "additions": 248,
        "deletions": 248,
        "changes": 496,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/guiutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/guiutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "bc7325edb92d7f2d28b63c952dd6b53afaae4252",
        "filename": "src/qt/guiutil.h",
        "status": "modified",
        "additions": 15,
        "deletions": 15,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/guiutil.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/guiutil.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "cdf7da0184bfbcee4d13854f82617c25b4bd2ac7",
        "filename": "src/qt/intro.cpp",
        "status": "modified",
        "additions": 81,
        "deletions": 81,
        "changes": 162,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/intro.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/intro.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/intro.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "bcd88adbde00b1dca1d980a73f898db6cac1f527",
        "filename": "src/qt/intro.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/intro.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/intro.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/intro.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "36f1f3d38749b4ea7976b42ad1925a9ccb66cc91",
        "filename": "src/qt/macdockiconhandler.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/macdockiconhandler.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/macdockiconhandler.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/macdockiconhandler.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "ef4ad332857fbf70992b9617a92caab50008325f",
        "filename": "src/qt/macnotificationhandler.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/macnotificationhandler.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/macnotificationhandler.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/macnotificationhandler.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "4ad308ffbb225fd1694d076e750875fb91333e0b",
        "filename": "src/qt/macos_appnap.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/macos_appnap.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/macos_appnap.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/macos_appnap.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "98cdc25308d6efd35e1e2de4a3b4bb67982cdcb0",
        "filename": "src/qt/main.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/main.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "ad6dc47802003fc92ec4cd4d44630da9364a9b93",
        "filename": "src/qt/modaloverlay.cpp",
        "status": "modified",
        "additions": 50,
        "deletions": 50,
        "changes": 100,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/modaloverlay.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/modaloverlay.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/modaloverlay.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "23e3381b3af0a1c55b4d6a1d6a12933ec445e39b",
        "filename": "src/qt/modaloverlay.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/modaloverlay.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/modaloverlay.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/modaloverlay.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "f89c0c222bc83eeee309a7f6e6aaf44bcbebe9c6",
        "filename": "src/qt/networkstyle.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 22,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/networkstyle.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/networkstyle.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/networkstyle.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "cd8e0a96a08754aa8499adb734a417d467a5f676",
        "filename": "src/qt/networkstyle.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/networkstyle.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/networkstyle.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/networkstyle.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "292b08f155181de9a75f8b7ae6d5511c8db9145a",
        "filename": "src/qt/notificator.cpp",
        "status": "modified",
        "additions": 45,
        "deletions": 45,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/notificator.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/notificator.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/notificator.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "72ca3c76b52cc0ec378fe33ad5ca431241096412",
        "filename": "src/qt/notificator.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/notificator.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/notificator.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/notificator.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "e2861dd091fec02ca1f6c344da37fd22356b40e7",
        "filename": "src/qt/openuridialog.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/openuridialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/openuridialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/openuridialog.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "d610b39febe53c654aa03e98720ccf03e63b43cd",
        "filename": "src/qt/openuridialog.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/openuridialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/openuridialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/openuridialog.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "174b795a12de3e8707973e12bafe89ff2caee29f",
        "filename": "src/qt/optionsdialog.cpp",
        "status": "modified",
        "additions": 70,
        "deletions": 70,
        "changes": 140,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/optionsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/optionsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsdialog.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "bbc8a47d18c2cd8f75c00e34cfa7c37bb543a13c",
        "filename": "src/qt/optionsdialog.h",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/optionsdialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/optionsdialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsdialog.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "b3b09355928ab073b7ae81f38f96a04f4d2ba7b8",
        "filename": "src/qt/optionsmodel.cpp",
        "status": "modified",
        "additions": 101,
        "deletions": 101,
        "changes": 202,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/optionsmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/optionsmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsmodel.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "6012129e70ed11dfd02ad1cb014f34e55f2d3d00",
        "filename": "src/qt/optionsmodel.h",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/optionsmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/optionsmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsmodel.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "6d9a52a8ab6f6a527add51e9bbd0d1f15576caf9",
        "filename": "src/qt/overviewpage.cpp",
        "status": "modified",
        "additions": 55,
        "deletions": 55,
        "changes": 110,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/overviewpage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/overviewpage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/overviewpage.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "3ecfc53372c83cd06a03c0c5a63c6747db75f035",
        "filename": "src/qt/overviewpage.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/overviewpage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/overviewpage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/overviewpage.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "ea6041b5baca8315c9a1feb4c65918ef9814299c",
        "filename": "src/qt/paymentrequestplus.cpp",
        "status": "modified",
        "additions": 60,
        "deletions": 60,
        "changes": 120,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/paymentrequestplus.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/paymentrequestplus.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentrequestplus.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "db47521423db951f180cfd864323d5ffb5ef5570",
        "filename": "src/qt/paymentrequestplus.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/paymentrequestplus.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/paymentrequestplus.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentrequestplus.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "1bfbbf9d9aa8395f2c3745812332b9f678260626",
        "filename": "src/qt/paymentserver.cpp",
        "status": "modified",
        "additions": 196,
        "deletions": 196,
        "changes": 392,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/paymentserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/paymentserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentserver.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "1532c955ea03cbd630a5fca35f38091c3e0360f8",
        "filename": "src/qt/paymentserver.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/paymentserver.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/paymentserver.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentserver.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "e1afbb9cd20853d575557b3dc069dd5439cb91a9",
        "filename": "src/qt/peertablemodel.cpp",
        "status": "modified",
        "additions": 56,
        "deletions": 56,
        "changes": 112,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/peertablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/peertablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/peertablemodel.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "eb0cad20e49bc25d41178a07eb3ed63e9dc38b30",
        "filename": "src/qt/peertablemodel.h",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/peertablemodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/peertablemodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/peertablemodel.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "48355d4c2cc6e570785b3bc3ee29be05f6430465",
        "filename": "src/qt/platformstyle.cpp",
        "status": "modified",
        "additions": 42,
        "deletions": 42,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/platformstyle.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/platformstyle.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/platformstyle.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "2fe73255d2b9c41f1a3fbf925d4a8902cb2ea614",
        "filename": "src/qt/platformstyle.h",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/platformstyle.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/platformstyle.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/platformstyle.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "b192319103ceebda16978e4e6b553247bfbf91c7",
        "filename": "src/qt/qvalidatedlineedit.cpp",
        "status": "modified",
        "additions": 38,
        "deletions": 38,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/qvalidatedlineedit.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/qvalidatedlineedit.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/qvalidatedlineedit.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "11c5aece2681291907966ebe5e942041d0e1a842",
        "filename": "src/qt/qvalidatedlineedit.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/qvalidatedlineedit.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/qvalidatedlineedit.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/qvalidatedlineedit.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "3c67183e4a4e4f0807b3c721b7cbc6ce4d0d74f9",
        "filename": "src/qt/qvaluecombobox.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/qvaluecombobox.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/qvaluecombobox.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/qvaluecombobox.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "2220ea94a14ae7d8ff3add9f67f8352510d08b3d",
        "filename": "src/qt/qvaluecombobox.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/qvaluecombobox.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/qvaluecombobox.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/qvaluecombobox.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "78ed741d1d091e14b212e75cbd0a7958dd5f27f8",
        "filename": "src/qt/receivecoinsdialog.cpp",
        "status": "modified",
        "additions": 71,
        "deletions": 71,
        "changes": 142,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/receivecoinsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/receivecoinsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/receivecoinsdialog.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "f51a605d550fe55349c9df4039f621f91c1192cb",
        "filename": "src/qt/receivecoinsdialog.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/receivecoinsdialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/receivecoinsdialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/receivecoinsdialog.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "651223c994513f9b3a889e106425a8153581773e",
        "filename": "src/qt/receiverequestdialog.cpp",
        "status": "modified",
        "additions": 44,
        "deletions": 44,
        "changes": 88,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/receiverequestdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/receiverequestdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/receiverequestdialog.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "d7f66067f4e502232bee5a5d5d3d53aeef268a2c",
        "filename": "src/qt/receiverequestdialog.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/receiverequestdialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/receiverequestdialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/receiverequestdialog.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "0ac00f9179c2f4b36b67c1f15f56943289377fbd",
        "filename": "src/qt/recentrequeststablemodel.cpp",
        "status": "modified",
        "additions": 61,
        "deletions": 61,
        "changes": 122,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/recentrequeststablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/recentrequeststablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/recentrequeststablemodel.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "b364094f45171536a323d15a42b30c4f3dcaefc6",
        "filename": "src/qt/recentrequeststablemodel.h",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/recentrequeststablemodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/recentrequeststablemodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/recentrequeststablemodel.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "3f844cffa89b7fc841b58e957144651fd95eafa3",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 282,
        "deletions": 282,
        "changes": 564,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "9b6776e74519bde2efb97158e9e56e30c97ae577",
        "filename": "src/qt/rpcconsole.h",
        "status": "modified",
        "additions": 17,
        "deletions": 17,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/rpcconsole.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/rpcconsole.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "62306f194bcf87c1bcb1aba07d033916eac934a2",
        "filename": "src/qt/sendcoinsdialog.cpp",
        "status": "modified",
        "additions": 223,
        "deletions": 223,
        "changes": 446,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/sendcoinsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/sendcoinsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "ca8ec17f37ef8c6de6398cda988a982c6cfab789",
        "filename": "src/qt/sendcoinsdialog.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/sendcoinsdialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/sendcoinsdialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "928e737be13e860c723e7f7cba5c931ab02e100d",
        "filename": "src/qt/sendcoinsentry.cpp",
        "status": "modified",
        "additions": 62,
        "deletions": 62,
        "changes": 124,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/sendcoinsentry.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/sendcoinsentry.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsentry.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "2bb633696d0c4978d0c06435cb90bc4d14ff9d2a",
        "filename": "src/qt/sendcoinsentry.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/sendcoinsentry.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/sendcoinsentry.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsentry.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "7c65dd6fb095687e699861c8d11f4c65c6ffb714",
        "filename": "src/qt/signverifymessagedialog.cpp",
        "status": "modified",
        "additions": 68,
        "deletions": 68,
        "changes": 136,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/signverifymessagedialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/signverifymessagedialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/signverifymessagedialog.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "3c6cea2ae72b6f9ac8ca2bc6eb0dad22504a843d",
        "filename": "src/qt/signverifymessagedialog.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/signverifymessagedialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/signverifymessagedialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/signverifymessagedialog.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "7df764c06197b158bbc53218cc066f017653df96",
        "filename": "src/qt/splashscreen.cpp",
        "status": "modified",
        "additions": 39,
        "deletions": 39,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/splashscreen.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/splashscreen.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/splashscreen.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "4a61818e7a3b39a626fa7f62682346f04b325463",
        "filename": "src/qt/splashscreen.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/splashscreen.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/splashscreen.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/splashscreen.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "c44422ec73e1b77956cd01a1f942866114adf0e7",
        "filename": "src/qt/test/addressbooktests.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/addressbooktests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/addressbooktests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/addressbooktests.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "88f632db08662d546f7a95f17cdd78d20d9784e2",
        "filename": "src/qt/test/addressbooktests.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/addressbooktests.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/addressbooktests.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/addressbooktests.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "3d51c4651ccaacfe6624f12d7718c3f0c69e41e0",
        "filename": "src/qt/test/apptests.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 18,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/apptests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/apptests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/apptests.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "7d47556c629193b005b78845e33af80d38fb085a",
        "filename": "src/qt/test/apptests.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/apptests.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/apptests.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/apptests.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "7da1faa9bfbdce3a0dc4abbf3ac43ac215bdc8cd",
        "filename": "src/qt/test/compattests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/compattests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/compattests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/compattests.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "bea54cb2dc16f0767f32c7517e35bea306a7e82d",
        "filename": "src/qt/test/compattests.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/compattests.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/compattests.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/compattests.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "17f2388040318c164a8025cc929508e540753196",
        "filename": "src/qt/test/paymentservertests.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/paymentservertests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/paymentservertests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/paymentservertests.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "e34c045a6c7703d229c954d7a4ffa5a5a75327e3",
        "filename": "src/qt/test/paymentservertests.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/paymentservertests.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/paymentservertests.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/paymentservertests.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "ba1987e56ed5bc21e9fe54707e7dec81d9a09f99",
        "filename": "src/qt/test/rpcnestedtests.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/rpcnestedtests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/rpcnestedtests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/rpcnestedtests.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "ce2ea1e723c80e1e4a8b1f9b42a3ec0119a48839",
        "filename": "src/qt/test/rpcnestedtests.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/rpcnestedtests.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/rpcnestedtests.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/rpcnestedtests.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "bd80f1f18f518a594022316fdd0f32e2c6f7dbd4",
        "filename": "src/qt/test/test_main.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/test_main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/test_main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/test_main.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "f07fa764e2854c27e7663a5996c3480e807332bf",
        "filename": "src/qt/test/uritests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/uritests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/uritests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/uritests.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "67427805ebc68d115222b3df5ada3d2ac1f6ef0c",
        "filename": "src/qt/test/uritests.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/uritests.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/uritests.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/uritests.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "beadeac112a51b832ded2adfdbc845d35dd72df3",
        "filename": "src/qt/test/util.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/util.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "0d299e669dc71d86e0dcacd6b84c33c1a2e416cf",
        "filename": "src/qt/test/wallettests.cpp",
        "status": "modified",
        "additions": 54,
        "deletions": 54,
        "changes": 108,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/wallettests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/wallettests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/wallettests.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "e92d03143b0d337ddeb9a4e92d0f8664e3fa2db4",
        "filename": "src/qt/test/wallettests.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/wallettests.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/test/wallettests.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/wallettests.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "d855b5e4308f9b1ace57e8cfcac3570715a2dabc",
        "filename": "src/qt/trafficgraphwidget.cpp",
        "status": "modified",
        "additions": 42,
        "deletions": 42,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/trafficgraphwidget.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/trafficgraphwidget.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/trafficgraphwidget.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "fdd0d03d69af09ad6a05eded8789ddcdf3511a22",
        "filename": "src/qt/trafficgraphwidget.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/trafficgraphwidget.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/trafficgraphwidget.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/trafficgraphwidget.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "abb3c6629e87f218cd5c4695d7ccb9250087b396",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 68,
        "deletions": 68,
        "changes": 136,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "9654e18b7b17fcaaf5a56cd72b0e0d7c7713f16b",
        "filename": "src/qt/transactiondesc.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/transactiondesc.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/transactiondesc.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "f2308635a0323d7fb43390b417b8ee340fb9de34",
        "filename": "src/qt/transactiondescdialog.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/transactiondescdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/transactiondescdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondescdialog.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "b0abb3fee240bd74b45e3836c2d0c18c617aeead",
        "filename": "src/qt/transactiondescdialog.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/transactiondescdialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/transactiondescdialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondescdialog.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "12d3b36786c413667c46864d0d310b29a17f4cfa",
        "filename": "src/qt/transactionfilterproxy.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 26,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/transactionfilterproxy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/transactionfilterproxy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionfilterproxy.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "378625d16cecf0da45c42351a7145e2be189c30e",
        "filename": "src/qt/transactionfilterproxy.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/transactionfilterproxy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/transactionfilterproxy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionfilterproxy.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "5c6f7d996d35efbd0859fb940f2aa39b28919bab",
        "filename": "src/qt/transactionrecord.cpp",
        "status": "modified",
        "additions": 72,
        "deletions": 72,
        "changes": 144,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/transactionrecord.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/transactionrecord.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "b9c5ef6cec4beecba1ab35a2b249100700c8fd32",
        "filename": "src/qt/transactionrecord.h",
        "status": "modified",
        "additions": 17,
        "deletions": 17,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/transactionrecord.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/transactionrecord.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "3e8375be68cd47aa7cdd1ec852c03abe00d53090",
        "filename": "src/qt/transactiontablemodel.cpp",
        "status": "modified",
        "additions": 190,
        "deletions": 190,
        "changes": 380,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/transactiontablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/transactiontablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiontablemodel.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "127ba0d744da8e6dc3e886a3b3031342af8655a7",
        "filename": "src/qt/transactiontablemodel.h",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/transactiontablemodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/transactiontablemodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiontablemodel.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "5847eb812085594eb8ae327678f596fbf028a103",
        "filename": "src/qt/transactionview.cpp",
        "status": "modified",
        "additions": 113,
        "deletions": 113,
        "changes": 226,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/transactionview.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/transactionview.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionview.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "904787c58d4ead346d027da1478a1241afdf9e96",
        "filename": "src/qt/transactionview.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/transactionview.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/transactionview.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionview.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "e95c023701dd6a744b2138f261ea7383b3e9b549",
        "filename": "src/qt/utilitydialog.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 25,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/utilitydialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/utilitydialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/utilitydialog.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "a088edd232bc1800ca58e0f8144091b3005e32a8",
        "filename": "src/qt/utilitydialog.h",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/utilitydialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/utilitydialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/utilitydialog.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "ccd4a2254b27c43758d536c84a6c4742eacf2bf5",
        "filename": "src/qt/walletcontroller.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 52,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/walletcontroller.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/walletcontroller.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletcontroller.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "d6bcc89177f734637f42b69d9d716839203be3a4",
        "filename": "src/qt/walletcontroller.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/walletcontroller.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/walletcontroller.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletcontroller.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "0e264b0aecd3f80d4982499e7305d517da035003",
        "filename": "src/qt/walletframe.cpp",
        "status": "modified",
        "additions": 53,
        "deletions": 53,
        "changes": 106,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/walletframe.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/walletframe.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletframe.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "75435447238cec7bc5b7f1345d6ed132bea64770",
        "filename": "src/qt/walletframe.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/walletframe.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/walletframe.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletframe.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "ce38b651e243a3c726ed1612e6ba4cd2383f34b3",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 165,
        "deletions": 165,
        "changes": 330,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "668476c36f818985d50ac78119f45a95bdc4244a",
        "filename": "src/qt/walletmodel.h",
        "status": "modified",
        "additions": 29,
        "deletions": 29,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/walletmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/walletmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "65e29cc7fc08e1f506c9b6cf65cc9c44d58d1ac8",
        "filename": "src/qt/walletmodeltransaction.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 26,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/walletmodeltransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/walletmodeltransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodeltransaction.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "d578989002560a53bbb414429ab325ffbf8bbc3d",
        "filename": "src/qt/walletmodeltransaction.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/walletmodeltransaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/walletmodeltransaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodeltransaction.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "6159897d30b7daffd192291bf991ee7776fccc08",
        "filename": "src/qt/walletview.cpp",
        "status": "modified",
        "additions": 69,
        "deletions": 69,
        "changes": 138,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/walletview.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/walletview.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletview.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "ca89cc748c994338f124e4d6e41cf24ba88e2e3a",
        "filename": "src/qt/walletview.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/walletview.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/walletview.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletview.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "3392bdc788a745fbc4d3d400ff945bce38fab0b2",
        "filename": "src/qt/winshutdownmonitor.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/winshutdownmonitor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/winshutdownmonitor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/winshutdownmonitor.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "5d5f6d98882580f84f1c22c5ae115f3ef944ee49",
        "filename": "src/qt/winshutdownmonitor.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/winshutdownmonitor.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/qt/winshutdownmonitor.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/winshutdownmonitor.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "6ce6467025b5623a613394be04ecdab807d3db75",
        "filename": "src/random.cpp",
        "status": "modified",
        "additions": 172,
        "deletions": 172,
        "changes": 344,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/random.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/random.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/random.cpp?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      },
      {
        "sha": "5fc051fe61f30f900a30adacbf63b96ec314a248",
        "filename": "src/random.h",
        "status": "modified",
        "additions": 31,
        "deletions": 31,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/random.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d/src/random.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/random.h?ref=621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      }
    ]
  },
  {
    "sha": "32c0ea4363706f703754bba1dd3e44d844d7968c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozMmMwZWE0MzYzNzA2ZjcwMzc1NGJiYTFkZDNlNDRkODQ0ZDc5Njhj",
    "commit": {
      "author": {
        "name": "Julian Fleischer",
        "email": "julian@thirdhash.com",
        "date": "2019-04-01T12:56:59Z"
      },
      "committer": {
        "name": "Julian Fleischer",
        "email": "julian@thirdhash.com",
        "date": "2019-04-01T13:03:35Z"
      },
      "message": "Fix check-rpc-mappings.py",
      "tree": {
        "sha": "405e47bb2d2396a3a2bffc79eba2ee8de1336766",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/405e47bb2d2396a3a2bffc79eba2ee8de1336766"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/32c0ea4363706f703754bba1dd3e44d844d7968c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/32c0ea4363706f703754bba1dd3e44d844d7968c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/32c0ea4363706f703754bba1dd3e44d844d7968c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/32c0ea4363706f703754bba1dd3e44d844d7968c/comments",
    "author": {
      "login": "scravy",
      "id": 295504,
      "node_id": "MDQ6VXNlcjI5NTUwNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/295504?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/scravy",
      "html_url": "https://github.com/scravy",
      "followers_url": "https://api.github.com/users/scravy/followers",
      "following_url": "https://api.github.com/users/scravy/following{/other_user}",
      "gists_url": "https://api.github.com/users/scravy/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/scravy/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/scravy/subscriptions",
      "organizations_url": "https://api.github.com/users/scravy/orgs",
      "repos_url": "https://api.github.com/users/scravy/repos",
      "events_url": "https://api.github.com/users/scravy/events{/privacy}",
      "received_events_url": "https://api.github.com/users/scravy/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "scravy",
      "id": 295504,
      "node_id": "MDQ6VXNlcjI5NTUwNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/295504?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/scravy",
      "html_url": "https://github.com/scravy",
      "followers_url": "https://api.github.com/users/scravy/followers",
      "following_url": "https://api.github.com/users/scravy/following{/other_user}",
      "gists_url": "https://api.github.com/users/scravy/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/scravy/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/scravy/subscriptions",
      "organizations_url": "https://api.github.com/users/scravy/orgs",
      "repos_url": "https://api.github.com/users/scravy/repos",
      "events_url": "https://api.github.com/users/scravy/events{/privacy}",
      "received_events_url": "https://api.github.com/users/scravy/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/621ea2f27c44c9903ea21d6c442d2f7bbdcaa45d"
      }
    ],
    "stats": {
      "total": 22,
      "additions": 11,
      "deletions": 11
    },
    "files": [
      {
        "sha": "ff5fd75e157d113f411efd8a14988e291b389a64",
        "filename": "test/lint/check-rpc-mappings.py",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32c0ea4363706f703754bba1dd3e44d844d7968c/test/lint/check-rpc-mappings.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32c0ea4363706f703754bba1dd3e44d844d7968c/test/lint/check-rpc-mappings.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/check-rpc-mappings.py?ref=32c0ea4363706f703754bba1dd3e44d844d7968c",
        "patch": "@@ -51,13 +51,13 @@ def process_commands(fname):\n                 if re.match(\"static const CRPCCommand .*\\[\\] =\", line):\n                     in_rpcs = True\n             else:\n-                if line.startswith('};'):\n+                if line.startswith('};') or line.startswith('%>;'):\n                     in_rpcs = False\n-                elif '{' in line and '\"' in line:\n-                    m = re.search('{ *(\"[^\"]*\"), *(\"[^\"]*\"), *&([^,]*), *{([^}]*)} *},', line)\n+                elif ('{' in line or '<%' in line) and '\"' in line:\n+                    m = re.search('(<%|{) *(\"[^\"]*\"), *(\"[^\"]*\"), *&([^,]*), *(<%|{)([^}>]*)(%>|}) *(%>|}),', line)\n                     assert m, 'No match to table expression: %s' % line\n-                    name = parse_string(m.group(2))\n-                    args_str = m.group(4).strip()\n+                    name = parse_string(m.group(3))\n+                    args_str = m.group(6).strip()\n                     if args_str:\n                         args = [RPCArgument(parse_string(x.strip()).split('|'), idx) for idx, x in enumerate(args_str.split(','))]\n                     else:\n@@ -77,14 +77,14 @@ def process_mapping(fname):\n                 if line == 'static const CRPCConvertParam vRPCConvertParams[] =':\n                     in_rpcs = True\n             else:\n-                if line.startswith('};'):\n+                if line.startswith('};') or line.startswith('%>;'):\n                     in_rpcs = False\n-                elif '{' in line and '\"' in line:\n-                    m = re.search('{ *(\"[^\"]*\"), *([0-9]+) *, *(\"[^\"]*\") *},', line)\n+                elif ('{' in line or '<%' in line) and '\"' in line:\n+                    m = re.search('(<%|{) *(\"[^\"]*\"), *([0-9]+) *, *(\"[^\"]*\") *(%>|}),', line)\n                     assert m, 'No match to table expression: %s' % line\n-                    name = parse_string(m.group(1))\n-                    idx = int(m.group(2))\n-                    argname = parse_string(m.group(3))\n+                    name = parse_string(m.group(2))\n+                    idx = int(m.group(3))\n+                    argname = parse_string(m.group(4))\n                     cmds.append((name, idx, argname))\n     assert not in_rpcs and cmds\n     return cmds"
      }
    ]
  },
  {
    "sha": "33a95273fa71356846290e0ea315801c2e714fba",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozM2E5NTI3M2ZhNzEzNTY4NDYyOTBlMGVhMzE1ODAxYzJlNzE0ZmJh",
    "commit": {
      "author": {
        "name": "Julian Fleischer",
        "email": "julian@thirdhash.com",
        "date": "2019-04-01T13:22:38Z"
      },
      "committer": {
        "name": "Julian Fleischer",
        "email": "julian@thirdhash.com",
        "date": "2019-04-01T13:22:38Z"
      },
      "message": "Satisfy white-space linter",
      "tree": {
        "sha": "2e70bf54eed5e26aef488dcb5f5ea06f08e2c44c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2e70bf54eed5e26aef488dcb5f5ea06f08e2c44c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/33a95273fa71356846290e0ea315801c2e714fba",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/33a95273fa71356846290e0ea315801c2e714fba",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/33a95273fa71356846290e0ea315801c2e714fba",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/33a95273fa71356846290e0ea315801c2e714fba/comments",
    "author": {
      "login": "scravy",
      "id": 295504,
      "node_id": "MDQ6VXNlcjI5NTUwNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/295504?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/scravy",
      "html_url": "https://github.com/scravy",
      "followers_url": "https://api.github.com/users/scravy/followers",
      "following_url": "https://api.github.com/users/scravy/following{/other_user}",
      "gists_url": "https://api.github.com/users/scravy/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/scravy/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/scravy/subscriptions",
      "organizations_url": "https://api.github.com/users/scravy/orgs",
      "repos_url": "https://api.github.com/users/scravy/repos",
      "events_url": "https://api.github.com/users/scravy/events{/privacy}",
      "received_events_url": "https://api.github.com/users/scravy/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "scravy",
      "id": 295504,
      "node_id": "MDQ6VXNlcjI5NTUwNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/295504?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/scravy",
      "html_url": "https://github.com/scravy",
      "followers_url": "https://api.github.com/users/scravy/followers",
      "following_url": "https://api.github.com/users/scravy/following{/other_user}",
      "gists_url": "https://api.github.com/users/scravy/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/scravy/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/scravy/subscriptions",
      "organizations_url": "https://api.github.com/users/scravy/orgs",
      "repos_url": "https://api.github.com/users/scravy/repos",
      "events_url": "https://api.github.com/users/scravy/events{/privacy}",
      "received_events_url": "https://api.github.com/users/scravy/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "32c0ea4363706f703754bba1dd3e44d844d7968c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/32c0ea4363706f703754bba1dd3e44d844d7968c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/32c0ea4363706f703754bba1dd3e44d844d7968c"
      }
    ],
    "stats": {
      "total": 8,
      "additions": 4,
      "deletions": 4
    },
    "files": [
      {
        "sha": "3dc3cbd41732b0a7bd63d60061a78a9e03ac8812",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/33a95273fa71356846290e0ea315801c2e714fba/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/33a95273fa71356846290e0ea315801c2e714fba/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=33a95273fa71356846290e0ea315801c2e714fba",
        "patch": "@@ -120,8 +120,8 @@ BOOST_AUTO_TEST_CASE(tx_valid)\n             std::map<COutPoint, int64_t> mapprevOutValues;\n             UniValue inputs = test[0].get_array();\n             bool fValid = true;\n-\t    for (unsigned int inpIdx = 0; inpIdx < inputs.size(); inpIdx++) <%\n-\t        const UniValue& input = inputs[inpIdx];\n+            for (unsigned int inpIdx = 0; inpIdx < inputs.size(); inpIdx++) <%\n+            const UniValue& input = inputs[inpIdx];\n                 if (!input.isArray())\n                 <%\n                     fValid = false;\n@@ -207,8 +207,8 @@ BOOST_AUTO_TEST_CASE(tx_invalid)\n             std::map<COutPoint, int64_t> mapprevOutValues;\n             UniValue inputs = test[0].get_array();\n             bool fValid = true;\n-\t    for (unsigned int inpIdx = 0; inpIdx < inputs.size(); inpIdx++) <%\n-\t        const UniValue& input = inputs[inpIdx];\n+            for (unsigned int inpIdx = 0; inpIdx < inputs.size(); inpIdx++) <%\n+            const UniValue& input = inputs[inpIdx];\n                 if (!input.isArray())\n                 <%\n                     fValid = false;"
      }
    ]
  }
]