[
  {
    "sha": "f8c099e2207c90d758e7a659d6a55fa7ccb7ceaa",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmOGMwOTllMjIwN2M5MGQ3NThlN2E2NTlkNmE1NWZhN2NjYjdjZWFh",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-09-14T16:51:36Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-06T21:51:30Z"
      },
      "message": "--- [TAPROOT] Refactors ---",
      "tree": {
        "sha": "3745f51247328903f435584f9b731ffbdce9df47",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3745f51247328903f435584f9b731ffbdce9df47"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f8c099e2207c90d758e7a659d6a55fa7ccb7ceaa",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f8c099e2207c90d758e7a659d6a55fa7ccb7ceaa",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f8c099e2207c90d758e7a659d6a55fa7ccb7ceaa",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f8c099e2207c90d758e7a659d6a55fa7ccb7ceaa/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "60ec57b3d73e5cef71ebf3c4cdf54a4474bf492b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/60ec57b3d73e5cef71ebf3c4cdf54a4474bf492b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/60ec57b3d73e5cef71ebf3c4cdf54a4474bf492b"
      }
    ],
    "stats": {
      "total": 0,
      "additions": 0,
      "deletions": 0
    },
    "files": []
  },
  {
    "sha": "107b57df9fa8b2d625d2b342dc77722282a6ae4c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMDdiNTdkZjlmYThiMmQ2MjVkMmIzNDJkYzc3NzIyMjgyYTZhZTRj",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-09-11T21:33:23Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-06T21:51:30Z"
      },
      "message": "scripted-diff: put ECDSA in name of signature functions\n\nIn preparation for adding Schnorr versions of `CheckSig`, `VerifySignature`, and\n`ComputeEntry`, give them an ECDSA specific name.\n\n-BEGIN VERIFY SCRIPT-\nsed -i 's/CheckSig(/CheckECDSASignature(/g' $(git grep -l CheckSig ./src)\nsed -i 's/VerifySignature(/VerifyECDSASignature(/g' $(git grep -l VerifySignature ./src)\nsed -i 's/ComputeEntry(/ComputeEntryECDSA(/g' $(git grep -l ComputeEntry ./src)\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "5b8a87a0ca24bdfdfde27a5836d45c9e6e7838b9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5b8a87a0ca24bdfdfde27a5836d45c9e6e7838b9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/107b57df9fa8b2d625d2b342dc77722282a6ae4c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/107b57df9fa8b2d625d2b342dc77722282a6ae4c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/107b57df9fa8b2d625d2b342dc77722282a6ae4c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/107b57df9fa8b2d625d2b342dc77722282a6ae4c/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f8c099e2207c90d758e7a659d6a55fa7ccb7ceaa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f8c099e2207c90d758e7a659d6a55fa7ccb7ceaa",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f8c099e2207c90d758e7a659d6a55fa7ccb7ceaa"
      }
    ],
    "stats": {
      "total": 40,
      "additions": 20,
      "deletions": 20
    },
    "files": [
      {
        "sha": "cd1049f66fcd6398b1401e949d1a8311b9eac30f",
        "filename": "src/pubkey.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/107b57df9fa8b2d625d2b342dc77722282a6ae4c/src/pubkey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/107b57df9fa8b2d625d2b342dc77722282a6ae4c/src/pubkey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.h?ref=107b57df9fa8b2d625d2b342dc77722282a6ae4c",
        "patch": "@@ -169,7 +169,7 @@ class CPubKey\n     /*\n      * Check syntactic correctness.\n      *\n-     * Note that this is consensus critical as CheckSig() calls it!\n+     * Note that this is consensus critical as CheckECDSASignature() calls it!\n      */\n     bool IsValid() const\n     {"
      },
      {
        "sha": "aabb3192a9be6f9e636e1ffc7bb3c01f57c225ef",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/107b57df9fa8b2d625d2b342dc77722282a6ae4c/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/107b57df9fa8b2d625d2b342dc77722282a6ae4c/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=107b57df9fa8b2d625d2b342dc77722282a6ae4c",
        "patch": "@@ -363,7 +363,7 @@ static bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScrip\n         //serror is set\n         return false;\n     }\n-    fSuccess = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);\n+    fSuccess = checker.CheckECDSASignature(vchSig, vchPubKey, scriptCode, sigversion);\n \n     if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) && vchSig.size())\n         return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);\n@@ -1089,7 +1089,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                         }\n \n                         // Check signature\n-                        bool fOk = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);\n+                        bool fOk = checker.CheckECDSASignature(vchSig, vchPubKey, scriptCode, sigversion);\n \n                         if (fOk) {\n                             isig++;\n@@ -1389,13 +1389,13 @@ uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn\n }\n \n template <class T>\n-bool GenericTransactionSignatureChecker<T>::VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& pubkey, const uint256& sighash) const\n+bool GenericTransactionSignatureChecker<T>::VerifyECDSASignature(const std::vector<unsigned char>& vchSig, const CPubKey& pubkey, const uint256& sighash) const\n {\n     return pubkey.Verify(sighash, vchSig);\n }\n \n template <class T>\n-bool GenericTransactionSignatureChecker<T>::CheckSig(const std::vector<unsigned char>& vchSigIn, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n+bool GenericTransactionSignatureChecker<T>::CheckECDSASignature(const std::vector<unsigned char>& vchSigIn, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n {\n     CPubKey pubkey(vchPubKey);\n     if (!pubkey.IsValid())\n@@ -1410,7 +1410,7 @@ bool GenericTransactionSignatureChecker<T>::CheckSig(const std::vector<unsigned\n \n     uint256 sighash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion, this->txdata);\n \n-    if (!VerifySignature(vchSig, pubkey, sighash))\n+    if (!VerifyECDSASignature(vchSig, pubkey, sighash))\n         return false;\n \n     return true;"
      },
      {
        "sha": "0ff4c4bc9561ff722204cc1c1c4c50d35355c1da",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/107b57df9fa8b2d625d2b342dc77722282a6ae4c/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/107b57df9fa8b2d625d2b342dc77722282a6ae4c/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=107b57df9fa8b2d625d2b342dc77722282a6ae4c",
        "patch": "@@ -148,7 +148,7 @@ uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn\n class BaseSignatureChecker\n {\n public:\n-    virtual bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n+    virtual bool CheckECDSASignature(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n     {\n         return false;\n     }\n@@ -176,12 +176,12 @@ class GenericTransactionSignatureChecker : public BaseSignatureChecker\n     const PrecomputedTransactionData* txdata;\n \n protected:\n-    virtual bool VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash) const;\n+    virtual bool VerifyECDSASignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash) const;\n \n public:\n     GenericTransactionSignatureChecker(const T* txToIn, unsigned int nInIn, const CAmount& amountIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(nullptr) {}\n     GenericTransactionSignatureChecker(const T* txToIn, unsigned int nInIn, const CAmount& amountIn, const PrecomputedTransactionData& txdataIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(&txdataIn) {}\n-    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override;\n+    bool CheckECDSASignature(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override;\n     bool CheckLockTime(const CScriptNum& nLockTime) const override;\n     bool CheckSequence(const CScriptNum& nSequence) const override;\n };"
      },
      {
        "sha": "b9ba006e47354e59f46351586dc797dad41c0fe9",
        "filename": "src/script/sigcache.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/107b57df9fa8b2d625d2b342dc77722282a6ae4c/src/script/sigcache.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/107b57df9fa8b2d625d2b342dc77722282a6ae4c/src/script/sigcache.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sigcache.cpp?ref=107b57df9fa8b2d625d2b342dc77722282a6ae4c",
        "patch": "@@ -40,7 +40,7 @@ class CSignatureCache\n     }\n \n     void\n-    ComputeEntry(uint256& entry, const uint256 &hash, const std::vector<unsigned char>& vchSig, const CPubKey& pubkey)\n+    ComputeEntryECDSA(uint256& entry, const uint256 &hash, const std::vector<unsigned char>& vchSig, const CPubKey& pubkey)\n     {\n         CSHA256 hasher = m_salted_hasher;\n         hasher.Write(hash.begin(), 32).Write(&pubkey[0], pubkey.size()).Write(&vchSig[0], vchSig.size()).Finalize(entry.begin());\n@@ -85,13 +85,13 @@ void InitSignatureCache()\n             (nElems*sizeof(uint256)) >>20, (nMaxCacheSize*2)>>20, nElems);\n }\n \n-bool CachingTransactionSignatureChecker::VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& pubkey, const uint256& sighash) const\n+bool CachingTransactionSignatureChecker::VerifyECDSASignature(const std::vector<unsigned char>& vchSig, const CPubKey& pubkey, const uint256& sighash) const\n {\n     uint256 entry;\n-    signatureCache.ComputeEntry(entry, sighash, vchSig, pubkey);\n+    signatureCache.ComputeEntryECDSA(entry, sighash, vchSig, pubkey);\n     if (signatureCache.Get(entry, !store))\n         return true;\n-    if (!TransactionSignatureChecker::VerifySignature(vchSig, pubkey, sighash))\n+    if (!TransactionSignatureChecker::VerifyECDSASignature(vchSig, pubkey, sighash))\n         return false;\n     if (store)\n         signatureCache.Set(entry);"
      },
      {
        "sha": "49c6b192e998f24879caaf31b7280614453a520d",
        "filename": "src/script/sigcache.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/107b57df9fa8b2d625d2b342dc77722282a6ae4c/src/script/sigcache.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/107b57df9fa8b2d625d2b342dc77722282a6ae4c/src/script/sigcache.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sigcache.h?ref=107b57df9fa8b2d625d2b342dc77722282a6ae4c",
        "patch": "@@ -48,7 +48,7 @@ class CachingTransactionSignatureChecker : public TransactionSignatureChecker\n public:\n     CachingTransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, bool storeIn, PrecomputedTransactionData& txdataIn) : TransactionSignatureChecker(txToIn, nInIn, amountIn, txdataIn), store(storeIn) {}\n \n-    bool VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash) const override;\n+    bool VerifyECDSASignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash) const override;\n };\n \n void InitSignatureCache();"
      },
      {
        "sha": "ace798eec1a942ccb5514c393bdde601b12a024b",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/107b57df9fa8b2d625d2b342dc77722282a6ae4c/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/107b57df9fa8b2d625d2b342dc77722282a6ae4c/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=107b57df9fa8b2d625d2b342dc77722282a6ae4c",
        "patch": "@@ -260,9 +260,9 @@ class SignatureExtractorChecker final : public BaseSignatureChecker\n \n public:\n     SignatureExtractorChecker(SignatureData& sigdata, BaseSignatureChecker& checker) : sigdata(sigdata), checker(checker) {}\n-    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override\n+    bool CheckECDSASignature(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override\n     {\n-        if (checker.CheckSig(scriptSig, vchPubKey, scriptCode, sigversion)) {\n+        if (checker.CheckECDSASignature(scriptSig, vchPubKey, scriptCode, sigversion)) {\n             CPubKey pubkey(vchPubKey);\n             sigdata.signatures.emplace(pubkey.GetID(), SigPair(pubkey, scriptSig));\n             return true;\n@@ -339,7 +339,7 @@ SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nI\n             for (unsigned int i = last_success_key; i < num_pubkeys; ++i) {\n                 const valtype& pubkey = solutions[i+1];\n                 // We either have a signature for this pubkey, or we have found a signature and it is valid\n-                if (data.signatures.count(CPubKey(pubkey).GetID()) || extractor_checker.CheckSig(sig, pubkey, next_script, sigversion)) {\n+                if (data.signatures.count(CPubKey(pubkey).GetID()) || extractor_checker.CheckECDSASignature(sig, pubkey, next_script, sigversion)) {\n                     last_success_key = i + 1;\n                     break;\n                 }\n@@ -400,7 +400,7 @@ class DummySignatureChecker final : public BaseSignatureChecker\n {\n public:\n     DummySignatureChecker() {}\n-    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override { return true; }\n+    bool CheckECDSASignature(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override { return true; }\n };\n const DummySignatureChecker DUMMY_CHECKER;\n "
      },
      {
        "sha": "0de1617d57fefafb23cea1fadd701e56e7e58965",
        "filename": "src/test/fuzz/script_sigcache.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/107b57df9fa8b2d625d2b342dc77722282a6ae4c/src/test/fuzz/script_sigcache.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/107b57df9fa8b2d625d2b342dc77722282a6ae4c/src/test/fuzz/script_sigcache.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/script_sigcache.cpp?ref=107b57df9fa8b2d625d2b342dc77722282a6ae4c",
        "patch": "@@ -39,7 +39,7 @@ void test_one_input(const std::vector<uint8_t>& buffer)\n     if (pub_key) {\n         const std::vector<uint8_t> random_bytes = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n         if (!random_bytes.empty()) {\n-            (void)caching_transaction_signature_checker.VerifySignature(random_bytes, *pub_key, ConsumeUInt256(fuzzed_data_provider));\n+            (void)caching_transaction_signature_checker.VerifyECDSASignature(random_bytes, *pub_key, ConsumeUInt256(fuzzed_data_provider));\n         }\n     }\n }"
      },
      {
        "sha": "fb5447609580b50a7d4b6dff2d15c79a854092a4",
        "filename": "src/test/fuzz/signature_checker.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/107b57df9fa8b2d625d2b342dc77722282a6ae4c/src/test/fuzz/signature_checker.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/107b57df9fa8b2d625d2b342dc77722282a6ae4c/src/test/fuzz/signature_checker.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/signature_checker.cpp?ref=107b57df9fa8b2d625d2b342dc77722282a6ae4c",
        "patch": "@@ -28,7 +28,7 @@ class FuzzedSignatureChecker : public BaseSignatureChecker\n     {\n     }\n \n-    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override\n+    bool CheckECDSASignature(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override\n     {\n         return m_fuzzed_data_provider.ConsumeBool();\n     }"
      }
    ]
  },
  {
    "sha": "8bd2b4e78452ff69c08c37acf164a6b80e503f13",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YmQyYjRlNzg0NTJmZjY5YzA4YzM3YWNmMTY0YTZiODBlNTAzZjEz",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-09-11T21:33:37Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-06T21:51:30Z"
      },
      "message": "refactor: rename scriptPubKey in VerifyWitnessProgram to exec_script\n\nThe old name is confusing, as it doesn't store a scriptPubKey, but the\nactually executed script.",
      "tree": {
        "sha": "211a4589ace23bc86b0dd5111f9ebf5877af821a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/211a4589ace23bc86b0dd5111f9ebf5877af821a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8bd2b4e78452ff69c08c37acf164a6b80e503f13",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8bd2b4e78452ff69c08c37acf164a6b80e503f13",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8bd2b4e78452ff69c08c37acf164a6b80e503f13",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8bd2b4e78452ff69c08c37acf164a6b80e503f13/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "107b57df9fa8b2d625d2b342dc77722282a6ae4c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/107b57df9fa8b2d625d2b342dc77722282a6ae4c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/107b57df9fa8b2d625d2b342dc77722282a6ae4c"
      }
    ],
    "stats": {
      "total": 16,
      "additions": 8,
      "deletions": 8
    },
    "files": [
      {
        "sha": "2fa7e5e1abf9dff7d0d7723a40ef3637d8d9cb23",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8bd2b4e78452ff69c08c37acf164a6b80e503f13/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8bd2b4e78452ff69c08c37acf164a6b80e503f13/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=8bd2b4e78452ff69c08c37acf164a6b80e503f13",
        "patch": "@@ -1524,7 +1524,7 @@ static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CS\n \n static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n {\n-    CScript scriptPubKey;\n+    CScript exec_script; //!< Actually executed script (last stack item in P2WSH; implied P2PKH script in P2WPKH)\n     Span<const valtype> stack{witness.stack};\n \n     if (witversion == 0) {\n@@ -1534,20 +1534,20 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n             }\n             const valtype& script_bytes = SpanPopBack(stack);\n-            scriptPubKey = CScript(script_bytes.begin(), script_bytes.end());\n-            uint256 hashScriptPubKey;\n-            CSHA256().Write(&scriptPubKey[0], scriptPubKey.size()).Finalize(hashScriptPubKey.begin());\n-            if (memcmp(hashScriptPubKey.begin(), program.data(), 32)) {\n+            exec_script = CScript(script_bytes.begin(), script_bytes.end());\n+            uint256 hash_exec_script;\n+            CSHA256().Write(&exec_script[0], exec_script.size()).Finalize(hash_exec_script.begin());\n+            if (memcmp(hash_exec_script.begin(), program.data(), 32)) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n             }\n-            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, serror);\n+            return ExecuteWitnessScript(stack, exec_script, flags, SigVersion::WITNESS_V0, checker, serror);\n         } else if (program.size() == WITNESS_V0_KEYHASH_SIZE) {\n             // Special case for pay-to-pubkeyhash; signature + pubkey in witness\n             if (stack.size() != 2) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH); // 2 items in witness\n             }\n-            scriptPubKey << OP_DUP << OP_HASH160 << program << OP_EQUALVERIFY << OP_CHECKSIG;\n-            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, serror);\n+            exec_script << OP_DUP << OP_HASH160 << program << OP_EQUALVERIFY << OP_CHECKSIG;\n+            return ExecuteWitnessScript(stack, exec_script, flags, SigVersion::WITNESS_V0, checker, serror);\n         } else {\n             return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);\n         }"
      }
    ]
  },
  {
    "sha": "5d62e3a68b6ea9bb03556ee1fbf5678f20be01a2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ZDYyZTNhNjhiNmVhOWJiMDM1NTZlZTFmYmY1Njc4ZjIwYmUwMWEy",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-09-11T21:33:00Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-12T09:06:32Z"
      },
      "message": "refactor: keep spent outputs in PrecomputedTransactionData\n\nA BIP-341 signature message may commit to the scriptPubKeys and amounts\nof all spent outputs (including other ones than the input being signed\nfor spends), so keep them available to signature hashing code.",
      "tree": {
        "sha": "de9e5600c4d2a5718861b4331df2344fd8c47838",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/de9e5600c4d2a5718861b4331df2344fd8c47838"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5d62e3a68b6ea9bb03556ee1fbf5678f20be01a2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5d62e3a68b6ea9bb03556ee1fbf5678f20be01a2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5d62e3a68b6ea9bb03556ee1fbf5678f20be01a2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5d62e3a68b6ea9bb03556ee1fbf5678f20be01a2/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8bd2b4e78452ff69c08c37acf164a6b80e503f13",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8bd2b4e78452ff69c08c37acf164a6b80e503f13",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8bd2b4e78452ff69c08c37acf164a6b80e503f13"
      }
    ],
    "stats": {
      "total": 33,
      "additions": 22,
      "deletions": 11
    },
    "files": [
      {
        "sha": "c322ecb1a099bfa00ef8896d9958007eb28a7810",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d62e3a68b6ea9bb03556ee1fbf5678f20be01a2/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d62e3a68b6ea9bb03556ee1fbf5678f20be01a2/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=5d62e3a68b6ea9bb03556ee1fbf5678f20be01a2",
        "patch": "@@ -1294,10 +1294,12 @@ uint256 GetOutputsSHA256(const T& txTo)\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut>&& spent_outputs)\n {\n     assert(!m_ready);\n \n+    m_spent_outputs = std::move(spent_outputs);\n+\n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n         hashPrevouts = SHA256Uint256(GetPrevoutsSHA256(txTo));\n@@ -1311,12 +1313,12 @@ void PrecomputedTransactionData::Init(const T& txTo)\n template <class T>\n PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n {\n-    Init(txTo);\n+    Init(txTo, {});\n }\n \n // explicit instantiation\n-template void PrecomputedTransactionData::Init(const CTransaction& txTo);\n-template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo);\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut>&& spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut>&& spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n "
      },
      {
        "sha": "64cefc0d6c11ac5d3ffe5f06849b119c7ba0e8cc",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d62e3a68b6ea9bb03556ee1fbf5678f20be01a2/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d62e3a68b6ea9bb03556ee1fbf5678f20be01a2/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=5d62e3a68b6ea9bb03556ee1fbf5678f20be01a2",
        "patch": "@@ -15,6 +15,7 @@\n class CPubKey;\n class CScript;\n class CTransaction;\n+class CTxOut;\n class uint256;\n \n /** Signature hash types/flags */\n@@ -122,11 +123,12 @@ struct PrecomputedTransactionData\n {\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n     bool m_ready = false;\n+    std::vector<CTxOut> m_spent_outputs;\n \n     PrecomputedTransactionData() = default;\n \n     template <class T>\n-    void Init(const T& tx);\n+    void Init(const T& tx, std::vector<CTxOut>&& spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);"
      },
      {
        "sha": "2090d9477fc2b477f54c0e07faa8fc43c68af5ee",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 6,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d62e3a68b6ea9bb03556ee1fbf5678f20be01a2/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d62e3a68b6ea9bb03556ee1fbf5678f20be01a2/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=5d62e3a68b6ea9bb03556ee1fbf5678f20be01a2",
        "patch": "@@ -1539,13 +1539,20 @@ bool CheckInputScripts(const CTransaction& tx, TxValidationState &state, const C\n     }\n \n     if (!txdata.m_ready) {\n-        txdata.Init(tx);\n+        std::vector<CTxOut> spent_outputs;\n+        spent_outputs.reserve(tx.vin.size());\n+\n+        for (const auto& txin : tx.vin) {\n+            const COutPoint& prevout = txin.prevout;\n+            const Coin& coin = inputs.AccessCoin(prevout);\n+            assert(!coin.IsSpent());\n+            spent_outputs.emplace_back(coin.out);\n+        }\n+        txdata.Init(tx, std::move(spent_outputs));\n     }\n+    assert(txdata.m_spent_outputs.size() == tx.vin.size());\n \n     for (unsigned int i = 0; i < tx.vin.size(); i++) {\n-        const COutPoint &prevout = tx.vin[i].prevout;\n-        const Coin& coin = inputs.AccessCoin(prevout);\n-        assert(!coin.IsSpent());\n \n         // We very carefully only pass in things to CScriptCheck which\n         // are clearly committed to by tx' witness hash. This provides\n@@ -1554,7 +1561,7 @@ bool CheckInputScripts(const CTransaction& tx, TxValidationState &state, const C\n         // spent being checked as a part of CScriptCheck.\n \n         // Verify signature\n-        CScriptCheck check(coin.out, tx, i, flags, cacheSigStore, &txdata);\n+        CScriptCheck check(txdata.m_spent_outputs[i], tx, i, flags, cacheSigStore, &txdata);\n         if (pvChecks) {\n             pvChecks->push_back(CScriptCheck());\n             check.swap(pvChecks->back());\n@@ -1568,7 +1575,7 @@ bool CheckInputScripts(const CTransaction& tx, TxValidationState &state, const C\n                 // splitting the network between upgraded and\n                 // non-upgraded nodes by banning CONSENSUS-failing\n                 // data providers.\n-                CScriptCheck check2(coin.out, tx, i,\n+                CScriptCheck check2(txdata.m_spent_outputs[i], tx, i,\n                         flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &txdata);\n                 if (check2())\n                     return state.Invalid(TxValidationResult::TX_NOT_STANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));"
      }
    ]
  },
  {
    "sha": "450d2b23710ad296eede81339195376021ab5500",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NTBkMmIyMzcxMGFkMjk2ZWVkZTgxMzM5MTk1Mzc2MDIxYWI1NTAw",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-09-14T16:53:42Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-12T09:06:32Z"
      },
      "message": "--- [TAPROOT] BIP340/341/342 consensus rules ---",
      "tree": {
        "sha": "de9e5600c4d2a5718861b4331df2344fd8c47838",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/de9e5600c4d2a5718861b4331df2344fd8c47838"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/450d2b23710ad296eede81339195376021ab5500",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/450d2b23710ad296eede81339195376021ab5500",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/450d2b23710ad296eede81339195376021ab5500",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/450d2b23710ad296eede81339195376021ab5500/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5d62e3a68b6ea9bb03556ee1fbf5678f20be01a2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5d62e3a68b6ea9bb03556ee1fbf5678f20be01a2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5d62e3a68b6ea9bb03556ee1fbf5678f20be01a2"
      }
    ],
    "stats": {
      "total": 0,
      "additions": 0,
      "deletions": 0
    },
    "files": []
  },
  {
    "sha": "9eb590894f15ff40806039bfd32972fbc260e30d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZWI1OTA4OTRmMTVmZjQwODA2MDM5YmZkMzI5NzJmYmMyNjBlMzBk",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-09-11T21:32:50Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-12T09:06:32Z"
      },
      "message": "Add TaggedHash function (BIP 340)\n\nThis adds the TaggedHash function as defined by BIP340 to the hash module, which\nis used in BIP340 and BIP341 to produce domain-separated hashes.",
      "tree": {
        "sha": "74ddd22d2750eb0de88176a108aa9a7ecc57fe6f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/74ddd22d2750eb0de88176a108aa9a7ecc57fe6f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9eb590894f15ff40806039bfd32972fbc260e30d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9eb590894f15ff40806039bfd32972fbc260e30d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9eb590894f15ff40806039bfd32972fbc260e30d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9eb590894f15ff40806039bfd32972fbc260e30d/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "450d2b23710ad296eede81339195376021ab5500",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/450d2b23710ad296eede81339195376021ab5500",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/450d2b23710ad296eede81339195376021ab5500"
      }
    ],
    "stats": {
      "total": 19,
      "additions": 19,
      "deletions": 0
    },
    "files": [
      {
        "sha": "3657b386395fbecf4166b95208f16e3f2fa0a655",
        "filename": "src/hash.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9eb590894f15ff40806039bfd32972fbc260e30d/src/hash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9eb590894f15ff40806039bfd32972fbc260e30d/src/hash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.cpp?ref=9eb590894f15ff40806039bfd32972fbc260e30d",
        "patch": "@@ -6,6 +6,7 @@\n #include <crypto/common.h>\n #include <crypto/hmac_sha512.h>\n \n+#include <string>\n \n inline uint32_t ROTL32(uint32_t x, int8_t r)\n {\n@@ -84,3 +85,12 @@ uint256 SHA256Uint256(const uint256& input)\n     CSHA256().Write(input.begin(), 32).Finalize(result.begin());\n     return result;\n }\n+\n+CHashWriter TaggedHash(const std::string& tag)\n+{\n+    CHashWriter writer(SER_GETHASH, 0);\n+    uint256 taghash;\n+    CSHA256().Write((const unsigned char*)tag.data(), tag.size()).Finalize(taghash.begin());\n+    writer << taghash << taghash;\n+    return writer;\n+}"
      },
      {
        "sha": "6d876076ee86f0cffb8aef766fea5753519d6eb9",
        "filename": "src/hash.h",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9eb590894f15ff40806039bfd32972fbc260e30d/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9eb590894f15ff40806039bfd32972fbc260e30d/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.h?ref=9eb590894f15ff40806039bfd32972fbc260e30d",
        "patch": "@@ -15,6 +15,7 @@\n #include <uint256.h>\n #include <version.h>\n \n+#include <string>\n #include <vector>\n \n typedef uint256 ChainCode;\n@@ -202,4 +203,12 @@ unsigned int MurmurHash3(unsigned int nHashSeed, Span<const unsigned char> vData\n \n void BIP32Hash(const ChainCode &chainCode, unsigned int nChild, unsigned char header, const unsigned char data[32], unsigned char output[64]);\n \n+/** Return a CHashWriter primed for tagged hashes (as specified in BIP 340).\n+ *\n+ * The returned object will have SHA256(tag) written to it twice (= 64 bytes).\n+ * A tagged hash can be computed by feeding the message into this object, and\n+ * then calling CHashWriter::GetSHA256().\n+ */\n+CHashWriter TaggedHash(const std::string& tag);\n+\n #endif // BITCOIN_HASH_H"
      }
    ]
  },
  {
    "sha": "5de246ca8159dcffaa4c136a60c8bfed2028e2ee",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ZGUyNDZjYTgxNTlkY2ZmYWE0YzEzNmE2MGM4YmZlZDIwMjhlMmVl",
    "commit": {
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2020-09-11T21:33:10Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-13T00:06:38Z"
      },
      "message": "Implement Taproot signature hashing (BIP 341)\n\nThis implements the new sighashing scheme from BIP341, with all relevant\nwhole-transaction values precomputed once and cached.\n\nIncludes changes to PrecomputedTransactionData by Pieter Wuille.",
      "tree": {
        "sha": "6360222a98a2f75e01882ad8c01f771b4f4c0b8b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6360222a98a2f75e01882ad8c01f771b4f4c0b8b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5de246ca8159dcffaa4c136a60c8bfed2028e2ee",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5de246ca8159dcffaa4c136a60c8bfed2028e2ee",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5de246ca8159dcffaa4c136a60c8bfed2028e2ee",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5de246ca8159dcffaa4c136a60c8bfed2028e2ee/comments",
    "author": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9eb590894f15ff40806039bfd32972fbc260e30d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9eb590894f15ff40806039bfd32972fbc260e30d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9eb590894f15ff40806039bfd32972fbc260e30d"
      }
    ],
    "stats": {
      "total": 175,
      "additions": 163,
      "deletions": 12
    },
    "files": [
      {
        "sha": "af8fd4912e2d2d58e0a3eb02b9e290aec2577edd",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 133,
        "deletions": 8,
        "changes": 141,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5de246ca8159dcffaa4c136a60c8bfed2028e2ee/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5de246ca8159dcffaa4c136a60c8bfed2028e2ee/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=5de246ca8159dcffaa4c136a60c8bfed2028e2ee",
        "patch": "@@ -1291,23 +1291,79 @@ uint256 GetOutputsSHA256(const T& txTo)\n     return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut>&& spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n     m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n+    }\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = SHA256Uint256(GetPrevoutsSHA256(txTo));\n-        hashSequence = SHA256Uint256(GetSequencesSHA256(txTo));\n-        hashOutputs = SHA256Uint256(GetOutputsSHA256(txTo));\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143_segwit = false;\n+    bool uses_bip341_taproot = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every witness-bearing spend with 34-byte scriptPubKey that starts with OP_1 as a Taproot\n+                // spend. This only works if spent_outputs was provided as well, but if it wasn't, actual validation\n+                // will fail anyway. Note that this branch may trigger for scriptPubKeys that aren't actually segwit\n+                // but in that case validation will fail as SCRIPT_ERR_WITNESS_UNEXPECTED anyway.\n+                uses_bip341_taproot = true;\n+            } else {\n+                // Treat every spend that's not known to native witness v1 as a Witness v0 spend. This branch may\n+                // also be taken for unknown witness versions, but it is harmless, and being precise would require\n+                // P2SH evaluation to find the redeemScript.\n+                uses_bip143_segwit = true;\n+            }\n+        }\n+        if (uses_bip341_taproot && uses_bip143_segwit) break; // No need to scan further if we already need all.\n     }\n \n-    m_ready = true;\n+    if (uses_bip143_segwit || uses_bip341_taproot) {\n+        // Computations shared between both sighash schemes.\n+        m_prevouts_single_hash = GetPrevoutsSHA256(txTo);\n+        m_sequences_single_hash = GetSequencesSHA256(txTo);\n+        m_outputs_single_hash = GetOutputsSHA256(txTo);\n+    }\n+    if (uses_bip143_segwit) {\n+        hashPrevouts = SHA256Uint256(m_prevouts_single_hash);\n+        hashSequence = SHA256Uint256(m_sequences_single_hash);\n+        hashOutputs = SHA256Uint256(m_outputs_single_hash);\n+        m_bip143_segwit_ready = true;\n+    }\n+    if (uses_bip341_taproot) {\n+        m_spent_amounts_single_hash = GetSpentAmountsSHA256(m_spent_outputs);\n+        m_spent_scripts_single_hash = GetSpentScriptsSHA256(m_spent_outputs);\n+        m_bip341_taproot_ready = true;\n+    }\n }\n \n template <class T>\n@@ -1322,6 +1378,75 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, uint32_t in_pos, uint8_t hash_type, SigVersion sigversion, const PrecomputedTransactionData& cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache.m_bip341_taproot_ready && cache.m_spent_outputs_ready);\n+\n+    CHashWriter ss = HASHER_TAPSIGHASH;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (!(hash_type <= 0x03 || (hash_type >= 0x81 && hash_type <= 0x83))) return false;\n+    ss << hash_type;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+    if (input_type != SIGHASH_ANYONECANPAY) {\n+        ss << cache.m_prevouts_single_hash;\n+        ss << cache.m_spent_amounts_single_hash;\n+        ss << cache.m_spent_scripts_single_hash;\n+        ss << cache.m_sequences_single_hash;\n+    }\n+    if (output_type == SIGHASH_ALL) {\n+        ss << cache.m_outputs_single_hash;\n+    }\n+\n+    // Data about the input/prevout being spent\n+    const auto& witstack = tx_to.vin[in_pos].scriptWitness.stack;\n+    bool have_annex = witstack.size() > 1 && witstack.back().size() > 0 && witstack.back()[0] == ANNEX_TAG;\n+    const uint8_t spend_type = (ext_flag << 1) + (have_annex ? 1 : 0); // The low bit indicates whether an annex is present.\n+    ss << spend_type;\n+    if (input_type == SIGHASH_ANYONECANPAY) {\n+        ss << tx_to.vin[in_pos].prevout;\n+        ss << cache.m_spent_outputs[in_pos];\n+        ss << tx_to.vin[in_pos].nSequence;\n+    } else {\n+        ss << in_pos;\n+    }\n+    if (have_annex) {\n+        ss << (CHashWriter(SER_GETHASH, 0) << witstack.back()).GetSHA256();\n+    }\n+\n+    // Data about the output (if only one).\n+    if (output_type == SIGHASH_SINGLE) {\n+        if (in_pos >= tx_to.vout.size()) return false;\n+        CHashWriter sha_single_output(SER_GETHASH, 0);\n+        sha_single_output << tx_to.vout[in_pos];\n+        ss << sha_single_output.GetSHA256();\n+    }\n+\n+    hash_out = ss.GetSHA256();\n+    return true;\n+}\n+\n template <class T>\n uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion, const PrecomputedTransactionData* cache)\n {\n@@ -1331,7 +1456,7 @@ uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn\n         uint256 hashPrevouts;\n         uint256 hashSequence;\n         uint256 hashOutputs;\n-        const bool cacheready = cache && cache->m_ready;\n+        const bool cacheready = cache && cache->m_bip143_segwit_ready;\n \n         if (!(nHashType & SIGHASH_ANYONECANPAY)) {\n             hashPrevouts = cacheready ? cache->hashPrevouts : SHA256Uint256(GetPrevoutsSHA256(txTo));"
      },
      {
        "sha": "b739528f0f33ff624592f355c7739434230f6d36",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 24,
        "deletions": 3,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5de246ca8159dcffaa4c136a60c8bfed2028e2ee/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5de246ca8159dcffaa4c136a60c8bfed2028e2ee/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=5de246ca8159dcffaa4c136a60c8bfed2028e2ee",
        "patch": "@@ -25,6 +25,10 @@ enum\n     SIGHASH_NONE = 2,\n     SIGHASH_SINGLE = 3,\n     SIGHASH_ANYONECANPAY = 0x80,\n+\n+    SIGHASH_DEFAULT = 0, //!< Taproot only; implied when sighash byte is missing, and equivalent to SIGHASH_ALL\n+    SIGHASH_OUTPUT_MASK = 3,\n+    SIGHASH_INPUT_MASK = 0x80,\n };\n \n /** Script verification flags.\n@@ -121,9 +125,24 @@ bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned i\n \n struct PrecomputedTransactionData\n {\n+    // BIP341 precomputed data.\n+    // These are single-SHA256, see https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-15.\n+    uint256 m_prevouts_single_hash;\n+    uint256 m_sequences_single_hash;\n+    uint256 m_outputs_single_hash;\n+    uint256 m_spent_amounts_single_hash;\n+    uint256 m_spent_scripts_single_hash;\n+    //! Whether the 5 fields above are initialized.\n+    bool m_bip341_taproot_ready = false;\n+\n+    // BIP143 precomputed data (double-SHA256).\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n-    bool m_ready = false;\n+    //! Whether the 3 fields above are initialized.\n+    bool m_bip143_segwit_ready = false;\n+\n     std::vector<CTxOut> m_spent_outputs;\n+    //! Whether m_spent_outputs is initialized.\n+    bool m_spent_outputs_ready = false;\n \n     PrecomputedTransactionData() = default;\n \n@@ -136,13 +155,15 @@ struct PrecomputedTransactionData\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and BIP16 P2SH-wrapped redeemscripts\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with 32-byte program, not BIP16 P2SH-wrapped, key path spending; see BIP 341\n };\n \n /** Signature hash sizes */\n static constexpr size_t WITNESS_V0_SCRIPTHASH_SIZE = 32;\n static constexpr size_t WITNESS_V0_KEYHASH_SIZE = 20;\n+static constexpr size_t WITNESS_V1_TAPROOT_SIZE = 32;\n \n template <class T>\n uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion, const PrecomputedTransactionData* cache = nullptr);"
      },
      {
        "sha": "fcf3e2936249d924265502648b631d2a7d4417b2",
        "filename": "src/script/script.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5de246ca8159dcffaa4c136a60c8bfed2028e2ee/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5de246ca8159dcffaa4c136a60c8bfed2028e2ee/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=5de246ca8159dcffaa4c136a60c8bfed2028e2ee",
        "patch": "@@ -44,6 +44,11 @@ static const unsigned int LOCKTIME_THRESHOLD = 500000000; // Tue Nov  5 00:53:20\n // SEQUENCE_FINAL).\n static const uint32_t LOCKTIME_MAX = 0xFFFFFFFFU;\n \n+// Tag for input annex. If there are at least two witness elements for a transaction input,\n+// and the first byte of the last element is 0x50, this last element is called annex, and\n+// has meanings independent of the script\n+static constexpr unsigned int ANNEX_TAG = 0x50;\n+\n template <typename T>\n std::vector<unsigned char> ToByteVector(const T& in)\n {"
      },
      {
        "sha": "65958967ee91bc46b9eb24c11055b2ca04671922",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5de246ca8159dcffaa4c136a60c8bfed2028e2ee/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5de246ca8159dcffaa4c136a60c8bfed2028e2ee/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=5de246ca8159dcffaa4c136a60c8bfed2028e2ee",
        "patch": "@@ -1538,7 +1538,7 @@ bool CheckInputScripts(const CTransaction& tx, TxValidationState &state, const C\n         return true;\n     }\n \n-    if (!txdata.m_ready) {\n+    if (!txdata.m_spent_outputs_ready) {\n         std::vector<CTxOut> spent_outputs;\n         spent_outputs.reserve(tx.vin.size());\n "
      }
    ]
  },
  {
    "sha": "0664f5fe1f77f08d235aa3750b59428257b0b91d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNjY0ZjVmZTFmNzdmMDhkMjM1YWEzNzUwYjU5NDI4MjU3YjBiOTFk",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-09-11T21:33:30Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-13T00:15:40Z"
      },
      "message": "Support for Schnorr signatures and integration in SignatureCheckers (BIP 340)\n\nThis enables the schnorrsig module in libsecp256k1, adds the relevant types\nand functions to src/pubkey, as well as in higher-level `SignatureChecker`\nclasses. The (verification side of the) BIP340 test vectors is also added.",
      "tree": {
        "sha": "fe5078625aa3e9b7cf34b51e6eb66e8fccf0d74f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fe5078625aa3e9b7cf34b51e6eb66e8fccf0d74f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0664f5fe1f77f08d235aa3750b59428257b0b91d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0664f5fe1f77f08d235aa3750b59428257b0b91d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0664f5fe1f77f08d235aa3750b59428257b0b91d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0664f5fe1f77f08d235aa3750b59428257b0b91d/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5de246ca8159dcffaa4c136a60c8bfed2028e2ee",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5de246ca8159dcffaa4c136a60c8bfed2028e2ee",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5de246ca8159dcffaa4c136a60c8bfed2028e2ee"
      }
    ],
    "stats": {
      "total": 178,
      "additions": 165,
      "deletions": 13
    },
    "files": [
      {
        "sha": "c42918d6e17737ad8a473a5d597e4c162108e42f",
        "filename": "build_msvc/libsecp256k1/libsecp256k1.vcxproj",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0664f5fe1f77f08d235aa3750b59428257b0b91d/build_msvc/libsecp256k1/libsecp256k1.vcxproj",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0664f5fe1f77f08d235aa3750b59428257b0b91d/build_msvc/libsecp256k1/libsecp256k1.vcxproj",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/libsecp256k1/libsecp256k1.vcxproj?ref=0664f5fe1f77f08d235aa3750b59428257b0b91d",
        "patch": "@@ -12,7 +12,7 @@\n   </ItemGroup>\n     <ItemDefinitionGroup>\n     <ClCompile>\n-      <PreprocessorDefinitions>ENABLE_MODULE_ECDH;ENABLE_MODULE_RECOVERY;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n+      <PreprocessorDefinitions>ENABLE_MODULE_ECDH;ENABLE_MODULE_RECOVERY;ENABLE_MODULE_EXTRAKEYS;ENABLE_MODULE_SCHNORRSIG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n        <AdditionalIncludeDirectories>..\\..\\src\\secp256k1;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n      </ClCompile>\n   </ItemDefinitionGroup>"
      },
      {
        "sha": "3df59e0b7b813e2f715e0a5dd7f49837481b5bcb",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0664f5fe1f77f08d235aa3750b59428257b0b91d/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0664f5fe1f77f08d235aa3750b59428257b0b91d/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=0664f5fe1f77f08d235aa3750b59428257b0b91d",
        "patch": "@@ -1645,7 +1645,7 @@ if test x$need_bundled_univalue = xyes; then\n   AC_CONFIG_SUBDIRS([src/univalue])\n fi\n \n-ac_configure_args=\"${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --with-bignum=no --enable-module-recovery\"\n+ac_configure_args=\"${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --with-bignum=no --enable-module-recovery --enable-module-schnorrsig --enable-experimental\"\n AC_CONFIG_SUBDIRS([src/secp256k1])\n \n AC_OUTPUT"
      },
      {
        "sha": "69e3d913921e4fe01f1c855e90c0303699e7e4f0",
        "filename": "src/pubkey.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0664f5fe1f77f08d235aa3750b59428257b0b91d/src/pubkey.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0664f5fe1f77f08d235aa3750b59428257b0b91d/src/pubkey.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.cpp?ref=0664f5fe1f77f08d235aa3750b59428257b0b91d",
        "patch": "@@ -7,6 +7,7 @@\n \n #include <secp256k1.h>\n #include <secp256k1_recovery.h>\n+#include <secp256k1_schnorrsig.h>\n \n namespace\n {\n@@ -166,6 +167,20 @@ int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_\n     return 1;\n }\n \n+XOnlyPubKey::XOnlyPubKey(Span<const unsigned char> bytes)\n+{\n+    assert(bytes.size() == 32);\n+    std::copy(bytes.begin(), bytes.end(), m_keydata.begin());\n+}\n+\n+bool XOnlyPubKey::VerifySchnorr(const uint256& msg, Span<const unsigned char> sigbytes) const\n+{\n+    assert(sigbytes.size() == 64);\n+    secp256k1_xonly_pubkey pubkey;\n+    if (!secp256k1_xonly_pubkey_parse(secp256k1_context_verify, &pubkey, m_keydata.data())) return false;\n+    return secp256k1_schnorrsig_verify(secp256k1_context_verify, sigbytes.data(), msg.begin(), &pubkey);\n+}\n+\n bool CPubKey::Verify(const uint256 &hash, const std::vector<unsigned char>& vchSig) const {\n     if (!IsValid())\n         return false;"
      },
      {
        "sha": "1a818037d1aa1590d3155ffbf0690b6bc019dcee",
        "filename": "src/pubkey.h",
        "status": "modified",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0664f5fe1f77f08d235aa3750b59428257b0b91d/src/pubkey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0664f5fe1f77f08d235aa3750b59428257b0b91d/src/pubkey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.h?ref=0664f5fe1f77f08d235aa3750b59428257b0b91d",
        "patch": "@@ -9,6 +9,7 @@\n \n #include <hash.h>\n #include <serialize.h>\n+#include <span.h>\n #include <uint256.h>\n \n #include <stdexcept>\n@@ -206,6 +207,25 @@ class CPubKey\n     bool Derive(CPubKey& pubkeyChild, ChainCode &ccChild, unsigned int nChild, const ChainCode& cc) const;\n };\n \n+class XOnlyPubKey\n+{\n+private:\n+    uint256 m_keydata;\n+\n+public:\n+    /** Construct an x-only pubkey from exactly 32 bytes. */\n+    XOnlyPubKey(Span<const unsigned char> bytes);\n+\n+    /** Verify a Schnorr signature against this public key.\n+     *\n+     * sigbytes must be exactly 64 bytes.\n+     */\n+    bool VerifySchnorr(const uint256& msg, Span<const unsigned char> sigbytes) const;\n+\n+    const unsigned char& operator[](int pos) const { return *(m_keydata.begin() + pos); }\n+    size_t size() const { return m_keydata.size(); }\n+};\n+\n struct CExtPubKey {\n     unsigned char nDepth;\n     unsigned char vchFingerprint[4];"
      },
      {
        "sha": "aef6e281181b81914caaf6f1e9085cbcac713d11",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 0,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0664f5fe1f77f08d235aa3750b59428257b0b91d/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0664f5fe1f77f08d235aa3750b59428257b0b91d/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=0664f5fe1f77f08d235aa3750b59428257b0b91d",
        "patch": "@@ -1521,6 +1521,12 @@ bool GenericTransactionSignatureChecker<T>::VerifyECDSASignature(const std::vect\n     return pubkey.Verify(sighash, vchSig);\n }\n \n+template <class T>\n+bool GenericTransactionSignatureChecker<T>::VerifySchnorrSignature(Span<const unsigned char> sig, const XOnlyPubKey& pubkey, const uint256& sighash) const\n+{\n+    return pubkey.VerifySchnorr(sighash, sig);\n+}\n+\n template <class T>\n bool GenericTransactionSignatureChecker<T>::CheckECDSASignature(const std::vector<unsigned char>& vchSigIn, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n {\n@@ -1543,6 +1549,30 @@ bool GenericTransactionSignatureChecker<T>::CheckECDSASignature(const std::vecto\n     return true;\n }\n \n+template <class T>\n+bool GenericTransactionSignatureChecker<T>::CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey_in, SigVersion sigversion, ScriptError* serror) const\n+{\n+    assert(sigversion == SigVersion::TAPROOT);\n+    // Schnorr signatures have 32-byte public keys. The caller is responsible for enforcing this.\n+    assert(pubkey_in.size() == 32);\n+    if (sig.size() != 64 && sig.size() != 65) return set_error(serror, SCRIPT_ERR_SCHNORR_SIG_SIZE);\n+\n+    XOnlyPubKey pubkey{pubkey_in};\n+\n+    uint8_t hashtype = SIGHASH_DEFAULT;\n+    if (sig.size() == 65) {\n+        hashtype = SpanPopBack(sig);\n+        if (hashtype == SIGHASH_DEFAULT) return set_error(serror, SCRIPT_ERR_SCHNORR_SIG_HASHTYPE);\n+    }\n+    uint256 sighash;\n+    assert(this->txdata);\n+    if (!SignatureHashSchnorr(sighash, *txTo, nIn, hashtype, sigversion, *this->txdata)) {\n+        return set_error(serror, SCRIPT_ERR_SCHNORR_SIG_HASHTYPE);\n+    }\n+    if (!VerifySchnorrSignature(sig, pubkey, sighash)) return set_error(serror, SCRIPT_ERR_SCHNORR_SIG);\n+    return true;\n+}\n+\n template <class T>\n bool GenericTransactionSignatureChecker<T>::CheckLockTime(const CScriptNum& nLockTime) const\n {"
      },
      {
        "sha": "e54243c8f0b04e36e6442af936ee462728799740",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0664f5fe1f77f08d235aa3750b59428257b0b91d/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0664f5fe1f77f08d235aa3750b59428257b0b91d/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=0664f5fe1f77f08d235aa3750b59428257b0b91d",
        "patch": "@@ -7,12 +7,14 @@\n #define BITCOIN_SCRIPT_INTERPRETER_H\n \n #include <script/script_error.h>\n+#include <span.h>\n #include <primitives/transaction.h>\n \n #include <vector>\n #include <stdint.h>\n \n class CPubKey;\n+class XOnlyPubKey;\n class CScript;\n class CTransaction;\n class CTxOut;\n@@ -176,6 +178,11 @@ class BaseSignatureChecker\n         return false;\n     }\n \n+    virtual bool CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey, SigVersion sigversion, ScriptError* serror = nullptr) const\n+    {\n+        return false;\n+    }\n+\n     virtual bool CheckLockTime(const CScriptNum& nLockTime) const\n     {\n          return false;\n@@ -200,11 +207,13 @@ class GenericTransactionSignatureChecker : public BaseSignatureChecker\n \n protected:\n     virtual bool VerifyECDSASignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash) const;\n+    virtual bool VerifySchnorrSignature(Span<const unsigned char> sig, const XOnlyPubKey& pubkey, const uint256& sighash) const;\n \n public:\n     GenericTransactionSignatureChecker(const T* txToIn, unsigned int nInIn, const CAmount& amountIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(nullptr) {}\n     GenericTransactionSignatureChecker(const T* txToIn, unsigned int nInIn, const CAmount& amountIn, const PrecomputedTransactionData& txdataIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(&txdataIn) {}\n     bool CheckECDSASignature(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override;\n+    bool CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey, SigVersion sigversion, ScriptError* serror = nullptr) const override;\n     bool CheckLockTime(const CScriptNum& nLockTime) const override;\n     bool CheckSequence(const CScriptNum& nSequence) const override;\n };"
      },
      {
        "sha": "9c49ced3edba3d143108418c20636da2fff805d2",
        "filename": "src/script/script_error.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0664f5fe1f77f08d235aa3750b59428257b0b91d/src/script/script_error.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0664f5fe1f77f08d235aa3750b59428257b0b91d/src/script/script_error.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script_error.cpp?ref=0664f5fe1f77f08d235aa3750b59428257b0b91d",
        "patch": "@@ -91,6 +91,12 @@ std::string ScriptErrorString(const ScriptError serror)\n             return \"Witness provided for non-witness script\";\n         case SCRIPT_ERR_WITNESS_PUBKEYTYPE:\n             return \"Using non-compressed keys in segwit\";\n+        case SCRIPT_ERR_SCHNORR_SIG_SIZE:\n+            return \"Invalid Schnorr signature size\";\n+        case SCRIPT_ERR_SCHNORR_SIG_HASHTYPE:\n+            return \"Invalid Schnorr signature hash type\";\n+        case SCRIPT_ERR_SCHNORR_SIG:\n+            return \"Invalid Schnorr signature\";\n         case SCRIPT_ERR_OP_CODESEPARATOR:\n             return \"Using OP_CODESEPARATOR in non-witness script\";\n         case SCRIPT_ERR_SIG_FINDANDDELETE:"
      },
      {
        "sha": "c79a11a94b3618d31aa154d5677dc43bdb2b15a3",
        "filename": "src/script/script_error.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0664f5fe1f77f08d235aa3750b59428257b0b91d/src/script/script_error.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0664f5fe1f77f08d235aa3750b59428257b0b91d/src/script/script_error.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script_error.h?ref=0664f5fe1f77f08d235aa3750b59428257b0b91d",
        "patch": "@@ -66,6 +66,11 @@ typedef enum ScriptError_t\n     SCRIPT_ERR_WITNESS_UNEXPECTED,\n     SCRIPT_ERR_WITNESS_PUBKEYTYPE,\n \n+    /* Taproot */\n+    SCRIPT_ERR_SCHNORR_SIG_SIZE,\n+    SCRIPT_ERR_SCHNORR_SIG_HASHTYPE,\n+    SCRIPT_ERR_SCHNORR_SIG,\n+\n     /* Constant scriptCode */\n     SCRIPT_ERR_OP_CODESEPARATOR,\n     SCRIPT_ERR_SIG_FINDANDDELETE,"
      },
      {
        "sha": "4a6e04f2eb3898aff4c7842d826f6494dbf82816",
        "filename": "src/script/sigcache.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 6,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0664f5fe1f77f08d235aa3750b59428257b0b91d/src/script/sigcache.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0664f5fe1f77f08d235aa3750b59428257b0b91d/src/script/sigcache.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sigcache.cpp?ref=0664f5fe1f77f08d235aa3750b59428257b0b91d",
        "patch": "@@ -22,8 +22,9 @@ namespace {\n class CSignatureCache\n {\n private:\n-     //! Entries are SHA256(nonce || signature hash || public key || signature):\n-    CSHA256 m_salted_hasher;\n+     //! Entries are SHA256(nonce || 'E' or 'S' || 31 zero bytes || signature hash || public key || signature):\n+    CSHA256 m_salted_hasher_ecdsa;\n+    CSHA256 m_salted_hasher_schnorr;\n     typedef CuckooCache::cache<uint256, SignatureCacheHasher> map_type;\n     map_type setValid;\n     boost::shared_mutex cs_sigcache;\n@@ -34,18 +35,30 @@ class CSignatureCache\n         uint256 nonce = GetRandHash();\n         // We want the nonce to be 64 bytes long to force the hasher to process\n         // this chunk, which makes later hash computations more efficient. We\n-        // just write our 32-byte entropy twice to fill the 64 bytes.\n-        m_salted_hasher.Write(nonce.begin(), 32);\n-        m_salted_hasher.Write(nonce.begin(), 32);\n+        // just write our 32-byte entropy, and then pad with 'E' for ECDSA and\n+        // 'S' for Schnorr (followed by 0 bytes).\n+        static constexpr unsigned char PADDING_ECDSA[32] = {'E'};\n+        static constexpr unsigned char PADDING_SCHNORR[32] = {'S'};\n+        m_salted_hasher_ecdsa.Write(nonce.begin(), 32);\n+        m_salted_hasher_ecdsa.Write(PADDING_ECDSA, 32);\n+        m_salted_hasher_schnorr.Write(nonce.begin(), 32);\n+        m_salted_hasher_schnorr.Write(PADDING_SCHNORR, 32);\n     }\n \n     void\n     ComputeEntryECDSA(uint256& entry, const uint256 &hash, const std::vector<unsigned char>& vchSig, const CPubKey& pubkey)\n     {\n-        CSHA256 hasher = m_salted_hasher;\n+        CSHA256 hasher = m_salted_hasher_ecdsa;\n         hasher.Write(hash.begin(), 32).Write(&pubkey[0], pubkey.size()).Write(&vchSig[0], vchSig.size()).Finalize(entry.begin());\n     }\n \n+    void\n+    ComputeEntrySchnorr(uint256& entry, const uint256 &hash, Span<const unsigned char> sig, const XOnlyPubKey& pubkey)\n+    {\n+        CSHA256 hasher = m_salted_hasher_schnorr;\n+        hasher.Write(hash.begin(), 32).Write(&pubkey[0], pubkey.size()).Write(sig.data(), sig.size()).Finalize(entry.begin());\n+    }\n+\n     bool\n     Get(const uint256& entry, const bool erase)\n     {\n@@ -97,3 +110,13 @@ bool CachingTransactionSignatureChecker::VerifyECDSASignature(const std::vector<\n         signatureCache.Set(entry);\n     return true;\n }\n+\n+bool CachingTransactionSignatureChecker::VerifySchnorrSignature(Span<const unsigned char> sig, const XOnlyPubKey& pubkey, const uint256& sighash) const\n+{\n+    uint256 entry;\n+    signatureCache.ComputeEntrySchnorr(entry, sighash, sig, pubkey);\n+    if (signatureCache.Get(entry, !store)) return true;\n+    if (!TransactionSignatureChecker::VerifySchnorrSignature(sig, pubkey, sighash)) return false;\n+    if (store) signatureCache.Set(entry);\n+    return true;\n+}"
      },
      {
        "sha": "00534f975844c6ae573cbe8c6bc4667dc2c828ae",
        "filename": "src/script/sigcache.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0664f5fe1f77f08d235aa3750b59428257b0b91d/src/script/sigcache.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0664f5fe1f77f08d235aa3750b59428257b0b91d/src/script/sigcache.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sigcache.h?ref=0664f5fe1f77f08d235aa3750b59428257b0b91d",
        "patch": "@@ -7,6 +7,7 @@\n #define BITCOIN_SCRIPT_SIGCACHE_H\n \n #include <script/interpreter.h>\n+#include <span.h>\n \n #include <vector>\n \n@@ -49,6 +50,7 @@ class CachingTransactionSignatureChecker : public TransactionSignatureChecker\n     CachingTransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, bool storeIn, PrecomputedTransactionData& txdataIn) : TransactionSignatureChecker(txToIn, nInIn, amountIn, txdataIn), store(storeIn) {}\n \n     bool VerifyECDSASignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash) const override;\n+    bool VerifySchnorrSignature(Span<const unsigned char> sig, const XOnlyPubKey& pubkey, const uint256& sighash) const override;\n };\n \n void InitSignatureCache();"
      },
      {
        "sha": "a1cfe1574d72c23e88f5838ab9b428928485739a",
        "filename": "src/script/sign.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0664f5fe1f77f08d235aa3750b59428257b0b91d/src/script/sign.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0664f5fe1f77f08d235aa3750b59428257b0b91d/src/script/sign.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.h?ref=0664f5fe1f77f08d235aa3750b59428257b0b91d",
        "patch": "@@ -11,6 +11,7 @@\n #include <pubkey.h>\n #include <script/interpreter.h>\n #include <script/keyorigin.h>\n+#include <span.h>\n #include <streams.h>\n \n class CKey;"
      },
      {
        "sha": "87af71897bf2fa963f534b1e28386e82d816f616",
        "filename": "src/test/fuzz/script_sigcache.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 5,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0664f5fe1f77f08d235aa3750b59428257b0b91d/src/test/fuzz/script_sigcache.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0664f5fe1f77f08d235aa3750b59428257b0b91d/src/test/fuzz/script_sigcache.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/script_sigcache.cpp?ref=0664f5fe1f77f08d235aa3750b59428257b0b91d",
        "patch": "@@ -35,11 +35,19 @@ void test_one_input(const std::vector<uint8_t>& buffer)\n     const bool store = fuzzed_data_provider.ConsumeBool();\n     PrecomputedTransactionData tx_data;\n     CachingTransactionSignatureChecker caching_transaction_signature_checker{mutable_transaction ? &tx : nullptr, n_in, amount, store, tx_data};\n-    const std::optional<CPubKey> pub_key = ConsumeDeserializable<CPubKey>(fuzzed_data_provider);\n-    if (pub_key) {\n-        const std::vector<uint8_t> random_bytes = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n-        if (!random_bytes.empty()) {\n-            (void)caching_transaction_signature_checker.VerifyECDSASignature(random_bytes, *pub_key, ConsumeUInt256(fuzzed_data_provider));\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        const auto random_bytes = fuzzed_data_provider.ConsumeBytes<unsigned char>(64);\n+        const XOnlyPubKey pub_key(ConsumeUInt256(fuzzed_data_provider));\n+        if (random_bytes.size() == 64) {\n+            (void)caching_transaction_signature_checker.VerifySchnorrSignature(random_bytes, pub_key, ConsumeUInt256(fuzzed_data_provider));\n+        }\n+    } else {\n+        const auto random_bytes = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n+        const auto pub_key = ConsumeDeserializable<CPubKey>(fuzzed_data_provider);\n+        if (pub_key) {\n+            if (!random_bytes.empty()) {\n+                (void)caching_transaction_signature_checker.VerifyECDSASignature(random_bytes, *pub_key, ConsumeUInt256(fuzzed_data_provider));\n+            }\n         }\n     }\n }"
      },
      {
        "sha": "f538c9272e8adb6b91b6ea7643d575502dc514bb",
        "filename": "src/test/fuzz/signature_checker.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0664f5fe1f77f08d235aa3750b59428257b0b91d/src/test/fuzz/signature_checker.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0664f5fe1f77f08d235aa3750b59428257b0b91d/src/test/fuzz/signature_checker.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/signature_checker.cpp?ref=0664f5fe1f77f08d235aa3750b59428257b0b91d",
        "patch": "@@ -33,6 +33,11 @@ class FuzzedSignatureChecker : public BaseSignatureChecker\n         return m_fuzzed_data_provider.ConsumeBool();\n     }\n \n+    bool CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey, SigVersion sigversion, ScriptError* serror = nullptr) const override\n+    {\n+        return m_fuzzed_data_provider.ConsumeBool();\n+    }\n+\n     bool CheckLockTime(const CScriptNum& nLockTime) const override\n     {\n         return m_fuzzed_data_provider.ConsumeBool();"
      },
      {
        "sha": "3362b8d17cdd53b93fc319542b1e525b39c79604",
        "filename": "src/test/key_tests.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0664f5fe1f77f08d235aa3750b59428257b0b91d/src/test/key_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0664f5fe1f77f08d235aa3750b59428257b0b91d/src/test/key_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/key_tests.cpp?ref=0664f5fe1f77f08d235aa3750b59428257b0b91d",
        "patch": "@@ -264,4 +264,32 @@ BOOST_AUTO_TEST_CASE(pubkey_unserialize)\n     }\n }\n \n+BOOST_AUTO_TEST_CASE(bip340_test_vectors)\n+{\n+    static const std::vector<std::pair<std::array<std::string, 3>, bool>> VECTORS = {\n+        {{\"F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BCE036F9\", \"0000000000000000000000000000000000000000000000000000000000000000\", \"E907831F80848D1069A5371B402410364BDF1C5F8307B0084C55F1CE2DCA821525F66A4A85EA8B71E482A74F382D2CE5EBEEE8FDB2172F477DF4900D310536C0\"}, true},\n+        {{\"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659\", \"243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89\", \"6896BD60EEAE296DB48A229FF71DFE071BDE413E6D43F917DC8DCF8C78DE33418906D11AC976ABCCB20B091292BFF4EA897EFCB639EA871CFA95F6DE339E4B0A\"}, true},\n+        {{\"DD308AFEC5777E13121FA72B9CC1B7CC0139715309B086C960E18FD969774EB8\", \"7E2D58D8B3BCDF1ABADEC7829054F90DDA9805AAB56C77333024B9D0A508B75C\", \"5831AAEED7B44BB74E5EAB94BA9D4294C49BCF2A60728D8B4C200F50DD313C1BAB745879A5AD954A72C45A91C3A51D3C7ADEA98D82F8481E0E1E03674A6F3FB7\"}, true},\n+        {{\"25D1DFF95105F5253C4022F628A996AD3A0D95FBF21D468A1B33F8C160D8F517\", \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", \"7EB0509757E246F19449885651611CB965ECC1A187DD51B64FDA1EDC9637D5EC97582B9CB13DB3933705B32BA982AF5AF25FD78881EBB32771FC5922EFC66EA3\"}, true},\n+        {{\"D69C3509BB99E412E68B0FE8544E72837DFA30746D8BE2AA65975F29D22DC7B9\", \"4DF3C3F68FCC83B27E9D42C90431A72499F17875C81A599B566C9889B9696703\", \"00000000000000000000003B78CE563F89A0ED9414F5AA28AD0D96D6795F9C6376AFB1548AF603B3EB45C9F8207DEE1060CB71C04E80F593060B07D28308D7F4\"}, true},\n+        {{\"EEFDEA4CDB677750A420FEE807EACF21EB9898AE79B9768766E4FAA04A2D4A34\", \"243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89\", \"6CFF5C3BA86C69EA4B7376F31A9BCB4F74C1976089B2D9963DA2E5543E17776969E89B4C5564D00349106B8497785DD7D1D713A8AE82B32FA79D5F7FC407D39B\"}, false},\n+        {{\"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659\", \"243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89\", \"FFF97BD5755EEEA420453A14355235D382F6472F8568A18B2F057A14602975563CC27944640AC607CD107AE10923D9EF7A73C643E166BE5EBEAFA34B1AC553E2\"}, false},\n+        {{\"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659\", \"243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89\", \"1FA62E331EDBC21C394792D2AB1100A7B432B013DF3F6FF4F99FCB33E0E1515F28890B3EDB6E7189B630448B515CE4F8622A954CFE545735AAEA5134FCCDB2BD\"}, false},\n+        {{\"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659\", \"243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89\", \"6CFF5C3BA86C69EA4B7376F31A9BCB4F74C1976089B2D9963DA2E5543E177769961764B3AA9B2FFCB6EF947B6887A226E8D7C93E00C5ED0C1834FF0D0C2E6DA6\"}, false},\n+        {{\"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659\", \"243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89\", \"0000000000000000000000000000000000000000000000000000000000000000123DDA8328AF9C23A94C1FEECFD123BA4FB73476F0D594DCB65C6425BD186051\"}, false},\n+        {{\"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659\", \"243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89\", \"00000000000000000000000000000000000000000000000000000000000000017615FBAF5AE28864013C099742DEADB4DBA87F11AC6754F93780D5A1837CF197\"}, false},\n+        {{\"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659\", \"243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89\", \"4A298DACAE57395A15D0795DDBFD1DCB564DA82B0F269BC70A74F8220429BA1D69E89B4C5564D00349106B8497785DD7D1D713A8AE82B32FA79D5F7FC407D39B\"}, false},\n+        {{\"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659\", \"243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89\", \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F69E89B4C5564D00349106B8497785DD7D1D713A8AE82B32FA79D5F7FC407D39B\"}, false},\n+        {{\"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659\", \"243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89\", \"6CFF5C3BA86C69EA4B7376F31A9BCB4F74C1976089B2D9963DA2E5543E177769FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\"}, false},\n+        {{\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC30\", \"243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89\", \"6CFF5C3BA86C69EA4B7376F31A9BCB4F74C1976089B2D9963DA2E5543E17776969E89B4C5564D00349106B8497785DD7D1D713A8AE82B32FA79D5F7FC407D39B\"}, false}\n+    };\n+\n+    for (const auto& test : VECTORS) {\n+        auto pubkey = ParseHex(test.first[0]);\n+        auto msg = ParseHex(test.first[1]);\n+        auto sig = ParseHex(test.first[2]);\n+        BOOST_CHECK_EQUAL(XOnlyPubKey(pubkey).VerifySchnorr(uint256(msg), sig), test.second);\n+    }\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YmJlZDRiN2FjZjRjNzZlYWVhOGMwZTEwZjNjYmY2YmE0ZTUzODA5",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-09-11T21:33:45Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-13T00:17:56Z"
      },
      "message": "Implement Taproot validation (BIP 341)\n\nThis includes key path spending and script path spending, but not the\nTapscript execution implementation (leaf 0xc0 remains unemcumbered in\nthis commit).\n\nIncludes constants for various aspects of the consensus rules suggested\nby Jeremy Rubin.",
      "tree": {
        "sha": "32afa457bf2ead02197781c43087b5f83f499d15",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/32afa457bf2ead02197781c43087b5f83f499d15"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0664f5fe1f77f08d235aa3750b59428257b0b91d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0664f5fe1f77f08d235aa3750b59428257b0b91d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0664f5fe1f77f08d235aa3750b59428257b0b91d"
      }
    ],
    "stats": {
      "total": 97,
      "additions": 90,
      "deletions": 7
    },
    "files": [
      {
        "sha": "4d734fc8914693af0c541e9ae5f550905e38ceff",
        "filename": "src/pubkey.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809/src/pubkey.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809/src/pubkey.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.cpp?ref=8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809",
        "patch": "@@ -181,6 +181,13 @@ bool XOnlyPubKey::VerifySchnorr(const uint256& msg, Span<const unsigned char> si\n     return secp256k1_schnorrsig_verify(secp256k1_context_verify, sigbytes.data(), msg.begin(), &pubkey);\n }\n \n+bool XOnlyPubKey::CheckPayToContract(const XOnlyPubKey& base, const uint256& hash, bool parity) const\n+{\n+    secp256k1_xonly_pubkey base_point;\n+    if (!secp256k1_xonly_pubkey_parse(secp256k1_context_verify, &base_point, base.data())) return false;\n+    return secp256k1_xonly_pubkey_tweak_add_check(secp256k1_context_verify, m_keydata.begin(), parity, &base_point, hash.begin());\n+}\n+\n bool CPubKey::Verify(const uint256 &hash, const std::vector<unsigned char>& vchSig) const {\n     if (!IsValid())\n         return false;"
      },
      {
        "sha": "0f784b86e4733315627d21cbe4f93515244d467a",
        "filename": "src/pubkey.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809/src/pubkey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809/src/pubkey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.h?ref=8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809",
        "patch": "@@ -221,8 +221,10 @@ class XOnlyPubKey\n      * sigbytes must be exactly 64 bytes.\n      */\n     bool VerifySchnorr(const uint256& msg, Span<const unsigned char> sigbytes) const;\n+    bool CheckPayToContract(const XOnlyPubKey& base, const uint256& hash, bool parity) const;\n \n     const unsigned char& operator[](int pos) const { return *(m_keydata.begin() + pos); }\n+    const unsigned char* data() const { return m_keydata.begin(); }\n     size_t size() const { return m_keydata.size(); }\n };\n "
      },
      {
        "sha": "07cc525f502edd1f2273738da538a9644e15a45f",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 61,
        "deletions": 7,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809",
        "patch": "@@ -1379,6 +1379,9 @@ template PrecomputedTransactionData::PrecomputedTransactionData(const CTransacti\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+static const CHashWriter HASHER_TAPLEAF = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HASHER_TAPBRANCH = TaggedHash(\"TapBranch\");\n+static const CHashWriter HASHER_TAPTWEAK = TaggedHash(\"TapTweak\");\n \n template<typename T>\n bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, uint32_t in_pos, uint8_t hash_type, SigVersion sigversion, const PrecomputedTransactionData& cache)\n@@ -1679,14 +1682,35 @@ static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CS\n     return true;\n }\n \n-static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const CScript& script)\n {\n-    CScript exec_script; //!< Actually executed script (last stack item in P2WSH; implied P2PKH script in P2WPKH)\n+    const int path_len = (control.size() - TAPROOT_CONTROL_BASE_SIZE) / TAPROOT_CONTROL_NODE_SIZE;\n+    const XOnlyPubKey p{uint256(std::vector<unsigned char>(control.begin() + 1, control.begin() + TAPROOT_CONTROL_BASE_SIZE))};\n+    const XOnlyPubKey q{uint256(program)};\n+    uint256 tapleaf_hash = (CHashWriter(HASHER_TAPLEAF) << uint8_t(control[0] & TAPROOT_LEAF_MASK) << script).GetSHA256();\n+    uint256 k = tapleaf_hash;\n+    for (int i = 0; i < path_len; ++i) {\n+        CHashWriter ss_branch{HASHER_TAPBRANCH};\n+        Span<const unsigned char> node(control.data() + TAPROOT_CONTROL_BASE_SIZE + TAPROOT_CONTROL_NODE_SIZE * i, TAPROOT_CONTROL_NODE_SIZE);\n+        if (std::lexicographical_compare(k.begin(), k.end(), node.begin(), node.end())) {\n+            ss_branch << k << node;\n+        } else {\n+            ss_branch << node << k;\n+        }\n+        k = ss_branch.GetSHA256();\n+    }\n+    k = (CHashWriter(HASHER_TAPTWEAK) << MakeSpan(p) << k).GetSHA256();\n+    return q.CheckPayToContract(p, k, control[0] & 1);\n+}\n+\n+static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror, bool is_p2sh)\n+{\n+    CScript exec_script; //!< Actually executed script (last stack item in P2WSH; implied P2PKH script in P2WPKH; leaf script in P2TR)\n     Span<const valtype> stack{witness.stack};\n \n     if (witversion == 0) {\n         if (program.size() == WITNESS_V0_SCRIPTHASH_SIZE) {\n-            // Version 0 segregated witness program: SHA256(CScript) inside the program, CScript + inputs in witness\n+            // BIP141 P2WSH: 32-byte witness v0 program (which encodes SHA256(script))\n             if (stack.size() == 0) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n             }\n@@ -1699,7 +1723,7 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n             }\n             return ExecuteWitnessScript(stack, exec_script, flags, SigVersion::WITNESS_V0, checker, serror);\n         } else if (program.size() == WITNESS_V0_KEYHASH_SIZE) {\n-            // Special case for pay-to-pubkeyhash; signature + pubkey in witness\n+            // BIP141 P2WPKH: 20-byte witness v0 program (which encodes Hash160(pubkey))\n             if (stack.size() != 2) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH); // 2 items in witness\n             }\n@@ -1708,11 +1732,41 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n         } else {\n             return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);\n         }\n+    } else if (witversion == 1 && program.size() == WITNESS_V1_TAPROOT_SIZE && !is_p2sh) {\n+        // BIP341 Taproot: 32-byte non-P2SH witness v1 program (which encodes a P2C-tweaked pubkey)\n+        if (!(flags & SCRIPT_VERIFY_TAPROOT)) return set_success(serror);\n+        if (stack.size() == 0) return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n+        if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {\n+            // Drop annex (this is non-standard; see IsWitnessStandard)\n+            SpanPopBack(stack);\n+        }\n+        if (stack.size() == 1) {\n+            // Key path spending (stack size is 1 after removing optional annex)\n+            if (!checker.CheckSchnorrSignature(stack.front(), program, SigVersion::TAPROOT, serror)) {\n+                return false; // serror is set\n+            }\n+            return set_success(serror);\n+        } else {\n+            // Script path spending (stack size is >1 after removing optional annex)\n+            const valtype& control = SpanPopBack(stack);\n+            const valtype& script_bytes = SpanPopBack(stack);\n+            exec_script = CScript(script_bytes.begin(), script_bytes.end());\n+            if (control.size() < TAPROOT_CONTROL_BASE_SIZE || control.size() > TAPROOT_CONTROL_MAX_SIZE || ((control.size() - TAPROOT_CONTROL_BASE_SIZE) % TAPROOT_CONTROL_NODE_SIZE) != 0) {\n+                return set_error(serror, SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE);\n+            }\n+            if (!VerifyTaprootCommitment(control, program, exec_script)) {\n+                return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n+            }\n+            if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION) {\n+                return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION);\n+            }\n+            return set_success(serror);\n+        }\n     } else {\n         if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM) {\n             return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM);\n         }\n-        // Higher version witness scripts return true for future softfork compatibility\n+        // Other version/size/p2sh combinations return true for future softfork compatibility\n         return true;\n     }\n     // There is intentionally no return statement here, to be able to use \"control reaches end of non-void function\" warnings to detect gaps in the logic above.\n@@ -1758,7 +1812,7 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n                 // The scriptSig must be _exactly_ CScript(), otherwise we reintroduce malleability.\n                 return set_error(serror, SCRIPT_ERR_WITNESS_MALLEATED);\n             }\n-            if (!VerifyWitnessProgram(*witness, witnessversion, witnessprogram, flags, checker, serror)) {\n+            if (!VerifyWitnessProgram(*witness, witnessversion, witnessprogram, flags, checker, serror, /* is_p2sh */ false)) {\n                 return false;\n             }\n             // Bypass the cleanstack check at the end. The actual stack is obviously not clean\n@@ -1803,7 +1857,7 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n                     // reintroduce malleability.\n                     return set_error(serror, SCRIPT_ERR_WITNESS_MALLEATED_P2SH);\n                 }\n-                if (!VerifyWitnessProgram(*witness, witnessversion, witnessprogram, flags, checker, serror)) {\n+                if (!VerifyWitnessProgram(*witness, witnessversion, witnessprogram, flags, checker, serror, /* is_p2sh */ true)) {\n                     return false;\n                 }\n                 // Bypass the cleanstack check at the end. The actual stack is obviously not clean"
      },
      {
        "sha": "2ffe18dd92cf36961082a238713320e12d621273",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809",
        "patch": "@@ -121,6 +121,14 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot validation (BIP 341)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n@@ -167,6 +175,12 @@ static constexpr size_t WITNESS_V0_SCRIPTHASH_SIZE = 32;\n static constexpr size_t WITNESS_V0_KEYHASH_SIZE = 20;\n static constexpr size_t WITNESS_V1_TAPROOT_SIZE = 32;\n \n+static constexpr uint8_t TAPROOT_LEAF_MASK = 0xfe;\n+static constexpr size_t TAPROOT_CONTROL_BASE_SIZE = 33;\n+static constexpr size_t TAPROOT_CONTROL_NODE_SIZE = 32;\n+static constexpr size_t TAPROOT_CONTROL_MAX_NODE_COUNT = 128;\n+static constexpr size_t TAPROOT_CONTROL_MAX_SIZE = TAPROOT_CONTROL_BASE_SIZE + TAPROOT_CONTROL_NODE_SIZE * TAPROOT_CONTROL_MAX_NODE_COUNT;\n+\n template <class T>\n uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion, const PrecomputedTransactionData* cache = nullptr);\n "
      },
      {
        "sha": "77add5194c8018a0678851125157f0e57a53e6ef",
        "filename": "src/script/script_error.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809/src/script/script_error.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809/src/script/script_error.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script_error.cpp?ref=8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809",
        "patch": "@@ -73,6 +73,8 @@ std::string ScriptErrorString(const ScriptError serror)\n             return \"NOPx reserved for soft-fork upgrades\";\n         case SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM:\n             return \"Witness version reserved for soft-fork upgrades\";\n+        case SCRIPT_ERR_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION:\n+            return \"Taproot version reserved for soft-fork upgrades\";\n         case SCRIPT_ERR_PUBKEYTYPE:\n             return \"Public key is neither compressed or uncompressed\";\n         case SCRIPT_ERR_CLEANSTACK:\n@@ -97,6 +99,8 @@ std::string ScriptErrorString(const ScriptError serror)\n             return \"Invalid Schnorr signature hash type\";\n         case SCRIPT_ERR_SCHNORR_SIG:\n             return \"Invalid Schnorr signature\";\n+        case SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE:\n+            return \"Invalid Taproot control block size\";\n         case SCRIPT_ERR_OP_CODESEPARATOR:\n             return \"Using OP_CODESEPARATOR in non-witness script\";\n         case SCRIPT_ERR_SIG_FINDANDDELETE:"
      },
      {
        "sha": "59d3e565a5ad2ac4f71729584893e4b9d259f8b0",
        "filename": "src/script/script_error.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809/src/script/script_error.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809/src/script/script_error.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script_error.h?ref=8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809",
        "patch": "@@ -56,6 +56,7 @@ typedef enum ScriptError_t\n     /* softfork safeness */\n     SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS,\n     SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM,\n+    SCRIPT_ERR_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION,\n \n     /* segregated witness */\n     SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH,\n@@ -70,6 +71,7 @@ typedef enum ScriptError_t\n     SCRIPT_ERR_SCHNORR_SIG_SIZE,\n     SCRIPT_ERR_SCHNORR_SIG_HASHTYPE,\n     SCRIPT_ERR_SCHNORR_SIG,\n+    SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE,\n \n     /* Constant scriptCode */\n     SCRIPT_ERR_OP_CODESEPARATOR,"
      }
    ]
  },
  {
    "sha": "330de894a9a48515d9a473448b6c67adc3d188be",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozMzBkZTg5NGE5YTQ4NTE1ZDlhNDczNDQ4YjZjNjdhZGMzZDE4OGJl",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-09-11T21:33:52Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-13T00:18:15Z"
      },
      "message": "Use ScriptExecutionData to pass through annex hash\n\nInstead of recomputing the annex hash every time a signature is verified, compute it\nonce and cache it in a new ScriptExecutionData structure.",
      "tree": {
        "sha": "0634f0d38e9d8c0fd668c850aa6c701872ba3b8d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0634f0d38e9d8c0fd668c850aa6c701872ba3b8d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/330de894a9a48515d9a473448b6c67adc3d188be",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/330de894a9a48515d9a473448b6c67adc3d188be",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/330de894a9a48515d9a473448b6c67adc3d188be",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/330de894a9a48515d9a473448b6c67adc3d188be/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809"
      }
    ],
    "stats": {
      "total": 55,
      "additions": 39,
      "deletions": 16
    },
    "files": [
      {
        "sha": "a9d28c25d2aa54e6389989627642ee171243dd97",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 13,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/330de894a9a48515d9a473448b6c67adc3d188be/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/330de894a9a48515d9a473448b6c67adc3d188be/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=330de894a9a48515d9a473448b6c67adc3d188be",
        "patch": "@@ -371,7 +371,7 @@ static bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScrip\n     return true;\n }\n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)\n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptExecutionData& execdata, ScriptError* serror)\n {\n     static const CScriptNum bnZero(0);\n     static const CScriptNum bnOne(1);\n@@ -1159,6 +1159,12 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n     return set_success(serror);\n }\n \n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)\n+{\n+    ScriptExecutionData execdata;\n+    return EvalScript(stack, script, flags, checker, sigversion, execdata, serror);\n+}\n+\n namespace {\n \n /**\n@@ -1384,7 +1390,7 @@ static const CHashWriter HASHER_TAPBRANCH = TaggedHash(\"TapBranch\");\n static const CHashWriter HASHER_TAPTWEAK = TaggedHash(\"TapTweak\");\n \n template<typename T>\n-bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, uint32_t in_pos, uint8_t hash_type, SigVersion sigversion, const PrecomputedTransactionData& cache)\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, uint32_t in_pos, uint8_t hash_type, SigVersion sigversion, const PrecomputedTransactionData& cache)\n {\n     uint8_t ext_flag;\n     switch (sigversion) {\n@@ -1423,8 +1429,8 @@ bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, uint32_t in_pos, ui\n     }\n \n     // Data about the input/prevout being spent\n-    const auto& witstack = tx_to.vin[in_pos].scriptWitness.stack;\n-    bool have_annex = witstack.size() > 1 && witstack.back().size() > 0 && witstack.back()[0] == ANNEX_TAG;\n+    assert(execdata.m_annex_init);\n+    const bool have_annex = execdata.m_annex_present;\n     const uint8_t spend_type = (ext_flag << 1) + (have_annex ? 1 : 0); // The low bit indicates whether an annex is present.\n     ss << spend_type;\n     if (input_type == SIGHASH_ANYONECANPAY) {\n@@ -1435,7 +1441,7 @@ bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, uint32_t in_pos, ui\n         ss << in_pos;\n     }\n     if (have_annex) {\n-        ss << (CHashWriter(SER_GETHASH, 0) << witstack.back()).GetSHA256();\n+        ss << execdata.m_annex_hash;\n     }\n \n     // Data about the output (if only one).\n@@ -1553,7 +1559,7 @@ bool GenericTransactionSignatureChecker<T>::CheckECDSASignature(const std::vecto\n }\n \n template <class T>\n-bool GenericTransactionSignatureChecker<T>::CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey_in, SigVersion sigversion, ScriptError* serror) const\n+bool GenericTransactionSignatureChecker<T>::CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey_in, SigVersion sigversion, const ScriptExecutionData& execdata, ScriptError* serror) const\n {\n     assert(sigversion == SigVersion::TAPROOT);\n     // Schnorr signatures have 32-byte public keys. The caller is responsible for enforcing this.\n@@ -1569,7 +1575,7 @@ bool GenericTransactionSignatureChecker<T>::CheckSchnorrSignature(Span<const uns\n     }\n     uint256 sighash;\n     assert(this->txdata);\n-    if (!SignatureHashSchnorr(sighash, *txTo, nIn, hashtype, sigversion, *this->txdata)) {\n+    if (!SignatureHashSchnorr(sighash, execdata, *txTo, nIn, hashtype, sigversion, *this->txdata)) {\n         return set_error(serror, SCRIPT_ERR_SCHNORR_SIG_HASHTYPE);\n     }\n     if (!VerifySchnorrSignature(sig, pubkey, sighash)) return set_error(serror, SCRIPT_ERR_SCHNORR_SIG);\n@@ -1664,7 +1670,7 @@ bool GenericTransactionSignatureChecker<T>::CheckSequence(const CScriptNum& nSeq\n template class GenericTransactionSignatureChecker<CTransaction>;\n template class GenericTransactionSignatureChecker<CMutableTransaction>;\n \n-static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, ScriptExecutionData& execdata, ScriptError* serror)\n {\n     std::vector<valtype> stack{stack_span.begin(), stack_span.end()};\n \n@@ -1674,7 +1680,7 @@ static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CS\n     }\n \n     // Run the script interpreter.\n-    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror)) return false;\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, execdata, serror)) return false;\n \n     // Scripts inside witness implicitly require cleanstack behaviour\n     if (stack.size() != 1) return set_error(serror, SCRIPT_ERR_CLEANSTACK);\n@@ -1707,6 +1713,7 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n {\n     CScript exec_script; //!< Actually executed script (last stack item in P2WSH; implied P2PKH script in P2WPKH; leaf script in P2TR)\n     Span<const valtype> stack{witness.stack};\n+    ScriptExecutionData execdata;\n \n     if (witversion == 0) {\n         if (program.size() == WITNESS_V0_SCRIPTHASH_SIZE) {\n@@ -1721,14 +1728,14 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n             if (memcmp(hash_exec_script.begin(), program.data(), 32)) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n             }\n-            return ExecuteWitnessScript(stack, exec_script, flags, SigVersion::WITNESS_V0, checker, serror);\n+            return ExecuteWitnessScript(stack, exec_script, flags, SigVersion::WITNESS_V0, checker, execdata, serror);\n         } else if (program.size() == WITNESS_V0_KEYHASH_SIZE) {\n             // BIP141 P2WPKH: 20-byte witness v0 program (which encodes Hash160(pubkey))\n             if (stack.size() != 2) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH); // 2 items in witness\n             }\n             exec_script << OP_DUP << OP_HASH160 << program << OP_EQUALVERIFY << OP_CHECKSIG;\n-            return ExecuteWitnessScript(stack, exec_script, flags, SigVersion::WITNESS_V0, checker, serror);\n+            return ExecuteWitnessScript(stack, exec_script, flags, SigVersion::WITNESS_V0, checker, execdata, serror);\n         } else {\n             return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);\n         }\n@@ -1738,11 +1745,16 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n         if (stack.size() == 0) return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n         if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {\n             // Drop annex (this is non-standard; see IsWitnessStandard)\n-            SpanPopBack(stack);\n+            const valtype& annex = SpanPopBack(stack);\n+            execdata.m_annex_hash = (CHashWriter(SER_GETHASH, 0) << annex).GetSHA256();\n+            execdata.m_annex_present = true;\n+        } else {\n+            execdata.m_annex_present = false;\n         }\n+        execdata.m_annex_init = true;\n         if (stack.size() == 1) {\n             // Key path spending (stack size is 1 after removing optional annex)\n-            if (!checker.CheckSchnorrSignature(stack.front(), program, SigVersion::TAPROOT, serror)) {\n+            if (!checker.CheckSchnorrSignature(stack.front(), program, SigVersion::TAPROOT, execdata, serror)) {\n                 return false; // serror is set\n             }\n             return set_success(serror);"
      },
      {
        "sha": "55aa1f230b141609b0f0d55ba71510e91806f230",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 13,
        "deletions": 2,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/330de894a9a48515d9a473448b6c67adc3d188be/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/330de894a9a48515d9a473448b6c67adc3d188be/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=330de894a9a48515d9a473448b6c67adc3d188be",
        "patch": "@@ -170,6 +170,16 @@ enum class SigVersion\n     TAPROOT = 2,     //!< Witness v1 with 32-byte program, not BIP16 P2SH-wrapped, key path spending; see BIP 341\n };\n \n+struct ScriptExecutionData\n+{\n+    //! Whether m_annex_present and (when needed) m_annex_hash are initialized.\n+    bool m_annex_init = false;\n+    //! Whether an annex is present.\n+    bool m_annex_present;\n+    //! Hash of the annex data.\n+    uint256 m_annex_hash;\n+};\n+\n /** Signature hash sizes */\n static constexpr size_t WITNESS_V0_SCRIPTHASH_SIZE = 32;\n static constexpr size_t WITNESS_V0_KEYHASH_SIZE = 20;\n@@ -192,7 +202,7 @@ class BaseSignatureChecker\n         return false;\n     }\n \n-    virtual bool CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey, SigVersion sigversion, ScriptError* serror = nullptr) const\n+    virtual bool CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey, SigVersion sigversion, const ScriptExecutionData& execdata, ScriptError* serror = nullptr) const\n     {\n         return false;\n     }\n@@ -227,14 +237,15 @@ class GenericTransactionSignatureChecker : public BaseSignatureChecker\n     GenericTransactionSignatureChecker(const T* txToIn, unsigned int nInIn, const CAmount& amountIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(nullptr) {}\n     GenericTransactionSignatureChecker(const T* txToIn, unsigned int nInIn, const CAmount& amountIn, const PrecomputedTransactionData& txdataIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(&txdataIn) {}\n     bool CheckECDSASignature(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override;\n-    bool CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey, SigVersion sigversion, ScriptError* serror = nullptr) const override;\n+    bool CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey, SigVersion sigversion, const ScriptExecutionData& execdata, ScriptError* serror = nullptr) const override;\n     bool CheckLockTime(const CScriptNum& nLockTime) const override;\n     bool CheckSequence(const CScriptNum& nSequence) const override;\n };\n \n using TransactionSignatureChecker = GenericTransactionSignatureChecker<CTransaction>;\n using MutableTransactionSignatureChecker = GenericTransactionSignatureChecker<CMutableTransaction>;\n \n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptExecutionData& execdata, ScriptError* error = nullptr);\n bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* error = nullptr);\n bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror = nullptr);\n "
      },
      {
        "sha": "e121c89665b4f579b9119ff66fcc409899b5961a",
        "filename": "src/test/fuzz/signature_checker.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/330de894a9a48515d9a473448b6c67adc3d188be/src/test/fuzz/signature_checker.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/330de894a9a48515d9a473448b6c67adc3d188be/src/test/fuzz/signature_checker.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/signature_checker.cpp?ref=330de894a9a48515d9a473448b6c67adc3d188be",
        "patch": "@@ -33,7 +33,7 @@ class FuzzedSignatureChecker : public BaseSignatureChecker\n         return m_fuzzed_data_provider.ConsumeBool();\n     }\n \n-    bool CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey, SigVersion sigversion, ScriptError* serror = nullptr) const override\n+    bool CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey, SigVersion sigversion, const ScriptExecutionData& execdata, ScriptError* serror = nullptr) const override\n     {\n         return m_fuzzed_data_provider.ConsumeBool();\n     }"
      }
    ]
  },
  {
    "sha": "72422ce396b8eba7b1a72c171c2f07dae691d1b5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3MjQyMmNlMzk2YjhlYmE3YjFhNzJjMTcxYzJmMDdkYWU2OTFkMWI1",
    "commit": {
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2020-09-11T21:34:02Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-13T00:18:24Z"
      },
      "message": "Implement Tapscript script validation rules (BIP 342)\n\nThis adds a new `SigVersion::TAPSCRIPT`, makes the necessary interpreter\nchanges to make it implement BIP342, and uses them for leaf version 0xc0\nin Taproot script path spends.",
      "tree": {
        "sha": "d2aa2a75ed54579ed6ddac8f858cf3ca67605b48",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d2aa2a75ed54579ed6ddac8f858cf3ca67605b48"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/72422ce396b8eba7b1a72c171c2f07dae691d1b5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/72422ce396b8eba7b1a72c171c2f07dae691d1b5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/72422ce396b8eba7b1a72c171c2f07dae691d1b5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/72422ce396b8eba7b1a72c171c2f07dae691d1b5/comments",
    "author": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "330de894a9a48515d9a473448b6c67adc3d188be",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/330de894a9a48515d9a473448b6c67adc3d188be",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/330de894a9a48515d9a473448b6c67adc3d188be"
      }
    ],
    "stats": {
      "total": 253,
      "additions": 234,
      "deletions": 19
    },
    "files": [
      {
        "sha": "5735e7df6669eb89e5af9d26633cd6ac5d93ec59",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 168,
        "deletions": 18,
        "changes": 186,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/72422ce396b8eba7b1a72c171c2f07dae691d1b5/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/72422ce396b8eba7b1a72c171c2f07dae691d1b5/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=72422ce396b8eba7b1a72c171c2f07dae691d1b5",
        "patch": "@@ -342,13 +342,10 @@ class ConditionStack {\n };\n }\n \n-/** Helper for OP_CHECKSIG and OP_CHECKSIGVERIFY\n- *\n- * A return value of false means the script fails entirely. When true is returned, the\n- * fSuccess variable indicates whether the signature check itself succeeded.\n- */\n-static bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScript::const_iterator pbegincodehash, CScript::const_iterator pend, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& fSuccess)\n+static bool EvalChecksigPreTapscript(const valtype& vchSig, const valtype& vchPubKey, CScript::const_iterator pbegincodehash, CScript::const_iterator pend, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& fSuccess)\n {\n+    assert(sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0);\n+\n     // Subset of script starting at the most recent codeseparator\n     CScript scriptCode(pbegincodehash, pend);\n \n@@ -371,6 +368,66 @@ static bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScrip\n     return true;\n }\n \n+static bool EvalChecksigTapscript(const valtype& sig, const valtype& pubkey, ScriptExecutionData& execdata, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& success)\n+{\n+    assert(sigversion == SigVersion::TAPSCRIPT);\n+\n+    /*\n+     *  The following validation sequence is consensus critical. Please note how --\n+     *    upgradable public key versions precede other rules;\n+     *    the script execution fails when using empty signature with invalid public key;\n+     *    the script execution fails when using non-empty invalid signature.\n+     */\n+    success = !sig.empty();\n+    if (success) {\n+        // Implement the sigops/witnesssize ratio test.\n+        // Passing with an upgradable public key version is also counted.\n+        assert(execdata.m_validation_weight_left_init);\n+        execdata.m_validation_weight_left -= VALIDATION_WEIGHT_PER_SIGOP_PASSED;\n+        if (execdata.m_validation_weight_left < 0) {\n+            return set_error(serror, SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT);\n+        }\n+    }\n+    if (pubkey.size() == 0) {\n+        return set_error(serror, SCRIPT_ERR_PUBKEYTYPE);\n+    } else if (pubkey.size() == 32) {\n+        if (success && !checker.CheckSchnorrSignature(sig, pubkey, sigversion, execdata, serror)) {\n+            return false; // serror is set\n+        }\n+    } else {\n+        /*\n+         *  New public key version softforks should be defined before this `else` block.\n+         *  Generally, the new code should not do anything but failing the script execution. To avoid\n+         *  consensus bugs, it should not modify any existing values (including `success`).\n+         */\n+        if ((flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE) != 0) {\n+            return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE);\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+/** Helper for OP_CHECKSIG, OP_CHECKSIGVERIFY, and (in Tapscript) OP_CHECKSIGADD.\n+ *\n+ * A return value of false means the script fails entirely. When true is returned, the\n+ * success variable indicates whether the signature check itself succeeded.\n+ */\n+static bool EvalChecksig(const valtype& sig, const valtype& pubkey, CScript::const_iterator pbegincodehash, CScript::const_iterator pend, ScriptExecutionData& execdata, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& success)\n+{\n+    switch (sigversion) {\n+    case SigVersion::BASE:\n+    case SigVersion::WITNESS_V0:\n+        return EvalChecksigPreTapscript(sig, pubkey, pbegincodehash, pend, flags, checker, sigversion, serror, success);\n+    case SigVersion::TAPSCRIPT:\n+        return EvalChecksigTapscript(sig, pubkey, execdata, flags, checker, sigversion, serror, success);\n+    case SigVersion::TAPROOT:\n+        // Key path spending in Taproot has no script, so this is unreachable.\n+        break;\n+    }\n+    assert(false);\n+}\n+\n bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptExecutionData& execdata, ScriptError* serror)\n {\n     static const CScriptNum bnZero(0);\n@@ -381,6 +438,9 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n     // static const valtype vchZero(0);\n     static const valtype vchTrue(1, 1);\n \n+    // sigversion cannot be TAPROOT here, as it admits no script execution.\n+    assert(sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0 || sigversion == SigVersion::TAPSCRIPT);\n+\n     CScript::const_iterator pc = script.begin();\n     CScript::const_iterator pend = script.end();\n     CScript::const_iterator pbegincodehash = script.begin();\n@@ -389,15 +449,18 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n     ConditionStack vfExec;\n     std::vector<valtype> altstack;\n     set_error(serror, SCRIPT_ERR_UNKNOWN_ERROR);\n-    if (script.size() > MAX_SCRIPT_SIZE)\n+    if ((sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0) && script.size() > MAX_SCRIPT_SIZE) {\n         return set_error(serror, SCRIPT_ERR_SCRIPT_SIZE);\n+    }\n     int nOpCount = 0;\n     bool fRequireMinimal = (flags & SCRIPT_VERIFY_MINIMALDATA) != 0;\n+    uint32_t opcode_pos = 0;\n+    execdata.m_codeseparator_pos = 0xFFFFFFFFUL;\n+    execdata.m_codeseparator_pos_init = true;\n \n     try\n     {\n-        while (pc < pend)\n-        {\n+        for (; pc < pend; ++opcode_pos) {\n             bool fExec = vfExec.all_true();\n \n             //\n@@ -408,9 +471,12 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n             if (vchPushValue.size() > MAX_SCRIPT_ELEMENT_SIZE)\n                 return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n \n-            // Note how OP_RESERVED does not count towards the opcode limit.\n-            if (opcode > OP_16 && ++nOpCount > MAX_OPS_PER_SCRIPT)\n-                return set_error(serror, SCRIPT_ERR_OP_COUNT);\n+            if (sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0) {\n+                // Note how OP_RESERVED does not count towards the opcode limit.\n+                if (opcode > OP_16 && ++nOpCount > MAX_OPS_PER_SCRIPT) {\n+                    return set_error(serror, SCRIPT_ERR_OP_COUNT);\n+                }\n+            }\n \n             if (opcode == OP_CAT ||\n                 opcode == OP_SUBSTR ||\n@@ -568,6 +634,15 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                         if (stack.size() < 1)\n                             return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);\n                         valtype& vch = stacktop(-1);\n+                        // Tapscript requires minimal IF/NOTIF inputs as a consensus rule.\n+                        if (sigversion == SigVersion::TAPSCRIPT) {\n+                            // The input argument to the OP_IF and OP_NOTIF opcodes must be either\n+                            // exactly 0 (the empty vector) or exactly 1 (the one-byte vector with value 1).\n+                            if (vch.size() > 1 || (vch.size() == 1 && vch[0] != 1)) {\n+                                return set_error(serror, SCRIPT_ERR_TAPSCRIPT_MINIMALIF);\n+                            }\n+                        }\n+                        // Under witness v0 rules it is only a policy rule, enabled through SCRIPT_VERIFY_MINIMALIF.\n                         if (sigversion == SigVersion::WITNESS_V0 && (flags & SCRIPT_VERIFY_MINIMALIF)) {\n                             if (vch.size() > 1)\n                                 return set_error(serror, SCRIPT_ERR_MINIMALIF);\n@@ -1001,6 +1076,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n \n                     // Hash starts after the code separator\n                     pbegincodehash = pc;\n+                    execdata.m_codeseparator_pos = opcode_pos;\n                 }\n                 break;\n \n@@ -1015,7 +1091,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                     valtype& vchPubKey = stacktop(-1);\n \n                     bool fSuccess = true;\n-                    if (!EvalChecksig(vchSig, vchPubKey, pbegincodehash, pend, flags, checker, sigversion, serror, fSuccess)) return false;\n+                    if (!EvalChecksig(vchSig, vchPubKey, pbegincodehash, pend, execdata, flags, checker, sigversion, serror, fSuccess)) return false;\n                     popstack(stack);\n                     popstack(stack);\n                     stack.push_back(fSuccess ? vchTrue : vchFalse);\n@@ -1029,9 +1105,32 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                 }\n                 break;\n \n+                case OP_CHECKSIGADD:\n+                {\n+                    // OP_CHECKSIGADD is only available in Tapscript\n+                    if (sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0) return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+\n+                    // (sig num pubkey -- num)\n+                    if (stack.size() < 3) return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n+\n+                    const valtype& sig = stacktop(-3);\n+                    const CScriptNum num(stacktop(-2), fRequireMinimal);\n+                    const valtype& pubkey = stacktop(-1);\n+\n+                    bool success = true;\n+                    if (!EvalChecksig(sig, pubkey, pbegincodehash, pend, execdata, flags, checker, sigversion, serror, success)) return false;\n+                    popstack(stack);\n+                    popstack(stack);\n+                    popstack(stack);\n+                    stack.push_back((num + (success ? 1 : 0)).getvch());\n+                }\n+                break;\n+\n                 case OP_CHECKMULTISIG:\n                 case OP_CHECKMULTISIGVERIFY:\n                 {\n+                    if (sigversion == SigVersion::TAPSCRIPT) return set_error(serror, SCRIPT_ERR_TAPSCRIPT_CHECKMULTISIG);\n+\n                     // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n \n                     int i = 1;\n@@ -1392,10 +1491,19 @@ static const CHashWriter HASHER_TAPTWEAK = TaggedHash(\"TapTweak\");\n template<typename T>\n bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, uint32_t in_pos, uint8_t hash_type, SigVersion sigversion, const PrecomputedTransactionData& cache)\n {\n-    uint8_t ext_flag;\n+    uint8_t ext_flag, key_version;\n     switch (sigversion) {\n     case SigVersion::TAPROOT:\n         ext_flag = 0;\n+        // key_version is not used and left uninitialized.\n+        break;\n+    case SigVersion::TAPSCRIPT:\n+        ext_flag = 1;\n+        // key_version must be 0 for now, representing the current version of\n+        // 32-byte public keys in the tapscript signature opcode execution.\n+        // An upgradable public key version (with a size not 32-byte) may\n+        // request a different key_version with a new sigversion.\n+        key_version = 0;\n         break;\n     default:\n         assert(false);\n@@ -1452,6 +1560,15 @@ bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata\n         ss << sha_single_output.GetSHA256();\n     }\n \n+    // Additional data for BIP 342 signatures\n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        assert(execdata.m_tapleaf_hash_init);\n+        ss << execdata.m_tapleaf_hash;\n+        ss << key_version;\n+        assert(execdata.m_codeseparator_pos_init);\n+        ss << execdata.m_codeseparator_pos;\n+    }\n+\n     hash_out = ss.GetSHA256();\n     return true;\n }\n@@ -1561,9 +1678,13 @@ bool GenericTransactionSignatureChecker<T>::CheckECDSASignature(const std::vecto\n template <class T>\n bool GenericTransactionSignatureChecker<T>::CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey_in, SigVersion sigversion, const ScriptExecutionData& execdata, ScriptError* serror) const\n {\n-    assert(sigversion == SigVersion::TAPROOT);\n+    assert(sigversion == SigVersion::TAPROOT || sigversion == SigVersion::TAPSCRIPT);\n     // Schnorr signatures have 32-byte public keys. The caller is responsible for enforcing this.\n     assert(pubkey_in.size() == 32);\n+    // Note that in Tapscript evaluation, empty signatures are treated specially (invalid signature that does not\n+    // abort script execution). This is implemented in EvalChecksigTapscript, which won't invoke\n+    // CheckSchnorrSignature in that case. In other contexts, they are invalid like every other signature with\n+    // size different from 64 or 65.\n     if (sig.size() != 64 && sig.size() != 65) return set_error(serror, SCRIPT_ERR_SCHNORR_SIG_SIZE);\n \n     XOnlyPubKey pubkey{pubkey_in};\n@@ -1674,6 +1795,28 @@ static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CS\n {\n     std::vector<valtype> stack{stack_span.begin(), stack_span.end()};\n \n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        // OP_SUCCESSx processing overrides everything, including stack element size limits\n+        CScript::const_iterator pc = scriptPubKey.begin();\n+        while (pc < scriptPubKey.end()) {\n+            opcodetype opcode;\n+            if (!scriptPubKey.GetOp(pc, opcode)) {\n+                // Note how this condition would not be reached if an unknown OP_SUCCESSx was found\n+                return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+            }\n+            // New opcodes will be listed here. May use a different sigversion to modify existing opcodes.\n+            if (IsOpSuccess(opcode)) {\n+                if (flags & SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS) {\n+                    return set_error(serror, SCRIPT_ERR_DISCOURAGE_OP_SUCCESS);\n+                }\n+                return set_success(serror);\n+            }\n+        }\n+\n+        // Tapscript enforces initial stack size limits (altstack is empty here)\n+        if (stack.size() > MAX_STACK_SIZE) return set_error(serror, SCRIPT_ERR_STACK_SIZE);\n+    }\n+\n     // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\n     for (const valtype& elem : stack) {\n         if (elem.size() > MAX_SCRIPT_ELEMENT_SIZE) return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n@@ -1688,12 +1831,12 @@ static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CS\n     return true;\n }\n \n-static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const CScript& script)\n+static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const CScript& script, uint256& tapleaf_hash)\n {\n     const int path_len = (control.size() - TAPROOT_CONTROL_BASE_SIZE) / TAPROOT_CONTROL_NODE_SIZE;\n     const XOnlyPubKey p{uint256(std::vector<unsigned char>(control.begin() + 1, control.begin() + TAPROOT_CONTROL_BASE_SIZE))};\n     const XOnlyPubKey q{uint256(program)};\n-    uint256 tapleaf_hash = (CHashWriter(HASHER_TAPLEAF) << uint8_t(control[0] & TAPROOT_LEAF_MASK) << script).GetSHA256();\n+    tapleaf_hash = (CHashWriter(HASHER_TAPLEAF) << uint8_t(control[0] & TAPROOT_LEAF_MASK) << script).GetSHA256();\n     uint256 k = tapleaf_hash;\n     for (int i = 0; i < path_len; ++i) {\n         CHashWriter ss_branch{HASHER_TAPBRANCH};\n@@ -1766,9 +1909,16 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n             if (control.size() < TAPROOT_CONTROL_BASE_SIZE || control.size() > TAPROOT_CONTROL_MAX_SIZE || ((control.size() - TAPROOT_CONTROL_BASE_SIZE) % TAPROOT_CONTROL_NODE_SIZE) != 0) {\n                 return set_error(serror, SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE);\n             }\n-            if (!VerifyTaprootCommitment(control, program, exec_script)) {\n+            if (!VerifyTaprootCommitment(control, program, exec_script, execdata.m_tapleaf_hash)) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n             }\n+            execdata.m_tapleaf_hash_init = true;\n+            if ((control[0] & TAPROOT_LEAF_MASK) == TAPROOT_LEAF_TAPSCRIPT) {\n+                // Tapscript (leaf version 0xc0)\n+                execdata.m_validation_weight_left = ::GetSerializeSize(witness.stack, PROTOCOL_VERSION) + VALIDATION_WEIGHT_OFFSET;\n+                execdata.m_validation_weight_left_init = true;\n+                return ExecuteWitnessScript(stack, exec_script, flags, SigVersion::TAPSCRIPT, checker, execdata, serror);\n+            }\n             if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION) {\n                 return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION);\n             }"
      },
      {
        "sha": "c0c2b012c68563d34182a37194f16d29ab27f871",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 28,
        "deletions": 1,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/72422ce396b8eba7b1a72c171c2f07dae691d1b5/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/72422ce396b8eba7b1a72c171c2f07dae691d1b5/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=72422ce396b8eba7b1a72c171c2f07dae691d1b5",
        "patch": "@@ -86,6 +86,8 @@ enum\n     // \"Exactly one stack element must remain, and when interpreted as a boolean, it must be true\".\n     // (BIP62 rule 6)\n     // Note: CLEANSTACK should never be used without P2SH or WITNESS.\n+    // Note: WITNESS_V0 and TAPSCRIPT script execution have behavior similar to CLEANSTACK as part of their\n+    //       consensus rules. It is automatic there and does not need this flag.\n     SCRIPT_VERIFY_CLEANSTACK = (1U << 8),\n \n     // Verify CHECKLOCKTIMEVERIFY\n@@ -108,6 +110,8 @@ enum\n \n     // Segwit script only: Require the argument of OP_IF/NOTIF to be exactly 0x01 or empty vector\n     //\n+    // Note: TAPSCRIPT script execution has behavior similar to MINIMALIF as part of its consensus\n+    //       rules. It is automatic there and does not depend on this flag.\n     SCRIPT_VERIFY_MINIMALIF = (1U << 13),\n \n     // Signature(s) must be empty vector if a CHECK(MULTI)SIG operation failed\n@@ -122,13 +126,19 @@ enum\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n \n-    // Taproot validation (BIP 341)\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n     //\n     SCRIPT_VERIFY_TAPROOT = (1U << 17),\n \n     // Making unknown Taproot leaf versions non-standard\n     //\n     SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 19),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 20),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n@@ -168,16 +178,32 @@ enum class SigVersion\n     BASE = 0,        //!< Bare scripts and BIP16 P2SH-wrapped redeemscripts\n     WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n     TAPROOT = 2,     //!< Witness v1 with 32-byte program, not BIP16 P2SH-wrapped, key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with 32-byte program, not BIP16 P2SH-wrapped, script path spending, leaf version 0xc0; see BIP 342\n };\n \n struct ScriptExecutionData\n {\n+    //! Whether m_tapleaf_hash is initialized.\n+    bool m_tapleaf_hash_init = false;\n+    //! The tapleaf hash.\n+    uint256 m_tapleaf_hash;\n+\n+    //! Whether m_codeseparator_pos is initialized.\n+    bool m_codeseparator_pos_init = false;\n+    //! Opcode position of the last executed OP_CODESEPARATOR (or 0xFFFFFFFF if none executed).\n+    uint32_t m_codeseparator_pos;\n+\n     //! Whether m_annex_present and (when needed) m_annex_hash are initialized.\n     bool m_annex_init = false;\n     //! Whether an annex is present.\n     bool m_annex_present;\n     //! Hash of the annex data.\n     uint256 m_annex_hash;\n+\n+    //! Whether m_validation_weight_left is initialized.\n+    bool m_validation_weight_left_init = false;\n+    //! How much validation weight is left (decremented for every successful non-empty signature check).\n+    int64_t m_validation_weight_left;\n };\n \n /** Signature hash sizes */\n@@ -186,6 +212,7 @@ static constexpr size_t WITNESS_V0_KEYHASH_SIZE = 20;\n static constexpr size_t WITNESS_V1_TAPROOT_SIZE = 32;\n \n static constexpr uint8_t TAPROOT_LEAF_MASK = 0xfe;\n+static constexpr uint8_t TAPROOT_LEAF_TAPSCRIPT = 0xc0;\n static constexpr size_t TAPROOT_CONTROL_BASE_SIZE = 33;\n static constexpr size_t TAPROOT_CONTROL_NODE_SIZE = 32;\n static constexpr size_t TAPROOT_CONTROL_MAX_NODE_COUNT = 128;"
      },
      {
        "sha": "f31472e42d99cc9d21b0016978279b065ef55322",
        "filename": "src/script/script.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/72422ce396b8eba7b1a72c171c2f07dae691d1b5/src/script/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/72422ce396b8eba7b1a72c171c2f07dae691d1b5/src/script/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.cpp?ref=72422ce396b8eba7b1a72c171c2f07dae691d1b5",
        "patch": "@@ -140,6 +140,9 @@ std::string GetOpName(opcodetype opcode)\n     case OP_NOP9                   : return \"OP_NOP9\";\n     case OP_NOP10                  : return \"OP_NOP10\";\n \n+    // Opcode added by BIP 342 (Tapscript)\n+    case OP_CHECKSIGADD            : return \"OP_CHECKSIGADD\";\n+\n     case OP_INVALIDOPCODE          : return \"OP_INVALIDOPCODE\";\n \n     default:\n@@ -328,3 +331,11 @@ bool GetScriptOp(CScriptBase::const_iterator& pc, CScriptBase::const_iterator en\n     opcodeRet = static_cast<opcodetype>(opcode);\n     return true;\n }\n+\n+bool IsOpSuccess(const opcodetype& opcode)\n+{\n+    return opcode == 80 || opcode == 98 || (opcode >= 126 && opcode <= 129) ||\n+           (opcode >= 131 && opcode <= 134) || (opcode >= 137 && opcode <= 138) ||\n+           (opcode >= 141 && opcode <= 142) || (opcode >= 149 && opcode <= 153) ||\n+           (opcode >= 187 && opcode <= 254);\n+}"
      },
      {
        "sha": "974cde49840d95773d9bce9486cbabc5071bdee7",
        "filename": "src/script/script.h",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/72422ce396b8eba7b1a72c171c2f07dae691d1b5/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/72422ce396b8eba7b1a72c171c2f07dae691d1b5/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=72422ce396b8eba7b1a72c171c2f07dae691d1b5",
        "patch": "@@ -49,6 +49,12 @@ static const uint32_t LOCKTIME_MAX = 0xFFFFFFFFU;\n // has meanings independent of the script\n static constexpr unsigned int ANNEX_TAG = 0x50;\n \n+// Validation weight per passing signature (Tapscript only, see BIP 342).\n+static constexpr uint64_t VALIDATION_WEIGHT_PER_SIGOP_PASSED = 50;\n+\n+// How much weight budget is added to the witness size (Tapscript only, see BIP 342).\n+static constexpr uint64_t VALIDATION_WEIGHT_OFFSET = 50;\n+\n template <typename T>\n std::vector<unsigned char> ToByteVector(const T& in)\n {\n@@ -192,6 +198,9 @@ enum opcodetype\n     OP_NOP9 = 0xb8,\n     OP_NOP10 = 0xb9,\n \n+    // Opcode added by BIP 342 (Tapscript)\n+    OP_CHECKSIGADD = 0xba,\n+\n     OP_INVALIDOPCODE = 0xff,\n };\n \n@@ -560,4 +569,7 @@ struct CScriptWitness\n     std::string ToString() const;\n };\n \n+/** Test for OP_SUCCESSx opcodes as defined by BIP342. */\n+bool IsOpSuccess(const opcodetype& opcode);\n+\n #endif // BITCOIN_SCRIPT_SCRIPT_H"
      },
      {
        "sha": "fadc04262c3146e45a06eae2d7c6053bdbe2c49d",
        "filename": "src/script/script_error.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/72422ce396b8eba7b1a72c171c2f07dae691d1b5/src/script/script_error.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/72422ce396b8eba7b1a72c171c2f07dae691d1b5/src/script/script_error.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script_error.cpp?ref=72422ce396b8eba7b1a72c171c2f07dae691d1b5",
        "patch": "@@ -75,6 +75,10 @@ std::string ScriptErrorString(const ScriptError serror)\n             return \"Witness version reserved for soft-fork upgrades\";\n         case SCRIPT_ERR_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION:\n             return \"Taproot version reserved for soft-fork upgrades\";\n+        case SCRIPT_ERR_DISCOURAGE_OP_SUCCESS:\n+            return \"OP_SUCCESSx reserved for soft-fork upgrades\";\n+        case SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE:\n+            return \"Public key version reserved for soft-fork upgrades\";\n         case SCRIPT_ERR_PUBKEYTYPE:\n             return \"Public key is neither compressed or uncompressed\";\n         case SCRIPT_ERR_CLEANSTACK:\n@@ -101,6 +105,12 @@ std::string ScriptErrorString(const ScriptError serror)\n             return \"Invalid Schnorr signature\";\n         case SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE:\n             return \"Invalid Taproot control block size\";\n+        case SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT:\n+            return \"Too much signature validation relative to witness weight\";\n+        case SCRIPT_ERR_TAPSCRIPT_CHECKMULTISIG:\n+            return \"OP_CHECKMULTISIG(VERIFY) is not available in tapscript\";\n+        case SCRIPT_ERR_TAPSCRIPT_MINIMALIF:\n+            return \"OP_IF/NOTIF argument must be minimal in tapscript\";\n         case SCRIPT_ERR_OP_CODESEPARATOR:\n             return \"Using OP_CODESEPARATOR in non-witness script\";\n         case SCRIPT_ERR_SIG_FINDANDDELETE:"
      },
      {
        "sha": "b0716816138226ecd1d104e920ae3ac1c40b0ec7",
        "filename": "src/script/script_error.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/72422ce396b8eba7b1a72c171c2f07dae691d1b5/src/script/script_error.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/72422ce396b8eba7b1a72c171c2f07dae691d1b5/src/script/script_error.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script_error.h?ref=72422ce396b8eba7b1a72c171c2f07dae691d1b5",
        "patch": "@@ -57,6 +57,8 @@ typedef enum ScriptError_t\n     SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS,\n     SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM,\n     SCRIPT_ERR_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION,\n+    SCRIPT_ERR_DISCOURAGE_OP_SUCCESS,\n+    SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE,\n \n     /* segregated witness */\n     SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH,\n@@ -72,6 +74,9 @@ typedef enum ScriptError_t\n     SCRIPT_ERR_SCHNORR_SIG_HASHTYPE,\n     SCRIPT_ERR_SCHNORR_SIG,\n     SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE,\n+    SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT,\n+    SCRIPT_ERR_TAPSCRIPT_CHECKMULTISIG,\n+    SCRIPT_ERR_TAPSCRIPT_MINIMALIF,\n \n     /* Constant scriptCode */\n     SCRIPT_ERR_OP_CODESEPARATOR,"
      }
    ]
  },
  {
    "sha": "865d2c37e2e44678498b7f425b65e01b1e231cde",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4NjVkMmMzN2UyZTQ0Njc4NDk4YjdmNDI1YjY1ZTAxYjFlMjMxY2Rl",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-09-14T16:55:40Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-13T00:18:47Z"
      },
      "message": "--- [TAPROOT] Regtest activation and policy ---",
      "tree": {
        "sha": "d2aa2a75ed54579ed6ddac8f858cf3ca67605b48",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d2aa2a75ed54579ed6ddac8f858cf3ca67605b48"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/865d2c37e2e44678498b7f425b65e01b1e231cde",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/865d2c37e2e44678498b7f425b65e01b1e231cde",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/865d2c37e2e44678498b7f425b65e01b1e231cde",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/865d2c37e2e44678498b7f425b65e01b1e231cde/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "72422ce396b8eba7b1a72c171c2f07dae691d1b5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/72422ce396b8eba7b1a72c171c2f07dae691d1b5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/72422ce396b8eba7b1a72c171c2f07dae691d1b5"
      }
    ],
    "stats": {
      "total": 0,
      "additions": 0,
      "deletions": 0
    },
    "files": []
  },
  {
    "sha": "e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplOWEwMjFkN2U2YTQ1NGQ2MTBhNDVjYjliMzk5NWYwZDk2YTVmYmI2",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-09-11T21:34:10Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-13T00:18:47Z"
      },
      "message": "Make Taproot spends standard + policy limits\n\nThis adds a `TxoutType::WITNESS_V1_TAPROOT` for P2TR outputs, and permits spending\nthem in standardness rules. No corresponding `CTxDestination` is added for it,\nas that isn't needed until we want wallet integration. The taproot validation flags\nare also enabled for mempool transactions, and standardness rules are added\n(stack item size limit, no annexes).",
      "tree": {
        "sha": "010e43f4b0a219779aaa562f6636e20ac18e848c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/010e43f4b0a219779aaa562f6636e20ac18e848c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "865d2c37e2e44678498b7f425b65e01b1e231cde",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/865d2c37e2e44678498b7f425b65e01b1e231cde",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/865d2c37e2e44678498b7f425b65e01b1e231cde"
      }
    ],
    "stats": {
      "total": 68,
      "additions": 61,
      "deletions": 7
    },
    "files": [
      {
        "sha": "69f2b456f1eee7f5080461f588a53f976e8f3ffa",
        "filename": "src/policy/policy.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 1,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6/src/policy/policy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6/src/policy/policy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.cpp?ref=e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6",
        "patch": "@@ -9,7 +9,7 @@\n \n #include <consensus/validation.h>\n #include <coins.h>\n-\n+#include <span.h>\n \n CAmount GetDustThreshold(const CTxOut& txout, const CFeeRate& dustRelayFeeIn)\n {\n@@ -206,6 +206,7 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n         // get the scriptPubKey corresponding to this input:\n         CScript prevScript = prev.scriptPubKey;\n \n+        bool p2sh = false;\n         if (prevScript.IsPayToScriptHash()) {\n             std::vector <std::vector<unsigned char> > stack;\n             // If the scriptPubKey is P2SH, we try to extract the redeemScript casually by converting the scriptSig\n@@ -216,6 +217,7 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n             if (stack.empty())\n                 return false;\n             prevScript = CScript(stack.back().begin(), stack.back().end());\n+            p2sh = true;\n         }\n \n         int witnessversion = 0;\n@@ -237,6 +239,36 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check policy limits for Taproot spends:\n+        // - MAX_STANDARD_TAPSCRIPT_STACK_ITEM_SIZE limit for stack item size\n+        // - No annexes\n+        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !p2sh) {\n+            // Taproot spend (non-P2SH-wrapped, version 1, witness program size 32; see BIP 341)\n+            auto stack = MakeSpan(tx.vin[i].scriptWitness.stack);\n+            if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {\n+                // Annexes are nonstandard as long as no semantics are defined for them.\n+                return false;\n+            }\n+            if (stack.size() >= 2) {\n+                // Script path spend (2 or more stack elements after removing optional annex)\n+                const auto& control_block = SpanPopBack(stack);\n+                SpanPopBack(stack); // Ignore script\n+                if (control_block.empty()) return false; // Empty control block is invalid\n+                if ((control_block[0] & TAPROOT_LEAF_MASK) == TAPROOT_LEAF_TAPSCRIPT) {\n+                    // Leaf version 0xc0 (aka Tapscript, see BIP 342)\n+                    for (const auto& item : stack) {\n+                        if (item.size() > MAX_STANDARD_TAPSCRIPT_STACK_ITEM_SIZE) return false;\n+                    }\n+                }\n+            } else if (stack.size() == 1) {\n+                // Key path spend (1 stack element after removing optional annex)\n+                // (no policy rules apply)\n+            } else {\n+                // 0 stack elements; this is already invalid by consensus rules\n+                return false;\n+            }\n+        }\n     }\n     return true;\n }"
      },
      {
        "sha": "51d67b93906557ddd8a41733375c6dbaf5e73b58",
        "filename": "src/policy/policy.h",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6/src/policy/policy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6/src/policy/policy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.h?ref=e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6",
        "patch": "@@ -40,6 +40,8 @@ static const bool DEFAULT_PERMIT_BAREMULTISIG = true;\n static const unsigned int MAX_STANDARD_P2WSH_STACK_ITEMS = 100;\n /** The maximum size of each witness stack item in a standard P2WSH script */\n static const unsigned int MAX_STANDARD_P2WSH_STACK_ITEM_SIZE = 80;\n+/** The maximum size of each witness stack item in a standard BIP 342 script (Taproot, leaf version 0xc0) */\n+static const unsigned int MAX_STANDARD_TAPSCRIPT_STACK_ITEM_SIZE = 80;\n /** The maximum size of a standard witnessScript */\n static const unsigned int MAX_STANDARD_P2WSH_SCRIPT_SIZE = 3600;\n /** Min feerate for defining dust. Historically this has been based on the\n@@ -68,7 +70,11 @@ static constexpr unsigned int STANDARD_SCRIPT_VERIFY_FLAGS = MANDATORY_SCRIPT_VE\n                                                              SCRIPT_VERIFY_WITNESS |\n                                                              SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM |\n                                                              SCRIPT_VERIFY_WITNESS_PUBKEYTYPE |\n-                                                             SCRIPT_VERIFY_CONST_SCRIPTCODE;\n+                                                             SCRIPT_VERIFY_CONST_SCRIPTCODE |\n+                                                             SCRIPT_VERIFY_TAPROOT |\n+                                                             SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION |\n+                                                             SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS |\n+                                                             SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE;\n \n /** For convenience, standard but not mandatory verify flags. */\n static constexpr unsigned int STANDARD_NOT_MANDATORY_VERIFY_FLAGS = STANDARD_SCRIPT_VERIFY_FLAGS & ~MANDATORY_SCRIPT_VERIFY_FLAGS;"
      },
      {
        "sha": "0e6864d547a7f08cfd9262f6602545bf2587c165",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6",
        "patch": "@@ -111,6 +111,7 @@ static bool SignStep(const SigningProvider& provider, const BaseSignatureCreator\n     case TxoutType::NONSTANDARD:\n     case TxoutType::NULL_DATA:\n     case TxoutType::WITNESS_UNKNOWN:\n+    case TxoutType::WITNESS_V1_TAPROOT:\n         return false;\n     case TxoutType::PUBKEY:\n         if (!CreateSig(creator, sigdata, provider, sig, CPubKey(vSolutions[0]), scriptPubKey, sigversion)) return false;"
      },
      {
        "sha": "f2f81664f622f0d5c181dbda125bb88b09aefa97",
        "filename": "src/script/standard.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6/src/script/standard.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6/src/script/standard.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.cpp?ref=e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6",
        "patch": "@@ -55,6 +55,7 @@ std::string GetTxnOutputType(TxoutType t)\n     case TxoutType::NULL_DATA: return \"nulldata\";\n     case TxoutType::WITNESS_V0_KEYHASH: return \"witness_v0_keyhash\";\n     case TxoutType::WITNESS_V0_SCRIPTHASH: return \"witness_v0_scripthash\";\n+    case TxoutType::WITNESS_V1_TAPROOT: return \"witness_v1_taproot\";\n     case TxoutType::WITNESS_UNKNOWN: return \"witness_unknown\";\n     } // no default case, so the compiler can warn about missing cases\n     assert(false);\n@@ -130,6 +131,11 @@ TxoutType Solver(const CScript& scriptPubKey, std::vector<std::vector<unsigned c\n             vSolutionsRet.push_back(witnessprogram);\n             return TxoutType::WITNESS_V0_SCRIPTHASH;\n         }\n+        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE) {\n+            vSolutionsRet.push_back(std::vector<unsigned char>{(unsigned char)witnessversion});\n+            vSolutionsRet.push_back(std::move(witnessprogram));\n+            return TxoutType::WITNESS_V1_TAPROOT;\n+        }\n         if (witnessversion != 0) {\n             vSolutionsRet.push_back(std::vector<unsigned char>{(unsigned char)witnessversion});\n             vSolutionsRet.push_back(std::move(witnessprogram));\n@@ -203,7 +209,7 @@ bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)\n         std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());\n         addressRet = hash;\n         return true;\n-    } else if (whichType == TxoutType::WITNESS_UNKNOWN) {\n+    } else if (whichType == TxoutType::WITNESS_UNKNOWN || whichType == TxoutType::WITNESS_V1_TAPROOT) {\n         WitnessUnknown unk;\n         unk.version = vSolutions[0][0];\n         std::copy(vSolutions[1].begin(), vSolutions[1].end(), unk.program);"
      },
      {
        "sha": "721203385ec0bf1f1e85e4ce2f5e275d14548a7f",
        "filename": "src/script/standard.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6/src/script/standard.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6/src/script/standard.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.h?ref=e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6",
        "patch": "@@ -129,6 +129,7 @@ enum class TxoutType {\n     NULL_DATA, //!< unspendable OP_RETURN script that carries data\n     WITNESS_V0_SCRIPTHASH,\n     WITNESS_V0_KEYHASH,\n+    WITNESS_V1_TAPROOT,\n     WITNESS_UNKNOWN, //!< Only for Witness versions not already defined above\n };\n \n@@ -206,7 +207,8 @@ struct WitnessUnknown\n  *  * ScriptHash: TxoutType::SCRIPTHASH destination (P2SH)\n  *  * WitnessV0ScriptHash: TxoutType::WITNESS_V0_SCRIPTHASH destination (P2WSH)\n  *  * WitnessV0KeyHash: TxoutType::WITNESS_V0_KEYHASH destination (P2WPKH)\n- *  * WitnessUnknown: TxoutType::WITNESS_UNKNOWN destination (P2W???)\n+ *  * WitnessUnknown: TxoutType::WITNESS_UNKNOWN/WITNESS_V1_TAPROOT destination (P2W???)\n+ *    (taproot outputs do not require their own type as long as no wallet support exists)\n  *  A CTxDestination is the internal data type encoded in a bitcoin address\n  */\n typedef boost::variant<CNoDestination, PKHash, ScriptHash, WitnessV0ScriptHash, WitnessV0KeyHash, WitnessUnknown> CTxDestination;"
      },
      {
        "sha": "7dcab46ad32dfbc9d67796a2d54b7a5b369d6f96",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6",
        "patch": "@@ -932,6 +932,7 @@ static std::string RecurseImportData(const CScript& script, ImportData& import_d\n         return \"unspendable script\";\n     case TxoutType::NONSTANDARD:\n     case TxoutType::WITNESS_UNKNOWN:\n+    case TxoutType::WITNESS_V1_TAPROOT:\n     default:\n         return \"unrecognized script\";\n     }"
      },
      {
        "sha": "b7c70dac3a7be1fc922e339af4c662f9cadb7523",
        "filename": "src/wallet/scriptpubkeyman.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6/src/wallet/scriptpubkeyman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6/src/wallet/scriptpubkeyman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/scriptpubkeyman.cpp?ref=e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6",
        "patch": "@@ -96,6 +96,7 @@ IsMineResult IsMineInner(const LegacyScriptPubKeyMan& keystore, const CScript& s\n     case TxoutType::NONSTANDARD:\n     case TxoutType::NULL_DATA:\n     case TxoutType::WITNESS_UNKNOWN:\n+    case TxoutType::WITNESS_V1_TAPROOT:\n         break;\n     case TxoutType::PUBKEY:\n         keyID = CPubKey(vSolutions[0]).GetID();"
      },
      {
        "sha": "29735b0fb3e6f2461aca5ca8d4cdff904dc21c85",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 8,
        "deletions": 3,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6",
        "patch": "@@ -55,6 +55,7 @@\n     MAX_SCRIPT_ELEMENT_SIZE,\n     OP_0,\n     OP_1,\n+    OP_2,\n     OP_16,\n     OP_2DROP,\n     OP_CHECKMULTISIG,\n@@ -1400,7 +1401,11 @@ def test_segwit_versions(self):\n         assert_equal(len(self.nodes[1].getrawmempool()), 0)\n         for version in list(range(OP_1, OP_16 + 1)) + [OP_0]:\n             # First try to spend to a future version segwit script_pubkey.\n-            script_pubkey = CScript([CScriptOp(version), witness_hash])\n+            if version == OP_1:\n+                # Don't use 32-byte v1 witness (used by Taproot; see BIP 341)\n+                script_pubkey = CScript([CScriptOp(version), witness_hash + b'\\x00'])\n+            else:\n+                script_pubkey = CScript([CScriptOp(version), witness_hash])\n             tx.vin = [CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\")]\n             tx.vout = [CTxOut(self.utxo[0].nValue - 1000, script_pubkey)]\n             tx.rehash()\n@@ -1413,9 +1418,9 @@ def test_segwit_versions(self):\n         self.sync_blocks()\n         assert len(self.nodes[0].getrawmempool()) == 0\n \n-        # Finally, verify that version 0 -> version 1 transactions\n+        # Finally, verify that version 0 -> version 2 transactions\n         # are standard\n-        script_pubkey = CScript([CScriptOp(OP_1), witness_hash])\n+        script_pubkey = CScript([CScriptOp(OP_2), witness_hash])\n         tx2 = CTransaction()\n         tx2.vin = [CTxIn(COutPoint(tx.sha256, 0), b\"\")]\n         tx2.vout = [CTxOut(tx.vout[0].nValue - 1000, script_pubkey)]"
      }
    ]
  },
  {
    "sha": "d7ff237f2996a4c11fdf9399187c2d2b26bf9809",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkN2ZmMjM3ZjI5OTZhNGMxMWZkZjkzOTkxODdjMmQyYjI2YmY5ODA5",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-09-11T21:34:17Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-13T00:18:47Z"
      },
      "message": "Activate Taproot/Tapscript on regtest (BIP 341, BIP 342)\n\nDefine a versionbits-based activation for the new consensus rules on regtest.\nNo activation or activation mechanism is defined for testnet or mainnet.",
      "tree": {
        "sha": "79de8e7660ed32cf50e94bc340e17bca14ab4bd0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/79de8e7660ed32cf50e94bc340e17bca14ab4bd0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d7ff237f2996a4c11fdf9399187c2d2b26bf9809",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d7ff237f2996a4c11fdf9399187c2d2b26bf9809",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d7ff237f2996a4c11fdf9399187c2d2b26bf9809",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d7ff237f2996a4c11fdf9399187c2d2b26bf9809/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6"
      }
    ],
    "stats": {
      "total": 38,
      "additions": 37,
      "deletions": 1
    },
    "files": [
      {
        "sha": "a34bf350fce5cb2bab9cc15e33417158934b7774",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d7ff237f2996a4c11fdf9399187c2d2b26bf9809/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d7ff237f2996a4c11fdf9399187c2d2b26bf9809/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=d7ff237f2996a4c11fdf9399187c2d2b26bf9809",
        "patch": "@@ -86,6 +86,11 @@ class CMainParams : public CChainParams {\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008\n \n+        // Deployment of Taproot (BIPs 340-342)\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].bit = 2;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nStartTime = 1199145601; // January 1, 2008\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nTimeout = 1230767999; // December 31, 2008\n+\n         // The best chain should have at least this much work.\n         consensus.nMinimumChainWork = uint256S(\"0x00000000000000000000000000000000000000000e1ab5ec9348e9f4b8eb8154\");\n \n@@ -197,6 +202,11 @@ class CTestNetParams : public CChainParams {\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008\n \n+        // Deployment of Taproot (BIPs 340-342)\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].bit = 2;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nStartTime = 1199145601; // January 1, 2008\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nTimeout = 1230767999; // December 31, 2008\n+\n         // The best chain should have at least this much work.\n         consensus.nMinimumChainWork = uint256S(\"0x0000000000000000000000000000000000000000000001495c1d5a01e2af8a23\");\n \n@@ -380,6 +390,9 @@ class CRegTestParams : public CChainParams {\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit = 28;\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 0;\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].bit = 2;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nStartTime = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nTimeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n \n         // The best chain should have at least this much work.\n         consensus.nMinimumChainWork = uint256S(\"0x00\");"
      },
      {
        "sha": "932f0d2c6055d336f89c2439f887c7a15ff643af",
        "filename": "src/consensus/params.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d7ff237f2996a4c11fdf9399187c2d2b26bf9809/src/consensus/params.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d7ff237f2996a4c11fdf9399187c2d2b26bf9809/src/consensus/params.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/params.h?ref=d7ff237f2996a4c11fdf9399187c2d2b26bf9809",
        "patch": "@@ -14,6 +14,7 @@ namespace Consensus {\n enum DeploymentPos\n {\n     DEPLOYMENT_TESTDUMMY,\n+    DEPLOYMENT_TAPROOT, // Deployment of Schnorr/Taproot (BIPs 340-342)\n     // NOTE: Also add new deployments to VersionBitsDeploymentInfo in versionbits.cpp\n     MAX_VERSION_BITS_DEPLOYMENTS\n };"
      },
      {
        "sha": "ef8d59266d115328fe3039a6cad0f8086bcc0c1e",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d7ff237f2996a4c11fdf9399187c2d2b26bf9809/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d7ff237f2996a4c11fdf9399187c2d2b26bf9809/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=d7ff237f2996a4c11fdf9399187c2d2b26bf9809",
        "patch": "@@ -1355,6 +1355,7 @@ RPCHelpMan getblockchaininfo()\n     BuriedForkDescPushBack(softforks, \"csv\", consensusParams.CSVHeight);\n     BuriedForkDescPushBack(softforks, \"segwit\", consensusParams.SegwitHeight);\n     BIP9SoftForkDescPushBack(softforks, \"testdummy\", consensusParams, Consensus::DEPLOYMENT_TESTDUMMY);\n+    BIP9SoftForkDescPushBack(softforks, \"taproot\", consensusParams, Consensus::DEPLOYMENT_TAPROOT);\n     obj.pushKV(\"softforks\",             softforks);\n \n     obj.pushKV(\"warnings\", GetWarnings(false).original);"
      },
      {
        "sha": "0b78ba677edb360f583e81d7dccb982582ad5154",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d7ff237f2996a4c11fdf9399187c2d2b26bf9809/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d7ff237f2996a4c11fdf9399187c2d2b26bf9809/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=d7ff237f2996a4c11fdf9399187c2d2b26bf9809",
        "patch": "@@ -1920,6 +1920,11 @@ static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consens\n         flags |= SCRIPT_VERIFY_CHECKSEQUENCEVERIFY;\n     }\n \n+    // Start enforcing Taproot using versionbits logic.\n+    if (VersionBitsState(pindex->pprev, consensusparams, Consensus::DEPLOYMENT_TAPROOT, versionbitscache) == ThresholdState::ACTIVE) {\n+        flags |= SCRIPT_VERIFY_TAPROOT;\n+    }\n+\n     // Start enforcing BIP147 NULLDUMMY (activated simultaneously with segwit)\n     if (IsWitnessEnabled(pindex->pprev, consensusparams)) {\n         flags |= SCRIPT_VERIFY_NULLDUMMY;"
      },
      {
        "sha": "20dfc044ca6595b8e2feb26e4528fb2bc25efe2b",
        "filename": "src/versionbitsinfo.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d7ff237f2996a4c11fdf9399187c2d2b26bf9809/src/versionbitsinfo.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d7ff237f2996a4c11fdf9399187c2d2b26bf9809/src/versionbitsinfo.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/versionbitsinfo.cpp?ref=d7ff237f2996a4c11fdf9399187c2d2b26bf9809",
        "patch": "@@ -11,4 +11,8 @@ const struct VBDeploymentInfo VersionBitsDeploymentInfo[Consensus::MAX_VERSION_B\n         /*.name =*/ \"testdummy\",\n         /*.gbt_force =*/ true,\n     },\n+    {\n+        /*.name =*/ \"taproot\",\n+        /*.gbt_force =*/ true,\n+    },\n };"
      },
      {
        "sha": "f96567740837463303cf319ee8117c223c5944d0",
        "filename": "test/functional/rpc_blockchain.py",
        "status": "modified",
        "additions": 13,
        "deletions": 1,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d7ff237f2996a4c11fdf9399187c2d2b26bf9809/test/functional/rpc_blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d7ff237f2996a4c11fdf9399187c2d2b26bf9809/test/functional/rpc_blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_blockchain.py?ref=d7ff237f2996a4c11fdf9399187c2d2b26bf9809",
        "patch": "@@ -146,7 +146,19 @@ def _test_getblockchaininfo(self):\n                         'possible': True,\n                     },\n                 },\n-                'active': False}\n+                'active': False\n+            },\n+            'taproot': {\n+                'type': 'bip9',\n+                'bip9': {\n+                    'status': 'active',\n+                    'start_time': -1,\n+                    'timeout': 9223372036854775807,\n+                    'since': 0\n+                },\n+                'height': 0,\n+                'active': True\n+            }\n         })\n \n     def _test_getchaintxstats(self):"
      }
    ]
  },
  {
    "sha": "206fb180ec6ee5f916afc6f574000d716daf79b7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMDZmYjE4MGVjNmVlNWY5MTZhZmM2ZjU3NDAwMGQ3MTZkYWY3OWI3",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-09-14T16:53:53Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-13T00:18:47Z"
      },
      "message": "--- [TAPROOT] Tests ---",
      "tree": {
        "sha": "79de8e7660ed32cf50e94bc340e17bca14ab4bd0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/79de8e7660ed32cf50e94bc340e17bca14ab4bd0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/206fb180ec6ee5f916afc6f574000d716daf79b7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/206fb180ec6ee5f916afc6f574000d716daf79b7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/206fb180ec6ee5f916afc6f574000d716daf79b7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/206fb180ec6ee5f916afc6f574000d716daf79b7/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d7ff237f2996a4c11fdf9399187c2d2b26bf9809",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d7ff237f2996a4c11fdf9399187c2d2b26bf9809",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d7ff237f2996a4c11fdf9399187c2d2b26bf9809"
      }
    ],
    "stats": {
      "total": 0,
      "additions": 0,
      "deletions": 0
    },
    "files": []
  },
  {
    "sha": "3c226639eb134314a0640d34e4ccb6148dbde22f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozYzIyNjYzOWViMTM0MzE0YTA2NDBkMzRlNGNjYjYxNDhkYmRlMjJm",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-09-11T21:34:24Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-13T00:18:47Z"
      },
      "message": "tests: add BIP340 Schnorr signature support to test framework\n\nAdd a pure Python implementation of BIP340 signing and verification, tested against\nthe BIP's test vectors.",
      "tree": {
        "sha": "c9cef5d292401c93edab0cb4fc1456d9d09d240b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c9cef5d292401c93edab0cb4fc1456d9d09d240b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3c226639eb134314a0640d34e4ccb6148dbde22f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3c226639eb134314a0640d34e4ccb6148dbde22f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3c226639eb134314a0640d34e4ccb6148dbde22f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3c226639eb134314a0640d34e4ccb6148dbde22f/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "206fb180ec6ee5f916afc6f574000d716daf79b7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/206fb180ec6ee5f916afc6f574000d716daf79b7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/206fb180ec6ee5f916afc6f574000d716daf79b7"
      }
    ],
    "stats": {
      "total": 210,
      "additions": 204,
      "deletions": 6
    },
    "files": [
      {
        "sha": "e068322deb3b7a65d746aceea809983cf545bb70",
        "filename": "test/functional/test_framework/bip340_test_vectors.csv",
        "status": "added",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3c226639eb134314a0640d34e4ccb6148dbde22f/test/functional/test_framework/bip340_test_vectors.csv",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3c226639eb134314a0640d34e4ccb6148dbde22f/test/functional/test_framework/bip340_test_vectors.csv",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/bip340_test_vectors.csv?ref=3c226639eb134314a0640d34e4ccb6148dbde22f",
        "patch": "@@ -0,0 +1,16 @@\n+index,secret key,public key,aux_rand,message,signature,verification result,comment\n+0,0000000000000000000000000000000000000000000000000000000000000003,F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BCE036F9,0000000000000000000000000000000000000000000000000000000000000000,0000000000000000000000000000000000000000000000000000000000000000,E907831F80848D1069A5371B402410364BDF1C5F8307B0084C55F1CE2DCA821525F66A4A85EA8B71E482A74F382D2CE5EBEEE8FDB2172F477DF4900D310536C0,TRUE,\n+1,B7E151628AED2A6ABF7158809CF4F3C762E7160F38B4DA56A784D9045190CFEF,DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659,0000000000000000000000000000000000000000000000000000000000000001,243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89,6896BD60EEAE296DB48A229FF71DFE071BDE413E6D43F917DC8DCF8C78DE33418906D11AC976ABCCB20B091292BFF4EA897EFCB639EA871CFA95F6DE339E4B0A,TRUE,\n+2,C90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B14E5C9,DD308AFEC5777E13121FA72B9CC1B7CC0139715309B086C960E18FD969774EB8,C87AA53824B4D7AE2EB035A2B5BBBCCC080E76CDC6D1692C4B0B62D798E6D906,7E2D58D8B3BCDF1ABADEC7829054F90DDA9805AAB56C77333024B9D0A508B75C,5831AAEED7B44BB74E5EAB94BA9D4294C49BCF2A60728D8B4C200F50DD313C1BAB745879A5AD954A72C45A91C3A51D3C7ADEA98D82F8481E0E1E03674A6F3FB7,TRUE,\n+3,0B432B2677937381AEF05BB02A66ECD012773062CF3FA2549E44F58ED2401710,25D1DFF95105F5253C4022F628A996AD3A0D95FBF21D468A1B33F8C160D8F517,FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF,FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF,7EB0509757E246F19449885651611CB965ECC1A187DD51B64FDA1EDC9637D5EC97582B9CB13DB3933705B32BA982AF5AF25FD78881EBB32771FC5922EFC66EA3,TRUE,test fails if msg is reduced modulo p or n\n+4,,D69C3509BB99E412E68B0FE8544E72837DFA30746D8BE2AA65975F29D22DC7B9,,4DF3C3F68FCC83B27E9D42C90431A72499F17875C81A599B566C9889B9696703,00000000000000000000003B78CE563F89A0ED9414F5AA28AD0D96D6795F9C6376AFB1548AF603B3EB45C9F8207DEE1060CB71C04E80F593060B07D28308D7F4,TRUE,\n+5,,EEFDEA4CDB677750A420FEE807EACF21EB9898AE79B9768766E4FAA04A2D4A34,,243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89,6CFF5C3BA86C69EA4B7376F31A9BCB4F74C1976089B2D9963DA2E5543E17776969E89B4C5564D00349106B8497785DD7D1D713A8AE82B32FA79D5F7FC407D39B,FALSE,public key not on the curve\n+6,,DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659,,243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89,FFF97BD5755EEEA420453A14355235D382F6472F8568A18B2F057A14602975563CC27944640AC607CD107AE10923D9EF7A73C643E166BE5EBEAFA34B1AC553E2,FALSE,has_even_y(R) is false\n+7,,DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659,,243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89,1FA62E331EDBC21C394792D2AB1100A7B432B013DF3F6FF4F99FCB33E0E1515F28890B3EDB6E7189B630448B515CE4F8622A954CFE545735AAEA5134FCCDB2BD,FALSE,negated message\n+8,,DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659,,243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89,6CFF5C3BA86C69EA4B7376F31A9BCB4F74C1976089B2D9963DA2E5543E177769961764B3AA9B2FFCB6EF947B6887A226E8D7C93E00C5ED0C1834FF0D0C2E6DA6,FALSE,negated s value\n+9,,DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659,,243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89,0000000000000000000000000000000000000000000000000000000000000000123DDA8328AF9C23A94C1FEECFD123BA4FB73476F0D594DCB65C6425BD186051,FALSE,sG - eP is infinite. Test fails in single verification if has_even_y(inf) is defined as true and x(inf) as 0\n+10,,DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659,,243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89,00000000000000000000000000000000000000000000000000000000000000017615FBAF5AE28864013C099742DEADB4DBA87F11AC6754F93780D5A1837CF197,FALSE,sG - eP is infinite. Test fails in single verification if has_even_y(inf) is defined as true and x(inf) as 1\n+11,,DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659,,243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89,4A298DACAE57395A15D0795DDBFD1DCB564DA82B0F269BC70A74F8220429BA1D69E89B4C5564D00349106B8497785DD7D1D713A8AE82B32FA79D5F7FC407D39B,FALSE,sig[0:32] is not an X coordinate on the curve\n+12,,DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659,,243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89,FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F69E89B4C5564D00349106B8497785DD7D1D713A8AE82B32FA79D5F7FC407D39B,FALSE,sig[0:32] is equal to field size\n+13,,DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659,,243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89,6CFF5C3BA86C69EA4B7376F31A9BCB4F74C1976089B2D9963DA2E5543E177769FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141,FALSE,sig[32:64] is equal to curve order\n+14,,FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC30,,243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89,6CFF5C3BA86C69EA4B7376F31A9BCB4F74C1976089B2D9963DA2E5543E17776969E89B4C5564D00349106B8497785DD7D1D713A8AE82B32FA79D5F7FC407D39B,FALSE,public key is not a valid X coordinate because it exceeds the field size"
      },
      {
        "sha": "c9f09a31aa7f802e7da12639da3ca08751fb00b9",
        "filename": "test/functional/test_framework/key.py",
        "status": "modified",
        "additions": 187,
        "deletions": 6,
        "changes": 193,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3c226639eb134314a0640d34e4ccb6148dbde22f/test/functional/test_framework/key.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3c226639eb134314a0640d34e4ccb6148dbde22f/test/functional/test_framework/key.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/key.py?ref=3c226639eb134314a0640d34e4ccb6148dbde22f",
        "patch": "@@ -1,15 +1,29 @@\n-# Copyright (c) 2019 Pieter Wuille\n+# Copyright (c) 2019-2020 Pieter Wuille\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test-only secp256k1 elliptic curve implementation\n \n WARNING: This code is slow, uses bad randomness, does not properly protect\n keys, and is trivially vulnerable to side channel attacks. Do not use for\n anything but tests.\"\"\"\n+import csv\n+import hashlib\n+import os\n import random\n+import sys\n+import unittest\n \n from .util import modinv\n \n+def TaggedHash(tag, data):\n+    ss = hashlib.sha256(tag.encode('utf-8')).digest()\n+    ss += ss\n+    ss += data\n+    return hashlib.sha256(ss).digest()\n+\n+def xor_bytes(b0, b1):\n+    return bytes(x ^ y for (x, y) in zip(b0, b1))\n+\n def jacobi_symbol(n, k):\n     \"\"\"Compute the Jacobi symbol of n modulo k\n \n@@ -68,6 +82,10 @@ def affine(self, p1):\n         inv_3 = (inv_2 * inv) % self.p\n         return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n \n+    def has_even_y(self, p1):\n+        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n+        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n+\n     def negate(self, p1):\n         \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n         x1, y1, z1 = p1\n@@ -86,13 +104,13 @@ def is_x_coord(self, x):\n         return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n \n     def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point.\"\"\"\n+        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n         x_3 = pow(x, 3, self.p)\n         v = x_3 + self.a * x + self.b\n         y = modsqrt(v, self.p)\n         if y is None:\n             return None\n-        return (x, y, 1)\n+        return (x, self.p - y if y & 1 else y, 1)\n \n     def double(self, p1):\n         \"\"\"Double a Jacobian tuple p1\n@@ -197,7 +215,8 @@ def mul(self, ps):\n                     r = self.add(r, p)\n         return r\n \n-SECP256K1 = EllipticCurve(2**256 - 2**32 - 977, 0, 7)\n+SECP256K1_FIELD_SIZE = 2**256 - 2**32 - 977\n+SECP256K1 = EllipticCurve(SECP256K1_FIELD_SIZE, 0, 7)\n SECP256K1_G = (0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798, 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8, 1)\n SECP256K1_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n SECP256K1_ORDER_HALF = SECP256K1_ORDER // 2\n@@ -223,7 +242,7 @@ def set(self, data):\n                 p = SECP256K1.lift_x(x)\n                 # if the oddness of the y co-ord isn't correct, find the other\n                 # valid y\n-                if (p[1] & 1) != (data[0] & 1):\n+                if data[0] & 1:\n                     p = SECP256K1.negate(p)\n                 self.p = p\n                 self.valid = True\n@@ -307,6 +326,10 @@ def verify_ecdsa(self, sig, msg, low_s=True):\n             return False\n         return True\n \n+def generate_privkey():\n+    \"\"\"Generate a valid random 32-byte private key.\"\"\"\n+    return random.randrange(1, SECP256K1_ORDER).to_bytes(32, 'big')\n+\n class ECKey():\n     \"\"\"A secp256k1 private key\"\"\"\n \n@@ -324,7 +347,7 @@ def set(self, secret, compressed):\n \n     def generate(self, compressed=True):\n         \"\"\"Generate a random private key (compressed or uncompressed).\"\"\"\n-        self.set(random.randrange(1, SECP256K1_ORDER).to_bytes(32, 'big'), compressed)\n+        self.set(generate_privkey(), compressed)\n \n     def get_bytes(self):\n         \"\"\"Retrieve the 32-byte representation of this key.\"\"\"\n@@ -369,3 +392,161 @@ def sign_ecdsa(self, msg, low_s=True):\n         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n         return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb\n+\n+def compute_xonly_pubkey(key):\n+    \"\"\"Compute an x-only (32 byte) public key from a (32 byte) private key.\n+\n+    This also returns whether the resulting public key was negated.\n+    \"\"\"\n+\n+    assert len(key) == 32\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return (None, None)\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, x)]))\n+    return (P[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(P))\n+\n+def tweak_add_privkey(key, tweak):\n+    \"\"\"Tweak a private key (after negating it if needed).\"\"\"\n+\n+    assert len(key) == 32\n+    assert len(tweak) == 32\n+\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return None\n+    if not SECP256K1.has_even_y(SECP256K1.mul([(SECP256K1_G, x)])):\n+       x = SECP256K1_ORDER - x\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    x = (x + t) % SECP256K1_ORDER\n+    if x == 0:\n+        return None\n+    return x.to_bytes(32, 'big')\n+\n+def tweak_add_pubkey(key, tweak):\n+    \"\"\"Tweak a public key and return whether the result had to be negated.\"\"\"\n+\n+    assert len(key) == 32\n+    assert len(tweak) == 32\n+\n+    x_coord = int.from_bytes(key, 'big')\n+    if x_coord >= SECP256K1_FIELD_SIZE:\n+        return None\n+    P = SECP256K1.lift_x(x_coord)\n+    if P is None:\n+        return None\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    Q = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, t), (P, 1)]))\n+    if Q is None:\n+        return None\n+    return (Q[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(Q))\n+\n+def verify_schnorr(key, sig, msg):\n+    \"\"\"Verify a Schnorr signature (see BIP 340).\n+\n+    - key is a 32-byte xonly pubkey (computed using compute_xonly_pubkey).\n+    - sig is a 64-byte Schnorr signature\n+    - msg is a 32-byte message\n+    \"\"\"\n+    assert len(key) == 32\n+    assert len(msg) == 32\n+    assert len(sig) == 64\n+\n+    x_coord = int.from_bytes(key, 'big')\n+    if x_coord == 0 or x_coord >= SECP256K1_FIELD_SIZE:\n+        return False\n+    P = SECP256K1.lift_x(x_coord)\n+    if P is None:\n+        return False\n+    r = int.from_bytes(sig[0:32], 'big')\n+    if r >= SECP256K1_FIELD_SIZE:\n+        return False\n+    s = int.from_bytes(sig[32:64], 'big')\n+    if s >= SECP256K1_ORDER:\n+        return False\n+    e = int.from_bytes(TaggedHash(\"BIP0340/challenge\", sig[0:32] + key + msg), 'big') % SECP256K1_ORDER\n+    R = SECP256K1.mul([(SECP256K1_G, s), (P, SECP256K1_ORDER - e)])\n+    if not SECP256K1.has_even_y(R):\n+        return False\n+    if ((r * R[2] * R[2]) % SECP256K1_FIELD_SIZE) != R[0]:\n+        return False\n+    return True\n+\n+def sign_schnorr(key, msg, aux=None):\n+    \"\"\"Create a Schnorr signature (see BIP 340).\"\"\"\n+\n+    if aux is None:\n+        aux = bytes(32)\n+\n+    assert len(key) == 32\n+    assert len(msg) == 32\n+    assert len(aux) == 32\n+\n+    sec = int.from_bytes(key, 'big')\n+    if sec == 0 or sec >= SECP256K1_ORDER:\n+        return None\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, sec)]))\n+    if not SECP256K1.has_even_y(P):\n+        sec = SECP256K1_ORDER - sec\n+    t = (sec ^ int.from_bytes(TaggedHash(\"BIP0340/aux\", aux), 'big')).to_bytes(32, 'big')\n+    kp = int.from_bytes(TaggedHash(\"BIP0340/nonce\", t + P[0].to_bytes(32, 'big') + msg), 'big') % SECP256K1_ORDER\n+    assert kp != 0\n+    R = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, kp)]))\n+    k = kp if SECP256K1.has_even_y(R) else SECP256K1_ORDER - kp\n+    e = int.from_bytes(TaggedHash(\"BIP0340/challenge\", R[0].to_bytes(32, 'big') + P[0].to_bytes(32, 'big') + msg), 'big') % SECP256K1_ORDER\n+    return R[0].to_bytes(32, 'big') + ((k + e * sec) % SECP256K1_ORDER).to_bytes(32, 'big')\n+\n+class TestFrameworkKey(unittest.TestCase):\n+    def test_schnorr(self):\n+        \"\"\"Test the Python Schnorr implementation.\"\"\"\n+        byte_arrays = [generate_privkey() for _ in range(3)] + [v.to_bytes(32, 'big') for v in [0, SECP256K1_ORDER - 1, SECP256K1_ORDER, 2**256 - 1]]\n+        keys = {}\n+        for privkey in byte_arrays:  # build array of key/pubkey pairs\n+            pubkey, _ = compute_xonly_pubkey(privkey)\n+            if pubkey is not None:\n+                keys[privkey] = pubkey\n+        for msg in byte_arrays:  # test every combination of message, signing key, verification key\n+            for sign_privkey, sign_pubkey in keys.items():\n+                sig = sign_schnorr(sign_privkey, msg)\n+                for verify_privkey, verify_pubkey in keys.items():\n+                    if verify_privkey == sign_privkey:\n+                        self.assertTrue(verify_schnorr(verify_pubkey, sig, msg))\n+                        sig = list(sig)\n+                        sig[random.randrange(64)] ^= (1 << (random.randrange(8)))  # damaging signature should break things\n+                        sig = bytes(sig)\n+                    self.assertFalse(verify_schnorr(verify_pubkey, sig, msg))\n+\n+    def test_schnorr_testvectors(self):\n+        \"\"\"Implement the BIP340 test vectors (read from bip340_test_vectors.csv).\"\"\"\n+        num_tests = 0\n+        with open(os.path.join(sys.path[0], 'test_framework', 'bip340_test_vectors.csv'), newline='', encoding='utf8') as csvfile:\n+            reader = csv.reader(csvfile)\n+            next(reader)\n+            for row in reader:\n+                (i_str, seckey_hex, pubkey_hex, aux_rand_hex, msg_hex, sig_hex, result_str, comment) = row\n+                i = int(i_str)\n+                pubkey = bytes.fromhex(pubkey_hex)\n+                msg = bytes.fromhex(msg_hex)\n+                sig = bytes.fromhex(sig_hex)\n+                result = result_str == 'TRUE'\n+                if seckey_hex != '':\n+                    seckey = bytes.fromhex(seckey_hex)\n+                    pubkey_actual = compute_xonly_pubkey(seckey)[0]\n+                    self.assertEqual(pubkey.hex(), pubkey_actual.hex(), \"BIP340 test vector %i (%s): pubkey mismatch\" % (i, comment))\n+                    aux_rand = bytes.fromhex(aux_rand_hex)\n+                    try:\n+                        sig_actual = sign_schnorr(seckey, msg, aux_rand)\n+                        self.assertEqual(sig.hex(), sig_actual.hex(), \"BIP340 test vector %i (%s): sig mismatch\" % (i, comment))\n+                    except RuntimeError as e:\n+                        self.assertFalse(\"BIP340 test vector %i (%s): signing raised exception %s\" % (i, comment, e))\n+                result_actual = verify_schnorr(pubkey, sig, msg)\n+                if result:\n+                    self.assertEqual(result, result_actual, \"BIP340 test vector %i (%s): verification failed\" % (i, comment))\n+                else:\n+                    self.assertEqual(result, result_actual, \"BIP340 test vector %i (%s): verification succeeded unexpectedly\" % (i, comment))\n+                num_tests += 1\n+        self.assertTrue(num_tests >= 15) # expect at least 15 test vectors"
      },
      {
        "sha": "b109480a59312424f262c97045eda8f1e384ca30",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3c226639eb134314a0640d34e4ccb6148dbde22f/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3c226639eb134314a0640d34e4ccb6148dbde22f/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=3c226639eb134314a0640d34e4ccb6148dbde22f",
        "patch": "@@ -70,6 +70,7 @@\n     \"address\",\n     \"blocktools\",\n     \"muhash\",\n+    \"key\",\n     \"script\",\n     \"segwit_addr\",\n     \"util\","
      }
    ]
  },
  {
    "sha": "f06e6d03452cf5e0b1a0863afb08c9e6d3ef452e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMDZlNmQwMzQ1MmNmNWUwYjFhMDg2M2FmYjA4YzllNmQzZWY0NTJl",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-09-14T05:20:17Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-13T00:18:47Z"
      },
      "message": "tests: functional tests for Schnorr/Taproot/Tapscript\n\nA large functional test is added that automatically generates random transactions which\nexercise various aspects of the new rules, and verifies they are accepted into the mempool\n(when appropriate), and correctly accepted/rejected in (Python-constructed) blocks.\n\nIncludes sighashing code and many tests by Johnson Lau.\nIncludes a test by Matthew Zipkin.\nIncludes several tests and improvements by Greg Sanders.",
      "tree": {
        "sha": "244793b4e215b6a6c0d8fc008530e65bd9f2bd7b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/244793b4e215b6a6c0d8fc008530e65bd9f2bd7b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f06e6d03452cf5e0b1a0863afb08c9e6d3ef452e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f06e6d03452cf5e0b1a0863afb08c9e6d3ef452e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f06e6d03452cf5e0b1a0863afb08c9e6d3ef452e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f06e6d03452cf5e0b1a0863afb08c9e6d3ef452e/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3c226639eb134314a0640d34e4ccb6148dbde22f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3c226639eb134314a0640d34e4ccb6148dbde22f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3c226639eb134314a0640d34e4ccb6148dbde22f"
      }
    ],
    "stats": {
      "total": 1570,
      "additions": 1553,
      "deletions": 17
    },
    "files": [
      {
        "sha": "146193d01881b4f99c93884eee256fbcd11cec5b",
        "filename": "test/functional/feature_taproot.py",
        "status": "added",
        "additions": 1411,
        "deletions": 0,
        "changes": 1411,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f06e6d03452cf5e0b1a0863afb08c9e6d3ef452e/test/functional/feature_taproot.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f06e6d03452cf5e0b1a0863afb08c9e6d3ef452e/test/functional/feature_taproot.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_taproot.py?ref=f06e6d03452cf5e0b1a0863afb08c9e6d3ef452e",
        "patch": "@@ -0,0 +1,1411 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expression for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        return tweak_add_privkey(key, tweak)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    scriptsig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    witness_stack = flatten(get(ctx, \"witness\"))\n+    return (scriptsig, witness_stack)\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda returning (scriptsig, witness_stack), taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+# - Whether this test demands being placed in a txin with no corresponding txout (for testing SIGHASH_SINGLE behavior)\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail,need_vin_vout_mismatch\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, need_vin_vout_mismatch=False, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert tap is None\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert script is None\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert script is None\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert script is None\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            return spend(tx, idx, utxos, **conf)\n+        else:\n+            assert failure is not None\n+            return spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None, need_vin_vout_mismatch=need_vin_vout_mismatch)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    return bytes(CScript([pubkey, OP_CHECKSIG]))\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+def zero_appender(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a zero added.\"\"\"\n+    return lambda ctx: deep_eval(ctx, expr) + b\"\\x00\"\n+\n+def byte_popper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with its last byte removed.\"\"\"\n+    return lambda ctx: deep_eval(ctx, expr)[:-1]\n+\n+# Expected error strings\n+\n+ERR_SIG_SIZE = {\"err_msg\": \"Invalid Schnorr signature size\"}\n+ERR_SIG_HASHTYPE = {\"err_msg\": \"Invalid Schnorr signature hash type\"}\n+ERR_SIG_SCHNORR = {\"err_msg\": \"Invalid Schnorr signature\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_TAPSCRIPT_CHECKMULTISIG = {\"err_msg\": \"OP_CHECKMULTISIG(VERIFY) is not available in tapscript\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal in tapscript\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Stack size must be exactly one after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+ERR_CHECKSIGVERIFY = {\"err_msg\": \"Script failed an OP_CHECKSIGVERIFY operation\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+VALID_SIGHASHES_TAPROOT_SINGLE = [\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT_NO_SINGLE = [h for h in VALID_SIGHASHES_TAPROOT if h not in VALID_SIGHASHES_TAPROOT_SINGLE]\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SIG_POP_BYTE = {\"failure\": {\"sign\": byte_popper(default_sign)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+SIG_ADD_ZERO = {\"failure\": {\"sign\": zero_appender(default_sign)}}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 50000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    secs = [generate_privkey() for _ in range(8)]\n+    pubs = [compute_xonly_pubkey(sec)[0] for sec in secs]\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    tap = taproot_construct(pubs[0])\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=secs[0], failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_SIG_SCHNORR)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=secs[0], failure={\"sighash\": bitflipper(default_sighash)}, **ERR_SIG_SCHNORR)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=secs[0], failure={\"flag_flip_r\": True}, **ERR_SIG_SCHNORR)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=secs[0], failure={\"flag_flip_p\": True}, **ERR_SIG_SCHNORR)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=secs[0], failure={\"signature\": bitflipper(default_signature)}, **ERR_SIG_SCHNORR)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pubs[0])\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pubs[1])))]\n+            tap = taproot_construct(pubs[0], scripts)\n+            add_spender(spenders, \"sighash/keypath_hashtype_%x\" % hashtype, tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+            add_spender(spenders, \"sighash/scriptpath_hashtype_%x\" % hashtype, tap=tap, leaf=\"s0\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+\n+            # Test SIGHASH_SINGLE behavior in combination with mismatching outputs\n+            if hashtype in VALID_SIGHASHES_TAPROOT_SINGLE:\n+                add_spender(spenders, \"sighash/keypath_hashtype_mis_%x\" % hashtype, tap=tap, key=secs[0], annex=annex, standard=no_annex, hashtype_actual=random.choice(VALID_SIGHASHES_TAPROOT_NO_SINGLE), failure={\"hashtype_actual\": hashtype}, **ERR_SIG_HASHTYPE, need_vin_vout_mismatch=True)\n+                add_spender(spenders, \"sighash/scriptpath_hashtype_mis_%x\" % hashtype, tap=tap, leaf=\"s0\", key=secs[1], annex=annex, standard=no_annex, hashtype_actual=random.choice(VALID_SIGHASHES_TAPROOT_NO_SINGLE), **SINGLE_SIG, failure={\"hashtype_actual\": hashtype}, **ERR_SIG_HASHTYPE, need_vin_vout_mismatch=True)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pubs[1]) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pubs[1]))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pubs[0], OP_ELSE, OP_CODESEPARATOR, pubs[1], OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=secs[1], codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=secs[0], codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=secs[1], codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=secs[1], hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=random.choice([x & 0xFE for x in range(0x100) if x & 0xFE != 0xC0]))}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=secs[0], **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_SIG_SCHNORR)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in [x for x in range(0x100) if x not in VALID_SIGHASHES_TAPROOT]:\n+        add_spender(spenders, \"sighash/keypath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, key=secs[0], hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SIG_HASHTYPE)\n+        add_spender(spenders, \"sighash/scriptpath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SIG_HASHTYPE)\n+\n+    # Test that hashtype 0 cannot have a hashtype byte, and 1 must have one.\n+    add_spender(spenders, \"sighash/hashtype0_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SIG_HASHTYPE)\n+    add_spender(spenders, \"sighash/hashtype0_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SIG_HASHTYPE)\n+    add_spender(spenders, \"sighash/hashtype1_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/hashtype1_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SIG_SCHNORR)\n+    # Test that hashtype 0 and hashtype 1 cannot be transmuted into each other.\n+    add_spender(spenders, \"sighash/hashtype0to1_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/hashtype0to1_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/hashtype1to0_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/hashtype1to0_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SIG_SCHNORR)\n+\n+    # Test aspects of signatures with unusual lengths\n+    for hashtype in [SIGHASH_DEFAULT, random.choice(VALID_SIGHASHES_TAPROOT)]:\n+        scripts = [\n+            (\"csv\", CScript([pubs[2], OP_CHECKSIGVERIFY, OP_1])),\n+            (\"cs_pos\", CScript([pubs[2], OP_CHECKSIG])),\n+            (\"csa_pos\", CScript([OP_0, pubs[2], OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+            (\"cs_neg\", CScript([pubs[2], OP_CHECKSIG, OP_NOT])),\n+            (\"csa_neg\", CScript([OP_2, pubs[2], OP_CHECKSIGADD, OP_2, OP_EQUAL]))\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[3], scripts)\n+        # Empty signatures\n+        add_spender(spenders, \"siglen/empty_keypath\", tap=tap, key=secs[3], hashtype=hashtype, failure={\"sign\": b\"\"}, **ERR_SIG_SIZE)\n+        add_spender(spenders, \"siglen/empty_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_CHECKSIGVERIFY)\n+        add_spender(spenders, \"siglen/empty_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_NO_SUCCESS)\n+        add_spender(spenders, \"siglen/empty_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_NO_SUCCESS)\n+        add_spender(spenders, \"siglen/empty_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": lambda _: random_bytes(random.randrange(1, 63))}, **ERR_SIG_SIZE)\n+        add_spender(spenders, \"siglen/empty_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": lambda _: random_bytes(random.randrange(66, 100))}, **ERR_SIG_SIZE)\n+        # Appending a zero byte to signatures invalidates them\n+        add_spender(spenders, \"siglen/padzero_keypath\", tap=tap, key=secs[3], hashtype=hashtype, **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        # Removing the last byte from signatures invalidates them\n+        add_spender(spenders, \"siglen/popbyte_keypath\", tap=tap, key=secs[3], hashtype=hashtype, **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        # Verify that an invalid signature is not allowed, not even when the CHECKSIG* is expected to fail.\n+        add_spender(spenders, \"siglen/invalid_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": default_sign, \"sighash\": bitflipper(default_sighash)}, **ERR_SIG_SCHNORR)\n+        add_spender(spenders, \"siglen/invalid_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": default_sign, \"sighash\": bitflipper(default_sighash)}, **ERR_SIG_SCHNORR)\n+\n+    # == Test that BIP341 spending only applies to witness version 1, program length 32, no P2SH ==\n+\n+    for p2sh in [False, True]:\n+        for witver in range(1, 17):\n+            for witlen in [20, 31, 32, 33]:\n+                def mutate(spk):\n+                    prog = spk[2:]\n+                    assert len(prog) == 32\n+                    if witlen < 32:\n+                        prog = prog[0:witlen]\n+                    elif witlen > 32:\n+                        prog += bytes([0 for _ in range(witlen - 32)])\n+                    return CScript([CScriptOp.encode_op_n(witver), prog])\n+                scripts = [(\"s0\", CScript([pubs[0], OP_CHECKSIG])), (\"dummy\", CScript([OP_RETURN]))]\n+                tap = taproot_construct(pubs[1], scripts)\n+                if not p2sh and witver == 1 and witlen == 32:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, failure={\"leaf\": \"dummy\"}, **ERR_OP_RETURN)\n+                else:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], standard=False)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, standard=False)\n+\n+    # == Test various aspects of BIP341 spending paths ==\n+\n+    # A set of functions that compute the hashing partner in a Merkle tree, designed to exercise\n+    # edge cases. This relies on the taproot_construct feature that a lambda can be passed in\n+    # instead of a subtree, to compute the partner to be hashed with.\n+    PARTNER_MERKLE_FN = [\n+        # Combine with itself\n+        lambda h: h,\n+        # Combine with hash 0\n+        lambda h: bytes([0 for _ in range(32)]),\n+        # Combine with hash 2^256-1\n+        lambda h: bytes([0xff for _ in range(32)]),\n+        # Combine with itself-1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') + 1).to_bytes(32, 'big'),\n+        # Combine with itself-1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') + 1).to_bytes(32, 'little'),\n+        # Combine with random bitflipped version of self.\n+        lambda h: (int.from_bytes(h, 'little') ^ (1 << random.randrange(256))).to_bytes(32, 'little')\n+    ]\n+    # Start with a tree of that has depth 1 for \"128deep\" and depth 2 for \"129deep\".\n+    scripts = [(\"128deep\", CScript([pubs[0], OP_CHECKSIG])), [(\"129deep\", CScript([pubs[0], OP_CHECKSIG])), random.choice(PARTNER_MERKLE_FN)]]\n+    # Add 127 nodes on top of that tree, so that \"128deep\" and \"129deep\" end up at their designated depths.\n+    for _ in range(127):\n+        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+    tap = taproot_construct(pubs[0], scripts)\n+    # Test that spends with a depth of 128 work, but 129 doesn't (even with a tree with weird Merkle branches in it).\n+    add_spender(spenders, \"spendpath/merklelimit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"leaf\": \"129deep\"}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that flipping the negation bit invalidates spends.\n+    add_spender(spenders, \"spendpath/negflag\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"negflag\": lambda ctx: 1 - default_negflag(ctx)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the Merkle branch invalidate it.\n+    add_spender(spenders, \"spendpath/bitflipmerkle\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"merklebranch\": bitflipper(default_merklebranch)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the inner pubkey invalidate it.\n+    add_spender(spenders, \"spendpath/bitflippubkey\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"pubkey_inner\": bitflipper(default_pubkey_inner)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that empty witnesses are invalid.\n+    add_spender(spenders, \"spendpath/emptywit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"witness\": []}, **ERR_EMPTY_WITNESS)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padlongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/trunclongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    scripts = [(\"s\", CScript([pubs[0], OP_CHECKSIG]))]\n+    tap = taproot_construct(pubs[1], scripts)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/truncshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block to 1 byte (\"-1 Merkle length\") invalidates it\n+    add_spender(spenders, \"spendpath/trunc1shortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:1]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    # == Test BIP342 edge cases ==\n+\n+    csa_low_val = random.randrange(0, 17) # Within range for OP_n\n+    csa_low_result = csa_low_val + 1\n+\n+    csa_high_val = random.randrange(17, 100) if random.getrandbits(1) else random.randrange(-100, -1) # Outside OP_n range\n+    csa_high_result = csa_high_val + 1\n+\n+    OVERSIZE_NUMBER = 2**31\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER))), 6)\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER-1))), 5)\n+\n+    big_choices = []\n+    big_scriptops = []\n+    for i in range(1000):\n+        r = random.randrange(len(pubs))\n+        big_choices.append(r)\n+        big_scriptops += [pubs[r], OP_CHECKSIGVERIFY]\n+\n+\n+    def big_spend_inputs(ctx):\n+        \"\"\"Helper function to construct the script input for t33/t34 below.\"\"\"\n+        # Instead of signing 999 times, precompute signatures for every (key, hashtype) combination\n+        sigs = {}\n+        for ht in VALID_SIGHASHES_TAPROOT:\n+            for k in range(len(pubs)):\n+                sigs[(k, ht)] = override(default_sign, hashtype=ht, key=secs[k])(ctx)\n+        num = get(ctx, \"num\")\n+        return [sigs[(big_choices[i], random.choice(VALID_SIGHASHES_TAPROOT))] for i in range(num - 1, -1, -1)]\n+\n+    # Various BIP342 features\n+    scripts = [\n+        # 0) drop stack element and OP_CHECKSIG\n+        (\"t0\", CScript([OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 1) normal OP_CHECKSIG\n+        (\"t1\", CScript([pubs[1], OP_CHECKSIG])),\n+        # 2) normal OP_CHECKSIGVERIFY\n+        (\"t2\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1])),\n+        # 3) Hypothetical OP_CHECKMULTISIG script that takes a single sig as input\n+        (\"t3\", CScript([OP_0, OP_SWAP, OP_1, pubs[1], OP_1, OP_CHECKMULTISIG])),\n+        # 4) Hypothetical OP_CHECKMULTISIGVERIFY script that takes a single sig as input\n+        (\"t4\", CScript([OP_0, OP_SWAP, OP_1, pubs[1], OP_1, OP_CHECKMULTISIGVERIFY, OP_1])),\n+        # 5) OP_IF script that needs a true input\n+        (\"t5\", CScript([OP_IF, pubs[1], OP_CHECKSIG, OP_ELSE, OP_RETURN, OP_ENDIF])),\n+        # 6) OP_NOTIF script that needs a true input\n+        (\"t6\", CScript([OP_NOTIF, OP_RETURN, OP_ELSE, pubs[1], OP_CHECKSIG, OP_ENDIF])),\n+        # 7) OP_CHECKSIG with an empty key\n+        (\"t7\", CScript([OP_0, OP_CHECKSIG])),\n+        # 8) OP_CHECKSIGVERIFY with an empty key\n+        (\"t8\", CScript([OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 9) normal OP_CHECKSIGADD that also ensures return value is correct\n+        (\"t9\", CScript([csa_low_val, pubs[1], OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 10) OP_CHECKSIGADD with empty key\n+        (\"t10\", CScript([csa_low_val, OP_0, OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 11) OP_CHECKSIGADD with missing counter stack element\n+        (\"t11\", CScript([pubs[1], OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+        # 12) OP_CHECKSIG that needs invalid signature\n+        (\"t12\", CScript([pubs[1], OP_CHECKSIGVERIFY, pubs[0], OP_CHECKSIG, OP_NOT])),\n+        # 13) OP_CHECKSIG with empty key that needs invalid signature\n+        (\"t13\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_CHECKSIG, OP_NOT])),\n+        # 14) OP_CHECKSIGADD that needs invalid signature\n+        (\"t14\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, pubs[0], OP_CHECKSIGADD, OP_NOT])),\n+        # 15) OP_CHECKSIGADD with empty key that needs invalid signature\n+        (\"t15\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGADD, OP_NOT])),\n+        # 16) OP_CHECKSIG with unknown pubkey type\n+        (\"t16\", CScript([OP_1, OP_CHECKSIG])),\n+        # 17) OP_CHECKSIGADD with unknown pubkey type\n+        (\"t17\", CScript([OP_0, OP_1, OP_CHECKSIGADD])),\n+        # 18) OP_CHECKSIGVERIFY with unknown pubkey type\n+        (\"t18\", CScript([OP_1, OP_CHECKSIGVERIFY, OP_1])),\n+        # 19) script longer than 10000 bytes and over 201 non-push opcodes\n+        (\"t19\", CScript([OP_0, OP_0, OP_2DROP] * 10001 + [pubs[1], OP_CHECKSIG])),\n+        # 20) OP_CHECKSIGVERIFY with empty key\n+        (\"t20\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 21) Script that grows the stack to 1000 elements\n+        (\"t21\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 999 + [OP_DROP] * 999)),\n+        # 22) Script that grows the stack to 1001 elements\n+        (\"t22\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 1000 + [OP_DROP] * 1000)),\n+        # 23) Script that expects an input stack of 1000 elements\n+        (\"t23\", CScript([OP_DROP] * 999 + [pubs[1], OP_CHECKSIG])),\n+        # 24) Script that expects an input stack of 1001 elements\n+        (\"t24\", CScript([OP_DROP] * 1000 + [pubs[1], OP_CHECKSIG])),\n+        # 25) Script that pushes a MAX_SCRIPT_ELEMENT_SIZE-bytes element\n+        (\"t25\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE), OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 26) Script that pushes a (MAX_SCRIPT_ELEMENT_SIZE+1)-bytes element\n+        (\"t26\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 27) CHECKSIGADD that must fail because numeric argument number is >4 bytes\n+        (\"t27\", CScript([CScriptNum(OVERSIZE_NUMBER), pubs[1], OP_CHECKSIGADD])),\n+        # 28) Pushes random CScriptNum value, checks OP_CHECKSIGADD result\n+        (\"t28\", CScript([csa_high_val, pubs[1], OP_CHECKSIGADD, csa_high_result, OP_EQUAL])),\n+        # 29) CHECKSIGADD that succeeds with proper sig because numeric argument number is <=4 bytes\n+        (\"t29\", CScript([CScriptNum(OVERSIZE_NUMBER-1), pubs[1], OP_CHECKSIGADD])),\n+        # 30) Variant of t1 with \"normal\" 33-byte pubkey\n+        (\"t30\", CScript([b'\\x03' + pubs[1], OP_CHECKSIG])),\n+        # 31) Variant of t2 with \"normal\" 33-byte pubkey\n+        (\"t31\", CScript([b'\\x02' + pubs[1], OP_CHECKSIGVERIFY, OP_1])),\n+        # 32) Variant of t28 with \"normal\" 33-byte pubkey\n+        (\"t32\", CScript([csa_high_val, b'\\x03' + pubs[1], OP_CHECKSIGADD, csa_high_result, OP_EQUAL])),\n+        # 33) 999-of-999 multisig\n+        (\"t33\", CScript(big_scriptops[:1998] + [OP_1])),\n+        # 34) 1000-of-1000 multisig\n+        (\"t34\", CScript(big_scriptops[:2000] + [OP_1])),\n+        # 35) Variant of t9 that uses a non-minimally encoded input arg\n+        (\"t35\", CScript([bytes([csa_low_val]), pubs[1], OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 36) Empty script\n+        (\"t36\", CScript([])),\n+    ]\n+    # Add many dummies to test huge trees\n+    for j in range(100000):\n+        scripts.append((None, CScript([OP_RETURN, random.randrange(100000)])))\n+    random.shuffle(scripts)\n+    tap = taproot_construct(pubs[0], scripts)\n+    common = {\n+        \"hashtype\": hashtype,\n+        \"key\": secs[1],\n+        \"tap\": tap,\n+    }\n+    # Test that MAX_SCRIPT_ELEMENT_SIZE byte stack element inputs are valid, but not one more (and 80 bytes is standard but 81 is not).\n+    add_spender(spenders, \"tapscript/inputmaxlimit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE)], failure={\"inputs\": [getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1)]}, **ERR_PUSH_LIMIT)\n+    add_spender(spenders, \"tapscript/input80limit\", leaf=\"t0\", **common, inputs=[getter(\"sign\"), random_bytes(80)])\n+    add_spender(spenders, \"tapscript/input81limit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(81)])\n+    # Test that OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY cause failure, but OP_CHECKSIG and OP_CHECKSIGVERIFY work.\n+    add_spender(spenders, \"tapscript/disabled_checkmultisig\", leaf=\"t1\", **common, **SINGLE_SIG, failure={\"leaf\": \"t3\"}, **ERR_TAPSCRIPT_CHECKMULTISIG)\n+    add_spender(spenders, \"tapscript/disabled_checkmultisigverify\", leaf=\"t2\", **common, **SINGLE_SIG, failure={\"leaf\": \"t4\"}, **ERR_TAPSCRIPT_CHECKMULTISIG)\n+    # Test that OP_IF and OP_NOTIF do not accept non-0x01 as truth value (the MINIMALIF rule is consensus in Tapscript)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x02']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x03']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0001']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0100']}, **ERR_MINIMALIF)\n+    # Test that 1-byte public keys (which are unknown) are acceptable but nonstandard with unrelated signatures, but 0-byte public keys are not valid.\n+    add_spender(spenders, \"tapscript/unkpk/checksig\", leaf=\"t16\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigadd\", leaf=\"t17\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigverify\", leaf=\"t18\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that 33-byte public keys (which are unknown) are acceptable but nonstandard with valid signatures, but normal pubkeys are not valid in that case.\n+    add_spender(spenders, \"tapscript/oldpk/checksig\", leaf=\"t30\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t1\"}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"tapscript/oldpk/checksigadd\", leaf=\"t31\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t2\"}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"tapscript/oldpk/checksigverify\", leaf=\"t32\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t28\"}, **ERR_SIG_SCHNORR)\n+    # Test that 0-byte public keys are not acceptable.\n+    add_spender(spenders, \"tapscript/emptypk/checksig\", leaf=\"t1\", **SINGLE_SIG, **common, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigverify\", leaf=\"t2\", **SINGLE_SIG, **common, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t35\", standard=False, **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that OP_CHECKSIGADD results are as expected\n+    add_spender(spenders, \"tapscript/checksigaddresults\", leaf=\"t28\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    add_spender(spenders, \"tapscript/checksigaddoversize\", leaf=\"t29\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    # Test that OP_CHECKSIGADD requires 3 stack elements.\n+    add_spender(spenders, \"tapscript/checksigadd3args\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t11\"}, **ERR_STACK_EMPTY)\n+    # Test that empty signatures do not cause script failure in OP_CHECKSIG and OP_CHECKSIGADD (but do fail with empty pubkey, and do fail OP_CHECKSIGVERIFY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksig\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t13\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/nochecksigverify\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t20\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksigadd\", leaf=\"t14\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t15\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that scripts over 10000 bytes (and over 201 non-push ops) are acceptable.\n+    add_spender(spenders, \"tapscript/no10000limit\", leaf=\"t19\", **SINGLE_SIG, **common)\n+    # Test that a stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000stack\", leaf=\"t21\", **SINGLE_SIG, **common, failure={\"leaf\": \"t22\"}, **ERR_STACK_SIZE)\n+    # Test that an input stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000inputs\", leaf=\"t23\", **common, inputs=[getter(\"sign\")] + [b'' for _ in range(999)], failure={\"leaf\": \"t24\", \"inputs\": [getter(\"sign\")] + [b'' for _ in range(1000)]}, **ERR_STACK_SIZE)\n+    # Test that pushing a MAX_SCRIPT_ELEMENT_SIZE byte stack element is valid, but one longer is not.\n+    add_spender(spenders, \"tapscript/pushmaxlimit\", leaf=\"t25\", **common, **SINGLE_SIG, failure={\"leaf\": \"t26\"}, **ERR_PUSH_LIMIT)\n+    # Test that 999-of-999 multisig works (but 1000-of-1000 triggers stack size limits)\n+    add_spender(spenders, \"tapscript/bigmulti\", leaf=\"t33\", **common, inputs=big_spend_inputs, num=999, failure={\"leaf\": \"t34\", \"num\": 1000}, **ERR_STACK_SIZE)\n+    # Test that the CLEANSTACK rule is consensus critical in tapscript\n+    add_spender(spenders, \"tapscript/cleanstack\", leaf=\"t36\", tap=tap, inputs=[b'\\x01'], failure={\"inputs\": [b'\\x01', b'\\x01']}, **ERR_CLEANSTACK)\n+\n+    # == Test for sigops ratio limit ==\n+\n+    # Given a number n, and a public key pk, functions that produce a (CScript, sigops). Each script takes as\n+    # input a valid signature with the passed pk followed by a dummy push of bytes that are to be dropped, and\n+    # will execute sigops signature checks.\n+    SIGOPS_RATIO_SCRIPTS = [\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIG.\n+        lambda n, pk: (CScript([OP_DROP, pk] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGVERIFY.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_0, OP_IF, OP_2DUP, OP_CHECKSIGVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_2, OP_SWAP, OP_CHECKSIGADD, OP_3, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIG.\n+        lambda n, pk: (CScript([random_bytes(220), OP_2DROP, pk, OP_1, OP_NOTIF, OP_2DUP, OP_CHECKSIG, OP_VERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_4, OP_SWAP, OP_CHECKSIGADD, OP_5, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGADD.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_1, OP_IF, OP_ELSE, OP_2DUP, OP_6, OP_SWAP, OP_CHECKSIGADD, OP_7, OP_EQUALVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_8, OP_SWAP, OP_CHECKSIGADD, OP_9, OP_EQUAL]), n + 1),\n+        # n+1 OP_CHECKSIGs, but also one OP_CHECKSIG with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, pk, OP_CHECKSIG, OP_NOT, OP_VERIFY, pk] + [OP_2DUP, OP_CHECKSIG, OP_VERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGADDs and 1 OP_CHECKSIG, but also an OP_CHECKSIGADD with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, OP_10, pk, OP_CHECKSIGADD, OP_10, OP_EQUALVERIFY, pk] + [OP_2DUP, OP_16, OP_SWAP, OP_CHECKSIGADD, b'\\x11', OP_EQUALVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+    ]\n+    for annex in [None, bytes([ANNEX_TAG]) + random_bytes(random.randrange(1000))]:\n+        for hashtype in [SIGHASH_DEFAULT, SIGHASH_ALL]:\n+            for pubkey in [pubs[1], random_bytes(random.choice([x for x in range(2, 81) if x != 32]))]:\n+                for fn_num, fn in enumerate(SIGOPS_RATIO_SCRIPTS):\n+                    merkledepth = random.randrange(129)\n+\n+\n+                    def predict_sigops_ratio(n, dummy_size):\n+                        \"\"\"Predict whether spending fn(n, pubkey) with dummy_size will pass the ratio test.\"\"\"\n+                        script, sigops = fn(n, pubkey)\n+                        # Predict the size of the witness for a given choice of n\n+                        stacklen_size = 1\n+                        sig_size = 64 + (hashtype != SIGHASH_DEFAULT)\n+                        siglen_size = 1\n+                        dummylen_size = 1 + 2 * (dummy_size >= 253)\n+                        script_size = len(script)\n+                        scriptlen_size = 1 + 2 * (script_size >= 253)\n+                        control_size = 33 + 32 * merkledepth\n+                        controllen_size = 1 + 2 * (control_size >= 253)\n+                        annex_size = 0 if annex is None else len(annex)\n+                        annexlen_size = 0 if annex is None else 1 + 2 * (annex_size >= 253)\n+                        witsize = stacklen_size + sig_size + siglen_size + dummy_size + dummylen_size + script_size + scriptlen_size + control_size + controllen_size + annex_size + annexlen_size\n+                        # sigops ratio test\n+                        return witsize + 50 >= 50 * sigops\n+                    # Make sure n is high enough that with empty dummy, the script is not valid\n+                    n = 0\n+                    while predict_sigops_ratio(n, 0):\n+                        n += 1\n+                    # But allow picking a bit higher still\n+                    n += random.randrange(5)\n+                    # Now pick dummy size *just* large enough that the overall construction passes\n+                    dummylen = 0\n+                    while not predict_sigops_ratio(n, dummylen):\n+                        dummylen += 1\n+                    scripts = [(\"s\", fn(n, pubkey)[0])]\n+                    for _ in range(merkledepth):\n+                        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+                    tap = taproot_construct(pubs[0], scripts)\n+                    standard = annex is None and dummylen <= 80 and len(pubkey) == 32\n+                    add_spender(spenders, \"tapscript/sigopsratio_%i\" % fn_num, tap=tap, leaf=\"s\", annex=annex, hashtype=hashtype, key=secs[1], inputs=[getter(\"sign\"), random_bytes(dummylen)], standard=standard, failure={\"inputs\": [getter(\"sign\"), random_bytes(dummylen - 1)]}, **ERR_SIGOPS_RATIO)\n+\n+    # Future leaf versions\n+    for leafver in range(0, 0x100, 2):\n+        if leafver == LEAF_VERSION_TAPSCRIPT or leafver == ANNEX_TAG:\n+            # Skip the defined LEAF_VERSION_TAPSCRIPT, and the ANNEX_TAG which is not usable as leaf version\n+            continue\n+        scripts = [\n+            (\"bare_c0\", CScript([OP_NOP])),\n+            (\"bare_unkver\", CScript([OP_NOP]), leafver),\n+            (\"return_c0\", CScript([OP_RETURN])),\n+            (\"return_unkver\", CScript([OP_RETURN]), leafver),\n+            (\"undecodable_c0\", CScript([OP_PUSHDATA1])),\n+            (\"undecodable_unkver\", CScript([OP_PUSHDATA1]), leafver),\n+            (\"bigpush_c0\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP])),\n+            (\"bigpush_unkver\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP]), leafver),\n+            (\"1001push_c0\", CScript([OP_0] * 1001)),\n+            (\"1001push_unkver\", CScript([OP_0] * 1001), leafver),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"unkver/bare\", standard=False, tap=tap, leaf=\"bare_unkver\", failure={\"leaf\": \"bare_c0\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"unkver/return\", standard=False, tap=tap, leaf=\"return_unkver\", failure={\"leaf\": \"return_c0\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"unkver/undecodable\", standard=False, tap=tap, leaf=\"undecodable_unkver\", failure={\"leaf\": \"undecodable_c0\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"unkver/bigpush\", standard=False, tap=tap, leaf=\"bigpush_unkver\", failure={\"leaf\": \"bigpush_c0\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"unkver/1001push\", standard=False, tap=tap, leaf=\"1001push_unkver\", failure={\"leaf\": \"1001push_c0\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"unkver/1001inputs\", standard=False, tap=tap, leaf=\"bare_unkver\", inputs=[b'']*1001, failure={\"leaf\": \"bare_c0\"}, **ERR_STACK_SIZE)\n+\n+    # OP_SUCCESSx tests.\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for opval in range(76, 0x100):\n+        opcode = CScriptOp(opval)\n+        if not is_op_success(opcode):\n+            continue\n+        scripts = [\n+            (\"bare_success\", CScript([opcode])),\n+            (\"bare_nop\", CScript([OP_NOP])),\n+            (\"unexecif_success\", CScript([OP_0, OP_IF, opcode, OP_ENDIF])),\n+            (\"unexecif_nop\", CScript([OP_0, OP_IF, OP_NOP, OP_ENDIF])),\n+            (\"return_success\", CScript([OP_RETURN, opcode])),\n+            (\"return_nop\", CScript([OP_RETURN, OP_NOP])),\n+            (\"undecodable_success\", CScript([opcode, OP_PUSHDATA1])),\n+            (\"undecodable_nop\", CScript([OP_NOP, OP_PUSHDATA1])),\n+            (\"undecodable_bypassed_success\", CScript([OP_PUSHDATA1, OP_2, opcode])),\n+            (\"bigpush_success\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, opcode])),\n+            (\"bigpush_nop\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, OP_NOP])),\n+            (\"1001push_success\", CScript([OP_0] * 1001 + [opcode])),\n+            (\"1001push_nop\", CScript([OP_0] * 1001 + [OP_NOP])),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"opsuccess/bare\", standard=False, tap=tap, leaf=\"bare_success\", failure={\"leaf\": \"bare_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/unexecif\", standard=False, tap=tap, leaf=\"unexecif_success\", failure={\"leaf\": \"unexecif_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/return\", standard=False, tap=tap, leaf=\"return_success\", failure={\"leaf\": \"return_nop\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"opsuccess/undecodable\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_nop\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"opsuccess/undecodable_bypass\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_bypassed_success\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"opsuccess/bigpush\", standard=False, tap=tap, leaf=\"bigpush_success\", failure={\"leaf\": \"bigpush_nop\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"opsuccess/1001push\", standard=False, tap=tap, leaf=\"1001push_success\", failure={\"leaf\": \"1001push_nop\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"opsuccess/1001inputs\", standard=False, tap=tap, leaf=\"bare_success\", inputs=[b'']*1001, failure={\"leaf\": \"bare_nop\"}, **ERR_STACK_SIZE)\n+\n+    # Non-OP_SUCCESSx (verify that those aren't accidentally treated as OP_SUCCESSx)\n+    for opval in range(0, 0x100):\n+        opcode = CScriptOp(opval)\n+        if is_op_success(opcode):\n+            continue\n+        scripts = [\n+            (\"normal\", CScript([OP_RETURN, opcode] + [OP_NOP] * 75)),\n+            (\"op_success\", CScript([OP_RETURN, CScriptOp(0x50)]))\n+        ]\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"alwaysvalid/notsuccessx\", tap=tap, leaf=\"op_success\", inputs=[], standard=False, failure={\"leaf\": \"normal\"}) # err_msg differs based on opcode\n+\n+    # == Legacy tests ==\n+\n+    # Also add a few legacy spends into the mix, so that transactions which combine taproot and pre-taproot spends get tested too.\n+    for compressed in [False, True]:\n+        eckey1 = ECKey()\n+        eckey1.set(generate_privkey(), compressed)\n+        pubkey1 = eckey1.get_pubkey().get_bytes()\n+        eckey2 = ECKey()\n+        eckey2.set(generate_privkey(), compressed)\n+        for p2sh in [False, True]:\n+            for witv0 in [False, True]:\n+                for hashtype in VALID_SIGHASHES_ECDSA + [random.randrange(0x04, 0x80), random.randrange(0x84, 0x100)]:\n+                    standard = (hashtype in VALID_SIGHASHES_ECDSA) and (compressed or not witv0)\n+                    add_spender(spenders, \"legacy/pk-wrongkey\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, script=CScript([pubkey1, OP_CHECKSIG]), **SINGLE_SIG, key=eckey1, failure={\"key\": eckey2}, sigops_weight=4-3*witv0, **ERR_NO_SUCCESS)\n+                    add_spender(spenders, \"legacy/pkh-sighashflip\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, pkh=pubkey1, key=eckey1, **SIGHASH_BITFLIP, sigops_weight=4-3*witv0, **ERR_NO_SUCCESS)\n+\n+    # Verify that OP_CHECKSIGADD wasn't accidentally added to pre-taproot validation logic.\n+    for p2sh in [False, True]:\n+        for witv0 in [False, True]:\n+            for hashtype in VALID_SIGHASHES_ECDSA + [random.randrange(0x04, 0x80), random.randrange(0x84, 0x100)]:\n+                standard = hashtype in VALID_SIGHASHES_ECDSA and (p2sh or witv0)\n+                add_spender(spenders, \"compat/nocsa\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, script=CScript([OP_IF, OP_11, pubkey1, OP_CHECKSIGADD, OP_12, OP_EQUAL, OP_ELSE, pubkey1, OP_CHECKSIG, OP_ENDIF]), key=eckey1, sigops_weight=4-3*witv0, inputs=[getter(\"sign\"), b''], failure={\"inputs\": [getter(\"sign\"), b'\\x01']}, **ERR_UNDECODABLE)\n+\n+    return spenders\n+\n+def spenders_taproot_inactive():\n+    \"\"\"Spenders for testing that pre-activation Taproot rules don't apply.\"\"\"\n+\n+    spenders = []\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    scripts = [\n+        (\"pk\", CScript([pub, OP_CHECKSIG])),\n+        (\"future_leaf\", CScript([pub, OP_CHECKSIG]), 0xc2),\n+        (\"op_success\", CScript([pub, OP_CHECKSIG, OP_0, OP_IF, CScriptOp(0x50), OP_ENDIF])),\n+    ]\n+    tap = taproot_construct(pub, scripts)\n+\n+    # Test that keypath spending is valid & standard if compliant, but valid and nonstandard otherwise.\n+    add_spender(spenders, \"inactive/keypath_valid\", key=sec, tap=tap)\n+    add_spender(spenders, \"inactive/keypath_invalidsig\", key=sec, tap=tap, standard=False, sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/keypath_empty\", key=sec, tap=tap, standard=False, witness=[])\n+\n+    # Same for scriptpath spending (but using future features like annex, leaf versions, or OP_SUCCESS is nonstandard).\n+    add_spender(spenders, \"inactive/scriptpath_valid\", key=sec, tap=tap, leaf=\"pk\", inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_invalidsig\", key=sec, tap=tap, leaf=\"pk\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/scriptpath_invalidcb\", key=sec, tap=tap, leaf=\"pk\", standard=False, inputs=[getter(\"sign\")], controlblock=bitflipper(default_controlblock))\n+    add_spender(spenders, \"inactive/scriptpath_valid_unkleaf\", key=sec, tap=tap, leaf=\"future_leaf\", standard=False, inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_invalid_unkleaf\", key=sec, tap=tap, leaf=\"future_leaf\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/scriptpath_valid_opsuccess\", key=sec, tap=tap, leaf=\"op_success\", standard=False, inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_valid_opsuccess\", key=sec, tap=tap, leaf=\"op_success\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+\n+    return spenders\n+\n+# Data type to keep track of UTXOs, where they were created, and how to spend them.\n+UTXOData = namedtuple('UTXOData', 'outpoint,output,spender')\n+\n+class TaprootTest(BitcoinTestFramework):\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.setup_clean_chain = True\n+        # Node 0 has Taproot inactive, Node 1 active.\n+        self.extra_args = [[\"-whitelist=127.0.0.1\", \"-par=1\", \"-vbparams=taproot:1:1\"], [\"-whitelist=127.0.0.1\", \"-par=1\"]]\n+\n+    def block_submit(self, node, txs, msg, err_msg, cb_pubkey=None, fees=0, sigops_weight=0, witness=False, accept=False):\n+\n+        # Deplete block of any non-tapscript sigops using a single additional 0-value coinbase output.\n+        # It is not impossible to fit enough tapscript sigops to hit the old 80k limit without\n+        # busting txin-level limits. We simply have to account for the p2pk outputs in all\n+        # transactions.\n+        extra_output_script = CScript([OP_CHECKSIG]*((MAX_BLOCK_SIGOPS_WEIGHT - sigops_weight) // WITNESS_SCALE_FACTOR))\n+\n+        block = create_block(self.tip, create_coinbase(self.lastblockheight + 1, pubkey=cb_pubkey, extra_output_script=extra_output_script, fees=fees), self.lastblocktime + 1)\n+        block.nVersion = 4\n+        for tx in txs:\n+            tx.rehash()\n+            block.vtx.append(tx)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        witness and add_witness_commitment(block)\n+        block.rehash()\n+        block.solve()\n+        block_response = node.submitblock(block.serialize(True).hex())\n+        if err_msg is not None:\n+            assert block_response is not None and err_msg in block_response, \"Missing error message '%s' from block response '%s': %s\" % (err_msg, \"(None)\" if block_response is None else block_response, msg)\n+        if (accept):\n+            assert node.getbestblockhash() == block.hash, \"Failed to accept: %s (response: %s)\" % (msg, block_response)\n+            self.tip = block.sha256\n+            self.lastblockhash = block.hash\n+            self.lastblocktime += 1\n+            self.lastblockheight += 1\n+        else:\n+            assert node.getbestblockhash() == self.lastblockhash, \"Failed to reject: \" + msg\n+\n+    def test_spenders(self, node, spenders, input_counts):\n+        \"\"\"Run randomized tests with a number of \"spenders\".\n+\n+        Steps:\n+            1) Generate an appropriate UTXO for each spender to test spend conditions\n+            2) Generate 100 random addresses of all wallet types: pkh/sh_wpkh/wpkh\n+            3) Select random number of inputs from (1)\n+            4) Select random number of addresses from (2) as outputs\n+\n+        Each spender embodies a test; in a large randomized test, it is verified\n+        that toggling the valid argument to each lambda toggles the validity of\n+        the transaction. This is accomplished by constructing transactions consisting\n+        of all valid inputs, except one invalid one.\n+        \"\"\"\n+\n+        # Construct a bunch of sPKs that send coins back to the host wallet\n+        self.log.info(\"- Constructing addresses for returning coins\")\n+        host_spks = []\n+        host_pubkeys = []\n+        for i in range(16):\n+            addr = node.getnewaddress(address_type=random.choice([\"legacy\", \"p2sh-segwit\", \"bech32\"]))\n+            info = node.getaddressinfo(addr)\n+            spk = bytes.fromhex(info['scriptPubKey'])\n+            host_spks.append(spk)\n+            host_pubkeys.append(bytes.fromhex(info['pubkey']))\n+\n+        # Initialize variables used by block_submit().\n+        self.lastblockhash = node.getbestblockhash()\n+        self.tip = int(self.lastblockhash, 16)\n+        block = node.getblock(self.lastblockhash)\n+        self.lastblockheight = block['height']\n+        self.lastblocktime = block['time']\n+\n+        # Create transactions spending up to 50 of the wallet's inputs, with one output for each spender, and\n+        # one change output at the end. The transaction is constructed on the Python side to enable\n+        # having multiple outputs to the same address and outputs with no assigned address. The wallet\n+        # is then asked to sign it through signrawtransactionwithwallet, and then added to a block on the\n+        # Python side (to bypass standardness rules).\n+        self.log.info(\"- Creating test UTXOs...\")\n+        random.shuffle(spenders)\n+        normal_utxos = []\n+        mismatching_utxos = [] # UTXOs with input that requires mismatching output position\n+        done = 0\n+        while done < len(spenders):\n+            # Compute how many UTXOs to create with this transaction\n+            count_this_tx = min(len(spenders) - done, (len(spenders) + 4) // 5, 10000)\n+\n+            fund_tx = CTransaction()\n+            # Add the 50 highest-value inputs\n+            unspents = node.listunspent()\n+            random.shuffle(unspents)\n+            unspents.sort(key=lambda x: int(x[\"amount\"] * 100000000), reverse=True)\n+            if len(unspents) > 50:\n+                unspents = unspents[:50]\n+            random.shuffle(unspents)\n+            balance = 0\n+            for unspent in unspents:\n+                balance += int(unspent[\"amount\"] * 100000000)\n+                txid = int(unspent[\"txid\"], 16)\n+                fund_tx.vin.append(CTxIn(COutPoint(txid, int(unspent[\"vout\"])), CScript()))\n+            # Add outputs\n+            cur_progress = done / len(spenders)\n+            next_progress = (done + count_this_tx) / len(spenders)\n+            change_goal = (1.0 - 0.6 * next_progress) / (1.0 - 0.6 * cur_progress) * balance\n+            self.log.debug(\"Create %i UTXOs in a transaction spending %i inputs worth %.8f (sending ~%.8f to change)\" % (count_this_tx, len(unspents), balance * 0.00000001, change_goal * 0.00000001))\n+            for i in range(count_this_tx):\n+                avg = (balance - change_goal) / (count_this_tx - i)\n+                amount = int(random.randrange(int(avg*0.85 + 0.5), int(avg*1.15 + 0.5)) + 0.5)\n+                balance -= amount\n+                fund_tx.vout.append(CTxOut(amount, spenders[done + i].script))\n+            # Add change\n+            fund_tx.vout.append(CTxOut(balance - 10000, random.choice(host_spks)))\n+            # Ask the wallet to sign\n+            ss = BytesIO(bytes.fromhex(node.signrawtransactionwithwallet(ToHex(fund_tx))[\"hex\"]))\n+            fund_tx.deserialize(ss)\n+            # Construct UTXOData entries\n+            fund_tx.rehash()\n+            for i in range(count_this_tx):\n+                utxodata = UTXOData(outpoint=COutPoint(fund_tx.sha256, i), output=fund_tx.vout[i], spender=spenders[done])\n+                if utxodata.spender.need_vin_vout_mismatch:\n+                    mismatching_utxos.append(utxodata)\n+                else:\n+                    normal_utxos.append(utxodata)\n+                done += 1\n+            # Mine into a block\n+            self.block_submit(node, [fund_tx], \"Funding tx\", None, random.choice(host_pubkeys), 10000, MAX_BLOCK_SIGOPS_WEIGHT, True, True)\n+\n+        # Consume groups of choice(input_coins) from utxos in a tx, testing the spenders.\n+        self.log.info(\"- Running %i spending tests\" % done)\n+        random.shuffle(normal_utxos)\n+        random.shuffle(mismatching_utxos)\n+        assert done == len(normal_utxos) + len(mismatching_utxos)\n+\n+        left = done\n+        while left:\n+            # Construct CTransaction with random nVersion, nLocktime\n+            tx = CTransaction()\n+            tx.nVersion = random.choice([1, 2, random.randint(-0x80000000, 0x7fffffff)])\n+            min_sequence = (tx.nVersion != 1 and tx.nVersion != 0) * 0x80000000  # The minimum sequence number to disable relative locktime\n+            if random.choice([True, False]):\n+                tx.nLockTime = random.randrange(LOCKTIME_THRESHOLD, self.lastblocktime - 7200)  # all absolute locktimes in the past\n+            else:\n+                tx.nLockTime = random.randrange(self.lastblockheight + 1)  # all block heights in the past\n+\n+            # Decide how many UTXOs to test with.\n+            acceptable = [n for n in input_counts if n <= left and (left - n > max(input_counts) or (left - n) in [0] + input_counts)]\n+            num_inputs = random.choice(acceptable)\n+\n+            # If we have UTXOs that require mismatching inputs/outputs left, include exactly one of those\n+            # unless there is only one normal UTXO left (as tests with mismatching UTXOs require at least one\n+            # normal UTXO to go in the first position), and we don't want to run out of normal UTXOs.\n+            input_utxos = []\n+            while len(mismatching_utxos) and (len(input_utxos) == 0 or len(normal_utxos) == 1):\n+                input_utxos.append(mismatching_utxos.pop())\n+                left -= 1\n+\n+            # Top up until we hit num_inputs (but include at least one normal UTXO always).\n+            for _ in range(max(1, num_inputs - len(input_utxos))):\n+                input_utxos.append(normal_utxos.pop())\n+                left -= 1\n+\n+            # The first input cannot require a mismatching output (as there is at least one output).\n+            while True:\n+                random.shuffle(input_utxos)\n+                if not input_utxos[0].spender.need_vin_vout_mismatch:\n+                    break\n+            first_mismatch_input = None\n+            for i in range(len(input_utxos)):\n+                if input_utxos[i].spender.need_vin_vout_mismatch:\n+                    first_mismatch_input = i\n+            assert first_mismatch_input is None or first_mismatch_input > 0\n+\n+            # Decide fee, and add CTxIns to tx.\n+            amount = sum(utxo.output.nValue for utxo in input_utxos)\n+            fee = min(random.randrange(MIN_FEE * 2, MIN_FEE * 4), amount - DUST_LIMIT)  # 10000-20000 sat fee\n+            in_value = amount - fee\n+            tx.vin = [CTxIn(outpoint=utxo.outpoint, nSequence=random.randint(min_sequence, 0xffffffff)) for utxo in input_utxos]\n+            tx.wit.vtxinwit = [CTxInWitness() for _ in range(len(input_utxos))]\n+            sigops_weight = sum(utxo.spender.sigops_weight for utxo in input_utxos)\n+            self.log.debug(\"Test: %s\" % (\", \".join(utxo.spender.comment for utxo in input_utxos)))\n+\n+            # Add 1 to 4 random outputs (but constrained by inputs that require mismatching outputs)\n+            num_outputs = random.choice(range(1, 1 + min(4, 4 if first_mismatch_input is None else first_mismatch_input)))\n+            assert in_value >= 0 and fee - num_outputs * DUST_LIMIT >= MIN_FEE\n+            for i in range(num_outputs):\n+                tx.vout.append(CTxOut())\n+                if in_value <= DUST_LIMIT:\n+                    tx.vout[-1].nValue = DUST_LIMIT\n+                elif i < num_outputs - 1:\n+                    tx.vout[-1].nValue = in_value\n+                else:\n+                    tx.vout[-1].nValue = random.randint(DUST_LIMIT, in_value)\n+                in_value -= tx.vout[-1].nValue\n+                tx.vout[-1].scriptPubKey = random.choice(host_spks)\n+                sigops_weight += CScript(tx.vout[-1].scriptPubKey).GetSigOpCount(False) * WITNESS_SCALE_FACTOR\n+            fee += in_value\n+            assert fee >= 0\n+\n+            # Select coinbase pubkey\n+            cb_pubkey = random.choice(host_pubkeys)\n+            sigops_weight += 1 * WITNESS_SCALE_FACTOR\n+\n+            # Precompute one satisfying and one failing scriptSig/witness for each input.\n+            input_data = []\n+            for i in range(len(input_utxos)):\n+                fn = input_utxos[i].spender.sat_function\n+                fail = None\n+                success = fn(tx, i, [utxo.output for utxo in input_utxos], True)\n+                if not input_utxos[i].spender.no_fail:\n+                    fail = fn(tx, i, [utxo.output for utxo in input_utxos], False)\n+                input_data.append((fail, success))\n+\n+            # Sign each input incorrectly once on each complete signing pass, except the very last.\n+            for fail_input in list(range(len(input_utxos))) + [None]:\n+                # Skip trying to fail at spending something that can't be made to fail.\n+                if fail_input is not None and input_utxos[fail_input].spender.no_fail:\n+                    continue\n+                # Expected message with each input failure, may be None(which is ignored)\n+                expected_fail_msg = None if fail_input is None else input_utxos[fail_input].spender.err_msg\n+                # Fill inputs/witnesses\n+                for i in range(len(input_utxos)):\n+                    tx.vin[i].scriptSig = input_data[i][i != fail_input][0]\n+                    tx.wit.vtxinwit[i].scriptWitness.stack = input_data[i][i != fail_input][1]\n+                # Submit to mempool to check standardness\n+                is_standard_tx = fail_input is None and all(utxo.spender.is_standard for utxo in input_utxos) and tx.nVersion >= 1 and tx.nVersion <= 2\n+                tx.rehash()\n+                msg = ','.join(utxo.spender.comment + (\"*\" if n == fail_input else \"\") for n, utxo in enumerate(input_utxos))\n+                if is_standard_tx:\n+                    node.sendrawtransaction(tx.serialize().hex(), 0)\n+                    assert node.getmempoolentry(tx.hash) is not None, \"Failed to accept into mempool: \" + msg\n+                else:\n+                    assert_raises_rpc_error(-26, None, node.sendrawtransaction, tx.serialize().hex(), 0)\n+                # Submit in a block\n+                self.block_submit(node, [tx], msg, witness=True, accept=fail_input is None, cb_pubkey=cb_pubkey, fees=fee, sigops_weight=sigops_weight, err_msg=expected_fail_msg)\n+\n+            if (len(spenders) - left) // 200 > (len(spenders) - left - len(input_utxos)) // 200:\n+                self.log.info(\"  - %i tests done\" % (len(spenders) - left))\n+\n+        assert left == 0\n+        assert len(normal_utxos) == 0\n+        assert len(mismatching_utxos) == 0\n+        self.log.info(\"  - Done\")\n+\n+    def run_test(self):\n+        self.connect_nodes(0, 1)\n+\n+        # Post-taproot activation tests go first (pre-taproot tests' blocks are invalid post-taproot).\n+        self.log.info(\"Post-activation tests...\")\n+        self.nodes[1].generate(101)\n+        self.test_spenders(self.nodes[1], spenders_taproot_active(), input_counts=[1, 2, 2, 2, 2, 3])\n+\n+        # Transfer % of funds to pre-taproot node.\n+        addr = self.nodes[0].getnewaddress()\n+        self.nodes[1].sendtoaddress(address=addr, amount=int(self.nodes[1].getbalance() * 70000000) / 100000000)\n+        self.nodes[1].generate(1)\n+        self.sync_blocks()\n+\n+        # Pre-taproot activation tests.\n+        self.log.info(\"Pre-activation tests...\")\n+        self.test_spenders(self.nodes[0], spenders_taproot_inactive(), input_counts=[1, 2, 2, 2, 2, 3])\n+\n+\n+if __name__ == '__main__':\n+    TaprootTest().main()"
      },
      {
        "sha": "4be8b7d80b7b4aa5190d165f2c64602c09741ade",
        "filename": "test/functional/test_framework/blocktools.py",
        "status": "modified",
        "additions": 15,
        "deletions": 4,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f06e6d03452cf5e0b1a0863afb08c9e6d3ef452e/test/functional/test_framework/blocktools.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f06e6d03452cf5e0b1a0863afb08c9e6d3ef452e/test/functional/test_framework/blocktools.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/blocktools.py?ref=f06e6d03452cf5e0b1a0863afb08c9e6d3ef452e",
        "patch": "@@ -43,7 +43,9 @@\n from .util import assert_equal\n from io import BytesIO\n \n+WITNESS_SCALE_FACTOR = 4\n MAX_BLOCK_SIGOPS = 20000\n+MAX_BLOCK_SIGOPS_WEIGHT = MAX_BLOCK_SIGOPS * WITNESS_SCALE_FACTOR\n \n # Genesis block time (regtest)\n TIME_GENESIS_BLOCK = 1296688602\n@@ -101,22 +103,31 @@ def script_BIP34_coinbase_height(height):\n     return CScript([CScriptNum(height)])\n \n \n-def create_coinbase(height, pubkey=None):\n-    \"\"\"Create a coinbase transaction, assuming no miner fees.\n+def create_coinbase(height, pubkey=None, extra_output_script=None, fees=0):\n+    \"\"\"Create a coinbase transaction.\n \n     If pubkey is passed in, the coinbase output will be a P2PK output;\n-    otherwise an anyone-can-spend output.\"\"\"\n+    otherwise an anyone-can-spend output.\n+\n+    If extra_output_script is given, make a 0-value output to that\n+    script. This is useful to pad block weight/sigops as needed. \"\"\"\n     coinbase = CTransaction()\n     coinbase.vin.append(CTxIn(COutPoint(0, 0xffffffff), script_BIP34_coinbase_height(height), 0xffffffff))\n     coinbaseoutput = CTxOut()\n     coinbaseoutput.nValue = 50 * COIN\n     halvings = int(height / 150)  # regtest\n     coinbaseoutput.nValue >>= halvings\n-    if (pubkey is not None):\n+    coinbaseoutput.nValue += fees\n+    if pubkey is not None:\n         coinbaseoutput.scriptPubKey = CScript([pubkey, OP_CHECKSIG])\n     else:\n         coinbaseoutput.scriptPubKey = CScript([OP_TRUE])\n     coinbase.vout = [coinbaseoutput]\n+    if extra_output_script is not None:\n+        coinbaseoutput2 = CTxOut()\n+        coinbaseoutput2.nValue = 0\n+        coinbaseoutput2.scriptPubKey = extra_output_script\n+        coinbase.vout.append(coinbaseoutput2)\n     coinbase.calc_sha256()\n     return coinbase\n "
      },
      {
        "sha": "17b869e542696b376b39c70f9a9abf7378becc62",
        "filename": "test/functional/test_framework/key.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f06e6d03452cf5e0b1a0863afb08c9e6d3ef452e/test/functional/test_framework/key.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f06e6d03452cf5e0b1a0863afb08c9e6d3ef452e/test/functional/test_framework/key.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/key.py?ref=f06e6d03452cf5e0b1a0863afb08c9e6d3ef452e",
        "patch": "@@ -476,7 +476,7 @@ def verify_schnorr(key, sig, msg):\n         return False\n     return True\n \n-def sign_schnorr(key, msg, aux=None):\n+def sign_schnorr(key, msg, aux=None, flip_p=False, flip_r=False):\n     \"\"\"Create a Schnorr signature (see BIP 340).\"\"\"\n \n     if aux is None:\n@@ -490,13 +490,13 @@ def sign_schnorr(key, msg, aux=None):\n     if sec == 0 or sec >= SECP256K1_ORDER:\n         return None\n     P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, sec)]))\n-    if not SECP256K1.has_even_y(P):\n+    if SECP256K1.has_even_y(P) == flip_p:\n         sec = SECP256K1_ORDER - sec\n     t = (sec ^ int.from_bytes(TaggedHash(\"BIP0340/aux\", aux), 'big')).to_bytes(32, 'big')\n     kp = int.from_bytes(TaggedHash(\"BIP0340/nonce\", t + P[0].to_bytes(32, 'big') + msg), 'big') % SECP256K1_ORDER\n     assert kp != 0\n     R = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, kp)]))\n-    k = kp if SECP256K1.has_even_y(R) else SECP256K1_ORDER - kp\n+    k = kp if SECP256K1.has_even_y(R) != flip_r else SECP256K1_ORDER - kp\n     e = int.from_bytes(TaggedHash(\"BIP0340/challenge\", R[0].to_bytes(32, 'big') + P[0].to_bytes(32, 'big') + msg), 'big') % SECP256K1_ORDER\n     return R[0].to_bytes(32, 'big') + ((k + e * sec) % SECP256K1_ORDER).to_bytes(32, 'big')\n "
      },
      {
        "sha": "8e5848d49359b06e0ca168f1edf4a8a6d0fe6297",
        "filename": "test/functional/test_framework/script.py",
        "status": "modified",
        "additions": 123,
        "deletions": 10,
        "changes": 133,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f06e6d03452cf5e0b1a0863afb08c9e6d3ef452e/test/functional/test_framework/script.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f06e6d03452cf5e0b1a0863afb08c9e6d3ef452e/test/functional/test_framework/script.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/script.py?ref=f06e6d03452cf5e0b1a0863afb08c9e6d3ef452e",
        "patch": "@@ -6,11 +6,15 @@\n \n This file is modified from python-bitcoinlib.\n \"\"\"\n+\n+from collections import namedtuple\n import hashlib\n import struct\n import unittest\n from typing import List, Dict\n \n+from .key import TaggedHash, tweak_add_pubkey\n+\n from .messages import (\n     CTransaction,\n     CTxOut,\n@@ -22,8 +26,13 @@\n )\n \n MAX_SCRIPT_ELEMENT_SIZE = 520\n+LOCKTIME_THRESHOLD = 500000000\n+ANNEX_TAG = 0x50\n+\n OPCODE_NAMES = {}  # type: Dict[CScriptOp, str]\n \n+LEAF_VERSION_TAPSCRIPT = 0xc0\n+\n def hash160(s):\n     return hashlib.new('ripemd160', sha256(s)).digest()\n \n@@ -239,11 +248,8 @@ def __new__(cls, n):\n OP_NOP9 = CScriptOp(0xb8)\n OP_NOP10 = CScriptOp(0xb9)\n \n-# template matching params\n-OP_SMALLINTEGER = CScriptOp(0xfa)\n-OP_PUBKEYS = CScriptOp(0xfb)\n-OP_PUBKEYHASH = CScriptOp(0xfd)\n-OP_PUBKEY = CScriptOp(0xfe)\n+# BIP 342 opcodes (Tapscript)\n+OP_CHECKSIGADD = CScriptOp(0xba)\n \n OP_INVALIDOPCODE = CScriptOp(0xff)\n \n@@ -359,10 +365,7 @@ def __new__(cls, n):\n     OP_NOP8: 'OP_NOP8',\n     OP_NOP9: 'OP_NOP9',\n     OP_NOP10: 'OP_NOP10',\n-    OP_SMALLINTEGER: 'OP_SMALLINTEGER',\n-    OP_PUBKEYS: 'OP_PUBKEYS',\n-    OP_PUBKEYHASH: 'OP_PUBKEYHASH',\n-    OP_PUBKEY: 'OP_PUBKEY',\n+    OP_CHECKSIGADD: 'OP_CHECKSIGADD',\n     OP_INVALIDOPCODE: 'OP_INVALIDOPCODE',\n })\n \n@@ -593,6 +596,7 @@ def GetSigOpCount(self, fAccurate):\n         return n\n \n \n+SIGHASH_DEFAULT = 0 # Taproot-only default, semantics same as SIGHASH_ALL\n SIGHASH_ALL = 1\n SIGHASH_NONE = 2\n SIGHASH_SINGLE = 3\n@@ -615,7 +619,6 @@ def FindAndDelete(script, sig):\n         r += script[last_sop_idx:]\n     return CScript(r)\n \n-\n def LegacySignatureHash(script, txTo, inIdx, hashtype):\n     \"\"\"Consensus-correct SignatureHash\n \n@@ -738,3 +741,113 @@ def test_cscriptnum_encoding(self):\n         values = [0, 1, -1, -2, 127, 128, -255, 256, (1 << 15) - 1, -(1 << 16), (1 << 24) - 1, (1 << 31), 1 - (1 << 32), 1 << 40, 1500, -1500]\n         for value in values:\n             self.assertEqual(CScriptNum.decode(CScriptNum.encode(CScriptNum(value))), value)\n+\n+def TaprootSignatureHash(txTo, spent_utxos, hash_type, input_index = 0, scriptpath = False, script = CScript(), codeseparator_pos = -1, annex = None, leaf_ver = LEAF_VERSION_TAPSCRIPT):\n+    assert (len(txTo.vin) == len(spent_utxos))\n+    assert (input_index < len(txTo.vin))\n+    out_type = SIGHASH_ALL if hash_type == 0 else hash_type & 3\n+    in_type = hash_type & SIGHASH_ANYONECANPAY\n+    spk = spent_utxos[input_index].scriptPubKey\n+    ss = bytes([0, hash_type]) # epoch, hash_type\n+    ss += struct.pack(\"<i\", txTo.nVersion)\n+    ss += struct.pack(\"<I\", txTo.nLockTime)\n+    if in_type != SIGHASH_ANYONECANPAY:\n+        ss += sha256(b\"\".join(i.prevout.serialize() for i in txTo.vin))\n+        ss += sha256(b\"\".join(struct.pack(\"<q\", u.nValue) for u in spent_utxos))\n+        ss += sha256(b\"\".join(ser_string(u.scriptPubKey) for u in spent_utxos))\n+        ss += sha256(b\"\".join(struct.pack(\"<I\", i.nSequence) for i in txTo.vin))\n+    if out_type == SIGHASH_ALL:\n+        ss += sha256(b\"\".join(o.serialize() for o in txTo.vout))\n+    spend_type = 0\n+    if annex is not None:\n+        spend_type |= 1\n+    if (scriptpath):\n+        spend_type |= 2\n+    ss += bytes([spend_type])\n+    if in_type == SIGHASH_ANYONECANPAY:\n+        ss += txTo.vin[input_index].prevout.serialize()\n+        ss += struct.pack(\"<q\", spent_utxos[input_index].nValue)\n+        ss += ser_string(spk)\n+        ss += struct.pack(\"<I\", txTo.vin[input_index].nSequence)\n+    else:\n+        ss += struct.pack(\"<I\", input_index)\n+    if (spend_type & 1):\n+        ss += sha256(ser_string(annex))\n+    if out_type == SIGHASH_SINGLE:\n+        if input_index < len(txTo.vout):\n+            ss += sha256(txTo.vout[input_index].serialize())\n+        else:\n+            ss += bytes(0 for _ in range(32))\n+    if (scriptpath):\n+        ss += TaggedHash(\"TapLeaf\", bytes([leaf_ver]) + ser_string(script))\n+        ss += bytes([0])\n+        ss += struct.pack(\"<i\", codeseparator_pos)\n+    assert len(ss) ==  175 - (in_type == SIGHASH_ANYONECANPAY) * 49 - (out_type != SIGHASH_ALL and out_type != SIGHASH_SINGLE) * 32 + (annex is not None) * 32 + scriptpath * 37\n+    return TaggedHash(\"TapSighash\", ss)\n+\n+def taproot_tree_helper(scripts):\n+    if len(scripts) == 0:\n+        return ([], bytes(0 for _ in range(32)))\n+    if len(scripts) == 1:\n+        # One entry: treat as a leaf\n+        script = scripts[0]\n+        assert(not callable(script))\n+        if isinstance(script, list):\n+            return taproot_tree_helper(script)\n+        assert(isinstance(script, tuple))\n+        version = LEAF_VERSION_TAPSCRIPT\n+        name = script[0]\n+        code = script[1]\n+        if len(script) == 3:\n+            version = script[2]\n+        assert version & 1 == 0\n+        assert isinstance(code, bytes)\n+        h = TaggedHash(\"TapLeaf\", bytes([version]) + ser_string(code))\n+        if name is None:\n+            return ([], h)\n+        return ([(name, version, code, bytes())], h)\n+    elif len(scripts) == 2 and callable(scripts[1]):\n+        # Two entries, and the right one is a function\n+        left, left_h = taproot_tree_helper(scripts[0:1])\n+        right_h = scripts[1](left_h)\n+        left = [(name, version, script, control + right_h) for name, version, script, control in left]\n+        right = []\n+    else:\n+        # Two or more entries: descend into each side\n+        split_pos = len(scripts) // 2\n+        left, left_h = taproot_tree_helper(scripts[0:split_pos])\n+        right, right_h = taproot_tree_helper(scripts[split_pos:])\n+        left = [(name, version, script, control + right_h) for name, version, script, control in left]\n+        right = [(name, version, script, control + left_h) for name, version, script, control in right]\n+    if right_h < left_h:\n+        right_h, left_h = left_h, right_h\n+    h = TaggedHash(\"TapBranch\", left_h + right_h)\n+    return (left + right, h)\n+\n+TaprootInfo = namedtuple(\"TaprootInfo\", \"scriptPubKey,inner_pubkey,negflag,tweak,leaves\")\n+TaprootLeafInfo = namedtuple(\"TaprootLeafInfo\", \"script,version,merklebranch\")\n+\n+def taproot_construct(pubkey, scripts=None):\n+    \"\"\"Construct a tree of Taproot spending conditions\n+\n+    pubkey: an ECPubKey object for the internal pubkey\n+    scripts: a list of items; each item is either:\n+             - a (name, CScript) tuple\n+             - a (name, CScript, leaf version) tuple\n+             - another list of items (with the same structure)\n+             - a function, which specifies how to compute the hashing partner\n+               in function of the hash of whatever it is combined with\n+\n+    Returns: script (sPK or redeemScript), tweak, {name:(script, leaf version, negation flag, innerkey, merklepath), ...}\n+    \"\"\"\n+    if scripts is None:\n+        scripts = []\n+\n+    ret, h = taproot_tree_helper(scripts)\n+    tweak = TaggedHash(\"TapTweak\", pubkey + h)\n+    tweaked, negated = tweak_add_pubkey(pubkey, tweak)\n+    leaves = dict((name, TaprootLeafInfo(script, version, merklebranch)) for name, version, script, merklebranch in ret)\n+    return TaprootInfo(CScript([OP_1, tweaked]), pubkey, negated + 0, tweak, leaves)\n+\n+def is_op_success(o):\n+    return o == 0x50 or o == 0x62 or o == 0x89 or o == 0x8a or o == 0x8d or o == 0x8e or (o >= 0x7e and o <= 0x81) or (o >= 0x83 and o <= 0x86) or (o >= 0x95 and o <= 0x99) or (o >= 0xbb and o <= 0xfe)"
      },
      {
        "sha": "ed6e830bb97910367eaef5f09cd34f8c3406f4f1",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f06e6d03452cf5e0b1a0863afb08c9e6d3ef452e/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f06e6d03452cf5e0b1a0863afb08c9e6d3ef452e/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=f06e6d03452cf5e0b1a0863afb08c9e6d3ef452e",
        "patch": "@@ -107,6 +107,7 @@\n     'mempool_updatefromblock.py',\n     'wallet_dump.py',\n     'wallet_listtransactions.py',\n+    'feature_taproot.py',\n     # vv Tests less than 60s vv\n     'p2p_sendheaders.py',\n     'wallet_importmulti.py',"
      }
    ]
  },
  {
    "sha": "4567ba034c5ae6e6cc161360f7425c9e844738f0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NTY3YmEwMzRjNWFlNmU2Y2MxNjEzNjBmNzQyNWM5ZTg0NDczOGYw",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-09-16T04:00:43Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-13T00:18:47Z"
      },
      "message": "tests: add generic qa-asset-based script verification unit test\n\nThis adds a unit test that does generic script verification tests,\nwith positive/negative witnesses/scriptsigs, under various flags.\nThe test data is large (several MB) so it's stored in the qa-assets\nrepo.",
      "tree": {
        "sha": "0cb9fec9a534609c5a8584a0531bcf0140bbd030",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0cb9fec9a534609c5a8584a0531bcf0140bbd030"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4567ba034c5ae6e6cc161360f7425c9e844738f0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4567ba034c5ae6e6cc161360f7425c9e844738f0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4567ba034c5ae6e6cc161360f7425c9e844738f0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4567ba034c5ae6e6cc161360f7425c9e844738f0/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f06e6d03452cf5e0b1a0863afb08c9e6d3ef452e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f06e6d03452cf5e0b1a0863afb08c9e6d3ef452e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f06e6d03452cf5e0b1a0863afb08c9e6d3ef452e"
      }
    ],
    "stats": {
      "total": 145,
      "additions": 137,
      "deletions": 8
    },
    "files": [
      {
        "sha": "632bccf574bd5f4a2cfa56aca30c821b9208ca0e",
        "filename": "ci/test/04_install.sh",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4567ba034c5ae6e6cc161360f7425c9e844738f0/ci/test/04_install.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4567ba034c5ae6e6cc161360f7425c9e844738f0/ci/test/04_install.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/04_install.sh?ref=4567ba034c5ae6e6cc161360f7425c9e844738f0",
        "patch": "@@ -81,11 +81,10 @@ else\n fi\n \n if [ ! -d ${DIR_QA_ASSETS} ]; then\n- if [ \"$RUN_FUZZ_TESTS\" = \"true\" ]; then\n-  DOCKER_EXEC git clone https://github.com/bitcoin-core/qa-assets ${DIR_QA_ASSETS}\n- fi\n+  DOCKER_EXEC git clone --depth=1 https://github.com/bitcoin-core/qa-assets ${DIR_QA_ASSETS}\n fi\n export DIR_FUZZ_IN=${DIR_QA_ASSETS}/fuzz_seed_corpus/\n+export DIR_UNIT_TEST_DATA=${DIR_QA_ASSETS}/unit_test_data/\n \n DOCKER_EXEC mkdir -p \"${BASE_SCRATCH_DIR}/sanitizer-output/\"\n "
      },
      {
        "sha": "607a2820dd578c10abdc52570e5f34f328ae5372",
        "filename": "ci/test/06_script_b.sh",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4567ba034c5ae6e6cc161360f7425c9e844738f0/ci/test/06_script_b.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4567ba034c5ae6e6cc161360f7425c9e844738f0/ci/test/06_script_b.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/06_script_b.sh?ref=4567ba034c5ae6e6cc161360f7425c9e844738f0",
        "patch": "@@ -23,13 +23,13 @@ fi\n \n if [ \"$RUN_UNIT_TESTS\" = \"true\" ]; then\n   BEGIN_FOLD unit-tests\n-  DOCKER_EXEC LD_LIBRARY_PATH=$DEPENDS_DIR/$HOST/lib make $MAKEJOBS check VERBOSE=1\n+  DOCKER_EXEC DIR_UNIT_TEST_DATA=${DIR_UNIT_TEST_DATA} LD_LIBRARY_PATH=$DEPENDS_DIR/$HOST/lib make $MAKEJOBS check VERBOSE=1\n   END_FOLD\n fi\n \n if [ \"$RUN_UNIT_TESTS_SEQUENTIAL\" = \"true\" ]; then\n   BEGIN_FOLD unit-tests-seq\n-  DOCKER_EXEC LD_LIBRARY_PATH=$DEPENDS_DIR/$HOST/lib \"${BASE_BUILD_DIR}/bitcoin-*/src/test/test_bitcoin*\" --catch_system_errors=no -l test_suite\n+  DOCKER_EXEC DIR_UNIT_TEST_DATA=${DIR_UNIT_TEST_DATA} LD_LIBRARY_PATH=$DEPENDS_DIR/$HOST/lib \"${BASE_BUILD_DIR}/bitcoin-*/src/test/test_bitcoin*\" --catch_system_errors=no -l test_suite\n   END_FOLD\n fi\n "
      },
      {
        "sha": "3132f440afd998c6e4ca509c89ce95e882dee2cd",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 132,
        "deletions": 3,
        "changes": 135,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4567ba034c5ae6e6cc161360f7425c9e844738f0/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4567ba034c5ae6e6cc161360f7425c9e844738f0/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=4567ba034c5ae6e6cc161360f7425c9e844738f0",
        "patch": "@@ -5,10 +5,12 @@\n #include <test/data/script_tests.json.h>\n \n #include <core_io.h>\n+#include <fs.h>\n #include <key.h>\n #include <rpc/util.h>\n #include <script/script.h>\n #include <script/script_error.h>\n+#include <script/sigcache.h>\n #include <script/sign.h>\n #include <script/signingprovider.h>\n #include <streams.h>\n@@ -1339,13 +1341,41 @@ BOOST_AUTO_TEST_CASE(script_GetScriptAsm)\n     BOOST_CHECK_EQUAL(derSig + \"83 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"83\")) << vchPubKey));\n }\n \n-static CScript\n-ScriptFromHex(const char* hex)\n+static CScript ScriptFromHex(const std::string& str)\n {\n-    std::vector<unsigned char> data = ParseHex(hex);\n+    std::vector<unsigned char> data = ParseHex(str);\n     return CScript(data.begin(), data.end());\n }\n \n+static CMutableTransaction TxFromHex(const std::string& str)\n+{\n+    CMutableTransaction tx;\n+    VectorReader(SER_DISK, SERIALIZE_TRANSACTION_NO_WITNESS, ParseHex(str), 0) >> tx;\n+    return tx;\n+}\n+\n+static std::vector<CTxOut> TxOutsFromJSON(const UniValue& univalue)\n+{\n+    assert(univalue.isArray());\n+    std::vector<CTxOut> prevouts;\n+    for (size_t i = 0; i < univalue.size(); ++i) {\n+        CTxOut txout;\n+        VectorReader(SER_DISK, 0, ParseHex(univalue[i].get_str()), 0) >> txout;\n+        prevouts.push_back(std::move(txout));\n+    }\n+    return prevouts;\n+}\n+\n+static CScriptWitness ScriptWitnessFromJSON(const UniValue& univalue)\n+{\n+    assert(univalue.isArray());\n+    CScriptWitness scriptwitness;\n+    for (size_t i = 0; i < univalue.size(); ++i) {\n+        auto bytes = ParseHex(univalue[i].get_str());\n+        scriptwitness.stack.push_back(std::move(bytes));\n+    }\n+    return scriptwitness;\n+}\n \n BOOST_AUTO_TEST_CASE(script_FindAndDelete)\n {\n@@ -1610,5 +1640,104 @@ BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_invalid_flags)\n     BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_INVALID_FLAGS);\n }\n \n+static std::vector<unsigned int> AllConsensusFlags()\n+{\n+    std::vector<unsigned int> ret;\n+\n+    for (unsigned int i = 0; i < 128; ++i) {\n+        unsigned int flag = 0;\n+        if (i & 1) flag |= SCRIPT_VERIFY_P2SH;\n+        if (i & 2) flag |= SCRIPT_VERIFY_DERSIG;\n+        if (i & 4) flag |= SCRIPT_VERIFY_NULLDUMMY;\n+        if (i & 8) flag |= SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY;\n+        if (i & 16) flag |= SCRIPT_VERIFY_CHECKSEQUENCEVERIFY;\n+        if (i & 32) flag |= SCRIPT_VERIFY_WITNESS;\n+        if (i & 64) flag |= SCRIPT_VERIFY_TAPROOT;\n+\n+        // SCRIPT_VERIFY_WITNESS requires SCRIPT_VERIFY_P2SH\n+        if (flag & SCRIPT_VERIFY_WITNESS && !(flag & SCRIPT_VERIFY_P2SH)) continue;\n+        // SCRIPT_VERIFY_TAPROOT requires SCRIPT_VERIFY_WITNESS\n+        if (flag & SCRIPT_VERIFY_TAPROOT && !(flag & SCRIPT_VERIFY_WITNESS)) continue;\n+\n+        ret.push_back(flag);\n+    }\n+\n+    return ret;\n+}\n+\n+/** Precomputed list of all valid combinations of consensus-relevant script validation flags. */\n+static const std::vector<unsigned int> ALL_CONSENSUS_FLAGS = AllConsensusFlags();\n+\n+static void AssetTest(const UniValue& test)\n+{\n+    BOOST_CHECK(test.isObject());\n+\n+    CMutableTransaction mtx = TxFromHex(test[\"tx\"].get_str());\n+    const std::vector<CTxOut> prevouts = TxOutsFromJSON(test[\"prevouts\"]);\n+    BOOST_CHECK(prevouts.size() == mtx.vin.size());\n+    size_t idx = test[\"index\"].get_int64();\n+    unsigned int test_flags = ParseScriptFlags(test[\"flags\"].get_str());\n+    bool fin = test.exists(\"final\") && test[\"final\"].get_bool();\n+\n+    if (test.exists(\"success\")) {\n+        mtx.vin[idx].scriptSig = ScriptFromHex(test[\"success\"][\"scriptSig\"].get_str());\n+        mtx.vin[idx].scriptWitness = ScriptWitnessFromJSON(test[\"success\"][\"witness\"]);\n+        CTransaction tx(mtx);\n+        PrecomputedTransactionData txdata;\n+        txdata.Init(tx, std::vector<CTxOut>(prevouts));\n+        CachingTransactionSignatureChecker txcheck(&tx, idx, prevouts[idx].nValue, true, txdata);\n+        for (const auto flags : ALL_CONSENSUS_FLAGS) {\n+            // \"final\": true tests are valid for all flags. Others are only valid with flags that are\n+            // a subset of test_flags.\n+            if (fin || ((flags & test_flags) == flags)) {\n+                bool ret = VerifyScript(tx.vin[idx].scriptSig, prevouts[idx].scriptPubKey, &tx.vin[idx].scriptWitness, flags, txcheck, nullptr);\n+                BOOST_CHECK(ret);\n+            }\n+        }\n+    }\n+\n+    if (test.exists(\"failure\")) {\n+        mtx.vin[idx].scriptSig = ScriptFromHex(test[\"failure\"][\"scriptSig\"].get_str());\n+        mtx.vin[idx].scriptWitness = ScriptWitnessFromJSON(test[\"failure\"][\"witness\"]);\n+        CTransaction tx(mtx);\n+        PrecomputedTransactionData txdata;\n+        txdata.Init(tx, std::vector<CTxOut>(prevouts));\n+        CachingTransactionSignatureChecker txcheck(&tx, idx, prevouts[idx].nValue, true, txdata);\n+        for (const auto flags : ALL_CONSENSUS_FLAGS) {\n+            // If a test is supposed to fail with test_flags, it should also fail with any superset thereof.\n+            if ((flags & test_flags) == test_flags) {\n+                bool ret = VerifyScript(tx.vin[idx].scriptSig, prevouts[idx].scriptPubKey, &tx.vin[idx].scriptWitness, flags, txcheck, nullptr);\n+                BOOST_CHECK(!ret);\n+            }\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_assets_test)\n+{\n+    const char* dir = std::getenv(\"DIR_UNIT_TEST_DATA\");\n+    BOOST_WARN_MESSAGE(dir != nullptr, \"Variable DIR_UNIT_TEST_DATA unset, skipping script_assets_test\");\n+    if (dir == nullptr) return;\n+    auto path = fs::path(dir) / \"script_assets_test.json\";\n+    bool exists = fs::exists(path);\n+    BOOST_WARN_MESSAGE(exists, \"File $DIR_UNIT_TEST_DATA/script_assets_test.json not found, skipping script_assets_test\");\n+    if (!exists) return;\n+    fs::ifstream file(path);\n+    BOOST_CHECK(file.is_open());\n+    file.seekg(0, std::ios::end);\n+    size_t length = file.tellg();\n+    file.seekg(0, std::ios::beg);\n+    std::string data(length, '\\0');\n+    file.read(&data[0], data.size());\n+    UniValue tests = read_json(data);\n+    BOOST_CHECK(tests.isArray());\n+    BOOST_CHECK(tests.size() > 0);\n+\n+    for (size_t i = 0; i < tests.size(); i++) {\n+        AssetTest(tests[i]);\n+    }\n+    file.close();\n+}\n+\n #endif\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "b7ee2803366e1c36b6d6113950ed1199d05b6735",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4567ba034c5ae6e6cc161360f7425c9e844738f0/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4567ba034c5ae6e6cc161360f7425c9e844738f0/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=4567ba034c5ae6e6cc161360f7425c9e844738f0",
        "patch": "@@ -57,6 +57,7 @@ static std::map<std::string, unsigned int> mapFlagNames = {\n     {std::string(\"DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM},\n     {std::string(\"WITNESS_PUBKEYTYPE\"), (unsigned int)SCRIPT_VERIFY_WITNESS_PUBKEYTYPE},\n     {std::string(\"CONST_SCRIPTCODE\"), (unsigned int)SCRIPT_VERIFY_CONST_SCRIPTCODE},\n+    {std::string(\"TAPROOT\"), (unsigned int)SCRIPT_VERIFY_TAPROOT},\n };\n \n unsigned int ParseScriptFlags(std::string strFlags)"
      }
    ]
  },
  {
    "sha": "0e2a5e448f426219a6464b9aaadcc715534114e6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowZTJhNWU0NDhmNDI2MjE5YTY0NjRiOWFhYWRjYzcxNTUzNDExNGU2",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-02T06:24:00Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-13T00:18:47Z"
      },
      "message": "tests: dumping and minimizing of script assets data\n\nThis adds a --dumptests flag to the feature_taproot.py test, to dump all its\ngenerated test cases to files, in a format compatible with the\nscript_assets_test unit test. A fuzzer for said format is added as well, whose\nprimary purpose is coverage-based minimization of those dumps.",
      "tree": {
        "sha": "b277fd73cf801b7066d1dee33b2b8858b98cb7b5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b277fd73cf801b7066d1dee33b2b8858b98cb7b5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0e2a5e448f426219a6464b9aaadcc715534114e6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0e2a5e448f426219a6464b9aaadcc715534114e6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0e2a5e448f426219a6464b9aaadcc715534114e6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0e2a5e448f426219a6464b9aaadcc715534114e6/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4567ba034c5ae6e6cc161360f7425c9e844738f0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4567ba034c5ae6e6cc161360f7425c9e844738f0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4567ba034c5ae6e6cc161360f7425c9e844738f0"
      }
    ],
    "stats": {
      "total": 259,
      "additions": 258,
      "deletions": 1
    },
    "files": [
      {
        "sha": "28608715b4c30f494ffce9fa18ee402dfba11372",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2a5e448f426219a6464b9aaadcc715534114e6/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2a5e448f426219a6464b9aaadcc715534114e6/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=0e2a5e448f426219a6464b9aaadcc715534114e6",
        "patch": "@@ -129,6 +129,7 @@ FUZZ_TARGETS = \\\n   test/fuzz/script_deserialize \\\n   test/fuzz/script_flags \\\n   test/fuzz/script_interpreter \\\n+  test/fuzz/script_assets_test_minimizer \\\n   test/fuzz/script_ops \\\n   test/fuzz/script_sigcache \\\n   test/fuzz/script_sign \\\n@@ -1082,6 +1083,12 @@ test_fuzz_script_interpreter_LDADD = $(FUZZ_SUITE_LD_COMMON)\n test_fuzz_script_interpreter_LDFLAGS = $(FUZZ_SUITE_LDFLAGS_COMMON)\n test_fuzz_script_interpreter_SOURCES = test/fuzz/script_interpreter.cpp\n \n+test_fuzz_script_assets_test_minimizer_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n+test_fuzz_script_assets_test_minimizer_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+test_fuzz_script_assets_test_minimizer_LDADD = $(FUZZ_SUITE_LD_COMMON)\n+test_fuzz_script_assets_test_minimizer_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n+test_fuzz_script_assets_test_minimizer_SOURCES = test/fuzz/script_assets_test_minimizer.cpp\n+\n test_fuzz_script_ops_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n test_fuzz_script_ops_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_script_ops_LDADD = $(FUZZ_SUITE_LD_COMMON)"
      },
      {
        "sha": "d20fa43d68a1d746a52d7fc91736cd159000913c",
        "filename": "src/test/fuzz/script_assets_test_minimizer.cpp",
        "status": "added",
        "additions": 200,
        "deletions": 0,
        "changes": 200,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2a5e448f426219a6464b9aaadcc715534114e6/src/test/fuzz/script_assets_test_minimizer.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2a5e448f426219a6464b9aaadcc715534114e6/src/test/fuzz/script_assets_test_minimizer.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/script_assets_test_minimizer.cpp?ref=0e2a5e448f426219a6464b9aaadcc715534114e6",
        "patch": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <test/fuzz/fuzz.h>\n+\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/interpreter.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <univalue.h>\n+#include <util/strencodings.h>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <cstdint>\n+#include <string>\n+#include <vector>\n+\n+// This fuzz \"test\" can be used to minimize test cases for script_assets_test in\n+// src/test/script_tests.cpp. While it written as a fuzz test, and can be used as such,\n+// fuzzing the inputs is unlikely to construct useful test cases.\n+//\n+// Instead, it is primarily intended to be run on a test set that was generated\n+// externally, for example using test/functional/feature_taproot.py's --dumptests mode.\n+// The minimized set can then be concatenated together, surrounded by '[' and ']',\n+// and used as the script_assets_test.json input to the script_assets_test unit test:\n+//\n+// (normal build)\n+// $ mkdir dump\n+// $ for N in $(seq 1 10); do TEST_DUMP_DIR=dump test/functional/feature_taproot --dumptests; done\n+// $ ...\n+//\n+// (fuzz test build)\n+// $ mkdir dump-min\n+// $ ./src/test/fuzz/script_assets_test_minimizer -merge=1 dump-min/ dump/\n+// $ (echo -en '[\\n'; cat dump-min/* | head -c -2; echo -en '\\n]') >script_assets_test.json\n+\n+namespace {\n+\n+std::vector<unsigned char> CheckedParseHex(const std::string& str)\n+{\n+    if (str.size() && !IsHex(str)) throw std::runtime_error(\"Non-hex input '\" + str + \"'\");\n+    return ParseHex(str);\n+}\n+\n+CScript ScriptFromHex(const std::string& str)\n+{\n+    std::vector<unsigned char> data = CheckedParseHex(str);\n+    return CScript(data.begin(), data.end());\n+}\n+\n+CMutableTransaction TxFromHex(const std::string& str)\n+{\n+    CMutableTransaction tx;\n+    try {\n+        VectorReader(SER_DISK, SERIALIZE_TRANSACTION_NO_WITNESS, CheckedParseHex(str), 0) >> tx;\n+    } catch (const std::ios_base::failure&) {\n+        throw std::runtime_error(\"Tx deserialization failure\");\n+    }\n+    return tx;\n+}\n+\n+std::vector<CTxOut> TxOutsFromJSON(const UniValue& univalue)\n+{\n+    if (!univalue.isArray()) throw std::runtime_error(\"Prevouts must be array\");\n+    std::vector<CTxOut> prevouts;\n+    for (size_t i = 0; i < univalue.size(); ++i) {\n+        CTxOut txout;\n+        try {\n+            VectorReader(SER_DISK, 0, CheckedParseHex(univalue[i].get_str()), 0) >> txout;\n+        } catch (const std::ios_base::failure&) {\n+            throw std::runtime_error(\"Prevout invalid format\");\n+        }\n+        prevouts.push_back(std::move(txout));\n+    }\n+    return prevouts;\n+}\n+\n+CScriptWitness ScriptWitnessFromJSON(const UniValue& univalue)\n+{\n+    if (!univalue.isArray()) throw std::runtime_error(\"Script witness is not array\");\n+    CScriptWitness scriptwitness;\n+    for (size_t i = 0; i < univalue.size(); ++i) {\n+        auto bytes = CheckedParseHex(univalue[i].get_str());\n+        scriptwitness.stack.push_back(std::move(bytes));\n+    }\n+    return scriptwitness;\n+}\n+\n+const std::map<std::string, unsigned int> FLAG_NAMES = {\n+    {std::string(\"P2SH\"), (unsigned int)SCRIPT_VERIFY_P2SH},\n+    {std::string(\"DERSIG\"), (unsigned int)SCRIPT_VERIFY_DERSIG},\n+    {std::string(\"NULLDUMMY\"), (unsigned int)SCRIPT_VERIFY_NULLDUMMY},\n+    {std::string(\"CHECKLOCKTIMEVERIFY\"), (unsigned int)SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY},\n+    {std::string(\"CHECKSEQUENCEVERIFY\"), (unsigned int)SCRIPT_VERIFY_CHECKSEQUENCEVERIFY},\n+    {std::string(\"WITNESS\"), (unsigned int)SCRIPT_VERIFY_WITNESS},\n+    {std::string(\"TAPROOT\"), (unsigned int)SCRIPT_VERIFY_TAPROOT},\n+};\n+\n+std::vector<unsigned int> AllFlags()\n+{\n+    std::vector<unsigned int> ret;\n+\n+    for (unsigned int i = 0; i < 128; ++i) {\n+        unsigned int flag = 0;\n+        if (i & 1) flag |= SCRIPT_VERIFY_P2SH;\n+        if (i & 2) flag |= SCRIPT_VERIFY_DERSIG;\n+        if (i & 4) flag |= SCRIPT_VERIFY_NULLDUMMY;\n+        if (i & 8) flag |= SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY;\n+        if (i & 16) flag |= SCRIPT_VERIFY_CHECKSEQUENCEVERIFY;\n+        if (i & 32) flag |= SCRIPT_VERIFY_WITNESS;\n+        if (i & 64) flag |= SCRIPT_VERIFY_TAPROOT;\n+\n+        // SCRIPT_VERIFY_WITNESS requires SCRIPT_VERIFY_P2SH\n+        if (flag & SCRIPT_VERIFY_WITNESS && !(flag & SCRIPT_VERIFY_P2SH)) continue;\n+        // SCRIPT_VERIFY_TAPROOT requires SCRIPT_VERIFY_WITNESS\n+        if (flag & SCRIPT_VERIFY_TAPROOT && !(flag & SCRIPT_VERIFY_WITNESS)) continue;\n+\n+        ret.push_back(flag);\n+    }\n+\n+    return ret;\n+}\n+\n+const std::vector<unsigned int> ALL_FLAGS = AllFlags();\n+\n+unsigned int ParseScriptFlags(const std::string& str)\n+{\n+    if (str.empty()) return 0;\n+\n+    unsigned int flags = 0;\n+    std::vector<std::string> words;\n+    boost::algorithm::split(words, str, boost::algorithm::is_any_of(\",\"));\n+\n+    for (const std::string& word : words)\n+    {\n+        auto it = FLAG_NAMES.find(word);\n+        if (it == FLAG_NAMES.end()) throw std::runtime_error(\"Unknown verification flag \" + word);\n+        flags |= it->second;\n+    }\n+\n+    return flags;\n+}\n+\n+void Test(const std::string& str)\n+{\n+    UniValue test;\n+    if (!test.read(str) || !test.isObject()) throw std::runtime_error(\"Non-object test input\");\n+\n+    CMutableTransaction tx = TxFromHex(test[\"tx\"].get_str());\n+    const std::vector<CTxOut> prevouts = TxOutsFromJSON(test[\"prevouts\"]);\n+    if (prevouts.size() != tx.vin.size()) throw std::runtime_error(\"Incorrect number of prevouts\");\n+    size_t idx = test[\"index\"].get_int64();\n+    if (idx >= tx.vin.size()) throw std::runtime_error(\"Invalid index\");\n+    unsigned int test_flags = ParseScriptFlags(test[\"flags\"].get_str());\n+    bool final = test.exists(\"final\") && test[\"final\"].get_bool();\n+\n+    if (test.exists(\"success\")) {\n+        tx.vin[idx].scriptSig = ScriptFromHex(test[\"success\"][\"scriptSig\"].get_str());\n+        tx.vin[idx].scriptWitness = ScriptWitnessFromJSON(test[\"success\"][\"witness\"]);\n+        PrecomputedTransactionData txdata;\n+        txdata.Init(tx, std::vector<CTxOut>(prevouts));\n+        MutableTransactionSignatureChecker txcheck(&tx, idx, prevouts[idx].nValue, txdata);\n+        for (const auto flags : ALL_FLAGS) {\n+            // \"final\": true tests are valid for all flags. Others are only valid with flags that are\n+            // a subset of test_flags.\n+            if (final || ((flags & test_flags) == flags)) {\n+                (void)VerifyScript(tx.vin[idx].scriptSig, prevouts[idx].scriptPubKey, &tx.vin[idx].scriptWitness, flags, txcheck, nullptr);\n+            }\n+        }\n+    }\n+\n+    if (test.exists(\"failure\")) {\n+        tx.vin[idx].scriptSig = ScriptFromHex(test[\"failure\"][\"scriptSig\"].get_str());\n+        tx.vin[idx].scriptWitness = ScriptWitnessFromJSON(test[\"failure\"][\"witness\"]);\n+        PrecomputedTransactionData txdata;\n+        txdata.Init(tx, std::vector<CTxOut>(prevouts));\n+        MutableTransactionSignatureChecker txcheck(&tx, idx, prevouts[idx].nValue, txdata);\n+        for (const auto flags : ALL_FLAGS) {\n+            // If a test is supposed to fail with test_flags, it should also fail with any superset thereof.\n+            if ((flags & test_flags) == test_flags) {\n+                (void)VerifyScript(tx.vin[idx].scriptSig, prevouts[idx].scriptPubKey, &tx.vin[idx].scriptWitness, flags, txcheck, nullptr);\n+            }\n+        }\n+    }\n+}\n+\n+ECCVerifyHandle handle;\n+\n+}\n+\n+void test_one_input(const std::vector<uint8_t>& buffer)\n+{\n+    if (buffer.size() < 2 || buffer.back() != '\\n' || buffer[buffer.size() - 2] != ',') return;\n+    const std::string str((const char*)buffer.data(), buffer.size() - 2);\n+    try {\n+        Test(str);\n+    } catch (const std::runtime_error&) {}\n+}"
      },
      {
        "sha": "a2efd8ac073000524b59183befac118d70437d3a",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2a5e448f426219a6464b9aaadcc715534114e6/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2a5e448f426219a6464b9aaadcc715534114e6/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=0e2a5e448f426219a6464b9aaadcc715534114e6",
        "patch": "@@ -1715,6 +1715,9 @@ static void AssetTest(const UniValue& test)\n \n BOOST_AUTO_TEST_CASE(script_assets_test)\n {\n+    // See src/test/fuzz/script_assets_test_minimizer.cpp for information on how to generate\n+    // the script_assets_test.json file used by this test.\n+\n     const char* dir = std::getenv(\"DIR_UNIT_TEST_DATA\");\n     BOOST_WARN_MESSAGE(dir != nullptr, \"Variable DIR_UNIT_TEST_DATA unset, skipping script_assets_test\");\n     if (dir == nullptr) return;"
      },
      {
        "sha": "7b534c1c2f90ee6e86bf311ca43bc580c7af9cd4",
        "filename": "test/functional/feature_taproot.py",
        "status": "modified",
        "additions": 48,
        "deletions": 1,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e2a5e448f426219a6464b9aaadcc715534114e6/test/functional/feature_taproot.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e2a5e448f426219a6464b9aaadcc715534114e6/test/functional/feature_taproot.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_taproot.py?ref=0e2a5e448f426219a6464b9aaadcc715534114e6",
        "patch": "@@ -82,8 +82,11 @@\n     hash160,\n     sha256,\n )\n-from collections import namedtuple\n+from collections import OrderedDict, namedtuple\n from io import BytesIO\n+import json\n+import hashlib\n+import os\n import random\n \n # === Framework for building spending transactions. ===\n@@ -1142,10 +1145,52 @@ def spenders_taproot_inactive():\n \n     return spenders\n \n+# Consensus validation flags to use in dumps for tests with \"legacy/\" or \"inactive/\" prefix.\n+LEGACY_FLAGS = \"P2SH,DERSIG,CHECKLOCKTIMEVERIFY,CHECKSEQUENCEVERIFY,WITNESS,NULLDUMMY\"\n+# Consensus validation flags to use in dumps for all other tests.\n+TAPROOT_FLAGS = \"P2SH,DERSIG,CHECKLOCKTIMEVERIFY,CHECKSEQUENCEVERIFY,WITNESS,NULLDUMMY,TAPROOT\"\n+\n+def dump_json_test(tx, input_utxos, idx, success, failure):\n+    spender = input_utxos[idx].spender\n+    # Determine flags to dump\n+    flags = LEGACY_FLAGS if spender.comment.startswith(\"legacy/\") or spender.comment.startswith(\"inactive/\") else TAPROOT_FLAGS\n+\n+    fields = [\n+        (\"tx\", tx.serialize().hex()),\n+        (\"prevouts\", [x.output.serialize().hex() for x in input_utxos]),\n+        (\"index\", idx),\n+        (\"flags\", flags),\n+        (\"comment\", spender.comment)\n+    ]\n+\n+    # The \"final\" field indicates that a spend should be always valid, even with more validation flags enabled\n+    # than the listed ones. Use standardness as a proxy for this (which gives a conservative underestimate).\n+    if spender.is_standard:\n+        fields.append((\"final\", True))\n+\n+    def dump_witness(wit):\n+        return OrderedDict([(\"scriptSig\", wit[0].hex()), (\"witness\", [x.hex() for x in wit[1]])])\n+    if success is not None:\n+        fields.append((\"success\", dump_witness(success)))\n+    if failure is not None:\n+        fields.append((\"failure\", dump_witness(failure)))\n+\n+    # Write the dump to $TEST_DUMP_DIR/x/xyz... where x,y,z,... are the SHA1 sum of the dump (which makes the\n+    # file naming scheme compatible with fuzzing infrastructure).\n+    dump = json.dumps(OrderedDict(fields)) + \",\\n\"\n+    sha1 = hashlib.sha1(dump.encode(\"utf-8\")).hexdigest()\n+    dirname = os.environ.get(\"TEST_DUMP_DIR\", \".\") + (\"/%s\" % sha1[0])\n+    os.makedirs(dirname, exist_ok=True)\n+    with open(dirname + (\"/%s\" % sha1), 'w', encoding=\"utf8\") as f:\n+        f.write(dump)\n+\n # Data type to keep track of UTXOs, where they were created, and how to spend them.\n UTXOData = namedtuple('UTXOData', 'outpoint,output,spender')\n \n class TaprootTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        parser.add_argument(\"--dumptests\", dest=\"dump_tests\", default=False, action=\"store_true\",\n+                            help=\"Dump generated test cases to directory set by TEST_DUMP_DIR environment variable\")\n \n     def skip_test_if_missing_module(self):\n         self.skip_if_no_wallet()\n@@ -1356,6 +1401,8 @@ def test_spenders(self, node, spenders, input_counts):\n                 if not input_utxos[i].spender.no_fail:\n                     fail = fn(tx, i, [utxo.output for utxo in input_utxos], False)\n                 input_data.append((fail, success))\n+                if self.options.dump_tests:\n+                    dump_json_test(tx, input_utxos, i, success, fail)\n \n             # Sign each input incorrectly once on each complete signing pass, except the very last.\n             for fail_input in list(range(len(input_utxos))) + [None]:"
      }
    ]
  }
]