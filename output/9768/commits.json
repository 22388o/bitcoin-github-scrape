[
  {
    "sha": "0e6d23dd53488700e42ca08eafddcea0b6616564",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowZTZkMjNkZDUzNDg4NzAwZTQyY2EwOGVhZmRkY2VhMGI2NjE2NTY0",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-02-15T16:36:46Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-03-09T14:26:48Z"
      },
      "message": "Add logging to test_framework.py\n\nThis commit adds python logging to test_framework.py. By default this\nwill output all log levels (DEBUG-INFO-WARNING-ERROR-CRITICAL) to a\ntest_framework.log file in the temporary test directory, and higher\nlevel logs (WARNING-ERROR-CRITICAL) to the console. The level of logging\nto the console can be controlled by a new log-level parameter.\n\nThis should have no interaction with the existing trace-rpc parameter.",
      "tree": {
        "sha": "7995b13fdbfb1bb1e0d10a8f6c7d613e91c4f56a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7995b13fdbfb1bb1e0d10a8f6c7d613e91c4f56a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0e6d23dd53488700e42ca08eafddcea0b6616564",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0e6d23dd53488700e42ca08eafddcea0b6616564",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0e6d23dd53488700e42ca08eafddcea0b6616564",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0e6d23dd53488700e42ca08eafddcea0b6616564/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5703dff0939f05c7457cebd6fc61d88ab13afe41",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5703dff0939f05c7457cebd6fc61d88ab13afe41",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5703dff0939f05c7457cebd6fc61d88ab13afe41"
      }
    ],
    "stats": {
      "total": 66,
      "additions": 46,
      "deletions": 20
    },
    "files": [
      {
        "sha": "024290237ed9fefc3cd67c3813e07f90060fc508",
        "filename": "qa/rpc-tests/test_framework/test_framework.py",
        "status": "modified",
        "additions": 46,
        "deletions": 20,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e6d23dd53488700e42ca08eafddcea0b6616564/qa/rpc-tests/test_framework/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e6d23dd53488700e42ca08eafddcea0b6616564/qa/rpc-tests/test_framework/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/test_framework.py?ref=0e6d23dd53488700e42ca08eafddcea0b6616564",
        "patch": "@@ -42,7 +42,7 @@ def add_options(self, parser):\n         pass\n \n     def setup_chain(self):\n-        print(\"Initializing test directory \"+self.options.tmpdir)\n+        self.log.info(\"Initializing test directory \"+self.options.tmpdir)\n         if self.setup_clean_chain:\n             initialize_chain_clean(self.options.tmpdir, self.num_nodes)\n         else:\n@@ -112,6 +112,8 @@ def main(self):\n                           help=\"Directory for caching pregenerated datadirs\")\n         parser.add_option(\"--tmpdir\", dest=\"tmpdir\", default=tempfile.mkdtemp(prefix=\"test\"),\n                           help=\"Root directory for datadirs\")\n+        parser.add_option(\"-l\", \"--loglevel\", dest=\"loglevel\", default=\"INFO\",\n+                          help=\"log events at this level and higher to the console. Can be set to DEBUG, INFO, WARNING, ERROR or CRITICAL. Passing --loglevel DEBUG will output all logs to console. Note that logs at all levels are always written to the test_framework.log file in the temporary test directory.\")\n         parser.add_option(\"--tracerpc\", dest=\"trace_rpc\", default=False, action=\"store_true\",\n                           help=\"Print out all RPC calls as they are made\")\n         parser.add_option(\"--portseed\", dest=\"port_seed\", default=os.getpid(), type='int',\n@@ -124,9 +126,6 @@ def main(self):\n         # backup dir variable for removal at cleanup\n         self.options.root, self.options.tmpdir = self.options.tmpdir, self.options.tmpdir + '/' + str(self.options.port_seed)\n \n-        if self.options.trace_rpc:\n-            logging.basicConfig(level=logging.DEBUG, stream=sys.stdout)\n-\n         if self.options.coveragedir:\n             enable_coverage(self.options.coveragedir)\n \n@@ -136,41 +135,41 @@ def main(self):\n \n         check_json_precision()\n \n+        # Set up temp directory and start logging\n+        os.makedirs(self.options.tmpdir, exist_ok=False)\n+        self._start_logging()\n+\n         success = False\n+\n         try:\n-            os.makedirs(self.options.tmpdir, exist_ok=False)\n             self.setup_chain()\n             self.setup_network()\n             self.run_test()\n             success = True\n         except JSONRPCException as e:\n-            print(\"JSONRPC error: \"+e.error['message'])\n-            traceback.print_tb(sys.exc_info()[2])\n+            self.log.exception(\"JSONRPC error\")\n         except AssertionError as e:\n-            print(\"Assertion failed: \" + str(e))\n-            traceback.print_tb(sys.exc_info()[2])\n+            self.log.exception(\"Assertion failed\")\n         except KeyError as e:\n-            print(\"key not found: \"+ str(e))\n-            traceback.print_tb(sys.exc_info()[2])\n+            self.log.exception(\"Key error\")\n         except Exception as e:\n-            print(\"Unexpected exception caught during testing: \" + repr(e))\n-            traceback.print_tb(sys.exc_info()[2])\n+            self.log.exception(\"Unexpected exception caught during testing\")\n         except KeyboardInterrupt as e:\n-            print(\"Exiting after \" + repr(e))\n+            self.log.warning(\"Exiting after keyboard interrupt\")\n \n         if not self.options.noshutdown:\n-            print(\"Stopping nodes\")\n+            self.log.info(\"Stopping nodes\")\n             stop_nodes(self.nodes)\n         else:\n-            print(\"Note: bitcoinds were not stopped and may still be running\")\n+            self.log.info(\"Note: bitcoinds were not stopped and may still be running\")\n \n         if not self.options.nocleanup and not self.options.noshutdown and success:\n-            print(\"Cleaning up\")\n+            self.log.info(\"Cleaning up\")\n             shutil.rmtree(self.options.tmpdir)\n             if not os.listdir(self.options.root):\n                 os.rmdir(self.options.root)\n         else:\n-            print(\"Not cleaning up dir %s\" % self.options.tmpdir)\n+            self.log.warning(\"Not cleaning up dir %s\" % self.options.tmpdir)\n             if os.getenv(\"PYTHON_DEBUG\", \"\"):\n                 # Dump the end of the debug logs, to aid in debugging rare\n                 # travis failures.\n@@ -182,12 +181,39 @@ def main(self):\n                     from collections import deque\n                     print(\"\".join(deque(open(f), MAX_LINES_TO_PRINT)))\n         if success:\n-            print(\"Tests successful\")\n+            self.log.info(\"Tests successful\")\n             sys.exit(0)\n         else:\n-            print(\"Failed\")\n+            self.log.error(\"Test failed. Test logging available at %s/test_framework.log\", self.options.tmpdir)\n+            logging.shutdown()\n             sys.exit(1)\n \n+    def _start_logging(self):\n+        # Add logger and logging handlers\n+        self.log = logging.getLogger('TestFramework')\n+        self.log.setLevel(logging.DEBUG)\n+        # Create file handler to log all messages\n+        fh = logging.FileHandler(self.options.tmpdir + '/test_framework.log')\n+        fh.setLevel(logging.DEBUG)\n+        # Create console handler to log messages to stderr. By default this logs only error messages, but can be configured with --loglevel.\n+        ch = logging.StreamHandler(sys.stdout)\n+        # User can provide log level as a number or string (eg DEBUG). loglevel was caught as a string, so try to convert it to an int\n+        ll = int(self.options.loglevel) if self.options.loglevel.isdigit() else self.options.loglevel.upper()\n+        ch.setLevel(ll)\n+        # Format logs the same as bitcoind's debug.log with microprecision (so log files can be concatenated and sorted)\n+        formatter = logging.Formatter(fmt = '%(asctime)s.%(msecs)03d000 %(name)s (%(levelname)s): %(message)s', datefmt='%Y-%m-%d %H:%M:%S')\n+        fh.setFormatter(formatter)\n+        ch.setFormatter(formatter)\n+        # add the handlers to the logger\n+        self.log.addHandler(fh)\n+        self.log.addHandler(ch)\n+\n+        if self.options.trace_rpc:\n+            rpc_logger = logging.getLogger(\"BitcoinRPC\")\n+            rpc_logger.setLevel(logging.DEBUG)\n+            rpc_handler = logging.StreamHandler(sys.stdout)\n+            rpc_handler.setLevel(logging.DEBUG)\n+            rpc_logger.addHandler(rpc_handler)\n \n # Test framework for doing p2p comparison testing, which sets up some bitcoind\n # binaries:"
      }
    ]
  },
  {
    "sha": "553a976929543c93d1b22fbabe50a9be32d3c290",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1NTNhOTc2OTI5NTQzYzkzZDFiMjJmYmFiZTUwYTliZTMyZDNjMjkw",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-02-15T16:48:54Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-03-09T14:26:48Z"
      },
      "message": "Add logging to p2p-segwit.py",
      "tree": {
        "sha": "6baab2bfcffefd30ee38b759fbe026a1b67ca229",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6baab2bfcffefd30ee38b759fbe026a1b67ca229"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/553a976929543c93d1b22fbabe50a9be32d3c290",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/553a976929543c93d1b22fbabe50a9be32d3c290",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/553a976929543c93d1b22fbabe50a9be32d3c290",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/553a976929543c93d1b22fbabe50a9be32d3c290/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0e6d23dd53488700e42ca08eafddcea0b6616564",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0e6d23dd53488700e42ca08eafddcea0b6616564",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0e6d23dd53488700e42ca08eafddcea0b6616564"
      }
    ],
    "stats": {
      "total": 55,
      "additions": 27,
      "deletions": 28
    },
    "files": [
      {
        "sha": "ca0960f2dceedd8c1eaebb042aa50ae7179bf109",
        "filename": "qa/rpc-tests/p2p-segwit.py",
        "status": "modified",
        "additions": 27,
        "deletions": 28,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/553a976929543c93d1b22fbabe50a9be32d3c290/qa/rpc-tests/p2p-segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/553a976929543c93d1b22fbabe50a9be32d3c290/qa/rpc-tests/p2p-segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-segwit.py?ref=553a976929543c93d1b22fbabe50a9be32d3c290",
        "patch": "@@ -70,7 +70,6 @@ def on_pong(self, conn, message):\n \n     def on_reject(self, conn, message):\n         self.last_reject = message\n-        #print (message)\n \n     # Syncing helpers\n     def sync(self, test_function, timeout=60):\n@@ -224,7 +223,7 @@ def update_witness_block_with_transactions(self, block, tx_list, nonce=0):\n \n     ''' Individual tests '''\n     def test_witness_services(self):\n-        print(\"\\tVerifying NODE_WITNESS service bit\")\n+        self.log.info(\"Verifying NODE_WITNESS service bit\")\n         assert((self.test_node.connection.nServices & NODE_WITNESS) != 0)\n \n \n@@ -233,7 +232,7 @@ def test_witness_services(self):\n     def test_non_witness_transaction(self):\n         # Mine a block with an anyone-can-spend coinbase,\n         # let it mature, then try to spend it.\n-        print(\"\\tTesting non-witness transaction\")\n+        self.log.info(\"Testing non-witness transaction\")\n         block = self.build_next_block(nVersion=1)\n         block.solve()\n         self.test_node.send_message(msg_block(block))\n@@ -262,7 +261,7 @@ def test_non_witness_transaction(self):\n \n     # Verify that blocks with witnesses are rejected before activation.\n     def test_unnecessary_witness_before_segwit_activation(self):\n-        print(\"\\tTesting behavior of unnecessary witnesses\")\n+        self.log.info(\"Testing behavior of unnecessary witnesses\")\n         # For now, rely on earlier tests to have created at least one utxo for\n         # us to use\n         assert(len(self.utxo) > 0)\n@@ -389,7 +388,7 @@ def advance_to_segwit_active(self):\n \n     # This test can only be run after segwit has activated\n     def test_witness_commitments(self):\n-        print(\"\\tTesting witness commitments\")\n+        self.log.info(\"Testing witness commitments\")\n \n         # First try a correct witness commitment.\n         block = self.build_next_block()\n@@ -478,7 +477,7 @@ def test_witness_commitments(self):\n \n \n     def test_block_malleability(self):\n-        print(\"\\tTesting witness block malleability\")\n+        self.log.info(\"Testing witness block malleability\")\n \n         # Make sure that a block that has too big a virtual size\n         # because of a too-large coinbase witness is not permanently\n@@ -519,7 +518,7 @@ def test_block_malleability(self):\n \n \n     def test_witness_block_size(self):\n-        print(\"\\tTesting witness block size limit\")\n+        self.log.info(\"Testing witness block size limit\")\n         # TODO: Test that non-witness carrying blocks can't exceed 1MB\n         # Skipping this test for now; this is covered in p2p-fullblocktest.py\n \n@@ -636,7 +635,7 @@ def test_submit_block(self):\n \n     # Consensus tests of extra witness data in a transaction.\n     def test_extra_witness_data(self):\n-        print(\"\\tTesting extra witness data in tx\")\n+        self.log.info(\"Testing extra witness data in tx\")\n \n         assert(len(self.utxo) > 0)\n         \n@@ -712,7 +711,7 @@ def test_extra_witness_data(self):\n \n     def test_max_witness_push_length(self):\n         ''' Should only allow up to 520 byte pushes in witness stack '''\n-        print(\"\\tTesting maximum witness push size\")\n+        self.log.info(\"Testing maximum witness push size\")\n         MAX_SCRIPT_ELEMENT_SIZE = 520\n         assert(len(self.utxo))\n \n@@ -752,7 +751,7 @@ def test_max_witness_push_length(self):\n     def test_max_witness_program_length(self):\n         # Can create witness outputs that are long, but can't be greater than\n         # 10k bytes to successfully spend\n-        print(\"\\tTesting maximum witness program length\")\n+        self.log.info(\"Testing maximum witness program length\")\n         assert(len(self.utxo))\n         MAX_PROGRAM_LENGTH = 10000\n \n@@ -801,7 +800,7 @@ def test_max_witness_program_length(self):\n \n     def test_witness_input_length(self):\n         ''' Ensure that vin length must match vtxinwit length '''\n-        print(\"\\tTesting witness input length\")\n+        self.log.info(\"Testing witness input length\")\n         assert(len(self.utxo))\n \n         witness_program = CScript([OP_DROP, OP_TRUE])\n@@ -884,7 +883,7 @@ def serialize_with_witness(self):\n \n \n     def test_witness_tx_relay_before_segwit_activation(self):\n-        print(\"\\tTesting relay of witness transactions\")\n+        self.log.info(\"Testing relay of witness transactions\")\n         # Generate a transaction that doesn't require a witness, but send it\n         # with a witness.  Should be rejected for premature-witness, but should\n         # not be added to recently rejected list.\n@@ -908,7 +907,7 @@ def test_witness_tx_relay_before_segwit_activation(self):\n         # a witness transaction ought not result in a getdata.\n         try:\n             self.test_node.announce_tx_and_wait_for_getdata(tx, timeout=2)\n-            print(\"Error: duplicate tx getdata!\")\n+            self.log.error(\"Error: duplicate tx getdata!\")\n             assert(False)\n         except AssertionError as e:\n             pass\n@@ -936,7 +935,7 @@ def test_witness_tx_relay_before_segwit_activation(self):\n     # - accepts transactions with valid witnesses\n     # and that witness transactions are relayed to non-upgraded peers.\n     def test_tx_relay_after_segwit_activation(self):\n-        print(\"\\tTesting relay of witness transactions\")\n+        self.log.info(\"Testing relay of witness transactions\")\n         # Generate a transaction that doesn't require a witness, but send it\n         # with a witness.  Should be rejected because we can't use a witness\n         # when spending a non-witness output.\n@@ -1025,7 +1024,7 @@ def test_tx_relay_after_segwit_activation(self):\n     # This is true regardless of segwit activation.\n     # Also test that we don't ask for blocks from unupgraded peers\n     def test_block_relay(self, segwit_activated):\n-        print(\"\\tTesting block relay\")\n+        self.log.info(\"Testing block relay\")\n \n         blocktype = 2|MSG_WITNESS_FLAG\n \n@@ -1113,7 +1112,7 @@ def test_block_relay(self, segwit_activated):\n \n     # V0 segwit outputs should be standard after activation, but not before.\n     def test_standardness_v0(self, segwit_activated):\n-        print(\"\\tTesting standardness of v0 outputs (%s activation)\" % (\"after\" if segwit_activated else \"before\"))\n+        self.log.info(\"Testing standardness of v0 outputs (%s activation)\" % (\"after\" if segwit_activated else \"before\"))\n         assert(len(self.utxo))\n \n         witness_program = CScript([OP_TRUE])\n@@ -1190,7 +1189,7 @@ def test_standardness_v0(self, segwit_activated):\n     # Verify that future segwit upgraded transactions are non-standard,\n     # but valid in blocks. Can run this before and after segwit activation.\n     def test_segwit_versions(self):\n-        print(\"\\tTesting standardness/consensus for segwit versions (0-16)\")\n+        self.log.info(\"Testing standardness/consensus for segwit versions (0-16)\")\n         assert(len(self.utxo))\n         NUM_TESTS = 17 # will test OP_0, OP1, ..., OP_16\n         if (len(self.utxo) < NUM_TESTS):\n@@ -1274,7 +1273,7 @@ def test_segwit_versions(self):\n \n \n     def test_premature_coinbase_witness_spend(self):\n-        print(\"\\tTesting premature coinbase witness spend\")\n+        self.log.info(\"Testing premature coinbase witness spend\")\n         block = self.build_next_block()\n         # Change the output of the block to be a witness output.\n         witness_program = CScript([OP_TRUE])\n@@ -1309,7 +1308,7 @@ def test_premature_coinbase_witness_spend(self):\n \n \n     def test_signature_version_1(self):\n-        print(\"\\tTesting segwit signature hash version 1\")\n+        self.log.info(\"Testing segwit signature hash version 1\")\n         key = CECKey()\n         key.set_secretbytes(b\"9\")\n         pubkey = CPubKey(key.get_pubkey())\n@@ -1491,7 +1490,7 @@ def test_signature_version_1(self):\n \n     # Test P2SH wrapped witness programs.\n     def test_p2sh_witness(self, segwit_activated):\n-        print(\"\\tTesting P2SH witness transactions\")\n+        self.log.info(\"Testing P2SH witness transactions\")\n \n         assert(len(self.utxo))\n \n@@ -1564,7 +1563,7 @@ def test_p2sh_witness(self, segwit_activated):\n     # To enable this test, pass --oldbinary=<path-to-pre-segwit-bitcoind> to\n     # the test.\n     def test_upgrade_after_activation(self, node, node_id):\n-        print(\"\\tTesting software upgrade after softfork activation\")\n+        self.log.info(\"Testing software upgrade after softfork activation\")\n \n         assert(node_id != 0) # node0 is assumed to be a segwit-active bitcoind\n \n@@ -1592,7 +1591,7 @@ def test_upgrade_after_activation(self, node, node_id):\n \n     def test_witness_sigops(self):\n         '''Ensure sigop counting is correct inside witnesses.'''\n-        print(\"\\tTesting sigops limit\")\n+        self.log.info(\"Testing sigops limit\")\n \n         assert(len(self.utxo))\n \n@@ -1694,7 +1693,7 @@ def test_witness_sigops(self):\n         # TODO: test p2sh sigop counting\n \n     def test_getblocktemplate_before_lockin(self):\n-        print(\"\\tTesting getblocktemplate setting of segwit versionbit (before lockin)\")\n+        self.log.info(\"Testing getblocktemplate setting of segwit versionbit (before lockin)\")\n         # Node0 is segwit aware, node2 is not.\n         for node in [self.nodes[0], self.nodes[2]]:\n             gbt_results = node.getblocktemplate()\n@@ -1746,7 +1745,7 @@ def test_getblocktemplate_before_lockin(self):\n     # Uncompressed pubkeys are no longer supported in default relay policy,\n     # but (for now) are still valid in blocks.\n     def test_uncompressed_pubkey(self):\n-        print(\"\\tTesting uncompressed pubkeys\")\n+        self.log.info(\"Testing uncompressed pubkeys\")\n         # Segwit transactions using uncompressed pubkeys are not accepted\n         # under default policy, but should still pass consensus.\n         key = CECKey()\n@@ -1848,7 +1847,7 @@ def test_uncompressed_pubkey(self):\n         self.utxo.append(UTXO(tx5.sha256, 0, tx5.vout[0].nValue))\n \n     def test_non_standard_witness(self):\n-        print(\"\\tTesting detection of non-standard P2WSH witness\")\n+        self.log.info(\"Testing detection of non-standard P2WSH witness\")\n         pad = chr(1).encode('latin-1')\n \n         # Create scripts for tests\n@@ -1972,7 +1971,7 @@ def run_test(self):\n         # Test logic begins here\n         self.test_node.wait_for_verack()\n \n-        print(\"\\nStarting tests before segwit lock in:\")\n+        self.log.info(\"Starting tests before segwit lock in:\")\n \n         self.test_witness_services() # Verifies NODE_WITNESS\n         self.test_non_witness_transaction() # non-witness tx's are accepted\n@@ -1987,7 +1986,7 @@ def run_test(self):\n         sync_blocks(self.nodes)\n \n         # At lockin, nothing should change.\n-        print(\"\\nTesting behavior post lockin, pre-activation\")\n+        self.log.info(\"Testing behavior post lockin, pre-activation\")\n         self.advance_to_segwit_lockin()\n \n         # Retest unnecessary witnesses\n@@ -2000,7 +1999,7 @@ def run_test(self):\n         sync_blocks(self.nodes)\n \n         # Now activate segwit\n-        print(\"\\nTesting behavior after segwit activation\")\n+        self.log.info(\"Testing behavior after segwit activation\")\n         self.advance_to_segwit_active()\n \n         sync_blocks(self.nodes)"
      }
    ]
  },
  {
    "sha": "6d0e3250bbded1fb90443340e98b861e5ed8944f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ZDBlMzI1MGJiZGVkMWZiOTA0NDMzNDBlOThiODYxZTVlZDg5NDRm",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-02-15T17:21:22Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-03-09T14:26:48Z"
      },
      "message": "Use logging in mininode.py\n\nThis commit adds a TestFramework.mininode Logger to the mininode module.\nThis is a child logger of TestFramework, so the handlers set up in\ntest_framework.py will receive records from this logger and emit them\nto the log file and console as appropriate.",
      "tree": {
        "sha": "cc77e399a04cefcd2f67c615ea60308cb2bc9c19",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cc77e399a04cefcd2f67c615ea60308cb2bc9c19"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6d0e3250bbded1fb90443340e98b861e5ed8944f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6d0e3250bbded1fb90443340e98b861e5ed8944f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6d0e3250bbded1fb90443340e98b861e5ed8944f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6d0e3250bbded1fb90443340e98b861e5ed8944f/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "553a976929543c93d1b22fbabe50a9be32d3c290",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/553a976929543c93d1b22fbabe50a9be32d3c290",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/553a976929543c93d1b22fbabe50a9be32d3c290"
      }
    ],
    "stats": {
      "total": 28,
      "additions": 10,
      "deletions": 18
    },
    "files": [
      {
        "sha": "eb4da22255af840d9de2ca656d8e2c288d9c8385",
        "filename": "qa/rpc-tests/test_framework/mininode.py",
        "status": "modified",
        "additions": 10,
        "deletions": 18,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6d0e3250bbded1fb90443340e98b861e5ed8944f/qa/rpc-tests/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6d0e3250bbded1fb90443340e98b861e5ed8944f/qa/rpc-tests/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/mininode.py?ref=6d0e3250bbded1fb90443340e98b861e5ed8944f",
        "patch": "@@ -51,6 +51,8 @@\n NODE_BLOOM = (1 << 2)\n NODE_WITNESS = (1 << 3)\n \n+logger = logging.getLogger(\"TestFramework.mininode\")\n+\n # Keep our own socket map for asyncore, so that we can track disconnects\n # ourselves (to workaround an issue with closing an asyncore socket when\n # using select)\n@@ -1502,8 +1504,7 @@ def deliver(self, conn, message):\n             try:\n                 getattr(self, 'on_' + message.command.decode('ascii'))(conn, message)\n             except:\n-                print(\"ERROR delivering %s (%s)\" % (repr(message),\n-                                                    sys.exc_info()[0]))\n+                logger.exception(\"ERROR delivering %s\" % repr(message))\n \n     def on_version(self, conn, message):\n         if message.nVersion >= 209:\n@@ -1615,7 +1616,6 @@ class NodeConn(asyncore.dispatcher):\n \n     def __init__(self, dstaddr, dstport, rpc, callback, net=\"regtest\", services=NODE_NETWORK, send_version=True):\n         asyncore.dispatcher.__init__(self, map=mininode_socket_map)\n-        self.log = logging.getLogger(\"NodeConn(%s:%d)\" % (dstaddr, dstport))\n         self.dstaddr = dstaddr\n         self.dstport = dstport\n         self.create_socket(socket.AF_INET, socket.SOCK_STREAM)\n@@ -1640,27 +1640,22 @@ def __init__(self, dstaddr, dstport, rpc, callback, net=\"regtest\", services=NODE\n             vt.addrFrom.port = 0\n             self.send_message(vt, True)\n \n-        print('MiniNode: Connecting to Bitcoin Node IP # ' + dstaddr + ':' \\\n-            + str(dstport))\n+        logger.info('Connecting to Bitcoin Node: %s:%d' % (self.dstaddr, self.dstport))\n \n         try:\n             self.connect((dstaddr, dstport))\n         except:\n             self.handle_close()\n         self.rpc = rpc\n \n-    def show_debug_msg(self, msg):\n-        self.log.debug(msg)\n-\n     def handle_connect(self):\n         if self.state != \"connected\":\n-            self.show_debug_msg(\"MiniNode: Connected & Listening: \\n\")\n+            logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n             self.state = \"connected\"\n             self.cb.on_open(self)\n \n     def handle_close(self):\n-        self.show_debug_msg(\"MiniNode: Closing Connection to %s:%d... \"\n-                            % (self.dstaddr, self.dstport))\n+        logger.debug(\"Closing connection to: %s:%d\" % (self.dstaddr, self.dstport))\n         self.state = \"closed\"\n         self.recvbuf = b\"\"\n         self.sendbuf = b\"\"\n@@ -1742,17 +1737,14 @@ def got_data(self):\n                     t.deserialize(f)\n                     self.got_message(t)\n                 else:\n-                    self.show_debug_msg(\"Unknown command: '\" + command + \"' \" +\n-                                        repr(msg))\n+                    logger.warning(\"Received unknown command from %s:%d: '%s' %s\" % (self.dstaddr, self.dstport, command, repr(msg)))\n         except Exception as e:\n-            print('got_data:', repr(e))\n-            # import  traceback\n-            # traceback.print_tb(sys.exc_info()[2])\n+            logger.exception('got_data:', repr(e))\n \n     def send_message(self, message, pushbuf=False):\n         if self.state != \"connected\" and not pushbuf:\n             raise IOError('Not connected, no pushbuf')\n-        self.show_debug_msg(\"Send %s\" % repr(message))\n+            logger.debug(\"Send message to %s:%d: %s\" % (self.dstaddr, self.dstport, repr(message)))\n         command = message.command\n         data = message.serialize()\n         tmsg = self.MAGIC_BYTES[self.network]\n@@ -1774,7 +1766,7 @@ def got_message(self, message):\n                 self.messagemap[b'ping'] = msg_ping_prebip31\n         if self.last_sent + 30 * 60 < time.time():\n             self.send_message(self.messagemap[b'ping']())\n-        self.show_debug_msg(\"Recv %s\" % repr(message))\n+        logger.debug(\"Received message from %s:%d: %s\" % (self.dstaddr, self.dstport, repr(message)))\n         self.cb.deliver(self, message)\n \n     def disconnect_node(self):"
      }
    ]
  },
  {
    "sha": "af1363cb1c9a6684c9d78fce34e5567406209c60",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphZjEzNjNjYjFjOWE2Njg0YzlkNzhmY2UzNGU1NTY3NDA2MjA5YzYw",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-02-24T17:17:46Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-03-09T14:26:48Z"
      },
      "message": "Always enable debug log and microsecond logging for test nodes.",
      "tree": {
        "sha": "33a4cae5b95fabe74a713e9711ef9e8b829f7585",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/33a4cae5b95fabe74a713e9711ef9e8b829f7585"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/af1363cb1c9a6684c9d78fce34e5567406209c60",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af1363cb1c9a6684c9d78fce34e5567406209c60",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/af1363cb1c9a6684c9d78fce34e5567406209c60",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af1363cb1c9a6684c9d78fce34e5567406209c60/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6d0e3250bbded1fb90443340e98b861e5ed8944f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6d0e3250bbded1fb90443340e98b861e5ed8944f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6d0e3250bbded1fb90443340e98b861e5ed8944f"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 2,
      "deletions": 2
    },
    "files": [
      {
        "sha": "aace17a04331dd7fc7a261197534eb8bc012ec7c",
        "filename": "qa/rpc-tests/test_framework/mininode.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/af1363cb1c9a6684c9d78fce34e5567406209c60/qa/rpc-tests/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/af1363cb1c9a6684c9d78fce34e5567406209c60/qa/rpc-tests/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/mininode.py?ref=af1363cb1c9a6684c9d78fce34e5567406209c60",
        "patch": "@@ -1744,7 +1744,7 @@ def got_data(self):\n     def send_message(self, message, pushbuf=False):\n         if self.state != \"connected\" and not pushbuf:\n             raise IOError('Not connected, no pushbuf')\n-            logger.debug(\"Send message to %s:%d: %s\" % (self.dstaddr, self.dstport, repr(message)))\n+        logger.debug(\"Send message to %s:%d: %s\" % (self.dstaddr, self.dstport, repr(message)))\n         command = message.command\n         data = message.serialize()\n         tmsg = self.MAGIC_BYTES[self.network]"
      },
      {
        "sha": "c22e57bcefaa5a092447556a237c7e71ad76039b",
        "filename": "qa/rpc-tests/test_framework/util.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/af1363cb1c9a6684c9d78fce34e5567406209c60/qa/rpc-tests/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/af1363cb1c9a6684c9d78fce34e5567406209c60/qa/rpc-tests/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/util.py?ref=af1363cb1c9a6684c9d78fce34e5567406209c60",
        "patch": "@@ -313,7 +313,7 @@ def start_node(i, dirname, extra_args=None, rpchost=None, timewait=None, binary=\n     datadir = os.path.join(dirname, \"node\"+str(i))\n     if binary is None:\n         binary = os.getenv(\"BITCOIND\", \"bitcoind\")\n-    args = [ binary, \"-datadir=\"+datadir, \"-server\", \"-keypool=1\", \"-discover=0\", \"-rest\", \"-mocktime=\"+str(get_mocktime()) ]\n+    args = [ binary, \"-datadir=\"+datadir, \"-server\", \"-keypool=1\", \"-discover=0\", \"-rest\", \"-logtimemicros\", \"-debug\", \"-mocktime=\"+str(get_mocktime()) ]\n     if extra_args is not None: args.extend(extra_args)\n     bitcoind_processes[i] = subprocess.Popen(args, stderr=stderr)\n     if os.getenv(\"PYTHON_DEBUG\", \"\"):"
      }
    ]
  },
  {
    "sha": "b0dec4a04a2d9415bfb4996404900e2c173b41d0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMGRlYzRhMDRhMmQ5NDE1YmZiNDk5NjQwNDkwMGUyYzE3M2I0MWQw",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-02-24T17:39:33Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-03-09T14:26:48Z"
      },
      "message": "Remove manual debug settings in qa tests.\n\n-debug and -logtimemicros are now set by default. Individual test cases\nno longer need to set these parameters manually.",
      "tree": {
        "sha": "bfd4791c3e6f9d693572fa4b610944a508e55ce7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bfd4791c3e6f9d693572fa4b610944a508e55ce7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b0dec4a04a2d9415bfb4996404900e2c173b41d0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b0dec4a04a2d9415bfb4996404900e2c173b41d0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b0dec4a04a2d9415bfb4996404900e2c173b41d0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b0dec4a04a2d9415bfb4996404900e2c173b41d0/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "af1363cb1c9a6684c9d78fce34e5567406209c60",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af1363cb1c9a6684c9d78fce34e5567406209c60",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/af1363cb1c9a6684c9d78fce34e5567406209c60"
      }
    ],
    "stats": {
      "total": 161,
      "additions": 79,
      "deletions": 82
    },
    "files": [
      {
        "sha": "9a5e0c218f6b60b8411c19bca70c64b33b25f2b4",
        "filename": "qa/rpc-tests/abandonconflict.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/abandonconflict.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/abandonconflict.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/abandonconflict.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -23,8 +23,8 @@ def __init__(self):\n \n     def setup_network(self):\n         self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\",\"-logtimemicros\",\"-minrelaytxfee=0.00001\"]))\n-        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\",\"-logtimemicros\"]))\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-minrelaytxfee=0.00001\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir))\n         connect_nodes(self.nodes[0], 1)\n \n     def run_test(self):\n@@ -81,7 +81,7 @@ def run_test(self):\n         # Restart the node with a higher min relay fee so the parent tx is no longer in mempool\n         # TODO: redo with eviction\n         stop_node(self.nodes[0],0)\n-        self.nodes[0]=start_node(0, self.options.tmpdir, [\"-debug\",\"-logtimemicros\",\"-minrelaytxfee=0.0001\"])\n+        self.nodes[0]=start_node(0, self.options.tmpdir, [\"-minrelaytxfee=0.0001\"])\n \n         # Verify txs no longer in mempool\n         assert_equal(len(self.nodes[0].getrawmempool()), 0)\n@@ -107,7 +107,7 @@ def run_test(self):\n \n         # Verify that even with a low min relay fee, the tx is not reaccepted from wallet on startup once abandoned\n         stop_node(self.nodes[0],0)\n-        self.nodes[0]=start_node(0, self.options.tmpdir, [\"-debug\",\"-logtimemicros\",\"-minrelaytxfee=0.00001\"])\n+        self.nodes[0]=start_node(0, self.options.tmpdir, [\"-minrelaytxfee=0.00001\"])\n         assert_equal(len(self.nodes[0].getrawmempool()), 0)\n         assert_equal(self.nodes[0].getbalance(), balance)\n \n@@ -127,7 +127,7 @@ def run_test(self):\n \n         # Remove using high relay fee again\n         stop_node(self.nodes[0],0)\n-        self.nodes[0]=start_node(0, self.options.tmpdir, [\"-debug\",\"-logtimemicros\",\"-minrelaytxfee=0.0001\"])\n+        self.nodes[0]=start_node(0, self.options.tmpdir, [\"-minrelaytxfee=0.0001\"])\n         assert_equal(len(self.nodes[0].getrawmempool()), 0)\n         newbalance = self.nodes[0].getbalance()\n         assert_equal(newbalance, balance - Decimal(\"24.9996\"))"
      },
      {
        "sha": "c60c8e6d1a914e55550d78eb497d2d8159e53d51",
        "filename": "qa/rpc-tests/assumevalid.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/assumevalid.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/assumevalid.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/assumevalid.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -73,7 +73,7 @@ def setup_network(self):\n         # we need to pre-mine a block with an invalid transaction\n         # signature so we can pass in the block hash as assumevalid.\n         self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\"]))\n+        self.nodes.append(start_node(0, self.options.tmpdir))\n \n     def run_test(self):\n \n@@ -146,14 +146,14 @@ def run_test(self):\n \n         # Start node1 and node2 with assumevalid so they accept a block with a bad signature.\n         self.nodes.append(start_node(1, self.options.tmpdir,\n-                                     [\"-debug\", \"-assumevalid=\" + hex(block102.sha256)]))\n+                                     [\"-assumevalid=\" + hex(block102.sha256)]))\n         node1 = BaseNode()  # connects to node1\n         connections.append(NodeConn('127.0.0.1', p2p_port(1), self.nodes[1], node1))\n         node1.add_connection(connections[1])\n         node1.wait_for_verack()\n \n         self.nodes.append(start_node(2, self.options.tmpdir,\n-                                     [\"-debug\", \"-assumevalid=\" + hex(block102.sha256)]))\n+                                     [\"-assumevalid=\" + hex(block102.sha256)]))\n         node2 = BaseNode()  # connects to node2\n         connections.append(NodeConn('127.0.0.1', p2p_port(2), self.nodes[2], node2))\n         node2.add_connection(connections[2])"
      },
      {
        "sha": "63d05e8fc9e47b9bbc022c8509aae707353659a0",
        "filename": "qa/rpc-tests/bip65-cltv-p2p.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/bip65-cltv-p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/bip65-cltv-p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bip65-cltv-p2p.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -43,7 +43,7 @@ def __init__(self):\n     def setup_network(self):\n         # Must set the blockversion for this test\n         self.nodes = start_nodes(self.num_nodes, self.options.tmpdir,\n-                                 extra_args=[['-debug', '-whitelist=127.0.0.1', '-blockversion=3']],\n+                                 extra_args=[['-whitelist=127.0.0.1', '-blockversion=3']],\n                                  binary=[self.options.testbinary])\n \n     def run_test(self):"
      },
      {
        "sha": "0867f42585ceee27296a7964fadfa4e3318f6cef",
        "filename": "qa/rpc-tests/bip68-112-113-p2p.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/bip68-112-113-p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/bip68-112-113-p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bip68-112-113-p2p.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -99,7 +99,7 @@ def __init__(self):\n     def setup_network(self):\n         # Must set the blockversion for this test\n         self.nodes = start_nodes(self.num_nodes, self.options.tmpdir,\n-                                 extra_args=[['-debug', '-whitelist=127.0.0.1', '-blockversion=4']],\n+                                 extra_args=[['-whitelist=127.0.0.1', '-blockversion=4']],\n                                  binary=[self.options.testbinary])\n \n     def run_test(self):"
      },
      {
        "sha": "2d41a5a44b53f292d257aa420a6f0a8b0eb76c1f",
        "filename": "qa/rpc-tests/bip68-sequence.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/bip68-sequence.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/bip68-sequence.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bip68-sequence.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -24,8 +24,8 @@ def __init__(self):\n \n     def setup_network(self):\n         self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\"]))\n-        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-acceptnonstdtxn=0\"]))\n+        self.nodes.append(start_node(0, self.options.tmpdir))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-acceptnonstdtxn=0\"]))\n         self.is_network_split = False\n         self.relayfee = self.nodes[0].getnetworkinfo()[\"relayfee\"]\n         connect_nodes(self.nodes[0], 1)"
      },
      {
        "sha": "0dffd06e1ab2864a658cac7209809fae9a33cddb",
        "filename": "qa/rpc-tests/bip9-softforks.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/bip9-softforks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/bip9-softforks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bip9-softforks.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -35,7 +35,7 @@ def __init__(self):\n \n     def setup_network(self):\n         self.nodes = start_nodes(self.num_nodes, self.options.tmpdir,\n-                                 extra_args=[['-debug', '-whitelist=127.0.0.1']],\n+                                 extra_args=[['-whitelist=127.0.0.1']],\n                                  binary=[self.options.testbinary])\n \n     def run_test(self):"
      },
      {
        "sha": "22bd39fbe55b864103099aad65842af119b99b57",
        "filename": "qa/rpc-tests/bipdersig-p2p.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/bipdersig-p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/bipdersig-p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bipdersig-p2p.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -50,7 +50,7 @@ def __init__(self):\n     def setup_network(self):\n         # Must set the blockversion for this test\n         self.nodes = start_nodes(self.num_nodes, self.options.tmpdir,\n-                                 extra_args=[['-debug', '-whitelist=127.0.0.1', '-blockversion=2']],\n+                                 extra_args=[['-whitelist=127.0.0.1', '-blockversion=2']],\n                                  binary=[self.options.testbinary])\n \n     def run_test(self):"
      },
      {
        "sha": "79cab2215ae5dd0e5bb118be9eff0a4c0f7cefd4",
        "filename": "qa/rpc-tests/bumpfee.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/bumpfee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/bumpfee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bumpfee.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -26,7 +26,7 @@ def __init__(self):\n         self.setup_clean_chain = True\n \n     def setup_network(self, split=False):\n-        extra_args = [[\"-debug\", \"-prematurewitness\", \"-walletprematurewitness\", \"-walletrbf={}\".format(i)]\n+        extra_args = [[\"-prematurewitness\", \"-walletprematurewitness\", \"-walletrbf={}\".format(i)]\n                       for i in range(self.num_nodes)]\n         self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n "
      },
      {
        "sha": "0218a46168e8766c516d952c62605d4487977599",
        "filename": "qa/rpc-tests/import-rescan.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/import-rescan.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/import-rescan.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/import-rescan.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -7,11 +7,11 @@\n Test rescan behavior of importaddress, importpubkey, importprivkey, and\n importmulti RPCs with different types of keys and rescan options.\n \n-In the first part of the test, node 1 creates an address for each type of\n-import RPC call and node 0 sends BTC to it. Then other nodes import the\n-addresses, and the test makes listtransactions and getbalance calls to confirm\n-that the importing node either did or did not execute rescans picking up the\n-send transactions.\n+In the first part of the test, node 0 creates an address for each type of\n+import RPC call and sends BTC to it. Then other nodes import the addresses,\n+and the test makes listtransactions and getbalance calls to confirm that the\n+importing node either did or did not execute rescans picking up the send\n+transactions.\n \n In the second part of the test, node 0 sends more BTC to each address, and the\n test makes more listtransactions and getbalance calls to confirm that the\n@@ -117,7 +117,7 @@ def __init__(self):\n         self.num_nodes = 2 + len(IMPORT_NODES)\n \n     def setup_network(self):\n-        extra_args = [[\"-debug=1\"] for _ in range(self.num_nodes)]\n+        extra_args = [[] for _ in range(self.num_nodes)]\n         for i, import_node in enumerate(IMPORT_NODES, 2):\n             if import_node.prune:\n                 extra_args[i] += [\"-prune=1\"]"
      },
      {
        "sha": "b19726edb97348e5a747c69234b9c17965a8560b",
        "filename": "qa/rpc-tests/invalidateblock.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/invalidateblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/invalidateblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/invalidateblock.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -18,9 +18,9 @@ def __init__(self):\n     def setup_network(self):\n         self.nodes = []\n         self.is_network_split = False \n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\"]))\n-        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\"]))\n-        self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\"]))\n+        self.nodes.append(start_node(0, self.options.tmpdir))\n+        self.nodes.append(start_node(1, self.options.tmpdir))\n+        self.nodes.append(start_node(2, self.options.tmpdir))\n         \n     def run_test(self):\n         print(\"Make sure we repopulate setBlockIndexCandidates after InvalidateBlock:\")"
      },
      {
        "sha": "5fb4408adf414a64e94bd925033593735bc1cad1",
        "filename": "qa/rpc-tests/maxblocksinflight.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/maxblocksinflight.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/maxblocksinflight.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/maxblocksinflight.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -84,7 +84,7 @@ def __init__(self):\n \n     def setup_network(self):\n         self.nodes = start_nodes(self.num_nodes, self.options.tmpdir,\n-                                 extra_args=[['-debug', '-whitelist=127.0.0.1']],\n+                                 extra_args=[['-whitelist=127.0.0.1']],\n                                  binary=[self.options.testbinary])\n \n     def run_test(self):"
      },
      {
        "sha": "06717e284f3fdb4f02f8225cf4247c9159986a5b",
        "filename": "qa/rpc-tests/maxuploadtarget.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/maxuploadtarget.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/maxuploadtarget.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/maxuploadtarget.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -90,7 +90,7 @@ def __init__(self):\n     def setup_network(self):\n         # Start a node with maxuploadtarget of 200 MB (/24h)\n         self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-maxuploadtarget=800\", \"-blockmaxsize=999000\"]))\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-maxuploadtarget=800\", \"-blockmaxsize=999000\"]))\n \n     def run_test(self):\n         # Before we connect anything, we first set the time on the node\n@@ -199,7 +199,7 @@ def run_test(self):\n         #stop and start node 0 with 1MB maxuploadtarget, whitelist 127.0.0.1\n         print(\"Restarting nodes with -whitelist=127.0.0.1\")\n         stop_node(self.nodes[0], 0)\n-        self.nodes[0] = start_node(0, self.options.tmpdir, [\"-debug\", \"-whitelist=127.0.0.1\", \"-maxuploadtarget=1\", \"-blockmaxsize=999000\"])\n+        self.nodes[0] = start_node(0, self.options.tmpdir, [\"-whitelist=127.0.0.1\", \"-maxuploadtarget=1\", \"-blockmaxsize=999000\"])\n \n         #recreate/reconnect 3 test nodes\n         test_nodes = []"
      },
      {
        "sha": "a7ca576aee447f8e4dadacb6950045219804d58b",
        "filename": "qa/rpc-tests/mempool_limit.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/mempool_limit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/mempool_limit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/mempool_limit.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -11,7 +11,7 @@ class MempoolLimitTest(BitcoinTestFramework):\n \n     def setup_network(self):\n         self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-maxmempool=5\", \"-spendzeroconfchange=0\", \"-debug\"]))\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-maxmempool=5\", \"-spendzeroconfchange=0\"]))\n         self.is_network_split = False\n         self.sync_all()\n         self.relayfee = self.nodes[0].getnetworkinfo()['relayfee']"
      },
      {
        "sha": "ce93ea0235ffa6d6eaa3020371f09f44131b9b1a",
        "filename": "qa/rpc-tests/mempool_packages.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/mempool_packages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/mempool_packages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/mempool_packages.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -19,8 +19,8 @@ def __init__(self):\n \n     def setup_network(self):\n         self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-maxorphantx=1000\", \"-debug\"]))\n-        self.nodes.append(start_node(1, self.options.tmpdir, [\"-maxorphantx=1000\", \"-limitancestorcount=5\", \"-debug\"]))\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-maxorphantx=1000\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-maxorphantx=1000\", \"-limitancestorcount=5\"]))\n         connect_nodes(self.nodes[0], 1)\n         self.is_network_split = False\n         self.sync_all()"
      },
      {
        "sha": "585e4147b21d0dadcdb14cf16e30e82e4d644bac",
        "filename": "qa/rpc-tests/mempool_reorg.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/mempool_reorg.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/mempool_reorg.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/mempool_reorg.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -21,7 +21,7 @@ def __init__(self):\n     alert_filename = None  # Set by setup_network\n \n     def setup_network(self):\n-        args = [\"-checkmempool\", \"-debug=mempool\"]\n+        args = [\"-checkmempool\"]\n         self.nodes = []\n         self.nodes.append(start_node(0, self.options.tmpdir, args))\n         self.nodes.append(start_node(1, self.options.tmpdir, args))"
      },
      {
        "sha": "727892d1f2be4b7f1fadebaa346cf9d524b37fda",
        "filename": "qa/rpc-tests/mempool_resurrect_test.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/mempool_resurrect_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/mempool_resurrect_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/mempool_resurrect_test.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -17,7 +17,7 @@ def __init__(self):\n \n     def setup_network(self):\n         # Just need one node for this test\n-        args = [\"-checkmempool\", \"-debug=mempool\"]\n+        args = [\"-checkmempool\"]\n         self.nodes = []\n         self.nodes.append(start_node(0, self.options.tmpdir, args))\n         self.is_network_split = False"
      },
      {
        "sha": "4818ad8bdaf856b3e79b4487df4f1bdd490eee80",
        "filename": "qa/rpc-tests/mempool_spendcoinbase.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/mempool_spendcoinbase.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/mempool_spendcoinbase.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/mempool_spendcoinbase.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -25,7 +25,7 @@ def __init__(self):\n \n     def setup_network(self):\n         # Just need one node for this test\n-        args = [\"-checkmempool\", \"-debug=mempool\"]\n+        args = [\"-checkmempool\"]\n         self.nodes = []\n         self.nodes.append(start_node(0, self.options.tmpdir, args))\n         self.is_network_split = False"
      },
      {
        "sha": "09683aba10122e0fb07ae3d7356f0d1e046f8b6e",
        "filename": "qa/rpc-tests/merkle_blocks.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/merkle_blocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/merkle_blocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/merkle_blocks.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -17,11 +17,11 @@ def __init__(self):\n     def setup_network(self):\n         self.nodes = []\n         # Nodes 0/1 are \"wallet\" nodes\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\"]))\n-        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\"]))\n+        self.nodes.append(start_node(0, self.options.tmpdir))\n+        self.nodes.append(start_node(1, self.options.tmpdir))\n         # Nodes 2/3 are used for testing\n-        self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\"]))\n-        self.nodes.append(start_node(3, self.options.tmpdir, [\"-debug\", \"-txindex\"]))\n+        self.nodes.append(start_node(2, self.options.tmpdir))\n+        self.nodes.append(start_node(3, self.options.tmpdir, [\"-txindex\"]))\n         connect_nodes(self.nodes[0], 1)\n         connect_nodes(self.nodes[0], 2)\n         connect_nodes(self.nodes[0], 3)"
      },
      {
        "sha": "a69892fabdbc49d224af7b473038fc95d19d780d",
        "filename": "qa/rpc-tests/nulldummy.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/nulldummy.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/nulldummy.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/nulldummy.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -45,7 +45,7 @@ def __init__(self):\n     def setup_network(self):\n         # Must set the blockversion for this test\n         self.nodes = start_nodes(self.num_nodes, self.options.tmpdir,\n-                                 extra_args=[['-debug', '-whitelist=127.0.0.1', '-walletprematurewitness']])\n+                                 extra_args=[['-whitelist=127.0.0.1', '-walletprematurewitness']])\n \n     def run_test(self):\n         self.address = self.nodes[0].getnewaddress()"
      },
      {
        "sha": "037f15568d9bb1f77414e1bde764ac58f4f3392b",
        "filename": "qa/rpc-tests/p2p-acceptblock.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/p2p-acceptblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/p2p-acceptblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-acceptblock.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -119,10 +119,10 @@ def setup_network(self):\n         # from peers which are not whitelisted, while Node1 will be used for\n         # the whitelisted case.\n         self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\"],\n+        self.nodes.append(start_node(0, self.options.tmpdir,\n                                      binary=self.options.testbinary))\n         self.nodes.append(start_node(1, self.options.tmpdir,\n-                                     [\"-debug\", \"-whitelist=127.0.0.1\"],\n+                                     [\"-whitelist=127.0.0.1\"],\n                                      binary=self.options.testbinary))\n \n     def run_test(self):"
      },
      {
        "sha": "33c0c60552122d74b4c81f0db43a88438228c3de",
        "filename": "qa/rpc-tests/p2p-compactblocks.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/p2p-compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/p2p-compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-compactblocks.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -120,8 +120,8 @@ def setup_network(self):\n \n         # Start up node0 to be a version 1, pre-segwit node.\n         self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, \n-                [[\"-debug\", \"-logtimemicros=1\", \"-bip9params=segwit:0:0\"], \n-                 [\"-debug\", \"-logtimemicros\", \"-txindex\"]])\n+                [[\"-bip9params=segwit:0:0\"], \n+                 [\"-txindex\"]])\n         connect_nodes(self.nodes[0], 1)\n \n     def build_block_on_tip(self, node, segwit=False):"
      },
      {
        "sha": "d8f07700d0dc2d04b30d58b2c223e0103000f121",
        "filename": "qa/rpc-tests/p2p-feefilter.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/p2p-feefilter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/p2p-feefilter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-feefilter.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -53,8 +53,8 @@ def setup_network(self):\n         # Node1 will be used to generate txs which should be relayed from Node0\n         # to our test node\n         self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-logtimemicros\"]))\n-        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-logtimemicros\"]))\n+        self.nodes.append(start_node(0, self.options.tmpdir))\n+        self.nodes.append(start_node(1, self.options.tmpdir))\n         connect_nodes(self.nodes[0], 1)\n \n     def run_test(self):"
      },
      {
        "sha": "c86f6257c92424c9b1b0852f8b3498ca0d50acca",
        "filename": "qa/rpc-tests/p2p-leaktests.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/p2p-leaktests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/p2p-leaktests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-leaktests.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -102,7 +102,7 @@ def __init__(self):\n         super().__init__()\n         self.num_nodes = 1\n     def setup_network(self):\n-        extra_args = [['-debug', '-banscore='+str(banscore)]\n+        extra_args = [['-banscore='+str(banscore)]\n                       for i in range(self.num_nodes)]\n         self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n "
      },
      {
        "sha": "0aa9c90e8f3d8b28c512d2b4811693d949e5ccee",
        "filename": "qa/rpc-tests/p2p-mempool.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/p2p-mempool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/p2p-mempool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-mempool.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -85,7 +85,7 @@ def __init__(self):\n     def setup_network(self):\n         # Start a node with maxuploadtarget of 200 MB (/24h)\n         self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-peerbloomfilters=0\"]))\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-peerbloomfilters=0\"]))\n \n     def run_test(self):\n         #connect a mininode"
      },
      {
        "sha": "cb04641b2460bb809a71b82fb170558a730aaf9c",
        "filename": "qa/rpc-tests/p2p-segwit.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/p2p-segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/p2p-segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-segwit.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -194,13 +194,13 @@ def __init__(self):\n \n     def setup_network(self):\n         self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-logtimemicros=1\", \"-whitelist=127.0.0.1\"]))\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-whitelist=127.0.0.1\"]))\n         # Start a node for testing IsStandard rules.\n-        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-logtimemicros=1\", \"-whitelist=127.0.0.1\", \"-acceptnonstdtxn=0\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-whitelist=127.0.0.1\", \"-acceptnonstdtxn=0\"]))\n         connect_nodes(self.nodes[0], 1)\n \n         # Disable segwit's bip9 parameter to simulate upgrading after activation.\n-        self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\", \"-whitelist=127.0.0.1\", \"-bip9params=segwit:0:0\"]))\n+        self.nodes.append(start_node(2, self.options.tmpdir, [\"-whitelist=127.0.0.1\", \"-bip9params=segwit:0:0\"]))\n         connect_nodes(self.nodes[0], 2)\n \n     ''' Helpers '''\n@@ -1572,7 +1572,7 @@ def test_upgrade_after_activation(self, node, node_id):\n \n         # Restart with the new binary\n         stop_node(node, node_id)\n-        self.nodes[node_id] = start_node(node_id, self.options.tmpdir, [\"-debug\"])\n+        self.nodes[node_id] = start_node(node_id, self.options.tmpdir)\n         connect_nodes(self.nodes[0], node_id)\n \n         sync_blocks(self.nodes)"
      },
      {
        "sha": "498acb23fec53bb2d07c99daa4cf67505eccc5bf",
        "filename": "qa/rpc-tests/p2p-timeouts.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/p2p-timeouts.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/p2p-timeouts.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-timeouts.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -53,8 +53,7 @@ def setup_network(self):\n         self.nodes = []\n \n         # Start up node0 to be a version 1, pre-segwit node.\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, \n-                [[\"-debug\", \"-logtimemicros=1\"]])\n+        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir)\n \n     def run_test(self):\n         # Setup the p2p connections and start up the network thread."
      },
      {
        "sha": "dc714e9a4a3f6eace151fc033146ea5ad0061260",
        "filename": "qa/rpc-tests/p2p-versionbits-warning.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/p2p-versionbits-warning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/p2p-versionbits-warning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-versionbits-warning.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -72,7 +72,7 @@ def setup_network(self):\n         # Open and close to create zero-length file\n         with open(self.alert_filename, 'w', encoding='utf8') as _:\n             pass\n-        self.extra_args = [[\"-debug\", \"-logtimemicros=1\", \"-alertnotify=echo %s >> \\\"\" + self.alert_filename + \"\\\"\"]]\n+        self.extra_args = [[\"-alertnotify=echo %s >> \\\"\" + self.alert_filename + \"\\\"\"]]\n         self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, self.extra_args)\n \n     # Send numblocks blocks via peer with nVersionToUse set."
      },
      {
        "sha": "01e5d94c9660abadda72c53bf3d53fc82eed34d6",
        "filename": "qa/rpc-tests/preciousblock.py",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/preciousblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/preciousblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/preciousblock.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -39,7 +39,6 @@ def __init__(self):\n         super().__init__()\n         self.setup_clean_chain = True\n         self.num_nodes = 3\n-        self.extra_args = [[\"-debug\"]] * self.num_nodes\n \n     def setup_network(self):\n         self.nodes = self.setup_nodes()"
      },
      {
        "sha": "59de16e49dd44c5fe009b684ca72e10039c2cdc7",
        "filename": "qa/rpc-tests/prioritise_transaction.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/prioritise_transaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/prioritise_transaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/prioritise_transaction.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -21,7 +21,7 @@ def setup_network(self):\n         self.nodes = []\n         self.is_network_split = False\n \n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-printpriority=1\"]))\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-printpriority=1\"]))\n         self.relayfee = self.nodes[0].getnetworkinfo()['relayfee']\n \n     def run_test(self):"
      },
      {
        "sha": "6b2a8ed1c7cf288803baed7607c5b1cfebef4b0e",
        "filename": "qa/rpc-tests/proxy_test.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/proxy_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/proxy_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/proxy_test.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -83,13 +83,13 @@ def setup_nodes(self):\n         # Note: proxies are not used to connect to local nodes\n         # this is because the proxy to use is based on CService.GetNetwork(), which return NET_UNROUTABLE for localhost\n         args = [\n-            ['-listen', '-debug=net', '-debug=proxy', '-proxy=%s:%i' % (self.conf1.addr),'-proxyrandomize=1'], \n-            ['-listen', '-debug=net', '-debug=proxy', '-proxy=%s:%i' % (self.conf1.addr),'-onion=%s:%i' % (self.conf2.addr),'-proxyrandomize=0'], \n-            ['-listen', '-debug=net', '-debug=proxy', '-proxy=%s:%i' % (self.conf2.addr),'-proxyrandomize=1'], \n+            ['-listen', '-proxy=%s:%i' % (self.conf1.addr),'-proxyrandomize=1'], \n+            ['-listen', '-proxy=%s:%i' % (self.conf1.addr),'-onion=%s:%i' % (self.conf2.addr),'-proxyrandomize=0'], \n+            ['-listen', '-proxy=%s:%i' % (self.conf2.addr),'-proxyrandomize=1'], \n             []\n             ]\n         if self.have_ipv6:\n-            args[3] = ['-listen', '-debug=net', '-debug=proxy', '-proxy=[%s]:%i' % (self.conf3.addr),'-proxyrandomize=0', '-noonion']\n+            args[3] = ['-listen', '-proxy=[%s]:%i' % (self.conf3.addr),'-proxyrandomize=0', '-noonion']\n         return start_nodes(self.num_nodes, self.options.tmpdir, extra_args=args)\n \n     def node_test(self, node, proxies, auth, test_onion=True):"
      },
      {
        "sha": "063123b714f4fc51543411d0e058d01b3d88709c",
        "filename": "qa/rpc-tests/pruning.py",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/pruning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/pruning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/pruning.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -41,19 +41,19 @@ def setup_network(self):\n         self.is_network_split = False\n \n         # Create nodes 0 and 1 to mine\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\",\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\", \"-checkblocks=5\"], timewait=900))\n-        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\",\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\", \"-checkblocks=5\"], timewait=900))\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\", \"-checkblocks=5\"], timewait=900))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\", \"-checkblocks=5\"], timewait=900))\n \n         # Create node 2 to test pruning\n-        self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\",\"-maxreceivebuffer=20000\",\"-prune=550\"], timewait=900))\n+        self.nodes.append(start_node(2, self.options.tmpdir, [\"-maxreceivebuffer=20000\",\"-prune=550\"], timewait=900))\n         self.prunedir = self.options.tmpdir+\"/node2/regtest/blocks/\"\n \n         # Create nodes 3 and 4 to test manual pruning (they will be re-started with manual pruning later)\n-        self.nodes.append(start_node(3, self.options.tmpdir, [\"-debug=0\",\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\"], timewait=900))\n-        self.nodes.append(start_node(4, self.options.tmpdir, [\"-debug=0\",\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\"], timewait=900))\n+        self.nodes.append(start_node(3, self.options.tmpdir, [\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\"], timewait=900))\n+        self.nodes.append(start_node(4, self.options.tmpdir, [\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\"], timewait=900))\n \n         # Create nodes 5 to test wallet in prune mode, but do not connect\n-        self.nodes.append(start_node(5, self.options.tmpdir, [\"-debug=0\", \"-prune=550\"]))\n+        self.nodes.append(start_node(5, self.options.tmpdir, [\"-prune=550\"]))\n \n         # Determine default relay fee\n         self.relayfee = self.nodes[0].getnetworkinfo()[\"relayfee\"]\n@@ -107,7 +107,7 @@ def create_chain_with_staleblocks(self):\n             # Node 2 stays connected, so it hears about the stale blocks and then reorg's when node0 reconnects\n             # Stopping node 0 also clears its mempool, so it doesn't have node1's transactions to accidentally mine\n             self.stop_node(0)\n-            self.nodes[0]=start_node(0, self.options.tmpdir, [\"-debug\",\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\", \"-checkblocks=5\"], timewait=900)\n+            self.nodes[0]=start_node(0, self.options.tmpdir, [\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\", \"-checkblocks=5\"], timewait=900)\n             # Mine 24 blocks in node 1\n             for i in range(24):\n                 if j == 0:\n@@ -132,7 +132,7 @@ def reorg_test(self):\n         # Reboot node 1 to clear its mempool (hopefully make the invalidate faster)\n         # Lower the block max size so we don't keep mining all our big mempool transactions (from disconnected blocks)\n         self.stop_node(1)\n-        self.nodes[1]=start_node(1, self.options.tmpdir, [\"-debug\",\"-maxreceivebuffer=20000\",\"-blockmaxsize=5000\", \"-checkblocks=5\", \"-disablesafemode\"], timewait=900)\n+        self.nodes[1]=start_node(1, self.options.tmpdir, [\"-maxreceivebuffer=20000\",\"-blockmaxsize=5000\", \"-checkblocks=5\", \"-disablesafemode\"], timewait=900)\n \n         height = self.nodes[1].getblockcount()\n         print(\"Current block height:\", height)\n@@ -155,7 +155,7 @@ def reorg_test(self):\n \n         # Reboot node1 to clear those giant tx's from mempool\n         self.stop_node(1)\n-        self.nodes[1]=start_node(1, self.options.tmpdir, [\"-debug\",\"-maxreceivebuffer=20000\",\"-blockmaxsize=5000\", \"-checkblocks=5\", \"-disablesafemode\"], timewait=900)\n+        self.nodes[1]=start_node(1, self.options.tmpdir, [\"-maxreceivebuffer=20000\",\"-blockmaxsize=5000\", \"-checkblocks=5\", \"-disablesafemode\"], timewait=900)\n \n         print(\"Generating new longer chain of 300 more blocks\")\n         self.nodes[1].generate(300)\n@@ -228,13 +228,13 @@ def reorg_back(self):\n \n     def manual_test(self, node_number, use_timestamp):\n         # at this point, node has 995 blocks and has not yet run in prune mode\n-        node = self.nodes[node_number] = start_node(node_number, self.options.tmpdir, [\"-debug=0\"], timewait=900)\n+        node = self.nodes[node_number] = start_node(node_number, self.options.tmpdir, timewait=900)\n         assert_equal(node.getblockcount(), 995)\n         assert_raises_jsonrpc(-1, \"not in prune mode\", node.pruneblockchain, 500)\n         self.stop_node(node_number)\n \n         # now re-start in manual pruning mode\n-        node = self.nodes[node_number] = start_node(node_number, self.options.tmpdir, [\"-debug=0\",\"-prune=1\"], timewait=900)\n+        node = self.nodes[node_number] = start_node(node_number, self.options.tmpdir, [\"-prune=1\"], timewait=900)\n         assert_equal(node.getblockcount(), 995)\n \n         def height(index):\n@@ -308,15 +308,15 @@ def has_block(index):\n \n         # stop node, start back up with auto-prune at 550MB, make sure still runs\n         self.stop_node(node_number)\n-        self.nodes[node_number] = start_node(node_number, self.options.tmpdir, [\"-debug=0\",\"-prune=550\"], timewait=900)\n+        self.nodes[node_number] = start_node(node_number, self.options.tmpdir, [\"-prune=550\"], timewait=900)\n \n         print(\"Success\")\n \n     def wallet_test(self):\n         # check that the pruning node's wallet is still in good shape\n         print(\"Stop and start pruning node to trigger wallet rescan\")\n         self.stop_node(2)\n-        start_node(2, self.options.tmpdir, [\"-debug=1\",\"-prune=550\"])\n+        start_node(2, self.options.tmpdir, [\"-prune=550\"])\n         print(\"Success\")\n \n         # check that wallet loads loads successfully when restarting a pruned node after IBD.\n@@ -326,7 +326,7 @@ def wallet_test(self):\n         nds = [self.nodes[0], self.nodes[5]]\n         sync_blocks(nds, wait=5, timeout=300)\n         self.stop_node(5) #stop and start to trigger rescan\n-        start_node(5, self.options.tmpdir, [\"-debug=1\",\"-prune=550\"])\n+        start_node(5, self.options.tmpdir, [\"-prune=550\"])\n         print (\"Success\")\n \n     def run_test(self):"
      },
      {
        "sha": "c9d14f4566fecbadaad7b58717ff3a6b8c955091",
        "filename": "qa/rpc-tests/reindex.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/reindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/reindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/reindex.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -31,7 +31,7 @@ def reindex(self, justchainstate=False):\n         self.nodes[0].generate(3)\n         blockcount = self.nodes[0].getblockcount()\n         stop_nodes(self.nodes)\n-        extra_args = [[\"-debug\", \"-reindex-chainstate\" if justchainstate else \"-reindex\", \"-checkblockindex=1\"]]\n+        extra_args = [[\"-reindex-chainstate\" if justchainstate else \"-reindex\", \"-checkblockindex=1\"]]\n         self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n         while self.nodes[0].getblockcount() < blockcount:\n             time.sleep(0.1)"
      },
      {
        "sha": "27c93ff89eb554541fddc183d7fe412baf93105a",
        "filename": "qa/rpc-tests/replace-by-fee.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/replace-by-fee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/replace-by-fee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/replace-by-fee.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -72,7 +72,7 @@ def __init__(self):\n \n     def setup_network(self):\n         self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-maxorphantx=1000\", \"-debug\",\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-maxorphantx=1000\",\n                                                               \"-whitelist=127.0.0.1\",\n                                                               \"-limitancestorcount=50\",\n                                                               \"-limitancestorsize=101\","
      },
      {
        "sha": "051358a9680b2f69f5a4cf948e21676cee251a4b",
        "filename": "qa/rpc-tests/segwit.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/segwit.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -82,9 +82,9 @@ def __init__(self):\n \n     def setup_network(self):\n         self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-logtimemicros\", \"-debug\", \"-walletprematurewitness\", \"-rpcserialversion=0\"]))\n-        self.nodes.append(start_node(1, self.options.tmpdir, [\"-logtimemicros\", \"-debug\", \"-blockversion=4\", \"-promiscuousmempoolflags=517\", \"-prematurewitness\", \"-walletprematurewitness\", \"-rpcserialversion=1\"]))\n-        self.nodes.append(start_node(2, self.options.tmpdir, [\"-logtimemicros\", \"-debug\", \"-blockversion=536870915\", \"-promiscuousmempoolflags=517\", \"-prematurewitness\", \"-walletprematurewitness\"]))\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-walletprematurewitness\", \"-rpcserialversion=0\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-blockversion=4\", \"-promiscuousmempoolflags=517\", \"-prematurewitness\", \"-walletprematurewitness\", \"-rpcserialversion=1\"]))\n+        self.nodes.append(start_node(2, self.options.tmpdir, [\"-blockversion=536870915\", \"-promiscuousmempoolflags=517\", \"-prematurewitness\", \"-walletprematurewitness\"]))\n         connect_nodes(self.nodes[1], 0)\n         connect_nodes(self.nodes[2], 1)\n         connect_nodes(self.nodes[0], 2)"
      },
      {
        "sha": "b36efadbe9ef026f8d7b94e3dc1d87baf62b3ccc",
        "filename": "qa/rpc-tests/sendheaders.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/sendheaders.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/sendheaders.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/sendheaders.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -229,7 +229,7 @@ def __init__(self):\n \n     def setup_network(self):\n         self.nodes = []\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, [[\"-debug\", \"-logtimemicros=1\"]]*2)\n+        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir)\n         connect_nodes(self.nodes[0], 1)\n \n     # mine count blocks and return the new tip"
      },
      {
        "sha": "ccae17058816022121b0a64f017b3e3ee9be8ca9",
        "filename": "qa/rpc-tests/smartfees.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/smartfees.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/smartfees.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/smartfees.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -193,8 +193,7 @@ def setup_network(self):\n         # NOTE: the CreateNewBlock code starts counting block size at 1,000 bytes,\n         # (17k is room enough for 110 or so transactions)\n         self.nodes.append(start_node(1, self.options.tmpdir,\n-                                     [\"-blockmaxsize=17000\",\n-                                      \"-maxorphantx=1000\", \"-debug=estimatefee\"]))\n+                                     [\"-blockmaxsize=17000\", \"-maxorphantx=1000\"]))\n         connect_nodes(self.nodes[1], 0)\n \n         # Node2 is a stingy miner, that"
      },
      {
        "sha": "d7072fa78d23cffe9308fc3b5dffbb0e38885eaf",
        "filename": "qa/rpc-tests/test_framework/test_framework.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/test_framework/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0dec4a04a2d9415bfb4996404900e2c173b41d0/qa/rpc-tests/test_framework/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/test_framework.py?ref=b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "patch": "@@ -239,6 +239,6 @@ def add_options(self, parser):\n     def setup_network(self):\n         self.nodes = start_nodes(\n             self.num_nodes, self.options.tmpdir,\n-            extra_args=[['-debug', '-whitelist=127.0.0.1']] * self.num_nodes,\n+            extra_args=[['-whitelist=127.0.0.1']] * self.num_nodes,\n             binary=[self.options.testbinary] +\n             [self.options.refbinary]*(self.num_nodes-1))"
      }
    ]
  },
  {
    "sha": "2a9c7c74dc557a0a1d8ef11b783aa134a00fe484",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyYTljN2M3NGRjNTU3YTBhMWQ4ZWYxMWI3ODNhYTEzNGEwMGZlNDg0",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-02-24T22:02:38Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-03-09T14:26:48Z"
      },
      "message": "Use logging in test_framework/util.py",
      "tree": {
        "sha": "3ec409efddbfdc97173b2c468e78868ce6fc972a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3ec409efddbfdc97173b2c468e78868ce6fc972a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2a9c7c74dc557a0a1d8ef11b783aa134a00fe484",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2a9c7c74dc557a0a1d8ef11b783aa134a00fe484",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2a9c7c74dc557a0a1d8ef11b783aa134a00fe484",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2a9c7c74dc557a0a1d8ef11b783aa134a00fe484/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b0dec4a04a2d9415bfb4996404900e2c173b41d0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b0dec4a04a2d9415bfb4996404900e2c173b41d0"
      }
    ],
    "stats": {
      "total": 19,
      "additions": 10,
      "deletions": 9
    },
    "files": [
      {
        "sha": "23ac32451038fe48e3ec7286023e59a7add26588",
        "filename": "qa/rpc-tests/test_framework/util.py",
        "status": "modified",
        "additions": 10,
        "deletions": 9,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a9c7c74dc557a0a1d8ef11b783aa134a00fe484/qa/rpc-tests/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a9c7c74dc557a0a1d8ef11b783aa134a00fe484/qa/rpc-tests/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/util.py?ref=2a9c7c74dc557a0a1d8ef11b783aa134a00fe484",
        "patch": "@@ -19,12 +19,15 @@\n import time\n import re\n import errno\n+import logging\n \n from . import coverage\n from .authproxy import AuthServiceProxy, JSONRPCException\n \n COVERAGE_DIR = None\n \n+logger = logging.getLogger(\"TestFramework.utils\")\n+\n # The maximum number of nodes a single test can spawn\n MAX_NODES = 8\n # Don't assign rpc or p2p ports lower than this\n@@ -237,6 +240,7 @@ def initialize_chain(test_dir, num_nodes, cachedir):\n             break\n \n     if create_cache:\n+        logger.debug(\"Creating data directories from cached datadir\")\n \n         #find and delete old cache directories if any exist\n         for i in range(MAX_NODES):\n@@ -250,11 +254,9 @@ def initialize_chain(test_dir, num_nodes, cachedir):\n             if i > 0:\n                 args.append(\"-connect=127.0.0.1:\"+str(p2p_port(0)))\n             bitcoind_processes[i] = subprocess.Popen(args)\n-            if os.getenv(\"PYTHON_DEBUG\", \"\"):\n-                print(\"initialize_chain: bitcoind started, waiting for RPC to come up\")\n+            logger.debug(\"initialize_chain: bitcoind started, waiting for RPC to come up\")\n             wait_for_bitcoind_start(bitcoind_processes[i], rpc_url(i), i)\n-            if os.getenv(\"PYTHON_DEBUG\", \"\"):\n-                print(\"initialize_chain: RPC successfully started\")\n+            logger.debug(\"initialize_chain: RPC successfully started\")\n \n         rpcs = []\n         for i in range(MAX_NODES):\n@@ -316,12 +318,10 @@ def start_node(i, dirname, extra_args=None, rpchost=None, timewait=None, binary=\n     args = [ binary, \"-datadir=\"+datadir, \"-server\", \"-keypool=1\", \"-discover=0\", \"-rest\", \"-logtimemicros\", \"-debug\", \"-mocktime=\"+str(get_mocktime()) ]\n     if extra_args is not None: args.extend(extra_args)\n     bitcoind_processes[i] = subprocess.Popen(args, stderr=stderr)\n-    if os.getenv(\"PYTHON_DEBUG\", \"\"):\n-        print(\"start_node: bitcoind started, waiting for RPC to come up\")\n+    logger.debug(\"initialize_chain: bitcoind started, waiting for RPC to come up\")\n     url = rpc_url(i, rpchost)\n     wait_for_bitcoind_start(bitcoind_processes[i], url, i)\n-    if os.getenv(\"PYTHON_DEBUG\", \"\"):\n-        print(\"start_node: RPC successfully started\")\n+    logger.debug(\"initialize_chain: RPC successfully started\")\n     proxy = get_rpc_proxy(url, i, timeout=timewait)\n \n     if COVERAGE_DIR:\n@@ -367,10 +367,11 @@ def log_filename(dirname, n_node, logname):\n     return os.path.join(dirname, \"node\"+str(n_node), \"regtest\", logname)\n \n def stop_node(node, i):\n+    logger.debug(\"Stopping node %d\" % i)\n     try:\n         node.stop()\n     except http.client.CannotSendRequest as e:\n-        print(\"WARN: Unable to stop node: \" + repr(e))\n+        logger.exception(\"Unable to stop node\")\n     return_code = bitcoind_processes[i].wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n     assert_equal(return_code, 0)\n     del bitcoind_processes[i]"
      }
    ]
  },
  {
    "sha": "ff190739be99a134df5e682c37ef255c51bc6128",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZjE5MDczOWJlOTlhMTM0ZGY1ZTY4MmMzN2VmMjU1YzUxYmM2MTI4",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-02-24T22:54:19Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-03-09T14:26:48Z"
      },
      "message": "Use logging in test_framework/blockstore.py",
      "tree": {
        "sha": "55ef5c7dff7bf4c9c150c75fb700f341739bd0fd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/55ef5c7dff7bf4c9c150c75fb700f341739bd0fd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ff190739be99a134df5e682c37ef255c51bc6128",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ff190739be99a134df5e682c37ef255c51bc6128",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ff190739be99a134df5e682c37ef255c51bc6128",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ff190739be99a134df5e682c37ef255c51bc6128/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2a9c7c74dc557a0a1d8ef11b783aa134a00fe484",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2a9c7c74dc557a0a1d8ef11b783aa134a00fe484",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2a9c7c74dc557a0a1d8ef11b783aa134a00fe484"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 4,
      "deletions": 2
    },
    "files": [
      {
        "sha": "4cfd682bb58c11f3e76e9dda588562e47c3d74fd",
        "filename": "qa/rpc-tests/test_framework/blockstore.py",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ff190739be99a134df5e682c37ef255c51bc6128/qa/rpc-tests/test_framework/blockstore.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ff190739be99a134df5e682c37ef255c51bc6128/qa/rpc-tests/test_framework/blockstore.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/blockstore.py?ref=ff190739be99a134df5e682c37ef255c51bc6128",
        "patch": "@@ -8,6 +8,8 @@\n from io import BytesIO\n import dbm.dumb as dbmd\n \n+logger = logging.getLogger(\"TestFramework.blockstore\")\n+\n class BlockStore(object):\n     \"\"\"BlockStore helper class.\n \n@@ -86,7 +88,7 @@ def add_block(self, block):\n         try:\n             self.blockDB[repr(block.sha256)] = bytes(block.serialize())\n         except TypeError as e:\n-            print(\"Unexpected error: \", sys.exc_info()[0], e.args)\n+            logger.exception(\"Unexpected error\")\n         self.currentBlock = block.sha256\n         self.headers_map[block.sha256] = CBlockHeader(block)\n \n@@ -156,7 +158,7 @@ def add_transaction(self, tx):\n         try:\n             self.txDB[repr(tx.sha256)] = bytes(tx.serialize())\n         except TypeError as e:\n-            print(\"Unexpected error: \", sys.exc_info()[0], e.args)\n+            logger.exception(\"Unexpected error\")\n \n     def get_transactions(self, inv):\n         responses = []"
      }
    ]
  },
  {
    "sha": "38ad281b2ad526f4aeef9445c1aa3715d692d861",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozOGFkMjgxYjJhZDUyNmY0YWVlZjk0NDVjMWFhMzcxNWQ2OTJkODYx",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-02-24T22:54:29Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-03-09T14:26:48Z"
      },
      "message": "Use logging in test_framework/comptool.py",
      "tree": {
        "sha": "4c8c45cc9db9fde9be3f84b4ef46fc1a723f3286",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4c8c45cc9db9fde9be3f84b4ef46fc1a723f3286"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/38ad281b2ad526f4aeef9445c1aa3715d692d861",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/38ad281b2ad526f4aeef9445c1aa3715d692d861",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/38ad281b2ad526f4aeef9445c1aa3715d692d861",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/38ad281b2ad526f4aeef9445c1aa3715d692d861/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ff190739be99a134df5e682c37ef255c51bc6128",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ff190739be99a134df5e682c37ef255c51bc6128",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ff190739be99a134df5e682c37ef255c51bc6128"
      }
    ],
    "stats": {
      "total": 19,
      "additions": 9,
      "deletions": 10
    },
    "files": [
      {
        "sha": "70d1d700ef7ad098f380ba7cbcac29efe9e19dec",
        "filename": "qa/rpc-tests/test_framework/comptool.py",
        "status": "modified",
        "additions": 9,
        "deletions": 10,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/38ad281b2ad526f4aeef9445c1aa3715d692d861/qa/rpc-tests/test_framework/comptool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/38ad281b2ad526f4aeef9445c1aa3715d692d861/qa/rpc-tests/test_framework/comptool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/comptool.py?ref=38ad281b2ad526f4aeef9445c1aa3715d692d861",
        "patch": "@@ -21,6 +21,10 @@\n from .blockstore import BlockStore, TxStore\n from .util import p2p_port\n \n+import logging\n+\n+logger=logging.getLogger(\"TestFramework.comptool\")\n+\n global mininode_lock\n \n class RejectResult(object):\n@@ -209,7 +213,6 @@ def blocks_requested():\n \n         # --> error if not requested\n         if not wait_until(blocks_requested, attempts=20*num_blocks):\n-            # print [ c.cb.block_request_map for c in self.connections ]\n             raise AssertionError(\"Not all nodes requested block\")\n \n         # Send getheaders message\n@@ -231,7 +234,6 @@ def transaction_requested():\n \n         # --> error if not requested\n         if not wait_until(transaction_requested, attempts=20*num_events):\n-            # print [ c.cb.tx_request_map for c in self.connections ]\n             raise AssertionError(\"Not all nodes requested transaction\")\n \n         # Get the mempool\n@@ -258,13 +260,12 @@ def check_results(self, blockhash, outcome):\n                     if c.cb.bestblockhash == blockhash:\n                         return False\n                     if blockhash not in c.cb.block_reject_map:\n-                        print('Block not in reject map: %064x' % (blockhash))\n+                        logger.error('Block not in reject map: %064x' % (blockhash))\n                         return False\n                     if not outcome.match(c.cb.block_reject_map[blockhash]):\n-                        print('Block rejected with %s instead of expected %s: %064x' % (c.cb.block_reject_map[blockhash], outcome, blockhash))\n+                        logger.error('Block rejected with %s instead of expected %s: %064x' % (c.cb.block_reject_map[blockhash], outcome, blockhash))\n                         return False\n                 elif ((c.cb.bestblockhash == blockhash) != outcome):\n-                    # print c.cb.bestblockhash, blockhash, outcome\n                     return False\n             return True\n \n@@ -280,19 +281,17 @@ def check_mempool(self, txhash, outcome):\n                 if outcome is None:\n                     # Make sure the mempools agree with each other\n                     if c.cb.lastInv != self.connections[0].cb.lastInv:\n-                        # print c.rpc.getrawmempool()\n                         return False\n                 elif isinstance(outcome, RejectResult): # Check that tx was rejected w/ code\n                     if txhash in c.cb.lastInv:\n                         return False\n                     if txhash not in c.cb.tx_reject_map:\n-                        print('Tx not in reject map: %064x' % (txhash))\n+                        logger.error('Tx not in reject map: %064x' % (txhash))\n                         return False\n                     if not outcome.match(c.cb.tx_reject_map[txhash]):\n-                        print('Tx rejected with %s instead of expected %s: %064x' % (c.cb.tx_reject_map[txhash], outcome, txhash))\n+                        logger.error('Tx rejected with %s instead of expected %s: %064x' % (c.cb.tx_reject_map[txhash], outcome, txhash))\n                         return False\n                 elif ((txhash in c.cb.lastInv) != outcome):\n-                    # print c.rpc.getrawmempool(), c.cb.lastInv\n                     return False\n             return True\n \n@@ -402,7 +401,7 @@ def run(self):\n                 if (not self.check_mempool(tx.sha256, tx_outcome)):\n                     raise AssertionError(\"Mempool test failed at test %d\" % test_number)\n \n-            print(\"Test %d: PASS\" % test_number, [ c.rpc.getblockcount() for c in self.connections ])\n+            logger.info(\"Test %d: PASS\" % test_number)\n             test_number += 1\n \n         [ c.disconnect_node() for c in self.connections ]"
      }
    ]
  },
  {
    "sha": "64c080051b932b3e53ece7638f199e48d0ad16c8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NGMwODAwNTFiOTMyYjNlNTNlY2U3NjM4ZjE5OWU0OGQwYWQxNmM4",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-03-07T23:46:17Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-03-09T14:26:48Z"
      },
      "message": "Use logging in individual tests",
      "tree": {
        "sha": "87dbf2ccfa73d4650556919e92108033b54fc9a7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/87dbf2ccfa73d4650556919e92108033b54fc9a7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/64c080051b932b3e53ece7638f199e48d0ad16c8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/64c080051b932b3e53ece7638f199e48d0ad16c8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/64c080051b932b3e53ece7638f199e48d0ad16c8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/64c080051b932b3e53ece7638f199e48d0ad16c8/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "38ad281b2ad526f4aeef9445c1aa3715d692d861",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/38ad281b2ad526f4aeef9445c1aa3715d692d861",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/38ad281b2ad526f4aeef9445c1aa3715d692d861"
      }
    ],
    "stats": {
      "total": 436,
      "additions": 212,
      "deletions": 224
    },
    "files": [
      {
        "sha": "887dbebd4f1068e2253fe27919a4200f6dbb94d7",
        "filename": "qa/rpc-tests/abandonconflict.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/abandonconflict.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/abandonconflict.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/abandonconflict.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -158,9 +158,9 @@ def run_test(self):\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n         newbalance = self.nodes[0].getbalance()\n         #assert_equal(newbalance, balance - Decimal(\"10\"))\n-        print(\"If balance has not declined after invalidateblock then out of mempool wallet tx which is no longer\")\n-        print(\"conflicted has not resumed causing its inputs to be seen as spent.  See Issue #7315\")\n-        print(str(balance) + \" -> \" + str(newbalance) + \" ?\")\n+        self.log.info(\"If balance has not declined after invalidateblock then out of mempool wallet tx which is no longer\")\n+        self.log.info(\"conflicted has not resumed causing its inputs to be seen as spent.  See Issue #7315\")\n+        self.log.info(str(balance) + \" -> \" + str(newbalance) + \" ?\")\n \n if __name__ == '__main__':\n     AbandonConflictTest().main()"
      },
      {
        "sha": "ffd461ccb0b8da59cbda930e7e58891b42bbdcbf",
        "filename": "qa/rpc-tests/bip68-sequence.py",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/bip68-sequence.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/bip68-sequence.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bip68-sequence.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -34,26 +34,26 @@ def run_test(self):\n         # Generate some coins\n         self.nodes[0].generate(110)\n \n-        print(\"Running test disable flag\")\n+        self.log.info(\"Running test disable flag\")\n         self.test_disable_flag()\n \n-        print(\"Running test sequence-lock-confirmed-inputs\")\n+        self.log.info(\"Running test sequence-lock-confirmed-inputs\")\n         self.test_sequence_lock_confirmed_inputs()\n \n-        print(\"Running test sequence-lock-unconfirmed-inputs\")\n+        self.log.info(\"Running test sequence-lock-unconfirmed-inputs\")\n         self.test_sequence_lock_unconfirmed_inputs()\n \n-        print(\"Running test BIP68 not consensus before versionbits activation\")\n+        self.log.info(\"Running test BIP68 not consensus before versionbits activation\")\n         self.test_bip68_not_consensus()\n \n-        print(\"Activating BIP68 (and 112/113)\")\n+        self.log.info(\"Activating BIP68 (and 112/113)\")\n         self.activateCSV()\n \n-        print(\"Verifying nVersion=2 transactions are standard.\")\n-        print(\"Note that with current versions of bitcoin software, nVersion=2 transactions are always standard (independent of BIP68 activation status).\")\n+        self.log.info(\"Verifying nVersion=2 transactions are standard.\")\n+        self.log.info(\"Note that nVersion=2 transactions are always standard (independent of BIP68 activation status).\")\n         self.test_version2_relay()\n \n-        print(\"Passed\\n\")\n+        self.log.info(\"Passed\")\n \n     # Test that BIP68 is not in effect if tx version is 1, or if\n     # the first sequence bit is set."
      },
      {
        "sha": "69db197e7a1aafe449c35147064e78c8329e54b7",
        "filename": "qa/rpc-tests/bumpfee.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/bumpfee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/bumpfee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bumpfee.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -45,7 +45,7 @@ def run_test(self):\n         rbf_node_address = rbf_node.getnewaddress()\n \n         # fund rbf node with 10 coins of 0.001 btc (100,000 satoshis)\n-        print(\"Mining blocks...\")\n+        self.log.info(\"Mining blocks...\")\n         peer_node.generate(110)\n         self.sync_all()\n         for i in range(25):\n@@ -55,7 +55,7 @@ def run_test(self):\n         self.sync_all()\n         assert_equal(rbf_node.getbalance(), Decimal(\"0.025\"))\n \n-        print(\"Running tests\")\n+        self.log.info(\"Running tests\")\n         dest_address = peer_node.getnewaddress()\n         test_small_output_fails(rbf_node, dest_address)\n         test_dust_to_fee(rbf_node, dest_address)\n@@ -70,7 +70,7 @@ def run_test(self):\n         test_unconfirmed_not_spendable(rbf_node, rbf_node_address)\n         test_bumpfee_metadata(rbf_node, dest_address)\n         test_locked_wallet_fails(rbf_node, dest_address)\n-        print(\"Success\")\n+        self.log.info(\"Success\")\n \n \n def test_simple_bumpfee_succeeds(rbf_node, peer_node, dest_address):"
      },
      {
        "sha": "fd330ef2779176c8225e242978b8ffdb53c201cc",
        "filename": "qa/rpc-tests/fundrawtransaction.py",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/fundrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/fundrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/fundrawtransaction.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -34,8 +34,6 @@ def setup_network(self, split=False):\n         self.sync_all()\n \n     def run_test(self):\n-        print(\"Mining blocks...\")\n-\n         min_relay_tx_fee = self.nodes[0].getnetworkinfo()['relayfee']\n         # This test is not meant to test fee estimation and we'd like\n         # to be sure all txs are sent at a consistent desired feerate"
      },
      {
        "sha": "dc17bbd7b3d7fe9dffcafeaf8c956448f4683737",
        "filename": "qa/rpc-tests/getblocktemplate_longpoll.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/getblocktemplate_longpoll.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/getblocktemplate_longpoll.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/getblocktemplate_longpoll.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -29,7 +29,7 @@ def __init__(self):\n         self.setup_clean_chain = False\n \n     def run_test(self):\n-        print(\"Warning: this test will take about 70 seconds in the best case. Be patient.\")\n+        self.log.info(\"Warning: this test will take about 70 seconds in the best case. Be patient.\")\n         self.nodes[0].generate(10)\n         templat = self.nodes[0].getblocktemplate()\n         longpollid = templat['longpollid']"
      },
      {
        "sha": "298b6e9b86ae396da4c72981fc21b86889d98dfe",
        "filename": "qa/rpc-tests/importmulti.py",
        "status": "modified",
        "additions": 21,
        "deletions": 21,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/importmulti.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -17,7 +17,7 @@ def setup_network(self, split=False):\n         self.is_network_split=False\n \n     def run_test (self):\n-        print (\"Mining blocks...\")\n+        self.log.info(\"Mining blocks...\")\n         self.nodes[0].generate(1)\n         self.nodes[1].generate(1)\n         timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n@@ -48,7 +48,7 @@ def run_test (self):\n         # RPC importmulti -----------------------------------------------\n \n         # Bitcoin Address\n-        print(\"Should import an address\")\n+        self.log.info(\"Should import an address\")\n         address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n@@ -64,7 +64,7 @@ def run_test (self):\n         watchonly_address = address['address']\n         watchonly_timestamp = timestamp\n \n-        print(\"Should not import an invalid address\")\n+        self.log.info(\"Should not import an invalid address\")\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n                 \"address\": \"not valid address\",\n@@ -76,7 +76,7 @@ def run_test (self):\n         assert_equal(result[0]['error']['message'], 'Invalid address')\n \n         # ScriptPubKey + internal\n-        print(\"Should import a scriptPubKey with internal flag\")\n+        self.log.info(\"Should import a scriptPubKey with internal flag\")\n         address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": address['scriptPubKey'],\n@@ -90,7 +90,7 @@ def run_test (self):\n         assert_equal(address_assert['timestamp'], timestamp)\n \n         # ScriptPubKey + !internal\n-        print(\"Should not import a scriptPubKey without internal flag\")\n+        self.log.info(\"Should not import a scriptPubKey without internal flag\")\n         address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": address['scriptPubKey'],\n@@ -106,7 +106,7 @@ def run_test (self):\n \n \n         # Address + Public key + !Internal\n-        print(\"Should import an address with public key\")\n+        self.log.info(\"Should import an address with public key\")\n         address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n@@ -123,7 +123,7 @@ def run_test (self):\n \n \n         # ScriptPubKey + Public key + internal\n-        print(\"Should import a scriptPubKey with internal and with public key\")\n+        self.log.info(\"Should import a scriptPubKey with internal and with public key\")\n         address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         request = [{\n             \"scriptPubKey\": address['scriptPubKey'],\n@@ -139,7 +139,7 @@ def run_test (self):\n         assert_equal(address_assert['timestamp'], timestamp)\n \n         # ScriptPubKey + Public key + !internal\n-        print(\"Should not import a scriptPubKey without internal and with public key\")\n+        self.log.info(\"Should not import a scriptPubKey without internal and with public key\")\n         address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         request = [{\n             \"scriptPubKey\": address['scriptPubKey'],\n@@ -156,7 +156,7 @@ def run_test (self):\n         assert_equal('timestamp' in address_assert, False)\n \n         # Address + Private key + !watchonly\n-        print(\"Should import an address with private key\")\n+        self.log.info(\"Should import an address with private key\")\n         address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n@@ -172,7 +172,7 @@ def run_test (self):\n         assert_equal(address_assert['timestamp'], timestamp)\n \n         # Address + Private key + watchonly\n-        print(\"Should not import an address with private key and with watchonly\")\n+        self.log.info(\"Should not import an address with private key and with watchonly\")\n         address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n@@ -191,7 +191,7 @@ def run_test (self):\n         assert_equal('timestamp' in address_assert, False)\n \n         # ScriptPubKey + Private key + internal\n-        print(\"Should import a scriptPubKey with internal and with private key\")\n+        self.log.info(\"Should import a scriptPubKey with internal and with private key\")\n         address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": address['scriptPubKey'],\n@@ -206,7 +206,7 @@ def run_test (self):\n         assert_equal(address_assert['timestamp'], timestamp)\n \n         # ScriptPubKey + Private key + !internal\n-        print(\"Should not import a scriptPubKey without internal and with private key\")\n+        self.log.info(\"Should not import a scriptPubKey without internal and with private key\")\n         address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": address['scriptPubKey'],\n@@ -233,7 +233,7 @@ def run_test (self):\n         timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n         transaction = self.nodes[1].gettransaction(transactionid)\n \n-        print(\"Should import a p2sh\")\n+        self.log.info(\"Should import a p2sh\")\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n                 \"address\": multi_sig_script['address']\n@@ -261,7 +261,7 @@ def run_test (self):\n         timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n         transaction = self.nodes[1].gettransaction(transactionid)\n \n-        print(\"Should import a p2sh with respective redeem script\")\n+        self.log.info(\"Should import a p2sh with respective redeem script\")\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n                 \"address\": multi_sig_script['address']\n@@ -289,7 +289,7 @@ def run_test (self):\n         timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n         transaction = self.nodes[1].gettransaction(transactionid)\n \n-        print(\"Should import a p2sh with respective redeem script and private keys\")\n+        self.log.info(\"Should import a p2sh with respective redeem script and private keys\")\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n                 \"address\": multi_sig_script['address']\n@@ -316,7 +316,7 @@ def run_test (self):\n         self.nodes[1].generate(1)\n         transaction = self.nodes[1].gettransaction(transactionid)\n \n-        print(\"Should import a p2sh with respective redeem script and private keys\")\n+        self.log.info(\"Should import a p2sh with respective redeem script and private keys\")\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n                 \"address\": multi_sig_script['address']\n@@ -332,7 +332,7 @@ def run_test (self):\n \n \n         # Address + Public key + !Internal + Wrong pubkey\n-        print(\"Should not import an address with a wrong public key\")\n+        self.log.info(\"Should not import an address with a wrong public key\")\n         address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         address2 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n@@ -352,7 +352,7 @@ def run_test (self):\n \n \n         # ScriptPubKey + Public key + internal + Wrong pubkey\n-        print(\"Should not import a scriptPubKey with internal and with a wrong public key\")\n+        self.log.info(\"Should not import a scriptPubKey with internal and with a wrong public key\")\n         address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         address2 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         request = [{\n@@ -372,7 +372,7 @@ def run_test (self):\n \n \n         # Address + Private key + !watchonly + Wrong private key\n-        print(\"Should not import an address with a wrong private key\")\n+        self.log.info(\"Should not import an address with a wrong private key\")\n         address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         address2 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n@@ -392,7 +392,7 @@ def run_test (self):\n \n \n         # ScriptPubKey + Private key + internal + Wrong private key\n-        print(\"Should not import a scriptPubKey with internal and with a wrong private key\")\n+        self.log.info(\"Should not import a scriptPubKey with internal and with a wrong private key\")\n         address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         address2 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n@@ -418,7 +418,7 @@ def run_test (self):\n         assert_equal(address_assert['timestamp'], watchonly_timestamp);\n \n         # Bad or missing timestamps\n-        print(\"Should throw on invalid or missing timestamp values\")\n+        self.log.info(\"Should throw on invalid or missing timestamp values\")\n         assert_raises_message(JSONRPCException, 'Missing required timestamp field for key',\n             self.nodes[1].importmulti, [{\n                 \"scriptPubKey\": address['scriptPubKey'],"
      },
      {
        "sha": "b4c8ee6c702a835674b91236b98607e5f79ad334",
        "filename": "qa/rpc-tests/importprunedfunds.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/importprunedfunds.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/importprunedfunds.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/importprunedfunds.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -21,7 +21,7 @@ def setup_network(self, split=False):\n         self.sync_all()\n \n     def run_test(self):\n-        print(\"Mining blocks...\")\n+        self.log.info(\"Mining blocks...\")\n         self.nodes[0].generate(101)\n \n         self.sync_all()"
      },
      {
        "sha": "8c80b640035a127884700a5ec6fceb1fc307bfa7",
        "filename": "qa/rpc-tests/invalidateblock.py",
        "status": "modified",
        "additions": 13,
        "deletions": 15,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/invalidateblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/invalidateblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/invalidateblock.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -23,48 +23,46 @@ def setup_network(self):\n         self.nodes.append(start_node(2, self.options.tmpdir))\n         \n     def run_test(self):\n-        print(\"Make sure we repopulate setBlockIndexCandidates after InvalidateBlock:\")\n-        print(\"Mine 4 blocks on Node 0\")\n+        self.log.info(\"Make sure we repopulate setBlockIndexCandidates after InvalidateBlock:\")\n+        self.log.info(\"Mine 4 blocks on Node 0\")\n         self.nodes[0].generate(4)\n         assert(self.nodes[0].getblockcount() == 4)\n         besthash = self.nodes[0].getbestblockhash()\n \n-        print(\"Mine competing 6 blocks on Node 1\")\n+        self.log.info(\"Mine competing 6 blocks on Node 1\")\n         self.nodes[1].generate(6)\n         assert(self.nodes[1].getblockcount() == 6)\n \n-        print(\"Connect nodes to force a reorg\")\n+        self.log.info(\"Connect nodes to force a reorg\")\n         connect_nodes_bi(self.nodes,0,1)\n         sync_blocks(self.nodes[0:2])\n         assert(self.nodes[0].getblockcount() == 6)\n         badhash = self.nodes[1].getblockhash(2)\n \n-        print(\"Invalidate block 2 on node 0 and verify we reorg to node 0's original chain\")\n+        self.log.info(\"Invalidate block 2 on node 0 and verify we reorg to node 0's original chain\")\n         self.nodes[0].invalidateblock(badhash)\n         newheight = self.nodes[0].getblockcount()\n         newhash = self.nodes[0].getbestblockhash()\n         if (newheight != 4 or newhash != besthash):\n             raise AssertionError(\"Wrong tip for node0, hash %s, height %d\"%(newhash,newheight))\n \n-        print(\"\\nMake sure we won't reorg to a lower work chain:\")\n+        self.log.info(\"Make sure we won't reorg to a lower work chain:\")\n         connect_nodes_bi(self.nodes,1,2)\n-        print(\"Sync node 2 to node 1 so both have 6 blocks\")\n+        self.log.info(\"Sync node 2 to node 1 so both have 6 blocks\")\n         sync_blocks(self.nodes[1:3])\n         assert(self.nodes[2].getblockcount() == 6)\n-        print(\"Invalidate block 5 on node 1 so its tip is now at 4\")\n+        self.log.info(\"Invalidate block 5 on node 1 so its tip is now at 4\")\n         self.nodes[1].invalidateblock(self.nodes[1].getblockhash(5))\n         assert(self.nodes[1].getblockcount() == 4)\n-        print(\"Invalidate block 3 on node 2, so its tip is now 2\")\n+        self.log.info(\"Invalidate block 3 on node 2, so its tip is now 2\")\n         self.nodes[2].invalidateblock(self.nodes[2].getblockhash(3))\n         assert(self.nodes[2].getblockcount() == 2)\n-        print(\"..and then mine a block\")\n+        self.log.info(\"..and then mine a block\")\n         self.nodes[2].generate(1)\n-        print(\"Verify all nodes are at the right height\")\n+        self.log.info(\"Verify all nodes are at the right height\")\n         time.sleep(5)\n-        for i in range(3):\n-            print(i,self.nodes[i].getblockcount())\n-        assert(self.nodes[2].getblockcount() == 3)\n-        assert(self.nodes[0].getblockcount() == 4)\n+        assert_equal(self.nodes[2].getblockcount(), 3)\n+        assert_equal(self.nodes[0].getblockcount(), 4)\n         node1height = self.nodes[1].getblockcount()\n         if node1height < 4:\n             raise AssertionError(\"Node 1 reorged to a lower height: %d\"%node1height)"
      },
      {
        "sha": "a75e66c8c4f92dd808735a76995de5aa6ab7e089",
        "filename": "qa/rpc-tests/listsinceblock.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/listsinceblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/listsinceblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/listsinceblock.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -62,7 +62,7 @@ def run_test (self):\n         # generate on both sides\n         lastblockhash = self.nodes[1].generate(6)[5]\n         self.nodes[2].generate(7)\n-        print('lastblockhash=%s' % (lastblockhash))\n+        self.log.info('lastblockhash=%s' % (lastblockhash))\n \n         self.sync_all()\n "
      },
      {
        "sha": "564337d0604ef333ab8a52fa32aa9e93906549ef",
        "filename": "qa/rpc-tests/maxblocksinflight.py",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/maxblocksinflight.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/maxblocksinflight.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/maxblocksinflight.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -13,7 +13,6 @@\n from test_framework.mininode import *\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n-import logging\n \n MAX_REQUESTS = 128\n \n@@ -33,7 +32,6 @@ def on_close(self, conn):\n \n     def __init__(self):\n         NodeConnCB.__init__(self)\n-        self.log = logging.getLogger(\"BlockRelayTest\")\n \n     def add_new_connection(self, connection):\n         self.connection = connection\n@@ -65,7 +63,7 @@ def run(self):\n                         raise AssertionError(\"Error, test failed: block %064x requested more than once\" % key)\n             if total_requests > MAX_REQUESTS:\n                 raise AssertionError(\"Error, too many blocks (%d) requested\" % total_requests)\n-            print(\"Round %d: success (total requests: %d)\" % (count, total_requests))\n+            self.log.info(\"Round %d: success (total requests: %d)\" % (count, total_requests))\n \n         self.disconnectOkay = True\n         self.connection.disconnect_node()"
      },
      {
        "sha": "40cd85c9ec5b50d46010f1dc36de9ca9678dcdce",
        "filename": "qa/rpc-tests/maxuploadtarget.py",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/maxuploadtarget.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/maxuploadtarget.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/maxuploadtarget.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -161,7 +161,7 @@ def run_test(self):\n             test_nodes[0].send_message(getdata_request)\n         test_nodes[0].wait_for_disconnect()\n         assert_equal(len(self.nodes[0].getpeerinfo()), 2)\n-        print(\"Peer 0 disconnected after downloading old block too many times\")\n+        self.log.info(\"Peer 0 disconnected after downloading old block too many times\")\n \n         # Requesting the current block on test_nodes[1] should succeed indefinitely,\n         # even when over the max upload target.\n@@ -172,17 +172,17 @@ def run_test(self):\n             test_nodes[1].sync_with_ping()\n             assert_equal(test_nodes[1].block_receive_map[big_new_block], i+1)\n \n-        print(\"Peer 1 able to repeatedly download new block\")\n+        self.log.info(\"Peer 1 able to repeatedly download new block\")\n \n         # But if test_nodes[1] tries for an old block, it gets disconnected too.\n         getdata_request.inv = [CInv(2, big_old_block)]\n         test_nodes[1].send_message(getdata_request)\n         test_nodes[1].wait_for_disconnect()\n         assert_equal(len(self.nodes[0].getpeerinfo()), 1)\n \n-        print(\"Peer 1 disconnected after trying to download old block\")\n+        self.log.info(\"Peer 1 disconnected after trying to download old block\")\n \n-        print(\"Advancing system time on node to clear counters...\")\n+        self.log.info(\"Advancing system time on node to clear counters...\")\n \n         # If we advance the time by 24 hours, then the counters should reset,\n         # and test_nodes[2] should be able to retrieve the old block.\n@@ -192,12 +192,12 @@ def run_test(self):\n         test_nodes[2].sync_with_ping()\n         assert_equal(test_nodes[2].block_receive_map[big_old_block], 1)\n \n-        print(\"Peer 2 able to download old block\")\n+        self.log.info(\"Peer 2 able to download old block\")\n \n         [c.disconnect_node() for c in connections]\n \n         #stop and start node 0 with 1MB maxuploadtarget, whitelist 127.0.0.1\n-        print(\"Restarting nodes with -whitelist=127.0.0.1\")\n+        self.log.info(\"Restarting nodes with -whitelist=127.0.0.1\")\n         stop_node(self.nodes[0], 0)\n         self.nodes[0] = start_node(0, self.options.tmpdir, [\"-whitelist=127.0.0.1\", \"-maxuploadtarget=1\", \"-blockmaxsize=999000\"])\n \n@@ -225,7 +225,7 @@ def run_test(self):\n         test_nodes[1].wait_for_disconnect()\n         assert_equal(len(self.nodes[0].getpeerinfo()), 3) #node is still connected because of the whitelist\n \n-        print(\"Peer 1 still connected after trying to download old block (whitelisted)\")\n+        self.log.info(\"Peer 1 still connected after trying to download old block (whitelisted)\")\n \n         [c.disconnect_node() for c in connections]\n "
      },
      {
        "sha": "915d17405278c5e55097b9733fea9092ff2b1518",
        "filename": "qa/rpc-tests/mempool_packages.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/mempool_packages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/mempool_packages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/mempool_packages.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -115,7 +115,7 @@ def run_test(self):\n         try:\n             self.chain_transaction(self.nodes[0], txid, vout, value, fee, 1)\n         except JSONRPCException as e:\n-            print(\"too-long-ancestor-chain successfully rejected\")\n+            self.log.info(\"too-long-ancestor-chain successfully rejected\")\n \n         # Check that prioritising a tx before it's added to the mempool works\n         # First clear the mempool by mining a block.\n@@ -165,9 +165,9 @@ def run_test(self):\n                     mempool = self.nodes[0].getrawmempool(True)\n                     assert_equal(mempool[parent_transaction]['descendantcount'], MAX_DESCENDANTS)\n             except JSONRPCException as e:\n-                print(e.error['message'])\n+                self.log.info(e.error['message'])\n                 assert_equal(i, MAX_DESCENDANTS - 1)\n-                print(\"tx that would create too large descendant package successfully rejected\")\n+                self.log.info(\"tx that would create too large descendant package successfully rejected\")\n \n         # TODO: check that node1's mempool is as expected\n "
      },
      {
        "sha": "5963f2e7b618bf5998dc291c6cda8a8e6de30d27",
        "filename": "qa/rpc-tests/merkle_blocks.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/merkle_blocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/merkle_blocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/merkle_blocks.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -30,7 +30,7 @@ def setup_network(self):\n         self.sync_all()\n \n     def run_test(self):\n-        print(\"Mining blocks...\")\n+        self.log.info(\"Mining blocks...\")\n         self.nodes[0].generate(105)\n         self.sync_all()\n "
      },
      {
        "sha": "4b215a70b0f4efb4f67fc5984d09998c0233b45c",
        "filename": "qa/rpc-tests/nulldummy.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/nulldummy.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/nulldummy.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/nulldummy.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -64,7 +64,7 @@ def run_test(self):\n         self.lastblockheight = 429\n         self.lastblocktime = int(time.time()) + 429\n \n-        print (\"Test 1: NULLDUMMY compliant base transactions should be accepted to mempool and mined before activation [430]\")\n+        self.log.info(\"Test 1: NULLDUMMY compliant base transactions should be accepted to mempool and mined before activation [430]\")\n         test1txs = [self.create_transaction(self.nodes[0], coinbase_txid[0], self.ms_address, 49)]\n         txid1 = self.tx_submit(self.nodes[0], test1txs[0])\n         test1txs.append(self.create_transaction(self.nodes[0], txid1, self.ms_address, 48))\n@@ -73,29 +73,29 @@ def run_test(self):\n         txid3 = self.tx_submit(self.nodes[0], test1txs[2])\n         self.block_submit(self.nodes[0], test1txs, False, True)\n \n-        print (\"Test 2: Non-NULLDUMMY base multisig transaction should not be accepted to mempool before activation\")\n+        self.log.info(\"Test 2: Non-NULLDUMMY base multisig transaction should not be accepted to mempool before activation\")\n         test2tx = self.create_transaction(self.nodes[0], txid2, self.ms_address, 47)\n         trueDummy(test2tx)\n         txid4 = self.tx_submit(self.nodes[0], test2tx, NULLDUMMY_ERROR)\n \n-        print (\"Test 3: Non-NULLDUMMY base transactions should be accepted in a block before activation [431]\")\n+        self.log.info(\"Test 3: Non-NULLDUMMY base transactions should be accepted in a block before activation [431]\")\n         self.block_submit(self.nodes[0], [test2tx], False, True)\n \n-        print (\"Test 4: Non-NULLDUMMY base multisig transaction is invalid after activation\")\n+        self.log.info(\"Test 4: Non-NULLDUMMY base multisig transaction is invalid after activation\")\n         test4tx = self.create_transaction(self.nodes[0], txid4, self.address, 46)\n         test6txs=[CTransaction(test4tx)]\n         trueDummy(test4tx)\n         self.tx_submit(self.nodes[0], test4tx, NULLDUMMY_ERROR)\n         self.block_submit(self.nodes[0], [test4tx])\n \n-        print (\"Test 5: Non-NULLDUMMY P2WSH multisig transaction invalid after activation\")\n+        self.log.info(\"Test 5: Non-NULLDUMMY P2WSH multisig transaction invalid after activation\")\n         test5tx = self.create_transaction(self.nodes[0], txid3, self.wit_address, 48)\n         test6txs.append(CTransaction(test5tx))\n         test5tx.wit.vtxinwit[0].scriptWitness.stack[0] = b'\\x01'\n         self.tx_submit(self.nodes[0], test5tx, NULLDUMMY_ERROR)\n         self.block_submit(self.nodes[0], [test5tx], True)\n \n-        print (\"Test 6: NULLDUMMY compliant base/witness transactions should be accepted to mempool and in block after activation [432]\")\n+        self.log.info(\"Test 6: NULLDUMMY compliant base/witness transactions should be accepted to mempool and in block after activation [432]\")\n         for i in test6txs:\n             self.tx_submit(self.nodes[0], i)\n         self.block_submit(self.nodes[0], test6txs, True, True)"
      },
      {
        "sha": "e1111da4ae2b34b7d1eeb9a066f7377e064152cf",
        "filename": "qa/rpc-tests/p2p-acceptblock.py",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/p2p-acceptblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/p2p-acceptblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-acceptblock.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -160,7 +160,7 @@ def run_test(self):\n         [ x.sync_with_ping() for x in [test_node, white_node] ]\n         assert_equal(self.nodes[0].getblockcount(), 2)\n         assert_equal(self.nodes[1].getblockcount(), 2)\n-        print(\"First height 2 block accepted by both nodes\")\n+        self.log.info(\"First height 2 block accepted by both nodes\")\n \n         # 3. Send another block that builds on the original tip.\n         blocks_h2f = []  # Blocks at height 2 that fork off the main chain\n@@ -179,7 +179,7 @@ def run_test(self):\n             if x['hash'] == blocks_h2f[1].hash:\n                 assert_equal(x['status'], \"valid-headers\")\n \n-        print(\"Second height 2 block accepted only from whitelisted peer\")\n+        self.log.info(\"Second height 2 block accepted only from whitelisted peer\")\n \n         # 4. Now send another block that builds on the forking chain.\n         blocks_h3 = []\n@@ -198,11 +198,11 @@ def run_test(self):\n \n         # But this block should be accepted by node0 since it has more work.\n         self.nodes[0].getblock(blocks_h3[0].hash)\n-        print(\"Unrequested more-work block accepted from non-whitelisted peer\")\n+        self.log.info(\"Unrequested more-work block accepted from non-whitelisted peer\")\n \n         # Node1 should have accepted and reorged.\n         assert_equal(self.nodes[1].getblockcount(), 3)\n-        print(\"Successfully reorged to length 3 chain from whitelisted peer\")\n+        self.log.info(\"Successfully reorged to length 3 chain from whitelisted peer\")\n \n         # 4b. Now mine 288 more blocks and deliver; all should be processed but\n         # the last (height-too-high) on node0.  Node1 should process the tip if\n@@ -232,7 +232,7 @@ def run_test(self):\n         white_node.send_message(msg_block(tips[1]))  # Now deliver the tip\n         white_node.sync_with_ping()\n         self.nodes[1].getblock(tips[1].hash)\n-        print(\"Unrequested block far ahead of tip accepted from whitelisted peer\")\n+        self.log.info(\"Unrequested block far ahead of tip accepted from whitelisted peer\")\n \n         # 5. Test handling of unrequested block on the node that didn't process\n         # Should still not be processed (even though it has a child that has more\n@@ -246,7 +246,7 @@ def run_test(self):\n         # a getdata request for this block.\n         test_node.sync_with_ping()\n         assert_equal(self.nodes[0].getblockcount(), 2)\n-        print(\"Unrequested block that would complete more-work chain was ignored\")\n+        self.log.info(\"Unrequested block that would complete more-work chain was ignored\")\n \n         # 6. Try to get node to request the missing block.\n         # Poke the node with an inv for block at height 3 and see if that\n@@ -262,14 +262,14 @@ def run_test(self):\n \n         # Check that the getdata includes the right block\n         assert_equal(getdata.inv[0].hash, blocks_h2f[0].sha256)\n-        print(\"Inv at tip triggered getdata for unprocessed block\")\n+        self.log.info(\"Inv at tip triggered getdata for unprocessed block\")\n \n         # 7. Send the missing block for the third time (now it is requested)\n         test_node.send_message(msg_block(blocks_h2f[0]))\n \n         test_node.sync_with_ping()\n         assert_equal(self.nodes[0].getblockcount(), 290)\n-        print(\"Successfully reorged to longer chain from non-whitelisted peer\")\n+        self.log.info(\"Successfully reorged to longer chain from non-whitelisted peer\")\n \n         [ c.disconnect_node() for c in connections ]\n "
      },
      {
        "sha": "1fc0312c34742ef4b78123c778d5a09ac496e306",
        "filename": "qa/rpc-tests/p2p-compactblocks.py",
        "status": "modified",
        "additions": 23,
        "deletions": 23,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/p2p-compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/p2p-compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-compactblocks.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -846,121 +846,121 @@ def run_test(self):\n         # We will need UTXOs to construct transactions in later tests.\n         self.make_utxos()\n \n-        print(\"Running tests, pre-segwit activation:\")\n+        self.log.info(\"Running tests, pre-segwit activation:\")\n \n-        print(\"\\tTesting SENDCMPCT p2p message... \")\n+        self.log.info(\"Testing SENDCMPCT p2p message... \")\n         self.test_sendcmpct(self.nodes[0], self.test_node, 1)\n         sync_blocks(self.nodes)\n         self.test_sendcmpct(self.nodes[1], self.segwit_node, 2, old_node=self.old_node)\n         sync_blocks(self.nodes)\n \n-        print(\"\\tTesting compactblock construction...\")\n+        self.log.info(\"Testing compactblock construction...\")\n         self.test_compactblock_construction(self.nodes[0], self.test_node, 1, False)\n         sync_blocks(self.nodes)\n         self.test_compactblock_construction(self.nodes[1], self.segwit_node, 2, False)\n         sync_blocks(self.nodes)\n \n-        print(\"\\tTesting compactblock requests... \")\n+        self.log.info(\"Testing compactblock requests... \")\n         self.test_compactblock_requests(self.nodes[0], self.test_node, 1, False)\n         sync_blocks(self.nodes)\n         self.test_compactblock_requests(self.nodes[1], self.segwit_node, 2, False)\n         sync_blocks(self.nodes)\n \n-        print(\"\\tTesting getblocktxn requests...\")\n+        self.log.info(\"Testing getblocktxn requests...\")\n         self.test_getblocktxn_requests(self.nodes[0], self.test_node, 1)\n         sync_blocks(self.nodes)\n         self.test_getblocktxn_requests(self.nodes[1], self.segwit_node, 2)\n         sync_blocks(self.nodes)\n \n-        print(\"\\tTesting getblocktxn handler...\")\n+        self.log.info(\"Testing getblocktxn handler...\")\n         self.test_getblocktxn_handler(self.nodes[0], self.test_node, 1)\n         sync_blocks(self.nodes)\n         self.test_getblocktxn_handler(self.nodes[1], self.segwit_node, 2)\n         self.test_getblocktxn_handler(self.nodes[1], self.old_node, 1)\n         sync_blocks(self.nodes)\n \n-        print(\"\\tTesting compactblock requests/announcements not at chain tip...\")\n+        self.log.info(\"Testing compactblock requests/announcements not at chain tip...\")\n         self.test_compactblocks_not_at_tip(self.nodes[0], self.test_node)\n         sync_blocks(self.nodes)\n         self.test_compactblocks_not_at_tip(self.nodes[1], self.segwit_node)\n         self.test_compactblocks_not_at_tip(self.nodes[1], self.old_node)\n         sync_blocks(self.nodes)\n \n-        print(\"\\tTesting handling of incorrect blocktxn responses...\")\n+        self.log.info(\"Testing handling of incorrect blocktxn responses...\")\n         self.test_incorrect_blocktxn_response(self.nodes[0], self.test_node, 1)\n         sync_blocks(self.nodes)\n         self.test_incorrect_blocktxn_response(self.nodes[1], self.segwit_node, 2)\n         sync_blocks(self.nodes)\n \n         # End-to-end block relay tests\n-        print(\"\\tTesting end-to-end block relay...\")\n+        self.log.info(\"Testing end-to-end block relay...\")\n         self.request_cb_announcements(self.test_node, self.nodes[0], 1)\n         self.request_cb_announcements(self.old_node, self.nodes[1], 1)\n         self.request_cb_announcements(self.segwit_node, self.nodes[1], 2)\n         self.test_end_to_end_block_relay(self.nodes[0], [self.segwit_node, self.test_node, self.old_node])\n         self.test_end_to_end_block_relay(self.nodes[1], [self.segwit_node, self.test_node, self.old_node])\n \n-        print(\"\\tTesting handling of invalid compact blocks...\")\n+        self.log.info(\"Testing handling of invalid compact blocks...\")\n         self.test_invalid_tx_in_compactblock(self.nodes[0], self.test_node, False)\n         self.test_invalid_tx_in_compactblock(self.nodes[1], self.segwit_node, False)\n         self.test_invalid_tx_in_compactblock(self.nodes[1], self.old_node, False)\n \n-        print(\"\\tTesting reconstructing compact blocks from all peers...\")\n+        self.log.info(\"Testing reconstructing compact blocks from all peers...\")\n         self.test_compactblock_reconstruction_multiple_peers(self.nodes[1], self.segwit_node, self.old_node)\n         sync_blocks(self.nodes)\n \n         # Advance to segwit activation\n-        print (\"\\nAdvancing to segwit activation\\n\")\n+        self.log.info(\"Advancing to segwit activation\")\n         self.activate_segwit(self.nodes[1])\n-        print (\"Running tests, post-segwit activation...\")\n+        self.log.info(\"Running tests, post-segwit activation...\")\n \n-        print(\"\\tTesting compactblock construction...\")\n+        self.log.info(\"Testing compactblock construction...\")\n         self.test_compactblock_construction(self.nodes[1], self.old_node, 1, True)\n         self.test_compactblock_construction(self.nodes[1], self.segwit_node, 2, True)\n         sync_blocks(self.nodes)\n \n-        print(\"\\tTesting compactblock requests (unupgraded node)... \")\n+        self.log.info(\"Testing compactblock requests (unupgraded node)... \")\n         self.test_compactblock_requests(self.nodes[0], self.test_node, 1, True)\n \n-        print(\"\\tTesting getblocktxn requests (unupgraded node)...\")\n+        self.log.info(\"Testing getblocktxn requests (unupgraded node)...\")\n         self.test_getblocktxn_requests(self.nodes[0], self.test_node, 1)\n \n         # Need to manually sync node0 and node1, because post-segwit activation,\n         # node1 will not download blocks from node0.\n-        print(\"\\tSyncing nodes...\")\n+        self.log.info(\"Syncing nodes...\")\n         assert(self.nodes[0].getbestblockhash() != self.nodes[1].getbestblockhash())\n         while (self.nodes[0].getblockcount() > self.nodes[1].getblockcount()):\n             block_hash = self.nodes[0].getblockhash(self.nodes[1].getblockcount()+1)\n             self.nodes[1].submitblock(self.nodes[0].getblock(block_hash, False))\n         assert_equal(self.nodes[0].getbestblockhash(), self.nodes[1].getbestblockhash())\n \n-        print(\"\\tTesting compactblock requests (segwit node)... \")\n+        self.log.info(\"Testing compactblock requests (segwit node)... \")\n         self.test_compactblock_requests(self.nodes[1], self.segwit_node, 2, True)\n \n-        print(\"\\tTesting getblocktxn requests (segwit node)...\")\n+        self.log.info(\"Testing getblocktxn requests (segwit node)...\")\n         self.test_getblocktxn_requests(self.nodes[1], self.segwit_node, 2)\n         sync_blocks(self.nodes)\n \n-        print(\"\\tTesting getblocktxn handler (segwit node should return witnesses)...\")\n+        self.log.info(\"Testing getblocktxn handler (segwit node should return witnesses)...\")\n         self.test_getblocktxn_handler(self.nodes[1], self.segwit_node, 2)\n         self.test_getblocktxn_handler(self.nodes[1], self.old_node, 1)\n \n         # Test that if we submitblock to node1, we'll get a compact block\n         # announcement to all peers.\n         # (Post-segwit activation, blocks won't propagate from node0 to node1\n         # automatically, so don't bother testing a block announced to node0.)\n-        print(\"\\tTesting end-to-end block relay...\")\n+        self.log.info(\"Testing end-to-end block relay...\")\n         self.request_cb_announcements(self.test_node, self.nodes[0], 1)\n         self.request_cb_announcements(self.old_node, self.nodes[1], 1)\n         self.request_cb_announcements(self.segwit_node, self.nodes[1], 2)\n         self.test_end_to_end_block_relay(self.nodes[1], [self.segwit_node, self.test_node, self.old_node])\n \n-        print(\"\\tTesting handling of invalid compact blocks...\")\n+        self.log.info(\"Testing handling of invalid compact blocks...\")\n         self.test_invalid_tx_in_compactblock(self.nodes[0], self.test_node, False)\n         self.test_invalid_tx_in_compactblock(self.nodes[1], self.segwit_node, True)\n         self.test_invalid_tx_in_compactblock(self.nodes[1], self.old_node, True)\n \n-        print(\"\\tTesting invalid index in cmpctblock message...\")\n+        self.log.info(\"Testing invalid index in cmpctblock message...\")\n         self.test_invalid_cmpctblock_message()\n \n "
      },
      {
        "sha": "3a843197fbac5c26ec7fd7c359d5eb9e0b3ba1ee",
        "filename": "qa/rpc-tests/p2p-leaktests.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/p2p-leaktests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/p2p-leaktests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-leaktests.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -32,7 +32,7 @@ def send_message(self, message):\n \n     def bad_message(self, message):\n         self.unexpected_msg = True\n-        print(\"should not have received message: %s\" % message.command)\n+        self.log.info(\"should not have received message: %s\" % message.command)\n \n     def on_open(self, conn):\n         self.connected = True"
      },
      {
        "sha": "0f844883b1a769c6db6c6fbb7e9f4ed6f168094c",
        "filename": "qa/rpc-tests/p2p-segwit.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/p2p-segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/p2p-segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-segwit.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -1427,7 +1427,7 @@ def test_signature_version_1(self):\n                 block = self.build_next_block()\n \n         if (not used_sighash_single_out_of_bounds):\n-            print(\"WARNING: this test run didn't attempt SIGHASH_SINGLE with out-of-bounds index value\")\n+            self.log.info(\"WARNING: this test run didn't attempt SIGHASH_SINGLE with out-of-bounds index value\")\n         # Test the transactions we've added to the block\n         if (len(block.vtx) > 1):\n             self.update_witness_block_with_transactions(block, [])"
      },
      {
        "sha": "30b0b5a3012f6ba9fb5a1d62a35f8abc2d987139",
        "filename": "qa/rpc-tests/preciousblock.py",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/preciousblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/preciousblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/preciousblock.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -44,70 +44,70 @@ def setup_network(self):\n         self.nodes = self.setup_nodes()\n \n     def run_test(self):\n-        print(\"Ensure submitblock can in principle reorg to a competing chain\")\n+        self.log.info(\"Ensure submitblock can in principle reorg to a competing chain\")\n         self.nodes[0].generate(1)\n         assert_equal(self.nodes[0].getblockcount(), 1)\n         (hashY, hashZ) = self.nodes[1].generate(2)\n         assert_equal(self.nodes[1].getblockcount(), 2)\n         node_sync_via_rpc(self.nodes[0:3])\n         assert_equal(self.nodes[0].getbestblockhash(), hashZ)\n \n-        print(\"Mine blocks A-B-C on Node 0\")\n+        self.log.info(\"Mine blocks A-B-C on Node 0\")\n         (hashA, hashB, hashC) = self.nodes[0].generate(3)\n         assert_equal(self.nodes[0].getblockcount(), 5)\n-        print(\"Mine competing blocks E-F-G on Node 1\")\n+        self.log.info(\"Mine competing blocks E-F-G on Node 1\")\n         (hashE, hashF, hashG) = self.nodes[1].generate(3)\n         assert_equal(self.nodes[1].getblockcount(), 5)\n         assert(hashC != hashG)\n-        print(\"Connect nodes and check no reorg occurs\")\n+        self.log.info(\"Connect nodes and check no reorg occurs\")\n         # Submit competing blocks via RPC so any reorg should occur before we proceed (no way to wait on inaction for p2p sync)\n         node_sync_via_rpc(self.nodes[0:2])\n         connect_nodes_bi(self.nodes,0,1)\n         assert_equal(self.nodes[0].getbestblockhash(), hashC)\n         assert_equal(self.nodes[1].getbestblockhash(), hashG)\n-        print(\"Make Node0 prefer block G\")\n+        self.log.info(\"Make Node0 prefer block G\")\n         self.nodes[0].preciousblock(hashG)\n         assert_equal(self.nodes[0].getbestblockhash(), hashG)\n-        print(\"Make Node0 prefer block C again\")\n+        self.log.info(\"Make Node0 prefer block C again\")\n         self.nodes[0].preciousblock(hashC)\n         assert_equal(self.nodes[0].getbestblockhash(), hashC)\n-        print(\"Make Node1 prefer block C\")\n+        self.log.info(\"Make Node1 prefer block C\")\n         self.nodes[1].preciousblock(hashC)\n         sync_chain(self.nodes[0:2]) # wait because node 1 may not have downloaded hashC\n         assert_equal(self.nodes[1].getbestblockhash(), hashC)\n-        print(\"Make Node1 prefer block G again\")\n+        self.log.info(\"Make Node1 prefer block G again\")\n         self.nodes[1].preciousblock(hashG)\n         assert_equal(self.nodes[1].getbestblockhash(), hashG)\n-        print(\"Make Node0 prefer block G again\")\n+        self.log.info(\"Make Node0 prefer block G again\")\n         self.nodes[0].preciousblock(hashG)\n         assert_equal(self.nodes[0].getbestblockhash(), hashG)\n-        print(\"Make Node1 prefer block C again\")\n+        self.log.info(\"Make Node1 prefer block C again\")\n         self.nodes[1].preciousblock(hashC)\n         assert_equal(self.nodes[1].getbestblockhash(), hashC)\n-        print(\"Mine another block (E-F-G-)H on Node 0 and reorg Node 1\")\n+        self.log.info(\"Mine another block (E-F-G-)H on Node 0 and reorg Node 1\")\n         self.nodes[0].generate(1)\n         assert_equal(self.nodes[0].getblockcount(), 6)\n         sync_blocks(self.nodes[0:2])\n         hashH = self.nodes[0].getbestblockhash()\n         assert_equal(self.nodes[1].getbestblockhash(), hashH)\n-        print(\"Node1 should not be able to prefer block C anymore\")\n+        self.log.info(\"Node1 should not be able to prefer block C anymore\")\n         self.nodes[1].preciousblock(hashC)\n         assert_equal(self.nodes[1].getbestblockhash(), hashH)\n-        print(\"Mine competing blocks I-J-K-L on Node 2\")\n+        self.log.info(\"Mine competing blocks I-J-K-L on Node 2\")\n         self.nodes[2].generate(4)\n         assert_equal(self.nodes[2].getblockcount(), 6)\n         hashL = self.nodes[2].getbestblockhash()\n-        print(\"Connect nodes and check no reorg occurs\")\n+        self.log.info(\"Connect nodes and check no reorg occurs\")\n         node_sync_via_rpc(self.nodes[1:3])\n         connect_nodes_bi(self.nodes,1,2)\n         connect_nodes_bi(self.nodes,0,2)\n         assert_equal(self.nodes[0].getbestblockhash(), hashH)\n         assert_equal(self.nodes[1].getbestblockhash(), hashH)\n         assert_equal(self.nodes[2].getbestblockhash(), hashL)\n-        print(\"Make Node1 prefer block L\")\n+        self.log.info(\"Make Node1 prefer block L\")\n         self.nodes[1].preciousblock(hashL)\n         assert_equal(self.nodes[1].getbestblockhash(), hashL)\n-        print(\"Make Node2 prefer block H\")\n+        self.log.info(\"Make Node2 prefer block H\")\n         self.nodes[2].preciousblock(hashH)\n         assert_equal(self.nodes[2].getbestblockhash(), hashH)\n "
      },
      {
        "sha": "10f596b2cb4cd92826cc50443e0cc3981ee73a31",
        "filename": "qa/rpc-tests/prioritise_transaction.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/prioritise_transaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/prioritise_transaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/prioritise_transaction.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -56,7 +56,7 @@ def run_test(self):\n         self.nodes[0].generate(1)\n \n         mempool = self.nodes[0].getrawmempool()\n-        print(\"Assert that prioritised transaction was mined\")\n+        self.log.info(\"Assert that prioritised transaction was mined\")\n         assert(txids[0][0] not in mempool)\n         assert(txids[0][1] in mempool)\n \n@@ -88,7 +88,7 @@ def run_test(self):\n         # High fee transaction should not have been mined, but other high fee rate\n         # transactions should have been.\n         mempool = self.nodes[0].getrawmempool()\n-        print(\"Assert that de-prioritised transaction is still in mempool\")\n+        self.log.info(\"Assert that de-prioritised transaction is still in mempool\")\n         assert(high_fee_tx in mempool)\n         for x in txids[2]:\n             if (x != high_fee_tx):\n@@ -120,7 +120,7 @@ def run_test(self):\n         # accepted.\n         self.nodes[0].prioritisetransaction(tx_id, int(self.relayfee*COIN))\n \n-        print(\"Assert that prioritised free transaction is accepted to mempool\")\n+        self.log.info(\"Assert that prioritised free transaction is accepted to mempool\")\n         assert_equal(self.nodes[0].sendrawtransaction(tx_hex), tx_id)\n         assert(tx_id in self.nodes[0].getrawmempool())\n "
      },
      {
        "sha": "c6a82b5feaa74e8fc1ff31ceefdd91004baba76f",
        "filename": "qa/rpc-tests/pruning.py",
        "status": "modified",
        "additions": 34,
        "deletions": 34,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/pruning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/pruning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/pruning.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -79,9 +79,9 @@ def create_big_chain(self):\n     def test_height_min(self):\n         if not os.path.isfile(self.prunedir+\"blk00000.dat\"):\n             raise AssertionError(\"blk00000.dat is missing, pruning too early\")\n-        print(\"Success\")\n-        print(\"Though we're already using more than 550MiB, current usage:\", calc_usage(self.prunedir))\n-        print(\"Mining 25 more blocks should cause the first block file to be pruned\")\n+        self.log.info(\"Success\")\n+        self.log.info(\"Though we're already using more than 550MiB, current usage:\", calc_usage(self.prunedir))\n+        self.log.info(\"Mining 25 more blocks should cause the first block file to be pruned\")\n         # Pruning doesn't run until we're allocating another chunk, 20 full blocks past the height cutoff will ensure this\n         for i in range(25):\n             mine_large_block(self.nodes[0], self.utxo_cache_0)\n@@ -92,15 +92,15 @@ def test_height_min(self):\n             if time.time() - waitstart > 30:\n                 raise AssertionError(\"blk00000.dat not pruned when it should be\")\n \n-        print(\"Success\")\n+        self.log.info(\"Success\")\n         usage = calc_usage(self.prunedir)\n-        print(\"Usage should be below target:\", usage)\n+        self.log.info(\"Usage should be below target:\", usage)\n         if (usage > 550):\n             raise AssertionError(\"Pruning target not being met\")\n \n     def create_chain_with_staleblocks(self):\n         # Create stale blocks in manageable sized chunks\n-        print(\"Mine 24 (stale) blocks on Node 1, followed by 25 (main chain) block reorg from Node 0, for 12 rounds\")\n+        self.log.info(\"Mine 24 (stale) blocks on Node 1, followed by 25 (main chain) block reorg from Node 0, for 12 rounds\")\n \n         for j in range(12):\n             # Disconnect node 0 so it can mine a longer reorg chain without knowing about node 1's soon-to-be-stale chain\n@@ -124,7 +124,7 @@ def create_chain_with_staleblocks(self):\n             connect_nodes(self.nodes[2], 0)\n             sync_blocks(self.nodes[0:3])\n \n-        print(\"Usage can be over target because of high stale rate:\", calc_usage(self.prunedir))\n+        self.log.info(\"Usage can be over target because of high stale rate:\", calc_usage(self.prunedir))\n \n     def reorg_test(self):\n         # Node 1 will mine a 300 block chain starting 287 blocks back from Node 0 and Node 2's tip\n@@ -135,11 +135,11 @@ def reorg_test(self):\n         self.nodes[1]=start_node(1, self.options.tmpdir, [\"-maxreceivebuffer=20000\",\"-blockmaxsize=5000\", \"-checkblocks=5\", \"-disablesafemode\"], timewait=900)\n \n         height = self.nodes[1].getblockcount()\n-        print(\"Current block height:\", height)\n+        self.log.info(\"Current block height:\", height)\n \n         invalidheight = height-287\n         badhash = self.nodes[1].getblockhash(invalidheight)\n-        print(\"Invalidating block at height:\",invalidheight,badhash)\n+        self.log.info(\"Invalidating block at height:\",invalidheight,badhash)\n         self.nodes[1].invalidateblock(badhash)\n \n         # We've now switched to our previously mined-24 block fork on node 1, but thats not what we want\n@@ -151,32 +151,32 @@ def reorg_test(self):\n             curhash = self.nodes[1].getblockhash(invalidheight - 1)\n \n         assert(self.nodes[1].getblockcount() == invalidheight - 1)\n-        print(\"New best height\", self.nodes[1].getblockcount())\n+        self.log.info(\"New best height\", self.nodes[1].getblockcount())\n \n         # Reboot node1 to clear those giant tx's from mempool\n         self.stop_node(1)\n         self.nodes[1]=start_node(1, self.options.tmpdir, [\"-maxreceivebuffer=20000\",\"-blockmaxsize=5000\", \"-checkblocks=5\", \"-disablesafemode\"], timewait=900)\n \n-        print(\"Generating new longer chain of 300 more blocks\")\n+        self.log.info(\"Generating new longer chain of 300 more blocks\")\n         self.nodes[1].generate(300)\n \n-        print(\"Reconnect nodes\")\n+        self.log.info(\"Reconnect nodes\")\n         connect_nodes(self.nodes[0], 1)\n         connect_nodes(self.nodes[2], 1)\n         sync_blocks(self.nodes[0:3], timeout=120)\n \n-        print(\"Verify height on node 2:\",self.nodes[2].getblockcount())\n-        print(\"Usage possibly still high bc of stale blocks in block files:\", calc_usage(self.prunedir))\n+        self.log.info(\"Verify height on node 2:\",self.nodes[2].getblockcount())\n+        self.log.info(\"Usage possibly still high bc of stale blocks in block files:\", calc_usage(self.prunedir))\n \n-        print(\"Mine 220 more blocks so we have requisite history (some blocks will be big and cause pruning of previous chain)\")\n+        self.log.info(\"Mine 220 more blocks so we have requisite history (some blocks will be big and cause pruning of previous chain)\")\n         for i in range(22):\n             # This can be slow, so do this in multiple RPC calls to avoid\n             # RPC timeouts.\n             self.nodes[0].generate(10) #node 0 has many large tx's in its mempool from the disconnects\n         sync_blocks(self.nodes[0:3], timeout=300)\n \n         usage = calc_usage(self.prunedir)\n-        print(\"Usage should be below target:\", usage)\n+        self.log.info(\"Usage should be below target:\", usage)\n         if (usage > 550):\n             raise AssertionError(\"Pruning target not being met\")\n \n@@ -185,7 +185,7 @@ def reorg_test(self):\n     def reorg_back(self):\n         # Verify that a block on the old main chain fork has been pruned away\n         assert_raises_jsonrpc(-1, \"Block not available (pruned data)\", self.nodes[2].getblock, self.forkhash)\n-        print(\"Will need to redownload block\",self.forkheight)\n+        self.log.info(\"Will need to redownload block\",self.forkheight)\n \n         # Verify that we have enough history to reorg back to the fork point\n         # Although this is more than 288 blocks, because this chain was written more recently\n@@ -209,14 +209,14 @@ def reorg_back(self):\n         # At this point node 2 is within 288 blocks of the fork point so it will preserve its ability to reorg\n         if self.nodes[2].getblockcount() < self.mainchainheight:\n             blocks_to_mine = first_reorg_height + 1 - self.mainchainheight\n-            print(\"Rewind node 0 to prev main chain to mine longer chain to trigger redownload. Blocks needed:\", blocks_to_mine)\n+            self.log.info(\"Rewind node 0 to prev main chain to mine longer chain to trigger redownload. Blocks needed:\", blocks_to_mine)\n             self.nodes[0].invalidateblock(curchainhash)\n             assert(self.nodes[0].getblockcount() == self.mainchainheight)\n             assert(self.nodes[0].getbestblockhash() == self.mainchainhash2)\n             goalbesthash = self.nodes[0].generate(blocks_to_mine)[-1]\n             goalbestheight = first_reorg_height + 1\n \n-        print(\"Verify node 2 reorged back to the main chain, some blocks of which it had to redownload\")\n+        self.log.info(\"Verify node 2 reorged back to the main chain, some blocks of which it had to redownload\")\n         waitstart = time.time()\n         while self.nodes[2].getblockcount() < goalbestheight:\n             time.sleep(0.1)\n@@ -310,28 +310,28 @@ def has_block(index):\n         self.stop_node(node_number)\n         self.nodes[node_number] = start_node(node_number, self.options.tmpdir, [\"-prune=550\"], timewait=900)\n \n-        print(\"Success\")\n+        self.log.info(\"Success\")\n \n     def wallet_test(self):\n         # check that the pruning node's wallet is still in good shape\n-        print(\"Stop and start pruning node to trigger wallet rescan\")\n+        self.log.info(\"Stop and start pruning node to trigger wallet rescan\")\n         self.stop_node(2)\n         start_node(2, self.options.tmpdir, [\"-prune=550\"])\n-        print(\"Success\")\n+        self.log.info(\"Success\")\n \n         # check that wallet loads loads successfully when restarting a pruned node after IBD.\n         # this was reported to fail in #7494.\n-        print (\"Syncing node 5 to test wallet\")\n+        self.log.info(\"Syncing node 5 to test wallet\")\n         connect_nodes(self.nodes[0], 5)\n         nds = [self.nodes[0], self.nodes[5]]\n         sync_blocks(nds, wait=5, timeout=300)\n         self.stop_node(5) #stop and start to trigger rescan\n         start_node(5, self.options.tmpdir, [\"-prune=550\"])\n-        print (\"Success\")\n+        self.log.info(\"Success\")\n \n     def run_test(self):\n-        print(\"Warning! This test requires 4GB of disk space and takes over 30 mins (up to 2 hours)\")\n-        print(\"Mining a big blockchain of 995 blocks\")\n+        self.log.info(\"Warning! This test requires 4GB of disk space and takes over 30 mins (up to 2 hours)\")\n+        self.log.info(\"Mining a big blockchain of 995 blocks\")\n         self.create_big_chain()\n         # Chain diagram key:\n         # *   blocks on main chain\n@@ -346,12 +346,12 @@ def run_test(self):\n         self.stop_node(3)\n         self.stop_node(4)\n \n-        print(\"Check that we haven't started pruning yet because we're below PruneAfterHeight\")\n+        self.log.info(\"Check that we haven't started pruning yet because we're below PruneAfterHeight\")\n         self.test_height_min()\n         # Extend this chain past the PruneAfterHeight\n         # N0=N1=N2 **...*(1020)\n \n-        print(\"Check that we'll exceed disk space target if we have a very high stale block rate\")\n+        self.log.info(\"Check that we'll exceed disk space target if we have a very high stale block rate\")\n         self.create_chain_with_staleblocks()\n         # Disconnect N0\n         # And mine a 24 block chain on N1 and a separate 25 block chain on N0\n@@ -375,7 +375,7 @@ def run_test(self):\n         self.mainchainheight = self.nodes[2].getblockcount()   #1320\n         self.mainchainhash2 = self.nodes[2].getblockhash(self.mainchainheight)\n \n-        print(\"Check that we can survive a 288 block reorg still\")\n+        self.log.info(\"Check that we can survive a 288 block reorg still\")\n         (self.forkheight,self.forkhash) = self.reorg_test() #(1033, )\n         # Now create a 288 block reorg by mining a longer chain on N1\n         # First disconnect N1\n@@ -408,7 +408,7 @@ def run_test(self):\n         #                                 \\\n         #                                  *...**(1320)\n \n-        print(\"Test that we can rerequest a block we previously pruned if needed for a reorg\")\n+        self.log.info(\"Test that we can rerequest a block we previously pruned if needed for a reorg\")\n         self.reorg_back()\n         # Verify that N2 still has block 1033 on current chain (@), but not on main chain (*)\n         # Invalidate 1033 on current chain (@) on N2 and we should be able to reorg to\n@@ -428,16 +428,16 @@ def run_test(self):\n         #\n         # N1 doesn't change because 1033 on main chain (*) is invalid\n \n-        print(\"Test manual pruning with block indices\")\n+        self.log.info(\"Test manual pruning with block indices\")\n         self.manual_test(3, use_timestamp=False)\n \n-        print(\"Test manual pruning with timestamps\")\n+        self.log.info(\"Test manual pruning with timestamps\")\n         self.manual_test(4, use_timestamp=True)\n \n-        print(\"Test wallet re-scan\")\n+        self.log.info(\"Test wallet re-scan\")\n         self.wallet_test()\n \n-        print(\"Done\")\n+        self.log.info(\"Done\")\n \n if __name__ == '__main__':\n     PruneTest().main()"
      },
      {
        "sha": "0cebb0466f72fdf19f9e715e5b1fc2964172b258",
        "filename": "qa/rpc-tests/reindex.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/reindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/reindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/reindex.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -36,7 +36,7 @@ def reindex(self, justchainstate=False):\n         while self.nodes[0].getblockcount() < blockcount:\n             time.sleep(0.1)\n         assert_equal(self.nodes[0].getblockcount(), blockcount)\n-        print(\"Success\")\n+        self.log.info(\"Success\")\n \n     def run_test(self):\n         self.reindex(False)"
      },
      {
        "sha": "8e2abea6a5921a4119fda38184e02bfec0bfa81d",
        "filename": "qa/rpc-tests/replace-by-fee.py",
        "status": "modified",
        "additions": 11,
        "deletions": 15,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/replace-by-fee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/replace-by-fee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/replace-by-fee.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -25,19 +25,15 @@ def make_utxo(node, amount, confirmed=True, scriptPubKey=CScript([1])):\n     fee = 1*COIN\n     while node.getbalance() < satoshi_round((amount + fee)/COIN):\n         node.generate(100)\n-        #print (node.getbalance(), amount, fee)\n \n     new_addr = node.getnewaddress()\n-    #print new_addr\n     txid = node.sendtoaddress(new_addr, satoshi_round((amount+fee)/COIN))\n     tx1 = node.getrawtransaction(txid, 1)\n     txid = int(txid, 16)\n     i = None\n \n     for i, txout in enumerate(tx1['vout']):\n-        #print i, txout['scriptPubKey']['addresses']\n         if txout['scriptPubKey']['addresses'] == [new_addr]:\n-            #print i\n             break\n     assert i is not None\n \n@@ -84,34 +80,34 @@ def setup_network(self):\n     def run_test(self):\n         make_utxo(self.nodes[0], 1*COIN)\n \n-        print(\"Running test simple doublespend...\")\n+        self.log.info(\"Running test simple doublespend...\")\n         self.test_simple_doublespend()\n \n-        print(\"Running test doublespend chain...\")\n+        self.log.info(\"Running test doublespend chain...\")\n         self.test_doublespend_chain()\n \n-        print(\"Running test doublespend tree...\")\n+        self.log.info(\"Running test doublespend tree...\")\n         self.test_doublespend_tree()\n \n-        print(\"Running test replacement feeperkb...\")\n+        self.log.info(\"Running test replacement feeperkb...\")\n         self.test_replacement_feeperkb()\n \n-        print(\"Running test spends of conflicting outputs...\")\n+        self.log.info(\"Running test spends of conflicting outputs...\")\n         self.test_spends_of_conflicting_outputs()\n \n-        print(\"Running test new unconfirmed inputs...\")\n+        self.log.info(\"Running test new unconfirmed inputs...\")\n         self.test_new_unconfirmed_inputs()\n \n-        print(\"Running test too many replacements...\")\n+        self.log.info(\"Running test too many replacements...\")\n         self.test_too_many_replacements()\n \n-        print(\"Running test opt-in...\")\n+        self.log.info(\"Running test opt-in...\")\n         self.test_opt_in()\n \n-        print(\"Running test prioritised transactions...\")\n+        self.log.info(\"Running test prioritised transactions...\")\n         self.test_prioritised_transactions()\n \n-        print(\"Passed\\n\")\n+        self.log.info(\"Passed\")\n \n     def test_simple_doublespend(self):\n         \"\"\"Simple doublespend\"\"\"\n@@ -460,7 +456,7 @@ def test_opt_in(self):\n         except JSONRPCException as exp:\n             assert_equal(exp.error['code'], -26)\n         else:\n-            print(tx1b_txid)\n+            self.log.info(tx1b_txid)\n             assert(False)\n \n         tx1_outpoint = make_utxo(self.nodes[0], int(1.1*COIN))"
      },
      {
        "sha": "776211d301f978f50949bf6b9ddd212e57ab8faa",
        "filename": "qa/rpc-tests/rest.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/rest.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/rest.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/rest.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -58,7 +58,7 @@ def setup_network(self, split=False):\n \n     def run_test(self):\n         url = urllib.parse.urlparse(self.nodes[0].url)\n-        print(\"Mining blocks...\")\n+        self.log.info(\"Mining blocks...\")\n \n         self.nodes[0].generate(1)\n         self.sync_all()"
      },
      {
        "sha": "220bf4ddd072bd166e9e70ebbb83b7032dc90f28",
        "filename": "qa/rpc-tests/rpcbind_test.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/rpcbind_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/rpcbind_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/rpcbind_test.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -61,7 +61,7 @@ def run_test(self):\n                 break\n         if non_loopback_ip is None:\n             assert(not 'This test requires at least one non-loopback IPv4 interface')\n-        print(\"Using interface %s for testing\" % non_loopback_ip)\n+        self.log.info(\"Using interface %s for testing\" % non_loopback_ip)\n \n         defaultport = rpc_port(0)\n "
      },
      {
        "sha": "f480e5c3f99ebe7314a14648ca0c88bebf7240f2",
        "filename": "qa/rpc-tests/segwit.py",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/segwit.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -124,7 +124,7 @@ def fail_mine(self, node, txid, sign, redeem_script=\"\"):\n     def run_test(self):\n         self.nodes[0].generate(161) #block 161\n \n-        print(\"Verify sigops are counted in GBT with pre-BIP141 rules before the fork\")\n+        self.log.info(\"Verify sigops are counted in GBT with pre-BIP141 rules before the fork\")\n         txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n         tmpl = self.nodes[0].getblocktemplate({})\n         assert(tmpl['sizelimit'] == 1000000)\n@@ -173,7 +173,7 @@ def run_test(self):\n         self.nodes[0].generate(260) #block 423\n         sync_blocks(self.nodes)\n \n-        print(\"Verify default node can't accept any witness format txs before fork\")\n+        self.log.info(\"Verify default node can't accept any witness format txs before fork\")\n         # unsigned, no scriptsig\n         self.fail_accept(self.nodes[0], wit_ids[NODE_0][WIT_V0][0], False)\n         self.fail_accept(self.nodes[0], wit_ids[NODE_0][WIT_V1][0], False)\n@@ -188,35 +188,35 @@ def run_test(self):\n         self.fail_accept(self.nodes[0], p2sh_ids[NODE_0][WIT_V0][0], True)\n         self.fail_accept(self.nodes[0], p2sh_ids[NODE_0][WIT_V1][0], True)\n \n-        print(\"Verify witness txs are skipped for mining before the fork\")\n+        self.log.info(\"Verify witness txs are skipped for mining before the fork\")\n         self.skip_mine(self.nodes[2], wit_ids[NODE_2][WIT_V0][0], True) #block 424\n         self.skip_mine(self.nodes[2], wit_ids[NODE_2][WIT_V1][0], True) #block 425\n         self.skip_mine(self.nodes[2], p2sh_ids[NODE_2][WIT_V0][0], True) #block 426\n         self.skip_mine(self.nodes[2], p2sh_ids[NODE_2][WIT_V1][0], True) #block 427\n \n         # TODO: An old node would see these txs without witnesses and be able to mine them\n \n-        print(\"Verify unsigned bare witness txs in versionbits-setting blocks are valid before the fork\")\n+        self.log.info(\"Verify unsigned bare witness txs in versionbits-setting blocks are valid before the fork\")\n         self.success_mine(self.nodes[2], wit_ids[NODE_2][WIT_V0][1], False) #block 428\n         self.success_mine(self.nodes[2], wit_ids[NODE_2][WIT_V1][1], False) #block 429\n \n-        print(\"Verify unsigned p2sh witness txs without a redeem script are invalid\")\n+        self.log.info(\"Verify unsigned p2sh witness txs without a redeem script are invalid\")\n         self.fail_accept(self.nodes[2], p2sh_ids[NODE_2][WIT_V0][1], False)\n         self.fail_accept(self.nodes[2], p2sh_ids[NODE_2][WIT_V1][1], False)\n \n-        print(\"Verify unsigned p2sh witness txs with a redeem script in versionbits-settings blocks are valid before the fork\")\n+        self.log.info(\"Verify unsigned p2sh witness txs with a redeem script in versionbits-settings blocks are valid before the fork\")\n         self.success_mine(self.nodes[2], p2sh_ids[NODE_2][WIT_V0][1], False, addlength(witness_script(0, self.pubkey[2]))) #block 430\n         self.success_mine(self.nodes[2], p2sh_ids[NODE_2][WIT_V1][1], False, addlength(witness_script(1, self.pubkey[2]))) #block 431\n \n-        print(\"Verify previous witness txs skipped for mining can now be mined\")\n+        self.log.info(\"Verify previous witness txs skipped for mining can now be mined\")\n         assert_equal(len(self.nodes[2].getrawmempool()), 4)\n         block = self.nodes[2].generate(1) #block 432 (first block with new rules; 432 = 144 * 3)\n         sync_blocks(self.nodes)\n         assert_equal(len(self.nodes[2].getrawmempool()), 0)\n         segwit_tx_list = self.nodes[2].getblock(block[0])[\"tx\"]\n         assert_equal(len(segwit_tx_list), 5)\n \n-        print(\"Verify block and transaction serialization rpcs return differing serializations depending on rpc serialization flag\")\n+        self.log.info(\"Verify block and transaction serialization rpcs return differing serializations depending on rpc serialization flag\")\n         assert(self.nodes[2].getblock(block[0], False) !=  self.nodes[0].getblock(block[0], False))\n         assert(self.nodes[1].getblock(block[0], False) ==  self.nodes[2].getblock(block[0], False))\n         for i in range(len(segwit_tx_list)):\n@@ -227,19 +227,19 @@ def run_test(self):\n             assert(self.nodes[1].getrawtransaction(segwit_tx_list[i]) == self.nodes[2].gettransaction(segwit_tx_list[i])[\"hex\"])\n             assert(self.nodes[0].getrawtransaction(segwit_tx_list[i]) == bytes_to_hex_str(tx.serialize_without_witness()))\n \n-        print(\"Verify witness txs without witness data are invalid after the fork\")\n+        self.log.info(\"Verify witness txs without witness data are invalid after the fork\")\n         self.fail_mine(self.nodes[2], wit_ids[NODE_2][WIT_V0][2], False)\n         self.fail_mine(self.nodes[2], wit_ids[NODE_2][WIT_V1][2], False)\n         self.fail_mine(self.nodes[2], p2sh_ids[NODE_2][WIT_V0][2], False, addlength(witness_script(0, self.pubkey[2])))\n         self.fail_mine(self.nodes[2], p2sh_ids[NODE_2][WIT_V1][2], False, addlength(witness_script(1, self.pubkey[2])))\n \n-        print(\"Verify default node can now use witness txs\")\n+        self.log.info(\"Verify default node can now use witness txs\")\n         self.success_mine(self.nodes[0], wit_ids[NODE_0][WIT_V0][0], True) #block 432\n         self.success_mine(self.nodes[0], wit_ids[NODE_0][WIT_V1][0], True) #block 433\n         self.success_mine(self.nodes[0], p2sh_ids[NODE_0][WIT_V0][0], True) #block 434\n         self.success_mine(self.nodes[0], p2sh_ids[NODE_0][WIT_V1][0], True) #block 435\n \n-        print(\"Verify sigops are counted in GBT with BIP141 rules after the fork\")\n+        self.log.info(\"Verify sigops are counted in GBT with BIP141 rules after the fork\")\n         txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n         tmpl = self.nodes[0].getblocktemplate({'rules':['segwit']})\n         assert(tmpl['sizelimit'] >= 3999577)  # actual maximum size is lower due to minimum mandatory non-witness data\n@@ -248,11 +248,11 @@ def run_test(self):\n         assert(tmpl['transactions'][0]['txid'] == txid)\n         assert(tmpl['transactions'][0]['sigops'] == 8)\n \n-        print(\"Non-segwit miners are not able to use GBT response after activation.\")\n+        self.log.info(\"Non-segwit miners are not able to use GBT response after activation.\")\n         send_to_witness(1, self.nodes[0], find_unspent(self.nodes[0], 50), self.pubkey[0], False, Decimal(\"49.998\"))\n         assert_raises_jsonrpc(-8, \"Support for 'segwit' rule requires explicit client support\", self.nodes[0].getblocktemplate, {})\n \n-        print(\"Verify behaviour of importaddress, addwitnessaddress and listunspent\")\n+        self.log.info(\"Verify behaviour of importaddress, addwitnessaddress and listunspent\")\n \n         # Some public keys to be used later\n         pubkeys = ["
      },
      {
        "sha": "de7f5e0849bfcda52fd0faa825edcc104cd69668",
        "filename": "qa/rpc-tests/sendheaders.py",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/sendheaders.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/sendheaders.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/sendheaders.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -283,7 +283,7 @@ def run_test(self):\n \n         # PART 1\n         # 1. Mine a block; expect inv announcements each time\n-        print(\"Part 1: headers don't start before sendheaders message...\")\n+        self.log.info(\"Part 1: headers don't start before sendheaders message...\")\n         for i in range(4):\n             old_tip = tip\n             tip = self.mine_blocks(1)\n@@ -314,8 +314,8 @@ def run_test(self):\n                 inv_node.clear_last_announcement()\n                 test_node.clear_last_announcement()\n \n-        print(\"Part 1: success!\")\n-        print(\"Part 2: announce blocks with headers after sendheaders message...\")\n+        self.log.info(\"Part 1: success!\")\n+        self.log.info(\"Part 2: announce blocks with headers after sendheaders message...\")\n         # PART 2\n         # 2. Send a sendheaders message and test that headers announcements\n         # commence and keep working.\n@@ -376,9 +376,9 @@ def run_test(self):\n                 height += 1\n                 block_time += 1\n \n-        print(\"Part 2: success!\")\n+        self.log.info(\"Part 2: success!\")\n \n-        print(\"Part 3: headers announcements can stop after large reorg, and resume after headers/inv from peer...\")\n+        self.log.info(\"Part 3: headers announcements can stop after large reorg, and resume after headers/inv from peer...\")\n \n         # PART 3.  Headers announcements can stop after large reorg, and resume after\n         # getheaders or inv from peer.\n@@ -440,9 +440,9 @@ def run_test(self):\n             assert_equal(inv_node.check_last_announcement(inv=[tip]), True)\n             assert_equal(test_node.check_last_announcement(headers=[tip]), True)\n \n-        print(\"Part 3: success!\")\n+        self.log.info(\"Part 3: success!\")\n \n-        print(\"Part 4: Testing direct fetch behavior...\")\n+        self.log.info(\"Part 4: Testing direct fetch behavior...\")\n         tip = self.mine_blocks(1)\n         height = self.nodes[0].getblockcount() + 1\n         last_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time']\n@@ -523,12 +523,12 @@ def run_test(self):\n         with mininode_lock:\n             assert_equal(test_node.last_getdata, None)\n \n-        print(\"Part 4: success!\")\n+        self.log.info(\"Part 4: success!\")\n \n         # Now deliver all those blocks we announced.\n         [ test_node.send_message(msg_block(x)) for x in blocks ]\n \n-        print(\"Part 5: Testing handling of unconnecting headers\")\n+        self.log.info(\"Part 5: Testing handling of unconnecting headers\")\n         # First we test that receipt of an unconnecting header doesn't prevent\n         # chain sync.\n         for i in range(10):\n@@ -595,7 +595,7 @@ def run_test(self):\n         with mininode_lock:\n             self.last_getheaders = True\n \n-        print(\"Part 5: success!\")\n+        self.log.info(\"Part 5: success!\")\n \n         # Finally, check that the inv node never received a getdata request,\n         # throughout the test"
      },
      {
        "sha": "f7d692083c02b18b3d7d103a86dc64eb1e24fcce",
        "filename": "qa/rpc-tests/smartfees.py",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/smartfees.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/smartfees.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/smartfees.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -99,7 +99,7 @@ def check_estimates(node, fees_seen, max_invalid, print_estimates = True):\n     \"\"\"\n     all_estimates = [ node.estimatefee(i) for i in range(1,26) ]\n     if print_estimates:\n-        print([str(all_estimates[e-1]) for e in [1,2,3,6,15,25]])\n+        self.log.info([str(all_estimates[e-1]) for e in [1,2,3,6,15,25]])\n     delta = 1.0e-6 # account for rounding error\n     last_e = max(fees_seen)\n     for e in [x for x in all_estimates if x >= 0]:\n@@ -159,8 +159,8 @@ def setup_network(self):\n         self.nodes.append(start_node(0, self.options.tmpdir, [\"-maxorphantx=1000\",\n                                                               \"-whitelist=127.0.0.1\"]))\n \n-        print(\"This test is time consuming, please be patient\")\n-        print(\"Splitting inputs so we can generate tx's\")\n+        self.log.info(\"This test is time consuming, please be patient\")\n+        self.log.info(\"Splitting inputs so we can generate tx's\")\n         self.txouts = []\n         self.txouts2 = []\n         # Split a coinbase into two transaction puzzle outputs\n@@ -185,7 +185,7 @@ def setup_network(self):\n             while (len(self.nodes[0].getrawmempool()) > 0):\n                 self.nodes[0].generate(1)\n             reps += 1\n-        print(\"Finished splitting\")\n+        self.log.info(\"Finished splitting\")\n \n         # Now we can connect the other nodes, didn't want to connect them earlier\n         # so the estimates would not be affected by the splitting transactions\n@@ -237,15 +237,15 @@ def run_test(self):\n         self.fees_per_kb = []\n         self.memutxo = []\n         self.confutxo = self.txouts # Start with the set of confirmed txouts after splitting\n-        print(\"Will output estimates for 1/2/3/6/15/25 blocks\")\n+        self.log.info(\"Will output estimates for 1/2/3/6/15/25 blocks\")\n \n         for i in range(2):\n-            print(\"Creating transactions and mining them with a block size that can't keep up\")\n+            self.log.info(\"Creating transactions and mining them with a block size that can't keep up\")\n             # Create transactions and mine 10 small blocks with node 2, but create txs faster than we can mine\n             self.transact_and_mine(10, self.nodes[2])\n             check_estimates(self.nodes[1], self.fees_per_kb, 14)\n \n-            print(\"Creating transactions and mining them at a block size that is just big enough\")\n+            self.log.info(\"Creating transactions and mining them at a block size that is just big enough\")\n             # Generate transactions while mining 10 more blocks, this time with node1\n             # which mines blocks with capacity just above the rate that transactions are being created\n             self.transact_and_mine(10, self.nodes[1])\n@@ -256,7 +256,7 @@ def run_test(self):\n             self.nodes[1].generate(1)\n \n         sync_blocks(self.nodes[0:3], wait=.1)\n-        print(\"Final estimates after emptying mempools\")\n+        self.log.info(\"Final estimates after emptying mempools\")\n         check_estimates(self.nodes[1], self.fees_per_kb, 2)\n \n if __name__ == '__main__':"
      },
      {
        "sha": "c40662dc3d6df26349936bfa971fe1f09f65c5a2",
        "filename": "qa/rpc-tests/wallet-hd.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/wallet-hd.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/wallet-hd.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/wallet-hd.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -68,7 +68,7 @@ def run_test (self):\n         self.sync_all()\n         assert_equal(self.nodes[1].getbalance(), num_hd_adds + 1)\n \n-        print(\"Restore backup ...\")\n+        self.log.info(\"Restore backup ...\")\n         self.stop_node(1)\n         os.remove(self.options.tmpdir + \"/node1/regtest/wallet.dat\")\n         shutil.copyfile(tmpdir + \"/hd.bak\", tmpdir + \"/node1/regtest/wallet.dat\")"
      },
      {
        "sha": "00fe37563b3c6119209aa25d4130be6192c7bc62",
        "filename": "qa/rpc-tests/wallet.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/wallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/wallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/wallet.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -35,7 +35,7 @@ def run_test (self):\n         assert_equal(len(self.nodes[1].listunspent()), 0)\n         assert_equal(len(self.nodes[2].listunspent()), 0)\n \n-        print(\"Mining blocks...\")\n+        self.log.info(\"Mining blocks...\")\n \n         self.nodes[0].generate(1)\n \n@@ -332,7 +332,7 @@ def run_test (self):\n         ]\n         chainlimit = 6\n         for m in maintenance:\n-            print(\"check \" + m)\n+            self.log.info(\"check \" + m)\n             stop_nodes(self.nodes)\n             # set lower ancestor limit for later\n             self.nodes = start_nodes(3, self.options.tmpdir, [[m, \"-limitancestorcount=\"+str(chainlimit)]] * 3)"
      },
      {
        "sha": "af1718572fd5c013fd433a1f9b31ceb110272cba",
        "filename": "qa/rpc-tests/walletbackup.py",
        "status": "modified",
        "additions": 7,
        "deletions": 9,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/walletbackup.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/walletbackup.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/walletbackup.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -34,8 +34,6 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n from random import randint\n-import logging\n-logging.basicConfig(format='%(levelname)s: %(message)s', level=logging.INFO, stream=sys.stdout)\n \n class WalletBackupTest(BitcoinTestFramework):\n \n@@ -100,7 +98,7 @@ def erase_three(self):\n         os.remove(self.options.tmpdir + \"/node2/regtest/wallet.dat\")\n \n     def run_test(self):\n-        logging.info(\"Generating initial blockchain\")\n+        self.log.info(\"Generating initial blockchain\")\n         self.nodes[0].generate(1)\n         sync_blocks(self.nodes)\n         self.nodes[1].generate(1)\n@@ -115,12 +113,12 @@ def run_test(self):\n         assert_equal(self.nodes[2].getbalance(), 50)\n         assert_equal(self.nodes[3].getbalance(), 0)\n \n-        logging.info(\"Creating transactions\")\n+        self.log.info(\"Creating transactions\")\n         # Five rounds of sending each other transactions.\n         for i in range(5):\n             self.do_one_round()\n \n-        logging.info(\"Backing up\")\n+        self.log.info(\"Backing up\")\n         tmpdir = self.options.tmpdir\n         self.nodes[0].backupwallet(tmpdir + \"/node0/wallet.bak\")\n         self.nodes[0].dumpwallet(tmpdir + \"/node0/wallet.dump\")\n@@ -129,7 +127,7 @@ def run_test(self):\n         self.nodes[2].backupwallet(tmpdir + \"/node2/wallet.bak\")\n         self.nodes[2].dumpwallet(tmpdir + \"/node2/wallet.dump\")\n \n-        logging.info(\"More transactions\")\n+        self.log.info(\"More transactions\")\n         for i in range(5):\n             self.do_one_round()\n \n@@ -150,7 +148,7 @@ def run_test(self):\n         ##\n         # Test restoring spender wallets from backups\n         ##\n-        logging.info(\"Restoring using wallet.dat\")\n+        self.log.info(\"Restoring using wallet.dat\")\n         self.stop_three()\n         self.erase_three()\n \n@@ -163,15 +161,15 @@ def run_test(self):\n         shutil.copyfile(tmpdir + \"/node1/wallet.bak\", tmpdir + \"/node1/regtest/wallet.dat\")\n         shutil.copyfile(tmpdir + \"/node2/wallet.bak\", tmpdir + \"/node2/regtest/wallet.dat\")\n \n-        logging.info(\"Re-starting nodes\")\n+        self.log.info(\"Re-starting nodes\")\n         self.start_three()\n         sync_blocks(self.nodes)\n \n         assert_equal(self.nodes[0].getbalance(), balance0)\n         assert_equal(self.nodes[1].getbalance(), balance1)\n         assert_equal(self.nodes[2].getbalance(), balance2)\n \n-        logging.info(\"Restoring using dumped wallet\")\n+        self.log.info(\"Restoring using dumped wallet\")\n         self.stop_three()\n         self.erase_three()\n "
      },
      {
        "sha": "ce446e44a356dcc695e956d6235a1715676dee7b",
        "filename": "qa/rpc-tests/zapwallettxes.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/zapwallettxes.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/zapwallettxes.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/zapwallettxes.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -32,7 +32,7 @@ def setup_network(self, split=False):\n         self.sync_all()\n \n     def run_test (self):\n-        print(\"Mining blocks...\")\n+        self.log.info(\"Mining blocks...\")\n         self.nodes[0].generate(1)\n         self.sync_all()\n         self.nodes[1].generate(101)"
      },
      {
        "sha": "e6f18b0b9332b1486040ee401161627e134648d9",
        "filename": "qa/rpc-tests/zmq_test.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/zmq_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64c080051b932b3e53ece7638f199e48d0ad16c8/qa/rpc-tests/zmq_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/zmq_test.py?ref=64c080051b932b3e53ece7638f199e48d0ad16c8",
        "patch": "@@ -36,7 +36,7 @@ def run_test(self):\n         genhashes = self.nodes[0].generate(1)\n         self.sync_all()\n \n-        print(\"listen...\")\n+        self.log.info(\"listen...\")\n         msg = self.zmqSubSocket.recv_multipart()\n         topic = msg[0]\n         assert_equal(topic, b\"hashtx\")"
      }
    ]
  }
]