laanwj,2019-10-30 16:32:13,I think this is over-sweeping. A comparison that is tautological on one platform might not be on another.,https://github.com/bitcoin/bitcoin/pull/17320#issuecomment-547995837,547995837,
practicalswift,2019-10-30 17:29:09,"@laanwj \n\nIf I'm reading `Parse{U,}Int64` correctly these functions are not written in a platform independent way today. The ""`sizeof(unsigned long long) > sizeof(uint64_t)` fix"" you're referring to in the current code does not look correct if the intention is that these functions should give identical results across platforms.\n\nMore specifically my reading is that input test cases can be ",https://github.com/bitcoin/bitcoin/pull/17320#issuecomment-548023177,548023177,
laanwj,2019-10-30 17:46:41,"*The idea* is that `ParseUint64` rejects values outside the range of `uint64_t` as parse error. So `strtoull` could return values outside the range of `uint64_t`, but this will be treated as a parse error. \n\n- On platforms where `uint64_t` == `unsigned long long` this works, because, values outside `uint64_t` will be rejected by `strtoull`. The comparison is tautological.\n- On platforms wher",https://github.com/bitcoin/bitcoin/pull/17320#issuecomment-548031477,548031477,
laanwj,2019-10-30 16:23:14,"I don't like this change.\nThe old code is written to work for the case where a `unsigned long long` has a larger range than `uint64_t`.\nThe new code throws a compile-time assertion error in that case.\nThis is not the same.\n",https://github.com/bitcoin/bitcoin/pull/17320#discussion_r340721741,340721741,src/util/strencodings.cpp
