[
  {
    "sha": "51fcfc022ce29aa8575d361497bfe458c973b1c5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1MWZjZmMwMjJjZTI5YWE4NTc1ZDM2MTQ5N2JmZTQ1OGM5NzNiMWM1",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-01-23T06:53:50Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-09-02T16:38:41Z"
      },
      "message": "doc: remove documentation for rpcssl",
      "tree": {
        "sha": "bd0484ff6573662eca5f557d06e4a25695e41cc7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bd0484ff6573662eca5f557d06e4a25695e41cc7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/51fcfc022ce29aa8575d361497bfe458c973b1c5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/51fcfc022ce29aa8575d361497bfe458c973b1c5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/51fcfc022ce29aa8575d361497bfe458c973b1c5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/51fcfc022ce29aa8575d361497bfe458c973b1c5/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3932ff50c563df19c14e9987f2297d9f99a299ac",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3932ff50c563df19c14e9987f2297d9f99a299ac",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3932ff50c563df19c14e9987f2297d9f99a299ac"
      }
    ],
    "stats": {
      "total": 50,
      "additions": 1,
      "deletions": 49
    },
    "files": [
      {
        "sha": "1338d2f2b5c3b5dc48a36f93c5afbac330b9a065",
        "filename": "contrib/bitcoind.bash-completion",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/51fcfc022ce29aa8575d361497bfe458c973b1c5/contrib/bitcoind.bash-completion",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/51fcfc022ce29aa8575d361497bfe458c973b1c5/contrib/bitcoind.bash-completion",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/bitcoind.bash-completion?ref=51fcfc022ce29aa8575d361497bfe458c973b1c5",
        "patch": "@@ -96,7 +96,7 @@ _bitcoind() {\n     esac\n \n     case \"$cur\" in\n-        -conf=*|-pid=*|-loadblock=*|-wallet=*|-rpcsslcertificatechainfile=*|-rpcsslprivatekeyfile=*)\n+        -conf=*|-pid=*|-loadblock=*|-wallet=*)\n             cur=\"${cur#*=}\"\n             _filedir\n             return 0"
      },
      {
        "sha": "62ffd7123a666eaeb140a1ec2846a0e6a3a91ad8",
        "filename": "contrib/debian/examples/bitcoin.conf",
        "status": "modified",
        "additions": 0,
        "deletions": 9,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/51fcfc022ce29aa8575d361497bfe458c973b1c5/contrib/debian/examples/bitcoin.conf",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/51fcfc022ce29aa8575d361497bfe458c973b1c5/contrib/debian/examples/bitcoin.conf",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/examples/bitcoin.conf?ref=51fcfc022ce29aa8575d361497bfe458c973b1c5",
        "patch": "@@ -95,15 +95,6 @@\n # running on another host using this option:\n #rpcconnect=127.0.0.1\n \n-# Use Secure Sockets Layer (also known as TLS or HTTPS) to communicate\n-# with Bitcoin -server or bitcoind\n-#rpcssl=1\n-\n-# OpenSSL settings used when rpcssl=1\n-#rpcsslciphers=TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!AH:!3DES:@STRENGTH\n-#rpcsslcertificatechainfile=server.cert\n-#rpcsslprivatekeyfile=server.pem\n-\n # Transaction Fee Changes in 0.10.0\n \n # Send transactions as zero-fee transactions if possible (default: 0)"
      },
      {
        "sha": "154b45873940c9d23b8d1fe96d516ee7b5bdf7f0",
        "filename": "contrib/debian/manpages/bitcoin-cli.1",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/51fcfc022ce29aa8575d361497bfe458c973b1c5/contrib/debian/manpages/bitcoin-cli.1",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/51fcfc022ce29aa8575d361497bfe458c973b1c5/contrib/debian/manpages/bitcoin-cli.1",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/manpages/bitcoin-cli.1?ref=51fcfc022ce29aa8575d361497bfe458c973b1c5",
        "patch": "@@ -36,9 +36,6 @@ Listen for JSON\\-RPC connections on <port> (default: 8332 or testnet: 18332).\n .TP\n \\fB\\-rpcconnect=\\fR<ip>\n Send commands to node running on <ip> (default: 127.0.0.1).\n-.TP\n-\\fB\\-rpcssl\\fR=\\fI1\\fR\n-Use OpenSSL (https) for JSON\\-RPC connections (see the Bitcoin Wiki for SSL setup instructions).\n \n .SH \"SEE ALSO\"\n \\fBbitcoind\\fP, \\fBbitcoin.conf\\fP"
      },
      {
        "sha": "05eadc94cdd441d5c3c6e32137884d43e506b4fb",
        "filename": "contrib/debian/manpages/bitcoin-qt.1",
        "status": "modified",
        "additions": 0,
        "deletions": 12,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/51fcfc022ce29aa8575d361497bfe458c973b1c5/contrib/debian/manpages/bitcoin-qt.1",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/51fcfc022ce29aa8575d361497bfe458c973b1c5/contrib/debian/manpages/bitcoin-qt.1",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/manpages/bitcoin-qt.1?ref=51fcfc022ce29aa8575d361497bfe458c973b1c5",
        "patch": "@@ -178,18 +178,6 @@ Set maximum block size in bytes (default: 250000)\n .HP\n \\fB\\-blockprioritysize=\\fR<n> Set maximum size of high\\-priority/low\\-fee transactions in bytes (default: 27000)\n .PP\n-SSL options: (see the Bitcoin Wiki for SSL setup instructions)\n-.TP\n-\\fB\\-rpcssl\\fR\n-Use OpenSSL (https) for JSON\\-RPC connections\n-.TP\n-\\fB\\-rpcsslcertificatechainfile=\\fR<file.cert>\n-Server certificate file (default: server.cert)\n-.TP\n-\\fB\\-rpcsslprivatekeyfile=\\fR<file.pem>\n-Server private key (default: server.pem)\n-.TP\n-\\fB\\-rpcsslciphers=\\fR<ciphers>\n Acceptable ciphers (default: TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!AH:!3DES:@STRENGTH)\n .SS \"UI options:\"\n .TP"
      },
      {
        "sha": "0cf4d991e34c90bf2d38e3fcb982c89cfee6aed6",
        "filename": "contrib/debian/manpages/bitcoin.conf.5",
        "status": "modified",
        "additions": 0,
        "deletions": 10,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/51fcfc022ce29aa8575d361497bfe458c973b1c5/contrib/debian/manpages/bitcoin.conf.5",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/51fcfc022ce29aa8575d361497bfe458c973b1c5/contrib/debian/manpages/bitcoin.conf.5",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/manpages/bitcoin.conf.5?ref=51fcfc022ce29aa8575d361497bfe458c973b1c5",
        "patch": "@@ -46,16 +46,6 @@ Listen for RPC connections on this TCP port.\n \\fBrpcconnect=\\fR\\fI'127.0.0.1'\\fR\n You can use *bitcoin* or *bitcoind(1)* to send commands to *bitcoin*/*bitcoind(1)* running on another host using this option.\n .TP\n-\\fBrpcssl=\\fR\\fI'1'\\fR\n-Use Secure Sockets Layer (also known as TLS or HTTPS) to communicate with *bitcoin* '\\-server' or *bitcoind(1)*. Example of OpenSSL settings used when *rpcssl*='1':\n-.TP\n-\\fB\\-rpcsslciphers=\\fR<ciphers>\n-Acceptable ciphers (default: TLSv1+HIGH:\\:!SSLv2:\\:!aNULL:\\:!eNULL:\\:!AH:\\:!3DES:\\:@STRENGTH)\n-.TP\n-\\fBrpcsslcertificatechainfile=\\fR\\fI'server.cert'\\fR\n-.TP\n-\\fBrpcsslprivatekeyfile=\\fR\\fI'server.pem'\\fR\n-.TP\n .SH MISCELLANEOUS OPTIONS\n .TP\n \\fBgen=\\fR[\\fI'0'\\fR|\\fI'1'\\fR]"
      },
      {
        "sha": "5b0f2921aa415b04663e472162bf95458d308e75",
        "filename": "contrib/debian/manpages/bitcoind.1",
        "status": "modified",
        "additions": 0,
        "deletions": 14,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/51fcfc022ce29aa8575d361497bfe458c973b1c5/contrib/debian/manpages/bitcoind.1",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/51fcfc022ce29aa8575d361497bfe458c973b1c5/contrib/debian/manpages/bitcoind.1",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/manpages/bitcoind.1?ref=51fcfc022ce29aa8575d361497bfe458c973b1c5",
        "patch": "@@ -62,20 +62,6 @@ Allow JSON\\-RPC connections from specified IP address\n .TP\n \\fB\\-rpcconnect=\\fR<ip>\n Send commands to node running on <ip>\n-.PP\n-SSL options: (see the Bitcoin Wiki for SSL setup instructions)\n-.TP\n-\\fB\\-rpcssl\\fR=\\fI1\\fR\n-Use OpenSSL (https) for JSON\\-RPC connections\n-.TP\n-\\fB\\-rpcsslcertificatchainfile=\\fR<file.cert>\n-Server certificate file (default: server.cert)\n-.TP\n-\\fB\\-rpcsslprivatekeyfile=\\fR<file.pem>\n-Server private key (default: server.pem)\n-.TP\n-\\fB\\-rpcsslciphers=\\fR<ciphers>\n-Acceptable ciphers (default: TLSv1+HIGH:\\:!SSLv2:\\:!aNULL:\\:!eNULL:\\:!AH:\\:!3DES:\\:@STRENGTH)\n .TP\n \\-?\n This help message"
      }
    ]
  },
  {
    "sha": "8f9301cdaae3682a650e42dfee6c7013b9703ff0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4ZjkzMDFjZGFhZTM2ODJhNjUwZTQyZGZlZTZjNzAxM2I5NzAzZmYw",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-01-23T06:54:27Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-09-02T16:38:41Z"
      },
      "message": "qa: Remove -rpckeepalive tests from httpbasics\n\nThis option was a temporary workaround, and is no longer necessary\nwith the new web server.",
      "tree": {
        "sha": "a9961561919e825df38b379745cc707b066e1fc3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a9961561919e825df38b379745cc707b066e1fc3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8f9301cdaae3682a650e42dfee6c7013b9703ff0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8f9301cdaae3682a650e42dfee6c7013b9703ff0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8f9301cdaae3682a650e42dfee6c7013b9703ff0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8f9301cdaae3682a650e42dfee6c7013b9703ff0/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "51fcfc022ce29aa8575d361497bfe458c973b1c5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/51fcfc022ce29aa8575d361497bfe458c973b1c5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/51fcfc022ce29aa8575d361497bfe458c973b1c5"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 2,
      "deletions": 3
    },
    "files": [
      {
        "sha": "b66533543d755b37c4cc10e5d580686c220fc918",
        "filename": "qa/rpc-tests/httpbasics.py",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f9301cdaae3682a650e42dfee6c7013b9703ff0/qa/rpc-tests/httpbasics.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f9301cdaae3682a650e42dfee6c7013b9703ff0/qa/rpc-tests/httpbasics.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/httpbasics.py?ref=8f9301cdaae3682a650e42dfee6c7013b9703ff0",
        "patch": "@@ -22,7 +22,7 @@\n \n class HTTPBasicsTest (BitcoinTestFramework):\n     def setup_nodes(self):\n-        return start_nodes(4, self.options.tmpdir, extra_args=[['-rpckeepalive=1'], ['-rpckeepalive=0'], [], []])\n+        return start_nodes(4, self.options.tmpdir)\n \n     def run_test(self):\n \n@@ -84,9 +84,8 @@ def run_test(self):\n         conn.request('POST', '/', '{\"method\": \"getbestblockhash\"}', headers)\n         out1 = conn.getresponse().read();\n         assert_equal('\"error\":null' in out1, True)\n-        assert_equal(conn.sock!=None, False) #connection must be closed because keep-alive was set to false\n \n-        #node2 (third node) is running with standard keep-alive parameters which means keep-alive is off\n+        #node2 (third node) is running with standard keep-alive parameters which means keep-alive is on\n         urlNode2 = urlparse.urlparse(self.nodes[2].url)\n         authpair = urlNode2.username + ':' + urlNode2.password\n         headers = {\"Authorization\": \"Basic \" + base64.b64encode(authpair)}"
      }
    ]
  },
  {
    "sha": "6a21dd598c01deb939681e4594bfd7b75ecb7ca3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2YTIxZGQ1OThjMDFkZWI5Mzk2ODFlNDU5NGJmZDdiNzVlY2I3Y2Ez",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-01-23T06:55:37Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-09-02T16:38:41Z"
      },
      "message": "Remove rpc_boostasiotocnetaddr test\n\nDropping all use of boost::asio.",
      "tree": {
        "sha": "259dc0591186c3189c4930d8d8cdaffba3a12da0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/259dc0591186c3189c4930d8d8cdaffba3a12da0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6a21dd598c01deb939681e4594bfd7b75ecb7ca3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6a21dd598c01deb939681e4594bfd7b75ecb7ca3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6a21dd598c01deb939681e4594bfd7b75ecb7ca3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6a21dd598c01deb939681e4594bfd7b75ecb7ca3/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8f9301cdaae3682a650e42dfee6c7013b9703ff0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8f9301cdaae3682a650e42dfee6c7013b9703ff0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8f9301cdaae3682a650e42dfee6c7013b9703ff0"
      }
    ],
    "stats": {
      "total": 15,
      "additions": 0,
      "deletions": 15
    },
    "files": [
      {
        "sha": "c0476db99b25983bfc02bd64e6ac7966e5944e90",
        "filename": "src/test/rpc_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 15,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a21dd598c01deb939681e4594bfd7b75ecb7ca3/src/test/rpc_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a21dd598c01deb939681e4594bfd7b75ecb7ca3/src/test/rpc_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/rpc_tests.cpp?ref=6a21dd598c01deb939681e4594bfd7b75ecb7ca3",
        "patch": "@@ -224,21 +224,6 @@ BOOST_AUTO_TEST_CASE(json_parse_errors)\n     BOOST_CHECK_THROW(ParseNonRFCJSONValue(\"3J98t1WpEZ73CNmQviecrnyiWrnqRhWNL\"), std::runtime_error);\n }\n \n-BOOST_AUTO_TEST_CASE(rpc_boostasiotocnetaddr)\n-{\n-    // Check IPv4 addresses\n-    BOOST_CHECK_EQUAL(BoostAsioToCNetAddr(boost::asio::ip::address::from_string(\"1.2.3.4\")).ToString(), \"1.2.3.4\");\n-    BOOST_CHECK_EQUAL(BoostAsioToCNetAddr(boost::asio::ip::address::from_string(\"127.0.0.1\")).ToString(), \"127.0.0.1\");\n-    // Check IPv6 addresses\n-    BOOST_CHECK_EQUAL(BoostAsioToCNetAddr(boost::asio::ip::address::from_string(\"::1\")).ToString(), \"::1\");\n-    BOOST_CHECK_EQUAL(BoostAsioToCNetAddr(boost::asio::ip::address::from_string(\"123:4567:89ab:cdef:123:4567:89ab:cdef\")).ToString(),\n-                                         \"123:4567:89ab:cdef:123:4567:89ab:cdef\");\n-    // v4 compatible must be interpreted as IPv4\n-    BOOST_CHECK_EQUAL(BoostAsioToCNetAddr(boost::asio::ip::address::from_string(\"::0:127.0.0.1\")).ToString(), \"127.0.0.1\");\n-    // v4 mapped must be interpreted as IPv4\n-    BOOST_CHECK_EQUAL(BoostAsioToCNetAddr(boost::asio::ip::address::from_string(\"::ffff:127.0.0.1\")).ToString(), \"127.0.0.1\");\n-}\n-\n BOOST_AUTO_TEST_CASE(rpc_ban)\n {\n     BOOST_CHECK_NO_THROW(CallRPC(string(\"clearbanned\")));"
      }
    ]
  },
  {
    "sha": "a9af234c1f22d3e8b49c6d8abb89cc8b8c009a30",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphOWFmMjM0YzFmMjJkM2U4YjQ5YzZkOGFiYjg5Y2M4YjhjMDA5YTMw",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2015-01-20T03:47:44Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-09-02T16:38:41Z"
      },
      "message": "libevent: add depends",
      "tree": {
        "sha": "c47f2eade458b3206c24b6eeef7aadd9381f0e63",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c47f2eade458b3206c24b6eeef7aadd9381f0e63"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a9af234c1f22d3e8b49c6d8abb89cc8b8c009a30",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a9af234c1f22d3e8b49c6d8abb89cc8b8c009a30",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a9af234c1f22d3e8b49c6d8abb89cc8b8c009a30",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a9af234c1f22d3e8b49c6d8abb89cc8b8c009a30/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6a21dd598c01deb939681e4594bfd7b75ecb7ca3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6a21dd598c01deb939681e4594bfd7b75ecb7ca3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6a21dd598c01deb939681e4594bfd7b75ecb7ca3"
      }
    ],
    "stats": {
      "total": 28,
      "additions": 27,
      "deletions": 1
    },
    "files": [
      {
        "sha": "3388a28437312ff6610096639104d91234b9298b",
        "filename": "depends/packages/libevent.mk",
        "status": "added",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a9af234c1f22d3e8b49c6d8abb89cc8b8c009a30/depends/packages/libevent.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a9af234c1f22d3e8b49c6d8abb89cc8b8c009a30/depends/packages/libevent.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/libevent.mk?ref=a9af234c1f22d3e8b49c6d8abb89cc8b8c009a30",
        "patch": "@@ -0,0 +1,26 @@\n+package=libevent\n+$(package)_version=2.0.22\n+$(package)_download_path=https://github.com/libevent/libevent/releases/download/release-2.0.22-stable\n+$(package)_file_name=$(package)-$($(package)_version)-stable.tar.gz\n+$(package)_sha256_hash=71c2c49f0adadacfdbe6332a372c38cf9c8b7895bb73dabeaa53cdcc1d4e1fa3\n+\n+define $(package)_set_vars\n+  $(package)_config_opts=--disable-shared --disable-openssl --disable-libevent-regress\n+  $(package)_config_opts_release=--disable-debug-mode\n+  $(package)_config_opts_linux=--with-pic\n+endef\n+\n+define $(package)_config_cmds\n+  $($(package)_autoconf)\n+endef\n+\n+define $(package)_build_cmds\n+  $(MAKE)\n+endef\n+\n+define $(package)_stage_cmds\n+  $(MAKE) DESTDIR=$($(package)_staging_dir) install\n+endef\n+\n+define $(package)_postprocess_cmds\n+endef"
      },
      {
        "sha": "a0d377bb43658efc700b9ea2ecd19aa48b74beed",
        "filename": "depends/packages/packages.mk",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a9af234c1f22d3e8b49c6d8abb89cc8b8c009a30/depends/packages/packages.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a9af234c1f22d3e8b49c6d8abb89cc8b8c009a30/depends/packages/packages.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/packages.mk?ref=a9af234c1f22d3e8b49c6d8abb89cc8b8c009a30",
        "patch": "@@ -1,4 +1,4 @@\n-packages:=boost openssl\n+packages:=boost openssl libevent\n native_packages := native_ccache native_comparisontool\n \n qt_native_packages = native_protobuf"
      }
    ]
  },
  {
    "sha": "3140ef92493169f1f993312b4add1fb87943c7b4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozMTQwZWY5MjQ5MzE2OWYxZjk5MzMxMmI0YWRkMWZiODc5NDNjN2I0",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-01-20T05:04:59Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-09-02T16:38:41Z"
      },
      "message": "build: build-system changes for libevent",
      "tree": {
        "sha": "177136285a73e36db5a57425a01890cb1faef4c8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/177136285a73e36db5a57425a01890cb1faef4c8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3140ef92493169f1f993312b4add1fb87943c7b4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3140ef92493169f1f993312b4add1fb87943c7b4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3140ef92493169f1f993312b4add1fb87943c7b4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3140ef92493169f1f993312b4add1fb87943c7b4/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a9af234c1f22d3e8b49c6d8abb89cc8b8c009a30",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a9af234c1f22d3e8b49c6d8abb89cc8b8c009a30",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a9af234c1f22d3e8b49c6d8abb89cc8b8c009a30"
      }
    ],
    "stats": {
      "total": 28,
      "additions": 22,
      "deletions": 6
    },
    "files": [
      {
        "sha": "07ee28f84e69ccd5cc41afc9aaeb7360dbb81bb8",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3140ef92493169f1f993312b4add1fb87943c7b4/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3140ef92493169f1f993312b4add1fb87943c7b4/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=3140ef92493169f1f993312b4add1fb87943c7b4",
        "patch": "@@ -664,6 +664,12 @@ if test x$use_pkgconfig = xyes; then\n       if test x$use_qr != xno; then\n         BITCOIN_QT_CHECK([PKG_CHECK_MODULES([QR], [libqrencode], [have_qrencode=yes], [have_qrencode=no])])\n       fi\n+      if test x$build_bitcoin_utils$build_bitcoind$bitcoin_enable_qt$use_tests != xnononono; then\n+        PKG_CHECK_MODULES([EVENT], [libevent],, [AC_MSG_ERROR(libevent not found.)])\n+        if test x$TARGET_OS != xwindows; then\n+          PKG_CHECK_MODULES([EVENT_PTHREADS], [libevent_pthreads],, [AC_MSG_ERROR(libevent_pthreads not found.)])\n+        fi\n+      fi\n     ]\n   )\n else\n@@ -673,6 +679,14 @@ else\n   AC_CHECK_HEADER([openssl/ssl.h],, AC_MSG_ERROR(libssl headers missing),)\n   AC_CHECK_LIB([ssl],         [main],SSL_LIBS=-lssl, AC_MSG_ERROR(libssl missing))\n \n+  if test x$build_bitcoin_utils$build_bitcoind$bitcoin_enable_qt$use_tests != xnononono; then\n+    AC_CHECK_HEADER([event2/event.h],, AC_MSG_ERROR(libevent headers missing),)\n+    AC_CHECK_LIB([event],[main],EVENT_LIBS=-levent,AC_MSG_ERROR(libevent missing))\n+    if test x$TARGET_OS != xwindows; then\n+      AC_CHECK_LIB([event_pthreads],[main],EVENT_PTHREADS_LIBS=-levent_pthreads,AC_MSG_ERROR(libevent_pthreads missing))\n+    fi\n+  fi\n+\n   BITCOIN_QT_CHECK(AC_CHECK_LIB([protobuf] ,[main],[PROTOBUF_LIBS=-lprotobuf], BITCOIN_QT_FAIL(libprotobuf not found)))\n   if test x$use_qr != xno; then\n     BITCOIN_QT_CHECK([AC_CHECK_LIB([qrencode], [main],[QR_LIBS=-lqrencode], [have_qrencode=no])])"
      },
      {
        "sha": "4b646f01839fe0921025569f259af556a51dc6b4",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3140ef92493169f1f993312b4add1fb87943c7b4/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3140ef92493169f1f993312b4add1fb87943c7b4/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=3140ef92493169f1f993312b4add1fb87943c7b4",
        "patch": "@@ -163,7 +163,7 @@ obj/build.h: FORCE\n libbitcoin_util_a-clientversion.$(OBJEXT): obj/build.h\n \n # server: shared between bitcoind and bitcoin-qt\n-libbitcoin_server_a_CPPFLAGS = $(BITCOIN_INCLUDES) $(MINIUPNPC_CPPFLAGS)\n+libbitcoin_server_a_CPPFLAGS = $(BITCOIN_INCLUDES) $(MINIUPNPC_CPPFLAGS) $(EVENT_CFLAGS) $(EVENT_PTHREADS_CFLAGS)\n libbitcoin_server_a_SOURCES = \\\n   addrman.cpp \\\n   alert.cpp \\\n@@ -319,12 +319,12 @@ if ENABLE_WALLET\n bitcoind_LDADD += libbitcoin_wallet.a\n endif\n \n-bitcoind_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS)\n+bitcoind_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS)\n #\n \n # bitcoin-cli binary #\n bitcoin_cli_SOURCES = bitcoin-cli.cpp\n-bitcoin_cli_CPPFLAGS = $(BITCOIN_INCLUDES)\n+bitcoin_cli_CPPFLAGS = $(BITCOIN_INCLUDES) $(EVENT_CFLAGS)\n bitcoin_cli_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n \n if TARGET_WINDOWS\n@@ -337,7 +337,7 @@ bitcoin_cli_LDADD = \\\n   $(LIBBITCOIN_UTIL) \\\n   $(LIBSECP256K1)\n \n-bitcoin_cli_LDADD += $(BOOST_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS)\n+bitcoin_cli_LDADD += $(BOOST_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(EVENT_LIBS)\n #\n \n # bitcoin-tx binary #"
      },
      {
        "sha": "8d60aca25c531b4068c258cf2574bb7c7d36d7f4",
        "filename": "src/Makefile.qt.include",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3140ef92493169f1f993312b4add1fb87943c7b4/src/Makefile.qt.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3140ef92493169f1f993312b4add1fb87943c7b4/src/Makefile.qt.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qt.include?ref=3140ef92493169f1f993312b4add1fb87943c7b4",
        "patch": "@@ -362,7 +362,8 @@ if ENABLE_WALLET\n qt_bitcoin_qt_LDADD += $(LIBBITCOIN_WALLET)\n endif\n qt_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CRYPTO) $(LIBBITCOIN_UNIVALUE) $(LIBLEVELDB) $(LIBMEMENV) \\\n-  $(BOOST_LIBS) $(QT_LIBS) $(QT_DBUS_LIBS) $(QR_LIBS) $(PROTOBUF_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(LIBSECP256K1)\n+  $(BOOST_LIBS) $(QT_LIBS) $(QT_DBUS_LIBS) $(QR_LIBS) $(PROTOBUF_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(LIBSECP256K1) \\\n+  $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS)\n qt_bitcoin_qt_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(QT_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n qt_bitcoin_qt_LIBTOOLFLAGS = --tag CXX\n "
      },
      {
        "sha": "4250bb8f3b27b2a49452aa4ea93e3307a9062271",
        "filename": "src/Makefile.qttest.include",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3140ef92493169f1f993312b4add1fb87943c7b4/src/Makefile.qttest.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3140ef92493169f1f993312b4add1fb87943c7b4/src/Makefile.qttest.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qttest.include?ref=3140ef92493169f1f993312b4add1fb87943c7b4",
        "patch": "@@ -32,7 +32,8 @@ qt_test_test_bitcoin_qt_LDADD += $(LIBBITCOIN_WALLET)\n endif\n qt_test_test_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CRYPTO) $(LIBBITCOIN_UNIVALUE) $(LIBLEVELDB) \\\n   $(LIBMEMENV) $(BOOST_LIBS) $(QT_DBUS_LIBS) $(QT_TEST_LIBS) $(QT_LIBS) \\\n-  $(QR_LIBS) $(PROTOBUF_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(LIBSECP256K1)\n+  $(QR_LIBS) $(PROTOBUF_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(LIBSECP256K1) \\\n+  $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS)\n qt_test_test_bitcoin_qt_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(QT_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n \n CLEAN_BITCOIN_QT_TEST = $(TEST_QT_MOC_CPP) qt/test/*.gcda qt/test/*.gcno"
      }
    ]
  },
  {
    "sha": "6e996d39da60006c47ea34e183164cbb4acd8af8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ZTk5NmQzOWRhNjAwMDZjNDdlYTM0ZTE4MzE2NGNiYjRhY2Q4YWY4",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2015-01-20T12:35:13Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-09-02T16:38:41Z"
      },
      "message": "tests: fix qt payment test\n\nNow that boost no longer automatically initializes openssl, we have to\ndo it ourselves.",
      "tree": {
        "sha": "802baca02102afbda69cd31159fd20fd4a63bc4d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/802baca02102afbda69cd31159fd20fd4a63bc4d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6e996d39da60006c47ea34e183164cbb4acd8af8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6e996d39da60006c47ea34e183164cbb4acd8af8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6e996d39da60006c47ea34e183164cbb4acd8af8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6e996d39da60006c47ea34e183164cbb4acd8af8/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3140ef92493169f1f993312b4add1fb87943c7b4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3140ef92493169f1f993312b4add1fb87943c7b4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3140ef92493169f1f993312b4add1fb87943c7b4"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 4,
      "deletions": 0
    },
    "files": [
      {
        "sha": "f91de2008c6fc10714904952020569051788be09",
        "filename": "src/qt/test/test_main.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6e996d39da60006c47ea34e183164cbb4acd8af8/src/qt/test/test_main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6e996d39da60006c47ea34e183164cbb4acd8af8/src/qt/test/test_main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/test_main.cpp?ref=6e996d39da60006c47ea34e183164cbb4acd8af8",
        "patch": "@@ -17,6 +17,8 @@\n #include <QObject>\n #include <QTest>\n \n+#include <openssl/ssl.h>\n+\n #if defined(QT_STATICPLUGIN) && QT_VERSION < 0x050000\n #include <QtPlugin>\n Q_IMPORT_PLUGIN(qcncodecs)\n@@ -36,6 +38,8 @@ int main(int argc, char *argv[])\n     QCoreApplication app(argc, argv);\n     app.setApplicationName(\"Bitcoin-Qt-test\");\n \n+    SSL_library_init();\n+\n     URITests test1;\n     if (QTest::qExec(&test1) != 0)\n         fInvalid = true;"
      }
    ]
  },
  {
    "sha": "ee2a42b447eebacc05ec4238d562b04a9a0d8462",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplZTJhNDJiNDQ3ZWViYWNjMDVlYzQyMzhkNTYyYjA0YTlhMGQ4NDYy",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-08-27T18:27:12Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-09-02T16:38:42Z"
      },
      "message": "tests: GET requests cannot have request body, use POST in rest.py\n\nSending a request body with GET request is not valid in HTTP spec, and\nnot compatible with evhttpd.",
      "tree": {
        "sha": "59becd12662cb2cefb082ad7fb9c559f9225f7be",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/59becd12662cb2cefb082ad7fb9c559f9225f7be"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ee2a42b447eebacc05ec4238d562b04a9a0d8462",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ee2a42b447eebacc05ec4238d562b04a9a0d8462",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ee2a42b447eebacc05ec4238d562b04a9a0d8462",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ee2a42b447eebacc05ec4238d562b04a9a0d8462/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6e996d39da60006c47ea34e183164cbb4acd8af8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6e996d39da60006c47ea34e183164cbb4acd8af8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6e996d39da60006c47ea34e183164cbb4acd8af8"
      }
    ],
    "stats": {
      "total": 42,
      "additions": 26,
      "deletions": 16
    },
    "files": [
      {
        "sha": "e084ad55abb4b52b96893f6fe7eb942103d9dcb4",
        "filename": "qa/rpc-tests/rest.py",
        "status": "modified",
        "additions": 26,
        "deletions": 16,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ee2a42b447eebacc05ec4238d562b04a9a0d8462/qa/rpc-tests/rest.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ee2a42b447eebacc05ec4238d562b04a9a0d8462/qa/rpc-tests/rest.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/rest.py?ref=ee2a42b447eebacc05ec4238d562b04a9a0d8462",
        "patch": "@@ -32,10 +32,20 @@ def deser_uint256(f):\n         r += t << (i * 32)\n     return r\n \n-#allows simple http get calls with a request body\n-def http_get_call(host, port, path, requestdata = '', response_object = 0):\n+#allows simple http get calls\n+def http_get_call(host, port, path, response_object = 0):\n     conn = httplib.HTTPConnection(host, port)\n-    conn.request('GET', path, requestdata)\n+    conn.request('GET', path)\n+\n+    if response_object:\n+        return conn.getresponse()\n+\n+    return conn.getresponse().read()\n+\n+#allows simple http post calls with a request body\n+def http_post_call(host, port, path, requestdata = '', response_object = 0):\n+    conn = httplib.HTTPConnection(host, port)\n+    conn.request('POST', path, requestdata)\n \n     if response_object:\n         return conn.getresponse()\n@@ -137,7 +147,7 @@ def run_test(self):\n         binaryRequest += binascii.unhexlify(vintx);\n         binaryRequest += pack(\"i\", 0);\n \n-        bin_response = http_get_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'bin', binaryRequest)\n+        bin_response = http_post_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'bin', binaryRequest)\n         output = StringIO.StringIO()\n         output.write(bin_response)\n         output.seek(0)\n@@ -175,29 +185,29 @@ def run_test(self):\n \n         #do some invalid requests\n         json_request = '{\"checkmempool'\n-        response = http_get_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'json', json_request, True)\n+        response = http_post_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'json', json_request, True)\n         assert_equal(response.status, 500) #must be a 500 because we send a invalid json request\n \n         json_request = '{\"checkmempool'\n-        response = http_get_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'bin', json_request, True)\n+        response = http_post_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'bin', json_request, True)\n         assert_equal(response.status, 500) #must be a 500 because we send a invalid bin request\n \n-        response = http_get_call(url.hostname, url.port, '/rest/getutxos/checkmempool'+self.FORMAT_SEPARATOR+'bin', '', True)\n+        response = http_post_call(url.hostname, url.port, '/rest/getutxos/checkmempool'+self.FORMAT_SEPARATOR+'bin', '', True)\n         assert_equal(response.status, 500) #must be a 500 because we send a invalid bin request\n \n         #test limits\n         json_request = '/checkmempool/'\n         for x in range(0, 20):\n             json_request += txid+'-'+str(n)+'/'\n         json_request = json_request.rstrip(\"/\")\n-        response = http_get_call(url.hostname, url.port, '/rest/getutxos'+json_request+self.FORMAT_SEPARATOR+'json', '', True)\n+        response = http_post_call(url.hostname, url.port, '/rest/getutxos'+json_request+self.FORMAT_SEPARATOR+'json', '', True)\n         assert_equal(response.status, 500) #must be a 500 because we exceeding the limits\n \n         json_request = '/checkmempool/'\n         for x in range(0, 15):\n             json_request += txid+'-'+str(n)+'/'\n         json_request = json_request.rstrip(\"/\");\n-        response = http_get_call(url.hostname, url.port, '/rest/getutxos'+json_request+self.FORMAT_SEPARATOR+'json', '', True)\n+        response = http_post_call(url.hostname, url.port, '/rest/getutxos'+json_request+self.FORMAT_SEPARATOR+'json', '', True)\n         assert_equal(response.status, 200) #must be a 500 because we exceeding the limits\n \n         self.nodes[0].generate(1) #generate block to not affect upcoming tests\n@@ -208,27 +218,27 @@ def run_test(self):\n         ################\n \n         # check binary format\n-        response = http_get_call(url.hostname, url.port, '/rest/block/'+bb_hash+self.FORMAT_SEPARATOR+\"bin\", \"\", True)\n+        response = http_get_call(url.hostname, url.port, '/rest/block/'+bb_hash+self.FORMAT_SEPARATOR+\"bin\", True)\n         assert_equal(response.status, 200)\n         assert_greater_than(int(response.getheader('content-length')), 80)\n         response_str = response.read()\n \n         # compare with block header\n-        response_header = http_get_call(url.hostname, url.port, '/rest/headers/1/'+bb_hash+self.FORMAT_SEPARATOR+\"bin\", \"\", True)\n+        response_header = http_get_call(url.hostname, url.port, '/rest/headers/1/'+bb_hash+self.FORMAT_SEPARATOR+\"bin\", True)\n         assert_equal(response_header.status, 200)\n         assert_equal(int(response_header.getheader('content-length')), 80)\n         response_header_str = response_header.read()\n         assert_equal(response_str[0:80], response_header_str)\n \n         # check block hex format\n-        response_hex = http_get_call(url.hostname, url.port, '/rest/block/'+bb_hash+self.FORMAT_SEPARATOR+\"hex\", \"\", True)\n+        response_hex = http_get_call(url.hostname, url.port, '/rest/block/'+bb_hash+self.FORMAT_SEPARATOR+\"hex\", True)\n         assert_equal(response_hex.status, 200)\n         assert_greater_than(int(response_hex.getheader('content-length')), 160)\n         response_hex_str = response_hex.read()\n         assert_equal(response_str.encode(\"hex\")[0:160], response_hex_str[0:160])\n \n         # compare with hex block header\n-        response_header_hex = http_get_call(url.hostname, url.port, '/rest/headers/1/'+bb_hash+self.FORMAT_SEPARATOR+\"hex\", \"\", True)\n+        response_header_hex = http_get_call(url.hostname, url.port, '/rest/headers/1/'+bb_hash+self.FORMAT_SEPARATOR+\"hex\", True)\n         assert_equal(response_header_hex.status, 200)\n         assert_greater_than(int(response_header_hex.getheader('content-length')), 160)\n         response_header_hex_str = response_header_hex.read()\n@@ -241,7 +251,7 @@ def run_test(self):\n         assert_equal(block_json_obj['hash'], bb_hash)\n \n         # compare with json block header\n-        response_header_json = http_get_call(url.hostname, url.port, '/rest/headers/1/'+bb_hash+self.FORMAT_SEPARATOR+\"json\", \"\", True)\n+        response_header_json = http_get_call(url.hostname, url.port, '/rest/headers/1/'+bb_hash+self.FORMAT_SEPARATOR+\"json\", True)\n         assert_equal(response_header_json.status, 200)\n         response_header_json_str = response_header_json.read()\n         json_obj = json.loads(response_header_json_str, parse_float=decimal.Decimal)\n@@ -265,7 +275,7 @@ def run_test(self):\n         #see if we can get 5 headers in one response\n         self.nodes[1].generate(5)\n         self.sync_all()\n-        response_header_json = http_get_call(url.hostname, url.port, '/rest/headers/5/'+bb_hash+self.FORMAT_SEPARATOR+\"json\", \"\", True)\n+        response_header_json = http_get_call(url.hostname, url.port, '/rest/headers/5/'+bb_hash+self.FORMAT_SEPARATOR+\"json\", True)\n         assert_equal(response_header_json.status, 200)\n         response_header_json_str = response_header_json.read()\n         json_obj = json.loads(response_header_json_str)\n@@ -278,7 +288,7 @@ def run_test(self):\n         assert_equal(json_obj['txid'], tx_hash)\n \n         # check hex format response\n-        hex_string = http_get_call(url.hostname, url.port, '/rest/tx/'+tx_hash+self.FORMAT_SEPARATOR+\"hex\", \"\", True)\n+        hex_string = http_get_call(url.hostname, url.port, '/rest/tx/'+tx_hash+self.FORMAT_SEPARATOR+\"hex\", True)\n         assert_equal(hex_string.status, 200)\n         assert_greater_than(int(response.getheader('content-length')), 10)\n "
      }
    ]
  },
  {
    "sha": "40b556d3742a1f65d67e2d4c760d0b13fe8be5b7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MGI1NTZkMzc0MmExZjY1ZDY3ZTJkNGM3NjBkMGIxM2ZlOGJlNWI3",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-01-23T06:53:17Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-09-03T08:59:18Z"
      },
      "message": "evhttpd implementation\n\n- *Replace usage of boost::asio with [libevent2](http://libevent.org/)*.\nboost::asio is not part of C++11, so unlike other boost there is no\nforwards-compatibility reason to stick with it. Together with #4738 (convert\njson_spirit to UniValue), this rids Bitcoin Core of the worst offenders with\nregard to compile-time slowness.\n\n- *Replace spit-and-duct-tape http server with evhttp*. Front-end http handling\nis handled by libevent, a work queue (with configurable depth and parallelism)\nis used to handle application requests.\n\n- *Wrap HTTP request in C++ class*; this makes the application code mostly\nHTTP-server-neutral\n\n- *Refactor RPC to move all http-specific code to a separate file*.\nTheoreticaly this can allow building without HTTP server but with another RPC\nbackend, e.g. Qt's debug console (currently not implemented) or future RPC\nmechanisms people may want to use.\n\n- *HTTP dispatch mechanism*; services (e.g., RPC, REST) register which URL\npaths they want to handle.\n\nBy using a proven, high-performance asynchronous networking library (also used\nby Tor) and HTTP server, problems such as #5674, #5655, #344 should be avoided.\n\nWhat works? bitcoind, bitcoin-cli, bitcoin-qt. Unit tests and RPC/REST tests\npass. The aim for now is everything but SSL support.\n\nConfiguration options:\n\n- `-rpcthreads`: repurposed as \"number of  work handler threads\". Still\ndefaults to 4.\n\n- `-rpcworkqueue`: maximum depth of work queue. When this is reached, new\nrequests will return a 500 Internal Error.\n\n- `-rpctimeout`: inactivity time, in seconds, after which to disconnect a\nclient.\n\n- `-debug=http`: low-level http activity logging",
      "tree": {
        "sha": "2a8117475070db6a8498201f7bee6cc85f2606ad",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2a8117475070db6a8498201f7bee6cc85f2606ad"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ee2a42b447eebacc05ec4238d562b04a9a0d8462",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ee2a42b447eebacc05ec4238d562b04a9a0d8462",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ee2a42b447eebacc05ec4238d562b04a9a0d8462"
      }
    ],
    "stats": {
      "total": 2348,
      "additions": 1299,
      "deletions": 1049
    },
    "files": [
      {
        "sha": "4dfd56626c83c912a831ead0c8939129157f6544",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=40b556d3742a1f65d67e2d4c760d0b13fe8be5b7",
        "patch": "@@ -98,6 +98,8 @@ BITCOIN_CORE_H = \\\n   eccryptoverify.h \\\n   ecwrapper.h \\\n   hash.h \\\n+  httprpc.h \\\n+  httpserver.h \\\n   init.h \\\n   key.h \\\n   keystore.h \\\n@@ -170,6 +172,8 @@ libbitcoin_server_a_SOURCES = \\\n   bloom.cpp \\\n   chain.cpp \\\n   checkpoints.cpp \\\n+  httprpc.cpp \\\n+  httpserver.cpp \\\n   init.cpp \\\n   leveldbwrapper.cpp \\\n   main.cpp \\"
      },
      {
        "sha": "2e094fde227afb122b7b3d1953fe7bfafacdcdd0",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 93,
        "deletions": 40,
        "changes": 133,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=40b556d3742a1f65d67e2d4c760d0b13fe8be5b7",
        "patch": "@@ -11,6 +11,12 @@\n #include \"utilstrencodings.h\"\n \n #include <boost/filesystem/operations.hpp>\n+#include <stdio.h>\n+\n+#include <event2/event.h>\n+#include <event2/http.h>\n+#include <event2/buffer.h>\n+#include <event2/keyvalq_struct.h>\n \n #include \"univalue/univalue.h\"\n \n@@ -32,9 +38,6 @@ std::string HelpMessageCli()\n     strUsage += HelpMessageOpt(\"-rpcuser=<user>\", _(\"Username for JSON-RPC connections\"));\n     strUsage += HelpMessageOpt(\"-rpcpassword=<pw>\", _(\"Password for JSON-RPC connections\"));\n \n-    strUsage += HelpMessageGroup(_(\"SSL options: (see the Bitcoin Wiki for SSL setup instructions)\"));\n-    strUsage += HelpMessageOpt(\"-rpcssl\", _(\"Use OpenSSL (https) for JSON-RPC connections\"));\n-\n     return strUsage;\n }\n \n@@ -92,67 +95,117 @@ static bool AppInitRPC(int argc, char* argv[])\n         fprintf(stderr, \"Error: Invalid combination of -regtest and -testnet.\\n\");\n         return false;\n     }\n+    if (GetBoolArg(\"-rpcssl\", false))\n+    {\n+        fprintf(stderr, \"Error: SSL mode for RPC (-rpcssl) is no longer supported.\\n\");\n+        return false;\n+    }\n     return true;\n }\n \n-UniValue CallRPC(const string& strMethod, const UniValue& params)\n+\n+/** Reply structure for request_done to fill in */\n+struct HTTPReply\n {\n-    // Connect to localhost\n-    bool fUseSSL = GetBoolArg(\"-rpcssl\", false);\n-    boost::asio::io_service io_service;\n-    boost::asio::ssl::context context(io_service, boost::asio::ssl::context::sslv23);\n-    context.set_options(boost::asio::ssl::context::no_sslv2 | boost::asio::ssl::context::no_sslv3);\n-    boost::asio::ssl::stream<boost::asio::ip::tcp::socket> sslStream(io_service, context);\n-    SSLIOStreamDevice<boost::asio::ip::tcp> d(sslStream, fUseSSL);\n-    boost::iostreams::stream< SSLIOStreamDevice<boost::asio::ip::tcp> > stream(d);\n-\n-    const bool fConnected = d.connect(GetArg(\"-rpcconnect\", \"127.0.0.1\"), GetArg(\"-rpcport\", itostr(BaseParams().RPCPort())));\n-    if (!fConnected)\n-        throw CConnectionFailed(\"couldn't connect to server\");\n+    int status;\n+    std::string body;\n+};\n+\n+static void http_request_done(struct evhttp_request *req, void *ctx)\n+{\n+    HTTPReply *reply = static_cast<HTTPReply*>(ctx);\n+\n+    if (req == NULL) {\n+        /* If req is NULL, it means an error occurred while connecting, but\n+         * I'm not sure how to find out which one. We also don't really care.\n+         */\n+        reply->status = 0;\n+        return;\n+    }\n \n-    // Find credentials to use\n+    reply->status = evhttp_request_get_response_code(req);\n+\n+    struct evbuffer *buf = evhttp_request_get_input_buffer(req);\n+    if (buf)\n+    {\n+        size_t size = evbuffer_get_length(buf);\n+        const char *data = (const char*)evbuffer_pullup(buf, size);\n+        if (data)\n+            reply->body = std::string(data, size);\n+        evbuffer_drain(buf, size);\n+    }\n+}\n+\n+UniValue CallRPC(const string& strMethod, const UniValue& params)\n+{\n+    std::string host = GetArg(\"-rpcconnect\", \"127.0.0.1\");\n+    int port = GetArg(\"-rpcport\", BaseParams().RPCPort());\n+\n+    // Create event base\n+    struct event_base *base = event_base_new(); // TODO RAII\n+    if (!base)\n+        throw runtime_error(\"cannot create event_base\");\n+\n+    // Synchronously look up hostname\n+    struct evhttp_connection *evcon = evhttp_connection_base_new(base, NULL, host.c_str(), port); // TODO RAII\n+    if (evcon == NULL)\n+        throw runtime_error(\"create connection failed\");\n+    evhttp_connection_set_timeout(evcon, GetArg(\"-rpctimeout\", 30));\n+\n+    HTTPReply response;\n+    struct evhttp_request *req = evhttp_request_new(http_request_done, (void*)&response); // TODO RAII\n+    if (req == NULL)\n+        throw runtime_error(\"create http request failed\");\n+\n+    // Get credentials\n     std::string strRPCUserColonPass;\n     if (mapArgs[\"-rpcpassword\"] == \"\") {\n         // Try fall back to cookie-based authentication if no password is provided\n         if (!GetAuthCookie(&strRPCUserColonPass)) {\n             throw runtime_error(strprintf(\n-                _(\"You must set rpcpassword=<password> in the configuration file:\\n%s\\n\"\n-                  \"If the file does not exist, create it with owner-readable-only file permissions.\"),\n+                _(\"Could not locate RPC credentials. No authentication cookie could be found, and no rpcpassword is set in the configuration file (%s)\"),\n                     GetConfigFile().string().c_str()));\n \n         }\n     } else {\n         strRPCUserColonPass = mapArgs[\"-rpcuser\"] + \":\" + mapArgs[\"-rpcpassword\"];\n     }\n \n-    // HTTP basic authentication\n-    map<string, string> mapRequestHeaders;\n-    mapRequestHeaders[\"Authorization\"] = string(\"Basic \") + EncodeBase64(strRPCUserColonPass);\n-\n-    // Send request\n-    string strRequest = JSONRPCRequest(strMethod, params, 1);\n-    string strPost = HTTPPost(strRequest, mapRequestHeaders);\n-    stream << strPost << std::flush;\n-\n-    // Receive HTTP reply status\n-    int nProto = 0;\n-    int nStatus = ReadHTTPStatus(stream, nProto);\n+    struct evkeyvalq *output_headers = evhttp_request_get_output_headers(req);\n+    assert(output_headers);\n+    evhttp_add_header(output_headers, \"Host\", host.c_str());\n+    evhttp_add_header(output_headers, \"Connection\", \"close\");\n+    evhttp_add_header(output_headers, \"Authorization\", (std::string(\"Basic \") + EncodeBase64(strRPCUserColonPass)).c_str());\n+\n+    // Attach request data\n+    std::string strRequest = JSONRPCRequest(strMethod, params, 1);\n+    struct evbuffer * output_buffer = evhttp_request_get_output_buffer(req);\n+    assert(output_buffer);\n+    evbuffer_add(output_buffer, strRequest.data(), strRequest.size());\n+\n+    int r = evhttp_make_request(evcon, req, EVHTTP_REQ_POST, \"/\");\n+    if (r != 0) {\n+        evhttp_connection_free(evcon);\n+        event_base_free(base);\n+        throw CConnectionFailed(\"send http request failed\");\n+    }\n \n-    // Receive HTTP reply message headers and body\n-    map<string, string> mapHeaders;\n-    string strReply;\n-    ReadHTTPMessage(stream, mapHeaders, strReply, nProto, std::numeric_limits<size_t>::max());\n+    event_base_dispatch(base);\n+    evhttp_connection_free(evcon);\n+    event_base_free(base);\n \n-    if (nStatus == HTTP_UNAUTHORIZED)\n+    if (response.status == 0)\n+        throw CConnectionFailed(\"couldn't connect to server\");\n+    else if (response.status == HTTP_UNAUTHORIZED)\n         throw runtime_error(\"incorrect rpcuser or rpcpassword (authorization failed)\");\n-    else if (nStatus >= 400 && nStatus != HTTP_BAD_REQUEST && nStatus != HTTP_NOT_FOUND && nStatus != HTTP_INTERNAL_SERVER_ERROR)\n-        throw runtime_error(strprintf(\"server returned HTTP error %d\", nStatus));\n-    else if (strReply.empty())\n+    else if (response.status >= 400 && response.status != HTTP_BAD_REQUEST && response.status != HTTP_NOT_FOUND && response.status != HTTP_INTERNAL_SERVER_ERROR)\n+        throw runtime_error(strprintf(\"server returned HTTP error %d\", response.status));\n+    else if (response.body.empty())\n         throw runtime_error(\"no response from server\");\n \n     // Parse reply\n     UniValue valReply(UniValue::VSTR);\n-    if (!valReply.read(strReply))\n+    if (!valReply.read(response.body))\n         throw runtime_error(\"couldn't parse reply from server\");\n     const UniValue& reply = valReply.get_obj();\n     if (reply.empty())"
      },
      {
        "sha": "b512f74c227003c3393aa099f4c4fe3cba55f818",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 2,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=40b556d3742a1f65d67e2d4c760d0b13fe8be5b7",
        "patch": "@@ -10,11 +10,16 @@\n #include \"noui.h\"\n #include \"scheduler.h\"\n #include \"util.h\"\n+#include \"httpserver.h\"\n+#include \"httprpc.h\"\n+#include \"rpcserver.h\"\n \n #include <boost/algorithm/string/predicate.hpp>\n #include <boost/filesystem.hpp>\n #include <boost/thread.hpp>\n \n+#include <stdio.h>\n+\n /* Introduction text for doxygen: */\n \n /*! \\mainpage Developer documentation\n@@ -44,7 +49,7 @@ void WaitForShutdown(boost::thread_group* threadGroup)\n     }\n     if (threadGroup)\n     {\n-        threadGroup->interrupt_all();\n+        Interrupt(*threadGroup);\n         threadGroup->join_all();\n     }\n }\n@@ -154,7 +159,7 @@ bool AppInit(int argc, char* argv[])\n \n     if (!fRet)\n     {\n-        threadGroup.interrupt_all();\n+        Interrupt(threadGroup);\n         // threadGroup.join_all(); was left out intentionally here, because we didn't re-test all of\n         // the startup-failure cases to make sure they don't result in a hang due to some\n         // thread-blocking-waiting-for-another-thread-during-startup case"
      },
      {
        "sha": "570beadc5f5e1fc555ce765cbed2fb99f86d9b4d",
        "filename": "src/httprpc.cpp",
        "status": "added",
        "additions": 201,
        "deletions": 0,
        "changes": 201,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/httprpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/httprpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httprpc.cpp?ref=40b556d3742a1f65d67e2d4c760d0b13fe8be5b7",
        "patch": "@@ -0,0 +1,201 @@\n+#include \"httprpc.h\"\n+\n+#include \"base58.h\"\n+#include \"chainparams.h\"\n+#include \"httpserver.h\"\n+#include \"rpcprotocol.h\"\n+#include \"rpcserver.h\"\n+#include \"random.h\"\n+#include \"sync.h\"\n+#include \"util.h\"\n+#include \"utilstrencodings.h\"\n+#include \"ui_interface.h\"\n+\n+#include <boost/algorithm/string.hpp> // boost::trim\n+\n+/** Simple one-shot callback timer to be used by the RPC mechanism to e.g.\n+ * re-lock the wellet.\n+ */\n+class HTTPRPCTimer : public RPCTimerBase\n+{\n+public:\n+    HTTPRPCTimer(struct event_base* eventBase, boost::function<void(void)>& func, int64_t seconds) : ev(eventBase, false, new Handler(func))\n+    {\n+        struct timeval tv = {seconds, 0};\n+        ev.trigger(&tv);\n+    }\n+private:\n+    HTTPEvent ev;\n+\n+    class Handler : public HTTPClosure\n+    {\n+    public:\n+        Handler(const boost::function<void(void)>& func) : func(func)\n+        {\n+        }\n+    private:\n+        boost::function<void(void)> func;\n+        void operator()() { func(); }\n+    };\n+};\n+\n+class HTTPRPCTimerInterface : public RPCTimerInterface\n+{\n+public:\n+    HTTPRPCTimerInterface(struct event_base* base) : base(base)\n+    {\n+    }\n+    const char* Name()\n+    {\n+        return \"HTTP\";\n+    }\n+    RPCTimerBase* NewTimer(boost::function<void(void)>& func, int64_t seconds)\n+    {\n+        return new HTTPRPCTimer(base, func, seconds);\n+    }\n+private:\n+    struct event_base* base;\n+};\n+\n+\n+/* Pre-base64-encoded authentication token */\n+static std::string strRPCUserColonPass;\n+/* Stored RPC timer interface (for unregistration) */\n+static HTTPRPCTimerInterface* httpRPCTimerInterface = 0;\n+\n+static void JSONErrorReply(HTTPRequest* req, const UniValue& objError, const UniValue& id)\n+{\n+    // Send error reply from json-rpc error object\n+    int nStatus = HTTP_INTERNAL_SERVER_ERROR;\n+    int code = find_value(objError, \"code\").get_int();\n+\n+    if (code == RPC_INVALID_REQUEST)\n+        nStatus = HTTP_BAD_REQUEST;\n+    else if (code == RPC_METHOD_NOT_FOUND)\n+        nStatus = HTTP_NOT_FOUND;\n+\n+    std::string strReply = JSONRPCReply(NullUniValue, objError, id);\n+\n+    req->WriteHeader(\"Content-Type\", \"application/json\");\n+    req->WriteReply(nStatus, strReply);\n+}\n+\n+static bool RPCAuthorized(const std::string& strAuth)\n+{\n+    if (strRPCUserColonPass.empty()) // Belt-and-suspenders measure if InitRPCAuthentication was not called\n+        return false;\n+    if (strAuth.substr(0, 6) != \"Basic \")\n+        return false;\n+    std::string strUserPass64 = strAuth.substr(6);\n+    boost::trim(strUserPass64);\n+    std::string strUserPass = DecodeBase64(strUserPass64);\n+    return TimingResistantEqual(strUserPass, strRPCUserColonPass);\n+}\n+\n+static bool HTTPReq_JSONRPC(HTTPRequest* req, const std::string &)\n+{\n+    // JSONRPC handles only POST\n+    if (req->GetRequestMethod() != HTTPRequest::POST) {\n+        req->WriteReply(HTTP_BAD_METHOD, \"JSONRPC server handles only POST requests\");\n+        return false;\n+    }\n+    // Check authorization\n+    std::pair<bool, std::string> authHeader = req->GetHeader(\"authorization\");\n+    if (!authHeader.first) {\n+        req->WriteReply(HTTP_UNAUTHORIZED);\n+        return false;\n+    }\n+\n+    if (!RPCAuthorized(authHeader.second)) {\n+        LogPrintf(\"ThreadRPCServer incorrect password attempt from %s\\n\", req->GetPeer().ToString());\n+\n+        /* Deter brute-forcing\n+           If this results in a DoS the user really\n+           shouldn't have their RPC port exposed. */\n+        MilliSleep(250);\n+\n+        req->WriteReply(HTTP_UNAUTHORIZED);\n+        return false;\n+    }\n+\n+    JSONRequest jreq;\n+    try {\n+        // Parse request\n+        UniValue valRequest;\n+        if (!valRequest.read(req->ReadBody()))\n+            throw JSONRPCError(RPC_PARSE_ERROR, \"Parse error\");\n+\n+        std::string strReply;\n+        // singleton request\n+        if (valRequest.isObject()) {\n+            jreq.parse(valRequest);\n+\n+            UniValue result = tableRPC.execute(jreq.strMethod, jreq.params);\n+\n+            // Send reply\n+            strReply = JSONRPCReply(result, NullUniValue, jreq.id);\n+\n+        // array of requests\n+        } else if (valRequest.isArray())\n+            strReply = JSONRPCExecBatch(valRequest.get_array());\n+        else\n+            throw JSONRPCError(RPC_PARSE_ERROR, \"Top-level object parse error\");\n+\n+        req->WriteHeader(\"Content-Type\", \"application/json\");\n+        req->WriteReply(HTTP_OK, strReply);\n+    } catch (const UniValue& objError) {\n+        JSONErrorReply(req, objError, jreq.id);\n+        return false;\n+    } catch (const std::exception& e) {\n+        JSONErrorReply(req, JSONRPCError(RPC_PARSE_ERROR, e.what()), jreq.id);\n+        return false;\n+    }\n+    return true;\n+}\n+\n+static bool InitRPCAuthentication()\n+{\n+    if (mapArgs[\"-rpcpassword\"] == \"\")\n+    {\n+        LogPrintf(\"No rpcpassword set - using random cookie authentication\\n\");\n+        if (!GenerateAuthCookie(&strRPCUserColonPass)) {\n+            uiInterface.ThreadSafeMessageBox(\n+                _(\"Error: A fatal internal error occurred, see debug.log for details\"), // Same message as AbortNode\n+                \"\", CClientUIInterface::MSG_ERROR);\n+            return false;\n+        }\n+    } else {\n+        strRPCUserColonPass = mapArgs[\"-rpcuser\"] + \":\" + mapArgs[\"-rpcpassword\"];\n+    }\n+    return true;\n+}\n+\n+bool StartHTTPRPC()\n+{\n+    LogPrint(\"rpc\", \"Starting HTTP RPC server\\n\");\n+    if (!InitRPCAuthentication())\n+        return false;\n+\n+    RegisterHTTPHandler(\"/\", true, HTTPReq_JSONRPC);\n+\n+    assert(EventBase());\n+    httpRPCTimerInterface = new HTTPRPCTimerInterface(EventBase());\n+    RPCRegisterTimerInterface(httpRPCTimerInterface);\n+    return true;\n+}\n+\n+void InterruptHTTPRPC()\n+{\n+    LogPrint(\"rpc\", \"Interrupting HTTP RPC server\\n\");\n+}\n+\n+void StopHTTPRPC()\n+{\n+    LogPrint(\"rpc\", \"Stopping HTTP RPC server\\n\");\n+    UnregisterHTTPHandler(\"/\", true);\n+    if (httpRPCTimerInterface) {\n+        RPCUnregisterTimerInterface(httpRPCTimerInterface);\n+        delete httpRPCTimerInterface;\n+        httpRPCTimerInterface = 0;\n+    }\n+}"
      },
      {
        "sha": "d35445718871ee6339ece7caf1c0c3cdc3872f4f",
        "filename": "src/httprpc.h",
        "status": "added",
        "additions": 37,
        "deletions": 0,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/httprpc.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/httprpc.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httprpc.h?ref=40b556d3742a1f65d67e2d4c760d0b13fe8be5b7",
        "patch": "@@ -0,0 +1,37 @@\n+// Copyright (c) 2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_HTTPRPC_H\n+#define BITCOIN_HTTPRPC_H\n+\n+#include <string>\n+#include <map>\n+\n+class HTTPRequest;\n+\n+/** Start HTTP RPC subsystem.\n+ * Precondition; HTTP and RPC has been started.\n+ */\n+bool StartHTTPRPC();\n+/** Interrupt HTTP RPC subsystem.\n+ */\n+void InterruptHTTPRPC();\n+/** Stop HTTP RPC subsystem.\n+ * Precondition; HTTP and RPC has been stopped.\n+ */\n+void StopHTTPRPC();\n+\n+/** Start HTTP REST subsystem.\n+ * Precondition; HTTP and RPC has been started.\n+ */\n+bool StartREST();\n+/** Interrupt RPC REST subsystem.\n+ */\n+void InterruptREST();\n+/** Stop HTTP REST subsystem.\n+ * Precondition; HTTP and RPC has been stopped.\n+ */\n+void StopREST();\n+\n+#endif"
      },
      {
        "sha": "89366b2e4e9084fa8fc2dded3fb10df13bf08d3e",
        "filename": "src/httpserver.cpp",
        "status": "added",
        "additions": 586,
        "deletions": 0,
        "changes": 586,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/httpserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/httpserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.cpp?ref=40b556d3742a1f65d67e2d4c760d0b13fe8be5b7",
        "patch": "@@ -0,0 +1,586 @@\n+// Copyright (c) 2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"httpserver.h\"\n+\n+#include \"chainparamsbase.h\"\n+#include \"compat.h\"\n+#include \"util.h\"\n+#include \"netbase.h\"\n+#include \"rpcprotocol.h\" // For HTTP status codes\n+#include \"sync.h\"\n+#include \"ui_interface.h\"\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <signal.h>\n+\n+#include <event2/event.h>\n+#include <event2/http.h>\n+#include <event2/thread.h>\n+#include <event2/buffer.h>\n+#include <event2/util.h>\n+#include <event2/keyvalq_struct.h>\n+\n+#ifdef EVENT__HAVE_NETINET_IN_H\n+#include <netinet/in.h>\n+#ifdef _XOPEN_SOURCE_EXTENDED\n+#include <arpa/inet.h>\n+#endif\n+#endif\n+\n+#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n+#include <boost/foreach.hpp>\n+#include <boost/scoped_ptr.hpp>\n+\n+/** HTTP request work item */\n+class HTTPWorkItem : public HTTPClosure\n+{\n+public:\n+    HTTPWorkItem(HTTPRequest* req, const std::string &path, const HTTPRequestHandler& func):\n+        req(req), path(path), func(func)\n+    {\n+    }\n+    void operator()()\n+    {\n+        func(req.get(), path);\n+    }\n+\n+    boost::scoped_ptr<HTTPRequest> req;\n+\n+private:\n+    std::string path;\n+    HTTPRequestHandler func;\n+};\n+\n+/** Simple work queue for distributing work over multiple threads.\n+ * Work items are simply callable objects.\n+ */\n+template <typename WorkItem>\n+class WorkQueue\n+{\n+private:\n+    /** Mutex protects entire object */\n+    CWaitableCriticalSection cs;\n+    CConditionVariable cond;\n+    /* XXX in C++11 we can use std::unique_ptr here and avoid manual cleanup */\n+    std::deque<WorkItem*> queue;\n+    bool running;\n+    size_t maxDepth;\n+\n+public:\n+    WorkQueue(size_t maxDepth) : running(true),\n+                                 maxDepth(maxDepth)\n+    {\n+    }\n+    /* Precondition: worker threads have all stopped */\n+    ~WorkQueue()\n+    {\n+        while (!queue.empty()) {\n+            delete queue.front();\n+            queue.pop_front();\n+        }\n+    }\n+    /** Enqueue a work item */\n+    bool Enqueue(WorkItem* item)\n+    {\n+        boost::unique_lock<boost::mutex> lock(cs);\n+        if (queue.size() >= maxDepth) {\n+            return false;\n+        }\n+        queue.push_back(item);\n+        cond.notify_one();\n+        return true;\n+    }\n+    /** Thread function */\n+    void Run()\n+    {\n+        while (running) {\n+            WorkItem* i = 0;\n+            {\n+                boost::unique_lock<boost::mutex> lock(cs);\n+                while (running && queue.empty())\n+                    cond.wait(lock);\n+                if (!running)\n+                    break;\n+                i = queue.front();\n+                queue.pop_front();\n+            }\n+            (*i)();\n+            delete i;\n+        }\n+    }\n+    /** Interrupt and exit loops */\n+    void Interrupt()\n+    {\n+        boost::unique_lock<boost::mutex> lock(cs);\n+        running = false;\n+        cond.notify_all();\n+    }\n+\n+    /** Return current depth of queue */\n+    size_t Depth()\n+    {\n+        boost::unique_lock<boost::mutex> lock(cs);\n+        return queue.size();\n+    }\n+};\n+\n+struct HTTPPathHandler\n+{\n+    HTTPPathHandler() {}\n+    HTTPPathHandler(std::string prefix, bool exactMatch, HTTPRequestHandler handler):\n+        prefix(prefix), exactMatch(exactMatch), handler(handler)\n+    {\n+    }\n+    std::string prefix;\n+    bool exactMatch;\n+    HTTPRequestHandler handler;\n+};\n+\n+/** HTTP module state */\n+\n+//! libevent event loop\n+static struct event_base* eventBase = 0;\n+//! HTTP server\n+struct evhttp* eventHTTP = 0;\n+//! List of subnets to allow RPC connections from\n+static std::vector<CSubNet> rpc_allow_subnets;\n+//! Work queue for handling longer requests off the event loop thread\n+static WorkQueue<HTTPClosure>* workQueue = 0;\n+//! Handlers for (sub)paths\n+std::vector<HTTPPathHandler> pathHandlers;\n+\n+/** Check if a network address is allowed to access the HTTP server */\n+static bool ClientAllowed(const CNetAddr& netaddr)\n+{\n+    if (!netaddr.IsValid())\n+        return false;\n+    BOOST_FOREACH (const CSubNet& subnet, rpc_allow_subnets)\n+        if (subnet.Match(netaddr))\n+            return true;\n+    return false;\n+}\n+\n+/** Initialize ACL list for HTTP server */\n+static bool InitHTTPAllowList()\n+{\n+    rpc_allow_subnets.clear();\n+    rpc_allow_subnets.push_back(CSubNet(\"127.0.0.0/8\")); // always allow IPv4 local subnet\n+    rpc_allow_subnets.push_back(CSubNet(\"::1\"));         // always allow IPv6 localhost\n+    if (mapMultiArgs.count(\"-rpcallowip\")) {\n+        const std::vector<std::string>& vAllow = mapMultiArgs[\"-rpcallowip\"];\n+        BOOST_FOREACH (std::string strAllow, vAllow) {\n+            CSubNet subnet(strAllow);\n+            if (!subnet.IsValid()) {\n+                uiInterface.ThreadSafeMessageBox(\n+                    strprintf(\"Invalid -rpcallowip subnet specification: %s. Valid are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24).\", strAllow),\n+                    \"\", CClientUIInterface::MSG_ERROR);\n+                return false;\n+            }\n+            rpc_allow_subnets.push_back(subnet);\n+        }\n+    }\n+    std::string strAllowed;\n+    BOOST_FOREACH (const CSubNet& subnet, rpc_allow_subnets)\n+        strAllowed += subnet.ToString() + \" \";\n+    LogPrint(\"http\", \"Allowing HTTP connections from: %s\\n\", strAllowed);\n+    return true;\n+}\n+\n+/** HTTP request method as string - use for logging only */\n+static std::string RequestMethodString(HTTPRequest::RequestMethod m)\n+{\n+    switch (m) {\n+    case HTTPRequest::GET:\n+        return \"GET\";\n+        break;\n+    case HTTPRequest::POST:\n+        return \"POST\";\n+        break;\n+    case HTTPRequest::HEAD:\n+        return \"HEAD\";\n+        break;\n+    case HTTPRequest::PUT:\n+        return \"PUT\";\n+        break;\n+    default:\n+        return \"unknown\";\n+    }\n+}\n+\n+/** HTTP request callback */\n+static void http_request_cb(struct evhttp_request* req, void* arg)\n+{\n+    std::auto_ptr<HTTPRequest> hreq(new HTTPRequest(req));\n+\n+    LogPrint(\"http\", \"Received a %s request for %s from %s\\n\",\n+             RequestMethodString(hreq->GetRequestMethod()), hreq->GetURI(), hreq->GetPeer().ToString());\n+\n+    // Early address-based allow check\n+    if (!ClientAllowed(hreq->GetPeer())) {\n+        hreq->WriteReply(HTTP_FORBIDDEN);\n+        return;\n+    }\n+\n+    // Early reject unknown HTTP methods\n+    if (hreq->GetRequestMethod() == HTTPRequest::UNKNOWN) {\n+        hreq->WriteReply(HTTP_BADMETHOD);\n+        return;\n+    }\n+\n+    // Find registered handler for prefix\n+    std::string strURI = hreq->GetURI();\n+    std::string path;\n+    std::vector<HTTPPathHandler>::const_iterator i = pathHandlers.begin();\n+    std::vector<HTTPPathHandler>::const_iterator iend = pathHandlers.end();\n+    for (; i != iend; ++i) {\n+        bool match = false;\n+        if (i->exactMatch)\n+            match = (strURI == i->prefix);\n+        else\n+            match = (strURI.substr(0, i->prefix.size()) == i->prefix);\n+        if (match) {\n+            path = strURI.substr(i->prefix.size());\n+            break;\n+        }\n+    }\n+\n+    // Dispatch to worker thread\n+    if (i != iend) {\n+        std::auto_ptr<HTTPWorkItem> item(new HTTPWorkItem(hreq.release(), path, i->handler));\n+        assert(workQueue);\n+        if (workQueue->Enqueue(item.get()))\n+            item.release(); /* if true, queue took ownership */\n+        else\n+            item->req->WriteReply(HTTP_INTERNAL, \"Work queue depth exceeded\");\n+    } else {\n+        hreq->WriteReply(HTTP_NOTFOUND);\n+    }\n+}\n+\n+/** Event dispatcher thread */\n+static void ThreadHTTP(struct event_base* base, struct evhttp* http)\n+{\n+    RenameThread(\"bitcoin-http\");\n+    LogPrint(\"http\", \"Entering http event loop\\n\");\n+    event_base_dispatch(base);\n+    // Event loop will be interrupted by InterruptHTTPServer()\n+    LogPrint(\"http\", \"Exited http event loop\\n\");\n+}\n+\n+/** Bind HTTP server to specified addresses */\n+static bool HTTPBindAddresses(struct evhttp* http)\n+{\n+    int defaultPort = GetArg(\"-rpcport\", BaseParams().RPCPort());\n+    int nBound = 0;\n+    std::vector<std::pair<std::string, uint16_t> > endpoints;\n+\n+    // Determine what addresses to bind to\n+    if (!mapArgs.count(\"-rpcallowip\")) { // Default to loopback if not allowing external IPs\n+        endpoints.push_back(std::make_pair(\"::1\", defaultPort));\n+        endpoints.push_back(std::make_pair(\"127.0.0.1\", defaultPort));\n+        if (mapArgs.count(\"-rpcbind\")) {\n+            LogPrintf(\"WARNING: option -rpcbind was ignored because -rpcallowip was not specified, refusing to allow everyone to connect\\n\");\n+        }\n+    } else if (mapArgs.count(\"-rpcbind\")) { // Specific bind address\n+        const std::vector<std::string>& vbind = mapMultiArgs[\"-rpcbind\"];\n+        for (std::vector<std::string>::const_iterator i = vbind.begin(); i != vbind.end(); ++i) {\n+            int port = defaultPort;\n+            std::string host;\n+            SplitHostPort(*i, port, host);\n+            endpoints.push_back(std::make_pair(host, port));\n+        }\n+    } else { // No specific bind address specified, bind to any\n+        endpoints.push_back(std::make_pair(\"::\", defaultPort));\n+        endpoints.push_back(std::make_pair(\"0.0.0.0\", defaultPort));\n+    }\n+\n+    // Bind addresses\n+    for (std::vector<std::pair<std::string, uint16_t> >::iterator i = endpoints.begin(); i != endpoints.end(); ++i) {\n+        LogPrint(\"http\", \"Binding RPC on address %s port %i\\n\", i->first, i->second);\n+        if (evhttp_bind_socket(http, i->first.empty() ? NULL : i->first.c_str(), i->second) == 0) {\n+            nBound += 1;\n+        } else {\n+            LogPrintf(\"Binding RPC on address %s port %i failed.\\n\", i->first, i->second);\n+        }\n+    }\n+    return nBound > 0;\n+}\n+\n+/** Simple wrapper to set thread name and run work queue */\n+static void HTTPWorkQueueRun(WorkQueue<HTTPClosure>* queue)\n+{\n+    RenameThread(\"bitcoin-httpworker\");\n+    queue->Run();\n+}\n+\n+bool StartHTTPServer(boost::thread_group& threadGroup)\n+{\n+    struct evhttp* http = 0;\n+    struct event_base* base = 0;\n+\n+    if (!InitHTTPAllowList())\n+        return false;\n+\n+    if (GetBoolArg(\"-rpcssl\", false)) {\n+        uiInterface.ThreadSafeMessageBox(\n+            \"SSL mode for RPC (-rpcssl) is no longer supported.\",\n+            \"\", CClientUIInterface::MSG_ERROR);\n+        return false;\n+    }\n+\n+#ifdef WIN32\n+    evthread_use_windows_threads();\n+#else\n+    evthread_use_pthreads();\n+#endif\n+\n+    base = event_base_new(); // XXX RAII\n+    if (!base) {\n+        LogPrintf(\"Couldn't create an event_base: exiting\\n\");\n+        return false;\n+    }\n+\n+    /* Create a new evhttp object to handle requests. */\n+    http = evhttp_new(base); // XXX RAII\n+    if (!http) {\n+        LogPrintf(\"couldn't create evhttp. Exiting.\\n\");\n+        event_base_free(base);\n+        return false;\n+    }\n+\n+    evhttp_set_timeout(http, GetArg(\"-rpctimeout\", 30));\n+    evhttp_set_max_body_size(http, MAX_SIZE);\n+    evhttp_set_gencb(http, http_request_cb, NULL);\n+\n+    if (!HTTPBindAddresses(http)) {\n+        LogPrintf(\"Unable to bind any endpoint for RPC server\\n\");\n+        evhttp_free(http);\n+        event_base_free(base);\n+        return false;\n+    }\n+\n+    LogPrint(\"http\", \"Starting HTTP server\\n\");\n+    int workQueueDepth = std::max((long)GetArg(\"-rpcworkqueue\", 16), 1L);\n+    int rpcThreads = std::max((long)GetArg(\"-rpcthreads\", 4), 1L);\n+    LogPrintf(\"HTTP: creating work queue of depth %d and %d worker threads\\n\", workQueueDepth, rpcThreads);\n+    workQueue = new WorkQueue<HTTPClosure>(workQueueDepth);\n+\n+    threadGroup.create_thread(boost::bind(&ThreadHTTP, base, http));\n+\n+    for (int i = 0; i < rpcThreads; i++)\n+        threadGroup.create_thread(boost::bind(&HTTPWorkQueueRun, workQueue));\n+\n+    eventBase = base;\n+    eventHTTP = http;\n+    return true;\n+}\n+\n+void InterruptHTTPServer()\n+{\n+    LogPrint(\"http\", \"Interrupting HTTP server\\n\");\n+    if (eventBase)\n+        event_base_loopbreak(eventBase);\n+    if (workQueue)\n+        workQueue->Interrupt();\n+}\n+\n+void StopHTTPServer()\n+{\n+    LogPrint(\"http\", \"Stopping HTTP server\\n\");\n+    delete workQueue;\n+    if (eventHTTP) {\n+        evhttp_free(eventHTTP);\n+        eventHTTP = 0;\n+    }\n+    if (eventBase) {\n+        event_base_free(eventBase);\n+        eventBase = 0;\n+    }\n+}\n+\n+struct event_base* EventBase()\n+{\n+    return eventBase;\n+}\n+\n+static void httpevent_callback_fn(evutil_socket_t, short, void* data)\n+{\n+    // Static handler simply passes through execution flow to _handle method\n+    ((HTTPEvent*)data)->_handle();\n+}\n+\n+void HTTPEvent::_handle()\n+{\n+    (*handler)();\n+    if (deleteWhenTriggered)\n+        delete this;\n+}\n+\n+HTTPEvent::HTTPEvent(struct event_base* base, bool deleteWhenTriggered, HTTPClosure* handler) : deleteWhenTriggered(deleteWhenTriggered), handler(handler)\n+{\n+    ev = event_new(base, -1, 0, httpevent_callback_fn, this);\n+    assert(ev);\n+}\n+HTTPEvent::~HTTPEvent()\n+{\n+    event_free(ev);\n+}\n+void HTTPEvent::trigger(struct timeval* tv)\n+{\n+    if (tv == NULL)\n+        event_active(ev, 0, 0); // immediately trigger event in main thread\n+    else\n+        evtimer_add(ev, tv); // trigger after timeval passed\n+}\n+HTTPRequest::HTTPRequest(struct evhttp_request* req) : req(req),\n+                                                       replySent(false)\n+{\n+}\n+HTTPRequest::~HTTPRequest()\n+{\n+    if (!replySent) {\n+        // Keep track of whether reply was sent to avoid request leaks\n+        LogPrintf(\"%s: Unhandled request\\n\", __func__);\n+        WriteReply(HTTP_INTERNAL, \"Unhandled request\");\n+    }\n+    // evhttpd cleans up the request, as long as a reply was sent.\n+}\n+\n+std::pair<bool, std::string> HTTPRequest::GetHeader(const std::string& hdr)\n+{\n+    const struct evkeyvalq* headers = evhttp_request_get_input_headers(req);\n+    assert(headers);\n+    const char* val = evhttp_find_header(headers, hdr.c_str());\n+    if (val)\n+        return std::make_pair(true, val);\n+    else\n+        return std::make_pair(false, \"\");\n+}\n+\n+std::string HTTPRequest::ReadBody()\n+{\n+    struct evbuffer* buf = evhttp_request_get_input_buffer(req);\n+    if (!buf)\n+        return \"\";\n+    size_t size = evbuffer_get_length(buf);\n+    /** Trivial implementation: if this is ever a performance bottleneck,\n+     * internal copying can be avoided in multi-segment buffers by using\n+     * evbuffer_peek and an awkward loop. Though in that case, it'd be even\n+     * better to not copy into an intermediate string but use a stream\n+     * abstraction to consume the evbuffer on the fly in the parsing algorithm.\n+     */\n+    const char* data = (const char*)evbuffer_pullup(buf, size);\n+    if (!data) // returns NULL in case of empty buffer\n+        return \"\";\n+    std::string rv(data, size);\n+    evbuffer_drain(buf, size);\n+    return rv;\n+}\n+\n+void HTTPRequest::WriteHeader(const std::string& hdr, const std::string& value)\n+{\n+    struct evkeyvalq* headers = evhttp_request_get_output_headers(req);\n+    assert(headers);\n+    evhttp_add_header(headers, hdr.c_str(), value.c_str());\n+}\n+\n+/** Closure sent to main thread to request a reply to be sent to\n+ * a HTTP request.\n+ * Replies must be sent in the main loop in the main http thread,\n+ * this cannot be done from worker threads.\n+ */\n+struct HTTPSendReplyHandler : HTTPClosure {\n+public:\n+    HTTPSendReplyHandler(struct evhttp_request* req, int nStatus) : req(req), nStatus(nStatus)\n+    {\n+    }\n+    void operator()()\n+    {\n+        evhttp_send_reply(req, nStatus, NULL, NULL);\n+    }\n+private:\n+    struct evhttp_request* req;\n+    int nStatus;\n+};\n+\n+void HTTPRequest::WriteReply(int nStatus, const std::string& strReply)\n+{\n+    assert(!replySent && req);\n+    // Send event to main http thread to send reply message\n+    struct evbuffer* evb = evhttp_request_get_output_buffer(req);\n+    assert(evb);\n+    evbuffer_add(evb, strReply.data(), strReply.size());\n+    HTTPEvent* ev = new HTTPEvent(eventBase, true,\n+                                  new HTTPSendReplyHandler(req, nStatus));\n+    ev->trigger(0);\n+    replySent = true;\n+    req = 0; // transferred back to main thread\n+}\n+\n+CService HTTPRequest::GetPeer()\n+{\n+    evhttp_connection* con = evhttp_request_get_connection(req);\n+    CService peer;\n+    if (con) {\n+        // evhttp retains ownership over returned address string\n+        const char* address = \"\";\n+        uint16_t port = 0;\n+        evhttp_connection_get_peer(con, (char**)&address, &port);\n+        peer = CService(address, port);\n+    }\n+    return peer;\n+}\n+\n+std::string HTTPRequest::GetURI()\n+{\n+    return evhttp_request_get_uri(req);\n+}\n+\n+HTTPRequest::RequestMethod HTTPRequest::GetRequestMethod()\n+{\n+    switch (evhttp_request_get_command(req)) {\n+    case EVHTTP_REQ_GET:\n+        return GET;\n+        break;\n+    case EVHTTP_REQ_POST:\n+        return POST;\n+        break;\n+    case EVHTTP_REQ_HEAD:\n+        return HEAD;\n+        break;\n+    case EVHTTP_REQ_PUT:\n+        return PUT;\n+        break;\n+    default:\n+        return UNKNOWN;\n+        break;\n+    }\n+}\n+\n+void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n+{\n+    LogPrint(\"http\", \"Registering HTTP handler for %s (exactmath %d)\\n\", prefix, exactMatch);\n+    pathHandlers.push_back(HTTPPathHandler(prefix, exactMatch, handler));\n+}\n+\n+void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n+{\n+    std::vector<HTTPPathHandler>::iterator i = pathHandlers.begin();\n+    std::vector<HTTPPathHandler>::iterator iend = pathHandlers.end();\n+    for (; i != iend; ++i)\n+        if (i->prefix == prefix && i->exactMatch == exactMatch)\n+            break;\n+    if (i != iend)\n+    {\n+        LogPrint(\"http\", \"Unregistering HTTP handler for %s (exactmath %d)\\n\", prefix, exactMatch);\n+        pathHandlers.erase(i);\n+    }\n+}\n+"
      },
      {
        "sha": "c6a7804195f53a8d70da502e7164ebb032a8f13f",
        "filename": "src/httpserver.h",
        "status": "added",
        "additions": 138,
        "deletions": 0,
        "changes": 138,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/httpserver.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/httpserver.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.h?ref=40b556d3742a1f65d67e2d4c760d0b13fe8be5b7",
        "patch": "@@ -0,0 +1,138 @@\n+// Copyright (c) 2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_HTTPSERVER_H\n+#define BITCOIN_HTTPSERVER_H\n+\n+#include <string>\n+#include <stdint.h>\n+#include <boost/thread.hpp>\n+#include <boost/scoped_ptr.hpp>\n+#include <boost/function.hpp>\n+\n+struct evhttp_request;\n+struct event_base;\n+class CService;\n+class HTTPRequest;\n+\n+/** Start HTTP server */\n+bool StartHTTPServer(boost::thread_group& threadGroup);\n+/** Interrupt HTTP server threads */\n+void InterruptHTTPServer();\n+/** Stop HTTP server */\n+void StopHTTPServer();\n+\n+/** Handler for requests to a certain HTTP path */\n+typedef boost::function<void(HTTPRequest* req, const std::string &)> HTTPRequestHandler;\n+/** Register handler for prefix.\n+ * If multiple handlers match a prefix, the first-registered one will\n+ * be invoked.\n+ */\n+void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler);\n+/** Unregister handler for prefix */\n+void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch);\n+\n+/** Return evhttp event base. This can be used by submodules to\n+ * queue timers or custom events.\n+ */\n+struct event_base* EventBase();\n+\n+/** In-flight HTTP request.\n+ * Thin C++ wrapper around evhttp_request.\n+ */\n+class HTTPRequest\n+{\n+private:\n+    struct evhttp_request* req;\n+    bool replySent;\n+\n+public:\n+    HTTPRequest(struct evhttp_request* req);\n+    ~HTTPRequest();\n+\n+    enum RequestMethod {\n+        UNKNOWN,\n+        GET,\n+        POST,\n+        HEAD,\n+        PUT\n+    };\n+\n+    /** Get requested URI.\n+     */\n+    std::string GetURI();\n+\n+    /** Get CService (address:ip) for the origin of the http request.\n+     */\n+    CService GetPeer();\n+\n+    /** Get request method.\n+     */\n+    RequestMethod GetRequestMethod();\n+\n+    /**\n+     * Get the request header specified by hdr, or an empty string.\n+     * Return an pair (isPresent,string).\n+     */\n+    std::pair<bool, std::string> GetHeader(const std::string& hdr);\n+\n+    /**\n+     * Read request body.\n+     *\n+     * @note As this consumes the underlying buffer, call this only once.\n+     * Repeated calls will return an empty string.\n+     */\n+    std::string ReadBody();\n+\n+    /**\n+     * Write output header.\n+     *\n+     * @note call this before calling WriteErrorReply or Reply.\n+     */\n+    void WriteHeader(const std::string& hdr, const std::string& value);\n+\n+    /**\n+     * Write HTTP reply.\n+     * nStatus is the HTTP status code to send.\n+     * strReply is the body of the reply. Keep it empty to send a standard message.\n+     *\n+     * @note Can be called only once. As this will give the request back to the\n+     * main thread, do not call any other HTTPRequest methods after calling this.\n+     */\n+    void WriteReply(int nStatus, const std::string& strReply = \"\");\n+};\n+\n+/** Event handler closure.\n+ */\n+class HTTPClosure\n+{\n+public:\n+    virtual void operator()() = 0;\n+    virtual ~HTTPClosure() {}\n+};\n+\n+/** Event class. This can be used either as an cross-thread trigger or as a timer.\n+ */\n+class HTTPEvent\n+{\n+public:\n+    /** Create a new event */\n+    HTTPEvent(struct event_base* base, bool deleteWhenTriggered, HTTPClosure* handler);\n+    ~HTTPEvent();\n+\n+    /** Trigger the event. If tv is 0, trigger it immediately. Otherwise trigger it after\n+     * the given time has elapsed.\n+     */\n+    void trigger(struct timeval* tv);\n+\n+    /** Internal function for handling, do not call directly */\n+    void _handle();\n+\n+private:\n+    bool deleteWhenTriggered;\n+    struct event* ev;\n+    boost::scoped_ptr<HTTPClosure> handler;\n+};\n+\n+#endif // BITCOIN_HTTPSERVER_H"
      },
      {
        "sha": "835ed4001072d636b7770702b6bc6a5cf447d832",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 11,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=40b556d3742a1f65d67e2d4c760d0b13fe8be5b7",
        "patch": "@@ -16,6 +16,8 @@\n #include \"checkpoints.h\"\n #include \"compat/sanity.h\"\n #include \"consensus/validation.h\"\n+#include \"httpserver.h\"\n+#include \"httprpc.h\"\n #include \"key.h\"\n #include \"main.h\"\n #include \"miner.h\"\n@@ -144,6 +146,15 @@ class CCoinsViewErrorCatcher : public CCoinsViewBacked\n static CCoinsViewDB *pcoinsdbview = NULL;\n static CCoinsViewErrorCatcher *pcoinscatcher = NULL;\n \n+void Interrupt(boost::thread_group& threadGroup)\n+{\n+    InterruptHTTPServer();\n+    InterruptHTTPRPC();\n+    InterruptRPC();\n+    InterruptREST();\n+    threadGroup.interrupt_all();\n+}\n+\n void Shutdown()\n {\n     LogPrintf(\"%s: In progress...\\n\", __func__);\n@@ -158,7 +169,11 @@ void Shutdown()\n     /// module was initialized.\n     RenameThread(\"bitcoin-shutoff\");\n     mempool.AddTransactionsUpdated(1);\n-    StopRPCThreads();\n+\n+    StopHTTPRPC();\n+    StopREST();\n+    StopRPC();\n+    StopHTTPServer();\n #ifdef ENABLE_WALLET\n     if (pwalletMain)\n         pwalletMain->Flush(false);\n@@ -424,13 +439,6 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-rpcport=<port>\", strprintf(_(\"Listen for JSON-RPC connections on <port> (default: %u or testnet: %u)\"), 8332, 18332));\n     strUsage += HelpMessageOpt(\"-rpcallowip=<ip>\", _(\"Allow JSON-RPC connections from specified source. Valid for <ip> are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24). This option can be specified multiple times\"));\n     strUsage += HelpMessageOpt(\"-rpcthreads=<n>\", strprintf(_(\"Set the number of threads to service RPC calls (default: %d)\"), 4));\n-    strUsage += HelpMessageOpt(\"-rpckeepalive\", strprintf(_(\"RPC support for HTTP persistent connections (default: %d)\"), 1));\n-\n-    strUsage += HelpMessageGroup(_(\"RPC SSL options: (see the Bitcoin Wiki for SSL setup instructions)\"));\n-    strUsage += HelpMessageOpt(\"-rpcssl\", _(\"Use OpenSSL (https) for JSON-RPC connections\"));\n-    strUsage += HelpMessageOpt(\"-rpcsslcertificatechainfile=<file.cert>\", strprintf(_(\"Server certificate file (default: %s)\"), \"server.cert\"));\n-    strUsage += HelpMessageOpt(\"-rpcsslprivatekeyfile=<file.pem>\", strprintf(_(\"Server private key (default: %s)\"), \"server.pem\"));\n-    strUsage += HelpMessageOpt(\"-rpcsslciphers=<ciphers>\", strprintf(_(\"Acceptable ciphers (default: %s)\"), \"TLSv1.2+HIGH:TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!3DES:@STRENGTH\"));\n \n     if (mode == HMM_BITCOIN_QT)\n     {\n@@ -602,6 +610,21 @@ bool InitSanityCheck(void)\n     return true;\n }\n \n+bool AppInitServers(boost::thread_group& threadGroup)\n+{\n+    RPCServer::OnStopped(&OnRPCStopped);\n+    RPCServer::OnPreCommand(&OnRPCPreCommand);\n+    if (!StartHTTPServer(threadGroup))\n+        return false;\n+    if (!StartRPC())\n+        return false;\n+    if (!StartHTTPRPC())\n+        return false;\n+    if (GetBoolArg(\"-rest\", false) && !StartREST())\n+        return false;\n+    return true;\n+}\n+\n /** Initialize bitcoin.\n  *  @pre Parameters should be parsed and config file should be read.\n  */\n@@ -990,9 +1013,8 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n     if (fServer)\n     {\n         uiInterface.InitMessage.connect(SetRPCWarmupStatus);\n-        RPCServer::OnStopped(&OnRPCStopped);\n-        RPCServer::OnPreCommand(&OnRPCPreCommand);\n-        StartRPCThreads();\n+        if (!AppInitServers(threadGroup))\n+            return InitError(_(\"Unable to start HTTP server. See debug log for details.\"));\n     }\n \n     int64_t nStart;"
      },
      {
        "sha": "8cd51b0286f5dfe0d33b5b02c179568627a05737",
        "filename": "src/init.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/init.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/init.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.h?ref=40b556d3742a1f65d67e2d4c760d0b13fe8be5b7",
        "patch": "@@ -20,6 +20,8 @@ extern CWallet* pwalletMain;\n \n void StartShutdown();\n bool ShutdownRequested();\n+/** Interrupt threads */\n+void Interrupt(boost::thread_group& threadGroup);\n void Shutdown();\n bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler);\n "
      },
      {
        "sha": "ea7f86d18e53f78a9a3b1e28f04fe645e75e430c",
        "filename": "src/qt/bitcoin.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 8,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/qt/bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/qt/bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.cpp?ref=40b556d3742a1f65d67e2d4c760d0b13fe8be5b7",
        "patch": "@@ -266,13 +266,6 @@ void BitcoinCore::initialize()\n     {\n         qDebug() << __func__ << \": Running AppInit2 in thread\";\n         int rv = AppInit2(threadGroup, scheduler);\n-        if(rv)\n-        {\n-            /* Start a dummy RPC thread if no RPC thread is active yet\n-             * to handle timeouts.\n-             */\n-            StartDummyRPCThread();\n-        }\n         Q_EMIT initializeResult(rv);\n     } catch (const std::exception& e) {\n         handleRunawayException(&e);\n@@ -286,7 +279,7 @@ void BitcoinCore::shutdown()\n     try\n     {\n         qDebug() << __func__ << \": Running Shutdown in thread\";\n-        threadGroup.interrupt_all();\n+        Interrupt(threadGroup);\n         threadGroup.join_all();\n         Shutdown();\n         qDebug() << __func__ << \": Shutdown finished\";"
      },
      {
        "sha": "940526706798faec6c4e935b0012cea1e9089aa2",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 111,
        "deletions": 132,
        "changes": 243,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=40b556d3742a1f65d67e2d4c760d0b13fe8be5b7",
        "patch": "@@ -7,6 +7,7 @@\n #include \"primitives/block.h\"\n #include \"primitives/transaction.h\"\n #include \"main.h\"\n+#include \"httpserver.h\"\n #include \"rpcserver.h\"\n #include \"streams.h\"\n #include \"sync.h\"\n@@ -56,29 +57,21 @@ struct CCoin {\n     }\n };\n \n-class RestErr\n-{\n-public:\n-    enum HTTPStatusCode status;\n-    string message;\n-};\n-\n extern void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry);\n extern UniValue blockToJSON(const CBlock& block, const CBlockIndex* blockindex, bool txDetails = false);\n extern UniValue mempoolInfoToJSON();\n extern UniValue mempoolToJSON(bool fVerbose = false);\n extern void ScriptPubKeyToJSON(const CScript& scriptPubKey, UniValue& out, bool fIncludeHex);\n extern UniValue blockheaderToJSON(const CBlockIndex* blockindex);\n \n-static RestErr RESTERR(enum HTTPStatusCode status, string message)\n+static bool RESTERR(HTTPRequest* req, enum HTTPStatusCode status, string message)\n {\n-    RestErr re;\n-    re.status = status;\n-    re.message = message;\n-    return re;\n+    req->WriteHeader(\"Content-Type\", \"text/plain\");\n+    req->WriteReply(status, message + \"\\r\\n\");\n+    return false;\n }\n \n-static enum RetFormat ParseDataFormat(vector<string>& params, const string strReq)\n+static enum RetFormat ParseDataFormat(vector<string>& params, const string& strReq)\n {\n     boost::split(params, strReq, boost::is_any_of(\".\"));\n     if (params.size() > 1) {\n@@ -115,28 +108,35 @@ static bool ParseHashStr(const string& strReq, uint256& v)\n     return true;\n }\n \n-static bool rest_headers(AcceptedConnection* conn,\n-                         const std::string& strURIPart,\n-                         const std::string& strRequest,\n-                         const std::map<std::string, std::string>& mapHeaders,\n-                         bool fRun)\n+static bool CheckWarmup(HTTPRequest* req)\n+{\n+    std::string statusmessage;\n+    if (RPCIsInWarmup(&statusmessage))\n+         return RESTERR(req, HTTP_SERVICE_UNAVAILABLE, \"Service temporarily unavailable: \" + statusmessage);\n+    return true;\n+}\n+\n+static bool rest_headers(HTTPRequest* req,\n+                         const std::string& strURIPart)\n {\n+    if (!CheckWarmup(req))\n+        return false;\n     vector<string> params;\n     const RetFormat rf = ParseDataFormat(params, strURIPart);\n     vector<string> path;\n     boost::split(path, params[0], boost::is_any_of(\"/\"));\n \n     if (path.size() != 2)\n-        throw RESTERR(HTTP_BAD_REQUEST, \"No header count specified. Use /rest/headers/<count>/<hash>.<ext>.\");\n+        return RESTERR(req, HTTP_BAD_REQUEST, \"No header count specified. Use /rest/headers/<count>/<hash>.<ext>.\");\n \n     long count = strtol(path[0].c_str(), NULL, 10);\n     if (count < 1 || count > 2000)\n-        throw RESTERR(HTTP_BAD_REQUEST, \"Header count out of range: \" + path[0]);\n+        return RESTERR(req, HTTP_BAD_REQUEST, \"Header count out of range: \" + path[0]);\n \n     string hashStr = path[1];\n     uint256 hash;\n     if (!ParseHashStr(hashStr, hash))\n-        throw RESTERR(HTTP_BAD_REQUEST, \"Invalid hash: \" + hashStr);\n+        return RESTERR(req, HTTP_BAD_REQUEST, \"Invalid hash: \" + hashStr);\n \n     std::vector<const CBlockIndex *> headers;\n     headers.reserve(count);\n@@ -160,63 +160,63 @@ static bool rest_headers(AcceptedConnection* conn,\n     switch (rf) {\n     case RF_BINARY: {\n         string binaryHeader = ssHeader.str();\n-        conn->stream() << HTTPReplyHeader(HTTP_OK, fRun, binaryHeader.size(), \"application/octet-stream\") << binaryHeader << std::flush;\n+        req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n+        req->WriteReply(HTTP_OK, binaryHeader);\n         return true;\n     }\n \n     case RF_HEX: {\n         string strHex = HexStr(ssHeader.begin(), ssHeader.end()) + \"\\n\";\n-        conn->stream() << HTTPReply(HTTP_OK, strHex, fRun, false, \"text/plain\") << std::flush;\n+        req->WriteHeader(\"Content-Type\", \"text/plain\");\n+        req->WriteReply(HTTP_OK, strHex);\n         return true;\n     }\n-\n     case RF_JSON: {\n         UniValue jsonHeaders(UniValue::VARR);\n         BOOST_FOREACH(const CBlockIndex *pindex, headers) {\n             jsonHeaders.push_back(blockheaderToJSON(pindex));\n         }\n         string strJSON = jsonHeaders.write() + \"\\n\";\n-        conn->stream() << HTTPReply(HTTP_OK, strJSON, fRun) << std::flush;\n+        req->WriteHeader(\"Content-Type\", \"application/json\");\n+        req->WriteReply(HTTP_OK, strJSON);\n         return true;\n     }\n-\n     default: {\n-        throw RESTERR(HTTP_NOT_FOUND, \"output format not found (available: .bin, .hex)\");\n+        return RESTERR(req, HTTP_NOT_FOUND, \"output format not found (available: .bin, .hex)\");\n     }\n     }\n \n     // not reached\n     return true; // continue to process further HTTP reqs on this cxn\n }\n \n-static bool rest_block(AcceptedConnection* conn,\n+static bool rest_block(HTTPRequest* req,\n                        const std::string& strURIPart,\n-                       const std::string& strRequest,\n-                       const std::map<std::string, std::string>& mapHeaders,\n-                       bool fRun,\n                        bool showTxDetails)\n {\n+    if (!CheckWarmup(req))\n+        return false;\n     vector<string> params;\n     const RetFormat rf = ParseDataFormat(params, strURIPart);\n \n     string hashStr = params[0];\n     uint256 hash;\n     if (!ParseHashStr(hashStr, hash))\n-        throw RESTERR(HTTP_BAD_REQUEST, \"Invalid hash: \" + hashStr);\n+        return RESTERR(req, HTTP_BAD_REQUEST, \"Invalid hash: \" + hashStr);\n \n     CBlock block;\n     CBlockIndex* pblockindex = NULL;\n     {\n         LOCK(cs_main);\n         if (mapBlockIndex.count(hash) == 0)\n-            throw RESTERR(HTTP_NOT_FOUND, hashStr + \" not found\");\n+            return RESTERR(req, HTTP_NOT_FOUND, hashStr + \" not found\");\n \n         pblockindex = mapBlockIndex[hash];\n         if (fHavePruned && !(pblockindex->nStatus & BLOCK_HAVE_DATA) && pblockindex->nTx > 0)\n-            throw RESTERR(HTTP_NOT_FOUND, hashStr + \" not available (pruned data)\");\n+            return RESTERR(req, HTTP_NOT_FOUND, hashStr + \" not available (pruned data)\");\n \n         if (!ReadBlockFromDisk(block, pblockindex))\n-            throw RESTERR(HTTP_NOT_FOUND, hashStr + \" not found\");\n+            return RESTERR(req, HTTP_NOT_FOUND, hashStr + \" not found\");\n     }\n \n     CDataStream ssBlock(SER_NETWORK, PROTOCOL_VERSION);\n@@ -225,56 +225,49 @@ static bool rest_block(AcceptedConnection* conn,\n     switch (rf) {\n     case RF_BINARY: {\n         string binaryBlock = ssBlock.str();\n-        conn->stream() << HTTPReplyHeader(HTTP_OK, fRun, binaryBlock.size(), \"application/octet-stream\") << binaryBlock << std::flush;\n+        req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n+        req->WriteReply(HTTP_OK, binaryBlock);\n         return true;\n     }\n \n     case RF_HEX: {\n         string strHex = HexStr(ssBlock.begin(), ssBlock.end()) + \"\\n\";\n-        conn->stream() << HTTPReply(HTTP_OK, strHex, fRun, false, \"text/plain\") << std::flush;\n+        req->WriteHeader(\"Content-Type\", \"text/plain\");\n+        req->WriteReply(HTTP_OK, strHex);\n         return true;\n     }\n \n     case RF_JSON: {\n         UniValue objBlock = blockToJSON(block, pblockindex, showTxDetails);\n         string strJSON = objBlock.write() + \"\\n\";\n-        conn->stream() << HTTPReply(HTTP_OK, strJSON, fRun) << std::flush;\n+        req->WriteHeader(\"Content-Type\", \"application/json\");\n+        req->WriteReply(HTTP_OK, strJSON);\n         return true;\n     }\n \n     default: {\n-        throw RESTERR(HTTP_NOT_FOUND, \"output format not found (available: \" + AvailableDataFormatsString() + \")\");\n+        return RESTERR(req, HTTP_NOT_FOUND, \"output format not found (available: \" + AvailableDataFormatsString() + \")\");\n     }\n     }\n \n     // not reached\n     return true; // continue to process further HTTP reqs on this cxn\n }\n \n-static bool rest_block_extended(AcceptedConnection* conn,\n-                       const std::string& strURIPart,\n-                       const std::string& strRequest,\n-                       const std::map<std::string, std::string>& mapHeaders,\n-                       bool fRun)\n+static bool rest_block_extended(HTTPRequest* req, const std::string& strURIPart)\n {\n-    return rest_block(conn, strURIPart, strRequest, mapHeaders, fRun, true);\n+    return rest_block(req, strURIPart, true);\n }\n \n-static bool rest_block_notxdetails(AcceptedConnection* conn,\n-                       const std::string& strURIPart,\n-                       const std::string& strRequest,\n-                       const std::map<std::string, std::string>& mapHeaders,\n-                       bool fRun)\n+static bool rest_block_notxdetails(HTTPRequest* req, const std::string& strURIPart)\n {\n-    return rest_block(conn, strURIPart, strRequest, mapHeaders, fRun, false);\n+    return rest_block(req, strURIPart, false);\n }\n \n-static bool rest_chaininfo(AcceptedConnection* conn,\n-                           const std::string& strURIPart,\n-                           const std::string& strRequest,\n-                           const std::map<std::string, std::string>& mapHeaders,\n-                           bool fRun)\n+static bool rest_chaininfo(HTTPRequest* req, const std::string& strURIPart)\n {\n+    if (!CheckWarmup(req))\n+        return false;\n     vector<string> params;\n     const RetFormat rf = ParseDataFormat(params, strURIPart);\n \n@@ -283,24 +276,23 @@ static bool rest_chaininfo(AcceptedConnection* conn,\n         UniValue rpcParams(UniValue::VARR);\n         UniValue chainInfoObject = getblockchaininfo(rpcParams, false);\n         string strJSON = chainInfoObject.write() + \"\\n\";\n-        conn->stream() << HTTPReply(HTTP_OK, strJSON, fRun) << std::flush;\n+        req->WriteHeader(\"Content-Type\", \"application/json\");\n+        req->WriteReply(HTTP_OK, strJSON);\n         return true;\n     }\n     default: {\n-        throw RESTERR(HTTP_NOT_FOUND, \"output format not found (available: json)\");\n+        return RESTERR(req, HTTP_NOT_FOUND, \"output format not found (available: json)\");\n     }\n     }\n \n     // not reached\n     return true; // continue to process further HTTP reqs on this cxn\n }\n \n-static bool rest_mempool_info(AcceptedConnection* conn,\n-                              const std::string& strURIPart,\n-                              const std::string& strRequest,\n-                              const std::map<std::string, std::string>& mapHeaders,\n-                              bool fRun)\n+static bool rest_mempool_info(HTTPRequest* req, const std::string& strURIPart)\n {\n+    if (!CheckWarmup(req))\n+        return false;\n     vector<string> params;\n     const RetFormat rf = ParseDataFormat(params, strURIPart);\n \n@@ -309,24 +301,23 @@ static bool rest_mempool_info(AcceptedConnection* conn,\n         UniValue mempoolInfoObject = mempoolInfoToJSON();\n \n         string strJSON = mempoolInfoObject.write() + \"\\n\";\n-        conn->stream() << HTTPReply(HTTP_OK, strJSON, fRun) << std::flush;\n+        req->WriteHeader(\"Content-Type\", \"application/json\");\n+        req->WriteReply(HTTP_OK, strJSON);\n         return true;\n     }\n     default: {\n-        throw RESTERR(HTTP_NOT_FOUND, \"output format not found (available: json)\");\n+        return RESTERR(req, HTTP_NOT_FOUND, \"output format not found (available: json)\");\n     }\n     }\n \n     // not reached\n     return true; // continue to process further HTTP reqs on this cxn\n }\n \n-static bool rest_mempool_contents(AcceptedConnection* conn,\n-                                  const std::string& strURIPart,\n-                                  const std::string& strRequest,\n-                                  const std::map<std::string, std::string>& mapHeaders,\n-                                  bool fRun)\n+static bool rest_mempool_contents(HTTPRequest* req, const std::string& strURIPart)\n {\n+    if (!CheckWarmup(req))\n+        return false;\n     vector<string> params;\n     const RetFormat rf = ParseDataFormat(params, strURIPart);\n \n@@ -335,76 +326,76 @@ static bool rest_mempool_contents(AcceptedConnection* conn,\n         UniValue mempoolObject = mempoolToJSON(true);\n \n         string strJSON = mempoolObject.write() + \"\\n\";\n-        conn->stream() << HTTPReply(HTTP_OK, strJSON, fRun) << std::flush;\n+        req->WriteHeader(\"Content-Type\", \"application/json\");\n+        req->WriteReply(HTTP_OK, strJSON);\n         return true;\n     }\n     default: {\n-        throw RESTERR(HTTP_NOT_FOUND, \"output format not found (available: json)\");\n+        return RESTERR(req, HTTP_NOT_FOUND, \"output format not found (available: json)\");\n     }\n     }\n \n     // not reached\n     return true; // continue to process further HTTP reqs on this cxn\n }\n \n-static bool rest_tx(AcceptedConnection* conn,\n-                    const std::string& strURIPart,\n-                    const std::string& strRequest,\n-                    const std::map<std::string, std::string>& mapHeaders,\n-                    bool fRun)\n+static bool rest_tx(HTTPRequest* req, const std::string& strURIPart)\n {\n+    if (!CheckWarmup(req))\n+        return false;\n     vector<string> params;\n     const RetFormat rf = ParseDataFormat(params, strURIPart);\n \n     string hashStr = params[0];\n     uint256 hash;\n     if (!ParseHashStr(hashStr, hash))\n-        throw RESTERR(HTTP_BAD_REQUEST, \"Invalid hash: \" + hashStr);\n+        return RESTERR(req, HTTP_BAD_REQUEST, \"Invalid hash: \" + hashStr);\n \n     CTransaction tx;\n     uint256 hashBlock = uint256();\n     if (!GetTransaction(hash, tx, hashBlock, true))\n-        throw RESTERR(HTTP_NOT_FOUND, hashStr + \" not found\");\n+        return RESTERR(req, HTTP_NOT_FOUND, hashStr + \" not found\");\n \n     CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n     ssTx << tx;\n \n     switch (rf) {\n     case RF_BINARY: {\n         string binaryTx = ssTx.str();\n-        conn->stream() << HTTPReplyHeader(HTTP_OK, fRun, binaryTx.size(), \"application/octet-stream\") << binaryTx << std::flush;\n+        req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n+        req->WriteReply(HTTP_OK, binaryTx);\n         return true;\n     }\n \n     case RF_HEX: {\n         string strHex = HexStr(ssTx.begin(), ssTx.end()) + \"\\n\";\n-        conn->stream() << HTTPReply(HTTP_OK, strHex, fRun, false, \"text/plain\") << std::flush;\n+        req->WriteHeader(\"Content-Type\", \"text/plain\");\n+        req->WriteReply(HTTP_OK, strHex);\n         return true;\n     }\n \n     case RF_JSON: {\n         UniValue objTx(UniValue::VOBJ);\n         TxToJSON(tx, hashBlock, objTx);\n         string strJSON = objTx.write() + \"\\n\";\n-        conn->stream() << HTTPReply(HTTP_OK, strJSON, fRun) << std::flush;\n+        req->WriteHeader(\"Content-Type\", \"application/json\");\n+        req->WriteReply(HTTP_OK, strJSON);\n         return true;\n     }\n \n     default: {\n-        throw RESTERR(HTTP_NOT_FOUND, \"output format not found (available: \" + AvailableDataFormatsString() + \")\");\n+        return RESTERR(req, HTTP_NOT_FOUND, \"output format not found (available: \" + AvailableDataFormatsString() + \")\");\n     }\n     }\n \n     // not reached\n     return true; // continue to process further HTTP reqs on this cxn\n }\n \n-static bool rest_getutxos(AcceptedConnection* conn,\n-                          const std::string& strURIPart,\n-                          const std::string& strRequest,\n-                          const std::map<std::string, std::string>& mapHeaders,\n-                          bool fRun)\n+static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n {\n+    if (!CheckWarmup(req))\n+        return false;\n     vector<string> params;\n     enum RetFormat rf = ParseDataFormat(params, strURIPart);\n \n@@ -416,8 +407,9 @@ static bool rest_getutxos(AcceptedConnection* conn,\n     }\n \n     // throw exception in case of a empty request\n-    if (strRequest.length() == 0 && uriParts.size() == 0)\n-        throw RESTERR(HTTP_INTERNAL_SERVER_ERROR, \"Error: empty request\");\n+    std::string strRequestMutable = req->ReadBody();\n+    if (strRequestMutable.length() == 0 && uriParts.size() == 0)\n+        return RESTERR(req, HTTP_INTERNAL_SERVER_ERROR, \"Error: empty request\");\n \n     bool fInputParsed = false;\n     bool fCheckMemPool = false;\n@@ -441,7 +433,7 @@ static bool rest_getutxos(AcceptedConnection* conn,\n             std::string strOutput = uriParts[i].substr(uriParts[i].find(\"-\")+1);\n \n             if (!ParseInt32(strOutput, &nOutput) || !IsHex(strTxid))\n-                throw RESTERR(HTTP_INTERNAL_SERVER_ERROR, \"Parse error\");\n+                return RESTERR(req, HTTP_INTERNAL_SERVER_ERROR, \"Parse error\");\n \n             txid.SetHex(strTxid);\n             vOutPoints.push_back(COutPoint(txid, (uint32_t)nOutput));\n@@ -450,15 +442,13 @@ static bool rest_getutxos(AcceptedConnection* conn,\n         if (vOutPoints.size() > 0)\n             fInputParsed = true;\n         else\n-            throw RESTERR(HTTP_INTERNAL_SERVER_ERROR, \"Error: empty request\");\n+            return RESTERR(req, HTTP_INTERNAL_SERVER_ERROR, \"Error: empty request\");\n     }\n \n-    string strRequestMutable = strRequest; //convert const string to string for allowing hex to bin converting\n-\n     switch (rf) {\n     case RF_HEX: {\n         // convert hex to bin, continue then with bin part\n-        std::vector<unsigned char> strRequestV = ParseHex(strRequest);\n+        std::vector<unsigned char> strRequestV = ParseHex(strRequestMutable);\n         strRequestMutable.assign(strRequestV.begin(), strRequestV.end());\n     }\n \n@@ -468,7 +458,7 @@ static bool rest_getutxos(AcceptedConnection* conn,\n             if (strRequestMutable.size() > 0)\n             {\n                 if (fInputParsed) //don't allow sending input over URI and HTTP RAW DATA\n-                    throw RESTERR(HTTP_INTERNAL_SERVER_ERROR, \"Combination of URI scheme inputs and raw post data is not allowed\");\n+                    return RESTERR(req, HTTP_INTERNAL_SERVER_ERROR, \"Combination of URI scheme inputs and raw post data is not allowed\");\n \n                 CDataStream oss(SER_NETWORK, PROTOCOL_VERSION);\n                 oss << strRequestMutable;\n@@ -477,24 +467,24 @@ static bool rest_getutxos(AcceptedConnection* conn,\n             }\n         } catch (const std::ios_base::failure& e) {\n             // abort in case of unreadable binary data\n-            throw RESTERR(HTTP_INTERNAL_SERVER_ERROR, \"Parse error\");\n+            return RESTERR(req, HTTP_INTERNAL_SERVER_ERROR, \"Parse error\");\n         }\n         break;\n     }\n \n     case RF_JSON: {\n         if (!fInputParsed)\n-            throw RESTERR(HTTP_INTERNAL_SERVER_ERROR, \"Error: empty request\");\n+            return RESTERR(req, HTTP_INTERNAL_SERVER_ERROR, \"Error: empty request\");\n         break;\n     }\n     default: {\n-        throw RESTERR(HTTP_NOT_FOUND, \"output format not found (available: \" + AvailableDataFormatsString() + \")\");\n+        return RESTERR(req, HTTP_NOT_FOUND, \"output format not found (available: \" + AvailableDataFormatsString() + \")\");\n     }\n     }\n \n     // limit max outpoints\n     if (vOutPoints.size() > MAX_GETUTXOS_OUTPOINTS)\n-        throw RESTERR(HTTP_INTERNAL_SERVER_ERROR, strprintf(\"Error: max outpoints exceeded (max: %d, tried: %d)\", MAX_GETUTXOS_OUTPOINTS, vOutPoints.size()));\n+        return RESTERR(req, HTTP_INTERNAL_SERVER_ERROR, strprintf(\"Error: max outpoints exceeded (max: %d, tried: %d)\", MAX_GETUTXOS_OUTPOINTS, vOutPoints.size()));\n \n     // check spentness and form a bitmap (as well as a JSON capable human-readble string representation)\n     vector<unsigned char> bitmap;\n@@ -544,7 +534,8 @@ static bool rest_getutxos(AcceptedConnection* conn,\n         ssGetUTXOResponse << chainActive.Height() << chainActive.Tip()->GetBlockHash() << bitmap << outs;\n         string ssGetUTXOResponseString = ssGetUTXOResponse.str();\n \n-        conn->stream() << HTTPReplyHeader(HTTP_OK, fRun, ssGetUTXOResponseString.size(), \"application/octet-stream\") << ssGetUTXOResponseString << std::flush;\n+        req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n+        req->WriteReply(HTTP_OK, ssGetUTXOResponseString);\n         return true;\n     }\n \n@@ -553,7 +544,8 @@ static bool rest_getutxos(AcceptedConnection* conn,\n         ssGetUTXOResponse << chainActive.Height() << chainActive.Tip()->GetBlockHash() << bitmap << outs;\n         string strHex = HexStr(ssGetUTXOResponse.begin(), ssGetUTXOResponse.end()) + \"\\n\";\n \n-        conn->stream() << HTTPReply(HTTP_OK, strHex, fRun, false, \"text/plain\") << std::flush;\n+        req->WriteHeader(\"Content-Type\", \"text/plain\");\n+        req->WriteReply(HTTP_OK, strHex);\n         return true;\n     }\n \n@@ -583,11 +575,12 @@ static bool rest_getutxos(AcceptedConnection* conn,\n \n         // return json string\n         string strJSON = objGetUTXOResponse.write() + \"\\n\";\n-        conn->stream() << HTTPReply(HTTP_OK, strJSON, fRun) << std::flush;\n+        req->WriteHeader(\"Content-Type\", \"application/json\");\n+        req->WriteReply(HTTP_OK, strJSON);\n         return true;\n     }\n     default: {\n-        throw RESTERR(HTTP_NOT_FOUND, \"output format not found (available: \" + AvailableDataFormatsString() + \")\");\n+        return RESTERR(req, HTTP_NOT_FOUND, \"output format not found (available: \" + AvailableDataFormatsString() + \")\");\n     }\n     }\n \n@@ -597,11 +590,7 @@ static bool rest_getutxos(AcceptedConnection* conn,\n \n static const struct {\n     const char* prefix;\n-    bool (*handler)(AcceptedConnection* conn,\n-                    const std::string& strURIPart,\n-                    const std::string& strRequest,\n-                    const std::map<std::string, std::string>& mapHeaders,\n-                    bool fRun);\n+    bool (*handler)(HTTPRequest* req, const std::string& strReq);\n } uri_prefixes[] = {\n       {\"/rest/tx/\", rest_tx},\n       {\"/rest/block/notxdetails/\", rest_block_notxdetails},\n@@ -613,29 +602,19 @@ static const struct {\n       {\"/rest/getutxos\", rest_getutxos},\n };\n \n-bool HTTPReq_REST(AcceptedConnection* conn,\n-                  const std::string& strURI,\n-                  const string& strRequest,\n-                  const std::map<std::string, std::string>& mapHeaders,\n-                  bool fRun)\n+bool StartREST()\n {\n-    try {\n-        std::string statusmessage;\n-        if (RPCIsInWarmup(&statusmessage))\n-            throw RESTERR(HTTP_SERVICE_UNAVAILABLE, \"Service temporarily unavailable: \" + statusmessage);\n-\n-        for (unsigned int i = 0; i < ARRAYLEN(uri_prefixes); i++) {\n-            unsigned int plen = strlen(uri_prefixes[i].prefix);\n-            if (strURI.substr(0, plen) == uri_prefixes[i].prefix) {\n-                string strURIPart = strURI.substr(plen);\n-                return uri_prefixes[i].handler(conn, strURIPart, strRequest, mapHeaders, fRun);\n-            }\n-        }\n-    } catch (const RestErr& re) {\n-        conn->stream() << HTTPReply(re.status, re.message + \"\\r\\n\", false, false, \"text/plain\") << std::flush;\n-        return false;\n-    }\n+    for (unsigned int i = 0; i < ARRAYLEN(uri_prefixes); i++)\n+        RegisterHTTPHandler(uri_prefixes[i].prefix, false, uri_prefixes[i].handler);\n+    return true;\n+}\n \n-    conn->stream() << HTTPError(HTTP_NOT_FOUND, false) << std::flush;\n-    return false;\n+void InterruptREST()\n+{\n+}\n+\n+void StopREST()\n+{\n+    for (unsigned int i = 0; i < ARRAYLEN(uri_prefixes); i++)\n+        UnregisterHTTPHandler(uri_prefixes[i].prefix, false);\n }"
      },
      {
        "sha": "d83cd87f9400a23c9e23fc0c8da13a38aa0f49b2",
        "filename": "src/rpcprotocol.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 229,
        "changes": 229,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/rpcprotocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/rpcprotocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcprotocol.cpp?ref=40b556d3742a1f65d67e2d4c760d0b13fe8be5b7",
        "patch": "@@ -5,7 +5,6 @@\n \n #include \"rpcprotocol.h\"\n \n-#include \"clientversion.h\"\n #include \"random.h\"\n #include \"tinyformat.h\"\n #include \"util.h\"\n@@ -16,236 +15,8 @@\n #include <stdint.h>\n #include <fstream>\n \n-#include <boost/algorithm/string.hpp>\n-#include <boost/asio.hpp>\n-#include <boost/asio/ssl.hpp>\n-#include <boost/bind.hpp>\n-#include <boost/filesystem.hpp>\n-#include <boost/foreach.hpp>\n-#include <boost/iostreams/concepts.hpp>\n-#include <boost/iostreams/stream.hpp>\n-#include <boost/shared_ptr.hpp>\n-\n-#include \"univalue/univalue.h\"\n-\n using namespace std;\n \n-//! Number of bytes to allocate and read at most at once in post data\n-const size_t POST_READ_SIZE = 256 * 1024;\n-\n-/**\n- * HTTP protocol\n- * \n- * This ain't Apache.  We're just using HTTP header for the length field\n- * and to be compatible with other JSON-RPC implementations.\n- */\n-\n-string HTTPPost(const string& strMsg, const map<string,string>& mapRequestHeaders)\n-{\n-    ostringstream s;\n-    s << \"POST / HTTP/1.1\\r\\n\"\n-      << \"User-Agent: bitcoin-json-rpc/\" << FormatFullVersion() << \"\\r\\n\"\n-      << \"Host: 127.0.0.1\\r\\n\"\n-      << \"Content-Type: application/json\\r\\n\"\n-      << \"Content-Length: \" << strMsg.size() << \"\\r\\n\"\n-      << \"Connection: close\\r\\n\"\n-      << \"Accept: application/json\\r\\n\";\n-    BOOST_FOREACH(const PAIRTYPE(string, string)& item, mapRequestHeaders)\n-        s << item.first << \": \" << item.second << \"\\r\\n\";\n-    s << \"\\r\\n\" << strMsg;\n-\n-    return s.str();\n-}\n-\n-static string rfc1123Time()\n-{\n-    return DateTimeStrFormat(\"%a, %d %b %Y %H:%M:%S +0000\", GetTime());\n-}\n-\n-static const char *httpStatusDescription(int nStatus)\n-{\n-    switch (nStatus) {\n-        case HTTP_OK: return \"OK\";\n-        case HTTP_BAD_REQUEST: return \"Bad Request\";\n-        case HTTP_FORBIDDEN: return \"Forbidden\";\n-        case HTTP_NOT_FOUND: return \"Not Found\";\n-        case HTTP_INTERNAL_SERVER_ERROR: return \"Internal Server Error\";\n-        default: return \"\";\n-    }\n-}\n-\n-string HTTPError(int nStatus, bool keepalive, bool headersOnly)\n-{\n-    if (nStatus == HTTP_UNAUTHORIZED)\n-        return strprintf(\"HTTP/1.0 401 Authorization Required\\r\\n\"\n-            \"Date: %s\\r\\n\"\n-            \"Server: bitcoin-json-rpc/%s\\r\\n\"\n-            \"WWW-Authenticate: Basic realm=\\\"jsonrpc\\\"\\r\\n\"\n-            \"Content-Type: text/html\\r\\n\"\n-            \"Content-Length: 296\\r\\n\"\n-            \"\\r\\n\"\n-            \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\"\\r\\n\"\n-            \"\\\"http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd\\\">\\r\\n\"\n-            \"<HTML>\\r\\n\"\n-            \"<HEAD>\\r\\n\"\n-            \"<TITLE>Error</TITLE>\\r\\n\"\n-            \"<META HTTP-EQUIV='Content-Type' CONTENT='text/html; charset=ISO-8859-1'>\\r\\n\"\n-            \"</HEAD>\\r\\n\"\n-            \"<BODY><H1>401 Unauthorized.</H1></BODY>\\r\\n\"\n-            \"</HTML>\\r\\n\", rfc1123Time(), FormatFullVersion());\n-\n-    return HTTPReply(nStatus, httpStatusDescription(nStatus), keepalive,\n-                     headersOnly, \"text/plain\");\n-}\n-\n-string HTTPReplyHeader(int nStatus, bool keepalive, size_t contentLength, const char *contentType)\n-{\n-    return strprintf(\n-            \"HTTP/1.1 %d %s\\r\\n\"\n-            \"Date: %s\\r\\n\"\n-            \"Connection: %s\\r\\n\"\n-            \"Content-Length: %u\\r\\n\"\n-            \"Content-Type: %s\\r\\n\"\n-            \"Server: bitcoin-json-rpc/%s\\r\\n\"\n-            \"\\r\\n\",\n-        nStatus,\n-        httpStatusDescription(nStatus),\n-        rfc1123Time(),\n-        keepalive ? \"keep-alive\" : \"close\",\n-        contentLength,\n-        contentType,\n-        FormatFullVersion());\n-}\n-\n-string HTTPReply(int nStatus, const string& strMsg, bool keepalive,\n-                 bool headersOnly, const char *contentType)\n-{\n-    if (headersOnly)\n-    {\n-        return HTTPReplyHeader(nStatus, keepalive, 0, contentType);\n-    } else {\n-        return HTTPReplyHeader(nStatus, keepalive, strMsg.size(), contentType) + strMsg;\n-    }\n-}\n-\n-bool ReadHTTPRequestLine(std::basic_istream<char>& stream, int &proto,\n-                         string& http_method, string& http_uri)\n-{\n-    string str;\n-    getline(stream, str);\n-\n-    // HTTP request line is space-delimited\n-    vector<string> vWords;\n-    boost::split(vWords, str, boost::is_any_of(\" \"));\n-    if (vWords.size() < 2)\n-        return false;\n-\n-    // HTTP methods permitted: GET, POST\n-    http_method = vWords[0];\n-    if (http_method != \"GET\" && http_method != \"POST\")\n-        return false;\n-\n-    // HTTP URI must be an absolute path, relative to current host\n-    http_uri = vWords[1];\n-    if (http_uri.size() == 0 || http_uri[0] != '/')\n-        return false;\n-\n-    // parse proto, if present\n-    string strProto = \"\";\n-    if (vWords.size() > 2)\n-        strProto = vWords[2];\n-\n-    proto = 0;\n-    const char *ver = strstr(strProto.c_str(), \"HTTP/1.\");\n-    if (ver != NULL)\n-        proto = atoi(ver+7);\n-\n-    return true;\n-}\n-\n-int ReadHTTPStatus(std::basic_istream<char>& stream, int &proto)\n-{\n-    string str;\n-    getline(stream, str);\n-    vector<string> vWords;\n-    boost::split(vWords, str, boost::is_any_of(\" \"));\n-    if (vWords.size() < 2)\n-        return HTTP_INTERNAL_SERVER_ERROR;\n-    proto = 0;\n-    const char *ver = strstr(str.c_str(), \"HTTP/1.\");\n-    if (ver != NULL)\n-        proto = atoi(ver+7);\n-    return atoi(vWords[1].c_str());\n-}\n-\n-int ReadHTTPHeaders(std::basic_istream<char>& stream, map<string, string>& mapHeadersRet)\n-{\n-    int nLen = 0;\n-    while (true)\n-    {\n-        string str;\n-        std::getline(stream, str);\n-        if (str.empty() || str == \"\\r\")\n-            break;\n-        string::size_type nColon = str.find(\":\");\n-        if (nColon != string::npos)\n-        {\n-            string strHeader = str.substr(0, nColon);\n-            boost::trim(strHeader);\n-            boost::to_lower(strHeader);\n-            string strValue = str.substr(nColon+1);\n-            boost::trim(strValue);\n-            mapHeadersRet[strHeader] = strValue;\n-            if (strHeader == \"content-length\")\n-                nLen = atoi(strValue.c_str());\n-        }\n-    }\n-    return nLen;\n-}\n-\n-\n-int ReadHTTPMessage(std::basic_istream<char>& stream, map<string,\n-                    string>& mapHeadersRet, string& strMessageRet,\n-                    int nProto, size_t max_size)\n-{\n-    mapHeadersRet.clear();\n-    strMessageRet = \"\";\n-\n-    // Read header\n-    int nLen = ReadHTTPHeaders(stream, mapHeadersRet);\n-    if (nLen < 0 || (size_t)nLen > max_size)\n-        return HTTP_INTERNAL_SERVER_ERROR;\n-\n-    // Read message\n-    if (nLen > 0)\n-    {\n-        vector<char> vch;\n-        size_t ptr = 0;\n-        while (ptr < (size_t)nLen)\n-        {\n-            size_t bytes_to_read = std::min((size_t)nLen - ptr, POST_READ_SIZE);\n-            vch.resize(ptr + bytes_to_read);\n-            stream.read(&vch[ptr], bytes_to_read);\n-            if (!stream) // Connection lost while reading\n-                return HTTP_INTERNAL_SERVER_ERROR;\n-            ptr += bytes_to_read;\n-        }\n-        strMessageRet = string(vch.begin(), vch.end());\n-    }\n-\n-    string sConHdr = mapHeadersRet[\"connection\"];\n-\n-    if ((sConHdr != \"close\") && (sConHdr != \"keep-alive\"))\n-    {\n-        if (nProto >= 1)\n-            mapHeadersRet[\"connection\"] = \"keep-alive\";\n-        else\n-            mapHeadersRet[\"connection\"] = \"close\";\n-    }\n-\n-    return HTTP_OK;\n-}\n-\n /**\n  * JSON-RPC protocol.  Bitcoin speaks version 1.0 for maximum compatibility,\n  * but uses JSON-RPC 1.1/2.0 standards for parts of the 1.0 standard that were"
      },
      {
        "sha": "5381e4bcfd258e4e7e9d4803f8f19909ca2eef0e",
        "filename": "src/rpcprotocol.h",
        "status": "modified",
        "additions": 1,
        "deletions": 86,
        "changes": 87,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/rpcprotocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/rpcprotocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcprotocol.h?ref=40b556d3742a1f65d67e2d4c760d0b13fe8be5b7",
        "patch": "@@ -10,10 +10,6 @@\n #include <map>\n #include <stdint.h>\n #include <string>\n-#include <boost/iostreams/concepts.hpp>\n-#include <boost/iostreams/stream.hpp>\n-#include <boost/asio.hpp>\n-#include <boost/asio/ssl.hpp>\n #include <boost/filesystem.hpp>\n \n #include \"univalue/univalue.h\"\n@@ -26,6 +22,7 @@ enum HTTPStatusCode\n     HTTP_UNAUTHORIZED          = 401,\n     HTTP_FORBIDDEN             = 403,\n     HTTP_NOT_FOUND             = 404,\n+    HTTP_BAD_METHOD            = 405,\n     HTTP_INTERNAL_SERVER_ERROR = 500,\n     HTTP_SERVICE_UNAVAILABLE   = 503,\n };\n@@ -79,88 +76,6 @@ enum RPCErrorCode\n     RPC_WALLET_ALREADY_UNLOCKED     = -17, //! Wallet is already unlocked\n };\n \n-/**\n- * IOStream device that speaks SSL but can also speak non-SSL\n- */\n-template <typename Protocol>\n-class SSLIOStreamDevice : public boost::iostreams::device<boost::iostreams::bidirectional> {\n-public:\n-    SSLIOStreamDevice(boost::asio::ssl::stream<typename Protocol::socket> &streamIn, bool fUseSSLIn) : stream(streamIn)\n-    {\n-        fUseSSL = fUseSSLIn;\n-        fNeedHandshake = fUseSSLIn;\n-    }\n-\n-    void handshake(boost::asio::ssl::stream_base::handshake_type role)\n-    {\n-        if (!fNeedHandshake) return;\n-        fNeedHandshake = false;\n-        stream.handshake(role);\n-    }\n-    std::streamsize read(char* s, std::streamsize n)\n-    {\n-        handshake(boost::asio::ssl::stream_base::server); // HTTPS servers read first\n-        if (fUseSSL) return stream.read_some(boost::asio::buffer(s, n));\n-        return stream.next_layer().read_some(boost::asio::buffer(s, n));\n-    }\n-    std::streamsize write(const char* s, std::streamsize n)\n-    {\n-        handshake(boost::asio::ssl::stream_base::client); // HTTPS clients write first\n-        if (fUseSSL) return boost::asio::write(stream, boost::asio::buffer(s, n));\n-        return boost::asio::write(stream.next_layer(), boost::asio::buffer(s, n));\n-    }\n-    bool connect(const std::string& server, const std::string& port)\n-    {\n-        using namespace boost::asio::ip;\n-        tcp::resolver resolver(stream.get_io_service());\n-        tcp::resolver::iterator endpoint_iterator;\n-#if BOOST_VERSION >= 104300\n-        try {\n-#endif\n-            // The default query (flags address_configured) tries IPv6 if\n-            // non-localhost IPv6 configured, and IPv4 if non-localhost IPv4\n-            // configured.\n-            tcp::resolver::query query(server.c_str(), port.c_str());\n-            endpoint_iterator = resolver.resolve(query);\n-#if BOOST_VERSION >= 104300\n-        } catch (const boost::system::system_error&) {\n-            // If we at first don't succeed, try blanket lookup (IPv4+IPv6 independent of configured interfaces)\n-            tcp::resolver::query query(server.c_str(), port.c_str(), resolver_query_base::flags());\n-            endpoint_iterator = resolver.resolve(query);\n-        }\n-#endif\n-        boost::system::error_code error = boost::asio::error::host_not_found;\n-        tcp::resolver::iterator end;\n-        while (error && endpoint_iterator != end)\n-        {\n-            stream.lowest_layer().close();\n-            stream.lowest_layer().connect(*endpoint_iterator++, error);\n-        }\n-        if (error)\n-            return false;\n-        return true;\n-    }\n-\n-private:\n-    bool fNeedHandshake;\n-    bool fUseSSL;\n-    boost::asio::ssl::stream<typename Protocol::socket>& stream;\n-};\n-\n-std::string HTTPPost(const std::string& strMsg, const std::map<std::string,std::string>& mapRequestHeaders);\n-std::string HTTPError(int nStatus, bool keepalive,\n-                      bool headerOnly = false);\n-std::string HTTPReplyHeader(int nStatus, bool keepalive, size_t contentLength,\n-                      const char *contentType = \"application/json\");\n-std::string HTTPReply(int nStatus, const std::string& strMsg, bool keepalive,\n-                      bool headerOnly = false,\n-                      const char *contentType = \"application/json\");\n-bool ReadHTTPRequestLine(std::basic_istream<char>& stream, int &proto,\n-                         std::string& http_method, std::string& http_uri);\n-int ReadHTTPStatus(std::basic_istream<char>& stream, int &proto);\n-int ReadHTTPHeaders(std::basic_istream<char>& stream, std::map<std::string, std::string>& mapHeadersRet);\n-int ReadHTTPMessage(std::basic_istream<char>& stream, std::map<std::string, std::string>& mapHeadersRet,\n-                    std::string& strMessageRet, int nProto, size_t max_size);\n std::string JSONRPCRequest(const std::string& strMethod, const UniValue& params, const UniValue& id);\n UniValue JSONRPCReplyObj(const UniValue& result, const UniValue& error, const UniValue& id);\n std::string JSONRPCReply(const UniValue& result, const UniValue& error, const UniValue& id);"
      },
      {
        "sha": "5d7e2125e54a9c1e9b4f72721a285030ec8bc41c",
        "filename": "src/rpcserver.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 513,
        "changes": 554,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/rpcserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/rpcserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcserver.cpp?ref=40b556d3742a1f65d67e2d4c760d0b13fe8be5b7",
        "patch": "@@ -12,13 +12,9 @@\n #include \"ui_interface.h\"\n #include \"util.h\"\n #include \"utilstrencodings.h\"\n-#ifdef ENABLE_WALLET\n-#include \"wallet/wallet.h\"\n-#endif\n \n-#include <boost/algorithm/string.hpp>\n-#include <boost/asio.hpp>\n-#include <boost/asio/ssl.hpp>\n+#include \"univalue/univalue.h\"\n+\n #include <boost/bind.hpp>\n #include <boost/filesystem.hpp>\n #include <boost/foreach.hpp>\n@@ -27,28 +23,20 @@\n #include <boost/shared_ptr.hpp>\n #include <boost/signals2/signal.hpp>\n #include <boost/thread.hpp>\n+#include <boost/algorithm/string/case_conv.hpp> // for to_upper()\n \n-#include \"univalue/univalue.h\"\n-\n-using namespace boost::asio;\n using namespace RPCServer;\n using namespace std;\n \n-static std::string strRPCUserColonPass;\n-\n static bool fRPCRunning = false;\n static bool fRPCInWarmup = true;\n static std::string rpcWarmupStatus(\"RPC server started\");\n static CCriticalSection cs_rpcWarmup;\n-\n-//! These are created by StartRPCThreads, destroyed in StopRPCThreads\n-static boost::asio::io_service* rpc_io_service = NULL;\n-static map<string, boost::shared_ptr<deadline_timer> > deadlineTimers;\n-static ssl::context* rpc_ssl_context = NULL;\n-static boost::thread_group* rpc_worker_group = NULL;\n-static boost::asio::io_service::work *rpc_dummy_work = NULL;\n-static std::vector<CSubNet> rpc_allow_subnets; //!< List of subnets to allow RPC connections from\n-static std::vector< boost::shared_ptr<ip::tcp::acceptor> > rpc_acceptors;\n+/* Timer-creating functions */\n+static std::vector<RPCTimerInterface*> timerInterfaces;\n+/* Map of name to timer.\n+ * @note Can be changed to std::unique_ptr when C++11 */\n+static std::map<std::string, boost::shared_ptr<RPCTimerBase> > deadlineTimers;\n \n static struct CRPCSignals\n {\n@@ -169,7 +157,6 @@ vector<unsigned char> ParseHexO(const UniValue& o, string strKey)\n     return ParseHexV(find_value(o, strKey), strKey);\n }\n \n-\n /**\n  * Note: This interface may still be subject to change.\n  */\n@@ -261,8 +248,6 @@ UniValue stop(const UniValue& params, bool fHelp)\n     return \"Bitcoin server stopping\";\n }\n \n-\n-\n /**\n  * Call Table\n  */\n@@ -399,381 +384,34 @@ CRPCTable::CRPCTable()\n     }\n }\n \n-const CRPCCommand *CRPCTable::operator[](const std::string& name) const\n+const CRPCCommand *CRPCTable::operator[](const std::string &name) const\n {\n     map<string, const CRPCCommand*>::const_iterator it = mapCommands.find(name);\n     if (it == mapCommands.end())\n         return NULL;\n     return (*it).second;\n }\n \n-\n-bool HTTPAuthorized(map<string, string>& mapHeaders)\n-{\n-    string strAuth = mapHeaders[\"authorization\"];\n-    if (strAuth.substr(0,6) != \"Basic \")\n-        return false;\n-    string strUserPass64 = strAuth.substr(6); boost::trim(strUserPass64);\n-    string strUserPass = DecodeBase64(strUserPass64);\n-    return TimingResistantEqual(strUserPass, strRPCUserColonPass);\n-}\n-\n-void ErrorReply(std::ostream& stream, const UniValue& objError, const UniValue& id)\n-{\n-    // Send error reply from json-rpc error object\n-    int nStatus = HTTP_INTERNAL_SERVER_ERROR;\n-    int code = find_value(objError, \"code\").get_int();\n-    if (code == RPC_INVALID_REQUEST) nStatus = HTTP_BAD_REQUEST;\n-    else if (code == RPC_METHOD_NOT_FOUND) nStatus = HTTP_NOT_FOUND;\n-    string strReply = JSONRPCReply(NullUniValue, objError, id);\n-    stream << HTTPReply(nStatus, strReply, false) << std::flush;\n-}\n-\n-CNetAddr BoostAsioToCNetAddr(boost::asio::ip::address address)\n-{\n-    CNetAddr netaddr;\n-    // Make sure that IPv4-compatible and IPv4-mapped IPv6 addresses are treated as IPv4 addresses\n-    if (address.is_v6()\n-     && (address.to_v6().is_v4_compatible()\n-      || address.to_v6().is_v4_mapped()))\n-        address = address.to_v6().to_v4();\n-\n-    if(address.is_v4())\n-    {\n-        boost::asio::ip::address_v4::bytes_type bytes = address.to_v4().to_bytes();\n-        netaddr.SetRaw(NET_IPV4, &bytes[0]);\n-    }\n-    else\n-    {\n-        boost::asio::ip::address_v6::bytes_type bytes = address.to_v6().to_bytes();\n-        netaddr.SetRaw(NET_IPV6, &bytes[0]);\n-    }\n-    return netaddr;\n-}\n-\n-bool ClientAllowed(const boost::asio::ip::address& address)\n-{\n-    CNetAddr netaddr = BoostAsioToCNetAddr(address);\n-    BOOST_FOREACH(const CSubNet &subnet, rpc_allow_subnets)\n-        if (subnet.Match(netaddr))\n-            return true;\n-    return false;\n-}\n-\n-template <typename Protocol>\n-class AcceptedConnectionImpl : public AcceptedConnection\n-{\n-public:\n-    AcceptedConnectionImpl(\n-            boost::asio::io_service& io_service,\n-            ssl::context &context,\n-            bool fUseSSL) :\n-        sslStream(io_service, context),\n-        _d(sslStream, fUseSSL),\n-        _stream(_d)\n-    {\n-    }\n-\n-    virtual std::iostream& stream()\n-    {\n-        return _stream;\n-    }\n-\n-    virtual std::string peer_address_to_string() const\n-    {\n-        return peer.address().to_string();\n-    }\n-\n-    virtual void close()\n-    {\n-        _stream.close();\n-    }\n-\n-    typename Protocol::endpoint peer;\n-    boost::asio::ssl::stream<typename Protocol::socket> sslStream;\n-\n-private:\n-    SSLIOStreamDevice<Protocol> _d;\n-    boost::iostreams::stream< SSLIOStreamDevice<Protocol> > _stream;\n-};\n-\n-void ServiceConnection(AcceptedConnection *conn);\n-\n-//! Forward declaration required for RPCListen\n-template <typename Protocol, typename SocketAcceptorService>\n-static void RPCAcceptHandler(boost::shared_ptr< basic_socket_acceptor<Protocol, SocketAcceptorService> > acceptor,\n-                             ssl::context& context,\n-                             bool fUseSSL,\n-                             boost::shared_ptr< AcceptedConnection > conn,\n-                             const boost::system::error_code& error);\n-\n-/**\n- * Sets up I/O resources to accept and handle a new connection.\n- */\n-template <typename Protocol, typename SocketAcceptorService>\n-static void RPCListen(boost::shared_ptr< basic_socket_acceptor<Protocol, SocketAcceptorService> > acceptor,\n-                   ssl::context& context,\n-                   const bool fUseSSL)\n-{\n-    // Accept connection\n-    boost::shared_ptr< AcceptedConnectionImpl<Protocol> > conn(new AcceptedConnectionImpl<Protocol>(acceptor->get_io_service(), context, fUseSSL));\n-\n-    acceptor->async_accept(\n-            conn->sslStream.lowest_layer(),\n-            conn->peer,\n-            boost::bind(&RPCAcceptHandler<Protocol, SocketAcceptorService>,\n-                acceptor,\n-                boost::ref(context),\n-                fUseSSL,\n-                conn,\n-                _1));\n-}\n-\n-\n-/**\n- * Accept and handle incoming connection.\n- */\n-template <typename Protocol, typename SocketAcceptorService>\n-static void RPCAcceptHandler(boost::shared_ptr< basic_socket_acceptor<Protocol, SocketAcceptorService> > acceptor,\n-                             ssl::context& context,\n-                             const bool fUseSSL,\n-                             boost::shared_ptr< AcceptedConnection > conn,\n-                             const boost::system::error_code& error)\n+bool StartRPC()\n {\n-    // Immediately start accepting new connections, except when we're cancelled or our socket is closed.\n-    if (error != boost::asio::error::operation_aborted && acceptor->is_open())\n-        RPCListen(acceptor, context, fUseSSL);\n-\n-    AcceptedConnectionImpl<ip::tcp>* tcp_conn = dynamic_cast< AcceptedConnectionImpl<ip::tcp>* >(conn.get());\n-\n-    if (error)\n-    {\n-        // TODO: Actually handle errors\n-        LogPrintf(\"%s: Error: %s\\n\", __func__, error.message());\n-    }\n-    // Restrict callers by IP.  It is important to\n-    // do this before starting client thread, to filter out\n-    // certain DoS and misbehaving clients.\n-    else if (tcp_conn && !ClientAllowed(tcp_conn->peer.address()))\n-    {\n-        // Only send a 403 if we're not using SSL to prevent a DoS during the SSL handshake.\n-        if (!fUseSSL)\n-            conn->stream() << HTTPError(HTTP_FORBIDDEN, false) << std::flush;\n-        conn->close();\n-    }\n-    else {\n-        ServiceConnection(conn.get());\n-        conn->close();\n-    }\n-}\n-\n-static ip::tcp::endpoint ParseEndpoint(const std::string &strEndpoint, int defaultPort)\n-{\n-    std::string addr;\n-    int port = defaultPort;\n-    SplitHostPort(strEndpoint, port, addr);\n-    return ip::tcp::endpoint(boost::asio::ip::address::from_string(addr), port);\n-}\n-\n-void StartRPCThreads()\n-{\n-    rpc_allow_subnets.clear();\n-    rpc_allow_subnets.push_back(CSubNet(\"127.0.0.0/8\")); // always allow IPv4 local subnet\n-    rpc_allow_subnets.push_back(CSubNet(\"::1\")); // always allow IPv6 localhost\n-    if (mapMultiArgs.count(\"-rpcallowip\"))\n-    {\n-        const vector<string>& vAllow = mapMultiArgs[\"-rpcallowip\"];\n-        BOOST_FOREACH(string strAllow, vAllow)\n-        {\n-            CSubNet subnet(strAllow);\n-            if(!subnet.IsValid())\n-            {\n-                uiInterface.ThreadSafeMessageBox(\n-                    strprintf(\"Invalid -rpcallowip subnet specification: %s. Valid are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24).\", strAllow),\n-                    \"\", CClientUIInterface::MSG_ERROR);\n-                StartShutdown();\n-                return;\n-            }\n-            rpc_allow_subnets.push_back(subnet);\n-        }\n-    }\n-    std::string strAllowed;\n-    BOOST_FOREACH(const CSubNet &subnet, rpc_allow_subnets)\n-        strAllowed += subnet.ToString() + \" \";\n-    LogPrint(\"rpc\", \"Allowing RPC connections from: %s\\n\", strAllowed);\n-\n-    if (mapArgs[\"-rpcpassword\"] == \"\")\n-    {\n-        LogPrintf(\"No rpcpassword set - using random cookie authentication\\n\");\n-        if (!GenerateAuthCookie(&strRPCUserColonPass)) {\n-            uiInterface.ThreadSafeMessageBox(\n-                _(\"Error: A fatal internal error occurred, see debug.log for details\"), // Same message as AbortNode\n-                \"\", CClientUIInterface::MSG_ERROR);\n-            StartShutdown();\n-            return;\n-        }\n-    } else {\n-        strRPCUserColonPass = mapArgs[\"-rpcuser\"] + \":\" + mapArgs[\"-rpcpassword\"];\n-    }\n-\n-    assert(rpc_io_service == NULL);\n-    rpc_io_service = new boost::asio::io_service();\n-    rpc_ssl_context = new ssl::context(*rpc_io_service, ssl::context::sslv23);\n-\n-    const bool fUseSSL = GetBoolArg(\"-rpcssl\", false);\n-\n-    if (fUseSSL)\n-    {\n-        rpc_ssl_context->set_options(ssl::context::no_sslv2 | ssl::context::no_sslv3);\n-\n-        boost::filesystem::path pathCertFile(GetArg(\"-rpcsslcertificatechainfile\", \"server.cert\"));\n-        if (!pathCertFile.is_complete()) pathCertFile = boost::filesystem::path(GetDataDir()) / pathCertFile;\n-        if (boost::filesystem::exists(pathCertFile)) rpc_ssl_context->use_certificate_chain_file(pathCertFile.string());\n-        else LogPrintf(\"ThreadRPCServer ERROR: missing server certificate file %s\\n\", pathCertFile.string());\n-\n-        boost::filesystem::path pathPKFile(GetArg(\"-rpcsslprivatekeyfile\", \"server.pem\"));\n-        if (!pathPKFile.is_complete()) pathPKFile = boost::filesystem::path(GetDataDir()) / pathPKFile;\n-        if (boost::filesystem::exists(pathPKFile)) rpc_ssl_context->use_private_key_file(pathPKFile.string(), ssl::context::pem);\n-        else LogPrintf(\"ThreadRPCServer ERROR: missing server private key file %s\\n\", pathPKFile.string());\n-\n-        string strCiphers = GetArg(\"-rpcsslciphers\", \"TLSv1.2+HIGH:TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!3DES:@STRENGTH\");\n-        SSL_CTX_set_cipher_list(rpc_ssl_context->impl(), strCiphers.c_str());\n-    }\n-\n-    std::vector<ip::tcp::endpoint> vEndpoints;\n-    bool bBindAny = false;\n-    int defaultPort = GetArg(\"-rpcport\", BaseParams().RPCPort());\n-    if (!mapArgs.count(\"-rpcallowip\")) // Default to loopback if not allowing external IPs\n-    {\n-        vEndpoints.push_back(ip::tcp::endpoint(boost::asio::ip::address_v6::loopback(), defaultPort));\n-        vEndpoints.push_back(ip::tcp::endpoint(boost::asio::ip::address_v4::loopback(), defaultPort));\n-        if (mapArgs.count(\"-rpcbind\"))\n-        {\n-            LogPrintf(\"WARNING: option -rpcbind was ignored because -rpcallowip was not specified, refusing to allow everyone to connect\\n\");\n-        }\n-    } else if (mapArgs.count(\"-rpcbind\")) // Specific bind address\n-    {\n-        BOOST_FOREACH(const std::string &addr, mapMultiArgs[\"-rpcbind\"])\n-        {\n-            try {\n-                vEndpoints.push_back(ParseEndpoint(addr, defaultPort));\n-            }\n-            catch (const boost::system::system_error&)\n-            {\n-                uiInterface.ThreadSafeMessageBox(\n-                    strprintf(_(\"Could not parse -rpcbind value %s as network address\"), addr),\n-                    \"\", CClientUIInterface::MSG_ERROR);\n-                StartShutdown();\n-                return;\n-            }\n-        }\n-    } else { // No specific bind address specified, bind to any\n-        vEndpoints.push_back(ip::tcp::endpoint(boost::asio::ip::address_v6::any(), defaultPort));\n-        vEndpoints.push_back(ip::tcp::endpoint(boost::asio::ip::address_v4::any(), defaultPort));\n-        // Prefer making the socket dual IPv6/IPv4 instead of binding\n-        // to both addresses separately.\n-        bBindAny = true;\n-    }\n-\n-    bool fListening = false;\n-    std::string strerr;\n-    std::string straddress;\n-    BOOST_FOREACH(const ip::tcp::endpoint &endpoint, vEndpoints)\n-    {\n-        try {\n-            boost::asio::ip::address bindAddress = endpoint.address();\n-            straddress = bindAddress.to_string();\n-            LogPrintf(\"Binding RPC on address %s port %i (IPv4+IPv6 bind any: %i)\\n\", straddress, endpoint.port(), bBindAny);\n-            boost::system::error_code v6_only_error;\n-            boost::shared_ptr<ip::tcp::acceptor> acceptor(new ip::tcp::acceptor(*rpc_io_service));\n-\n-            acceptor->open(endpoint.protocol());\n-            acceptor->set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));\n-\n-            // Try making the socket dual IPv6/IPv4 when listening on the IPv6 \"any\" address\n-            acceptor->set_option(boost::asio::ip::v6_only(\n-                !bBindAny || bindAddress != boost::asio::ip::address_v6::any()), v6_only_error);\n-\n-            acceptor->bind(endpoint);\n-            acceptor->listen(socket_base::max_connections);\n-\n-            RPCListen(acceptor, *rpc_ssl_context, fUseSSL);\n-\n-            fListening = true;\n-            rpc_acceptors.push_back(acceptor);\n-            // If dual IPv6/IPv4 bind successful, skip binding to IPv4 separately\n-            if(bBindAny && bindAddress == boost::asio::ip::address_v6::any() && !v6_only_error)\n-                break;\n-        }\n-        catch (const boost::system::system_error& e)\n-        {\n-            LogPrintf(\"ERROR: Binding RPC on address %s port %i failed: %s\\n\", straddress, endpoint.port(), e.what());\n-            strerr = strprintf(_(\"An error occurred while setting up the RPC address %s port %u for listening: %s\"), straddress, endpoint.port(), e.what());\n-        }\n-    }\n-\n-    if (!fListening) {\n-        uiInterface.ThreadSafeMessageBox(strerr, \"\", CClientUIInterface::MSG_ERROR);\n-        StartShutdown();\n-        return;\n-    }\n-\n-    rpc_worker_group = new boost::thread_group();\n-    for (int i = 0; i < GetArg(\"-rpcthreads\", 4); i++)\n-        rpc_worker_group->create_thread(boost::bind(&boost::asio::io_service::run, rpc_io_service));\n+    LogPrint(\"rpc\", \"Starting RPC\\n\");\n     fRPCRunning = true;\n     g_rpcSignals.Started();\n+    return true;\n }\n \n-void StartDummyRPCThread()\n+void InterruptRPC()\n {\n-    if(rpc_io_service == NULL)\n-    {\n-        rpc_io_service = new boost::asio::io_service();\n-        /* Create dummy \"work\" to keep the thread from exiting when no timeouts active,\n-         * see http://www.boost.org/doc/libs/1_51_0/doc/html/boost_asio/reference/io_service.html#boost_asio.reference.io_service.stopping_the_io_service_from_running_out_of_work */\n-        rpc_dummy_work = new boost::asio::io_service::work(*rpc_io_service);\n-        rpc_worker_group = new boost::thread_group();\n-        rpc_worker_group->create_thread(boost::bind(&boost::asio::io_service::run, rpc_io_service));\n-        fRPCRunning = true;\n-    }\n+    LogPrint(\"rpc\", \"Interrupting RPC\\n\");\n+    // Interrupt e.g. running longpolls\n+    fRPCRunning = false;\n }\n \n-void StopRPCThreads()\n+void StopRPC()\n {\n-    if (rpc_io_service == NULL) return;\n-    // Set this to false first, so that longpolling loops will exit when woken up\n-    fRPCRunning = false;\n-\n-    // First, cancel all timers and acceptors\n-    // This is not done automatically by ->stop(), and in some cases the destructor of\n-    // boost::asio::io_service can hang if this is skipped.\n-    boost::system::error_code ec;\n-    BOOST_FOREACH(const boost::shared_ptr<ip::tcp::acceptor> &acceptor, rpc_acceptors)\n-    {\n-        acceptor->cancel(ec);\n-        if (ec)\n-            LogPrintf(\"%s: Warning: %s when cancelling acceptor\\n\", __func__, ec.message());\n-    }\n-    rpc_acceptors.clear();\n-    BOOST_FOREACH(const PAIRTYPE(std::string, boost::shared_ptr<deadline_timer>) &timer, deadlineTimers)\n-    {\n-        timer.second->cancel(ec);\n-        if (ec)\n-            LogPrintf(\"%s: Warning: %s when cancelling timer\\n\", __func__, ec.message());\n-    }\n+    LogPrint(\"rpc\", \"Stopping RPC\\n\");\n     deadlineTimers.clear();\n-\n-    DeleteAuthCookie();\n-\n-    rpc_io_service->stop();\n     g_rpcSignals.Stopped();\n-    if (rpc_worker_group != NULL)\n-        rpc_worker_group->join_all();\n-    delete rpc_dummy_work; rpc_dummy_work = NULL;\n-    delete rpc_worker_group; rpc_worker_group = NULL;\n-    delete rpc_ssl_context; rpc_ssl_context = NULL;\n-    delete rpc_io_service; rpc_io_service = NULL;\n }\n \n bool IsRPCRunning()\n@@ -802,36 +440,6 @@ bool RPCIsInWarmup(std::string *outStatus)\n     return fRPCInWarmup;\n }\n \n-void RPCRunHandler(const boost::system::error_code& err, boost::function<void(void)> func)\n-{\n-    if (!err)\n-        func();\n-}\n-\n-void RPCRunLater(const std::string& name, boost::function<void(void)> func, int64_t nSeconds)\n-{\n-    assert(rpc_io_service != NULL);\n-\n-    if (deadlineTimers.count(name) == 0)\n-    {\n-        deadlineTimers.insert(make_pair(name,\n-                                        boost::shared_ptr<deadline_timer>(new deadline_timer(*rpc_io_service))));\n-    }\n-    deadlineTimers[name]->expires_from_now(boost::posix_time::seconds(nSeconds));\n-    deadlineTimers[name]->async_wait(boost::bind(RPCRunHandler, _1, func));\n-}\n-\n-class JSONRequest\n-{\n-public:\n-    UniValue id;\n-    string strMethod;\n-    UniValue params;\n-\n-    JSONRequest() { id = NullUniValue; }\n-    void parse(const UniValue& valRequest);\n-};\n-\n void JSONRequest::parse(const UniValue& valRequest)\n {\n     // Parse request\n@@ -862,7 +470,6 @@ void JSONRequest::parse(const UniValue& valRequest)\n         throw JSONRPCError(RPC_INVALID_REQUEST, \"Params must be an array\");\n }\n \n-\n static UniValue JSONRPCExecOne(const UniValue& req)\n {\n     UniValue rpc_result(UniValue::VOBJ);\n@@ -887,7 +494,7 @@ static UniValue JSONRPCExecOne(const UniValue& req)\n     return rpc_result;\n }\n \n-static string JSONRPCExecBatch(const UniValue& vReq)\n+std::string JSONRPCExecBatch(const UniValue& vReq)\n {\n     UniValue ret(UniValue::VARR);\n     for (unsigned int reqIdx = 0; reqIdx < vReq.size(); reqIdx++)\n@@ -896,107 +503,6 @@ static string JSONRPCExecBatch(const UniValue& vReq)\n     return ret.write() + \"\\n\";\n }\n \n-static bool HTTPReq_JSONRPC(AcceptedConnection *conn,\n-                            string& strRequest,\n-                            map<string, string>& mapHeaders,\n-                            bool fRun)\n-{\n-    // Check authorization\n-    if (mapHeaders.count(\"authorization\") == 0)\n-    {\n-        conn->stream() << HTTPError(HTTP_UNAUTHORIZED, false) << std::flush;\n-        return false;\n-    }\n-\n-    if (!HTTPAuthorized(mapHeaders))\n-    {\n-        LogPrintf(\"ThreadRPCServer incorrect password attempt from %s\\n\", conn->peer_address_to_string());\n-        /* Deter brute-forcing\n-           We don't support exposing the RPC port, so this shouldn't result\n-           in a DoS. */\n-        MilliSleep(250);\n-\n-        conn->stream() << HTTPError(HTTP_UNAUTHORIZED, false) << std::flush;\n-        return false;\n-    }\n-\n-    JSONRequest jreq;\n-    try\n-    {\n-        // Parse request\n-        UniValue valRequest;\n-        if (!valRequest.read(strRequest))\n-            throw JSONRPCError(RPC_PARSE_ERROR, \"Parse error\");\n-\n-        string strReply;\n-\n-        // singleton request\n-        if (valRequest.isObject()) {\n-            jreq.parse(valRequest);\n-\n-            UniValue result = tableRPC.execute(jreq.strMethod, jreq.params);\n-\n-            // Send reply\n-            strReply = JSONRPCReply(result, NullUniValue, jreq.id);\n-\n-        // array of requests\n-        } else if (valRequest.isArray())\n-            strReply = JSONRPCExecBatch(valRequest.get_array());\n-        else\n-            throw JSONRPCError(RPC_PARSE_ERROR, \"Top-level object parse error\");\n-\n-        conn->stream() << HTTPReplyHeader(HTTP_OK, fRun, strReply.size()) << strReply << std::flush;\n-    }\n-    catch (const UniValue& objError)\n-    {\n-        ErrorReply(conn->stream(), objError, jreq.id);\n-        return false;\n-    }\n-    catch (const std::exception& e)\n-    {\n-        ErrorReply(conn->stream(), JSONRPCError(RPC_PARSE_ERROR, e.what()), jreq.id);\n-        return false;\n-    }\n-    return true;\n-}\n-\n-void ServiceConnection(AcceptedConnection *conn)\n-{\n-    bool fRun = true;\n-    while (fRun && !ShutdownRequested())\n-    {\n-        int nProto = 0;\n-        map<string, string> mapHeaders;\n-        string strRequest, strMethod, strURI;\n-\n-        // Read HTTP request line\n-        if (!ReadHTTPRequestLine(conn->stream(), nProto, strMethod, strURI))\n-            break;\n-\n-        // Read HTTP message headers and body\n-        ReadHTTPMessage(conn->stream(), mapHeaders, strRequest, nProto, MAX_SIZE);\n-\n-        // HTTP Keep-Alive is false; close connection immediately\n-        if ((mapHeaders[\"connection\"] == \"close\") || (!GetBoolArg(\"-rpckeepalive\", true)))\n-            fRun = false;\n-\n-        // Process via JSON-RPC API\n-        if (strURI == \"/\") {\n-            if (!HTTPReq_JSONRPC(conn, strRequest, mapHeaders, fRun))\n-                break;\n-\n-        // Process via HTTP REST API\n-        } else if (strURI.substr(0, 6) == \"/rest/\" && GetBoolArg(\"-rest\", false)) {\n-            if (!HTTPReq_REST(conn, strURI, strRequest, mapHeaders, fRun))\n-                break;\n-\n-        } else {\n-            conn->stream() << HTTPError(HTTP_NOT_FOUND, false) << std::flush;\n-            break;\n-        }\n-    }\n-}\n-\n UniValue CRPCTable::execute(const std::string &strMethod, const UniValue &params) const\n {\n     // Return immediately if in warmup\n@@ -1037,4 +543,26 @@ std::string HelpExampleRpc(const std::string& methodname, const std::string& arg\n         \"\\\"method\\\": \\\"\" + methodname + \"\\\", \\\"params\\\": [\" + args + \"] }' -H 'content-type: text/plain;' http://127.0.0.1:8332/\\n\";\n }\n \n+void RPCRegisterTimerInterface(RPCTimerInterface *iface)\n+{\n+    timerInterfaces.push_back(iface);\n+}\n+\n+void RPCUnregisterTimerInterface(RPCTimerInterface *iface)\n+{\n+    std::vector<RPCTimerInterface*>::iterator i = std::find(timerInterfaces.begin(), timerInterfaces.end(), iface);\n+    assert(i != timerInterfaces.end());\n+    timerInterfaces.erase(i);\n+}\n+\n+void RPCRunLater(const std::string& name, boost::function<void(void)> func, int64_t nSeconds)\n+{\n+    if (timerInterfaces.empty())\n+        throw JSONRPCError(RPC_INTERNAL_ERROR, \"No timer handler registered for RPC\");\n+    deadlineTimers.erase(name);\n+    RPCTimerInterface* timerInterface = timerInterfaces[0];\n+    LogPrint(\"rpc\", \"queue run of timer %s in %i seconds (using %s)\\n\", name, nSeconds, timerInterface->Name());\n+    deadlineTimers.insert(std::make_pair(name, timerInterface->NewTimer(func, nSeconds)));\n+}\n+\n const CRPCTable tableRPC;"
      },
      {
        "sha": "ac821d5b5540428a6169d624276683deb771d945",
        "filename": "src/rpcserver.h",
        "status": "modified",
        "additions": 44,
        "deletions": 28,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/rpcserver.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7/src/rpcserver.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcserver.h?ref=40b556d3742a1f65d67e2d4c760d0b13fe8be5b7",
        "patch": "@@ -32,26 +32,17 @@ namespace RPCServer\n class CBlockIndex;\n class CNetAddr;\n \n-class AcceptedConnection\n+class JSONRequest\n {\n public:\n-    virtual ~AcceptedConnection() {}\n+    UniValue id;\n+    std::string strMethod;\n+    UniValue params;\n \n-    virtual std::iostream& stream() = 0;\n-    virtual std::string peer_address_to_string() const = 0;\n-    virtual void close() = 0;\n+    JSONRequest() { id = NullUniValue; }\n+    void parse(const UniValue& valRequest);\n };\n \n-/** Start RPC threads */\n-void StartRPCThreads();\n-/**\n- * Alternative to StartRPCThreads for the GUI, when no server is\n- * used. The RPC thread in this case is only used to handle timeouts.\n- * If real RPC threads have already been started this is a no-op.\n- */\n-void StartDummyRPCThread();\n-/** Stop RPC threads */\n-void StopRPCThreads();\n /** Query whether RPC is running */\n bool IsRPCRunning();\n \n@@ -81,15 +72,45 @@ void RPCTypeCheck(const UniValue& params,\n void RPCTypeCheckObj(const UniValue& o,\n                   const std::map<std::string, UniValue::VType>& typesExpected, bool fAllowNull=false);\n \n+/** Opaque base class for timers returned by NewTimerFunc.\n+ * This provides no methods at the moment, but makes sure that delete\n+ * cleans up the whole state.\n+ */\n+class RPCTimerBase\n+{\n+public:\n+    virtual ~RPCTimerBase() {}\n+};\n+\n /**\n- * Run func nSeconds from now. Uses boost deadline timers.\n+ * RPC timer \"driver\".\n+ */\n+class RPCTimerInterface\n+{\n+public:\n+    virtual ~RPCTimerInterface() {}\n+    /** Implementation name */\n+    virtual const char *Name() = 0;\n+    /** Factory function for timers.\n+     * RPC will call the function to create a timer that will call func in *seconds* seconds.\n+     * @note As the RPC mechanism is backend-neutral, it can use different implementations of timers.\n+     * This is needed to cope with the case in which there is no HTTP server, but\n+     * only GUI RPC console, and to break the dependency of pcserver on httprpc.\n+     */\n+    virtual RPCTimerBase* NewTimer(boost::function<void(void)>&, int64_t) = 0;\n+};\n+\n+/** Register factory function for timers */\n+void RPCRegisterTimerInterface(RPCTimerInterface *iface);\n+/** Unregister factory function for timers */\n+void RPCUnregisterTimerInterface(RPCTimerInterface *iface);\n+\n+/**\n+ * Run func nSeconds from now.\n  * Overrides previous timer <name> (if any).\n  */\n void RPCRunLater(const std::string& name, boost::function<void(void)> func, int64_t nSeconds);\n \n-//! Convert boost::asio address to CNetAddr\n-extern CNetAddr BoostAsioToCNetAddr(boost::asio::ip::address address);\n-\n typedef UniValue(*rpcfn_type)(const UniValue& params, bool fHelp);\n \n class CRPCCommand\n@@ -134,9 +155,6 @@ extern uint256 ParseHashO(const UniValue& o, std::string strKey);\n extern std::vector<unsigned char> ParseHexV(const UniValue& v, std::string strName);\n extern std::vector<unsigned char> ParseHexO(const UniValue& o, std::string strKey);\n \n-extern void InitRPCMining();\n-extern void ShutdownRPCMining();\n-\n extern int64_t nWalletUnlockTime;\n extern CAmount AmountFromValue(const UniValue& value);\n extern UniValue ValueFromAmount(const CAmount& amount);\n@@ -244,11 +262,9 @@ extern UniValue getchaintips(const UniValue& params, bool fHelp);\n extern UniValue invalidateblock(const UniValue& params, bool fHelp);\n extern UniValue reconsiderblock(const UniValue& params, bool fHelp);\n \n-// in rest.cpp\n-extern bool HTTPReq_REST(AcceptedConnection *conn,\n-                  const std::string& strURI,\n-                  const std::string& strRequest,\n-                  const std::map<std::string, std::string>& mapHeaders,\n-                  bool fRun);\n+bool StartRPC();\n+void InterruptRPC();\n+void StopRPC();\n+std::string JSONRPCExecBatch(const UniValue& vReq);\n \n #endif // BITCOIN_RPCSERVER_H"
      }
    ]
  },
  {
    "sha": "57d85d9bee20edb6c3070504f23b6a2be2802654",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1N2Q4NWQ5YmVlMjBlZGI2YzMwNzA1MDRmMjNiNmEyYmUyODAyNjU0",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-08-28T10:20:01Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-09-03T08:59:19Z"
      },
      "message": "doc: mention SSL support dropped for RPC in release notes",
      "tree": {
        "sha": "b08ba54e5e74d3353a717feada510b4fb97bbf27",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b08ba54e5e74d3353a717feada510b4fb97bbf27"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/57d85d9bee20edb6c3070504f23b6a2be2802654",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/57d85d9bee20edb6c3070504f23b6a2be2802654",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/57d85d9bee20edb6c3070504f23b6a2be2802654",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/57d85d9bee20edb6c3070504f23b6a2be2802654/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "40b556d3742a1f65d67e2d4c760d0b13fe8be5b7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/40b556d3742a1f65d67e2d4c760d0b13fe8be5b7"
      }
    ],
    "stats": {
      "total": 23,
      "additions": 23,
      "deletions": 0
    },
    "files": [
      {
        "sha": "2fc601d4354259796a04650c75315aa5b41f8b15",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/57d85d9bee20edb6c3070504f23b6a2be2802654/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/57d85d9bee20edb6c3070504f23b6a2be2802654/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=57d85d9bee20edb6c3070504f23b6a2be2802654",
        "patch": "@@ -4,6 +4,29 @@ release-notes at release time)\n Notable changes\n ===============\n \n+SSL support for RPC dropped\n+----------------------------\n+\n+SSL support for RPC, previously enabled by the option `rpcssl` has been dropped\n+from both the client and the server. This was done in preparation for removing\n+the dependency on OpenSSL for the daemon completely.\n+\n+Trying to use `rpcssl` will result in an error:\n+\n+    Error: SSL mode for RPC (-rpcssl) is no longer supported.\n+\n+If you are one of the few people that relies on this feature, a flexible\n+migration path is to use `stunnel`. This is an utility that can tunnel\n+arbitrary TCP connections inside SSL. On e.g. Ubuntu it can be installed with:\n+\n+    sudo apt-get install stunnel4\n+\n+Then, to tunnel a SSL connection on 28332 to a RPC server bound on localhost on port 18332 do:\n+\n+    stunnel -d 28332 -r 127.0.0.1:18332 -p stunnel.pem -P ''\n+\n+It can also be set up system-wide in inetd style.\n+\n Random-cookie RPC authentication\n ---------------------------------\n "
      }
    ]
  },
  {
    "sha": "be33f3f50b7358bbad9e16bf730fac2ab3c4886b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiZTMzZjNmNTBiNzM1OGJiYWQ5ZTE2YmY3MzBmYWMyYWIzYzQ4ODZi",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-08-28T14:46:20Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-09-03T08:59:19Z"
      },
      "message": "Implement RPCTimerHandler for Qt RPC console\n\nImplement RPCTimerHandler for Qt RPC console, so that `walletpassphrase`\nworks with GUI and `-server=0`.\n\nAlso simplify HTTPEvent-related code by using boost::function directly.",
      "tree": {
        "sha": "534b59ec81e5baf95c85980013304eb31b24d0c8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/534b59ec81e5baf95c85980013304eb31b24d0c8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/be33f3f50b7358bbad9e16bf730fac2ab3c4886b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/be33f3f50b7358bbad9e16bf730fac2ab3c4886b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/be33f3f50b7358bbad9e16bf730fac2ab3c4886b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/be33f3f50b7358bbad9e16bf730fac2ab3c4886b/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "57d85d9bee20edb6c3070504f23b6a2be2802654",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/57d85d9bee20edb6c3070504f23b6a2be2802654",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/57d85d9bee20edb6c3070504f23b6a2be2802654"
      }
    ],
    "stats": {
      "total": 117,
      "additions": 67,
      "deletions": 50
    },
    "files": [
      {
        "sha": "98ac750bb1938f2bcd7a3125611ee383bcaaff16",
        "filename": "src/httprpc.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 15,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/be33f3f50b7358bbad9e16bf730fac2ab3c4886b/src/httprpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/be33f3f50b7358bbad9e16bf730fac2ab3c4886b/src/httprpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httprpc.cpp?ref=be33f3f50b7358bbad9e16bf730fac2ab3c4886b",
        "patch": "@@ -19,24 +19,16 @@\n class HTTPRPCTimer : public RPCTimerBase\n {\n public:\n-    HTTPRPCTimer(struct event_base* eventBase, boost::function<void(void)>& func, int64_t seconds) : ev(eventBase, false, new Handler(func))\n+    HTTPRPCTimer(struct event_base* eventBase, boost::function<void(void)>& func, int64_t millis) :\n+        ev(eventBase, false, func)\n     {\n-        struct timeval tv = {seconds, 0};\n+        struct timeval tv;\n+        tv.tv_sec = millis/1000;\n+        tv.tv_usec = (millis%1000)*1000;\n         ev.trigger(&tv);\n     }\n private:\n     HTTPEvent ev;\n-\n-    class Handler : public HTTPClosure\n-    {\n-    public:\n-        Handler(const boost::function<void(void)>& func) : func(func)\n-        {\n-        }\n-    private:\n-        boost::function<void(void)> func;\n-        void operator()() { func(); }\n-    };\n };\n \n class HTTPRPCTimerInterface : public RPCTimerInterface\n@@ -49,9 +41,9 @@ class HTTPRPCTimerInterface : public RPCTimerInterface\n     {\n         return \"HTTP\";\n     }\n-    RPCTimerBase* NewTimer(boost::function<void(void)>& func, int64_t seconds)\n+    RPCTimerBase* NewTimer(boost::function<void(void)>& func, int64_t millis)\n     {\n-        return new HTTPRPCTimer(base, func, seconds);\n+        return new HTTPRPCTimer(base, func, millis);\n     }\n private:\n     struct event_base* base;"
      },
      {
        "sha": "13f870567806f3b5233c87a2544c3a75ab49b6d0",
        "filename": "src/httpserver.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 25,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/be33f3f50b7358bbad9e16bf730fac2ab3c4886b/src/httpserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/be33f3f50b7358bbad9e16bf730fac2ab3c4886b/src/httpserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.cpp?ref=be33f3f50b7358bbad9e16bf730fac2ab3c4886b",
        "patch": "@@ -412,18 +412,15 @@ struct event_base* EventBase()\n \n static void httpevent_callback_fn(evutil_socket_t, short, void* data)\n {\n-    // Static handler simply passes through execution flow to _handle method\n-    ((HTTPEvent*)data)->_handle();\n+    // Static handler: simply call inner handler\n+    HTTPEvent *self = ((HTTPEvent*)data);\n+    self->handler();\n+    if (self->deleteWhenTriggered)\n+        delete self;\n }\n \n-void HTTPEvent::_handle()\n-{\n-    (*handler)();\n-    if (deleteWhenTriggered)\n-        delete this;\n-}\n-\n-HTTPEvent::HTTPEvent(struct event_base* base, bool deleteWhenTriggered, HTTPClosure* handler) : deleteWhenTriggered(deleteWhenTriggered), handler(handler)\n+HTTPEvent::HTTPEvent(struct event_base* base, bool deleteWhenTriggered, const boost::function<void(void)>& handler):\n+    deleteWhenTriggered(deleteWhenTriggered), handler(handler)\n {\n     ev = event_new(base, -1, 0, httpevent_callback_fn, this);\n     assert(ev);\n@@ -496,20 +493,6 @@ void HTTPRequest::WriteHeader(const std::string& hdr, const std::string& value)\n  * Replies must be sent in the main loop in the main http thread,\n  * this cannot be done from worker threads.\n  */\n-struct HTTPSendReplyHandler : HTTPClosure {\n-public:\n-    HTTPSendReplyHandler(struct evhttp_request* req, int nStatus) : req(req), nStatus(nStatus)\n-    {\n-    }\n-    void operator()()\n-    {\n-        evhttp_send_reply(req, nStatus, NULL, NULL);\n-    }\n-private:\n-    struct evhttp_request* req;\n-    int nStatus;\n-};\n-\n void HTTPRequest::WriteReply(int nStatus, const std::string& strReply)\n {\n     assert(!replySent && req);\n@@ -518,7 +501,7 @@ void HTTPRequest::WriteReply(int nStatus, const std::string& strReply)\n     assert(evb);\n     evbuffer_add(evb, strReply.data(), strReply.size());\n     HTTPEvent* ev = new HTTPEvent(eventBase, true,\n-                                  new HTTPSendReplyHandler(req, nStatus));\n+        boost::bind(evhttp_send_reply, req, nStatus, (const char*)NULL, (struct evbuffer *)NULL));\n     ev->trigger(0);\n     replySent = true;\n     req = 0; // transferred back to main thread"
      },
      {
        "sha": "648e8b6f8648c320645d7e6db7d15f24fc259fce",
        "filename": "src/httpserver.h",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/be33f3f50b7358bbad9e16bf730fac2ab3c4886b/src/httpserver.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/be33f3f50b7358bbad9e16bf730fac2ab3c4886b/src/httpserver.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.h?ref=be33f3f50b7358bbad9e16bf730fac2ab3c4886b",
        "patch": "@@ -117,22 +117,22 @@ class HTTPClosure\n class HTTPEvent\n {\n public:\n-    /** Create a new event */\n-    HTTPEvent(struct event_base* base, bool deleteWhenTriggered, HTTPClosure* handler);\n+    /** Create a new event.\n+     * deleteWhenTriggered deletes this event object after the event is triggered (and the handler called)\n+     * handler is the handler to call when the event is triggered.\n+     */\n+    HTTPEvent(struct event_base* base, bool deleteWhenTriggered, const boost::function<void(void)>& handler);\n     ~HTTPEvent();\n \n     /** Trigger the event. If tv is 0, trigger it immediately. Otherwise trigger it after\n      * the given time has elapsed.\n      */\n     void trigger(struct timeval* tv);\n \n-    /** Internal function for handling, do not call directly */\n-    void _handle();\n-\n-private:\n     bool deleteWhenTriggered;\n+    boost::function<void(void)> handler;\n+private:\n     struct event* ev;\n-    boost::scoped_ptr<HTTPClosure> handler;\n };\n \n #endif // BITCOIN_HTTPSERVER_H"
      },
      {
        "sha": "b742a47c9ba323e359604bb300c68e3694ea9d05",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 40,
        "deletions": 0,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/be33f3f50b7358bbad9e16bf730fac2ab3c4886b/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/be33f3f50b7358bbad9e16bf730fac2ab3c4886b/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=be33f3f50b7358bbad9e16bf730fac2ab3c4886b",
        "patch": "@@ -28,6 +28,7 @@\n #include <QScrollBar>\n #include <QThread>\n #include <QTime>\n+#include <QTimer>\n \n #if QT_VERSION < 0x050000\n #include <QUrl>\n@@ -66,6 +67,40 @@ public Q_SLOTS:\n     void reply(int category, const QString &command);\n };\n \n+/** Class for handling RPC timers\n+ * (used for e.g. re-locking the wallet after a timeout)\n+ */\n+class QtRPCTimerBase: public QObject, public RPCTimerBase\n+{\n+    Q_OBJECT\n+public:\n+    QtRPCTimerBase(boost::function<void(void)>& func, int64_t millis):\n+        func(func)\n+    {\n+        timer.setSingleShot(true);\n+        connect(&timer, SIGNAL(timeout()), this, SLOT(timeout()));\n+        timer.start(millis);\n+    }\n+    ~QtRPCTimerBase() {}\n+private Q_SLOTS:\n+    void timeout() { func(); }\n+private:\n+    QTimer timer;\n+    boost::function<void(void)> func;\n+};\n+\n+class QtRPCTimerInterface: public RPCTimerInterface\n+{\n+public:\n+    ~QtRPCTimerInterface() {}\n+    const char *Name() { return \"Qt\"; }\n+    RPCTimerBase* NewTimer(boost::function<void(void)>& func, int64_t millis)\n+    {\n+        return new QtRPCTimerBase(func, millis);\n+    }\n+};\n+\n+\n #include \"rpcconsole.moc\"\n \n /**\n@@ -232,6 +267,9 @@ RPCConsole::RPCConsole(const PlatformStyle *platformStyle, QWidget *parent) :\n     ui->label_berkeleyDBVersion->hide();\n     ui->berkeleyDBVersion->hide();\n #endif\n+    // Register RPC timer interface\n+    rpcTimerInterface = new QtRPCTimerInterface();\n+    RPCRegisterTimerInterface(rpcTimerInterface);\n \n     startExecutor();\n     setTrafficGraphRange(INITIAL_TRAFFIC_GRAPH_MINS);\n@@ -246,6 +284,8 @@ RPCConsole::~RPCConsole()\n {\n     GUIUtil::saveWindowGeometry(\"nRPCConsoleWindow\", this);\n     Q_EMIT stopExecutor();\n+    RPCUnregisterTimerInterface(rpcTimerInterface);\n+    delete rpcTimerInterface;\n     delete ui;\n }\n "
      },
      {
        "sha": "1409fca525ad9f30e36fe3a608791becbc71b81f",
        "filename": "src/qt/rpcconsole.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/be33f3f50b7358bbad9e16bf730fac2ab3c4886b/src/qt/rpcconsole.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/be33f3f50b7358bbad9e16bf730fac2ab3c4886b/src/qt/rpcconsole.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.h?ref=be33f3f50b7358bbad9e16bf730fac2ab3c4886b",
        "patch": "@@ -14,6 +14,7 @@\n \n class ClientModel;\n class PlatformStyle;\n+class RPCTimerInterface;\n \n namespace Ui {\n     class RPCConsole;\n@@ -108,6 +109,7 @@ public Q_SLOTS:\n     NodeId cachedNodeid;\n     QMenu *contextMenu;\n     const PlatformStyle *platformStyle;\n+    RPCTimerInterface *rpcTimerInterface;\n };\n \n #endif // BITCOIN_QT_RPCCONSOLE_H"
      },
      {
        "sha": "b831d3d3b2bd6fbfc85827e2ca064495d04ae4a8",
        "filename": "src/rpcserver.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/be33f3f50b7358bbad9e16bf730fac2ab3c4886b/src/rpcserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/be33f3f50b7358bbad9e16bf730fac2ab3c4886b/src/rpcserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcserver.cpp?ref=be33f3f50b7358bbad9e16bf730fac2ab3c4886b",
        "patch": "@@ -562,7 +562,7 @@ void RPCRunLater(const std::string& name, boost::function<void(void)> func, int6\n     deadlineTimers.erase(name);\n     RPCTimerInterface* timerInterface = timerInterfaces[0];\n     LogPrint(\"rpc\", \"queue run of timer %s in %i seconds (using %s)\\n\", name, nSeconds, timerInterface->Name());\n-    deadlineTimers.insert(std::make_pair(name, timerInterface->NewTimer(func, nSeconds)));\n+    deadlineTimers.insert(std::make_pair(name, timerInterface->NewTimer(func, nSeconds*1000)));\n }\n \n const CRPCTable tableRPC;"
      },
      {
        "sha": "83cc37918ba5785d8f8d29e0bd663e39857e41d9",
        "filename": "src/rpcserver.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/be33f3f50b7358bbad9e16bf730fac2ab3c4886b/src/rpcserver.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/be33f3f50b7358bbad9e16bf730fac2ab3c4886b/src/rpcserver.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcserver.h?ref=be33f3f50b7358bbad9e16bf730fac2ab3c4886b",
        "patch": "@@ -92,12 +92,12 @@ class RPCTimerInterface\n     /** Implementation name */\n     virtual const char *Name() = 0;\n     /** Factory function for timers.\n-     * RPC will call the function to create a timer that will call func in *seconds* seconds.\n+     * RPC will call the function to create a timer that will call func in *millis* milliseconds.\n      * @note As the RPC mechanism is backend-neutral, it can use different implementations of timers.\n      * This is needed to cope with the case in which there is no HTTP server, but\n      * only GUI RPC console, and to break the dependency of pcserver on httprpc.\n      */\n-    virtual RPCTimerBase* NewTimer(boost::function<void(void)>&, int64_t) = 0;\n+    virtual RPCTimerBase* NewTimer(boost::function<void(void)>& func, int64_t millis) = 0;\n };\n \n /** Register factory function for timers */"
      }
    ]
  },
  {
    "sha": "6d2bc221463ffe3ed3a99e8c682b090983b2e7b5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ZDJiYzIyMTQ2M2ZmZTNlZDNhOTllOGM2ODJiMDkwOTgzYjJlN2I1",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-08-28T15:14:51Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-09-03T08:59:19Z"
      },
      "message": "Document options for new HTTP/RPC server in --help",
      "tree": {
        "sha": "4370d570b38fea9ffa1ad630b481433cfb2b890b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4370d570b38fea9ffa1ad630b481433cfb2b890b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6d2bc221463ffe3ed3a99e8c682b090983b2e7b5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6d2bc221463ffe3ed3a99e8c682b090983b2e7b5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6d2bc221463ffe3ed3a99e8c682b090983b2e7b5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6d2bc221463ffe3ed3a99e8c682b090983b2e7b5/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "be33f3f50b7358bbad9e16bf730fac2ab3c4886b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/be33f3f50b7358bbad9e16bf730fac2ab3c4886b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/be33f3f50b7358bbad9e16bf730fac2ab3c4886b"
      }
    ],
    "stats": {
      "total": 18,
      "additions": 13,
      "deletions": 5
    },
    "files": [
      {
        "sha": "813764f22c78038edf57a5344cd81b11441b37db",
        "filename": "src/httpserver.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6d2bc221463ffe3ed3a99e8c682b090983b2e7b5/src/httpserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6d2bc221463ffe3ed3a99e8c682b090983b2e7b5/src/httpserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.cpp?ref=6d2bc221463ffe3ed3a99e8c682b090983b2e7b5",
        "patch": "@@ -355,7 +355,7 @@ bool StartHTTPServer(boost::thread_group& threadGroup)\n         return false;\n     }\n \n-    evhttp_set_timeout(http, GetArg(\"-rpctimeout\", 30));\n+    evhttp_set_timeout(http, GetArg(\"-rpctimeout\", DEFAULT_HTTP_TIMEOUT));\n     evhttp_set_max_body_size(http, MAX_SIZE);\n     evhttp_set_gencb(http, http_request_cb, NULL);\n \n@@ -367,8 +367,8 @@ bool StartHTTPServer(boost::thread_group& threadGroup)\n     }\n \n     LogPrint(\"http\", \"Starting HTTP server\\n\");\n-    int workQueueDepth = std::max((long)GetArg(\"-rpcworkqueue\", 16), 1L);\n-    int rpcThreads = std::max((long)GetArg(\"-rpcthreads\", 4), 1L);\n+    int workQueueDepth = std::max((long)GetArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);\n+    int rpcThreads = std::max((long)GetArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n     LogPrintf(\"HTTP: creating work queue of depth %d and %d worker threads\\n\", workQueueDepth, rpcThreads);\n     workQueue = new WorkQueue<HTTPClosure>(workQueueDepth);\n "
      },
      {
        "sha": "1b0d77ad4d2d50b0c0872041dd0d190d01eb33bf",
        "filename": "src/httpserver.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6d2bc221463ffe3ed3a99e8c682b090983b2e7b5/src/httpserver.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6d2bc221463ffe3ed3a99e8c682b090983b2e7b5/src/httpserver.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.h?ref=6d2bc221463ffe3ed3a99e8c682b090983b2e7b5",
        "patch": "@@ -11,6 +11,10 @@\n #include <boost/scoped_ptr.hpp>\n #include <boost/function.hpp>\n \n+static const int DEFAULT_HTTP_THREADS=4;\n+static const int DEFAULT_HTTP_WORKQUEUE=16;\n+static const int DEFAULT_HTTP_TIMEOUT=30;\n+\n struct evhttp_request;\n struct event_base;\n class CService;"
      },
      {
        "sha": "bbf73dc8f448068ea7404c9d558131b366d9c6e0",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6d2bc221463ffe3ed3a99e8c682b090983b2e7b5/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6d2bc221463ffe3ed3a99e8c682b090983b2e7b5/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=6d2bc221463ffe3ed3a99e8c682b090983b2e7b5",
        "patch": "@@ -388,7 +388,7 @@ std::string HelpMessage(HelpMessageMode mode)\n         strUsage += HelpMessageOpt(\"-flushwallet\", strprintf(\"Run a thread to flush wallet periodically (default: %u)\", 1));\n         strUsage += HelpMessageOpt(\"-stopafterblockimport\", strprintf(\"Stop running after importing blocks from disk (default: %u)\", 0));\n     }\n-    string debugCategories = \"addrman, alert, bench, coindb, db, lock, rand, rpc, selectcoins, mempool, mempoolrej, net, proxy, prune\"; // Don't translate these and qt below\n+    string debugCategories = \"addrman, alert, bench, coindb, db, lock, rand, rpc, selectcoins, mempool, mempoolrej, net, proxy, prune, http\"; // Don't translate these and qt below\n     if (mode == HMM_BITCOIN_QT)\n         debugCategories += \", qt\";\n     strUsage += HelpMessageOpt(\"-debug=<category>\", strprintf(_(\"Output debugging information (default: %u, supplying <category> is optional)\"), 0) + \". \" +\n@@ -438,7 +438,11 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-rpcpassword=<pw>\", _(\"Password for JSON-RPC connections\"));\n     strUsage += HelpMessageOpt(\"-rpcport=<port>\", strprintf(_(\"Listen for JSON-RPC connections on <port> (default: %u or testnet: %u)\"), 8332, 18332));\n     strUsage += HelpMessageOpt(\"-rpcallowip=<ip>\", _(\"Allow JSON-RPC connections from specified source. Valid for <ip> are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24). This option can be specified multiple times\"));\n-    strUsage += HelpMessageOpt(\"-rpcthreads=<n>\", strprintf(_(\"Set the number of threads to service RPC calls (default: %d)\"), 4));\n+    strUsage += HelpMessageOpt(\"-rpcthreads=<n>\", strprintf(_(\"Set the number of threads to service RPC calls (default: %d)\"), DEFAULT_HTTP_THREADS));\n+    if (showDebug) {\n+        strUsage += HelpMessageOpt(\"-rpcworkqueue=<n>\", strprintf(\"Set the depth of the work queue to service RPC calls (default: %d)\", DEFAULT_HTTP_WORKQUEUE));\n+        strUsage += HelpMessageOpt(\"-rpctimeout=<n>\", strprintf(\"Timeout during HTTP requests (default: %d)\", DEFAULT_HTTP_TIMEOUT));\n+    }\n \n     if (mode == HMM_BITCOIN_QT)\n     {"
      }
    ]
  },
  {
    "sha": "3a174cd400c6c239539d4c0c10b557c3e0615212",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozYTE3NGNkNDAwYzZjMjM5NTM5ZDRjMGMxMGI1NTdjM2UwNjE1MjEy",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-08-28T14:55:16Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-09-03T08:59:19Z"
      },
      "message": "Fix race condition between starting HTTP server thread and setting EventBase()\n\nSplit StartHTTPServer into InitHTTPServer and StartHTTPServer to give\nclients a window to register their handlers without race conditions.\n\nThanks @ajweiss for figuring this out.",
      "tree": {
        "sha": "3a7b26b9218f9e3d17d8a3f5f77e032b35f6e416",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3a7b26b9218f9e3d17d8a3f5f77e032b35f6e416"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3a174cd400c6c239539d4c0c10b557c3e0615212",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3a174cd400c6c239539d4c0c10b557c3e0615212",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3a174cd400c6c239539d4c0c10b557c3e0615212",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3a174cd400c6c239539d4c0c10b557c3e0615212/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6d2bc221463ffe3ed3a99e8c682b090983b2e7b5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6d2bc221463ffe3ed3a99e8c682b090983b2e7b5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6d2bc221463ffe3ed3a99e8c682b090983b2e7b5"
      }
    ],
    "stats": {
      "total": 35,
      "additions": 25,
      "deletions": 10
    },
    "files": [
      {
        "sha": "7e599b1d78d31a16151d455e000677de2543a408",
        "filename": "src/httpserver.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 8,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a174cd400c6c239539d4c0c10b557c3e0615212/src/httpserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a174cd400c6c239539d4c0c10b557c3e0615212/src/httpserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.cpp?ref=3a174cd400c6c239539d4c0c10b557c3e0615212",
        "patch": "@@ -320,7 +320,7 @@ static void HTTPWorkQueueRun(WorkQueue<HTTPClosure>* queue)\n     queue->Run();\n }\n \n-bool StartHTTPServer(boost::thread_group& threadGroup)\n+bool InitHTTPServer()\n {\n     struct evhttp* http = 0;\n     struct event_base* base = 0;\n@@ -366,19 +366,25 @@ bool StartHTTPServer(boost::thread_group& threadGroup)\n         return false;\n     }\n \n-    LogPrint(\"http\", \"Starting HTTP server\\n\");\n+    LogPrint(\"http\", \"Initialized HTTP server\\n\");\n     int workQueueDepth = std::max((long)GetArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);\n-    int rpcThreads = std::max((long)GetArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n-    LogPrintf(\"HTTP: creating work queue of depth %d and %d worker threads\\n\", workQueueDepth, rpcThreads);\n+    LogPrintf(\"HTTP: creating work queue of depth %d\\n\", workQueueDepth);\n+\n     workQueue = new WorkQueue<HTTPClosure>(workQueueDepth);\n+    eventBase = base;\n+    eventHTTP = http;\n+    return true;\n+}\n \n-    threadGroup.create_thread(boost::bind(&ThreadHTTP, base, http));\n+bool StartHTTPServer(boost::thread_group& threadGroup)\n+{\n+    LogPrint(\"http\", \"Starting HTTP server\\n\");\n+    int rpcThreads = std::max((long)GetArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n+    LogPrintf(\"HTTP: starting %d worker threads\\n\", rpcThreads);\n+    threadGroup.create_thread(boost::bind(&ThreadHTTP, eventBase, eventHTTP));\n \n     for (int i = 0; i < rpcThreads; i++)\n         threadGroup.create_thread(boost::bind(&HTTPWorkQueueRun, workQueue));\n-\n-    eventBase = base;\n-    eventHTTP = http;\n     return true;\n }\n "
      },
      {
        "sha": "459c60c04724c0281ffcea3cccbbc3fb994fc29c",
        "filename": "src/httpserver.h",
        "status": "modified",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a174cd400c6c239539d4c0c10b557c3e0615212/src/httpserver.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a174cd400c6c239539d4c0c10b557c3e0615212/src/httpserver.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.h?ref=3a174cd400c6c239539d4c0c10b557c3e0615212",
        "patch": "@@ -20,7 +20,14 @@ struct event_base;\n class CService;\n class HTTPRequest;\n \n-/** Start HTTP server */\n+/** Initialize HTTP server.\n+ * Call this before RegisterHTTPHandler or EventBase().\n+ */\n+bool InitHTTPServer();\n+/** Start HTTP server.\n+ * This is separate from InitHTTPServer to give users race-condition-free time\n+ * to register their handlers between InitHTTPServer and StartHTTPServer.\n+ */\n bool StartHTTPServer(boost::thread_group& threadGroup);\n /** Interrupt HTTP server threads */\n void InterruptHTTPServer();"
      },
      {
        "sha": "4aaeee257b35da4f8424dfd6b6853a082086ec2e",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a174cd400c6c239539d4c0c10b557c3e0615212/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a174cd400c6c239539d4c0c10b557c3e0615212/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=3a174cd400c6c239539d4c0c10b557c3e0615212",
        "patch": "@@ -618,14 +618,16 @@ bool AppInitServers(boost::thread_group& threadGroup)\n {\n     RPCServer::OnStopped(&OnRPCStopped);\n     RPCServer::OnPreCommand(&OnRPCPreCommand);\n-    if (!StartHTTPServer(threadGroup))\n+    if (!InitHTTPServer())\n         return false;\n     if (!StartRPC())\n         return false;\n     if (!StartHTTPRPC())\n         return false;\n     if (GetBoolArg(\"-rest\", false) && !StartREST())\n         return false;\n+    if (!StartHTTPServer(threadGroup))\n+        return false;\n     return true;\n }\n "
      }
    ]
  },
  {
    "sha": "4be0b082b97062be4df20e9c45dafa577b05b07c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0YmUwYjA4MmI5NzA2MmJlNGRmMjBlOWM0NWRhZmE1NzdiMDViMDdj",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2015-08-31T09:17:26Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-09-03T08:59:19Z"
      },
      "message": "libevent: Windows reuseaddr workaround in depends\n\nMake it possible to reuse sockets.\nThis is necessary to make the RPC tests work in WINE.",
      "tree": {
        "sha": "6f331d8dc827ef0f7a27ffb89348800bb7bd4936",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6f331d8dc827ef0f7a27ffb89348800bb7bd4936"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4be0b082b97062be4df20e9c45dafa577b05b07c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4be0b082b97062be4df20e9c45dafa577b05b07c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4be0b082b97062be4df20e9c45dafa577b05b07c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4be0b082b97062be4df20e9c45dafa577b05b07c/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3a174cd400c6c239539d4c0c10b557c3e0615212",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3a174cd400c6c239539d4c0c10b557c3e0615212",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3a174cd400c6c239539d4c0c10b557c3e0615212"
      }
    ],
    "stats": {
      "total": 26,
      "additions": 26,
      "deletions": 0
    },
    "files": [
      {
        "sha": "2e9be1e98ccedda520459b8d4deed2f686473746",
        "filename": "depends/packages/libevent.mk",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4be0b082b97062be4df20e9c45dafa577b05b07c/depends/packages/libevent.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4be0b082b97062be4df20e9c45dafa577b05b07c/depends/packages/libevent.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/libevent.mk?ref=4be0b082b97062be4df20e9c45dafa577b05b07c",
        "patch": "@@ -3,6 +3,11 @@ $(package)_version=2.0.22\n $(package)_download_path=https://github.com/libevent/libevent/releases/download/release-2.0.22-stable\n $(package)_file_name=$(package)-$($(package)_version)-stable.tar.gz\n $(package)_sha256_hash=71c2c49f0adadacfdbe6332a372c38cf9c8b7895bb73dabeaa53cdcc1d4e1fa3\n+$(package)_patches=reuseaddr.patch\n+\n+define $(package)_preprocess_cmds\n+  patch -p1 < $($(package)_patch_dir)/reuseaddr.patch\n+endef\n \n define $(package)_set_vars\n   $(package)_config_opts=--disable-shared --disable-openssl --disable-libevent-regress"
      },
      {
        "sha": "58695c11f5d976bd163429884e02d9a7f6f4eb4d",
        "filename": "depends/patches/libevent/reuseaddr.patch",
        "status": "added",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4be0b082b97062be4df20e9c45dafa577b05b07c/depends/patches/libevent/reuseaddr.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4be0b082b97062be4df20e9c45dafa577b05b07c/depends/patches/libevent/reuseaddr.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/libevent/reuseaddr.patch?ref=4be0b082b97062be4df20e9c45dafa577b05b07c",
        "patch": "@@ -0,0 +1,21 @@\n+--- old/evutil.c   2015-08-28 19:26:23.488765923 -0400\n++++ new/evutil.c   2015-08-28 19:27:41.392767019 -0400\n+@@ -321,15 +321,16 @@\n+ int\n+ evutil_make_listen_socket_reuseable(evutil_socket_t sock)\n+ {\n+-#ifndef WIN32\n+ \tint one = 1;\n++#ifndef WIN32\n+ \t/* REUSEADDR on Unix means, \"don't hang on to this address after the\n+ \t * listener is closed.\"  On Windows, though, it means \"don't keep other\n+ \t * processes from binding to this address while we're using it. */\n+ \treturn setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void*) &one,\n+ \t    (ev_socklen_t)sizeof(one));\n+ #else\n+-\treturn 0;\n++\treturn setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (const char*) &one,\n++\t\t(ev_socklen_t)sizeof(one));\n+ #endif\n+ }\n+ "
      }
    ]
  },
  {
    "sha": "26c9b836778cbaf9b9ccb9b92e841d7bd6ea2fdc",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNmM5YjgzNjc3OGNiYWY5YjljY2I5YjkyZTg0MWQ3YmQ2ZWEyZmRj",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-09-02T14:18:16Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-09-03T08:59:19Z"
      },
      "message": "Move windows socket init to utility function",
      "tree": {
        "sha": "36f589364a3040c46914c1e038e6544bb48e4b7f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/36f589364a3040c46914c1e038e6544bb48e4b7f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/26c9b836778cbaf9b9ccb9b92e841d7bd6ea2fdc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/26c9b836778cbaf9b9ccb9b92e841d7bd6ea2fdc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/26c9b836778cbaf9b9ccb9b92e841d7bd6ea2fdc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/26c9b836778cbaf9b9ccb9b92e841d7bd6ea2fdc/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4be0b082b97062be4df20e9c45dafa577b05b07c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4be0b082b97062be4df20e9c45dafa577b05b07c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4be0b082b97062be4df20e9c45dafa577b05b07c"
      }
    ],
    "stats": {
      "total": 30,
      "additions": 21,
      "deletions": 9
    },
    "files": [
      {
        "sha": "866c6f2d4443cd2565a3ef86255833573d932de9",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26c9b836778cbaf9b9ccb9b92e841d7bd6ea2fdc/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26c9b836778cbaf9b9ccb9b92e841d7bd6ea2fdc/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=26c9b836778cbaf9b9ccb9b92e841d7bd6ea2fdc",
        "patch": "@@ -301,6 +301,10 @@ int CommandLineRPC(int argc, char *argv[])\n int main(int argc, char* argv[])\n {\n     SetupEnvironment();\n+    if (!SetupNetworking()) {\n+        fprintf(stderr, \"Error: Initializing networking failed\\n\");\n+        exit(1);\n+    }\n \n     try {\n         if(!AppInitRPC(argc, argv))"
      },
      {
        "sha": "4cdbd5edaaa0d9d6293ca491913555b3d82645bc",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 9,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26c9b836778cbaf9b9ccb9b92e841d7bd6ea2fdc/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26c9b836778cbaf9b9ccb9b92e841d7bd6ea2fdc/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=26c9b836778cbaf9b9ccb9b92e841d7bd6ea2fdc",
        "patch": "@@ -658,17 +658,12 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n     typedef BOOL (WINAPI *PSETPROCDEPPOL)(DWORD);\n     PSETPROCDEPPOL setProcDEPPol = (PSETPROCDEPPOL)GetProcAddress(GetModuleHandleA(\"Kernel32.dll\"), \"SetProcessDEPPolicy\");\n     if (setProcDEPPol != NULL) setProcDEPPol(PROCESS_DEP_ENABLE);\n-\n-    // Initialize Windows Sockets\n-    WSADATA wsadata;\n-    int ret = WSAStartup(MAKEWORD(2,2), &wsadata);\n-    if (ret != NO_ERROR || LOBYTE(wsadata.wVersion ) != 2 || HIBYTE(wsadata.wVersion) != 2)\n-    {\n-        return InitError(strprintf(\"Error: Winsock library failed to start (WSAStartup returned error %d)\", ret));\n-    }\n #endif\n-#ifndef WIN32\n \n+    if (!SetupNetworking())\n+        return InitError(\"Error: Initializing networking failed\");\n+\n+#ifndef WIN32\n     if (GetBoolArg(\"-sysperms\", false)) {\n #ifdef ENABLE_WALLET\n         if (!GetBoolArg(\"-disablewallet\", false))"
      },
      {
        "sha": "f50d25e17a14e55063daa790b009bf751db7b181",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26c9b836778cbaf9b9ccb9b92e841d7bd6ea2fdc/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26c9b836778cbaf9b9ccb9b92e841d7bd6ea2fdc/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=26c9b836778cbaf9b9ccb9b92e841d7bd6ea2fdc",
        "patch": "@@ -794,6 +794,18 @@ void SetupEnvironment()\n     boost::filesystem::path::imbue(loc);\n }\n \n+bool SetupNetworking()\n+{\n+#ifdef WIN32\n+    // Initialize Windows Sockets\n+    WSADATA wsadata;\n+    int ret = WSAStartup(MAKEWORD(2,2), &wsadata);\n+    if (ret != NO_ERROR || LOBYTE(wsadata.wVersion ) != 2 || HIBYTE(wsadata.wVersion) != 2)\n+        return false;\n+#endif\n+    return true;\n+}\n+\n void SetThreadPriority(int nPriority)\n {\n #ifdef WIN32"
      },
      {
        "sha": "0b2dc01ac65f397c86e69eeb3fe821f70c69b110",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26c9b836778cbaf9b9ccb9b92e841d7bd6ea2fdc/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26c9b836778cbaf9b9ccb9b92e841d7bd6ea2fdc/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=26c9b836778cbaf9b9ccb9b92e841d7bd6ea2fdc",
        "patch": "@@ -59,6 +59,7 @@ inline std::string _(const char* psz)\n }\n \n void SetupEnvironment();\n+bool SetupNetworking();\n \n /** Return true if log accepts specified category */\n bool LogAcceptCategory(const char* category);"
      }
    ]
  },
  {
    "sha": "1e700c9b601552ea83567d32c9f1d6c07cd8bfcc",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxZTcwMGM5YjYwMTU1MmVhODM1NjdkMzJjOWYxZDZjMDdjZDhiZmNj",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-09-04T08:59:34Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-09-04T08:59:34Z"
      },
      "message": "doc: update deps in build-unix.md after libevent\n\nAdd libevent, change usage of libssl from \"secure communication\" to\n\"crypto\" that's more accurate after RPC SSL support removed.",
      "tree": {
        "sha": "bf65a2be1a90322c1bfeb470107bf080a347d542",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bf65a2be1a90322c1bfeb470107bf080a347d542"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1e700c9b601552ea83567d32c9f1d6c07cd8bfcc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1e700c9b601552ea83567d32c9f1d6c07cd8bfcc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1e700c9b601552ea83567d32c9f1d6c07cd8bfcc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1e700c9b601552ea83567d32c9f1d6c07cd8bfcc/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "26c9b836778cbaf9b9ccb9b92e841d7bd6ea2fdc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/26c9b836778cbaf9b9ccb9b92e841d7bd6ea2fdc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/26c9b836778cbaf9b9ccb9b92e841d7bd6ea2fdc"
      }
    ],
    "stats": {
      "total": 7,
      "additions": 4,
      "deletions": 3
    },
    "files": [
      {
        "sha": "5f674c8f8818c78a78860ed5a9e633b695008311",
        "filename": "doc/build-unix.md",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1e700c9b601552ea83567d32c9f1d6c07cd8bfcc/doc/build-unix.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1e700c9b601552ea83567d32c9f1d6c07cd8bfcc/doc/build-unix.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-unix.md?ref=1e700c9b601552ea83567d32c9f1d6c07cd8bfcc",
        "patch": "@@ -31,8 +31,9 @@ These dependencies are required:\n \n  Library     | Purpose          | Description\n  ------------|------------------|----------------------\n- libssl      | SSL Support      | Secure communications\n- libboost    | Boost            | C++ Library\n+ libssl      | Crypto           | Random Number Generation, Elliptic Curve Cryptography\n+ libboost    | Utility          | Library for threading, data structures, etc\n+ libevent    | Networking       | OS independent asynchronous networking\n \n Optional dependencies:\n \n@@ -57,7 +58,7 @@ Dependency Build Instructions: Ubuntu & Debian\n ----------------------------------------------\n Build requirements:\n \n-\tsudo apt-get install build-essential libtool autotools-dev autoconf pkg-config libssl-dev\n+\tsudo apt-get install build-essential libtool autotools-dev autoconf pkg-config libssl-dev libevent-dev\n \t\n For Ubuntu 12.04 and later or Debian 7 and later libboost-all-dev has to be installed:\n "
      }
    ]
  },
  {
    "sha": "d52802551752140cf41f0d9a225a43e84404d3e9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNTI4MDI1NTE3NTIxNDBjZjQxZjBkOWEyMjVhNDNlODQ0MDRkM2U5",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-09-04T09:01:44Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-09-04T09:01:44Z"
      },
      "message": "Revert \"rpc-tests: re-enable rpc-tests for Windows\"\n\nThis reverts commit bd30c3dced21fca869a14c75081f15195762afe1.\n\nDisable windows RPC tests for now. These should be re-enabled once a\nsuitable Wine version is used on Travis.",
      "tree": {
        "sha": "fdcc38f5814b018be3b7f6a64e92e92bb73a6c5c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fdcc38f5814b018be3b7f6a64e92e92bb73a6c5c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d52802551752140cf41f0d9a225a43e84404d3e9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d52802551752140cf41f0d9a225a43e84404d3e9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d52802551752140cf41f0d9a225a43e84404d3e9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d52802551752140cf41f0d9a225a43e84404d3e9/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1e700c9b601552ea83567d32c9f1d6c07cd8bfcc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1e700c9b601552ea83567d32c9f1d6c07cd8bfcc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1e700c9b601552ea83567d32c9f1d6c07cd8bfcc"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 5,
      "deletions": 0
    },
    "files": [
      {
        "sha": "514bdf5640b121de18ea33fcddd328170e22c944",
        "filename": "qa/pull-tester/rpc-tests.sh",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d52802551752140cf41f0d9a225a43e84404d3e9/qa/pull-tester/rpc-tests.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d52802551752140cf41f0d9a225a43e84404d3e9/qa/pull-tester/rpc-tests.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.sh?ref=d52802551752140cf41f0d9a225a43e84404d3e9",
        "patch": "@@ -8,6 +8,11 @@ CURDIR=$(cd $(dirname \"$0\"); pwd)\n export BITCOIND=${REAL_BITCOIND}\n export BITCOINCLI=${REAL_BITCOINCLI}\n \n+if [ \"x${EXEEXT}\" = \"x.exe\" ]; then\n+  echo \"Win tests currently disabled\"\n+  exit 0\n+fi\n+\n #Run the tests\n \n testScripts=("
      }
    ]
  }
]