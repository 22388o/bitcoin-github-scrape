[
  {
    "sha": "32520bfb9e450522cc507faf30bf2eadecdf349b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozMjUyMGJmYjllNDUwNTIyY2M1MDdmYWYzMGJmMmVhZGVjZGYzNDli",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-11-10T15:28:05Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-11-11T20:51:05Z"
      },
      "message": "Add priority space to mempool\n\nReserve part of the mempool for transactions that have no in-mempool\nparents.  Change the feerate index to sort that part of the mempool\nby priority at the time of entry.\n\nTransactions at the bottom of the priority sort get moved to the fee\nrate area when the priority area exceeds its size limit.\n\nNew transactions that don't meet the mempool reject fee must meet\nthe new GetMinPriority(), which is increased when priority transactions\nare moved to the feerate part of the mempool, and decayed as time passes.",
      "tree": {
        "sha": "6223d4efda7178c3721a5136aeb2b02cff22df27",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6223d4efda7178c3721a5136aeb2b02cff22df27"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/32520bfb9e450522cc507faf30bf2eadecdf349b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/32520bfb9e450522cc507faf30bf2eadecdf349b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/32520bfb9e450522cc507faf30bf2eadecdf349b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/32520bfb9e450522cc507faf30bf2eadecdf349b/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "77beab70deae8ad821cc069c1ce80fc809c89c33",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/77beab70deae8ad821cc069c1ce80fc809c89c33",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/77beab70deae8ad821cc069c1ce80fc809c89c33"
      }
    ],
    "stats": {
      "total": 312,
      "additions": 263,
      "deletions": 49
    },
    "files": [
      {
        "sha": "94c949410ed583b029875471cc31d52d3d111ac3",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32520bfb9e450522cc507faf30bf2eadecdf349b/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32520bfb9e450522cc507faf30bf2eadecdf349b/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=32520bfb9e450522cc507faf30bf2eadecdf349b",
        "patch": "@@ -421,6 +421,7 @@ std::string HelpMessage(HelpMessageMode mode)\n         strUsage += HelpMessageOpt(\"-limitancestorsize=<n>\", strprintf(\"Do not accept transactions whose size with all in-mempool ancestors exceeds <n> kilobytes (default: %u)\", DEFAULT_ANCESTOR_SIZE_LIMIT));\n         strUsage += HelpMessageOpt(\"-limitdescendantcount=<n>\", strprintf(\"Do not accept transactions if any ancestor would have <n> or more in-mempool descendants (default: %u)\", DEFAULT_DESCENDANT_LIMIT));\n         strUsage += HelpMessageOpt(\"-limitdescendantsize=<n>\", strprintf(\"Do not accept transactions if any ancestor would have more than <n> kilobytes of in-mempool descendants (default: %u).\", DEFAULT_DESCENDANT_SIZE_LIMIT));\n+        strUsage += HelpMessageOpt(\"-prioritylimit=<n>\", \"Reserve <n> bytes for priority space in mempool (default: maxmempool*blockprioritysize/blockmaxsize)\");\n     }\n     string debugCategories = \"addrman, alert, bench, coindb, db, lock, rand, rpc, selectcoins, mempool, mempoolrej, net, proxy, prune, http, libevent\"; // Don't translate these and qt below\n     if (mode == HMM_BITCOIN_QT)"
      },
      {
        "sha": "24644f3a2b44720665d3296aaf4a782b2b9732d9",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 6,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32520bfb9e450522cc507faf30bf2eadecdf349b/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32520bfb9e450522cc507faf30bf2eadecdf349b/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=32520bfb9e450522cc507faf30bf2eadecdf349b",
        "patch": "@@ -911,7 +911,16 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n                 strprintf(\"%d < %d\", nFees, txMinFee));\n \n         CAmount mempoolRejectFee = pool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(nSize);\n-        if (mempoolRejectFee > 0 && nFees < mempoolRejectFee) {\n+\n+        size_t mempoolLimit = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n+        const double defaultPriorityLimit = (double)GetArg(\"-blockprioritysize\", DEFAULT_BLOCK_PRIORITY_SIZE) / (double) GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n+        size_t priorityLimit = GetArg(\"-prioritylimit\", mempoolLimit * defaultPriorityLimit);\n+\n+        // If the fee is below the minimum fee and it doesn't qualify to enter\n+        // the priority space, reject it.\n+        if (mempoolRejectFee > 0 && nFees < mempoolRejectFee &&\n+            (!entry.IsPriorityTx() || dPriority < pool.GetMinPriority(priorityLimit)))\n+        {\n             return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", false, strprintf(\"%d < %d\", nFees, mempoolRejectFee));\n         } else if (GetBoolArg(\"-relaypriority\", true) && nFees < ::minRelayTxFee.GetFee(nSize) && !AllowFree(view.GetPriority(tx, chainActive.Height() + 1))) {\n             // Require that free transactions have sufficient priority to be mined in the next block.\n@@ -921,7 +930,8 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         // Continuously rate-limit free (really, very-low-fee) transactions\n         // This mitigates 'penny-flooding' -- sending thousands of free transactions just to\n         // be annoying or make others' transactions take longer to confirm.\n-        if (fLimitFree && nFees < ::minRelayTxFee.GetFee(nSize))\n+        if (fLimitFree && (nFees < ::minRelayTxFee.GetFee(nSize) ||\n+                    (mempoolRejectFee > 0 && nFees < mempoolRejectFee)))\n         {\n             static CCriticalSection csFreeLimiter;\n             static double dFreeCount;\n@@ -986,7 +996,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n             if (expired != 0)\n                 LogPrint(\"mempool\", \"Expired %i transactions from the memory pool\\n\", expired);\n \n-            pool.TrimToSize(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+            pool.TrimToSize(mempoolLimit, priorityLimit);\n             if (!pool.exists(tx.GetHash()))\n                 return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full\");\n         }\n@@ -2316,8 +2326,13 @@ static bool ActivateBestChainStep(CValidationState &state, CBlockIndex *pindexMo\n     }\n     }\n \n-    if (fBlocksDisconnected)\n-        mempool.TrimToSize(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (fBlocksDisconnected) {\n+        size_t mempoolLimit = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n+        const double defaultPriorityLimit = (double) GetArg(\"-blockprioritysize\", DEFAULT_BLOCK_PRIORITY_SIZE) / (double) GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n+        size_t priorityLimit = GetArg(\"-prioritylimit\", defaultPriorityLimit * mempoolLimit);\n+        mempool.TrimToSize(mempoolLimit, priorityLimit);\n+    }\n+\n \n     // Callbacks/notifications for a new best chain.\n     if (fInvalidFound)\n@@ -2406,7 +2421,10 @@ bool InvalidateBlock(CValidationState& state, const Consensus::Params& consensus\n         }\n     }\n \n-    mempool.TrimToSize(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    size_t mempoolLimit = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n+    const double defaultPriorityLimit = (double) GetArg(\"-blockprioritysize\", DEFAULT_BLOCK_PRIORITY_SIZE) / (double) GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n+    size_t priorityLimit = GetArg(\"-prioritylimit\", defaultPriorityLimit * mempoolLimit);\n+    mempool.TrimToSize(mempoolLimit, priorityLimit);\n \n     // The resulting new best tip may not be in setBlockIndexCandidates anymore, so\n     // add it again."
      },
      {
        "sha": "a2e8725164662054da8573140af1c58727407c1c",
        "filename": "src/rpcblockchain.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32520bfb9e450522cc507faf30bf2eadecdf349b/src/rpcblockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32520bfb9e450522cc507faf30bf2eadecdf349b/src/rpcblockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcblockchain.cpp?ref=32520bfb9e450522cc507faf30bf2eadecdf349b",
        "patch": "@@ -17,6 +17,7 @@\n #include \"txmempool.h\"\n #include \"util.h\"\n #include \"utilstrencodings.h\"\n+#include \"policy/policy.h\"\n \n #include <stdint.h>\n \n@@ -776,6 +777,10 @@ UniValue mempoolInfoToJSON()\n     size_t maxmempool = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n     ret.push_back(Pair(\"maxmempool\", (int64_t) maxmempool));\n     ret.push_back(Pair(\"mempoolminfee\", ValueFromAmount(mempool.GetMinFee(maxmempool).GetFeePerK())));\n+    double defaultPriorityLimit = (double) GetArg(\"-blockprioritysize\", DEFAULT_BLOCK_PRIORITY_SIZE) / (double) GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n+    size_t priorityLimit = GetArg(\"-prioritylimit\", defaultPriorityLimit * maxmempool);\n+    ret.push_back(Pair(\"mempoolminpriority\", mempool.GetMinPriority(priorityLimit)));\n+    ret.push_back(Pair(\"priorityusage\", (int64_t) mempool.GetPriorityUsage()));\n \n     return ret;\n }\n@@ -791,6 +796,11 @@ UniValue getmempoolinfo(const UniValue& params, bool fHelp)\n             \"  \\\"size\\\": xxxxx                (numeric) Current tx count\\n\"\n             \"  \\\"bytes\\\": xxxxx               (numeric) Sum of all tx sizes\\n\"\n             \"  \\\"usage\\\": xxxxx               (numeric) Total memory usage for the mempool\\n\"\n+            \"  \\\"maxmempool\\\": xxxxx          (numeric) Mempool usage limit\\n\"\n+            \"  \\\"mempoolminfee\\\": xxxxx       (numeric) Fee required to enter mempool\\n\"\n+            \"  \\\"prioritylimit\\\": xxxxx       (numeric) Priority usage limit\\n\"\n+            \"  \\\"mempoolminpriority\\\": xxxxx  (numeric) Priority required to enter mempool\\n\"\n+            \"  \\\"priorityusage\\\": xxxxx       (numeric) Total memory usage of priority txs\\n\"\n             \"}\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"getmempoolinfo\", \"\")"
      },
      {
        "sha": "b0f35c1b0eb7f555d397a2b92156bb0910f687de",
        "filename": "src/test/mempool_tests.cpp",
        "status": "modified",
        "additions": 76,
        "deletions": 18,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32520bfb9e450522cc507faf30bf2eadecdf349b/src/test/mempool_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32520bfb9e450522cc507faf30bf2eadecdf349b/src/test/mempool_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/mempool_tests.cpp?ref=32520bfb9e450522cc507faf30bf2eadecdf349b",
        "patch": "@@ -4,6 +4,7 @@\n \n #include \"txmempool.h\"\n #include \"util.h\"\n+#include \"policy/fees.h\"\n \n #include \"test/test_bitcoin.h\"\n \n@@ -120,35 +121,35 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n     tx1.vout.resize(1);\n     tx1.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx1.vout[0].nValue = 10 * COIN;\n-    pool.addUnchecked(tx1.GetHash(), CTxMemPoolEntry(tx1, 10000LL, 0, 10.0, 1, true));\n+    pool.addUnchecked(tx1.GetHash(), CTxMemPoolEntry(tx1, 10000LL, 0, 10.0, 1, false));\n \n     /* highest fee */\n     CMutableTransaction tx2 = CMutableTransaction();\n     tx2.vout.resize(1);\n     tx2.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx2.vout[0].nValue = 2 * COIN;\n-    pool.addUnchecked(tx2.GetHash(), CTxMemPoolEntry(tx2, 20000LL, 0, 9.0, 1, true));\n+    pool.addUnchecked(tx2.GetHash(), CTxMemPoolEntry(tx2, 20000LL, 0, 9.0, 1, false));\n \n     /* lowest fee */\n     CMutableTransaction tx3 = CMutableTransaction();\n     tx3.vout.resize(1);\n     tx3.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx3.vout[0].nValue = 5 * COIN;\n-    pool.addUnchecked(tx3.GetHash(), CTxMemPoolEntry(tx3, 0LL, 0, 100.0, 1, true));\n+    pool.addUnchecked(tx3.GetHash(), CTxMemPoolEntry(tx3, 0LL, 0, 100.0, 1, false));\n \n     /* 2nd highest fee */\n     CMutableTransaction tx4 = CMutableTransaction();\n     tx4.vout.resize(1);\n     tx4.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx4.vout[0].nValue = 6 * COIN;\n-    pool.addUnchecked(tx4.GetHash(), CTxMemPoolEntry(tx4, 15000LL, 0, 1.0, 1, true));\n+    pool.addUnchecked(tx4.GetHash(), CTxMemPoolEntry(tx4, 15000LL, 0, 1.0, 1, false));\n \n     /* equal fee rate to tx1, but newer */\n     CMutableTransaction tx5 = CMutableTransaction();\n     tx5.vout.resize(1);\n     tx5.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx5.vout[0].nValue = 11 * COIN;\n-    pool.addUnchecked(tx5.GetHash(), CTxMemPoolEntry(tx5, 10000LL, 1, 10.0, 1, true));\n+    pool.addUnchecked(tx5.GetHash(), CTxMemPoolEntry(tx5, 10000LL, 1, 10.0, 1, false));\n     BOOST_CHECK_EQUAL(pool.size(), 5);\n \n     std::vector<std::string> sortedOrder;\n@@ -166,7 +167,7 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n     tx6.vout.resize(1);\n     tx6.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx6.vout[0].nValue = 20 * COIN;\n-    pool.addUnchecked(tx6.GetHash(), CTxMemPoolEntry(tx6, 0LL, 1, 10.0, 1, true));\n+    pool.addUnchecked(tx6.GetHash(), CTxMemPoolEntry(tx6, 0LL, 1, 10.0, 1, false));\n     BOOST_CHECK_EQUAL(pool.size(), 6);\n     // Check that at this point, tx6 is sorted low\n     sortedOrder.insert(sortedOrder.begin(), tx6.GetHash().ToString());\n@@ -186,11 +187,11 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n \n     CTxMemPool::setEntries setAncestorsCalculated;\n     std::string dummy;\n-    CTxMemPoolEntry entry7(tx7, 2000000LL, 1, 10.0, 1, true);\n+    CTxMemPoolEntry entry7(tx7, 2000000LL, 1, 10.0, 1, false);\n     BOOST_CHECK_EQUAL(pool.CalculateMemPoolAncestors(entry7, setAncestorsCalculated, 100, 1000000, 1000, 1000000, dummy), true);\n     BOOST_CHECK(setAncestorsCalculated == setAncestors);\n \n-    pool.addUnchecked(tx7.GetHash(), CTxMemPoolEntry(tx7, 2000000LL, 1, 10.0, 1, true), setAncestors);\n+    pool.addUnchecked(tx7.GetHash(), CTxMemPoolEntry(tx7, 2000000LL, 1, 10.0, 1, false), setAncestors);\n     BOOST_CHECK_EQUAL(pool.size(), 7);\n \n     // Now tx6 should be sorted higher (high fee child): tx7, tx6, tx2, ...\n@@ -208,7 +209,7 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n     tx8.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx8.vout[0].nValue = 10 * COIN;\n     setAncestors.insert(pool.mapTx.find(tx7.GetHash()));\n-    pool.addUnchecked(tx8.GetHash(), CTxMemPoolEntry(tx8, 0LL, 2, 10.0, 1, true), setAncestors);\n+    pool.addUnchecked(tx8.GetHash(), CTxMemPoolEntry(tx8, 0LL, 2, 10.0, 1, false), setAncestors);\n \n     // Now tx8 should be sorted low, but tx6/tx both high\n     sortedOrder.insert(sortedOrder.begin(), tx8.GetHash().ToString());\n@@ -222,7 +223,7 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n     tx9.vout.resize(1);\n     tx9.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx9.vout[0].nValue = 1 * COIN;\n-    pool.addUnchecked(tx9.GetHash(), CTxMemPoolEntry(tx9, 0LL, 3, 10.0, 1, true), setAncestors);\n+    pool.addUnchecked(tx9.GetHash(), CTxMemPoolEntry(tx9, 0LL, 3, 10.0, 1, false), setAncestors);\n \n     // tx9 should be sorted low\n     BOOST_CHECK_EQUAL(pool.size(), 9);\n@@ -245,11 +246,11 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n     tx10.vout[0].nValue = 10 * COIN;\n \n     setAncestorsCalculated.clear();\n-    CTxMemPoolEntry entry10(tx10, 200000LL, 4, 10.0, 1, true);\n+    CTxMemPoolEntry entry10(tx10, 200000LL, 4, 10.0, 1, false);\n     BOOST_CHECK_EQUAL(pool.CalculateMemPoolAncestors(entry10, setAncestorsCalculated, 100, 1000000, 1000, 1000000, dummy), true);\n     BOOST_CHECK(setAncestorsCalculated == setAncestors);\n \n-    pool.addUnchecked(tx10.GetHash(), CTxMemPoolEntry(tx10, 200000LL, 4, 10.0, 1, true), setAncestors);\n+    pool.addUnchecked(tx10.GetHash(), CTxMemPoolEntry(tx10, 200000LL, 4, 10.0, 1, false), setAncestors);\n \n     /**\n      *  tx8 and tx9 should both now be sorted higher\n@@ -279,6 +280,63 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n     std::list<CTransaction> removed;\n     pool.remove(pool.mapTx.find(tx10.GetHash())->GetTx(), removed, true);\n     CheckSort(pool, snapshotOrder);\n+\n+    // Now add some priority transactions and verify they sort to the end,\n+    // in reverse priority order\n+    sortedOrder = snapshotOrder;\n+    CMutableTransaction tx11 = CMutableTransaction();\n+    tx11.vin.resize(0);\n+    tx11.vout.resize(1);\n+    tx11.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx11.vout[0].nValue = 105 * COIN;\n+    CTxMemPoolEntry entry11(tx11, 0LL, 5, 1e10, 1, true);\n+    sortedOrder.push_back(tx11.GetHash().ToString());\n+    pool.addUnchecked(tx11.GetHash(), entry11);\n+    CheckSort(pool, sortedOrder);\n+\n+    CMutableTransaction tx12 = CMutableTransaction();\n+    tx12.vin.resize(0);\n+    tx12.vout.resize(1);\n+    tx12.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx12.vout[0].nValue = 106 * COIN;\n+    CTxMemPoolEntry entry12(tx12, 0LL, 6, 1e10, 1, true);\n+    sortedOrder.push_back(tx12.GetHash().ToString());\n+    pool.addUnchecked(tx12.GetHash(), entry12);\n+    CheckSort(pool, sortedOrder);\n+\n+    CMutableTransaction tx13 = CMutableTransaction();\n+    tx13.vin.resize(0);\n+    tx13.vout.resize(1);\n+    tx13.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx13.vout[0].nValue = 102 * COIN;\n+    CTxMemPoolEntry entry13(tx13, 0LL, 6, 1e11, 1, true);\n+    sortedOrder.insert(sortedOrder.end()-2, tx13.GetHash().ToString());\n+    pool.addUnchecked(tx13.GetHash(), entry13);\n+    CheckSort(pool, sortedOrder);\n+\n+    // Verify that GetMinPriority works\n+    SetMockTime(42);\n+    BOOST_CHECK(pool.GetMinPriority(0) == INF_PRIORITY);\n+\n+    pool.TrimToSize(pool.DynamicMemoryUsage(), 1); // evict all priority tx's\n+\n+    // entry13 had max priority, so that's the new minimum\n+    BOOST_CHECK(pool.GetMinPriority(1) == entry13.GetPriority());\n+\n+    // No decay unless a block is found\n+    SetMockTime(42 + CTxMemPool::ROLLING_FEE_HALFLIFE);\n+    BOOST_CHECK(pool.GetMinPriority(1) == entry13.GetPriority());\n+\n+    std::vector<CTransaction> vtx;\n+    std::list<CTransaction> conflicts;\n+    pool.removeForBlock(vtx, 1, conflicts);\n+\n+    SetMockTime(42 + 2*CTxMemPool::ROLLING_FEE_HALFLIFE);\n+    BOOST_CHECK(pool.GetMinPriority(1) == entry13.GetPriority()/2);\n+\n+    // After enough time decay will drop but not below AllowFreeThreshold()\n+    SetMockTime(42 + 20*CTxMemPool::ROLLING_FEE_HALFLIFE);\n+    BOOST_CHECK(pool.GetMinPriority(1) == AllowFreeThreshold());\n }\n \n BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)\n@@ -301,11 +359,11 @@ BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)\n     tx2.vout[0].nValue = 10 * COIN;\n     pool.addUnchecked(tx2.GetHash(), CTxMemPoolEntry(tx2, 5000LL, 0, 10.0, 1, pool.HasNoInputsOf(tx2)));\n \n-    pool.TrimToSize(pool.DynamicMemoryUsage()); // should do nothing\n+    pool.TrimToSize(pool.DynamicMemoryUsage(), 0); // should do nothing\n     BOOST_CHECK(pool.exists(tx1.GetHash()));\n     BOOST_CHECK(pool.exists(tx2.GetHash()));\n \n-    pool.TrimToSize(pool.DynamicMemoryUsage() * 3 / 4); // should remove the lower-feerate transaction\n+    pool.TrimToSize(pool.DynamicMemoryUsage() * 3 / 4, 0); // should remove the lower-feerate transaction\n     BOOST_CHECK(pool.exists(tx1.GetHash()));\n     BOOST_CHECK(!pool.exists(tx2.GetHash()));\n \n@@ -319,12 +377,12 @@ BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)\n     tx3.vout[0].nValue = 10 * COIN;\n     pool.addUnchecked(tx3.GetHash(), CTxMemPoolEntry(tx3, 20000LL, 0, 10.0, 1, pool.HasNoInputsOf(tx3)));\n \n-    pool.TrimToSize(pool.DynamicMemoryUsage() * 3 / 4); // tx3 should pay for tx2 (CPFP)\n+    pool.TrimToSize(pool.DynamicMemoryUsage() * 3 / 4, 0); // tx3 should pay for tx2 (CPFP)\n     BOOST_CHECK(!pool.exists(tx1.GetHash()));\n     BOOST_CHECK(pool.exists(tx2.GetHash()));\n     BOOST_CHECK(pool.exists(tx3.GetHash()));\n \n-    pool.TrimToSize(::GetSerializeSize(CTransaction(tx1), SER_NETWORK, PROTOCOL_VERSION)); // mempool is limited to tx1's size in memory usage, so nothing fits\n+    pool.TrimToSize(::GetSerializeSize(CTransaction(tx1), SER_NETWORK, PROTOCOL_VERSION), 0); // mempool is limited to tx1's size in memory usage, so nothing fits\n     BOOST_CHECK(!pool.exists(tx1.GetHash()));\n     BOOST_CHECK(!pool.exists(tx2.GetHash()));\n     BOOST_CHECK(!pool.exists(tx3.GetHash()));\n@@ -386,7 +444,7 @@ BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)\n     pool.addUnchecked(tx7.GetHash(), CTxMemPoolEntry(tx7, 9000LL, 0, 10.0, 1, pool.HasNoInputsOf(tx7)));\n \n     // we only require this remove, at max, 2 txn, because its not clear what we're really optimizing for aside from that\n-    pool.TrimToSize(pool.DynamicMemoryUsage() - 1);\n+    pool.TrimToSize(pool.DynamicMemoryUsage() - 1, 0);\n     BOOST_CHECK(pool.exists(tx4.GetHash()));\n     BOOST_CHECK(pool.exists(tx6.GetHash()));\n     BOOST_CHECK(!pool.exists(tx7.GetHash()));\n@@ -395,7 +453,7 @@ BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)\n         pool.addUnchecked(tx5.GetHash(), CTxMemPoolEntry(tx5, 1000LL, 0, 10.0, 1, pool.HasNoInputsOf(tx5)));\n     pool.addUnchecked(tx7.GetHash(), CTxMemPoolEntry(tx7, 9000LL, 0, 10.0, 1, pool.HasNoInputsOf(tx7)));\n \n-    pool.TrimToSize(pool.DynamicMemoryUsage() / 2); // should maximize mempool size by only removing 5/7\n+    pool.TrimToSize(pool.DynamicMemoryUsage() / 2, 0); // should maximize mempool size by only removing 5/7\n     BOOST_CHECK(pool.exists(tx4.GetHash()));\n     BOOST_CHECK(!pool.exists(tx5.GetHash()));\n     BOOST_CHECK(pool.exists(tx6.GetHash()));"
      },
      {
        "sha": "d502c68bf98dc5e154d24d81022df391ac026986",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 72,
        "deletions": 1,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32520bfb9e450522cc507faf30bf2eadecdf349b/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32520bfb9e450522cc507faf30bf2eadecdf349b/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=32520bfb9e450522cc507faf30bf2eadecdf349b",
        "patch": "@@ -31,6 +31,9 @@ CTxMemPoolEntry::CTxMemPoolEntry(const CTransaction& _tx, const CAmount& _nFee,\n     nCountWithDescendants = 1;\n     nSizeWithDescendants = nTxSize;\n     nFeesWithDescendants = nFee;\n+\n+    // Assume priority-eligible if no in-mempool parents\n+    fPriorityTx = hadNoDependencies;\n }\n \n CTxMemPoolEntry::CTxMemPoolEntry(const CTxMemPoolEntry& other)\n@@ -386,6 +389,11 @@ bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry,\n     }\n     UpdateAncestorsOf(true, newit, setAncestors);\n \n+    if (newit->IsPriorityTx()) {\n+        assert(setAncestors.empty());\n+        priorityUsage += sizeof(*newit) + newit->DynamicMemoryUsage();\n+    }\n+\n     nTransactionsUpdated++;\n     totalTxSize += entry.GetTxSize();\n     minerPolicyEstimator->processTransaction(entry, fCurrentEstimate);\n@@ -544,7 +552,9 @@ void CTxMemPool::removeForBlock(const std::vector<CTransaction>& vtx, unsigned i\n     // After the txs in the new block have been removed from the mempool, update policy estimates\n     minerPolicyEstimator->processBlock(nBlockHeight, entries, fCurrentEstimate);\n     lastRollingFeeUpdate = GetTime();\n+    lastRollingPriorityUpdate = lastRollingFeeUpdate;\n     blockSinceLastRollingFeeBump = true;\n+    blockSinceLastRollingPriorityBump = true;\n }\n \n void CTxMemPool::_clear()\n@@ -555,9 +565,13 @@ void CTxMemPool::_clear()\n     totalTxSize = 0;\n     cachedInnerUsage = 0;\n     lastRollingFeeUpdate = GetTime();\n+    lastRollingPriorityUpdate = lastRollingFeeUpdate;\n     blockSinceLastRollingFeeBump = false;\n+    blockSinceLastRollingPriorityBump = false;\n     rollingMinimumFeeRate = 0;\n+    rollingMinimumPriority = 0;\n     ++nTransactionsUpdated;\n+    priorityUsage = 0;\n }\n \n void CTxMemPool::clear()\n@@ -578,6 +592,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n \n     uint64_t checkTotal = 0;\n     uint64_t innerUsage = 0;\n+    uint64_t checkPriorityUsage = 0;\n \n     CCoinsViewCache mempoolDuplicate(const_cast<CCoinsViewCache*>(pcoins));\n \n@@ -587,6 +602,8 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n         unsigned int i = 0;\n         checkTotal += it->GetTxSize();\n         innerUsage += it->DynamicMemoryUsage();\n+        if (it->IsPriorityTx())\n+            checkPriorityUsage += sizeof(*it) + it->DynamicMemoryUsage();\n         const CTransaction& tx = it->GetTx();\n         txlinksMap::const_iterator linksiter = mapLinks.find(it);\n         assert(linksiter != mapLinks.end());\n@@ -675,6 +692,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n \n     assert(totalTxSize == checkTotal);\n     assert(innerUsage == cachedInnerUsage);\n+    assert(priorityUsage == checkPriorityUsage);\n }\n \n void CTxMemPool::queryHashes(vector<uint256>& vtxid)\n@@ -806,6 +824,9 @@ void CTxMemPool::RemoveStaged(setEntries &stage) {\n     AssertLockHeld(cs);\n     UpdateForRemoveFromMempool(stage);\n     BOOST_FOREACH(const txiter& it, stage) {\n+        if (it->IsPriorityTx()) {\n+            priorityUsage -= sizeof(*it) + it->DynamicMemoryUsage();\n+        }\n         removeUnchecked(it);\n     }\n }\n@@ -904,11 +925,38 @@ void CTxMemPool::trackPackageRemoved(const CFeeRate& rate) {\n     }\n }\n \n-void CTxMemPool::TrimToSize(size_t sizelimit) {\n+void CTxMemPool::trackPriorityRemoved(double priority) {\n+    AssertLockHeld(cs);\n+    if (priority > rollingMinimumPriority) {\n+        rollingMinimumPriority = priority;\n+        blockSinceLastRollingPriorityBump = false;\n+    }\n+}\n+\n+void CTxMemPool::TrimToSize(size_t sizelimit, size_t priorityLimit) {\n     LOCK(cs);\n \n     unsigned nTxnRemoved = 0;\n     CFeeRate maxFeeRateRemoved(0);\n+    while (priorityUsage > priorityLimit) {\n+        // First move transactions from priority space to fee space\n+        indexed_transaction_set::nth_index<1>::type::iterator lastPriTx;\n+        lastPriTx = mapTx.get<1>().end();\n+        assert(lastPriTx != mapTx.get<1>().begin()); // must have something to evict!\n+        lastPriTx--;\n+        assert(lastPriTx->IsPriorityTx());\n+\n+        trackPriorityRemoved(lastPriTx->GetPriority());\n+        LogPrint(\"mempool\", \"TrimToSize: priority usage too high (%d > %d); moving tx %s (%lu bytes %f priority; rolling min priority=%f)\\n\",\n+                priorityUsage, priorityLimit,\n+                lastPriTx->GetTx().GetHash().ToString(), \n+                lastPriTx->DynamicMemoryUsage(),\n+                lastPriTx->GetPriority(),\n+                rollingMinimumPriority);\n+\n+        priorityUsage -= sizeof(*lastPriTx) + lastPriTx->DynamicMemoryUsage();\n+        mapTx.modify(mapTx.project<0>(lastPriTx), set_prioritytx(false));\n+    }\n     while (DynamicMemoryUsage() > sizelimit) {\n         indexed_transaction_set::nth_index<1>::type::iterator it = mapTx.get<1>().begin();\n \n@@ -930,3 +978,26 @@ void CTxMemPool::TrimToSize(size_t sizelimit) {\n     if (maxFeeRateRemoved > CFeeRate(0))\n         LogPrint(\"mempool\", \"Removed %u txn, rolling minimum fee bumped to %s\\n\", nTxnRemoved, maxFeeRateRemoved.ToString());\n }\n+\n+double CTxMemPool::GetMinPriority(size_t priorityLimit) const {\n+    if (priorityLimit == 0)\n+        return INF_PRIORITY;\n+\n+    LOCK(cs);\n+    if (!blockSinceLastRollingPriorityBump || rollingMinimumPriority < AllowFreeThreshold())\n+        return std::max(rollingMinimumPriority, AllowFreeThreshold());\n+\n+    // Check to see if it's time to decay, and then return the updated value.\n+    int64_t time = GetTime();\n+    if (time > lastRollingPriorityUpdate + 10) {\n+        double halflife = ROLLING_FEE_HALFLIFE; // use the same halflife as for fee\n+        if (priorityUsage < priorityLimit / 4)\n+            halflife /= 4;\n+        else if (priorityUsage < priorityLimit / 2)\n+            halflife /= 2;\n+\n+        rollingMinimumPriority = rollingMinimumPriority / pow(2.0, (time - lastRollingPriorityUpdate) / halflife);\n+        lastRollingPriorityUpdate = time;\n+    }\n+    return std::max(rollingMinimumPriority, AllowFreeThreshold());\n+}"
      },
      {
        "sha": "2073f8d3ca0e363acd4c43e069b7e2ddc1550402",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 80,
        "deletions": 24,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32520bfb9e450522cc507faf30bf2eadecdf349b/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32520bfb9e450522cc507faf30bf2eadecdf349b/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=32520bfb9e450522cc507faf30bf2eadecdf349b",
        "patch": "@@ -76,13 +76,17 @@ class CTxMemPoolEntry\n     uint64_t nSizeWithDescendants;  //! ... and size\n     CAmount nFeesWithDescendants;  //! ... and total fees (all including us)\n \n+    bool fPriorityTx; //! ...whether to store this in the priority space\n+\n public:\n     CTxMemPoolEntry(const CTransaction& _tx, const CAmount& _nFee,\n-                    int64_t _nTime, double _dPriority, unsigned int _nHeight, bool poolHasNoInputsOf = false);\n+                    int64_t _nTime, double _dPriority, unsigned int _nHeight,\n+                    bool poolHasNoInputsOf = false);\n     CTxMemPoolEntry(const CTxMemPoolEntry& other);\n \n     const CTransaction& GetTx() const { return this->tx; }\n     double GetPriority(unsigned int currentHeight) const;\n+    double GetPriority() const { return dPriority; }\n     const CAmount& GetFee() const { return nFee; }\n     size_t GetTxSize() const { return nTxSize; }\n     int64_t GetTime() const { return nTime; }\n@@ -103,6 +107,9 @@ class CTxMemPoolEntry\n     uint64_t GetCountWithDescendants() const { return nCountWithDescendants; }\n     uint64_t GetSizeWithDescendants() const { return nSizeWithDescendants; }\n     CAmount GetFeesWithDescendants() const { return nFeesWithDescendants; }\n+\n+    bool IsPriorityTx() const { return fPriorityTx; }\n+    void SetPriorityTx(bool flag) { fPriorityTx = flag; }\n };\n \n // Helpers for modifying CTxMemPool::mapTx, which is a boost multi_index.\n@@ -127,6 +134,16 @@ struct set_dirty\n         { e.SetDirty(); }\n };\n \n+struct set_prioritytx\n+{\n+    set_prioritytx(bool flag) : fPriorityTx(flag) {}\n+\n+    void operator() (CTxMemPoolEntry &e)\n+        { e.SetPriorityTx(fPriorityTx); }\n+\n+    bool fPriorityTx;\n+};\n+\n // extracts a TxMemPoolEntry's transaction hash\n struct mempoolentry_txid\n {\n@@ -137,32 +154,50 @@ struct mempoolentry_txid\n     }\n };\n \n-/** \\class CompareTxMemPoolEntryByFee\n+/** \\class CompareTxMemPoolEntryByPriorityAndFee\n  *\n- *  Sort an entry by max(feerate of entry's tx, feerate with all descendants).\n+ *  Sort an entry by:\n+ *   1) priority > non-priority\n+ *   2) If both priority: sort by priority (in reverse)\n+ *   3) If both non-priority: sort by max(feerate of entry's tx, feerate with all descendants).\n+ *  We sort the priority space in reverse so it is easy to remove the\n+ *  worst priority elements (something we do in TrimToSize()).\n  */\n-class CompareTxMemPoolEntryByFee\n+class CompareTxMemPoolEntryByPriorityAndFee\n {\n public:\n     bool operator()(const CTxMemPoolEntry& a, const CTxMemPoolEntry& b)\n     {\n-        bool fUseADescendants = UseDescendantFeeRate(a);\n-        bool fUseBDescendants = UseDescendantFeeRate(b);\n-\n-        double aFees = fUseADescendants ? a.GetFeesWithDescendants() : a.GetFee();\n-        double aSize = fUseADescendants ? a.GetSizeWithDescendants() : a.GetTxSize();\n-\n-        double bFees = fUseBDescendants ? b.GetFeesWithDescendants() : b.GetFee();\n-        double bSize = fUseBDescendants ? b.GetSizeWithDescendants() : b.GetTxSize();\n-\n-        // Avoid division by rewriting (a/b > c/d) as (a*d > c*b).\n-        double f1 = aFees * bSize;\n-        double f2 = aSize * bFees;\n-\n-        if (f1 == f2) {\n-            return a.GetTime() >= b.GetTime();\n+        if (a.IsPriorityTx() && b.IsPriorityTx()) {\n+            // Sort by reverse priority -- so end of the multi_index\n+            // is the worst priority item that is in the priority space\n+            if (a.GetPriority() == b.GetPriority()) {\n+                return a.GetTime() <= b.GetTime();\n+            }\n+            return a.GetPriority() > b.GetPriority();\n+        } else if (!a.IsPriorityTx() && !b.IsPriorityTx()) {\n+            // sort by feerate\n+            bool fUseADescendants = UseDescendantFeeRate(a);\n+            bool fUseBDescendants = UseDescendantFeeRate(b);\n+\n+            double aFees = fUseADescendants ? a.GetFeesWithDescendants() : a.GetFee();\n+            double aSize = fUseADescendants ? a.GetSizeWithDescendants() : a.GetTxSize();\n+\n+            double bFees = fUseBDescendants ? b.GetFeesWithDescendants() : b.GetFee();\n+            double bSize = fUseBDescendants ? b.GetSizeWithDescendants() : b.GetTxSize();\n+\n+            // Avoid division by rewriting (a/b > c/d) as (a*d > c*b).\n+            double f1 = aFees * bSize;\n+            double f2 = aSize * bFees;\n+\n+            if (f1 == f2) {\n+                return a.GetTime() >= b.GetTime();\n+            }\n+            return f1 < f2;\n+        } else {\n+            // One of the entries is a priority one\n+            return b.IsPriorityTx();\n         }\n-        return f1 < f2;\n     }\n \n     // Calculate which feerate to use for an entry (avoiding division).\n@@ -213,13 +248,22 @@ class CInPoint\n  *\n  * mapTx is a boost::multi_index that sorts the mempool on 3 criteria:\n  * - transaction hash\n- * - feerate [we use max(feerate of tx, feerate of tx with all descendants)]\n+ * - priority & feerate\n  * - time in mempool\n  *\n  * Note: the term \"descendant\" refers to in-mempool transactions that depend on\n  * this one, while \"ancestor\" refers to in-mempool transactions that a given\n  * transaction depends on.\n  *\n+ * The second index that uses priority and feerate works as follows:\n+ * - Transactions that have no in-mempool ancestors are eligible to be sorted\n+ *   based on priority.\n+ * - Priority transactions all sort better than non-priority transactions.\n+ * - Between priority transactions, we sort based on priority upon entry into\n+ *   the mempool (in reverse order, so that the worst priority tx is at the end).\n+ * - Between non-priority transactions, we sort based on\n+ *   max(feerate, feerate with descendants).\n+ *\n  * In order for the feerate sort to remain correct, we must update transactions\n  * in the mempool when new descendants arrive.  To facilitate this, we track\n  * the set of in-mempool direct parents and direct children in mapLinks.  Within\n@@ -291,7 +335,12 @@ class CTxMemPool\n     mutable bool blockSinceLastRollingFeeBump;\n     mutable double rollingMinimumFeeRate; //! minimum fee to get into the pool, decreases exponentially\n \n+    mutable int64_t lastRollingPriorityUpdate;\n+    mutable bool blockSinceLastRollingPriorityBump;\n+    mutable double rollingMinimumPriority; //! minimum priority to get into mempool, decreases exponentially\n+\n     void trackPackageRemoved(const CFeeRate& rate);\n+    void trackPriorityRemoved(double priority);\n \n public:\n \n@@ -305,7 +354,7 @@ class CTxMemPool\n             // sorted by fee rate\n             boost::multi_index::ordered_non_unique<\n                 boost::multi_index::identity<CTxMemPoolEntry>,\n-                CompareTxMemPoolEntryByFee\n+                CompareTxMemPoolEntryByPriorityAndFee\n             >,\n             // sorted by entry time\n             boost::multi_index::ordered_non_unique<\n@@ -341,6 +390,8 @@ class CTxMemPool\n     void UpdateParent(txiter entry, txiter parent, bool add);\n     void UpdateChild(txiter entry, txiter child, bool add);\n \n+    size_t priorityUsage; // memory used by priority transactions\n+\n public:\n     std::map<COutPoint, CInPoint> mapNextTx;\n     std::map<uint256, std::pair<double, CAmount> > mapDeltas;\n@@ -427,9 +478,14 @@ class CTxMemPool\n       *  would otherwise be half of this, it is set to 0 instead.\n       */\n     CFeeRate GetMinFee(size_t sizelimit) const;\n+    double GetMinPriority(size_t priorityLimit) const;\n+    size_t GetPriorityUsage() const { return priorityUsage; }\n \n-    /** Remove transactions from the mempool until its dynamic size is <= sizelimit. */\n-    void TrimToSize(size_t sizelimit);\n+    /**\n+     * Remove transactions from the mempool until its dynamic size is <= sizelimit.\n+     * Also moves transactions out of the priority space if priorityUsage exceeds limit.\n+     */\n+    void TrimToSize(size_t sizelimit, size_t priorityLimit);\n \n     /** Expire all transaction (and their dependencies) in the mempool older than time. Return the number of removed transactions. */\n     int Expire(int64_t time);"
      }
    ]
  }
]