[
  {
    "sha": "1e861060c07c22050ac8c5ef93a006935aa1c2a7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxZTg2MTA2MGMwN2MyMjA1MGFjOGM1ZWY5M2EwMDY5MzVhYTFjMmE3",
    "commit": {
      "author": {
        "name": "Timo Witte",
        "email": "timo.witte@gmail.com",
        "date": "2014-09-22T19:40:19Z"
      },
      "committer": {
        "name": "Timo Witte",
        "email": "timo.witte@gmail.com",
        "date": "2014-09-22T19:40:19Z"
      },
      "message": "prefixed int64_t and uint64_t with :: to use libc implementation. Otherwise the symbol might be ambiguous with boost:int64_t. Fixes #3483",
      "tree": {
        "sha": "84c63b826d7dc5868df5258a9f34f04a6426de5d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/84c63b826d7dc5868df5258a9f34f04a6426de5d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1e861060c07c22050ac8c5ef93a006935aa1c2a7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1e861060c07c22050ac8c5ef93a006935aa1c2a7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1e861060c07c22050ac8c5ef93a006935aa1c2a7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1e861060c07c22050ac8c5ef93a006935aa1c2a7/comments",
    "author": {
      "login": "Spacefish",
      "id": 375633,
      "node_id": "MDQ6VXNlcjM3NTYzMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/375633?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Spacefish",
      "html_url": "https://github.com/Spacefish",
      "followers_url": "https://api.github.com/users/Spacefish/followers",
      "following_url": "https://api.github.com/users/Spacefish/following{/other_user}",
      "gists_url": "https://api.github.com/users/Spacefish/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Spacefish/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Spacefish/subscriptions",
      "organizations_url": "https://api.github.com/users/Spacefish/orgs",
      "repos_url": "https://api.github.com/users/Spacefish/repos",
      "events_url": "https://api.github.com/users/Spacefish/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Spacefish/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "Spacefish",
      "id": 375633,
      "node_id": "MDQ6VXNlcjM3NTYzMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/375633?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Spacefish",
      "html_url": "https://github.com/Spacefish",
      "followers_url": "https://api.github.com/users/Spacefish/followers",
      "following_url": "https://api.github.com/users/Spacefish/following{/other_user}",
      "gists_url": "https://api.github.com/users/Spacefish/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Spacefish/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Spacefish/subscriptions",
      "organizations_url": "https://api.github.com/users/Spacefish/orgs",
      "repos_url": "https://api.github.com/users/Spacefish/repos",
      "events_url": "https://api.github.com/users/Spacefish/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Spacefish/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "27fc5277f73e510c2150dc29308fdf2dc6a96053",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/27fc5277f73e510c2150dc29308fdf2dc6a96053",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/27fc5277f73e510c2150dc29308fdf2dc6a96053"
      }
    ],
    "stats": {
      "total": 342,
      "additions": 172,
      "deletions": 170
    },
    "files": [
      {
        "sha": "7096e5523cdea7d5468466e69a2e4b3ee2172b6a",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1e861060c07c22050ac8c5ef93a006935aa1c2a7/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1e861060c07c22050ac8c5ef93a006935aa1c2a7/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=1e861060c07c22050ac8c5ef93a006935aa1c2a7",
        "patch": "@@ -415,7 +415,7 @@ bool CDB::Rewrite(const string& strFile, const char* pszSkip)\n \n void CDBEnv::Flush(bool fShutdown)\n {\n-    int64_t nStart = GetTimeMillis();\n+    ::int64_t nStart = GetTimeMillis();\n     // Flush log data to the actual data file on all files that are not in use\n     LogPrint(\"db\", \"CDBEnv::Flush : Flush(%s)%s\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" database not started\");\n     if (!fDbEnvInit)"
      },
      {
        "sha": "152bd77d5362df0d36f6fb225b7c6c208995f1c5",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1e861060c07c22050ac8c5ef93a006935aa1c2a7/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1e861060c07c22050ac8c5ef93a006935aa1c2a7/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=1e861060c07c22050ac8c5ef93a006935aa1c2a7",
        "patch": "@@ -662,7 +662,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n     // cost to you of processing a transaction.\n     if (mapArgs.count(\"-minrelaytxfee\"))\n     {\n-        int64_t n = 0;\n+        ::int64_t n = 0;\n         if (ParseMoney(mapArgs[\"-minrelaytxfee\"], n) && n > 0)\n             ::minRelayTxFee = CFeeRate(n);\n         else\n@@ -672,15 +672,15 @@ bool AppInit2(boost::thread_group& threadGroup)\n #ifdef ENABLE_WALLET\n     if (mapArgs.count(\"-mintxfee\"))\n     {\n-        int64_t n = 0;\n+       :: int64_t n = 0;\n         if (ParseMoney(mapArgs[\"-mintxfee\"], n) && n > 0)\n             CWallet::minTxFee = CFeeRate(n);\n         else\n             return InitError(strprintf(_(\"Invalid amount for -mintxfee=<amount>: '%s'\"), mapArgs[\"-mintxfee\"]));\n     }\n     if (mapArgs.count(\"-paytxfee\"))\n     {\n-        int64_t nFeePerK = 0;\n+        ::int64_t nFeePerK = 0;\n         if (!ParseMoney(mapArgs[\"-paytxfee\"], nFeePerK))\n             return InitError(strprintf(_(\"Invalid amount for -paytxfee=<amount>: '%s'\"), mapArgs[\"-paytxfee\"]));\n         if (nFeePerK > nHighTransactionFeeWarning)\n@@ -743,7 +743,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n             threadGroup.create_thread(&ThreadScriptCheck);\n     }\n \n-    int64_t nStart;\n+    ::int64_t nStart;\n \n     // ********************************************************* Step 5: verify wallet database integrity\n #ifdef ENABLE_WALLET"
      },
      {
        "sha": "84ca874b0316e9665e38364723cab1bca5a5c417",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 71,
        "deletions": 70,
        "changes": 141,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1e861060c07c22050ac8c5ef93a006935aa1c2a7/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1e861060c07c22050ac8c5ef93a006935aa1c2a7/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=1e861060c07c22050ac8c5ef93a006935aa1c2a7",
        "patch": "@@ -40,7 +40,7 @@ CCriticalSection cs_main;\n \n BlockMap mapBlockIndex;\n CChain chainActive;\n-int64_t nTimeBestReceived = 0;\n+::int64_t nTimeBestReceived = 0;\n CWaitableCriticalSection csBestBlock;\n CConditionVariable cvBlockChange;\n int nScriptCheckThreads = 0;\n@@ -124,7 +124,7 @@ namespace {\n     // Protected by cs_main.\n     struct QueuedBlock {\n         uint256 hash;\n-        int64_t nTime;  // Time of \"getdata\" request in microseconds.\n+        ::int64_t nTime;  // Time of \"getdata\" request in microseconds.\n         int nQueuedBefore;  // Number of blocks in flight at the time of request.\n     };\n     map<uint256, pair<NodeId, list<QueuedBlock>::iterator> > mapBlocksInFlight;\n@@ -223,8 +223,8 @@ struct CNodeState {\n     int nBlocksInFlight;\n     list<uint256> vBlocksToDownload;\n     int nBlocksToDownload;\n-    int64_t nLastBlockReceive;\n-    int64_t nLastBlockProcess;\n+    ::int64_t nLastBlockReceive;\n+    ::int64_t nLastBlockProcess;\n \n     CNodeState() {\n         nMisbehavior = 0;\n@@ -644,7 +644,7 @@ bool IsStandardTx(const CTransaction& tx, string& reason)\n     return true;\n }\n \n-bool IsFinalTx(const CTransaction &tx, int nBlockHeight, int64_t nBlockTime)\n+bool IsFinalTx(const CTransaction &tx, int nBlockHeight, ::int64_t nBlockTime)\n {\n     AssertLockHeld(cs_main);\n     // Time based nLockTime implemented in 0.1.6\n@@ -654,7 +654,7 @@ bool IsFinalTx(const CTransaction &tx, int nBlockHeight, int64_t nBlockTime)\n         nBlockHeight = chainActive.Height();\n     if (nBlockTime == 0)\n         nBlockTime = GetAdjustedTime();\n-    if ((int64_t)tx.nLockTime < ((int64_t)tx.nLockTime < LOCKTIME_THRESHOLD ? (int64_t)nBlockHeight : nBlockTime))\n+    if ((::int64_t)tx.nLockTime < ((::int64_t)tx.nLockTime < LOCKTIME_THRESHOLD ? (::int64_t)nBlockHeight : nBlockTime))\n         return true;\n     BOOST_FOREACH(const CTxIn& txin, tx.vin)\n         if (!txin.IsFinal())\n@@ -781,7 +781,7 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state)\n                          REJECT_INVALID, \"bad-txns-oversize\");\n \n     // Check for negative or overflow output values\n-    int64_t nValueOut = 0;\n+    ::int64_t nValueOut = 0;\n     BOOST_FOREACH(const CTxOut& txout, tx.vout)\n     {\n         if (txout.nValue < 0)\n@@ -823,19 +823,19 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state)\n     return true;\n }\n \n-int64_t GetMinRelayFee(const CTransaction& tx, unsigned int nBytes, bool fAllowFree)\n+::int64_t GetMinRelayFee(const CTransaction& tx, unsigned int nBytes, bool fAllowFree)\n {\n     {\n         LOCK(mempool.cs);\n         uint256 hash = tx.GetHash();\n         double dPriorityDelta = 0;\n-        int64_t nFeeDelta = 0;\n+        ::int64_t nFeeDelta = 0;\n         mempool.ApplyDeltas(hash, dPriorityDelta, nFeeDelta);\n         if (dPriorityDelta > 0 || nFeeDelta > 0)\n             return 0;\n     }\n \n-    int64_t nMinFee = ::minRelayTxFee.GetFee(nBytes);\n+    ::int64_t nMinFee = ::minRelayTxFee.GetFee(nBytes);\n \n     if (fAllowFree)\n     {\n@@ -898,7 +898,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         CCoinsView dummy;\n         CCoinsViewCache view(dummy);\n \n-        int64_t nValueIn = 0;\n+        ::int64_t nValueIn = 0;\n         {\n         LOCK(pool.cs);\n         CCoinsViewMemPool viewMemPool(*pcoinsTip, pool);\n@@ -950,15 +950,15 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n                                    hash.ToString(), nSigOps, MAX_TX_SIGOPS),\n                              REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\");\n \n-        int64_t nValueOut = tx.GetValueOut();\n-        int64_t nFees = nValueIn-nValueOut;\n+        ::int64_t nValueOut = tx.GetValueOut();\n+        ::int64_t nFees = nValueIn-nValueOut;\n         double dPriority = view.GetPriority(tx, chainActive.Height());\n \n         CTxMemPoolEntry entry(tx, nFees, GetTime(), dPriority, chainActive.Height());\n         unsigned int nSize = entry.GetTxSize();\n \n         // Don't accept it if it can't get into a block\n-        int64_t txMinFee = GetMinRelayFee(tx, nSize, true);\n+        ::int64_t txMinFee = GetMinRelayFee(tx, nSize, true);\n         if (fLimitFree && nFees < txMinFee)\n             return state.DoS(0, error(\"AcceptToMemoryPool : not enough fees %s, %d < %d\",\n                                       hash.ToString(), nFees, txMinFee),\n@@ -971,8 +971,8 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         {\n             static CCriticalSection csFreeLimiter;\n             static double dFreeCount;\n-            static int64_t nLastTime;\n-            int64_t nNow = GetTime();\n+            static ::int64_t nLastTime;\n+            ::int64_t nNow = GetTime();\n \n             LOCK(csFreeLimiter);\n \n@@ -1156,7 +1156,7 @@ uint256 static GetOrphanRoot(const uint256& hash)\n // Remove a random orphan block (which does not have any dependent orphans).\n void static PruneOrphanBlocks()\n {\n-    if (mapOrphanBlocksByPrev.size() <= (size_t)std::max((int64_t)0, GetArg(\"-maxorphanblocks\", DEFAULT_MAX_ORPHAN_BLOCKS)))\n+    if (mapOrphanBlocksByPrev.size() <= (size_t)std::max((::int64_t)0, GetArg(\"-maxorphanblocks\", DEFAULT_MAX_ORPHAN_BLOCKS)))\n         return;\n \n     // Pick a random orphan block.\n@@ -1178,9 +1178,9 @@ void static PruneOrphanBlocks()\n     mapOrphanBlocks.erase(hash);\n }\n \n-int64_t GetBlockValue(int nHeight, int64_t nFees)\n+::int64_t GetBlockValue(int nHeight, ::int64_t nFees)\n {\n-    int64_t nSubsidy = 50 * COIN;\n+    ::int64_t nSubsidy = 50 * COIN;\n     int halvings = nHeight / Params().SubsidyHalvingInterval();\n \n     // Force block reward to zero when right shift is undefined.\n@@ -1198,7 +1198,7 @@ bool IsInitialBlockDownload()\n     LOCK(cs_main);\n     if (fImporting || fReindex || chainActive.Height() < Checkpoints::GetTotalBlocksEstimate())\n         return true;\n-    static int64_t nLastUpdate;\n+    static ::int64_t nLastUpdate;\n     static CBlockIndex* pindexLastBest;\n     if (chainActive.Tip() != pindexLastBest)\n     {\n@@ -1389,8 +1389,8 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n         // This is also true for mempool checks.\n         CBlockIndex *pindexPrev = mapBlockIndex.find(inputs.GetBestBlock())->second;\n         int nSpendHeight = pindexPrev->nHeight + 1;\n-        int64_t nValueIn = 0;\n-        int64_t nFees = 0;\n+        ::int64_t nValueIn = 0;\n+        ::int64_t nFees = 0;\n         for (unsigned int i = 0; i < tx.vin.size(); i++)\n         {\n             const COutPoint &prevout = tx.vin[i].prevout;\n@@ -1418,7 +1418,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                              REJECT_INVALID, \"bad-txns-in-belowout\");\n \n         // Tally transaction fees\n-        int64_t nTxFee = nValueIn - tx.GetValueOut();\n+        ::int64_t nTxFee = nValueIn - tx.GetValueOut();\n         if (nTxFee < 0)\n             return state.DoS(100, error(\"CheckInputs() : %s nTxFee < 0\", tx.GetHash().ToString()),\n                              REJECT_INVALID, \"bad-txns-fee-negative\");\n@@ -1596,11 +1596,11 @@ void ThreadScriptCheck() {\n     scriptcheckqueue.Thread();\n }\n \n-static int64_t nTimeVerify = 0;\n-static int64_t nTimeConnect = 0;\n-static int64_t nTimeIndex = 0;\n-static int64_t nTimeCallbacks = 0;\n-static int64_t nTimeTotal = 0;\n+static ::int64_t nTimeVerify = 0;\n+static ::int64_t nTimeConnect = 0;\n+static ::int64_t nTimeIndex = 0;\n+static ::int64_t nTimeCallbacks = 0;\n+static ::int64_t nTimeTotal = 0;\n \n bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, CCoinsViewCache& view, bool fJustCheck)\n {\n@@ -1647,7 +1647,7 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n     }\n \n     // BIP16 didn't become active until Apr 1 2012\n-    int64_t nBIP16SwitchTime = 1333238400;\n+    ::int64_t nBIP16SwitchTime = 1333238400;\n     bool fStrictPayToScriptHash = (pindex->GetBlockTime() >= nBIP16SwitchTime);\n \n     unsigned int flags = SCRIPT_VERIFY_NOCACHE |\n@@ -1657,8 +1657,8 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n \n     CCheckQueueControl<CScriptCheck> control(fScriptChecks && nScriptCheckThreads ? &scriptcheckqueue : NULL);\n \n-    int64_t nTimeStart = GetTimeMicros();\n-    int64_t nFees = 0;\n+    ::int64_t nTimeStart = GetTimeMicros();\n+    ::int64_t nFees = 0;\n     int nInputs = 0;\n     unsigned int nSigOps = 0;\n     CDiskTxPos pos(pindex->GetBlockPos(), GetSizeOfCompactSize(block.vtx.size()));\n@@ -1709,7 +1709,7 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n         vPos.push_back(std::make_pair(tx.GetHash(), pos));\n         pos.nTxOffset += ::GetSerializeSize(tx, SER_DISK, CLIENT_VERSION);\n     }\n-    int64_t nTime1 = GetTimeMicros(); nTimeConnect += nTime1 - nTimeStart;\n+    ::int64_t nTime1 = GetTimeMicros(); nTimeConnect += nTime1 - nTimeStart;\n     LogPrint(\"bench\", \"      - Connect %u transactions: %.2fms (%.3fms/tx, %.3fms/txin) [%.2fs]\\n\", (unsigned)block.vtx.size(), 0.001 * (nTime1 - nTimeStart), 0.001 * (nTime1 - nTimeStart) / block.vtx.size(), nInputs <= 1 ? 0 : 0.001 * (nTime1 - nTimeStart) / (nInputs-1), nTimeConnect * 0.000001);\n \n     if (block.vtx[0].GetValueOut() > GetBlockValue(pindex->nHeight, nFees))\n@@ -1720,7 +1720,8 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n \n     if (!control.Wait())\n         return state.DoS(100, false);\n-    int64_t nTime2 = GetTimeMicros(); nTimeVerify += nTime2 - nTimeStart;\n+\n+    ::int64_t nTime2 = GetTimeMicros(); nTimeVerify += nTime2 - nTimeStart;\n     LogPrint(\"bench\", \"    - Verify %u txins: %.2fms (%.3fms/txin) [%.2fs]\\n\", nInputs - 1, 0.001 * (nTime2 - nTimeStart), nInputs <= 1 ? 0 : 0.001 * (nTime2 - nTimeStart) / (nInputs-1), nTimeVerify * 0.000001);\n \n     if (fJustCheck)\n@@ -1762,23 +1763,23 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n     ret = view.SetBestBlock(pindex->GetBlockHash());\n     assert(ret);\n \n-    int64_t nTime3 = GetTimeMicros(); nTimeIndex += nTime3 - nTime2;\n+    ::int64_t nTime3 = GetTimeMicros(); nTimeIndex += nTime3 - nTime2;\n     LogPrint(\"bench\", \"    - Index writing: %.2fms [%.2fs]\\n\", 0.001 * (nTime3 - nTime2), nTimeIndex * 0.000001);\n \n     // Watch for changes to the previous coinbase transaction.\n     static uint256 hashPrevBestCoinBase;\n     g_signals.UpdatedTransaction(hashPrevBestCoinBase);\n     hashPrevBestCoinBase = block.vtx[0].GetHash();\n \n-    int64_t nTime4 = GetTimeMicros(); nTimeCallbacks += nTime4 - nTime3;\n+    ::int64_t nTime4 = GetTimeMicros(); nTimeCallbacks += nTime4 - nTime3;\n     LogPrint(\"bench\", \"    - Callbacks: %.2fms [%.2fs]\\n\", 0.001 * (nTime4 - nTime3), nTimeCallbacks * 0.000001);\n \n     return true;\n }\n \n // Update the on-disk chain state.\n bool static WriteChainState(CValidationState &state) {\n-    static int64_t nLastWrite = 0;\n+    static ::int64_t nLastWrite = 0;\n     if (pcoinsTip->GetCacheSize() > nCoinCacheSize || (!IsInitialBlockDownload() && GetTimeMicros() > nLastWrite + 600*1000000)) {\n         // Typical CCoins structures on disk are around 100 bytes in size.\n         // Pushing a new one to the database can cause it to be written\n@@ -1840,7 +1841,7 @@ bool static DisconnectTip(CValidationState &state) {\n     if (!ReadBlockFromDisk(block, pindexDelete))\n         return state.Abort(_(\"Failed to read block\"));\n     // Apply the block atomically to the chain state.\n-    int64_t nStart = GetTimeMicros();\n+    ::int64_t nStart = GetTimeMicros();\n     {\n         CCoinsViewCache view(*pcoinsTip, true);\n         if (!DisconnectBlock(block, state, pindexDelete, view))\n@@ -1871,28 +1872,28 @@ bool static DisconnectTip(CValidationState &state) {\n     return true;\n }\n \n-static int64_t nTimeReadFromDisk = 0;\n-static int64_t nTimeConnectTotal = 0;\n-static int64_t nTimeFlush = 0;\n-static int64_t nTimeChainState = 0;\n-static int64_t nTimePostConnect = 0;\n+static ::int64_t nTimeReadFromDisk = 0;\n+static ::int64_t nTimeConnectTotal = 0;\n+static ::int64_t nTimeFlush = 0;\n+static ::int64_t nTimeChainState = 0;\n+static ::int64_t nTimePostConnect = 0;\n \n // Connect a new block to chainActive. pblock is either NULL or a pointer to a CBlock\n // corresponding to pindexNew, to bypass loading it again from disk.\n bool static ConnectTip(CValidationState &state, CBlockIndex *pindexNew, CBlock *pblock) {\n     assert(pindexNew->pprev == chainActive.Tip());\n     mempool.check(pcoinsTip);\n     // Read block from disk.\n-    int64_t nTime1 = GetTimeMicros();\n+    ::int64_t nTime1 = GetTimeMicros();\n     CBlock block;\n     if (!pblock) {\n         if (!ReadBlockFromDisk(block, pindexNew))\n             return state.Abort(_(\"Failed to read block\"));\n         pblock = &block;\n     }\n     // Apply the block atomically to the chain state.\n-    int64_t nTime2 = GetTimeMicros(); nTimeReadFromDisk += nTime2 - nTime1;\n-    int64_t nTime3;\n+    ::int64_t nTime2 = GetTimeMicros(); nTimeReadFromDisk += nTime2 - nTime1;\n+    ::int64_t nTime3;\n     LogPrint(\"bench\", \"  - Load block from disk: %.2fms [%.2fs]\\n\", (nTime2 - nTime1) * 0.001, nTimeReadFromDisk * 0.000001);\n     {\n         CCoinsViewCache view(*pcoinsTip, true);\n@@ -1907,12 +1908,12 @@ bool static ConnectTip(CValidationState &state, CBlockIndex *pindexNew, CBlock *\n         LogPrint(\"bench\", \"  - Connect total: %.2fms [%.2fs]\\n\", (nTime3 - nTime2) * 0.001, nTimeConnectTotal * 0.000001);\n         assert(view.Flush());\n     }\n-    int64_t nTime4 = GetTimeMicros(); nTimeFlush += nTime4 - nTime3;\n+    ::int64_t nTime4 = GetTimeMicros(); nTimeFlush += nTime4 - nTime3;\n     LogPrint(\"bench\", \"  - Flush: %.2fms [%.2fs]\\n\", (nTime4 - nTime3) * 0.001, nTimeFlush * 0.000001);\n     // Write the chain state to disk, if necessary.\n     if (!WriteChainState(state))\n         return false;\n-    int64_t nTime5 = GetTimeMicros(); nTimeChainState += nTime5 - nTime4;\n+    ::int64_t nTime5 = GetTimeMicros(); nTimeChainState += nTime5 - nTime4;\n     LogPrint(\"bench\", \"  - Writing chainstate: %.2fms [%.2fs]\\n\", (nTime5 - nTime4) * 0.001, nTimeChainState * 0.000001);\n     // Remove conflicting transactions from the mempool.\n     list<CTransaction> txConflicted;\n@@ -1934,7 +1935,7 @@ bool static ConnectTip(CValidationState &state, CBlockIndex *pindexNew, CBlock *\n     if ((chainActive.Height() % 20160) == 0 || ((chainActive.Height() % 144) == 0 && !IsInitialBlockDownload()))\n         g_signals.SetBestChain(chainActive.GetLocator());\n \n-    int64_t nTime6 = GetTimeMicros(); nTimePostConnect += nTime6 - nTime5; nTimeTotal += nTime6 - nTime1;\n+    ::int64_t nTime6 = GetTimeMicros(); nTimePostConnect += nTime6 - nTime5; nTimeTotal += nTime6 - nTime1;\n     LogPrint(\"bench\", \"  - Connect postprocess: %.2fms [%.2fs]\\n\", (nTime6 - nTime5) * 0.001, nTimePostConnect * 0.000001);\n     LogPrint(\"bench\", \"- Connect block: %.2fms [%.2fs]\\n\", (nTime6 - nTime1) * 0.001, nTimeTotal * 0.000001);\n     return true;\n@@ -2153,7 +2154,7 @@ bool ReceivedBlockTransactions(const CBlock &block, CValidationState& state, CBl\n     return true;\n }\n \n-bool FindBlockPos(CValidationState &state, CDiskBlockPos &pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime, bool fKnown = false)\n+bool FindBlockPos(CValidationState &state, CDiskBlockPos &pos, unsigned int nAddSize, unsigned int nHeight, ::uint64_t nTime, bool fKnown = false)\n {\n     bool fUpdatedLast = false;\n \n@@ -2333,7 +2334,7 @@ bool AcceptBlockHeader(CBlockHeader& block, CValidationState& state, CBlockIndex\n     if (pcheckpoint && block.hashPrevBlock != (chainActive.Tip() ? chainActive.Tip()->GetBlockHash() : uint256(0)))\n     {\n         // Extra checks to prevent \"fill up memory by spamming with bogus blocks\"\n-        int64_t deltaTime = block.GetBlockTime() - pcheckpoint->GetBlockTime();\n+        ::int64_t deltaTime = block.GetBlockTime() - pcheckpoint->GetBlockTime();\n         if (deltaTime < 0)\n         {\n             return state.DoS(100, error(\"CheckBlockHeader() : block with timestamp before last checkpoint\"),\n@@ -2778,9 +2779,9 @@ bool AbortNode(const std::string &strMessage) {\n     return false;\n }\n \n-bool CheckDiskSpace(uint64_t nAdditionalBytes)\n+bool CheckDiskSpace(::uint64_t nAdditionalBytes)\n {\n-    uint64_t nFreeBytesAvailable = filesystem::space(GetDataDir()).available;\n+    ::uint64_t nFreeBytesAvailable = filesystem::space(GetDataDir()).available;\n \n     // Check for nMinDiskSpace bytes (currently 50MB)\n     if (nFreeBytesAvailable < nMinDiskSpace + nAdditionalBytes)\n@@ -3132,12 +3133,12 @@ void PrintBlockTree()\n \n bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n {\n-    int64_t nStart = GetTimeMillis();\n+    ::int64_t nStart = GetTimeMillis();\n \n     int nLoaded = 0;\n     try {\n         CBufferedFile blkdat(fileIn, 2*MAX_BLOCK_SIZE, MAX_BLOCK_SIZE+8, SER_DISK, CLIENT_VERSION);\n-        uint64_t nStartByte = 0;\n+        ::uint64_t nStartByte = 0;\n         if (dbp) {\n             // (try to) skip already indexed part\n             CBlockFileInfo info;\n@@ -3146,7 +3147,7 @@ bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n                 blkdat.Seek(info.nSize);\n             }\n         }\n-        uint64_t nRewind = blkdat.GetPos();\n+        ::uint64_t nRewind = blkdat.GetPos();\n         while (!blkdat.eof()) {\n             boost::this_thread::interruption_point();\n \n@@ -3172,7 +3173,7 @@ bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n             }\n             try {\n                 // read block\n-                uint64_t nBlockPos = blkdat.GetPos();\n+                ::uint64_t nBlockPos = blkdat.GetPos();\n                 blkdat.SetLimit(nBlockPos + nSize);\n                 CBlock block;\n                 blkdat >> block;\n@@ -3422,7 +3423,7 @@ void static ProcessGetData(CNode* pfrom)\n     }\n }\n \n-bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv, int64_t nTimeReceived)\n+bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv, ::int64_t nTimeReceived)\n {\n     RandAddSeedPerfmon();\n     LogPrint(\"net\", \"received: %s (%u bytes) peer=%d\\n\", strCommand, vRecv.size(), pfrom->id);\n@@ -3449,10 +3450,10 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return false;\n         }\n \n-        int64_t nTime;\n+        ::int64_t nTime;\n         CAddress addrMe;\n         CAddress addrFrom;\n-        uint64_t nNonce = 1;\n+        ::uint64_t nNonce = 1;\n         vRecv >> pfrom->nVersion >> pfrom->nServices >> nTime >> addrMe;\n         if (pfrom->nVersion < MIN_PEER_PROTO_VERSION)\n         {\n@@ -3581,8 +3582,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n         // Store the new addresses\n         vector<CAddress> vAddrOk;\n-        int64_t nNow = GetAdjustedTime();\n-        int64_t nSince = nNow - 10 * 60;\n+        ::int64_t nNow = GetAdjustedTime();\n+        ::int64_t nSince = nNow - 10 * 60;\n         BOOST_FOREACH(CAddress& addr, vAddr)\n         {\n             boost::this_thread::interruption_point();\n@@ -3601,7 +3602,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                     static uint256 hashSalt;\n                     if (hashSalt == 0)\n                         hashSalt = GetRandHash();\n-                    uint64_t hashAddr = addr.GetHash();\n+                    ::uint64_t hashAddr = addr.GetHash();\n                     uint256 hashRand = hashSalt ^ (hashAddr<<32) ^ ((GetTime()+hashAddr)/(24*60*60));\n                     hashRand = Hash(BEGIN(hashRand), END(hashRand));\n                     multimap<uint256, CNode*> mapMix;\n@@ -3859,7 +3860,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             AddOrphanTx(tx, pfrom->GetId());\n \n             // DoS prevention: do not allow mapOrphanTransactions to grow unbounded\n-            unsigned int nMaxOrphanTx = (unsigned int)std::max((int64_t)0, GetArg(\"-maxorphantx\", DEFAULT_MAX_ORPHAN_TRANSACTIONS));\n+            unsigned int nMaxOrphanTx = (unsigned int)std::max((::int64_t)0, GetArg(\"-maxorphantx\", DEFAULT_MAX_ORPHAN_TRANSACTIONS));\n             unsigned int nEvicted = LimitOrphanTxSize(nMaxOrphanTx);\n             if (nEvicted > 0)\n                 LogPrint(\"mempool\", \"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n@@ -3953,7 +3954,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     {\n         if (pfrom->nVersion > BIP0031_VERSION)\n         {\n-            uint64_t nonce = 0;\n+            ::uint64_t nonce = 0;\n             vRecv >> nonce;\n             // Echo the message back with the nonce. This allows for two useful features:\n             //\n@@ -3973,8 +3974,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n     else if (strCommand == \"pong\")\n     {\n-        int64_t pingUsecEnd = nTimeReceived;\n-        uint64_t nonce = 0;\n+        ::int64_t pingUsecEnd = nTimeReceived;\n+        ::uint64_t nonce = 0;\n         size_t nAvail = vRecv.in_avail();\n         bool bPingFinished = false;\n         std::string sProblem;\n@@ -3987,7 +3988,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 if (nonce == pfrom->nPingNonceSent) {\n                     // Matching pong received, this ping is no longer outstanding\n                     bPingFinished = true;\n-                    int64_t pingUsecTime = pingUsecEnd - pfrom->nPingUsecStart;\n+                    ::int64_t pingUsecTime = pingUsecEnd - pfrom->nPingUsecStart;\n                     if (pingUsecTime > 0) {\n                         // Successful ping time measurement, replace previous\n                         pfrom->nPingUsecTime = pingUsecTime;\n@@ -4289,7 +4290,7 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n             pingSend = true;\n         }\n         if (pingSend) {\n-            uint64_t nonce = 0;\n+            ::uint64_t nonce = 0;\n             while (nonce == 0) {\n                 GetRandBytes((unsigned char*)&nonce, sizeof(nonce));\n             }\n@@ -4310,7 +4311,7 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n             return true;\n \n         // Address refresh broadcast\n-        static int64_t nLastRebroadcast;\n+        static ::int64_t nLastRebroadcast;\n         if (!IsInitialBlockDownload() && (GetTime() - nLastRebroadcast > 24 * 60 * 60))\n         {\n             {\n@@ -4446,7 +4447,7 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n         // received a (requested) block in one minute, and that all blocks are\n         // in flight for over two minutes, since we first had a chance to\n         // process an incoming block.\n-        int64_t nNow = GetTimeMicros();\n+        ::int64_t nNow = GetTimeMicros();\n         if (!pto->fDisconnect && state.nBlocksInFlight &&\n             state.nLastBlockReceive < state.nLastBlockProcess - BLOCK_DOWNLOAD_TIMEOUT*1000000 &&\n             state.vBlocksInFlight.front().nTime < state.nLastBlockProcess - 2*BLOCK_DOWNLOAD_TIMEOUT*1000000) {"
      },
      {
        "sha": "cbbff0ddd25b8c20eb4c448accb7fed9edc81060",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 28,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1e861060c07c22050ac8c5ef93a006935aa1c2a7/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1e861060c07c22050ac8c5ef93a006935aa1c2a7/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=1e861060c07c22050ac8c5ef93a006935aa1c2a7",
        "patch": "@@ -67,24 +67,24 @@ namespace {\n //\n bool fDiscover = true;\n bool fListen = true;\n-uint64_t nLocalServices = NODE_NETWORK;\n+::uint64_t nLocalServices = NODE_NETWORK;\n CCriticalSection cs_mapLocalHost;\n map<CNetAddr, LocalServiceInfo> mapLocalHost;\n static bool vfReachable[NET_MAX] = {};\n static bool vfLimited[NET_MAX] = {};\n static CNode* pnodeLocalHost = NULL;\n static CNode* pnodeSync = NULL;\n-uint64_t nLocalHostNonce = 0;\n+::uint64_t nLocalHostNonce = 0;\n static std::vector<ListenSocket> vhListenSocket;\n CAddrMan addrman;\n int nMaxConnections = 125;\n \n vector<CNode*> vNodes;\n CCriticalSection cs_vNodes;\n map<CInv, CDataStream> mapRelay;\n-deque<pair<int64_t, CInv> > vRelayExpiration;\n+deque<pair< ::int64_t, CInv> > vRelayExpiration;\n CCriticalSection cs_mapRelay;\n-limitedmap<CInv, int64_t> mapAlreadyAskedFor(MAX_INV_SZ);\n+limitedmap<CInv, ::int64_t> mapAlreadyAskedFor(MAX_INV_SZ);\n \n static deque<string> vOneShots;\n CCriticalSection cs_vOneShots;\n@@ -430,8 +430,8 @@ void AddressCurrentlyConnected(const CService& addr)\n \n \n \n-uint64_t CNode::nTotalBytesRecv = 0;\n-uint64_t CNode::nTotalBytesSent = 0;\n+::uint64_t CNode::nTotalBytesRecv = 0;\n+::uint64_t CNode::nTotalBytesSent = 0;\n CCriticalSection CNode::cs_totalBytesRecv;\n CCriticalSection CNode::cs_totalBytesSent;\n \n@@ -529,7 +529,7 @@ void CNode::PushVersion()\n     int nBestHeight = g_signals.GetHeight().get_value_or(0);\n \n     /// when NTP implemented, change to just nTime = GetAdjustedTime()\n-    int64_t nTime = (fInbound ? GetAdjustedTime() : GetTime());\n+    ::int64_t nTime = (fInbound ? GetAdjustedTime() : GetTime());\n     CAddress addrYou = (addr.IsRoutable() && !IsProxy(addr) ? addr : CAddress(CService(\"0.0.0.0\",0)));\n     CAddress addrMe = GetLocalAddress(&addr);\n     GetRandBytes((unsigned char*)&nLocalHostNonce, sizeof(nLocalHostNonce));\n@@ -545,7 +545,7 @@ void CNode::PushVersion()\n \n \n \n-std::map<CNetAddr, int64_t> CNode::setBanned;\n+std::map<CNetAddr, ::int64_t> CNode::setBanned;\n CCriticalSection CNode::cs_setBanned;\n \n void CNode::ClearBanned()\n@@ -558,10 +558,10 @@ bool CNode::IsBanned(CNetAddr ip)\n     bool fResult = false;\n     {\n         LOCK(cs_setBanned);\n-        std::map<CNetAddr, int64_t>::iterator i = setBanned.find(ip);\n+        std::map<CNetAddr, ::int64_t>::iterator i = setBanned.find(ip);\n         if (i != setBanned.end())\n         {\n-            int64_t t = (*i).second;\n+            ::int64_t t = (*i).second;\n             if (GetTime() < t)\n                 fResult = true;\n         }\n@@ -570,7 +570,7 @@ bool CNode::IsBanned(CNetAddr ip)\n }\n \n bool CNode::Ban(const CNetAddr &addr) {\n-    int64_t banTime = GetTime()+GetArg(\"-bantime\", 60*60*24);  // Default 24-hour ban\n+    ::int64_t banTime = GetTime()+GetArg(\"-bantime\", 60*60*24);  // Default 24-hour ban\n     {\n         LOCK(cs_setBanned);\n         if (setBanned[addr] < banTime)\n@@ -622,7 +622,7 @@ void CNode::copyStats(CNodeStats &stats)\n     // since pingtime does not update until the ping is complete, which might take a while.\n     // So, if a ping is taking an unusually long time in flight,\n     // the caller can immediately detect that this is happening.\n-    int64_t nPingUsecWait = 0;\n+    ::int64_t nPingUsecWait = 0;\n     if ((0 != nPingNonceSent) && (0 != nPingUsecStart)) {\n         nPingUsecWait = GetTimeMicros() - nPingUsecStart;\n     }\n@@ -1046,7 +1046,7 @@ void ThreadSocketHandler()\n             //\n             // Inactivity checking\n             //\n-            int64_t nTime = GetTime();\n+            ::int64_t nTime = GetTime();\n             if (nTime - pnode->nTimeConnected > 60)\n             {\n                 if (pnode->nLastRecv == 0 || pnode->nLastSend == 0)\n@@ -1257,7 +1257,7 @@ void ThreadDNSAddressSeed()\n \n void DumpAddresses()\n {\n-    int64_t nStart = GetTimeMillis();\n+    ::int64_t nStart = GetTimeMillis();\n \n     CAddrDB adb;\n     adb.Write(addrman);\n@@ -1289,7 +1289,7 @@ void ThreadOpenConnections()\n     // Connect to specific addresses\n     if (mapArgs.count(\"-connect\") && mapMultiArgs[\"-connect\"].size() > 0)\n     {\n-        for (int64_t nLoop = 0;; nLoop++)\n+        for (::int64_t nLoop = 0;; nLoop++)\n         {\n             ProcessOneShot();\n             BOOST_FOREACH(string strAddr, mapMultiArgs[\"-connect\"])\n@@ -1306,7 +1306,7 @@ void ThreadOpenConnections()\n     }\n \n     // Initiate network connections\n-    int64_t nStart = GetTime();\n+    ::int64_t nStart = GetTime();\n     while (true)\n     {\n         ProcessOneShot();\n@@ -1345,7 +1345,7 @@ void ThreadOpenConnections()\n             }\n         }\n \n-        int64_t nANow = GetAdjustedTime();\n+        ::int64_t nANow = GetAdjustedTime();\n \n         int nTries = 0;\n         while (true)\n@@ -1488,13 +1488,13 @@ bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOu\n \n // for now, use a very simple selection metric: the node from which we received\n // most recently\n-static int64_t NodeSyncScore(const CNode *pnode) {\n+static ::int64_t NodeSyncScore(const CNode *pnode) {\n     return pnode->nLastRecv;\n }\n \n void static StartSync(const vector<CNode*> &vNodes) {\n     CNode *pnodeNewSync = NULL;\n-    int64_t nBestScore = 0;\n+    ::int64_t nBestScore = 0;\n \n     int nBestHeight = g_signals.GetHeight().get_value_or(0);\n \n@@ -1506,7 +1506,7 @@ void static StartSync(const vector<CNode*> &vNodes) {\n             (pnode->nStartingHeight > (nBestHeight - 144)) &&\n             (pnode->nVersion < NOBLKS_VERSION_START || pnode->nVersion >= NOBLKS_VERSION_END)) {\n             // if ok, compare node's score with the best so far\n-            int64_t nScore = NodeSyncScore(pnode);\n+            ::int64_t nScore = NodeSyncScore(pnode);\n             if (pnodeNewSync == NULL || nScore > nBestScore) {\n                 pnodeNewSync = pnode;\n                 nBestScore = nScore;\n@@ -1872,25 +1872,25 @@ void RelayTransaction(const CTransaction& tx, const CDataStream& ss)\n     }\n }\n \n-void CNode::RecordBytesRecv(uint64_t bytes)\n+void CNode::RecordBytesRecv(::uint64_t bytes)\n {\n     LOCK(cs_totalBytesRecv);\n     nTotalBytesRecv += bytes;\n }\n \n-void CNode::RecordBytesSent(uint64_t bytes)\n+void CNode::RecordBytesSent(::uint64_t bytes)\n {\n     LOCK(cs_totalBytesSent);\n     nTotalBytesSent += bytes;\n }\n \n-uint64_t CNode::GetTotalBytesRecv()\n+::uint64_t CNode::GetTotalBytesRecv()\n {\n     LOCK(cs_totalBytesRecv);\n     return nTotalBytesRecv;\n }\n \n-uint64_t CNode::GetTotalBytesSent()\n+::uint64_t CNode::GetTotalBytesSent()\n {\n     LOCK(cs_totalBytesSent);\n     return nTotalBytesSent;\n@@ -2106,17 +2106,17 @@ void CNode::AskFor(const CInv& inv)\n         return;\n     // We're using mapAskFor as a priority queue,\n     // the key is the earliest time the request can be sent\n-    int64_t nRequestTime;\n-    limitedmap<CInv, int64_t>::const_iterator it = mapAlreadyAskedFor.find(inv);\n+    ::int64_t nRequestTime;\n+    limitedmap<CInv, ::int64_t>::const_iterator it = mapAlreadyAskedFor.find(inv);\n     if (it != mapAlreadyAskedFor.end())\n         nRequestTime = it->second;\n     else\n         nRequestTime = 0;\n     LogPrint(\"net\", \"askfor %s  %d (%s) peer=%d\\n\", inv.ToString(), nRequestTime, DateTimeStrFormat(\"%H:%M:%S\", nRequestTime/1000000), id);\n \n     // Make sure not to reuse time indexes to keep things in the same order\n-    int64_t nNow = GetTimeMicros() - 1000000;\n-    static int64_t nLastTime;\n+    ::int64_t nNow = GetTimeMicros() - 1000000;\n+    static ::int64_t nLastTime;\n     ++nLastTime;\n     nNow = std::max(nNow, nLastTime);\n     nLastTime = nNow;"
      },
      {
        "sha": "7df56fcd46b7f2f99c517f1a3b69e2d32a14ced1",
        "filename": "src/rpcrawtransaction.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1e861060c07c22050ac8c5ef93a006935aa1c2a7/src/rpcrawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1e861060c07c22050ac8c5ef93a006935aa1c2a7/src/rpcrawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcrawtransaction.cpp?ref=1e861060c07c22050ac8c5ef93a006935aa1c2a7",
        "patch": "@@ -58,21 +58,21 @@ void TxToJSON(const CTransaction& tx, const uint256 hashBlock, Object& entry)\n {\n     entry.push_back(Pair(\"txid\", tx.GetHash().GetHex()));\n     entry.push_back(Pair(\"version\", tx.nVersion));\n-    entry.push_back(Pair(\"locktime\", (int64_t)tx.nLockTime));\n+    entry.push_back(Pair(\"locktime\", (::int64_t)tx.nLockTime));\n     Array vin;\n     BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n         Object in;\n         if (tx.IsCoinBase())\n             in.push_back(Pair(\"coinbase\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n         else {\n             in.push_back(Pair(\"txid\", txin.prevout.hash.GetHex()));\n-            in.push_back(Pair(\"vout\", (int64_t)txin.prevout.n));\n+            in.push_back(Pair(\"vout\", (::int64_t)txin.prevout.n));\n             Object o;\n             o.push_back(Pair(\"asm\", txin.scriptSig.ToString()));\n             o.push_back(Pair(\"hex\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n             in.push_back(Pair(\"scriptSig\", o));\n         }\n-        in.push_back(Pair(\"sequence\", (int64_t)txin.nSequence));\n+        in.push_back(Pair(\"sequence\", (::int64_t)txin.nSequence));\n         vin.push_back(in);\n     }\n     entry.push_back(Pair(\"vin\", vin));\n@@ -81,7 +81,7 @@ void TxToJSON(const CTransaction& tx, const uint256 hashBlock, Object& entry)\n         const CTxOut& txout = tx.vout[i];\n         Object out;\n         out.push_back(Pair(\"value\", ValueFromAmount(txout.nValue)));\n-        out.push_back(Pair(\"n\", (int64_t)i));\n+        out.push_back(Pair(\"n\", (::int64_t)i));\n         Object o;\n         ScriptPubKeyToJSON(txout.scriptPubKey, o, true);\n         out.push_back(Pair(\"scriptPubKey\", o));\n@@ -269,7 +269,7 @@ Value listunspent(const Array& params, bool fHelp)\n                 continue;\n         }\n \n-        int64_t nValue = out.tx->vout[out.i].nValue;\n+        ::int64_t nValue = out.tx->vout[out.i].nValue;\n         const CScript& pk = out.tx->vout[out.i].scriptPubKey;\n         Object entry;\n         entry.push_back(Pair(\"txid\", out.tx->GetHash().GetHex()));\n@@ -367,7 +367,7 @@ Value createrawtransaction(const Array& params, bool fHelp)\n         setAddress.insert(address);\n \n         CScript scriptPubKey = GetScriptForDestination(address.Get());\n-        int64_t nAmount = AmountFromValue(s.value_);\n+        ::int64_t nAmount = AmountFromValue(s.value_);\n \n         CTxOut out(nAmount, scriptPubKey);\n         rawTx.vout.push_back(out);"
      },
      {
        "sha": "0794f82f7b14edb7c7314517d0cc9f8513fa73cc",
        "filename": "src/rpcserver.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1e861060c07c22050ac8c5ef93a006935aa1c2a7/src/rpcserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1e861060c07c22050ac8c5ef93a006935aa1c2a7/src/rpcserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcserver.cpp?ref=1e861060c07c22050ac8c5ef93a006935aa1c2a7",
        "patch": "@@ -83,23 +83,23 @@ void RPCTypeCheck(const Object& o,\n     }\n }\n \n-static inline int64_t roundint64(double d)\n+static inline ::int64_t roundint64(double d)\n {\n-    return (int64_t)(d > 0 ? d + 0.5 : d - 0.5);\n+    return (::int64_t)(d > 0 ? d + 0.5 : d - 0.5);\n }\n \n-int64_t AmountFromValue(const Value& value)\n+::int64_t AmountFromValue(const Value& value)\n {\n     double dAmount = value.get_real();\n     if (dAmount <= 0.0 || dAmount > 21000000.0)\n         throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid amount\");\n-    int64_t nAmount = roundint64(dAmount * COIN);\n+    ::int64_t nAmount = roundint64(dAmount * COIN);\n     if (!MoneyRange(nAmount))\n         throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid amount\");\n     return nAmount;\n }\n \n-Value ValueFromAmount(int64_t amount)\n+Value ValueFromAmount(::int64_t amount)\n {\n     return (double)amount / (double)COIN;\n }\n@@ -752,7 +752,7 @@ void RPCRunHandler(const boost::system::error_code& err, boost::function<void(vo\n         func();\n }\n \n-void RPCRunLater(const std::string& name, boost::function<void(void)> func, int64_t nSeconds)\n+void RPCRunLater(const std::string& name, boost::function<void(void)> func, ::int64_t nSeconds)\n {\n     assert(rpc_io_service != NULL);\n "
      },
      {
        "sha": "e6bb63864fd39952fc214a0cb5464c59d9f39590",
        "filename": "src/rpcwallet.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 35,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1e861060c07c22050ac8c5ef93a006935aa1c2a7/src/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1e861060c07c22050ac8c5ef93a006935aa1c2a7/src/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcwallet.cpp?ref=1e861060c07c22050ac8c5ef93a006935aa1c2a7",
        "patch": "@@ -25,7 +25,7 @@ using namespace boost;\n using namespace boost::assign;\n using namespace json_spirit;\n \n-int64_t nWalletUnlockTime;\n+::int64_t nWalletUnlockTime;\n static CCriticalSection cs_nWalletUnlockTime;\n \n std::string HelpRequiringPassphrase()\n@@ -52,6 +52,7 @@ void WalletTxToJSON(const CWalletTx& wtx, Object& entry)\n         entry.push_back(Pair(\"blockhash\", wtx.hashBlock.GetHex()));\n         entry.push_back(Pair(\"blockindex\", wtx.nIndex));\n         entry.push_back(Pair(\"blocktime\", mapBlockIndex[wtx.hashBlock]->GetBlockTime()));\n+        entry.push_back(Pair(\"blocktime\", (::int64_t)(mapBlockIndex[wtx.hashBlock]->nTime)));\n     }\n     uint256 hash = wtx.GetHash();\n     entry.push_back(Pair(\"txid\", hash.GetHex()));\n@@ -60,7 +61,7 @@ void WalletTxToJSON(const CWalletTx& wtx, Object& entry)\n         conflicts.push_back(conflict.GetHex());\n     entry.push_back(Pair(\"walletconflicts\", conflicts));\n     entry.push_back(Pair(\"time\", wtx.GetTxTime()));\n-    entry.push_back(Pair(\"timereceived\", (int64_t)wtx.nTimeReceived));\n+    entry.push_back(Pair(\"timereceived\", (::int64_t)wtx.nTimeReceived));\n     BOOST_FOREACH(const PAIRTYPE(string,string)& item, wtx.mapValue)\n         entry.push_back(Pair(item.first, item.second));\n }\n@@ -331,7 +332,7 @@ Value sendtoaddress(const Array& params, bool fHelp)\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n \n     // Amount\n-    int64_t nAmount = AmountFromValue(params[1]);\n+    ::int64_t nAmount = AmountFromValue(params[1]);\n \n     // Wallet comments\n     CWalletTx wtx;\n@@ -375,7 +376,7 @@ Value listaddressgroupings(const Array& params, bool fHelp)\n         );\n \n     Array jsonGroupings;\n-    map<CTxDestination, int64_t> balances = pwalletMain->GetAddressBalances();\n+    map<CTxDestination, ::int64_t> balances = pwalletMain->GetAddressBalances();\n     BOOST_FOREACH(set<CTxDestination> grouping, pwalletMain->GetAddressGroupings())\n     {\n         Array jsonGrouping;\n@@ -483,7 +484,7 @@ Value getreceivedbyaddress(const Array& params, bool fHelp)\n         nMinDepth = params[1].get_int();\n \n     // Tally\n-    int64_t nAmount = 0;\n+    ::int64_t nAmount = 0;\n     for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n     {\n         const CWalletTx& wtx = (*it).second;\n@@ -532,7 +533,7 @@ Value getreceivedbyaccount(const Array& params, bool fHelp)\n     set<CTxDestination> setAddress = pwalletMain->GetAccountAddresses(strAccount);\n \n     // Tally\n-    int64_t nAmount = 0;\n+    ::int64_t nAmount = 0;\n     for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n     {\n         const CWalletTx& wtx = (*it).second;\n@@ -552,9 +553,9 @@ Value getreceivedbyaccount(const Array& params, bool fHelp)\n }\n \n \n-int64_t GetAccountBalance(CWalletDB& walletdb, const string& strAccount, int nMinDepth, const isminefilter& filter)\n+::int64_t GetAccountBalance(CWalletDB& walletdb, const string& strAccount, int nMinDepth, const isminefilter& filter)\n {\n-    int64_t nBalance = 0;\n+    ::int64_t nBalance = 0;\n \n     // Tally wallet transactions\n     for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n@@ -563,7 +564,7 @@ int64_t GetAccountBalance(CWalletDB& walletdb, const string& strAccount, int nMi\n         if (!IsFinalTx(wtx) || wtx.GetBlocksToMaturity() > 0 || wtx.GetDepthInMainChain() < 0)\n             continue;\n \n-        int64_t nReceived, nSent, nFee;\n+        ::int64_t nReceived, nSent, nFee;\n         wtx.GetAccountAmounts(strAccount, nReceived, nSent, nFee, filter);\n \n         if (nReceived != 0 && wtx.GetDepthInMainChain() >= nMinDepth)\n@@ -577,7 +578,7 @@ int64_t GetAccountBalance(CWalletDB& walletdb, const string& strAccount, int nMi\n     return nBalance;\n }\n \n-int64_t GetAccountBalance(const string& strAccount, int nMinDepth, const isminefilter& filter)\n+::int64_t GetAccountBalance(const string& strAccount, int nMinDepth, const isminefilter& filter)\n {\n     CWalletDB walletdb(pwalletMain->strWalletFile);\n     return GetAccountBalance(walletdb, strAccount, nMinDepth, filter);\n@@ -627,14 +628,14 @@ Value getbalance(const Array& params, bool fHelp)\n         // Calculate total balance a different way from GetBalance()\n         // (GetBalance() sums up all unspent TxOuts)\n         // getbalance and getbalance '*' 0 should return the same number\n-        int64_t nBalance = 0;\n+        ::int64_t nBalance = 0;\n         for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n         {\n             const CWalletTx& wtx = (*it).second;\n             if (!wtx.IsTrusted() || wtx.GetBlocksToMaturity() > 0)\n                 continue;\n \n-            int64_t allFee;\n+            ::int64_t allFee;\n             string strSentAccount;\n             list<COutputEntry> listReceived;\n             list<COutputEntry> listSent;\n@@ -653,7 +654,7 @@ Value getbalance(const Array& params, bool fHelp)\n \n     string strAccount = AccountFromValue(params[0]);\n \n-    int64_t nBalance = GetAccountBalance(strAccount, nMinDepth, filter);\n+    ::int64_t nBalance = GetAccountBalance(strAccount, nMinDepth, filter);\n \n     return ValueFromAmount(nBalance);\n }\n@@ -692,7 +693,7 @@ Value movecmd(const Array& params, bool fHelp)\n \n     string strFrom = AccountFromValue(params[0]);\n     string strTo = AccountFromValue(params[1]);\n-    int64_t nAmount = AmountFromValue(params[2]);\n+    ::int64_t nAmount = AmountFromValue(params[2]);\n     if (params.size() > 3)\n         // unused parameter, used to be nMinDepth, keep type-checking it though\n         (void)params[3].get_int();\n@@ -704,7 +705,7 @@ Value movecmd(const Array& params, bool fHelp)\n     if (!walletdb.TxnBegin())\n         throw JSONRPCError(RPC_DATABASE_ERROR, \"database error\");\n \n-    int64_t nNow = GetAdjustedTime();\n+    ::int64_t nNow = GetAdjustedTime();\n \n     // Debit\n     CAccountingEntry debit;\n@@ -766,7 +767,7 @@ Value sendfrom(const Array& params, bool fHelp)\n     CBitcoinAddress address(params[1].get_str());\n     if (!address.IsValid())\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n-    int64_t nAmount = AmountFromValue(params[2]);\n+    ::int64_t nAmount = AmountFromValue(params[2]);\n     int nMinDepth = 1;\n     if (params.size() > 3)\n         nMinDepth = params[3].get_int();\n@@ -781,7 +782,7 @@ Value sendfrom(const Array& params, bool fHelp)\n     EnsureWalletIsUnlocked();\n \n     // Check funds\n-    int64_t nBalance = GetAccountBalance(strAccount, nMinDepth, ISMINE_SPENDABLE);\n+    ::int64_t nBalance = GetAccountBalance(strAccount, nMinDepth, ISMINE_SPENDABLE);\n     if (nAmount > nBalance)\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Account has insufficient funds\");\n \n@@ -834,9 +835,9 @@ Value sendmany(const Array& params, bool fHelp)\n         wtx.mapValue[\"comment\"] = params[3].get_str();\n \n     set<CBitcoinAddress> setAddress;\n-    vector<pair<CScript, int64_t> > vecSend;\n+    vector<pair<CScript, ::int64_t> > vecSend;\n \n-    int64_t totalAmount = 0;\n+    ::int64_t totalAmount = 0;\n     BOOST_FOREACH(const Pair& s, sendTo)\n     {\n         CBitcoinAddress address(s.name_);\n@@ -848,7 +849,7 @@ Value sendmany(const Array& params, bool fHelp)\n         setAddress.insert(address);\n \n         CScript scriptPubKey = GetScriptForDestination(address.Get());\n-        int64_t nAmount = AmountFromValue(s.value_);\n+        ::int64_t nAmount = AmountFromValue(s.value_);\n         totalAmount += nAmount;\n \n         vecSend.push_back(make_pair(scriptPubKey, nAmount));\n@@ -857,13 +858,13 @@ Value sendmany(const Array& params, bool fHelp)\n     EnsureWalletIsUnlocked();\n \n     // Check funds\n-    int64_t nBalance = GetAccountBalance(strAccount, nMinDepth, ISMINE_SPENDABLE);\n+    ::int64_t nBalance = GetAccountBalance(strAccount, nMinDepth, ISMINE_SPENDABLE);\n     if (totalAmount > nBalance)\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Account has insufficient funds\");\n \n     // Send\n     CReserveKey keyChange(pwalletMain);\n-    int64_t nFeeRequired = 0;\n+    ::int64_t nFeeRequired = 0;\n     string strFailReason;\n     bool fCreated = pwalletMain->CreateTransaction(vecSend, wtx, keyChange, nFeeRequired, strFailReason);\n     if (!fCreated)\n@@ -923,7 +924,7 @@ Value addmultisigaddress(const Array& params, bool fHelp)\n \n struct tallyitem\n {\n-    int64_t nAmount;\n+    ::int64_t nAmount;\n     int nConf;\n     vector<uint256> txids;\n     bool fIsWatchonly;\n@@ -995,7 +996,7 @@ Value ListReceived(const Array& params, bool fByAccounts)\n         if (it == mapTally.end() && !fIncludeEmpty)\n             continue;\n \n-        int64_t nAmount = 0;\n+        ::int64_t nAmount = 0;\n         int nConf = std::numeric_limits<int>::max();\n         bool fIsWatchonly = false;\n         if (it != mapTally.end())\n@@ -1038,7 +1039,7 @@ Value ListReceived(const Array& params, bool fByAccounts)\n     {\n         for (map<string, tallyitem>::iterator it = mapAccountTally.begin(); it != mapAccountTally.end(); ++it)\n         {\n-            int64_t nAmount = (*it).second.nAmount;\n+            ::int64_t nAmount = (*it).second.nAmount;\n             int nConf = (*it).second.nConf;\n             Object obj;\n             if((*it).second.fIsWatchonly)\n@@ -1125,7 +1126,7 @@ static void MaybePushAddress(Object & entry, const CTxDestination &dest)\n \n void ListTransactions(const CWalletTx& wtx, const string& strAccount, int nMinDepth, bool fLong, Array& ret, const isminefilter& filter)\n {\n-    int64_t nFee;\n+    ::int64_t nFee;\n     string strSentAccount;\n     list<COutputEntry> listReceived;\n     list<COutputEntry> listSent;\n@@ -1355,7 +1356,7 @@ Value listaccounts(const Array& params, bool fHelp)\n         if(params[1].get_bool())\n             includeWatchonly = includeWatchonly | ISMINE_WATCH_ONLY;\n \n-    map<string, int64_t> mapAccountBalances;\n+    map<string, ::int64_t> mapAccountBalances;\n     BOOST_FOREACH(const PAIRTYPE(CTxDestination, CAddressBookData)& entry, pwalletMain->mapAddressBook) {\n         if (IsMine(*pwalletMain, entry.first) & includeWatchonly) // This address belongs to me\n             mapAccountBalances[entry.second.name] = 0;\n@@ -1364,7 +1365,7 @@ Value listaccounts(const Array& params, bool fHelp)\n     for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n     {\n         const CWalletTx& wtx = (*it).second;\n-        int64_t nFee;\n+        ::int64_t nFee;\n         string strSentAccount;\n         list<COutputEntry> listReceived;\n         list<COutputEntry> listSent;\n@@ -1391,7 +1392,7 @@ Value listaccounts(const Array& params, bool fHelp)\n         mapAccountBalances[entry.strAccount] += entry.nCreditDebit;\n \n     Object ret;\n-    BOOST_FOREACH(const PAIRTYPE(string, int64_t)& accountBalance, mapAccountBalances) {\n+    BOOST_FOREACH(const PAIRTYPE(string, ::int64_t)& accountBalance, mapAccountBalances) {\n         ret.push_back(Pair(accountBalance.first, ValueFromAmount(accountBalance.second)));\n     }\n     return ret;\n@@ -1534,10 +1535,10 @@ Value gettransaction(const Array& params, bool fHelp)\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n     const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n \n-    int64_t nCredit = wtx.GetCredit(filter != 0);\n-    int64_t nDebit = wtx.GetDebit(filter);\n-    int64_t nNet = nCredit - nDebit;\n-    int64_t nFee = (wtx.IsFromMe(filter) ? wtx.GetValueOut() - nDebit : 0);\n+    ::int64_t nCredit = wtx.GetCredit(filter != 0);\n+    ::int64_t nDebit = wtx.GetDebit(filter);\n+    ::int64_t nNet = nCredit - nDebit;\n+    ::int64_t nFee = (wtx.IsFromMe(filter) ? wtx.GetValueOut() - nDebit : 0);\n \n     entry.push_back(Pair(\"amount\", ValueFromAmount(nNet - nFee)));\n     if (wtx.IsFromMe(filter))\n@@ -1662,7 +1663,7 @@ Value walletpassphrase(const Array& params, bool fHelp)\n \n     pwalletMain->TopUpKeyPool();\n \n-    int64_t nSleepTime = params[1].get_int64();\n+    ::int64_t nSleepTime = params[1].get_int64();\n     LOCK(cs_nWalletUnlockTime);\n     nWalletUnlockTime = GetTime() + nSleepTime;\n     RPCRunLater(\"lockwallet\", boost::bind(LockWallet, pwalletMain), nSleepTime);\n@@ -1937,7 +1938,7 @@ Value settxfee(const Array& params, bool fHelp)\n         );\n \n     // Amount\n-    int64_t nAmount = 0;\n+    ::int64_t nAmount = 0;\n     if (params[0].get_real() != 0.0)\n         nAmount = AmountFromValue(params[0]);        // rejects 0.0 amounts\n "
      },
      {
        "sha": "27c80b1c495705d6675ba07e4359196dfdc7c3f1",
        "filename": "src/walletdb.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 20,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1e861060c07c22050ac8c5ef93a006935aa1c2a7/src/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1e861060c07c22050ac8c5ef93a006935aa1c2a7/src/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/walletdb.cpp?ref=1e861060c07c22050ac8c5ef93a006935aa1c2a7",
        "patch": "@@ -21,7 +21,7 @@ using namespace std;\n using namespace boost;\n \n \n-static uint64_t nAccountingEntryNumber = 0;\n+static ::uint64_t nAccountingEntryNumber = 0;\n \n //\n // CWalletDB\n@@ -132,7 +132,7 @@ bool CWalletDB::ReadBestBlock(CBlockLocator& locator)\n     return Read(std::string(\"bestblock\"), locator);\n }\n \n-bool CWalletDB::WriteOrderPosNext(int64_t nOrderPosNext)\n+bool CWalletDB::WriteOrderPosNext(::int64_t nOrderPosNext)\n {\n     nWalletDBUpdated++;\n     return Write(std::string(\"orderposnext\"), nOrderPosNext);\n@@ -144,18 +144,18 @@ bool CWalletDB::WriteDefaultKey(const CPubKey& vchPubKey)\n     return Write(std::string(\"defaultkey\"), vchPubKey);\n }\n \n-bool CWalletDB::ReadPool(int64_t nPool, CKeyPool& keypool)\n+bool CWalletDB::ReadPool(::int64_t nPool, CKeyPool& keypool)\n {\n     return Read(std::make_pair(std::string(\"pool\"), nPool), keypool);\n }\n \n-bool CWalletDB::WritePool(int64_t nPool, const CKeyPool& keypool)\n+bool CWalletDB::WritePool(::int64_t nPool, const CKeyPool& keypool)\n {\n     nWalletDBUpdated++;\n     return Write(std::make_pair(std::string(\"pool\"), nPool), keypool);\n }\n \n-bool CWalletDB::ErasePool(int64_t nPool)\n+bool CWalletDB::ErasePool(::int64_t nPool)\n {\n     nWalletDBUpdated++;\n     return Erase(std::make_pair(std::string(\"pool\"), nPool));\n@@ -177,7 +177,7 @@ bool CWalletDB::WriteAccount(const string& strAccount, const CAccount& account)\n     return Write(make_pair(string(\"acc\"), strAccount), account);\n }\n \n-bool CWalletDB::WriteAccountingEntry(const uint64_t nAccEntryNum, const CAccountingEntry& acentry)\n+bool CWalletDB::WriteAccountingEntry(const ::uint64_t nAccEntryNum, const CAccountingEntry& acentry)\n {\n     return Write(boost::make_tuple(string(\"acentry\"), acentry.strAccount, nAccEntryNum), acentry);\n }\n@@ -187,12 +187,12 @@ bool CWalletDB::WriteAccountingEntry(const CAccountingEntry& acentry)\n     return WriteAccountingEntry(++nAccountingEntryNumber, acentry);\n }\n \n-int64_t CWalletDB::GetAccountCreditDebit(const string& strAccount)\n+::int64_t CWalletDB::GetAccountCreditDebit(const string& strAccount)\n {\n     list<CAccountingEntry> entries;\n     ListAccountCreditDebit(strAccount, entries);\n \n-    int64_t nCreditDebit = 0;\n+    ::int64_t nCreditDebit = 0;\n     BOOST_FOREACH (const CAccountingEntry& entry, entries)\n         nCreditDebit += entry.nCreditDebit;\n \n@@ -212,7 +212,7 @@ void CWalletDB::ListAccountCreditDebit(const string& strAccount, list<CAccountin\n         // Read next record\n         CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n         if (fFlags == DB_SET_RANGE)\n-            ssKey << boost::make_tuple(string(\"acentry\"), (fAllAccounts? string(\"\") : strAccount), uint64_t(0));\n+            ssKey << boost::make_tuple(string(\"acentry\"), (fAllAccounts? string(\"\") : strAccount), ::uint64_t(0));\n         CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n         int ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n         fFlags = DB_NEXT;\n@@ -250,7 +250,7 @@ DBErrors CWalletDB::ReorderTransactions(CWallet* pwallet)\n \n     // First: get all CWalletTx and CAccountingEntry into a sorted-by-time multimap.\n     typedef pair<CWalletTx*, CAccountingEntry*> TxPair;\n-    typedef multimap<int64_t, TxPair > TxItems;\n+    typedef multimap< ::int64_t, TxPair > TxItems;\n     TxItems txByTime;\n \n     for (map<uint256, CWalletTx>::iterator it = pwallet->mapWallet.begin(); it != pwallet->mapWallet.end(); ++it)\n@@ -265,14 +265,14 @@ DBErrors CWalletDB::ReorderTransactions(CWallet* pwallet)\n         txByTime.insert(make_pair(entry.nTime, TxPair((CWalletTx*)0, &entry)));\n     }\n \n-    int64_t& nOrderPosNext = pwallet->nOrderPosNext;\n+    ::int64_t& nOrderPosNext = pwallet->nOrderPosNext;\n     nOrderPosNext = 0;\n-    std::vector<int64_t> nOrderPosOffsets;\n+    std::vector< ::int64_t> nOrderPosOffsets;\n     for (TxItems::iterator it = txByTime.begin(); it != txByTime.end(); ++it)\n     {\n         CWalletTx *const pwtx = (*it).second.first;\n         CAccountingEntry *const pacentry = (*it).second.second;\n-        int64_t& nOrderPos = (pwtx != 0) ? pwtx->nOrderPos : pacentry->nOrderPos;\n+        ::int64_t& nOrderPos = (pwtx != 0) ? pwtx->nOrderPos : pacentry->nOrderPos;\n \n         if (nOrderPos == -1)\n         {\n@@ -290,8 +290,8 @@ DBErrors CWalletDB::ReorderTransactions(CWallet* pwallet)\n         }\n         else\n         {\n-            int64_t nOrderPosOff = 0;\n-            BOOST_FOREACH(const int64_t& nOffsetStart, nOrderPosOffsets)\n+            ::int64_t nOrderPosOff = 0;\n+            BOOST_FOREACH(const ::int64_t& nOffsetStart, nOrderPosOffsets)\n             {\n                 if (nOrderPos >= nOffsetStart)\n                     ++nOrderPosOff;\n@@ -403,7 +403,7 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n         {\n             string strAccount;\n             ssKey >> strAccount;\n-            uint64_t nNumber;\n+            ::uint64_t nNumber;\n             ssKey >> nNumber;\n             if (nNumber > nAccountingEntryNumber)\n                 nAccountingEntryNumber = nNumber;\n@@ -544,7 +544,7 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n         }\n         else if (strType == \"pool\")\n         {\n-            int64_t nIndex;\n+            ::int64_t nIndex;\n             ssKey >> nIndex;\n             CKeyPool keypool;\n             ssValue >> keypool;\n@@ -803,7 +803,7 @@ void ThreadFlushWalletDB(const string& strFile)\n \n     unsigned int nLastSeen = nWalletDBUpdated;\n     unsigned int nLastFlushed = nWalletDBUpdated;\n-    int64_t nLastWalletUpdate = GetTime();\n+    ::int64_t nLastWalletUpdate = GetTime();\n     while (true)\n     {\n         MilliSleep(500);\n@@ -836,7 +836,7 @@ void ThreadFlushWalletDB(const string& strFile)\n                     {\n                         LogPrint(\"db\", \"Flushing wallet.dat\\n\");\n                         nLastFlushed = nWalletDBUpdated;\n-                        int64_t nStart = GetTimeMillis();\n+                        ::int64_t nStart = GetTimeMillis();\n \n                         // Flush wallet.dat so it's self contained\n                         bitdb.CloseDb(strFile);\n@@ -903,7 +903,7 @@ bool CWalletDB::Recover(CDBEnv& dbenv, std::string filename, bool fOnlyKeys)\n     // Rewrite salvaged data to wallet.dat\n     // Set -rescan so any missing transactions will be\n     // found.\n-    int64_t now = GetTime();\n+    ::int64_t now = GetTime();\n     std::string newFilename = strprintf(\"wallet.%d.bak\", now);\n \n     int result = dbenv.dbenv.dbrename(NULL, filename.c_str(), NULL,"
      }
    ]
  },
  {
    "sha": "211d358c57789d416ed30d3b42384b06a8a96cf3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMTFkMzU4YzU3Nzg5ZDQxNmVkMzBkM2I0MjM4NGIwNmE4YTk2Y2Yz",
    "commit": {
      "author": {
        "name": "Timo Witte",
        "email": "timo.witte@gmail.com",
        "date": "2014-09-22T19:43:16Z"
      },
      "committer": {
        "name": "Timo Witte",
        "email": "timo.witte@gmail.com",
        "date": "2014-09-22T19:43:16Z"
      },
      "message": "Merge https://github.com/Spacefish/bitcoin",
      "tree": {
        "sha": "f77df3489f269b4ec13b8bb9198713e91c28a09c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f77df3489f269b4ec13b8bb9198713e91c28a09c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/211d358c57789d416ed30d3b42384b06a8a96cf3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/211d358c57789d416ed30d3b42384b06a8a96cf3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/211d358c57789d416ed30d3b42384b06a8a96cf3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/211d358c57789d416ed30d3b42384b06a8a96cf3/comments",
    "author": {
      "login": "Spacefish",
      "id": 375633,
      "node_id": "MDQ6VXNlcjM3NTYzMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/375633?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Spacefish",
      "html_url": "https://github.com/Spacefish",
      "followers_url": "https://api.github.com/users/Spacefish/followers",
      "following_url": "https://api.github.com/users/Spacefish/following{/other_user}",
      "gists_url": "https://api.github.com/users/Spacefish/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Spacefish/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Spacefish/subscriptions",
      "organizations_url": "https://api.github.com/users/Spacefish/orgs",
      "repos_url": "https://api.github.com/users/Spacefish/repos",
      "events_url": "https://api.github.com/users/Spacefish/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Spacefish/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "Spacefish",
      "id": 375633,
      "node_id": "MDQ6VXNlcjM3NTYzMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/375633?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Spacefish",
      "html_url": "https://github.com/Spacefish",
      "followers_url": "https://api.github.com/users/Spacefish/followers",
      "following_url": "https://api.github.com/users/Spacefish/following{/other_user}",
      "gists_url": "https://api.github.com/users/Spacefish/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Spacefish/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Spacefish/subscriptions",
      "organizations_url": "https://api.github.com/users/Spacefish/orgs",
      "repos_url": "https://api.github.com/users/Spacefish/repos",
      "events_url": "https://api.github.com/users/Spacefish/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Spacefish/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1e861060c07c22050ac8c5ef93a006935aa1c2a7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1e861060c07c22050ac8c5ef93a006935aa1c2a7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1e861060c07c22050ac8c5ef93a006935aa1c2a7"
      },
      {
        "sha": "cb9871194a7fffe8bc0a53ea820b1a395e79e283",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cb9871194a7fffe8bc0a53ea820b1a395e79e283",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cb9871194a7fffe8bc0a53ea820b1a395e79e283"
      }
    ],
    "stats": {
      "total": 70,
      "additions": 34,
      "deletions": 36
    },
    "files": [
      {
        "sha": "ddfc09607e16c2646398a183c653384138d2f414",
        "filename": "autogen.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/211d358c57789d416ed30d3b42384b06a8a96cf3/autogen.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/211d358c57789d416ed30d3b42384b06a8a96cf3/autogen.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/autogen.sh?ref=211d358c57789d416ed30d3b42384b06a8a96cf3",
        "patch": "@@ -5,4 +5,4 @@ cd \"$srcdir\"\n if [ -z ${LIBTOOLIZE} ] && GLIBTOOLIZE=\"`which glibtoolize 2>/dev/null`\"; then\n   export LIBTOOLIZE=\"${GLIBTOOLIZE}\"\n fi\n-autoreconf --install --force\n+autoreconf --install --force --warnings=all"
      },
      {
        "sha": "f3b14461eb9e8e248235e9592ede0db9bb039313",
        "filename": "build-aux/m4/bitcoin_find_bdb48.m4",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/211d358c57789d416ed30d3b42384b06a8a96cf3/build-aux/m4/bitcoin_find_bdb48.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/211d358c57789d416ed30d3b42384b06a8a96cf3/build-aux/m4/bitcoin_find_bdb48.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/bitcoin_find_bdb48.m4?ref=211d358c57789d416ed30d3b42384b06a8a96cf3",
        "patch": "@@ -12,29 +12,29 @@ AC_DEFUN([BITCOIN_FIND_BDB48],[\n   done\n   for searchpath in $bdbdirlist ''; do\n     test -n \"${searchpath}\" && searchpath=\"${searchpath}/\"\n-    AC_TRY_COMPILE([\n+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n       #include <${searchpath}db_cxx.h>\n-    ],[\n+    ]],[[\n       #if !((DB_VERSION_MAJOR == 4 && DB_VERSION_MINOR >= 8) || DB_VERSION_MAJOR > 4)\n         #error \"failed to find bdb 4.8+\"\n       #endif\n-    ],[\n+    ]])],[\n       if test \"x$bdbpath\" = \"xX\"; then\n         bdbpath=\"${searchpath}\"\n       fi\n     ],[\n       continue\n     ])\n-    AC_TRY_COMPILE([\n+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n       #include <${searchpath}db_cxx.h>\n-    ],[\n+    ]],[[\n       #if !(DB_VERSION_MAJOR == 4 && DB_VERSION_MINOR == 8)\n         #error \"failed to find bdb 4.8\"\n       #endif\n-    ],[\n+    ]])],[\n       bdb48path=\"${searchpath}\"\n       break\n-    ])\n+    ],[])\n   done\n   if test \"x$bdbpath\" = \"xX\"; then\n     AC_MSG_RESULT([no])"
      },
      {
        "sha": "edfde4cd79781fa822c94cff68844acdaaf9f967",
        "filename": "build-aux/m4/bitcoin_qt.m4",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/211d358c57789d416ed30d3b42384b06a8a96cf3/build-aux/m4/bitcoin_qt.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/211d358c57789d416ed30d3b42384b06a8a96cf3/build-aux/m4/bitcoin_qt.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/bitcoin_qt.m4?ref=211d358c57789d416ed30d3b42384b06a8a96cf3",
        "patch": "@@ -217,17 +217,17 @@ dnl Requires: INCLUDES must be populated as necessary.\n dnl Output: bitcoin_cv_qt5=yes|no\n AC_DEFUN([_BITCOIN_QT_CHECK_QT5],[\n   AC_CACHE_CHECK(for Qt 5, bitcoin_cv_qt5,[\n-  AC_TRY_COMPILE(\n-    [#include <QtCore>],\n-    [\n+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n+    [[#include <QtCore>]],\n+    [[\n       #if QT_VERSION < 0x050000\n       choke me\n       #else\n       return 0;\n       #endif\n-    ],\n-    bitcoin_cv_qt5=yes,\n-    bitcoin_cv_qt5=no)\n+    ]])],\n+    [bitcoin_cv_qt5=yes],\n+    [bitcoin_cv_qt5=no])\n ])])\n \n dnl Internal. Check if the linked version of Qt was built as static libs.\n@@ -237,15 +237,15 @@ dnl Output: bitcoin_cv_static_qt=yes|no\n dnl Output: Defines QT_STATICPLUGIN if plugins are static.\n AC_DEFUN([_BITCOIN_QT_IS_STATIC],[\n   AC_CACHE_CHECK(for static Qt, bitcoin_cv_static_qt,[\n-  AC_TRY_COMPILE(\n-    [#include <QtCore>],\n-    [\n+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n+    [[#include <QtCore>]],\n+    [[\n       #if defined(QT_STATIC)\n       return 0;\n       #else\n       choke me\n       #endif\n-    ],\n+    ]])],\n     [bitcoin_cv_static_qt=yes],\n     [bitcoin_cv_static_qt=no])\n   ])\n@@ -263,13 +263,13 @@ AC_DEFUN([_BITCOIN_QT_CHECK_STATIC_PLUGINS],[\n   AC_MSG_CHECKING(for static Qt plugins: $2)\n   CHECK_STATIC_PLUGINS_TEMP_LIBS=\"$LIBS\"\n   LIBS=\"$2 $QT_LIBS $LIBS\"\n-  AC_TRY_LINK([\n+  AC_LINK_IFELSE([AC_LANG_PROGRAM([[\n     #define QT_STATICPLUGIN\n     #include <QtPlugin>\n-    $1],\n-    [return 0;],\n+    $1]],\n+    [[return 0;]])],\n     [AC_MSG_RESULT(yes); QT_LIBS=\"$2 $QT_LIBS\"],\n-    [AC_MSG_RESULT(no)]; BITCOIN_QT_FAIL(Could not resolve: $2))\n+    [AC_MSG_RESULT(no); BITCOIN_QT_FAIL(Could not resolve: $2)])\n   LIBS=\"$CHECK_STATIC_PLUGINS_TEMP_LIBS\"\n ])\n "
      },
      {
        "sha": "0f9e78b74fbe38d01a2e3773e74477c1adc6cb22",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 12,
        "deletions": 14,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/211d358c57789d416ed30d3b42384b06a8a96cf3/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/211d358c57789d416ed30d3b42384b06a8a96cf3/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=211d358c57789d416ed30d3b42384b06a8a96cf3",
        "patch": "@@ -7,6 +7,8 @@ define(_CLIENT_VERSION_BUILD, 0)\n define(_CLIENT_VERSION_IS_RELEASE, false)\n define(_COPYRIGHT_YEAR, 2014)\n AC_INIT([Bitcoin Core],[_CLIENT_VERSION_MAJOR._CLIENT_VERSION_MINOR._CLIENT_VERSION_REVISION],[info@bitcoin.org],[bitcoin])\n+AC_CONFIG_SRCDIR([src/main.cpp])\n+AC_CONFIG_HEADERS([src/config/bitcoin-config.h])\n AC_CONFIG_AUX_DIR([build-aux])\n AC_CONFIG_MACRO_DIR([build-aux/m4])\n LT_INIT([disable-shared])\n@@ -140,10 +142,6 @@ AC_ARG_ENABLE([glibc-back-compat],\n \n AC_ARG_WITH([protoc-bindir],[AS_HELP_STRING([--with-protoc-bindir=BIN_DIR],[specify protoc bin path])], [protoc_bin_path=$withval], [])\n \n-\n-AC_CONFIG_SRCDIR([src])\n-AC_CONFIG_HEADERS([src/config/bitcoin-config.h])\n-\n # Enable debug \n AC_ARG_ENABLE([debug],\n     [AS_HELP_STRING([--enable-debug],\n@@ -337,12 +335,12 @@ if test x$use_glibc_compat != xno; then\n   #__fdelt_chk's params and return type have changed from long unsigned int to long int.\n   # See which one is present here.\n   AC_MSG_CHECKING(__fdelt_chk type)\n-  AC_TRY_COMPILE([#ifdef _FORTIFY_SOURCE\n+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#ifdef _FORTIFY_SOURCE\n                     #undef _FORTIFY_SOURCE\n                   #endif\n                   #define _FORTIFY_SOURCE 2\n                   #include <sys/select.h>\n-     extern \"C\" long unsigned int __fdelt_warn(long unsigned int);],[],\n+     extern \"C\" long unsigned int __fdelt_warn(long unsigned int);]],[[]])],\n     [ fdelt_type=\"long unsigned int\"],\n     [ fdelt_type=\"long int\"])\n   AC_MSG_RESULT($fdelt_type)\n@@ -394,8 +392,8 @@ AC_CHECK_DECLS([le32toh, le64toh, htole32, htole64, be32toh, be64toh, htobe32, h\n \n dnl Check for MSG_NOSIGNAL\n AC_MSG_CHECKING(for MSG_NOSIGNAL)\n-AC_TRY_COMPILE([#include <sys/socket.h>],\n- [ int f = MSG_NOSIGNAL; ],\n+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/socket.h>]],\n+ [[ int f = MSG_NOSIGNAL; ]])],\n  [ AC_MSG_RESULT(yes); AC_DEFINE(HAVE_MSG_NOSIGNAL, 1,[Define this symbol if you have MSG_NOSIGNAL]) ],\n  [ AC_MSG_RESULT(no)]\n )\n@@ -537,16 +535,16 @@ TEMP_LIBS=\"$LIBS\"\n LIBS=\"$BOOST_LIBS $BOOST_CHRONO_LIB $LIBS\"\n TEMP_CPPFLAGS=\"$CPPFLAGS\"\n CPPFLAGS=\"$CPPFLAGS $BOOST_CPPFLAGS\"\n-AC_TRY_LINK([\n+AC_LINK_IFELSE([AC_LANG_PROGRAM([[\n   #include <boost/thread/thread.hpp>\n   #include <boost/version.hpp>\n-  ],[\n+  ]],[[\n   #if BOOST_VERSION >= 105000 && (!defined(BOOST_HAS_NANOSLEEP) || BOOST_VERSION >= 105200)\n       boost::this_thread::sleep_for(boost::chrono::milliseconds(0));\n   #else\n    choke me\n   #endif\n-  ],\n+  ]])],\n   [boost_sleep=yes; BOOST_LIBS=\"$BOOST_LIBS $BOOST_CHRONO_LIB\";\n      AC_DEFINE(HAVE_WORKING_BOOST_SLEEP_FOR, 1, [Define this symbol if boost sleep_for works])],\n   [boost_sleep=no])\n@@ -559,17 +557,17 @@ TEMP_LIBS=\"$LIBS\"\n LIBS=\"$BOOST_LIBS $LIBS\"\n TEMP_CPPFLAGS=\"$CPPFLAGS\"\n CPPFLAGS=\"$CPPFLAGS $BOOST_CPPFLAGS\"\n-AC_TRY_LINK([\n+AC_LINK_IFELSE([AC_LANG_PROGRAM([[\n   #include <boost/version.hpp>\n   #include <boost/thread.hpp>\n   #include <boost/date_time/posix_time/posix_time_types.hpp>\n-  ],[\n+  ]],[[\n   #if BOOST_VERSION <= 105600\n       boost::this_thread::sleep(boost::posix_time::milliseconds(0));\n   #else\n    choke me\n   #endif\n-  ],\n+  ]])],\n   [boost_sleep=yes; AC_DEFINE(HAVE_WORKING_BOOST_SLEEP, 1, [Define this symbol if boost sleep works])],\n   [boost_sleep=no])\n LIBS=\"$TEMP_LIBS\""
      }
    ]
  },
  {
    "sha": "0bc69687b2a71dfdecd6bc7fa6abc72567d23d38",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowYmM2OTY4N2IyYTcxZGZkZWNkNmJjN2ZhNmFiYzcyNTY3ZDIzZDM4",
    "commit": {
      "author": {
        "name": "Timo Witte",
        "email": "timo.witte@gmail.com",
        "date": "2014-09-22T19:48:18Z"
      },
      "committer": {
        "name": "Timo Witte",
        "email": "timo.witte@gmail.com",
        "date": "2014-09-22T19:48:18Z"
      },
      "message": "corrected a merge error",
      "tree": {
        "sha": "e0f03187ab28daddd609ca90d4d19bf7b51b9c9f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e0f03187ab28daddd609ca90d4d19bf7b51b9c9f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0bc69687b2a71dfdecd6bc7fa6abc72567d23d38",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0bc69687b2a71dfdecd6bc7fa6abc72567d23d38",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0bc69687b2a71dfdecd6bc7fa6abc72567d23d38",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0bc69687b2a71dfdecd6bc7fa6abc72567d23d38/comments",
    "author": {
      "login": "Spacefish",
      "id": 375633,
      "node_id": "MDQ6VXNlcjM3NTYzMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/375633?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Spacefish",
      "html_url": "https://github.com/Spacefish",
      "followers_url": "https://api.github.com/users/Spacefish/followers",
      "following_url": "https://api.github.com/users/Spacefish/following{/other_user}",
      "gists_url": "https://api.github.com/users/Spacefish/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Spacefish/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Spacefish/subscriptions",
      "organizations_url": "https://api.github.com/users/Spacefish/orgs",
      "repos_url": "https://api.github.com/users/Spacefish/repos",
      "events_url": "https://api.github.com/users/Spacefish/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Spacefish/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "Spacefish",
      "id": 375633,
      "node_id": "MDQ6VXNlcjM3NTYzMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/375633?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Spacefish",
      "html_url": "https://github.com/Spacefish",
      "followers_url": "https://api.github.com/users/Spacefish/followers",
      "following_url": "https://api.github.com/users/Spacefish/following{/other_user}",
      "gists_url": "https://api.github.com/users/Spacefish/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Spacefish/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Spacefish/subscriptions",
      "organizations_url": "https://api.github.com/users/Spacefish/orgs",
      "repos_url": "https://api.github.com/users/Spacefish/repos",
      "events_url": "https://api.github.com/users/Spacefish/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Spacefish/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "211d358c57789d416ed30d3b42384b06a8a96cf3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/211d358c57789d416ed30d3b42384b06a8a96cf3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/211d358c57789d416ed30d3b42384b06a8a96cf3"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 0,
      "deletions": 1
    },
    "files": [
      {
        "sha": "145e4476d429eca2488238645b111c9a28b20e32",
        "filename": "src/rpcwallet.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0bc69687b2a71dfdecd6bc7fa6abc72567d23d38/src/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0bc69687b2a71dfdecd6bc7fa6abc72567d23d38/src/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcwallet.cpp?ref=0bc69687b2a71dfdecd6bc7fa6abc72567d23d38",
        "patch": "@@ -52,7 +52,6 @@ void WalletTxToJSON(const CWalletTx& wtx, Object& entry)\n         entry.push_back(Pair(\"blockhash\", wtx.hashBlock.GetHex()));\n         entry.push_back(Pair(\"blockindex\", wtx.nIndex));\n         entry.push_back(Pair(\"blocktime\", mapBlockIndex[wtx.hashBlock]->GetBlockTime()));\n-        entry.push_back(Pair(\"blocktime\", (::int64_t)(mapBlockIndex[wtx.hashBlock]->nTime)));\n     }\n     uint256 hash = wtx.GetHash();\n     entry.push_back(Pair(\"txid\", hash.GetHex()));"
      }
    ]
  }
]