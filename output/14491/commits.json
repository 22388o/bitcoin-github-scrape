[
  {
    "sha": "a1b25e12a5f57048a4639964d57c0b46eb84cd4e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphMWIyNWUxMmE1ZjU3MDQ4YTQ2Mzk5NjRkNTdjMGI0NmViODRjZDRl",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-01-11T21:32:44Z"
      },
      "committer": {
        "name": "MeshCollider",
        "email": "dobsonsa68@gmail.com",
        "date": "2019-02-05T06:41:24Z"
      },
      "message": "[wallet] Refactor ProcessImport()\n\nThis commit is move-only and doesn't make any functional changes. It\nsimply moves code around within ProcessImport() in preparation for\nrefactors in the next commits.",
      "tree": {
        "sha": "ffc1eee76b5b170835431fcbba924c0fadd461c6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ffc1eee76b5b170835431fcbba924c0fadd461c6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a1b25e12a5f57048a4639964d57c0b46eb84cd4e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a1b25e12a5f57048a4639964d57c0b46eb84cd4e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a1b25e12a5f57048a4639964d57c0b46eb84cd4e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a1b25e12a5f57048a4639964d57c0b46eb84cd4e/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e50853501b79378597edbcd6dd217819c057de4b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e50853501b79378597edbcd6dd217819c057de4b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e50853501b79378597edbcd6dd217819c057de4b"
      }
    ],
    "stats": {
      "total": 50,
      "additions": 31,
      "deletions": 19
    },
    "files": [
      {
        "sha": "7bd3502276a758514f9be67469e1aae9d5c88475",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 19,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a1b25e12a5f57048a4639964d57c0b46eb84cd4e/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a1b25e12a5f57048a4639964d57c0b46eb84cd4e/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=a1b25e12a5f57048a4639964d57c0b46eb84cd4e",
        "patch": "@@ -970,6 +970,19 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n     UniValue result(UniValue::VOBJ);\n \n     try {\n+        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n+        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+        ImportData import_data;\n+        std::map<CKeyID, CPubKey> pubkey_map;\n+        std::map<CKeyID, CKey> privkey_map;\n+        std::set<CScript> script_pub_keys;\n+        bool have_solving_data;\n+\n         // First ensure scriptPubKey has either a script or JSON with \"address\" string\n         const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n         bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n@@ -983,9 +996,7 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n         const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n         const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n         const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n         const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n \n         // If private keys are disabled, abort if private keys are being imported\n         if (pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) && !keys.isNull()) {\n@@ -1011,9 +1022,9 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n             }\n         }\n+        script_pub_keys.emplace(script);\n \n         // Parse all arguments\n-        ImportData import_data;\n         if (strRedeemScript.size()) {\n             if (!IsHex(strRedeemScript)) {\n                 throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n@@ -1028,7 +1039,6 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             auto parsed_witnessscript = ParseHex(witness_script_hex);\n             import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n         }\n-        std::map<CKeyID, CPubKey> pubkey_map;\n         for (size_t i = 0; i < pubKeys.size(); ++i) {\n             const auto& str = pubKeys[i].get_str();\n             if (!IsHex(str)) {\n@@ -1041,7 +1051,6 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             }\n             pubkey_map.emplace(pubkey.GetID(), pubkey);\n         }\n-        std::map<CKeyID, CKey> privkey_map;\n         for (size_t i = 0; i < keys.size(); ++i) {\n             const auto& str = keys[i].get_str();\n             CKey key = DecodeSecret(str);\n@@ -1056,13 +1065,9 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             privkey_map.emplace(id, key);\n         }\n \n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n \n         // Verify and process input data\n-        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n+        have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n         if (have_solving_data) {\n             // Match up data in import_data with the scriptPubKey in script.\n             auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n@@ -1115,8 +1120,10 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n         }\n \n         // Check whether we have any work to do\n-        if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        for (const CScript& script : script_pub_keys) {\n+            if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n         }\n \n         // All good, time to import\n@@ -1146,14 +1153,19 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n         }\n-        if (!have_solving_data || !::IsMine(*pwallet, script)) { // Always call AddWatchOnly for non-solvable watch-only, so that watch timestamp gets updated\n-            if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+        for (const CScript& script : script_pub_keys) {\n+            if (!have_solving_data || !::IsMine(*pwallet, script)) { // Always call AddWatchOnly for non-solvable watch-only, so that watch timestamp gets updated\n+                if (!pwallet->AddWatchOnly(script, timestamp)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                }\n+            }\n+            CTxDestination dest;\n+            ExtractDestination(script, dest);\n+            if (!internal) {\n+                assert(IsValidDestination(dest));\n+                pwallet->SetAddressBook(dest, label, \"receive\");\n             }\n-        }\n-        if (!internal) {\n-            assert(IsValidDestination(dest));\n-            pwallet->SetAddressBook(dest, label, \"receive\");\n         }\n \n         result.pushKV(\"success\", UniValue(true));"
      }
    ]
  },
  {
    "sha": "4cac0ddd258bc82258ccc99568d02d3b2415339d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0Y2FjMGRkZDI1OGJjODIyNThjY2M5OTU2OGQwMmQzYjI0MTUzMzlk",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-01-11T21:42:43Z"
      },
      "committer": {
        "name": "MeshCollider",
        "email": "dobsonsa68@gmail.com",
        "date": "2019-02-05T06:41:24Z"
      },
      "message": "[wallet] Add ProcessImportLegacy()\n\nThis commit adds a ProcessImportLegacy() function which\ncurrently does nothing. It also unindents a block of\ncode for a future move-only change.\n\nReviewer hint: review with -w to ignore whitespace changes.",
      "tree": {
        "sha": "10d3dd9c352d74a81e0a9138399f4de99e667ec8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/10d3dd9c352d74a81e0a9138399f4de99e667ec8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4cac0ddd258bc82258ccc99568d02d3b2415339d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4cac0ddd258bc82258ccc99568d02d3b2415339d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4cac0ddd258bc82258ccc99568d02d3b2415339d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4cac0ddd258bc82258ccc99568d02d3b2415339d/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a1b25e12a5f57048a4639964d57c0b46eb84cd4e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a1b25e12a5f57048a4639964d57c0b46eb84cd4e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a1b25e12a5f57048a4639964d57c0b46eb84cd4e"
      }
    ],
    "stats": {
      "total": 240,
      "additions": 124,
      "deletions": 116
    },
    "files": [
      {
        "sha": "58dad78502e4eddc1a8edd000c9b5186fcb046af",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 124,
        "deletions": 116,
        "changes": 240,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4cac0ddd258bc82258ccc99568d02d3b2415339d/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4cac0ddd258bc82258ccc99568d02d3b2415339d/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=4cac0ddd258bc82258ccc99568d02d3b2415339d",
        "patch": "@@ -964,6 +964,12 @@ static std::string RecurseImportData(const CScript& script, ImportData& import_d\n     }\n }\n \n+static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n+{\n+    UniValue warnings(UniValue::VARR);\n+    return warnings;\n+}\n+\n static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n     UniValue warnings(UniValue::VARR);\n@@ -983,141 +989,143 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n         std::set<CScript> script_pub_keys;\n         bool have_solving_data;\n \n-        // First ensure scriptPubKey has either a script or JSON with \"address\" string\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+        warnings = ProcessImportLegacy(import_data, pubkey_map, privkey_map, script_pub_keys, have_solving_data, data);\n+\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    // If private keys are disabled, abort if private keys are being imported\n+    if (pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) && !keys.isNull()) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot import private keys to a wallet with private keys disabled\");\n+    }\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n         }\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-\n-        // If private keys are disabled, abort if private keys are being imported\n-        if (pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) && !keys.isNull()) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot import private keys to a wallet with private keys disabled\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n         }\n-\n-        // Generate the script and destination for the scriptPubKey provided\n-        CScript script;\n-        CTxDestination dest;\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n-            }\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n-        script_pub_keys.emplace(script);\n+    }\n+    script_pub_keys.emplace(script);\n \n-        // Parse all arguments\n-        if (strRedeemScript.size()) {\n-            if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n-            }\n-            auto parsed_redeemscript = ParseHex(strRedeemScript);\n-            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    // Parse all arguments\n+    if (strRedeemScript.size()) {\n+        if (!IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n         }\n-        if (witness_script_hex.size()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n-            }\n-            auto parsed_witnessscript = ParseHex(witness_script_hex);\n-            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        auto parsed_redeemscript = ParseHex(strRedeemScript);\n+        import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    }\n+    if (witness_script_hex.size()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n         }\n-        for (size_t i = 0; i < pubKeys.size(); ++i) {\n-            const auto& str = pubKeys[i].get_str();\n-            if (!IsHex(str)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n-            }\n-            auto parsed_pubkey = ParseHex(str);\n-            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n-            if (!pubkey.IsFullyValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n-            }\n-            pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        auto parsed_witnessscript = ParseHex(witness_script_hex);\n+        import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+    }\n+    for (size_t i = 0; i < pubKeys.size(); ++i) {\n+        const auto& str = pubKeys[i].get_str();\n+        if (!IsHex(str)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n         }\n-        for (size_t i = 0; i < keys.size(); ++i) {\n-            const auto& str = keys[i].get_str();\n-            CKey key = DecodeSecret(str);\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-            }\n-            CPubKey pubkey = key.GetPubKey();\n-            CKeyID id = pubkey.GetID();\n-            if (pubkey_map.count(id)) {\n-                pubkey_map.erase(id);\n-            }\n-            privkey_map.emplace(id, key);\n+        auto parsed_pubkey = ParseHex(str);\n+        CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+        if (!pubkey.IsFullyValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n         }\n+        pubkey_map.emplace(pubkey.GetID(), pubkey);\n+    }\n+    for (size_t i = 0; i < keys.size(); ++i) {\n+        const auto& str = keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+        if (pubkey_map.count(id)) {\n+            pubkey_map.erase(id);\n+        }\n+        privkey_map.emplace(id, key);\n+    }\n \n \n-        // Verify and process input data\n-        have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n-        if (have_solving_data) {\n-            // Match up data in import_data with the scriptPubKey in script.\n-            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+    // Verify and process input data\n+    have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n+    if (have_solving_data) {\n+        // Match up data in import_data with the scriptPubKey in script.\n+        auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n \n-            // Verify whether the watchonly option corresponds to the availability of private keys.\n-            bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n-            if (!watchOnly && !spendable) {\n-                warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n-            }\n-            if (watchOnly && spendable) {\n-                warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n-            }\n+        // Verify whether the watchonly option corresponds to the availability of private keys.\n+        bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+        if (!watchOnly && !spendable) {\n+            warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n+        }\n+        if (watchOnly && spendable) {\n+            warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n+        }\n \n-            // Check that all required keys for solvability are provided.\n-            if (error.empty()) {\n-                for (const auto& require_key : import_data.used_keys) {\n-                    if (!require_key.second) continue; // Not a required key\n-                    if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n-                        error = \"some required keys are missing\";\n-                    }\n+        // Check that all required keys for solvability are provided.\n+        if (error.empty()) {\n+            for (const auto& require_key : import_data.used_keys) {\n+                if (!require_key.second) continue; // Not a required key\n+                if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n+                    error = \"some required keys are missing\";\n                 }\n             }\n+        }\n \n-            if (!error.empty()) {\n-                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n-                import_data = ImportData();\n-                pubkey_map.clear();\n-                privkey_map.clear();\n-                have_solving_data = false;\n-            } else {\n-                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n-                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n-                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n-                for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {\n-                    auto oldit = it++;\n-                    if (import_data.used_keys.count(oldit->first) == 0) {\n-                        warnings.push_back(\"Ignoring irrelevant private key.\");\n-                        privkey_map.erase(oldit);\n-                    }\n+        if (!error.empty()) {\n+            warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+            import_data = ImportData();\n+            pubkey_map.clear();\n+            privkey_map.clear();\n+            have_solving_data = false;\n+        } else {\n+            // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+            if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+            if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+            for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {\n+                auto oldit = it++;\n+                if (import_data.used_keys.count(oldit->first) == 0) {\n+                    warnings.push_back(\"Ignoring irrelevant private key.\");\n+                    privkey_map.erase(oldit);\n                 }\n-                for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {\n-                    auto oldit = it++;\n-                    auto key_data_it = import_data.used_keys.find(oldit->first);\n-                    if (key_data_it == import_data.used_keys.end() || !key_data_it->second) {\n-                        warnings.push_back(\"Ignoring public key \\\"\" + HexStr(oldit->first) + \"\\\" as it doesn't appear inside P2PKH or P2WPKH.\");\n-                        pubkey_map.erase(oldit);\n-                    }\n+            }\n+            for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {\n+                auto oldit = it++;\n+                auto key_data_it = import_data.used_keys.find(oldit->first);\n+                if (key_data_it == import_data.used_keys.end() || !key_data_it->second) {\n+                    warnings.push_back(\"Ignoring public key \\\"\" + HexStr(oldit->first) + \"\\\" as it doesn't appear inside P2PKH or P2WPKH.\");\n+                    pubkey_map.erase(oldit);\n                 }\n             }\n         }\n+    }\n \n         // Check whether we have any work to do\n         for (const CScript& script : script_pub_keys) {"
      }
    ]
  },
  {
    "sha": "d2b381cc91b2c4e74abe11e5bd66af647b70dafb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMmIzODFjYzkxYjJjNGU3NGFiZTExZTViZDY2YWY2NDdiNzBkYWZi",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-01-11T21:47:52Z"
      },
      "committer": {
        "name": "MeshCollider",
        "email": "dobsonsa68@gmail.com",
        "date": "2019-02-05T06:41:24Z"
      },
      "message": "[wallet] Refactor ProcessImport() to call ProcessImportLegacy()\n\nThis is almost entirely a move-only commit.\n\nReviewer hint: use --color-moved=zebra for review.",
      "tree": {
        "sha": "740ad8c0b6b43501b287762b6bd1a9f1a82b0a0c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/740ad8c0b6b43501b287762b6bd1a9f1a82b0a0c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d2b381cc91b2c4e74abe11e5bd66af647b70dafb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d2b381cc91b2c4e74abe11e5bd66af647b70dafb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d2b381cc91b2c4e74abe11e5bd66af647b70dafb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d2b381cc91b2c4e74abe11e5bd66af647b70dafb/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4cac0ddd258bc82258ccc99568d02d3b2415339d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4cac0ddd258bc82258ccc99568d02d3b2415339d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4cac0ddd258bc82258ccc99568d02d3b2415339d"
      }
    ],
    "stats": {
      "total": 58,
      "additions": 30,
      "deletions": 28
    },
    "files": [
      {
        "sha": "f91d545a3b63b36ea3e3deff071784a2fe5cda22",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 28,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d2b381cc91b2c4e74abe11e5bd66af647b70dafb/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d2b381cc91b2c4e74abe11e5bd66af647b70dafb/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=d2b381cc91b2c4e74abe11e5bd66af647b70dafb",
        "patch": "@@ -967,29 +967,6 @@ static std::string RecurseImportData(const CScript& script, ImportData& import_d\n static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n {\n     UniValue warnings(UniValue::VARR);\n-    return warnings;\n-}\n-\n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n-{\n-    UniValue warnings(UniValue::VARR);\n-    UniValue result(UniValue::VOBJ);\n-\n-    try {\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n-        }\n-        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n-\n-        ImportData import_data;\n-        std::map<CKeyID, CPubKey> pubkey_map;\n-        std::map<CKeyID, CKey> privkey_map;\n-        std::set<CScript> script_pub_keys;\n-        bool have_solving_data;\n-\n-        warnings = ProcessImportLegacy(import_data, pubkey_map, privkey_map, script_pub_keys, have_solving_data, data);\n \n     // First ensure scriptPubKey has either a script or JSON with \"address\" string\n     const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n@@ -1004,13 +981,9 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n     const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n     const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n     const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n     const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n \n-    // If private keys are disabled, abort if private keys are being imported\n-    if (pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) && !keys.isNull()) {\n-        throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot import private keys to a wallet with private keys disabled\");\n-    }\n-\n     // Generate the script and destination for the scriptPubKey provided\n     CScript script;\n     CTxDestination dest;\n@@ -1127,6 +1100,35 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n         }\n     }\n \n+    return warnings;\n+}\n+\n+static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    UniValue warnings(UniValue::VARR);\n+    UniValue result(UniValue::VOBJ);\n+\n+    try {\n+        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        }\n+        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+        ImportData import_data;\n+        std::map<CKeyID, CPubKey> pubkey_map;\n+        std::map<CKeyID, CKey> privkey_map;\n+        std::set<CScript> script_pub_keys;\n+        bool have_solving_data;\n+\n+        warnings = ProcessImportLegacy(import_data, pubkey_map, privkey_map, script_pub_keys, have_solving_data, data);\n+\n+        // If private keys are disabled, abort if private keys are being imported\n+        if (pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) && !privkey_map.empty()) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot import private keys to a wallet with private keys disabled\");\n+        }\n+\n         // Check whether we have any work to do\n         for (const CScript& script : script_pub_keys) {\n             if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {"
      }
    ]
  },
  {
    "sha": "9f48053d8f9a1feacc96d7e2a00c8a3a67576948",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZjQ4MDUzZDhmOWExZmVhY2M5NmQ3ZTJhMDBjOGEzYTY3NTc2OTQ4",
    "commit": {
      "author": {
        "name": "MeshCollider",
        "email": "dobsonsa68@gmail.com",
        "date": "2018-12-13T00:55:48Z"
      },
      "committer": {
        "name": "MeshCollider",
        "email": "dobsonsa68@gmail.com",
        "date": "2019-02-05T06:42:04Z"
      },
      "message": "[wallet] Allow descriptor imports with importmulti",
      "tree": {
        "sha": "c0a7ae7139a1e7c61dd6733046a7911ff312eda8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c0a7ae7139a1e7c61dd6733046a7911ff312eda8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9f48053d8f9a1feacc96d7e2a00c8a3a67576948",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9f48053d8f9a1feacc96d7e2a00c8a3a67576948",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9f48053d8f9a1feacc96d7e2a00c8a3a67576948",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9f48053d8f9a1feacc96d7e2a00c8a3a67576948/comments",
    "author": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d2b381cc91b2c4e74abe11e5bd66af647b70dafb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d2b381cc91b2c4e74abe11e5bd66af647b70dafb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d2b381cc91b2c4e74abe11e5bd66af647b70dafb"
      }
    ],
    "stats": {
      "total": 118,
      "additions": 111,
      "deletions": 7
    },
    "files": [
      {
        "sha": "9ed2a16416e036945623bf93e3b75dad7be4a5af",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 111,
        "deletions": 7,
        "changes": 118,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9f48053d8f9a1feacc96d7e2a00c8a3a67576948/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9f48053d8f9a1feacc96d7e2a00c8a3a67576948/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=9f48053d8f9a1feacc96d7e2a00c8a3a67576948",
        "patch": "@@ -9,6 +9,7 @@\n #include <merkleblock.h>\n #include <rpc/server.h>\n #include <rpc/util.h>\n+#include <script/descriptor.h>\n #include <script/script.h>\n #include <script/standard.h>\n #include <sync.h>\n@@ -984,11 +985,14 @@ static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CP\n     const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n     const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n \n+    if (data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for a non-descriptor import\");\n+    }\n+\n     // Generate the script and destination for the scriptPubKey provided\n     CScript script;\n-    CTxDestination dest;\n     if (!isScript) {\n-        dest = DecodeDestination(output);\n+        CTxDestination dest = DecodeDestination(output);\n         if (!IsValidDestination(dest)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n         }\n@@ -999,6 +1003,7 @@ static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CP\n         }\n         std::vector<unsigned char> vData(ParseHex(output));\n         script = CScript(vData.begin(), vData.end());\n+        CTxDestination dest;\n         if (!ExtractDestination(script, dest) && !internal) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n@@ -1103,6 +1108,91 @@ static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CP\n     return warnings;\n }\n \n+static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n+{\n+    UniValue warnings(UniValue::VARR);\n+\n+    const std::string& descriptor = data[\"desc\"].get_str();\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+\n+    have_solving_data = parsed_desc->IsSolvable();\n+    const bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    int64_t range_start = 0, range_end = 0;\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange()) {\n+        if (!data.exists(\"range\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+        }\n+        const UniValue& range = data[\"range\"];\n+        range_start = range.exists(\"start\") ? range[\"start\"].get_int64() : 0;\n+        if (!range.exists(\"end\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End of range for descriptor must be specified\");\n+        }\n+        range_end = range[\"end\"].get_int64();\n+        if (range_end < range_start || range_start < 0) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid descriptor range specified\");\n+        }\n+    }\n+\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    FlatSigningProvider out_keys;\n+\n+    // Expand all descriptors to get public keys and scripts.\n+    // TODO: get private keys from descriptors too\n+    for (int i = range_start; i <= range_end; ++i) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        std::copy(scripts_temp.begin(), scripts_temp.end(), std::inserter(script_pub_keys, script_pub_keys.end()));\n+    }\n+\n+    for (const auto& x : out_keys.scripts) {\n+        import_data.import_scripts.emplace(x.second);\n+    }\n+\n+    std::copy(out_keys.pubkeys.begin(), out_keys.pubkeys.end(), std::inserter(pubkey_map, pubkey_map.end()));\n+\n+    for (size_t i = 0; i < priv_keys.size(); ++i) {\n+        const auto& str = priv_keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+\n+        // Check if this private key corresponds to a public key from the descriptor\n+        if (!pubkey_map.count(id)) {\n+            warnings.push_back(\"Ignoring irrelevant private key.\");\n+        } else {\n+            privkey_map.emplace(id, key);\n+        }\n+    }\n+\n+    // Check if all the public keys have corresponding private keys in the import for spendability.\n+    // This does not take into account threshold multisigs which could be spendable without all keys.\n+    // Thus, threshold multisigs without all keys will be considered not spendable here, even if they are,\n+    // perhaps triggering a false warning message. This is consistent with the current wallet IsMine check.\n+    bool spendable = std::all_of(pubkey_map.begin(), pubkey_map.end(),\n+        [&](const std::pair<CKeyID, CPubKey>& used_key) {\n+            return privkey_map.count(used_key.first) > 0;\n+        });\n+    if (!watch_only && !spendable) {\n+        warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n+    }\n+    if (watch_only && spendable) {\n+        warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n+    }\n+\n+    return warnings;\n+}\n+\n static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n     UniValue warnings(UniValue::VARR);\n@@ -1122,7 +1212,15 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n         std::set<CScript> script_pub_keys;\n         bool have_solving_data;\n \n-        warnings = ProcessImportLegacy(import_data, pubkey_map, privkey_map, script_pub_keys, have_solving_data, data);\n+        if (data.exists(\"scriptPubKey\") && data.exists(\"desc\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Both a descriptor and a scriptPubKey should not be provided.\");\n+        } else if (data.exists(\"scriptPubKey\")) {\n+            warnings = ProcessImportLegacy(import_data, pubkey_map, privkey_map, script_pub_keys, have_solving_data, data);\n+        } else if (data.exists(\"desc\")) {\n+            warnings = ProcessImportDescriptor(import_data, pubkey_map, privkey_map, script_pub_keys, have_solving_data, data);\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Either a descriptor or scriptPubKey must be provided.\");\n+        }\n \n         // If private keys are disabled, abort if private keys are being imported\n         if (pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) && !privkey_map.empty()) {\n@@ -1132,7 +1230,7 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n         // Check whether we have any work to do\n         for (const CScript& script : script_pub_keys) {\n             if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script (\\\"\" + HexStr(script.begin(), script.end()) + \"\\\")\");\n             }\n         }\n \n@@ -1172,8 +1270,7 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             }\n             CTxDestination dest;\n             ExtractDestination(script, dest);\n-            if (!internal) {\n-                assert(IsValidDestination(dest));\n+            if (!internal && IsValidDestination(dest)) {\n                 pwallet->SetAddressBook(dest, label, \"receive\");\n             }\n         }\n@@ -1226,7 +1323,8 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n                         {\n                             {\"\", RPCArg::Type::OBJ, /* opt */ false, /* default_val */ \"\", \"\",\n                                 {\n-                                    {\"scriptPubKey\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"Type of scriptPubKey (string for script, json for address)\",\n+                                    {\"desc\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"\", \"Descriptor to import. If using descriptor, do not also provide address/scriptPubKey, scripts, or pubkeys\"},\n+                                    {\"scriptPubKey\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"Type of scriptPubKey (string for script, json for address). Should not be provided if using a descriptor\",\n                                         /* oneline_description */ \"\", {\"\\\"<script>\\\" | { \\\"address\\\":\\\"<address>\\\" }\", \"string / json\"}\n                                     },\n                                     {\"timestamp\", RPCArg::Type::NUM, /* opt */ false, /* default_val */ \"\", \"Creation time of the key in seconds since epoch (Jan 1 1970 GMT),\\n\"\n@@ -1249,6 +1347,12 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n                                             {\"key\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"\"},\n                                         }\n                                     },\n+                                    {\"range\", RPCArg::Type::OBJ, /* opt */ true, /* default_val */ \"\", \"If a ranged descriptor is used, this specifies the start and end of the range to import\",\n+                                        {\n+                                            {\"start\", RPCArg::Type::NUM, /* opt */ true, /* default_val */ \"0\", \"Start of the range to import\"},\n+                                            {\"end\", RPCArg::Type::NUM, /* opt */ false, /* default_val */ \"\", \"End of the range to import (inclusive)\"},\n+                                        }\n+                                    },\n                                     {\"internal\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"Stating whether matching outputs should be treated as not incoming payments (also known as change)\"},\n                                     {\"watchonly\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"Stating whether matching outputs should be considered watchonly.\"},\n                                     {\"label\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"''\", \"Label to assign to the address, only allowed with internal=false\"},"
      }
    ]
  },
  {
    "sha": "fbb5e935eaf17d603ec62e1a704a174235540b71",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYmI1ZTkzNWVhZjE3ZDYwM2VjNjJlMWE3MDRhMTc0MjM1NTQwYjcx",
    "commit": {
      "author": {
        "name": "MeshCollider",
        "email": "dobsonsa68@gmail.com",
        "date": "2018-12-13T01:01:36Z"
      },
      "committer": {
        "name": "MeshCollider",
        "email": "dobsonsa68@gmail.com",
        "date": "2019-02-05T06:42:05Z"
      },
      "message": "Add test for importing via descriptor",
      "tree": {
        "sha": "15f137d8f7abb043e8d4ffb339a35ce0a116a6de",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/15f137d8f7abb043e8d4ffb339a35ce0a116a6de"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fbb5e935eaf17d603ec62e1a704a174235540b71",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fbb5e935eaf17d603ec62e1a704a174235540b71",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fbb5e935eaf17d603ec62e1a704a174235540b71",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fbb5e935eaf17d603ec62e1a704a174235540b71/comments",
    "author": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9f48053d8f9a1feacc96d7e2a00c8a3a67576948",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9f48053d8f9a1feacc96d7e2a00c8a3a67576948",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9f48053d8f9a1feacc96d7e2a00c8a3a67576948"
      }
    ],
    "stats": {
      "total": 85,
      "additions": 84,
      "deletions": 1
    },
    "files": [
      {
        "sha": "7cce72b39fc87fbc83c6ec116cc6d606455f8fcd",
        "filename": "test/functional/wallet_importmulti.py",
        "status": "modified",
        "additions": 84,
        "deletions": 1,
        "changes": 85,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fbb5e935eaf17d603ec62e1a704a174235540b71/test/functional/wallet_importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fbb5e935eaf17d603ec62e1a704a174235540b71/test/functional/wallet_importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importmulti.py?ref=fbb5e935eaf17d603ec62e1a704a174235540b71",
        "patch": "@@ -203,7 +203,7 @@ def run_test(self):\n                                \"keys\": [key.privkey]},\n                               success=False,\n                               error_code=-4,\n-                              error_message='The wallet already contains the private key for this address or script')\n+                              error_message='The wallet already contains the private key for this address or script (\"' + key.p2pkh_script + '\")')\n \n         # Address + Private key + watchonly\n         self.log.info(\"Should import an address with private key and with watchonly\")\n@@ -543,5 +543,88 @@ def run_test(self):\n                      solvable=True,\n                      ismine=False)\n \n+        # Test importing of a P2SH-P2WPKH address via descriptor + private key\n+        key = get_key(self.nodes[0])\n+        self.log.info(\"Should import a p2sh-p2wpkh address from descriptor and private key\")\n+        self.test_importmulti({\"desc\": \"sh(wpkh(\" + key.pubkey + \"))\",\n+                               \"timestamp\": \"now\",\n+                               \"label\": \"Descriptor import test\",\n+                               \"keys\": [key.privkey]},\n+                              success=True)\n+        test_address(self.nodes[1],\n+                     key.p2sh_p2wpkh_addr,\n+                     solvable=True,\n+                     ismine=True,\n+                     label=\"Descriptor import test\")\n+\n+        # Test ranged descriptor fails if range is not specified\n+        xpriv = \"tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg\"\n+        addresses = [\"2N7yv4p8G8yEaPddJxY41kPihnWvs39qCMf\", \"2MsHxyb2JS3pAySeNUsJ7mNnurtpeenDzLA\"] # hdkeypath=m/0'/0'/0' and 1'\n+        desc = \"sh(wpkh(\" + xpriv + \"/0'/0'/*'\" + \"))\"\n+        self.log.info(\"Ranged descriptor import should fail without a specified range\")\n+        self.test_importmulti({\"desc\": desc,\n+                               \"timestamp\": \"now\"},\n+                              success=False,\n+                              error_code=-8,\n+                              error_message='Descriptor is ranged, please specify the range')\n+\n+        # Test importing of a ranged descriptor without keys\n+        self.log.info(\"Should import the ranged descriptor with specified range as solvable\")\n+        self.test_importmulti({\"desc\": desc,\n+                               \"timestamp\": \"now\",\n+                               \"range\": {\"end\": 1}},\n+                              success=True,\n+                              warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n+        for address in addresses:\n+            test_address(self.nodes[1],\n+                         key.p2sh_p2wpkh_addr,\n+                         solvable=True)\n+\n+        # Test importing of a P2PKH address via descriptor\n+        key = get_key(self.nodes[0])\n+        self.log.info(\"Should import a p2pkh address from descriptor\")\n+        self.test_importmulti({\"desc\": \"pkh(\" + key.pubkey + \")\",\n+                               \"timestamp\": \"now\",\n+                               \"label\": \"Descriptor import test\"},\n+                              True,\n+                              warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n+        test_address(self.nodes[1],\n+                     key.p2pkh_addr,\n+                     solvable=True,\n+                     ismine=False,\n+                     label=\"Descriptor import test\")\n+\n+        # Test import fails if both desc and scriptPubKey are provided\n+        key = get_key(self.nodes[0])\n+        self.log.info(\"Import should fail if both scriptPubKey and desc are provided\")\n+        self.test_importmulti({\"desc\": \"pkh(\" + key.pubkey + \")\",\n+                               \"scriptPubKey\": {\"address\": key.p2pkh_addr},\n+                               \"timestamp\": \"now\"},\n+                              success=False,\n+                              error_code=-8,\n+                              error_message='Both a descriptor and a scriptPubKey should not be provided.')\n+\n+        # Test import fails if neither desc nor scriptPubKey are present\n+        key = get_key(self.nodes[0])\n+        self.log.info(\"Import should fail if neither a descriptor nor a scriptPubKey are provided\")\n+        self.test_importmulti({\"timestamp\": \"now\"},\n+                              success=False,\n+                              error_code=-8,\n+                              error_message='Either a descriptor or scriptPubKey must be provided.')\n+\n+        # Test importing of a multisig via descriptor\n+        key1 = get_key(self.nodes[0])\n+        key2 = get_key(self.nodes[0])\n+        self.log.info(\"Should import a 1-of-2 bare multisig from descriptor\")\n+        self.test_importmulti({\"desc\": \"multi(1,\" + key1.pubkey + \",\" + key2.pubkey + \")\",\n+                               \"timestamp\": \"now\"},\n+                              success=True)\n+        self.log.info(\"Should not treat individual keys from the imported bare multisig as watchonly\")\n+        test_address(self.nodes[1],\n+                     key1.p2pkh_addr,\n+                     ismine=False,\n+                     iswatchonly=False)\n+\n+\n if __name__ == '__main__':\n     ImportMultiTest().main()"
      }
    ]
  },
  {
    "sha": "b985e9c850ea682eced7021faf6c7c835066c61b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiOTg1ZTljODUwZWE2ODJlY2VkNzAyMWZhZjZjN2M4MzUwNjZjNjFi",
    "commit": {
      "author": {
        "name": "MeshCollider",
        "email": "dobsonsa68@gmail.com",
        "date": "2018-11-09T00:54:22Z"
      },
      "committer": {
        "name": "MeshCollider",
        "email": "dobsonsa68@gmail.com",
        "date": "2019-02-05T06:42:06Z"
      },
      "message": "Add release notes for importmulti descriptor support",
      "tree": {
        "sha": "88b717b4b99ed0abf0794eec66b29e24febd034d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/88b717b4b99ed0abf0794eec66b29e24febd034d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b985e9c850ea682eced7021faf6c7c835066c61b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b985e9c850ea682eced7021faf6c7c835066c61b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b985e9c850ea682eced7021faf6c7c835066c61b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b985e9c850ea682eced7021faf6c7c835066c61b/comments",
    "author": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fbb5e935eaf17d603ec62e1a704a174235540b71",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fbb5e935eaf17d603ec62e1a704a174235540b71",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fbb5e935eaf17d603ec62e1a704a174235540b71"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 5,
      "deletions": 0
    },
    "files": [
      {
        "sha": "1cf36e85cffcc2dc88e51964ca0a2a8f565a2ed2",
        "filename": "doc/release-notes-14491.md",
        "status": "added",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b985e9c850ea682eced7021faf6c7c835066c61b/doc/release-notes-14491.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b985e9c850ea682eced7021faf6c7c835066c61b/doc/release-notes-14491.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-14491.md?ref=b985e9c850ea682eced7021faf6c7c835066c61b",
        "patch": "@@ -0,0 +1,5 @@\n+Descriptor import support\n+---------------------\n+\n+The `importmulti` RPC now supports importing of addresses from descriptors. A \"desc\" parameter can be provided instead of the \"scriptPubKey\" in a request, as well as an optional range for ranged descriptors to specify the start and end of the range to import. More information about\n+descriptors can be found [here](https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md)."
      }
    ]
  }
]