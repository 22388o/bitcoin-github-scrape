[
  {
    "sha": "568dd2f83900a11a4dbba1250722791a135bf0a9",
    "node_id": "C_kwDOABII59oAKDU2OGRkMmY4MzkwMGExMWE0ZGJiYTEyNTA3MjI3OTFhMTM1YmYwYTk",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-11-01T20:32:53Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-11-29T22:58:53Z"
      },
      "message": "Replace MakeSpan helper with Span deduction guide",
      "tree": {
        "sha": "b9091ef5f60075570c9f0e0c487282450e152ec0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b9091ef5f60075570c9f0e0c487282450e152ec0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/568dd2f83900a11a4dbba1250722791a135bf0a9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/568dd2f83900a11a4dbba1250722791a135bf0a9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/568dd2f83900a11a4dbba1250722791a135bf0a9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/568dd2f83900a11a4dbba1250722791a135bf0a9/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "383d350bd5107bfe00e3b90a00cab9a3c1397c72",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/383d350bd5107bfe00e3b90a00cab9a3c1397c72",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/383d350bd5107bfe00e3b90a00cab9a3c1397c72"
      }
    ],
    "stats": {
      "total": 210,
      "additions": 106,
      "deletions": 104
    },
    "files": [
      {
        "sha": "b122e0055e7cad9fd104049314b32b38212e575c",
        "filename": "src/base58.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/568dd2f83900a11a4dbba1250722791a135bf0a9/src/base58.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/568dd2f83900a11a4dbba1250722791a135bf0a9/src/base58.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.cpp?ref=568dd2f83900a11a4dbba1250722791a135bf0a9",
        "patch": "@@ -149,7 +149,7 @@ std::string EncodeBase58Check(Span<const unsigned char> input)\n         return false;\n     }\n     // re-calculate the checksum, ensure it matches the included 4-byte checksum\n-    uint256 hash = Hash(MakeSpan(vchRet).first(vchRet.size() - 4));\n+    uint256 hash = Hash(Span{vchRet}.first(vchRet.size() - 4));\n     if (memcmp(&hash, &vchRet[vchRet.size() - 4], 4) != 0) {\n         vchRet.clear();\n         return false;"
      },
      {
        "sha": "00b777a1116de2290ed7c1af3773c4eea8045c48",
        "filename": "src/compressor.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/568dd2f83900a11a4dbba1250722791a135bf0a9/src/compressor.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/568dd2f83900a11a4dbba1250722791a135bf0a9/src/compressor.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compressor.h?ref=568dd2f83900a11a4dbba1250722791a135bf0a9",
        "patch": "@@ -65,12 +65,12 @@ struct ScriptCompression\n     void Ser(Stream &s, const CScript& script) {\n         CompressedScript compr;\n         if (CompressScript(script, compr)) {\n-            s << MakeSpan(compr);\n+            s << Span{compr};\n             return;\n         }\n         unsigned int nSize = script.size() + nSpecialScripts;\n         s << VARINT(nSize);\n-        s << MakeSpan(script);\n+        s << Span{script};\n     }\n \n     template<typename Stream>\n@@ -79,7 +79,7 @@ struct ScriptCompression\n         s >> VARINT(nSize);\n         if (nSize < nSpecialScripts) {\n             CompressedScript vch(GetSpecialScriptSize(nSize), 0x00);\n-            s >> MakeSpan(vch);\n+            s >> Span{vch};\n             DecompressScript(script, nSize, vch);\n             return;\n         }\n@@ -90,7 +90,7 @@ struct ScriptCompression\n             s.ignore(nSize);\n         } else {\n             script.resize(nSize);\n-            s >> MakeSpan(script);\n+            s >> Span{script};\n         }\n     }\n };"
      },
      {
        "sha": "b6752f3ed4322cc929909b16aebd465f33172f61",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/568dd2f83900a11a4dbba1250722791a135bf0a9/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/568dd2f83900a11a4dbba1250722791a135bf0a9/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=568dd2f83900a11a4dbba1250722791a135bf0a9",
        "patch": "@@ -1815,7 +1815,7 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CInv&\n         if (!ReadRawBlockFromDisk(block_data, pindex, m_chainparams.MessageStart())) {\n             assert(!\"cannot load block from disk\");\n         }\n-        m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::BLOCK, MakeSpan(block_data)));\n+        m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::BLOCK, Span{block_data}));\n         // Don't set pblock as we've sent the block\n     } else {\n         // Send block from disk"
      },
      {
        "sha": "eb67445baf0b8ae2b27f041fa2aa38fdd5a279b7",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/568dd2f83900a11a4dbba1250722791a135bf0a9/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/568dd2f83900a11a4dbba1250722791a135bf0a9/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=568dd2f83900a11a4dbba1250722791a135bf0a9",
        "patch": "@@ -196,7 +196,7 @@ static void Checksum(Span<const uint8_t> addr_pubkey, uint8_t (&checksum)[CHECKS\n \n     SHA3_256 hasher;\n \n-    hasher.Write(MakeSpan(prefix).first(prefix_len));\n+    hasher.Write(Span{prefix}.first(prefix_len));\n     hasher.Write(addr_pubkey);\n     hasher.Write(VERSION);\n \n@@ -693,13 +693,13 @@ uint32_t CNetAddr::GetLinkedIPv4() const\n         return ReadBE32(m_addr.data());\n     } else if (IsRFC6052() || IsRFC6145()) {\n         // mapped IPv4, SIIT translated IPv4: the IPv4 address is the last 4 bytes of the address\n-        return ReadBE32(MakeSpan(m_addr).last(ADDR_IPV4_SIZE).data());\n+        return ReadBE32(Span{m_addr}.last(ADDR_IPV4_SIZE).data());\n     } else if (IsRFC3964()) {\n         // 6to4 tunneled IPv4: the IPv4 address is in bytes 2-6\n-        return ReadBE32(MakeSpan(m_addr).subspan(2, ADDR_IPV4_SIZE).data());\n+        return ReadBE32(Span{m_addr}.subspan(2, ADDR_IPV4_SIZE).data());\n     } else if (IsRFC4380()) {\n         // Teredo tunneled IPv4: the IPv4 address is in the last 4 bytes of the address, but bitflipped\n-        return ~ReadBE32(MakeSpan(m_addr).last(ADDR_IPV4_SIZE).data());\n+        return ~ReadBE32(Span{m_addr}.last(ADDR_IPV4_SIZE).data());\n     }\n     assert(false);\n }"
      },
      {
        "sha": "c8af4a96056d937c0d1d299f8c55fd3c0b7cea97",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/568dd2f83900a11a4dbba1250722791a135bf0a9/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/568dd2f83900a11a4dbba1250722791a135bf0a9/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=568dd2f83900a11a4dbba1250722791a135bf0a9",
        "patch": "@@ -433,7 +433,7 @@ class CNetAddr\n \n         if (SetNetFromBIP155Network(bip155_net, address_size)) {\n             m_addr.resize(address_size);\n-            s >> MakeSpan(m_addr);\n+            s >> Span{m_addr};\n \n             if (m_net != NET_IPV6) {\n                 return;"
      },
      {
        "sha": "5d0bb68ec620a9e699d1e2af4dd8ae12d8cae06e",
        "filename": "src/policy/policy.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/568dd2f83900a11a4dbba1250722791a135bf0a9/src/policy/policy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/568dd2f83900a11a4dbba1250722791a135bf0a9/src/policy/policy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.cpp?ref=568dd2f83900a11a4dbba1250722791a135bf0a9",
        "patch": "@@ -251,7 +251,7 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n         // - No annexes\n         if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !p2sh) {\n             // Taproot spend (non-P2SH-wrapped, version 1, witness program size 32; see BIP 341)\n-            auto stack = MakeSpan(tx.vin[i].scriptWitness.stack);\n+            Span stack{tx.vin[i].scriptWitness.stack};\n             if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {\n                 // Annexes are nonstandard as long as no semantics are defined for them.\n                 return false;"
      },
      {
        "sha": "1171ecf1dd1e70af3870016380ad5c064dc57f42",
        "filename": "src/psbt.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/568dd2f83900a11a4dbba1250722791a135bf0a9/src/psbt.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/568dd2f83900a11a4dbba1250722791a135bf0a9/src/psbt.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/psbt.h?ref=568dd2f83900a11a4dbba1250722791a135bf0a9",
        "patch": "@@ -81,7 +81,7 @@ struct PSBTInput\n         if (final_script_sig.empty() && final_script_witness.IsNull()) {\n             // Write any partial signatures\n             for (auto sig_pair : partial_sigs) {\n-                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, Span{sig_pair.second.first});\n                 s << sig_pair.second.second;\n             }\n "
      },
      {
        "sha": "cba104a5e54912cfda8a7aea21949d818c2be444",
        "filename": "src/pubkey.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/568dd2f83900a11a4dbba1250722791a135bf0a9/src/pubkey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/568dd2f83900a11a4dbba1250722791a135bf0a9/src/pubkey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.h?ref=568dd2f83900a11a4dbba1250722791a135bf0a9",
        "patch": "@@ -157,13 +157,13 @@ class CPubKey\n     //! Get the KeyID of this public key (hash of its serialization)\n     CKeyID GetID() const\n     {\n-        return CKeyID(Hash160(MakeSpan(vch).first(size())));\n+        return CKeyID(Hash160(Span{vch}.first(size())));\n     }\n \n     //! Get the 256-bit hash of this public key.\n     uint256 GetHash() const\n     {\n-        return Hash(MakeSpan(vch).first(size()));\n+        return Hash(Span{vch}.first(size()));\n     }\n \n     /*"
      },
      {
        "sha": "1c99df147b0696b4ef0f45740f583c5e27a9685e",
        "filename": "src/script/descriptor.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/568dd2f83900a11a4dbba1250722791a135bf0a9/src/script/descriptor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/568dd2f83900a11a4dbba1250722791a135bf0a9/src/script/descriptor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.cpp?ref=568dd2f83900a11a4dbba1250722791a135bf0a9",
        "patch": "@@ -631,7 +631,7 @@ class DescriptorImpl : public Descriptor\n             out.origins.emplace(entry.first.GetID(), std::make_pair<CPubKey, KeyOriginInfo>(CPubKey(entry.first), std::move(entry.second)));\n         }\n \n-        output_scripts = MakeScripts(pubkeys, MakeSpan(subscripts), out);\n+        output_scripts = MakeScripts(pubkeys, Span{subscripts}, out);\n         return true;\n     }\n \n@@ -974,10 +974,10 @@ std::unique_ptr<PubkeyProvider> ParsePubkeyInner(uint32_t key_exp_index, const S\n     }\n     KeyPath path;\n     DeriveType type = DeriveType::NO;\n-    if (split.back() == MakeSpan(\"*\").first(1)) {\n+    if (split.back() == Span{\"*\"}.first(1)) {\n         split.pop_back();\n         type = DeriveType::UNHARDENED;\n-    } else if (split.back() == MakeSpan(\"*'\").first(2) || split.back() == MakeSpan(\"*h\").first(2)) {\n+    } else if (split.back() == Span{\"*'\"}.first(2) || split.back() == Span{\"*h\"}.first(2)) {\n         split.pop_back();\n         type = DeriveType::HARDENED;\n     }"
      },
      {
        "sha": "3f7060879ce64f8c61af4b58ea21ea1e51b5e35e",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/568dd2f83900a11a4dbba1250722791a135bf0a9/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/568dd2f83900a11a4dbba1250722791a135bf0a9/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=568dd2f83900a11a4dbba1250722791a135bf0a9",
        "patch": "@@ -167,7 +167,7 @@ static bool SignTaprootScript(const SigningProvider& provider, const BaseSignatu\n \n     // <xonly pubkey> OP_CHECKSIG\n     if (script.size() == 34 && script[33] == OP_CHECKSIG && script[0] == 0x20) {\n-        XOnlyPubKey pubkey(MakeSpan(script).subspan(1, 32));\n+        XOnlyPubKey pubkey{Span{script}.subspan(1, 32)};\n         std::vector<unsigned char> sig;\n         if (CreateTaprootScriptSig(creator, sigdata, provider, sig, pubkey, leaf_hash, sigversion)) {\n             result = Vector(std::move(sig));"
      },
      {
        "sha": "50525af33235b23c22be18a50e5f9798a3874b7d",
        "filename": "src/script/sign.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/568dd2f83900a11a4dbba1250722791a135bf0a9/src/script/sign.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/568dd2f83900a11a4dbba1250722791a135bf0a9/src/script/sign.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.h?ref=568dd2f83900a11a4dbba1250722791a135bf0a9",
        "patch": "@@ -149,7 +149,7 @@ void SerializeHDKeypaths(Stream& s, const std::map<CPubKey, KeyOriginInfo>& hd_k\n         if (!keypath_pair.first.IsValid()) {\n             throw std::ios_base::failure(\"Invalid CPubKey being serialized\");\n         }\n-        SerializeToVector(s, type, MakeSpan(keypath_pair.first));\n+        SerializeToVector(s, type, Span{keypath_pair.first});\n         WriteCompactSize(s, (keypath_pair.second.path.size() + 1) * sizeof(uint32_t));\n         s << keypath_pair.second.fingerprint;\n         for (const auto& path : keypath_pair.second.path) {"
      },
      {
        "sha": "ce5b7ca31600411931e64584e835f513a27be8aa",
        "filename": "src/span.h",
        "status": "modified",
        "additions": 11,
        "deletions": 9,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/568dd2f83900a11a4dbba1250722791a135bf0a9/src/span.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/568dd2f83900a11a4dbba1250722791a135bf0a9/src/span.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/span.h?ref=568dd2f83900a11a4dbba1250722791a135bf0a9",
        "patch": "@@ -222,13 +222,15 @@ class Span\n     template <typename O> friend class Span;\n };\n \n-// MakeSpan helps constructing a Span of the right type automatically.\n-/** MakeSpan for arrays: */\n-template <typename A, int N> Span<A> constexpr MakeSpan(A (&a)[N]) { return Span<A>(a, N); }\n-/** MakeSpan for temporaries / rvalue references, only supporting const output. */\n-template <typename V> constexpr auto MakeSpan(V&& v SPAN_ATTR_LIFETIMEBOUND) -> typename std::enable_if<!std::is_lvalue_reference<V>::value, Span<const typename std::remove_pointer<decltype(v.data())>::type>>::type { return std::forward<V>(v); }\n-/** MakeSpan for (lvalue) references, supporting mutable output. */\n-template <typename V> constexpr auto MakeSpan(V& v SPAN_ATTR_LIFETIMEBOUND) -> Span<typename std::remove_pointer<decltype(v.data())>::type> { return v; }\n+// Deduction guides for Span\n+// For the pointer/size based and iterator based constructor:\n+template <typename T, typename EndOrSize> Span(T*, EndOrSize) -> Span<T>;\n+// For the array constructor:\n+template <typename T, std::size_t N> Span(T (&)[N]) -> Span<T>;\n+// For the temporaries/rvalue references constructor, only supporting const output.\n+template <typename T> Span(T&&) -> Span<std::enable_if_t<!std::is_lvalue_reference_v<T>, const std::remove_pointer_t<decltype(std::declval<T&&>().data())>>>;\n+// For (lvalue) references, supporting mutable output.\n+template <typename T> Span(T&) -> Span<std::remove_pointer_t<decltype(std::declval<T&>().data())>>;\n \n /** Pop the last element off a span, and return a reference to that element. */\n template <typename T>\n@@ -274,7 +276,7 @@ inline const unsigned char* UCharCast(const std::byte* c) { return reinterpret_c\n // Helper function to safely convert a Span to a Span<[const] unsigned char>.\n template <typename T> constexpr auto UCharSpanCast(Span<T> s) -> Span<typename std::remove_pointer<decltype(UCharCast(s.data()))>::type> { return {UCharCast(s.data()), s.size()}; }\n \n-/** Like MakeSpan, but for (const) unsigned char member types only. Only works for (un)signed char containers. */\n-template <typename V> constexpr auto MakeUCharSpan(V&& v) -> decltype(UCharSpanCast(MakeSpan(std::forward<V>(v)))) { return UCharSpanCast(MakeSpan(std::forward<V>(v))); }\n+/** Like the Span constructor, but for (const) unsigned char member types only. Only works for (un)signed char containers. */\n+template <typename V> constexpr auto MakeUCharSpan(V&& v) -> decltype(UCharSpanCast(Span{std::forward<V>(v)})) { return UCharSpanCast(Span{std::forward<V>(v)}); }\n \n #endif // BITCOIN_SPAN_H"
      },
      {
        "sha": "dfea73e87b82f0d7df89116228d3ed414f91c821",
        "filename": "src/test/crypto_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/568dd2f83900a11a4dbba1250722791a135bf0a9/src/test/crypto_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/568dd2f83900a11a4dbba1250722791a135bf0a9/src/test/crypto_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/crypto_tests.cpp?ref=568dd2f83900a11a4dbba1250722791a135bf0a9",
        "patch": "@@ -770,8 +770,8 @@ static void TestSHA3_256(const std::string& input, const std::string& output)\n     int s1 = InsecureRandRange(in_bytes.size() + 1);\n     int s2 = InsecureRandRange(in_bytes.size() + 1 - s1);\n     int s3 = in_bytes.size() - s1 - s2;\n-    sha.Write(MakeSpan(in_bytes).first(s1)).Write(MakeSpan(in_bytes).subspan(s1, s2));\n-    sha.Write(MakeSpan(in_bytes).last(s3)).Finalize(out);\n+    sha.Write(Span{in_bytes}.first(s1)).Write(Span{in_bytes}.subspan(s1, s2));\n+    sha.Write(Span{in_bytes}.last(s3)).Finalize(out);\n     BOOST_CHECK(std::equal(std::begin(out_bytes), std::end(out_bytes), out));\n }\n "
      },
      {
        "sha": "f8fa26d907338e0a9bc44e454fed09ea2e9dde02",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 70,
        "deletions": 70,
        "changes": 140,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/568dd2f83900a11a4dbba1250722791a135bf0a9/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/568dd2f83900a11a4dbba1250722791a135bf0a9/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=568dd2f83900a11a4dbba1250722791a135bf0a9",
        "patch": "@@ -386,9 +386,9 @@ BOOST_AUTO_TEST_CASE(cnetaddr_unserialize_v2)\n     s.SetVersion(s.GetVersion() | ADDRV2_FORMAT);\n \n     // Valid IPv4.\n-    s << MakeSpan(ParseHex(\"01\"          // network type (IPv4)\n-                           \"04\"          // address length\n-                           \"01020304\")); // address\n+    s << Span{ParseHex(\"01\"          // network type (IPv4)\n+                       \"04\"          // address length\n+                       \"01020304\")}; // address\n     s >> addr;\n     BOOST_CHECK(addr.IsValid());\n     BOOST_CHECK(addr.IsIPv4());\n@@ -397,35 +397,35 @@ BOOST_AUTO_TEST_CASE(cnetaddr_unserialize_v2)\n     BOOST_REQUIRE(s.empty());\n \n     // Invalid IPv4, valid length but address itself is shorter.\n-    s << MakeSpan(ParseHex(\"01\"      // network type (IPv4)\n-                           \"04\"      // address length\n-                           \"0102\")); // address\n+    s << Span{ParseHex(\"01\"      // network type (IPv4)\n+                       \"04\"      // address length\n+                       \"0102\")}; // address\n     BOOST_CHECK_EXCEPTION(s >> addr, std::ios_base::failure, HasReason(\"end of data\"));\n     BOOST_REQUIRE(!s.empty()); // The stream is not consumed on invalid input.\n     s.clear();\n \n     // Invalid IPv4, with bogus length.\n-    s << MakeSpan(ParseHex(\"01\"          // network type (IPv4)\n-                           \"05\"          // address length\n-                           \"01020304\")); // address\n+    s << Span{ParseHex(\"01\"          // network type (IPv4)\n+                       \"05\"          // address length\n+                       \"01020304\")}; // address\n     BOOST_CHECK_EXCEPTION(s >> addr, std::ios_base::failure,\n                           HasReason(\"BIP155 IPv4 address with length 5 (should be 4)\"));\n     BOOST_REQUIRE(!s.empty()); // The stream is not consumed on invalid input.\n     s.clear();\n \n     // Invalid IPv4, with extreme length.\n-    s << MakeSpan(ParseHex(\"01\"          // network type (IPv4)\n-                           \"fd0102\"      // address length (513 as CompactSize)\n-                           \"01020304\")); // address\n+    s << Span{ParseHex(\"01\"          // network type (IPv4)\n+                       \"fd0102\"      // address length (513 as CompactSize)\n+                       \"01020304\")}; // address\n     BOOST_CHECK_EXCEPTION(s >> addr, std::ios_base::failure,\n                           HasReason(\"Address too long: 513 > 512\"));\n     BOOST_REQUIRE(!s.empty()); // The stream is not consumed on invalid input.\n     s.clear();\n \n     // Valid IPv6.\n-    s << MakeSpan(ParseHex(\"02\"                                  // network type (IPv6)\n-                           \"10\"                                  // address length\n-                           \"0102030405060708090a0b0c0d0e0f10\")); // address\n+    s << Span{ParseHex(\"02\"                                  // network type (IPv6)\n+                       \"10\"                                  // address length\n+                       \"0102030405060708090a0b0c0d0e0f10\")}; // address\n     s >> addr;\n     BOOST_CHECK(addr.IsValid());\n     BOOST_CHECK(addr.IsIPv6());\n@@ -434,10 +434,10 @@ BOOST_AUTO_TEST_CASE(cnetaddr_unserialize_v2)\n     BOOST_REQUIRE(s.empty());\n \n     // Valid IPv6, contains embedded \"internal\".\n-    s << MakeSpan(ParseHex(\n+    s << Span{ParseHex(\n         \"02\"                                  // network type (IPv6)\n         \"10\"                                  // address length\n-        \"fd6b88c08724ca978112ca1bbdcafac2\")); // address: 0xfd + sha256(\"bitcoin\")[0:5] +\n+        \"fd6b88c08724ca978112ca1bbdcafac2\")}; // address: 0xfd + sha256(\"bitcoin\")[0:5] +\n                                               // sha256(name)[0:10]\n     s >> addr;\n     BOOST_CHECK(addr.IsInternal());\n@@ -446,44 +446,44 @@ BOOST_AUTO_TEST_CASE(cnetaddr_unserialize_v2)\n     BOOST_REQUIRE(s.empty());\n \n     // Invalid IPv6, with bogus length.\n-    s << MakeSpan(ParseHex(\"02\"    // network type (IPv6)\n-                           \"04\"    // address length\n-                           \"00\")); // address\n+    s << Span{ParseHex(\"02\"    // network type (IPv6)\n+                       \"04\"    // address length\n+                       \"00\")}; // address\n     BOOST_CHECK_EXCEPTION(s >> addr, std::ios_base::failure,\n                           HasReason(\"BIP155 IPv6 address with length 4 (should be 16)\"));\n     BOOST_REQUIRE(!s.empty()); // The stream is not consumed on invalid input.\n     s.clear();\n \n     // Invalid IPv6, contains embedded IPv4.\n-    s << MakeSpan(ParseHex(\"02\"                                  // network type (IPv6)\n-                           \"10\"                                  // address length\n-                           \"00000000000000000000ffff01020304\")); // address\n+    s << Span{ParseHex(\"02\"                                  // network type (IPv6)\n+                       \"10\"                                  // address length\n+                       \"00000000000000000000ffff01020304\")}; // address\n     s >> addr;\n     BOOST_CHECK(!addr.IsValid());\n     BOOST_REQUIRE(s.empty());\n \n     // Invalid IPv6, contains embedded TORv2.\n-    s << MakeSpan(ParseHex(\"02\"                                  // network type (IPv6)\n-                           \"10\"                                  // address length\n-                           \"fd87d87eeb430102030405060708090a\")); // address\n+    s << Span{ParseHex(\"02\"                                  // network type (IPv6)\n+                       \"10\"                                  // address length\n+                       \"fd87d87eeb430102030405060708090a\")}; // address\n     s >> addr;\n     BOOST_CHECK(!addr.IsValid());\n     BOOST_REQUIRE(s.empty());\n \n     // TORv2, no longer supported.\n-    s << MakeSpan(ParseHex(\"03\"                      // network type (TORv2)\n-                           \"0a\"                      // address length\n-                           \"f1f2f3f4f5f6f7f8f9fa\")); // address\n+    s << Span{ParseHex(\"03\"                      // network type (TORv2)\n+                       \"0a\"                      // address length\n+                       \"f1f2f3f4f5f6f7f8f9fa\")}; // address\n     s >> addr;\n     BOOST_CHECK(!addr.IsValid());\n     BOOST_REQUIRE(s.empty());\n \n     // Valid TORv3.\n-    s << MakeSpan(ParseHex(\"04\"                               // network type (TORv3)\n-                           \"20\"                               // address length\n-                           \"79bcc625184b05194975c28b66b66b04\" // address\n-                           \"69f7f6556fb1ac3189a79b40dda32f1f\"\n-                           ));\n+    s << Span{ParseHex(\"04\"                               // network type (TORv3)\n+                       \"20\"                               // address length\n+                       \"79bcc625184b05194975c28b66b66b04\" // address\n+                       \"69f7f6556fb1ac3189a79b40dda32f1f\"\n+                       )};\n     s >> addr;\n     BOOST_CHECK(addr.IsValid());\n     BOOST_CHECK(addr.IsTor());\n@@ -493,20 +493,20 @@ BOOST_AUTO_TEST_CASE(cnetaddr_unserialize_v2)\n     BOOST_REQUIRE(s.empty());\n \n     // Invalid TORv3, with bogus length.\n-    s << MakeSpan(ParseHex(\"04\" // network type (TORv3)\n-                           \"00\" // address length\n-                           \"00\" // address\n-                           ));\n+    s << Span{ParseHex(\"04\" // network type (TORv3)\n+                       \"00\" // address length\n+                       \"00\" // address\n+                       )};\n     BOOST_CHECK_EXCEPTION(s >> addr, std::ios_base::failure,\n                           HasReason(\"BIP155 TORv3 address with length 0 (should be 32)\"));\n     BOOST_REQUIRE(!s.empty()); // The stream is not consumed on invalid input.\n     s.clear();\n \n     // Valid I2P.\n-    s << MakeSpan(ParseHex(\"05\"                               // network type (I2P)\n-                           \"20\"                               // address length\n-                           \"a2894dabaec08c0051a481a6dac88b64\" // address\n-                           \"f98232ae42d4b6fd2fa81952dfe36a87\"));\n+    s << Span{ParseHex(\"05\"                               // network type (I2P)\n+                       \"20\"                               // address length\n+                       \"a2894dabaec08c0051a481a6dac88b64\" // address\n+                       \"f98232ae42d4b6fd2fa81952dfe36a87\")};\n     s >> addr;\n     BOOST_CHECK(addr.IsValid());\n     BOOST_CHECK(addr.IsI2P());\n@@ -516,20 +516,20 @@ BOOST_AUTO_TEST_CASE(cnetaddr_unserialize_v2)\n     BOOST_REQUIRE(s.empty());\n \n     // Invalid I2P, with bogus length.\n-    s << MakeSpan(ParseHex(\"05\" // network type (I2P)\n-                           \"03\" // address length\n-                           \"00\" // address\n-                           ));\n+    s << Span{ParseHex(\"05\" // network type (I2P)\n+                       \"03\" // address length\n+                       \"00\" // address\n+                       )};\n     BOOST_CHECK_EXCEPTION(s >> addr, std::ios_base::failure,\n                           HasReason(\"BIP155 I2P address with length 3 (should be 32)\"));\n     BOOST_REQUIRE(!s.empty()); // The stream is not consumed on invalid input.\n     s.clear();\n \n     // Valid CJDNS.\n-    s << MakeSpan(ParseHex(\"06\"                               // network type (CJDNS)\n-                           \"10\"                               // address length\n-                           \"fc000001000200030004000500060007\" // address\n-                           ));\n+    s << Span{ParseHex(\"06\"                               // network type (CJDNS)\n+                       \"10\"                               // address length\n+                       \"fc000001000200030004000500060007\" // address\n+                       )};\n     s >> addr;\n     BOOST_CHECK(addr.IsValid());\n     BOOST_CHECK(addr.IsCJDNS());\n@@ -538,49 +538,49 @@ BOOST_AUTO_TEST_CASE(cnetaddr_unserialize_v2)\n     BOOST_REQUIRE(s.empty());\n \n     // Invalid CJDNS, wrong prefix.\n-    s << MakeSpan(ParseHex(\"06\"                               // network type (CJDNS)\n-                           \"10\"                               // address length\n-                           \"aa000001000200030004000500060007\" // address\n-                           ));\n+    s << Span{ParseHex(\"06\"                               // network type (CJDNS)\n+                       \"10\"                               // address length\n+                       \"aa000001000200030004000500060007\" // address\n+                       )};\n     s >> addr;\n     BOOST_CHECK(addr.IsCJDNS());\n     BOOST_CHECK(!addr.IsValid());\n     BOOST_REQUIRE(s.empty());\n \n     // Invalid CJDNS, with bogus length.\n-    s << MakeSpan(ParseHex(\"06\" // network type (CJDNS)\n-                           \"01\" // address length\n-                           \"00\" // address\n-                           ));\n+    s << Span{ParseHex(\"06\" // network type (CJDNS)\n+                       \"01\" // address length\n+                       \"00\" // address\n+                       )};\n     BOOST_CHECK_EXCEPTION(s >> addr, std::ios_base::failure,\n                           HasReason(\"BIP155 CJDNS address with length 1 (should be 16)\"));\n     BOOST_REQUIRE(!s.empty()); // The stream is not consumed on invalid input.\n     s.clear();\n \n     // Unknown, with extreme length.\n-    s << MakeSpan(ParseHex(\"aa\"             // network type (unknown)\n-                           \"fe00000002\"     // address length (CompactSize's MAX_SIZE)\n-                           \"01020304050607\" // address\n-                           ));\n+    s << Span{ParseHex(\"aa\"             // network type (unknown)\n+                       \"fe00000002\"     // address length (CompactSize's MAX_SIZE)\n+                       \"01020304050607\" // address\n+                       )};\n     BOOST_CHECK_EXCEPTION(s >> addr, std::ios_base::failure,\n                           HasReason(\"Address too long: 33554432 > 512\"));\n     BOOST_REQUIRE(!s.empty()); // The stream is not consumed on invalid input.\n     s.clear();\n \n     // Unknown, with reasonable length.\n-    s << MakeSpan(ParseHex(\"aa\"       // network type (unknown)\n-                           \"04\"       // address length\n-                           \"01020304\" // address\n-                           ));\n+    s << Span{ParseHex(\"aa\"       // network type (unknown)\n+                       \"04\"       // address length\n+                       \"01020304\" // address\n+                       )};\n     s >> addr;\n     BOOST_CHECK(!addr.IsValid());\n     BOOST_REQUIRE(s.empty());\n \n     // Unknown, with zero length.\n-    s << MakeSpan(ParseHex(\"aa\" // network type (unknown)\n-                           \"00\" // address length\n-                           \"\"   // address\n-                           ));\n+    s << Span{ParseHex(\"aa\" // network type (unknown)\n+                       \"00\" // address length\n+                       \"\"   // address\n+                       )};\n     s >> addr;\n     BOOST_CHECK(!addr.IsValid());\n     BOOST_REQUIRE(s.empty());"
      },
      {
        "sha": "73c3a63c08ce40a813f57c78e44f30c468d333e8",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/568dd2f83900a11a4dbba1250722791a135bf0a9/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/568dd2f83900a11a4dbba1250722791a135bf0a9/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=568dd2f83900a11a4dbba1250722791a135bf0a9",
        "patch": "@@ -284,7 +284,7 @@ class TestBuilder\n         CScript scriptPubKey = script;\n         if (wm == WitnessMode::PKH) {\n             uint160 hash;\n-            CHash160().Write(MakeSpan(script).subspan(1)).Finalize(hash);\n+            CHash160().Write(Span{script}.subspan(1)).Finalize(hash);\n             script = CScript() << OP_DUP << OP_HASH160 << ToByteVector(hash) << OP_EQUALVERIFY << OP_CHECKSIG;\n             scriptPubKey = CScript() << witnessversion << ToByteVector(hash);\n         } else if (wm == WitnessMode::SH) {\n@@ -1812,7 +1812,7 @@ BOOST_AUTO_TEST_CASE(bip341_keypath_test_vectors)\n             BOOST_CHECK_EQUAL(HexStr(sighash), input[\"intermediary\"][\"sigHash\"].get_str());\n \n             // To verify the sigmsg, hash the expected sigmsg, and compare it with the (expected) sighash.\n-            BOOST_CHECK_EQUAL(HexStr((CHashWriter(HASHER_TAPSIGHASH) << MakeSpan(ParseHex(input[\"intermediary\"][\"sigMsg\"].get_str()))).GetSHA256()), input[\"intermediary\"][\"sigHash\"].get_str());\n+            BOOST_CHECK_EQUAL(HexStr((CHashWriter(HASHER_TAPSIGHASH) << Span{ParseHex(input[\"intermediary\"][\"sigMsg\"].get_str())}).GetSHA256()), input[\"intermediary\"][\"sigHash\"].get_str());\n         }\n \n     }"
      },
      {
        "sha": "644333278677665f81fae14843afd07a7fece750",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/568dd2f83900a11a4dbba1250722791a135bf0a9/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/568dd2f83900a11a4dbba1250722791a135bf0a9/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=568dd2f83900a11a4dbba1250722791a135bf0a9",
        "patch": "@@ -4937,5 +4937,5 @@ static const CRPCCommand commands[] =\n     { \"wallet\",             &walletprocesspsbt,              },\n };\n // clang-format on\n-    return MakeSpan(commands);\n+    return Span{commands};\n }"
      }
    ]
  },
  {
    "sha": "11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3",
    "node_id": "C_kwDOABII59oAKDExZGFmNmNlYjFkOWVhMWY4ZDYzOGIxMjNlZWNmZTM5ZDE2MmE3YzM",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-11-02T14:07:46Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-11-29T22:59:44Z"
      },
      "message": "More Span simplifications\n\nBased on suggestions by MarcoFalke <falke.marco@gmail.com>",
      "tree": {
        "sha": "04577b15fa2b9dbbf611377c5a0e23bf2a705768",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/04577b15fa2b9dbbf611377c5a0e23bf2a705768"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "568dd2f83900a11a4dbba1250722791a135bf0a9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/568dd2f83900a11a4dbba1250722791a135bf0a9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/568dd2f83900a11a4dbba1250722791a135bf0a9"
      }
    ],
    "stats": {
      "total": 41,
      "additions": 20,
      "deletions": 21
    },
    "files": [
      {
        "sha": "f8b73cdc6ba45431f87f60c02fa739b796b76f79",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3",
        "patch": "@@ -760,7 +760,7 @@ CNetMessage V1TransportDeserializer::GetMessage(const std::chrono::microseconds\n     if (memcmp(hash.begin(), hdr.pchChecksum, CMessageHeader::CHECKSUM_SIZE) != 0) {\n         LogPrint(BCLog::NET, \"Header error: Wrong checksum (%s, %u bytes), expected %s was %s, peer=%d\\n\",\n                  SanitizeString(msg.m_command), msg.m_message_size,\n-                 HexStr(Span<uint8_t>(hash.begin(), hash.begin() + CMessageHeader::CHECKSUM_SIZE)),\n+                 HexStr(Span{hash}.first(CMessageHeader::CHECKSUM_SIZE)),\n                  HexStr(hdr.pchChecksum),\n                  m_node_id);\n         reject_message = true;\n@@ -1582,8 +1582,9 @@ void CConnman::SocketHandlerConnected(const std::vector<CNode*>& nodes,\n             if (nBytes > 0)\n             {\n                 bool notify = false;\n-                if (!pnode->ReceiveMsgBytes(Span<const uint8_t>(pchBuf, nBytes), notify))\n+                if (!pnode->ReceiveMsgBytes({pchBuf, (size_t)nBytes}, notify)) {\n                     pnode->CloseSocketDisconnect();\n+                }\n                 RecordBytesRecv(nBytes);\n                 if (notify) {\n                     size_t nSizeAdded = 0;"
      },
      {
        "sha": "f6bc7fbb944673d81482bc419e57b3a74d64ef8a",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3",
        "patch": "@@ -303,7 +303,7 @@ CNetAddr::CNetAddr(const struct in_addr& ipv4Addr)\n \n CNetAddr::CNetAddr(const struct in6_addr& ipv6Addr, const uint32_t scope)\n {\n-    SetLegacyIPv6(Span<const uint8_t>(reinterpret_cast<const uint8_t*>(&ipv6Addr), sizeof(ipv6Addr)));\n+    SetLegacyIPv6({reinterpret_cast<const uint8_t*>(&ipv6Addr), sizeof(ipv6Addr)});\n     m_scope_id = scope;\n }\n "
      },
      {
        "sha": "2453c92d92d49c0d6ddb3ffe66f895b8f24d8986",
        "filename": "src/pubkey.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3/src/pubkey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3/src/pubkey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.h?ref=11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3",
        "patch": "@@ -240,7 +240,7 @@ class XOnlyPubKey\n     explicit XOnlyPubKey(Span<const unsigned char> bytes);\n \n     /** Construct an x-only pubkey from a normal pubkey. */\n-    explicit XOnlyPubKey(const CPubKey& pubkey) : XOnlyPubKey(Span<const unsigned char>(pubkey.begin() + 1, pubkey.begin() + 33)) {}\n+    explicit XOnlyPubKey(const CPubKey& pubkey) : XOnlyPubKey(Span{pubkey}.subspan(1, 32)) {}\n \n     /** Verify a Schnorr signature against this public key.\n      *"
      },
      {
        "sha": "683cf88af80497d0550fe148737b371580c373b8",
        "filename": "src/rpc/util.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3/src/rpc/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3/src/rpc/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.cpp?ref=11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3",
        "patch": "@@ -317,7 +317,7 @@ class DescribeAddressVisitor\n         UniValue obj(UniValue::VOBJ);\n         obj.pushKV(\"iswitness\", true);\n         obj.pushKV(\"witness_version\", (int)id.version);\n-        obj.pushKV(\"witness_program\", HexStr(Span<const unsigned char>(id.program, id.length)));\n+        obj.pushKV(\"witness_program\", HexStr({id.program, id.length}));\n         return obj;\n     }\n };"
      },
      {
        "sha": "30f929664f1b18f725fbb7d60fd9c3c3c7296bcf",
        "filename": "src/script/descriptor.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3/src/script/descriptor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3/src/script/descriptor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.cpp?ref=11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3",
        "patch": "@@ -1252,7 +1252,7 @@ std::unique_ptr<PubkeyProvider> InferXOnlyPubkey(const XOnlyPubKey& xkey, ParseS\n std::unique_ptr<DescriptorImpl> InferScript(const CScript& script, ParseScriptContext ctx, const SigningProvider& provider)\n {\n     if (ctx == ParseScriptContext::P2TR && script.size() == 34 && script[0] == 32 && script[33] == OP_CHECKSIG) {\n-        XOnlyPubKey key{Span<const unsigned char>{script.data() + 1, script.data() + 33}};\n+        XOnlyPubKey key{Span{script}.subspan(1, 32)};\n         return std::make_unique<PKDescriptor>(InferXOnlyPubkey(key, ctx, provider));\n     }\n "
      },
      {
        "sha": "6433ba1b58fbdff9c6973c6eb926936b49bf7881",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3",
        "patch": "@@ -1858,7 +1858,7 @@ uint256 ComputeTaprootMerkleRoot(Span<const unsigned char> control, const uint25\n     uint256 k = tapleaf_hash;\n     for (int i = 0; i < path_len; ++i) {\n         CHashWriter ss_branch{HASHER_TAPBRANCH};\n-        Span<const unsigned char> node(control.data() + TAPROOT_CONTROL_BASE_SIZE + TAPROOT_CONTROL_NODE_SIZE * i, TAPROOT_CONTROL_NODE_SIZE);\n+        Span node{Span{control}.subspan(TAPROOT_CONTROL_BASE_SIZE + TAPROOT_CONTROL_NODE_SIZE * i, TAPROOT_CONTROL_NODE_SIZE)};\n         if (std::lexicographical_compare(k.begin(), k.end(), node.begin(), node.end())) {\n             ss_branch << k << node;\n         } else {\n@@ -1874,7 +1874,7 @@ static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, c\n     assert(control.size() >= TAPROOT_CONTROL_BASE_SIZE);\n     assert(program.size() >= uint256::size());\n     //! The internal pubkey (x-only, so no Y coordinate parity).\n-    const XOnlyPubKey p{Span<const unsigned char>{control.data() + 1, control.data() + TAPROOT_CONTROL_BASE_SIZE}};\n+    const XOnlyPubKey p{Span{control}.subspan(1, TAPROOT_CONTROL_BASE_SIZE - 1)};\n     //! The output pubkey (taken from the scriptPubKey).\n     const XOnlyPubKey q{program};\n     // Compute the Merkle root from the leaf and the provided path.\n@@ -1886,7 +1886,7 @@ static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, c\n static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror, bool is_p2sh)\n {\n     CScript exec_script; //!< Actually executed script (last stack item in P2WSH; implied P2PKH script in P2WPKH; leaf script in P2TR)\n-    Span<const valtype> stack{witness.stack};\n+    Span stack{witness.stack};\n     ScriptExecutionData execdata;\n \n     if (witversion == 0) {"
      },
      {
        "sha": "40d6ae2f3c3aef767f5c3993f08fb3cbe7dde079",
        "filename": "src/signet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3/src/signet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3/src/signet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/signet.cpp?ref=11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3",
        "patch": "@@ -38,7 +38,7 @@ static bool FetchAndClearCommitmentSection(const Span<const uint8_t> header, CSc\n     std::vector<uint8_t> pushdata;\n     while (witness_commitment.GetOp(pc, opcode, pushdata)) {\n         if (pushdata.size() > 0) {\n-            if (!found_header && pushdata.size() > (size_t) header.size() && Span<const uint8_t>(pushdata.data(), header.size()) == header) {\n+            if (!found_header && pushdata.size() > (size_t)header.size() && Span{pushdata}.first(header.size()) == header) {\n                 // pushdata only counts if it has the header _and_ some data\n                 result.insert(result.end(), pushdata.begin() + header.size(), pushdata.end());\n                 pushdata.erase(pushdata.begin() + header.size(), pushdata.end());"
      },
      {
        "sha": "6703e889c5db78f1e6f4e6ffd257cd1f318cedd5",
        "filename": "src/span.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3/src/span.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3/src/span.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/span.h?ref=11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3",
        "patch": "@@ -258,12 +258,12 @@ Span<std::byte> AsWritableBytes(Span<T> s) noexcept\n template <typename V>\n Span<const std::byte> MakeByteSpan(V&& v) noexcept\n {\n-    return AsBytes(MakeSpan(std::forward<V>(v)));\n+    return AsBytes(Span{std::forward<V>(v)});\n }\n template <typename V>\n Span<std::byte> MakeWritableByteSpan(V&& v) noexcept\n {\n-    return AsWritableBytes(MakeSpan(std::forward<V>(v)));\n+    return AsWritableBytes(Span{std::forward<V>(v)});\n }\n \n // Helper functions to safely cast to unsigned char pointers."
      },
      {
        "sha": "c5e9c560498a2b315632f31aa65a60bbef789341",
        "filename": "src/test/fuzz/asmap.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3/src/test/fuzz/asmap.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3/src/test/fuzz/asmap.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/asmap.cpp?ref=11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3",
        "patch": "@@ -49,7 +49,7 @@ FUZZ_TARGET(asmap)\n     CNetAddr net_addr;\n     if (ipv6) {\n         assert(addr_size == ADDR_IPV6_SIZE);\n-        net_addr.SetLegacyIPv6(Span<const uint8_t>(addr_data, addr_size));\n+        net_addr.SetLegacyIPv6({addr_data, addr_size});\n     } else {\n         assert(addr_size == ADDR_IPV4_SIZE);\n         in_addr ipv4;"
      },
      {
        "sha": "d625403fa0af6f8ed98962323d2995fcfebbec76",
        "filename": "src/test/fuzz/utxo_snapshot.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3/src/test/fuzz/utxo_snapshot.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3/src/test/fuzz/utxo_snapshot.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/utxo_snapshot.cpp?ref=11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3",
        "patch": "@@ -38,7 +38,7 @@ FUZZ_TARGET_INIT(utxo_snapshot, initialize_chain)\n     {\n         CAutoFile outfile{fsbridge::fopen(snapshot_path, \"wb\"), SER_DISK, CLIENT_VERSION};\n         const auto file_data{ConsumeRandomLengthByteVector(fuzzed_data_provider)};\n-        outfile << Span<const uint8_t>{file_data};\n+        outfile << Span{file_data};\n     }\n \n     const auto ActivateFuzzedSnapshot{[&] {"
      },
      {
        "sha": "02268dbcf5ce704a2e4c4300607bd673ae45750d",
        "filename": "src/test/key_io_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3/src/test/key_io_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3/src/test/key_io_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/key_io_tests.cpp?ref=11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3",
        "patch": "@@ -46,7 +46,7 @@ BOOST_AUTO_TEST_CASE(key_io_valid_parse)\n             privkey = DecodeSecret(exp_base58string);\n             BOOST_CHECK_MESSAGE(privkey.IsValid(), \"!IsValid:\" + strTest);\n             BOOST_CHECK_MESSAGE(privkey.IsCompressed() == isCompressed, \"compressed mismatch:\" + strTest);\n-            BOOST_CHECK_MESSAGE(Span<const uint8_t>{privkey} == Span<const uint8_t>{exp_payload}, \"key mismatch:\" + strTest);\n+            BOOST_CHECK_MESSAGE(Span{privkey} == Span{exp_payload}, \"key mismatch:\" + strTest);\n \n             // Private key must be invalid public key\n             destination = DecodeDestination(exp_base58string);"
      },
      {
        "sha": "9540cead24bd242f8769f739cca82598bb2d93b5",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3",
        "patch": "@@ -142,13 +142,11 @@ BOOST_AUTO_TEST_CASE(util_HexStr)\n         \"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\");\n \n     BOOST_CHECK_EQUAL(\n-        HexStr(Span<const unsigned char>(\n-               ParseHex_expected + sizeof(ParseHex_expected),\n-               ParseHex_expected + sizeof(ParseHex_expected))),\n+        HexStr(Span{ParseHex_expected}.last(0)),\n         \"\");\n \n     BOOST_CHECK_EQUAL(\n-        HexStr(Span<const unsigned char>(ParseHex_expected, ParseHex_expected)),\n+        HexStr(Span{ParseHex_expected}.first(0)),\n         \"\");\n \n     {"
      },
      {
        "sha": "65459557cbfe876cfea558593f8857f1744db802",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3",
        "patch": "@@ -35,7 +35,7 @@ std::string static EncodeDumpString(const std::string &str) {\n     std::stringstream ret;\n     for (const unsigned char c : str) {\n         if (c <= 32 || c >= 128 || c == '%') {\n-            ret << '%' << HexStr(Span<const unsigned char>(&c, 1));\n+            ret << '%' << HexStr({&c, 1});\n         } else {\n             ret << c;\n         }"
      },
      {
        "sha": "171ec8ae80beef3f6168eaa85cdf3a7401b330f1",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=11daf6ceb1d9ea1f8d638b123eecfe39d162a7c3",
        "patch": "@@ -4937,5 +4937,5 @@ static const CRPCCommand commands[] =\n     { \"wallet\",             &walletprocesspsbt,              },\n };\n // clang-format on\n-    return Span{commands};\n+    return commands;\n }"
      }
    ]
  }
]