[
  {
    "sha": "af3ae0a2527f25267062f106a9e6507e380bb41e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphZjNhZTBhMjUyN2YyNTI2NzA2MmYxMDZhOWU2NTA3ZTM4MGJiNDFl",
    "commit": {
      "author": {
        "name": "Gregory Sanders",
        "email": "gsanders87@gmail.com",
        "date": "2018-06-12T18:04:52Z"
      },
      "committer": {
        "name": "Gregory Sanders",
        "email": "gsanders87@gmail.com",
        "date": "2018-06-12T18:15:15Z"
      },
      "message": "support new multisig template in wallet for Solver, signing, and signature combining",
      "tree": {
        "sha": "3d7d7b5022cf6fdae5cae1c8e649191d5cb7cd25",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3d7d7b5022cf6fdae5cae1c8e649191d5cb7cd25"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/af3ae0a2527f25267062f106a9e6507e380bb41e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af3ae0a2527f25267062f106a9e6507e380bb41e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/af3ae0a2527f25267062f106a9e6507e380bb41e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af3ae0a2527f25267062f106a9e6507e380bb41e/comments",
    "author": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a607d23ae82ee374799d21d02932d945c1ce9616",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a607d23ae82ee374799d21d02932d945c1ce9616",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a607d23ae82ee374799d21d02932d945c1ce9616"
      }
    ],
    "stats": {
      "total": 168,
      "additions": 168,
      "deletions": 0
    },
    "files": [
      {
        "sha": "78ce1fbe1f1dbd168f42f84f046bc7cea68e4e0d",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 81,
        "deletions": 0,
        "changes": 81,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/af3ae0a2527f25267062f106a9e6507e380bb41e/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/af3ae0a2527f25267062f106a9e6507e380bb41e/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=af3ae0a2527f25267062f106a9e6507e380bb41e",
        "patch": "@@ -56,6 +56,24 @@ static bool SignN(const SigningProvider& provider, const std::vector<valtype>& m\n     return nSigned==nRequired;\n }\n \n+static bool SignLargeN(const SigningProvider& provider, const std::vector<valtype>& multisigdata, const BaseSignatureCreator& creator, const CScript& scriptCode, std::vector<valtype>& ret, SigVersion sigversion)\n+{\n+    int nSigned = 0;\n+    int nRequired = multisigdata.back()[0];\n+    for (unsigned int i = 1; i < multisigdata.size()-1; i++)\n+    {\n+        const valtype& pubkey = multisigdata[i];\n+        CKeyID keyID = CPubKey(pubkey).GetID();\n+        if (Sign1(provider, keyID, creator, scriptCode, ret, sigversion)) {\n+            ++nSigned;\n+        } else {\n+            ret.push_back(valtype());\n+        }\n+    }\n+    std::reverse(std::begin(ret), std::end(ret));\n+    return nSigned==nRequired;\n+}\n+\n /**\n  * Sign scriptPubKey using signature made with creator.\n  * Signatures are returned in scriptSigRet (or returns false if scriptPubKey can't be signed),\n@@ -105,6 +123,9 @@ static bool SignStep(const SigningProvider& provider, const BaseSignatureCreator\n         ret.push_back(valtype()); // workaround CHECKMULTISIG bug\n         return (SignN(provider, vSolutions, creator, scriptPubKey, ret, sigversion));\n \n+    case TX_LARGE_MULTISIG:\n+        return SignLargeN(provider, vSolutions, creator, scriptPubKey, ret, sigversion);\n+\n     case TX_WITNESS_V0_KEYHASH:\n         ret.push_back(vSolutions[0]);\n         return true;\n@@ -276,6 +297,64 @@ static std::vector<valtype> CombineMultisig(const CScript& scriptPubKey, const B\n     return result;\n }\n \n+static std::vector<valtype> CombineLargeMultisig(const CScript& scriptPubKey, const BaseSignatureChecker& checker,\n+                               const std::vector<valtype>& vSolutions,\n+                               const std::vector<valtype>& sigs1, const std::vector<valtype>& sigs2, SigVersion sigversion)\n+{\n+    // Combine all the signatures we've got:\n+    std::set<valtype> allsigs;\n+    for (const valtype& v : sigs1)\n+    {\n+        if (!v.empty())\n+            allsigs.insert(v);\n+    }\n+    for (const valtype& v : sigs2)\n+    {\n+        if (!v.empty())\n+            allsigs.insert(v);\n+    }\n+\n+    // Build a map of pubkey -> signature by matching sigs to pubkeys:\n+    assert(vSolutions.size() > 1);\n+    unsigned int nSigsRequired = vSolutions.back()[0];\n+    unsigned int nPubKeys = vSolutions.size()-2;\n+    std::map<valtype, valtype> sigs;\n+    for (const valtype& sig : allsigs)\n+    {\n+        for (unsigned int i = 0; i < nPubKeys; i++)\n+        {\n+            const valtype& pubkey = vSolutions[i];\n+            if (sigs.count(pubkey))\n+                continue; // Already got a sig for this pubkey\n+\n+            if (checker.CheckSig(sig, pubkey, scriptPubKey, sigversion))\n+            {\n+                sigs[pubkey] = sig;\n+                break;\n+            }\n+        }\n+    }\n+    // Now build a merged CScript:\n+    unsigned int nSigsHave = 0;\n+    std::vector<valtype> result; result.push_back(valtype()); // pop-one-too-many workaround\n+    for (unsigned int i = 0; i < nPubKeys && nSigsHave < nSigsRequired; i++)\n+    {\n+        if (sigs.count(vSolutions[i]) && nSigsHave < nSigsRequired)\n+        {\n+            result.push_back(sigs[vSolutions[i]]);\n+            ++nSigsHave;\n+        } else {\n+            result.push_back(valtype());\n+        }\n+    }\n+\n+    // Sigs are in \"reverse\" order compared to OP_CHECKMULTISIG(VERIFY)\n+    std::reverse(std::begin(result), std::end(result));\n+\n+    return result;\n+}\n+\n+\n namespace\n {\n struct Stacks\n@@ -344,6 +423,8 @@ static Stacks CombineSignatures(const CScript& scriptPubKey, const BaseSignature\n         }\n     case TX_MULTISIG:\n         return Stacks(CombineMultisig(scriptPubKey, checker, vSolutions, sigs1.script, sigs2.script, sigversion));\n+    case TX_LARGE_MULTISIG:\n+        return Stacks(CombineLargeMultisig(scriptPubKey, checker, vSolutions, sigs1.script, sigs2.script, sigversion));\n     case TX_WITNESS_V0_SCRIPTHASH:\n         if (sigs1.witness.empty() || sigs1.witness.back().empty())\n             return sigs2;"
      },
      {
        "sha": "571021b14a605f297652c0bc913246ec0e2609dc",
        "filename": "src/script/standard.cpp",
        "status": "modified",
        "additions": 86,
        "deletions": 0,
        "changes": 86,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/af3ae0a2527f25267062f106a9e6507e380bb41e/src/script/standard.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/af3ae0a2527f25267062f106a9e6507e380bb41e/src/script/standard.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.cpp?ref=af3ae0a2527f25267062f106a9e6507e380bb41e",
        "patch": "@@ -35,6 +35,87 @@ const char* GetTxnOutputType(txnouttype t)\n     return nullptr;\n }\n \n+static bool IsSmallishInteger(const opcodetype& opcode, const valtype& data, unsigned int& value)\n+{\n+    if (opcode >= OP_1 && opcode <= OP_16) {\n+        value = CScript::DecodeOP_N(opcode);\n+        return true;\n+    }\n+    if (opcode == 1 && data[0] >= 17 && data[0] <= 67) {\n+        value = data[0];\n+        return true;\n+    }\n+    return false;\n+}\n+\n+/* Script of the form:\n+ *\n+ * <pubkey1> OP_CHECKSIG\n+ * OP_SWAP <pubkey2> OP_CHECKSIG OP_ADD\n+ * OP_SWAP <pubkey3> OP_CHECKSIG OP_ADD\n+ * ...\n+ * OP_SWAP <pubkey67> OP_CHECKSIG OP_ADD\n+ * <m> OP_NUMEQUAL\n+ */\n+bool IsLargeMultisig(const CScript& script, std::vector<std::vector<unsigned char> >& solutions) {\n+    opcodetype opcode;\n+    std::vector<unsigned char> vch;\n+    CScript::const_iterator pc = script.begin();\n+\n+    // First pubkey/checksig/swap\n+    if (!script.GetOp(pc, opcode, vch) || vch.size() != 33) {\n+        return false;\n+    }\n+    solutions.push_back(vch);\n+    if (!script.GetOp(pc, opcode, vch) || opcode != OP_CHECKSIG) {\n+        return false;\n+    }\n+\n+    // Repeated pubkey/checksig/op_add/swaps\n+    while (true) {\n+\n+        if (!script.GetOp(pc, opcode, vch)) {\n+            return false;\n+        }\n+\n+        // Might just be <m>, break\n+        if (opcode != OP_SWAP) {\n+            break;\n+        }\n+\n+        if (!script.GetOp(pc, opcode, vch) || vch.size() != 33) {\n+            return false;\n+        }\n+        solutions.push_back(vch);\n+\n+        if (!script.GetOp(pc, opcode, vch) || opcode != OP_CHECKSIG) {\n+            return false;\n+        }\n+\n+        if (!script.GetOp(pc, opcode, vch) || opcode != OP_ADD) {\n+            return false;\n+        }\n+\n+    }\n+\n+    unsigned int value;\n+    if (!IsSmallishInteger(opcode, vch, value)) {\n+         return false;\n+    }\n+\n+    if (value > solutions.size()) {\n+        return false;\n+    }\n+\n+    solutions.push_back({static_cast<unsigned char>(value)});\n+\n+    if (!script.GetOp(pc, opcode, vch) || opcode != OP_NUMEQUAL) {\n+        return false;\n+    }\n+\n+    return true;\n+}\n+\n static bool MatchPayToPubkey(const CScript& script, valtype& pubkey)\n {\n     if (script.size() == CPubKey::PUBLIC_KEY_SIZE + 2 && script[0] == CPubKey::PUBLIC_KEY_SIZE && script.back() == OP_CHECKSIG) {\n@@ -85,6 +166,11 @@ bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<std::v\n {\n     vSolutionsRet.clear();\n \n+    if (IsLargeMultisig(scriptPubKey, vSolutionsRet)) {\n+        typeRet = TX_LARGE_MULTISIG;\n+        return true;\n+    }\n+\n     // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n     // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL\n     if (scriptPubKey.IsPayToScriptHash())"
      },
      {
        "sha": "13912debbdaa838143919701f93e9df5522f658a",
        "filename": "src/script/standard.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/af3ae0a2527f25267062f106a9e6507e380bb41e/src/script/standard.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/af3ae0a2527f25267062f106a9e6507e380bb41e/src/script/standard.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.h?ref=af3ae0a2527f25267062f106a9e6507e380bb41e",
        "patch": "@@ -61,6 +61,7 @@ enum txnouttype\n     TX_PUBKEYHASH,\n     TX_SCRIPTHASH,\n     TX_MULTISIG,\n+    TX_LARGE_MULTISIG,\n     TX_NULL_DATA, //!< unspendable OP_RETURN script that carries data\n     TX_WITNESS_V0_SCRIPTHASH,\n     TX_WITNESS_V0_KEYHASH,"
      }
    ]
  }
]