[
  {
    "sha": "2a98d704e575ec42dada2dbf40b8fcce5fd7368e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyYTk4ZDcwNGU1NzVlYzQyZGFkYTJkYmY0MGI4ZmNjZTVmZDczNjhl",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2013-11-12T06:46:43Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2013-12-09T01:59:42Z"
      },
      "message": "Save/restore memory pool",
      "tree": {
        "sha": "2c225ff2067b6103bf2ccc3ce2039cb08a43b848",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2c225ff2067b6103bf2ccc3ce2039cb08a43b848"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2a98d704e575ec42dada2dbf40b8fcce5fd7368e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2a98d704e575ec42dada2dbf40b8fcce5fd7368e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2a98d704e575ec42dada2dbf40b8fcce5fd7368e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2a98d704e575ec42dada2dbf40b8fcce5fd7368e/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "70370ae502df8756f3a067a00ccd61b9fc819581",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/70370ae502df8756f3a067a00ccd61b9fc819581",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/70370ae502df8756f3a067a00ccd61b9fc819581"
      }
    ],
    "stats": {
      "total": 340,
      "additions": 329,
      "deletions": 11
    },
    "files": [
      {
        "sha": "406b0c473a57be79857c4f430796cc362070a8ec",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a98d704e575ec42dada2dbf40b8fcce5fd7368e/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a98d704e575ec42dada2dbf40b8fcce5fd7368e/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=2a98d704e575ec42dada2dbf40b8fcce5fd7368e",
        "patch": "@@ -120,6 +120,7 @@ void Shutdown()\n     GenerateBitcoins(false, NULL, 0);\n #endif\n     StopNode();\n+    mempool.Write();\n     {\n         LOCK(cs_main);\n #ifdef ENABLE_WALLET\n@@ -895,6 +896,21 @@ bool AppInit2(boost::thread_group& threadGroup, bool fForceServer)\n         return false;\n     }\n \n+    // It is OK if mempool.Read() fails; starting out with an empty memory pool is not\n+    // a problem, it gets filled quickly.\n+    list<CTxMemPoolEntry> mempoolEntries;\n+    if (mempool.Read(mempoolEntries) && !empty(mempoolEntries))\n+    {\n+        CValidationState valState;\n+        bool fMissingInputs;\n+        BOOST_FOREACH(CTxMemPoolEntry& mempoolEntry, mempoolEntries)\n+        {\n+            AcceptToMemoryPool(mempool, valState, mempoolEntry.GetTx(), false,\n+                               &fMissingInputs, false);\n+        }\n+        LogPrintf(\"Accepted %lu mempool transactions\\n\", mempool.size());\n+    }\n+\n     // ********************************************************* Step 8: load wallet\n #ifdef ENABLE_WALLET\n     if (fDisableWallet) {"
      },
      {
        "sha": "f744dbff1ff6381779b354df113125290dc1bde7",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 9,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a98d704e575ec42dada2dbf40b8fcce5fd7368e/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a98d704e575ec42dada2dbf40b8fcce5fd7368e/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=2a98d704e575ec42dada2dbf40b8fcce5fd7368e",
        "patch": "@@ -1731,7 +1731,6 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n     }\n \n     // Connect longer branch\n-    vector<CTransaction> vDelete;\n     BOOST_FOREACH(CBlockIndex *pindex, vConnect) {\n         CBlock block;\n         if (!ReadBlockFromDisk(block, pindex))\n@@ -1747,9 +1746,12 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n         if (fBenchmark)\n             LogPrintf(\"- Connect: %.2fms\\n\", (GetTimeMicros() - nStart) * 0.001);\n \n-        // Queue memory transactions to delete\n+        // Accepted into block, means remove from memory pool\n         BOOST_FOREACH(const CTransaction& tx, block.vtx)\n-            vDelete.push_back(tx);\n+        {\n+            mempool.remove(tx, false, pindex->nHeight-1);\n+            mempool.removeConflicts(tx);\n+        }\n     }\n \n     // Flush changes to global coin state\n@@ -1792,12 +1794,6 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n             mempool.remove(tx, true);\n     }\n \n-    // Delete redundant memory transactions that are in the connected branch\n-    BOOST_FOREACH(CTransaction& tx, vDelete) {\n-        mempool.remove(tx);\n-        mempool.removeConflicts(tx);\n-    }\n-\n     mempool.check(pcoinsTip);\n \n     // Update best block in wallet (so we can detect restored wallets)"
      },
      {
        "sha": "44a80cfe27b44c5b517aaa2b3fe68ba2bed92377",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 292,
        "deletions": 1,
        "changes": 293,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a98d704e575ec42dada2dbf40b8fcce5fd7368e/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a98d704e575ec42dada2dbf40b8fcce5fd7368e/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=2a98d704e575ec42dada2dbf40b8fcce5fd7368e",
        "patch": "@@ -3,10 +3,156 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include \"compat.h\"\n #include \"core.h\"\n #include \"txmempool.h\"\n \n+// These must come after compat.h to avoid windows\n+// cross-compiler build errors.\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+#include <boost/multi_index/member.hpp>\n+\n using namespace std;\n+using namespace boost;\n+using namespace boost::multi_index;\n+\n+static const char* MEMPOOL_FILENAME=\"mempool.dat\";\n+\n+// CMinerPolicyEstimator is told when transactions exit the\n+// memory pool because they are included in blocks, and uses\n+// that information to estimate the priority needed for\n+// free transactions to be included in blocks and the\n+// fee needed for fee-paying transactions.\n+\n+struct TimeValue\n+{\n+    int64_t t;\n+    double v;\n+    TimeValue(int64_t _t, double _v) : t(_t), v(_v) { }\n+};\n+typedef multi_index_container<\n+    TimeValue,\n+    indexed_by<\n+        // Sort by time inserted\n+        ordered_non_unique<member<TimeValue,int64_t,&TimeValue::t > >,\n+\n+        // Sort by value\n+        ordered_non_unique<member<TimeValue,double,&TimeValue::v > >\n+        >\n+    > SortedValues ;\n+\n+class CMinerPolicyEstimator\n+{\n+private:\n+    size_t nMin, nMax;\n+    SortedValues byPriority;\n+    SortedValues byFee;\n+\n+    // Results of estimate() are cached between new blocks, because\n+    // the estimate doesn't change until a new block pulls transactions\n+    // from the memory pool and because the transaction relaying code\n+    // calls estimate on every transaction to decide whether or not it\n+    // should be relayed.\n+    map<double, double> byPriorityCache;\n+    map<double, double> byFeeCache;\n+\n+    // Estimate what value is required to be chosen above\n+    // fraction of other transactions (fraction is 0.0 to 1.0)\n+    // Returns -1.0 if not enough data has been collected to\n+    // give a good estimate.\n+    double estimate(const SortedValues& values, double fraction, map<double,double>& cache)\n+    {\n+        assert(fraction >= 0.0 && fraction <= 1.0);\n+        if (values.size() < nMin) return -1.0;\n+\n+        map<double,double>::iterator cached = cache.find(fraction);\n+        if (cached != cache.end())\n+            return cached->second;\n+\n+        size_t n = size_t(values.size()*fraction);\n+        if (n > 0) --n;\n+        SortedValues::nth_index<1>::type::iterator it=values.get<1>().begin();\n+        std::advance(it, n);\n+        cache[fraction] = it->v;\n+        return it->v;\n+    }\n+\n+    bool Write(CAutoFile& fileout, const SortedValues& values)\n+    {\n+        fileout << values.size();\n+        SortedValues::nth_index<1>::type::iterator it=values.get<1>().begin();\n+        while (it != values.get<1>().end())\n+        {\n+            fileout << it->t << it->v;\n+            it++;\n+        }\n+        return true;\n+    }\n+    bool Read(CAutoFile& filein, SortedValues& values)\n+    {\n+        size_t n;\n+        filein >> n;\n+        for (size_t i = 0; i < n; i++)\n+        {\n+            int64_t t;\n+            double v;\n+            filein >> t >> v;\n+            values.insert(TimeValue(t, v));\n+        }\n+        return true;\n+    }\n+\n+public:\n+    CMinerPolicyEstimator(size_t _nMin, size_t _nMax) : nMin(_nMin), nMax(_nMax)\n+    {\n+    }\n+\n+    void resize(SortedValues& what, size_t n)\n+    {\n+        while (what.size() > n)\n+            what.erase(what.begin());\n+    }\n+\n+    void add(const CTxMemPoolEntry& entry, unsigned int nBlockHeight)\n+    {\n+        if (nBlockHeight == 0 || entry.GetTxSize() == 0) return;\n+        double dFeePerByte = entry.GetFee() / (double)entry.GetTxSize();\n+        double dPriority = entry.GetPriority(nBlockHeight);\n+        if (dPriority == 0 && dFeePerByte > 0)\n+        {\n+            byFee.insert(TimeValue(GetTimeMillis(), dFeePerByte));\n+            resize(byFee, nMax);\n+            byFeeCache.clear();\n+        }\n+        else if (dFeePerByte == 0 && dPriority > 0)\n+        {\n+            byPriority.insert(TimeValue(GetTimeMillis(), dPriority));\n+            resize(byPriority, nMax);\n+            byPriorityCache.clear();\n+        }\n+        // Ignore transactions with both fee and priority > 0,\n+        // because we can't tell why miners included them (might\n+        // have been priority, might have been fee)\n+    }\n+\n+    double estimatePriority(double fraction)\n+    {\n+        return estimate(byPriority, fraction, byPriorityCache);\n+    }\n+    double estimateFee(double fraction)\n+    {\n+        return estimate(byFee, fraction, byFeeCache);\n+    }\n+    bool Write(CAutoFile& fileout)\n+    {\n+        return Write(fileout, byPriority) && Write(fileout, byFee);\n+    }\n+    bool Read(CAutoFile& filein)\n+    {\n+        return Read(filein, byPriority) && Read(filein, byFee);\n+    }\n+};\n \n CTxMemPoolEntry::CTxMemPoolEntry()\n {\n@@ -41,6 +187,15 @@ CTxMemPool::CTxMemPool()\n     // accepting transactions becomes O(N^2) where N is the number\n     // of transactions in the pool\n     fSanityCheck = false;\n+    // 100 and 10,000 values here are arbitrary, but work\n+    // well in practice, giving reasonable estimates within a few\n+    // blocks and stable estimates over time.\n+    minerPolicyEstimator = new CMinerPolicyEstimator(100, 10000);\n+}\n+\n+CTxMemPool::~CTxMemPool()\n+{\n+    delete minerPolicyEstimator;\n }\n \n void CTxMemPool::pruneSpent(const uint256 &hashTx, CCoins &coins)\n@@ -86,7 +241,7 @@ bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry)\n }\n \n \n-bool CTxMemPool::remove(const CTransaction &tx, bool fRecursive)\n+bool CTxMemPool::remove(const CTransaction &tx, bool fRecursive, unsigned int nBlockHeight)\n {\n     // Remove transaction from memory pool\n     {\n@@ -101,6 +256,7 @@ bool CTxMemPool::remove(const CTransaction &tx, bool fRecursive)\n         }\n         if (mapTx.count(hash))\n         {\n+            minerPolicyEstimator->add(mapTx[hash], nBlockHeight);\n             BOOST_FOREACH(const CTxIn& txin, tx.vin)\n                 mapNextTx.erase(txin.prevout);\n             mapTx.erase(hash);\n@@ -192,6 +348,141 @@ bool CTxMemPool::lookup(uint256 hash, CTransaction& result) const\n     return true;\n }\n \n+void CTxMemPool::estimateFees(double dPriorityMedian, double& dPriority,\n+                              double dFeeMedian, double& dFee, bool fUseHardCoded)\n+{\n+    LOCK(cs);\n+    dPriority = minerPolicyEstimator->estimatePriority(dPriorityMedian);\n+    // Hard-coded priority is 1-BTC, 144-confirmation old, 250-byte txn:\n+    if (dPriority < 0 && fUseHardCoded) dPriority = COIN*144 / 250;\n+    dFee = minerPolicyEstimator->estimateFee(dFeeMedian);\n+    // Hard-coded fee is 10,000 satoshis per kilobyte (10 satoshis per byte):\n+    if (dFee < 0 && fUseHardCoded) dFee = 10.0;\n+}\n+\n+bool CTxMemPool::isDust(const CTxOut& txout)\n+{\n+    // \"Dust\" is defined as outputs so small\n+    // (in value) that they would require that\n+    // more than 1/3 of their value in fees to\n+    // have a reasonable chance of being accepted into\n+    // a block right now.\n+    // Fees are per-byte, so:\n+    int nSize = (int)::GetSerializeSize(txout, SER_DISK,0);\n+    // ... and assume it will need a 148-byte CTxIn to spend:\n+    nSize += 148;\n+\n+    // Use 0.01 (lowest 1%) as threshold to estimate fee-per-byte:\n+    double dMinFee, dUnused;\n+    estimateFees(0.01, dUnused, 0.01, dMinFee, true);\n+\n+    // Need to pay more than 1/3 of value?\n+    bool fIsDust = dMinFee*nSize > txout.nValue/3;\n+    return fIsDust;\n+}\n+\n+void CTxMemPool::writeEntry(CAutoFile& file, const uint256& txid, std::set<uint256>& alreadyWritten) const\n+{\n+    if (alreadyWritten.count(txid)) return;\n+    alreadyWritten.insert(txid);\n+    const CTxMemPoolEntry& entry = mapTx.at(txid);\n+    // Write txns we depend on first:\n+    BOOST_FOREACH(const CTxIn txin, entry.GetTx().vin)\n+    {\n+        const uint256& prevout = txin.prevout.hash;\n+        if (mapTx.count(prevout))\n+            writeEntry(file, prevout, alreadyWritten);\n+    }\n+    unsigned int nHeight = entry.GetHeight();\n+    file << entry.GetTx() << entry.GetFee() << entry.GetTime() << entry.GetPriority(nHeight) << nHeight;\n+}\n+\n+//\n+// Format of the mempool.dat file:\n+//  32-bit versionRequiredToRead\n+//  32-bit versionThatWrote\n+//  32-bit-number of transactions\n+//  [ serialized: transaction / fee / time / priority / height ]\n+//    ... then the miner policy estimation data:\n+//  32-bit-number of priority data points\n+//  [ (time,priority) ]\n+//  32-bit-number of fee data points\n+//  [ (time,fee) ]\n+//\n+bool CTxMemPool::Write() const\n+{\n+    boost::filesystem::path path = GetDataDir() / MEMPOOL_FILENAME;\n+    FILE *file = fopen(path.string().c_str(), \"wb\"); // Overwrites any older mempool (which is fine)\n+    CAutoFile fileout = CAutoFile(file, SER_DISK, CLIENT_VERSION);\n+    if (!fileout)\n+        return error(\"CTxMemPool::Write() : open failed\");\n+\n+    fileout << CLIENT_VERSION; // version required to read\n+    fileout << CLIENT_VERSION; // version that wrote the file\n+\n+    std::set<uint256> alreadyWritten; // Used to write parents before dependents\n+    try {\n+        LOCK(cs);\n+        fileout << mapTx.size();\n+        for (map<uint256, CTxMemPoolEntry>::const_iterator it = mapTx.begin();\n+             it != mapTx.end(); it++)\n+        {\n+            writeEntry(fileout, it->first, alreadyWritten);\n+        }\n+        minerPolicyEstimator->Write(fileout);\n+    }\n+    catch (std::exception &e) {\n+        // We don't care much about errors; saving\n+        // and restoring the memory pool is mostly an\n+        // optimization for cases where a mining node shuts down\n+        // briefly (maybe to change an option), and it is better\n+        // to restart with a full memory pool of transactions to mine.\n+        return error(\"CTxMemPool::Write() : unable to write (non-fatal)\");\n+    }\n+\n+    return true;\n+}\n+\n+bool CTxMemPool::Read(std::list<CTxMemPoolEntry>& vecEntries) const\n+{\n+    boost::filesystem::path path = GetDataDir() / MEMPOOL_FILENAME;\n+    FILE *file = fopen(path.string().c_str(), \"rb\");\n+    if (!file) return true; // No mempool.dat: OK\n+    CAutoFile filein = CAutoFile(file, SER_DISK, CLIENT_VERSION);\n+    if (!filein)\n+        return error(\"CTxMemPool::Read() : open failed\");\n+\n+    try {\n+        int nVersionRequired, nVersionThatWrote;\n+        filein >> nVersionRequired >> nVersionThatWrote;\n+\n+        if (nVersionRequired > CLIENT_VERSION)\n+            return error(\"CTxMemPool::Read() : up-version (%d) mempool.dat\", nVersionRequired);\n+\n+        size_t nTx;\n+        filein >> nTx;\n+\n+        for (size_t i = 0; i < nTx; i++)\n+        {\n+            CTransaction tx;\n+            int64_t nFee;\n+            int64_t nTime;\n+            double dPriority;\n+            unsigned int nHeight;\n+            filein >> tx >> nFee >> nTime >> dPriority >> nHeight;\n+            CTxMemPoolEntry e(tx, 0, nTime, dPriority, nHeight);\n+            vecEntries.push_back(e);\n+        }\n+        minerPolicyEstimator->Read(filein);\n+    }\n+    catch (std::exception &e) {\n+        // Not a big deal if mempool.dat gets corrupted:\n+        return error(\"CTxMemPool::Read() : unable to read (non-fatal)\");\n+    }\n+\n+    return true;\n+}\n+\n CCoinsViewMemPool::CCoinsViewMemPool(CCoinsView &baseIn, CTxMemPool &mempoolIn) : CCoinsViewBacked(baseIn), mempool(mempoolIn) { }\n \n bool CCoinsViewMemPool::GetCoins(const uint256 &txid, CCoins &coins) {"
      },
      {
        "sha": "fa002e34c6ec12654a2610b8695ea0b70d33ae4f",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 16,
        "deletions": 1,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a98d704e575ec42dada2dbf40b8fcce5fd7368e/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a98d704e575ec42dada2dbf40b8fcce5fd7368e/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=2a98d704e575ec42dada2dbf40b8fcce5fd7368e",
        "patch": "@@ -12,6 +12,8 @@\n /** Fake height value used in CCoins to signify they are only in the memory pool (since 0.8) */\n static const unsigned int MEMPOOL_HEIGHT = 0x7FFFFFFF;\n \n+class CMinerPolicyEstimator; // Internal class used for estimatefees functionality\n+\n /*\n  * CTxMemPool stores these:\n  */\n@@ -54,13 +56,17 @@ class CTxMemPool\n private:\n     bool fSanityCheck; // Normally false, true if -checkmempool or -regtest\n     unsigned int nTransactionsUpdated;\n+    CMinerPolicyEstimator* minerPolicyEstimator; // For estimating transaction fees\n+\n+    void writeEntry(CAutoFile& file, const uint256& txid, std::set<uint256>& alreadyWritten) const;\n \n public:\n     mutable CCriticalSection cs;\n     std::map<uint256, CTxMemPoolEntry> mapTx;\n     std::map<COutPoint, CInPoint> mapNextTx;\n \n     CTxMemPool();\n+    ~CTxMemPool();\n \n     /*\n      * If sanity-checking is turned on, check makes sure the pool is\n@@ -72,11 +78,13 @@ class CTxMemPool\n     void setSanityCheck(bool _fSanityCheck) { fSanityCheck = _fSanityCheck; }\n \n     bool addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry);\n-    bool remove(const CTransaction &tx, bool fRecursive = false);\n+    bool remove(const CTransaction &tx, bool fRecursive = false, unsigned int nBlockHeight = 0);\n     bool removeConflicts(const CTransaction &tx);\n     void clear();\n     void queryHashes(std::vector<uint256>& vtxid);\n     void pruneSpent(const uint256& hash, CCoins &coins);\n+    void estimateFees(double dPriorityMedian, double& dPriority, double dFeeMedian, double& dFee, bool fUseHardCoded=false);\n+    bool isDust(const CTxOut& txout);\n     unsigned int GetTransactionsUpdated() const;\n     void AddTransactionsUpdated(unsigned int n);\n \n@@ -93,6 +101,13 @@ class CTxMemPool\n     }\n \n     bool lookup(uint256 hash, CTransaction& result) const;\n+\n+    // Save to mempool.dat:\n+    bool Write() const;\n+    // Read from mempool.dat, return entries; does\n+    // not automatically add them to the pool,\n+    // because they might no longer be valid.\n+    bool Read(std::list<CTxMemPoolEntry>& entries) const;\n };\n \n /** CCoinsView that brings transactions from a memorypool into view."
      }
    ]
  },
  {
    "sha": "656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NTZmOGE3ZjJjZjBjODNlZDlhYzE3MmY0ZDVlYzU1NWY5MGZlZDcz",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2013-11-15T10:29:49Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2013-12-09T02:45:11Z"
      },
      "message": "Floating fees for the client\n\nEstimate what fee or priority is needed to get a transaction\naccepted into a block (unless user has set a fee using\n-paytxfee or the GUI).\n\nIncludes a safety net: always pay at least what a 0.8.5 client\nwould pay. The plan is for future releases to eliminate that\ncheck, and let fees float up and down based on competition for\nblock space.\n\nAdds two new RPC methods to expose the estimates:\nestimatefee and estimatepriority.\n\nI expect future releases might improve the fee estimation code;\nit is self-contained in the CMinerPolicyEstimator class, so\n\"patches welcome.\"\n\nThis is a much more conservative of the pull request I\nsubmitted a couple months ago.",
      "tree": {
        "sha": "4d5b35a6a531be2413fa1ae39bae873a0e10a1e6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4d5b35a6a531be2413fa1ae39bae873a0e10a1e6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2a98d704e575ec42dada2dbf40b8fcce5fd7368e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2a98d704e575ec42dada2dbf40b8fcce5fd7368e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2a98d704e575ec42dada2dbf40b8fcce5fd7368e"
      }
    ],
    "stats": {
      "total": 495,
      "additions": 400,
      "deletions": 95
    },
    "files": [
      {
        "sha": "02a2fe9f7f1314a2565b4e956cf7fa01e5d14139",
        "filename": "qa/rpc-tests/README.md",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73/qa/rpc-tests/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73/qa/rpc-tests/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/README.md?ref=656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73",
        "patch": "@@ -3,4 +3,6 @@ Regression tests of RPC interface\n \n wallet.sh : Test wallet send/receive code (see comments for details)\n \n+estimatefee.sh : Test estimatefee/estimatepriority RPC calls\n+\n util.sh : useful re-usable functions "
      },
      {
        "sha": "c4cdd7d52acb757f48ac3dfe6da063f052857d02",
        "filename": "qa/rpc-tests/estimatefee.sh",
        "status": "added",
        "additions": 149,
        "deletions": 0,
        "changes": 149,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73/qa/rpc-tests/estimatefee.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73/qa/rpc-tests/estimatefee.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/estimatefee.sh?ref=656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73",
        "patch": "@@ -0,0 +1,149 @@\n+#!/usr/bin/env bash\n+\n+# Test estimatefee\n+\n+#set -o xtrace  # Uncomment to debug\n+\n+if [ $# -lt 1 ]; then\n+        echo \"Usage: $0 path_to_binaries\"\n+        echo \"e.g. $0 ../../src\"\n+        exit 1\n+fi\n+\n+echo \"Tests can take more than 10 minutes to run; be patient.\"\n+\n+BITCOIND=${1}/bitcoind\n+CLI=${1}/bitcoin-cli\n+\n+DIR=\"${BASH_SOURCE%/*}\"\n+if [[ ! -d \"$DIR\" ]]; then DIR=\"$PWD\"; fi\n+. \"$DIR/util.sh\"\n+\n+D=$(mktemp -d test.XXXXX)\n+\n+# Three nodes:\n+#  B1 relays between the other two, runs with defaults,\n+D1=${D}/node1\n+CreateDataDir $D1 port=11000 rpcport=11001 debug=estimatefee\n+B1ARGS=\"-datadir=$D1\"\n+$BITCOIND $B1ARGS &\n+B1PID=$!\n+\n+#  B2 runs with -paytxfee=0.001, is also used to send\n+#  higher/lower priority transactions\n+D2=${D}/node2\n+CreateDataDir $D2 port=11010 rpcport=11011 connect=127.0.0.1:11000 paytxfee=0.001 debug=estimatefee\n+B2ARGS=\"-datadir=$D2\"\n+$BITCOIND $B2ARGS &\n+B2PID=$!\n+\n+#  B3 runs with -paytxfee=0.02\n+D3=${D}/node3\n+CreateDataDir $D3 port=11020 rpcport=11021 connect=127.0.0.1:11000 paytxfee=0.02 debug=estimatefee\n+B3ARGS=\"-datadir=$D3\"\n+$BITCOIND $BITCOINDARGS $B3ARGS &\n+B3PID=$!\n+\n+# trap \"kill -9 $B1PID $B2PID $B3PID; rm -rf $D\" EXIT\n+\n+echo \"Generating initial blockchain\"\n+\n+# B2 starts with 220 blocks (so 120 old, mature):\n+$CLI $B2ARGS setgenerate true 220\n+WaitForBlock $B1ARGS 220\n+\n+PRI=$($CLI $B1ARGS estimatepriority)\n+AssertEqual $PRI -1.0\n+\n+B1ADDRESS=$(Address $B1ARGS)\n+B2ADDRESS=$(Address $B2ARGS)\n+B3ADDRESS=$(Address $B3ARGS)\n+\n+echo \"Testing priority estimation\"\n+\n+# Generate 110 very-high-priority (50 BTC with at least 100 confirmations) transactions\n+# (in two batches, with a block generated in between)\n+# 100 confirmed transactions is the minimum the estimation code needs.\n+for i in {1..55} ; do\n+    RAW=$(CreateTxn1 $B2ARGS 1 $B1ADDRESS)\n+    RAWTXID=$(SendRawTxn $B2ARGS $RAW)\n+done\n+$CLI $B3ARGS setgenerate true 1\n+WaitForBlock $B1ARGS 221\n+for i in {1..55} ; do\n+    RAW=$(CreateTxn1 $B2ARGS 1 $B1ADDRESS)\n+    RAWTXID=$(SendRawTxn $B2ARGS $RAW)\n+done\n+sleep 1\n+$CLI $B3ARGS setgenerate true 3\n+WaitForBlock $B1ARGS 224\n+\n+PRI_HIGH=$($CLI $B3ARGS estimatepriority)\n+AssertGreater \"$PRI_HIGH\" 56000000\n+\n+# Generate 100 very-low-priority free transactions;\n+# priority estimate should go down\n+\n+for i in {1..50} ; do\n+    RAW=$(CreateTxn1 $B1ARGS 1 $B2ADDRESS)\n+    RAWTXID=$(SendRawTxn $B1ARGS $RAW)\n+    RAW=$(CreateTxn1 $B1ARGS 1 $B3ADDRESS)\n+    RAWTXID=$(SendRawTxn $B1ARGS $RAW)\n+done\n+$CLI $B3ARGS setgenerate true 3\n+WaitForBlock $B1ARGS 227\n+\n+PRI_LOW=$($CLI $B3ARGS estimatepriority)\n+AssertGreater \"$PRI_HIGH\" \"$PRI_LOW\"\n+\n+echo \"Success. Testing fee estimation.\"\n+\n+# At this point:\n+#  B1 has 60 unspent outputs with 6 or 7 confirmations\n+#  B2 has 17 coinbases with over 100 confirmations\n+#   and 50 utxos with 3 confirmations\n+#  B3 has no mature coins/transactions.\n+#\n+# So: create 200 1 XBT transactions from B2 to B3,\n+# using sendtoaddress.  The first 67 will be free, the\n+# rest will pay a 0.001 XBT fee, and estimatefee\n+# should give an estimate of over 0.00099 XBT/kilobyte\n+#  (transactions are less than 1KB big)\n+for i in {1..200} ; do\n+    Send $B2ARGS $B3ARGS 1\n+done\n+$CLI $B2ARGS setgenerate true 1\n+WaitForBlock $B3ARGS 228\n+\n+FEE_LOW=$($CLI $B3ARGS estimatefee)\n+AssertGreater \"$FEE_LOW\" \"0.00099\"\n+echo \"Fee low: $FEE_LOW\"\n+\n+# Now create 500 0.1 XBT transactions\n+# from B3 to B1, each paying a 0.02 XBT fee.\n+# At most 200 will have non-zero priority,\n+# so at least 300 will be zero-priority.\n+# Median fee estimate should go up.\n+for i in {1..500} ; do\n+    Send $B3ARGS $B1ARGS 0.1\n+done\n+$CLI $B2ARGS setgenerate true 2\n+WaitForBlock $B1ARGS 230\n+\n+FEE_HIGH=$($CLI $B2ARGS estimatefee)\n+echo \"Fee high: $FEE_HIGH\"\n+AssertGreater \"$FEE_HIGH\" \"$FEE_LOW\"\n+\n+# Shut down, clean up\n+\n+$CLI $B3ARGS stop > /dev/null 2>&1\n+wait $B3PID\n+$CLI $B2ARGS stop > /dev/null 2>&1\n+wait $B2PID\n+$CLI $B1ARGS stop > /dev/null 2>&1\n+wait $B1PID\n+\n+echo \"Tests successful, cleaning up\"\n+trap \"\" EXIT\n+rm -rf $D\n+exit 0"
      },
      {
        "sha": "a495d502f0daece67145a67d6864b067f8bb431a",
        "filename": "qa/rpc-tests/util.sh",
        "status": "modified",
        "additions": 29,
        "deletions": 1,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73/qa/rpc-tests/util.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73/qa/rpc-tests/util.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/util.sh?ref=656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73",
        "patch": "@@ -30,6 +30,14 @@ function CreateDataDir {\n   done\n }\n \n+function AssertNotEmpty {\n+  if [ -z  \"$1\" ]\n+  then\n+    echoerr \"Unexpected empty result.\"\n+    exit 1\n+  fi\n+}\n+\n function AssertEqual {\n   if (( $( echo \"$1 == $2\" | bc ) == 0 ))\n   then\n@@ -38,6 +46,22 @@ function AssertEqual {\n   fi\n }\n \n+function AssertGreater {\n+  if (( $( echo \"$1 > $2\" | bc ) == 0 ))\n+  then\n+    echoerr \"AssertGreater: $1 <= $2\"\n+    exit 1\n+  fi\n+}\n+\n+# WaitBlock -datadir=... block#\n+function WaitForBlock {\n+  while [ $( $CLI $1 getblockcount) -lt $2 ]\n+  do\n+    sleep 1\n+  done\n+}\n+\n # CheckBalance -datadir=... amount account minconf\n function CheckBalance {\n   B=$( $CLI $1 getbalance $3 $4 )\n@@ -60,6 +84,7 @@ function Send {\n   amount=$3\n   address=$(Address $to)\n   txid=$( $CLI $from sendtoaddress $address $amount )\n+  AssertNotEmpty \"$txid\"\n }\n \n # Use: Unspent <datadir> <n'th-last-unspent> <var>\n@@ -75,10 +100,13 @@ function CreateTxn1 {\n   AMOUNT=$(Unspent $1 $2 amount)\n   VOUT=$(Unspent $1 $2 vout)\n   RAWTXN=$( $CLI $1 createrawtransaction \"[{\\\"txid\\\":\\\"$TXID\\\",\\\"vout\\\":$VOUT}]\" \"{\\\"$3\\\":$AMOUNT}\")\n+  AssertNotEmpty \"$RAWTXN\"\n   ExtractKey hex \"$( $CLI $1 signrawtransaction $RAWTXN )\"\n }\n \n # Use: SendRawTxn <datadir> <hex_txn_data>\n function SendRawTxn {\n-  $CLI $1 sendrawtransaction $2\n+  TXID=$($CLI $1 sendrawtransaction $2)\n+  AssertNotEmpty \"$TXID\"\n+  echo $TXID\n }"
      },
      {
        "sha": "b49d1a89a962a42ae0c9b0fd7b528c36a0ebe6b7",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 74,
        "deletions": 22,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73",
        "patch": "@@ -587,36 +587,86 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state)\n     return true;\n }\n \n-int64_t GetMinFee(const CTransaction& tx, unsigned int nBytes, bool fAllowFree, enum GetMinFee_mode mode)\n+bool AllowFree(const CTransaction& tx, double dPriority, unsigned int nBytes, enum GetMinFee_mode mode)\n {\n-    // Base fee is either nMinTxFee or nMinRelayTxFee\n-    int64_t nBaseFee = (mode == GMF_RELAY) ? tx.nMinRelayTxFee : tx.nMinTxFee;\n+    // There is a free transaction area in blocks created by most miners,\n+    // * If we are relaying we allow transactions up to DEFAULT_BLOCK_PRIORITY_SIZE - 1000\n+    //   to be considered to fall into this category. We don't want to encourage sending\n+    //   multiple transactions instead of one big transaction to avoid fees.\n+    // * If we are creating a transaction we allow transactions up to 1,000 bytes\n+    //   to be considered safe and assume they can likely make it into this section.\n+    if (nBytes >= (mode == GMF_SEND ? 1000 : (DEFAULT_BLOCK_PRIORITY_SIZE - 1000)))\n+        return false;\n+\n+    if (mode == GMF_RELAY)\n+        return true; // Relay almost everything (free txn rate-limiter keeps spam under control)\n+\n+    // This check can be removed after enough miners have upgraded to version 0.9.\n+    // Until then, be safe when sending and require a fee if any output\n+    // is less than CENT:\n+    BOOST_FOREACH(const CTxOut& txout, tx.vout)\n+        if (txout.nValue < CENT) return false;\n+\n+    return dPriority >= mempool.estimateFreePriority(0.5, true);\n+}\n+\n+// Minimum fee as of version 0.8.5.\n+// Remove this when network has upgraded.\n+static int64_t GetMinFee08(unsigned int nBytes, enum GetMinFee_mode mode)\n+{\n+    int64_t nBaseFee = (mode == GMF_RELAY) ? CTransaction::nMinRelayTxFee : CTransaction::nMinTxFee;\n \n+    // nBytes is rounded up to the next nearest 1,000 bytes, and nBaseFee per\n+    // 1,000 bytes is required.\n     int64_t nMinFee = (1 + (int64_t)nBytes / 1000) * nBaseFee;\n \n-    if (fAllowFree)\n+    return nMinFee;\n+}\n+\n+int64_t GetMinFee(unsigned int nBytes, enum GetMinFee_mode mode)\n+{\n+    // The fee rules have evolved over time, and are more complicated\n+    // than we'd like. Changing them requires first changing miners,\n+    // and then changing wallet software.\n+    //\n+    // Summary of fee-related settings:\n+    // -paytxfee / ::nTransactionFee : User setting, means\n+    //   \"pay at least this much per transaction.\"  Default 0.\n+    //   If -paytxfee is not set, then current fees are\n+    //   estimated.\n+    //\n+    // -mintxfee / CTransaction::nMinTxFee : Miner setting,\n+    //   means \"transactions that pay less than this\n+    //   per kilobyte considered free when creating blocks.\"\n+    //\n+    // -minrelaytxfee / CTransaction::nMinRelayTxFee : Relay\n+    //   setting, means \"transactions that pay less than\n+    //   this per kb considered free when relaying.\"\n+    //\n+\n+    int64_t nFee08 = GetMinFee08(nBytes, mode); // Remove when network has upgraded\n+\n+\n+    int64_t nFee = 0;\n+\n+    if (mode == GMF_SEND)\n     {\n-        // There is a free transaction area in blocks created by most miners,\n-        // * If we are relaying we allow transactions up to DEFAULT_BLOCK_PRIORITY_SIZE - 1000\n-        //   to be considered to fall into this category. We don't want to encourage sending\n-        //   multiple transactions instead of one big transaction to avoid fees.\n-        // * If we are creating a transaction we allow transactions up to 1,000 bytes\n-        //   to be considered safe and assume they can likely make it into this section.\n-        if (nBytes < (mode == GMF_SEND ? 1000 : (DEFAULT_BLOCK_PRIORITY_SIZE - 1000)))\n-            nMinFee = 0;\n+        // If user set nTransactionFee, pay at least that\n+        // (pay nTransactionFee per kb, if transaction is > 1,000 bytes):\n+        if (nTransactionFee > 0)\n+            nFee = max(nTransactionFee, nTransactionFee*nBytes/1000);\n+        // Otherwise pay median estimated fee-per-byte:\n+        else\n+            nFee = nBytes*mempool.estimateFee(0.5, true);\n     }\n-\n-    // This code can be removed after enough miners have upgraded to version 0.9.\n-    // Until then, be safe when sending and require a fee if any output\n-    // is less than CENT:\n-    if (nMinFee < nBaseFee && mode == GMF_SEND)\n+    else // Relay:\n     {\n-        BOOST_FOREACH(const CTxOut& txout, tx.vout)\n-            if (txout.nValue < CENT)\n-                nMinFee = nBaseFee;\n+        nFee = nBytes*CTransaction::nMinRelayTxFee/1000;\n     }\n \n-    if (!MoneyRange(nMinFee))\n+    int64_t nMinFee = max(nFee08, nFee);\n+\n+    if (!MoneyRange(nMinFee)) // belt-and-suspenders sanity check\n         nMinFee = MAX_MONEY;\n     return nMinFee;\n }\n@@ -715,7 +765,9 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         unsigned int nSize = entry.GetTxSize();\n \n         // Don't accept it if it can't get into a block\n-        int64_t txMinFee = GetMinFee(tx, nSize, true, GMF_RELAY);\n+        int64_t txMinFee = 0;\n+        if (!AllowFree(tx, dPriority, nSize, GMF_RELAY))\n+            txMinFee = GetMinFee(nSize, GMF_RELAY);\n         if (fLimitFree && nFees < txMinFee)\n             return state.DoS(0, error(\"AcceptToMemoryPool : not enough fees %s, %\"PRId64\" < %\"PRId64,\n                                       hash.ToString().c_str(), nFees, txMinFee),"
      },
      {
        "sha": "23a894844c44e3854638fb3342dcae104fb5f62f",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 2,
        "deletions": 8,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73",
        "patch": "@@ -255,7 +255,8 @@ enum GetMinFee_mode\n     GMF_SEND,\n };\n \n-int64_t GetMinFee(const CTransaction& tx, unsigned int nBytes, bool fAllowFree, enum GetMinFee_mode mode);\n+bool AllowFree(const CTransaction& tx, double dPriority, unsigned int nBytes, enum GetMinFee_mode mode);\n+int64_t GetMinFee(unsigned int nBytes, enum GetMinFee_mode mode);\n \n //\n // Check transaction inputs, and make sure any\n@@ -290,13 +291,6 @@ unsigned int GetLegacySigOpCount(const CTransaction& tx);\n unsigned int GetP2SHSigOpCount(const CTransaction& tx, CCoinsViewCache& mapInputs);\n \n \n-inline bool AllowFree(double dPriority)\n-{\n-    // Large (in bytes) low-priority (new, small-coin) transactions\n-    // need a fee.\n-    return dPriority > COIN * 144 / 250;\n-}\n-\n // Check whether all inputs of this transaction are valid (no double spends, scripts & sigs, amounts)\n // This does not modify the UTXO set. If pvChecks is not NULL, script checks are pushed onto it\n // instead of being performed inline."
      },
      {
        "sha": "0c498ee39ec9dc9a21bfff180da2593d91eec86d",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73",
        "patch": "@@ -247,9 +247,6 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n             unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n             dPriority = tx.ComputePriority(dPriority, nTxSize);\n \n-            // This is a more accurate fee-per-kilobyte than is used by the client code, because the\n-            // client code rounds up the size to the nearest 1K. That's good, because it gives an\n-            // incentive to create smaller transactions.\n             double dFeePerKb =  double(nTotalIn-tx.GetValueOut()) / (double(nTxSize)/1000.0);\n \n             if (porphan)\n@@ -297,7 +294,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n             // Prioritize by fee once past the priority size or we run out of high-priority\n             // transactions:\n             if (!fSortedByFee &&\n-                ((nBlockSize + nTxSize >= nBlockPrioritySize) || !AllowFree(dPriority)))\n+                ((nBlockSize + nTxSize >= nBlockPrioritySize) || !AllowFree(tx, dPriority, nTxSize, GMF_SEND)))\n             {\n                 fSortedByFee = true;\n                 comparer = TxPriorityCompare(fSortedByFee);"
      },
      {
        "sha": "9922ab905be27464209623be05c432023b985da3",
        "filename": "src/qt/coincontroldialog.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 17,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73/src/qt/coincontroldialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73/src/qt/coincontroldialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroldialog.cpp?ref=656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73",
        "patch": "@@ -395,20 +395,23 @@ void CoinControlDialog::viewItemChanged(QTreeWidgetItem* item, int column)\n // return human readable label for priority number\n QString CoinControlDialog::getPriorityLabel(double dPriority)\n {\n-    if (AllowFree(dPriority)) // at least medium\n+    double dPriorityLow = mempool.estimateFreePriority(0.1, true);\n+    double dPriorityMedian = mempool.estimateFreePriority(0.5, true);\n+    if (dPriorityMedian <= dPriorityLow) dPriorityMedian=dPriorityLow*100;\n+    double dPriorityHigh = mempool.estimateFreePriority(0.9, true);\n+    if (dPriorityHigh <= dPriorityMedian) dPriorityHigh=dPriorityMedian*100;\n+\n+    if (dPriority > dPriorityLow) // at least medium\n     {\n-        if      (AllowFree(dPriority / 1000000))  return tr(\"highest\");\n-        else if (AllowFree(dPriority / 100000))   return tr(\"higher\");\n-        else if (AllowFree(dPriority / 10000))    return tr(\"high\");\n-        else if (AllowFree(dPriority / 1000))     return tr(\"medium-high\");\n+        if      (dPriority > dPriorityHigh)  return tr(\"highest\");\n+        else if (dPriority > dPriorityMedian)   return tr(\"high\");\n         else                                      return tr(\"medium\");\n     }\n     else\n     {\n-        if      (AllowFree(dPriority * 10))   return tr(\"low-medium\");\n-        else if (AllowFree(dPriority * 100))  return tr(\"low\");\n-        else if (AllowFree(dPriority * 1000)) return tr(\"lower\");\n-        else                                  return tr(\"lowest\");\n+        if      (dPriority * 10 > dPriorityLow)  return tr(\"low\");\n+        else if (dPriority * 100 > dPriorityLow) return tr(\"lower\");\n+        else                                     return tr(\"lowest\");\n     }\n }\n \n@@ -506,6 +509,8 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n     }\n \n     // calculation\n+    // Much of this code is duplicated from CWallet::CreateTransaction;\n+    // it should be refactored one day\n     if (nQuantity > 0)\n     {\n         // Bytes\n@@ -515,19 +520,21 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n         dPriority = dPriorityInputs / (nBytes - nBytesInputs + (nQuantityUncompressed * 29)); // 29 = 180 - 151 (uncompressed public keys are over the limit. max 151 bytes of the input are ignored for priority)\n         sPriorityLabel = CoinControlDialog::getPriorityLabel(dPriority);\n \n-        // Fee\n-        int64_t nFee = nTransactionFee * (1 + (int64_t)nBytes / 1000);\n-\n-        // Min Fee\n-        int64_t nMinFee = GetMinFee(txDummy, nBytes, AllowFree(dPriority), GMF_SEND);\n-\n-        nPayFee = max(nFee, nMinFee);\n+        if (!AllowFree(txDummy, dPriority, nBytes, GMF_SEND))\n+        {\n+            // If we have to pay a fee:\n+            // Pay either nTransactionFee, the user-set \"I want to pay at least this much\"\n+            // OR the minimum estimated fee, whichever is larger.\n+            // This must match the logic in CWallet::CreateTransaction\n+            nPayFee = max(nTransactionFee, GetMinFee(nBytes, GMF_SEND));\n+        }\n \n         if (nPayAmount > 0)\n         {\n             nChange = nAmount - nPayFee - nPayAmount;\n \n             // if sub-cent change is required, the fee must be raised to at least CTransaction::nMinTxFee\n+            // CENT rule is going away, this code can eventually be removed:\n             if (nPayFee < CTransaction::nMinTxFee && nChange > 0 && nChange < CENT)\n             {\n                 if (nChange < CTransaction::nMinTxFee) // change < 0.0001 => simply move all change to fees\n@@ -595,7 +602,7 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n \n     // turn labels \"red\"\n     l5->setStyleSheet((nBytes >= 1000) ? \"color:red;\" : \"\");                // Bytes >= 1000\n-    l6->setStyleSheet((!AllowFree(dPriority)) ? \"color:red;\" : \"\");         // Priority < \"medium\"\n+    l6->setStyleSheet((!AllowFree(txDummy, dPriority, nBytes, GMF_SEND)) ? \"color:red;\" : \"\"); // Priority < \"medium\"\n     l7->setStyleSheet((fLowOutput) ? \"color:red;\" : \"\");                    // Low Output = \"yes\"\n     l8->setStyleSheet((nChange > 0 && nChange < CENT) ? \"color:red;\" : \"\"); // Change < 0.01BTC\n "
      },
      {
        "sha": "24e4cde442bb058ee753b0986fcea962328dfc7a",
        "filename": "src/rpcclient.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73/src/rpcclient.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73/src/rpcclient.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcclient.cpp?ref=656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73",
        "patch": "@@ -177,6 +177,8 @@ Array RPCConvertValues(const std::string &strMethod, const std::vector<std::stri\n     if (strMethod == \"verifychain\"            && n > 1) ConvertTo<boost::int64_t>(params[1]);\n     if (strMethod == \"keypoolrefill\"          && n > 0) ConvertTo<boost::int64_t>(params[0]);\n     if (strMethod == \"getrawmempool\"          && n > 0) ConvertTo<bool>(params[0]);\n+    if (strMethod == \"estimatefee\"            && n > 0) ConvertTo<double>(params[0]);\n+    if (strMethod == \"estimatepriority\"       && n > 0) ConvertTo<double>(params[0]);\n \n     return params;\n }"
      },
      {
        "sha": "b67c9d911abe9308a8aa9ed994a61bec1016fd97",
        "filename": "src/rpcmining.cpp",
        "status": "modified",
        "additions": 77,
        "deletions": 0,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73/src/rpcmining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73/src/rpcmining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcmining.cpp?ref=656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73",
        "patch": "@@ -12,6 +12,7 @@\n #include \"miner.h\"\n #include \"wallet.h\"\n \n+#include <boost/assign/list_of.hpp>\n #include <stdint.h>\n \n #include \"json/json_spirit_utils.h\"\n@@ -609,3 +610,79 @@ Value submitblock(const Array& params, bool fHelp)\n \n     return Value::null;\n }\n+\n+Value estimatefee(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() > 1)\n+        throw runtime_error(\n+            \"estimatefee ( feemedian )\\n\"\n+            \"\\nEstimates the fee-per-kilobyte needed for \\n\"\n+            \"transactions to be relayed across the network and\\n\"\n+            \"confirmed in the block chain.\\n\"\n+            \"feemedian is a value from 0.0 to 1.0, where\\n\"\n+            \"0.0 will return the smallest\\n\"\n+            \"recently-included-in-a-block fee seen,\\n\"\n+            \"1.0 the largest, and 0.5 the median fee paid.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. feemedian          (numeric, optional, default=0.5)\\n\"\n+            \"\\nResult:\\n\"\n+            \"n :        (numeric) fee, in bitcoins/1000-bytes, needed to out-compete a\\n\"\n+            \"           feemedian fraction of fee-paying transactions.\\n\"\n+            \"\\n\"\n+            \"-1.0 is returned if not enough transactions and\\n\"\n+            \"blocks have been observed to make an estimate.\\n\"\n+            \"\\nExample:\\n\"\n+            + HelpExampleCli(\"estimatefee\", \"0.75\")\n+        );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(real_type));\n+\n+    double dFeeMedian = 0.5;\n+    if (params.size() > 0)\n+        dFeeMedian = params[0].get_real();\n+    if (dFeeMedian < 0.0 || dFeeMedian > 1.0)\n+        throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid fee median (must be 0.0 to 1.0)\");\n+\n+    double dFee = mempool.estimateFee(dFeeMedian);\n+    if (dFee > 0.0)\n+        return ValueFromAmount(1000*dFee);  // Convert from satoshi-per-byte to bitcon-per-kilobyte\n+\n+    return -1.0;\n+}\n+\n+Value estimatepriority(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() > 1)\n+        throw runtime_error(\n+            \"estimatepriority ( prioritymedian )\\n\"\n+            \"\\nEstimates the priority sufficient\\n\"\n+            \"for a transaction to be relayed across the network and\\n\"\n+            \"confirmed in the block chain.\\n\"\n+            \"prioritymedian ranges from 0.0\\n\"\n+            \"to 1.0, where 0.0 will return the smallest\\n\"\n+            \"recently-included-in-a-block priority seen,\\n\"\n+            \"1.0 the largest, and 0.5 the median\\n\"\n+            \"for transactions that were broadcast on the network and\\n\"\n+            \"included in a block.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. prioritymedian     (numeric, optional, default=0.5)\\n\"\n+            \"\\nResult:\\n\"\n+            \"n :    (numeric) priority needed to out-compete a prioritymedian\\n\"\n+            \"       fraction of free transactions to be relayed and included in blocks.\\n\"\n+            \"\\n\"\n+            \"-1.0 is returned if not enough transactions and\\n\"\n+            \"blocks have been observed to make an estimate.\\n\"\n+            \"\\nExample:\\n\"\n+            + HelpExampleCli(\"estimatepriority\", \"0.1\")\n+        );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(real_type));\n+\n+    double dPriorityMedian = 0.5;\n+    if (params.size() > 0)\n+        dPriorityMedian = params[0].get_real();\n+    if (dPriorityMedian < 0.0 || dPriorityMedian > 1.0)\n+        throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid priority median (must be 0.0 to 1.0)\");\n+\n+    return mempool.estimateFreePriority(dPriorityMedian);\n+}"
      },
      {
        "sha": "9808c053fb72225522d7157cc55cef0d0ea45f64",
        "filename": "src/rpcserver.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73/src/rpcserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73/src/rpcserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcserver.cpp?ref=656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73",
        "patch": "@@ -247,6 +247,8 @@ static const CRPCCommand vRPCCommands[] =\n     { \"gettxoutsetinfo\",        &gettxoutsetinfo,        true,      false,      false },\n     { \"gettxout\",               &gettxout,               true,      false,      false },\n     { \"verifychain\",            &verifychain,            true,      false,      false },\n+    { \"estimatefee\",            &estimatefee,            true,      true,       false },\n+    { \"estimatepriority\",       &estimatepriority,       true,      true,       false },\n \n #ifdef ENABLE_WALLET\n     { \"getnetworkhashps\",       &getnetworkhashps,       true,      false,      false },"
      },
      {
        "sha": "747f9721141273ac1498d53da3f1851ff19aec9e",
        "filename": "src/rpcserver.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73/src/rpcserver.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73/src/rpcserver.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcserver.h?ref=656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73",
        "patch": "@@ -176,5 +176,7 @@ extern json_spirit::Value getblock(const json_spirit::Array& params, bool fHelp)\n extern json_spirit::Value gettxoutsetinfo(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value gettxout(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value verifychain(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value estimatefee(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value estimatepriority(const json_spirit::Array& params, bool fHelp);\n \n #endif"
      },
      {
        "sha": "290b6df5f759180a4ebed93e458f70033bb19457",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 30,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73",
        "patch": "@@ -51,9 +51,9 @@ class CMinerPolicyEstimator\n \n     // Results of estimate() are cached between new blocks, because\n     // the estimate doesn't change until a new block pulls transactions\n-    // from the memory pool and because the transaction relaying code\n-    // calls estimate on every transaction to decide whether or not it\n-    // should be relayed.\n+    // from the memory pool and because estimation is O(N) where N\n+    // is the number of data points; that becomes O(N^2) if an estimate\n+    // is done for every transaction\n     map<double, double> byPriorityCache;\n     map<double, double> byFeeCache;\n \n@@ -124,16 +124,22 @@ class CMinerPolicyEstimator\n             byFee.insert(TimeValue(GetTimeMillis(), dFeePerByte));\n             resize(byFee, nMax);\n             byFeeCache.clear();\n+            LogPrint(\"estimatefee\", \"est.fee+ %g\\n\", dFeePerByte);\n         }\n         else if (dFeePerByte == 0 && dPriority > 0)\n         {\n             byPriority.insert(TimeValue(GetTimeMillis(), dPriority));\n             resize(byPriority, nMax);\n             byPriorityCache.clear();\n+            LogPrint(\"estimatefee\", \"est.pri+ %g\\n\", dPriority);\n+        }\n+        else\n+        {\n+            LogPrint(\"estimatefee\", \"est.ignore: %g %g\\n\", dFeePerByte, dPriority);\n+            // Ignore transactions with both fee and priority > 0,\n+            // because we can't tell why miners included them (might\n+            // have been priority, might have been fee)\n         }\n-        // Ignore transactions with both fee and priority > 0,\n-        // because we can't tell why miners included them (might\n-        // have been priority, might have been fee)\n     }\n \n     double estimatePriority(double fraction)\n@@ -348,37 +354,21 @@ bool CTxMemPool::lookup(uint256 hash, CTransaction& result) const\n     return true;\n }\n \n-void CTxMemPool::estimateFees(double dPriorityMedian, double& dPriority,\n-                              double dFeeMedian, double& dFee, bool fUseHardCoded)\n+double CTxMemPool::estimateFreePriority(double dPriorityMedian, bool fUseHardCoded)\n {\n     LOCK(cs);\n-    dPriority = minerPolicyEstimator->estimatePriority(dPriorityMedian);\n+    double dPriority = minerPolicyEstimator->estimatePriority(dPriorityMedian);\n     // Hard-coded priority is 1-BTC, 144-confirmation old, 250-byte txn:\n     if (dPriority < 0 && fUseHardCoded) dPriority = COIN*144 / 250;\n-    dFee = minerPolicyEstimator->estimateFee(dFeeMedian);\n-    // Hard-coded fee is 10,000 satoshis per kilobyte (10 satoshis per byte):\n-    if (dFee < 0 && fUseHardCoded) dFee = 10.0;\n+    return dPriority;\n }\n \n-bool CTxMemPool::isDust(const CTxOut& txout)\n+double CTxMemPool::estimateFee(double dFeeMedian, bool fUseHardCoded)\n {\n-    // \"Dust\" is defined as outputs so small\n-    // (in value) that they would require that\n-    // more than 1/3 of their value in fees to\n-    // have a reasonable chance of being accepted into\n-    // a block right now.\n-    // Fees are per-byte, so:\n-    int nSize = (int)::GetSerializeSize(txout, SER_DISK,0);\n-    // ... and assume it will need a 148-byte CTxIn to spend:\n-    nSize += 148;\n-\n-    // Use 0.01 (lowest 1%) as threshold to estimate fee-per-byte:\n-    double dMinFee, dUnused;\n-    estimateFees(0.01, dUnused, 0.01, dMinFee, true);\n-\n-    // Need to pay more than 1/3 of value?\n-    bool fIsDust = dMinFee*nSize > txout.nValue/3;\n-    return fIsDust;\n+    LOCK(cs);\n+    double dFee = minerPolicyEstimator->estimateFee(dFeeMedian);\n+    if (dFee < 0 && fUseHardCoded) dFee = CTransaction::nMinTxFee / 1000.0;\n+    return dFee;\n }\n \n void CTxMemPool::writeEntry(CAutoFile& file, const uint256& txid, std::set<uint256>& alreadyWritten) const"
      },
      {
        "sha": "092be5e249d6cf27bd5ff6c1992ab136abf44bb3",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73",
        "patch": "@@ -12,7 +12,7 @@\n /** Fake height value used in CCoins to signify they are only in the memory pool (since 0.8) */\n static const unsigned int MEMPOOL_HEIGHT = 0x7FFFFFFF;\n \n-class CMinerPolicyEstimator; // Internal class used for estimatefees functionality\n+class CMinerPolicyEstimator; // Internal class used for estimatefee functionality\n \n /*\n  * CTxMemPool stores these:\n@@ -83,8 +83,8 @@ class CTxMemPool\n     void clear();\n     void queryHashes(std::vector<uint256>& vtxid);\n     void pruneSpent(const uint256& hash, CCoins &coins);\n-    void estimateFees(double dPriorityMedian, double& dPriority, double dFeeMedian, double& dFee, bool fUseHardCoded=false);\n-    bool isDust(const CTxOut& txout);\n+    double estimateFreePriority(double dPriorityMedian, bool fUseHardCoded=false);\n+    double estimateFee(double dFeeMedian, bool fUseHardCoded=false); // Returns satoshi-per-byte estimate\n     unsigned int GetTransactionsUpdated() const;\n     void AddTransactionsUpdated(unsigned int n);\n "
      },
      {
        "sha": "224be3b2edbe810c7f674519bafd54a43520f404",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 10,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73",
        "patch": "@@ -1232,6 +1232,8 @@ bool CWallet::CreateTransaction(const vector<pair<CScript, int64_t> >& vecSend,\n     {\n         LOCK2(cs_main, cs_wallet);\n         {\n+            // If user set nTransactionFee, always pay at least\n+            // that in fees\n             nFeeRet = nTransactionFee;\n             while (true)\n             {\n@@ -1240,7 +1242,7 @@ bool CWallet::CreateTransaction(const vector<pair<CScript, int64_t> >& vecSend,\n                 wtxNew.fFromMe = true;\n \n                 int64_t nTotalValue = nValue + nFeeRet;\n-                double dPriority = 0;\n+                double dPriorityInputs = 0;\n                 // vouts to the payees\n                 BOOST_FOREACH (const PAIRTYPE(CScript, int64_t)& s, vecSend)\n                 {\n@@ -1267,7 +1269,7 @@ bool CWallet::CreateTransaction(const vector<pair<CScript, int64_t> >& vecSend,\n                     //The priority after the next block (depth+1) is used instead of the current,\n                     //reflecting an assumption the user would accept a bit more delay for\n                     //a chance at a free transaction.\n-                    dPriority += (double)nCredit * (pcoin.first->GetDepthInMainChain()+1);\n+                    dPriorityInputs += (double)nCredit * (pcoin.first->GetDepthInMainChain()+1);\n                 }\n \n                 int64_t nChange = nValueIn - nValue - nFeeRet;\n@@ -1351,18 +1353,19 @@ bool CWallet::CreateTransaction(const vector<pair<CScript, int64_t> >& vecSend,\n                     strFailReason = _(\"Transaction too large\");\n                     return false;\n                 }\n-                dPriority = wtxNew.ComputePriority(dPriority, nBytes);\n+                double dPriority = wtxNew.ComputePriority(dPriorityInputs, nBytes);\n \n                 // Check that enough fee is included\n-                int64_t nPayFee = nTransactionFee * (1 + (int64_t)nBytes / 1000);\n-                bool fAllowFree = AllowFree(dPriority);\n-                int64_t nMinFee = GetMinFee(wtxNew, nBytes, fAllowFree, GMF_SEND);\n-                if (nFeeRet < max(nPayFee, nMinFee))\n+                int64_t nFeeNeeded = 0;\n+                if (!AllowFree(wtxNew, dPriority, nBytes, GMF_SEND))\n+                    nFeeNeeded = GetMinFee(nBytes, GMF_SEND);\n+\n+                if (nFeeRet < nFeeNeeded)\n                 {\n-                    nFeeRet = max(nPayFee, nMinFee);\n-                    continue;\n+                    nFeeRet = nFeeNeeded;\n+                    continue; // loop again with higher fee\n                 }\n-\n+                \n                 // Fill vtxPrev by copying from previous transactions vtxPrev\n                 wtxNew.AddSupportingTransactions();\n                 wtxNew.fTimeReceivedIsTxTime = true;"
      }
    ]
  },
  {
    "sha": "0fb46bf4e67afb44ec676452fdc8e29a2e2919c5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowZmI0NmJmNGU2N2FmYjQ0ZWM2NzY0NTJmZGM4ZTI5YTJlMjkxOWM1",
    "commit": {
      "author": {
        "name": "Mike Hearn",
        "email": "mike@plan99.net",
        "date": "2013-12-27T21:42:18Z"
      },
      "committer": {
        "name": "Mike Hearn",
        "email": "mike@plan99.net",
        "date": "2013-12-27T21:42:18Z"
      },
      "message": "Track fees being paid to get confirmed within N blocks.",
      "tree": {
        "sha": "dc4a67a3cfb6cc2d61a44b4516ce3a4a933c8e76",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/dc4a67a3cfb6cc2d61a44b4516ce3a4a933c8e76"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0fb46bf4e67afb44ec676452fdc8e29a2e2919c5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0fb46bf4e67afb44ec676452fdc8e29a2e2919c5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0fb46bf4e67afb44ec676452fdc8e29a2e2919c5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0fb46bf4e67afb44ec676452fdc8e29a2e2919c5/comments",
    "author": {
      "login": "mikehearn",
      "id": 971089,
      "node_id": "MDQ6VXNlcjk3MTA4OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/971089?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mikehearn",
      "html_url": "https://github.com/mikehearn",
      "followers_url": "https://api.github.com/users/mikehearn/followers",
      "following_url": "https://api.github.com/users/mikehearn/following{/other_user}",
      "gists_url": "https://api.github.com/users/mikehearn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mikehearn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mikehearn/subscriptions",
      "organizations_url": "https://api.github.com/users/mikehearn/orgs",
      "repos_url": "https://api.github.com/users/mikehearn/repos",
      "events_url": "https://api.github.com/users/mikehearn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mikehearn/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mikehearn",
      "id": 971089,
      "node_id": "MDQ6VXNlcjk3MTA4OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/971089?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mikehearn",
      "html_url": "https://github.com/mikehearn",
      "followers_url": "https://api.github.com/users/mikehearn/followers",
      "following_url": "https://api.github.com/users/mikehearn/following{/other_user}",
      "gists_url": "https://api.github.com/users/mikehearn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mikehearn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mikehearn/subscriptions",
      "organizations_url": "https://api.github.com/users/mikehearn/orgs",
      "repos_url": "https://api.github.com/users/mikehearn/repos",
      "events_url": "https://api.github.com/users/mikehearn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mikehearn/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73"
      }
    ],
    "stats": {
      "total": 259,
      "additions": 251,
      "deletions": 8
    },
    "files": [
      {
        "sha": "7a2a010e63f695d09310ef7657e0c89dc3ec0edc",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 5,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0fb46bf4e67afb44ec676452fdc8e29a2e2919c5/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0fb46bf4e67afb44ec676452fdc8e29a2e2919c5/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=0fb46bf4e67afb44ec676452fdc8e29a2e2919c5",
        "patch": "@@ -1799,11 +1799,7 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n             LogPrintf(\"- Connect: %.2fms\\n\", (GetTimeMicros() - nStart) * 0.001);\n \n         // Accepted into block, means remove from memory pool\n-        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n-        {\n-            mempool.remove(tx, false, pindex->nHeight-1);\n-            mempool.removeConflicts(tx);\n-        }\n+        mempool.removeForBlock(block.vtx, pindex->nHeight-1);\n     }\n \n     // Flush changes to global coin state"
      },
      {
        "sha": "4ba8d313a292cb3e08b5f156d7bc9cce57852c87",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 245,
        "deletions": 3,
        "changes": 248,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0fb46bf4e67afb44ec676452fdc8e29a2e2919c5/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0fb46bf4e67afb44ec676452fdc8e29a2e2919c5/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=0fb46bf4e67afb44ec676452fdc8e29a2e2919c5",
        "patch": "@@ -12,6 +12,7 @@\n #include <boost/multi_index_container.hpp>\n #include <boost/multi_index/ordered_index.hpp>\n #include <boost/multi_index/member.hpp>\n+#include <boost/circular_buffer.hpp>\n \n using namespace std;\n using namespace boost;\n@@ -104,7 +105,8 @@ class CMinerPolicyEstimator\n     }\n \n public:\n-    CMinerPolicyEstimator(size_t _nMin, size_t _nMax) : nMin(_nMin), nMax(_nMax)\n+    CMinerPolicyEstimator(size_t _nMin, size_t _nMax) \n+        : nMin(_nMin), nMax(_nMax)\n     {\n     }\n \n@@ -114,7 +116,7 @@ class CMinerPolicyEstimator\n             what.erase(what.begin());\n     }\n \n-    void add(const CTxMemPoolEntry& entry, unsigned int nBlockHeight)\n+    void seenTxAtHeight(const CTxMemPoolEntry& entry, unsigned int nBlockHeight)\n     {\n         if (nBlockHeight == 0 || entry.GetTxSize() == 0) return;\n         double dFeePerByte = entry.GetFee() / (double)entry.GetTxSize();\n@@ -150,6 +152,7 @@ class CMinerPolicyEstimator\n     {\n         return estimate(byFee, fraction, byFeeCache);\n     }\n+\n     bool Write(CAutoFile& fileout)\n     {\n         return Write(fileout, byPriority) && Write(fileout, byFee);\n@@ -160,6 +163,208 @@ class CMinerPolicyEstimator\n     }\n };\n \n+//\n+// Another one, this time that measures the median fee/priority for transactions being\n+// confirmed within N blocks.\n+//\n+\n+class CBlockAverage\n+{\n+private:\n+    boost::circular_buffer<double> feePerKilobyteSamples;\n+    boost::circular_buffer<double> prioritySamples;\n+\n+    // Modifies the caller!\n+    double percentile(std::vector<double>& buf, double p) const {\n+        if (buf.size() == 0)\n+            return -1;\n+        int index = buf.size() * p;\n+        // Technically, the median for a list of even numbers is the mean of the two\n+        // middle elements. However we don't bother with that here.\n+        std::nth_element(buf.begin(), buf.begin() + index, buf.end());\n+        return buf[index];\n+    }\n+\n+    std::vector<double> buf2vec(boost::circular_buffer<double> buf) const\n+    {\n+        std::vector<double> vec(buf.begin(), buf.end());\n+        return vec;\n+    }\n+\n+public:\n+    CBlockAverage() : feePerKilobyteSamples(1000), prioritySamples(1000) {}\n+\n+    void RecordFee(double feePerKilobyte) {\n+        feePerKilobyteSamples.push_back(feePerKilobyte);\n+    }\n+\n+    void RecordPriority(double priority) {\n+        prioritySamples.push_back(priority);\n+    }\n+\n+    int FeeSamples() const { return feePerKilobyteSamples.size(); }\n+    int PrioSamples() const { return prioritySamples.size(); }\n+\n+    double MedianFee() const\n+    {\n+        return PercentileFee(0.5);\n+    }\n+\n+    double PercentileFee(double p) const \n+    { \n+        std::vector<double> vec = buf2vec(feePerKilobyteSamples);\n+        if (false)\n+        {\n+            // Print out the raw samples with the median marked.\n+            std::sort(vec.begin(), vec.end());\n+            std::string tmp = \"fee samples: \";\n+            for (size_t i = 0; i < vec.size(); i++) {\n+                if (i == vec.size() * p)\n+                    tmp += \"*\";\n+                tmp += boost::to_string(vec[i]);\n+                tmp += \" \";\n+            }\n+            tmp += \"\\n\";\n+            LogPrint(\"estimatefee2\", tmp.c_str());\n+        }\n+        return percentile(vec, p);\n+    }\n+\n+    double MedianPriority() const \n+    { \n+        std::vector<double> vec = buf2vec(prioritySamples);\n+        return percentile(vec, 0.5);\n+    }\n+\n+    void Write(CAutoFile& fileout) const\n+    {\n+        std::vector<double> vec = buf2vec(feePerKilobyteSamples);\n+        fileout << vec;\n+        vec = buf2vec(prioritySamples);\n+        fileout << vec;\n+    }\n+\n+    void Read(CAutoFile& filein) {\n+        std::vector<double> vec;\n+        filein >> vec;\n+        feePerKilobyteSamples.assign(vec.begin(), vec.end());\n+        vec.clear();\n+        filein >> vec;\n+        prioritySamples.assign(vec.begin(), vec.end());\n+        if (feePerKilobyteSamples.size() + prioritySamples.size() > 0)\n+            LogPrint(\"estimatefee2\", \"Read %d fee samples and %d priority samples\\n\", feePerKilobyteSamples.size(), prioritySamples.size());\n+    }\n+};\n+\n+class CMinerPolicyEstimator2\n+{\n+private:\n+    // Records observed averages transactions that confirmed within one block, two blocks, \n+    // three blocks etc.\n+    std::vector<CBlockAverage> history;\n+\n+    int nBestSeenHeight;\n+\n+    // nBlocksAgo is 0 based, i.e. transactions that confirmed in the highest seen block are\n+    // nBlocksAgo == 0, transactions in the block before that are nBlocksAgo == 1 etc.\n+    void seenTxConfirm(double dFeePerKilobyte, double dPriority, int nBlocksAgo)\n+    {\n+        // Last entry records \"everything else\".\n+        nBlocksAgo = min(nBlocksAgo, (int) history.size() - 1);\n+        assert(nBlocksAgo >= 0);\n+        CBlockAverage& avg = history.at(nBlocksAgo);\n+        // We assume that if there was a fee, that was responsible for the confirmation. We\n+        // only bother tracking priority for free transactions, as otherwise it's hard to know\n+        // what caused the tx to be confirmed.\n+        LogPrint(\"estimatefee2\", \"Seen TX confirm: %g fee per kilobyte/%g priority, took %d blocks\\n\", dFeePerKilobyte, dPriority, nBlocksAgo);\n+        if (dFeePerKilobyte > 0)\n+            avg.RecordFee(dFeePerKilobyte);\n+        else\n+            avg.RecordPriority(dPriority);\n+    }\n+\n+public:\n+    CMinerPolicyEstimator2(int nEntries) : history(nEntries), nBestSeenHeight(0) {}\n+\n+    void seenBlock(const std::vector<CTxMemPoolEntry>& entries, int nBlockHeight)\n+    {\n+        if (nBlockHeight <= nBestSeenHeight)\n+        {\n+            // Ignore side chains and re-orgs for now, in the hope that they won't\n+            // affect the estimate much.\n+            return;   \n+        }\n+        nBestSeenHeight = nBlockHeight;\n+        BOOST_FOREACH(const CTxMemPoolEntry& entry, entries)\n+        {\n+            // How many blocks did it take for miners to include this transaction?\n+            int delta = nBlockHeight - entry.GetHeight();\n+            if (delta <= 0)\n+            {\n+                // Re-org made us lose height, this should only happen if we happen\n+                // to re-org on a difficulty transition point: very rare!\n+                continue;\n+            }\n+            // Re-adjust to be fee-per-1000-bytes which is what the mining code uses. If we don't do\n+            // this we can end up calculating median fees below the 0.8.x min fee.\n+            double dFeePerKilobyte = entry.GetFee() / ((double)entry.GetTxSize()/1000.0);\n+            double dPriority = entry.GetPriority(nBlockHeight);\n+            seenTxConfirm(dFeePerKilobyte, dPriority, delta - 1);\n+        }\n+        for (size_t i = 0; i < history.size(); i++) {\n+            if (history[i].FeeSamples() + history[i].PrioSamples() > 0)\n+                LogPrint(\"estimatefee2\", \"estimates: for confirming within %d blocks based on %d/%d samples, fee=%g/%g (10%%) per kilobyte, prio=%g\\n\", \n+                    i, \n+                    history[i].FeeSamples(), history[i].PrioSamples(),\n+                    history[i].MedianFee(), history[i].PercentileFee(0.1), history[i].MedianPriority());\n+        }\n+    }    \n+\n+    // Can return -1 if we don't have any data for that many blocks back. nBlocksToConfirm is 1 based.\n+    double estimateFee(int nBlocksToConfirm) \n+    {\n+        assert(nBlocksToConfirm >= 1);\n+        nBlocksToConfirm--;\n+        nBlocksToConfirm = min(nBlocksToConfirm, (int) history.size() - 1);\n+        return history.at(nBlocksToConfirm).MedianFee();\n+    }\n+\n+    // Can return -1 if we don't have any data for that many blocks back. nBlocksToConfirm is 1 based.\n+    double estimatePriority(int nBlocksToConfirm) \n+    {\n+        assert(nBlocksToConfirm >= 1);\n+        nBlocksToConfirm--;\n+        nBlocksToConfirm = min(nBlocksToConfirm, (int) history.size() - 1);\n+        return history.at(nBlocksToConfirm).MedianPriority();\n+    }\n+\n+    void Write(CAutoFile& fileout) const\n+    {\n+        fileout << nBestSeenHeight;\n+        fileout << history.size();\n+        BOOST_FOREACH(const CBlockAverage& entry, history)\n+        {\n+            entry.Write(fileout);\n+        }\n+    }\n+\n+    void Read(CAutoFile& filein)\n+    {\n+        filein >> nBestSeenHeight;\n+        size_t numEntries;\n+        filein >> numEntries;\n+        history.clear();\n+        for (size_t i = 0; i < numEntries; i++)\n+        {\n+            CBlockAverage entry;\n+            entry.Read(filein);\n+            history.push_back(entry);\n+        }\n+    }\n+};\n+\n+\n+\n CTxMemPoolEntry::CTxMemPoolEntry()\n {\n     nHeight = MEMPOOL_HEIGHT;\n@@ -197,11 +402,15 @@ CTxMemPool::CTxMemPool()\n     // well in practice, giving reasonable estimates within a few\n     // blocks and stable estimates over time.\n     minerPolicyEstimator = new CMinerPolicyEstimator(100, 10000);\n+    // We don't care about calculating the right fee to get confirmed in >1000 blocks,\n+    // we just assume a free transaction will always confirm within that window.\n+    minerPolicyEstimator2 = new CMinerPolicyEstimator2(1000);\n }\n \n CTxMemPool::~CTxMemPool()\n {\n     delete minerPolicyEstimator;\n+    delete minerPolicyEstimator2;\n }\n \n void CTxMemPool::pruneSpent(const uint256 &hashTx, CCoins &coins)\n@@ -262,7 +471,7 @@ bool CTxMemPool::remove(const CTransaction &tx, bool fRecursive, unsigned int nB\n         }\n         if (mapTx.count(hash))\n         {\n-            minerPolicyEstimator->add(mapTx[hash], nBlockHeight);\n+            minerPolicyEstimator->seenTxAtHeight(mapTx[hash], nBlockHeight);\n             BOOST_FOREACH(const CTxIn& txin, tx.vin)\n                 mapNextTx.erase(txin.prevout);\n             mapTx.erase(hash);\n@@ -287,6 +496,25 @@ bool CTxMemPool::removeConflicts(const CTransaction &tx)\n     return true;\n }\n \n+// Called when a block is connected. Removes from mempool and updates the miner fee estimator.\n+void CTxMemPool::removeForBlock(const std::vector<CTransaction>& vtx, unsigned int nBlockHeight)\n+{\n+    LOCK(cs);\n+    std::vector<CTxMemPoolEntry> entries;\n+    BOOST_FOREACH(const CTransaction& tx, vtx)\n+    {\n+        uint256 hash = tx.GetHash();\n+        if (mapTx.count(hash))\n+            entries.push_back(mapTx[hash]);\n+    }\n+    minerPolicyEstimator2->seenBlock(entries, nBlockHeight);\n+    BOOST_FOREACH(const CTransaction& tx, vtx)\n+    {\n+        remove(tx, false, nBlockHeight);\n+        removeConflicts(tx);\n+    }\n+}\n+\n void CTxMemPool::clear()\n {\n     LOCK(cs);\n@@ -371,6 +599,18 @@ double CTxMemPool::estimateFee(double dFeeMedian, bool fUseHardCoded)\n     return dFee;\n }\n \n+double CTxMemPool::estimateFeeToConfirmWithin(int nBlocksToConfirm)\n+{\n+    LOCK(cs);\n+    return minerPolicyEstimator2->estimateFee(nBlocksToConfirm);\n+}\n+\n+double CTxMemPool::estimatePriorityToConfirmWithin(int nBlocksToConfirm)\n+{\n+    LOCK(cs);\n+    return minerPolicyEstimator2->estimatePriority(nBlocksToConfirm);\n+}\n+\n void CTxMemPool::writeEntry(CAutoFile& file, const uint256& txid, std::set<uint256>& alreadyWritten) const\n {\n     if (alreadyWritten.count(txid)) return;\n@@ -420,6 +660,7 @@ bool CTxMemPool::Write() const\n             writeEntry(fileout, it->first, alreadyWritten);\n         }\n         minerPolicyEstimator->Write(fileout);\n+        minerPolicyEstimator2->Write(fileout);\n     }\n     catch (std::exception &e) {\n         // We don't care much about errors; saving\n@@ -464,6 +705,7 @@ bool CTxMemPool::Read(std::list<CTxMemPoolEntry>& vecEntries) const\n             vecEntries.push_back(e);\n         }\n         minerPolicyEstimator->Read(filein);\n+        minerPolicyEstimator2->Read(filein);\n     }\n     catch (std::exception &e) {\n         // Not a big deal if mempool.dat gets corrupted:"
      },
      {
        "sha": "9e34ecf4bf6aa362b7ad549ab0d644a0867a2794",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0fb46bf4e67afb44ec676452fdc8e29a2e2919c5/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0fb46bf4e67afb44ec676452fdc8e29a2e2919c5/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=0fb46bf4e67afb44ec676452fdc8e29a2e2919c5",
        "patch": "@@ -13,6 +13,7 @@\n static const unsigned int MEMPOOL_HEIGHT = 0x7FFFFFFF;\n \n class CMinerPolicyEstimator; // Internal class used for estimatefee functionality\n+class CMinerPolicyEstimator2;\n \n /*\n  * CTxMemPool stores these:\n@@ -57,6 +58,7 @@ class CTxMemPool\n     bool fSanityCheck; // Normally false, true if -checkmempool or -regtest\n     unsigned int nTransactionsUpdated;\n     CMinerPolicyEstimator* minerPolicyEstimator; // For estimating transaction fees\n+    CMinerPolicyEstimator2* minerPolicyEstimator2;\n \n     void writeEntry(CAutoFile& file, const uint256& txid, std::set<uint256>& alreadyWritten) const;\n \n@@ -80,11 +82,14 @@ class CTxMemPool\n     bool addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry);\n     bool remove(const CTransaction &tx, bool fRecursive = false, unsigned int nBlockHeight = 0);\n     bool removeConflicts(const CTransaction &tx);\n+    void removeForBlock(const std::vector<CTransaction>& vtx, unsigned int nBlockHeight);\n     void clear();\n     void queryHashes(std::vector<uint256>& vtxid);\n     void pruneSpent(const uint256& hash, CCoins &coins);\n     double estimateFreePriority(double dPriorityMedian, bool fUseHardCoded=false);\n     double estimateFee(double dFeeMedian, bool fUseHardCoded=false); // Returns satoshi-per-byte estimate\n+    double estimatePriorityToConfirmWithin(int nBlocks);\n+    double estimateFeeToConfirmWithin(int nBlocks);\n     unsigned int GetTransactionsUpdated() const;\n     void AddTransactionsUpdated(unsigned int n);\n "
      }
    ]
  },
  {
    "sha": "07eeec5c12fbb22b4e53a63fdf0186fa2339f06b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowN2VlZWM1YzEyZmJiMjJiNGU1M2E2M2ZkZjAxODZmYTIzMzlmMDZi",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2014-03-13T16:00:23Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2014-03-13T16:00:23Z"
      },
      "message": "Merge pull request #30 from mikehearn/estimator2\n\nTrack fees being paid to get confirmed within N blocks.",
      "tree": {
        "sha": "dc4a67a3cfb6cc2d61a44b4516ce3a4a933c8e76",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/dc4a67a3cfb6cc2d61a44b4516ce3a4a933c8e76"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/07eeec5c12fbb22b4e53a63fdf0186fa2339f06b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/07eeec5c12fbb22b4e53a63fdf0186fa2339f06b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/07eeec5c12fbb22b4e53a63fdf0186fa2339f06b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/07eeec5c12fbb22b4e53a63fdf0186fa2339f06b/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/656f8a7f2cf0c83ed9ac172f4d5ec555f90fed73"
      },
      {
        "sha": "0fb46bf4e67afb44ec676452fdc8e29a2e2919c5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0fb46bf4e67afb44ec676452fdc8e29a2e2919c5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0fb46bf4e67afb44ec676452fdc8e29a2e2919c5"
      }
    ],
    "stats": {
      "total": 259,
      "additions": 251,
      "deletions": 8
    },
    "files": [
      {
        "sha": "7a2a010e63f695d09310ef7657e0c89dc3ec0edc",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 5,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/07eeec5c12fbb22b4e53a63fdf0186fa2339f06b/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/07eeec5c12fbb22b4e53a63fdf0186fa2339f06b/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=07eeec5c12fbb22b4e53a63fdf0186fa2339f06b",
        "patch": "@@ -1799,11 +1799,7 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n             LogPrintf(\"- Connect: %.2fms\\n\", (GetTimeMicros() - nStart) * 0.001);\n \n         // Accepted into block, means remove from memory pool\n-        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n-        {\n-            mempool.remove(tx, false, pindex->nHeight-1);\n-            mempool.removeConflicts(tx);\n-        }\n+        mempool.removeForBlock(block.vtx, pindex->nHeight-1);\n     }\n \n     // Flush changes to global coin state"
      },
      {
        "sha": "4ba8d313a292cb3e08b5f156d7bc9cce57852c87",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 245,
        "deletions": 3,
        "changes": 248,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/07eeec5c12fbb22b4e53a63fdf0186fa2339f06b/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/07eeec5c12fbb22b4e53a63fdf0186fa2339f06b/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=07eeec5c12fbb22b4e53a63fdf0186fa2339f06b",
        "patch": "@@ -12,6 +12,7 @@\n #include <boost/multi_index_container.hpp>\n #include <boost/multi_index/ordered_index.hpp>\n #include <boost/multi_index/member.hpp>\n+#include <boost/circular_buffer.hpp>\n \n using namespace std;\n using namespace boost;\n@@ -104,7 +105,8 @@ class CMinerPolicyEstimator\n     }\n \n public:\n-    CMinerPolicyEstimator(size_t _nMin, size_t _nMax) : nMin(_nMin), nMax(_nMax)\n+    CMinerPolicyEstimator(size_t _nMin, size_t _nMax) \n+        : nMin(_nMin), nMax(_nMax)\n     {\n     }\n \n@@ -114,7 +116,7 @@ class CMinerPolicyEstimator\n             what.erase(what.begin());\n     }\n \n-    void add(const CTxMemPoolEntry& entry, unsigned int nBlockHeight)\n+    void seenTxAtHeight(const CTxMemPoolEntry& entry, unsigned int nBlockHeight)\n     {\n         if (nBlockHeight == 0 || entry.GetTxSize() == 0) return;\n         double dFeePerByte = entry.GetFee() / (double)entry.GetTxSize();\n@@ -150,6 +152,7 @@ class CMinerPolicyEstimator\n     {\n         return estimate(byFee, fraction, byFeeCache);\n     }\n+\n     bool Write(CAutoFile& fileout)\n     {\n         return Write(fileout, byPriority) && Write(fileout, byFee);\n@@ -160,6 +163,208 @@ class CMinerPolicyEstimator\n     }\n };\n \n+//\n+// Another one, this time that measures the median fee/priority for transactions being\n+// confirmed within N blocks.\n+//\n+\n+class CBlockAverage\n+{\n+private:\n+    boost::circular_buffer<double> feePerKilobyteSamples;\n+    boost::circular_buffer<double> prioritySamples;\n+\n+    // Modifies the caller!\n+    double percentile(std::vector<double>& buf, double p) const {\n+        if (buf.size() == 0)\n+            return -1;\n+        int index = buf.size() * p;\n+        // Technically, the median for a list of even numbers is the mean of the two\n+        // middle elements. However we don't bother with that here.\n+        std::nth_element(buf.begin(), buf.begin() + index, buf.end());\n+        return buf[index];\n+    }\n+\n+    std::vector<double> buf2vec(boost::circular_buffer<double> buf) const\n+    {\n+        std::vector<double> vec(buf.begin(), buf.end());\n+        return vec;\n+    }\n+\n+public:\n+    CBlockAverage() : feePerKilobyteSamples(1000), prioritySamples(1000) {}\n+\n+    void RecordFee(double feePerKilobyte) {\n+        feePerKilobyteSamples.push_back(feePerKilobyte);\n+    }\n+\n+    void RecordPriority(double priority) {\n+        prioritySamples.push_back(priority);\n+    }\n+\n+    int FeeSamples() const { return feePerKilobyteSamples.size(); }\n+    int PrioSamples() const { return prioritySamples.size(); }\n+\n+    double MedianFee() const\n+    {\n+        return PercentileFee(0.5);\n+    }\n+\n+    double PercentileFee(double p) const \n+    { \n+        std::vector<double> vec = buf2vec(feePerKilobyteSamples);\n+        if (false)\n+        {\n+            // Print out the raw samples with the median marked.\n+            std::sort(vec.begin(), vec.end());\n+            std::string tmp = \"fee samples: \";\n+            for (size_t i = 0; i < vec.size(); i++) {\n+                if (i == vec.size() * p)\n+                    tmp += \"*\";\n+                tmp += boost::to_string(vec[i]);\n+                tmp += \" \";\n+            }\n+            tmp += \"\\n\";\n+            LogPrint(\"estimatefee2\", tmp.c_str());\n+        }\n+        return percentile(vec, p);\n+    }\n+\n+    double MedianPriority() const \n+    { \n+        std::vector<double> vec = buf2vec(prioritySamples);\n+        return percentile(vec, 0.5);\n+    }\n+\n+    void Write(CAutoFile& fileout) const\n+    {\n+        std::vector<double> vec = buf2vec(feePerKilobyteSamples);\n+        fileout << vec;\n+        vec = buf2vec(prioritySamples);\n+        fileout << vec;\n+    }\n+\n+    void Read(CAutoFile& filein) {\n+        std::vector<double> vec;\n+        filein >> vec;\n+        feePerKilobyteSamples.assign(vec.begin(), vec.end());\n+        vec.clear();\n+        filein >> vec;\n+        prioritySamples.assign(vec.begin(), vec.end());\n+        if (feePerKilobyteSamples.size() + prioritySamples.size() > 0)\n+            LogPrint(\"estimatefee2\", \"Read %d fee samples and %d priority samples\\n\", feePerKilobyteSamples.size(), prioritySamples.size());\n+    }\n+};\n+\n+class CMinerPolicyEstimator2\n+{\n+private:\n+    // Records observed averages transactions that confirmed within one block, two blocks, \n+    // three blocks etc.\n+    std::vector<CBlockAverage> history;\n+\n+    int nBestSeenHeight;\n+\n+    // nBlocksAgo is 0 based, i.e. transactions that confirmed in the highest seen block are\n+    // nBlocksAgo == 0, transactions in the block before that are nBlocksAgo == 1 etc.\n+    void seenTxConfirm(double dFeePerKilobyte, double dPriority, int nBlocksAgo)\n+    {\n+        // Last entry records \"everything else\".\n+        nBlocksAgo = min(nBlocksAgo, (int) history.size() - 1);\n+        assert(nBlocksAgo >= 0);\n+        CBlockAverage& avg = history.at(nBlocksAgo);\n+        // We assume that if there was a fee, that was responsible for the confirmation. We\n+        // only bother tracking priority for free transactions, as otherwise it's hard to know\n+        // what caused the tx to be confirmed.\n+        LogPrint(\"estimatefee2\", \"Seen TX confirm: %g fee per kilobyte/%g priority, took %d blocks\\n\", dFeePerKilobyte, dPriority, nBlocksAgo);\n+        if (dFeePerKilobyte > 0)\n+            avg.RecordFee(dFeePerKilobyte);\n+        else\n+            avg.RecordPriority(dPriority);\n+    }\n+\n+public:\n+    CMinerPolicyEstimator2(int nEntries) : history(nEntries), nBestSeenHeight(0) {}\n+\n+    void seenBlock(const std::vector<CTxMemPoolEntry>& entries, int nBlockHeight)\n+    {\n+        if (nBlockHeight <= nBestSeenHeight)\n+        {\n+            // Ignore side chains and re-orgs for now, in the hope that they won't\n+            // affect the estimate much.\n+            return;   \n+        }\n+        nBestSeenHeight = nBlockHeight;\n+        BOOST_FOREACH(const CTxMemPoolEntry& entry, entries)\n+        {\n+            // How many blocks did it take for miners to include this transaction?\n+            int delta = nBlockHeight - entry.GetHeight();\n+            if (delta <= 0)\n+            {\n+                // Re-org made us lose height, this should only happen if we happen\n+                // to re-org on a difficulty transition point: very rare!\n+                continue;\n+            }\n+            // Re-adjust to be fee-per-1000-bytes which is what the mining code uses. If we don't do\n+            // this we can end up calculating median fees below the 0.8.x min fee.\n+            double dFeePerKilobyte = entry.GetFee() / ((double)entry.GetTxSize()/1000.0);\n+            double dPriority = entry.GetPriority(nBlockHeight);\n+            seenTxConfirm(dFeePerKilobyte, dPriority, delta - 1);\n+        }\n+        for (size_t i = 0; i < history.size(); i++) {\n+            if (history[i].FeeSamples() + history[i].PrioSamples() > 0)\n+                LogPrint(\"estimatefee2\", \"estimates: for confirming within %d blocks based on %d/%d samples, fee=%g/%g (10%%) per kilobyte, prio=%g\\n\", \n+                    i, \n+                    history[i].FeeSamples(), history[i].PrioSamples(),\n+                    history[i].MedianFee(), history[i].PercentileFee(0.1), history[i].MedianPriority());\n+        }\n+    }    \n+\n+    // Can return -1 if we don't have any data for that many blocks back. nBlocksToConfirm is 1 based.\n+    double estimateFee(int nBlocksToConfirm) \n+    {\n+        assert(nBlocksToConfirm >= 1);\n+        nBlocksToConfirm--;\n+        nBlocksToConfirm = min(nBlocksToConfirm, (int) history.size() - 1);\n+        return history.at(nBlocksToConfirm).MedianFee();\n+    }\n+\n+    // Can return -1 if we don't have any data for that many blocks back. nBlocksToConfirm is 1 based.\n+    double estimatePriority(int nBlocksToConfirm) \n+    {\n+        assert(nBlocksToConfirm >= 1);\n+        nBlocksToConfirm--;\n+        nBlocksToConfirm = min(nBlocksToConfirm, (int) history.size() - 1);\n+        return history.at(nBlocksToConfirm).MedianPriority();\n+    }\n+\n+    void Write(CAutoFile& fileout) const\n+    {\n+        fileout << nBestSeenHeight;\n+        fileout << history.size();\n+        BOOST_FOREACH(const CBlockAverage& entry, history)\n+        {\n+            entry.Write(fileout);\n+        }\n+    }\n+\n+    void Read(CAutoFile& filein)\n+    {\n+        filein >> nBestSeenHeight;\n+        size_t numEntries;\n+        filein >> numEntries;\n+        history.clear();\n+        for (size_t i = 0; i < numEntries; i++)\n+        {\n+            CBlockAverage entry;\n+            entry.Read(filein);\n+            history.push_back(entry);\n+        }\n+    }\n+};\n+\n+\n+\n CTxMemPoolEntry::CTxMemPoolEntry()\n {\n     nHeight = MEMPOOL_HEIGHT;\n@@ -197,11 +402,15 @@ CTxMemPool::CTxMemPool()\n     // well in practice, giving reasonable estimates within a few\n     // blocks and stable estimates over time.\n     minerPolicyEstimator = new CMinerPolicyEstimator(100, 10000);\n+    // We don't care about calculating the right fee to get confirmed in >1000 blocks,\n+    // we just assume a free transaction will always confirm within that window.\n+    minerPolicyEstimator2 = new CMinerPolicyEstimator2(1000);\n }\n \n CTxMemPool::~CTxMemPool()\n {\n     delete minerPolicyEstimator;\n+    delete minerPolicyEstimator2;\n }\n \n void CTxMemPool::pruneSpent(const uint256 &hashTx, CCoins &coins)\n@@ -262,7 +471,7 @@ bool CTxMemPool::remove(const CTransaction &tx, bool fRecursive, unsigned int nB\n         }\n         if (mapTx.count(hash))\n         {\n-            minerPolicyEstimator->add(mapTx[hash], nBlockHeight);\n+            minerPolicyEstimator->seenTxAtHeight(mapTx[hash], nBlockHeight);\n             BOOST_FOREACH(const CTxIn& txin, tx.vin)\n                 mapNextTx.erase(txin.prevout);\n             mapTx.erase(hash);\n@@ -287,6 +496,25 @@ bool CTxMemPool::removeConflicts(const CTransaction &tx)\n     return true;\n }\n \n+// Called when a block is connected. Removes from mempool and updates the miner fee estimator.\n+void CTxMemPool::removeForBlock(const std::vector<CTransaction>& vtx, unsigned int nBlockHeight)\n+{\n+    LOCK(cs);\n+    std::vector<CTxMemPoolEntry> entries;\n+    BOOST_FOREACH(const CTransaction& tx, vtx)\n+    {\n+        uint256 hash = tx.GetHash();\n+        if (mapTx.count(hash))\n+            entries.push_back(mapTx[hash]);\n+    }\n+    minerPolicyEstimator2->seenBlock(entries, nBlockHeight);\n+    BOOST_FOREACH(const CTransaction& tx, vtx)\n+    {\n+        remove(tx, false, nBlockHeight);\n+        removeConflicts(tx);\n+    }\n+}\n+\n void CTxMemPool::clear()\n {\n     LOCK(cs);\n@@ -371,6 +599,18 @@ double CTxMemPool::estimateFee(double dFeeMedian, bool fUseHardCoded)\n     return dFee;\n }\n \n+double CTxMemPool::estimateFeeToConfirmWithin(int nBlocksToConfirm)\n+{\n+    LOCK(cs);\n+    return minerPolicyEstimator2->estimateFee(nBlocksToConfirm);\n+}\n+\n+double CTxMemPool::estimatePriorityToConfirmWithin(int nBlocksToConfirm)\n+{\n+    LOCK(cs);\n+    return minerPolicyEstimator2->estimatePriority(nBlocksToConfirm);\n+}\n+\n void CTxMemPool::writeEntry(CAutoFile& file, const uint256& txid, std::set<uint256>& alreadyWritten) const\n {\n     if (alreadyWritten.count(txid)) return;\n@@ -420,6 +660,7 @@ bool CTxMemPool::Write() const\n             writeEntry(fileout, it->first, alreadyWritten);\n         }\n         minerPolicyEstimator->Write(fileout);\n+        minerPolicyEstimator2->Write(fileout);\n     }\n     catch (std::exception &e) {\n         // We don't care much about errors; saving\n@@ -464,6 +705,7 @@ bool CTxMemPool::Read(std::list<CTxMemPoolEntry>& vecEntries) const\n             vecEntries.push_back(e);\n         }\n         minerPolicyEstimator->Read(filein);\n+        minerPolicyEstimator2->Read(filein);\n     }\n     catch (std::exception &e) {\n         // Not a big deal if mempool.dat gets corrupted:"
      },
      {
        "sha": "9e34ecf4bf6aa362b7ad549ab0d644a0867a2794",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/07eeec5c12fbb22b4e53a63fdf0186fa2339f06b/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/07eeec5c12fbb22b4e53a63fdf0186fa2339f06b/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=07eeec5c12fbb22b4e53a63fdf0186fa2339f06b",
        "patch": "@@ -13,6 +13,7 @@\n static const unsigned int MEMPOOL_HEIGHT = 0x7FFFFFFF;\n \n class CMinerPolicyEstimator; // Internal class used for estimatefee functionality\n+class CMinerPolicyEstimator2;\n \n /*\n  * CTxMemPool stores these:\n@@ -57,6 +58,7 @@ class CTxMemPool\n     bool fSanityCheck; // Normally false, true if -checkmempool or -regtest\n     unsigned int nTransactionsUpdated;\n     CMinerPolicyEstimator* minerPolicyEstimator; // For estimating transaction fees\n+    CMinerPolicyEstimator2* minerPolicyEstimator2;\n \n     void writeEntry(CAutoFile& file, const uint256& txid, std::set<uint256>& alreadyWritten) const;\n \n@@ -80,11 +82,14 @@ class CTxMemPool\n     bool addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry);\n     bool remove(const CTransaction &tx, bool fRecursive = false, unsigned int nBlockHeight = 0);\n     bool removeConflicts(const CTransaction &tx);\n+    void removeForBlock(const std::vector<CTransaction>& vtx, unsigned int nBlockHeight);\n     void clear();\n     void queryHashes(std::vector<uint256>& vtxid);\n     void pruneSpent(const uint256& hash, CCoins &coins);\n     double estimateFreePriority(double dPriorityMedian, bool fUseHardCoded=false);\n     double estimateFee(double dFeeMedian, bool fUseHardCoded=false); // Returns satoshi-per-byte estimate\n+    double estimatePriorityToConfirmWithin(int nBlocks);\n+    double estimateFeeToConfirmWithin(int nBlocks);\n     unsigned int GetTransactionsUpdated() const;\n     void AddTransactionsUpdated(unsigned int n);\n "
      }
    ]
  }
]