[
  {
    "sha": "1df206f854d222230dcffd58e1b496567e570978",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxZGYyMDZmODU0ZDIyMjIzMGRjZmZkNThlMWI0OTY1NjdlNTcwOTc4",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2017-09-29T04:21:28Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-01-11T19:13:24Z"
      },
      "message": "Disallow using addresses in createmultisig\n\nMake createmultisig only accept public keys with the old functionality\nmarked as deprecated.\n\nSplits _createmultisig_redeemscript into two functions, one for\ngetting public keys from UniValue and one for getting addresses\nfrom UniValue and then their respective public keys. The one for\nretrieving address's public keys is located in rpcwallet.cpp\n\nChanges addwitnessaddress's output to be a JSON object with\ntwo fields, address and redeemscript.\n\nAdds a test to deprecated_rpc.py for testing the deprecation.\n\nUpdate the tests to use addwitnessaddress or give only public keys\nto createmultisig. Anything that used addwitnessaddress was also\nupdated to reflect the new API.",
      "tree": {
        "sha": "ae69bf08457642e4bd354461bbc391747605a1aa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ae69bf08457642e4bd354461bbc391747605a1aa"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1df206f854d222230dcffd58e1b496567e570978",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1df206f854d222230dcffd58e1b496567e570978",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1df206f854d222230dcffd58e1b496567e570978",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1df206f854d222230dcffd58e1b496567e570978/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0910cbe4ef31eb95fd76c7c2f820419fe64a3150",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0910cbe4ef31eb95fd76c7c2f820419fe64a3150",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0910cbe4ef31eb95fd76c7c2f820419fe64a3150"
      }
    ],
    "stats": {
      "total": 330,
      "additions": 204,
      "deletions": 126
    },
    "files": [
      {
        "sha": "4fbd605d9e5c9f8753ceeddf2d8eafba22af2970",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1df206f854d222230dcffd58e1b496567e570978/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1df206f854d222230dcffd58e1b496567e570978/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=1df206f854d222230dcffd58e1b496567e570978",
        "patch": "@@ -133,6 +133,7 @@ BITCOIN_CORE_H = \\\n   rpc/safemode.h \\\n   rpc/server.h \\\n   rpc/register.h \\\n+  rpc/util.h \\\n   scheduler.h \\\n   script/sigcache.h \\\n   script/sign.h \\\n@@ -352,6 +353,7 @@ libbitcoin_util_a_SOURCES = \\\n   fs.cpp \\\n   random.cpp \\\n   rpc/protocol.cpp \\\n+  rpc/util.cpp \\\n   support/cleanse.cpp \\\n   sync.cpp \\\n   threadinterrupt.cpp \\"
      },
      {
        "sha": "62bcdea31c4ec4b68c04a66a9a6069cf33d37aee",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 77,
        "changes": 109,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1df206f854d222230dcffd58e1b496567e570978/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1df206f854d222230dcffd58e1b496567e570978/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=1df206f854d222230dcffd58e1b496567e570978",
        "patch": "@@ -15,6 +15,7 @@\n #include <netbase.h>\n #include <rpc/blockchain.h>\n #include <rpc/server.h>\n+#include <rpc/util.h>\n #include <timedata.h>\n #include <util.h>\n #include <utilstrencodings.h>\n@@ -254,88 +255,21 @@ UniValue validateaddress(const JSONRPCRequest& request)\n // Needed even with !ENABLE_WALLET, to pass (ignored) pointers around\n class CWallet;\n \n-/**\n- * Used by addmultisigaddress / createmultisig:\n- */\n-CScript _createmultisig_redeemScript(CWallet * const pwallet, const UniValue& params)\n-{\n-    int nRequired = params[0].get_int();\n-    const UniValue& keys = params[1].get_array();\n-\n-    // Gather public keys\n-    if (nRequired < 1)\n-        throw std::runtime_error(\"a multisignature address must require at least one key to redeem\");\n-    if ((int)keys.size() < nRequired)\n-        throw std::runtime_error(\n-            strprintf(\"not enough keys supplied \"\n-                      \"(got %u keys, but need at least %d to redeem)\", keys.size(), nRequired));\n-    if (keys.size() > 16)\n-        throw std::runtime_error(\"Number of addresses involved in the multisignature address creation > 16\\nReduce the number\");\n-    std::vector<CPubKey> pubkeys;\n-    pubkeys.resize(keys.size());\n-    for (unsigned int i = 0; i < keys.size(); i++)\n-    {\n-        const std::string& ks = keys[i].get_str();\n-#ifdef ENABLE_WALLET\n-        // Case 1: Bitcoin address and we have full public key:\n-        CTxDestination dest = DecodeDestination(ks);\n-        if (pwallet && IsValidDestination(dest)) {\n-            CKeyID key = GetKeyForDestination(*pwallet, dest);\n-            if (key.IsNull()) {\n-                throw std::runtime_error(strprintf(\"%s does not refer to a key\", ks));\n-            }\n-            CPubKey vchPubKey;\n-            if (!pwallet->GetPubKey(key, vchPubKey)) {\n-                throw std::runtime_error(strprintf(\"no full public key for address %s\", ks));\n-            }\n-            if (!vchPubKey.IsFullyValid())\n-                throw std::runtime_error(\" Invalid public key: \"+ks);\n-            pubkeys[i] = vchPubKey;\n-        }\n-\n-        // Case 2: hex public key\n-        else\n-#endif\n-        if (IsHex(ks))\n-        {\n-            CPubKey vchPubKey(ParseHex(ks));\n-            if (!vchPubKey.IsFullyValid())\n-                throw std::runtime_error(\" Invalid public key: \"+ks);\n-            pubkeys[i] = vchPubKey;\n-        }\n-        else\n-        {\n-            throw std::runtime_error(\" Invalid public key: \"+ks);\n-        }\n-    }\n-    CScript result = GetScriptForMultisig(nRequired, pubkeys);\n-\n-    if (result.size() > MAX_SCRIPT_ELEMENT_SIZE)\n-        throw std::runtime_error(\n-                strprintf(\"redeemScript exceeds size limit: %d > %d\", result.size(), MAX_SCRIPT_ELEMENT_SIZE));\n-\n-    return result;\n-}\n-\n UniValue createmultisig(const JSONRPCRequest& request)\n {\n-#ifdef ENABLE_WALLET\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n-#else\n-    CWallet * const pwallet = nullptr;\n-#endif\n-\n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 2)\n     {\n         std::string msg = \"createmultisig nrequired [\\\"key\\\",...]\\n\"\n             \"\\nCreates a multi-signature address with n signature of m keys required.\\n\"\n             \"It returns a json object with the address and redeemScript.\\n\"\n-\n+            \"DEPRECATION WARNING: Using addresses with createmultisig is deprecated. Clients must\\n\"\n+            \"transition to using addmultisigaddress to create multisig addresses with addresses known\\n\"\n+            \"to the wallet before upgrading to v0.17. To use the deprecated functionality, start bitcoind with -deprecatedrpc=createmultisig\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. nrequired      (numeric, required) The number of required signatures out of the n keys or addresses.\\n\"\n-            \"2. \\\"keys\\\"       (string, required) A json array of keys which are bitcoin addresses or hex-encoded public keys\\n\"\n+            \"1. nrequired                    (numeric, required) The number of required signatures out of the n keys or addresses.\\n\"\n+            \"2. \\\"keys\\\"                       (string, required) A json array of hex-encoded public keys\\n\"\n             \"     [\\n\"\n-            \"       \\\"key\\\"    (string) bitcoin address or hex-encoded public key\\n\"\n+            \"       \\\"key\\\"                    (string) The hex-encoded public key\\n\"\n             \"       ,...\\n\"\n             \"     ]\\n\"\n \n@@ -346,16 +280,37 @@ UniValue createmultisig(const JSONRPCRequest& request)\n             \"}\\n\"\n \n             \"\\nExamples:\\n\"\n-            \"\\nCreate a multisig address from 2 addresses\\n\"\n-            + HelpExampleCli(\"createmultisig\", \"2 \\\"[\\\\\\\"16sSauSf5pF2UkUwvKGq4qjNRzBZYqgEL5\\\\\\\",\\\\\\\"171sgjn4YtPu27adkKGrdDwzRTxnRkBfKV\\\\\\\"]\\\"\") +\n+            \"\\nCreate a multisig address from 2 public keys\\n\"\n+            + HelpExampleCli(\"createmultisig\", \"2 \\\"[\\\\\\\"03789ed0bb717d88f7d321a368d905e7430207ebbd82bd342cf11ae157a7ace5fd\\\\\\\",\\\\\\\"03dbc6764b8884a92e871274b87583e6d5c2a58819473e17e107ef3f6aa5a61626\\\\\\\"]\\\"\") +\n             \"\\nAs a json rpc call\\n\"\n-            + HelpExampleRpc(\"createmultisig\", \"2, \\\"[\\\\\\\"16sSauSf5pF2UkUwvKGq4qjNRzBZYqgEL5\\\\\\\",\\\\\\\"171sgjn4YtPu27adkKGrdDwzRTxnRkBfKV\\\\\\\"]\\\"\")\n+            + HelpExampleRpc(\"createmultisig\", \"2, \\\"[\\\\\\\"03789ed0bb717d88f7d321a368d905e7430207ebbd82bd342cf11ae157a7ace5fd\\\\\\\",\\\\\\\"03dbc6764b8884a92e871274b87583e6d5c2a58819473e17e107ef3f6aa5a61626\\\\\\\"]\\\"\")\n         ;\n         throw std::runtime_error(msg);\n     }\n \n+    int required = request.params[0].get_int();\n+\n+    // Get the public keys\n+    const UniValue& keys = request.params[1].get_array();\n+    std::vector<CPubKey> pubkeys;\n+    for (unsigned int i = 0; i < keys.size(); ++i) {\n+        if (IsHex(keys[i].get_str()) && (keys[i].get_str().length() == 66 || keys[i].get_str().length() == 130)) {\n+            pubkeys.push_back(HexToPubKey(keys[i].get_str()));\n+        } else {\n+#ifdef ENABLE_WALLET\n+            CWallet* const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (IsDeprecatedRPCEnabled(\"createmultisig\") && EnsureWalletIsAvailable(pwallet, false)) {\n+                pubkeys.push_back(AddrToPubKey(pwallet, keys[i].get_str()));\n+            } else\n+#endif\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"Invalid public key: %s\\nNote that from v0.16, createmultisig no longer accepts addresses.\"\n+            \" Clients must transition to using addmultisigaddress to create multisig addresses with addresses known to the wallet before upgrading to v0.17.\"\n+            \" To use the deprecated functionality, start bitcoind with -deprecatedrpc=createmultisig\", keys[i].get_str()));\n+        }\n+    }\n+\n     // Construct using pay-to-script-hash:\n-    CScript inner = _createmultisig_redeemScript(pwallet, request.params);\n+    CScript inner = CreateMultisigRedeemscript(required, pubkeys);\n     CScriptID innerID(inner);\n \n     UniValue result(UniValue::VOBJ);"
      },
      {
        "sha": "09ded4e46e73b5166f9fbe59e1dfa5ca824ec208",
        "filename": "src/rpc/util.cpp",
        "status": "added",
        "additions": 68,
        "deletions": 0,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1df206f854d222230dcffd58e1b496567e570978/src/rpc/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1df206f854d222230dcffd58e1b496567e570978/src/rpc/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.cpp?ref=1df206f854d222230dcffd58e1b496567e570978",
        "patch": "@@ -0,0 +1,68 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <base58.h>\n+#include <keystore.h>\n+#include <pubkey.h>\n+#include <rpc/protocol.h>\n+#include <rpc/util.h>\n+#include <tinyformat.h>\n+#include <utilstrencodings.h>\n+\n+// Converts a hex string to a public key if possible\n+CPubKey HexToPubKey(const std::string& hex_in)\n+{\n+    if (!IsHex(hex_in)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key: \" + hex_in);\n+    }\n+    CPubKey vchPubKey(ParseHex(hex_in));\n+    if (!vchPubKey.IsFullyValid()) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key: \" + hex_in);\n+    }\n+    return vchPubKey;\n+}\n+\n+// Retrieves a public key for an address from the given CKeyStore\n+CPubKey AddrToPubKey(CKeyStore* const keystore, const std::string& addr_in)\n+{\n+    CTxDestination dest = DecodeDestination(addr_in);\n+    if (!IsValidDestination(dest)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address: \" + addr_in);\n+    }\n+    CKeyID key = GetKeyForDestination(*keystore, dest);\n+    if (key.IsNull()) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"%s does not refer to a key\", addr_in));\n+    }\n+    CPubKey vchPubKey;\n+    if (!keystore->GetPubKey(key, vchPubKey)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"no full public key for address %s\", addr_in));\n+    }\n+    if (!vchPubKey.IsFullyValid()) {\n+       throw JSONRPCError(RPC_INTERNAL_ERROR, \"Wallet contains an invalid public key\");\n+    }\n+    return vchPubKey;\n+}\n+\n+// Creates a multisig redeemscript from a given list of public keys and number required.\n+CScript CreateMultisigRedeemscript(const int required, const std::vector<CPubKey>& pubkeys)\n+{\n+    // Gather public keys\n+    if (required < 1) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"a multisignature address must require at least one key to redeem\");\n+    }\n+    if ((int)pubkeys.size() < required) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"not enough keys supplied (got %u keys, but need at least %d to redeem)\", pubkeys.size(), required));\n+    }\n+    if (pubkeys.size() > 16) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Number of keys involved in the multisignature address creation > 16\\nReduce the number\");\n+    }\n+\n+    CScript result = GetScriptForMultisig(required, pubkeys);\n+\n+    if (result.size() > MAX_SCRIPT_ELEMENT_SIZE) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, (strprintf(\"redeemScript exceeds size limit: %d > %d\", result.size(), MAX_SCRIPT_ELEMENT_SIZE)));\n+    }\n+\n+    return result;\n+}"
      },
      {
        "sha": "568a4260ba3dcb683da4d53bf3d38f390c3b8718",
        "filename": "src/rpc/util.h",
        "status": "added",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1df206f854d222230dcffd58e1b496567e570978/src/rpc/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1df206f854d222230dcffd58e1b496567e570978/src/rpc/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.h?ref=1df206f854d222230dcffd58e1b496567e570978",
        "patch": "@@ -0,0 +1,19 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_RPC_UTIL_H\n+#define BITCOIN_RPC_UTIL_H\n+\n+#include <string>\n+#include <vector>\n+\n+class CKeyStore;\n+class CPubKey;\n+class CScript;\n+\n+CPubKey HexToPubKey(const std::string& hex_in);\n+CPubKey AddrToPubKey(CKeyStore* const keystore, const std::string& addr_in);\n+CScript CreateMultisigRedeemscript(const int required, const std::vector<CPubKey>& pubkeys);\n+\n+#endif // BITCOIN_RPC_UTIL_H"
      },
      {
        "sha": "bd8c9ecb0cd8d5f373ab1713755c2cc3311b4b9c",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 12,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1df206f854d222230dcffd58e1b496567e570978/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1df206f854d222230dcffd58e1b496567e570978/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=1df206f854d222230dcffd58e1b496567e570978",
        "patch": "@@ -18,6 +18,7 @@\n #include <rpc/mining.h>\n #include <rpc/safemode.h>\n #include <rpc/server.h>\n+#include <rpc/util.h>\n #include <script/sign.h>\n #include <timedata.h>\n #include <util.h>\n@@ -1161,9 +1162,6 @@ UniValue sendmany(const JSONRPCRequest& request)\n     return wtx.GetHash().GetHex();\n }\n \n-// Defined in rpc/misc.cpp\n-extern CScript _createmultisig_redeemScript(CWallet * const pwallet, const UniValue& params);\n-\n UniValue addmultisigaddress(const JSONRPCRequest& request)\n {\n     CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n@@ -1181,16 +1179,22 @@ UniValue addmultisigaddress(const JSONRPCRequest& request)\n             \"If 'account' is specified (DEPRECATED), assign address to that account.\\n\"\n \n             \"\\nArguments:\\n\"\n-            \"1. nrequired        (numeric, required) The number of required signatures out of the n keys or addresses.\\n\"\n-            \"2. \\\"keys\\\"         (string, required) A json array of bitcoin addresses or hex-encoded public keys\\n\"\n+            \"1. nrequired                      (numeric, required) The number of required signatures out of the n keys or addresses.\\n\"\n+            \"2. \\\"keys\\\"                         (string, required) A json array of bitcoin addresses or hex-encoded public keys\\n\"\n             \"     [\\n\"\n-            \"       \\\"address\\\"  (string) bitcoin address or hex-encoded public key\\n\"\n+            \"       \\\"address\\\"                  (string) bitcoin address or hex-encoded public key\\n\"\n             \"       ...,\\n\"\n             \"     ]\\n\"\n-            \"3. \\\"account\\\"      (string, optional) DEPRECATED. An account to assign the addresses to.\\n\"\n+            \"3. \\\"account\\\"                      (string, optional) DEPRECATED. An account to assign the addresses to.\\n\"\n \n             \"\\nResult:\\n\"\n-            \"\\\"address\\\"         (string) A bitcoin address associated with the keys.\\n\"\n+            \"{\\n\"\n+            \"  \\\"address\\\":\\\"multisigaddress\\\",    (string) The value of the new multisig address.\\n\"\n+            \"  \\\"redeemScript\\\":\\\"script\\\"         (string) The string value of the hex-encoded redemption script.\\n\"\n+            \"}\\n\"\n+            \"\\nResult (DEPRECATED. To see this result in v0.16 instead, please start bitcoind with -deprecatedrpc=addmultisigaddress).\\n\"\n+            \"        clients should transition to the new output api before upgrading to v0.17.\\n\"\n+            \"\\\"address\\\"                         (string) A bitcoin address associated with the keys.\\n\"\n \n             \"\\nExamples:\\n\"\n             \"\\nAdd a multisig address from 2 addresses\\n\"\n@@ -1207,14 +1211,34 @@ UniValue addmultisigaddress(const JSONRPCRequest& request)\n     if (!request.params[2].isNull())\n         strAccount = AccountFromValue(request.params[2]);\n \n+    int required = request.params[0].get_int();\n+\n+    // Get the public keys\n+    const UniValue& keys_or_addrs = request.params[1].get_array();\n+    std::vector<CPubKey> pubkeys;\n+    for (unsigned int i = 0; i < keys_or_addrs.size(); ++i) {\n+        if (IsHex(keys_or_addrs[i].get_str()) && (keys_or_addrs[i].get_str().length() == 66 || keys_or_addrs[i].get_str().length() == 130)) {\n+            pubkeys.push_back(HexToPubKey(keys_or_addrs[i].get_str()));\n+        } else {\n+            pubkeys.push_back(AddrToPubKey(pwallet, keys_or_addrs[i].get_str()));\n+        }\n+    }\n+\n     // Construct using pay-to-script-hash:\n-    CScript inner = _createmultisig_redeemScript(pwallet, request.params);\n+    CScript inner = CreateMultisigRedeemscript(required, pubkeys);\n     pwallet->AddCScript(inner);\n-\n     CTxDestination dest = pwallet->AddAndGetDestinationForScript(inner, g_address_type);\n-\n     pwallet->SetAddressBook(dest, strAccount, \"send\");\n-    return EncodeDestination(dest);\n+\n+    // Return old style interface\n+    if (IsDeprecatedRPCEnabled(\"addmultisigaddress\")) {\n+        return EncodeDestination(dest);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    result.pushKV(\"address\", EncodeDestination(dest));\n+    result.pushKV(\"redeemScript\", HexStr(inner.begin(), inner.end()));\n+    return result;\n }\n \n class Witnessifier : public boost::static_visitor<bool>"
      },
      {
        "sha": "9984e171f01f63535d8d5a145b3a20cd1e3bed94",
        "filename": "test/functional/address_types.py",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1df206f854d222230dcffd58e1b496567e570978/test/functional/address_types.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1df206f854d222230dcffd58e1b496567e570978/test/functional/address_types.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/address_types.py?ref=1df206f854d222230dcffd58e1b496567e570978",
        "patch": "@@ -117,14 +117,14 @@ def run_test(self):\n \n         # addmultisigaddress with at least 1 uncompressed key should return a legacy address.\n         for node in range(4):\n-            self.test_address(node, self.nodes[node].addmultisigaddress(2, [uncompressed_1, uncompressed_2]), True, 'legacy')\n-            self.test_address(node, self.nodes[node].addmultisigaddress(2, [compressed_1, uncompressed_2]), True, 'legacy')\n-            self.test_address(node, self.nodes[node].addmultisigaddress(2, [uncompressed_1, compressed_2]), True, 'legacy')\n+            self.test_address(node, self.nodes[node].addmultisigaddress(2, [uncompressed_1, uncompressed_2])['address'], True, 'legacy')\n+            self.test_address(node, self.nodes[node].addmultisigaddress(2, [compressed_1, uncompressed_2])['address'], True, 'legacy')\n+            self.test_address(node, self.nodes[node].addmultisigaddress(2, [uncompressed_1, compressed_2])['address'], True, 'legacy')\n         # addmultisigaddress with all compressed keys should return the appropriate address type (even when the keys are not ours).\n-        self.test_address(0, self.nodes[0].addmultisigaddress(2, [compressed_1, compressed_2]), True, 'legacy')\n-        self.test_address(1, self.nodes[1].addmultisigaddress(2, [compressed_1, compressed_2]), True, 'p2sh-segwit')\n-        self.test_address(2, self.nodes[2].addmultisigaddress(2, [compressed_1, compressed_2]), True, 'p2sh-segwit')\n-        self.test_address(3, self.nodes[3].addmultisigaddress(2, [compressed_1, compressed_2]), True, 'bech32')\n+        self.test_address(0, self.nodes[0].addmultisigaddress(2, [compressed_1, compressed_2])['address'], True, 'legacy')\n+        self.test_address(1, self.nodes[1].addmultisigaddress(2, [compressed_1, compressed_2])['address'], True, 'p2sh-segwit')\n+        self.test_address(2, self.nodes[2].addmultisigaddress(2, [compressed_1, compressed_2])['address'], True, 'p2sh-segwit')\n+        self.test_address(3, self.nodes[3].addmultisigaddress(2, [compressed_1, compressed_2])['address'], True, 'bech32')\n \n         for explicit_type, multisig, from_node in itertools.product([False, True], [False, True], range(4)):\n             address_type = None\n@@ -155,7 +155,7 @@ def run_test(self):\n                 else:\n                     addr1 = self.nodes[to_node].getnewaddress()\n                     addr2 = self.nodes[to_node].getnewaddress()\n-                    address = self.nodes[to_node].addmultisigaddress(2, [addr1, addr2])\n+                    address = self.nodes[to_node].addmultisigaddress(2, [addr1, addr2])['address']\n \n                 # Do some sanity checking on the created address\n                 if address_type is not None:"
      },
      {
        "sha": "d6f25158ef3077aa1bb929555b6d67499df7bed7",
        "filename": "test/functional/deprecated_rpc.py",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1df206f854d222230dcffd58e1b496567e570978/test/functional/deprecated_rpc.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1df206f854d222230dcffd58e1b496567e570978/test/functional/deprecated_rpc.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/deprecated_rpc.py?ref=1df206f854d222230dcffd58e1b496567e570978",
        "patch": "@@ -10,7 +10,7 @@ class DeprecatedRpcTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 2\n         self.setup_clean_chain = True\n-        self.extra_args = [[], [\"-deprecatedrpc=estimatefee\"]]\n+        self.extra_args = [[], [\"-deprecatedrpc=estimatefee\", \"-deprecatedrpc=createmultisig\"]]\n \n     def run_test(self):\n         self.log.info(\"estimatefee: Shows deprecated message\")\n@@ -19,5 +19,9 @@ def run_test(self):\n         self.log.info(\"Using -deprecatedrpc=estimatefee bypasses the error\")\n         self.nodes[1].estimatefee(1)\n \n+        self.log.info(\"Make sure that -deprecatedrpc=createmultisig allows it to take addresses\")\n+        assert_raises_rpc_error(-5, \"Invalid public key\", self.nodes[0].createmultisig, 1, [self.nodes[0].getnewaddress()])\n+        self.nodes[1].createmultisig(1, [self.nodes[1].getnewaddress()])\n+\n if __name__ == '__main__':\n     DeprecatedRpcTest().main()"
      },
      {
        "sha": "b3d6549229cc5336b07ee19b785c6bcf13fe9e6d",
        "filename": "test/functional/fundrawtransaction.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1df206f854d222230dcffd58e1b496567e570978/test/functional/fundrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1df206f854d222230dcffd58e1b496567e570978/test/functional/fundrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/fundrawtransaction.py?ref=1df206f854d222230dcffd58e1b496567e570978",
        "patch": "@@ -358,7 +358,7 @@ def run_test(self):\n         addr1Obj = self.nodes[1].validateaddress(addr1)\n         addr2Obj = self.nodes[1].validateaddress(addr2)\n \n-        mSigObj = self.nodes[1].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey']])\n+        mSigObj = self.nodes[1].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey']])['address']\n \n         inputs = []\n         outputs = {mSigObj:1.1}\n@@ -391,7 +391,7 @@ def run_test(self):\n         addr4Obj = self.nodes[1].validateaddress(addr4)\n         addr5Obj = self.nodes[1].validateaddress(addr5)\n \n-        mSigObj = self.nodes[1].addmultisigaddress(4, [addr1Obj['pubkey'], addr2Obj['pubkey'], addr3Obj['pubkey'], addr4Obj['pubkey'], addr5Obj['pubkey']])\n+        mSigObj = self.nodes[1].addmultisigaddress(4, [addr1Obj['pubkey'], addr2Obj['pubkey'], addr3Obj['pubkey'], addr4Obj['pubkey'], addr5Obj['pubkey']])['address']\n \n         inputs = []\n         outputs = {mSigObj:1.1}\n@@ -418,7 +418,7 @@ def run_test(self):\n         addr1Obj = self.nodes[2].validateaddress(addr1)\n         addr2Obj = self.nodes[2].validateaddress(addr2)\n \n-        mSigObj = self.nodes[2].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey']])\n+        mSigObj = self.nodes[2].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey']])['address']\n \n \n         # send 1.2 BTC to msig addr"
      },
      {
        "sha": "be9be83839b0fc204589cd83599d4e2970b9e6d8",
        "filename": "test/functional/importmulti.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1df206f854d222230dcffd58e1b496567e570978/test/functional/importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1df206f854d222230dcffd58e1b496567e570978/test/functional/importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/importmulti.py?ref=1df206f854d222230dcffd58e1b496567e570978",
        "patch": "@@ -228,7 +228,7 @@ def run_test (self):\n         sig_address_1 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         sig_address_2 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         sig_address_3 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n-        multi_sig_script = self.nodes[0].createmultisig(2, [sig_address_1['address'], sig_address_2['address'], sig_address_3['pubkey']])\n+        multi_sig_script = self.nodes[0].createmultisig(2, [sig_address_1['pubkey'], sig_address_2['pubkey'], sig_address_3['pubkey']])\n         self.nodes[1].generate(100)\n         transactionid = self.nodes[1].sendtoaddress(multi_sig_script['address'], 10.00)\n         self.nodes[1].generate(1)\n@@ -255,7 +255,7 @@ def run_test (self):\n         sig_address_1 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         sig_address_2 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         sig_address_3 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n-        multi_sig_script = self.nodes[0].createmultisig(2, [sig_address_1['address'], sig_address_2['address'], sig_address_3['pubkey']])\n+        multi_sig_script = self.nodes[0].createmultisig(2, [sig_address_1['pubkey'], sig_address_2['pubkey'], sig_address_3['pubkey']])\n         self.nodes[1].generate(100)\n         transactionid = self.nodes[1].sendtoaddress(multi_sig_script['address'], 10.00)\n         self.nodes[1].generate(1)\n@@ -282,7 +282,7 @@ def run_test (self):\n         sig_address_1 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         sig_address_2 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         sig_address_3 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n-        multi_sig_script = self.nodes[0].createmultisig(2, [sig_address_1['address'], sig_address_2['address'], sig_address_3['pubkey']])\n+        multi_sig_script = self.nodes[0].createmultisig(2, [sig_address_1['pubkey'], sig_address_2['pubkey'], sig_address_3['pubkey']])\n         self.nodes[1].generate(100)\n         transactionid = self.nodes[1].sendtoaddress(multi_sig_script['address'], 10.00)\n         self.nodes[1].generate(1)\n@@ -309,7 +309,7 @@ def run_test (self):\n         sig_address_1 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         sig_address_2 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n         sig_address_3 = self.nodes[0].validateaddress(self.nodes[0].getnewaddress())\n-        multi_sig_script = self.nodes[0].createmultisig(2, [sig_address_1['address'], sig_address_2['address'], sig_address_3['pubkey']])\n+        multi_sig_script = self.nodes[0].createmultisig(2, [sig_address_1['pubkey'], sig_address_2['pubkey'], sig_address_3['pubkey']])\n         self.nodes[1].generate(100)\n         transactionid = self.nodes[1].sendtoaddress(multi_sig_script['address'], 10.00)\n         self.nodes[1].generate(1)"
      },
      {
        "sha": "ba71ac0967eb74e633600f227faf80f7ac05835f",
        "filename": "test/functional/listtransactions.py",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1df206f854d222230dcffd58e1b496567e570978/test/functional/listtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1df206f854d222230dcffd58e1b496567e570978/test/functional/listtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/listtransactions.py?ref=1df206f854d222230dcffd58e1b496567e570978",
        "patch": "@@ -81,7 +81,8 @@ def run_test(self):\n                            {\"category\":\"receive\",\"amount\":Decimal(\"0.44\")},\n                            {\"txid\":txid, \"account\" : \"toself\"} )\n \n-        multisig = self.nodes[1].createmultisig(1, [self.nodes[1].getnewaddress()])\n+        pubkey = self.nodes[1].validateaddress(self.nodes[1].getnewaddress())['pubkey']\n+        multisig = self.nodes[1].createmultisig(1, [pubkey])\n         self.nodes[0].importaddress(multisig[\"redeemScript\"], \"watchonly\", False, True)\n         txid = self.nodes[1].sendtoaddress(multisig[\"address\"], 0.1)\n         self.nodes[1].generate(1)"
      },
      {
        "sha": "1fbf4c138126a04854b3f87176d46528f296d489",
        "filename": "test/functional/nulldummy.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1df206f854d222230dcffd58e1b496567e570978/test/functional/nulldummy.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1df206f854d222230dcffd58e1b496567e570978/test/functional/nulldummy.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/nulldummy.py?ref=1df206f854d222230dcffd58e1b496567e570978",
        "patch": "@@ -46,7 +46,7 @@ def set_test_params(self):\n \n     def run_test(self):\n         self.address = self.nodes[0].getnewaddress()\n-        self.ms_address = self.nodes[0].addmultisigaddress(1,[self.address])\n+        self.ms_address = self.nodes[0].addmultisigaddress(1,[self.address])['address']\n         self.wit_address = self.nodes[0].addwitnessaddress(self.address)\n         self.wit_ms_address = self.nodes[0].addwitnessaddress(self.ms_address)\n "
      },
      {
        "sha": "d39d86b3108fd747da976c8e4fafb51c9201ac01",
        "filename": "test/functional/rawtransactions.py",
        "status": "modified",
        "additions": 9,
        "deletions": 4,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1df206f854d222230dcffd58e1b496567e570978/test/functional/rawtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1df206f854d222230dcffd58e1b496567e570978/test/functional/rawtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rawtransactions.py?ref=1df206f854d222230dcffd58e1b496567e570978",
        "patch": "@@ -145,7 +145,12 @@ def run_test(self):\n         addr1Obj = self.nodes[2].validateaddress(addr1)\n         addr2Obj = self.nodes[2].validateaddress(addr2)\n \n-        mSigObj = self.nodes[2].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey']])\n+        # Tests for createmultisig and addmultisigaddress\n+        assert_raises_rpc_error(-5, \"Invalid public key\", self.nodes[0].createmultisig, 1, [\"01020304\"])\n+        self.nodes[0].createmultisig(2, [addr1Obj['pubkey'], addr2Obj['pubkey']]) # createmultisig can only take public keys\n+        assert_raises_rpc_error(-5, \"Invalid public key\", self.nodes[0].createmultisig, 2, [addr1Obj['pubkey'], addr1]) # addmultisigaddress can take both pubkeys and addresses so long as they are in the wallet, which is tested here.\n+\n+        mSigObj = self.nodes[2].addmultisigaddress(2, [addr1Obj['pubkey'], addr1])['address']\n \n         #use balance deltas instead of absolute values\n         bal = self.nodes[2].getbalance()\n@@ -168,7 +173,7 @@ def run_test(self):\n         addr2Obj = self.nodes[2].validateaddress(addr2)\n         addr3Obj = self.nodes[2].validateaddress(addr3)\n \n-        mSigObj = self.nodes[2].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey'], addr3Obj['pubkey']])\n+        mSigObj = self.nodes[2].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey'], addr3Obj['pubkey']])['address']\n \n         txId = self.nodes[0].sendtoaddress(mSigObj, 2.2)\n         decTx = self.nodes[0].gettransaction(txId)\n@@ -213,8 +218,8 @@ def run_test(self):\n         addr1Obj = self.nodes[1].validateaddress(addr1)\n         addr2Obj = self.nodes[2].validateaddress(addr2)\n \n-        self.nodes[1].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey']])\n-        mSigObj = self.nodes[2].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey']])\n+        self.nodes[1].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey']])['address']\n+        mSigObj = self.nodes[2].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey']])['address']\n         mSigObjValid = self.nodes[2].validateaddress(mSigObj)\n \n         txId = self.nodes[0].sendtoaddress(mSigObj, 2.2)"
      },
      {
        "sha": "d3de23e061e3fe53270032ad849e6bdc32a72386",
        "filename": "test/functional/segwit.py",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1df206f854d222230dcffd58e1b496567e570978/test/functional/segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1df206f854d222230dcffd58e1b496567e570978/test/functional/segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/segwit.py?ref=1df206f854d222230dcffd58e1b496567e570978",
        "patch": "@@ -133,7 +133,7 @@ def run_test(self):\n         for i in range(3):\n             newaddress = self.nodes[i].getnewaddress()\n             self.pubkey.append(self.nodes[i].validateaddress(newaddress)[\"pubkey\"])\n-            multiaddress = self.nodes[i].addmultisigaddress(1, [self.pubkey[-1]])\n+            multiaddress = self.nodes[i].addmultisigaddress(1, [self.pubkey[-1]])['address']\n             multiscript = CScript([OP_1, hex_str_to_bytes(self.pubkey[-1]), OP_1, OP_CHECKMULTISIG])\n             p2sh_addr = self.nodes[i].addwitnessaddress(newaddress)\n             bip173_addr = self.nodes[i].addwitnessaddress(newaddress, False)\n@@ -328,19 +328,19 @@ def run_test(self):\n         solvable_anytime = []                       # These outputs should be solvable after importpubkey\n         unseen_anytime = []                         # These outputs should never be seen\n \n-        uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [uncompressed_spendable_address[0], compressed_spendable_address[0]]))\n-        uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [uncompressed_spendable_address[0], uncompressed_spendable_address[0]]))\n-        compressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_spendable_address[0]]))\n-        uncompressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], uncompressed_solvable_address[0]]))\n-        compressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_solvable_address[0]]))\n-        compressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_solvable_address[0], compressed_solvable_address[1]]))\n+        uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [uncompressed_spendable_address[0], compressed_spendable_address[0]])['address'])\n+        uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [uncompressed_spendable_address[0], uncompressed_spendable_address[0]])['address'])\n+        compressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_spendable_address[0]])['address'])\n+        uncompressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], uncompressed_solvable_address[0]])['address'])\n+        compressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_solvable_address[0]])['address'])\n+        compressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_solvable_address[0], compressed_solvable_address[1]])['address'])\n         unknown_address = [\"mtKKyoHabkk6e4ppT7NaM7THqPUt7AzPrT\", \"2NDP3jLWAFT8NDAiUa9qiE6oBt2awmMq7Dx\"]\n \n         # Test multisig_without_privkey\n         # We have 2 public keys without private keys, use addmultisigaddress to add to wallet.\n         # Money sent to P2SH of multisig of this should only be seen after importaddress with the BASE58 P2SH address.\n \n-        multisig_without_privkey_address = self.nodes[0].addmultisigaddress(2, [pubkeys[3], pubkeys[4]])\n+        multisig_without_privkey_address = self.nodes[0].addmultisigaddress(2, [pubkeys[3], pubkeys[4]])['address']\n         script = CScript([OP_2, hex_str_to_bytes(pubkeys[3]), hex_str_to_bytes(pubkeys[4]), OP_2, OP_CHECKMULTISIG])\n         solvable_after_importaddress.append(CScript([OP_HASH160, hash160(script), OP_EQUAL]))\n \n@@ -501,11 +501,11 @@ def run_test(self):\n         solvable_anytime = []                       # These outputs should be solvable after importpubkey\n         unseen_anytime = []                         # These outputs should never be seen\n \n-        uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [uncompressed_spendable_address[0], compressed_spendable_address[0]]))\n-        uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [uncompressed_spendable_address[0], uncompressed_spendable_address[0]]))\n-        compressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_spendable_address[0]]))\n-        uncompressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_solvable_address[0], uncompressed_solvable_address[0]]))\n-        compressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_solvable_address[0]]))\n+        uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [uncompressed_spendable_address[0], compressed_spendable_address[0]])['address'])\n+        uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [uncompressed_spendable_address[0], uncompressed_spendable_address[0]])['address'])\n+        compressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_spendable_address[0]])['address'])\n+        uncompressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_solvable_address[0], uncompressed_solvable_address[0]])['address'])\n+        compressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_solvable_address[0]])['address'])\n \n         premature_witaddress = []\n "
      },
      {
        "sha": "ecd1cfc82b1bb4a297284cc0ca546661c27f0256",
        "filename": "test/functional/wallet-accounts.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1df206f854d222230dcffd58e1b496567e570978/test/functional/wallet-accounts.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1df206f854d222230dcffd58e1b496567e570978/test/functional/wallet-accounts.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet-accounts.py?ref=1df206f854d222230dcffd58e1b496567e570978",
        "patch": "@@ -126,7 +126,7 @@ def run_test(self):\n             addresses = []\n             for x in range(10):\n                 addresses.append(node.getnewaddress())\n-            multisig_address = node.addmultisigaddress(5, addresses, account.name)\n+            multisig_address = node.addmultisigaddress(5, addresses, account.name)['address']\n             account.add_address(multisig_address)\n             account.verify(node)\n             node.sendfrom(\"\", multisig_address, 50)"
      },
      {
        "sha": "86b268094c0aa7f1e2e45381bfb14cacd8fecf31",
        "filename": "test/functional/wallet-dump.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1df206f854d222230dcffd58e1b496567e570978/test/functional/wallet-dump.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1df206f854d222230dcffd58e1b496567e570978/test/functional/wallet-dump.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet-dump.py?ref=1df206f854d222230dcffd58e1b496567e570978",
        "patch": "@@ -94,7 +94,7 @@ def run_test (self):\n \n         # Test scripts dump by adding a P2SH witness and a 1-of-1 multisig address\n         witness_addr = self.nodes[0].addwitnessaddress(addrs[0][\"address\"], True)\n-        multisig_addr = self.nodes[0].addmultisigaddress(1, [addrs[1][\"address\"]])\n+        multisig_addr = self.nodes[0].addmultisigaddress(1, [addrs[1][\"address\"]])[\"address\"]\n         script_addrs = [witness_addr, multisig_addr]\n \n         # dump unencrypted wallet"
      }
    ]
  }
]