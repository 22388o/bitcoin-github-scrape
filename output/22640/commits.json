[
  {
    "sha": "df1c9674c05fe731a3430993ca6c8b5500669bf7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkZjFjOTY3NGMwNWZlNzMxYTM0MzA5OTNjYTZjOGI1NTAwNjY5YmY3",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-08-22T18:19:41Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2021-07-26T20:17:39Z"
      },
      "message": "Use robin_hood.unordered_node_map for CCoinsViewCache.cacheCoins",
      "tree": {
        "sha": "922cc50e5513990081eeef511770bafe9ced1a85",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/922cc50e5513990081eeef511770bafe9ced1a85"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/df1c9674c05fe731a3430993ca6c8b5500669bf7",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEGNRVI1NPYuZCSIrGepNdrbLETwUFAmD/GGMACgkQepNdrbLE\nTwWVDw//ep6YRtEwqF0UvnNGIlabwKtM9DvDt/Mw+U/6dtbmGx/R7AGk2/GN5HwL\npVuLnH1rESTaJ1WUxO97fIxC0IgpZ05H5W0geq3ITZ4YAZIdy/quMlUBaVbg6zYL\ngp2DPjvmPhBsTvjkLxDgErz1wGqTxDx2TNye/i7PPmnfh24/947yslbqRIY/jQK4\nppfbnMPoqxQ4OyZ2aRG904qgSM3DB3HsoZ51Lm0crT+v6d+iEBM5fE62bBbHdbby\nnTcF6T6cBQDSOsO6StJgoAiy1MN4CfPET1OKT3LjJ7LVpcEFdLjgZMki3xP9ehOH\nOFeVQsjuB59pO7nCeo+ushO57t+bMzfhoDLHJ3P/CvBDzLT51ip/fwfDko3p1OPE\n6V+SdALh8B5KapuPesP0j/2QZum6/H95vI/CSC/BS2X+XAtYqGgZ8n9axFsW2zPE\n0lSKNJ5qiAe1cEH5j4cYZDW/7hlk+QAvBPxnwEfrxL6ssXoammWtJqoaGm0Hbihw\nY2TG1a2jCG0mxQL32cPyiUfohE7SVW/WBjjvDISZ04VVx0IjDmraCXBtX46b0nEH\n+zwRjvHkGTHuKWg8gjtvHo6Phy0bJ7SGVyOCeJzKBAdpS9CorLfWZs9eZ36F4BXR\nFNx8l3hKZL+5Z71z8rtGIW9bfNlZ6ivN0IgQJb76+6L5b7zyw78=\n=NXPG\n-----END PGP SIGNATURE-----",
        "payload": "tree 922cc50e5513990081eeef511770bafe9ced1a85\nparent 2b5563bb1e6819bf46f561d94213d5fb32751359\nauthor James O'Beirne <james.obeirne@gmail.com> 1566497981 -0400\ncommitter James O'Beirne <james.obeirne@pm.me> 1627330659 -0400\n\nUse robin_hood.unordered_node_map for CCoinsViewCache.cacheCoins\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/df1c9674c05fe731a3430993ca6c8b5500669bf7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/df1c9674c05fe731a3430993ca6c8b5500669bf7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/df1c9674c05fe731a3430993ca6c8b5500669bf7/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2b5563bb1e6819bf46f561d94213d5fb32751359",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2b5563bb1e6819bf46f561d94213d5fb32751359",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2b5563bb1e6819bf46f561d94213d5fb32751359"
      }
    ],
    "stats": {
      "total": 2054,
      "additions": 2049,
      "deletions": 5
    },
    "files": [
      {
        "sha": "8b176f7946f8fa297625273cb516f08b1665099f",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/df1c9674c05fe731a3430993ca6c8b5500669bf7/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/df1c9674c05fe731a3430993ca6c8b5500669bf7/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=df1c9674c05fe731a3430993ca6c8b5500669bf7",
        "patch": "@@ -8,6 +8,8 @@\n \n #include <compressor.h>\n #include <core_memusage.h>\n+#include <crypto/siphash.h>\n+#include <robin_hood.h>\n #include <memusage.h>\n #include <primitives/transaction.h>\n #include <serialize.h>\n@@ -131,7 +133,7 @@ struct CCoinsCacheEntry\n     CCoinsCacheEntry(Coin&& coin_, unsigned char flag) : coin(std::move(coin_)), flags(flag) {}\n };\n \n-typedef std::unordered_map<COutPoint, CCoinsCacheEntry, SaltedOutpointHasher> CCoinsMap;\n+typedef robin_hood::unordered_node_map<COutPoint, CCoinsCacheEntry, SaltedOutpointHasher> CCoinsMap;\n \n /** Cursor for iterating over CoinsView state */\n class CCoinsViewCursor"
      },
      {
        "sha": "60b62f04d7c153c99fafd1d568d57ded53e4ee3d",
        "filename": "src/memusage.h",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/df1c9674c05fe731a3430993ca6c8b5500669bf7/src/memusage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/df1c9674c05fe731a3430993ca6c8b5500669bf7/src/memusage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/memusage.h?ref=df1c9674c05fe731a3430993ca6c8b5500669bf7",
        "patch": "@@ -7,6 +7,7 @@\n \n #include <indirectmap.h>\n #include <prevector.h>\n+#include <robin_hood.h>\n \n #include <stdlib.h>\n \n@@ -18,7 +19,6 @@\n #include <unordered_map>\n #include <unordered_set>\n \n-\n namespace memusage\n {\n \n@@ -167,6 +167,12 @@ static inline size_t DynamicUsage(const std::unordered_map<X, Y, Z>& m)\n     return MallocUsage(sizeof(unordered_node<std::pair<const X, Y> >)) * m.size() + MallocUsage(sizeof(void*) * m.bucket_count());\n }\n \n+template<typename X, typename Y, typename Z>\n+static inline size_t DynamicUsage(const robin_hood::unordered_node_map<X, Y, Z>& m)\n+{\n+    return MallocUsage(sizeof(unordered_node<robin_hood::pair<const X, Y> >)) * m.size() + MallocUsage(sizeof(void*) * (m.mask() + 1));\n+}\n+\n }\n \n #endif // BITCOIN_MEMUSAGE_H"
      },
      {
        "sha": "afe0326f3ef65d55a08445da5d5392adb734d217",
        "filename": "src/robin_hood.h",
        "status": "added",
        "additions": 2037,
        "deletions": 0,
        "changes": 2037,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/df1c9674c05fe731a3430993ca6c8b5500669bf7/src/robin_hood.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/df1c9674c05fe731a3430993ca6c8b5500669bf7/src/robin_hood.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/robin_hood.h?ref=df1c9674c05fe731a3430993ca6c8b5500669bf7",
        "patch": "@@ -0,0 +1,2037 @@\n+//                 ______  _____                 ______                _________\n+//  ______________ ___  /_ ___(_)_______         ___  /_ ______ ______ ______  /\n+//  __  ___/_  __ \\__  __ \\__  / __  __ \\        __  __ \\_  __ \\_  __ \\_  __  /\n+//  _  /    / /_/ /_  /_/ /_  /  _  / / /        _  / / // /_/ // /_/ // /_/ /\n+//  /_/     \\____/ /_.___/ /_/   /_/ /_/ ________/_/ /_/ \\____/ \\____/ \\__,_/\n+//                                      _/_____/\n+//\n+// robin_hood::unordered_map for C++11\n+// version 3.4.0\n+// https://github.com/martinus/robin-hood-hashing\n+//\n+// Licensed under the MIT License <http://opensource.org/licenses/MIT>.\n+// SPDX-License-Identifier: MIT\n+// Copyright (c) 2018-2019 Martin Ankerl <http://martin.ankerl.com>\n+//\n+// Permission is hereby granted, free of charge, to any person obtaining a copy\n+// of this software and associated documentation files (the \"Software\"), to deal\n+// in the Software without restriction, including without limitation the rights\n+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+// copies of the Software, and to permit persons to whom the Software is\n+// furnished to do so, subject to the following conditions:\n+//\n+// The above copyright notice and this permission notice shall be included in all\n+// copies or substantial portions of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+// SOFTWARE.\n+\n+#ifndef ROBIN_HOOD_H_INCLUDED\n+#define ROBIN_HOOD_H_INCLUDED\n+\n+// see https://semver.org/\n+#define ROBIN_HOOD_VERSION_MAJOR 3 // for incompatible API changes\n+#define ROBIN_HOOD_VERSION_MINOR 4 // for adding functionality in a backwards-compatible manner\n+#define ROBIN_HOOD_VERSION_PATCH 0 // for backwards-compatible bug fixes\n+\n+#include <algorithm>\n+#include <cstdlib>\n+#include <cstring>\n+#include <functional>\n+#include <stdexcept>\n+#include <string>\n+#include <type_traits>\n+#include <utility>\n+\n+// #define ROBIN_HOOD_LOG_ENABLED\n+#ifdef ROBIN_HOOD_LOG_ENABLED\n+#    include <iostream>\n+#    define ROBIN_HOOD_LOG(x) std::cout << __FUNCTION__ << \"@\" << __LINE__ << \": \" << x << std::endl\n+#else\n+#    define ROBIN_HOOD_LOG(x)\n+#endif\n+\n+// #define ROBIN_HOOD_TRACE_ENABLED\n+#ifdef ROBIN_HOOD_TRACE_ENABLED\n+#    include <iostream>\n+#    define ROBIN_HOOD_TRACE(x) \\\n+        std::cout << __FUNCTION__ << \"@\" << __LINE__ << \": \" << x << std::endl\n+#else\n+#    define ROBIN_HOOD_TRACE(x)\n+#endif\n+\n+// all non-argument macros should use this facility. See\n+// https://www.fluentcpp.com/2019/05/28/better-macros-better-flags/\n+#define ROBIN_HOOD(x) ROBIN_HOOD_PRIVATE_DEFINITION_##x()\n+\n+// mark unused members with this macro\n+#define ROBIN_HOOD_UNUSED(identifier)\n+\n+// bitness\n+#if SIZE_MAX == UINT32_MAX\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_BITNESS() 32\n+#elif SIZE_MAX == UINT64_MAX\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_BITNESS() 64\n+#else\n+#    error Unsupported bitness\n+#endif\n+\n+// endianess\n+#ifdef _WIN32\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_LITTLE_ENDIAN() 1\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_BIG_ENDIAN() 0\n+#else\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_LITTLE_ENDIAN() \\\n+        (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_BIG_ENDIAN() (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+#endif\n+\n+// inline\n+#ifdef _WIN32\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_NOINLINE() __declspec(noinline)\n+#else\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_NOINLINE() __attribute__((noinline))\n+#endif\n+\n+// exceptions\n+#if !defined(__cpp_exceptions) && !defined(__EXCEPTIONS) && !defined(_CPPUNWIND)\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_HAS_EXCEPTIONS() 0\n+#else\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_HAS_EXCEPTIONS() 1\n+#endif\n+\n+// count leading/trailing bits\n+#ifdef _WIN32\n+#    if ROBIN_HOOD(BITNESS) == 32\n+#        define ROBIN_HOOD_PRIVATE_DEFINITION_BITSCANFORWARD() _BitScanForward\n+#    else\n+#        define ROBIN_HOOD_PRIVATE_DEFINITION_BITSCANFORWARD() _BitScanForward64\n+#    endif\n+#    include <intrin.h>\n+#    pragma intrinsic(ROBIN_HOOD(BITSCANFORWARD))\n+#    define ROBIN_HOOD_COUNT_TRAILING_ZEROES(x)                                       \\\n+        [](size_t mask) noexcept->int {                                               \\\n+            unsigned long index;                                                      \\\n+            return ROBIN_HOOD(BITSCANFORWARD)(&index, mask) ? static_cast<int>(index) \\\n+                                                            : ROBIN_HOOD(BITNESS);    \\\n+        }                                                                             \\\n+        (x)\n+#else\n+#    if ROBIN_HOOD(BITNESS) == 32\n+#        define ROBIN_HOOD_PRIVATE_DEFINITION_CTZ() __builtin_ctzl\n+#        define ROBIN_HOOD_PRIVATE_DEFINITION_CLZ() __builtin_clzl\n+#    else\n+#        define ROBIN_HOOD_PRIVATE_DEFINITION_CTZ() __builtin_ctzll\n+#        define ROBIN_HOOD_PRIVATE_DEFINITION_CLZ() __builtin_clzll\n+#    endif\n+#    define ROBIN_HOOD_COUNT_LEADING_ZEROES(x) ((x) ? ROBIN_HOOD(CLZ)(x) : ROBIN_HOOD(BITNESS))\n+#    define ROBIN_HOOD_COUNT_TRAILING_ZEROES(x) ((x) ? ROBIN_HOOD(CTZ)(x) : ROBIN_HOOD(BITNESS))\n+#endif\n+\n+// fallthrough\n+#ifndef __has_cpp_attribute // For backwards compatibility\n+#    define __has_cpp_attribute(x) 0\n+#endif\n+#if __has_cpp_attribute(clang::fallthrough)\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_FALLTHROUGH() [[clang::fallthrough]]\n+#elif __has_cpp_attribute(gnu::fallthrough)\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_FALLTHROUGH() [[gnu::fallthrough]]\n+#else\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_FALLTHROUGH()\n+#endif\n+\n+// likely/unlikely\n+#if defined(_WIN32)\n+#    define ROBIN_HOOD_LIKELY(condition) condition\n+#    define ROBIN_HOOD_UNLIKELY(condition) condition\n+#else\n+#    define ROBIN_HOOD_LIKELY(condition) __builtin_expect(condition, 1)\n+#    define ROBIN_HOOD_UNLIKELY(condition) __builtin_expect(condition, 0)\n+#endif\n+\n+// workaround missing \"is_trivially_copyable\" in g++ < 5.0\n+// See https://stackoverflow.com/a/31798726/48181\n+#if defined(__GNUC__) && __GNUC__ < 5\n+#    define ROBIN_HOOD_IS_TRIVIALLY_COPYABLE(...) __has_trivial_copy(__VA_ARGS__)\n+#else\n+#    define ROBIN_HOOD_IS_TRIVIALLY_COPYABLE(...) std::is_trivially_copyable<__VA_ARGS__>::value\n+#endif\n+\n+// helpers for C++ versions, see https://gcc.gnu.org/onlinedocs/cpp/Standard-Predefined-Macros.html\n+#define ROBIN_HOOD_PRIVATE_DEFINITION_CXX() __cplusplus\n+#define ROBIN_HOOD_PRIVATE_DEFINITION_CXX98() 199711L\n+#define ROBIN_HOOD_PRIVATE_DEFINITION_CXX11() 201103L\n+#define ROBIN_HOOD_PRIVATE_DEFINITION_CXX14() 201402L\n+#define ROBIN_HOOD_PRIVATE_DEFINITION_CXX17() 201703L\n+\n+#if ROBIN_HOOD(CXX) >= ROBIN_HOOD(CXX17)\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_NODISCARD() [[nodiscard]]\n+#else\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_NODISCARD()\n+#endif\n+\n+namespace robin_hood {\n+\n+#if ROBIN_HOOD(CXX) >= ROBIN_HOOD(CXX14)\n+#    define ROBIN_HOOD_STD std\n+#else\n+\n+// c++11 compatibility layer\n+namespace ROBIN_HOOD_STD {\n+template <class T>\n+struct alignment_of\n+    : std::integral_constant<std::size_t, alignof(typename std::remove_all_extents<T>::type)> {};\n+\n+template <class T, T... Ints>\n+class integer_sequence {\n+public:\n+    using value_type = T;\n+    static_assert(std::is_integral<value_type>::value, \"not integral type\");\n+    static constexpr std::size_t size() noexcept {\n+        return sizeof...(Ints);\n+    }\n+};\n+template <std::size_t... Inds>\n+using index_sequence = integer_sequence<std::size_t, Inds...>;\n+\n+namespace detail_ {\n+template <class T, T Begin, T End, bool>\n+struct IntSeqImpl {\n+    using TValue = T;\n+    static_assert(std::is_integral<TValue>::value, \"not integral type\");\n+    static_assert(Begin >= 0 && Begin < End, \"unexpected argument (Begin<0 || Begin<=End)\");\n+\n+    template <class, class>\n+    struct IntSeqCombiner;\n+\n+    template <TValue... Inds0, TValue... Inds1>\n+    struct IntSeqCombiner<integer_sequence<TValue, Inds0...>, integer_sequence<TValue, Inds1...>> {\n+        using TResult = integer_sequence<TValue, Inds0..., Inds1...>;\n+    };\n+\n+    using TResult =\n+        typename IntSeqCombiner<typename IntSeqImpl<TValue, Begin, Begin + (End - Begin) / 2,\n+                                                    (End - Begin) / 2 == 1>::TResult,\n+                                typename IntSeqImpl<TValue, Begin + (End - Begin) / 2, End,\n+                                                    (End - Begin + 1) / 2 == 1>::TResult>::TResult;\n+};\n+\n+template <class T, T Begin>\n+struct IntSeqImpl<T, Begin, Begin, false> {\n+    using TValue = T;\n+    static_assert(std::is_integral<TValue>::value, \"not integral type\");\n+    static_assert(Begin >= 0, \"unexpected argument (Begin<0)\");\n+    using TResult = integer_sequence<TValue>;\n+};\n+\n+template <class T, T Begin, T End>\n+struct IntSeqImpl<T, Begin, End, true> {\n+    using TValue = T;\n+    static_assert(std::is_integral<TValue>::value, \"not integral type\");\n+    static_assert(Begin >= 0, \"unexpected argument (Begin<0)\");\n+    using TResult = integer_sequence<TValue, Begin>;\n+};\n+} // namespace detail_\n+\n+template <class T, T N>\n+using make_integer_sequence = typename detail_::IntSeqImpl<T, 0, N, (N - 0) == 1>::TResult;\n+\n+template <std::size_t N>\n+using make_index_sequence = make_integer_sequence<std::size_t, N>;\n+\n+template <class... T>\n+using index_sequence_for = make_index_sequence<sizeof...(T)>;\n+\n+} // namespace ROBIN_HOOD_STD\n+\n+#endif\n+\n+namespace detail {\n+\n+// umul\n+#if defined(__SIZEOF_INT128__)\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_HAS_UMUL128() 1\n+#    if defined(__GNUC__) || defined(__clang__)\n+#        pragma GCC diagnostic push\n+#        pragma GCC diagnostic ignored \"-Wpedantic\"\n+using uint128_t = unsigned __int128;\n+#        pragma GCC diagnostic pop\n+#    endif\n+inline uint64_t umul128(uint64_t a, uint64_t b, uint64_t* high) noexcept {\n+    auto result = static_cast<uint128_t>(a) * static_cast<uint128_t>(b);\n+    *high = static_cast<uint64_t>(result >> 64U);\n+    return static_cast<uint64_t>(result);\n+}\n+#elif (defined(_WIN32) && ROBIN_HOOD(BITNESS) == 64)\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_HAS_UMUL128() 1\n+#    include <intrin.h> // for __umulh\n+#    pragma intrinsic(__umulh)\n+#    ifndef _M_ARM64\n+#        pragma intrinsic(_umul128)\n+#    endif\n+inline uint64_t umul128(uint64_t a, uint64_t b, uint64_t* high) noexcept {\n+#    ifdef _M_ARM64\n+    *high = __umulh(a, b);\n+    return ((uint64_t)(a)) * (b);\n+#    else\n+    return _umul128(a, b, high);\n+#    endif\n+}\n+#else\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_HAS_UMUL128() 0\n+#endif\n+\n+// This cast gets rid of warnings like \"cast from 'uint8_t*' {aka 'unsigned char*'} to\n+// 'uint64_t*' {aka 'long unsigned int*'} increases required alignment of target type\". Use with\n+// care!\n+template <typename T>\n+inline T reinterpret_cast_no_cast_align_warning(void* ptr) noexcept {\n+    return reinterpret_cast<T>(ptr);\n+}\n+\n+template <typename T>\n+inline T reinterpret_cast_no_cast_align_warning(void const* ptr) noexcept {\n+    return reinterpret_cast<T>(ptr);\n+}\n+\n+// make sure this is not inlined as it is slow and dramatically enlarges code, thus making other\n+// inlinings more difficult. Throws are also generally the slow path.\n+template <typename E, typename... Args>\n+ROBIN_HOOD(NOINLINE)\n+#if ROBIN_HOOD(HAS_EXCEPTIONS)\n+void doThrow(Args&&... args) {\n+    // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-array-to-pointer-decay)\n+    throw E(std::forward<Args>(args)...);\n+}\n+#else\n+void doThrow(Args&&... ROBIN_HOOD_UNUSED(args) /*unused*/) {\n+    abort();\n+}\n+#endif\n+\n+template <typename E, typename T, typename... Args>\n+T* assertNotNull(T* t, Args&&... args) {\n+    if (ROBIN_HOOD_UNLIKELY(nullptr == t)) {\n+        doThrow<E>(std::forward<Args>(args)...);\n+    }\n+    return t;\n+}\n+\n+template <typename T>\n+inline T unaligned_load(void const* ptr) noexcept {\n+    // using memcpy so we don't get into unaligned load problems.\n+    // compiler should optimize this very well anyways.\n+    T t;\n+    std::memcpy(&t, ptr, sizeof(T));\n+    return t;\n+}\n+\n+// Allocates bulks of memory for objects of type T. This deallocates the memory in the destructor,\n+// and keeps a linked list of the allocated memory around. Overhead per allocation is the size of a\n+// pointer.\n+template <typename T, size_t MinNumAllocs = 4, size_t MaxNumAllocs = 256>\n+class BulkPoolAllocator {\n+public:\n+    BulkPoolAllocator() noexcept = default;\n+\n+    // does not copy anything, just creates a new allocator.\n+    BulkPoolAllocator(const BulkPoolAllocator& ROBIN_HOOD_UNUSED(o) /*unused*/) noexcept\n+        : mHead(nullptr)\n+        , mListForFree(nullptr) {}\n+\n+    BulkPoolAllocator(BulkPoolAllocator&& o) noexcept\n+        : mHead(o.mHead)\n+        , mListForFree(o.mListForFree) {\n+        o.mListForFree = nullptr;\n+        o.mHead = nullptr;\n+    }\n+\n+    BulkPoolAllocator& operator=(BulkPoolAllocator&& o) noexcept {\n+        reset();\n+        mHead = o.mHead;\n+        mListForFree = o.mListForFree;\n+        o.mListForFree = nullptr;\n+        o.mHead = nullptr;\n+        return *this;\n+    }\n+\n+    BulkPoolAllocator&\n+    operator=(const BulkPoolAllocator& ROBIN_HOOD_UNUSED(o) /*unused*/) noexcept {\n+        // does not do anything\n+        return *this;\n+    }\n+\n+    ~BulkPoolAllocator() noexcept {\n+        reset();\n+    }\n+\n+    // Deallocates all allocated memory.\n+    void reset() noexcept {\n+        while (mListForFree) {\n+            T* tmp = *mListForFree;\n+            free(mListForFree);\n+            mListForFree = reinterpret_cast_no_cast_align_warning<T**>(tmp);\n+        }\n+        mHead = nullptr;\n+    }\n+\n+    // allocates, but does NOT initialize. Use in-place new constructor, e.g.\n+    //   T* obj = pool.allocate();\n+    //   ::new (static_cast<void*>(obj)) T();\n+    T* allocate() {\n+        T* tmp = mHead;\n+        if (!tmp) {\n+            tmp = performAllocation();\n+        }\n+\n+        mHead = *reinterpret_cast_no_cast_align_warning<T**>(tmp);\n+        return tmp;\n+    }\n+\n+    // does not actually deallocate but puts it in store.\n+    // make sure you have already called the destructor! e.g. with\n+    //  obj->~T();\n+    //  pool.deallocate(obj);\n+    void deallocate(T* obj) noexcept {\n+        *reinterpret_cast_no_cast_align_warning<T**>(obj) = mHead;\n+        mHead = obj;\n+    }\n+\n+    // Adds an already allocated block of memory to the allocator. This allocator is from now on\n+    // responsible for freeing the data (with free()). If the provided data is not large enough to\n+    // make use of, it is immediately freed. Otherwise it is reused and freed in the destructor.\n+    void addOrFree(void* ptr, const size_t numBytes) noexcept {\n+        // calculate number of available elements in ptr\n+        if (numBytes < ALIGNMENT + ALIGNED_SIZE) {\n+            // not enough data for at least one element. Free and return.\n+            free(ptr);\n+        } else {\n+            add(ptr, numBytes);\n+        }\n+    }\n+\n+    void swap(BulkPoolAllocator<T, MinNumAllocs, MaxNumAllocs>& other) noexcept {\n+        using std::swap;\n+        swap(mHead, other.mHead);\n+        swap(mListForFree, other.mListForFree);\n+    }\n+\n+private:\n+    // iterates the list of allocated memory to calculate how many to alloc next.\n+    // Recalculating this each time saves us a size_t member.\n+    // This ignores the fact that memory blocks might have been added manually with addOrFree. In\n+    // practice, this should not matter much.\n+    ROBIN_HOOD(NODISCARD) size_t calcNumElementsToAlloc() const noexcept {\n+        auto tmp = mListForFree;\n+        size_t numAllocs = MinNumAllocs;\n+\n+        while (numAllocs * 2 <= MaxNumAllocs && tmp) {\n+            auto x = reinterpret_cast<T***>(tmp);\n+            tmp = *x;\n+            numAllocs *= 2;\n+        }\n+\n+        return numAllocs;\n+    }\n+\n+    // WARNING: Underflow if numBytes < ALIGNMENT! This is guarded in addOrFree().\n+    void add(void* ptr, const size_t numBytes) noexcept {\n+        const size_t numElements = (numBytes - ALIGNMENT) / ALIGNED_SIZE;\n+\n+        auto data = reinterpret_cast<T**>(ptr);\n+\n+        // link free list\n+        auto x = reinterpret_cast<T***>(data);\n+        *x = mListForFree;\n+        mListForFree = data;\n+\n+        // create linked list for newly allocated data\n+        auto const headT =\n+            reinterpret_cast_no_cast_align_warning<T*>(reinterpret_cast<char*>(ptr) + ALIGNMENT);\n+\n+        auto const head = reinterpret_cast<char*>(headT);\n+\n+        // Visual Studio compiler automatically unrolls this loop, which is pretty cool\n+        for (size_t i = 0; i < numElements; ++i) {\n+            *reinterpret_cast_no_cast_align_warning<char**>(head + i * ALIGNED_SIZE) =\n+                head + (i + 1) * ALIGNED_SIZE;\n+        }\n+\n+        // last one points to 0\n+        *reinterpret_cast_no_cast_align_warning<T**>(head + (numElements - 1) * ALIGNED_SIZE) =\n+            mHead;\n+        mHead = headT;\n+    }\n+\n+    // Called when no memory is available (mHead == 0).\n+    // Don't inline this slow path.\n+    ROBIN_HOOD(NOINLINE) T* performAllocation() {\n+        size_t const numElementsToAlloc = calcNumElementsToAlloc();\n+\n+        // alloc new memory: [prev |T, T, ... T]\n+        // std::cout << (sizeof(T*) + ALIGNED_SIZE * numElementsToAlloc) << \" bytes\" << std::endl;\n+        size_t const bytes = ALIGNMENT + ALIGNED_SIZE * numElementsToAlloc;\n+        add(assertNotNull<std::bad_alloc>(malloc(bytes)), bytes);\n+        return mHead;\n+    }\n+\n+    // enforce byte alignment of the T's\n+#if ROBIN_HOOD(CXX) >= ROBIN_HOOD(CXX14)\n+    static constexpr size_t ALIGNMENT =\n+        (std::max)(std::alignment_of<T>::value, std::alignment_of<T*>::value);\n+#else\n+    static const size_t ALIGNMENT =\n+        (ROBIN_HOOD_STD::alignment_of<T>::value > ROBIN_HOOD_STD::alignment_of<T*>::value)\n+            ? ROBIN_HOOD_STD::alignment_of<T>::value\n+            : +ROBIN_HOOD_STD::alignment_of<T*>::value; // the + is for walkarround\n+#endif\n+\n+    static constexpr size_t ALIGNED_SIZE = ((sizeof(T) - 1) / ALIGNMENT + 1) * ALIGNMENT;\n+\n+    static_assert(MinNumAllocs >= 1, \"MinNumAllocs\");\n+    static_assert(MaxNumAllocs >= MinNumAllocs, \"MaxNumAllocs\");\n+    static_assert(ALIGNED_SIZE >= sizeof(T*), \"ALIGNED_SIZE\");\n+    static_assert(0 == (ALIGNED_SIZE % sizeof(T*)), \"ALIGNED_SIZE mod\");\n+    static_assert(ALIGNMENT >= sizeof(T*), \"ALIGNMENT\");\n+\n+    T* mHead{nullptr};\n+    T** mListForFree{nullptr};\n+};\n+\n+template <typename T, size_t MinSize, size_t MaxSize, bool IsFlatMap>\n+struct NodeAllocator;\n+\n+// dummy allocator that does nothing\n+template <typename T, size_t MinSize, size_t MaxSize>\n+struct NodeAllocator<T, MinSize, MaxSize, true> {\n+\n+    // we are not using the data, so just free it.\n+    void addOrFree(void* ptr, size_t ROBIN_HOOD_UNUSED(numBytes) /*unused*/) noexcept {\n+        free(ptr);\n+    }\n+};\n+\n+template <typename T, size_t MinSize, size_t MaxSize>\n+struct NodeAllocator<T, MinSize, MaxSize, false> : public BulkPoolAllocator<T, MinSize, MaxSize> {};\n+\n+// dummy hash, unsed as mixer when robin_hood::hash is already used\n+template <typename T>\n+struct identity_hash {\n+    constexpr size_t operator()(T const& obj) const noexcept {\n+        return static_cast<size_t>(obj);\n+    }\n+};\n+\n+// c++14 doesn't have is_nothrow_swappable, and clang++ 6.0.1 doesn't like it either, so I'm making\n+// my own here.\n+namespace swappable {\n+using std::swap;\n+template <typename T>\n+struct nothrow {\n+    static const bool value = noexcept(swap(std::declval<T&>(), std::declval<T&>()));\n+};\n+\n+} // namespace swappable\n+\n+} // namespace detail\n+\n+struct is_transparent_tag {};\n+\n+// A custom pair implementation is used in the map because std::pair is not is_trivially_copyable,\n+// which means it would  not be allowed to be used in std::memcpy. This struct is copyable, which is\n+// also tested.\n+template <typename T1, typename T2>\n+struct pair {\n+    using first_type = T1;\n+    using second_type = T2;\n+\n+    template <typename U1 = T1, typename U2 = T2,\n+              typename = typename std::enable_if<std::is_default_constructible<U1>::value &&\n+                                                 std::is_default_constructible<U2>::value>::type>\n+    constexpr pair() noexcept(noexcept(U1()) && noexcept(U2()))\n+        : first()\n+        , second() {}\n+\n+    // pair constructors are explicit so we don't accidentally call this ctor when we don't have to.\n+    explicit constexpr pair(std::pair<T1, T2> const& o) noexcept(\n+        noexcept(T1(std::declval<T1 const&>())) && noexcept(T2(std::declval<T2 const&>())))\n+        : first(o.first)\n+        , second(o.second) {}\n+\n+    // pair constructors are explicit so we don't accidentally call this ctor when we don't have to.\n+    explicit constexpr pair(std::pair<T1, T2>&& o) noexcept(\n+        noexcept(T1(std::move(std::declval<T1&&>()))) &&\n+        noexcept(T2(std::move(std::declval<T2&&>()))))\n+        : first(std::move(o.first))\n+        , second(std::move(o.second)) {}\n+\n+    constexpr pair(T1&& a, T2&& b) noexcept(noexcept(T1(std::move(std::declval<T1&&>()))) &&\n+                                            noexcept(T2(std::move(std::declval<T2&&>()))))\n+        : first(std::move(a))\n+        , second(std::move(b)) {}\n+\n+    template <typename U1, typename U2>\n+    constexpr pair(U1&& a, U2&& b) noexcept(noexcept(T1(std::forward<U1>(std::declval<U1&&>()))) &&\n+                                            noexcept(T2(std::forward<U2>(std::declval<U2&&>()))))\n+        : first(std::forward<U1>(a))\n+        , second(std::forward<U2>(b)) {}\n+\n+    template <typename... U1, typename... U2>\n+    constexpr pair(\n+        std::piecewise_construct_t /*unused*/, std::tuple<U1...> a,\n+        std::tuple<U2...> b) noexcept(noexcept(pair(std::declval<std::tuple<U1...>&>(),\n+                                                    std::declval<std::tuple<U2...>&>(),\n+                                                    ROBIN_HOOD_STD::index_sequence_for<U1...>(),\n+                                                    ROBIN_HOOD_STD::index_sequence_for<U2...>())))\n+        : pair(a, b, ROBIN_HOOD_STD::index_sequence_for<U1...>(),\n+               ROBIN_HOOD_STD::index_sequence_for<U2...>()) {}\n+\n+    // constructor called from the std::piecewise_construct_t ctor\n+    template <typename... U1, size_t... I1, typename... U2, size_t... I2>\n+    pair(std::tuple<U1...>& a, std::tuple<U2...>& b,\n+         ROBIN_HOOD_STD::index_sequence<I1...> /*unused*/,\n+         ROBIN_HOOD_STD::index_sequence<\n+             I2...> /*unused*/) noexcept(noexcept(T1(std::\n+                                                         forward<U1>(std::get<I1>(\n+                                                             std::declval<\n+                                                                 std::tuple<U1...>&>()))...)) &&\n+                                         noexcept(T2(std::forward<U2>(\n+                                             std::get<I2>(std::declval<std::tuple<U2...>&>()))...)))\n+        : first(std::forward<U1>(std::get<I1>(a))...)\n+        , second(std::forward<U2>(std::get<I2>(b))...) {\n+        // make visual studio compiler happy about warning about unused a & b.\n+        // Visual studio's pair implementation disables warning 4100.\n+        (void)a;\n+        (void)b;\n+    }\n+\n+    ROBIN_HOOD(NODISCARD) first_type& getFirst() noexcept {\n+        return first;\n+    }\n+    ROBIN_HOOD(NODISCARD) first_type const& getFirst() const noexcept {\n+        return first;\n+    }\n+    ROBIN_HOOD(NODISCARD) second_type& getSecond() noexcept {\n+        return second;\n+    }\n+    ROBIN_HOOD(NODISCARD) second_type const& getSecond() const noexcept {\n+        return second;\n+    }\n+\n+    void swap(pair<T1, T2>& o) noexcept((detail::swappable::nothrow<T1>::value) &&\n+                                        (detail::swappable::nothrow<T2>::value)) {\n+        using std::swap;\n+        swap(first, o.first);\n+        swap(second, o.second);\n+    }\n+\n+    T1 first;  // NOLINT(misc-non-private-member-variables-in-classes)\n+    T2 second; // NOLINT(misc-non-private-member-variables-in-classes)\n+};\n+\n+template <typename A, typename B>\n+void swap(pair<A, B>& a, pair<A, B>& b) noexcept(\n+    noexcept(std::declval<pair<A, B>&>().swap(std::declval<pair<A, B>&>()))) {\n+    a.swap(b);\n+}\n+\n+// Hash an arbitrary amount of bytes. This is basically Murmur2 hash without caring about big\n+// endianness. TODO(martinus) add a fallback for very large strings?\n+static size_t hash_bytes(void const* ptr, size_t const len) noexcept {\n+    static constexpr uint64_t m = UINT64_C(0xc6a4a7935bd1e995);\n+    static constexpr uint64_t seed = UINT64_C(0xe17a1465);\n+    static constexpr unsigned int r = 47;\n+\n+    auto const data64 = static_cast<uint64_t const*>(ptr);\n+    uint64_t h = seed ^ (len * m);\n+\n+    size_t const n_blocks = len / 8;\n+    for (size_t i = 0; i < n_blocks; ++i) {\n+        auto k = detail::unaligned_load<uint64_t>(data64 + i);\n+\n+        k *= m;\n+        k ^= k >> r;\n+        k *= m;\n+\n+        h ^= k;\n+        h *= m;\n+    }\n+\n+    auto const data8 = reinterpret_cast<uint8_t const*>(data64 + n_blocks);\n+    switch (len & 7U) {\n+    case 7:\n+        h ^= static_cast<uint64_t>(data8[6]) << 48U;\n+        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n+    case 6:\n+        h ^= static_cast<uint64_t>(data8[5]) << 40U;\n+        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n+    case 5:\n+        h ^= static_cast<uint64_t>(data8[4]) << 32U;\n+        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n+    case 4:\n+        h ^= static_cast<uint64_t>(data8[3]) << 24U;\n+        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n+    case 3:\n+        h ^= static_cast<uint64_t>(data8[2]) << 16U;\n+        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n+    case 2:\n+        h ^= static_cast<uint64_t>(data8[1]) << 8U;\n+        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n+    case 1:\n+        h ^= static_cast<uint64_t>(data8[0]);\n+        h *= m;\n+        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n+    default:\n+        break;\n+    }\n+\n+    h ^= h >> r;\n+    h *= m;\n+    h ^= h >> r;\n+    return static_cast<size_t>(h);\n+}\n+\n+inline size_t hash_int(uint64_t obj) noexcept {\n+#if ROBIN_HOOD(HAS_UMUL128)\n+    // 167079903232 masksum, 120428523 ops best: 0xde5fb9d2630458e9\n+    static constexpr uint64_t k = UINT64_C(0xde5fb9d2630458e9);\n+    uint64_t h;\n+    uint64_t l = detail::umul128(obj, k, &h);\n+    return h + l;\n+#elif ROBIN_HOOD(BITNESS) == 32\n+    uint64_t const r = obj * UINT64_C(0xca4bcaa75ec3f625);\n+    auto h = static_cast<uint32_t>(r >> 32U);\n+    auto l = static_cast<uint32_t>(r);\n+    return h + l;\n+#else\n+    // murmurhash 3 finalizer\n+    uint64_t h = obj;\n+    h ^= h >> 33;\n+    h *= 0xff51afd7ed558ccd;\n+    h ^= h >> 33;\n+    h *= 0xc4ceb9fe1a85ec53;\n+    h ^= h >> 33;\n+    return static_cast<size_t>(h);\n+#endif\n+}\n+\n+// A thin wrapper around std::hash, performing an additional simple mixing step of the result.\n+template <typename T>\n+struct hash : public std::hash<T> {\n+    size_t operator()(T const& obj) const\n+        noexcept(noexcept(std::declval<std::hash<T>>().operator()(std::declval<T const&>()))) {\n+        // call base hash\n+        auto result = std::hash<T>::operator()(obj);\n+        // return mixed of that, to be save against identity has\n+        return hash_int(static_cast<uint64_t>(result));\n+    }\n+};\n+\n+template <>\n+struct hash<std::string> {\n+    size_t operator()(std::string const& str) const noexcept {\n+        return hash_bytes(str.data(), str.size());\n+    }\n+};\n+\n+template <class T>\n+struct hash<T*> {\n+    size_t operator()(T* ptr) const noexcept {\n+        return hash_int(reinterpret_cast<size_t>(ptr));\n+    }\n+};\n+\n+#define ROBIN_HOOD_HASH_INT(T)                           \\\n+    template <>                                          \\\n+    struct hash<T> {                                     \\\n+        size_t operator()(T obj) const noexcept {        \\\n+            return hash_int(static_cast<uint64_t>(obj)); \\\n+        }                                                \\\n+    }\n+\n+#if defined(__GNUC__) && !defined(__clang__)\n+#    pragma GCC diagnostic push\n+#    pragma GCC diagnostic ignored \"-Wuseless-cast\"\n+#endif\n+// see https://en.cppreference.com/w/cpp/utility/hash\n+ROBIN_HOOD_HASH_INT(bool);\n+ROBIN_HOOD_HASH_INT(char);\n+ROBIN_HOOD_HASH_INT(signed char);\n+ROBIN_HOOD_HASH_INT(unsigned char);\n+ROBIN_HOOD_HASH_INT(char16_t);\n+ROBIN_HOOD_HASH_INT(char32_t);\n+ROBIN_HOOD_HASH_INT(wchar_t);\n+ROBIN_HOOD_HASH_INT(short);\n+ROBIN_HOOD_HASH_INT(unsigned short);\n+ROBIN_HOOD_HASH_INT(int);\n+ROBIN_HOOD_HASH_INT(unsigned int);\n+ROBIN_HOOD_HASH_INT(long);\n+ROBIN_HOOD_HASH_INT(long long);\n+ROBIN_HOOD_HASH_INT(unsigned long);\n+ROBIN_HOOD_HASH_INT(unsigned long long);\n+#if defined(__GNUC__) && !defined(__clang__)\n+#    pragma GCC diagnostic pop\n+#endif\n+namespace detail {\n+\n+// A highly optimized hashmap implementation, using the Robin Hood algorithm.\n+//\n+// In most cases, this map should be usable as a drop-in replacement for std::unordered_map, but be\n+// about 2x faster in most cases and require much less allocations.\n+//\n+// This implementation uses the following memory layout:\n+//\n+// [Node, Node, ... Node | info, info, ... infoSentinel ]\n+//\n+// * Node: either a DataNode that directly has the std::pair<key, val> as member,\n+//   or a DataNode with a pointer to std::pair<key,val>. Which DataNode representation to use\n+//   depends on how fast the swap() operation is. Heuristically, this is automatically choosen based\n+//   on sizeof(). there are always 2^n Nodes.\n+//\n+// * info: Each Node in the map has a corresponding info byte, so there are 2^n info bytes.\n+//   Each byte is initialized to 0, meaning the corresponding Node is empty. Set to 1 means the\n+//   corresponding node contains data. Set to 2 means the corresponding Node is filled, but it\n+//   actually belongs to the previous position and was pushed out because that place is already\n+//   taken.\n+//\n+// * infoSentinel: Sentinel byte set to 1, so that iterator's ++ can stop at end() without the need\n+// for a idx\n+//   variable.\n+//\n+// According to STL, order of templates has effect on throughput. That's why I've moved the boolean\n+// to the front.\n+// https://www.reddit.com/r/cpp/comments/ahp6iu/compile_time_binary_size_reductions_and_cs_future/eeguck4/\n+template <bool IsFlatMap, size_t MaxLoadFactor100, typename Key, typename T, typename Hash,\n+          typename KeyEqual>\n+class unordered_map\n+    : public Hash,\n+      public KeyEqual,\n+      detail::NodeAllocator<\n+          robin_hood::pair<typename std::conditional<IsFlatMap, Key, Key const>::type, T>, 4, 16384,\n+          IsFlatMap> {\n+public:\n+    using key_type = Key;\n+    using mapped_type = T;\n+    using value_type =\n+        robin_hood::pair<typename std::conditional<IsFlatMap, Key, Key const>::type, T>;\n+    using size_type = size_t;\n+    using hasher = Hash;\n+    using key_equal = KeyEqual;\n+    using Self =\n+        unordered_map<IsFlatMap, MaxLoadFactor100, key_type, mapped_type, hasher, key_equal>;\n+    static constexpr bool is_flat_map = IsFlatMap;\n+\n+private:\n+    static_assert(MaxLoadFactor100 > 10 && MaxLoadFactor100 < 100,\n+                  \"MaxLoadFactor100 needs to be >10 && < 100\");\n+\n+    // configuration defaults\n+\n+    // make sure we have 8 elements, needed to quickly rehash mInfo\n+    static constexpr size_t InitialNumElements = sizeof(uint64_t);\n+    static constexpr uint32_t InitialInfoNumBits = 5;\n+    static constexpr uint8_t InitialInfoInc = 1U << InitialInfoNumBits;\n+    static constexpr uint8_t InitialInfoHashShift = sizeof(size_t) * 8 - InitialInfoNumBits;\n+    using DataPool = detail::NodeAllocator<value_type, 4, 16384, IsFlatMap>;\n+\n+    // type needs to be wider than uint8_t.\n+    using InfoType = uint32_t;\n+\n+    // DataNode ////////////////////////////////////////////////////////\n+\n+    // Primary template for the data node. We have special implementations for small and big\n+    // objects. For large objects it is assumed that swap() is fairly slow, so we allocate these on\n+    // the heap so swap merely swaps a pointer.\n+    template <typename M, bool>\n+    class DataNode {};\n+\n+    // Small: just allocate on the stack.\n+    template <typename M>\n+    class DataNode<M, true> final {\n+    public:\n+        template <typename... Args>\n+        explicit DataNode(M& ROBIN_HOOD_UNUSED(map) /*unused*/, Args&&... args) noexcept(\n+            noexcept(value_type(std::forward<Args>(args)...)))\n+            : mData(std::forward<Args>(args)...) {}\n+\n+        DataNode(M& ROBIN_HOOD_UNUSED(map) /*unused*/, DataNode<M, true>&& n) noexcept(\n+            std::is_nothrow_move_constructible<value_type>::value)\n+            : mData(std::move(n.mData)) {}\n+\n+        // doesn't do anything\n+        void destroy(M& ROBIN_HOOD_UNUSED(map) /*unused*/) noexcept {}\n+        void destroyDoNotDeallocate() noexcept {}\n+\n+        value_type const* operator->() const noexcept {\n+            return &mData;\n+        }\n+        value_type* operator->() noexcept {\n+            return &mData;\n+        }\n+\n+        const value_type& operator*() const noexcept {\n+            return mData;\n+        }\n+\n+        value_type& operator*() noexcept {\n+            return mData;\n+        }\n+\n+        ROBIN_HOOD(NODISCARD) typename value_type::first_type& getFirst() noexcept {\n+            return mData.first;\n+        }\n+\n+        ROBIN_HOOD(NODISCARD) typename value_type::first_type const& getFirst() const noexcept {\n+            return mData.first;\n+        }\n+\n+        ROBIN_HOOD(NODISCARD) typename value_type::second_type& getSecond() noexcept {\n+            return mData.second;\n+        }\n+\n+        ROBIN_HOOD(NODISCARD) typename value_type::second_type const& getSecond() const noexcept {\n+            return mData.second;\n+        }\n+\n+        void swap(DataNode<M, true>& o) noexcept(\n+            noexcept(std::declval<value_type>().swap(std::declval<value_type>()))) {\n+            mData.swap(o.mData);\n+        }\n+\n+    private:\n+        value_type mData;\n+    };\n+\n+    // big object: allocate on heap.\n+    template <typename M>\n+    class DataNode<M, false> {\n+    public:\n+        template <typename... Args>\n+        explicit DataNode(M& map, Args&&... args)\n+            : mData(map.allocate()) {\n+            ::new (static_cast<void*>(mData)) value_type(std::forward<Args>(args)...);\n+        }\n+\n+        DataNode(M& ROBIN_HOOD_UNUSED(map) /*unused*/, DataNode<M, false>&& n) noexcept\n+            : mData(std::move(n.mData)) {}\n+\n+        void destroy(M& map) noexcept {\n+            // don't deallocate, just put it into list of datapool.\n+            mData->~value_type();\n+            map.deallocate(mData);\n+        }\n+\n+        void destroyDoNotDeallocate() noexcept {\n+            mData->~value_type();\n+        }\n+\n+        value_type const* operator->() const noexcept {\n+            return mData;\n+        }\n+\n+        value_type* operator->() noexcept {\n+            return mData;\n+        }\n+\n+        const value_type& operator*() const {\n+            return *mData;\n+        }\n+\n+        value_type& operator*() {\n+            return *mData;\n+        }\n+\n+        ROBIN_HOOD(NODISCARD) typename value_type::first_type& getFirst() {\n+            return mData->first;\n+        }\n+\n+        ROBIN_HOOD(NODISCARD) typename value_type::first_type const& getFirst() const {\n+            return mData->first;\n+        }\n+\n+        ROBIN_HOOD(NODISCARD) typename value_type::second_type& getSecond() {\n+            return mData->second;\n+        }\n+\n+        ROBIN_HOOD(NODISCARD) typename value_type::second_type const& getSecond() const {\n+            return mData->second;\n+        }\n+\n+        void swap(DataNode<M, false>& o) noexcept {\n+            using std::swap;\n+            swap(mData, o.mData);\n+        }\n+\n+    private:\n+        value_type* mData;\n+    };\n+\n+    using Node = DataNode<Self, IsFlatMap>;\n+\n+    // Cloner //////////////////////////////////////////////////////////\n+\n+    template <typename M, bool UseMemcpy>\n+    struct Cloner;\n+\n+    // fast path: Just copy data, without allocating anything.\n+    template <typename M>\n+    struct Cloner<M, true> {\n+        void operator()(M const& source, M& target) const {\n+            // std::memcpy(target.mKeyVals, source.mKeyVals,\n+            //             target.calcNumBytesTotal(target.mMask + 1));\n+            auto src = reinterpret_cast<char const*>(source.mKeyVals);\n+            auto tgt = reinterpret_cast<char*>(target.mKeyVals);\n+            std::copy(src, src + target.calcNumBytesTotal(target.mMask + 1), tgt);\n+        }\n+    };\n+\n+    template <typename M>\n+    struct Cloner<M, false> {\n+        void operator()(M const& s, M& t) const {\n+            std::copy(s.mInfo, s.mInfo + t.calcNumBytesInfo(t.mMask + 1), t.mInfo);\n+\n+            for (size_t i = 0; i < t.mMask + 1; ++i) {\n+                if (t.mInfo[i]) {\n+                    ::new (static_cast<void*>(t.mKeyVals + i)) Node(t, *s.mKeyVals[i]);\n+                }\n+            }\n+        }\n+    };\n+\n+    // Destroyer ///////////////////////////////////////////////////////\n+\n+    template <typename M, bool IsFlatMapAndTrivial>\n+    struct Destroyer {};\n+\n+    template <typename M>\n+    struct Destroyer<M, true> {\n+        void nodes(M& m) const noexcept {\n+            m.mNumElements = 0;\n+        }\n+\n+        void nodesDoNotDeallocate(M& m) const noexcept {\n+            m.mNumElements = 0;\n+        }\n+    };\n+\n+    template <typename M>\n+    struct Destroyer<M, false> {\n+        void nodes(M& m) const noexcept {\n+            m.mNumElements = 0;\n+            // clear also resets mInfo to 0, that's sometimes not necessary.\n+            for (size_t idx = 0; idx <= m.mMask; ++idx) {\n+                if (0 != m.mInfo[idx]) {\n+                    Node& n = m.mKeyVals[idx];\n+                    n.destroy(m);\n+                    n.~Node();\n+                }\n+            }\n+        }\n+\n+        void nodesDoNotDeallocate(M& m) const noexcept {\n+            m.mNumElements = 0;\n+            // clear also resets mInfo to 0, that's sometimes not necessary.\n+            for (size_t idx = 0; idx <= m.mMask; ++idx) {\n+                if (0 != m.mInfo[idx]) {\n+                    Node& n = m.mKeyVals[idx];\n+                    n.destroyDoNotDeallocate();\n+                    n.~Node();\n+                }\n+            }\n+        }\n+    };\n+\n+    // Iter ////////////////////////////////////////////////////////////\n+\n+    struct fast_forward_tag {};\n+\n+    // generic iterator for both const_iterator and iterator.\n+    template <bool IsConst>\n+    // NOLINTNEXTLINE(hicpp-special-member-functions,cppcoreguidelines-special-member-functions)\n+    class Iter {\n+    private:\n+        using NodePtr = typename std::conditional<IsConst, Node const*, Node*>::type;\n+\n+    public:\n+        using difference_type = std::ptrdiff_t;\n+        using value_type = typename Self::value_type;\n+        using reference = typename std::conditional<IsConst, value_type const&, value_type&>::type;\n+        using pointer = typename std::conditional<IsConst, value_type const*, value_type*>::type;\n+        using iterator_category = std::forward_iterator_tag;\n+\n+        // default constructed iterator can be compared to itself, but WON'T return true when\n+        // compared to end().\n+        Iter() = default;\n+\n+        // Rule of zero: nothing specified. The conversion constructor is only enabled for iterator\n+        // to const_iterator, so it doesn't accidentally work as a copy ctor.\n+\n+        // Conversion constructor from iterator to const_iterator.\n+        template <bool OtherIsConst,\n+                  typename = typename std::enable_if<IsConst && !OtherIsConst>::type>\n+        // NOLINTNEXTLINE(hicpp-explicit-conversions)\n+        Iter(Iter<OtherIsConst> const& other) noexcept\n+            : mKeyVals(other.mKeyVals)\n+            , mInfo(other.mInfo) {}\n+\n+        Iter(NodePtr valPtr, uint8_t const* infoPtr) noexcept\n+            : mKeyVals(valPtr)\n+            , mInfo(infoPtr) {}\n+\n+        Iter(NodePtr valPtr, uint8_t const* infoPtr,\n+             fast_forward_tag ROBIN_HOOD_UNUSED(tag) /*unused*/) noexcept\n+            : mKeyVals(valPtr)\n+            , mInfo(infoPtr) {\n+            fastForward();\n+        }\n+\n+        template <bool OtherIsConst,\n+                  typename = typename std::enable_if<IsConst && !OtherIsConst>::type>\n+        Iter& operator=(Iter<OtherIsConst> const& other) noexcept {\n+            mKeyVals = other.mKeyVals;\n+            mInfo = other.mInfo;\n+            return *this;\n+        }\n+\n+        // prefix increment. Undefined behavior if we are at end()!\n+        Iter& operator++() noexcept {\n+            mInfo++;\n+            mKeyVals++;\n+            fastForward();\n+            return *this;\n+        }\n+\n+        reference operator*() const {\n+            return **mKeyVals;\n+        }\n+\n+        pointer operator->() const {\n+            return &**mKeyVals;\n+        }\n+\n+        template <bool O>\n+        bool operator==(Iter<O> const& o) const noexcept {\n+            return mKeyVals == o.mKeyVals;\n+        }\n+\n+        template <bool O>\n+        bool operator!=(Iter<O> const& o) const noexcept {\n+            return mKeyVals != o.mKeyVals;\n+        }\n+\n+    private:\n+        // fast forward to the next non-free info byte\n+        void fastForward() noexcept {\n+            int inc;\n+            do {\n+                auto const n = detail::unaligned_load<size_t>(mInfo);\n+#if ROBIN_HOOD(LITTLE_ENDIAN)\n+                inc = ROBIN_HOOD_COUNT_TRAILING_ZEROES(n) / 8;\n+#else\n+                inc = ROBIN_HOOD_COUNT_LEADING_ZEROES(n) / 8;\n+#endif\n+                mInfo += inc;\n+                mKeyVals += inc;\n+            } while (inc == static_cast<int>(sizeof(size_t)));\n+        }\n+\n+        friend class unordered_map<IsFlatMap, MaxLoadFactor100, key_type, mapped_type, hasher,\n+                                   key_equal>;\n+        NodePtr mKeyVals{nullptr};\n+        uint8_t const* mInfo{nullptr};\n+    };\n+\n+    ////////////////////////////////////////////////////////////////////\n+\n+    // highly performance relevant code.\n+    // Lower bits are used for indexing into the array (2^n size)\n+    // The upper 1-5 bits need to be a reasonable good hash, to save comparisons.\n+    template <typename HashKey>\n+    void keyToIdx(HashKey&& key, size_t* idx, InfoType* info) const {\n+        // for a user-specified hash that is *not* robin_hood::hash, apply robin_hood::hash as an\n+        // additional mixing step. This serves as a bad hash prevention, if the given data is badly\n+        // mixed.\n+        using Mix =\n+            typename std::conditional<std::is_same<::robin_hood::hash<key_type>, hasher>::value,\n+                                      ::robin_hood::detail::identity_hash<size_t>,\n+                                      ::robin_hood::hash<size_t>>::type;\n+        *idx = Mix{}(Hash::operator()(key));\n+\n+        *info = mInfoInc + static_cast<InfoType>(*idx >> mInfoHashShift);\n+        *idx &= mMask;\n+    }\n+\n+    // forwards the index by one, wrapping around at the end\n+    void next(InfoType* info, size_t* idx) const noexcept {\n+        *idx = (*idx + 1) & mMask;\n+        *info += mInfoInc;\n+    }\n+\n+    void nextWhileLess(InfoType* info, size_t* idx) const noexcept {\n+        // unrolling this by hand did not bring any speedups.\n+        while (*info < mInfo[*idx]) {\n+            next(info, idx);\n+        }\n+    }\n+\n+    // Shift everything up by one element. Tries to move stuff around.\n+    // True if some shifting has occured (entry under idx is a constructed object)\n+    // Fals if no shift has occured (entry under idx is unconstructed memory)\n+    void\n+    shiftUp(size_t idx,\n+            size_t const insertion_idx) noexcept(std::is_nothrow_move_assignable<Node>::value) {\n+        while (idx != insertion_idx) {\n+            size_t prev_idx = (idx - 1) & mMask;\n+            if (mInfo[idx]) {\n+                mKeyVals[idx] = std::move(mKeyVals[prev_idx]);\n+            } else {\n+                ::new (static_cast<void*>(mKeyVals + idx)) Node(std::move(mKeyVals[prev_idx]));\n+            }\n+            mInfo[idx] = static_cast<uint8_t>(mInfo[prev_idx] + mInfoInc);\n+            if (ROBIN_HOOD_UNLIKELY(mInfo[idx] + mInfoInc > 0xFF)) {\n+                mMaxNumElementsAllowed = 0;\n+            }\n+            idx = prev_idx;\n+        }\n+    }\n+\n+    void shiftDown(size_t idx) noexcept(std::is_nothrow_move_assignable<Node>::value) {\n+        // until we find one that is either empty or has zero offset.\n+        // TODO(martinus) we don't need to move everything, just the last one for the same bucket.\n+        mKeyVals[idx].destroy(*this);\n+\n+        // until we find one that is either empty or has zero offset.\n+        size_t nextIdx = (idx + 1) & mMask;\n+        while (mInfo[nextIdx] >= 2 * mInfoInc) {\n+            mInfo[idx] = static_cast<uint8_t>(mInfo[nextIdx] - mInfoInc);\n+            mKeyVals[idx] = std::move(mKeyVals[nextIdx]);\n+            idx = nextIdx;\n+            nextIdx = (idx + 1) & mMask;\n+        }\n+\n+        mInfo[idx] = 0;\n+        // don't destroy, we've moved it\n+        // mKeyVals[idx].destroy(*this);\n+        mKeyVals[idx].~Node();\n+    }\n+\n+    // copy of find(), except that it returns iterator instead of const_iterator.\n+    template <typename Other>\n+    ROBIN_HOOD(NODISCARD)\n+    size_t findIdx(Other const& key) const {\n+        size_t idx;\n+        InfoType info;\n+        keyToIdx(key, &idx, &info);\n+\n+        do {\n+            // unrolling this twice gives a bit of a speedup. More unrolling did not help.\n+            if (info == mInfo[idx] && KeyEqual::operator()(key, mKeyVals[idx].getFirst())) {\n+                return idx;\n+            }\n+            next(&info, &idx);\n+            if (info == mInfo[idx] && KeyEqual::operator()(key, mKeyVals[idx].getFirst())) {\n+                return idx;\n+            }\n+            next(&info, &idx);\n+        } while (info <= mInfo[idx]);\n+\n+        // nothing found!\n+        return mMask == 0 ? 0 : mMask + 1;\n+    }\n+\n+    void cloneData(const unordered_map& o) {\n+        Cloner<unordered_map, IsFlatMap && ROBIN_HOOD_IS_TRIVIALLY_COPYABLE(Node)>()(o, *this);\n+    }\n+\n+    // inserts a keyval that is guaranteed to be new, e.g. when the hashmap is resized.\n+    // @return index where the element was created\n+    size_t insert_move(Node&& keyval) {\n+        // we don't retry, fail if overflowing\n+        // don't need to check max num elements\n+        if (0 == mMaxNumElementsAllowed && !try_increase_info()) {\n+            throwOverflowError();\n+        }\n+\n+        size_t idx;\n+        InfoType info;\n+        keyToIdx(keyval.getFirst(), &idx, &info);\n+\n+        // skip forward. Use <= because we are certain that the element is not there.\n+        while (info <= mInfo[idx]) {\n+            idx = (idx + 1) & mMask;\n+            info += mInfoInc;\n+        }\n+\n+        // key not found, so we are now exactly where we want to insert it.\n+        auto const insertion_idx = idx;\n+        auto const insertion_info = static_cast<uint8_t>(info);\n+        if (ROBIN_HOOD_UNLIKELY(insertion_info + mInfoInc > 0xFF)) {\n+            mMaxNumElementsAllowed = 0;\n+        }\n+\n+        // find an empty spot\n+        while (0 != mInfo[idx]) {\n+            next(&info, &idx);\n+        }\n+\n+        auto& l = mKeyVals[insertion_idx];\n+        if (idx == insertion_idx) {\n+            ::new (static_cast<void*>(&l)) Node(std::move(keyval));\n+        } else {\n+            shiftUp(idx, insertion_idx);\n+            l = std::move(keyval);\n+        }\n+\n+        // put at empty spot\n+        mInfo[insertion_idx] = insertion_info;\n+\n+        ++mNumElements;\n+        return insertion_idx;\n+    }\n+\n+public:\n+    using iterator = Iter<false>;\n+    using const_iterator = Iter<true>;\n+\n+    // Creates an empty hash map. Nothing is allocated yet, this happens at the first insert. This\n+    // tremendously speeds up ctor & dtor of a map that never receives an element. The penalty is\n+    // payed at the first insert, and not before. Lookup of this empty map works because everybody\n+    // points to DummyInfoByte::b. parameter bucket_count is dictated by the standard, but we can\n+    // ignore it.\n+    explicit unordered_map(size_t ROBIN_HOOD_UNUSED(bucket_count) /*unused*/ = 0,\n+                           const Hash& h = Hash{},\n+                           const KeyEqual& equal = KeyEqual{}) noexcept(noexcept(Hash(h)) &&\n+                                                                        noexcept(KeyEqual(equal)))\n+        : Hash(h)\n+        , KeyEqual(equal) {\n+        ROBIN_HOOD_TRACE(this);\n+    }\n+\n+    template <typename Iter>\n+    unordered_map(Iter first, Iter last, size_t ROBIN_HOOD_UNUSED(bucket_count) /*unused*/ = 0,\n+                  const Hash& h = Hash{}, const KeyEqual& equal = KeyEqual{})\n+        : Hash(h)\n+        , KeyEqual(equal) {\n+        ROBIN_HOOD_TRACE(this);\n+        insert(first, last);\n+    }\n+\n+    unordered_map(std::initializer_list<value_type> initlist,\n+                  size_t ROBIN_HOOD_UNUSED(bucket_count) /*unused*/ = 0, const Hash& h = Hash{},\n+                  const KeyEqual& equal = KeyEqual{})\n+        : Hash(h)\n+        , KeyEqual(equal) {\n+        ROBIN_HOOD_TRACE(this);\n+        insert(initlist.begin(), initlist.end());\n+    }\n+\n+    unordered_map(unordered_map&& o) noexcept\n+        : Hash(std::move(static_cast<Hash&>(o)))\n+        , KeyEqual(std::move(static_cast<KeyEqual&>(o)))\n+        , DataPool(std::move(static_cast<DataPool&>(o))) {\n+        ROBIN_HOOD_TRACE(this);\n+        if (o.mMask) {\n+            mKeyVals = std::move(o.mKeyVals);\n+            mInfo = std::move(o.mInfo);\n+            mNumElements = std::move(o.mNumElements);\n+            mMask = std::move(o.mMask);\n+            mMaxNumElementsAllowed = std::move(o.mMaxNumElementsAllowed);\n+            mInfoInc = std::move(o.mInfoInc);\n+            mInfoHashShift = std::move(o.mInfoHashShift);\n+            // set other's mask to 0 so its destructor won't do anything\n+            o.init();\n+        }\n+    }\n+\n+    unordered_map& operator=(unordered_map&& o) noexcept {\n+        ROBIN_HOOD_TRACE(this);\n+        if (&o != this) {\n+            if (o.mMask) {\n+                // only move stuff if the other map actually has some data\n+                destroy();\n+                mKeyVals = std::move(o.mKeyVals);\n+                mInfo = std::move(o.mInfo);\n+                mNumElements = std::move(o.mNumElements);\n+                mMask = std::move(o.mMask);\n+                mMaxNumElementsAllowed = std::move(o.mMaxNumElementsAllowed);\n+                mInfoInc = std::move(o.mInfoInc);\n+                mInfoHashShift = std::move(o.mInfoHashShift);\n+                Hash::operator=(std::move(static_cast<Hash&>(o)));\n+                KeyEqual::operator=(std::move(static_cast<KeyEqual&>(o)));\n+                DataPool::operator=(std::move(static_cast<DataPool&>(o)));\n+\n+                o.init();\n+\n+            } else {\n+                // nothing in the other map => just clear us.\n+                clear();\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    unordered_map(const unordered_map& o)\n+        : Hash(static_cast<const Hash&>(o))\n+        , KeyEqual(static_cast<const KeyEqual&>(o))\n+        , DataPool(static_cast<const DataPool&>(o)) {\n+        ROBIN_HOOD_TRACE(this);\n+        if (!o.empty()) {\n+            // not empty: create an exact copy. it is also possible to just iterate through all\n+            // elements and insert them, but copying is probably faster.\n+\n+            mKeyVals = static_cast<Node*>(\n+                detail::assertNotNull<std::bad_alloc>(malloc(calcNumBytesTotal(o.mMask + 1))));\n+            // no need for calloc because clonData does memcpy\n+            mInfo = reinterpret_cast<uint8_t*>(mKeyVals + o.mMask + 1);\n+            mNumElements = o.mNumElements;\n+            mMask = o.mMask;\n+            mMaxNumElementsAllowed = o.mMaxNumElementsAllowed;\n+            mInfoInc = o.mInfoInc;\n+            mInfoHashShift = o.mInfoHashShift;\n+            cloneData(o);\n+        }\n+    }\n+\n+    // Creates a copy of the given map. Copy constructor of each entry is used.\n+    unordered_map& operator=(unordered_map const& o) {\n+        ROBIN_HOOD_TRACE(this);\n+        if (&o == this) {\n+            // prevent assigning of itself\n+            return *this;\n+        }\n+\n+        // we keep using the old allocator and not assign the new one, because we want to keep the\n+        // memory available. when it is the same size.\n+        if (o.empty()) {\n+            if (0 == mMask) {\n+                // nothing to do, we are empty too\n+                return *this;\n+            }\n+\n+            // not empty: destroy what we have there\n+            // clear also resets mInfo to 0, that's sometimes not necessary.\n+            destroy();\n+            init();\n+            Hash::operator=(static_cast<const Hash&>(o));\n+            KeyEqual::operator=(static_cast<const KeyEqual&>(o));\n+            DataPool::operator=(static_cast<DataPool const&>(o));\n+\n+            return *this;\n+        }\n+\n+        // clean up old stuff\n+        Destroyer<Self, IsFlatMap && std::is_trivially_destructible<Node>::value>{}.nodes(*this);\n+\n+        if (mMask != o.mMask) {\n+            // no luck: we don't have the same array size allocated, so we need to realloc.\n+            if (0 != mMask) {\n+                // only deallocate if we actually have data!\n+                free(mKeyVals);\n+            }\n+\n+            mKeyVals = static_cast<Node*>(\n+                detail::assertNotNull<std::bad_alloc>(malloc(calcNumBytesTotal(o.mMask + 1))));\n+\n+            // no need for calloc here because cloneData performs a memcpy.\n+            mInfo = reinterpret_cast<uint8_t*>(mKeyVals + o.mMask + 1);\n+            // sentinel is set in cloneData\n+        }\n+        Hash::operator=(static_cast<const Hash&>(o));\n+        KeyEqual::operator=(static_cast<const KeyEqual&>(o));\n+        DataPool::operator=(static_cast<DataPool const&>(o));\n+        mNumElements = o.mNumElements;\n+        mMask = o.mMask;\n+        mMaxNumElementsAllowed = o.mMaxNumElementsAllowed;\n+        mInfoInc = o.mInfoInc;\n+        mInfoHashShift = o.mInfoHashShift;\n+        cloneData(o);\n+\n+        return *this;\n+    }\n+\n+    // Swaps everything between the two maps.\n+    void swap(unordered_map& o) {\n+        ROBIN_HOOD_TRACE(this);\n+        using std::swap;\n+        swap(o, *this);\n+    }\n+\n+    // Clears all data, without resizing.\n+    void clear() {\n+        ROBIN_HOOD_TRACE(this);\n+        if (empty()) {\n+            // don't do anything! also important because we don't want to write to DummyInfoByte::b,\n+            // even though we would just write 0 to it.\n+            return;\n+        }\n+\n+        Destroyer<Self, IsFlatMap && std::is_trivially_destructible<Node>::value>{}.nodes(*this);\n+\n+        // clear everything except the sentinel\n+        // std::memset(mInfo, 0, sizeof(uint8_t) * (mMask + 1));\n+        uint8_t const z = 0;\n+        std::fill(mInfo, mInfo + (sizeof(uint8_t) * (mMask + 1)), z);\n+\n+        mInfoInc = InitialInfoInc;\n+        mInfoHashShift = InitialInfoHashShift;\n+    }\n+\n+    // Destroys the map and all it's contents.\n+    ~unordered_map() {\n+        ROBIN_HOOD_TRACE(this);\n+        destroy();\n+    }\n+\n+    // Checks if both maps contain the same entries. Order is irrelevant.\n+    bool operator==(const unordered_map& other) const {\n+        ROBIN_HOOD_TRACE(this);\n+        if (other.size() != size()) {\n+            return false;\n+        }\n+        for (auto const& otherEntry : other) {\n+            auto const myIt = find(otherEntry.first);\n+            if (myIt == end() || !(myIt->second == otherEntry.second)) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    bool operator!=(const unordered_map& other) const {\n+        ROBIN_HOOD_TRACE(this);\n+        return !operator==(other);\n+    }\n+\n+    mapped_type& operator[](const key_type& key) {\n+        ROBIN_HOOD_TRACE(this);\n+        return doCreateByKey(key);\n+    }\n+\n+    mapped_type& operator[](key_type&& key) {\n+        ROBIN_HOOD_TRACE(this);\n+        return doCreateByKey(std::move(key));\n+    }\n+\n+    template <typename Iter>\n+    void insert(Iter first, Iter last) {\n+        for (; first != last; ++first) {\n+            // value_type ctor needed because this might be called with std::pair's\n+            insert(value_type(*first));\n+        }\n+    }\n+\n+    template <typename... Args>\n+    std::pair<iterator, bool> emplace(Args&&... args) {\n+        ROBIN_HOOD_TRACE(this);\n+        Node n{*this, std::forward<Args>(args)...};\n+        auto r = doInsert(std::move(n));\n+        if (!r.second) {\n+            // insertion not possible: destroy node\n+            // NOLINTNEXTLINE(bugprone-use-after-move)\n+            n.destroy(*this);\n+        }\n+        return r;\n+    }\n+\n+    std::pair<iterator, bool> insert(const value_type& keyval) {\n+        ROBIN_HOOD_TRACE(this);\n+        return doInsert(keyval);\n+    }\n+\n+    std::pair<iterator, bool> insert(value_type&& keyval) {\n+        return doInsert(std::move(keyval));\n+    }\n+\n+    // Returns 1 if key is found, 0 otherwise.\n+    size_t count(const key_type& key) const { // NOLINT(modernize-use-nodiscard)\n+        ROBIN_HOOD_TRACE(this);\n+        auto kv = mKeyVals + findIdx(key);\n+        if (kv != reinterpret_cast_no_cast_align_warning<Node*>(mInfo)) {\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    // Returns a reference to the value found for key.\n+    // Throws std::out_of_range if element cannot be found\n+    mapped_type& at(key_type const& key) {\n+        ROBIN_HOOD_TRACE(this);\n+        auto kv = mKeyVals + findIdx(key);\n+        if (kv == reinterpret_cast_no_cast_align_warning<Node*>(mInfo)) {\n+            doThrow<std::out_of_range>(\"key not found\");\n+        }\n+        return kv->getSecond();\n+    }\n+\n+    // Returns a reference to the value found for key.\n+    // Throws std::out_of_range if element cannot be found\n+    mapped_type const& at(key_type const& key) const { // NOLINT(modernize-use-nodiscard)\n+        ROBIN_HOOD_TRACE(this);\n+        auto kv = mKeyVals + findIdx(key);\n+        if (kv == reinterpret_cast_no_cast_align_warning<Node*>(mInfo)) {\n+            doThrow<std::out_of_range>(\"key not found\");\n+        }\n+        return kv->getSecond();\n+    }\n+\n+    const_iterator find(const key_type& key) const { // NOLINT(modernize-use-nodiscard)\n+        ROBIN_HOOD_TRACE(this);\n+        const size_t idx = findIdx(key);\n+        return const_iterator{mKeyVals + idx, mInfo + idx};\n+    }\n+\n+    template <typename OtherKey>\n+    const_iterator find(const OtherKey& key, is_transparent_tag /*unused*/) const {\n+        ROBIN_HOOD_TRACE(this);\n+        const size_t idx = findIdx(key);\n+        return const_iterator{mKeyVals + idx, mInfo + idx};\n+    }\n+\n+    iterator find(const key_type& key) {\n+        ROBIN_HOOD_TRACE(this);\n+        const size_t idx = findIdx(key);\n+        return iterator{mKeyVals + idx, mInfo + idx};\n+    }\n+\n+    template <typename OtherKey>\n+    iterator find(const OtherKey& key, is_transparent_tag /*unused*/) {\n+        ROBIN_HOOD_TRACE(this);\n+        const size_t idx = findIdx(key);\n+        return iterator{mKeyVals + idx, mInfo + idx};\n+    }\n+\n+    iterator begin() {\n+        ROBIN_HOOD_TRACE(this);\n+        if (empty()) {\n+            return end();\n+        }\n+        return iterator(mKeyVals, mInfo, fast_forward_tag{});\n+    }\n+    const_iterator begin() const { // NOLINT(modernize-use-nodiscard)\n+        ROBIN_HOOD_TRACE(this);\n+        return cbegin();\n+    }\n+    const_iterator cbegin() const { // NOLINT(modernize-use-nodiscard)\n+        ROBIN_HOOD_TRACE(this);\n+        if (empty()) {\n+            return cend();\n+        }\n+        return const_iterator(mKeyVals, mInfo, fast_forward_tag{});\n+    }\n+\n+    iterator end() {\n+        ROBIN_HOOD_TRACE(this);\n+        // no need to supply valid info pointer: end() must not be dereferenced, and only node\n+        // pointer is compared.\n+        return iterator{reinterpret_cast_no_cast_align_warning<Node*>(mInfo), nullptr};\n+    }\n+    const_iterator end() const { // NOLINT(modernize-use-nodiscard)\n+        ROBIN_HOOD_TRACE(this);\n+        return cend();\n+    }\n+    const_iterator cend() const { // NOLINT(modernize-use-nodiscard)\n+        ROBIN_HOOD_TRACE(this);\n+        return const_iterator{reinterpret_cast_no_cast_align_warning<Node*>(mInfo), nullptr};\n+    }\n+\n+    iterator erase(const_iterator pos) {\n+        ROBIN_HOOD_TRACE(this);\n+        // its safe to perform const cast here\n+        // NOLINTNEXTLINE(cppcoreguidelines-pro-type-const-cast)\n+        return erase(iterator{const_cast<Node*>(pos.mKeyVals), const_cast<uint8_t*>(pos.mInfo)});\n+    }\n+\n+    // Erases element at pos, returns iterator to the next element.\n+    iterator erase(iterator pos) {\n+        ROBIN_HOOD_TRACE(this);\n+        // we assume that pos always points to a valid entry, and not end().\n+        auto const idx = static_cast<size_t>(pos.mKeyVals - mKeyVals);\n+\n+        shiftDown(idx);\n+        --mNumElements;\n+\n+        if (*pos.mInfo) {\n+            // we've backward shifted, return this again\n+            return pos;\n+        }\n+\n+        // no backward shift, return next element\n+        return ++pos;\n+    }\n+\n+    size_t erase(const key_type& key) {\n+        ROBIN_HOOD_TRACE(this);\n+        size_t idx;\n+        InfoType info;\n+        keyToIdx(key, &idx, &info);\n+\n+        // check while info matches with the source idx\n+        do {\n+            if (info == mInfo[idx] && KeyEqual::operator()(key, mKeyVals[idx].getFirst())) {\n+                shiftDown(idx);\n+                --mNumElements;\n+                return 1;\n+            }\n+            next(&info, &idx);\n+        } while (info <= mInfo[idx]);\n+\n+        // nothing found to delete\n+        return 0;\n+    }\n+\n+    // reserves space for the specified number of elements. Makes sure the old data fits.\n+    // exactly the same as reserve(c).\n+    void rehash(size_t c) {\n+        reserve(c);\n+    }\n+\n+    // reserves space for the specified number of elements. Makes sure the old data fits.\n+    // Exactly the same as resize(c). Use resize(0) to shrink to fit.\n+    void reserve(size_t c) {\n+        ROBIN_HOOD_TRACE(this);\n+        auto const minElementsAllowed = (std::max)(c, mNumElements);\n+        auto newSize = InitialNumElements;\n+        while (calcMaxNumElementsAllowed(newSize) < minElementsAllowed && newSize != 0) {\n+            newSize *= 2;\n+        }\n+        if (ROBIN_HOOD_UNLIKELY(newSize == 0)) {\n+            throwOverflowError();\n+        }\n+\n+        rehashPowerOfTwo(newSize);\n+    }\n+\n+    size_type size() const noexcept { // NOLINT(modernize-use-nodiscard)\n+        ROBIN_HOOD_TRACE(this);\n+        return mNumElements;\n+    }\n+\n+    size_type max_size() const noexcept { // NOLINT(modernize-use-nodiscard)\n+        ROBIN_HOOD_TRACE(this);\n+        return static_cast<size_type>(-1);\n+    }\n+\n+    ROBIN_HOOD(NODISCARD) bool empty() const noexcept {\n+        ROBIN_HOOD_TRACE(this);\n+        return 0 == mNumElements;\n+    }\n+\n+    float max_load_factor() const noexcept { // NOLINT(modernize-use-nodiscard)\n+        ROBIN_HOOD_TRACE(this);\n+        return MaxLoadFactor100 / 100.0F;\n+    }\n+\n+    // Average number of elements per bucket. Since we allow only 1 per bucket\n+    float load_factor() const noexcept { // NOLINT(modernize-use-nodiscard)\n+        ROBIN_HOOD_TRACE(this);\n+        return static_cast<float>(size()) / static_cast<float>(mMask + 1);\n+    }\n+\n+    ROBIN_HOOD(NODISCARD) size_t mask() const noexcept {\n+        ROBIN_HOOD_TRACE(this);\n+        return mMask;\n+    }\n+\n+    ROBIN_HOOD(NODISCARD) size_t calcMaxNumElementsAllowed(size_t maxElements) const noexcept {\n+        if (ROBIN_HOOD_LIKELY(maxElements <= (std::numeric_limits<size_t>::max)() / 100)) {\n+            return maxElements * MaxLoadFactor100 / 100;\n+        }\n+\n+        // we might be a bit inprecise, but since maxElements is quite large that doesn't matter\n+        return (maxElements / 100) * MaxLoadFactor100;\n+    }\n+\n+    ROBIN_HOOD(NODISCARD) size_t calcNumBytesInfo(size_t numElements) const {\n+        return numElements + sizeof(uint64_t);\n+    }\n+\n+    // calculation ony allowed for 2^n values\n+    ROBIN_HOOD(NODISCARD) size_t calcNumBytesTotal(size_t numElements) const {\n+#if ROBIN_HOOD(BITNESS) == 64\n+        return numElements * sizeof(Node) + calcNumBytesInfo(numElements);\n+#else\n+        // make sure we're doing 64bit operations, so we are at least safe against 32bit overflows.\n+        auto const ne = static_cast<uint64_t>(numElements);\n+        auto const s = static_cast<uint64_t>(sizeof(Node));\n+        auto const infos = static_cast<uint64_t>(calcNumBytesInfo(numElements));\n+\n+        auto const total64 = ne * s + infos;\n+        auto const total = static_cast<size_t>(total64);\n+\n+        if (ROBIN_HOOD_UNLIKELY(static_cast<uint64_t>(total) != total64)) {\n+            throwOverflowError();\n+        }\n+        return total;\n+#endif\n+    }\n+\n+private:\n+    // reserves space for at least the specified number of elements.\n+    // only works if numBuckets if power of two\n+    void rehashPowerOfTwo(size_t numBuckets) {\n+        ROBIN_HOOD_TRACE(this);\n+\n+        Node* const oldKeyVals = mKeyVals;\n+        uint8_t const* const oldInfo = mInfo;\n+\n+        const size_t oldMaxElements = mMask + 1;\n+\n+        // resize operation: move stuff\n+        init_data(numBuckets);\n+        if (oldMaxElements > 1) {\n+            for (size_t i = 0; i < oldMaxElements; ++i) {\n+                if (oldInfo[i] != 0) {\n+                    insert_move(std::move(oldKeyVals[i]));\n+                    // destroy the node but DON'T destroy the data.\n+                    oldKeyVals[i].~Node();\n+                }\n+            }\n+\n+            // don't destroy old data: put it into the pool instead\n+            DataPool::addOrFree(oldKeyVals, calcNumBytesTotal(oldMaxElements));\n+        }\n+    }\n+\n+    ROBIN_HOOD(NOINLINE) void throwOverflowError() const {\n+#if ROBIN_HOOD(HAS_EXCEPTIONS)\n+        throw std::overflow_error(\"robin_hood::map overflow\");\n+#else\n+        abort();\n+#endif\n+    }\n+\n+    void init_data(size_t max_elements) {\n+        mNumElements = 0;\n+        mMask = max_elements - 1;\n+        mMaxNumElementsAllowed = calcMaxNumElementsAllowed(max_elements);\n+\n+        // calloc also zeroes everything\n+        mKeyVals = reinterpret_cast<Node*>(\n+            detail::assertNotNull<std::bad_alloc>(calloc(1, calcNumBytesTotal(max_elements))));\n+        mInfo = reinterpret_cast<uint8_t*>(mKeyVals + max_elements);\n+\n+        // set sentinel\n+        mInfo[max_elements] = 1;\n+\n+        mInfoInc = InitialInfoInc;\n+        mInfoHashShift = InitialInfoHashShift;\n+    }\n+\n+    template <typename Arg>\n+    mapped_type& doCreateByKey(Arg&& key) {\n+        while (true) {\n+            size_t idx;\n+            InfoType info;\n+            keyToIdx(key, &idx, &info);\n+            nextWhileLess(&info, &idx);\n+\n+            // while we potentially have a match. Can't do a do-while here because when mInfo is 0\n+            // we don't want to skip forward\n+            while (info == mInfo[idx]) {\n+                if (KeyEqual::operator()(key, mKeyVals[idx].getFirst())) {\n+                    // key already exists, do not insert.\n+                    return mKeyVals[idx].getSecond();\n+                }\n+                next(&info, &idx);\n+            }\n+\n+            // unlikely that this evaluates to true\n+            if (ROBIN_HOOD_UNLIKELY(mNumElements >= mMaxNumElementsAllowed)) {\n+                increase_size();\n+                continue;\n+            }\n+\n+            // key not found, so we are now exactly where we want to insert it.\n+            auto const insertion_idx = idx;\n+            auto const insertion_info = info;\n+            if (ROBIN_HOOD_UNLIKELY(insertion_info + mInfoInc > 0xFF)) {\n+                mMaxNumElementsAllowed = 0;\n+            }\n+\n+            // find an empty spot\n+            while (0 != mInfo[idx]) {\n+                next(&info, &idx);\n+            }\n+\n+            auto& l = mKeyVals[insertion_idx];\n+            if (idx == insertion_idx) {\n+                // put at empty spot. This forwards all arguments into the node where the object is\n+                // constructed exactly where it is needed.\n+                ::new (static_cast<void*>(&l))\n+                    Node(*this, std::piecewise_construct,\n+                         std::forward_as_tuple(std::forward<Arg>(key)), std::forward_as_tuple());\n+            } else {\n+                shiftUp(idx, insertion_idx);\n+                l = Node(*this, std::piecewise_construct,\n+                         std::forward_as_tuple(std::forward<Arg>(key)), std::forward_as_tuple());\n+            }\n+\n+            // mKeyVals[idx].getFirst() = std::move(key);\n+            mInfo[insertion_idx] = static_cast<uint8_t>(insertion_info);\n+\n+            ++mNumElements;\n+            return mKeyVals[insertion_idx].getSecond();\n+        }\n+    }\n+\n+    // This is exactly the same code as operator[], except for the return values\n+    template <typename Arg>\n+    std::pair<iterator, bool> doInsert(Arg&& keyval) {\n+        while (true) {\n+            size_t idx;\n+            InfoType info;\n+            keyToIdx(keyval.getFirst(), &idx, &info);\n+            nextWhileLess(&info, &idx);\n+\n+            // while we potentially have a match\n+            while (info == mInfo[idx]) {\n+                if (KeyEqual::operator()(keyval.getFirst(), mKeyVals[idx].getFirst())) {\n+                    // key already exists, do NOT insert.\n+                    // see http://en.cppreference.com/w/cpp/container/unordered_map/insert\n+                    return std::make_pair<iterator, bool>(iterator(mKeyVals + idx, mInfo + idx),\n+                                                          false);\n+                }\n+                next(&info, &idx);\n+            }\n+\n+            // unlikely that this evaluates to true\n+            if (ROBIN_HOOD_UNLIKELY(mNumElements >= mMaxNumElementsAllowed)) {\n+                increase_size();\n+                continue;\n+            }\n+\n+            // key not found, so we are now exactly where we want to insert it.\n+            auto const insertion_idx = idx;\n+            auto const insertion_info = info;\n+            if (ROBIN_HOOD_UNLIKELY(insertion_info + mInfoInc > 0xFF)) {\n+                mMaxNumElementsAllowed = 0;\n+            }\n+\n+            // find an empty spot\n+            while (0 != mInfo[idx]) {\n+                next(&info, &idx);\n+            }\n+\n+            auto& l = mKeyVals[insertion_idx];\n+            if (idx == insertion_idx) {\n+                ::new (static_cast<void*>(&l)) Node(*this, std::forward<Arg>(keyval));\n+            } else {\n+                shiftUp(idx, insertion_idx);\n+                l = Node(*this, std::forward<Arg>(keyval));\n+            }\n+\n+            // put at empty spot\n+            mInfo[insertion_idx] = static_cast<uint8_t>(insertion_info);\n+\n+            ++mNumElements;\n+            return std::make_pair(iterator(mKeyVals + insertion_idx, mInfo + insertion_idx), true);\n+        }\n+    }\n+\n+    bool try_increase_info() {\n+        ROBIN_HOOD_LOG(\"mInfoInc=\" << mInfoInc << \", numElements=\" << mNumElements\n+                                   << \", maxNumElementsAllowed=\"\n+                                   << calcMaxNumElementsAllowed(mMask + 1));\n+        if (mInfoInc <= 2) {\n+            // need to be > 2 so that shift works (otherwise undefined behavior!)\n+            return false;\n+        }\n+        // we got space left, try to make info smaller\n+        mInfoInc = static_cast<uint8_t>(mInfoInc >> 1U);\n+\n+        // remove one bit of the hash, leaving more space for the distance info.\n+        // This is extremely fast because we can operate on 8 bytes at once.\n+        ++mInfoHashShift;\n+        auto const data = reinterpret_cast_no_cast_align_warning<uint64_t*>(mInfo);\n+        auto const numEntries = (mMask + 1) / 8;\n+\n+        for (size_t i = 0; i < numEntries; ++i) {\n+            data[i] = (data[i] >> 1U) & UINT64_C(0x7f7f7f7f7f7f7f7f);\n+        }\n+        mMaxNumElementsAllowed = calcMaxNumElementsAllowed(mMask + 1);\n+        return true;\n+    }\n+\n+    void increase_size() {\n+        // nothing allocated yet? just allocate InitialNumElements\n+        if (0 == mMask) {\n+            init_data(InitialNumElements);\n+            return;\n+        }\n+\n+        auto const maxNumElementsAllowed = calcMaxNumElementsAllowed(mMask + 1);\n+        if (mNumElements < maxNumElementsAllowed && try_increase_info()) {\n+            return;\n+        }\n+\n+        ROBIN_HOOD_LOG(\"mNumElements=\" << mNumElements << \", maxNumElementsAllowed=\"\n+                                       << maxNumElementsAllowed << \", load=\"\n+                                       << (static_cast<double>(mNumElements) * 100.0 /\n+                                           (static_cast<double>(mMask) + 1)));\n+        // it seems we have a really bad hash function! don't try to resize again\n+        if (mNumElements * 2 < calcMaxNumElementsAllowed(mMask + 1)) {\n+            throwOverflowError();\n+        }\n+\n+        rehashPowerOfTwo((mMask + 1) * 2);\n+    }\n+\n+    void destroy() {\n+        if (0 == mMask) {\n+            // don't deallocate!\n+            return;\n+        }\n+\n+        Destroyer<Self, IsFlatMap && std::is_trivially_destructible<Node>::value>{}\n+            .nodesDoNotDeallocate(*this);\n+        free(mKeyVals);\n+    }\n+\n+    void init() noexcept {\n+        mKeyVals = reinterpret_cast<Node*>(&mMask);\n+        mInfo = reinterpret_cast<uint8_t*>(&mMask);\n+        mNumElements = 0;\n+        mMask = 0;\n+        mMaxNumElementsAllowed = 0;\n+        mInfoInc = InitialInfoInc;\n+        mInfoHashShift = InitialInfoHashShift;\n+    }\n+\n+    // members are sorted so no padding occurs\n+    Node* mKeyVals = reinterpret_cast<Node*>(&mMask);    // 8 byte  8\n+    uint8_t* mInfo = reinterpret_cast<uint8_t*>(&mMask); // 8 byte 16\n+    size_t mNumElements = 0;                             // 8 byte 24\n+    size_t mMask = 0;                                    // 8 byte 32\n+    size_t mMaxNumElementsAllowed = 0;                   // 8 byte 40\n+    InfoType mInfoInc = InitialInfoInc;                  // 4 byte 44\n+    InfoType mInfoHashShift = InitialInfoHashShift;      // 4 byte 48\n+                                                         // 16 byte 56 if NodeAllocator\n+};\n+\n+} // namespace detail\n+\n+template <typename Key, typename T, typename Hash = hash<Key>,\n+          typename KeyEqual = std::equal_to<Key>, size_t MaxLoadFactor100 = 80>\n+using unordered_flat_map = detail::unordered_map<true, MaxLoadFactor100, Key, T, Hash, KeyEqual>;\n+\n+template <typename Key, typename T, typename Hash = hash<Key>,\n+          typename KeyEqual = std::equal_to<Key>, size_t MaxLoadFactor100 = 80>\n+using unordered_node_map = detail::unordered_map<false, MaxLoadFactor100, Key, T, Hash, KeyEqual>;\n+\n+template <typename Key, typename T, typename Hash = hash<Key>,\n+          typename KeyEqual = std::equal_to<Key>, size_t MaxLoadFactor100 = 80>\n+using unordered_map =\n+    detail::unordered_map<sizeof(robin_hood::pair<Key, T>) <= sizeof(size_t) * 6 &&\n+                              std::is_nothrow_move_constructible<robin_hood::pair<Key, T>>::value &&\n+                              std::is_nothrow_move_assignable<robin_hood::pair<Key, T>>::value,\n+                          MaxLoadFactor100, Key, T, Hash, KeyEqual>;\n+\n+} // namespace robin_hood\n+\n+#endif"
      },
      {
        "sha": "fece3489f7bf2c1d2f0a4fd9b8756eac07357e4f",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/df1c9674c05fe731a3430993ca6c8b5500669bf7/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/df1c9674c05fe731a3430993ca6c8b5500669bf7/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=df1c9674c05fe731a3430993ca6c8b5500669bf7",
        "patch": "@@ -65,7 +65,7 @@ class CCoinsViewTest : public CCoinsView\n                     map_.erase(it->first);\n                 }\n             }\n-            mapCoins.erase(it++);\n+            it = mapCoins.erase(it);\n         }\n         if (!hashBlock.IsNull())\n             hashBestBlock_ = hashBlock;"
      },
      {
        "sha": "7338c9d3877b27af8727e63ab573a56618df6a98",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/df1c9674c05fe731a3430993ca6c8b5500669bf7/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/df1c9674c05fe731a3430993ca6c8b5500669bf7/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=df1c9674c05fe731a3430993ca6c8b5500669bf7",
        "patch": "@@ -115,8 +115,7 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n             changed++;\n         }\n         count++;\n-        CCoinsMap::iterator itOld = it++;\n-        mapCoins.erase(itOld);\n+        it = mapCoins.erase(it);\n         if (batch.SizeEstimate() > batch_size) {\n             LogPrint(BCLog::COINDB, \"Writing partial batch of %.2f MiB\\n\", batch.SizeEstimate() * (1.0 / 1048576.0));\n             m_db->WriteBatch(batch);"
      }
    ]
  },
  {
    "sha": "dfdd18eb31d54757e05da57aef910dc8025b9d73",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkZmRkMThlYjMxZDU0NzU3ZTA1ZGE1N2FlZjkxMGRjODAyNWI5ZDcz",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-09-01T17:23:00Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2021-07-26T20:17:42Z"
      },
      "message": "[robinhood] remove custom hash",
      "tree": {
        "sha": "aa5e7579673be5d67d2c2653b45d7afa54378b75",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/aa5e7579673be5d67d2c2653b45d7afa54378b75"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dfdd18eb31d54757e05da57aef910dc8025b9d73",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEGNRVI1NPYuZCSIrGepNdrbLETwUFAmD/GGYACgkQepNdrbLE\nTwVZcA//aTZol95QlWUoqMCU8oD6cytKdl14xHkKGgiqyEeeCJ+16UqZYXFk0yWk\noD8iHSNG0Z9YfW2E5vfcFwRaEALjHsz5UaaHojxvABzLYlb5IjFTj9e4OCTwCz3S\np5F9G/M2oOubBm9UvdQB3nxYLjcqJb9P9wVWP27o/asm11orze+j9EAjIfdzxU5g\nd1r8Ax13r9KVVGXQDCgrCM8bZIC//N7Ey90vokvieqg1OJpk1SxTn0sTIW3OslUJ\nzI3XXgnFb2nay+enpSH+DyauwC/j1koOK60WE62sz87vc3bYM7Bb2hh82ZiJaygy\ndjmQVXOiGgGeGpbn+Nr68bWxDxWkXa0/PqXwH0vPmY8PBMTEGo0knyd8NTpT+nIk\nClqWurh0Wd9YTVJv0Nif+JoZiSIQ2An9U8T1V154TJcyMTA0R4rGurQsupLhXrAM\nM2lwDjqug3gqXtqebby8SsQE6MI3+Ewgy/RcdfM8y88K5L34LOsm9hGU68EAOoML\ngjdFCM3gqyIuRBj8HtegP5Cf0TpdwIdhILYR9ZGzklZygp0LWbZfghm6p/N54VcN\naTWWfbC19stizkF50mAfuV2Ew/Og26dSrqHybb09WBdt09ErhWGFwffro+HEdZ47\nnpLFpU97FOrYUCtrKRtQ/TBMgCAsueI5ZpaCwPjuyAq96MVLiUE=\n=9A6z\n-----END PGP SIGNATURE-----",
        "payload": "tree aa5e7579673be5d67d2c2653b45d7afa54378b75\nparent df1c9674c05fe731a3430993ca6c8b5500669bf7\nauthor James O'Beirne <james.obeirne@gmail.com> 1567358580 -0400\ncommitter James O'Beirne <james.obeirne@pm.me> 1627330662 -0400\n\n[robinhood] remove custom hash\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dfdd18eb31d54757e05da57aef910dc8025b9d73",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dfdd18eb31d54757e05da57aef910dc8025b9d73",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dfdd18eb31d54757e05da57aef910dc8025b9d73/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "df1c9674c05fe731a3430993ca6c8b5500669bf7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/df1c9674c05fe731a3430993ca6c8b5500669bf7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/df1c9674c05fe731a3430993ca6c8b5500669bf7"
      }
    ],
    "stats": {
      "total": 153,
      "additions": 4,
      "deletions": 149
    },
    "files": [
      {
        "sha": "c5fc34eb46594159fbe80e3b92419881b53c6b11",
        "filename": "src/robin_hood.h",
        "status": "modified",
        "additions": 4,
        "deletions": 149,
        "changes": 153,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfdd18eb31d54757e05da57aef910dc8025b9d73/src/robin_hood.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfdd18eb31d54757e05da57aef910dc8025b9d73/src/robin_hood.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/robin_hood.h?ref=dfdd18eb31d54757e05da57aef910dc8025b9d73",
        "patch": "@@ -640,143 +640,6 @@ void swap(pair<A, B>& a, pair<A, B>& b) noexcept(\n     a.swap(b);\n }\n \n-// Hash an arbitrary amount of bytes. This is basically Murmur2 hash without caring about big\n-// endianness. TODO(martinus) add a fallback for very large strings?\n-static size_t hash_bytes(void const* ptr, size_t const len) noexcept {\n-    static constexpr uint64_t m = UINT64_C(0xc6a4a7935bd1e995);\n-    static constexpr uint64_t seed = UINT64_C(0xe17a1465);\n-    static constexpr unsigned int r = 47;\n-\n-    auto const data64 = static_cast<uint64_t const*>(ptr);\n-    uint64_t h = seed ^ (len * m);\n-\n-    size_t const n_blocks = len / 8;\n-    for (size_t i = 0; i < n_blocks; ++i) {\n-        auto k = detail::unaligned_load<uint64_t>(data64 + i);\n-\n-        k *= m;\n-        k ^= k >> r;\n-        k *= m;\n-\n-        h ^= k;\n-        h *= m;\n-    }\n-\n-    auto const data8 = reinterpret_cast<uint8_t const*>(data64 + n_blocks);\n-    switch (len & 7U) {\n-    case 7:\n-        h ^= static_cast<uint64_t>(data8[6]) << 48U;\n-        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n-    case 6:\n-        h ^= static_cast<uint64_t>(data8[5]) << 40U;\n-        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n-    case 5:\n-        h ^= static_cast<uint64_t>(data8[4]) << 32U;\n-        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n-    case 4:\n-        h ^= static_cast<uint64_t>(data8[3]) << 24U;\n-        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n-    case 3:\n-        h ^= static_cast<uint64_t>(data8[2]) << 16U;\n-        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n-    case 2:\n-        h ^= static_cast<uint64_t>(data8[1]) << 8U;\n-        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n-    case 1:\n-        h ^= static_cast<uint64_t>(data8[0]);\n-        h *= m;\n-        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n-    default:\n-        break;\n-    }\n-\n-    h ^= h >> r;\n-    h *= m;\n-    h ^= h >> r;\n-    return static_cast<size_t>(h);\n-}\n-\n-inline size_t hash_int(uint64_t obj) noexcept {\n-#if ROBIN_HOOD(HAS_UMUL128)\n-    // 167079903232 masksum, 120428523 ops best: 0xde5fb9d2630458e9\n-    static constexpr uint64_t k = UINT64_C(0xde5fb9d2630458e9);\n-    uint64_t h;\n-    uint64_t l = detail::umul128(obj, k, &h);\n-    return h + l;\n-#elif ROBIN_HOOD(BITNESS) == 32\n-    uint64_t const r = obj * UINT64_C(0xca4bcaa75ec3f625);\n-    auto h = static_cast<uint32_t>(r >> 32U);\n-    auto l = static_cast<uint32_t>(r);\n-    return h + l;\n-#else\n-    // murmurhash 3 finalizer\n-    uint64_t h = obj;\n-    h ^= h >> 33;\n-    h *= 0xff51afd7ed558ccd;\n-    h ^= h >> 33;\n-    h *= 0xc4ceb9fe1a85ec53;\n-    h ^= h >> 33;\n-    return static_cast<size_t>(h);\n-#endif\n-}\n-\n-// A thin wrapper around std::hash, performing an additional simple mixing step of the result.\n-template <typename T>\n-struct hash : public std::hash<T> {\n-    size_t operator()(T const& obj) const\n-        noexcept(noexcept(std::declval<std::hash<T>>().operator()(std::declval<T const&>()))) {\n-        // call base hash\n-        auto result = std::hash<T>::operator()(obj);\n-        // return mixed of that, to be save against identity has\n-        return hash_int(static_cast<uint64_t>(result));\n-    }\n-};\n-\n-template <>\n-struct hash<std::string> {\n-    size_t operator()(std::string const& str) const noexcept {\n-        return hash_bytes(str.data(), str.size());\n-    }\n-};\n-\n-template <class T>\n-struct hash<T*> {\n-    size_t operator()(T* ptr) const noexcept {\n-        return hash_int(reinterpret_cast<size_t>(ptr));\n-    }\n-};\n-\n-#define ROBIN_HOOD_HASH_INT(T)                           \\\n-    template <>                                          \\\n-    struct hash<T> {                                     \\\n-        size_t operator()(T obj) const noexcept {        \\\n-            return hash_int(static_cast<uint64_t>(obj)); \\\n-        }                                                \\\n-    }\n-\n-#if defined(__GNUC__) && !defined(__clang__)\n-#    pragma GCC diagnostic push\n-#    pragma GCC diagnostic ignored \"-Wuseless-cast\"\n-#endif\n-// see https://en.cppreference.com/w/cpp/utility/hash\n-ROBIN_HOOD_HASH_INT(bool);\n-ROBIN_HOOD_HASH_INT(char);\n-ROBIN_HOOD_HASH_INT(signed char);\n-ROBIN_HOOD_HASH_INT(unsigned char);\n-ROBIN_HOOD_HASH_INT(char16_t);\n-ROBIN_HOOD_HASH_INT(char32_t);\n-ROBIN_HOOD_HASH_INT(wchar_t);\n-ROBIN_HOOD_HASH_INT(short);\n-ROBIN_HOOD_HASH_INT(unsigned short);\n-ROBIN_HOOD_HASH_INT(int);\n-ROBIN_HOOD_HASH_INT(unsigned int);\n-ROBIN_HOOD_HASH_INT(long);\n-ROBIN_HOOD_HASH_INT(long long);\n-ROBIN_HOOD_HASH_INT(unsigned long);\n-ROBIN_HOOD_HASH_INT(unsigned long long);\n-#if defined(__GNUC__) && !defined(__clang__)\n-#    pragma GCC diagnostic pop\n-#endif\n namespace detail {\n \n // A highly optimized hashmap implementation, using the Robin Hood algorithm.\n@@ -1153,15 +1016,7 @@ class unordered_map\n     // The upper 1-5 bits need to be a reasonable good hash, to save comparisons.\n     template <typename HashKey>\n     void keyToIdx(HashKey&& key, size_t* idx, InfoType* info) const {\n-        // for a user-specified hash that is *not* robin_hood::hash, apply robin_hood::hash as an\n-        // additional mixing step. This serves as a bad hash prevention, if the given data is badly\n-        // mixed.\n-        using Mix =\n-            typename std::conditional<std::is_same<::robin_hood::hash<key_type>, hasher>::value,\n-                                      ::robin_hood::detail::identity_hash<size_t>,\n-                                      ::robin_hood::hash<size_t>>::type;\n-        *idx = Mix{}(Hash::operator()(key));\n-\n+        *idx = Hash::operator()(key);\n         *info = mInfoInc + static_cast<InfoType>(*idx >> mInfoHashShift);\n         *idx &= mMask;\n     }\n@@ -2016,15 +1871,15 @@ class unordered_map\n \n } // namespace detail\n \n-template <typename Key, typename T, typename Hash = hash<Key>,\n+template <typename Key, typename T, typename Hash,\n           typename KeyEqual = std::equal_to<Key>, size_t MaxLoadFactor100 = 80>\n using unordered_flat_map = detail::unordered_map<true, MaxLoadFactor100, Key, T, Hash, KeyEqual>;\n \n-template <typename Key, typename T, typename Hash = hash<Key>,\n+template <typename Key, typename T, typename Hash,\n           typename KeyEqual = std::equal_to<Key>, size_t MaxLoadFactor100 = 80>\n using unordered_node_map = detail::unordered_map<false, MaxLoadFactor100, Key, T, Hash, KeyEqual>;\n \n-template <typename Key, typename T, typename Hash = hash<Key>,\n+template <typename Key, typename T, typename Hash,\n           typename KeyEqual = std::equal_to<Key>, size_t MaxLoadFactor100 = 80>\n using unordered_map =\n     detail::unordered_map<sizeof(robin_hood::pair<Key, T>) <= sizeof(size_t) * 6 &&"
      }
    ]
  },
  {
    "sha": "960dbb579532529bf91ac853f1cadea9ba6e3b61",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NjBkYmI1Nzk1MzI1MjliZjkxYWM4NTNmMWNhZGVhOWJhNmUzYjYx",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-09-01T17:35:49Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2021-07-26T20:17:43Z"
      },
      "message": "[robinhood] remove inline DataNode (flatmap=true)",
      "tree": {
        "sha": "8b65328da194a3e8f3bf5351fd4711f2b0b28844",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8b65328da194a3e8f3bf5351fd4711f2b0b28844"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/960dbb579532529bf91ac853f1cadea9ba6e3b61",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEGNRVI1NPYuZCSIrGepNdrbLETwUFAmD/GGcACgkQepNdrbLE\nTwX49Q/7BE6iEIziLy4mL/xAuuqyl8fBKlYlPO75jyBJ7fYGunRVjZ/sZIDvcXtx\nbXHaDkjgUR9fLSLggr3lrulAPxF0UZCF+Jx5TWoaE1DK55SRG53OoE4MrXudwysv\nNoQEmNvzWh2imCuesceEBeI57/n86A6hNG/+VBJQlTT4fhXlQSO//Q9dQZoeDEFQ\nXetlYApDpmsRP96bgXFLv7VlnAH3mNJTPwHp9ZI4Ks9UpDmbqfcW0iKOsR6RBvFC\n350hAt2lCUy2OI0fxuWTZIPuP8wBF+VyXA7++NgiuOYb0IJz46NDY0dqSe6Uwpzg\nWD6/g0RY0rzHodyCVYElEwQ+gmBPkxqfNlguTaX5AJIsYadmbG8a4BKbpR4sjABL\nxZF6l8ghNIhDIpdpa6fBiziotZjLOgZrq2ZkAb+8lT5ORLacLtU61twBJt8Vg8Gw\nvScIqk0u4R+Nt2fRR20QsRClokdwbfPSq2P1B+0u/20JbRcUwTQ6RXaaLi1Izljp\ntBz/b7qKiRNwqGqC9hNSLsTiW0cTDz4WydB7GBxwNr0xLoP/EgxLdAq5zXnq/5co\nQ0kgssyu0Ar1NiTJLGlosL56wbbWpzFWtXT20kP1ec6AFq5TnAUslmgzSoyR+Wgd\nFuo+qPSg8xoFSGXrfpMVLCiUJwuUm95NeIHSFJvbiq35IGN3Rdc=\n=DXzi\n-----END PGP SIGNATURE-----",
        "payload": "tree 8b65328da194a3e8f3bf5351fd4711f2b0b28844\nparent dfdd18eb31d54757e05da57aef910dc8025b9d73\nauthor James O'Beirne <james.obeirne@gmail.com> 1567359349 -0400\ncommitter James O'Beirne <james.obeirne@pm.me> 1627330663 -0400\n\n[robinhood] remove inline DataNode (flatmap=true)\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/960dbb579532529bf91ac853f1cadea9ba6e3b61",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/960dbb579532529bf91ac853f1cadea9ba6e3b61",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/960dbb579532529bf91ac853f1cadea9ba6e3b61/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "dfdd18eb31d54757e05da57aef910dc8025b9d73",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dfdd18eb31d54757e05da57aef910dc8025b9d73",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/dfdd18eb31d54757e05da57aef910dc8025b9d73"
      }
    ],
    "stats": {
      "total": 61,
      "additions": 3,
      "deletions": 58
    },
    "files": [
      {
        "sha": "eb09ff91a62c34f65108d1b039bde55e69dd41c4",
        "filename": "src/robin_hood.h",
        "status": "modified",
        "additions": 3,
        "deletions": 58,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/960dbb579532529bf91ac853f1cadea9ba6e3b61/src/robin_hood.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/960dbb579532529bf91ac853f1cadea9ba6e3b61/src/robin_hood.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/robin_hood.h?ref=960dbb579532529bf91ac853f1cadea9ba6e3b61",
        "patch": "@@ -703,6 +703,8 @@ class unordered_map\n     using DataPool = detail::NodeAllocator<value_type, 4, 16384, IsFlatMap>;\n \n     // type needs to be wider than uint8_t.\n+    //\n+    // TODO(jamesob): why? advertised as a byte?\n     using InfoType = uint32_t;\n \n     // DataNode ////////////////////////////////////////////////////////\n@@ -713,63 +715,6 @@ class unordered_map\n     template <typename M, bool>\n     class DataNode {};\n \n-    // Small: just allocate on the stack.\n-    template <typename M>\n-    class DataNode<M, true> final {\n-    public:\n-        template <typename... Args>\n-        explicit DataNode(M& ROBIN_HOOD_UNUSED(map) /*unused*/, Args&&... args) noexcept(\n-            noexcept(value_type(std::forward<Args>(args)...)))\n-            : mData(std::forward<Args>(args)...) {}\n-\n-        DataNode(M& ROBIN_HOOD_UNUSED(map) /*unused*/, DataNode<M, true>&& n) noexcept(\n-            std::is_nothrow_move_constructible<value_type>::value)\n-            : mData(std::move(n.mData)) {}\n-\n-        // doesn't do anything\n-        void destroy(M& ROBIN_HOOD_UNUSED(map) /*unused*/) noexcept {}\n-        void destroyDoNotDeallocate() noexcept {}\n-\n-        value_type const* operator->() const noexcept {\n-            return &mData;\n-        }\n-        value_type* operator->() noexcept {\n-            return &mData;\n-        }\n-\n-        const value_type& operator*() const noexcept {\n-            return mData;\n-        }\n-\n-        value_type& operator*() noexcept {\n-            return mData;\n-        }\n-\n-        ROBIN_HOOD(NODISCARD) typename value_type::first_type& getFirst() noexcept {\n-            return mData.first;\n-        }\n-\n-        ROBIN_HOOD(NODISCARD) typename value_type::first_type const& getFirst() const noexcept {\n-            return mData.first;\n-        }\n-\n-        ROBIN_HOOD(NODISCARD) typename value_type::second_type& getSecond() noexcept {\n-            return mData.second;\n-        }\n-\n-        ROBIN_HOOD(NODISCARD) typename value_type::second_type const& getSecond() const noexcept {\n-            return mData.second;\n-        }\n-\n-        void swap(DataNode<M, true>& o) noexcept(\n-            noexcept(std::declval<value_type>().swap(std::declval<value_type>()))) {\n-            mData.swap(o.mData);\n-        }\n-\n-    private:\n-        value_type mData;\n-    };\n-\n     // big object: allocate on heap.\n     template <typename M>\n     class DataNode<M, false> {\n@@ -834,7 +779,7 @@ class unordered_map\n         value_type* mData;\n     };\n \n-    using Node = DataNode<Self, IsFlatMap>;\n+    using Node = DataNode<Self, false>;\n \n     // Cloner //////////////////////////////////////////////////////////\n "
      }
    ]
  },
  {
    "sha": "c04614301bdfe6ebe478a499128f286f74e2e1c5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjMDQ2MTQzMDFiZGZlNmViZTQ3OGE0OTkxMjhmMjg2Zjc0ZTJlMWM1",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-09-01T17:42:28Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2021-07-26T20:17:44Z"
      },
      "message": "[robinhood] remove robin_hood::pair",
      "tree": {
        "sha": "91cb81461585766779ac3f46871c5434a8ef68d0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/91cb81461585766779ac3f46871c5434a8ef68d0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c04614301bdfe6ebe478a499128f286f74e2e1c5",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEGNRVI1NPYuZCSIrGepNdrbLETwUFAmD/GGgACgkQepNdrbLE\nTwWV9A//YZOb64fuDI5vP8Nm1SvoEI7HqMAiWX29gecAYU7loe4e5lA2SLLeD4wS\nEg4aLuOfHf+/oxq1eEE3yxFi+rbtBglGoPPnoGqaHrA2wjQuWnctoHMVSk1j7Q15\necBcn+p/YjQ2EPiDwP29TsdYURBb0LxkTK+yolpjfQ0ABEjmTbmpclhkkF4D46Ya\nMgu9TLycjm+gPbK6MBM/JdvR6hSmpjUwuKZbPI36gGNByEPxnSNPhiuOvTuFjUVE\nYuQSCVCDz4m7/2FY0oZssPWJuL1hlgeuovjX9yisp5n8o6ALeRPwxvZFVn34quqQ\n1EGUWpoBh66mOQTBlR7XrnF4tv1W0UGMmpe9dfT+7fVTlJYD32HCBYL9cPIM6iOX\nhUbwuN47RD0OW5VsFcz83wiG7vEjppC20eKEddjjIktpYpbVxlUz6zKWl0gAhBmz\n49voI6LhEDON9cHHEa4O9URMDbSvMi+BcbOnAU8t1e35kR8FZI+hwK5QpkjejCuo\ngMvPC2Sus1V/xc/gy9Lf7m270cPknYScWAd/onjptt78keFU8RMGjVBa3zZm1uSQ\ndWs2tQy4SyKAttl29aDmxKYnawrdXzZaxEuW6odCzY8kjbmPNkNbKInUrAlav7pm\nkRglzL6TMXAE6/metyJvSEwtTE6yHMZZSUWyPsgJLoYxPOMY4eI=\n=vpUH\n-----END PGP SIGNATURE-----",
        "payload": "tree 91cb81461585766779ac3f46871c5434a8ef68d0\nparent 960dbb579532529bf91ac853f1cadea9ba6e3b61\nauthor James O'Beirne <james.obeirne@gmail.com> 1567359748 -0400\ncommitter James O'Beirne <james.obeirne@pm.me> 1627330664 -0400\n\n[robinhood] remove robin_hood::pair\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c04614301bdfe6ebe478a499128f286f74e2e1c5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c04614301bdfe6ebe478a499128f286f74e2e1c5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c04614301bdfe6ebe478a499128f286f74e2e1c5/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "960dbb579532529bf91ac853f1cadea9ba6e3b61",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/960dbb579532529bf91ac853f1cadea9ba6e3b61",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/960dbb579532529bf91ac853f1cadea9ba6e3b61"
      }
    ],
    "stats": {
      "total": 110,
      "additions": 6,
      "deletions": 104
    },
    "files": [
      {
        "sha": "f62c931c1466de9d308b32cd505cbea46e374f22",
        "filename": "src/memusage.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c04614301bdfe6ebe478a499128f286f74e2e1c5/src/memusage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c04614301bdfe6ebe478a499128f286f74e2e1c5/src/memusage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/memusage.h?ref=c04614301bdfe6ebe478a499128f286f74e2e1c5",
        "patch": "@@ -170,7 +170,7 @@ static inline size_t DynamicUsage(const std::unordered_map<X, Y, Z>& m)\n template<typename X, typename Y, typename Z>\n static inline size_t DynamicUsage(const robin_hood::unordered_node_map<X, Y, Z>& m)\n {\n-    return MallocUsage(sizeof(unordered_node<robin_hood::pair<const X, Y> >)) * m.size() + MallocUsage(sizeof(void*) * (m.mask() + 1));\n+    return MallocUsage(sizeof(unordered_node<std::pair<const X, Y> >)) * m.size() + MallocUsage(sizeof(void*) * (m.mask() + 1));\n }\n \n }"
      },
      {
        "sha": "499efd5a573735c683f2cf5c1d5595cc87bb7d68",
        "filename": "src/robin_hood.h",
        "status": "modified",
        "additions": 5,
        "deletions": 103,
        "changes": 108,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c04614301bdfe6ebe478a499128f286f74e2e1c5/src/robin_hood.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c04614301bdfe6ebe478a499128f286f74e2e1c5/src/robin_hood.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/robin_hood.h?ref=c04614301bdfe6ebe478a499128f286f74e2e1c5",
        "patch": "@@ -542,104 +542,6 @@ struct nothrow {\n \n struct is_transparent_tag {};\n \n-// A custom pair implementation is used in the map because std::pair is not is_trivially_copyable,\n-// which means it would  not be allowed to be used in std::memcpy. This struct is copyable, which is\n-// also tested.\n-template <typename T1, typename T2>\n-struct pair {\n-    using first_type = T1;\n-    using second_type = T2;\n-\n-    template <typename U1 = T1, typename U2 = T2,\n-              typename = typename std::enable_if<std::is_default_constructible<U1>::value &&\n-                                                 std::is_default_constructible<U2>::value>::type>\n-    constexpr pair() noexcept(noexcept(U1()) && noexcept(U2()))\n-        : first()\n-        , second() {}\n-\n-    // pair constructors are explicit so we don't accidentally call this ctor when we don't have to.\n-    explicit constexpr pair(std::pair<T1, T2> const& o) noexcept(\n-        noexcept(T1(std::declval<T1 const&>())) && noexcept(T2(std::declval<T2 const&>())))\n-        : first(o.first)\n-        , second(o.second) {}\n-\n-    // pair constructors are explicit so we don't accidentally call this ctor when we don't have to.\n-    explicit constexpr pair(std::pair<T1, T2>&& o) noexcept(\n-        noexcept(T1(std::move(std::declval<T1&&>()))) &&\n-        noexcept(T2(std::move(std::declval<T2&&>()))))\n-        : first(std::move(o.first))\n-        , second(std::move(o.second)) {}\n-\n-    constexpr pair(T1&& a, T2&& b) noexcept(noexcept(T1(std::move(std::declval<T1&&>()))) &&\n-                                            noexcept(T2(std::move(std::declval<T2&&>()))))\n-        : first(std::move(a))\n-        , second(std::move(b)) {}\n-\n-    template <typename U1, typename U2>\n-    constexpr pair(U1&& a, U2&& b) noexcept(noexcept(T1(std::forward<U1>(std::declval<U1&&>()))) &&\n-                                            noexcept(T2(std::forward<U2>(std::declval<U2&&>()))))\n-        : first(std::forward<U1>(a))\n-        , second(std::forward<U2>(b)) {}\n-\n-    template <typename... U1, typename... U2>\n-    constexpr pair(\n-        std::piecewise_construct_t /*unused*/, std::tuple<U1...> a,\n-        std::tuple<U2...> b) noexcept(noexcept(pair(std::declval<std::tuple<U1...>&>(),\n-                                                    std::declval<std::tuple<U2...>&>(),\n-                                                    ROBIN_HOOD_STD::index_sequence_for<U1...>(),\n-                                                    ROBIN_HOOD_STD::index_sequence_for<U2...>())))\n-        : pair(a, b, ROBIN_HOOD_STD::index_sequence_for<U1...>(),\n-               ROBIN_HOOD_STD::index_sequence_for<U2...>()) {}\n-\n-    // constructor called from the std::piecewise_construct_t ctor\n-    template <typename... U1, size_t... I1, typename... U2, size_t... I2>\n-    pair(std::tuple<U1...>& a, std::tuple<U2...>& b,\n-         ROBIN_HOOD_STD::index_sequence<I1...> /*unused*/,\n-         ROBIN_HOOD_STD::index_sequence<\n-             I2...> /*unused*/) noexcept(noexcept(T1(std::\n-                                                         forward<U1>(std::get<I1>(\n-                                                             std::declval<\n-                                                                 std::tuple<U1...>&>()))...)) &&\n-                                         noexcept(T2(std::forward<U2>(\n-                                             std::get<I2>(std::declval<std::tuple<U2...>&>()))...)))\n-        : first(std::forward<U1>(std::get<I1>(a))...)\n-        , second(std::forward<U2>(std::get<I2>(b))...) {\n-        // make visual studio compiler happy about warning about unused a & b.\n-        // Visual studio's pair implementation disables warning 4100.\n-        (void)a;\n-        (void)b;\n-    }\n-\n-    ROBIN_HOOD(NODISCARD) first_type& getFirst() noexcept {\n-        return first;\n-    }\n-    ROBIN_HOOD(NODISCARD) first_type const& getFirst() const noexcept {\n-        return first;\n-    }\n-    ROBIN_HOOD(NODISCARD) second_type& getSecond() noexcept {\n-        return second;\n-    }\n-    ROBIN_HOOD(NODISCARD) second_type const& getSecond() const noexcept {\n-        return second;\n-    }\n-\n-    void swap(pair<T1, T2>& o) noexcept((detail::swappable::nothrow<T1>::value) &&\n-                                        (detail::swappable::nothrow<T2>::value)) {\n-        using std::swap;\n-        swap(first, o.first);\n-        swap(second, o.second);\n-    }\n-\n-    T1 first;  // NOLINT(misc-non-private-member-variables-in-classes)\n-    T2 second; // NOLINT(misc-non-private-member-variables-in-classes)\n-};\n-\n-template <typename A, typename B>\n-void swap(pair<A, B>& a, pair<A, B>& b) noexcept(\n-    noexcept(std::declval<pair<A, B>&>().swap(std::declval<pair<A, B>&>()))) {\n-    a.swap(b);\n-}\n-\n namespace detail {\n \n // A highly optimized hashmap implementation, using the Robin Hood algorithm.\n@@ -675,13 +577,13 @@ class unordered_map\n     : public Hash,\n       public KeyEqual,\n       detail::NodeAllocator<\n-          robin_hood::pair<typename std::conditional<IsFlatMap, Key, Key const>::type, T>, 4, 16384,\n+          std::pair<typename std::conditional<IsFlatMap, Key, Key const>::type, T>, 4, 16384,\n           IsFlatMap> {\n public:\n     using key_type = Key;\n     using mapped_type = T;\n     using value_type =\n-        robin_hood::pair<typename std::conditional<IsFlatMap, Key, Key const>::type, T>;\n+        std::pair<typename std::conditional<IsFlatMap, Key, Key const>::type, T>;\n     using size_type = size_t;\n     using hasher = Hash;\n     using key_equal = KeyEqual;\n@@ -1827,9 +1729,9 @@ using unordered_node_map = detail::unordered_map<false, MaxLoadFactor100, Key, T\n template <typename Key, typename T, typename Hash,\n           typename KeyEqual = std::equal_to<Key>, size_t MaxLoadFactor100 = 80>\n using unordered_map =\n-    detail::unordered_map<sizeof(robin_hood::pair<Key, T>) <= sizeof(size_t) * 6 &&\n-                              std::is_nothrow_move_constructible<robin_hood::pair<Key, T>>::value &&\n-                              std::is_nothrow_move_assignable<robin_hood::pair<Key, T>>::value,\n+    detail::unordered_map<sizeof(std::pair<Key, T>) <= sizeof(size_t) * 6 &&\n+                              std::is_nothrow_move_constructible<std::pair<Key, T>>::value &&\n+                              std::is_nothrow_move_assignable<std::pair<Key, T>>::value,\n                           MaxLoadFactor100, Key, T, Hash, KeyEqual>;\n \n } // namespace robin_hood"
      }
    ]
  },
  {
    "sha": "f29a8a4c1dd264d97b052a4b568e8d63f72c6370",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMjlhOGE0YzFkZDI2NGQ5N2IwNTJhNGI1NjhlOGQ2M2Y3MmM2Mzcw",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-09-01T17:46:10Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2021-07-26T20:17:45Z"
      },
      "message": "[robinhood] remove Cloner and Destroyer for flatmaps",
      "tree": {
        "sha": "84469b5a94b16338a3c216a458b6e869c6bd164f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/84469b5a94b16338a3c216a458b6e869c6bd164f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f29a8a4c1dd264d97b052a4b568e8d63f72c6370",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEGNRVI1NPYuZCSIrGepNdrbLETwUFAmD/GGkACgkQepNdrbLE\nTwWYvQ/+Nj5n8TTXwY1ZH4HrCzn0Al0efjPl3iORUuurYHgMLtsCUTgTuyeIYBWY\nUfpl3NclkbdSU8RLV/YRxTV6QsKaxyqnrLDWL0P8qGl/DKxXcoNu85Orlez3QGvs\nQBqFy8pxdjI1d0/ubDE8GWZA+u+TMeYxxoivKyB6rZ4Tw3GrPGy4xnfEf4G+PxwL\n4nngJuW9LtStPGFwB6ku+VpgaYKoejNqLCZfXV5zoPTUG+e4E0AjII2kWS9XDHGY\nHyupaMgBDzNrr1o+YKp0ryQomamNOXyFKRYhhZnidFczbTKWlrLTUsUDoTRAx7tX\n1HeSlWPaUZ6eiE24CcSrC5EqxaW7kkCdkOmsRMvPgk2cnBiPsaNBsXf5XBw03/j5\n5QzJ+2TvrtgQtbHP1bvsLTmN7GmGm103HH5h/4WygBoAjQdaGtkSpll9hgyMfWMR\nXIegTjjr6w1vRFvJSGjIpIRD+aVMkrCkFecI9Eqa3c3MgUV6T68V41AnK/AD1rge\na5LWBGjYK/LiqRP7sYdCo6HxX3lr9GpJAdykJWQ+W8Ol6hiMVDpTGeCzjVcT+dfH\ns6TkaIdX5jHJqq0BslKjU8sMFRKrm5c82Q2+lik/506cY8NlhzKvh83mnXcZelx2\nEO5IqciWAAy9xDNXlnA0OINUQ7KrRF+lOQ5rT+iJkVoh/Vb0d70=\n=SRl7\n-----END PGP SIGNATURE-----",
        "payload": "tree 84469b5a94b16338a3c216a458b6e869c6bd164f\nparent c04614301bdfe6ebe478a499128f286f74e2e1c5\nauthor James O'Beirne <james.obeirne@gmail.com> 1567359970 -0400\ncommitter James O'Beirne <james.obeirne@pm.me> 1627330665 -0400\n\n[robinhood] remove Cloner and Destroyer for flatmaps\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f29a8a4c1dd264d97b052a4b568e8d63f72c6370",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f29a8a4c1dd264d97b052a4b568e8d63f72c6370",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f29a8a4c1dd264d97b052a4b568e8d63f72c6370/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c04614301bdfe6ebe478a499128f286f74e2e1c5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c04614301bdfe6ebe478a499128f286f74e2e1c5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c04614301bdfe6ebe478a499128f286f74e2e1c5"
      }
    ],
    "stats": {
      "total": 27,
      "additions": 2,
      "deletions": 25
    },
    "files": [
      {
        "sha": "abd9a9c53a05e21ca514cfe1b6b6c9b642287d5a",
        "filename": "src/robin_hood.h",
        "status": "modified",
        "additions": 2,
        "deletions": 25,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f29a8a4c1dd264d97b052a4b568e8d63f72c6370/src/robin_hood.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f29a8a4c1dd264d97b052a4b568e8d63f72c6370/src/robin_hood.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/robin_hood.h?ref=f29a8a4c1dd264d97b052a4b568e8d63f72c6370",
        "patch": "@@ -688,18 +688,6 @@ class unordered_map\n     template <typename M, bool UseMemcpy>\n     struct Cloner;\n \n-    // fast path: Just copy data, without allocating anything.\n-    template <typename M>\n-    struct Cloner<M, true> {\n-        void operator()(M const& source, M& target) const {\n-            // std::memcpy(target.mKeyVals, source.mKeyVals,\n-            //             target.calcNumBytesTotal(target.mMask + 1));\n-            auto src = reinterpret_cast<char const*>(source.mKeyVals);\n-            auto tgt = reinterpret_cast<char*>(target.mKeyVals);\n-            std::copy(src, src + target.calcNumBytesTotal(target.mMask + 1), tgt);\n-        }\n-    };\n-\n     template <typename M>\n     struct Cloner<M, false> {\n         void operator()(M const& s, M& t) const {\n@@ -718,17 +706,6 @@ class unordered_map\n     template <typename M, bool IsFlatMapAndTrivial>\n     struct Destroyer {};\n \n-    template <typename M>\n-    struct Destroyer<M, true> {\n-        void nodes(M& m) const noexcept {\n-            m.mNumElements = 0;\n-        }\n-\n-        void nodesDoNotDeallocate(M& m) const noexcept {\n-            m.mNumElements = 0;\n-        }\n-    };\n-\n     template <typename M>\n     struct Destroyer<M, false> {\n         void nodes(M& m) const noexcept {\n@@ -947,7 +924,7 @@ class unordered_map\n     }\n \n     void cloneData(const unordered_map& o) {\n-        Cloner<unordered_map, IsFlatMap && ROBIN_HOOD_IS_TRIVIALLY_COPYABLE(Node)>()(o, *this);\n+        Cloner<unordered_map, false>()(o, *this);\n     }\n \n     // inserts a keyval that is guaranteed to be new, e.g. when the hashmap is resized.\n@@ -1127,7 +1104,7 @@ class unordered_map\n         }\n \n         // clean up old stuff\n-        Destroyer<Self, IsFlatMap && std::is_trivially_destructible<Node>::value>{}.nodes(*this);\n+        Destroyer<Self, false>{}.nodes(*this);\n \n         if (mMask != o.mMask) {\n             // no luck: we don't have the same array size allocated, so we need to realloc."
      }
    ]
  },
  {
    "sha": "9acd37be6866f7f6324176c0bbf8998ed9e37302",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YWNkMzdiZTY4NjZmN2Y2MzI0MTc2YzBiYmY4OTk4ZWQ5ZTM3MzAy",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-09-01T17:54:10Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2021-07-26T20:17:46Z"
      },
      "message": "[robinhood] remove unnecessary constructors, operators",
      "tree": {
        "sha": "33ee987dcfcb68385e52ae1152db21e728a6ac90",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/33ee987dcfcb68385e52ae1152db21e728a6ac90"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9acd37be6866f7f6324176c0bbf8998ed9e37302",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEGNRVI1NPYuZCSIrGepNdrbLETwUFAmD/GGoACgkQepNdrbLE\nTwUNvhAAho+tcbIxBnS6FGVSajsk6SCxfenBZ37GsMZCJltRmSIcQJxGJzVamlTM\nvMKwOObRRXGSZn5cczDanZFS48lfPHSVpAYLPe4ZPfpoHZVPWR+XKPlWlPLv02jm\nbYwb6Emk9FOXQ1B7xTzbla/xoUbmO/CX10bJ6FLVi4Lzgq10nL3sfoyhJUEV9fRF\nwR2LRoINU0wRlKHuMwtYUu6aqk3WxHGbqU+ZPbIroXMml+EZefqslKGRlaz+wd37\nF04VTU1P9CqxlijhVN6V3CAkKSRByaODybBXAKR0Z90GNFwW8NsePIEdBf7XgRc2\nZswjnnnsopFsv1J9fq3s/+VhBp1rZXTtck/m/3nhjrkUouMqhAHUJh6FAkBZ7eeE\nU3tQwh13s61rYgHPwF7k7VLyKSPe09TaUBqiXfSHo0vq0elY7+RVnW3iE8+3IEOV\nug9iuHNEpjM4hhEt2J09S8XaR+P41oK8TjMwfvvmOsOHnv0Ywn309gMqUwIf0Noa\nMNe+BPT9MHXpZHCuQt4CKWAYDQwxT78uZOD9ELBveBjwJiD6O2wf6goUYxK4T2mg\nPVUDu4KJjWo6WgoEy06YHFz1Z8sUVNob5kdvFB5D4t3NN61n2iAEtE5jeKfcecYt\n2BRajSQiZgWh1wQTox0i29UPqcuihh3rLLjABSDUgzYU4TXCD38=\n=+GjX\n-----END PGP SIGNATURE-----",
        "payload": "tree 33ee987dcfcb68385e52ae1152db21e728a6ac90\nparent f29a8a4c1dd264d97b052a4b568e8d63f72c6370\nauthor James O'Beirne <james.obeirne@gmail.com> 1567360450 -0400\ncommitter James O'Beirne <james.obeirne@pm.me> 1627330666 -0400\n\n[robinhood] remove unnecessary constructors, operators\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9acd37be6866f7f6324176c0bbf8998ed9e37302",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9acd37be6866f7f6324176c0bbf8998ed9e37302",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9acd37be6866f7f6324176c0bbf8998ed9e37302/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f29a8a4c1dd264d97b052a4b568e8d63f72c6370",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f29a8a4c1dd264d97b052a4b568e8d63f72c6370",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f29a8a4c1dd264d97b052a4b568e8d63f72c6370"
      }
    ],
    "stats": {
      "total": 124,
      "additions": 0,
      "deletions": 124
    },
    "files": [
      {
        "sha": "f211093c74c5c23eb0509640e00bbfa8369f6ca7",
        "filename": "src/robin_hood.h",
        "status": "modified",
        "additions": 0,
        "deletions": 124,
        "changes": 124,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9acd37be6866f7f6324176c0bbf8998ed9e37302/src/robin_hood.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9acd37be6866f7f6324176c0bbf8998ed9e37302/src/robin_hood.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/robin_hood.h?ref=9acd37be6866f7f6324176c0bbf8998ed9e37302",
        "patch": "@@ -1009,130 +1009,6 @@ class unordered_map\n         insert(initlist.begin(), initlist.end());\n     }\n \n-    unordered_map(unordered_map&& o) noexcept\n-        : Hash(std::move(static_cast<Hash&>(o)))\n-        , KeyEqual(std::move(static_cast<KeyEqual&>(o)))\n-        , DataPool(std::move(static_cast<DataPool&>(o))) {\n-        ROBIN_HOOD_TRACE(this);\n-        if (o.mMask) {\n-            mKeyVals = std::move(o.mKeyVals);\n-            mInfo = std::move(o.mInfo);\n-            mNumElements = std::move(o.mNumElements);\n-            mMask = std::move(o.mMask);\n-            mMaxNumElementsAllowed = std::move(o.mMaxNumElementsAllowed);\n-            mInfoInc = std::move(o.mInfoInc);\n-            mInfoHashShift = std::move(o.mInfoHashShift);\n-            // set other's mask to 0 so its destructor won't do anything\n-            o.init();\n-        }\n-    }\n-\n-    unordered_map& operator=(unordered_map&& o) noexcept {\n-        ROBIN_HOOD_TRACE(this);\n-        if (&o != this) {\n-            if (o.mMask) {\n-                // only move stuff if the other map actually has some data\n-                destroy();\n-                mKeyVals = std::move(o.mKeyVals);\n-                mInfo = std::move(o.mInfo);\n-                mNumElements = std::move(o.mNumElements);\n-                mMask = std::move(o.mMask);\n-                mMaxNumElementsAllowed = std::move(o.mMaxNumElementsAllowed);\n-                mInfoInc = std::move(o.mInfoInc);\n-                mInfoHashShift = std::move(o.mInfoHashShift);\n-                Hash::operator=(std::move(static_cast<Hash&>(o)));\n-                KeyEqual::operator=(std::move(static_cast<KeyEqual&>(o)));\n-                DataPool::operator=(std::move(static_cast<DataPool&>(o)));\n-\n-                o.init();\n-\n-            } else {\n-                // nothing in the other map => just clear us.\n-                clear();\n-            }\n-        }\n-        return *this;\n-    }\n-\n-    unordered_map(const unordered_map& o)\n-        : Hash(static_cast<const Hash&>(o))\n-        , KeyEqual(static_cast<const KeyEqual&>(o))\n-        , DataPool(static_cast<const DataPool&>(o)) {\n-        ROBIN_HOOD_TRACE(this);\n-        if (!o.empty()) {\n-            // not empty: create an exact copy. it is also possible to just iterate through all\n-            // elements and insert them, but copying is probably faster.\n-\n-            mKeyVals = static_cast<Node*>(\n-                detail::assertNotNull<std::bad_alloc>(malloc(calcNumBytesTotal(o.mMask + 1))));\n-            // no need for calloc because clonData does memcpy\n-            mInfo = reinterpret_cast<uint8_t*>(mKeyVals + o.mMask + 1);\n-            mNumElements = o.mNumElements;\n-            mMask = o.mMask;\n-            mMaxNumElementsAllowed = o.mMaxNumElementsAllowed;\n-            mInfoInc = o.mInfoInc;\n-            mInfoHashShift = o.mInfoHashShift;\n-            cloneData(o);\n-        }\n-    }\n-\n-    // Creates a copy of the given map. Copy constructor of each entry is used.\n-    unordered_map& operator=(unordered_map const& o) {\n-        ROBIN_HOOD_TRACE(this);\n-        if (&o == this) {\n-            // prevent assigning of itself\n-            return *this;\n-        }\n-\n-        // we keep using the old allocator and not assign the new one, because we want to keep the\n-        // memory available. when it is the same size.\n-        if (o.empty()) {\n-            if (0 == mMask) {\n-                // nothing to do, we are empty too\n-                return *this;\n-            }\n-\n-            // not empty: destroy what we have there\n-            // clear also resets mInfo to 0, that's sometimes not necessary.\n-            destroy();\n-            init();\n-            Hash::operator=(static_cast<const Hash&>(o));\n-            KeyEqual::operator=(static_cast<const KeyEqual&>(o));\n-            DataPool::operator=(static_cast<DataPool const&>(o));\n-\n-            return *this;\n-        }\n-\n-        // clean up old stuff\n-        Destroyer<Self, false>{}.nodes(*this);\n-\n-        if (mMask != o.mMask) {\n-            // no luck: we don't have the same array size allocated, so we need to realloc.\n-            if (0 != mMask) {\n-                // only deallocate if we actually have data!\n-                free(mKeyVals);\n-            }\n-\n-            mKeyVals = static_cast<Node*>(\n-                detail::assertNotNull<std::bad_alloc>(malloc(calcNumBytesTotal(o.mMask + 1))));\n-\n-            // no need for calloc here because cloneData performs a memcpy.\n-            mInfo = reinterpret_cast<uint8_t*>(mKeyVals + o.mMask + 1);\n-            // sentinel is set in cloneData\n-        }\n-        Hash::operator=(static_cast<const Hash&>(o));\n-        KeyEqual::operator=(static_cast<const KeyEqual&>(o));\n-        DataPool::operator=(static_cast<DataPool const&>(o));\n-        mNumElements = o.mNumElements;\n-        mMask = o.mMask;\n-        mMaxNumElementsAllowed = o.mMaxNumElementsAllowed;\n-        mInfoInc = o.mInfoInc;\n-        mInfoHashShift = o.mInfoHashShift;\n-        cloneData(o);\n-\n-        return *this;\n-    }\n-\n     // Swaps everything between the two maps.\n     void swap(unordered_map& o) {\n         ROBIN_HOOD_TRACE(this);"
      }
    ]
  },
  {
    "sha": "c0cd24143fb6cd6eb45ad77a94b85d6c324f87de",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjMGNkMjQxNDNmYjZjZDZlYjQ1YWQ3N2E5NGI4NWQ2YzMyNGY4N2Rl",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-09-01T18:10:32Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2021-07-26T20:17:47Z"
      },
      "message": "[robinhood] remove all references to IsFlatMap",
      "tree": {
        "sha": "6020e4c80e4eea92fc9cd85fde8ee9d638f9bee0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6020e4c80e4eea92fc9cd85fde8ee9d638f9bee0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c0cd24143fb6cd6eb45ad77a94b85d6c324f87de",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEGNRVI1NPYuZCSIrGepNdrbLETwUFAmD/GGsACgkQepNdrbLE\nTwXASw/8DMyE21EksMhayTRmVSc1yohbdCtNnfH5gDXDAEZpcrqNqvh4UfeoJpzg\np/PTDcW3sfOSp4pO4Iy9sJK/S0SBsz8CaMjKUEQxUJA2Du7Oq+Kf5tXjHBylxikY\n9iNHpUjEgNmT0B83xmUWlS9miJyt1ZIRHW4NnqgpTVtYCFgNU4V8NB6sSgD4kKSZ\nGmwk/AXni82bLr0BfcEiWpFC6xV05i8UKeev8/3uRztHf8LXz5Id53JWuTV2aVnf\nsxJ5r5aFpRCPYrOfbqMfQMIwel4bDDoSjk1zb3bNPi1qdW6LKhSv1Kc2MozCJqRw\npCwjsQLN1keeAabSw65LmvQGA1x/5FIK6CAg18nb1nrKlcWsltgZ0hPFgknbAy9c\nwycgLFU1g7zJ+RVOoMhFg4D1H95sHRvbk40TUiQoYxWI5ds8alzGAleGH8LZRB4E\nk5K/WAo8rXFe7jGOur11RRKf7yC6B2W/+36ilAeDDRi6FOrUlUGbja1TKx+mBmn1\n75Qgxu3xDi7kr4lg79eFXo0YSUBfKM5d7n9eDcnCD4RPdtTS2+TwZrysRnQ6jFY/\nXjhCyz83ixPk+cyVNvCrLpeAfSJaQOnjRUPD66Qux5cnx3Z5xMut7fgY3s3y9Ssm\nOH+6sAehFgQ77Gi/zcISmD7avqwvShs98S8DfOKJVUZ3XqcD70A=\n=AQuJ\n-----END PGP SIGNATURE-----",
        "payload": "tree 6020e4c80e4eea92fc9cd85fde8ee9d638f9bee0\nparent 9acd37be6866f7f6324176c0bbf8998ed9e37302\nauthor James O'Beirne <james.obeirne@gmail.com> 1567361432 -0400\ncommitter James O'Beirne <james.obeirne@pm.me> 1627330667 -0400\n\n[robinhood] remove all references to IsFlatMap\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c0cd24143fb6cd6eb45ad77a94b85d6c324f87de",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c0cd24143fb6cd6eb45ad77a94b85d6c324f87de",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c0cd24143fb6cd6eb45ad77a94b85d6c324f87de/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9acd37be6866f7f6324176c0bbf8998ed9e37302",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9acd37be6866f7f6324176c0bbf8998ed9e37302",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9acd37be6866f7f6324176c0bbf8998ed9e37302"
      }
    ],
    "stats": {
      "total": 52,
      "additions": 9,
      "deletions": 43
    },
    "files": [
      {
        "sha": "bab2ad8a2a243d6f1b580367082f80991da51ec0",
        "filename": "src/robin_hood.h",
        "status": "modified",
        "additions": 9,
        "deletions": 43,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c0cd24143fb6cd6eb45ad77a94b85d6c324f87de/src/robin_hood.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c0cd24143fb6cd6eb45ad77a94b85d6c324f87de/src/robin_hood.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/robin_hood.h?ref=c0cd24143fb6cd6eb45ad77a94b85d6c324f87de",
        "patch": "@@ -503,22 +503,6 @@ class BulkPoolAllocator {\n     T** mListForFree{nullptr};\n };\n \n-template <typename T, size_t MinSize, size_t MaxSize, bool IsFlatMap>\n-struct NodeAllocator;\n-\n-// dummy allocator that does nothing\n-template <typename T, size_t MinSize, size_t MaxSize>\n-struct NodeAllocator<T, MinSize, MaxSize, true> {\n-\n-    // we are not using the data, so just free it.\n-    void addOrFree(void* ptr, size_t ROBIN_HOOD_UNUSED(numBytes) /*unused*/) noexcept {\n-        free(ptr);\n-    }\n-};\n-\n-template <typename T, size_t MinSize, size_t MaxSize>\n-struct NodeAllocator<T, MinSize, MaxSize, false> : public BulkPoolAllocator<T, MinSize, MaxSize> {};\n-\n // dummy hash, unsed as mixer when robin_hood::hash is already used\n template <typename T>\n struct identity_hash {\n@@ -571,25 +555,21 @@ namespace detail {\n // According to STL, order of templates has effect on throughput. That's why I've moved the boolean\n // to the front.\n // https://www.reddit.com/r/cpp/comments/ahp6iu/compile_time_binary_size_reductions_and_cs_future/eeguck4/\n-template <bool IsFlatMap, size_t MaxLoadFactor100, typename Key, typename T, typename Hash,\n+template <size_t MaxLoadFactor100, typename Key, typename T, typename Hash,\n           typename KeyEqual>\n class unordered_map\n     : public Hash,\n       public KeyEqual,\n-      detail::NodeAllocator<\n-          std::pair<typename std::conditional<IsFlatMap, Key, Key const>::type, T>, 4, 16384,\n-          IsFlatMap> {\n+      detail::BulkPoolAllocator<std::pair<Key const, T>, 4, 16384> {\n public:\n     using key_type = Key;\n     using mapped_type = T;\n-    using value_type =\n-        std::pair<typename std::conditional<IsFlatMap, Key, Key const>::type, T>;\n+    using value_type = std::pair<Key const, T>;\n     using size_type = size_t;\n     using hasher = Hash;\n     using key_equal = KeyEqual;\n     using Self =\n-        unordered_map<IsFlatMap, MaxLoadFactor100, key_type, mapped_type, hasher, key_equal>;\n-    static constexpr bool is_flat_map = IsFlatMap;\n+        unordered_map<MaxLoadFactor100, key_type, mapped_type, hasher, key_equal>;\n \n private:\n     static_assert(MaxLoadFactor100 > 10 && MaxLoadFactor100 < 100,\n@@ -602,7 +582,7 @@ class unordered_map\n     static constexpr uint32_t InitialInfoNumBits = 5;\n     static constexpr uint8_t InitialInfoInc = 1U << InitialInfoNumBits;\n     static constexpr uint8_t InitialInfoHashShift = sizeof(size_t) * 8 - InitialInfoNumBits;\n-    using DataPool = detail::NodeAllocator<value_type, 4, 16384, IsFlatMap>;\n+    using DataPool = detail::BulkPoolAllocator<value_type, 4, 16384>;\n \n     // type needs to be wider than uint8_t.\n     //\n@@ -827,8 +807,7 @@ class unordered_map\n             } while (inc == static_cast<int>(sizeof(size_t)));\n         }\n \n-        friend class unordered_map<IsFlatMap, MaxLoadFactor100, key_type, mapped_type, hasher,\n-                                   key_equal>;\n+        friend class unordered_map<MaxLoadFactor100, key_type, mapped_type, hasher, key_equal>;\n         NodePtr mKeyVals{nullptr};\n         uint8_t const* mInfo{nullptr};\n     };\n@@ -1025,7 +1004,7 @@ class unordered_map\n             return;\n         }\n \n-        Destroyer<Self, IsFlatMap && std::is_trivially_destructible<Node>::value>{}.nodes(*this);\n+        Destroyer<Self, false>{}.nodes(*this);\n \n         // clear everything except the sentinel\n         // std::memset(mInfo, 0, sizeof(uint8_t) * (mMask + 1));\n@@ -1543,8 +1522,7 @@ class unordered_map\n             return;\n         }\n \n-        Destroyer<Self, IsFlatMap && std::is_trivially_destructible<Node>::value>{}\n-            .nodesDoNotDeallocate(*this);\n+        Destroyer<Self, false>{}.nodesDoNotDeallocate(*this);\n         free(mKeyVals);\n     }\n \n@@ -1573,19 +1551,7 @@ class unordered_map\n \n template <typename Key, typename T, typename Hash,\n           typename KeyEqual = std::equal_to<Key>, size_t MaxLoadFactor100 = 80>\n-using unordered_flat_map = detail::unordered_map<true, MaxLoadFactor100, Key, T, Hash, KeyEqual>;\n-\n-template <typename Key, typename T, typename Hash,\n-          typename KeyEqual = std::equal_to<Key>, size_t MaxLoadFactor100 = 80>\n-using unordered_node_map = detail::unordered_map<false, MaxLoadFactor100, Key, T, Hash, KeyEqual>;\n-\n-template <typename Key, typename T, typename Hash,\n-          typename KeyEqual = std::equal_to<Key>, size_t MaxLoadFactor100 = 80>\n-using unordered_map =\n-    detail::unordered_map<sizeof(std::pair<Key, T>) <= sizeof(size_t) * 6 &&\n-                              std::is_nothrow_move_constructible<std::pair<Key, T>>::value &&\n-                              std::is_nothrow_move_assignable<std::pair<Key, T>>::value,\n-                          MaxLoadFactor100, Key, T, Hash, KeyEqual>;\n+using unordered_node_map = detail::unordered_map< MaxLoadFactor100, Key, T, Hash, KeyEqual>;\n \n } // namespace robin_hood\n "
      }
    ]
  },
  {
    "sha": "f76b3681c356086810ffdf5f4af20fec9f926d6e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNzZiMzY4MWMzNTYwODY4MTBmZmRmNWY0YWYyMGZlYzlmOTI2ZDZl",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-09-01T18:14:00Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2021-07-26T20:17:48Z"
      },
      "message": "[robinhood] remove integer sequence stuff",
      "tree": {
        "sha": "975631dfbcd3c6524bbd9dfa7846839644120a8d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/975631dfbcd3c6524bbd9dfa7846839644120a8d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f76b3681c356086810ffdf5f4af20fec9f926d6e",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEGNRVI1NPYuZCSIrGepNdrbLETwUFAmD/GGwACgkQepNdrbLE\nTwVFJBAAmX4b4BZ+xf9edBFqdm557LWQZjuRNQwgl9kVO4rVv6frU7vChzvuZxS9\nNJB5WPETDj91+13t/OgskdFxjZ6ntAqq/m+XibPVHIo+fm9Cs5M54nBxG3VkXFAt\nGIcPF7g7iS76ol2zrE/2v+DJtL2Q8LNwULT086LqJvjU4leM1NrxREd0X8Gwo8i1\ndlBiRJj7cBzouZUfRdF5PNRIAcBpz4nSYlHKnqhizGqzsgLDWSuvlBGfSO8d1LGv\ndQnNYSAe8slI0hnxT8r/3c76Z0japbOWAS4hD91Rrx3f8Im85bismA+0yx3AViTO\naLixGD4+qpJsqfI7cVwx0c0R+y6xu4KlXc8Vz0NSkJBLxz41NDnOMbYRxqaM65fA\n91HF0pyxfAfGvUAfmqHpJFg/XxhA0MWoQ2OUCuhcnaKZkOsg1Gg5Ump6n9CGxQSp\nQt6C3uuv9nW4xdWBIXDu/MZ3/o48v39O3qAW0nASpLc0Li/RR6KGfWJx0RVhyI9D\numol+h1RP906hGVdlBVVuw4pcfVfWH/uvgUDvCX4kyeVWAByRWYreGHZqWsffxQH\nKiaQ8zZpcdry2nSbEJnK7kHF9KjxcCy8QMVWmo4+vbMkLH+wsMk1aJroleHxywuZ\nd6mpSO48RwaOI6e3AdtubRuDPtFRSr2I02tZcZupgCaylM5IxTg=\n=ZOq7\n-----END PGP SIGNATURE-----",
        "payload": "tree 975631dfbcd3c6524bbd9dfa7846839644120a8d\nparent c0cd24143fb6cd6eb45ad77a94b85d6c324f87de\nauthor James O'Beirne <james.obeirne@gmail.com> 1567361640 -0400\ncommitter James O'Beirne <james.obeirne@pm.me> 1627330668 -0400\n\n[robinhood] remove integer sequence stuff\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f76b3681c356086810ffdf5f4af20fec9f926d6e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f76b3681c356086810ffdf5f4af20fec9f926d6e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f76b3681c356086810ffdf5f4af20fec9f926d6e/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c0cd24143fb6cd6eb45ad77a94b85d6c324f87de",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c0cd24143fb6cd6eb45ad77a94b85d6c324f87de",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c0cd24143fb6cd6eb45ad77a94b85d6c324f87de"
      }
    ],
    "stats": {
      "total": 60,
      "additions": 0,
      "deletions": 60
    },
    "files": [
      {
        "sha": "22c8a050ca7544d4659c142279751b34d54b4d75",
        "filename": "src/robin_hood.h",
        "status": "modified",
        "additions": 0,
        "deletions": 60,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f76b3681c356086810ffdf5f4af20fec9f926d6e/src/robin_hood.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f76b3681c356086810ffdf5f4af20fec9f926d6e/src/robin_hood.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/robin_hood.h?ref=f76b3681c356086810ffdf5f4af20fec9f926d6e",
        "patch": "@@ -187,66 +187,6 @@ template <class T>\n struct alignment_of\n     : std::integral_constant<std::size_t, alignof(typename std::remove_all_extents<T>::type)> {};\n \n-template <class T, T... Ints>\n-class integer_sequence {\n-public:\n-    using value_type = T;\n-    static_assert(std::is_integral<value_type>::value, \"not integral type\");\n-    static constexpr std::size_t size() noexcept {\n-        return sizeof...(Ints);\n-    }\n-};\n-template <std::size_t... Inds>\n-using index_sequence = integer_sequence<std::size_t, Inds...>;\n-\n-namespace detail_ {\n-template <class T, T Begin, T End, bool>\n-struct IntSeqImpl {\n-    using TValue = T;\n-    static_assert(std::is_integral<TValue>::value, \"not integral type\");\n-    static_assert(Begin >= 0 && Begin < End, \"unexpected argument (Begin<0 || Begin<=End)\");\n-\n-    template <class, class>\n-    struct IntSeqCombiner;\n-\n-    template <TValue... Inds0, TValue... Inds1>\n-    struct IntSeqCombiner<integer_sequence<TValue, Inds0...>, integer_sequence<TValue, Inds1...>> {\n-        using TResult = integer_sequence<TValue, Inds0..., Inds1...>;\n-    };\n-\n-    using TResult =\n-        typename IntSeqCombiner<typename IntSeqImpl<TValue, Begin, Begin + (End - Begin) / 2,\n-                                                    (End - Begin) / 2 == 1>::TResult,\n-                                typename IntSeqImpl<TValue, Begin + (End - Begin) / 2, End,\n-                                                    (End - Begin + 1) / 2 == 1>::TResult>::TResult;\n-};\n-\n-template <class T, T Begin>\n-struct IntSeqImpl<T, Begin, Begin, false> {\n-    using TValue = T;\n-    static_assert(std::is_integral<TValue>::value, \"not integral type\");\n-    static_assert(Begin >= 0, \"unexpected argument (Begin<0)\");\n-    using TResult = integer_sequence<TValue>;\n-};\n-\n-template <class T, T Begin, T End>\n-struct IntSeqImpl<T, Begin, End, true> {\n-    using TValue = T;\n-    static_assert(std::is_integral<TValue>::value, \"not integral type\");\n-    static_assert(Begin >= 0, \"unexpected argument (Begin<0)\");\n-    using TResult = integer_sequence<TValue, Begin>;\n-};\n-} // namespace detail_\n-\n-template <class T, T N>\n-using make_integer_sequence = typename detail_::IntSeqImpl<T, 0, N, (N - 0) == 1>::TResult;\n-\n-template <std::size_t N>\n-using make_index_sequence = make_integer_sequence<std::size_t, N>;\n-\n-template <class... T>\n-using index_sequence_for = make_index_sequence<sizeof...(T)>;\n-\n } // namespace ROBIN_HOOD_STD\n \n #endif"
      }
    ]
  },
  {
    "sha": "c19d01482656627f504c7744b98a8504f3989890",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjMTlkMDE0ODI2NTY2MjdmNTA0Yzc3NDRiOThhODUwNGYzOTg5ODkw",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2021-07-26T20:23:34Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2021-07-26T20:23:34Z"
      },
      "message": "[robin_hood] update to 3.11.3",
      "tree": {
        "sha": "d8f646882514615a8871bfb2eb2656a9ed4d04ab",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d8f646882514615a8871bfb2eb2656a9ed4d04ab"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c19d01482656627f504c7744b98a8504f3989890",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEGNRVI1NPYuZCSIrGepNdrbLETwUFAmD/Gd0ACgkQepNdrbLE\nTwUx0g/+MvXRSNGEDaTyIgBXuByGGP/ydtBNHrn1ailfqr6+I9FtO2NHySJY2JJR\nRjFs9uvteAGsnDykUKeGuF3ctKl0R98pPG9sl/Y9fOXO9MKbel90qKMhdxaho+3u\n7LGVQTufOYDykYusQ8qHC5AXSWvnCMuwBRuPMiEPg1aEJkXo02MUbK0XOnxMEg0q\nozUwKdERh1TWOkPUZs0JGJO96PmClLjr6tTQaA6/J9Tdgdp0AxY1RAIRXof4pc/7\nURoNvniN67iNXK8jINf/RIoaB56g5jFySz7ZK88wPJMiBrFGnCgD/S5OTH8A7zkA\n1gPtdt8PVZ0opaA+zQym93J4OGAo1Ro5phf7ZjSD+yh4p9ylUKRA0ihluy8Wzq6y\nmKy8QikGF9KEtgAA/kM7hPMZM/xI989Rveq43TdRI3afAp508URyymgAwa9v6UvG\nkOY9IsS5K6ZwghXgFaBCVeqwuUWyahub0g+aud8YSiNLJPZbxZD49HTR/XZiqy8g\n4EfImuciQErFWCOBTM+WtYfwwzkr5grHTk98rUjPSGdtBOQgyFvbERdWYQIoY4Xn\nImvaqeEfJYlaTm5okNwykxSaMxa3ROcscF4FgnzKKKXuuOnbnoOJ98mV+0k7DOLk\ncMiJmYRjFJPErb9RsS+olO1mjq/33zMAz6HHzywhJwmVvdZ1vXM=\n=Rdj8\n-----END PGP SIGNATURE-----",
        "payload": "tree d8f646882514615a8871bfb2eb2656a9ed4d04ab\nparent f76b3681c356086810ffdf5f4af20fec9f926d6e\nauthor James O'Beirne <james.obeirne@pm.me> 1627331014 -0400\ncommitter James O'Beirne <james.obeirne@pm.me> 1627331014 -0400\n\n[robin_hood] update to 3.11.3\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c19d01482656627f504c7744b98a8504f3989890",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c19d01482656627f504c7744b98a8504f3989890",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c19d01482656627f504c7744b98a8504f3989890/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f76b3681c356086810ffdf5f4af20fec9f926d6e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f76b3681c356086810ffdf5f4af20fec9f926d6e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f76b3681c356086810ffdf5f4af20fec9f926d6e"
      }
    ],
    "stats": {
      "total": 1759,
      "additions": 1395,
      "deletions": 364
    },
    "files": [
      {
        "sha": "511a308d32bdf53ede4930a55b62bf516c6de77e",
        "filename": "src/robin_hood.h",
        "status": "modified",
        "additions": 1395,
        "deletions": 364,
        "changes": 1759,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c19d01482656627f504c7744b98a8504f3989890/src/robin_hood.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c19d01482656627f504c7744b98a8504f3989890/src/robin_hood.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/robin_hood.h?ref=c19d01482656627f504c7744b98a8504f3989890",
        "patch": "@@ -5,13 +5,12 @@\n //  /_/     \\____/ /_.___/ /_/   /_/ /_/ ________/_/ /_/ \\____/ \\____/ \\__,_/\n //                                      _/_____/\n //\n-// robin_hood::unordered_map for C++11\n-// version 3.4.0\n+// Fast & memory efficient hashtable based on robin hood hashing for C++11/14/17/20\n // https://github.com/martinus/robin-hood-hashing\n //\n // Licensed under the MIT License <http://opensource.org/licenses/MIT>.\n // SPDX-License-Identifier: MIT\n-// Copyright (c) 2018-2019 Martin Ankerl <http://martin.ankerl.com>\n+// Copyright (c) 2018-2021 Martin Ankerl <http://martin.ankerl.com>\n //\n // Permission is hereby granted, free of charge, to any person obtaining a copy\n // of this software and associated documentation files (the \"Software\"), to deal\n@@ -35,36 +34,64 @@\n #define ROBIN_HOOD_H_INCLUDED\n \n // see https://semver.org/\n-#define ROBIN_HOOD_VERSION_MAJOR 3 // for incompatible API changes\n-#define ROBIN_HOOD_VERSION_MINOR 4 // for adding functionality in a backwards-compatible manner\n-#define ROBIN_HOOD_VERSION_PATCH 0 // for backwards-compatible bug fixes\n+#define ROBIN_HOOD_VERSION_MAJOR 3  // for incompatible API changes\n+#define ROBIN_HOOD_VERSION_MINOR 11 // for adding functionality in a backwards-compatible manner\n+#define ROBIN_HOOD_VERSION_PATCH 3  // for backwards-compatible bug fixes\n \n #include <algorithm>\n #include <cstdlib>\n #include <cstring>\n #include <functional>\n+#include <limits>\n+#include <memory> // only to support hash of smart pointers\n #include <stdexcept>\n #include <string>\n #include <type_traits>\n #include <utility>\n+#if __cplusplus >= 201703L\n+#    include <string_view>\n+#endif\n \n // #define ROBIN_HOOD_LOG_ENABLED\n #ifdef ROBIN_HOOD_LOG_ENABLED\n #    include <iostream>\n-#    define ROBIN_HOOD_LOG(x) std::cout << __FUNCTION__ << \"@\" << __LINE__ << \": \" << x << std::endl\n+#    define ROBIN_HOOD_LOG(...) \\\n+        std::cout << __FUNCTION__ << \"@\" << __LINE__ << \": \" << __VA_ARGS__ << std::endl;\n #else\n #    define ROBIN_HOOD_LOG(x)\n #endif\n \n // #define ROBIN_HOOD_TRACE_ENABLED\n #ifdef ROBIN_HOOD_TRACE_ENABLED\n #    include <iostream>\n-#    define ROBIN_HOOD_TRACE(x) \\\n-        std::cout << __FUNCTION__ << \"@\" << __LINE__ << \": \" << x << std::endl\n+#    define ROBIN_HOOD_TRACE(...) \\\n+        std::cout << __FUNCTION__ << \"@\" << __LINE__ << \": \" << __VA_ARGS__ << std::endl;\n #else\n #    define ROBIN_HOOD_TRACE(x)\n #endif\n \n+// #define ROBIN_HOOD_COUNT_ENABLED\n+#ifdef ROBIN_HOOD_COUNT_ENABLED\n+#    include <iostream>\n+#    define ROBIN_HOOD_COUNT(x) ++counts().x;\n+namespace robin_hood {\n+struct Counts {\n+    uint64_t shiftUp{};\n+    uint64_t shiftDown{};\n+};\n+inline std::ostream& operator<<(std::ostream& os, Counts const& c) {\n+    return os << c.shiftUp << \" shiftUp\" << std::endl << c.shiftDown << \" shiftDown\" << std::endl;\n+}\n+\n+static Counts& counts() {\n+    static Counts counts{};\n+    return counts;\n+}\n+} // namespace robin_hood\n+#else\n+#    define ROBIN_HOOD_COUNT(x)\n+#endif\n+\n // all non-argument macros should use this facility. See\n // https://www.fluentcpp.com/2019/05/28/better-macros-better-flags/\n #define ROBIN_HOOD(x) ROBIN_HOOD_PRIVATE_DEFINITION_##x()\n@@ -82,7 +109,7 @@\n #endif\n \n // endianess\n-#ifdef _WIN32\n+#ifdef _MSC_VER\n #    define ROBIN_HOOD_PRIVATE_DEFINITION_LITTLE_ENDIAN() 1\n #    define ROBIN_HOOD_PRIVATE_DEFINITION_BIG_ENDIAN() 0\n #else\n@@ -92,7 +119,7 @@\n #endif\n \n // inline\n-#ifdef _WIN32\n+#ifdef _MSC_VER\n #    define ROBIN_HOOD_PRIVATE_DEFINITION_NOINLINE() __declspec(noinline)\n #else\n #    define ROBIN_HOOD_PRIVATE_DEFINITION_NOINLINE() __attribute__((noinline))\n@@ -106,31 +133,32 @@\n #endif\n \n // count leading/trailing bits\n-#ifdef _WIN32\n-#    if ROBIN_HOOD(BITNESS) == 32\n-#        define ROBIN_HOOD_PRIVATE_DEFINITION_BITSCANFORWARD() _BitScanForward\n+#if !defined(ROBIN_HOOD_DISABLE_INTRINSICS)\n+#    ifdef _MSC_VER\n+#        if ROBIN_HOOD(BITNESS) == 32\n+#            define ROBIN_HOOD_PRIVATE_DEFINITION_BITSCANFORWARD() _BitScanForward\n+#        else\n+#            define ROBIN_HOOD_PRIVATE_DEFINITION_BITSCANFORWARD() _BitScanForward64\n+#        endif\n+#        include <intrin.h>\n+#        pragma intrinsic(ROBIN_HOOD(BITSCANFORWARD))\n+#        define ROBIN_HOOD_COUNT_TRAILING_ZEROES(x)                                       \\\n+            [](size_t mask) noexcept -> int {                                             \\\n+                unsigned long index;                                                      \\\n+                return ROBIN_HOOD(BITSCANFORWARD)(&index, mask) ? static_cast<int>(index) \\\n+                                                                : ROBIN_HOOD(BITNESS);    \\\n+            }(x)\n #    else\n-#        define ROBIN_HOOD_PRIVATE_DEFINITION_BITSCANFORWARD() _BitScanForward64\n+#        if ROBIN_HOOD(BITNESS) == 32\n+#            define ROBIN_HOOD_PRIVATE_DEFINITION_CTZ() __builtin_ctzl\n+#            define ROBIN_HOOD_PRIVATE_DEFINITION_CLZ() __builtin_clzl\n+#        else\n+#            define ROBIN_HOOD_PRIVATE_DEFINITION_CTZ() __builtin_ctzll\n+#            define ROBIN_HOOD_PRIVATE_DEFINITION_CLZ() __builtin_clzll\n+#        endif\n+#        define ROBIN_HOOD_COUNT_LEADING_ZEROES(x) ((x) ? ROBIN_HOOD(CLZ)(x) : ROBIN_HOOD(BITNESS))\n+#        define ROBIN_HOOD_COUNT_TRAILING_ZEROES(x) ((x) ? ROBIN_HOOD(CTZ)(x) : ROBIN_HOOD(BITNESS))\n #    endif\n-#    include <intrin.h>\n-#    pragma intrinsic(ROBIN_HOOD(BITSCANFORWARD))\n-#    define ROBIN_HOOD_COUNT_TRAILING_ZEROES(x)                                       \\\n-        [](size_t mask) noexcept->int {                                               \\\n-            unsigned long index;                                                      \\\n-            return ROBIN_HOOD(BITSCANFORWARD)(&index, mask) ? static_cast<int>(index) \\\n-                                                            : ROBIN_HOOD(BITNESS);    \\\n-        }                                                                             \\\n-        (x)\n-#else\n-#    if ROBIN_HOOD(BITNESS) == 32\n-#        define ROBIN_HOOD_PRIVATE_DEFINITION_CTZ() __builtin_ctzl\n-#        define ROBIN_HOOD_PRIVATE_DEFINITION_CLZ() __builtin_clzl\n-#    else\n-#        define ROBIN_HOOD_PRIVATE_DEFINITION_CTZ() __builtin_ctzll\n-#        define ROBIN_HOOD_PRIVATE_DEFINITION_CLZ() __builtin_clzll\n-#    endif\n-#    define ROBIN_HOOD_COUNT_LEADING_ZEROES(x) ((x) ? ROBIN_HOOD(CLZ)(x) : ROBIN_HOOD(BITNESS))\n-#    define ROBIN_HOOD_COUNT_TRAILING_ZEROES(x) ((x) ? ROBIN_HOOD(CTZ)(x) : ROBIN_HOOD(BITNESS))\n #endif\n \n // fallthrough\n@@ -146,14 +174,36 @@\n #endif\n \n // likely/unlikely\n-#if defined(_WIN32)\n+#ifdef _MSC_VER\n #    define ROBIN_HOOD_LIKELY(condition) condition\n #    define ROBIN_HOOD_UNLIKELY(condition) condition\n #else\n #    define ROBIN_HOOD_LIKELY(condition) __builtin_expect(condition, 1)\n #    define ROBIN_HOOD_UNLIKELY(condition) __builtin_expect(condition, 0)\n #endif\n \n+// detect if native wchar_t type is availiable in MSVC\n+#ifdef _MSC_VER\n+#    ifdef _NATIVE_WCHAR_T_DEFINED\n+#        define ROBIN_HOOD_PRIVATE_DEFINITION_HAS_NATIVE_WCHART() 1\n+#    else\n+#        define ROBIN_HOOD_PRIVATE_DEFINITION_HAS_NATIVE_WCHART() 0\n+#    endif\n+#else\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_HAS_NATIVE_WCHART() 1\n+#endif\n+\n+// detect if MSVC supports the pair(std::piecewise_construct_t,...) consructor being constexpr\n+#ifdef _MSC_VER\n+#    if _MSC_VER <= 1900\n+#        define ROBIN_HOOD_PRIVATE_DEFINITION_BROKEN_CONSTEXPR() 1\n+#    else\n+#        define ROBIN_HOOD_PRIVATE_DEFINITION_BROKEN_CONSTEXPR() 0\n+#    endif\n+#else\n+#    define ROBIN_HOOD_PRIVATE_DEFINITION_BROKEN_CONSTEXPR() 0\n+#endif\n+\n // workaround missing \"is_trivially_copyable\" in g++ < 5.0\n // See https://stackoverflow.com/a/31798726/48181\n #if defined(__GNUC__) && __GNUC__ < 5\n@@ -187,45 +237,84 @@ template <class T>\n struct alignment_of\n     : std::integral_constant<std::size_t, alignof(typename std::remove_all_extents<T>::type)> {};\n \n+template <class T, T... Ints>\n+class integer_sequence {\n+public:\n+    using value_type = T;\n+    static_assert(std::is_integral<value_type>::value, \"not integral type\");\n+    static constexpr std::size_t size() noexcept {\n+        return sizeof...(Ints);\n+    }\n+};\n+template <std::size_t... Inds>\n+using index_sequence = integer_sequence<std::size_t, Inds...>;\n+\n+namespace detail_ {\n+template <class T, T Begin, T End, bool>\n+struct IntSeqImpl {\n+    using TValue = T;\n+    static_assert(std::is_integral<TValue>::value, \"not integral type\");\n+    static_assert(Begin >= 0 && Begin < End, \"unexpected argument (Begin<0 || Begin<=End)\");\n+\n+    template <class, class>\n+    struct IntSeqCombiner;\n+\n+    template <TValue... Inds0, TValue... Inds1>\n+    struct IntSeqCombiner<integer_sequence<TValue, Inds0...>, integer_sequence<TValue, Inds1...>> {\n+        using TResult = integer_sequence<TValue, Inds0..., Inds1...>;\n+    };\n+\n+    using TResult =\n+        typename IntSeqCombiner<typename IntSeqImpl<TValue, Begin, Begin + (End - Begin) / 2,\n+                                                    (End - Begin) / 2 == 1>::TResult,\n+                                typename IntSeqImpl<TValue, Begin + (End - Begin) / 2, End,\n+                                                    (End - Begin + 1) / 2 == 1>::TResult>::TResult;\n+};\n+\n+template <class T, T Begin>\n+struct IntSeqImpl<T, Begin, Begin, false> {\n+    using TValue = T;\n+    static_assert(std::is_integral<TValue>::value, \"not integral type\");\n+    static_assert(Begin >= 0, \"unexpected argument (Begin<0)\");\n+    using TResult = integer_sequence<TValue>;\n+};\n+\n+template <class T, T Begin, T End>\n+struct IntSeqImpl<T, Begin, End, true> {\n+    using TValue = T;\n+    static_assert(std::is_integral<TValue>::value, \"not integral type\");\n+    static_assert(Begin >= 0, \"unexpected argument (Begin<0)\");\n+    using TResult = integer_sequence<TValue, Begin>;\n+};\n+} // namespace detail_\n+\n+template <class T, T N>\n+using make_integer_sequence = typename detail_::IntSeqImpl<T, 0, N, (N - 0) == 1>::TResult;\n+\n+template <std::size_t N>\n+using make_index_sequence = make_integer_sequence<std::size_t, N>;\n+\n+template <class... T>\n+using index_sequence_for = make_index_sequence<sizeof...(T)>;\n+\n } // namespace ROBIN_HOOD_STD\n \n #endif\n \n namespace detail {\n \n-// umul\n-#if defined(__SIZEOF_INT128__)\n-#    define ROBIN_HOOD_PRIVATE_DEFINITION_HAS_UMUL128() 1\n-#    if defined(__GNUC__) || defined(__clang__)\n-#        pragma GCC diagnostic push\n-#        pragma GCC diagnostic ignored \"-Wpedantic\"\n-using uint128_t = unsigned __int128;\n-#        pragma GCC diagnostic pop\n-#    endif\n-inline uint64_t umul128(uint64_t a, uint64_t b, uint64_t* high) noexcept {\n-    auto result = static_cast<uint128_t>(a) * static_cast<uint128_t>(b);\n-    *high = static_cast<uint64_t>(result >> 64U);\n-    return static_cast<uint64_t>(result);\n-}\n-#elif (defined(_WIN32) && ROBIN_HOOD(BITNESS) == 64)\n-#    define ROBIN_HOOD_PRIVATE_DEFINITION_HAS_UMUL128() 1\n-#    include <intrin.h> // for __umulh\n-#    pragma intrinsic(__umulh)\n-#    ifndef _M_ARM64\n-#        pragma intrinsic(_umul128)\n-#    endif\n-inline uint64_t umul128(uint64_t a, uint64_t b, uint64_t* high) noexcept {\n-#    ifdef _M_ARM64\n-    *high = __umulh(a, b);\n-    return ((uint64_t)(a)) * (b);\n-#    else\n-    return _umul128(a, b, high);\n-#    endif\n-}\n+// make sure we static_cast to the correct type for hash_int\n+#if ROBIN_HOOD(BITNESS) == 64\n+using SizeT = uint64_t;\n #else\n-#    define ROBIN_HOOD_PRIVATE_DEFINITION_HAS_UMUL128() 0\n+using SizeT = uint32_t;\n #endif\n \n+template <typename T>\n+T rotr(T x, unsigned k) {\n+    return (x >> k) | (x << (8U * sizeof(T) - k));\n+}\n+\n // This cast gets rid of warnings like \"cast from 'uint8_t*' {aka 'unsigned char*'} to\n // 'uint64_t*' {aka 'long unsigned int*'} increases required alignment of target type\". Use with\n // care!\n@@ -242,14 +331,14 @@ inline T reinterpret_cast_no_cast_align_warning(void const* ptr) noexcept {\n // make sure this is not inlined as it is slow and dramatically enlarges code, thus making other\n // inlinings more difficult. Throws are also generally the slow path.\n template <typename E, typename... Args>\n-ROBIN_HOOD(NOINLINE)\n+[[noreturn]] ROBIN_HOOD(NOINLINE)\n #if ROBIN_HOOD(HAS_EXCEPTIONS)\n-void doThrow(Args&&... args) {\n+    void doThrow(Args&&... args) {\n     // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-array-to-pointer-decay)\n     throw E(std::forward<Args>(args)...);\n }\n #else\n-void doThrow(Args&&... ROBIN_HOOD_UNUSED(args) /*unused*/) {\n+    void doThrow(Args&&... ROBIN_HOOD_UNUSED(args) /*unused*/) {\n     abort();\n }\n #endif\n@@ -301,6 +390,7 @@ class BulkPoolAllocator {\n     }\n \n     BulkPoolAllocator&\n+    // NOLINTNEXTLINE(bugprone-unhandled-self-assignment,cert-oop54-cpp)\n     operator=(const BulkPoolAllocator& ROBIN_HOOD_UNUSED(o) /*unused*/) noexcept {\n         // does not do anything\n         return *this;\n@@ -314,7 +404,8 @@ class BulkPoolAllocator {\n     void reset() noexcept {\n         while (mListForFree) {\n             T* tmp = *mListForFree;\n-            free(mListForFree);\n+            ROBIN_HOOD_LOG(\"std::free\")\n+            std::free(mListForFree);\n             mListForFree = reinterpret_cast_no_cast_align_warning<T**>(tmp);\n         }\n         mHead = nullptr;\n@@ -349,8 +440,10 @@ class BulkPoolAllocator {\n         // calculate number of available elements in ptr\n         if (numBytes < ALIGNMENT + ALIGNED_SIZE) {\n             // not enough data for at least one element. Free and return.\n-            free(ptr);\n+            ROBIN_HOOD_LOG(\"std::free\")\n+            std::free(ptr);\n         } else {\n+            ROBIN_HOOD_LOG(\"add to buffer\")\n             add(ptr, numBytes);\n         }\n     }\n@@ -391,10 +484,10 @@ class BulkPoolAllocator {\n         mListForFree = data;\n \n         // create linked list for newly allocated data\n-        auto const headT =\n+        auto* const headT =\n             reinterpret_cast_no_cast_align_warning<T*>(reinterpret_cast<char*>(ptr) + ALIGNMENT);\n \n-        auto const head = reinterpret_cast<char*>(headT);\n+        auto* const head = reinterpret_cast<char*>(headT);\n \n         // Visual Studio compiler automatically unrolls this loop, which is pretty cool\n         for (size_t i = 0; i < numElements; ++i) {\n@@ -414,9 +507,10 @@ class BulkPoolAllocator {\n         size_t const numElementsToAlloc = calcNumElementsToAlloc();\n \n         // alloc new memory: [prev |T, T, ... T]\n-        // std::cout << (sizeof(T*) + ALIGNED_SIZE * numElementsToAlloc) << \" bytes\" << std::endl;\n         size_t const bytes = ALIGNMENT + ALIGNED_SIZE * numElementsToAlloc;\n-        add(assertNotNull<std::bad_alloc>(malloc(bytes)), bytes);\n+        ROBIN_HOOD_LOG(\"std::malloc \" << bytes << \" = \" << ALIGNMENT << \" + \" << ALIGNED_SIZE\n+                                      << \" * \" << numElementsToAlloc)\n+        add(assertNotNull<std::bad_alloc>(std::malloc(bytes)), bytes);\n         return mHead;\n     }\n \n@@ -443,100 +537,504 @@ class BulkPoolAllocator {\n     T** mListForFree{nullptr};\n };\n \n-// dummy hash, unsed as mixer when robin_hood::hash is already used\n-template <typename T>\n-struct identity_hash {\n-    constexpr size_t operator()(T const& obj) const noexcept {\n-        return static_cast<size_t>(obj);\n+template <typename T, size_t MinSize, size_t MaxSize, bool IsFlat>\n+struct NodeAllocator;\n+\n+// dummy allocator that does nothing\n+template <typename T, size_t MinSize, size_t MaxSize>\n+struct NodeAllocator<T, MinSize, MaxSize, true> {\n+\n+    // we are not using the data, so just free it.\n+    void addOrFree(void* ptr, size_t ROBIN_HOOD_UNUSED(numBytes) /*unused*/) noexcept {\n+        ROBIN_HOOD_LOG(\"std::free\")\n+        std::free(ptr);\n     }\n };\n \n+template <typename T, size_t MinSize, size_t MaxSize>\n+struct NodeAllocator<T, MinSize, MaxSize, false> : public BulkPoolAllocator<T, MinSize, MaxSize> {};\n+\n // c++14 doesn't have is_nothrow_swappable, and clang++ 6.0.1 doesn't like it either, so I'm making\n // my own here.\n namespace swappable {\n+#if ROBIN_HOOD(CXX) < ROBIN_HOOD(CXX17)\n using std::swap;\n template <typename T>\n struct nothrow {\n     static const bool value = noexcept(swap(std::declval<T&>(), std::declval<T&>()));\n };\n-\n+#else\n+template <typename T>\n+struct nothrow {\n+    static const bool value = std::is_nothrow_swappable<T>::value;\n+};\n+#endif\n } // namespace swappable\n \n } // namespace detail\n \n struct is_transparent_tag {};\n \n+// A custom pair implementation is used in the map because std::pair is not is_trivially_copyable,\n+// which means it would  not be allowed to be used in std::memcpy. This struct is copyable, which is\n+// also tested.\n+template <typename T1, typename T2>\n+struct pair {\n+    using first_type = T1;\n+    using second_type = T2;\n+\n+    template <typename U1 = T1, typename U2 = T2,\n+              typename = typename std::enable_if<std::is_default_constructible<U1>::value &&\n+                                                 std::is_default_constructible<U2>::value>::type>\n+    constexpr pair() noexcept(noexcept(U1()) && noexcept(U2()))\n+        : first()\n+        , second() {}\n+\n+    // pair constructors are explicit so we don't accidentally call this ctor when we don't have to.\n+    explicit constexpr pair(std::pair<T1, T2> const& o) noexcept(\n+        noexcept(T1(std::declval<T1 const&>())) && noexcept(T2(std::declval<T2 const&>())))\n+        : first(o.first)\n+        , second(o.second) {}\n+\n+    // pair constructors are explicit so we don't accidentally call this ctor when we don't have to.\n+    explicit constexpr pair(std::pair<T1, T2>&& o) noexcept(noexcept(\n+        T1(std::move(std::declval<T1&&>()))) && noexcept(T2(std::move(std::declval<T2&&>()))))\n+        : first(std::move(o.first))\n+        , second(std::move(o.second)) {}\n+\n+    constexpr pair(T1&& a, T2&& b) noexcept(noexcept(\n+        T1(std::move(std::declval<T1&&>()))) && noexcept(T2(std::move(std::declval<T2&&>()))))\n+        : first(std::move(a))\n+        , second(std::move(b)) {}\n+\n+    template <typename U1, typename U2>\n+    constexpr pair(U1&& a, U2&& b) noexcept(noexcept(T1(std::forward<U1>(\n+        std::declval<U1&&>()))) && noexcept(T2(std::forward<U2>(std::declval<U2&&>()))))\n+        : first(std::forward<U1>(a))\n+        , second(std::forward<U2>(b)) {}\n+\n+    template <typename... U1, typename... U2>\n+    // MSVC 2015 produces error \"C2476: \u2018constexpr\u2019 constructor does not initialize all members\"\n+    // if this constructor is constexpr\n+#if !ROBIN_HOOD(BROKEN_CONSTEXPR)\n+    constexpr\n+#endif\n+        pair(std::piecewise_construct_t /*unused*/, std::tuple<U1...> a,\n+             std::tuple<U2...>\n+                 b) noexcept(noexcept(pair(std::declval<std::tuple<U1...>&>(),\n+                                           std::declval<std::tuple<U2...>&>(),\n+                                           ROBIN_HOOD_STD::index_sequence_for<U1...>(),\n+                                           ROBIN_HOOD_STD::index_sequence_for<U2...>())))\n+        : pair(a, b, ROBIN_HOOD_STD::index_sequence_for<U1...>(),\n+               ROBIN_HOOD_STD::index_sequence_for<U2...>()) {\n+    }\n+\n+    // constructor called from the std::piecewise_construct_t ctor\n+    template <typename... U1, size_t... I1, typename... U2, size_t... I2>\n+    pair(std::tuple<U1...>& a, std::tuple<U2...>& b, ROBIN_HOOD_STD::index_sequence<I1...> /*unused*/, ROBIN_HOOD_STD::index_sequence<I2...> /*unused*/) noexcept(\n+        noexcept(T1(std::forward<U1>(std::get<I1>(\n+            std::declval<std::tuple<\n+                U1...>&>()))...)) && noexcept(T2(std::\n+                                                     forward<U2>(std::get<I2>(\n+                                                         std::declval<std::tuple<U2...>&>()))...)))\n+        : first(std::forward<U1>(std::get<I1>(a))...)\n+        , second(std::forward<U2>(std::get<I2>(b))...) {\n+        // make visual studio compiler happy about warning about unused a & b.\n+        // Visual studio's pair implementation disables warning 4100.\n+        (void)a;\n+        (void)b;\n+    }\n+\n+    void swap(pair<T1, T2>& o) noexcept((detail::swappable::nothrow<T1>::value) &&\n+                                        (detail::swappable::nothrow<T2>::value)) {\n+        using std::swap;\n+        swap(first, o.first);\n+        swap(second, o.second);\n+    }\n+\n+    T1 first;  // NOLINT(misc-non-private-member-variables-in-classes)\n+    T2 second; // NOLINT(misc-non-private-member-variables-in-classes)\n+};\n+\n+template <typename A, typename B>\n+inline void swap(pair<A, B>& a, pair<A, B>& b) noexcept(\n+    noexcept(std::declval<pair<A, B>&>().swap(std::declval<pair<A, B>&>()))) {\n+    a.swap(b);\n+}\n+\n+template <typename A, typename B>\n+inline constexpr bool operator==(pair<A, B> const& x, pair<A, B> const& y) {\n+    return (x.first == y.first) && (x.second == y.second);\n+}\n+template <typename A, typename B>\n+inline constexpr bool operator!=(pair<A, B> const& x, pair<A, B> const& y) {\n+    return !(x == y);\n+}\n+template <typename A, typename B>\n+inline constexpr bool operator<(pair<A, B> const& x, pair<A, B> const& y) noexcept(noexcept(\n+    std::declval<A const&>() < std::declval<A const&>()) && noexcept(std::declval<B const&>() <\n+                                                                     std::declval<B const&>())) {\n+    return x.first < y.first || (!(y.first < x.first) && x.second < y.second);\n+}\n+template <typename A, typename B>\n+inline constexpr bool operator>(pair<A, B> const& x, pair<A, B> const& y) {\n+    return y < x;\n+}\n+template <typename A, typename B>\n+inline constexpr bool operator<=(pair<A, B> const& x, pair<A, B> const& y) {\n+    return !(x > y);\n+}\n+template <typename A, typename B>\n+inline constexpr bool operator>=(pair<A, B> const& x, pair<A, B> const& y) {\n+    return !(x < y);\n+}\n+\n+inline size_t hash_bytes(void const* ptr, size_t len) noexcept {\n+    static constexpr uint64_t m = UINT64_C(0xc6a4a7935bd1e995);\n+    static constexpr uint64_t seed = UINT64_C(0xe17a1465);\n+    static constexpr unsigned int r = 47;\n+\n+    auto const* const data64 = static_cast<uint64_t const*>(ptr);\n+    uint64_t h = seed ^ (len * m);\n+\n+    size_t const n_blocks = len / 8;\n+    for (size_t i = 0; i < n_blocks; ++i) {\n+        auto k = detail::unaligned_load<uint64_t>(data64 + i);\n+\n+        k *= m;\n+        k ^= k >> r;\n+        k *= m;\n+\n+        h ^= k;\n+        h *= m;\n+    }\n+\n+    auto const* const data8 = reinterpret_cast<uint8_t const*>(data64 + n_blocks);\n+    switch (len & 7U) {\n+    case 7:\n+        h ^= static_cast<uint64_t>(data8[6]) << 48U;\n+        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n+    case 6:\n+        h ^= static_cast<uint64_t>(data8[5]) << 40U;\n+        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n+    case 5:\n+        h ^= static_cast<uint64_t>(data8[4]) << 32U;\n+        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n+    case 4:\n+        h ^= static_cast<uint64_t>(data8[3]) << 24U;\n+        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n+    case 3:\n+        h ^= static_cast<uint64_t>(data8[2]) << 16U;\n+        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n+    case 2:\n+        h ^= static_cast<uint64_t>(data8[1]) << 8U;\n+        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n+    case 1:\n+        h ^= static_cast<uint64_t>(data8[0]);\n+        h *= m;\n+        ROBIN_HOOD(FALLTHROUGH); // FALLTHROUGH\n+    default:\n+        break;\n+    }\n+\n+    h ^= h >> r;\n+\n+    // not doing the final step here, because this will be done by keyToIdx anyways\n+    // h *= m;\n+    // h ^= h >> r;\n+    return static_cast<size_t>(h);\n+}\n+\n+inline size_t hash_int(uint64_t x) noexcept {\n+    // tried lots of different hashes, let's stick with murmurhash3. It's simple, fast, well tested,\n+    // and doesn't need any special 128bit operations.\n+    x ^= x >> 33U;\n+    x *= UINT64_C(0xff51afd7ed558ccd);\n+    x ^= x >> 33U;\n+\n+    // not doing the final step here, because this will be done by keyToIdx anyways\n+    // x *= UINT64_C(0xc4ceb9fe1a85ec53);\n+    // x ^= x >> 33U;\n+    return static_cast<size_t>(x);\n+}\n+\n+// A thin wrapper around std::hash, performing an additional simple mixing step of the result.\n+template <typename T, typename Enable = void>\n+struct hash : public std::hash<T> {\n+    size_t operator()(T const& obj) const\n+        noexcept(noexcept(std::declval<std::hash<T>>().operator()(std::declval<T const&>()))) {\n+        // call base hash\n+        auto result = std::hash<T>::operator()(obj);\n+        // return mixed of that, to be save against identity has\n+        return hash_int(static_cast<detail::SizeT>(result));\n+    }\n+};\n+\n+template <typename CharT>\n+struct hash<std::basic_string<CharT>> {\n+    size_t operator()(std::basic_string<CharT> const& str) const noexcept {\n+        return hash_bytes(str.data(), sizeof(CharT) * str.size());\n+    }\n+};\n+\n+#if ROBIN_HOOD(CXX) >= ROBIN_HOOD(CXX17)\n+template <typename CharT>\n+struct hash<std::basic_string_view<CharT>> {\n+    size_t operator()(std::basic_string_view<CharT> const& sv) const noexcept {\n+        return hash_bytes(sv.data(), sizeof(CharT) * sv.size());\n+    }\n+};\n+#endif\n+\n+template <class T>\n+struct hash<T*> {\n+    size_t operator()(T* ptr) const noexcept {\n+        return hash_int(reinterpret_cast<detail::SizeT>(ptr));\n+    }\n+};\n+\n+template <class T>\n+struct hash<std::unique_ptr<T>> {\n+    size_t operator()(std::unique_ptr<T> const& ptr) const noexcept {\n+        return hash_int(reinterpret_cast<detail::SizeT>(ptr.get()));\n+    }\n+};\n+\n+template <class T>\n+struct hash<std::shared_ptr<T>> {\n+    size_t operator()(std::shared_ptr<T> const& ptr) const noexcept {\n+        return hash_int(reinterpret_cast<detail::SizeT>(ptr.get()));\n+    }\n+};\n+\n+template <typename Enum>\n+struct hash<Enum, typename std::enable_if<std::is_enum<Enum>::value>::type> {\n+    size_t operator()(Enum e) const noexcept {\n+        using Underlying = typename std::underlying_type<Enum>::type;\n+        return hash<Underlying>{}(static_cast<Underlying>(e));\n+    }\n+};\n+\n+#define ROBIN_HOOD_HASH_INT(T)                           \\\n+    template <>                                          \\\n+    struct hash<T> {                                     \\\n+        size_t operator()(T const& obj) const noexcept { \\\n+            return hash_int(static_cast<uint64_t>(obj)); \\\n+        }                                                \\\n+    }\n+\n+#if defined(__GNUC__) && !defined(__clang__)\n+#    pragma GCC diagnostic push\n+#    pragma GCC diagnostic ignored \"-Wuseless-cast\"\n+#endif\n+// see https://en.cppreference.com/w/cpp/utility/hash\n+ROBIN_HOOD_HASH_INT(bool);\n+ROBIN_HOOD_HASH_INT(char);\n+ROBIN_HOOD_HASH_INT(signed char);\n+ROBIN_HOOD_HASH_INT(unsigned char);\n+ROBIN_HOOD_HASH_INT(char16_t);\n+ROBIN_HOOD_HASH_INT(char32_t);\n+#if ROBIN_HOOD(HAS_NATIVE_WCHART)\n+ROBIN_HOOD_HASH_INT(wchar_t);\n+#endif\n+ROBIN_HOOD_HASH_INT(short);\n+ROBIN_HOOD_HASH_INT(unsigned short);\n+ROBIN_HOOD_HASH_INT(int);\n+ROBIN_HOOD_HASH_INT(unsigned int);\n+ROBIN_HOOD_HASH_INT(long);\n+ROBIN_HOOD_HASH_INT(long long);\n+ROBIN_HOOD_HASH_INT(unsigned long);\n+ROBIN_HOOD_HASH_INT(unsigned long long);\n+#if defined(__GNUC__) && !defined(__clang__)\n+#    pragma GCC diagnostic pop\n+#endif\n namespace detail {\n \n+template <typename T>\n+struct void_type {\n+    using type = void;\n+};\n+\n+template <typename T, typename = void>\n+struct has_is_transparent : public std::false_type {};\n+\n+template <typename T>\n+struct has_is_transparent<T, typename void_type<typename T::is_transparent>::type>\n+    : public std::true_type {};\n+\n+// using wrapper classes for hash and key_equal prevents the diamond problem when the same type\n+// is used. see https://stackoverflow.com/a/28771920/48181\n+template <typename T>\n+struct WrapHash : public T {\n+    WrapHash() = default;\n+    explicit WrapHash(T const& o) noexcept(noexcept(T(std::declval<T const&>())))\n+        : T(o) {}\n+};\n+\n+template <typename T>\n+struct WrapKeyEqual : public T {\n+    WrapKeyEqual() = default;\n+    explicit WrapKeyEqual(T const& o) noexcept(noexcept(T(std::declval<T const&>())))\n+        : T(o) {}\n+};\n+\n // A highly optimized hashmap implementation, using the Robin Hood algorithm.\n //\n-// In most cases, this map should be usable as a drop-in replacement for std::unordered_map, but be\n-// about 2x faster in most cases and require much less allocations.\n+// In most cases, this map should be usable as a drop-in replacement for std::unordered_map, but\n+// be about 2x faster in most cases and require much less allocations.\n //\n // This implementation uses the following memory layout:\n //\n // [Node, Node, ... Node | info, info, ... infoSentinel ]\n //\n // * Node: either a DataNode that directly has the std::pair<key, val> as member,\n //   or a DataNode with a pointer to std::pair<key,val>. Which DataNode representation to use\n-//   depends on how fast the swap() operation is. Heuristically, this is automatically choosen based\n-//   on sizeof(). there are always 2^n Nodes.\n+//   depends on how fast the swap() operation is. Heuristically, this is automatically choosen\n+//   based on sizeof(). there are always 2^n Nodes.\n //\n // * info: Each Node in the map has a corresponding info byte, so there are 2^n info bytes.\n //   Each byte is initialized to 0, meaning the corresponding Node is empty. Set to 1 means the\n //   corresponding node contains data. Set to 2 means the corresponding Node is filled, but it\n //   actually belongs to the previous position and was pushed out because that place is already\n //   taken.\n //\n-// * infoSentinel: Sentinel byte set to 1, so that iterator's ++ can stop at end() without the need\n-// for a idx\n-//   variable.\n+// * infoSentinel: Sentinel byte set to 1, so that iterator's ++ can stop at end() without the\n+//   need for a idx variable.\n //\n-// According to STL, order of templates has effect on throughput. That's why I've moved the boolean\n-// to the front.\n+// According to STL, order of templates has effect on throughput. That's why I've moved the\n+// boolean to the front.\n // https://www.reddit.com/r/cpp/comments/ahp6iu/compile_time_binary_size_reductions_and_cs_future/eeguck4/\n-template <size_t MaxLoadFactor100, typename Key, typename T, typename Hash,\n+template <bool IsFlat, size_t MaxLoadFactor100, typename Key, typename T, typename Hash,\n           typename KeyEqual>\n-class unordered_map\n-    : public Hash,\n-      public KeyEqual,\n-      detail::BulkPoolAllocator<std::pair<Key const, T>, 4, 16384> {\n+class Table\n+    : public WrapHash<Hash>,\n+      public WrapKeyEqual<KeyEqual>,\n+      detail::NodeAllocator<\n+          typename std::conditional<\n+              std::is_void<T>::value, Key,\n+              robin_hood::pair<typename std::conditional<IsFlat, Key, Key const>::type, T>>::type,\n+          4, 16384, IsFlat> {\n public:\n+    static constexpr bool is_flat = IsFlat;\n+    static constexpr bool is_map = !std::is_void<T>::value;\n+    static constexpr bool is_set = !is_map;\n+    static constexpr bool is_transparent =\n+        has_is_transparent<Hash>::value && has_is_transparent<KeyEqual>::value;\n+\n     using key_type = Key;\n     using mapped_type = T;\n-    using value_type = std::pair<Key const, T>;\n+    using value_type = typename std::conditional<\n+        is_set, Key,\n+        robin_hood::pair<typename std::conditional<is_flat, Key, Key const>::type, T>>::type;\n     using size_type = size_t;\n     using hasher = Hash;\n     using key_equal = KeyEqual;\n-    using Self =\n-        unordered_map<MaxLoadFactor100, key_type, mapped_type, hasher, key_equal>;\n+    using Self = Table<IsFlat, MaxLoadFactor100, key_type, mapped_type, hasher, key_equal>;\n \n private:\n     static_assert(MaxLoadFactor100 > 10 && MaxLoadFactor100 < 100,\n                   \"MaxLoadFactor100 needs to be >10 && < 100\");\n \n+    using WHash = WrapHash<Hash>;\n+    using WKeyEqual = WrapKeyEqual<KeyEqual>;\n+\n     // configuration defaults\n \n     // make sure we have 8 elements, needed to quickly rehash mInfo\n     static constexpr size_t InitialNumElements = sizeof(uint64_t);\n     static constexpr uint32_t InitialInfoNumBits = 5;\n     static constexpr uint8_t InitialInfoInc = 1U << InitialInfoNumBits;\n-    static constexpr uint8_t InitialInfoHashShift = sizeof(size_t) * 8 - InitialInfoNumBits;\n-    using DataPool = detail::BulkPoolAllocator<value_type, 4, 16384>;\n+    static constexpr size_t InfoMask = InitialInfoInc - 1U;\n+    static constexpr uint8_t InitialInfoHashShift = 0;\n+    using DataPool = detail::NodeAllocator<value_type, 4, 16384, IsFlat>;\n \n     // type needs to be wider than uint8_t.\n-    //\n-    // TODO(jamesob): why? advertised as a byte?\n     using InfoType = uint32_t;\n \n     // DataNode ////////////////////////////////////////////////////////\n \n     // Primary template for the data node. We have special implementations for small and big\n-    // objects. For large objects it is assumed that swap() is fairly slow, so we allocate these on\n-    // the heap so swap merely swaps a pointer.\n+    // objects. For large objects it is assumed that swap() is fairly slow, so we allocate these\n+    // on the heap so swap merely swaps a pointer.\n     template <typename M, bool>\n     class DataNode {};\n \n+    // Small: just allocate on the stack.\n+    template <typename M>\n+    class DataNode<M, true> final {\n+    public:\n+        template <typename... Args>\n+        explicit DataNode(M& ROBIN_HOOD_UNUSED(map) /*unused*/, Args&&... args) noexcept(\n+            noexcept(value_type(std::forward<Args>(args)...)))\n+            : mData(std::forward<Args>(args)...) {}\n+\n+        DataNode(M& ROBIN_HOOD_UNUSED(map) /*unused*/, DataNode<M, true>&& n) noexcept(\n+            std::is_nothrow_move_constructible<value_type>::value)\n+            : mData(std::move(n.mData)) {}\n+\n+        // doesn't do anything\n+        void destroy(M& ROBIN_HOOD_UNUSED(map) /*unused*/) noexcept {}\n+        void destroyDoNotDeallocate() noexcept {}\n+\n+        value_type const* operator->() const noexcept {\n+            return &mData;\n+        }\n+        value_type* operator->() noexcept {\n+            return &mData;\n+        }\n+\n+        const value_type& operator*() const noexcept {\n+            return mData;\n+        }\n+\n+        value_type& operator*() noexcept {\n+            return mData;\n+        }\n+\n+        template <typename VT = value_type>\n+        ROBIN_HOOD(NODISCARD)\n+        typename std::enable_if<is_map, typename VT::first_type&>::type getFirst() noexcept {\n+            return mData.first;\n+        }\n+        template <typename VT = value_type>\n+        ROBIN_HOOD(NODISCARD)\n+        typename std::enable_if<is_set, VT&>::type getFirst() noexcept {\n+            return mData;\n+        }\n+\n+        template <typename VT = value_type>\n+        ROBIN_HOOD(NODISCARD)\n+        typename std::enable_if<is_map, typename VT::first_type const&>::type\n+            getFirst() const noexcept {\n+            return mData.first;\n+        }\n+        template <typename VT = value_type>\n+        ROBIN_HOOD(NODISCARD)\n+        typename std::enable_if<is_set, VT const&>::type getFirst() const noexcept {\n+            return mData;\n+        }\n+\n+        template <typename MT = mapped_type>\n+        ROBIN_HOOD(NODISCARD)\n+        typename std::enable_if<is_map, MT&>::type getSecond() noexcept {\n+            return mData.second;\n+        }\n+\n+        template <typename MT = mapped_type>\n+        ROBIN_HOOD(NODISCARD)\n+        typename std::enable_if<is_set, MT const&>::type getSecond() const noexcept {\n+            return mData.second;\n+        }\n+\n+        void swap(DataNode<M, true>& o) noexcept(\n+            noexcept(std::declval<value_type>().swap(std::declval<value_type>()))) {\n+            mData.swap(o.mData);\n+        }\n+\n+    private:\n+        value_type mData;\n+    };\n+\n     // big object: allocate on heap.\n     template <typename M>\n     class DataNode<M, false> {\n@@ -576,19 +1074,38 @@ class unordered_map\n             return *mData;\n         }\n \n-        ROBIN_HOOD(NODISCARD) typename value_type::first_type& getFirst() {\n+        template <typename VT = value_type>\n+        ROBIN_HOOD(NODISCARD)\n+        typename std::enable_if<is_map, typename VT::first_type&>::type getFirst() noexcept {\n             return mData->first;\n         }\n+        template <typename VT = value_type>\n+        ROBIN_HOOD(NODISCARD)\n+        typename std::enable_if<is_set, VT&>::type getFirst() noexcept {\n+            return *mData;\n+        }\n \n-        ROBIN_HOOD(NODISCARD) typename value_type::first_type const& getFirst() const {\n+        template <typename VT = value_type>\n+        ROBIN_HOOD(NODISCARD)\n+        typename std::enable_if<is_map, typename VT::first_type const&>::type\n+            getFirst() const noexcept {\n             return mData->first;\n         }\n+        template <typename VT = value_type>\n+        ROBIN_HOOD(NODISCARD)\n+        typename std::enable_if<is_set, VT const&>::type getFirst() const noexcept {\n+            return *mData;\n+        }\n \n-        ROBIN_HOOD(NODISCARD) typename value_type::second_type& getSecond() {\n+        template <typename MT = mapped_type>\n+        ROBIN_HOOD(NODISCARD)\n+        typename std::enable_if<is_map, MT&>::type getSecond() noexcept {\n             return mData->second;\n         }\n \n-        ROBIN_HOOD(NODISCARD) typename value_type::second_type const& getSecond() const {\n+        template <typename MT = mapped_type>\n+        ROBIN_HOOD(NODISCARD)\n+        typename std::enable_if<is_map, MT const&>::type getSecond() const noexcept {\n             return mData->second;\n         }\n \n@@ -601,19 +1118,50 @@ class unordered_map\n         value_type* mData;\n     };\n \n-    using Node = DataNode<Self, false>;\n+    using Node = DataNode<Self, IsFlat>;\n+\n+    // helpers for insertKeyPrepareEmptySpot: extract first entry (only const required)\n+    ROBIN_HOOD(NODISCARD) key_type const& getFirstConst(Node const& n) const noexcept {\n+        return n.getFirst();\n+    }\n+\n+    // in case we have void mapped_type, we are not using a pair, thus we just route k through.\n+    // No need to disable this because it's just not used if not applicable.\n+    ROBIN_HOOD(NODISCARD) key_type const& getFirstConst(key_type const& k) const noexcept {\n+        return k;\n+    }\n+\n+    // in case we have non-void mapped_type, we have a standard robin_hood::pair\n+    template <typename Q = mapped_type>\n+    ROBIN_HOOD(NODISCARD)\n+    typename std::enable_if<!std::is_void<Q>::value, key_type const&>::type\n+        getFirstConst(value_type const& vt) const noexcept {\n+        return vt.first;\n+    }\n \n     // Cloner //////////////////////////////////////////////////////////\n \n     template <typename M, bool UseMemcpy>\n     struct Cloner;\n \n+    // fast path: Just copy data, without allocating anything.\n+    template <typename M>\n+    struct Cloner<M, true> {\n+        void operator()(M const& source, M& target) const {\n+            auto const* const src = reinterpret_cast<char const*>(source.mKeyVals);\n+            auto* tgt = reinterpret_cast<char*>(target.mKeyVals);\n+            auto const numElementsWithBuffer = target.calcNumElementsWithBuffer(target.mMask + 1);\n+            std::copy(src, src + target.calcNumBytesTotal(numElementsWithBuffer), tgt);\n+        }\n+    };\n+\n     template <typename M>\n     struct Cloner<M, false> {\n         void operator()(M const& s, M& t) const {\n-            std::copy(s.mInfo, s.mInfo + t.calcNumBytesInfo(t.mMask + 1), t.mInfo);\n+            auto const numElementsWithBuffer = t.calcNumElementsWithBuffer(t.mMask + 1);\n+            std::copy(s.mInfo, s.mInfo + t.calcNumBytesInfo(numElementsWithBuffer), t.mInfo);\n \n-            for (size_t i = 0; i < t.mMask + 1; ++i) {\n+            for (size_t i = 0; i < numElementsWithBuffer; ++i) {\n                 if (t.mInfo[i]) {\n                     ::new (static_cast<void*>(t.mKeyVals + i)) Node(t, *s.mKeyVals[i]);\n                 }\n@@ -623,15 +1171,28 @@ class unordered_map\n \n     // Destroyer ///////////////////////////////////////////////////////\n \n-    template <typename M, bool IsFlatMapAndTrivial>\n+    template <typename M, bool IsFlatAndTrivial>\n     struct Destroyer {};\n \n+    template <typename M>\n+    struct Destroyer<M, true> {\n+        void nodes(M& m) const noexcept {\n+            m.mNumElements = 0;\n+        }\n+\n+        void nodesDoNotDeallocate(M& m) const noexcept {\n+            m.mNumElements = 0;\n+        }\n+    };\n+\n     template <typename M>\n     struct Destroyer<M, false> {\n         void nodes(M& m) const noexcept {\n             m.mNumElements = 0;\n             // clear also resets mInfo to 0, that's sometimes not necessary.\n-            for (size_t idx = 0; idx <= m.mMask; ++idx) {\n+            auto const numElementsWithBuffer = m.calcNumElementsWithBuffer(m.mMask + 1);\n+\n+            for (size_t idx = 0; idx < numElementsWithBuffer; ++idx) {\n                 if (0 != m.mInfo[idx]) {\n                     Node& n = m.mKeyVals[idx];\n                     n.destroy(m);\n@@ -643,7 +1204,8 @@ class unordered_map\n         void nodesDoNotDeallocate(M& m) const noexcept {\n             m.mNumElements = 0;\n             // clear also resets mInfo to 0, that's sometimes not necessary.\n-            for (size_t idx = 0; idx <= m.mMask; ++idx) {\n+            auto const numElementsWithBuffer = m.calcNumElementsWithBuffer(m.mMask + 1);\n+            for (size_t idx = 0; idx < numElementsWithBuffer; ++idx) {\n                 if (0 != m.mInfo[idx]) {\n                     Node& n = m.mKeyVals[idx];\n                     n.destroyDoNotDeallocate();\n@@ -675,8 +1237,8 @@ class unordered_map\n         // compared to end().\n         Iter() = default;\n \n-        // Rule of zero: nothing specified. The conversion constructor is only enabled for iterator\n-        // to const_iterator, so it doesn't accidentally work as a copy ctor.\n+        // Rule of zero: nothing specified. The conversion constructor is only enabled for\n+        // iterator to const_iterator, so it doesn't accidentally work as a copy ctor.\n \n         // Conversion constructor from iterator to const_iterator.\n         template <bool OtherIsConst,\n@@ -713,6 +1275,12 @@ class unordered_map\n             return *this;\n         }\n \n+        Iter operator++(int) noexcept {\n+            Iter tmp = *this;\n+            ++(*this);\n+            return tmp;\n+        }\n+\n         reference operator*() const {\n             return **mKeyVals;\n         }\n@@ -733,21 +1301,40 @@ class unordered_map\n \n     private:\n         // fast forward to the next non-free info byte\n+        // I've tried a few variants that don't depend on intrinsics, but unfortunately they are\n+        // quite a bit slower than this one. So I've reverted that change again. See map_benchmark.\n         void fastForward() noexcept {\n-            int inc;\n-            do {\n-                auto const n = detail::unaligned_load<size_t>(mInfo);\n-#if ROBIN_HOOD(LITTLE_ENDIAN)\n-                inc = ROBIN_HOOD_COUNT_TRAILING_ZEROES(n) / 8;\n+            size_t n = 0;\n+            while (0U == (n = detail::unaligned_load<size_t>(mInfo))) {\n+                mInfo += sizeof(size_t);\n+                mKeyVals += sizeof(size_t);\n+            }\n+#if defined(ROBIN_HOOD_DISABLE_INTRINSICS)\n+            // we know for certain that within the next 8 bytes we'll find a non-zero one.\n+            if (ROBIN_HOOD_UNLIKELY(0U == detail::unaligned_load<uint32_t>(mInfo))) {\n+                mInfo += 4;\n+                mKeyVals += 4;\n+            }\n+            if (ROBIN_HOOD_UNLIKELY(0U == detail::unaligned_load<uint16_t>(mInfo))) {\n+                mInfo += 2;\n+                mKeyVals += 2;\n+            }\n+            if (ROBIN_HOOD_UNLIKELY(0U == *mInfo)) {\n+                mInfo += 1;\n+                mKeyVals += 1;\n+            }\n #else\n-                inc = ROBIN_HOOD_COUNT_LEADING_ZEROES(n) / 8;\n+#    if ROBIN_HOOD(LITTLE_ENDIAN)\n+            auto inc = ROBIN_HOOD_COUNT_TRAILING_ZEROES(n) / 8;\n+#    else\n+            auto inc = ROBIN_HOOD_COUNT_LEADING_ZEROES(n) / 8;\n+#    endif\n+            mInfo += inc;\n+            mKeyVals += inc;\n #endif\n-                mInfo += inc;\n-                mKeyVals += inc;\n-            } while (inc == static_cast<int>(sizeof(size_t)));\n         }\n \n-        friend class unordered_map<MaxLoadFactor100, key_type, mapped_type, hasher, key_equal>;\n+        friend class Table<IsFlat, MaxLoadFactor100, key_type, mapped_type, hasher, key_equal>;\n         NodePtr mKeyVals{nullptr};\n         uint8_t const* mInfo{nullptr};\n     };\n@@ -759,14 +1346,22 @@ class unordered_map\n     // The upper 1-5 bits need to be a reasonable good hash, to save comparisons.\n     template <typename HashKey>\n     void keyToIdx(HashKey&& key, size_t* idx, InfoType* info) const {\n-        *idx = Hash::operator()(key);\n-        *info = mInfoInc + static_cast<InfoType>(*idx >> mInfoHashShift);\n-        *idx &= mMask;\n+        // In addition to whatever hash is used, add another mul & shift so we get better hashing.\n+        // This serves as a bad hash prevention, if the given data is\n+        // badly mixed.\n+        auto h = static_cast<uint64_t>(WHash::operator()(key));\n+\n+        h *= mHashMultiplier;\n+        h ^= h >> 33U;\n+\n+        // the lower InitialInfoNumBits are reserved for info.\n+        *info = mInfoInc + static_cast<InfoType>((h & InfoMask) >> mInfoHashShift);\n+        *idx = (static_cast<size_t>(h) >> InitialInfoNumBits) & mMask;\n     }\n \n     // forwards the index by one, wrapping around at the end\n     void next(InfoType* info, size_t* idx) const noexcept {\n-        *idx = (*idx + 1) & mMask;\n+        *idx = *idx + 1;\n         *info += mInfoInc;\n     }\n \n@@ -778,38 +1373,38 @@ class unordered_map\n     }\n \n     // Shift everything up by one element. Tries to move stuff around.\n-    // True if some shifting has occured (entry under idx is a constructed object)\n-    // Fals if no shift has occured (entry under idx is unconstructed memory)\n     void\n-    shiftUp(size_t idx,\n+    shiftUp(size_t startIdx,\n             size_t const insertion_idx) noexcept(std::is_nothrow_move_assignable<Node>::value) {\n+        auto idx = startIdx;\n+        ::new (static_cast<void*>(mKeyVals + idx)) Node(std::move(mKeyVals[idx - 1]));\n+        while (--idx != insertion_idx) {\n+            mKeyVals[idx] = std::move(mKeyVals[idx - 1]);\n+        }\n+\n+        idx = startIdx;\n         while (idx != insertion_idx) {\n-            size_t prev_idx = (idx - 1) & mMask;\n-            if (mInfo[idx]) {\n-                mKeyVals[idx] = std::move(mKeyVals[prev_idx]);\n-            } else {\n-                ::new (static_cast<void*>(mKeyVals + idx)) Node(std::move(mKeyVals[prev_idx]));\n-            }\n-            mInfo[idx] = static_cast<uint8_t>(mInfo[prev_idx] + mInfoInc);\n+            ROBIN_HOOD_COUNT(shiftUp)\n+            mInfo[idx] = static_cast<uint8_t>(mInfo[idx - 1] + mInfoInc);\n             if (ROBIN_HOOD_UNLIKELY(mInfo[idx] + mInfoInc > 0xFF)) {\n                 mMaxNumElementsAllowed = 0;\n             }\n-            idx = prev_idx;\n+            --idx;\n         }\n     }\n \n     void shiftDown(size_t idx) noexcept(std::is_nothrow_move_assignable<Node>::value) {\n         // until we find one that is either empty or has zero offset.\n-        // TODO(martinus) we don't need to move everything, just the last one for the same bucket.\n+        // TODO(martinus) we don't need to move everything, just the last one for the same\n+        // bucket.\n         mKeyVals[idx].destroy(*this);\n \n         // until we find one that is either empty or has zero offset.\n-        size_t nextIdx = (idx + 1) & mMask;\n-        while (mInfo[nextIdx] >= 2 * mInfoInc) {\n-            mInfo[idx] = static_cast<uint8_t>(mInfo[nextIdx] - mInfoInc);\n-            mKeyVals[idx] = std::move(mKeyVals[nextIdx]);\n-            idx = nextIdx;\n-            nextIdx = (idx + 1) & mMask;\n+        while (mInfo[idx + 1] >= 2 * mInfoInc) {\n+            ROBIN_HOOD_COUNT(shiftDown)\n+            mInfo[idx] = static_cast<uint8_t>(mInfo[idx + 1] - mInfoInc);\n+            mKeyVals[idx] = std::move(mKeyVals[idx + 1]);\n+            ++idx;\n         }\n \n         mInfo[idx] = 0;\n@@ -822,46 +1417,50 @@ class unordered_map\n     template <typename Other>\n     ROBIN_HOOD(NODISCARD)\n     size_t findIdx(Other const& key) const {\n-        size_t idx;\n-        InfoType info;\n+        size_t idx{};\n+        InfoType info{};\n         keyToIdx(key, &idx, &info);\n \n         do {\n             // unrolling this twice gives a bit of a speedup. More unrolling did not help.\n-            if (info == mInfo[idx] && KeyEqual::operator()(key, mKeyVals[idx].getFirst())) {\n+            if (info == mInfo[idx] &&\n+                ROBIN_HOOD_LIKELY(WKeyEqual::operator()(key, mKeyVals[idx].getFirst()))) {\n                 return idx;\n             }\n             next(&info, &idx);\n-            if (info == mInfo[idx] && KeyEqual::operator()(key, mKeyVals[idx].getFirst())) {\n+            if (info == mInfo[idx] &&\n+                ROBIN_HOOD_LIKELY(WKeyEqual::operator()(key, mKeyVals[idx].getFirst()))) {\n                 return idx;\n             }\n             next(&info, &idx);\n         } while (info <= mInfo[idx]);\n \n         // nothing found!\n-        return mMask == 0 ? 0 : mMask + 1;\n+        return mMask == 0 ? 0\n+                          : static_cast<size_t>(std::distance(\n+                                mKeyVals, reinterpret_cast_no_cast_align_warning<Node*>(mInfo)));\n     }\n \n-    void cloneData(const unordered_map& o) {\n-        Cloner<unordered_map, false>()(o, *this);\n+    void cloneData(const Table& o) {\n+        Cloner<Table, IsFlat && ROBIN_HOOD_IS_TRIVIALLY_COPYABLE(Node)>()(o, *this);\n     }\n \n     // inserts a keyval that is guaranteed to be new, e.g. when the hashmap is resized.\n-    // @return index where the element was created\n-    size_t insert_move(Node&& keyval) {\n+    // @return True on success, false if something went wrong\n+    void insert_move(Node&& keyval) {\n         // we don't retry, fail if overflowing\n         // don't need to check max num elements\n         if (0 == mMaxNumElementsAllowed && !try_increase_info()) {\n             throwOverflowError();\n         }\n \n-        size_t idx;\n-        InfoType info;\n+        size_t idx{};\n+        InfoType info{};\n         keyToIdx(keyval.getFirst(), &idx, &info);\n \n         // skip forward. Use <= because we are certain that the element is not there.\n         while (info <= mInfo[idx]) {\n-            idx = (idx + 1) & mMask;\n+            idx = idx + 1;\n             info += mInfoInc;\n         }\n \n@@ -889,107 +1488,294 @@ class unordered_map\n         mInfo[insertion_idx] = insertion_info;\n \n         ++mNumElements;\n-        return insertion_idx;\n     }\n \n public:\n     using iterator = Iter<false>;\n     using const_iterator = Iter<true>;\n \n-    // Creates an empty hash map. Nothing is allocated yet, this happens at the first insert. This\n-    // tremendously speeds up ctor & dtor of a map that never receives an element. The penalty is\n-    // payed at the first insert, and not before. Lookup of this empty map works because everybody\n-    // points to DummyInfoByte::b. parameter bucket_count is dictated by the standard, but we can\n-    // ignore it.\n-    explicit unordered_map(size_t ROBIN_HOOD_UNUSED(bucket_count) /*unused*/ = 0,\n-                           const Hash& h = Hash{},\n-                           const KeyEqual& equal = KeyEqual{}) noexcept(noexcept(Hash(h)) &&\n-                                                                        noexcept(KeyEqual(equal)))\n-        : Hash(h)\n-        , KeyEqual(equal) {\n-        ROBIN_HOOD_TRACE(this);\n+    Table() noexcept(noexcept(Hash()) && noexcept(KeyEqual()))\n+        : WHash()\n+        , WKeyEqual() {\n+        ROBIN_HOOD_TRACE(this)\n+    }\n+\n+    // Creates an empty hash map. Nothing is allocated yet, this happens at the first insert.\n+    // This tremendously speeds up ctor & dtor of a map that never receives an element. The\n+    // penalty is payed at the first insert, and not before. Lookup of this empty map works\n+    // because everybody points to DummyInfoByte::b. parameter bucket_count is dictated by the\n+    // standard, but we can ignore it.\n+    explicit Table(\n+        size_t ROBIN_HOOD_UNUSED(bucket_count) /*unused*/, const Hash& h = Hash{},\n+        const KeyEqual& equal = KeyEqual{}) noexcept(noexcept(Hash(h)) && noexcept(KeyEqual(equal)))\n+        : WHash(h)\n+        , WKeyEqual(equal) {\n+        ROBIN_HOOD_TRACE(this)\n     }\n \n     template <typename Iter>\n-    unordered_map(Iter first, Iter last, size_t ROBIN_HOOD_UNUSED(bucket_count) /*unused*/ = 0,\n-                  const Hash& h = Hash{}, const KeyEqual& equal = KeyEqual{})\n-        : Hash(h)\n-        , KeyEqual(equal) {\n-        ROBIN_HOOD_TRACE(this);\n+    Table(Iter first, Iter last, size_t ROBIN_HOOD_UNUSED(bucket_count) /*unused*/ = 0,\n+          const Hash& h = Hash{}, const KeyEqual& equal = KeyEqual{})\n+        : WHash(h)\n+        , WKeyEqual(equal) {\n+        ROBIN_HOOD_TRACE(this)\n         insert(first, last);\n     }\n \n-    unordered_map(std::initializer_list<value_type> initlist,\n-                  size_t ROBIN_HOOD_UNUSED(bucket_count) /*unused*/ = 0, const Hash& h = Hash{},\n-                  const KeyEqual& equal = KeyEqual{})\n-        : Hash(h)\n-        , KeyEqual(equal) {\n-        ROBIN_HOOD_TRACE(this);\n+    Table(std::initializer_list<value_type> initlist,\n+          size_t ROBIN_HOOD_UNUSED(bucket_count) /*unused*/ = 0, const Hash& h = Hash{},\n+          const KeyEqual& equal = KeyEqual{})\n+        : WHash(h)\n+        , WKeyEqual(equal) {\n+        ROBIN_HOOD_TRACE(this)\n         insert(initlist.begin(), initlist.end());\n     }\n \n+    Table(Table&& o) noexcept\n+        : WHash(std::move(static_cast<WHash&>(o)))\n+        , WKeyEqual(std::move(static_cast<WKeyEqual&>(o)))\n+        , DataPool(std::move(static_cast<DataPool&>(o))) {\n+        ROBIN_HOOD_TRACE(this)\n+        if (o.mMask) {\n+            mHashMultiplier = std::move(o.mHashMultiplier);\n+            mKeyVals = std::move(o.mKeyVals);\n+            mInfo = std::move(o.mInfo);\n+            mNumElements = std::move(o.mNumElements);\n+            mMask = std::move(o.mMask);\n+            mMaxNumElementsAllowed = std::move(o.mMaxNumElementsAllowed);\n+            mInfoInc = std::move(o.mInfoInc);\n+            mInfoHashShift = std::move(o.mInfoHashShift);\n+            // set other's mask to 0 so its destructor won't do anything\n+            o.init();\n+        }\n+    }\n+\n+    Table& operator=(Table&& o) noexcept {\n+        ROBIN_HOOD_TRACE(this)\n+        if (&o != this) {\n+            if (o.mMask) {\n+                // only move stuff if the other map actually has some data\n+                destroy();\n+                mHashMultiplier = std::move(o.mHashMultiplier);\n+                mKeyVals = std::move(o.mKeyVals);\n+                mInfo = std::move(o.mInfo);\n+                mNumElements = std::move(o.mNumElements);\n+                mMask = std::move(o.mMask);\n+                mMaxNumElementsAllowed = std::move(o.mMaxNumElementsAllowed);\n+                mInfoInc = std::move(o.mInfoInc);\n+                mInfoHashShift = std::move(o.mInfoHashShift);\n+                WHash::operator=(std::move(static_cast<WHash&>(o)));\n+                WKeyEqual::operator=(std::move(static_cast<WKeyEqual&>(o)));\n+                DataPool::operator=(std::move(static_cast<DataPool&>(o)));\n+\n+                o.init();\n+\n+            } else {\n+                // nothing in the other map => just clear us.\n+                clear();\n+            }\n+        }\n+        return *this;\n+    }\n+\n+    Table(const Table& o)\n+        : WHash(static_cast<const WHash&>(o))\n+        , WKeyEqual(static_cast<const WKeyEqual&>(o))\n+        , DataPool(static_cast<const DataPool&>(o)) {\n+        ROBIN_HOOD_TRACE(this)\n+        if (!o.empty()) {\n+            // not empty: create an exact copy. it is also possible to just iterate through all\n+            // elements and insert them, but copying is probably faster.\n+\n+            auto const numElementsWithBuffer = calcNumElementsWithBuffer(o.mMask + 1);\n+            auto const numBytesTotal = calcNumBytesTotal(numElementsWithBuffer);\n+\n+            ROBIN_HOOD_LOG(\"std::malloc \" << numBytesTotal << \" = calcNumBytesTotal(\"\n+                                          << numElementsWithBuffer << \")\")\n+            mHashMultiplier = o.mHashMultiplier;\n+            mKeyVals = static_cast<Node*>(\n+                detail::assertNotNull<std::bad_alloc>(std::malloc(numBytesTotal)));\n+            // no need for calloc because clonData does memcpy\n+            mInfo = reinterpret_cast<uint8_t*>(mKeyVals + numElementsWithBuffer);\n+            mNumElements = o.mNumElements;\n+            mMask = o.mMask;\n+            mMaxNumElementsAllowed = o.mMaxNumElementsAllowed;\n+            mInfoInc = o.mInfoInc;\n+            mInfoHashShift = o.mInfoHashShift;\n+            cloneData(o);\n+        }\n+    }\n+\n+    // Creates a copy of the given map. Copy constructor of each entry is used.\n+    // Not sure why clang-tidy thinks this doesn't handle self assignment, it does\n+    // NOLINTNEXTLINE(bugprone-unhandled-self-assignment,cert-oop54-cpp)\n+    Table& operator=(Table const& o) {\n+        ROBIN_HOOD_TRACE(this)\n+        if (&o == this) {\n+            // prevent assigning of itself\n+            return *this;\n+        }\n+\n+        // we keep using the old allocator and not assign the new one, because we want to keep\n+        // the memory available. when it is the same size.\n+        if (o.empty()) {\n+            if (0 == mMask) {\n+                // nothing to do, we are empty too\n+                return *this;\n+            }\n+\n+            // not empty: destroy what we have there\n+            // clear also resets mInfo to 0, that's sometimes not necessary.\n+            destroy();\n+            init();\n+            WHash::operator=(static_cast<const WHash&>(o));\n+            WKeyEqual::operator=(static_cast<const WKeyEqual&>(o));\n+            DataPool::operator=(static_cast<DataPool const&>(o));\n+\n+            return *this;\n+        }\n+\n+        // clean up old stuff\n+        Destroyer<Self, IsFlat && std::is_trivially_destructible<Node>::value>{}.nodes(*this);\n+\n+        if (mMask != o.mMask) {\n+            // no luck: we don't have the same array size allocated, so we need to realloc.\n+            if (0 != mMask) {\n+                // only deallocate if we actually have data!\n+                ROBIN_HOOD_LOG(\"std::free\")\n+                std::free(mKeyVals);\n+            }\n+\n+            auto const numElementsWithBuffer = calcNumElementsWithBuffer(o.mMask + 1);\n+            auto const numBytesTotal = calcNumBytesTotal(numElementsWithBuffer);\n+            ROBIN_HOOD_LOG(\"std::malloc \" << numBytesTotal << \" = calcNumBytesTotal(\"\n+                                          << numElementsWithBuffer << \")\")\n+            mKeyVals = static_cast<Node*>(\n+                detail::assertNotNull<std::bad_alloc>(std::malloc(numBytesTotal)));\n+\n+            // no need for calloc here because cloneData performs a memcpy.\n+            mInfo = reinterpret_cast<uint8_t*>(mKeyVals + numElementsWithBuffer);\n+            // sentinel is set in cloneData\n+        }\n+        WHash::operator=(static_cast<const WHash&>(o));\n+        WKeyEqual::operator=(static_cast<const WKeyEqual&>(o));\n+        DataPool::operator=(static_cast<DataPool const&>(o));\n+        mHashMultiplier = o.mHashMultiplier;\n+        mNumElements = o.mNumElements;\n+        mMask = o.mMask;\n+        mMaxNumElementsAllowed = o.mMaxNumElementsAllowed;\n+        mInfoInc = o.mInfoInc;\n+        mInfoHashShift = o.mInfoHashShift;\n+        cloneData(o);\n+\n+        return *this;\n+    }\n+\n     // Swaps everything between the two maps.\n-    void swap(unordered_map& o) {\n-        ROBIN_HOOD_TRACE(this);\n+    void swap(Table& o) {\n+        ROBIN_HOOD_TRACE(this)\n         using std::swap;\n         swap(o, *this);\n     }\n \n     // Clears all data, without resizing.\n     void clear() {\n-        ROBIN_HOOD_TRACE(this);\n+        ROBIN_HOOD_TRACE(this)\n         if (empty()) {\n-            // don't do anything! also important because we don't want to write to DummyInfoByte::b,\n-            // even though we would just write 0 to it.\n+            // don't do anything! also important because we don't want to write to\n+            // DummyInfoByte::b, even though we would just write 0 to it.\n             return;\n         }\n \n-        Destroyer<Self, false>{}.nodes(*this);\n+        Destroyer<Self, IsFlat && std::is_trivially_destructible<Node>::value>{}.nodes(*this);\n \n-        // clear everything except the sentinel\n-        // std::memset(mInfo, 0, sizeof(uint8_t) * (mMask + 1));\n+        auto const numElementsWithBuffer = calcNumElementsWithBuffer(mMask + 1);\n+        // clear everything, then set the sentinel again\n         uint8_t const z = 0;\n-        std::fill(mInfo, mInfo + (sizeof(uint8_t) * (mMask + 1)), z);\n+        std::fill(mInfo, mInfo + calcNumBytesInfo(numElementsWithBuffer), z);\n+        mInfo[numElementsWithBuffer] = 1;\n \n         mInfoInc = InitialInfoInc;\n         mInfoHashShift = InitialInfoHashShift;\n     }\n \n     // Destroys the map and all it's contents.\n-    ~unordered_map() {\n-        ROBIN_HOOD_TRACE(this);\n+    ~Table() {\n+        ROBIN_HOOD_TRACE(this)\n         destroy();\n     }\n \n-    // Checks if both maps contain the same entries. Order is irrelevant.\n-    bool operator==(const unordered_map& other) const {\n-        ROBIN_HOOD_TRACE(this);\n+    // Checks if both tables contain the same entries. Order is irrelevant.\n+    bool operator==(const Table& other) const {\n+        ROBIN_HOOD_TRACE(this)\n         if (other.size() != size()) {\n             return false;\n         }\n         for (auto const& otherEntry : other) {\n-            auto const myIt = find(otherEntry.first);\n-            if (myIt == end() || !(myIt->second == otherEntry.second)) {\n+            if (!has(otherEntry)) {\n                 return false;\n             }\n         }\n \n         return true;\n     }\n \n-    bool operator!=(const unordered_map& other) const {\n-        ROBIN_HOOD_TRACE(this);\n+    bool operator!=(const Table& other) const {\n+        ROBIN_HOOD_TRACE(this)\n         return !operator==(other);\n     }\n \n-    mapped_type& operator[](const key_type& key) {\n-        ROBIN_HOOD_TRACE(this);\n-        return doCreateByKey(key);\n+    template <typename Q = mapped_type>\n+    typename std::enable_if<!std::is_void<Q>::value, Q&>::type operator[](const key_type& key) {\n+        ROBIN_HOOD_TRACE(this)\n+        auto idxAndState = insertKeyPrepareEmptySpot(key);\n+        switch (idxAndState.second) {\n+        case InsertionState::key_found:\n+            break;\n+\n+        case InsertionState::new_node:\n+            ::new (static_cast<void*>(&mKeyVals[idxAndState.first]))\n+                Node(*this, std::piecewise_construct, std::forward_as_tuple(key),\n+                     std::forward_as_tuple());\n+            break;\n+\n+        case InsertionState::overwrite_node:\n+            mKeyVals[idxAndState.first] = Node(*this, std::piecewise_construct,\n+                                               std::forward_as_tuple(key), std::forward_as_tuple());\n+            break;\n+\n+        case InsertionState::overflow_error:\n+            throwOverflowError();\n+        }\n+\n+        return mKeyVals[idxAndState.first].getSecond();\n     }\n \n-    mapped_type& operator[](key_type&& key) {\n-        ROBIN_HOOD_TRACE(this);\n-        return doCreateByKey(std::move(key));\n+    template <typename Q = mapped_type>\n+    typename std::enable_if<!std::is_void<Q>::value, Q&>::type operator[](key_type&& key) {\n+        ROBIN_HOOD_TRACE(this)\n+        auto idxAndState = insertKeyPrepareEmptySpot(key);\n+        switch (idxAndState.second) {\n+        case InsertionState::key_found:\n+            break;\n+\n+        case InsertionState::new_node:\n+            ::new (static_cast<void*>(&mKeyVals[idxAndState.first]))\n+                Node(*this, std::piecewise_construct, std::forward_as_tuple(std::move(key)),\n+                     std::forward_as_tuple());\n+            break;\n+\n+        case InsertionState::overwrite_node:\n+            mKeyVals[idxAndState.first] =\n+                Node(*this, std::piecewise_construct, std::forward_as_tuple(std::move(key)),\n+                     std::forward_as_tuple());\n+            break;\n+\n+        case InsertionState::overflow_error:\n+            throwOverflowError();\n+        }\n+\n+        return mKeyVals[idxAndState.first].getSecond();\n     }\n \n     template <typename Iter>\n@@ -1000,42 +1786,132 @@ class unordered_map\n         }\n     }\n \n+    void insert(std::initializer_list<value_type> ilist) {\n+        for (auto&& vt : ilist) {\n+            insert(std::move(vt));\n+        }\n+    }\n+\n     template <typename... Args>\n     std::pair<iterator, bool> emplace(Args&&... args) {\n-        ROBIN_HOOD_TRACE(this);\n+        ROBIN_HOOD_TRACE(this)\n         Node n{*this, std::forward<Args>(args)...};\n-        auto r = doInsert(std::move(n));\n-        if (!r.second) {\n-            // insertion not possible: destroy node\n-            // NOLINTNEXTLINE(bugprone-use-after-move)\n+        auto idxAndState = insertKeyPrepareEmptySpot(getFirstConst(n));\n+        switch (idxAndState.second) {\n+        case InsertionState::key_found:\n             n.destroy(*this);\n+            break;\n+\n+        case InsertionState::new_node:\n+            ::new (static_cast<void*>(&mKeyVals[idxAndState.first])) Node(*this, std::move(n));\n+            break;\n+\n+        case InsertionState::overwrite_node:\n+            mKeyVals[idxAndState.first] = std::move(n);\n+            break;\n+\n+        case InsertionState::overflow_error:\n+            n.destroy(*this);\n+            throwOverflowError();\n+            break;\n         }\n-        return r;\n+\n+        return std::make_pair(iterator(mKeyVals + idxAndState.first, mInfo + idxAndState.first),\n+                              InsertionState::key_found != idxAndState.second);\n+    }\n+\n+    template <typename... Args>\n+    std::pair<iterator, bool> try_emplace(const key_type& key, Args&&... args) {\n+        return try_emplace_impl(key, std::forward<Args>(args)...);\n+    }\n+\n+    template <typename... Args>\n+    std::pair<iterator, bool> try_emplace(key_type&& key, Args&&... args) {\n+        return try_emplace_impl(std::move(key), std::forward<Args>(args)...);\n+    }\n+\n+    template <typename... Args>\n+    std::pair<iterator, bool> try_emplace(const_iterator hint, const key_type& key,\n+                                          Args&&... args) {\n+        (void)hint;\n+        return try_emplace_impl(key, std::forward<Args>(args)...);\n+    }\n+\n+    template <typename... Args>\n+    std::pair<iterator, bool> try_emplace(const_iterator hint, key_type&& key, Args&&... args) {\n+        (void)hint;\n+        return try_emplace_impl(std::move(key), std::forward<Args>(args)...);\n+    }\n+\n+    template <typename Mapped>\n+    std::pair<iterator, bool> insert_or_assign(const key_type& key, Mapped&& obj) {\n+        return insertOrAssignImpl(key, std::forward<Mapped>(obj));\n+    }\n+\n+    template <typename Mapped>\n+    std::pair<iterator, bool> insert_or_assign(key_type&& key, Mapped&& obj) {\n+        return insertOrAssignImpl(std::move(key), std::forward<Mapped>(obj));\n+    }\n+\n+    template <typename Mapped>\n+    std::pair<iterator, bool> insert_or_assign(const_iterator hint, const key_type& key,\n+                                               Mapped&& obj) {\n+        (void)hint;\n+        return insertOrAssignImpl(key, std::forward<Mapped>(obj));\n+    }\n+\n+    template <typename Mapped>\n+    std::pair<iterator, bool> insert_or_assign(const_iterator hint, key_type&& key, Mapped&& obj) {\n+        (void)hint;\n+        return insertOrAssignImpl(std::move(key), std::forward<Mapped>(obj));\n     }\n \n     std::pair<iterator, bool> insert(const value_type& keyval) {\n-        ROBIN_HOOD_TRACE(this);\n-        return doInsert(keyval);\n+        ROBIN_HOOD_TRACE(this)\n+        return emplace(keyval);\n     }\n \n     std::pair<iterator, bool> insert(value_type&& keyval) {\n-        return doInsert(std::move(keyval));\n+        return emplace(std::move(keyval));\n     }\n \n     // Returns 1 if key is found, 0 otherwise.\n     size_t count(const key_type& key) const { // NOLINT(modernize-use-nodiscard)\n-        ROBIN_HOOD_TRACE(this);\n+        ROBIN_HOOD_TRACE(this)\n         auto kv = mKeyVals + findIdx(key);\n         if (kv != reinterpret_cast_no_cast_align_warning<Node*>(mInfo)) {\n             return 1;\n         }\n         return 0;\n     }\n \n+    template <typename OtherKey, typename Self_ = Self>\n+    // NOLINTNEXTLINE(modernize-use-nodiscard)\n+    typename std::enable_if<Self_::is_transparent, size_t>::type count(const OtherKey& key) const {\n+        ROBIN_HOOD_TRACE(this)\n+        auto kv = mKeyVals + findIdx(key);\n+        if (kv != reinterpret_cast_no_cast_align_warning<Node*>(mInfo)) {\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    bool contains(const key_type& key) const { // NOLINT(modernize-use-nodiscard)\n+        return 1U == count(key);\n+    }\n+\n+    template <typename OtherKey, typename Self_ = Self>\n+    // NOLINTNEXTLINE(modernize-use-nodiscard)\n+    typename std::enable_if<Self_::is_transparent, bool>::type contains(const OtherKey& key) const {\n+        return 1U == count(key);\n+    }\n+\n     // Returns a reference to the value found for key.\n     // Throws std::out_of_range if element cannot be found\n-    mapped_type& at(key_type const& key) {\n-        ROBIN_HOOD_TRACE(this);\n+    template <typename Q = mapped_type>\n+    // NOLINTNEXTLINE(modernize-use-nodiscard)\n+    typename std::enable_if<!std::is_void<Q>::value, Q&>::type at(key_type const& key) {\n+        ROBIN_HOOD_TRACE(this)\n         auto kv = mKeyVals + findIdx(key);\n         if (kv == reinterpret_cast_no_cast_align_warning<Node*>(mInfo)) {\n             doThrow<std::out_of_range>(\"key not found\");\n@@ -1045,8 +1921,10 @@ class unordered_map\n \n     // Returns a reference to the value found for key.\n     // Throws std::out_of_range if element cannot be found\n-    mapped_type const& at(key_type const& key) const { // NOLINT(modernize-use-nodiscard)\n-        ROBIN_HOOD_TRACE(this);\n+    template <typename Q = mapped_type>\n+    // NOLINTNEXTLINE(modernize-use-nodiscard)\n+    typename std::enable_if<!std::is_void<Q>::value, Q const&>::type at(key_type const& key) const {\n+        ROBIN_HOOD_TRACE(this)\n         auto kv = mKeyVals + findIdx(key);\n         if (kv == reinterpret_cast_no_cast_align_warning<Node*>(mInfo)) {\n             doThrow<std::out_of_range>(\"key not found\");\n@@ -1055,75 +1933,91 @@ class unordered_map\n     }\n \n     const_iterator find(const key_type& key) const { // NOLINT(modernize-use-nodiscard)\n-        ROBIN_HOOD_TRACE(this);\n+        ROBIN_HOOD_TRACE(this)\n         const size_t idx = findIdx(key);\n         return const_iterator{mKeyVals + idx, mInfo + idx};\n     }\n \n     template <typename OtherKey>\n     const_iterator find(const OtherKey& key, is_transparent_tag /*unused*/) const {\n-        ROBIN_HOOD_TRACE(this);\n+        ROBIN_HOOD_TRACE(this)\n+        const size_t idx = findIdx(key);\n+        return const_iterator{mKeyVals + idx, mInfo + idx};\n+    }\n+\n+    template <typename OtherKey, typename Self_ = Self>\n+    typename std::enable_if<Self_::is_transparent, // NOLINT(modernize-use-nodiscard)\n+                            const_iterator>::type  // NOLINT(modernize-use-nodiscard)\n+    find(const OtherKey& key) const {              // NOLINT(modernize-use-nodiscard)\n+        ROBIN_HOOD_TRACE(this)\n         const size_t idx = findIdx(key);\n         return const_iterator{mKeyVals + idx, mInfo + idx};\n     }\n \n     iterator find(const key_type& key) {\n-        ROBIN_HOOD_TRACE(this);\n+        ROBIN_HOOD_TRACE(this)\n         const size_t idx = findIdx(key);\n         return iterator{mKeyVals + idx, mInfo + idx};\n     }\n \n     template <typename OtherKey>\n     iterator find(const OtherKey& key, is_transparent_tag /*unused*/) {\n-        ROBIN_HOOD_TRACE(this);\n+        ROBIN_HOOD_TRACE(this)\n+        const size_t idx = findIdx(key);\n+        return iterator{mKeyVals + idx, mInfo + idx};\n+    }\n+\n+    template <typename OtherKey, typename Self_ = Self>\n+    typename std::enable_if<Self_::is_transparent, iterator>::type find(const OtherKey& key) {\n+        ROBIN_HOOD_TRACE(this)\n         const size_t idx = findIdx(key);\n         return iterator{mKeyVals + idx, mInfo + idx};\n     }\n \n     iterator begin() {\n-        ROBIN_HOOD_TRACE(this);\n+        ROBIN_HOOD_TRACE(this)\n         if (empty()) {\n             return end();\n         }\n         return iterator(mKeyVals, mInfo, fast_forward_tag{});\n     }\n     const_iterator begin() const { // NOLINT(modernize-use-nodiscard)\n-        ROBIN_HOOD_TRACE(this);\n+        ROBIN_HOOD_TRACE(this)\n         return cbegin();\n     }\n     const_iterator cbegin() const { // NOLINT(modernize-use-nodiscard)\n-        ROBIN_HOOD_TRACE(this);\n+        ROBIN_HOOD_TRACE(this)\n         if (empty()) {\n             return cend();\n         }\n         return const_iterator(mKeyVals, mInfo, fast_forward_tag{});\n     }\n \n     iterator end() {\n-        ROBIN_HOOD_TRACE(this);\n+        ROBIN_HOOD_TRACE(this)\n         // no need to supply valid info pointer: end() must not be dereferenced, and only node\n         // pointer is compared.\n         return iterator{reinterpret_cast_no_cast_align_warning<Node*>(mInfo), nullptr};\n     }\n     const_iterator end() const { // NOLINT(modernize-use-nodiscard)\n-        ROBIN_HOOD_TRACE(this);\n+        ROBIN_HOOD_TRACE(this)\n         return cend();\n     }\n     const_iterator cend() const { // NOLINT(modernize-use-nodiscard)\n-        ROBIN_HOOD_TRACE(this);\n+        ROBIN_HOOD_TRACE(this)\n         return const_iterator{reinterpret_cast_no_cast_align_warning<Node*>(mInfo), nullptr};\n     }\n \n     iterator erase(const_iterator pos) {\n-        ROBIN_HOOD_TRACE(this);\n+        ROBIN_HOOD_TRACE(this)\n         // its safe to perform const cast here\n         // NOLINTNEXTLINE(cppcoreguidelines-pro-type-const-cast)\n         return erase(iterator{const_cast<Node*>(pos.mKeyVals), const_cast<uint8_t*>(pos.mInfo)});\n     }\n \n     // Erases element at pos, returns iterator to the next element.\n     iterator erase(iterator pos) {\n-        ROBIN_HOOD_TRACE(this);\n+        ROBIN_HOOD_TRACE(this)\n         // we assume that pos always points to a valid entry, and not end().\n         auto const idx = static_cast<size_t>(pos.mKeyVals - mKeyVals);\n \n@@ -1140,14 +2034,14 @@ class unordered_map\n     }\n \n     size_t erase(const key_type& key) {\n-        ROBIN_HOOD_TRACE(this);\n-        size_t idx;\n-        InfoType info;\n+        ROBIN_HOOD_TRACE(this)\n+        size_t idx{};\n+        InfoType info{};\n         keyToIdx(key, &idx, &info);\n \n         // check while info matches with the source idx\n         do {\n-            if (info == mInfo[idx] && KeyEqual::operator()(key, mKeyVals[idx].getFirst())) {\n+            if (info == mInfo[idx] && WKeyEqual::operator()(key, mKeyVals[idx].getFirst())) {\n                 shiftDown(idx);\n                 --mNumElements;\n                 return 1;\n@@ -1162,53 +2056,66 @@ class unordered_map\n     // reserves space for the specified number of elements. Makes sure the old data fits.\n     // exactly the same as reserve(c).\n     void rehash(size_t c) {\n-        reserve(c);\n+        // forces a reserve\n+        reserve(c, true);\n     }\n \n     // reserves space for the specified number of elements. Makes sure the old data fits.\n-    // Exactly the same as resize(c). Use resize(0) to shrink to fit.\n+    // Exactly the same as rehash(c). Use rehash(0) to shrink to fit.\n     void reserve(size_t c) {\n-        ROBIN_HOOD_TRACE(this);\n-        auto const minElementsAllowed = (std::max)(c, mNumElements);\n+        // reserve, but don't force rehash\n+        reserve(c, false);\n+    }\n+\n+    // If possible reallocates the map to a smaller one. This frees the underlying table.\n+    // Does not do anything if load_factor is too large for decreasing the table's size.\n+    void compact() {\n+        ROBIN_HOOD_TRACE(this)\n         auto newSize = InitialNumElements;\n-        while (calcMaxNumElementsAllowed(newSize) < minElementsAllowed && newSize != 0) {\n+        while (calcMaxNumElementsAllowed(newSize) < mNumElements && newSize != 0) {\n             newSize *= 2;\n         }\n         if (ROBIN_HOOD_UNLIKELY(newSize == 0)) {\n             throwOverflowError();\n         }\n \n-        rehashPowerOfTwo(newSize);\n+        ROBIN_HOOD_LOG(\"newSize > mMask + 1: \" << newSize << \" > \" << mMask << \" + 1\")\n+\n+        // only actually do anything when the new size is bigger than the old one. This prevents to\n+        // continuously allocate for each reserve() call.\n+        if (newSize < mMask + 1) {\n+            rehashPowerOfTwo(newSize, true);\n+        }\n     }\n \n     size_type size() const noexcept { // NOLINT(modernize-use-nodiscard)\n-        ROBIN_HOOD_TRACE(this);\n+        ROBIN_HOOD_TRACE(this)\n         return mNumElements;\n     }\n \n     size_type max_size() const noexcept { // NOLINT(modernize-use-nodiscard)\n-        ROBIN_HOOD_TRACE(this);\n+        ROBIN_HOOD_TRACE(this)\n         return static_cast<size_type>(-1);\n     }\n \n     ROBIN_HOOD(NODISCARD) bool empty() const noexcept {\n-        ROBIN_HOOD_TRACE(this);\n+        ROBIN_HOOD_TRACE(this)\n         return 0 == mNumElements;\n     }\n \n     float max_load_factor() const noexcept { // NOLINT(modernize-use-nodiscard)\n-        ROBIN_HOOD_TRACE(this);\n+        ROBIN_HOOD_TRACE(this)\n         return MaxLoadFactor100 / 100.0F;\n     }\n \n     // Average number of elements per bucket. Since we allow only 1 per bucket\n     float load_factor() const noexcept { // NOLINT(modernize-use-nodiscard)\n-        ROBIN_HOOD_TRACE(this);\n+        ROBIN_HOOD_TRACE(this)\n         return static_cast<float>(size()) / static_cast<float>(mMask + 1);\n     }\n \n     ROBIN_HOOD(NODISCARD) size_t mask() const noexcept {\n-        ROBIN_HOOD_TRACE(this);\n+        ROBIN_HOOD_TRACE(this)\n         return mMask;\n     }\n \n@@ -1221,11 +2128,19 @@ class unordered_map\n         return (maxElements / 100) * MaxLoadFactor100;\n     }\n \n-    ROBIN_HOOD(NODISCARD) size_t calcNumBytesInfo(size_t numElements) const {\n+    ROBIN_HOOD(NODISCARD) size_t calcNumBytesInfo(size_t numElements) const noexcept {\n+        // we add a uint64_t, which houses the sentinel (first byte) and padding so we can load\n+        // 64bit types.\n         return numElements + sizeof(uint64_t);\n     }\n \n-    // calculation ony allowed for 2^n values\n+    ROBIN_HOOD(NODISCARD)\n+    size_t calcNumElementsWithBuffer(size_t numElements) const noexcept {\n+        auto maxNumElementsAllowed = calcMaxNumElementsAllowed(numElements);\n+        return numElements + (std::min)(maxNumElementsAllowed, (static_cast<size_t>(0xFF)));\n+    }\n+\n+    // calculation only allowed for 2^n values\n     ROBIN_HOOD(NODISCARD) size_t calcNumBytesTotal(size_t numElements) const {\n #if ROBIN_HOOD(BITNESS) == 64\n         return numElements * sizeof(Node) + calcNumBytesInfo(numElements);\n@@ -1246,29 +2161,76 @@ class unordered_map\n     }\n \n private:\n+    template <typename Q = mapped_type>\n+    ROBIN_HOOD(NODISCARD)\n+    typename std::enable_if<!std::is_void<Q>::value, bool>::type has(const value_type& e) const {\n+        ROBIN_HOOD_TRACE(this)\n+        auto it = find(e.first);\n+        return it != end() && it->second == e.second;\n+    }\n+\n+    template <typename Q = mapped_type>\n+    ROBIN_HOOD(NODISCARD)\n+    typename std::enable_if<std::is_void<Q>::value, bool>::type has(const value_type& e) const {\n+        ROBIN_HOOD_TRACE(this)\n+        return find(e) != end();\n+    }\n+\n+    void reserve(size_t c, bool forceRehash) {\n+        ROBIN_HOOD_TRACE(this)\n+        auto const minElementsAllowed = (std::max)(c, mNumElements);\n+        auto newSize = InitialNumElements;\n+        while (calcMaxNumElementsAllowed(newSize) < minElementsAllowed && newSize != 0) {\n+            newSize *= 2;\n+        }\n+        if (ROBIN_HOOD_UNLIKELY(newSize == 0)) {\n+            throwOverflowError();\n+        }\n+\n+        ROBIN_HOOD_LOG(\"newSize > mMask + 1: \" << newSize << \" > \" << mMask << \" + 1\")\n+\n+        // only actually do anything when the new size is bigger than the old one. This prevents to\n+        // continuously allocate for each reserve() call.\n+        if (forceRehash || newSize > mMask + 1) {\n+            rehashPowerOfTwo(newSize, false);\n+        }\n+    }\n+\n     // reserves space for at least the specified number of elements.\n     // only works if numBuckets if power of two\n-    void rehashPowerOfTwo(size_t numBuckets) {\n-        ROBIN_HOOD_TRACE(this);\n+    // True on success, false otherwise\n+    void rehashPowerOfTwo(size_t numBuckets, bool forceFree) {\n+        ROBIN_HOOD_TRACE(this)\n \n         Node* const oldKeyVals = mKeyVals;\n         uint8_t const* const oldInfo = mInfo;\n \n-        const size_t oldMaxElements = mMask + 1;\n+        const size_t oldMaxElementsWithBuffer = calcNumElementsWithBuffer(mMask + 1);\n \n         // resize operation: move stuff\n-        init_data(numBuckets);\n-        if (oldMaxElements > 1) {\n-            for (size_t i = 0; i < oldMaxElements; ++i) {\n+        initData(numBuckets);\n+        if (oldMaxElementsWithBuffer > 1) {\n+            for (size_t i = 0; i < oldMaxElementsWithBuffer; ++i) {\n                 if (oldInfo[i] != 0) {\n+                    // might throw an exception, which is really bad since we are in the middle of\n+                    // moving stuff.\n                     insert_move(std::move(oldKeyVals[i]));\n                     // destroy the node but DON'T destroy the data.\n                     oldKeyVals[i].~Node();\n                 }\n             }\n \n-            // don't destroy old data: put it into the pool instead\n-            DataPool::addOrFree(oldKeyVals, calcNumBytesTotal(oldMaxElements));\n+            // this check is not necessary as it's guarded by the previous if, but it helps\n+            // silence g++'s overeager \"attempt to free a non-heap object 'map'\n+            // [-Werror=free-nonheap-object]\" warning.\n+            if (oldKeyVals != reinterpret_cast_no_cast_align_warning<Node*>(&mMask)) {\n+                // don't destroy old data: put it into the pool instead\n+                if (forceFree) {\n+                    std::free(oldKeyVals);\n+                } else {\n+                    DataPool::addOrFree(oldKeyVals, calcNumBytesTotal(oldMaxElementsWithBuffer));\n+                }\n+            }\n         }\n     }\n \n@@ -1280,103 +2242,115 @@ class unordered_map\n #endif\n     }\n \n-    void init_data(size_t max_elements) {\n-        mNumElements = 0;\n-        mMask = max_elements - 1;\n-        mMaxNumElementsAllowed = calcMaxNumElementsAllowed(max_elements);\n+    template <typename OtherKey, typename... Args>\n+    std::pair<iterator, bool> try_emplace_impl(OtherKey&& key, Args&&... args) {\n+        ROBIN_HOOD_TRACE(this)\n+        auto idxAndState = insertKeyPrepareEmptySpot(key);\n+        switch (idxAndState.second) {\n+        case InsertionState::key_found:\n+            break;\n \n-        // calloc also zeroes everything\n-        mKeyVals = reinterpret_cast<Node*>(\n-            detail::assertNotNull<std::bad_alloc>(calloc(1, calcNumBytesTotal(max_elements))));\n-        mInfo = reinterpret_cast<uint8_t*>(mKeyVals + max_elements);\n+        case InsertionState::new_node:\n+            ::new (static_cast<void*>(&mKeyVals[idxAndState.first])) Node(\n+                *this, std::piecewise_construct, std::forward_as_tuple(std::forward<OtherKey>(key)),\n+                std::forward_as_tuple(std::forward<Args>(args)...));\n+            break;\n \n-        // set sentinel\n-        mInfo[max_elements] = 1;\n+        case InsertionState::overwrite_node:\n+            mKeyVals[idxAndState.first] = Node(*this, std::piecewise_construct,\n+                                               std::forward_as_tuple(std::forward<OtherKey>(key)),\n+                                               std::forward_as_tuple(std::forward<Args>(args)...));\n+            break;\n \n-        mInfoInc = InitialInfoInc;\n-        mInfoHashShift = InitialInfoHashShift;\n+        case InsertionState::overflow_error:\n+            throwOverflowError();\n+            break;\n+        }\n+\n+        return std::make_pair(iterator(mKeyVals + idxAndState.first, mInfo + idxAndState.first),\n+                              InsertionState::key_found != idxAndState.second);\n     }\n \n-    template <typename Arg>\n-    mapped_type& doCreateByKey(Arg&& key) {\n-        while (true) {\n-            size_t idx;\n-            InfoType info;\n-            keyToIdx(key, &idx, &info);\n-            nextWhileLess(&info, &idx);\n+    template <typename OtherKey, typename Mapped>\n+    std::pair<iterator, bool> insertOrAssignImpl(OtherKey&& key, Mapped&& obj) {\n+        ROBIN_HOOD_TRACE(this)\n+        auto idxAndState = insertKeyPrepareEmptySpot(key);\n+        switch (idxAndState.second) {\n+        case InsertionState::key_found:\n+            mKeyVals[idxAndState.first].getSecond() = std::forward<Mapped>(obj);\n+            break;\n \n-            // while we potentially have a match. Can't do a do-while here because when mInfo is 0\n-            // we don't want to skip forward\n-            while (info == mInfo[idx]) {\n-                if (KeyEqual::operator()(key, mKeyVals[idx].getFirst())) {\n-                    // key already exists, do not insert.\n-                    return mKeyVals[idx].getSecond();\n-                }\n-                next(&info, &idx);\n-            }\n+        case InsertionState::new_node:\n+            ::new (static_cast<void*>(&mKeyVals[idxAndState.first])) Node(\n+                *this, std::piecewise_construct, std::forward_as_tuple(std::forward<OtherKey>(key)),\n+                std::forward_as_tuple(std::forward<Mapped>(obj)));\n+            break;\n \n-            // unlikely that this evaluates to true\n-            if (ROBIN_HOOD_UNLIKELY(mNumElements >= mMaxNumElementsAllowed)) {\n-                increase_size();\n-                continue;\n-            }\n+        case InsertionState::overwrite_node:\n+            mKeyVals[idxAndState.first] = Node(*this, std::piecewise_construct,\n+                                               std::forward_as_tuple(std::forward<OtherKey>(key)),\n+                                               std::forward_as_tuple(std::forward<Mapped>(obj)));\n+            break;\n \n-            // key not found, so we are now exactly where we want to insert it.\n-            auto const insertion_idx = idx;\n-            auto const insertion_info = info;\n-            if (ROBIN_HOOD_UNLIKELY(insertion_info + mInfoInc > 0xFF)) {\n-                mMaxNumElementsAllowed = 0;\n-            }\n+        case InsertionState::overflow_error:\n+            throwOverflowError();\n+            break;\n+        }\n \n-            // find an empty spot\n-            while (0 != mInfo[idx]) {\n-                next(&info, &idx);\n-            }\n+        return std::make_pair(iterator(mKeyVals + idxAndState.first, mInfo + idxAndState.first),\n+                              InsertionState::key_found != idxAndState.second);\n+    }\n \n-            auto& l = mKeyVals[insertion_idx];\n-            if (idx == insertion_idx) {\n-                // put at empty spot. This forwards all arguments into the node where the object is\n-                // constructed exactly where it is needed.\n-                ::new (static_cast<void*>(&l))\n-                    Node(*this, std::piecewise_construct,\n-                         std::forward_as_tuple(std::forward<Arg>(key)), std::forward_as_tuple());\n-            } else {\n-                shiftUp(idx, insertion_idx);\n-                l = Node(*this, std::piecewise_construct,\n-                         std::forward_as_tuple(std::forward<Arg>(key)), std::forward_as_tuple());\n-            }\n+    void initData(size_t max_elements) {\n+        mNumElements = 0;\n+        mMask = max_elements - 1;\n+        mMaxNumElementsAllowed = calcMaxNumElementsAllowed(max_elements);\n \n-            // mKeyVals[idx].getFirst() = std::move(key);\n-            mInfo[insertion_idx] = static_cast<uint8_t>(insertion_info);\n+        auto const numElementsWithBuffer = calcNumElementsWithBuffer(max_elements);\n \n-            ++mNumElements;\n-            return mKeyVals[insertion_idx].getSecond();\n-        }\n+        // calloc also zeroes everything\n+        auto const numBytesTotal = calcNumBytesTotal(numElementsWithBuffer);\n+        ROBIN_HOOD_LOG(\"std::calloc \" << numBytesTotal << \" = calcNumBytesTotal(\"\n+                                      << numElementsWithBuffer << \")\")\n+        mKeyVals = reinterpret_cast<Node*>(\n+            detail::assertNotNull<std::bad_alloc>(std::calloc(1, numBytesTotal)));\n+        mInfo = reinterpret_cast<uint8_t*>(mKeyVals + numElementsWithBuffer);\n+\n+        // set sentinel\n+        mInfo[numElementsWithBuffer] = 1;\n+\n+        mInfoInc = InitialInfoInc;\n+        mInfoHashShift = InitialInfoHashShift;\n     }\n \n-    // This is exactly the same code as operator[], except for the return values\n-    template <typename Arg>\n-    std::pair<iterator, bool> doInsert(Arg&& keyval) {\n-        while (true) {\n-            size_t idx;\n-            InfoType info;\n-            keyToIdx(keyval.getFirst(), &idx, &info);\n+    enum class InsertionState { overflow_error, key_found, new_node, overwrite_node };\n+\n+    // Finds key, and if not already present prepares a spot where to pot the key & value.\n+    // This potentially shifts nodes out of the way, updates mInfo and number of inserted\n+    // elements, so the only operation left to do is create/assign a new node at that spot.\n+    template <typename OtherKey>\n+    std::pair<size_t, InsertionState> insertKeyPrepareEmptySpot(OtherKey&& key) {\n+        for (int i = 0; i < 256; ++i) {\n+            size_t idx{};\n+            InfoType info{};\n+            keyToIdx(key, &idx, &info);\n             nextWhileLess(&info, &idx);\n \n             // while we potentially have a match\n             while (info == mInfo[idx]) {\n-                if (KeyEqual::operator()(keyval.getFirst(), mKeyVals[idx].getFirst())) {\n+                if (WKeyEqual::operator()(key, mKeyVals[idx].getFirst())) {\n                     // key already exists, do NOT insert.\n                     // see http://en.cppreference.com/w/cpp/container/unordered_map/insert\n-                    return std::make_pair<iterator, bool>(iterator(mKeyVals + idx, mInfo + idx),\n-                                                          false);\n+                    return std::make_pair(idx, InsertionState::key_found);\n                 }\n                 next(&info, &idx);\n             }\n \n             // unlikely that this evaluates to true\n             if (ROBIN_HOOD_UNLIKELY(mNumElements >= mMaxNumElementsAllowed)) {\n-                increase_size();\n+                if (!increase_size()) {\n+                    return std::make_pair(size_t(0), InsertionState::overflow_error);\n+                }\n                 continue;\n             }\n \n@@ -1392,26 +2366,25 @@ class unordered_map\n                 next(&info, &idx);\n             }\n \n-            auto& l = mKeyVals[insertion_idx];\n-            if (idx == insertion_idx) {\n-                ::new (static_cast<void*>(&l)) Node(*this, std::forward<Arg>(keyval));\n-            } else {\n+            if (idx != insertion_idx) {\n                 shiftUp(idx, insertion_idx);\n-                l = Node(*this, std::forward<Arg>(keyval));\n             }\n-\n             // put at empty spot\n             mInfo[insertion_idx] = static_cast<uint8_t>(insertion_info);\n-\n             ++mNumElements;\n-            return std::make_pair(iterator(mKeyVals + insertion_idx, mInfo + insertion_idx), true);\n+            return std::make_pair(insertion_idx, idx == insertion_idx\n+                                                     ? InsertionState::new_node\n+                                                     : InsertionState::overwrite_node);\n         }\n+\n+        // enough attempts failed, so finally give up.\n+        return std::make_pair(size_t(0), InsertionState::overflow_error);\n     }\n \n     bool try_increase_info() {\n         ROBIN_HOOD_LOG(\"mInfoInc=\" << mInfoInc << \", numElements=\" << mNumElements\n                                    << \", maxNumElementsAllowed=\"\n-                                   << calcMaxNumElementsAllowed(mMask + 1));\n+                                   << calcMaxNumElementsAllowed(mMask + 1))\n         if (mInfoInc <= 2) {\n             // need to be > 2 so that shift works (otherwise undefined behavior!)\n             return false;\n@@ -1422,38 +2395,55 @@ class unordered_map\n         // remove one bit of the hash, leaving more space for the distance info.\n         // This is extremely fast because we can operate on 8 bytes at once.\n         ++mInfoHashShift;\n-        auto const data = reinterpret_cast_no_cast_align_warning<uint64_t*>(mInfo);\n-        auto const numEntries = (mMask + 1) / 8;\n+        auto const numElementsWithBuffer = calcNumElementsWithBuffer(mMask + 1);\n \n-        for (size_t i = 0; i < numEntries; ++i) {\n-            data[i] = (data[i] >> 1U) & UINT64_C(0x7f7f7f7f7f7f7f7f);\n+        for (size_t i = 0; i < numElementsWithBuffer; i += 8) {\n+            auto val = unaligned_load<uint64_t>(mInfo + i);\n+            val = (val >> 1U) & UINT64_C(0x7f7f7f7f7f7f7f7f);\n+            std::memcpy(mInfo + i, &val, sizeof(val));\n         }\n+        // update sentinel, which might have been cleared out!\n+        mInfo[numElementsWithBuffer] = 1;\n+\n         mMaxNumElementsAllowed = calcMaxNumElementsAllowed(mMask + 1);\n         return true;\n     }\n \n-    void increase_size() {\n+    // True if resize was possible, false otherwise\n+    bool increase_size() {\n         // nothing allocated yet? just allocate InitialNumElements\n         if (0 == mMask) {\n-            init_data(InitialNumElements);\n-            return;\n+            initData(InitialNumElements);\n+            return true;\n         }\n \n         auto const maxNumElementsAllowed = calcMaxNumElementsAllowed(mMask + 1);\n         if (mNumElements < maxNumElementsAllowed && try_increase_info()) {\n-            return;\n+            return true;\n         }\n \n         ROBIN_HOOD_LOG(\"mNumElements=\" << mNumElements << \", maxNumElementsAllowed=\"\n                                        << maxNumElementsAllowed << \", load=\"\n                                        << (static_cast<double>(mNumElements) * 100.0 /\n-                                           (static_cast<double>(mMask) + 1)));\n-        // it seems we have a really bad hash function! don't try to resize again\n+                                           (static_cast<double>(mMask) + 1)))\n+\n         if (mNumElements * 2 < calcMaxNumElementsAllowed(mMask + 1)) {\n-            throwOverflowError();\n+            // we have to resize, even though there would still be plenty of space left!\n+            // Try to rehash instead. Delete freed memory so we don't steadyily increase mem in case\n+            // we have to rehash a few times\n+            nextHashMultiplier();\n+            rehashPowerOfTwo(mMask + 1, true);\n+        } else {\n+            // we've reached the capacity of the map, so the hash seems to work nice. Keep using it.\n+            rehashPowerOfTwo((mMask + 1) * 2, false);\n         }\n+        return true;\n+    }\n \n-        rehashPowerOfTwo((mMask + 1) * 2);\n+    void nextHashMultiplier() {\n+        // adding an *even* number, so that the multiplier will always stay odd. This is necessary\n+        // so that the hash stays a mixing function (and thus doesn't have any information loss).\n+        mHashMultiplier += UINT64_C(0xc4ceb9fe1a85ec54);\n     }\n \n     void destroy() {\n@@ -1462,12 +2452,21 @@ class unordered_map\n             return;\n         }\n \n-        Destroyer<Self, false>{}.nodesDoNotDeallocate(*this);\n-        free(mKeyVals);\n+        Destroyer<Self, IsFlat && std::is_trivially_destructible<Node>::value>{}\n+            .nodesDoNotDeallocate(*this);\n+\n+        // This protection against not deleting mMask shouldn't be needed as it's sufficiently\n+        // protected with the 0==mMask check, but I have this anyways because g++ 7 otherwise\n+        // reports a compile error: attempt to free a non-heap object 'fm'\n+        // [-Werror=free-nonheap-object]\n+        if (mKeyVals != reinterpret_cast_no_cast_align_warning<Node*>(&mMask)) {\n+            ROBIN_HOOD_LOG(\"std::free\")\n+            std::free(mKeyVals);\n+        }\n     }\n \n     void init() noexcept {\n-        mKeyVals = reinterpret_cast<Node*>(&mMask);\n+        mKeyVals = reinterpret_cast_no_cast_align_warning<Node*>(&mMask);\n         mInfo = reinterpret_cast<uint8_t*>(&mMask);\n         mNumElements = 0;\n         mMask = 0;\n@@ -1477,21 +2476,53 @@ class unordered_map\n     }\n \n     // members are sorted so no padding occurs\n-    Node* mKeyVals = reinterpret_cast<Node*>(&mMask);    // 8 byte  8\n-    uint8_t* mInfo = reinterpret_cast<uint8_t*>(&mMask); // 8 byte 16\n-    size_t mNumElements = 0;                             // 8 byte 24\n-    size_t mMask = 0;                                    // 8 byte 32\n-    size_t mMaxNumElementsAllowed = 0;                   // 8 byte 40\n-    InfoType mInfoInc = InitialInfoInc;                  // 4 byte 44\n-    InfoType mInfoHashShift = InitialInfoHashShift;      // 4 byte 48\n-                                                         // 16 byte 56 if NodeAllocator\n+    uint64_t mHashMultiplier = UINT64_C(0xc4ceb9fe1a85ec53);                // 8 byte  8\n+    Node* mKeyVals = reinterpret_cast_no_cast_align_warning<Node*>(&mMask); // 8 byte 16\n+    uint8_t* mInfo = reinterpret_cast<uint8_t*>(&mMask);                    // 8 byte 24\n+    size_t mNumElements = 0;                                                // 8 byte 32\n+    size_t mMask = 0;                                                       // 8 byte 40\n+    size_t mMaxNumElementsAllowed = 0;                                      // 8 byte 48\n+    InfoType mInfoInc = InitialInfoInc;                                     // 4 byte 52\n+    InfoType mInfoHashShift = InitialInfoHashShift;                         // 4 byte 56\n+                                                    // 16 byte 56 if NodeAllocator\n };\n \n } // namespace detail\n \n-template <typename Key, typename T, typename Hash,\n+// map\n+\n+template <typename Key, typename T, typename Hash = hash<Key>,\n+          typename KeyEqual = std::equal_to<Key>, size_t MaxLoadFactor100 = 80>\n+using unordered_flat_map = detail::Table<true, MaxLoadFactor100, Key, T, Hash, KeyEqual>;\n+\n+template <typename Key, typename T, typename Hash = hash<Key>,\n+          typename KeyEqual = std::equal_to<Key>, size_t MaxLoadFactor100 = 80>\n+using unordered_node_map = detail::Table<false, MaxLoadFactor100, Key, T, Hash, KeyEqual>;\n+\n+template <typename Key, typename T, typename Hash = hash<Key>,\n           typename KeyEqual = std::equal_to<Key>, size_t MaxLoadFactor100 = 80>\n-using unordered_node_map = detail::unordered_map< MaxLoadFactor100, Key, T, Hash, KeyEqual>;\n+using unordered_map =\n+    detail::Table<sizeof(robin_hood::pair<Key, T>) <= sizeof(size_t) * 6 &&\n+                      std::is_nothrow_move_constructible<robin_hood::pair<Key, T>>::value &&\n+                      std::is_nothrow_move_assignable<robin_hood::pair<Key, T>>::value,\n+                  MaxLoadFactor100, Key, T, Hash, KeyEqual>;\n+\n+// set\n+\n+template <typename Key, typename Hash = hash<Key>, typename KeyEqual = std::equal_to<Key>,\n+          size_t MaxLoadFactor100 = 80>\n+using unordered_flat_set = detail::Table<true, MaxLoadFactor100, Key, void, Hash, KeyEqual>;\n+\n+template <typename Key, typename Hash = hash<Key>, typename KeyEqual = std::equal_to<Key>,\n+          size_t MaxLoadFactor100 = 80>\n+using unordered_node_set = detail::Table<false, MaxLoadFactor100, Key, void, Hash, KeyEqual>;\n+\n+template <typename Key, typename Hash = hash<Key>, typename KeyEqual = std::equal_to<Key>,\n+          size_t MaxLoadFactor100 = 80>\n+using unordered_set = detail::Table<sizeof(Key) <= sizeof(size_t) * 6 &&\n+                                        std::is_nothrow_move_constructible<Key>::value &&\n+                                        std::is_nothrow_move_assignable<Key>::value,\n+                                    MaxLoadFactor100, Key, void, Hash, KeyEqual>;\n \n } // namespace robin_hood\n "
      }
    ]
  }
]