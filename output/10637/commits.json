[
  {
    "sha": "12ec29d3bb0d46c61712210fe9bb96a0d543204a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMmVjMjlkM2JiMGQ0NmM2MTcxMjIxMGZlOWJiOTZhMGQ1NDMyMDRh",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-05T21:37:24Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-10T02:15:36Z"
      },
      "message": "Calculate and store the number of bytes required to spend an input",
      "tree": {
        "sha": "5570d616050510641d8f55d894da60048841e6cf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5570d616050510641d8f55d894da60048841e6cf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/12ec29d3bb0d46c61712210fe9bb96a0d543204a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/12ec29d3bb0d46c61712210fe9bb96a0d543204a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/12ec29d3bb0d46c61712210fe9bb96a0d543204a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/12ec29d3bb0d46c61712210fe9bb96a0d543204a/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a34ac6ae0788b50e12dd2c8ac59dbda2a03a3c2e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a34ac6ae0788b50e12dd2c8ac59dbda2a03a3c2e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a34ac6ae0788b50e12dd2c8ac59dbda2a03a3c2e"
      }
    ],
    "stats": {
      "total": 195,
      "additions": 127,
      "deletions": 68
    },
    "files": [
      {
        "sha": "757df518ae041b3d3ab0a49069f8893ace17f7f2",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/12ec29d3bb0d46c61712210fe9bb96a0d543204a/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/12ec29d3bb0d46c61712210fe9bb96a0d543204a/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=12ec29d3bb0d46c61712210fe9bb96a0d543204a",
        "patch": "@@ -101,5 +101,10 @@ static inline int64_t GetBlockWeight(const CBlock& block)\n {\n     return ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION);\n }\n+static inline int64_t GetTransationInputWeight(const CTxIn& txin)\n+{\n+    // scriptWitness size is added here because witnesses and txins are split up in segwit serialization.\n+    return ::GetSerializeSize(txin, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(txin, SER_NETWORK, PROTOCOL_VERSION) + ::GetSerializeSize(txin.scriptWitness.stack, SER_NETWORK, PROTOCOL_VERSION);\n+}\n \n #endif // BITCOIN_CONSENSUS_VALIDATION_H"
      },
      {
        "sha": "41f967c98547c7849e290134d7c3545ff3a40d47",
        "filename": "src/policy/policy.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/12ec29d3bb0d46c61712210fe9bb96a0d543204a/src/policy/policy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/12ec29d3bb0d46c61712210fe9bb96a0d543204a/src/policy/policy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.cpp?ref=12ec29d3bb0d46c61712210fe9bb96a0d543204a",
        "patch": "@@ -258,3 +258,8 @@ int64_t GetVirtualTransactionSize(const CTransaction& tx, int64_t nSigOpCost)\n {\n     return GetVirtualTransactionSize(GetTransactionWeight(tx), nSigOpCost);\n }\n+\n+int64_t GetVirtualTransactionInputSize(const CTxIn& txin, int64_t nSigOpCost)\n+{\n+    return GetVirtualTransactionSize(GetTransationInputWeight(txin), nSigOpCost);\n+}"
      },
      {
        "sha": "e4eda4b6354081f3e097d0003ba224d9d5e58df4",
        "filename": "src/policy/policy.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/12ec29d3bb0d46c61712210fe9bb96a0d543204a/src/policy/policy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/12ec29d3bb0d46c61712210fe9bb96a0d543204a/src/policy/policy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.h?ref=12ec29d3bb0d46c61712210fe9bb96a0d543204a",
        "patch": "@@ -102,5 +102,6 @@ extern unsigned int nBytesPerSigOp;\n /** Compute the virtual transaction size (weight reinterpreted as bytes). */\n int64_t GetVirtualTransactionSize(int64_t nWeight, int64_t nSigOpCost);\n int64_t GetVirtualTransactionSize(const CTransaction& tx, int64_t nSigOpCost = 0);\n+int64_t GetVirtualTransactionInputSize(const CTxIn& tx, int64_t nSigOpCost = 0);\n \n #endif // BITCOIN_POLICY_POLICY_H"
      },
      {
        "sha": "baa712dc2d05f912f1497b99b834a2c2c1f04bef",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 2,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/12ec29d3bb0d46c61712210fe9bb96a0d543204a/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/12ec29d3bb0d46c61712210fe9bb96a0d543204a/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=12ec29d3bb0d46c61712210fe9bb96a0d543204a",
        "patch": "@@ -194,11 +194,16 @@ SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nI\n     return data;\n }\n \n+void UpdateInput(CTxIn& input, const SignatureData& data)\n+{\n+    input.scriptSig = data.scriptSig;\n+    input.scriptWitness = data.scriptWitness;\n+}\n+\n void UpdateTransaction(CMutableTransaction& tx, unsigned int nIn, const SignatureData& data)\n {\n     assert(tx.vin.size() > nIn);\n-    tx.vin[nIn].scriptSig = data.scriptSig;\n-    tx.vin[nIn].scriptWitness = data.scriptWitness;\n+    UpdateInput(tx.vin[nIn], data);\n }\n \n bool SignSignature(const CKeyStore &keystore, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, const CAmount& amount, int nHashType)"
      },
      {
        "sha": "2c749521cd62a66f5ed19ccef0d3ad94c95163c5",
        "filename": "src/script/sign.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/12ec29d3bb0d46c61712210fe9bb96a0d543204a/src/script/sign.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/12ec29d3bb0d46c61712210fe9bb96a0d543204a/src/script/sign.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.h?ref=12ec29d3bb0d46c61712210fe9bb96a0d543204a",
        "patch": "@@ -80,6 +80,7 @@ SignatureData CombineSignatures(const CScript& scriptPubKey, const BaseSignature\n /** Extract signature data from a transaction, and insert it. */\n SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn);\n void UpdateTransaction(CMutableTransaction& tx, unsigned int nIn, const SignatureData& data);\n+void UpdateInput(CTxIn& input, const SignatureData& data);\n \n /* Check whether we know how to sign for an output like this, assuming we\n  * have all private keys. While this function does not need private keys, the passed"
      },
      {
        "sha": "9b85176ca01b0d8e407ab7b992fbc7a423d61620",
        "filename": "src/wallet/feebumper.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 27,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/12ec29d3bb0d46c61712210fe9bb96a0d543204a/src/wallet/feebumper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/12ec29d3bb0d46c61712210fe9bb96a0d543204a/src/wallet/feebumper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.cpp?ref=12ec29d3bb0d46c61712210fe9bb96a0d543204a",
        "patch": "@@ -16,33 +16,6 @@\n #include <util.h>\n #include <net.h>\n \n-// Calculate the size of the transaction assuming all signatures are max size\n-// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n-// TODO: re-use this in CWallet::CreateTransaction (right now\n-// CreateTransaction uses the constructed dummy-signed tx to do a priority\n-// calculation, but we should be able to refactor after priority is removed).\n-// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n-// be IsAllFromMe).\n-static int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet)\n-{\n-    CMutableTransaction txNew(tx);\n-    std::vector<CInputCoin> vCoins;\n-    // Look up the inputs.  We should have already checked that this transaction\n-    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n-    // wallet, with a valid index into the vout array.\n-    for (auto& input : tx.vin) {\n-        const auto mi = wallet->mapWallet.find(input.prevout.hash);\n-        assert(mi != wallet->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n-        vCoins.emplace_back(CInputCoin(&(mi->second), input.prevout.n));\n-    }\n-    if (!wallet->DummySignTx(txNew, vCoins)) {\n-        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n-        // implies that we can sign for every input.\n-        return -1;\n-    }\n-    return GetVirtualTransactionSize(txNew);\n-}\n-\n //! Check whether transaction has descendant in wallet or mempool, or has been\n //! mined, or conflicts with a mined transaction. Return a feebumper::Result.\n static feebumper::Result PreconditionChecks(const CWallet* wallet, const CWalletTx& wtx, std::vector<std::string>& errors)"
      },
      {
        "sha": "a739077a31f084052a884eca9dd120cc0d68f963",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 76,
        "deletions": 11,
        "changes": 87,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/12ec29d3bb0d46c61712210fe9bb96a0d543204a/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/12ec29d3bb0d46c61712210fe9bb96a0d543204a/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=12ec29d3bb0d46c61712210fe9bb96a0d543204a",
        "patch": "@@ -1543,6 +1543,79 @@ int CWalletTx::GetRequestCount() const\n     return nRequests;\n }\n \n+// Helper for producing a max-sized low-S signature (eg 72 bytes)\n+bool CWallet::DummySignInput(CTxIn &tx_in, const CTxOut &txout) const\n+{\n+    // Fill in dummy signatures for fee calculation.\n+    const CScript& scriptPubKey = txout.scriptPubKey;\n+    SignatureData sigdata;\n+\n+    if (!ProduceSignature(DummySignatureCreator(this), scriptPubKey, sigdata))\n+    {\n+        return false;\n+    } else {\n+        UpdateInput(tx_in, sigdata);\n+    }\n+    return true;\n+}\n+\n+// Helper for producing a bunch of max-sized low-S signatures (eg 72 bytes)\n+bool CWallet::DummySignTx(CMutableTransaction &txNew, const std::vector<CTxOut> &txouts) const\n+{\n+    // Fill in dummy signatures for fee calculation.\n+    int nIn = 0;\n+    for (const auto& txout : txouts)\n+    {\n+        if (!DummySignInput(txNew.vin[nIn], txout)) {\n+            return false;\n+        }\n+\n+        nIn++;\n+    }\n+    return true;\n+}\n+\n+int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet)\n+{\n+    std::vector<CTxOut> txouts;\n+    // Look up the inputs.  We should have already checked that this transaction\n+    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n+    // wallet, with a valid index into the vout array, and the ability to sign.\n+    for (auto& input : tx.vin) {\n+        const auto mi = wallet->mapWallet.find(input.prevout.hash);\n+        if (mi == wallet->mapWallet.end()) {\n+            return -1;\n+        }\n+        assert(input.prevout.n < mi->second.tx->vout.size());\n+        txouts.emplace_back(mi->second.tx->vout[input.prevout.n]);\n+    }\n+    return CalculateMaximumSignedTxSize(tx, wallet, txouts);\n+}\n+\n+// txouts needs to be in the order of tx.vin\n+int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, const std::vector<CTxOut>& txouts)\n+{\n+    CMutableTransaction txNew(tx);\n+    if (!wallet->DummySignTx(txNew, txouts)) {\n+        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n+        // implies that we can sign for every input.\n+        return -1;\n+    }\n+    return GetVirtualTransactionSize(txNew);\n+}\n+\n+int CalculateMaximumSignedInputSize(const CTxOut& txout, const CWallet* wallet)\n+{\n+    CMutableTransaction txn;\n+    txn.vin.push_back(CTxIn(COutPoint()));\n+    if (!wallet->DummySignInput(txn.vin[0], txout)) {\n+        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n+        // implies that we can sign for every input.\n+        return -1;\n+    }\n+    return GetVirtualTransactionInputSize(txn.vin[0]);\n+}\n+\n void CWalletTx::GetAmounts(std::list<COutputEntry>& listReceived,\n                            std::list<COutputEntry>& listSent, CAmount& nFee, std::string& strSentAccount, const isminefilter& filter) const\n {\n@@ -2752,7 +2825,7 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n     assert(txNew.nLockTime < LOCKTIME_THRESHOLD);\n     FeeCalculation feeCalc;\n     CAmount nFeeNeeded;\n-    unsigned int nBytes;\n+    int nBytes;\n     {\n         std::set<CInputCoin> setCoins;\n         LOCK2(cs_main, cs_wallet);\n@@ -2903,20 +2976,12 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n                     txNew.vin.push_back(CTxIn(coin.outpoint,CScript(),\n                                               nSequence));\n \n-                // Fill in dummy signatures for fee calculation.\n-                if (!DummySignTx(txNew, setCoins)) {\n+                nBytes = CalculateMaximumSignedTxSize(txNew, this);\n+                if (nBytes < 0) {\n                     strFailReason = _(\"Signing transaction failed\");\n                     return false;\n                 }\n \n-                nBytes = GetVirtualTransactionSize(txNew);\n-\n-                // Remove scriptSigs to eliminate the fee calculation dummy signatures\n-                for (auto& vin : txNew.vin) {\n-                    vin.scriptSig = CScript();\n-                    vin.scriptWitness.SetNull();\n-                }\n-\n                 nFeeNeeded = GetMinimumFee(nBytes, coin_control, ::mempool, ::feeEstimator, &feeCalc);\n                 if (feeCalc.reason == FeeReason::FALLBACK && !g_wallet_allow_fallback_fee) {\n                     // eventually allow a fallback fee"
      },
      {
        "sha": "fbb87353c1b493b7f3038862ae9bca8504c91008",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 32,
        "deletions": 28,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/12ec29d3bb0d46c61712210fe9bb96a0d543204a/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/12ec29d3bb0d46c61712210fe9bb96a0d543204a/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=12ec29d3bb0d46c61712210fe9bb96a0d543204a",
        "patch": "@@ -269,6 +269,9 @@ class CMerkleTx\n     bool IsCoinBase() const { return tx->IsCoinBase(); }\n };\n \n+//Get the marginal bytes of spending the specified output\n+int CalculateMaximumSignedInputSize(const CTxOut& txout, const CWallet* pwallet);\n+\n /** \n  * A transaction with a bunch of additional info that only the owner cares about.\n  * It includes any unrecorded transactions needed to link it back to the block chain.\n@@ -462,6 +465,12 @@ class CWalletTx : public CMerkleTx\n     CAmount GetAvailableWatchOnlyCredit(const bool fUseCache=true) const;\n     CAmount GetChange() const;\n \n+    // Get the marginal bytes if spending the specified output from this transaction\n+    int GetSpendSize(unsigned int out) const\n+    {\n+        return CalculateMaximumSignedInputSize(tx->vout[out], pwallet);\n+    }\n+\n     void GetAmounts(std::list<COutputEntry>& listReceived,\n                     std::list<COutputEntry>& listSent, CAmount& nFee, std::string& strSentAccount, const isminefilter& filter) const;\n \n@@ -525,6 +534,9 @@ class COutput\n     int i;\n     int nDepth;\n \n+    /** Pre-computed estimated size of this output as a fully-signed input in a transaction. Can be -1 if it could not be calculated */\n+    int nInputBytes;\n+\n     /** Whether we have the private keys to spend this output */\n     bool fSpendable;\n \n@@ -540,7 +552,12 @@ class COutput\n \n     COutput(const CWalletTx *txIn, int iIn, int nDepthIn, bool fSpendableIn, bool fSolvableIn, bool fSafeIn)\n     {\n-        tx = txIn; i = iIn; nDepth = nDepthIn; fSpendable = fSpendableIn; fSolvable = fSolvableIn; fSafe = fSafeIn;\n+        tx = txIn; i = iIn; nDepth = nDepthIn; fSpendable = fSpendableIn; fSolvable = fSolvableIn; fSafe = fSafeIn; nInputBytes = -1;\n+        // If known and signable by the given wallet, compute nInputBytes\n+        // Failure will keep this value -1\n+        if (fSpendable && tx) {\n+            nInputBytes = tx->GetSpendSize(i);\n+        }\n     }\n \n     std::string ToString() const;\n@@ -981,8 +998,14 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     void ListAccountCreditDebit(const std::string& strAccount, std::list<CAccountingEntry>& entries);\n     bool AddAccountingEntry(const CAccountingEntry&);\n     bool AddAccountingEntry(const CAccountingEntry&, CWalletDB *pwalletdb);\n-    template <typename ContainerType>\n-    bool DummySignTx(CMutableTransaction &txNew, const ContainerType &coins) const;\n+    bool DummySignTx(CMutableTransaction &txNew, const std::set<CTxOut> &txouts) const\n+    {\n+        std::vector<CTxOut> v_txouts(txouts.size());\n+        std::copy(txouts.begin(), txouts.end(), v_txouts.begin());\n+        return DummySignTx(txNew, v_txouts);\n+    }\n+    bool DummySignTx(CMutableTransaction &txNew, const std::vector<CTxOut> &txouts) const;\n+    bool DummySignInput(CTxIn &tx_in, const CTxOut &txout) const;\n \n     static CFeeRate minTxFee;\n     static CFeeRate fallbackFee;\n@@ -1227,31 +1250,6 @@ class CAccount\n     }\n };\n \n-// Helper for producing a bunch of max-sized low-S signatures (eg 72 bytes)\n-// ContainerType is meant to hold pair<CWalletTx *, int>, and be iterable\n-// so that each entry corresponds to each vIn, in order.\n-template <typename ContainerType>\n-bool CWallet::DummySignTx(CMutableTransaction &txNew, const ContainerType &coins) const\n-{\n-    // Fill in dummy signatures for fee calculation.\n-    int nIn = 0;\n-    for (const auto& coin : coins)\n-    {\n-        const CScript& scriptPubKey = coin.txout.scriptPubKey;\n-        SignatureData sigdata;\n-\n-        if (!ProduceSignature(DummySignatureCreator(this), scriptPubKey, sigdata))\n-        {\n-            return false;\n-        } else {\n-            UpdateTransaction(txNew, nIn, sigdata);\n-        }\n-\n-        nIn++;\n-    }\n-    return true;\n-}\n-\n OutputType ParseOutputType(const std::string& str, OutputType default_type = OUTPUT_TYPE_DEFAULT);\n const std::string& FormatOutputType(OutputType type);\n \n@@ -1299,4 +1297,10 @@ class WalletRescanReserver\n     }\n };\n \n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet);\n+int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *wallet, const std::vector<CTxOut>& txouts);\n #endif // BITCOIN_WALLET_WALLET_H"
      }
    ]
  },
  {
    "sha": "f84fed8eb6a8518a54a997044e55332dd37e223d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmODRmZWQ4ZWI2YTg1MThhNTRhOTk3MDQ0ZTU1MzMyZGQzN2UyMjNk",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-10T01:51:22Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-10T02:15:40Z"
      },
      "message": "Store effective value, fee, and long term fee in CInputCoin\n\nHave CInputCOin store effective value information. This includes the effective\nvalue itself, the fee, and the long term fee for the input",
      "tree": {
        "sha": "265072d9414c7fc3e7acd4db9f3496b5c1669211",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/265072d9414c7fc3e7acd4db9f3496b5c1669211"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f84fed8eb6a8518a54a997044e55332dd37e223d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f84fed8eb6a8518a54a997044e55332dd37e223d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f84fed8eb6a8518a54a997044e55332dd37e223d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f84fed8eb6a8518a54a997044e55332dd37e223d/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "12ec29d3bb0d46c61712210fe9bb96a0d543204a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/12ec29d3bb0d46c61712210fe9bb96a0d543204a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/12ec29d3bb0d46c61712210fe9bb96a0d543204a"
      }
    ],
    "stats": {
      "total": 3,
      "additions": 3,
      "deletions": 0
    },
    "files": [
      {
        "sha": "89dc4f399ca53d45d30a5904da1d327bbb01eb57",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f84fed8eb6a8518a54a997044e55332dd37e223d/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f84fed8eb6a8518a54a997044e55332dd37e223d/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=f84fed8eb6a8518a54a997044e55332dd37e223d",
        "patch": "@@ -513,6 +513,9 @@ class CInputCoin {\n \n     COutPoint outpoint;\n     CTxOut txout;\n+    CAmount effective_value;\n+    CAmount fee = 0;\n+    CAmount long_term_fee = 0;\n \n     bool operator<(const CInputCoin& rhs) const {\n         return outpoint < rhs.outpoint;"
      }
    ]
  },
  {
    "sha": "0185939be6f7c5554b864e33657ce610fd434e18",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMTg1OTM5YmU2ZjdjNTU1NGI4NjRlMzM2NTdjZTYxMGZkNDM0ZTE4",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-05T21:29:37Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-13T16:39:17Z"
      },
      "message": "Implement Branch and Bound coin selection in a new file\n\nCreate a new file for coin selection logic and implement the BnB algorithm in it.",
      "tree": {
        "sha": "638323d15efce6c4768ea6c79d41ab3cd1a50925",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/638323d15efce6c4768ea6c79d41ab3cd1a50925"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0185939be6f7c5554b864e33657ce610fd434e18",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0185939be6f7c5554b864e33657ce610fd434e18",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0185939be6f7c5554b864e33657ce610fd434e18",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0185939be6f7c5554b864e33657ce610fd434e18/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f84fed8eb6a8518a54a997044e55332dd37e223d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f84fed8eb6a8518a54a997044e55332dd37e223d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f84fed8eb6a8518a54a997044e55332dd37e223d"
      }
    ],
    "stats": {
      "total": 184,
      "additions": 184,
      "deletions": 0
    },
    "files": [
      {
        "sha": "7c2fe56d9d43594cce4aec2e2e996225f281c433",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0185939be6f7c5554b864e33657ce610fd434e18/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0185939be6f7c5554b864e33657ce610fd434e18/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=0185939be6f7c5554b864e33657ce610fd434e18",
        "patch": "@@ -172,6 +172,7 @@ BITCOIN_CORE_H = \\\n   wallet/wallet.h \\\n   wallet/walletdb.h \\\n   wallet/walletutil.h \\\n+  wallet/coinselection.h \\\n   warnings.h \\\n   zmq/zmqabstractnotifier.h \\\n   zmq/zmqconfig.h\\\n@@ -253,6 +254,7 @@ libbitcoin_wallet_a_SOURCES = \\\n   wallet/wallet.cpp \\\n   wallet/walletdb.cpp \\\n   wallet/walletutil.cpp \\\n+  wallet/coinselection.cpp \\\n   $(BITCOIN_CORE_H)\n \n # crypto primitives library"
      },
      {
        "sha": "05bcdc12bb93d3bcbaec09fb94c228e9690018ab",
        "filename": "src/wallet/coinselection.cpp",
        "status": "added",
        "additions": 165,
        "deletions": 0,
        "changes": 165,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0185939be6f7c5554b864e33657ce610fd434e18/src/wallet/coinselection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0185939be6f7c5554b864e33657ce610fd434e18/src/wallet/coinselection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.cpp?ref=0185939be6f7c5554b864e33657ce610fd434e18",
        "patch": "@@ -0,0 +1,165 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <wallet/coinselection.h>\n+#include <util.h>\n+#include <utilmoneystr.h>\n+\n+// Descending order comparator\n+struct {\n+    bool operator()(const CInputCoin& a, const CInputCoin& b) const\n+    {\n+        return a.effective_value > b.effective_value;\n+    }\n+} descending;\n+\n+/*\n+ * This is the Branch and Bound Coin Selection algorithm designed by Murch. It searches for an input\n+ * set that can pay for the spending target and does not exceed the spending target by more than the\n+ * cost of creating and spending a change output. The algorithm uses a depth-first search on a binary\n+ * tree. In the binary tree, each node corresponds to the inclusion or the omission of a UTXO. UTXOs\n+ * are sorted by their effective values and the trees is explored deterministically per the inclusion\n+ * branch first. At each node, the algorithm checks whether the selection is within the target range.\n+ * While the selection has not reached the target range, more UTXOs are included. When a selection's\n+ * value exceeds the target range, the complete subtree deriving from this selection can be omitted.\n+ * At that point, the last included UTXO is deselected and the corresponding omission branch explored\n+ * instead. The search ends after the complete tree has been searched or after a limited number of tries.\n+ *\n+ * The search continues to search for better solutions after one solution has been found. The best\n+ * solution is chosen by minimizing the waste metric. The waste metric is defined as the cost to\n+ * spend the current inputs at the given fee rate minus the long term expected cost to spend the\n+ * inputs, plus the amount the selection exceeds the spending target:\n+ *\n+ * waste = selectionTotal - target + inputs \u00d7 (currentFeeRate - longTermFeeRate)\n+ *\n+ * The algorithm uses two additional optimizations. A lookahead keeps track of the total value of\n+ * the unexplored UTXOs. A subtree is not explored if the lookahead indicates that the target range\n+ * cannot be reached. Further, it is unnecessary to test equivalent combinations. This allows us\n+ * to skip testing the inclusion of UTXOs that match the effective value and waste of an omitted\n+ * predecessor.\n+ *\n+ * The Branch and Bound algorithm is described in detail in Murch's Master Thesis:\n+ * https://murch.one/wp-content/uploads/2016/11/erhardt2016coinselection.pdf\n+ *\n+ * @param const std::vector<CInputCoin>& utxo_pool The set of UTXOs that we are choosing from.\n+ *        These UTXOs will be sorted in descending order by effective value and the CInputCoins'\n+ *        values are their effective values.\n+ * @param const CAmount& target_value This is the value that we want to select. It is the lower\n+ *        bound of the range.\n+ * @param const CAmount& cost_of_change This is the cost of creating and spending a change output.\n+ *        This plus target_value is the upper bound of the range.\n+ * @param std::set<CInputCoin>& out_set -> This is an output parameter for the set of CInputCoins\n+ *        that have been selected.\n+ * @param CAmount& value_ret -> This is an output parameter for the total value of the CInputCoins\n+ *        that were selected.\n+ * @param CAmount not_input_fees -> The fees that need to be paid for the outputs and fixed size\n+ *        overhead (version, locktime, marker and flag)\n+ */\n+\n+static const size_t TOTAL_TRIES = 100000;\n+\n+bool SelectCoinsBnB(std::vector<CInputCoin>& utxo_pool, const CAmount& target_value, const CAmount& cost_of_change, std::set<CInputCoin>& out_set, CAmount& value_ret, CAmount not_input_fees)\n+{\n+    out_set.clear();\n+    CAmount curr_value = 0;\n+\n+    std::vector<bool> curr_selection; // select the utxo at this index\n+    curr_selection.reserve(utxo_pool.size());\n+    CAmount actual_target = not_input_fees + target_value;\n+\n+    // Calculate curr_available_value\n+    CAmount curr_available_value = 0;\n+    for (const CInputCoin& utxo : utxo_pool) {\n+        // Assert that this utxo is not negative. It should never be negative, effective value calculation should have removed it\n+        assert(utxo.effective_value > 0);\n+        curr_available_value += utxo.effective_value;\n+    }\n+    if (curr_available_value < actual_target) {\n+        return false;\n+    }\n+\n+    // Sort the utxo_pool\n+    std::sort(utxo_pool.begin(), utxo_pool.end(), descending);\n+\n+    CAmount curr_waste = 0;\n+    std::vector<bool> best_selection;\n+    CAmount best_waste = MAX_MONEY;\n+\n+    // Depth First search loop for choosing the UTXOs\n+    for (size_t i = 0; i < TOTAL_TRIES; ++i) {\n+        // Conditions for starting a backtrack\n+        bool backtrack = false;\n+        if (curr_value + curr_available_value < actual_target ||                // Cannot possibly reach target with the amount remaining in the curr_available_value.\n+            curr_value > actual_target + cost_of_change ||    // Selected value is out of range, go back and try other branch\n+            (curr_waste > best_waste && (utxo_pool.at(0).fee - utxo_pool.at(0).long_term_fee) > 0)) { // Don't select things which we know will be more wasteful if the waste is increasing\n+            backtrack = true;\n+        } else if (curr_value >= actual_target) {       // Selected value is within range\n+            curr_waste += (curr_value - actual_target); // This is the excess value which is added to the waste for the below comparison\n+            // Adding another UTXO after this check could bring the waste down if the long term fee is higher than the current fee.\n+            // However we are not going to explore that because this optimization for the waste is only done when we have hit our target\n+            // value. Adding any more UTXOs will be just burning the UTXO; it will go entirely to fees. Thus we aren't going to\n+            // explore any more UTXOs to avoid burning money like that.\n+            if (curr_waste <= best_waste) {\n+                best_selection = curr_selection;\n+                best_selection.resize(utxo_pool.size());\n+                best_waste = curr_waste;\n+            }\n+            curr_waste -= (curr_value - actual_target); // Remove the excess value as we will be selecting different coins now\n+            backtrack = true;\n+        }\n+\n+        // Backtracking, moving backwards\n+        if (backtrack) {\n+            // Walk backwards to find the last included UTXO that still needs to have its omission branch traversed.\n+            while (!curr_selection.empty() && !curr_selection.back()) {\n+                curr_selection.pop_back();\n+                curr_available_value += utxo_pool.at(curr_selection.size()).effective_value;\n+            };\n+\n+            if (curr_selection.empty()) { // We have walked back to the first utxo and no branch is untraversed. All solutions searched\n+                break;\n+            }\n+\n+            // Output was included on previous iterations, try excluding now.\n+            curr_selection.back() = false;\n+            CInputCoin& utxo = utxo_pool.at(curr_selection.size() - 1);\n+            curr_value -= utxo.effective_value;\n+            curr_waste -= utxo.fee - utxo.long_term_fee;\n+        } else { // Moving forwards, continuing down this branch\n+            CInputCoin& utxo = utxo_pool.at(curr_selection.size());\n+\n+            // Remove this utxo from the curr_available_value utxo amount\n+            curr_available_value -= utxo.effective_value;\n+\n+            // Avoid searching a branch if the previous UTXO has the same value and same waste and was excluded. Since the ratio of fee to\n+            // long term fee is the same, we only need to check if one of those values match in order to know that the waste is the same.\n+            if (!curr_selection.empty() && !curr_selection.back() &&\n+                utxo.effective_value == utxo_pool.at(curr_selection.size() - 1).effective_value &&\n+                utxo.fee == utxo_pool.at(curr_selection.size() - 1).fee) {\n+                curr_selection.push_back(false);\n+            } else {\n+                // Inclusion branch first (Largest First Exploration)\n+                curr_selection.push_back(true);\n+                curr_value += utxo.effective_value;\n+                curr_waste += utxo.fee - utxo.long_term_fee;\n+            }\n+        }\n+    }\n+\n+    // Check for solution\n+    if (best_selection.empty()) {\n+        return false;\n+    }\n+\n+    // Set output set\n+    value_ret = 0;\n+    for (size_t i = 0; i < best_selection.size(); ++i) {\n+        if (best_selection.at(i)) {\n+            out_set.insert(utxo_pool.at(i));\n+            value_ret += utxo_pool.at(i).txout.nValue;\n+        }\n+    }\n+\n+    return true;\n+}"
      },
      {
        "sha": "a98f1cc7c1b0b015ae87d3c8d1d10b494fb90f0f",
        "filename": "src/wallet/coinselection.h",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0185939be6f7c5554b864e33657ce610fd434e18/src/wallet/coinselection.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0185939be6f7c5554b864e33657ce610fd434e18/src/wallet/coinselection.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.h?ref=0185939be6f7c5554b864e33657ce610fd434e18",
        "patch": "@@ -0,0 +1,15 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_COINSELECTION_H\n+#define BITCOIN_COINSELECTION_H\n+\n+#include <amount.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <wallet/wallet.h>\n+\n+bool SelectCoinsBnB(std::vector<CInputCoin>& utxo_pool, const CAmount& target_value, const CAmount& cost_of_change, std::set<CInputCoin>& out_set, CAmount& value_ret, CAmount not_input_fees);\n+\n+#endif // BITCOIN_COINSELECTION_H"
      },
      {
        "sha": "e797a63dd831296d3f9fa38c4ba114380a7033ac",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0185939be6f7c5554b864e33657ce610fd434e18/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0185939be6f7c5554b864e33657ce610fd434e18/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=0185939be6f7c5554b864e33657ce610fd434e18",
        "patch": "@@ -8,6 +8,7 @@\n #include <checkpoints.h>\n #include <chain.h>\n #include <wallet/coincontrol.h>\n+#include <wallet/coinselection.h>\n #include <consensus/consensus.h>\n #include <consensus/validation.h>\n #include <fs.h>"
      },
      {
        "sha": "a2fab3c88ea154788ce709ac32dc0196d1c1ca21",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0185939be6f7c5554b864e33657ce610fd434e18/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0185939be6f7c5554b864e33657ce610fd434e18/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=0185939be6f7c5554b864e33657ce610fd434e18",
        "patch": "@@ -509,6 +509,7 @@ class CInputCoin {\n \n         outpoint = COutPoint(walletTx->GetHash(), i);\n         txout = walletTx->tx->vout[i];\n+        effective_value = txout.nValue;\n     }\n \n     COutPoint outpoint;"
      }
    ]
  },
  {
    "sha": "ce7435cf1ef36109595be9a3a3955afdff1d63e4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjZTc0MzVjZjFlZjM2MTA5NTk1YmU5YTNhMzk1NWFmZGZmMWQ2M2U0",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-09T22:21:27Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-13T16:39:26Z"
      },
      "message": "Move output eligibility to a separate function",
      "tree": {
        "sha": "ad93d328576d4d2f2f8e3bcbf46483bf4100e6ec",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ad93d328576d4d2f2f8e3bcbf46483bf4100e6ec"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ce7435cf1ef36109595be9a3a3955afdff1d63e4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ce7435cf1ef36109595be9a3a3955afdff1d63e4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ce7435cf1ef36109595be9a3a3955afdff1d63e4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ce7435cf1ef36109595be9a3a3955afdff1d63e4/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0185939be6f7c5554b864e33657ce610fd434e18",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0185939be6f7c5554b864e33657ce610fd434e18",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0185939be6f7c5554b864e33657ce610fd434e18"
      }
    ],
    "stats": {
      "total": 31,
      "additions": 19,
      "deletions": 12
    },
    "files": [
      {
        "sha": "639e00f2bc2e2365602fba356b6b8b01b8326dbd",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 12,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ce7435cf1ef36109595be9a3a3955afdff1d63e4/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ce7435cf1ef36109595be9a3a3955afdff1d63e4/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=ce7435cf1ef36109595be9a3a3955afdff1d63e4",
        "patch": "@@ -2484,6 +2484,20 @@ static void ApproximateBestSubset(const std::vector<CInputCoin>& vValue, const C\n     }\n }\n \n+bool CWallet::OutputEligibleForSpending(const COutput& output, const int nConfMine, const int nConfTheirs, const uint64_t nMaxAncestors) const\n+{\n+    if (!output.fSpendable)\n+        return false;\n+\n+    if (output.nDepth < (output.tx->IsFromMe(ISMINE_ALL) ? nConfMine : nConfTheirs))\n+        return false;\n+\n+    if (!mempool.TransactionWithinChainLimit(output.tx->GetHash(), nMaxAncestors))\n+        return false;\n+\n+    return true;\n+}\n+\n bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const int nConfMine, const int nConfTheirs, const uint64_t nMaxAncestors, std::vector<COutput> vCoins,\n                                  std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet) const\n {\n@@ -2499,20 +2513,10 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const int nConfMin\n \n     for (const COutput &output : vCoins)\n     {\n-        if (!output.fSpendable)\n-            continue;\n-\n-        const CWalletTx *pcoin = output.tx;\n-\n-        if (output.nDepth < (pcoin->IsFromMe(ISMINE_ALL) ? nConfMine : nConfTheirs))\n-            continue;\n-\n-        if (!mempool.TransactionWithinChainLimit(pcoin->GetHash(), nMaxAncestors))\n+        if (!OutputEligibleForSpending(output, nConfMine, nConfTheirs, nMaxAncestors))\n             continue;\n \n-        int i = output.i;\n-\n-        CInputCoin coin = CInputCoin(pcoin, i);\n+        CInputCoin coin = CInputCoin(output.tx, output.i);\n \n         if (coin.txout.nValue == nTargetValue)\n         {"
      },
      {
        "sha": "d2389ae2b6d6cf32a3105a82264dc8a5ce64d976",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ce7435cf1ef36109595be9a3a3955afdff1d63e4/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ce7435cf1ef36109595be9a3a3955afdff1d63e4/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=ce7435cf1ef36109595be9a3a3955afdff1d63e4",
        "patch": "@@ -1190,6 +1190,9 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n      * This function will automatically add the necessary scripts to the wallet.\n      */\n     CTxDestination AddAndGetDestinationForScript(const CScript& script, OutputType);\n+\n+    /** Whether a given output is spendable by this wallet */\n+    bool OutputEligibleForSpending(const COutput& output, const int nConfMine, const int nConfTheirs, const uint64_t nMaxAncestors) const;\n };\n \n /** A key allocated from the key pool. */"
      }
    ]
  },
  {
    "sha": "7d77eb1a5b980a7d56acbf0b3861434c5e195c54",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZDc3ZWIxYTViOTgwYTdkNTZhY2JmMGIzODYxNDM0YzVlMTk1YzU0",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-10T04:11:20Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-13T16:39:26Z"
      },
      "message": "Use a struct for output eligibility\n\nInstead of specifying 3 parameters, use a struct for those parameters\nin order to reduce the number of arguments to SelectCoinsMinConf.",
      "tree": {
        "sha": "ab32d4cda804cf9d24c6c115dd5db04b921903e5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ab32d4cda804cf9d24c6c115dd5db04b921903e5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7d77eb1a5b980a7d56acbf0b3861434c5e195c54",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d77eb1a5b980a7d56acbf0b3861434c5e195c54",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7d77eb1a5b980a7d56acbf0b3861434c5e195c54",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d77eb1a5b980a7d56acbf0b3861434c5e195c54/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ce7435cf1ef36109595be9a3a3955afdff1d63e4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ce7435cf1ef36109595be9a3a3955afdff1d63e4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ce7435cf1ef36109595be9a3a3955afdff1d63e4"
      }
    ],
    "stats": {
      "total": 117,
      "additions": 65,
      "deletions": 52
    },
    "files": [
      {
        "sha": "55ff7b61f1b7bea4ae6a17dc0e3c1a4fc6ff3f74",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d77eb1a5b980a7d56acbf0b3861434c5e195c54/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d77eb1a5b980a7d56acbf0b3861434c5e195c54/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=7d77eb1a5b980a7d56acbf0b3861434c5e195c54",
        "patch": "@@ -44,7 +44,8 @@ static void CoinSelection(benchmark::State& state)\n \n         std::set<CInputCoin> setCoinsRet;\n         CAmount nValueRet;\n-        bool success = wallet.SelectCoinsMinConf(1003 * COIN, 1, 6, 0, vCoins, setCoinsRet, nValueRet);\n+        CoinEligibilityFilter filter_standard(1, 6, 0);\n+        bool success = wallet.SelectCoinsMinConf(1003 * COIN, filter_standard, vCoins, setCoinsRet, nValueRet);\n         assert(success);\n         assert(nValueRet == 1003 * COIN);\n         assert(setCoinsRet.size() == 2);"
      },
      {
        "sha": "003d182077f999aa23ee117f604e3691941b9e5c",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 37,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d77eb1a5b980a7d56acbf0b3861434c5e195c54/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d77eb1a5b980a7d56acbf0b3861434c5e195c54/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=7d77eb1a5b980a7d56acbf0b3861434c5e195c54",
        "patch": "@@ -74,6 +74,10 @@ static bool equal_sets(CoinSet a, CoinSet b)\n     return ret.first == a.end() && ret.second == b.end();\n }\n \n+CoinEligibilityFilter filter_standard(1, 6, 0);\n+CoinEligibilityFilter filter_confirmed(1, 1, 0);\n+CoinEligibilityFilter filter_standard_extra(6, 6, 0);\n+\n BOOST_AUTO_TEST_CASE(coin_selection_tests)\n {\n     CoinSet setCoinsRet, setCoinsRet2;\n@@ -87,24 +91,24 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n         empty_wallet();\n \n         // with an empty wallet we can't even pay one cent\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, 1, 6, 0, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet));\n \n         add_coin(1*CENT, 4);        // add a new 1 cent coin\n \n         // with a new 1 cent coin, we still can't find a mature 1 cent\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, 1, 6, 0, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet));\n \n         // but we can find a new 1 cent\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 1 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 1 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);\n \n         add_coin(2*CENT);           // add a mature 2 cent coin\n \n         // we can't make 3 cents of mature coins\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 3 * CENT, 1, 6, 0, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 3 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet));\n \n         // we can make 3 cents of new coins\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 3 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 3 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 3 * CENT);\n \n         add_coin(5*CENT);           // add a mature 5 cent coin,\n@@ -114,33 +118,33 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n         // now we have new: 1+10=11 (of which 10 was self-sent), and mature: 2+5+20=27.  total = 38\n \n         // we can't make 38 cents only if we disallow new coins:\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf(38 * CENT, 1, 6, 0, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf(38 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet));\n         // we can't even make 37 cents if we don't allow new coins even if they're from us\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf(38 * CENT, 6, 6, 0, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf(38 * CENT, filter_standard_extra, vCoins, setCoinsRet, nValueRet));\n         // but we can make 37 cents if we accept new coins from ourself\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(37 * CENT, 1, 6, 0, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(37 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 37 * CENT);\n         // and we can make 38 cents if we accept all new coins\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(38 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(38 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 38 * CENT);\n \n         // try making 34 cents from 1,2,5,10,20 - we can't do it exactly\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(34 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(34 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 35 * CENT);       // but 35 cents is closest\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);     // the best should be 20+10+5.  it's incredibly unlikely the 1 or 2 got included (but possible)\n \n         // when we try making 7 cents, the smaller coins (1,2,5) are enough.  We should see just 2+5\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 7 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 7 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 7 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n \n         // when we try making 8 cents, the smaller coins (1,2,5) are exactly enough.\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 8 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 8 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK(nValueRet == 8 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n \n         // when we try making 9 cents, no subset of smaller coins is enough, and we get the next bigger coin (10)\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 9 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 9 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 10 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n@@ -154,30 +158,30 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n         add_coin(30*CENT); // now we have 6+7+8+20+30 = 71 cents total\n \n         // check that we have 71 and not 72\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(71 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf(72 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(71 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf(72 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n \n         // now try making 16 cents.  the best smaller coins can do is 6+7+8 = 21; not as good at the next biggest coin, 20\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 20 * CENT); // we should get 20 in one coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n         add_coin( 5*CENT); // now we have 5+6+7+8+20+30 = 75 cents total\n \n         // now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, better than the next biggest coin, 20\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 18 * CENT); // we should get 18 in 3 coins\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n \n         add_coin( 18*CENT); // now we have 5+6+7+8+18+20+30\n \n         // and now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, the same as the next biggest coin, 18\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 18 * CENT);  // we should get 18 in 1 coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U); // because in the event of a tie, the biggest coin wins\n \n         // now try making 11 cents.  we should get 5+6\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(11 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(11 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 11 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n \n@@ -186,11 +190,11 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n         add_coin( 2*COIN);\n         add_coin( 3*COIN);\n         add_coin( 4*COIN); // now we have 5+6+7+8+18+20+30+100+200+300+400 = 1094 cents\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(95 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(95 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 1 * COIN);  // we should get 1 BTC in 1 coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(195 * CENT, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(195 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 2 * COIN);  // we should get 2 BTC in 1 coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n@@ -205,22 +209,22 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n \n         // try making 1 * MIN_CHANGE from the 1.5 * MIN_CHANGE\n         // we'll get change smaller than MIN_CHANGE whatever happens, so can expect MIN_CHANGE exactly\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(MIN_CHANGE, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE);\n \n         // but if we add a bigger coin, small change is avoided\n         add_coin(1111*MIN_CHANGE);\n \n         // try making 1 from 0.1 + 0.2 + 0.3 + 0.4 + 0.5 + 1111 = 1112.5\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 1 * MIN_CHANGE); // we should get the exact amount\n \n         // if we add more small coins:\n         add_coin(MIN_CHANGE * 6 / 10);\n         add_coin(MIN_CHANGE * 7 / 10);\n \n         // and try again to make 1.0 * MIN_CHANGE\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 1 * MIN_CHANGE); // we should get the exact amount\n \n         // run the 'mtgox' test (see http://blockexplorer.com/tx/29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf)\n@@ -229,7 +233,7 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n         for (int j = 0; j < 20; j++)\n             add_coin(50000 * COIN);\n \n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(500000 * COIN, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(500000 * COIN, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 500000 * COIN); // we should get the exact amount\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 10U); // in ten coins\n \n@@ -242,7 +246,7 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n         add_coin(MIN_CHANGE * 6 / 10);\n         add_coin(MIN_CHANGE * 7 / 10);\n         add_coin(1111 * MIN_CHANGE);\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 1111 * MIN_CHANGE); // we get the bigger coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n@@ -252,7 +256,7 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n         add_coin(MIN_CHANGE * 6 / 10);\n         add_coin(MIN_CHANGE * 8 / 10);\n         add_coin(1111 * MIN_CHANGE);\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(MIN_CHANGE, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE);   // we should get the exact amount\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U); // in two coins 0.4+0.6\n \n@@ -263,12 +267,12 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n         add_coin(MIN_CHANGE * 100);\n \n         // trying to make 100.01 from these three coins\n-        BOOST_CHECK(testWallet.SelectCoinsMinConf(MIN_CHANGE * 10001 / 100, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(testWallet.SelectCoinsMinConf(MIN_CHANGE * 10001 / 100, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE * 10105 / 100); // we should get all coins\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n \n         // but if we try to make 99.9, we should take the bigger of the two small coins to avoid small change\n-        BOOST_CHECK(testWallet.SelectCoinsMinConf(MIN_CHANGE * 9990 / 100, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(testWallet.SelectCoinsMinConf(MIN_CHANGE * 9990 / 100, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 101 * MIN_CHANGE);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n \n@@ -278,7 +282,7 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n              // Create 676 inputs (=  (old MAX_STANDARD_TX_SIZE == 100000)  / 148 bytes per input)\n              for (uint16_t j = 0; j < 676; j++)\n                  add_coin(amt);\n-             BOOST_CHECK(testWallet.SelectCoinsMinConf(2000, 1, 1, 0, vCoins, setCoinsRet, nValueRet));\n+             BOOST_CHECK(testWallet.SelectCoinsMinConf(2000, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n              if (amt - 2000 < MIN_CHANGE) {\n                  // needs more than one input:\n                  uint16_t returnSize = std::ceil((2000.0 + MIN_CHANGE)/amt);\n@@ -300,17 +304,17 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n \n             // picking 50 from 100 coins doesn't depend on the shuffle,\n             // but does depend on randomness in the stochastic approximation code\n-            BOOST_CHECK(testWallet.SelectCoinsMinConf(50 * COIN, 1, 6, 0, vCoins, setCoinsRet , nValueRet));\n-            BOOST_CHECK(testWallet.SelectCoinsMinConf(50 * COIN, 1, 6, 0, vCoins, setCoinsRet2, nValueRet));\n+            BOOST_CHECK(testWallet.SelectCoinsMinConf(50 * COIN, filter_standard, vCoins, setCoinsRet , nValueRet));\n+            BOOST_CHECK(testWallet.SelectCoinsMinConf(50 * COIN, filter_standard, vCoins, setCoinsRet2, nValueRet));\n             BOOST_CHECK(!equal_sets(setCoinsRet, setCoinsRet2));\n \n             int fails = 0;\n             for (int j = 0; j < RANDOM_REPEATS; j++)\n             {\n                 // selecting 1 from 100 identical coins depends on the shuffle; this test will fail 1% of the time\n                 // run the test RANDOM_REPEATS times and only complain if all of them fail\n-                BOOST_CHECK(testWallet.SelectCoinsMinConf(COIN, 1, 6, 0, vCoins, setCoinsRet , nValueRet));\n-                BOOST_CHECK(testWallet.SelectCoinsMinConf(COIN, 1, 6, 0, vCoins, setCoinsRet2, nValueRet));\n+                BOOST_CHECK(testWallet.SelectCoinsMinConf(COIN, filter_standard, vCoins, setCoinsRet , nValueRet));\n+                BOOST_CHECK(testWallet.SelectCoinsMinConf(COIN, filter_standard, vCoins, setCoinsRet2, nValueRet));\n                 if (equal_sets(setCoinsRet, setCoinsRet2))\n                     fails++;\n             }\n@@ -330,8 +334,8 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n             {\n                 // selecting 1 from 100 identical coins depends on the shuffle; this test will fail 1% of the time\n                 // run the test RANDOM_REPEATS times and only complain if all of them fail\n-                BOOST_CHECK(testWallet.SelectCoinsMinConf(90*CENT, 1, 6, 0, vCoins, setCoinsRet , nValueRet));\n-                BOOST_CHECK(testWallet.SelectCoinsMinConf(90*CENT, 1, 6, 0, vCoins, setCoinsRet2, nValueRet));\n+                BOOST_CHECK(testWallet.SelectCoinsMinConf(90*CENT, filter_standard, vCoins, setCoinsRet , nValueRet));\n+                BOOST_CHECK(testWallet.SelectCoinsMinConf(90*CENT, filter_standard, vCoins, setCoinsRet2, nValueRet));\n                 if (equal_sets(setCoinsRet, setCoinsRet2))\n                     fails++;\n             }\n@@ -355,7 +359,7 @@ BOOST_AUTO_TEST_CASE(ApproximateBestSubset)\n         add_coin(1000 * COIN);\n     add_coin(3 * COIN);\n \n-    BOOST_CHECK(testWallet.SelectCoinsMinConf(1003 * COIN, 1, 6, 0, vCoins, setCoinsRet, nValueRet));\n+    BOOST_CHECK(testWallet.SelectCoinsMinConf(1003 * COIN, filter_standard, vCoins, setCoinsRet, nValueRet));\n     BOOST_CHECK_EQUAL(nValueRet, 1003 * COIN);\n     BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n "
      },
      {
        "sha": "fe9e803d283454eb0f2816c50608a68228cc1b0a",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d77eb1a5b980a7d56acbf0b3861434c5e195c54/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d77eb1a5b980a7d56acbf0b3861434c5e195c54/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=7d77eb1a5b980a7d56acbf0b3861434c5e195c54",
        "patch": "@@ -2484,21 +2484,21 @@ static void ApproximateBestSubset(const std::vector<CInputCoin>& vValue, const C\n     }\n }\n \n-bool CWallet::OutputEligibleForSpending(const COutput& output, const int nConfMine, const int nConfTheirs, const uint64_t nMaxAncestors) const\n+bool CWallet::OutputEligibleForSpending(const COutput& output, const CoinEligibilityFilter& eligibilty_filter) const\n {\n     if (!output.fSpendable)\n         return false;\n \n-    if (output.nDepth < (output.tx->IsFromMe(ISMINE_ALL) ? nConfMine : nConfTheirs))\n+    if (output.nDepth < (output.tx->IsFromMe(ISMINE_ALL) ? eligibilty_filter.conf_mine : eligibilty_filter.conf_theirs))\n         return false;\n \n-    if (!mempool.TransactionWithinChainLimit(output.tx->GetHash(), nMaxAncestors))\n+    if (!mempool.TransactionWithinChainLimit(output.tx->GetHash(), eligibilty_filter.max_ancestors))\n         return false;\n \n     return true;\n }\n \n-bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const int nConfMine, const int nConfTheirs, const uint64_t nMaxAncestors, std::vector<COutput> vCoins,\n+bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibilty_filter, std::vector<COutput> vCoins,\n                                  std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet) const\n {\n     setCoinsRet.clear();\n@@ -2513,7 +2513,7 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const int nConfMin\n \n     for (const COutput &output : vCoins)\n     {\n-        if (!OutputEligibleForSpending(output, nConfMine, nConfTheirs, nMaxAncestors))\n+        if (!OutputEligibleForSpending(output, eligibilty_filter))\n             continue;\n \n         CInputCoin coin = CInputCoin(output.tx, output.i);\n@@ -2646,13 +2646,13 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n     bool fRejectLongChains = gArgs.GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS);\n \n     bool res = nTargetValue <= nValueFromPresetInputs ||\n-        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 1, 6, 0, vCoins, setCoinsRet, nValueRet) ||\n-        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 1, 1, 0, vCoins, setCoinsRet, nValueRet) ||\n-        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 0, 1, 2, vCoins, setCoinsRet, nValueRet)) ||\n-        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 0, 1, std::min((size_t)4, nMaxChainLength/3), vCoins, setCoinsRet, nValueRet)) ||\n-        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 0, 1, nMaxChainLength/2, vCoins, setCoinsRet, nValueRet)) ||\n-        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 0, 1, nMaxChainLength, vCoins, setCoinsRet, nValueRet)) ||\n-        (bSpendZeroConfChange && !fRejectLongChains && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 0, 1, std::numeric_limits<uint64_t>::max(), vCoins, setCoinsRet, nValueRet));\n+        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 6, 0), vCoins, setCoinsRet, nValueRet) ||\n+        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 1, 0), vCoins, setCoinsRet, nValueRet) ||\n+        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, 2), vCoins, setCoinsRet, nValueRet)) ||\n+        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::min((size_t)4, nMaxChainLength/3)), vCoins, setCoinsRet, nValueRet)) ||\n+        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, nMaxChainLength/2), vCoins, setCoinsRet, nValueRet)) ||\n+        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, nMaxChainLength), vCoins, setCoinsRet, nValueRet)) ||\n+        (bSpendZeroConfChange && !fRejectLongChains && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max()), vCoins, setCoinsRet, nValueRet));\n \n     // because SelectCoinsMinConf clears the setCoinsRet, we now add the possible inputs to the coinset\n     setCoinsRet.insert(setPresetCoins.begin(), setPresetCoins.end());"
      },
      {
        "sha": "4f195b2bcd64789b600769be922ef7b07931398a",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 10,
        "deletions": 2,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d77eb1a5b980a7d56acbf0b3861434c5e195c54/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d77eb1a5b980a7d56acbf0b3861434c5e195c54/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=7d77eb1a5b980a7d56acbf0b3861434c5e195c54",
        "patch": "@@ -679,6 +679,14 @@ class CAccountingEntry\n     std::vector<char> _ssExtra;\n };\n \n+struct CoinEligibilityFilter\n+{\n+    const int conf_mine;\n+    const int conf_theirs;\n+    const uint64_t max_ancestors;\n+\n+    CoinEligibilityFilter(int conf_mine, int conf_theirs, uint64_t max_ancestors) : conf_mine(conf_mine), conf_theirs(conf_theirs), max_ancestors(max_ancestors) {}\n+};\n \n class WalletRescanReserver; //forward declarations for ScanForWalletTransactions/RescanFromTime\n /** \n@@ -881,7 +889,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n      * completion the coin set and corresponding actual target value is\n      * assembled\n      */\n-    bool SelectCoinsMinConf(const CAmount& nTargetValue, int nConfMine, int nConfTheirs, uint64_t nMaxAncestors, std::vector<COutput> vCoins, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet) const;\n+    bool SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibilty_filter, std::vector<COutput> vCoins, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet) const;\n \n     bool IsSpent(const uint256& hash, unsigned int n) const;\n \n@@ -1192,7 +1200,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     CTxDestination AddAndGetDestinationForScript(const CScript& script, OutputType);\n \n     /** Whether a given output is spendable by this wallet */\n-    bool OutputEligibleForSpending(const COutput& output, const int nConfMine, const int nConfTheirs, const uint64_t nMaxAncestors) const;\n+    bool OutputEligibleForSpending(const COutput& output, const CoinEligibilityFilter& eligibilty_filter) const;\n };\n \n /** A key allocated from the key pool. */"
      }
    ]
  },
  {
    "sha": "4b2716da46e96c45206db869b83c28c5fc7889f4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0YjI3MTZkYTQ2ZTk2YzQ1MjA2ZGI4NjliODNjMjhjNWZjNzg4OWY0",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-07T17:18:37Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-13T16:39:26Z"
      },
      "message": "Remove coinselection.h -> wallet.h circular dependency\n\nChanges CInputCoin to coinselection and to use CTransactionRef in\norder to avoid a circular dependency. Also moves other coin selection\nspecific variables out of wallet.h to coinselectoin.h",
      "tree": {
        "sha": "79b43ea07fa17c0a2a56a3fcea75cd93aae510ba",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/79b43ea07fa17c0a2a56a3fcea75cd93aae510ba"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4b2716da46e96c45206db869b83c28c5fc7889f4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4b2716da46e96c45206db869b83c28c5fc7889f4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4b2716da46e96c45206db869b83c28c5fc7889f4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4b2716da46e96c45206db869b83c28c5fc7889f4/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7d77eb1a5b980a7d56acbf0b3861434c5e195c54",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d77eb1a5b980a7d56acbf0b3861434c5e195c54",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7d77eb1a5b980a7d56acbf0b3861434c5e195c54"
      }
    ],
    "stats": {
      "total": 86,
      "additions": 43,
      "deletions": 43
    },
    "files": [
      {
        "sha": "bbfa08a242390a08e17ebab5bce61f347315968c",
        "filename": "src/wallet/coinselection.h",
        "status": "modified",
        "additions": 38,
        "deletions": 1,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4b2716da46e96c45206db869b83c28c5fc7889f4/src/wallet/coinselection.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4b2716da46e96c45206db869b83c28c5fc7889f4/src/wallet/coinselection.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.h?ref=4b2716da46e96c45206db869b83c28c5fc7889f4",
        "patch": "@@ -8,7 +8,44 @@\n #include <amount.h>\n #include <primitives/transaction.h>\n #include <random.h>\n-#include <wallet/wallet.h>\n+\n+//! target minimum change amount\n+static const CAmount MIN_CHANGE = CENT;\n+//! final minimum change amount after paying for fees\n+static const CAmount MIN_FINAL_CHANGE = MIN_CHANGE/2;\n+\n+class CInputCoin {\n+public:\n+    CInputCoin(const CTransactionRef& tx, unsigned int i)\n+    {\n+        if (!tx)\n+            throw std::invalid_argument(\"tx should not be null\");\n+        if (i >= tx->vout.size())\n+            throw std::out_of_range(\"The output index is out of range\");\n+\n+        outpoint = COutPoint(tx->GetHash(), i);\n+        txout = tx->vout[i];\n+        effective_value = txout.nValue;\n+    }\n+\n+    COutPoint outpoint;\n+    CTxOut txout;\n+    CAmount effective_value;\n+    CAmount fee = 0;\n+    CAmount long_term_fee = 0;\n+\n+    bool operator<(const CInputCoin& rhs) const {\n+        return outpoint < rhs.outpoint;\n+    }\n+\n+    bool operator!=(const CInputCoin& rhs) const {\n+        return outpoint != rhs.outpoint;\n+    }\n+\n+    bool operator==(const CInputCoin& rhs) const {\n+        return outpoint == rhs.outpoint;\n+    }\n+};\n \n bool SelectCoinsBnB(std::vector<CInputCoin>& utxo_pool, const CAmount& target_value, const CAmount& cost_of_change, std::set<CInputCoin>& out_set, CAmount& value_ret, CAmount not_input_fees);\n "
      },
      {
        "sha": "fbd515c47f10729646ea47fd34265ef30297b4a0",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4b2716da46e96c45206db869b83c28c5fc7889f4/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4b2716da46e96c45206db869b83c28c5fc7889f4/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=4b2716da46e96c45206db869b83c28c5fc7889f4",
        "patch": "@@ -2516,7 +2516,7 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n         if (!OutputEligibleForSpending(output, eligibilty_filter))\n             continue;\n \n-        CInputCoin coin = CInputCoin(output.tx, output.i);\n+        CInputCoin coin = CInputCoin(output.tx->tx, output.i);\n \n         if (coin.txout.nValue == nTargetValue)\n         {\n@@ -2606,7 +2606,7 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n             if (!out.fSpendable)\n                  continue;\n             nValueRet += out.tx->tx->vout[out.i].nValue;\n-            setCoinsRet.insert(CInputCoin(out.tx, out.i));\n+            setCoinsRet.insert(CInputCoin(out.tx->tx, out.i));\n         }\n         return (nValueRet >= nTargetValue);\n     }\n@@ -2628,15 +2628,15 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n             if (pcoin->tx->vout.size() <= outpoint.n)\n                 return false;\n             nValueFromPresetInputs += pcoin->tx->vout[outpoint.n].nValue;\n-            setPresetCoins.insert(CInputCoin(pcoin, outpoint.n));\n+            setPresetCoins.insert(CInputCoin(pcoin->tx, outpoint.n));\n         } else\n             return false; // TODO: Allow non-wallet inputs\n     }\n \n     // remove preset inputs from vCoins\n     for (std::vector<COutput>::iterator it = vCoins.begin(); it != vCoins.end() && coinControl && coinControl->HasSelected();)\n     {\n-        if (setPresetCoins.count(CInputCoin(it->tx, it->i)))\n+        if (setPresetCoins.count(CInputCoin(it->tx->tx, it->i)))\n             it = vCoins.erase(it);\n         else\n             ++it;"
      },
      {
        "sha": "8f518bae6373c21f024bda8daa518015c2474081",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 38,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4b2716da46e96c45206db869b83c28c5fc7889f4/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4b2716da46e96c45206db869b83c28c5fc7889f4/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=4b2716da46e96c45206db869b83c28c5fc7889f4",
        "patch": "@@ -17,6 +17,7 @@\n #include <script/sign.h>\n #include <util.h>\n #include <wallet/crypter.h>\n+#include <wallet/coinselection.h>\n #include <wallet/walletdb.h>\n #include <wallet/rpcwallet.h>\n \n@@ -53,10 +54,6 @@ static const CAmount DEFAULT_DISCARD_FEE = 10000;\n static const CAmount DEFAULT_TRANSACTION_MINFEE = 1000;\n //! minimum recommended increment for BIP 125 replacement txs\n static const CAmount WALLET_INCREMENTAL_RELAY_FEE = 5000;\n-//! target minimum change amount\n-static const CAmount MIN_CHANGE = CENT;\n-//! final minimum change amount after paying for fees\n-static const CAmount MIN_FINAL_CHANGE = MIN_CHANGE/2;\n //! Default for -spendzeroconfchange\n static const bool DEFAULT_SPEND_ZEROCONF_CHANGE = true;\n //! Default for -walletrejectlongchains\n@@ -497,40 +494,6 @@ class CWalletTx : public CMerkleTx\n     std::set<uint256> GetConflicts() const;\n };\n \n-\n-class CInputCoin {\n-public:\n-    CInputCoin(const CWalletTx* walletTx, unsigned int i)\n-    {\n-        if (!walletTx)\n-            throw std::invalid_argument(\"walletTx should not be null\");\n-        if (i >= walletTx->tx->vout.size())\n-            throw std::out_of_range(\"The output index is out of range\");\n-\n-        outpoint = COutPoint(walletTx->GetHash(), i);\n-        txout = walletTx->tx->vout[i];\n-        effective_value = txout.nValue;\n-    }\n-\n-    COutPoint outpoint;\n-    CTxOut txout;\n-    CAmount effective_value;\n-    CAmount fee = 0;\n-    CAmount long_term_fee = 0;\n-\n-    bool operator<(const CInputCoin& rhs) const {\n-        return outpoint < rhs.outpoint;\n-    }\n-\n-    bool operator!=(const CInputCoin& rhs) const {\n-        return outpoint != rhs.outpoint;\n-    }\n-\n-    bool operator==(const CInputCoin& rhs) const {\n-        return outpoint == rhs.outpoint;\n-    }\n-};\n-\n class COutput\n {\n public:"
      }
    ]
  },
  {
    "sha": "4566ab75f277612425337bf7786c1d3a410d894a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NTY2YWI3NWYyNzc2MTI0MjUzMzdiZjc3ODZjMWQzYTQxMGQ4OTRh",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-10T04:18:18Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-13T16:39:26Z"
      },
      "message": "Add tests for the Branch and Bound algorithm",
      "tree": {
        "sha": "7883d3133cbd810b8105fbd2dcbaccf17af056bb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7883d3133cbd810b8105fbd2dcbaccf17af056bb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4566ab75f277612425337bf7786c1d3a410d894a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4566ab75f277612425337bf7786c1d3a410d894a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4566ab75f277612425337bf7786c1d3a410d894a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4566ab75f277612425337bf7786c1d3a410d894a/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4b2716da46e96c45206db869b83c28c5fc7889f4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4b2716da46e96c45206db869b83c28c5fc7889f4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4b2716da46e96c45206db869b83c28c5fc7889f4"
      }
    ],
    "stats": {
      "total": 174,
      "additions": 173,
      "deletions": 1
    },
    "files": [
      {
        "sha": "4d0819ab796acf02527c17759d87f14d4467455f",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4566ab75f277612425337bf7786c1d3a410d894a/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4566ab75f277612425337bf7786c1d3a410d894a/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=4566ab75f277612425337bf7786c1d3a410d894a",
        "patch": "@@ -94,7 +94,8 @@ BITCOIN_TESTS += \\\n   wallet/test/wallet_test_fixture.h \\\n   wallet/test/accounting_tests.cpp \\\n   wallet/test/wallet_tests.cpp \\\n-  wallet/test/crypto_tests.cpp\n+  wallet/test/crypto_tests.cpp \\\n+  wallet/test/coinselector_tests.cpp\n endif\n \n test_test_bitcoin_SOURCES = $(BITCOIN_TESTS) $(JSON_TEST_FILES) $(RAW_TEST_FILES)"
      },
      {
        "sha": "d4f432e361f92e6bd94eecf055a50517f02afec1",
        "filename": "src/wallet/test/coinselector_tests.cpp",
        "status": "added",
        "additions": 171,
        "deletions": 0,
        "changes": 171,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4566ab75f277612425337bf7786c1d3a410d894a/src/wallet/test/coinselector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4566ab75f277612425337bf7786c1d3a410d894a/src/wallet/test/coinselector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/coinselector_tests.cpp?ref=4566ab75f277612425337bf7786c1d3a410d894a",
        "patch": "@@ -0,0 +1,171 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"wallet/wallet.h\"\n+#include \"wallet/coinselection.h\"\n+#include \"amount.h\"\n+#include \"primitives/transaction.h\"\n+#include \"random.h\"\n+#include \"test/test_bitcoin.h\"\n+#include \"wallet/test/wallet_test_fixture.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+#include <random>\n+\n+BOOST_FIXTURE_TEST_SUITE(coin_selection_tests, WalletTestingSetup)\n+\n+typedef std::set<CInputCoin> CoinSet;\n+\n+static std::vector<COutput> vCoins;\n+static const CWallet testWallet(\"dummy\", CWalletDBWrapper::CreateDummy());\n+\n+static void add_coin(const CAmount& nValue, int nInput, std::vector<CInputCoin>& set)\n+{\n+    CMutableTransaction tx;\n+    tx.vout.resize(nInput + 1);\n+    tx.vout[nInput].nValue = nValue;\n+    set.emplace_back(MakeTransactionRef(tx), nInput);\n+}\n+\n+static void add_coin(const CAmount& nValue, int nInput, CoinSet& set)\n+{\n+    CMutableTransaction tx;\n+    tx.vout.resize(nInput + 1);\n+    tx.vout[nInput].nValue = nValue;\n+    set.emplace(MakeTransactionRef(tx), nInput);\n+}\n+\n+static bool equal_sets(CoinSet a, CoinSet b)\n+{\n+    std::pair<CoinSet::iterator, CoinSet::iterator> ret = mismatch(a.begin(), a.end(), b.begin());\n+    return ret.first == a.end() && ret.second == b.end();\n+}\n+\n+static CAmount make_hard_case(int utxos, std::vector<CInputCoin>& utxo_pool)\n+{\n+    utxo_pool.clear();\n+    CAmount target = 0;\n+    for (int i = 0; i < utxos; ++i) {\n+        target += (CAmount)1 << (utxos+i);\n+        add_coin((CAmount)1 << (utxos+i), 2*i, utxo_pool);\n+        add_coin(((CAmount)1 << (utxos+i)) + ((CAmount)1 << (utxos-1-i)), 2*i + 1, utxo_pool);\n+    }\n+    return target;\n+}\n+\n+// Branch and bound coin selection tests\n+BOOST_AUTO_TEST_CASE(bnb_search_test)\n+{\n+\n+    LOCK(testWallet.cs_wallet);\n+\n+    // Setup\n+    std::vector<CInputCoin> utxo_pool;\n+    CoinSet selection;\n+    CoinSet actual_selection;\n+    CAmount value_ret = 0;\n+    CAmount not_input_fees = 0;\n+\n+    /////////////////////////\n+    // Known Outcome tests //\n+    /////////////////////////\n+    BOOST_TEST_MESSAGE(\"Testing known outcomes\");\n+\n+    // Empty utxo pool\n+    BOOST_CHECK(!SelectCoinsBnB(utxo_pool, 1 * CENT, 0.5 * CENT, selection, value_ret, not_input_fees));\n+    selection.clear();\n+\n+    // Add utxos\n+    add_coin(1 * CENT, 1, utxo_pool);\n+    add_coin(2 * CENT, 2, utxo_pool);\n+    add_coin(3 * CENT, 3, utxo_pool);\n+    add_coin(4 * CENT, 4, utxo_pool);\n+\n+    // Select 1 Cent\n+    add_coin(1 * CENT, 1, actual_selection);\n+    BOOST_CHECK(SelectCoinsBnB(utxo_pool, 1 * CENT, 0.5 * CENT, selection, value_ret, not_input_fees));\n+    BOOST_CHECK(equal_sets(selection, actual_selection));\n+    actual_selection.clear();\n+    selection.clear();\n+\n+    // Select 2 Cent\n+    add_coin(2 * CENT, 2, actual_selection);\n+    BOOST_CHECK(SelectCoinsBnB(utxo_pool, 2 * CENT, 0.5 * CENT, selection, value_ret, not_input_fees));\n+    BOOST_CHECK(equal_sets(selection, actual_selection));\n+    actual_selection.clear();\n+    selection.clear();\n+\n+    // Select 5 Cent\n+    add_coin(3 * CENT, 3, actual_selection);\n+    add_coin(2 * CENT, 2, actual_selection);\n+    BOOST_CHECK(SelectCoinsBnB(utxo_pool, 5 * CENT, 0.5 * CENT, selection, value_ret, not_input_fees));\n+    BOOST_CHECK(equal_sets(selection, actual_selection));\n+    actual_selection.clear();\n+    selection.clear();\n+\n+    // Select 11 Cent, not possible\n+    BOOST_CHECK(!SelectCoinsBnB(utxo_pool, 11 * CENT, 0.5 * CENT, selection, value_ret, not_input_fees));\n+    actual_selection.clear();\n+    selection.clear();\n+\n+    // Select 10 Cent\n+    add_coin(5 * CENT, 5, utxo_pool);\n+    add_coin(4 * CENT, 4, actual_selection);\n+    add_coin(3 * CENT, 3, actual_selection);\n+    add_coin(2 * CENT, 2, actual_selection);\n+    add_coin(1 * CENT, 1, actual_selection);\n+    BOOST_CHECK(SelectCoinsBnB(utxo_pool, 10 * CENT, 0.5 * CENT, selection, value_ret, not_input_fees));\n+    BOOST_CHECK(equal_sets(selection, actual_selection));\n+    actual_selection.clear();\n+    selection.clear();\n+\n+    // Negative effective value\n+    // Select 10 Cent but have 1 Cent not be possible because too small\n+    add_coin(5 * CENT, 5, actual_selection);\n+    add_coin(3 * CENT, 3, actual_selection);\n+    add_coin(2 * CENT, 2, actual_selection);\n+    BOOST_CHECK(SelectCoinsBnB(utxo_pool, 10 * CENT, 5000, selection, value_ret, not_input_fees));\n+\n+    // Select 0.25 Cent, not possible\n+    BOOST_CHECK(!SelectCoinsBnB(utxo_pool, 0.25 * CENT, 0.5 * CENT, selection, value_ret, not_input_fees));\n+    actual_selection.clear();\n+    selection.clear();\n+\n+    // Iteration exhaustion test\n+    CAmount target = make_hard_case(17, utxo_pool);\n+    BOOST_CHECK(!SelectCoinsBnB(utxo_pool, target, 0, selection, value_ret, not_input_fees)); // Should exhaust\n+    target = make_hard_case(14, utxo_pool);\n+    BOOST_CHECK(SelectCoinsBnB(utxo_pool, target, 0, selection, value_ret, not_input_fees)); // Should not exhaust\n+\n+    // Test same value early bailout optimization\n+    add_coin(7 * CENT, 7, actual_selection);\n+    add_coin(7 * CENT, 7, actual_selection);\n+    add_coin(7 * CENT, 7, actual_selection);\n+    add_coin(7 * CENT, 7, actual_selection);\n+    add_coin(2 * CENT, 7, actual_selection);\n+    add_coin(7 * CENT, 7, utxo_pool);\n+    add_coin(7 * CENT, 7, utxo_pool);\n+    add_coin(7 * CENT, 7, utxo_pool);\n+    add_coin(7 * CENT, 7, utxo_pool);\n+    add_coin(2 * CENT, 7, utxo_pool);\n+    for (int i = 0; i < 50000; ++i) {\n+        add_coin(5 * CENT, 7, utxo_pool);\n+    }\n+    BOOST_CHECK(SelectCoinsBnB(utxo_pool, 30 * CENT, 5000, selection, value_ret, not_input_fees));\n+\n+    ////////////////////\n+    // Behavior tests //\n+    ////////////////////\n+    // Select 1 Cent with pool of only greater than 5 Cent\n+    utxo_pool.clear();\n+    for (int i = 5; i <= 20; ++i) {\n+        add_coin(i * CENT, i, utxo_pool);\n+    }\n+    // Run 100 times, to make sure it is never finding a solution\n+    for (int i = 0; i < 100; ++i) {\n+        BOOST_CHECK(!SelectCoinsBnB(utxo_pool, 1 * CENT, 2 * CENT, selection, value_ret, not_input_fees));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "fb716f7b25927e377f73b904a88ab67facfe3e55",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYjcxNmY3YjI1OTI3ZTM3N2Y3M2I5MDRhODhhYjY3ZmFjZmUzZTU1",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-10T03:51:39Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-13T16:39:26Z"
      },
      "message": "Move current coin selection algorithm to coinselection.{cpp,h}\n\nMoves the current coin selection algorithm out of SelectCoinsMinConf\nand puts it in coinselection.{cpp,h}. The new function, KnapsackSolver,\ninstead of taking a vector of COutputs, will take a vector of CInputCoins\nthat is prepared by SelectCoinsMinConf.",
      "tree": {
        "sha": "80dd5c4d3fb2c13031611f2ab5f11e23c8510e45",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/80dd5c4d3fb2c13031611f2ab5f11e23c8510e45"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fb716f7b25927e377f73b904a88ab67facfe3e55",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fb716f7b25927e377f73b904a88ab67facfe3e55",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fb716f7b25927e377f73b904a88ab67facfe3e55",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fb716f7b25927e377f73b904a88ab67facfe3e55/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4566ab75f277612425337bf7786c1d3a410d894a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4566ab75f277612425337bf7786c1d3a410d894a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4566ab75f277612425337bf7786c1d3a410d894a"
      }
    ],
    "stats": {
      "total": 267,
      "additions": 140,
      "deletions": 127
    },
    "files": [
      {
        "sha": "8596ad2adc5df9390c60150c043ff78c0799d850",
        "filename": "src/wallet/coinselection.cpp",
        "status": "modified",
        "additions": 135,
        "deletions": 0,
        "changes": 135,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fb716f7b25927e377f73b904a88ab67facfe3e55/src/wallet/coinselection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fb716f7b25927e377f73b904a88ab67facfe3e55/src/wallet/coinselection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.cpp?ref=fb716f7b25927e377f73b904a88ab67facfe3e55",
        "patch": "@@ -163,3 +163,138 @@ bool SelectCoinsBnB(std::vector<CInputCoin>& utxo_pool, const CAmount& target_va\n \n     return true;\n }\n+\n+static void ApproximateBestSubset(const std::vector<CInputCoin>& vValue, const CAmount& nTotalLower, const CAmount& nTargetValue,\n+                                  std::vector<char>& vfBest, CAmount& nBest, int iterations = 1000)\n+{\n+    std::vector<char> vfIncluded;\n+\n+    vfBest.assign(vValue.size(), true);\n+    nBest = nTotalLower;\n+\n+    FastRandomContext insecure_rand;\n+\n+    for (int nRep = 0; nRep < iterations && nBest != nTargetValue; nRep++)\n+    {\n+        vfIncluded.assign(vValue.size(), false);\n+        CAmount nTotal = 0;\n+        bool fReachedTarget = false;\n+        for (int nPass = 0; nPass < 2 && !fReachedTarget; nPass++)\n+        {\n+            for (unsigned int i = 0; i < vValue.size(); i++)\n+            {\n+                //The solver here uses a randomized algorithm,\n+                //the randomness serves no real security purpose but is just\n+                //needed to prevent degenerate behavior and it is important\n+                //that the rng is fast. We do not use a constant random sequence,\n+                //because there may be some privacy improvement by making\n+                //the selection random.\n+                if (nPass == 0 ? insecure_rand.randbool() : !vfIncluded[i])\n+                {\n+                    nTotal += vValue[i].txout.nValue;\n+                    vfIncluded[i] = true;\n+                    if (nTotal >= nTargetValue)\n+                    {\n+                        fReachedTarget = true;\n+                        if (nTotal < nBest)\n+                        {\n+                            nBest = nTotal;\n+                            vfBest = vfIncluded;\n+                        }\n+                        nTotal -= vValue[i].txout.nValue;\n+                        vfIncluded[i] = false;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+bool KnapsackSolver(const CAmount& nTargetValue, std::vector<CInputCoin>& vCoins, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet)\n+{\n+    setCoinsRet.clear();\n+    nValueRet = 0;\n+\n+    // List of values less than target\n+    boost::optional<CInputCoin> coinLowestLarger;\n+    std::vector<CInputCoin> vValue;\n+    CAmount nTotalLower = 0;\n+\n+    random_shuffle(vCoins.begin(), vCoins.end(), GetRandInt);\n+\n+    for (const CInputCoin &coin : vCoins)\n+    {\n+        if (coin.txout.nValue == nTargetValue)\n+        {\n+            setCoinsRet.insert(coin);\n+            nValueRet += coin.txout.nValue;\n+            return true;\n+        }\n+        else if (coin.txout.nValue < nTargetValue + MIN_CHANGE)\n+        {\n+            vValue.push_back(coin);\n+            nTotalLower += coin.txout.nValue;\n+        }\n+        else if (!coinLowestLarger || coin.txout.nValue < coinLowestLarger->txout.nValue)\n+        {\n+            coinLowestLarger = coin;\n+        }\n+    }\n+\n+    if (nTotalLower == nTargetValue)\n+    {\n+        for (const auto& input : vValue)\n+        {\n+            setCoinsRet.insert(input);\n+            nValueRet += input.txout.nValue;\n+        }\n+        return true;\n+    }\n+\n+    if (nTotalLower < nTargetValue)\n+    {\n+        if (!coinLowestLarger)\n+            return false;\n+        setCoinsRet.insert(coinLowestLarger.get());\n+        nValueRet += coinLowestLarger->txout.nValue;\n+        return true;\n+    }\n+\n+    // Solve subset sum by stochastic approximation\n+    std::sort(vValue.begin(), vValue.end(), descending);\n+    std::vector<char> vfBest;\n+    CAmount nBest;\n+\n+    ApproximateBestSubset(vValue, nTotalLower, nTargetValue, vfBest, nBest);\n+    if (nBest != nTargetValue && nTotalLower >= nTargetValue + MIN_CHANGE)\n+        ApproximateBestSubset(vValue, nTotalLower, nTargetValue + MIN_CHANGE, vfBest, nBest);\n+\n+    // If we have a bigger coin and (either the stochastic approximation didn't find a good solution,\n+    //                                   or the next bigger coin is closer), return the bigger coin\n+    if (coinLowestLarger &&\n+        ((nBest != nTargetValue && nBest < nTargetValue + MIN_CHANGE) || coinLowestLarger->txout.nValue <= nBest))\n+    {\n+        setCoinsRet.insert(coinLowestLarger.get());\n+        nValueRet += coinLowestLarger->txout.nValue;\n+    }\n+    else {\n+        for (unsigned int i = 0; i < vValue.size(); i++)\n+            if (vfBest[i])\n+            {\n+                setCoinsRet.insert(vValue[i]);\n+                nValueRet += vValue[i].txout.nValue;\n+            }\n+\n+        if (LogAcceptCategory(BCLog::SELECTCOINS)) {\n+            LogPrint(BCLog::SELECTCOINS, \"SelectCoins() best subset: \");\n+            for (unsigned int i = 0; i < vValue.size(); i++) {\n+                if (vfBest[i]) {\n+                    LogPrint(BCLog::SELECTCOINS, \"%s \", FormatMoney(vValue[i].txout.nValue));\n+                }\n+            }\n+            LogPrint(BCLog::SELECTCOINS, \"total %s\\n\", FormatMoney(nBest));\n+        }\n+    }\n+\n+    return true;\n+}"
      },
      {
        "sha": "4d1a43bc17c8aa54b3b5a365e2bf9acfa80647b9",
        "filename": "src/wallet/coinselection.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fb716f7b25927e377f73b904a88ab67facfe3e55/src/wallet/coinselection.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fb716f7b25927e377f73b904a88ab67facfe3e55/src/wallet/coinselection.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.h?ref=fb716f7b25927e377f73b904a88ab67facfe3e55",
        "patch": "@@ -49,4 +49,6 @@ class CInputCoin {\n \n bool SelectCoinsBnB(std::vector<CInputCoin>& utxo_pool, const CAmount& target_value, const CAmount& cost_of_change, std::set<CInputCoin>& out_set, CAmount& value_ret, CAmount not_input_fees);\n \n+// Original coin selection algorithm as a fallback\n+bool KnapsackSolver(const CAmount& nTargetValue, std::vector<CInputCoin>& vCoins, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet);\n #endif // BITCOIN_COINSELECTION_H"
      },
      {
        "sha": "ae882d7bd2e02072cf54c82270d745603b89452d",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 127,
        "changes": 130,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fb716f7b25927e377f73b904a88ab67facfe3e55/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fb716f7b25927e377f73b904a88ab67facfe3e55/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=fb716f7b25927e377f73b904a88ab67facfe3e55",
        "patch": "@@ -2438,52 +2438,6 @@ const CTxOut& CWallet::FindNonChangeParentOutput(const CTransaction& tx, int out\n     return ptx->vout[n];\n }\n \n-static void ApproximateBestSubset(const std::vector<CInputCoin>& vValue, const CAmount& nTotalLower, const CAmount& nTargetValue,\n-                                  std::vector<char>& vfBest, CAmount& nBest, int iterations = 1000)\n-{\n-    std::vector<char> vfIncluded;\n-\n-    vfBest.assign(vValue.size(), true);\n-    nBest = nTotalLower;\n-\n-    FastRandomContext insecure_rand;\n-\n-    for (int nRep = 0; nRep < iterations && nBest != nTargetValue; nRep++)\n-    {\n-        vfIncluded.assign(vValue.size(), false);\n-        CAmount nTotal = 0;\n-        bool fReachedTarget = false;\n-        for (int nPass = 0; nPass < 2 && !fReachedTarget; nPass++)\n-        {\n-            for (unsigned int i = 0; i < vValue.size(); i++)\n-            {\n-                //The solver here uses a randomized algorithm,\n-                //the randomness serves no real security purpose but is just\n-                //needed to prevent degenerate behavior and it is important\n-                //that the rng is fast. We do not use a constant random sequence,\n-                //because there may be some privacy improvement by making\n-                //the selection random.\n-                if (nPass == 0 ? insecure_rand.randbool() : !vfIncluded[i])\n-                {\n-                    nTotal += vValue[i].txout.nValue;\n-                    vfIncluded[i] = true;\n-                    if (nTotal >= nTargetValue)\n-                    {\n-                        fReachedTarget = true;\n-                        if (nTotal < nBest)\n-                        {\n-                            nBest = nTotal;\n-                            vfBest = vfIncluded;\n-                        }\n-                        nTotal -= vValue[i].txout.nValue;\n-                        vfIncluded[i] = false;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n bool CWallet::OutputEligibleForSpending(const COutput& output, const CoinEligibilityFilter& eligibilty_filter) const\n {\n     if (!output.fSpendable)\n@@ -2504,94 +2458,16 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibil\n     setCoinsRet.clear();\n     nValueRet = 0;\n \n-    // List of values less than target\n-    boost::optional<CInputCoin> coinLowestLarger;\n-    std::vector<CInputCoin> vValue;\n-    CAmount nTotalLower = 0;\n-\n-    random_shuffle(vCoins.begin(), vCoins.end(), GetRandInt);\n-\n+    std::vector<CInputCoin> utxo_pool;\n     for (const COutput &output : vCoins)\n     {\n         if (!OutputEligibleForSpending(output, eligibilty_filter))\n             continue;\n \n         CInputCoin coin = CInputCoin(output.tx->tx, output.i);\n-\n-        if (coin.txout.nValue == nTargetValue)\n-        {\n-            setCoinsRet.insert(coin);\n-            nValueRet += coin.txout.nValue;\n-            return true;\n-        }\n-        else if (coin.txout.nValue < nTargetValue + MIN_CHANGE)\n-        {\n-            vValue.push_back(coin);\n-            nTotalLower += coin.txout.nValue;\n-        }\n-        else if (!coinLowestLarger || coin.txout.nValue < coinLowestLarger->txout.nValue)\n-        {\n-            coinLowestLarger = coin;\n-        }\n-    }\n-\n-    if (nTotalLower == nTargetValue)\n-    {\n-        for (const auto& input : vValue)\n-        {\n-            setCoinsRet.insert(input);\n-            nValueRet += input.txout.nValue;\n-        }\n-        return true;\n-    }\n-\n-    if (nTotalLower < nTargetValue)\n-    {\n-        if (!coinLowestLarger)\n-            return false;\n-        setCoinsRet.insert(coinLowestLarger.get());\n-        nValueRet += coinLowestLarger->txout.nValue;\n-        return true;\n-    }\n-\n-    // Solve subset sum by stochastic approximation\n-    std::sort(vValue.begin(), vValue.end(), CompareValueOnly());\n-    std::reverse(vValue.begin(), vValue.end());\n-    std::vector<char> vfBest;\n-    CAmount nBest;\n-\n-    ApproximateBestSubset(vValue, nTotalLower, nTargetValue, vfBest, nBest);\n-    if (nBest != nTargetValue && nTotalLower >= nTargetValue + MIN_CHANGE)\n-        ApproximateBestSubset(vValue, nTotalLower, nTargetValue + MIN_CHANGE, vfBest, nBest);\n-\n-    // If we have a bigger coin and (either the stochastic approximation didn't find a good solution,\n-    //                                   or the next bigger coin is closer), return the bigger coin\n-    if (coinLowestLarger &&\n-        ((nBest != nTargetValue && nBest < nTargetValue + MIN_CHANGE) || coinLowestLarger->txout.nValue <= nBest))\n-    {\n-        setCoinsRet.insert(coinLowestLarger.get());\n-        nValueRet += coinLowestLarger->txout.nValue;\n+        utxo_pool.push_back(coin);\n     }\n-    else {\n-        for (unsigned int i = 0; i < vValue.size(); i++)\n-            if (vfBest[i])\n-            {\n-                setCoinsRet.insert(vValue[i]);\n-                nValueRet += vValue[i].txout.nValue;\n-            }\n-\n-        if (LogAcceptCategory(BCLog::SELECTCOINS)) {\n-            LogPrint(BCLog::SELECTCOINS, \"SelectCoins() best subset: \");\n-            for (unsigned int i = 0; i < vValue.size(); i++) {\n-                if (vfBest[i]) {\n-                    LogPrint(BCLog::SELECTCOINS, \"%s \", FormatMoney(vValue[i].txout.nValue));\n-                }\n-            }\n-            LogPrint(BCLog::SELECTCOINS, \"total %s\\n\", FormatMoney(nBest));\n-        }\n-    }\n-\n-    return true;\n+    return KnapsackSolver(nTargetValue, utxo_pool, setCoinsRet, nValueRet);\n }\n \n bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CCoinControl* coinControl) const"
      }
    ]
  },
  {
    "sha": "cd927ff3283fc23a5f42c178e10bcaf5409bb7ea",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjZDkyN2ZmMzI4M2ZjMjNhNWY0MmMxNzhlMTBiY2FmNTQwOWJiN2Vh",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-10T05:39:29Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-13T16:39:26Z"
      },
      "message": "Move original knapsack solver tests to coinselector_tests.cpp",
      "tree": {
        "sha": "8b33dfcc7ad4775ffd8e7d9dd852acbe901667bc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8b33dfcc7ad4775ffd8e7d9dd852acbe901667bc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cd927ff3283fc23a5f42c178e10bcaf5409bb7ea",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cd927ff3283fc23a5f42c178e10bcaf5409bb7ea",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cd927ff3283fc23a5f42c178e10bcaf5409bb7ea",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cd927ff3283fc23a5f42c178e10bcaf5409bb7ea/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fb716f7b25927e377f73b904a88ab67facfe3e55",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fb716f7b25927e377f73b904a88ab67facfe3e55",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fb716f7b25927e377f73b904a88ab67facfe3e55"
      }
    ],
    "stats": {
      "total": 680,
      "additions": 330,
      "deletions": 350
    },
    "files": [
      {
        "sha": "aa1579c20f2ff33e6f74fbd0c6dac55ab88b6759",
        "filename": "src/wallet/test/coinselector_tests.cpp",
        "status": "modified",
        "additions": 330,
        "deletions": 0,
        "changes": 330,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cd927ff3283fc23a5f42c178e10bcaf5409bb7ea/src/wallet/test/coinselector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cd927ff3283fc23a5f42c178e10bcaf5409bb7ea/src/wallet/test/coinselector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/coinselector_tests.cpp?ref=cd927ff3283fc23a5f42c178e10bcaf5409bb7ea",
        "patch": "@@ -15,6 +15,15 @@\n \n BOOST_FIXTURE_TEST_SUITE(coin_selection_tests, WalletTestingSetup)\n \n+// how many times to run all the tests to have a chance to catch errors that only show up with particular random shuffles\n+#define RUN_TESTS 100\n+\n+// some tests fail 1% of the time due to bad luck.\n+// we repeat those tests this many times and only complain if all iterations of the test fail\n+#define RANDOM_REPEATS 5\n+\n+std::vector<std::unique_ptr<CWalletTx>> wtxn;\n+\n typedef std::set<CInputCoin> CoinSet;\n \n static std::vector<COutput> vCoins;\n@@ -36,6 +45,35 @@ static void add_coin(const CAmount& nValue, int nInput, CoinSet& set)\n     set.emplace(MakeTransactionRef(tx), nInput);\n }\n \n+static void add_coin(const CAmount& nValue, int nAge = 6*24, bool fIsFromMe = false, int nInput=0)\n+{\n+    static int nextLockTime = 0;\n+    CMutableTransaction tx;\n+    tx.nLockTime = nextLockTime++;        // so all transactions get different hashes\n+    tx.vout.resize(nInput + 1);\n+    tx.vout[nInput].nValue = nValue;\n+    if (fIsFromMe) {\n+        // IsFromMe() returns (GetDebit() > 0), and GetDebit() is 0 if vin.empty(),\n+        // so stop vin being empty, and cache a non-zero Debit to fake out IsFromMe()\n+        tx.vin.resize(1);\n+    }\n+    std::unique_ptr<CWalletTx> wtx(new CWalletTx(&testWallet, MakeTransactionRef(std::move(tx))));\n+    if (fIsFromMe)\n+    {\n+        wtx->fDebitCached = true;\n+        wtx->nDebitCached = 1;\n+    }\n+    COutput output(wtx.get(), nInput, nAge, true /* spendable */, true /* solvable */, true /* safe */);\n+    vCoins.push_back(output);\n+    wtxn.emplace_back(std::move(wtx));\n+}\n+\n+static void empty_wallet(void)\n+{\n+    vCoins.clear();\n+    wtxn.clear();\n+}\n+\n static bool equal_sets(CoinSet a, CoinSet b)\n {\n     std::pair<CoinSet::iterator, CoinSet::iterator> ret = mismatch(a.begin(), a.end(), b.begin());\n@@ -168,4 +206,296 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     }\n }\n \n+CoinEligibilityFilter filter_standard(1, 6, 0);\n+CoinEligibilityFilter filter_confirmed(1, 1, 0);\n+CoinEligibilityFilter filter_standard_extra(6, 6, 0);\n+\n+BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n+{\n+    CoinSet setCoinsRet, setCoinsRet2;\n+    CAmount nValueRet;\n+\n+    LOCK(testWallet.cs_wallet);\n+\n+    // test multiple times to allow for differences in the shuffle order\n+    for (int i = 0; i < RUN_TESTS; i++)\n+    {\n+        empty_wallet();\n+\n+        // with an empty wallet we can't even pay one cent\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet));\n+\n+        add_coin(1*CENT, 4);        // add a new 1 cent coin\n+\n+        // with a new 1 cent coin, we still can't find a mature 1 cent\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet));\n+\n+        // but we can find a new 1 cent\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 1 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);\n+\n+        add_coin(2*CENT);           // add a mature 2 cent coin\n+\n+        // we can't make 3 cents of mature coins\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 3 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet));\n+\n+        // we can make 3 cents of new coins\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 3 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 3 * CENT);\n+\n+        add_coin(5*CENT);           // add a mature 5 cent coin,\n+        add_coin(10*CENT, 3, true); // a new 10 cent coin sent from one of our own addresses\n+        add_coin(20*CENT);          // and a mature 20 cent coin\n+\n+        // now we have new: 1+10=11 (of which 10 was self-sent), and mature: 2+5+20=27.  total = 38\n+\n+        // we can't make 38 cents only if we disallow new coins:\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf(38 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet));\n+        // we can't even make 37 cents if we don't allow new coins even if they're from us\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf(38 * CENT, filter_standard_extra, vCoins, setCoinsRet, nValueRet));\n+        // but we can make 37 cents if we accept new coins from ourself\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(37 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 37 * CENT);\n+        // and we can make 38 cents if we accept all new coins\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(38 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 38 * CENT);\n+\n+        // try making 34 cents from 1,2,5,10,20 - we can't do it exactly\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(34 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 35 * CENT);       // but 35 cents is closest\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);     // the best should be 20+10+5.  it's incredibly unlikely the 1 or 2 got included (but possible)\n+\n+        // when we try making 7 cents, the smaller coins (1,2,5) are enough.  We should see just 2+5\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 7 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 7 * CENT);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n+\n+        // when we try making 8 cents, the smaller coins (1,2,5) are exactly enough.\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 8 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(nValueRet == 8 * CENT);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n+\n+        // when we try making 9 cents, no subset of smaller coins is enough, and we get the next bigger coin (10)\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 9 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 10 * CENT);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n+\n+        // now clear out the wallet and start again to test choosing between subsets of smaller coins and the next biggest coin\n+        empty_wallet();\n+\n+        add_coin( 6*CENT);\n+        add_coin( 7*CENT);\n+        add_coin( 8*CENT);\n+        add_coin(20*CENT);\n+        add_coin(30*CENT); // now we have 6+7+8+20+30 = 71 cents total\n+\n+        // check that we have 71 and not 72\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(71 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf(72 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+\n+        // now try making 16 cents.  the best smaller coins can do is 6+7+8 = 21; not as good at the next biggest coin, 20\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 20 * CENT); // we should get 20 in one coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n+\n+        add_coin( 5*CENT); // now we have 5+6+7+8+20+30 = 75 cents total\n+\n+        // now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, better than the next biggest coin, 20\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 18 * CENT); // we should get 18 in 3 coins\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n+\n+        add_coin( 18*CENT); // now we have 5+6+7+8+18+20+30\n+\n+        // and now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, the same as the next biggest coin, 18\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 18 * CENT);  // we should get 18 in 1 coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U); // because in the event of a tie, the biggest coin wins\n+\n+        // now try making 11 cents.  we should get 5+6\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(11 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 11 * CENT);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n+\n+        // check that the smallest bigger coin is used\n+        add_coin( 1*COIN);\n+        add_coin( 2*COIN);\n+        add_coin( 3*COIN);\n+        add_coin( 4*COIN); // now we have 5+6+7+8+18+20+30+100+200+300+400 = 1094 cents\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(95 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * COIN);  // we should get 1 BTC in 1 coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n+\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(195 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 2 * COIN);  // we should get 2 BTC in 1 coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n+\n+        // empty the wallet and start again, now with fractions of a cent, to test small change avoidance\n+\n+        empty_wallet();\n+        add_coin(MIN_CHANGE * 1 / 10);\n+        add_coin(MIN_CHANGE * 2 / 10);\n+        add_coin(MIN_CHANGE * 3 / 10);\n+        add_coin(MIN_CHANGE * 4 / 10);\n+        add_coin(MIN_CHANGE * 5 / 10);\n+\n+        // try making 1 * MIN_CHANGE from the 1.5 * MIN_CHANGE\n+        // we'll get change smaller than MIN_CHANGE whatever happens, so can expect MIN_CHANGE exactly\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE);\n+\n+        // but if we add a bigger coin, small change is avoided\n+        add_coin(1111*MIN_CHANGE);\n+\n+        // try making 1 from 0.1 + 0.2 + 0.3 + 0.4 + 0.5 + 1111 = 1112.5\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * MIN_CHANGE); // we should get the exact amount\n+\n+        // if we add more small coins:\n+        add_coin(MIN_CHANGE * 6 / 10);\n+        add_coin(MIN_CHANGE * 7 / 10);\n+\n+        // and try again to make 1.0 * MIN_CHANGE\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1 * MIN_CHANGE); // we should get the exact amount\n+\n+        // run the 'mtgox' test (see http://blockexplorer.com/tx/29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf)\n+        // they tried to consolidate 10 50k coins into one 500k coin, and ended up with 50k in change\n+        empty_wallet();\n+        for (int j = 0; j < 20; j++)\n+            add_coin(50000 * COIN);\n+\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(500000 * COIN, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 500000 * COIN); // we should get the exact amount\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 10U); // in ten coins\n+\n+        // if there's not enough in the smaller coins to make at least 1 * MIN_CHANGE change (0.5+0.6+0.7 < 1.0+1.0),\n+        // we need to try finding an exact subset anyway\n+\n+        // sometimes it will fail, and so we use the next biggest coin:\n+        empty_wallet();\n+        add_coin(MIN_CHANGE * 5 / 10);\n+        add_coin(MIN_CHANGE * 6 / 10);\n+        add_coin(MIN_CHANGE * 7 / 10);\n+        add_coin(1111 * MIN_CHANGE);\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 1111 * MIN_CHANGE); // we get the bigger coin\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n+\n+        // but sometimes it's possible, and we use an exact subset (0.4 + 0.6 = 1.0)\n+        empty_wallet();\n+        add_coin(MIN_CHANGE * 4 / 10);\n+        add_coin(MIN_CHANGE * 6 / 10);\n+        add_coin(MIN_CHANGE * 8 / 10);\n+        add_coin(1111 * MIN_CHANGE);\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE);   // we should get the exact amount\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U); // in two coins 0.4+0.6\n+\n+        // test avoiding small change\n+        empty_wallet();\n+        add_coin(MIN_CHANGE * 5 / 100);\n+        add_coin(MIN_CHANGE * 1);\n+        add_coin(MIN_CHANGE * 100);\n+\n+        // trying to make 100.01 from these three coins\n+        BOOST_CHECK(testWallet.SelectCoinsMinConf(MIN_CHANGE * 10001 / 100, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE * 10105 / 100); // we should get all coins\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n+\n+        // but if we try to make 99.9, we should take the bigger of the two small coins to avoid small change\n+        BOOST_CHECK(testWallet.SelectCoinsMinConf(MIN_CHANGE * 9990 / 100, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK_EQUAL(nValueRet, 101 * MIN_CHANGE);\n+        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n+\n+        // test with many inputs\n+        for (CAmount amt=1500; amt < COIN; amt*=10) {\n+             empty_wallet();\n+             // Create 676 inputs (=  (old MAX_STANDARD_TX_SIZE == 100000)  / 148 bytes per input)\n+             for (uint16_t j = 0; j < 676; j++)\n+                 add_coin(amt);\n+             BOOST_CHECK(testWallet.SelectCoinsMinConf(2000, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+             if (amt - 2000 < MIN_CHANGE) {\n+                 // needs more than one input:\n+                 uint16_t returnSize = std::ceil((2000.0 + MIN_CHANGE)/amt);\n+                 CAmount returnValue = amt * returnSize;\n+                 BOOST_CHECK_EQUAL(nValueRet, returnValue);\n+                 BOOST_CHECK_EQUAL(setCoinsRet.size(), returnSize);\n+             } else {\n+                 // one input is sufficient:\n+                 BOOST_CHECK_EQUAL(nValueRet, amt);\n+                 BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n+             }\n+        }\n+\n+        // test randomness\n+        {\n+            empty_wallet();\n+            for (int i2 = 0; i2 < 100; i2++)\n+                add_coin(COIN);\n+\n+            // picking 50 from 100 coins doesn't depend on the shuffle,\n+            // but does depend on randomness in the stochastic approximation code\n+            BOOST_CHECK(testWallet.SelectCoinsMinConf(50 * COIN, filter_standard, vCoins, setCoinsRet , nValueRet));\n+            BOOST_CHECK(testWallet.SelectCoinsMinConf(50 * COIN, filter_standard, vCoins, setCoinsRet2, nValueRet));\n+            BOOST_CHECK(!equal_sets(setCoinsRet, setCoinsRet2));\n+\n+            int fails = 0;\n+            for (int j = 0; j < RANDOM_REPEATS; j++)\n+            {\n+                // selecting 1 from 100 identical coins depends on the shuffle; this test will fail 1% of the time\n+                // run the test RANDOM_REPEATS times and only complain if all of them fail\n+                BOOST_CHECK(testWallet.SelectCoinsMinConf(COIN, filter_standard, vCoins, setCoinsRet , nValueRet));\n+                BOOST_CHECK(testWallet.SelectCoinsMinConf(COIN, filter_standard, vCoins, setCoinsRet2, nValueRet));\n+                if (equal_sets(setCoinsRet, setCoinsRet2))\n+                    fails++;\n+            }\n+            BOOST_CHECK_NE(fails, RANDOM_REPEATS);\n+\n+            // add 75 cents in small change.  not enough to make 90 cents,\n+            // then try making 90 cents.  there are multiple competing \"smallest bigger\" coins,\n+            // one of which should be picked at random\n+            add_coin(5 * CENT);\n+            add_coin(10 * CENT);\n+            add_coin(15 * CENT);\n+            add_coin(20 * CENT);\n+            add_coin(25 * CENT);\n+\n+            fails = 0;\n+            for (int j = 0; j < RANDOM_REPEATS; j++)\n+            {\n+                // selecting 1 from 100 identical coins depends on the shuffle; this test will fail 1% of the time\n+                // run the test RANDOM_REPEATS times and only complain if all of them fail\n+                BOOST_CHECK(testWallet.SelectCoinsMinConf(90*CENT, filter_standard, vCoins, setCoinsRet , nValueRet));\n+                BOOST_CHECK(testWallet.SelectCoinsMinConf(90*CENT, filter_standard, vCoins, setCoinsRet2, nValueRet));\n+                if (equal_sets(setCoinsRet, setCoinsRet2))\n+                    fails++;\n+            }\n+            BOOST_CHECK_NE(fails, RANDOM_REPEATS);\n+        }\n+    }\n+    empty_wallet();\n+}\n+\n+BOOST_AUTO_TEST_CASE(ApproximateBestSubset)\n+{\n+    CoinSet setCoinsRet;\n+    CAmount nValueRet;\n+\n+    LOCK(testWallet.cs_wallet);\n+\n+    empty_wallet();\n+\n+    // Test vValue sort order\n+    for (int i = 0; i < 1000; i++)\n+        add_coin(1000 * COIN);\n+    add_coin(3 * COIN);\n+\n+    BOOST_CHECK(testWallet.SelectCoinsMinConf(1003 * COIN, filter_standard, vCoins, setCoinsRet, nValueRet));\n+    BOOST_CHECK_EQUAL(nValueRet, 1003 * COIN);\n+    BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n+\n+    empty_wallet();\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "a9e127fe2a4b09fd0040a854385eb3cb2b690e8b",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 341,
        "changes": 341,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cd927ff3283fc23a5f42c178e10bcaf5409bb7ea/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cd927ff3283fc23a5f42c178e10bcaf5409bb7ea/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=cd927ff3283fc23a5f42c178e10bcaf5409bb7ea",
        "patch": "@@ -23,349 +23,8 @@ extern UniValue importmulti(const JSONRPCRequest& request);\n extern UniValue dumpwallet(const JSONRPCRequest& request);\n extern UniValue importwallet(const JSONRPCRequest& request);\n \n-// how many times to run all the tests to have a chance to catch errors that only show up with particular random shuffles\n-#define RUN_TESTS 100\n-\n-// some tests fail 1% of the time due to bad luck.\n-// we repeat those tests this many times and only complain if all iterations of the test fail\n-#define RANDOM_REPEATS 5\n-\n-std::vector<std::unique_ptr<CWalletTx>> wtxn;\n-\n-typedef std::set<CInputCoin> CoinSet;\n-\n BOOST_FIXTURE_TEST_SUITE(wallet_tests, WalletTestingSetup)\n \n-static const CWallet testWallet(\"dummy\", CWalletDBWrapper::CreateDummy());\n-static std::vector<COutput> vCoins;\n-\n-static void add_coin(const CAmount& nValue, int nAge = 6*24, bool fIsFromMe = false, int nInput=0)\n-{\n-    static int nextLockTime = 0;\n-    CMutableTransaction tx;\n-    tx.nLockTime = nextLockTime++;        // so all transactions get different hashes\n-    tx.vout.resize(nInput+1);\n-    tx.vout[nInput].nValue = nValue;\n-    if (fIsFromMe) {\n-        // IsFromMe() returns (GetDebit() > 0), and GetDebit() is 0 if vin.empty(),\n-        // so stop vin being empty, and cache a non-zero Debit to fake out IsFromMe()\n-        tx.vin.resize(1);\n-    }\n-    std::unique_ptr<CWalletTx> wtx(new CWalletTx(&testWallet, MakeTransactionRef(std::move(tx))));\n-    if (fIsFromMe)\n-    {\n-        wtx->fDebitCached = true;\n-        wtx->nDebitCached = 1;\n-    }\n-    COutput output(wtx.get(), nInput, nAge, true /* spendable */, true /* solvable */, true /* safe */);\n-    vCoins.push_back(output);\n-    wtxn.emplace_back(std::move(wtx));\n-}\n-\n-static void empty_wallet(void)\n-{\n-    vCoins.clear();\n-    wtxn.clear();\n-}\n-\n-static bool equal_sets(CoinSet a, CoinSet b)\n-{\n-    std::pair<CoinSet::iterator, CoinSet::iterator> ret = mismatch(a.begin(), a.end(), b.begin());\n-    return ret.first == a.end() && ret.second == b.end();\n-}\n-\n-CoinEligibilityFilter filter_standard(1, 6, 0);\n-CoinEligibilityFilter filter_confirmed(1, 1, 0);\n-CoinEligibilityFilter filter_standard_extra(6, 6, 0);\n-\n-BOOST_AUTO_TEST_CASE(coin_selection_tests)\n-{\n-    CoinSet setCoinsRet, setCoinsRet2;\n-    CAmount nValueRet;\n-\n-    LOCK(testWallet.cs_wallet);\n-\n-    // test multiple times to allow for differences in the shuffle order\n-    for (int i = 0; i < RUN_TESTS; i++)\n-    {\n-        empty_wallet();\n-\n-        // with an empty wallet we can't even pay one cent\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet));\n-\n-        add_coin(1*CENT, 4);        // add a new 1 cent coin\n-\n-        // with a new 1 cent coin, we still can't find a mature 1 cent\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet));\n-\n-        // but we can find a new 1 cent\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 1 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);\n-\n-        add_coin(2*CENT);           // add a mature 2 cent coin\n-\n-        // we can't make 3 cents of mature coins\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 3 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet));\n-\n-        // we can make 3 cents of new coins\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 3 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 3 * CENT);\n-\n-        add_coin(5*CENT);           // add a mature 5 cent coin,\n-        add_coin(10*CENT, 3, true); // a new 10 cent coin sent from one of our own addresses\n-        add_coin(20*CENT);          // and a mature 20 cent coin\n-\n-        // now we have new: 1+10=11 (of which 10 was self-sent), and mature: 2+5+20=27.  total = 38\n-\n-        // we can't make 38 cents only if we disallow new coins:\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf(38 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet));\n-        // we can't even make 37 cents if we don't allow new coins even if they're from us\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf(38 * CENT, filter_standard_extra, vCoins, setCoinsRet, nValueRet));\n-        // but we can make 37 cents if we accept new coins from ourself\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(37 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 37 * CENT);\n-        // and we can make 38 cents if we accept all new coins\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(38 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 38 * CENT);\n-\n-        // try making 34 cents from 1,2,5,10,20 - we can't do it exactly\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(34 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 35 * CENT);       // but 35 cents is closest\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);     // the best should be 20+10+5.  it's incredibly unlikely the 1 or 2 got included (but possible)\n-\n-        // when we try making 7 cents, the smaller coins (1,2,5) are enough.  We should see just 2+5\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 7 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 7 * CENT);\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n-\n-        // when we try making 8 cents, the smaller coins (1,2,5) are exactly enough.\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 8 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK(nValueRet == 8 * CENT);\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n-\n-        // when we try making 9 cents, no subset of smaller coins is enough, and we get the next bigger coin (10)\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 9 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 10 * CENT);\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n-\n-        // now clear out the wallet and start again to test choosing between subsets of smaller coins and the next biggest coin\n-        empty_wallet();\n-\n-        add_coin( 6*CENT);\n-        add_coin( 7*CENT);\n-        add_coin( 8*CENT);\n-        add_coin(20*CENT);\n-        add_coin(30*CENT); // now we have 6+7+8+20+30 = 71 cents total\n-\n-        // check that we have 71 and not 72\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(71 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf(72 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n-\n-        // now try making 16 cents.  the best smaller coins can do is 6+7+8 = 21; not as good at the next biggest coin, 20\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 20 * CENT); // we should get 20 in one coin\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n-\n-        add_coin( 5*CENT); // now we have 5+6+7+8+20+30 = 75 cents total\n-\n-        // now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, better than the next biggest coin, 20\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 18 * CENT); // we should get 18 in 3 coins\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n-\n-        add_coin( 18*CENT); // now we have 5+6+7+8+18+20+30\n-\n-        // and now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, the same as the next biggest coin, 18\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 18 * CENT);  // we should get 18 in 1 coin\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U); // because in the event of a tie, the biggest coin wins\n-\n-        // now try making 11 cents.  we should get 5+6\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(11 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 11 * CENT);\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n-\n-        // check that the smallest bigger coin is used\n-        add_coin( 1*COIN);\n-        add_coin( 2*COIN);\n-        add_coin( 3*COIN);\n-        add_coin( 4*COIN); // now we have 5+6+7+8+18+20+30+100+200+300+400 = 1094 cents\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(95 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 1 * COIN);  // we should get 1 BTC in 1 coin\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n-\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(195 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 2 * COIN);  // we should get 2 BTC in 1 coin\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n-\n-        // empty the wallet and start again, now with fractions of a cent, to test small change avoidance\n-\n-        empty_wallet();\n-        add_coin(MIN_CHANGE * 1 / 10);\n-        add_coin(MIN_CHANGE * 2 / 10);\n-        add_coin(MIN_CHANGE * 3 / 10);\n-        add_coin(MIN_CHANGE * 4 / 10);\n-        add_coin(MIN_CHANGE * 5 / 10);\n-\n-        // try making 1 * MIN_CHANGE from the 1.5 * MIN_CHANGE\n-        // we'll get change smaller than MIN_CHANGE whatever happens, so can expect MIN_CHANGE exactly\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE);\n-\n-        // but if we add a bigger coin, small change is avoided\n-        add_coin(1111*MIN_CHANGE);\n-\n-        // try making 1 from 0.1 + 0.2 + 0.3 + 0.4 + 0.5 + 1111 = 1112.5\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 1 * MIN_CHANGE); // we should get the exact amount\n-\n-        // if we add more small coins:\n-        add_coin(MIN_CHANGE * 6 / 10);\n-        add_coin(MIN_CHANGE * 7 / 10);\n-\n-        // and try again to make 1.0 * MIN_CHANGE\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 1 * MIN_CHANGE); // we should get the exact amount\n-\n-        // run the 'mtgox' test (see http://blockexplorer.com/tx/29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf)\n-        // they tried to consolidate 10 50k coins into one 500k coin, and ended up with 50k in change\n-        empty_wallet();\n-        for (int j = 0; j < 20; j++)\n-            add_coin(50000 * COIN);\n-\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(500000 * COIN, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 500000 * COIN); // we should get the exact amount\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 10U); // in ten coins\n-\n-        // if there's not enough in the smaller coins to make at least 1 * MIN_CHANGE change (0.5+0.6+0.7 < 1.0+1.0),\n-        // we need to try finding an exact subset anyway\n-\n-        // sometimes it will fail, and so we use the next biggest coin:\n-        empty_wallet();\n-        add_coin(MIN_CHANGE * 5 / 10);\n-        add_coin(MIN_CHANGE * 6 / 10);\n-        add_coin(MIN_CHANGE * 7 / 10);\n-        add_coin(1111 * MIN_CHANGE);\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 1111 * MIN_CHANGE); // we get the bigger coin\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n-\n-        // but sometimes it's possible, and we use an exact subset (0.4 + 0.6 = 1.0)\n-        empty_wallet();\n-        add_coin(MIN_CHANGE * 4 / 10);\n-        add_coin(MIN_CHANGE * 6 / 10);\n-        add_coin(MIN_CHANGE * 8 / 10);\n-        add_coin(1111 * MIN_CHANGE);\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE);   // we should get the exact amount\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U); // in two coins 0.4+0.6\n-\n-        // test avoiding small change\n-        empty_wallet();\n-        add_coin(MIN_CHANGE * 5 / 100);\n-        add_coin(MIN_CHANGE * 1);\n-        add_coin(MIN_CHANGE * 100);\n-\n-        // trying to make 100.01 from these three coins\n-        BOOST_CHECK(testWallet.SelectCoinsMinConf(MIN_CHANGE * 10001 / 100, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE * 10105 / 100); // we should get all coins\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n-\n-        // but if we try to make 99.9, we should take the bigger of the two small coins to avoid small change\n-        BOOST_CHECK(testWallet.SelectCoinsMinConf(MIN_CHANGE * 9990 / 100, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK_EQUAL(nValueRet, 101 * MIN_CHANGE);\n-        BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n-\n-        // test with many inputs\n-        for (CAmount amt=1500; amt < COIN; amt*=10) {\n-             empty_wallet();\n-             // Create 676 inputs (=  (old MAX_STANDARD_TX_SIZE == 100000)  / 148 bytes per input)\n-             for (uint16_t j = 0; j < 676; j++)\n-                 add_coin(amt);\n-             BOOST_CHECK(testWallet.SelectCoinsMinConf(2000, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n-             if (amt - 2000 < MIN_CHANGE) {\n-                 // needs more than one input:\n-                 uint16_t returnSize = std::ceil((2000.0 + MIN_CHANGE)/amt);\n-                 CAmount returnValue = amt * returnSize;\n-                 BOOST_CHECK_EQUAL(nValueRet, returnValue);\n-                 BOOST_CHECK_EQUAL(setCoinsRet.size(), returnSize);\n-             } else {\n-                 // one input is sufficient:\n-                 BOOST_CHECK_EQUAL(nValueRet, amt);\n-                 BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n-             }\n-        }\n-\n-        // test randomness\n-        {\n-            empty_wallet();\n-            for (int i2 = 0; i2 < 100; i2++)\n-                add_coin(COIN);\n-\n-            // picking 50 from 100 coins doesn't depend on the shuffle,\n-            // but does depend on randomness in the stochastic approximation code\n-            BOOST_CHECK(testWallet.SelectCoinsMinConf(50 * COIN, filter_standard, vCoins, setCoinsRet , nValueRet));\n-            BOOST_CHECK(testWallet.SelectCoinsMinConf(50 * COIN, filter_standard, vCoins, setCoinsRet2, nValueRet));\n-            BOOST_CHECK(!equal_sets(setCoinsRet, setCoinsRet2));\n-\n-            int fails = 0;\n-            for (int j = 0; j < RANDOM_REPEATS; j++)\n-            {\n-                // selecting 1 from 100 identical coins depends on the shuffle; this test will fail 1% of the time\n-                // run the test RANDOM_REPEATS times and only complain if all of them fail\n-                BOOST_CHECK(testWallet.SelectCoinsMinConf(COIN, filter_standard, vCoins, setCoinsRet , nValueRet));\n-                BOOST_CHECK(testWallet.SelectCoinsMinConf(COIN, filter_standard, vCoins, setCoinsRet2, nValueRet));\n-                if (equal_sets(setCoinsRet, setCoinsRet2))\n-                    fails++;\n-            }\n-            BOOST_CHECK_NE(fails, RANDOM_REPEATS);\n-\n-            // add 75 cents in small change.  not enough to make 90 cents,\n-            // then try making 90 cents.  there are multiple competing \"smallest bigger\" coins,\n-            // one of which should be picked at random\n-            add_coin(5 * CENT);\n-            add_coin(10 * CENT);\n-            add_coin(15 * CENT);\n-            add_coin(20 * CENT);\n-            add_coin(25 * CENT);\n-\n-            fails = 0;\n-            for (int j = 0; j < RANDOM_REPEATS; j++)\n-            {\n-                // selecting 1 from 100 identical coins depends on the shuffle; this test will fail 1% of the time\n-                // run the test RANDOM_REPEATS times and only complain if all of them fail\n-                BOOST_CHECK(testWallet.SelectCoinsMinConf(90*CENT, filter_standard, vCoins, setCoinsRet , nValueRet));\n-                BOOST_CHECK(testWallet.SelectCoinsMinConf(90*CENT, filter_standard, vCoins, setCoinsRet2, nValueRet));\n-                if (equal_sets(setCoinsRet, setCoinsRet2))\n-                    fails++;\n-            }\n-            BOOST_CHECK_NE(fails, RANDOM_REPEATS);\n-        }\n-    }\n-    empty_wallet();\n-}\n-\n-BOOST_AUTO_TEST_CASE(ApproximateBestSubset)\n-{\n-    CoinSet setCoinsRet;\n-    CAmount nValueRet;\n-\n-    LOCK(testWallet.cs_wallet);\n-\n-    empty_wallet();\n-\n-    // Test vValue sort order\n-    for (int i = 0; i < 1000; i++)\n-        add_coin(1000 * COIN);\n-    add_coin(3 * COIN);\n-\n-    BOOST_CHECK(testWallet.SelectCoinsMinConf(1003 * COIN, filter_standard, vCoins, setCoinsRet, nValueRet));\n-    BOOST_CHECK_EQUAL(nValueRet, 1003 * COIN);\n-    BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n-\n-    empty_wallet();\n-}\n-\n static void AddKey(CWallet& wallet, const CKey& key)\n {\n     LOCK(wallet.cs_wallet);"
      },
      {
        "sha": "37e071d9982c4ee6aadc5dd0deb23084dbd7c9b8",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 9,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cd927ff3283fc23a5f42c178e10bcaf5409bb7ea/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cd927ff3283fc23a5f42c178e10bcaf5409bb7ea/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=cd927ff3283fc23a5f42c178e10bcaf5409bb7ea",
        "patch": "@@ -69,15 +69,6 @@ const uint256 CMerkleTx::ABANDON_HASH(uint256S(\"00000000000000000000000000000000\n  * @{\n  */\n \n-struct CompareValueOnly\n-{\n-    bool operator()(const CInputCoin& t1,\n-                    const CInputCoin& t2) const\n-    {\n-        return t1.txout.nValue < t2.txout.nValue;\n-    }\n-};\n-\n std::string COutput::ToString() const\n {\n     return strprintf(\"COutput(%s, %d, %d) [%s]\", tx->GetHash().ToString(), i, nDepth, FormatMoney(tx->tx->vout[i].nValue));"
      }
    ]
  },
  {
    "sha": "fab04887c22cf71a4b15ac0b0a127e150229d686",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYWIwNDg4N2MyMmNmNzFhNGIxNWFjMGIwYTEyN2UxNTAyMjlkNjg2",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-05T21:39:48Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-13T16:39:26Z"
      },
      "message": "Add a GetMinimumFeeRate function which is wrapped by GetMinimumFee",
      "tree": {
        "sha": "efee6b6b92027ca25eb30e4509f14e04d12e78ed",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/efee6b6b92027ca25eb30e4509f14e04d12e78ed"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fab04887c22cf71a4b15ac0b0a127e150229d686",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fab04887c22cf71a4b15ac0b0a127e150229d686",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fab04887c22cf71a4b15ac0b0a127e150229d686",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fab04887c22cf71a4b15ac0b0a127e150229d686/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cd927ff3283fc23a5f42c178e10bcaf5409bb7ea",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cd927ff3283fc23a5f42c178e10bcaf5409bb7ea",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cd927ff3283fc23a5f42c178e10bcaf5409bb7ea"
      }
    ],
    "stats": {
      "total": 64,
      "additions": 43,
      "deletions": 21
    },
    "files": [
      {
        "sha": "03c32d3b9733f6ab889506671ca718667df520ab",
        "filename": "src/wallet/fees.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 21,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab04887c22cf71a4b15ac0b0a127e150229d686/src/wallet/fees.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab04887c22cf71a4b15ac0b0a127e150229d686/src/wallet/fees.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/fees.cpp?ref=fab04887c22cf71a4b15ac0b0a127e150229d686",
        "patch": "@@ -20,6 +20,22 @@ CAmount GetRequiredFee(unsigned int nTxBytes)\n \n \n CAmount GetMinimumFee(unsigned int nTxBytes, const CCoinControl& coin_control, const CTxMemPool& pool, const CBlockPolicyEstimator& estimator, FeeCalculation *feeCalc)\n+{\n+    CAmount fee_needed = GetMinimumFeeRate(coin_control, pool, estimator, feeCalc).GetFee(nTxBytes);\n+    // Always obey the maximum\n+    if (fee_needed > maxTxFee) {\n+        fee_needed = maxTxFee;\n+        if (feeCalc) feeCalc->reason = FeeReason::MAXTXFEE;\n+    }\n+    return fee_needed;\n+}\n+\n+CFeeRate GetRequiredFeeRate()\n+{\n+    return std::max(CWallet::minTxFee, ::minRelayTxFee);\n+}\n+\n+CFeeRate GetMinimumFeeRate(const CCoinControl& coin_control, const CTxMemPool& pool, const CBlockPolicyEstimator& estimator, FeeCalculation *feeCalc)\n {\n     /* User control of how to calculate fee uses the following parameter precedence:\n        1. coin_control.m_feerate\n@@ -28,15 +44,15 @@ CAmount GetMinimumFee(unsigned int nTxBytes, const CCoinControl& coin_control, c\n        4. nTxConfirmTarget (user-set global variable)\n        The first parameter that is set is used.\n     */\n-    CAmount fee_needed;\n+    CFeeRate feerate_needed ;\n     if (coin_control.m_feerate) { // 1.\n-        fee_needed = coin_control.m_feerate->GetFee(nTxBytes);\n+        feerate_needed = *(coin_control.m_feerate);\n         if (feeCalc) feeCalc->reason = FeeReason::PAYTXFEE;\n         // Allow to override automatic min/max check over coin control instance\n-        if (coin_control.fOverrideFeeRate) return fee_needed;\n+        if (coin_control.fOverrideFeeRate) return feerate_needed;\n     }\n     else if (!coin_control.m_confirm_target && ::payTxFee != CFeeRate(0)) { // 3. TODO: remove magic value of 0 for global payTxFee\n-        fee_needed = ::payTxFee.GetFee(nTxBytes);\n+        feerate_needed = ::payTxFee;\n         if (feeCalc) feeCalc->reason = FeeReason::PAYTXFEE;\n     }\n     else { // 2. or 4.\n@@ -48,38 +64,32 @@ CAmount GetMinimumFee(unsigned int nTxBytes, const CCoinControl& coin_control, c\n         if (coin_control.m_fee_mode == FeeEstimateMode::CONSERVATIVE) conservative_estimate = true;\n         else if (coin_control.m_fee_mode == FeeEstimateMode::ECONOMICAL) conservative_estimate = false;\n \n-        fee_needed = estimator.estimateSmartFee(target, feeCalc, conservative_estimate).GetFee(nTxBytes);\n-        if (fee_needed == 0) {\n+        feerate_needed = estimator.estimateSmartFee(target, feeCalc, conservative_estimate);\n+        if (feerate_needed == CFeeRate(0)) {\n             // if we don't have enough data for estimateSmartFee, then use fallbackFee\n-            fee_needed = CWallet::fallbackFee.GetFee(nTxBytes);\n+            feerate_needed = CWallet::fallbackFee;\n             if (feeCalc) feeCalc->reason = FeeReason::FALLBACK;\n \n             // directly return if fallback fee is disabled (feerate 0 == disabled)\n-            if (CWallet::fallbackFee.GetFee(1000) == 0) return fee_needed;\n+            if (CWallet::fallbackFee == CFeeRate(0)) return feerate_needed;\n         }\n         // Obey mempool min fee when using smart fee estimation\n-        CAmount min_mempool_fee = pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(nTxBytes);\n-        if (fee_needed < min_mempool_fee) {\n-            fee_needed = min_mempool_fee;\n+        CFeeRate min_mempool_feerate = pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+        if (feerate_needed < min_mempool_feerate) {\n+            feerate_needed = min_mempool_feerate;\n             if (feeCalc) feeCalc->reason = FeeReason::MEMPOOL_MIN;\n         }\n     }\n \n     // prevent user from paying a fee below minRelayTxFee or minTxFee\n-    CAmount required_fee = GetRequiredFee(nTxBytes);\n-    if (required_fee > fee_needed) {\n-        fee_needed = required_fee;\n+    CFeeRate required_feerate = GetRequiredFeeRate();\n+    if (required_feerate > feerate_needed) {\n+        feerate_needed = required_feerate;\n         if (feeCalc) feeCalc->reason = FeeReason::REQUIRED;\n     }\n-    // But always obey the maximum\n-    if (fee_needed > maxTxFee) {\n-        fee_needed = maxTxFee;\n-        if (feeCalc) feeCalc->reason = FeeReason::MAXTXFEE;\n-    }\n-    return fee_needed;\n+    return feerate_needed;\n }\n \n-\n CFeeRate GetDiscardRate(const CBlockPolicyEstimator& estimator)\n {\n     unsigned int highest_target = estimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE);"
      },
      {
        "sha": "a627af70b0a69efeda80f61ee14b494da0b303ea",
        "filename": "src/wallet/fees.h",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fab04887c22cf71a4b15ac0b0a127e150229d686/src/wallet/fees.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fab04887c22cf71a4b15ac0b0a127e150229d686/src/wallet/fees.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/fees.h?ref=fab04887c22cf71a4b15ac0b0a127e150229d686",
        "patch": "@@ -26,6 +26,18 @@ CAmount GetRequiredFee(unsigned int nTxBytes);\n  */\n CAmount GetMinimumFee(unsigned int nTxBytes, const CCoinControl& coin_control, const CTxMemPool& pool, const CBlockPolicyEstimator& estimator, FeeCalculation *feeCalc);\n \n+/**\n+ * Return the minimum required feerate taking into account the\n+ * floating relay feerate and user set minimum transaction feerate\n+ */\n+CFeeRate GetRequiredFeeRate();\n+\n+/**\n+ * Estimate the minimum fee rate considering user set parameters\n+ * and the required fee\n+ */\n+CFeeRate GetMinimumFeeRate(const CCoinControl& coin_control, const CTxMemPool& pool, const CBlockPolicyEstimator& estimator, FeeCalculation *feeCalc);\n+\n /**\n  * Return the maximum feerate for discarding change.\n  */"
      }
    ]
  },
  {
    "sha": "6a34ff5335786615771ca423134a484b04831c4e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2YTM0ZmY1MzM1Nzg2NjE1NzcxY2E0MjMxMzRhNDg0YjA0ODMxYzRl",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-05T21:42:49Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-13T16:39:27Z"
      },
      "message": "Have SelectCoinsMinConf and SelectCoins use BnB or Knapsack and use it\n\nAllows SelectCoinsMinConf and SelectCoins be able to switch between\nusing BnB or Knapsack for choosing coins.\n\nHas SelectCoinsMinConf do the preprocessing necessary to support either\nBnB or Knapsack. This includes calculating the filtering the effective\nvalues for each input.\n\nUses BnB in CreateTransaction to find an exact match for the output.\nIf BnB fails, it will fallback to the Knapsack solver.",
      "tree": {
        "sha": "ed5aaec39589b9ac50272d0844bd0c19e564ccc2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ed5aaec39589b9ac50272d0844bd0c19e564ccc2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6a34ff5335786615771ca423134a484b04831c4e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6a34ff5335786615771ca423134a484b04831c4e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6a34ff5335786615771ca423134a484b04831c4e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6a34ff5335786615771ca423134a484b04831c4e/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fab04887c22cf71a4b15ac0b0a127e150229d686",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fab04887c22cf71a4b15ac0b0a127e150229d686",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fab04887c22cf71a4b15ac0b0a127e150229d686"
      }
    ],
    "stats": {
      "total": 265,
      "additions": 198,
      "deletions": 67
    },
    "files": [
      {
        "sha": "605d9e3e66abb54f1d0c0656a82c3ab0ea1a5f1a",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a34ff5335786615771ca423134a484b04831c4e/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a34ff5335786615771ca423134a484b04831c4e/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=6a34ff5335786615771ca423134a484b04831c4e",
        "patch": "@@ -44,8 +44,11 @@ static void CoinSelection(benchmark::State& state)\n \n         std::set<CInputCoin> setCoinsRet;\n         CAmount nValueRet;\n+        bool bnb_used;\n         CoinEligibilityFilter filter_standard(1, 6, 0);\n-        bool success = wallet.SelectCoinsMinConf(1003 * COIN, filter_standard, vCoins, setCoinsRet, nValueRet);\n+        CoinSelectionParams coin_selection_params(false, 34, 148, CFeeRate(0), 0);\n+        bool success = wallet.SelectCoinsMinConf(1003 * COIN, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)\n+                       || wallet.SelectCoinsMinConf(1003 * COIN, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used);\n         assert(success);\n         assert(nValueRet == 1003 * COIN);\n         assert(setCoinsRet.size() == 2);"
      },
      {
        "sha": "d2953983016aad0ddc779199baa390a0c4db4077",
        "filename": "src/wallet/test/coinselector_tests.cpp",
        "status": "modified",
        "additions": 87,
        "deletions": 37,
        "changes": 124,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a34ff5335786615771ca423134a484b04831c4e/src/wallet/test/coinselector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a34ff5335786615771ca423134a484b04831c4e/src/wallet/test/coinselector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/coinselector_tests.cpp?ref=6a34ff5335786615771ca423134a484b04831c4e",
        "patch": "@@ -28,6 +28,7 @@ typedef std::set<CInputCoin> CoinSet;\n \n static std::vector<COutput> vCoins;\n static const CWallet testWallet(\"dummy\", CWalletDBWrapper::CreateDummy());\n+static CAmount balance = 0;\n \n static void add_coin(const CAmount& nValue, int nInput, std::vector<CInputCoin>& set)\n {\n@@ -47,6 +48,7 @@ static void add_coin(const CAmount& nValue, int nInput, CoinSet& set)\n \n static void add_coin(const CAmount& nValue, int nAge = 6*24, bool fIsFromMe = false, int nInput=0)\n {\n+    balance += nValue;\n     static int nextLockTime = 0;\n     CMutableTransaction tx;\n     tx.nLockTime = nextLockTime++;        // so all transactions get different hashes\n@@ -72,6 +74,7 @@ static void empty_wallet(void)\n {\n     vCoins.clear();\n     wtxn.clear();\n+    balance = 0;\n }\n \n static bool equal_sets(CoinSet a, CoinSet b)\n@@ -209,11 +212,13 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n CoinEligibilityFilter filter_standard(1, 6, 0);\n CoinEligibilityFilter filter_confirmed(1, 1, 0);\n CoinEligibilityFilter filter_standard_extra(6, 6, 0);\n+CoinSelectionParams coin_selection_params(false, 0, 0, CFeeRate(0), 0);\n \n BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n {\n     CoinSet setCoinsRet, setCoinsRet2;\n     CAmount nValueRet;\n+    bool bnb_used;\n \n     LOCK(testWallet.cs_wallet);\n \n@@ -223,24 +228,24 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         empty_wallet();\n \n         // with an empty wallet we can't even pay one cent\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n \n         add_coin(1*CENT, 4);        // add a new 1 cent coin\n \n         // with a new 1 cent coin, we still can't find a mature 1 cent\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n \n         // but we can find a new 1 cent\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 1 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 1 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);\n \n         add_coin(2*CENT);           // add a mature 2 cent coin\n \n         // we can't make 3 cents of mature coins\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 3 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf( 3 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n \n         // we can make 3 cents of new coins\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 3 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 3 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 3 * CENT);\n \n         add_coin(5*CENT);           // add a mature 5 cent coin,\n@@ -250,33 +255,33 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         // now we have new: 1+10=11 (of which 10 was self-sent), and mature: 2+5+20=27.  total = 38\n \n         // we can't make 38 cents only if we disallow new coins:\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf(38 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf(38 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         // we can't even make 37 cents if we don't allow new coins even if they're from us\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf(38 * CENT, filter_standard_extra, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf(38 * CENT, filter_standard_extra, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         // but we can make 37 cents if we accept new coins from ourself\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(37 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(37 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 37 * CENT);\n         // and we can make 38 cents if we accept all new coins\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(38 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(38 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 38 * CENT);\n \n         // try making 34 cents from 1,2,5,10,20 - we can't do it exactly\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(34 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(34 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 35 * CENT);       // but 35 cents is closest\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);     // the best should be 20+10+5.  it's incredibly unlikely the 1 or 2 got included (but possible)\n \n         // when we try making 7 cents, the smaller coins (1,2,5) are enough.  We should see just 2+5\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 7 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 7 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 7 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n \n         // when we try making 8 cents, the smaller coins (1,2,5) are exactly enough.\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 8 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 8 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK(nValueRet == 8 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n \n         // when we try making 9 cents, no subset of smaller coins is enough, and we get the next bigger coin (10)\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf( 9 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf( 9 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 10 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n@@ -290,30 +295,30 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin(30*CENT); // now we have 6+7+8+20+30 = 71 cents total\n \n         // check that we have 71 and not 72\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(71 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n-        BOOST_CHECK(!testWallet.SelectCoinsMinConf(72 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(71 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n+        BOOST_CHECK(!testWallet.SelectCoinsMinConf(72 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n \n         // now try making 16 cents.  the best smaller coins can do is 6+7+8 = 21; not as good at the next biggest coin, 20\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 20 * CENT); // we should get 20 in one coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n         add_coin( 5*CENT); // now we have 5+6+7+8+20+30 = 75 cents total\n \n         // now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, better than the next biggest coin, 20\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 18 * CENT); // we should get 18 in 3 coins\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n \n         add_coin( 18*CENT); // now we have 5+6+7+8+18+20+30\n \n         // and now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, the same as the next biggest coin, 18\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 18 * CENT);  // we should get 18 in 1 coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U); // because in the event of a tie, the biggest coin wins\n \n         // now try making 11 cents.  we should get 5+6\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(11 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(11 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 11 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n \n@@ -322,11 +327,11 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin( 2*COIN);\n         add_coin( 3*COIN);\n         add_coin( 4*COIN); // now we have 5+6+7+8+18+20+30+100+200+300+400 = 1094 cents\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(95 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(95 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 1 * COIN);  // we should get 1 BTC in 1 coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(195 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(195 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 2 * COIN);  // we should get 2 BTC in 1 coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n@@ -341,22 +346,22 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n \n         // try making 1 * MIN_CHANGE from the 1.5 * MIN_CHANGE\n         // we'll get change smaller than MIN_CHANGE whatever happens, so can expect MIN_CHANGE exactly\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE);\n \n         // but if we add a bigger coin, small change is avoided\n         add_coin(1111*MIN_CHANGE);\n \n         // try making 1 from 0.1 + 0.2 + 0.3 + 0.4 + 0.5 + 1111 = 1112.5\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 1 * MIN_CHANGE); // we should get the exact amount\n \n         // if we add more small coins:\n         add_coin(MIN_CHANGE * 6 / 10);\n         add_coin(MIN_CHANGE * 7 / 10);\n \n         // and try again to make 1.0 * MIN_CHANGE\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 1 * MIN_CHANGE); // we should get the exact amount\n \n         // run the 'mtgox' test (see http://blockexplorer.com/tx/29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf)\n@@ -365,7 +370,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         for (int j = 0; j < 20; j++)\n             add_coin(50000 * COIN);\n \n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(500000 * COIN, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(500000 * COIN, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 500000 * COIN); // we should get the exact amount\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 10U); // in ten coins\n \n@@ -378,7 +383,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin(MIN_CHANGE * 6 / 10);\n         add_coin(MIN_CHANGE * 7 / 10);\n         add_coin(1111 * MIN_CHANGE);\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 1111 * MIN_CHANGE); // we get the bigger coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n@@ -388,7 +393,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin(MIN_CHANGE * 6 / 10);\n         add_coin(MIN_CHANGE * 8 / 10);\n         add_coin(1111 * MIN_CHANGE);\n-        BOOST_CHECK( testWallet.SelectCoinsMinConf(MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK( testWallet.SelectCoinsMinConf(MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE);   // we should get the exact amount\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U); // in two coins 0.4+0.6\n \n@@ -399,12 +404,12 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin(MIN_CHANGE * 100);\n \n         // trying to make 100.01 from these three coins\n-        BOOST_CHECK(testWallet.SelectCoinsMinConf(MIN_CHANGE * 10001 / 100, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(testWallet.SelectCoinsMinConf(MIN_CHANGE * 10001 / 100, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE * 10105 / 100); // we should get all coins\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n \n         // but if we try to make 99.9, we should take the bigger of the two small coins to avoid small change\n-        BOOST_CHECK(testWallet.SelectCoinsMinConf(MIN_CHANGE * 9990 / 100, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+        BOOST_CHECK(testWallet.SelectCoinsMinConf(MIN_CHANGE * 9990 / 100, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n         BOOST_CHECK_EQUAL(nValueRet, 101 * MIN_CHANGE);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n \n@@ -414,7 +419,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n              // Create 676 inputs (=  (old MAX_STANDARD_TX_SIZE == 100000)  / 148 bytes per input)\n              for (uint16_t j = 0; j < 676; j++)\n                  add_coin(amt);\n-             BOOST_CHECK(testWallet.SelectCoinsMinConf(2000, filter_confirmed, vCoins, setCoinsRet, nValueRet));\n+             BOOST_CHECK(testWallet.SelectCoinsMinConf(2000, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n              if (amt - 2000 < MIN_CHANGE) {\n                  // needs more than one input:\n                  uint16_t returnSize = std::ceil((2000.0 + MIN_CHANGE)/amt);\n@@ -436,17 +441,17 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n \n             // picking 50 from 100 coins doesn't depend on the shuffle,\n             // but does depend on randomness in the stochastic approximation code\n-            BOOST_CHECK(testWallet.SelectCoinsMinConf(50 * COIN, filter_standard, vCoins, setCoinsRet , nValueRet));\n-            BOOST_CHECK(testWallet.SelectCoinsMinConf(50 * COIN, filter_standard, vCoins, setCoinsRet2, nValueRet));\n+            BOOST_CHECK(testWallet.SelectCoinsMinConf(50 * COIN, filter_standard, vCoins, setCoinsRet , nValueRet, coin_selection_params, bnb_used));\n+            BOOST_CHECK(testWallet.SelectCoinsMinConf(50 * COIN, filter_standard, vCoins, setCoinsRet2, nValueRet, coin_selection_params, bnb_used));\n             BOOST_CHECK(!equal_sets(setCoinsRet, setCoinsRet2));\n \n             int fails = 0;\n             for (int j = 0; j < RANDOM_REPEATS; j++)\n             {\n                 // selecting 1 from 100 identical coins depends on the shuffle; this test will fail 1% of the time\n                 // run the test RANDOM_REPEATS times and only complain if all of them fail\n-                BOOST_CHECK(testWallet.SelectCoinsMinConf(COIN, filter_standard, vCoins, setCoinsRet , nValueRet));\n-                BOOST_CHECK(testWallet.SelectCoinsMinConf(COIN, filter_standard, vCoins, setCoinsRet2, nValueRet));\n+                BOOST_CHECK(testWallet.SelectCoinsMinConf(COIN, filter_standard, vCoins, setCoinsRet , nValueRet, coin_selection_params, bnb_used));\n+                BOOST_CHECK(testWallet.SelectCoinsMinConf(COIN, filter_standard, vCoins, setCoinsRet2, nValueRet, coin_selection_params, bnb_used));\n                 if (equal_sets(setCoinsRet, setCoinsRet2))\n                     fails++;\n             }\n@@ -466,8 +471,8 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n             {\n                 // selecting 1 from 100 identical coins depends on the shuffle; this test will fail 1% of the time\n                 // run the test RANDOM_REPEATS times and only complain if all of them fail\n-                BOOST_CHECK(testWallet.SelectCoinsMinConf(90*CENT, filter_standard, vCoins, setCoinsRet , nValueRet));\n-                BOOST_CHECK(testWallet.SelectCoinsMinConf(90*CENT, filter_standard, vCoins, setCoinsRet2, nValueRet));\n+                BOOST_CHECK(testWallet.SelectCoinsMinConf(90*CENT, filter_standard, vCoins, setCoinsRet , nValueRet, coin_selection_params, bnb_used));\n+                BOOST_CHECK(testWallet.SelectCoinsMinConf(90*CENT, filter_standard, vCoins, setCoinsRet2, nValueRet, coin_selection_params, bnb_used));\n                 if (equal_sets(setCoinsRet, setCoinsRet2))\n                     fails++;\n             }\n@@ -481,6 +486,7 @@ BOOST_AUTO_TEST_CASE(ApproximateBestSubset)\n {\n     CoinSet setCoinsRet;\n     CAmount nValueRet;\n+    bool bnb_used;\n \n     LOCK(testWallet.cs_wallet);\n \n@@ -491,11 +497,55 @@ BOOST_AUTO_TEST_CASE(ApproximateBestSubset)\n         add_coin(1000 * COIN);\n     add_coin(3 * COIN);\n \n-    BOOST_CHECK(testWallet.SelectCoinsMinConf(1003 * COIN, filter_standard, vCoins, setCoinsRet, nValueRet));\n+    BOOST_CHECK(testWallet.SelectCoinsMinConf(1003 * COIN, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n     BOOST_CHECK_EQUAL(nValueRet, 1003 * COIN);\n     BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n \n     empty_wallet();\n }\n \n+// Tests that with the ideal conditions, the coin selector will always be able to find a solution that can pay the target value\n+BOOST_AUTO_TEST_CASE(SelectCoins_test)\n+{\n+    // Random generator stuff\n+    std::default_random_engine generator;\n+    std::exponential_distribution<double> distribution (100);\n+    FastRandomContext rand;\n+\n+    // Output stuff\n+    CAmount out_value = 0;\n+    CoinSet out_set;\n+    CAmount target = 0;\n+    bool bnb_used;\n+\n+    // Run this test 100 times\n+    for (int i = 0; i < 100; ++i)\n+    {\n+        // Reset\n+        out_value = 0;\n+        target = 0;\n+        out_set.clear();\n+        empty_wallet();\n+\n+        // Make a wallet with 1000 exponentially distributed random inputs\n+        for (int j = 0; j < 1000; ++j)\n+        {\n+            add_coin((CAmount)(distribution(generator)*10000000));\n+        }\n+\n+        // Generate a random fee rate in the range of 100 - 400\n+        CFeeRate rate(rand.randrange(300) + 100);\n+\n+        // Generate a random target value between 1000 and wallet balance\n+        target = rand.randrange(balance - 1000) + 1000;\n+\n+        // Perform selection\n+        CoinSelectionParams coin_selection_params_knapsack(false, 34, 148, CFeeRate(0), 0);\n+        CoinSelectionParams coin_selection_params_bnb(true, 34, 148, CFeeRate(0), 0);\n+        BOOST_CHECK(testWallet.SelectCoinsMinConf(target, filter_standard, vCoins, out_set, out_value, coin_selection_params_bnb, bnb_used) ||\n+                    testWallet.SelectCoinsMinConf(target, filter_standard, vCoins, out_set, out_value, coin_selection_params_knapsack, bnb_used));\n+        BOOST_CHECK_GE(out_value, target);\n+    }\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "0a469d7aed9bc5758998f74348a292c52225be74",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 91,
        "deletions": 27,
        "changes": 118,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a34ff5335786615771ca423134a484b04831c4e/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a34ff5335786615771ca423134a484b04831c4e/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=6a34ff5335786615771ca423134a484b04831c4e",
        "patch": "@@ -2444,30 +2444,67 @@ bool CWallet::OutputEligibleForSpending(const COutput& output, const CoinEligibi\n }\n \n bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibilty_filter, std::vector<COutput> vCoins,\n-                                 std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet) const\n+                                 std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params, bool& bnb_used) const\n {\n     setCoinsRet.clear();\n     nValueRet = 0;\n \n     std::vector<CInputCoin> utxo_pool;\n-    for (const COutput &output : vCoins)\n-    {\n-        if (!OutputEligibleForSpending(output, eligibilty_filter))\n-            continue;\n+    if (coin_selection_params.use_bnb) {\n+\n+        // Get long term estimate\n+        FeeCalculation feeCalc;\n+        CCoinControl temp;\n+        temp.m_confirm_target = 1008;\n+        CFeeRate long_term_feerate = GetMinimumFeeRate(temp, ::mempool, ::feeEstimator, &feeCalc);\n+\n+        // Calculate cost of change\n+        CAmount cost_of_change = GetDiscardRate(::feeEstimator).GetFee(coin_selection_params.change_spend_size) + coin_selection_params.effective_fee.GetFee(coin_selection_params.change_output_size);\n+\n+        // Filter by the min conf specs and add to utxo_pool and calculate effective value\n+        for (const COutput &output : vCoins)\n+        {\n+            if (!OutputEligibleForSpending(output, eligibilty_filter))\n+                continue;\n+\n+            CInputCoin coin(output.tx->tx, output.i);\n+            coin.effective_value = coin.txout.nValue - (output.nInputBytes < 0 ? 0 : coin_selection_params.effective_fee.GetFee(output.nInputBytes));\n+            // Only include outputs that are positive effective value (i.e. not dust)\n+            if (coin.effective_value > 0) {\n+                coin.fee = output.nInputBytes < 0 ? 0 : coin_selection_params.effective_fee.GetFee(output.nInputBytes);\n+                coin.long_term_fee = output.nInputBytes < 0 ? 0 : long_term_feerate.GetFee(output.nInputBytes);\n+                utxo_pool.push_back(coin);\n+            }\n+        }\n+        // Calculate the fees for things that aren't inputs\n+        CAmount not_input_fees = coin_selection_params.effective_fee.GetFee(coin_selection_params.tx_noinputs_size);\n+        bnb_used = true;\n+        return SelectCoinsBnB(utxo_pool, nTargetValue, cost_of_change, setCoinsRet, nValueRet, not_input_fees);\n+    } else {\n+        // Filter by the min conf specs and add to utxo_pool\n+        for (const COutput &output : vCoins)\n+        {\n+            if (!OutputEligibleForSpending(output, eligibilty_filter))\n+                continue;\n \n-        CInputCoin coin = CInputCoin(output.tx->tx, output.i);\n-        utxo_pool.push_back(coin);\n+            CInputCoin coin = CInputCoin(output.tx->tx, output.i);\n+            utxo_pool.push_back(coin);\n+        }\n+        bnb_used = false;\n+        return KnapsackSolver(nTargetValue, utxo_pool, setCoinsRet, nValueRet);\n     }\n-    return KnapsackSolver(nTargetValue, utxo_pool, setCoinsRet, nValueRet);\n }\n \n-bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CCoinControl* coinControl) const\n+bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CCoinControl& coin_control, const CoinSelectionParams& coin_selection_params, bool& bnb_used) const\n {\n     std::vector<COutput> vCoins(vAvailableCoins);\n \n     // coin control -> return all selected outputs (we want all selected to go into the transaction for sure)\n-    if (coinControl && coinControl->HasSelected() && !coinControl->fAllowOtherInputs)\n+    if (coin_control.HasSelected() && !coin_control.fAllowOtherInputs)\n     {\n+        // We didn't use BnB here, so set it to false.\n+        bnb_used = false;\n+\n         for (const COutput& out : vCoins)\n         {\n             if (!out.fSpendable)\n@@ -2483,25 +2520,28 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n     CAmount nValueFromPresetInputs = 0;\n \n     std::vector<COutPoint> vPresetInputs;\n-    if (coinControl)\n-        coinControl->ListSelected(vPresetInputs);\n+    coin_control.ListSelected(vPresetInputs);\n     for (const COutPoint& outpoint : vPresetInputs)\n     {\n+        // For now, don't use BnB if preset inputs are selected. TODO: Enable this later\n+        bnb_used = false;\n+\n         std::map<uint256, CWalletTx>::const_iterator it = mapWallet.find(outpoint.hash);\n         if (it != mapWallet.end())\n         {\n             const CWalletTx* pcoin = &it->second;\n             // Clearly invalid input, fail\n             if (pcoin->tx->vout.size() <= outpoint.n)\n                 return false;\n+            // Just to calculate the marginal byte size\n             nValueFromPresetInputs += pcoin->tx->vout[outpoint.n].nValue;\n             setPresetCoins.insert(CInputCoin(pcoin->tx, outpoint.n));\n         } else\n             return false; // TODO: Allow non-wallet inputs\n     }\n \n     // remove preset inputs from vCoins\n-    for (std::vector<COutput>::iterator it = vCoins.begin(); it != vCoins.end() && coinControl && coinControl->HasSelected();)\n+    for (std::vector<COutput>::iterator it = vCoins.begin(); it != vCoins.end() && coin_control.HasSelected();)\n     {\n         if (setPresetCoins.count(CInputCoin(it->tx->tx, it->i)))\n             it = vCoins.erase(it);\n@@ -2513,13 +2553,13 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n     bool fRejectLongChains = gArgs.GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS);\n \n     bool res = nTargetValue <= nValueFromPresetInputs ||\n-        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 6, 0), vCoins, setCoinsRet, nValueRet) ||\n-        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 1, 0), vCoins, setCoinsRet, nValueRet) ||\n-        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, 2), vCoins, setCoinsRet, nValueRet)) ||\n-        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::min((size_t)4, nMaxChainLength/3)), vCoins, setCoinsRet, nValueRet)) ||\n-        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, nMaxChainLength/2), vCoins, setCoinsRet, nValueRet)) ||\n-        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, nMaxChainLength), vCoins, setCoinsRet, nValueRet)) ||\n-        (bSpendZeroConfChange && !fRejectLongChains && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max()), vCoins, setCoinsRet, nValueRet));\n+        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 6, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used) ||\n+        SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(1, 1, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used) ||\n+        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, 2), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n+        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::min((size_t)4, nMaxChainLength/3)), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n+        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, nMaxChainLength/2), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n+        (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, nMaxChainLength), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used)) ||\n+        (bSpendZeroConfChange && !fRejectLongChains && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max()), vCoins, setCoinsRet, nValueRet, coin_selection_params, bnb_used));\n \n     // because SelectCoinsMinConf clears the setCoinsRet, we now add the possible inputs to the coinset\n     setCoinsRet.insert(setPresetCoins.begin(), setPresetCoins.end());\n@@ -2704,6 +2744,7 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n         {\n             std::vector<COutput> vAvailableCoins;\n             AvailableCoins(vAvailableCoins, true, &coin_control);\n+            CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n \n             // Create change script that will be used if we need change\n             // TODO: pass in scriptChange instead of reservekey so\n@@ -2737,12 +2778,20 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n                 scriptChange = GetScriptForDestination(GetDestinationForKey(vchPubKey, change_type));\n             }\n             CTxOut change_prototype_txout(0, scriptChange);\n-            size_t change_prototype_size = GetSerializeSize(change_prototype_txout, SER_DISK, 0);\n+            coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout, SER_DISK, 0);\n \n             CFeeRate discard_rate = GetDiscardRate(::feeEstimator);\n+\n+            // Get the fee rate to use effective values in coin selection\n+            CFeeRate nFeeRateNeeded = GetMinimumFeeRate(coin_control, ::mempool, ::feeEstimator, &feeCalc);\n+\n             nFeeRet = 0;\n             bool pick_new_inputs = true;\n             CAmount nValueIn = 0;\n+\n+            // BnB selector is the only selector used when this is true.\n+            // That should only happen on the first pass through the loop.\n+            coin_selection_params.use_bnb = nSubtractFeeFromAmount == 0; // If we are doing subtract fee from recipient, then don't use BnB\n             // Start with no fee and loop until there is enough fee\n             while (true)\n             {\n@@ -2755,7 +2804,9 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n                 CAmount nValueToSelect = nValue;\n                 if (nSubtractFeeFromAmount == 0)\n                     nValueToSelect += nFeeRet;\n+\n                 // vouts to the payees\n+                coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n                 for (const auto& recipient : vecSend)\n                 {\n                     CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n@@ -2771,6 +2822,8 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n                             txout.nValue -= nFeeRet % nSubtractFeeFromAmount;\n                         }\n                     }\n+                    // Include the fee cost for outputs. Note this is only used for BnB right now\n+                    coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, SER_NETWORK, PROTOCOL_VERSION);\n \n                     if (IsDust(txout, ::dustRelayFee))\n                     {\n@@ -2789,26 +2842,36 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n                 }\n \n                 // Choose coins to use\n+                bool bnb_used;\n                 if (pick_new_inputs) {\n                     nValueIn = 0;\n                     setCoins.clear();\n-                    if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, &coin_control))\n+                    coin_selection_params.change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n+                    coin_selection_params.effective_fee = nFeeRateNeeded;\n+                    if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coin_control, coin_selection_params, bnb_used))\n                     {\n-                        strFailReason = _(\"Insufficient funds\");\n-                        return false;\n+                        // If BnB was used, it was the first pass. No longer the first pass and continue loop with knapsack.\n+                        if (bnb_used) {\n+                            coin_selection_params.use_bnb = false;\n+                            continue;\n+                        }\n+                        else {\n+                            strFailReason = _(\"Insufficient funds\");\n+                            return false;\n+                        }\n                     }\n                 }\n \n                 const CAmount nChange = nValueIn - nValueToSelect;\n-\n                 if (nChange > 0)\n                 {\n                     // Fill a vout to ourself\n                     CTxOut newTxOut(nChange, scriptChange);\n \n                     // Never create dust outputs; if we would, just\n                     // add the dust to the fee.\n-                    if (IsDust(newTxOut, discard_rate))\n+                    // The nChange when BnB is used is always going to go to fees.\n+                    if (IsDust(newTxOut, discard_rate) || bnb_used)\n                     {\n                         nChangePosInOut = -1;\n                         nFeeRet += nChange;\n@@ -2881,7 +2944,7 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n                     // (because of reduced tx size) and so we should add a\n                     // change output. Only try this once.\n                     if (nChangePosInOut == -1 && nSubtractFeeFromAmount == 0 && pick_new_inputs) {\n-                        unsigned int tx_size_with_change = nBytes + change_prototype_size + 2; // Add 2 as a buffer in case increasing # of outputs changes compact size\n+                        unsigned int tx_size_with_change = nBytes + coin_selection_params.change_output_size + 2; // Add 2 as a buffer in case increasing # of outputs changes compact size\n                         CAmount fee_needed_with_change = GetMinimumFee(tx_size_with_change, coin_control, ::mempool, ::feeEstimator, nullptr);\n                         CAmount minimum_value_for_change = GetDustThreshold(change_prototype_txout, discard_rate);\n                         if (nFeeRet >= fee_needed_with_change + minimum_value_for_change) {\n@@ -2929,6 +2992,7 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n \n                 // Include more fee and try again.\n                 nFeeRet = nFeeNeeded;\n+                coin_selection_params.use_bnb = false;\n                 continue;\n             }\n         }"
      },
      {
        "sha": "f50cde60b92d1f14b5c8471495a2c82f3e6c8f99",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 16,
        "deletions": 2,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a34ff5335786615771ca423134a484b04831c4e/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a34ff5335786615771ca423134a484b04831c4e/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=6a34ff5335786615771ca423134a484b04831c4e",
        "patch": "@@ -642,6 +642,18 @@ class CAccountingEntry\n     std::vector<char> _ssExtra;\n };\n \n+struct CoinSelectionParams\n+{\n+    bool use_bnb = true;\n+    size_t change_output_size = 0;\n+    size_t change_spend_size = 0;\n+    CFeeRate effective_fee = CFeeRate(0);\n+    size_t tx_noinputs_size = 0;\n+\n+    CoinSelectionParams(bool use_bnb, size_t change_output_size, size_t change_spend_size, CFeeRate effective_fee, size_t tx_noinputs_size) : use_bnb(use_bnb), change_output_size(change_output_size), change_spend_size(change_spend_size), effective_fee(effective_fee), tx_noinputs_size(tx_noinputs_size) {}\n+    CoinSelectionParams() {}\n+};\n+\n struct CoinEligibilityFilter\n {\n     const int conf_mine;\n@@ -671,7 +683,8 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n      * all coins from coinControl are selected; Never select unconfirmed coins\n      * if they are not ours\n      */\n-    bool SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CCoinControl *coinControl = nullptr) const;\n+    bool SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet,\n+                    const CCoinControl& coin_control, const CoinSelectionParams& coin_selection_params, bool& bnb_used) const;\n \n     CWalletDB *pwalletdbEncryption;\n \n@@ -852,7 +865,8 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n      * completion the coin set and corresponding actual target value is\n      * assembled\n      */\n-    bool SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibilty_filter, std::vector<COutput> vCoins, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet) const;\n+    bool SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibilty_filter, std::vector<COutput> vCoins,\n+        std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params, bool& bnb_used) const;\n \n     bool IsSpent(const uint256& hash, unsigned int n) const;\n "
      }
    ]
  },
  {
    "sha": "76d2f068a4cbd2bfe50c166fe0babfc5f17acaf4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3NmQyZjA2OGE0Y2JkMmJmZTUwYzE2NmZlMGJhYmZjNWYxN2FjYWY0",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-06T19:24:15Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-13T16:39:35Z"
      },
      "message": "Benchmark BnB in the worst case where it exhausts",
      "tree": {
        "sha": "0d98fbdba561f701632b872162c171fdbe32b1f2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0d98fbdba561f701632b872162c171fdbe32b1f2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/76d2f068a4cbd2bfe50c166fe0babfc5f17acaf4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/76d2f068a4cbd2bfe50c166fe0babfc5f17acaf4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/76d2f068a4cbd2bfe50c166fe0babfc5f17acaf4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/76d2f068a4cbd2bfe50c166fe0babfc5f17acaf4/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6a34ff5335786615771ca423134a484b04831c4e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6a34ff5335786615771ca423134a484b04831c4e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6a34ff5335786615771ca423134a484b04831c4e"
      }
    ],
    "stats": {
      "total": 44,
      "additions": 44,
      "deletions": 0
    },
    "files": [
      {
        "sha": "4b2a0e72fe8b06acce3b9931a4493a91b411d902",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 44,
        "deletions": 0,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76d2f068a4cbd2bfe50c166fe0babfc5f17acaf4/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76d2f068a4cbd2bfe50c166fe0babfc5f17acaf4/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=76d2f068a4cbd2bfe50c166fe0babfc5f17acaf4",
        "patch": "@@ -4,6 +4,7 @@\n \n #include <bench/bench.h>\n #include <wallet/wallet.h>\n+#include <wallet/coinselection.h>\n \n #include <set>\n \n@@ -61,4 +62,47 @@ static void CoinSelection(benchmark::State& state)\n     }\n }\n \n+typedef std::set<CInputCoin> CoinSet;\n+\n+// Copied from src/wallet/test/coinselector_tests.cpp\n+static void add_coin(const CAmount& nValue, int nInput, std::vector<CInputCoin>& set)\n+{\n+    CMutableTransaction tx;\n+    tx.vout.resize(nInput + 1);\n+    tx.vout[nInput].nValue = nValue;\n+    set.emplace_back(MakeTransactionRef(tx), nInput);\n+}\n+// Copied from src/wallet/test/coinselector_tests.cpp\n+static CAmount make_hard_case(int utxos, std::vector<CInputCoin>& utxo_pool)\n+{\n+    utxo_pool.clear();\n+    CAmount target = 0;\n+    for (int i = 0; i < utxos; ++i) {\n+        target += (CAmount)1 << (utxos+i);\n+        add_coin((CAmount)1 << (utxos+i), 2*i, utxo_pool);\n+        add_coin(((CAmount)1 << (utxos+i)) + ((CAmount)1 << (utxos-1-i)), 2*i + 1, utxo_pool);\n+    }\n+    return target;\n+}\n+\n+static void BnBExhaustion(benchmark::State& state)\n+{\n+    // Setup\n+    std::vector<CInputCoin> utxo_pool;\n+    CoinSet selection;\n+    CAmount value_ret = 0;\n+    CAmount not_input_fees = 0;\n+\n+    while (state.KeepRunning()) {\n+        // Benchmark\n+        CAmount target = make_hard_case(17, utxo_pool);\n+        SelectCoinsBnB(utxo_pool, target, 0, selection, value_ret, not_input_fees); // Should exhaust\n+\n+        // Cleanup\n+        utxo_pool.clear();\n+        selection.clear();\n+    }\n+}\n+\n BENCHMARK(CoinSelection, 650);\n+BENCHMARK(BnBExhaustion, 650);"
      }
    ]
  },
  {
    "sha": "73b5bf2cb40720bb4e4436ea63b5badf3d89ceb9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3M2I1YmYyY2I0MDcyMGJiNGU0NDM2ZWE2M2I1YmFkZjNkODljZWI5",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-12T23:43:32Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-03-13T16:39:35Z"
      },
      "message": "Add a test to make sure that negative effective values are filtered",
      "tree": {
        "sha": "02aee7c0c32709e73e512847eba36de40c6c8b48",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/02aee7c0c32709e73e512847eba36de40c6c8b48"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/73b5bf2cb40720bb4e4436ea63b5badf3d89ceb9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/73b5bf2cb40720bb4e4436ea63b5badf3d89ceb9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/73b5bf2cb40720bb4e4436ea63b5badf3d89ceb9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/73b5bf2cb40720bb4e4436ea63b5badf3d89ceb9/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "76d2f068a4cbd2bfe50c166fe0babfc5f17acaf4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/76d2f068a4cbd2bfe50c166fe0babfc5f17acaf4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/76d2f068a4cbd2bfe50c166fe0babfc5f17acaf4"
      }
    ],
    "stats": {
      "total": 20,
      "additions": 15,
      "deletions": 5
    },
    "files": [
      {
        "sha": "f05c81cd4c03a4e5275aed4c254800a407652faf",
        "filename": "src/wallet/test/coinselector_tests.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 5,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/73b5bf2cb40720bb4e4436ea63b5badf3d89ceb9/src/wallet/test/coinselector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/73b5bf2cb40720bb4e4436ea63b5badf3d89ceb9/src/wallet/test/coinselector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/coinselector_tests.cpp?ref=73b5bf2cb40720bb4e4436ea63b5badf3d89ceb9",
        "patch": "@@ -30,6 +30,11 @@ static std::vector<COutput> vCoins;\n static const CWallet testWallet(\"dummy\", CWalletDBWrapper::CreateDummy());\n static CAmount balance = 0;\n \n+CoinEligibilityFilter filter_standard(1, 6, 0);\n+CoinEligibilityFilter filter_confirmed(1, 1, 0);\n+CoinEligibilityFilter filter_standard_extra(6, 6, 0);\n+CoinSelectionParams coin_selection_params(false, 0, 0, CFeeRate(0), 0);\n+\n static void add_coin(const CAmount& nValue, int nInput, std::vector<CInputCoin>& set)\n {\n     CMutableTransaction tx;\n@@ -207,12 +212,17 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     for (int i = 0; i < 100; ++i) {\n         BOOST_CHECK(!SelectCoinsBnB(utxo_pool, 1 * CENT, 2 * CENT, selection, value_ret, not_input_fees));\n     }\n-}\n \n-CoinEligibilityFilter filter_standard(1, 6, 0);\n-CoinEligibilityFilter filter_confirmed(1, 1, 0);\n-CoinEligibilityFilter filter_standard_extra(6, 6, 0);\n-CoinSelectionParams coin_selection_params(false, 0, 0, CFeeRate(0), 0);\n+    // Make sure that effective value is working in SelectCoinsMinConf when BnB is used\n+    CoinSelectionParams coin_selection_params_bnb(true, 0, 0, CFeeRate(3000), 0);\n+    CoinSet setCoinsRet;\n+    CAmount nValueRet;\n+    bool bnb_used;\n+    empty_wallet();\n+    add_coin(1);\n+    vCoins.at(0).nInputBytes = 40; // Make sure that it has a negative effective value. The next check should assert if this somehow got through. Otherwise it will fail\n+    BOOST_CHECK(!testWallet.SelectCoinsMinConf( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params_bnb, bnb_used));\n+}\n \n BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n {"
      }
    ]
  }
]