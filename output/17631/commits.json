[
  {
    "sha": "ef7c8228fd5cf45526518ae2bd5ebdd483e65525",
    "node_id": "C_kwDOABII59oAKGVmN2M4MjI4ZmQ1Y2Y0NTUyNjUxOGFlMmJkNWViZGQ0ODNlNjU1MjU",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-11-29T03:39:12Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2021-10-17T02:56:56Z"
      },
      "message": "Expose block filters over REST.\n\nThis adds a new rest endpoint:\n/rest/blockfilter/filtertype/requesttype/blockhash (eg\n/rest/blockfilter/basic/header/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f.hex)\nwhich exposes either the filter \"header\" or the filter data itself.\nMost of the code is cribbed from the equivalent RPC.",
      "tree": {
        "sha": "7bb6ce58e8a924f4d68898bb95ec72c8e008bc7e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7bb6ce58e8a924f4d68898bb95ec72c8e008bc7e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ef7c8228fd5cf45526518ae2bd5ebdd483e65525",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ef7c8228fd5cf45526518ae2bd5ebdd483e65525",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ef7c8228fd5cf45526518ae2bd5ebdd483e65525",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ef7c8228fd5cf45526518ae2bd5ebdd483e65525/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "810ce36d54e4a047f27a099e8295ddadfced75a9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/810ce36d54e4a047f27a099e8295ddadfced75a9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/810ce36d54e4a047f27a099e8295ddadfced75a9"
      }
    ],
    "stats": {
      "total": 222,
      "additions": 217,
      "deletions": 5
    },
    "files": [
      {
        "sha": "18ae3506306ad8c316bf3ead9312cfdb0427162c",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 212,
        "deletions": 3,
        "changes": 215,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ef7c8228fd5cf45526518ae2bd5ebdd483e65525/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ef7c8228fd5cf45526518ae2bd5ebdd483e65525/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=ef7c8228fd5cf45526518ae2bd5ebdd483e65525",
        "patch": "@@ -3,10 +3,12 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include <blockfilter.h>\n #include <chain.h>\n #include <chainparams.h>\n #include <core_io.h>\n #include <httpserver.h>\n+#include <index/blockfilterindex.h>\n #include <index/txindex.h>\n #include <node/blockstorage.h>\n #include <node/context.h>\n@@ -30,6 +32,7 @@\n #include <univalue.h>\n \n static const size_t MAX_GETUTXOS_OUTPOINTS = 15; //allow a max of 15 outpoints to be queried at once\n+static constexpr unsigned int MAX_REST_HEADERS_RESULTS = 2000;\n \n enum class RetFormat {\n     UNDEF,\n@@ -190,8 +193,8 @@ static bool rest_headers(const std::any& context,\n         return RESTERR(req, HTTP_BAD_REQUEST, \"No header count specified. Use /rest/headers/<count>/<hash>.<ext>.\");\n \n     const auto parsed_count{ToIntegral<size_t>(path[0])};\n-    if (!parsed_count.has_value() || *parsed_count < 1 || *parsed_count > 2000) {\n-        return RESTERR(req, HTTP_BAD_REQUEST, \"Header count out of range: \" + path[0]);\n+    if (!parsed_count.has_value() || *parsed_count < 1 || *parsed_count > MAX_REST_HEADERS_RESULTS) {\n+        return RESTERR(req, HTTP_BAD_REQUEST, strprintf(\"Header count out of acceptable range (1-%u): %s\",  MAX_REST_HEADERS_RESULTS, path[0]));\n     }\n \n     std::string hashStr = path[1];\n@@ -254,7 +257,7 @@ static bool rest_headers(const std::any& context,\n         return true;\n     }\n     default: {\n-        return RESTERR(req, HTTP_NOT_FOUND, \"output format not found (available: .bin, .hex, .json)\");\n+        return RESTERR(req, HTTP_NOT_FOUND, \"output format not found (available: \" + AvailableDataFormatsString() + \")\");\n     }\n     }\n }\n@@ -337,6 +340,210 @@ static bool rest_block_notxdetails(const std::any& context, HTTPRequest* req, co\n     return rest_block(context, req, strURIPart, false);\n }\n \n+\n+static bool rest_filter_header(const std::any& context, HTTPRequest* req, const std::string& strURIPart)\n+{\n+    if (!CheckWarmup(req))\n+        return false;\n+    std::string param;\n+    const RetFormat rf = ParseDataFormat(param, strURIPart);\n+\n+    std::vector<std::string> uri_parts;\n+    boost::split(uri_parts, param, boost::is_any_of(\"/\"));\n+    if (uri_parts.size() != 3) {\n+        return RESTERR(req, HTTP_BAD_REQUEST, \"Invalid URI format. Expected /rest/blockfilterheaders/<filtertype>/<count>/<blockhash>\");\n+    }\n+\n+    uint256 block_hash;\n+    if (!ParseHashStr(uri_parts[2], block_hash)) {\n+        return RESTERR(req, HTTP_BAD_REQUEST, \"Invalid hash: \" + uri_parts[2]);\n+    }\n+\n+    BlockFilterType filtertype;\n+    if (!BlockFilterTypeByName(uri_parts[0], filtertype)) {\n+        return RESTERR(req, HTTP_BAD_REQUEST, \"Unknown filtertype \" + uri_parts[0]);\n+    }\n+\n+    BlockFilterIndex* index = GetBlockFilterIndex(filtertype);\n+    if (!index) {\n+        return RESTERR(req, HTTP_BAD_REQUEST, \"Index is not enabled for filtertype \" + uri_parts[0]);\n+    }\n+\n+    const auto parsed_count{ToIntegral<size_t>(uri_parts[1])};\n+    if (!parsed_count.has_value() || *parsed_count < 1 || *parsed_count > MAX_REST_HEADERS_RESULTS) {\n+        return RESTERR(req, HTTP_BAD_REQUEST, strprintf(\"Header count out of acceptable range (1-%u): %s\",  MAX_REST_HEADERS_RESULTS, uri_parts[1]));\n+    }\n+\n+    std::vector<const CBlockIndex *> headers;\n+    headers.reserve(*parsed_count);\n+    {\n+        ChainstateManager* maybe_chainman = GetChainman(context, req);\n+        if (!maybe_chainman) return false;\n+        ChainstateManager& chainman = *maybe_chainman;\n+        LOCK(cs_main);\n+        CChain& active_chain = chainman.ActiveChain();\n+        const CBlockIndex* pindex = chainman.m_blockman.LookupBlockIndex(block_hash);\n+        while (pindex != nullptr && active_chain.Contains(pindex)) {\n+            headers.push_back(pindex);\n+            if (headers.size() == *parsed_count)\n+                break;\n+            pindex = active_chain.Next(pindex);\n+        }\n+    }\n+\n+    bool index_ready = index->BlockUntilSyncedToCurrentChain();\n+\n+    std::vector<uint256> filter_headers;\n+    filter_headers.reserve(*parsed_count);\n+    for (const CBlockIndex *pindex : headers) {\n+        uint256 filter_header;\n+        if (!index->LookupFilterHeader(pindex, filter_header)) {\n+            std::string errmsg = \"Filter not found.\";\n+\n+            if (!index_ready) {\n+                errmsg += \" Block filters are still in the process of being indexed.\";\n+            } else {\n+                errmsg += \" This error is unexpected and indicates index corruption.\";\n+            }\n+\n+            return RESTERR(req, HTTP_NOT_FOUND, errmsg);\n+        }\n+        filter_headers.push_back(filter_header);\n+    }\n+\n+    switch (rf) {\n+    case RetFormat::BINARY: {\n+        CDataStream ssHeader(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());\n+        for (const uint256& header : filter_headers) {\n+            ssHeader << header;\n+        }\n+\n+        std::string binaryHeader = ssHeader.str();\n+        req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n+        req->WriteReply(HTTP_OK, binaryHeader);\n+        return true;\n+    }\n+    case RetFormat::HEX: {\n+        CDataStream ssHeader(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());\n+        for (const uint256& header : filter_headers) {\n+            ssHeader << header;\n+        }\n+\n+        std::string strHex = HexStr(ssHeader) + \"\\n\";\n+        req->WriteHeader(\"Content-Type\", \"text/plain\");\n+        req->WriteReply(HTTP_OK, strHex);\n+        return true;\n+    }\n+    case RetFormat::JSON: {\n+        UniValue jsonHeaders(UniValue::VARR);\n+        for (const uint256& header : filter_headers) {\n+            jsonHeaders.push_back(header.GetHex());\n+        }\n+\n+        std::string strJSON = jsonHeaders.write() + \"\\n\";\n+        req->WriteHeader(\"Content-Type\", \"application/json\");\n+        req->WriteReply(HTTP_OK, strJSON);\n+        return true;\n+    }\n+    default: {\n+        return RESTERR(req, HTTP_NOT_FOUND, \"output format not found (available: \" + AvailableDataFormatsString() + \")\");\n+    }\n+    }\n+}\n+\n+static bool rest_block_filter(const std::any& context, HTTPRequest* req, const std::string& strURIPart)\n+{\n+    if (!CheckWarmup(req))\n+        return false;\n+    std::string param;\n+    const RetFormat rf = ParseDataFormat(param, strURIPart);\n+\n+    //request is sent over URI scheme /rest/blockfilter/filtertype/blockhash\n+    std::vector<std::string> uri_parts;\n+    boost::split(uri_parts, param, boost::is_any_of(\"/\"));\n+    if (uri_parts.size() != 2) {\n+        return RESTERR(req, HTTP_BAD_REQUEST, \"Invalid URI format. Expected /rest/blockfilter/<filtertype>/<blockhash>\");\n+    }\n+\n+    uint256 block_hash;\n+    if (!ParseHashStr(uri_parts[1], block_hash)) {\n+        return RESTERR(req, HTTP_BAD_REQUEST, \"Invalid hash: \" + uri_parts[1]);\n+    }\n+\n+    BlockFilterType filtertype;\n+    if (!BlockFilterTypeByName(uri_parts[0], filtertype)) {\n+        return RESTERR(req, HTTP_BAD_REQUEST, \"Unknown filtertype \" + uri_parts[0]);\n+    }\n+\n+    BlockFilterIndex* index = GetBlockFilterIndex(filtertype);\n+    if (!index) {\n+        return RESTERR(req, HTTP_BAD_REQUEST, \"Index is not enabled for filtertype \" + uri_parts[0]);\n+    }\n+\n+    const CBlockIndex* block_index;\n+    bool block_was_connected;\n+    {\n+        ChainstateManager* maybe_chainman = GetChainman(context, req);\n+        if (!maybe_chainman) return false;\n+        ChainstateManager& chainman = *maybe_chainman;\n+        LOCK(cs_main);\n+        block_index = chainman.m_blockman.LookupBlockIndex(block_hash);\n+        if (!block_index) {\n+            return RESTERR(req, HTTP_NOT_FOUND, uri_parts[1] + \" not found\");\n+        }\n+        block_was_connected = block_index->IsValid(BLOCK_VALID_SCRIPTS);\n+    }\n+\n+    bool index_ready = index->BlockUntilSyncedToCurrentChain();\n+\n+    BlockFilter filter;\n+    if (!index->LookupFilter(block_index, filter)) {\n+        std::string errmsg = \"Filter not found.\";\n+\n+        if (!block_was_connected) {\n+            errmsg += \" Block was not connected to active chain.\";\n+        } else if (!index_ready) {\n+            errmsg += \" Block filters are still in the process of being indexed.\";\n+        } else {\n+            errmsg += \" This error is unexpected and indicates index corruption.\";\n+        }\n+\n+        return RESTERR(req, HTTP_NOT_FOUND, errmsg);\n+    }\n+\n+    switch (rf) {\n+    case RetFormat::BINARY: {\n+        CDataStream ssResp(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());\n+        ssResp << filter;\n+\n+        std::string binaryResp = ssResp.str();\n+        req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n+        req->WriteReply(HTTP_OK, binaryResp);\n+        return true;\n+    }\n+    case RetFormat::HEX: {\n+        CDataStream ssResp(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());\n+        ssResp << filter;\n+\n+        std::string strHex = HexStr(ssResp) + \"\\n\";\n+        req->WriteHeader(\"Content-Type\", \"text/plain\");\n+        req->WriteReply(HTTP_OK, strHex);\n+        return true;\n+    }\n+    case RetFormat::JSON: {\n+        UniValue ret(UniValue::VOBJ);\n+        ret.pushKV(\"filter\", HexStr(filter.GetEncodedFilter()));\n+        std::string strJSON = ret.write() + \"\\n\";\n+        req->WriteHeader(\"Content-Type\", \"application/json\");\n+        req->WriteReply(HTTP_OK, strJSON);\n+        return true;\n+    }\n+    default: {\n+        return RESTERR(req, HTTP_NOT_FOUND, \"output format not found (available: \" + AvailableDataFormatsString() + \")\");\n+    }\n+    }\n+}\n+\n // A bit of a hack - dependency on a function defined in rpc/blockchain.cpp\n RPCHelpMan getblockchaininfo();\n \n@@ -717,6 +924,8 @@ static const struct {\n       {\"/rest/tx/\", rest_tx},\n       {\"/rest/block/notxdetails/\", rest_block_notxdetails},\n       {\"/rest/block/\", rest_block_extended},\n+      {\"/rest/blockfilter/\", rest_block_filter},\n+      {\"/rest/blockfilterheaders/\", rest_filter_header},\n       {\"/rest/chaininfo\", rest_chaininfo},\n       {\"/rest/mempool/info\", rest_mempool_info},\n       {\"/rest/mempool/contents\", rest_mempool_contents},"
      },
      {
        "sha": "3490d8808ccdb27b4a08919084d4f25af34dabd6",
        "filename": "test/functional/interface_rest.py",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ef7c8228fd5cf45526518ae2bd5ebdd483e65525/test/functional/interface_rest.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ef7c8228fd5cf45526518ae2bd5ebdd483e65525/test/functional/interface_rest.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_rest.py?ref=ef7c8228fd5cf45526518ae2bd5ebdd483e65525",
        "patch": "@@ -41,7 +41,7 @@ class RESTTest (BitcoinTestFramework):\n     def set_test_params(self):\n         self.setup_clean_chain = True\n         self.num_nodes = 2\n-        self.extra_args = [[\"-rest\"], []]\n+        self.extra_args = [[\"-rest\", \"-blockfilterindex=1\"], []]\n         self.supports_cli = False\n \n     def skip_test_if_missing_module(self):\n@@ -278,11 +278,14 @@ def run_test(self):\n         self.sync_all()\n         json_obj = self.test_rest_request(f\"/headers/5/{bb_hash}\")\n         assert_equal(len(json_obj), 5)  # now we should have 5 header objects\n+        json_obj = self.test_rest_request(f\"/blockfilterheaders/basic/5/{bb_hash}\")\n+        assert_equal(len(json_obj), 5)  # now we should have 5 filter header objects\n+        self.test_rest_request(f\"/blockfilter/basic/{bb_hash}\", req_type=ReqType.BIN, ret_type=RetType.OBJ)\n \n         # Test number parsing\n         for num in ['5a', '-5', '0', '2001', '99999999999999999999999999999999999']:\n             assert_equal(\n-                bytes(f'Header count out of range: {num}\\r\\n', 'ascii'),\n+                bytes(f'Header count out of acceptable range (1-2000): {num}\\r\\n', 'ascii'),\n                 self.test_rest_request(f\"/headers/{num}/{bb_hash}\", ret_type=RetType.BYTES, status=400),\n             )\n "
      }
    ]
  },
  {
    "sha": "2b64fa3251ac5ff4b4d174f1f0be7226490dce87",
    "node_id": "C_kwDOABII59oAKDJiNjRmYTMyNTFhYzVmZjRiNGQxNzRmMWYwYmU3MjI2NDkwZGNlODc",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2021-10-12T02:56:48Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2021-10-17T02:56:56Z"
      },
      "message": "Update REST docs with new accessors",
      "tree": {
        "sha": "dafff8913879a886fd938b9cf41e81339c37f69f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/dafff8913879a886fd938b9cf41e81339c37f69f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2b64fa3251ac5ff4b4d174f1f0be7226490dce87",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2b64fa3251ac5ff4b4d174f1f0be7226490dce87",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2b64fa3251ac5ff4b4d174f1f0be7226490dce87",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2b64fa3251ac5ff4b4d174f1f0be7226490dce87/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ef7c8228fd5cf45526518ae2bd5ebdd483e65525",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ef7c8228fd5cf45526518ae2bd5ebdd483e65525",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ef7c8228fd5cf45526518ae2bd5ebdd483e65525"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 14,
      "deletions": 0
    },
    "files": [
      {
        "sha": "51a73b89fcecf7e5bf4c24519c6eaa89b5ccc673",
        "filename": "doc/REST-interface.md",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b64fa3251ac5ff4b4d174f1f0be7226490dce87/doc/REST-interface.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b64fa3251ac5ff4b4d174f1f0be7226490dce87/doc/REST-interface.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/REST-interface.md?ref=2b64fa3251ac5ff4b4d174f1f0be7226490dce87",
        "patch": "@@ -52,6 +52,20 @@ With the /notxdetails/ option JSON response will only contain the transaction ha\n Given a block hash: returns <COUNT> amount of blockheaders in upward direction.\n Returns empty if the block doesn't exist or it isn't in the active chain.\n \n+#### Blockfilter Headers\n+`GET /rest/blockfilterheaders/<FILTERTYPE>/<COUNT>/<BLOCK-HASH>.<bin|hex|json>`\n+\n+Given a block hash: returns <COUNT> amount of blockfilter headers in upward\n+direction for the filter type <FILTERTYPE>.\n+Returns empty if the block doesn't exist or it isn't in the active chain.\n+\n+#### Blockfilters\n+`GET /rest/blockfilter/<FILTERTYPE>/<BLOCK-HASH>.<bin|hex|json>`\n+\n+Given a block hash: returns the block filter of the given block of type\n+<FILTERTYPE>.\n+Responds with 404 if the block doesn't exist.\n+\n #### Blockhash by height\n `GET /rest/blockhashbyheight/<HEIGHT>.<bin|hex|json>`\n "
      }
    ]
  }
]