sipa,2017-01-11T18:19:23Z,I measure a 1.5% slowdown from these changes for the SHA256_32b benchmark (i7-6820HQ CPU @ 2.70GHz).,https://github.com/bitcoin/bitcoin/pull/9512#issuecomment-271950266,271950266,
gmaxwell,2017-01-11T22:09:33Z,"@sipa it's frustrating that the compiler doesn't recognize that pattern and peephole optimize it on platforms that support unaligned reads.  At the same time, we really should be using platform optimized SIMD sha256 on our primary platforms, so the performance of this code won't matter once we do.",https://github.com/bitcoin/bitcoin/pull/9512#issuecomment-272011414,272011414,
laanwj,2017-01-12T10:50:06Z,"Specifying &0xff for an unsigned char operation will just be ignored by the compiler (this is a no-brainer optimization). I doubt that is the cause of the slowdown.\n\nI wonder, isn't there some compiler intrinsic for ""non-aligned read of larger type"" that could be detected by autoconf and used if available?\n",https://github.com/bitcoin/bitcoin/pull/9512#issuecomment-272132864,272132864,
sipa,2017-01-12T20:32:34Z,"Updated to use a different approach to avoiding unaligned access, which seems as fast as master for the SHA256_32b benchmark (or even faster, I consistently across different runs see a minimum duration speedup of 0.02-0.025%).\n\nI've also added a commit to remove the use of boost::dynamic_bitset (which ubsan complains about, though I can't see exactly how or why).\n\nNow all unit tests and rp",https://github.com/bitcoin/bitcoin/pull/9512#issuecomment-272275259,272275259,
jtimon,2017-01-13T01:14:52Z,"utACK individual commits: 5a0b7e4106bc97a7a67bda6bf6fbd7f26d892420 99f001eb52dda703bd326833430054b108de35a1\n\nNote: I will edit this post as I go, the list with 2 will hopefully grow, maybe up to 6",https://github.com/bitcoin/bitcoin/pull/9512#issuecomment-272334094,272334094,
gmaxwell,2017-01-13T06:22:07Z,utACK.,https://github.com/bitcoin/bitcoin/pull/9512#issuecomment-272370488,272370488,
gmaxwell,2017-01-17T14:28:19Z,ACK.,https://github.com/bitcoin/bitcoin/pull/9512#issuecomment-273180085,273180085,
laanwj,2017-01-17T14:31:42Z,utACK 82e8baa,https://github.com/bitcoin/bitcoin/pull/9512#issuecomment-273181786,273181786,
dcousens,2017-01-11T00:17:23Z,maybe define these constants ourselves rather than inlining them?,https://github.com/bitcoin/bitcoin/pull/9512#discussion_r95488219,95488219,src/test/scriptnum_tests.cpp
laanwj,2017-01-11T12:47:51Z,Interesting. This would also have failed on CPUs that don't support non-aligned reads (though I know of no such instances reported).,https://github.com/bitcoin/bitcoin/pull/9512#discussion_r95571569,95571569,src/crypto/common.h
laanwj,2017-01-11T12:49:41Z,"What is the problem that sanitize reports here? I don't understand the rationale for using ""40"" here.",https://github.com/bitcoin/bitcoin/pull/9512#discussion_r95571816,95571816,src/test/scriptnum_tests.cpp
sipa,2017-01-11T17:05:22Z,I've just replaced them with integer constants and added a comment.,https://github.com/bitcoin/bitcoin/pull/9512#discussion_r95624023,95624023,src/test/scriptnum_tests.cpp
sipa,2017-01-11T17:05:48Z,Seems ARM supports unaligned reads pretty much since the architecture we support.,https://github.com/bitcoin/bitcoin/pull/9512#discussion_r95624120,95624120,src/crypto/common.h
sipa,2017-01-11T17:07:07Z,"Overflow of signed integers is undefined behaviour. These numbers are added/subtracted from eachother, so that behaviour triggers. However, it doesn't matter in practice, as we only use scriptnums up to 4 bytes (which can turn into 5 bytes after arithmetic).",https://github.com/bitcoin/bitcoin/pull/9512#discussion_r95624410,95624410,src/test/scriptnum_tests.cpp
JeremyRubin,2017-01-11T20:11:55Z,"I think the & 0xFF is redundant here, no? Unless you think there is some pipelining advantage...",https://github.com/bitcoin/bitcoin/pull/9512#discussion_r95661490,95661490,src/crypto/common.h
JeremyRubin,2017-01-11T20:12:56Z,"I think the & 0xFF is redundant here, no? Unless you think there is some pipelining advantage...",https://github.com/bitcoin/bitcoin/pull/9512#discussion_r95661679,95661679,src/crypto/common.h
JeremyRubin,2017-01-11T20:13:23Z,"I think the & 0xFF is redundant here, no? Unless you think there is some pipelining advantage...",https://github.com/bitcoin/bitcoin/pull/9512#discussion_r95661756,95661756,src/crypto/common.h
JeremyRubin,2017-01-11T20:14:55Z,"I think the & 0xFF is redundant here, no? Unless you think there is some pipelining advantage...",https://github.com/bitcoin/bitcoin/pull/9512#discussion_r95662046,95662046,src/crypto/common.h
JeremyRubin,2017-01-11T20:15:16Z,"I think the & 0xFF is redundant here, no? Unless you think there is some pipelining advantage...",https://github.com/bitcoin/bitcoin/pull/9512#discussion_r95662129,95662129,src/crypto/common.h
