[
  {
    "sha": "b0cb5bda712208c50797d5bb04b28d4da6517199",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMGNiNWJkYTcxMjIwOGM1MDc5N2Q1YmIwNGIyOGQ0ZGE2NTE3MTk5",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2014-11-01T03:29:12Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2014-11-01T04:25:03Z"
      },
      "message": "script: work towards creating sane error return codes for script validation\n\nThis is far from complete, but it's enough to get started. The eventual goal is\nto remove application logging from this code, and let bitcoind log based on\nthe return code instead. For now, only the errors with existing error messages\nhave been enumerated, the rest are defined as UNKNOWN_ERROR.",
      "tree": {
        "sha": "6f36120edbb4e10fad5a8442779064303c5b9be6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6f36120edbb4e10fad5a8442779064303c5b9be6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b0cb5bda712208c50797d5bb04b28d4da6517199",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b0cb5bda712208c50797d5bb04b28d4da6517199",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b0cb5bda712208c50797d5bb04b28d4da6517199",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b0cb5bda712208c50797d5bb04b28d4da6517199/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "04e988c6ce1e7255a9575ff2fd130219f03c64f2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/04e988c6ce1e7255a9575ff2fd130219f03c64f2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/04e988c6ce1e7255a9575ff2fd130219f03c64f2"
      }
    ],
    "stats": {
      "total": 335,
      "additions": 228,
      "deletions": 107
    },
    "files": [
      {
        "sha": "8c98c879e1a734b1ab9248762a734899122eb396",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 195,
        "deletions": 105,
        "changes": 300,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0cb5bda712208c50797d5bb04b28d4da6517199/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0cb5bda712208c50797d5bb04b28d4da6517199/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=b0cb5bda712208c50797d5bb04b28d4da6517199",
        "patch": "@@ -25,6 +25,26 @@ static const CScriptNum bnOne(1);\n static const CScriptNum bnFalse(0);\n static const CScriptNum bnTrue(1);\n \n+namespace {\n+\n+inline bool set_success(ScriptError* ret)\n+{\n+    if (ret)\n+        *ret = SCRIPT_NO_ERROR;\n+    return true;\n+}\n+\n+inline bool set_error(ScriptError* ret, const ScriptError serror = SCRIPT_UNKNOWN_ERROR)\n+{\n+    if (ret)\n+        *ret = serror;\n+    if (serror != UNKNOWN_ERROR)\n+        return error(ScriptErrorString(serror));\n+    return false;\n+}\n+\n+} // anon namespace\n+\n bool CastToBool(const valtype& vch)\n {\n     for (unsigned int i = 0; i < vch.size(); i++)\n@@ -52,68 +72,69 @@ static inline void popstack(vector<valtype>& stack)\n         throw runtime_error(\"popstack() : stack empty\");\n     stack.pop_back();\n }\n-\n-bool static IsCompressedOrUncompressedPubKey(const valtype &vchPubKey) {\n-    if (vchPubKey.size() < 33)\n-        return error(\"Non-canonical public key: too short\");\n+bool static IsCompressedOrUncompressedPubKey(const valtype &vchPubKey, ScriptError* serror) {\n+    if (vchPubKey.size() < 33) {\n+        return set_error(serror, PUBKEY_TOO_SHORT);\n+    }\n     if (vchPubKey[0] == 0x04) {\n         if (vchPubKey.size() != 65)\n-            return error(\"Non-canonical public key: invalid length for uncompressed key\");\n+            return set_error(serror, PUBKEY_BAD_UNCOMPRESSED_LENGTH);\n     } else if (vchPubKey[0] == 0x02 || vchPubKey[0] == 0x03) {\n         if (vchPubKey.size() != 33)\n-            return error(\"Non-canonical public key: invalid length for compressed key\");\n+            return set_error(serror, PUBKEY_BAD_COMPRESSED_LENGTH);\n     } else {\n-        return error(\"Non-canonical public key: neither compressed nor uncompressed\");\n+        return set_error(serror, PUBKEY_UNKNOWN_LENGTH);\n     }\n     return true;\n }\n \n-bool static IsDERSignature(const valtype &vchSig) {\n+bool static IsDERSignature(const valtype &vchSig, ScriptError* serror) {\n     // See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623\n     // A canonical signature exists of: <30> <total len> <02> <len R> <R> <02> <len S> <S> <hashtype>\n     // Where R and S are not negative (their first byte has its highest bit not set), and not\n     // excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,\n     // in which case a single 0 byte is necessary and even required).\n     if (vchSig.size() < 9)\n-        return error(\"Non-canonical signature: too short\");\n+        return set_error(serror, SIG_TOO_SHORT);\n     if (vchSig.size() > 73)\n-        return error(\"Non-canonical signature: too long\");\n+        return set_error(serror, SIG_TOO_LONG);\n     if (vchSig[0] != 0x30)\n-        return error(\"Non-canonical signature: wrong type\");\n+        return set_error(serror, SIG_BAD_TYPE);\n     if (vchSig[1] != vchSig.size()-3)\n-        return error(\"Non-canonical signature: wrong length marker\");\n+        return set_error(serror, SIG_BAD_LENGTH_MARKER);\n     unsigned int nLenR = vchSig[3];\n     if (5 + nLenR >= vchSig.size())\n-        return error(\"Non-canonical signature: S length misplaced\");\n+        return set_error(serror, SIG_S_LENGTH_MISPLACED);\n     unsigned int nLenS = vchSig[5+nLenR];\n     if ((unsigned long)(nLenR+nLenS+7) != vchSig.size())\n-        return error(\"Non-canonical signature: R+S length mismatch\");\n+        return set_error(serror, SIG_R_S_LENGTH_MISMATCH);\n \n     const unsigned char *R = &vchSig[4];\n     if (R[-2] != 0x02)\n-        return error(\"Non-canonical signature: R value type mismatch\");\n+        return set_error(serror, SIG_R_TYPE_MISMATCH);\n     if (nLenR == 0)\n-        return error(\"Non-canonical signature: R length is zero\");\n+        return set_error(serror, SIG_R_ZERO_LENGTH);\n     if (R[0] & 0x80)\n-        return error(\"Non-canonical signature: R value negative\");\n+        return set_error(serror, SIG_R_NEGATIVE);\n     if (nLenR > 1 && (R[0] == 0x00) && !(R[1] & 0x80))\n-        return error(\"Non-canonical signature: R value excessively padded\");\n+        return set_error(serror, SIG_R_EXCESSIVE_PADDING);\n \n     const unsigned char *S = &vchSig[6+nLenR];\n     if (S[-2] != 0x02)\n-        return error(\"Non-canonical signature: S value type mismatch\");\n+        return set_error(serror, SIG_S_TYPE_MISMATCH);\n     if (nLenS == 0)\n-        return error(\"Non-canonical signature: S length is zero\");\n+        return set_error(serror, SIG_S_ZERO_LENGTH);\n     if (S[0] & 0x80)\n-        return error(\"Non-canonical signature: S value negative\");\n+        return set_error(serror, SIG_S_NEGATIVE);\n     if (nLenS > 1 && (S[0] == 0x00) && !(S[1] & 0x80))\n-        return error(\"Non-canonical signature: S value excessively padded\");\n+        return set_error(serror, SIG_S_EXCESSIVE_PADDING);\n \n     return true;\n }\n \n-bool static IsLowDERSignature(const valtype &vchSig) {\n-    if (!IsDERSignature(vchSig)) {\n+bool static IsLowDERSignature(const valtype &vchSig, ScriptError* serror) {\n+    if (!IsDERSignature(vchSig, serror)) {\n+        // serror is set\n         return false;\n     }\n     unsigned int nLenR = vchSig[3];\n@@ -123,35 +144,35 @@ bool static IsLowDERSignature(const valtype &vchSig) {\n     // complement modulo the order could have been used instead, which is\n     // one byte shorter when encoded correctly.\n     if (!CKey::CheckSignatureElement(S, nLenS, true))\n-        return error(\"Non-canonical signature: S value is unnecessarily high\");\n+        return set_error(serror, SIG_S_TOO_HIGH);\n \n     return true;\n }\n \n-bool static IsDefinedHashtypeSignature(const valtype &vchSig) {\n+bool static IsDefinedHashtypeSignature(const valtype &vchSig, ScriptError* serror) {\n     if (vchSig.size() == 0) {\n-        return false;\n+        return set_error(serror);\n     }\n     unsigned char nHashType = vchSig[vchSig.size() - 1] & (~(SIGHASH_ANYONECANPAY));\n     if (nHashType < SIGHASH_ALL || nHashType > SIGHASH_SINGLE)\n-        return error(\"Non-canonical signature: unknown hashtype byte\");\n+        return set_error(serror, SIG_BAD_HASHTYPE);\n \n     return true;\n }\n \n-bool static CheckSignatureEncoding(const valtype &vchSig, unsigned int flags) {\n-    if ((flags & (SCRIPT_VERIFY_DERSIG | SCRIPT_VERIFY_LOW_S | SCRIPT_VERIFY_STRICTENC)) != 0 && !IsDERSignature(vchSig)) {\n+bool static CheckSignatureEncoding(const valtype &vchSig, unsigned int flags, ScriptError* serror) {\n+    if ((flags & (SCRIPT_VERIFY_DERSIG | SCRIPT_VERIFY_LOW_S | SCRIPT_VERIFY_STRICTENC)) != 0 && !IsDERSignature(vchSig, serror)) {\n         return false;\n-    } else if ((flags & SCRIPT_VERIFY_LOW_S) != 0 && !IsLowDERSignature(vchSig)) {\n+    } else if ((flags & SCRIPT_VERIFY_LOW_S) != 0 && !IsLowDERSignature(vchSig, serror)) {\n         return false;\n-    } else if ((flags & SCRIPT_VERIFY_STRICTENC) != 0 && !IsDefinedHashtypeSignature(vchSig)) {\n+    } else if ((flags & SCRIPT_VERIFY_STRICTENC) != 0 && !IsDefinedHashtypeSignature(vchSig, serror)) {\n         return false;\n     }\n     return true;\n }\n \n-bool static CheckPubKeyEncoding(const valtype &vchSig, unsigned int flags) {\n-    if ((flags & SCRIPT_VERIFY_STRICTENC) != 0 && !IsCompressedOrUncompressedPubKey(vchSig)) {\n+bool static CheckPubKeyEncoding(const valtype &vchSig, unsigned int flags, ScriptError* serror) {\n+    if ((flags & SCRIPT_VERIFY_STRICTENC) != 0 && !IsCompressedOrUncompressedPubKey(vchSig, serror)) {\n         return false;\n     }\n     return true;\n@@ -180,7 +201,7 @@ bool static CheckMinimalPush(const valtype& data, opcodetype opcode) {\n     return true;\n }\n \n-bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker)\n+bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n {\n     CScript::const_iterator pc = script.begin();\n     CScript::const_iterator pend = script.end();\n@@ -190,7 +211,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n     vector<bool> vfExec;\n     vector<valtype> altstack;\n     if (script.size() > 10000)\n-        return false;\n+        return set_error(serror);\n     int nOpCount = 0;\n     bool fRequireMinimal = (flags & SCRIPT_VERIFY_MINIMALDATA) != 0;\n \n@@ -204,13 +225,13 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n             // Read instruction\n             //\n             if (!script.GetOp(pc, opcode, vchPushValue))\n-                return false;\n+                return set_error(serror);\n             if (vchPushValue.size() > MAX_SCRIPT_ELEMENT_SIZE)\n-                return false;\n+                return set_error(serror);\n \n             // Note how OP_RESERVED does not count towards the opcode limit.\n             if (opcode > OP_16 && ++nOpCount > 201)\n-                return false;\n+                return set_error(serror);\n \n             if (opcode == OP_CAT ||\n                 opcode == OP_SUBSTR ||\n@@ -227,11 +248,11 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 opcode == OP_MOD ||\n                 opcode == OP_LSHIFT ||\n                 opcode == OP_RSHIFT)\n-                return false; // Disabled opcodes.\n+                return set_error(serror); // Disabled opcodes.\n \n             if (fExec && 0 <= opcode && opcode <= OP_PUSHDATA4) {\n                 if (fRequireMinimal && !CheckMinimalPush(vchPushValue, opcode)) {\n-                    return false;\n+                    return set_error(serror);\n                 }\n                 stack.push_back(vchPushValue);\n             } else if (fExec || (OP_IF <= opcode && opcode <= OP_ENDIF))\n@@ -283,7 +304,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                     if (fExec)\n                     {\n                         if (stack.size() < 1)\n-                            return false;\n+                            return set_error(serror);\n                         valtype& vch = stacktop(-1);\n                         fValue = CastToBool(vch);\n                         if (opcode == OP_NOTIF)\n@@ -297,15 +318,15 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 case OP_ELSE:\n                 {\n                     if (vfExec.empty())\n-                        return false;\n+                        return set_error(serror);\n                     vfExec.back() = !vfExec.back();\n                 }\n                 break;\n \n                 case OP_ENDIF:\n                 {\n                     if (vfExec.empty())\n-                        return false;\n+                        return set_error(serror);\n                     vfExec.pop_back();\n                 }\n                 break;\n@@ -315,18 +336,18 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                     // (true -- ) or\n                     // (false -- false) and return\n                     if (stack.size() < 1)\n-                        return false;\n+                        return set_error(serror);\n                     bool fValue = CastToBool(stacktop(-1));\n                     if (fValue)\n                         popstack(stack);\n                     else\n-                        return false;\n+                        return set_error(serror);\n                 }\n                 break;\n \n                 case OP_RETURN:\n                 {\n-                    return false;\n+                    return set_error(serror);\n                 }\n                 break;\n \n@@ -337,7 +358,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 case OP_TOALTSTACK:\n                 {\n                     if (stack.size() < 1)\n-                        return false;\n+                        return set_error(serror);\n                     altstack.push_back(stacktop(-1));\n                     popstack(stack);\n                 }\n@@ -346,7 +367,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 case OP_FROMALTSTACK:\n                 {\n                     if (altstack.size() < 1)\n-                        return false;\n+                        return set_error(serror);\n                     stack.push_back(altstacktop(-1));\n                     popstack(altstack);\n                 }\n@@ -356,7 +377,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x1 x2 -- )\n                     if (stack.size() < 2)\n-                        return false;\n+                        return set_error(serror);\n                     popstack(stack);\n                     popstack(stack);\n                 }\n@@ -366,7 +387,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x1 x2 -- x1 x2 x1 x2)\n                     if (stack.size() < 2)\n-                        return false;\n+                        return set_error(serror);\n                     valtype vch1 = stacktop(-2);\n                     valtype vch2 = stacktop(-1);\n                     stack.push_back(vch1);\n@@ -378,7 +399,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n                     if (stack.size() < 3)\n-                        return false;\n+                        return set_error(serror);\n                     valtype vch1 = stacktop(-3);\n                     valtype vch2 = stacktop(-2);\n                     valtype vch3 = stacktop(-1);\n@@ -392,7 +413,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n                     if (stack.size() < 4)\n-                        return false;\n+                        return set_error(serror);\n                     valtype vch1 = stacktop(-4);\n                     valtype vch2 = stacktop(-3);\n                     stack.push_back(vch1);\n@@ -404,7 +425,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n                     if (stack.size() < 6)\n-                        return false;\n+                        return set_error(serror);\n                     valtype vch1 = stacktop(-6);\n                     valtype vch2 = stacktop(-5);\n                     stack.erase(stack.end()-6, stack.end()-4);\n@@ -417,7 +438,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n                     if (stack.size() < 4)\n-                        return false;\n+                        return set_error(serror);\n                     swap(stacktop(-4), stacktop(-2));\n                     swap(stacktop(-3), stacktop(-1));\n                 }\n@@ -427,7 +448,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x - 0 | x x)\n                     if (stack.size() < 1)\n-                        return false;\n+                        return set_error(serror);\n                     valtype vch = stacktop(-1);\n                     if (CastToBool(vch))\n                         stack.push_back(vch);\n@@ -446,7 +467,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x -- )\n                     if (stack.size() < 1)\n-                        return false;\n+                        return set_error(serror);\n                     popstack(stack);\n                 }\n                 break;\n@@ -455,7 +476,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x -- x x)\n                     if (stack.size() < 1)\n-                        return false;\n+                        return set_error(serror);\n                     valtype vch = stacktop(-1);\n                     stack.push_back(vch);\n                 }\n@@ -465,7 +486,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x1 x2 -- x2)\n                     if (stack.size() < 2)\n-                        return false;\n+                        return set_error(serror);\n                     stack.erase(stack.end() - 2);\n                 }\n                 break;\n@@ -474,7 +495,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x1 x2 -- x1 x2 x1)\n                     if (stack.size() < 2)\n-                        return false;\n+                        return set_error(serror);\n                     valtype vch = stacktop(-2);\n                     stack.push_back(vch);\n                 }\n@@ -486,11 +507,11 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                     // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n                     // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n                     if (stack.size() < 2)\n-                        return false;\n+                        return set_error(serror);\n                     int n = CScriptNum(stacktop(-1), fRequireMinimal).getint();\n                     popstack(stack);\n                     if (n < 0 || n >= (int)stack.size())\n-                        return false;\n+                        return set_error(serror);\n                     valtype vch = stacktop(-n-1);\n                     if (opcode == OP_ROLL)\n                         stack.erase(stack.end()-n-1);\n@@ -504,7 +525,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                     //  x2 x1 x3  after first swap\n                     //  x2 x3 x1  after second swap\n                     if (stack.size() < 3)\n-                        return false;\n+                        return set_error(serror);\n                     swap(stacktop(-3), stacktop(-2));\n                     swap(stacktop(-2), stacktop(-1));\n                 }\n@@ -514,7 +535,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x1 x2 -- x2 x1)\n                     if (stack.size() < 2)\n-                        return false;\n+                        return set_error(serror);\n                     swap(stacktop(-2), stacktop(-1));\n                 }\n                 break;\n@@ -523,7 +544,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x1 x2 -- x2 x1 x2)\n                     if (stack.size() < 2)\n-                        return false;\n+                        return set_error(serror);\n                     valtype vch = stacktop(-1);\n                     stack.insert(stack.end()-2, vch);\n                 }\n@@ -534,7 +555,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (in -- in size)\n                     if (stack.size() < 1)\n-                        return false;\n+                        return set_error(serror);\n                     CScriptNum bn(stacktop(-1).size());\n                     stack.push_back(bn.getvch());\n                 }\n@@ -550,7 +571,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x1 x2 - bool)\n                     if (stack.size() < 2)\n-                        return false;\n+                        return set_error(serror);\n                     valtype& vch1 = stacktop(-2);\n                     valtype& vch2 = stacktop(-1);\n                     bool fEqual = (vch1 == vch2);\n@@ -567,7 +588,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                         if (fEqual)\n                             popstack(stack);\n                         else\n-                            return false;\n+                            return set_error(serror);\n                     }\n                 }\n                 break;\n@@ -585,7 +606,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (in -- out)\n                     if (stack.size() < 1)\n-                        return false;\n+                        return set_error(serror);\n                     CScriptNum bn(stacktop(-1), fRequireMinimal);\n                     switch (opcode)\n                     {\n@@ -618,7 +639,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x1 x2 -- out)\n                     if (stack.size() < 2)\n-                        return false;\n+                        return set_error(serror);\n                     CScriptNum bn1(stacktop(-2), fRequireMinimal);\n                     CScriptNum bn2(stacktop(-1), fRequireMinimal);\n                     CScriptNum bn(0);\n@@ -654,7 +675,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                         if (CastToBool(stacktop(-1)))\n                             popstack(stack);\n                         else\n-                            return false;\n+                            return set_error(serror);\n                     }\n                 }\n                 break;\n@@ -663,7 +684,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x min max -- out)\n                     if (stack.size() < 3)\n-                        return false;\n+                        return set_error(serror);\n                     CScriptNum bn1(stacktop(-3), fRequireMinimal);\n                     CScriptNum bn2(stacktop(-2), fRequireMinimal);\n                     CScriptNum bn3(stacktop(-1), fRequireMinimal);\n@@ -687,7 +708,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (in -- hash)\n                     if (stack.size() < 1)\n-                        return false;\n+                        return set_error(serror);\n                     valtype& vch = stacktop(-1);\n                     valtype vchHash((opcode == OP_RIPEMD160 || opcode == OP_SHA1 || opcode == OP_HASH160) ? 20 : 32);\n                     if (opcode == OP_RIPEMD160)\n@@ -717,7 +738,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (sig pubkey -- bool)\n                     if (stack.size() < 2)\n-                        return false;\n+                        return set_error(serror);\n \n                     valtype& vchSig    = stacktop(-2);\n                     valtype& vchPubKey = stacktop(-1);\n@@ -728,12 +749,19 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                     // Drop the signature, since there's no way for a signature to sign itself\n                     scriptCode.FindAndDelete(CScript(vchSig));\n \n-                    if (!CheckSignatureEncoding(vchSig, flags)) {\n+                    if (!CheckSignatureEncoding(vchSig, flags, serror)) {\n+                        //serror is set\n                         return false;\n                     }\n \n-                    bool fSuccess = CheckPubKeyEncoding(vchPubKey, flags) && checker.CheckSig(vchSig, vchPubKey, scriptCode);\n-\n+                    ScriptError temperror;\n+                    bool fSuccess = CheckPubKeyEncoding(vchPubKey, flags, &temperror);\n+                    if (fSuccess)\n+                    {\n+                        fSuccess = checker.CheckSig(vchSig, vchPubKey, scriptCode);\n+                        if (!fSuccess)\n+                            set_error(&temperror, SIG_BAD);\n+                    }\n                     popstack(stack);\n                     popstack(stack);\n                     stack.push_back(fSuccess ? vchTrue : vchFalse);\n@@ -742,7 +770,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                         if (fSuccess)\n                             popstack(stack);\n                         else\n-                            return false;\n+                            return set_error(serror, temperror);\n                     }\n                 }\n                 break;\n@@ -754,26 +782,26 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n \n                     int i = 1;\n                     if ((int)stack.size() < i)\n-                        return false;\n+                        return set_error(serror);\n \n                     int nKeysCount = CScriptNum(stacktop(-i), fRequireMinimal).getint();\n                     if (nKeysCount < 0 || nKeysCount > 20)\n-                        return false;\n+                        return set_error(serror);\n                     nOpCount += nKeysCount;\n                     if (nOpCount > 201)\n-                        return false;\n+                        return set_error(serror);\n                     int ikey = ++i;\n                     i += nKeysCount;\n                     if ((int)stack.size() < i)\n-                        return false;\n+                        return set_error(serror);\n \n                     int nSigsCount = CScriptNum(stacktop(-i), fRequireMinimal).getint();\n                     if (nSigsCount < 0 || nSigsCount > nKeysCount)\n-                        return false;\n+                        return set_error(serror);\n                     int isig = ++i;\n                     i += nSigsCount;\n                     if ((int)stack.size() < i)\n-                        return false;\n+                        return set_error(serror);\n \n                     // Subset of script starting at the most recent codeseparator\n                     CScript scriptCode(pbegincodehash, pend);\n@@ -791,12 +819,13 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                         valtype& vchSig    = stacktop(-isig);\n                         valtype& vchPubKey = stacktop(-ikey);\n \n-                        if (!CheckSignatureEncoding(vchSig, flags)) {\n+                        if (!CheckSignatureEncoding(vchSig, flags, serror)) {\n+                            // serror is set\n                             return false;\n                         }\n \n                         // Check signature\n-                        bool fOk = CheckPubKeyEncoding(vchPubKey, flags) && checker.CheckSig(vchSig, vchPubKey, scriptCode);\n+                        bool fOk = CheckPubKeyEncoding(vchPubKey, flags, NULL) && checker.CheckSig(vchSig, vchPubKey, scriptCode);\n \n                         if (fOk) {\n                             isig++;\n@@ -822,9 +851,9 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                     // so optionally verify it is exactly equal to zero prior\n                     // to removing it from the stack.\n                     if (stack.size() < 1)\n-                        return false;\n+                        return set_error(serror);\n                     if ((flags & SCRIPT_VERIFY_NULLDUMMY) && stacktop(-1).size())\n-                        return error(\"CHECKMULTISIG dummy argument not null\");\n+                        return set_error(serror, SIG_CHECKMULTISIG_DUMMY_NONNULL);\n                     popstack(stack);\n \n                     stack.push_back(fSuccess ? vchTrue : vchFalse);\n@@ -834,29 +863,29 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                         if (fSuccess)\n                             popstack(stack);\n                         else\n-                            return false;\n+                            return set_error(serror);\n                     }\n                 }\n                 break;\n \n                 default:\n-                    return false;\n+                    return set_error(serror);\n             }\n \n             // Size limits\n             if (stack.size() + altstack.size() > 1000)\n-                return false;\n+                return set_error(serror);\n         }\n     }\n     catch (...)\n     {\n-        return false;\n+        return set_error(serror);\n     }\n \n     if (!vfExec.empty())\n-        return false;\n+        return set_error(serror);\n \n-    return true;\n+    return set_success(serror);\n }\n \n namespace {\n@@ -1007,30 +1036,32 @@ bool SignatureChecker::CheckSig(const vector<unsigned char>& vchSigIn, const vec\n     return true;\n }\n \n-bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, unsigned int flags, const BaseSignatureChecker& checker)\n+bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n {\n     if ((flags & SCRIPT_VERIFY_SIGPUSHONLY) != 0 && !scriptSig.IsPushOnly()) {\n-        return false;\n+        return set_error(serror);\n     }\n \n     vector<vector<unsigned char> > stack, stackCopy;\n-    if (!EvalScript(stack, scriptSig, flags, checker))\n+    if (!EvalScript(stack, scriptSig, flags, checker, serror))\n+        // serror is set\n         return false;\n     if (flags & SCRIPT_VERIFY_P2SH)\n         stackCopy = stack;\n-    if (!EvalScript(stack, scriptPubKey, flags, checker))\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, serror))\n+        // serror is set\n         return false;\n     if (stack.empty())\n-        return false;\n+        return set_error(serror);\n \n     if (CastToBool(stack.back()) == false)\n-        return false;\n+        return set_error(serror);\n \n     // Additional validation for spend-to-script-hash transactions:\n     if ((flags & SCRIPT_VERIFY_P2SH) && scriptPubKey.IsPayToScriptHash())\n     {\n         if (!scriptSig.IsPushOnly()) // scriptSig must be literals-only\n-            return false;            // or validation fails\n+            return set_error(serror);            // or validation fails\n \n         // stackCopy cannot be empty here, because if it was the\n         // P2SH  HASH <> EQUAL  scriptPubKey would be evaluated with\n@@ -1041,12 +1072,71 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, unsigne\n         CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end());\n         popstack(stackCopy);\n \n-        if (!EvalScript(stackCopy, pubKey2, flags, checker))\n+        if (!EvalScript(stackCopy, pubKey2, flags, checker, serror))\n+            // serror is set\n             return false;\n         if (stackCopy.empty())\n-            return false;\n-        return CastToBool(stackCopy.back());\n+            return set_error(serror);\n+        if (!CastToBool(stackCopy.back()))\n+            return set_error(serror);\n+        else\n+            return set_success(serror);\n     }\n \n-    return true;\n+    return set_success(serror);\n+}\n+\n+const char* ScriptErrorString(ScriptError serror)\n+{\n+    switch (serror)\n+    {\n+        case SCRIPT_NO_ERROR:\n+            return \"no error\";\n+        case PUBKEY_TOO_SHORT:\n+            return \"Non-canonical public key: too short\";\n+        case PUBKEY_BAD_UNCOMPRESSED_LENGTH:\n+            return \"Non-canonical public key: invalid length for uncompressed key\";\n+        case PUBKEY_BAD_COMPRESSED_LENGTH:\n+            return \"Non-canonical public key: invalid length for compressed key\";\n+        case PUBKEY_UNKNOWN_LENGTH:\n+            return \"Non-canonical public key: neither compressed nor uncompressed\";\n+        case SIG_TOO_SHORT:\n+            return \"Non-canonical signature: too short\";\n+        case SIG_TOO_LONG:\n+            return \"Non-canonical signature: too long\";\n+        case SIG_BAD_TYPE:\n+            return \"Non-canonical signature: wrong type\";\n+        case SIG_BAD_LENGTH_MARKER:\n+            return \"Non-canonical signature: wrong length marker\";\n+        case SIG_S_LENGTH_MISPLACED:\n+            return \"Non-canonical signature: S length misplaced\";\n+        case SIG_R_S_LENGTH_MISMATCH:\n+            return \"Non-canonical signature: R+S length mismatch\";\n+        case SIG_R_TYPE_MISMATCH:\n+            return \"Non-canonical signature: R value type mismatch\";\n+        case SIG_R_ZERO_LENGTH:\n+            return \"Non-canonical signature: return R length is zero\";\n+        case SIG_R_NEGATIVE:\n+            return \"Non-canonical signature: R value negative\";\n+        case SIG_R_EXCESSIVE_PADDING:\n+            return \"Non-canonical signature: R value excessively padded\";\n+        case SIG_S_TYPE_MISMATCH:\n+            return \"Non-canonical signature: return S value type mismatch\";\n+        case SIG_S_ZERO_LENGTH:\n+            return \"Non-canonical signature: return S length is zero\";\n+        case SIG_S_NEGATIVE:\n+            return \"Non-canonical signature: return S value negative\";\n+        case SIG_S_EXCESSIVE_PADDING:\n+            return \"Non-canonical signature: return S value excessively padded\";\n+        case SIG_S_TOO_HIGH:\n+            return \"Non-canonical signature: S value is unnecessarily high\";\n+        case SIG_BAD_HASHTYPE:\n+            return \"Non-canonical signature: unknown hashtype byte\";\n+        case SIG_CHECKMULTISIG_DUMMY_NONNULL:\n+            return \"CHECKMULTISIG dummy argument not null\";\n+        case SCRIPT_UNKNOWN_ERROR:\n+        case SCRIPT_ERROR_COUNT:\n+        default: break;\n+    }\n+    return \"unknown error\";\n }"
      },
      {
        "sha": "431cfe0f62597660ba01511537cbcdda555596a1",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 33,
        "deletions": 2,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0cb5bda712208c50797d5bb04b28d4da6517199/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0cb5bda712208c50797d5bb04b28d4da6517199/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=b0cb5bda712208c50797d5bb04b28d4da6517199",
        "patch": "@@ -58,8 +58,39 @@ enum\n     SCRIPT_VERIFY_MINIMALDATA = (1U << 6)\n };\n \n+enum ScriptError\n+{\n+    SCRIPT_NO_ERROR = 0,\n+    SCRIPT_UNKNOWN_ERROR,\n+    PUBKEY_TOO_SHORT,\n+    PUBKEY_BAD_UNCOMPRESSED_LENGTH,\n+    PUBKEY_BAD_COMPRESSED_LENGTH,\n+    PUBKEY_UNKNOWN_LENGTH,\n+    SIG_TOO_SHORT,\n+    SIG_TOO_LONG,\n+    SIG_BAD_TYPE,\n+    SIG_BAD_LENGTH_MARKER,\n+    SIG_S_LENGTH_MISPLACED,\n+    SIG_R_S_LENGTH_MISMATCH,\n+    SIG_R_TYPE_MISMATCH,\n+    SIG_R_ZERO_LENGTH,\n+    SIG_R_NEGATIVE,\n+    SIG_R_EXCESSIVE_PADDING,\n+    SIG_S_TOO_HIGH,\n+    SIG_S_TYPE_MISMATCH,\n+    SIG_S_ZERO_LENGTH,\n+    SIG_S_NEGATIVE,\n+    SIG_S_EXCESSIVE_PADDING,\n+    SIG_BAD_HASHTYPE,\n+    SIG_CHECKMULTISIG_DUMMY_NONNULL,\n+    SIG_BAD,\n+    SCRIPT_ERROR_COUNT\n+};\n+\n uint256 SignatureHash(const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n \n+const char* ScriptErrorString(ScriptError error);\n+\n class BaseSignatureChecker\n {\n public:\n@@ -85,7 +116,7 @@ class SignatureChecker : public BaseSignatureChecker\n     bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode) const;\n };\n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker);\n-bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, unsigned int flags, const BaseSignatureChecker& checker);\n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* error = NULL);\n+bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* error = NULL);\n \n #endif // H_BITCOIN_SCRIPT_INTERPRETER"
      }
    ]
  },
  {
    "sha": "69931df631439778f8a072d4a682855d3113b5cb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2OTkzMWRmNjMxNDM5Nzc4ZjhhMDcyZDRhNjgyODU1ZDMxMTNiNWNi",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2014-11-01T04:14:25Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2014-11-01T04:25:04Z"
      },
      "message": "script: remove logging from the script interpreter\n\nHandle logging based on the ScriptError that's returned.",
      "tree": {
        "sha": "98506f852a1d4d905e7bccc24d6f54357fbb7177",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/98506f852a1d4d905e7bccc24d6f54357fbb7177"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/69931df631439778f8a072d4a682855d3113b5cb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/69931df631439778f8a072d4a682855d3113b5cb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/69931df631439778f8a072d4a682855d3113b5cb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/69931df631439778f8a072d4a682855d3113b5cb/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b0cb5bda712208c50797d5bb04b28d4da6517199",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b0cb5bda712208c50797d5bb04b28d4da6517199",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b0cb5bda712208c50797d5bb04b28d4da6517199"
      }
    ],
    "stats": {
      "total": 16,
      "additions": 8,
      "deletions": 8
    },
    "files": [
      {
        "sha": "9edb034ec25bad9e7796c02f2ad645a2db24f022",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 3,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69931df631439778f8a072d4a682855d3113b5cb/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69931df631439778f8a072d4a682855d3113b5cb/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=69931df631439778f8a072d4a682855d3113b5cb",
        "patch": "@@ -716,8 +716,12 @@ bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n         // IsStandard() will have already returned false\n         // and this method isn't called.\n         vector<vector<unsigned char> > stack;\n-        if (!EvalScript(stack, tx.vin[i].scriptSig, false, BaseSignatureChecker()))\n+        ScriptError serror;\n+        if (!EvalScript(stack, tx.vin[i].scriptSig, false, BaseSignatureChecker(), &serror)) {\n+            if (serror != SCRIPT_UNKNOWN_ERROR)\n+                return error(ScriptErrorString(serror));\n             return false;\n+        }\n \n         if (whichType == TX_SCRIPTHASH)\n         {\n@@ -1338,8 +1342,9 @@ void UpdateCoins(const CTransaction& tx, CValidationState &state, CCoinsViewCach\n \n bool CScriptCheck::operator()() const {\n     const CScript &scriptSig = ptxTo->vin[nIn].scriptSig;\n-    if (!VerifyScript(scriptSig, scriptPubKey, nFlags, CachingSignatureChecker(*ptxTo, nIn, cacheStore)))\n-        return error(\"CScriptCheck() : %s:%d VerifySignature failed\", ptxTo->GetHash().ToString(), nIn);\n+    ScriptError serror;\n+    if (!VerifyScript(scriptSig, scriptPubKey, nFlags, CachingSignatureChecker(*ptxTo, nIn, cacheStore), &serror))\n+        return error(\"CScriptCheck() : %s:%d VerifySignature failed. Error: %s\", ptxTo->GetHash().ToString(), nIn, ScriptErrorString(serror));\n     return true;\n }\n "
      },
      {
        "sha": "31a8a25771d2eb4c5441c506d363720cd64781a3",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69931df631439778f8a072d4a682855d3113b5cb/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69931df631439778f8a072d4a682855d3113b5cb/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=69931df631439778f8a072d4a682855d3113b5cb",
        "patch": "@@ -12,7 +12,6 @@\n #include \"key.h\"\n #include \"script/script.h\"\n #include \"uint256.h\"\n-#include \"util.h\"\n \n using namespace std;\n \n@@ -38,8 +37,6 @@ inline bool set_error(ScriptError* ret, const ScriptError serror = SCRIPT_UNKNOW\n {\n     if (ret)\n         *ret = serror;\n-    if (serror != UNKNOWN_ERROR)\n-        return error(ScriptErrorString(serror));\n     return false;\n }\n \n@@ -989,14 +986,12 @@ class CTransactionSignatureSerializer {\n uint256 SignatureHash(const CScript& scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType)\n {\n     if (nIn >= txTo.vin.size()) {\n-        LogPrintf(\"ERROR: SignatureHash() : nIn=%d out of range\\n\", nIn);\n         return 1;\n     }\n \n     // Check for invalid use of SIGHASH_SINGLE\n     if ((nHashType & 0x1f) == SIGHASH_SINGLE) {\n         if (nIn >= txTo.vout.size()) {\n-            LogPrintf(\"ERROR: SignatureHash() : nOut=%d out of range\\n\", nIn);\n             return 1;\n         }\n     }"
      }
    ]
  }
]