[
  {
    "sha": "6f7f5bc0026df12b64935b4e9db32cfc7b6e8829",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ZjdmNWJjMDAyNmRmMTJiNjQ5MzViNGU5ZGIzMmNmYzdiNmU4ODI5",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-29T21:45:24Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-03-18T22:45:22Z"
      },
      "message": "[tests] fix flake8 nits in feature_csv_activation.py",
      "tree": {
        "sha": "8a196db1abde4d8bebe60e5629388304c64a0599",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8a196db1abde4d8bebe60e5629388304c64a0599"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6f7f5bc0026df12b64935b4e9db32cfc7b6e8829",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6f7f5bc0026df12b64935b4e9db32cfc7b6e8829",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6f7f5bc0026df12b64935b4e9db32cfc7b6e8829",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6f7f5bc0026df12b64935b4e9db32cfc7b6e8829/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "00d1680498c5550e7db1f359202d3433a092fafd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00d1680498c5550e7db1f359202d3433a092fafd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/00d1680498c5550e7db1f359202d3433a092fafd"
      }
    ],
    "stats": {
      "total": 186,
      "additions": 96,
      "deletions": 90
    },
    "files": [
      {
        "sha": "0b353e78b55720b557e11fdea442c730966e9d3f",
        "filename": "test/functional/feature_csv_activation.py",
        "status": "modified",
        "additions": 96,
        "deletions": 90,
        "changes": 186,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6f7f5bc0026df12b64935b4e9db32cfc7b6e8829/test/functional/feature_csv_activation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6f7f5bc0026df12b64935b4e9db32cfc7b6e8829/test/functional/feature_csv_activation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_csv_activation.py?ref=6f7f5bc0026df12b64935b4e9db32cfc7b6e8829",
        "patch": "@@ -42,21 +42,30 @@\n bip112txs_vary_OP_CSV_9 - 16 txs with nSequence = 9 evaluated against varying {relative_locktimes of 10} OP_CSV OP_DROP\n bip112tx_special - test negative argument to OP_CSV\n \"\"\"\n+from decimal import Decimal\n+from io import BytesIO\n+import time\n \n-from test_framework.test_framework import ComparisonTestFramework\n-from test_framework.util import *\n-from test_framework.mininode import ToHex, CTransaction, network_thread_start\n from test_framework.blocktools import create_coinbase, create_block\n from test_framework.comptool import TestInstance, TestManager\n-from test_framework.script import *\n-from io import BytesIO\n-import time\n+from test_framework.mininode import ToHex, CTransaction, network_thread_start\n+from test_framework.script import (\n+    CScript,\n+    OP_CHECKSEQUENCEVERIFY,\n+    OP_DROP,\n+)\n+from test_framework.test_framework import ComparisonTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    get_bip9_status,\n+    hex_str_to_bytes,\n+)\n \n base_relative_locktime = 10\n-seq_disable_flag = 1<<31\n-seq_random_high_bit = 1<<25\n-seq_type_flag = 1<<22\n-seq_random_low_bit = 1<<18\n+seq_disable_flag = 1 << 31\n+seq_random_high_bit = 1 << 25\n+seq_type_flag = 1 << 22\n+seq_random_low_bit = 1 << 18\n \n # b31,b25,b22,b18 represent the 31st, 25th, 22nd and 18th bits respectively in the nSequence field\n # relative_locktimes[b31][b25][b22][b18] is a base_relative_locktime with the indicated bits set if their indices are 1\n@@ -108,8 +117,8 @@ def send_generic_input_tx(self, node, coinbases):\n         return node.sendrawtransaction(ToHex(self.sign_transaction(node, self.create_transaction(node, node.getblock(coinbases.pop())['tx'][0], self.nodeaddress, amount))))\n \n     def create_transaction(self, node, txid, to_address, amount):\n-        inputs = [{ \"txid\" : txid, \"vout\" : 0}]\n-        outputs = { to_address : amount }\n+        inputs = [{\"txid\": txid, \"vout\": 0}]\n+        outputs = {to_address: amount}\n         rawtx = node.createrawtransaction(inputs, outputs)\n         tx = CTransaction()\n         f = BytesIO(hex_str_to_bytes(rawtx))\n@@ -124,7 +133,7 @@ def sign_transaction(self, node, unsignedtx):\n         tx.deserialize(f)\n         return tx\n \n-    def generate_blocks(self, number, version, test_blocks = []):\n+    def generate_blocks(self, number, version, test_blocks=[]):\n         for i in range(number):\n             block = self.create_test_block([], version)\n             test_blocks.append([block, True])\n@@ -133,7 +142,7 @@ def generate_blocks(self, number, version, test_blocks = []):\n             self.tipheight += 1\n         return test_blocks\n \n-    def create_test_block(self, txs, version = 536870912):\n+    def create_test_block(self, txs, version=536870912):\n         block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600)\n         block.nVersion = version\n         block.vtx.extend(txs)\n@@ -142,7 +151,7 @@ def create_test_block(self, txs, version = 536870912):\n         block.solve()\n         return block\n \n-    def create_bip68txs(self, bip68inputs, txversion, locktime_delta = 0):\n+    def create_bip68txs(self, bip68inputs, txversion, locktime_delta=0):\n         txs = []\n         assert(len(bip68inputs) >= 16)\n         i = 0\n@@ -153,7 +162,7 @@ def create_bip68txs(self, bip68inputs, txversion, locktime_delta = 0):\n                 for b22 in range(2):\n                     b18txs = []\n                     for b18 in range(2):\n-                        tx =  self.create_transaction(self.nodes[0], bip68inputs[i], self.nodeaddress, Decimal(\"49.98\"))\n+                        tx = self.create_transaction(self.nodes[0], bip68inputs[i], self.nodeaddress, Decimal(\"49.98\"))\n                         i += 1\n                         tx.nVersion = txversion\n                         tx.vin[0].nSequence = relative_locktimes[b31][b25][b22][b18] + locktime_delta\n@@ -170,7 +179,7 @@ def create_bip112special(self, input, txversion):\n         signtx.vin[0].scriptSig = CScript([-1, OP_CHECKSEQUENCEVERIFY, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n         return signtx\n \n-    def create_bip112txs(self, bip112inputs, varyOP_CSV, txversion, locktime_delta = 0):\n+    def create_bip112txs(self, bip112inputs, varyOP_CSV, txversion, locktime_delta=0):\n         txs = []\n         assert(len(bip112inputs) >= 16)\n         i = 0\n@@ -181,11 +190,11 @@ def create_bip112txs(self, bip112inputs, varyOP_CSV, txversion, locktime_delta =\n                 for b22 in range(2):\n                     b18txs = []\n                     for b18 in range(2):\n-                        tx =  self.create_transaction(self.nodes[0], bip112inputs[i], self.nodeaddress, Decimal(\"49.98\"))\n+                        tx = self.create_transaction(self.nodes[0], bip112inputs[i], self.nodeaddress, Decimal(\"49.98\"))\n                         i += 1\n-                        if (varyOP_CSV): # if varying OP_CSV, nSequence is fixed\n+                        if (varyOP_CSV):  # if varying OP_CSV, nSequence is fixed\n                             tx.vin[0].nSequence = base_relative_locktime + locktime_delta\n-                        else: # vary nSequence instead, OP_CSV is fixed\n+                        else:  # vary nSequence instead, OP_CSV is fixed\n                             tx.vin[0].nSequence = relative_locktimes[b31][b25][b22][b18] + locktime_delta\n                         tx.nVersion = txversion\n                         signtx = self.sign_transaction(self.nodes[0], tx)\n@@ -200,46 +209,47 @@ def create_bip112txs(self, bip112inputs, varyOP_CSV, txversion, locktime_delta =\n         return txs\n \n     def get_tests(self):\n-        long_past_time = int(time.time()) - 600 * 1000 # enough to build up to 1000 blocks 10 minutes apart without worrying about getting into the future\n-        self.nodes[0].setmocktime(long_past_time - 100) # enough so that the generated blocks will still all be before long_past_time\n-        self.coinbase_blocks = self.nodes[0].generate(1 + 16 + 2*32 + 1) # 82 blocks generated for inputs\n-        self.nodes[0].setmocktime(0) # set time back to present so yielded blocks aren't in the future as we advance last_block_time\n-        self.tipheight = 82 # height of the next block to build\n+        long_past_time = int(time.time()) - 600 * 1000  # enough to build up to 1000 blocks 10 minutes apart without worrying about getting into the future\n+        self.nodes[0].setmocktime(long_past_time - 100)  # enough so that the generated blocks will still all be before long_past_time\n+        self.coinbase_blocks = self.nodes[0].generate(1 + 16 + 2 * 32 + 1)  # 82 blocks generated for inputs\n+        self.nodes[0].setmocktime(0)  # set time back to present so yielded blocks aren't in the future as we advance last_block_time\n+        self.tipheight = 82  # height of the next block to build\n         self.last_block_time = long_past_time\n-        self.tip = int(\"0x\" + self.nodes[0].getbestblockhash(), 0)\n+        self.tip = int(self.nodes[0].getbestblockhash(), 16)\n         self.nodeaddress = self.nodes[0].getnewaddress()\n \n         assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'defined')\n         test_blocks = self.generate_blocks(61, 4)\n-        yield TestInstance(test_blocks, sync_every_block=False) # 1\n+        yield TestInstance(test_blocks, sync_every_block=False)\n         # Advanced from DEFINED to STARTED, height = 143\n         assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'started')\n \n         # Fail to achieve LOCKED_IN 100 out of 144 signal bit 0\n         # using a variety of bits to simulate multiple parallel softforks\n-        test_blocks = self.generate_blocks(50, 536870913) # 0x20000001 (signalling ready)\n-        test_blocks = self.generate_blocks(20, 4, test_blocks) # 0x00000004 (signalling not)\n-        test_blocks = self.generate_blocks(50, 536871169, test_blocks) # 0x20000101 (signalling ready)\n-        test_blocks = self.generate_blocks(24, 536936448, test_blocks) # 0x20010000 (signalling not)\n-        yield TestInstance(test_blocks, sync_every_block=False) # 2\n+        test_blocks = self.generate_blocks(50, 536870913)  # 0x20000001 (signalling ready)\n+        test_blocks = self.generate_blocks(20, 4, test_blocks)  # 0x00000004 (signalling not)\n+        test_blocks = self.generate_blocks(50, 536871169, test_blocks)  # 0x20000101 (signalling ready)\n+        test_blocks = self.generate_blocks(24, 536936448, test_blocks)  # 0x20010000 (signalling not)\n+        yield TestInstance(test_blocks, sync_every_block=False)\n         # Failed to advance past STARTED, height = 287\n         assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'started')\n \n         # 108 out of 144 signal bit 0 to achieve lock-in\n         # using a variety of bits to simulate multiple parallel softforks\n-        test_blocks = self.generate_blocks(58, 536870913) # 0x20000001 (signalling ready)\n-        test_blocks = self.generate_blocks(26, 4, test_blocks) # 0x00000004 (signalling not)\n-        test_blocks = self.generate_blocks(50, 536871169, test_blocks) # 0x20000101 (signalling ready)\n-        test_blocks = self.generate_blocks(10, 536936448, test_blocks) # 0x20010000 (signalling not)\n-        yield TestInstance(test_blocks, sync_every_block=False) # 3\n+        test_blocks = self.generate_blocks(58, 536870913)  # 0x20000001 (signalling ready)\n+        test_blocks = self.generate_blocks(26, 4, test_blocks)  # 0x00000004 (signalling not)\n+        test_blocks = self.generate_blocks(50, 536871169, test_blocks)  # 0x20000101 (signalling ready)\n+        test_blocks = self.generate_blocks(10, 536936448, test_blocks)  # 0x20010000 (signalling not)\n+        yield TestInstance(test_blocks, sync_every_block=False)\n         # Advanced from STARTED to LOCKED_IN, height = 431\n         assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'locked_in')\n \n         # 140 more version 4 blocks\n         test_blocks = self.generate_blocks(140, 4)\n-        yield TestInstance(test_blocks, sync_every_block=False) # 4\n+        yield TestInstance(test_blocks, sync_every_block=False)\n \n-        ### Inputs at height = 572\n+        # Inputs at height = 572\n+        #\n         # Put inputs for all tests in the chain at height 572 (tip now = 571) (time increases by 600s per block)\n         # Note we reuse inputs for v1 and v2 txs so must test these separately\n         # 16 normal inputs\n@@ -266,16 +276,16 @@ def get_tests(self):\n         bip113input = self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks)\n \n         self.nodes[0].setmocktime(self.last_block_time + 600)\n-        inputblockhash = self.nodes[0].generate(1)[0] # 1 block generated for inputs to be in chain at height 572\n+        inputblockhash = self.nodes[0].generate(1)[0]  # 1 block generated for inputs to be in chain at height 572\n         self.nodes[0].setmocktime(0)\n-        self.tip = int(\"0x\" + inputblockhash, 0)\n+        self.tip = int(inputblockhash, 16)\n         self.tipheight += 1\n         self.last_block_time += 600\n-        assert_equal(len(self.nodes[0].getblock(inputblockhash,True)[\"tx\"]), 82+1)\n+        assert_equal(len(self.nodes[0].getblock(inputblockhash, True)[\"tx\"]), 82 + 1)\n \n         # 2 more version 4 blocks\n         test_blocks = self.generate_blocks(2, 4)\n-        yield TestInstance(test_blocks, sync_every_block=False) # 5\n+        yield TestInstance(test_blocks, sync_every_block=False)\n         # Not yet advanced to ACTIVE, height = 574 (will activate for block 576, not 575)\n         assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'locked_in')\n \n@@ -318,7 +328,7 @@ def get_tests(self):\n         ### Version 1 txs ###\n         success_txs = []\n         # add BIP113 tx and -1 CSV tx\n-        bip113tx_v1.nLockTime = self.last_block_time - 600 * 5 # = MTP of prior block (not <) but < time put on current block\n+        bip113tx_v1.nLockTime = self.last_block_time - 600 * 5  # = MTP of prior block (not <) but < time put on current block\n         bip113signed1 = self.sign_transaction(self.nodes[0], bip113tx_v1)\n         success_txs.append(bip113signed1)\n         success_txs.append(bip112tx_special_v1)\n@@ -330,13 +340,13 @@ def get_tests(self):\n         # try BIP 112 with seq=9 txs\n         success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v1))\n         success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_9_v1))\n-        yield TestInstance([[self.create_test_block(success_txs), True]]) # 6\n+        yield TestInstance([[self.create_test_block(success_txs), True]])\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n         ### Version 2 txs ###\n         success_txs = []\n         # add BIP113 tx and -1 CSV tx\n-        bip113tx_v2.nLockTime = self.last_block_time - 600 * 5 # = MTP of prior block (not <) but < time put on current block\n+        bip113tx_v2.nLockTime = self.last_block_time - 600 * 5  # = MTP of prior block (not <) but < time put on current block\n         bip113signed2 = self.sign_transaction(self.nodes[0], bip113tx_v2)\n         success_txs.append(bip113signed2)\n         success_txs.append(bip112tx_special_v2)\n@@ -348,46 +358,44 @@ def get_tests(self):\n         # try BIP 112 with seq=9 txs\n         success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v2))\n         success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_9_v2))\n-        yield TestInstance([[self.create_test_block(success_txs), True]]) # 7\n+        yield TestInstance([[self.create_test_block(success_txs), True]])\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n-\n         # 1 more version 4 block to get us to height 575 so the fork should now be active for the next block\n         test_blocks = self.generate_blocks(1, 4)\n-        yield TestInstance(test_blocks, sync_every_block=False) # 8\n+        yield TestInstance(test_blocks, sync_every_block=False)\n         assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'active')\n \n-\n         #################################\n         ### After Soft Forks Activate ###\n         #################################\n         ### BIP 113 ###\n         # BIP 113 tests should now fail regardless of version number if nLockTime isn't satisfied by new rules\n-        bip113tx_v1.nLockTime = self.last_block_time - 600 * 5 # = MTP of prior block (not <) but < time put on current block\n+        bip113tx_v1.nLockTime = self.last_block_time - 600 * 5  # = MTP of prior block (not <) but < time put on current block\n         bip113signed1 = self.sign_transaction(self.nodes[0], bip113tx_v1)\n-        bip113tx_v2.nLockTime = self.last_block_time - 600 * 5 # = MTP of prior block (not <) but < time put on current block\n+        bip113tx_v2.nLockTime = self.last_block_time - 600 * 5  # = MTP of prior block (not <) but < time put on current block\n         bip113signed2 = self.sign_transaction(self.nodes[0], bip113tx_v2)\n         for bip113tx in [bip113signed1, bip113signed2]:\n-            yield TestInstance([[self.create_test_block([bip113tx]), False]]) # 9,10\n+            yield TestInstance([[self.create_test_block([bip113tx]), False]])\n         # BIP 113 tests should now pass if the locktime is < MTP\n-        bip113tx_v1.nLockTime = self.last_block_time - 600 * 5 - 1 # < MTP of prior block\n+        bip113tx_v1.nLockTime = self.last_block_time - 600 * 5 - 1  # < MTP of prior block\n         bip113signed1 = self.sign_transaction(self.nodes[0], bip113tx_v1)\n-        bip113tx_v2.nLockTime = self.last_block_time - 600 * 5 - 1 # < MTP of prior block\n+        bip113tx_v2.nLockTime = self.last_block_time - 600 * 5 - 1  # < MTP of prior block\n         bip113signed2 = self.sign_transaction(self.nodes[0], bip113tx_v2)\n         for bip113tx in [bip113signed1, bip113signed2]:\n-            yield TestInstance([[self.create_test_block([bip113tx]), True]]) # 11,12\n+            yield TestInstance([[self.create_test_block([bip113tx]), True]])\n             self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n         # Next block height = 580 after 4 blocks of random version\n         test_blocks = self.generate_blocks(4, 1234)\n-        yield TestInstance(test_blocks, sync_every_block=False) # 13\n+        yield TestInstance(test_blocks, sync_every_block=False)\n \n         ### BIP 68 ###\n         ### Version 1 txs ###\n         # All still pass\n         success_txs = []\n         success_txs.extend(all_rlt_txs(bip68txs_v1))\n-        yield TestInstance([[self.create_test_block(success_txs), True]]) # 14\n+        yield TestInstance([[self.create_test_block(success_txs), True]])\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n         ### Version 2 txs ###\n@@ -397,55 +405,54 @@ def get_tests(self):\n             for b22 in range(2):\n                 for b18 in range(2):\n                     bip68success_txs.append(bip68txs_v2[1][b25][b22][b18])\n-        yield TestInstance([[self.create_test_block(bip68success_txs), True]]) # 15\n+        yield TestInstance([[self.create_test_block(bip68success_txs), True]])\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n         # All txs without flag fail as we are at delta height = 8 < 10 and delta time = 8 * 600 < 10 * 512\n         bip68timetxs = []\n         for b25 in range(2):\n             for b18 in range(2):\n                 bip68timetxs.append(bip68txs_v2[0][b25][1][b18])\n         for tx in bip68timetxs:\n-            yield TestInstance([[self.create_test_block([tx]), False]]) # 16 - 19\n+            yield TestInstance([[self.create_test_block([tx]), False]])\n         bip68heighttxs = []\n         for b25 in range(2):\n             for b18 in range(2):\n                 bip68heighttxs.append(bip68txs_v2[0][b25][0][b18])\n         for tx in bip68heighttxs:\n-            yield TestInstance([[self.create_test_block([tx]), False]]) # 20 - 23\n+            yield TestInstance([[self.create_test_block([tx]), False]])\n \n         # Advance one block to 581\n         test_blocks = self.generate_blocks(1, 1234)\n-        yield TestInstance(test_blocks, sync_every_block=False) # 24\n+        yield TestInstance(test_blocks, sync_every_block=False)\n \n         # Height txs should fail and time txs should now pass 9 * 600 > 10 * 512\n         bip68success_txs.extend(bip68timetxs)\n-        yield TestInstance([[self.create_test_block(bip68success_txs), True]]) # 25\n+        yield TestInstance([[self.create_test_block(bip68success_txs), True]])\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n         for tx in bip68heighttxs:\n-            yield TestInstance([[self.create_test_block([tx]), False]]) # 26 - 29\n+            yield TestInstance([[self.create_test_block([tx]), False]])\n \n         # Advance one block to 582\n         test_blocks = self.generate_blocks(1, 1234)\n-        yield TestInstance(test_blocks, sync_every_block=False) # 30\n+        yield TestInstance(test_blocks, sync_every_block=False)\n \n         # All BIP 68 txs should pass\n         bip68success_txs.extend(bip68heighttxs)\n-        yield TestInstance([[self.create_test_block(bip68success_txs), True]]) # 31\n+        yield TestInstance([[self.create_test_block(bip68success_txs), True]])\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n-\n         ### BIP 112 ###\n         ### Version 1 txs ###\n         # -1 OP_CSV tx should fail\n-        yield TestInstance([[self.create_test_block([bip112tx_special_v1]), False]]) #32\n+        yield TestInstance([[self.create_test_block([bip112tx_special_v1]), False]])\n         # If SEQUENCE_LOCKTIME_DISABLE_FLAG is set in argument to OP_CSV, version 1 txs should still pass\n         success_txs = []\n         for b25 in range(2):\n             for b22 in range(2):\n                 for b18 in range(2):\n                     success_txs.append(bip112txs_vary_OP_CSV_v1[1][b25][b22][b18])\n                     success_txs.append(bip112txs_vary_OP_CSV_9_v1[1][b25][b22][b18])\n-        yield TestInstance([[self.create_test_block(success_txs), True]]) # 33\n+        yield TestInstance([[self.create_test_block(success_txs), True]])\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n         # If SEQUENCE_LOCKTIME_DISABLE_FLAG is unset in argument to OP_CSV, version 1 txs should now fail\n@@ -459,60 +466,61 @@ def get_tests(self):\n                     fail_txs.append(bip112txs_vary_OP_CSV_9_v1[0][b25][b22][b18])\n \n         for tx in fail_txs:\n-            yield TestInstance([[self.create_test_block([tx]), False]]) # 34 - 81\n+            yield TestInstance([[self.create_test_block([tx]), False]])\n \n         ### Version 2 txs ###\n         # -1 OP_CSV tx should fail\n-        yield TestInstance([[self.create_test_block([bip112tx_special_v2]), False]]) #82\n+        yield TestInstance([[self.create_test_block([bip112tx_special_v2]), False]])\n \n         # If SEQUENCE_LOCKTIME_DISABLE_FLAG is set in argument to OP_CSV, version 2 txs should pass (all sequence locks are met)\n         success_txs = []\n         for b25 in range(2):\n             for b22 in range(2):\n                 for b18 in range(2):\n-                    success_txs.append(bip112txs_vary_OP_CSV_v2[1][b25][b22][b18]) # 8/16 of vary_OP_CSV\n-                    success_txs.append(bip112txs_vary_OP_CSV_9_v2[1][b25][b22][b18]) # 8/16 of vary_OP_CSV_9\n+                    success_txs.append(bip112txs_vary_OP_CSV_v2[1][b25][b22][b18])  # 8/16 of vary_OP_CSV\n+                    success_txs.append(bip112txs_vary_OP_CSV_9_v2[1][b25][b22][b18])  # 8/16 of vary_OP_CSV_9\n \n-        yield TestInstance([[self.create_test_block(success_txs), True]]) # 83\n+        yield TestInstance([[self.create_test_block(success_txs), True]])\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n-        ## SEQUENCE_LOCKTIME_DISABLE_FLAG is unset in argument to OP_CSV for all remaining txs ##\n+        # SEQUENCE_LOCKTIME_DISABLE_FLAG is unset in argument to OP_CSV for all remaining txs ##\n+\n         # All txs with nSequence 9 should fail either due to earlier mismatch or failing the CSV check\n         fail_txs = []\n-        fail_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v2)) # 16/16 of vary_nSequence_9\n+        fail_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v2))  # 16/16 of vary_nSequence_9\n         for b25 in range(2):\n             for b22 in range(2):\n                 for b18 in range(2):\n-                    fail_txs.append(bip112txs_vary_OP_CSV_9_v2[0][b25][b22][b18]) # 16/16 of vary_OP_CSV_9\n+                    fail_txs.append(bip112txs_vary_OP_CSV_9_v2[0][b25][b22][b18])  # 16/16 of vary_OP_CSV_9\n \n         for tx in fail_txs:\n-            yield TestInstance([[self.create_test_block([tx]), False]]) # 84 - 107\n+            yield TestInstance([[self.create_test_block([tx]), False]])\n \n         # If SEQUENCE_LOCKTIME_DISABLE_FLAG is set in nSequence, tx should fail\n         fail_txs = []\n         for b25 in range(2):\n             for b22 in range(2):\n                 for b18 in range(2):\n-                    fail_txs.append(bip112txs_vary_nSequence_v2[1][b25][b22][b18]) # 8/16 of vary_nSequence\n+                    fail_txs.append(bip112txs_vary_nSequence_v2[1][b25][b22][b18])  # 8/16 of vary_nSequence\n         for tx in fail_txs:\n-            yield TestInstance([[self.create_test_block([tx]), False]]) # 108-115\n+            yield TestInstance([[self.create_test_block([tx]), False]])\n \n         # If sequencelock types mismatch, tx should fail\n         fail_txs = []\n         for b25 in range(2):\n             for b18 in range(2):\n-                fail_txs.append(bip112txs_vary_nSequence_v2[0][b25][1][b18]) # 12/16 of vary_nSequence\n-                fail_txs.append(bip112txs_vary_OP_CSV_v2[0][b25][1][b18]) # 12/16 of vary_OP_CSV\n+                fail_txs.append(bip112txs_vary_nSequence_v2[0][b25][1][b18])  # 12/16 of vary_nSequence\n+                fail_txs.append(bip112txs_vary_OP_CSV_v2[0][b25][1][b18])  # 12/16 of vary_OP_CSV\n         for tx in fail_txs:\n-            yield TestInstance([[self.create_test_block([tx]), False]]) # 116-123\n+            yield TestInstance([[self.create_test_block([tx]), False]])\n \n         # Remaining txs should pass, just test masking works properly\n         success_txs = []\n         for b25 in range(2):\n             for b18 in range(2):\n-                success_txs.append(bip112txs_vary_nSequence_v2[0][b25][0][b18]) # 16/16 of vary_nSequence\n-                success_txs.append(bip112txs_vary_OP_CSV_v2[0][b25][0][b18]) # 16/16 of vary_OP_CSV\n-        yield TestInstance([[self.create_test_block(success_txs), True]]) # 124\n+                success_txs.append(bip112txs_vary_nSequence_v2[0][b25][0][b18])  # 16/16 of vary_nSequence\n+                success_txs.append(bip112txs_vary_OP_CSV_v2[0][b25][0][b18])  # 16/16 of vary_OP_CSV\n+        yield TestInstance([[self.create_test_block(success_txs), True]])  # 124\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n         # Additional test, of checking that comparison of two time types works properly\n@@ -523,12 +531,10 @@ def get_tests(self):\n                 tx.vin[0].nSequence = base_relative_locktime | seq_type_flag\n                 signtx = self.sign_transaction(self.nodes[0], tx)\n                 time_txs.append(signtx)\n-        yield TestInstance([[self.create_test_block(time_txs), True]]) # 125\n+        yield TestInstance([[self.create_test_block(time_txs), True]])\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n-        ### Missing aspects of test\n-        ##  Testing empty stack fails\n-\n+        # TODO: Test empty stack fails\n \n if __name__ == '__main__':\n     BIP68_112_113Test().main()"
      }
    ]
  },
  {
    "sha": "2e511d54243e360c013079bc8f676934ef450ae3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyZTUxMWQ1NDI0M2UzNjBjMDEzMDc5YmM4ZjY3NjkzNGVmNDUwYWUz",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-29T22:38:51Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-03-18T22:45:25Z"
      },
      "message": "[tests] improve logging in feature_csv_activation.py",
      "tree": {
        "sha": "0170a69db342977570c5f93241f1d391dc1cc6d8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0170a69db342977570c5f93241f1d391dc1cc6d8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2e511d54243e360c013079bc8f676934ef450ae3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2e511d54243e360c013079bc8f676934ef450ae3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2e511d54243e360c013079bc8f676934ef450ae3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2e511d54243e360c013079bc8f676934ef450ae3/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6f7f5bc0026df12b64935b4e9db32cfc7b6e8829",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6f7f5bc0026df12b64935b4e9db32cfc7b6e8829",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6f7f5bc0026df12b64935b4e9db32cfc7b6e8829"
      }
    ],
    "stats": {
      "total": 63,
      "additions": 38,
      "deletions": 25
    },
    "files": [
      {
        "sha": "3591617083970e15022ba51d064c71e655c7086f",
        "filename": "test/functional/feature_csv_activation.py",
        "status": "modified",
        "additions": 38,
        "deletions": 25,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2e511d54243e360c013079bc8f676934ef450ae3/test/functional/feature_csv_activation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2e511d54243e360c013079bc8f676934ef450ae3/test/functional/feature_csv_activation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_csv_activation.py?ref=2e511d54243e360c013079bc8f676934ef450ae3",
        "patch": "@@ -209,6 +209,7 @@ def create_bip112txs(self, bip112inputs, varyOP_CSV, txversion, locktime_delta=0\n         return txs\n \n     def get_tests(self):\n+        self.log.info(\"Generate blocks in the past for coinbase outputs.\")\n         long_past_time = int(time.time()) - 600 * 1000  # enough to build up to 1000 blocks 10 minutes apart without worrying about getting into the future\n         self.nodes[0].setmocktime(long_past_time - 100)  # enough so that the generated blocks will still all be before long_past_time\n         self.coinbase_blocks = self.nodes[0].generate(1 + 16 + 2 * 32 + 1)  # 82 blocks generated for inputs\n@@ -218,33 +219,39 @@ def get_tests(self):\n         self.tip = int(self.nodes[0].getbestblockhash(), 16)\n         self.nodeaddress = self.nodes[0].getnewaddress()\n \n+        self.log.info(\"Test that the csv softfork is DEFINED\")\n         assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'defined')\n         test_blocks = self.generate_blocks(61, 4)\n         yield TestInstance(test_blocks, sync_every_block=False)\n-        # Advanced from DEFINED to STARTED, height = 143\n+\n+        self.log.info(\"Advance from DEFINED to STARTED, height = 143\")\n         assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'started')\n \n-        # Fail to achieve LOCKED_IN 100 out of 144 signal bit 0\n-        # using a variety of bits to simulate multiple parallel softforks\n+        self.log.info(\"Fail to achieve LOCKED_IN\")\n+        # 100 out of 144 signal bit 0. Use a variety of bits to simulate multiple parallel softforks\n+\n         test_blocks = self.generate_blocks(50, 536870913)  # 0x20000001 (signalling ready)\n         test_blocks = self.generate_blocks(20, 4, test_blocks)  # 0x00000004 (signalling not)\n         test_blocks = self.generate_blocks(50, 536871169, test_blocks)  # 0x20000101 (signalling ready)\n         test_blocks = self.generate_blocks(24, 536936448, test_blocks)  # 0x20010000 (signalling not)\n         yield TestInstance(test_blocks, sync_every_block=False)\n-        # Failed to advance past STARTED, height = 287\n+\n+        self.log.info(\"Failed to advance past STARTED, height = 287\")\n         assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'started')\n \n+        self.log.info(\"Generate blocks to achieve LOCK-IN\")\n         # 108 out of 144 signal bit 0 to achieve lock-in\n         # using a variety of bits to simulate multiple parallel softforks\n         test_blocks = self.generate_blocks(58, 536870913)  # 0x20000001 (signalling ready)\n         test_blocks = self.generate_blocks(26, 4, test_blocks)  # 0x00000004 (signalling not)\n         test_blocks = self.generate_blocks(50, 536871169, test_blocks)  # 0x20000101 (signalling ready)\n         test_blocks = self.generate_blocks(10, 536936448, test_blocks)  # 0x20010000 (signalling not)\n         yield TestInstance(test_blocks, sync_every_block=False)\n-        # Advanced from STARTED to LOCKED_IN, height = 431\n+\n+        self.log.info(\"Advanced from STARTED to LOCKED_IN, height = 431\")\n         assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'locked_in')\n \n-        # 140 more version 4 blocks\n+        # Generate 140 more version 4 blocks\n         test_blocks = self.generate_blocks(140, 4)\n         yield TestInstance(test_blocks, sync_every_block=False)\n \n@@ -256,22 +263,26 @@ def get_tests(self):\n         bip68inputs = []\n         for i in range(16):\n             bip68inputs.append(self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks))\n+\n         # 2 sets of 16 inputs with 10 OP_CSV OP_DROP (actually will be prepended to spending scriptSig)\n         bip112basicinputs = []\n         for j in range(2):\n             inputs = []\n             for i in range(16):\n                 inputs.append(self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks))\n             bip112basicinputs.append(inputs)\n+\n         # 2 sets of 16 varied inputs with (relative_lock_time) OP_CSV OP_DROP (actually will be prepended to spending scriptSig)\n         bip112diverseinputs = []\n         for j in range(2):\n             inputs = []\n             for i in range(16):\n                 inputs.append(self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks))\n             bip112diverseinputs.append(inputs)\n+\n         # 1 special input with -1 OP_CSV OP_DROP (actually will be prepended to spending scriptSig)\n         bip112specialinput = self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks)\n+\n         # 1 normal input\n         bip113input = self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks)\n \n@@ -286,7 +297,8 @@ def get_tests(self):\n         # 2 more version 4 blocks\n         test_blocks = self.generate_blocks(2, 4)\n         yield TestInstance(test_blocks, sync_every_block=False)\n-        # Not yet advanced to ACTIVE, height = 574 (will activate for block 576, not 575)\n+\n+        self.log.info(\"Not yet advanced to ACTIVE, height = 574 (will activate for block 576, not 575)\")\n         assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'locked_in')\n \n         # Test both version 1 and version 2 transactions for all tests\n@@ -319,13 +331,11 @@ def get_tests(self):\n         bip112tx_special_v1 = self.create_bip112special(bip112specialinput, 1)\n         bip112tx_special_v2 = self.create_bip112special(bip112specialinput, 2)\n \n+        self.log.info(\"TESTING\")\n+\n+        self.log.info(\"Pre-Soft Fork Tests. All txs should pass.\")\n+        self.log.info(\"Test version 1 txs\")\n \n-        ### TESTING ###\n-        ##################################\n-        ### Before Soft Forks Activate ###\n-        ##################################\n-        # All txs should pass\n-        ### Version 1 txs ###\n         success_txs = []\n         # add BIP113 tx and -1 CSV tx\n         bip113tx_v1.nLockTime = self.last_block_time - 600 * 5  # = MTP of prior block (not <) but < time put on current block\n@@ -343,7 +353,8 @@ def get_tests(self):\n         yield TestInstance([[self.create_test_block(success_txs), True]])\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n-        ### Version 2 txs ###\n+        self.log.info(\"Test version 2 txs\")\n+\n         success_txs = []\n         # add BIP113 tx and -1 CSV tx\n         bip113tx_v2.nLockTime = self.last_block_time - 600 * 5  # = MTP of prior block (not <) but < time put on current block\n@@ -366,10 +377,9 @@ def get_tests(self):\n         yield TestInstance(test_blocks, sync_every_block=False)\n         assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'active')\n \n-        #################################\n-        ### After Soft Forks Activate ###\n-        #################################\n-        ### BIP 113 ###\n+        self.log.info(\"Post-Soft Fork Tests.\")\n+\n+        self.log.info(\"BIP 113 tests\")\n         # BIP 113 tests should now fail regardless of version number if nLockTime isn't satisfied by new rules\n         bip113tx_v1.nLockTime = self.last_block_time - 600 * 5  # = MTP of prior block (not <) but < time put on current block\n         bip113signed1 = self.sign_transaction(self.nodes[0], bip113tx_v1)\n@@ -390,15 +400,16 @@ def get_tests(self):\n         test_blocks = self.generate_blocks(4, 1234)\n         yield TestInstance(test_blocks, sync_every_block=False)\n \n-        ### BIP 68 ###\n-        ### Version 1 txs ###\n-        # All still pass\n+        self.log.info(\"BIP 68 tests\")\n+        self.log.info(\"Test version 1 txs - all should still pass\")\n+\n         success_txs = []\n         success_txs.extend(all_rlt_txs(bip68txs_v1))\n         yield TestInstance([[self.create_test_block(success_txs), True]])\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n-        ### Version 2 txs ###\n+        self.log.info(\"Test version 2 txs\")\n+\n         bip68success_txs = []\n         # All txs with SEQUENCE_LOCKTIME_DISABLE_FLAG set pass\n         for b25 in range(2):\n@@ -441,8 +452,9 @@ def get_tests(self):\n         yield TestInstance([[self.create_test_block(bip68success_txs), True]])\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n-        ### BIP 112 ###\n-        ### Version 1 txs ###\n+        self.log.info(\"BIP 112 tests\")\n+        self.log.info(\"Test version 1 txs\")\n+\n         # -1 OP_CSV tx should fail\n         yield TestInstance([[self.create_test_block([bip112tx_special_v1]), False]])\n         # If SEQUENCE_LOCKTIME_DISABLE_FLAG is set in argument to OP_CSV, version 1 txs should still pass\n@@ -468,7 +480,8 @@ def get_tests(self):\n         for tx in fail_txs:\n             yield TestInstance([[self.create_test_block([tx]), False]])\n \n-        ### Version 2 txs ###\n+        self.log.info(\"Version 2 txs\")\n+\n         # -1 OP_CSV tx should fail\n         yield TestInstance([[self.create_test_block([bip112tx_special_v2]), False]])\n "
      }
    ]
  },
  {
    "sha": "0842edf9ee7d659408e48b8897ac4a272e48b716",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowODQyZWRmOWVlN2Q2NTk0MDhlNDhiODg5N2FjNGEyNzJlNDhiNzE2",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-30T21:25:27Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-03-22T13:35:11Z"
      },
      "message": "[tests] Remove nested loops from feature_csv_activation.py\n\nMakes the test a lot clearer.",
      "tree": {
        "sha": "a81dea4124c41a8b12abd6ce4756972c5d4cc0bc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a81dea4124c41a8b12abd6ce4756972c5d4cc0bc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0842edf9ee7d659408e48b8897ac4a272e48b716",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0842edf9ee7d659408e48b8897ac4a272e48b716",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0842edf9ee7d659408e48b8897ac4a272e48b716",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0842edf9ee7d659408e48b8897ac4a272e48b716/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2e511d54243e360c013079bc8f676934ef450ae3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2e511d54243e360c013079bc8f676934ef450ae3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2e511d54243e360c013079bc8f676934ef450ae3"
      }
    ],
    "stats": {
      "total": 215,
      "additions": 75,
      "deletions": 140
    },
    "files": [
      {
        "sha": "1e549eba630e58cc9c571d8daf3ce984cc5fceca",
        "filename": "test/functional/feature_csv_activation.py",
        "status": "modified",
        "additions": 75,
        "deletions": 140,
        "changes": 215,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0842edf9ee7d659408e48b8897ac4a272e48b716/test/functional/feature_csv_activation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0842edf9ee7d659408e48b8897ac4a272e48b716/test/functional/feature_csv_activation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_csv_activation.py?ref=0842edf9ee7d659408e48b8897ac4a272e48b716",
        "patch": "@@ -43,6 +43,7 @@\n bip112tx_special - test negative argument to OP_CSV\n \"\"\"\n from decimal import Decimal\n+from itertools import product\n from io import BytesIO\n import time\n \n@@ -61,44 +62,28 @@\n     hex_str_to_bytes,\n )\n \n-base_relative_locktime = 10\n-seq_disable_flag = 1 << 31\n-seq_random_high_bit = 1 << 25\n-seq_type_flag = 1 << 22\n-seq_random_low_bit = 1 << 18\n-\n-# b31,b25,b22,b18 represent the 31st, 25th, 22nd and 18th bits respectively in the nSequence field\n-# relative_locktimes[b31][b25][b22][b18] is a base_relative_locktime with the indicated bits set if their indices are 1\n-relative_locktimes = []\n-for b31 in range(2):\n-    b25times = []\n-    for b25 in range(2):\n-        b22times = []\n-        for b22 in range(2):\n-            b18times = []\n-            for b18 in range(2):\n-                rlt = base_relative_locktime\n-                if (b31):\n-                    rlt = rlt | seq_disable_flag\n-                if (b25):\n-                    rlt = rlt | seq_random_high_bit\n-                if (b22):\n-                    rlt = rlt | seq_type_flag\n-                if (b18):\n-                    rlt = rlt | seq_random_low_bit\n-                b18times.append(rlt)\n-            b22times.append(b18times)\n-        b25times.append(b22times)\n-    relative_locktimes.append(b25times)\n-\n-def all_rlt_txs(txarray):\n-    txs = []\n-    for b31 in range(2):\n-        for b25 in range(2):\n-            for b22 in range(2):\n-                for b18 in range(2):\n-                    txs.append(txarray[b31][b25][b22][b18])\n-    return txs\n+BASE_RELATIVE_LOCKTIME = 10\n+SEQ_DISABLE_FLAG = 1 << 31\n+SEQ_RANDOM_HIGH_BIT = 1 << 25\n+SEQ_TYPE_FLAG = 1 << 22\n+SEQ_RANDOM_LOW_BIT = 1 << 18\n+\n+def relative_locktime(sdf, srhb, stf, srlb):\n+    \"\"\"Returns a locktime with certain bits set.\"\"\"\n+\n+    locktime = BASE_RELATIVE_LOCKTIME\n+    if sdf:\n+        locktime |= SEQ_DISABLE_FLAG\n+    if srhb:\n+        locktime |= SEQ_RANDOM_HIGH_BIT\n+    if stf:\n+        locktime |= SEQ_TYPE_FLAG\n+    if srlb:\n+        locktime |= SEQ_RANDOM_LOW_BIT\n+    return locktime\n+\n+def all_rlt_txs(txs):\n+    return [tx['tx'] for tx in txs]\n \n class BIP68_112_113Test(ComparisonTestFramework):\n     def set_test_params(self):\n@@ -152,24 +137,18 @@ def create_test_block(self, txs, version=536870912):\n         return block\n \n     def create_bip68txs(self, bip68inputs, txversion, locktime_delta=0):\n+        \"\"\"Returns a list of bip68 transactions with different bits set.\"\"\"\n         txs = []\n         assert(len(bip68inputs) >= 16)\n-        i = 0\n-        for b31 in range(2):\n-            b25txs = []\n-            for b25 in range(2):\n-                b22txs = []\n-                for b22 in range(2):\n-                    b18txs = []\n-                    for b18 in range(2):\n-                        tx = self.create_transaction(self.nodes[0], bip68inputs[i], self.nodeaddress, Decimal(\"49.98\"))\n-                        i += 1\n-                        tx.nVersion = txversion\n-                        tx.vin[0].nSequence = relative_locktimes[b31][b25][b22][b18] + locktime_delta\n-                        b18txs.append(self.sign_transaction(self.nodes[0], tx))\n-                    b22txs.append(b18txs)\n-                b25txs.append(b22txs)\n-            txs.append(b25txs)\n+        for i, (sdf, srhb, stf, srlb) in enumerate(product(*[[True, False]] * 4)):\n+            locktime = relative_locktime(sdf, srhb, stf, srlb)\n+            tx = self.create_transaction(self.nodes[0], bip68inputs[i], self.nodeaddress, Decimal(\"49.98\"))\n+            tx.nVersion = txversion\n+            tx.vin[0].nSequence = locktime + locktime_delta\n+            tx = self.sign_transaction(self.nodes[0], tx)\n+            tx.rehash()\n+            txs.append({'tx': tx, 'sdf': sdf, 'stf': stf})\n+\n         return txs\n \n     def create_bip112special(self, input, txversion):\n@@ -180,32 +159,24 @@ def create_bip112special(self, input, txversion):\n         return signtx\n \n     def create_bip112txs(self, bip112inputs, varyOP_CSV, txversion, locktime_delta=0):\n+        \"\"\"Returns a list of bip68 transactions with different bits set.\"\"\"\n         txs = []\n         assert(len(bip112inputs) >= 16)\n-        i = 0\n-        for b31 in range(2):\n-            b25txs = []\n-            for b25 in range(2):\n-                b22txs = []\n-                for b22 in range(2):\n-                    b18txs = []\n-                    for b18 in range(2):\n-                        tx = self.create_transaction(self.nodes[0], bip112inputs[i], self.nodeaddress, Decimal(\"49.98\"))\n-                        i += 1\n-                        if (varyOP_CSV):  # if varying OP_CSV, nSequence is fixed\n-                            tx.vin[0].nSequence = base_relative_locktime + locktime_delta\n-                        else:  # vary nSequence instead, OP_CSV is fixed\n-                            tx.vin[0].nSequence = relative_locktimes[b31][b25][b22][b18] + locktime_delta\n-                        tx.nVersion = txversion\n-                        signtx = self.sign_transaction(self.nodes[0], tx)\n-                        if (varyOP_CSV):\n-                            signtx.vin[0].scriptSig = CScript([relative_locktimes[b31][b25][b22][b18], OP_CHECKSEQUENCEVERIFY, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n-                        else:\n-                            signtx.vin[0].scriptSig = CScript([base_relative_locktime, OP_CHECKSEQUENCEVERIFY, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n-                        b18txs.append(signtx)\n-                    b22txs.append(b18txs)\n-                b25txs.append(b22txs)\n-            txs.append(b25txs)\n+        for i, (sdf, srhb, stf, srlb) in enumerate(product(*[[True, False]] * 4)):\n+            locktime = relative_locktime(sdf, srhb, stf, srlb)\n+            tx = self.create_transaction(self.nodes[0], bip112inputs[i], self.nodeaddress, Decimal(\"49.98\"))\n+            if (varyOP_CSV):  # if varying OP_CSV, nSequence is fixed\n+                tx.vin[0].nSequence = BASE_RELATIVE_LOCKTIME + locktime_delta\n+            else:  # vary nSequence instead, OP_CSV is fixed\n+                tx.vin[0].nSequence = locktime + locktime_delta\n+            tx.nVersion = txversion\n+            signtx = self.sign_transaction(self.nodes[0], tx)\n+            if (varyOP_CSV):\n+                signtx.vin[0].scriptSig = CScript([locktime, OP_CHECKSEQUENCEVERIFY, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n+            else:\n+                signtx.vin[0].scriptSig = CScript([BASE_RELATIVE_LOCKTIME, OP_CHECKSEQUENCEVERIFY, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n+            tx.rehash()\n+            txs.append({'tx': signtx, 'sdf': sdf, 'stf': stf})\n         return txs\n \n     def get_tests(self):\n@@ -410,25 +381,17 @@ def get_tests(self):\n \n         self.log.info(\"Test version 2 txs\")\n \n-        bip68success_txs = []\n         # All txs with SEQUENCE_LOCKTIME_DISABLE_FLAG set pass\n-        for b25 in range(2):\n-            for b22 in range(2):\n-                for b18 in range(2):\n-                    bip68success_txs.append(bip68txs_v2[1][b25][b22][b18])\n+        bip68success_txs = [tx['tx'] for tx in bip68txs_v2 if tx['sdf']]\n         yield TestInstance([[self.create_test_block(bip68success_txs), True]])\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n         # All txs without flag fail as we are at delta height = 8 < 10 and delta time = 8 * 600 < 10 * 512\n-        bip68timetxs = []\n-        for b25 in range(2):\n-            for b18 in range(2):\n-                bip68timetxs.append(bip68txs_v2[0][b25][1][b18])\n+        bip68timetxs = [tx['tx'] for tx in bip68txs_v2 if not tx['sdf'] and tx['stf']]\n         for tx in bip68timetxs:\n             yield TestInstance([[self.create_test_block([tx]), False]])\n-        bip68heighttxs = []\n-        for b25 in range(2):\n-            for b18 in range(2):\n-                bip68heighttxs.append(bip68txs_v2[0][b25][0][b18])\n+\n+        bip68heighttxs = [tx['tx'] for tx in bip68txs_v2 if not tx['sdf'] and not tx['stf']]\n         for tx in bip68heighttxs:\n             yield TestInstance([[self.create_test_block([tx]), False]])\n \n@@ -458,25 +421,17 @@ def get_tests(self):\n         # -1 OP_CSV tx should fail\n         yield TestInstance([[self.create_test_block([bip112tx_special_v1]), False]])\n         # If SEQUENCE_LOCKTIME_DISABLE_FLAG is set in argument to OP_CSV, version 1 txs should still pass\n-        success_txs = []\n-        for b25 in range(2):\n-            for b22 in range(2):\n-                for b18 in range(2):\n-                    success_txs.append(bip112txs_vary_OP_CSV_v1[1][b25][b22][b18])\n-                    success_txs.append(bip112txs_vary_OP_CSV_9_v1[1][b25][b22][b18])\n+\n+        success_txs = [tx['tx'] for tx in bip112txs_vary_OP_CSV_v1 if tx['sdf']]\n+        success_txs += [tx['tx'] for tx in bip112txs_vary_OP_CSV_9_v1 if tx['sdf']]\n         yield TestInstance([[self.create_test_block(success_txs), True]])\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n         # If SEQUENCE_LOCKTIME_DISABLE_FLAG is unset in argument to OP_CSV, version 1 txs should now fail\n-        fail_txs = []\n-        fail_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_v1))\n-        fail_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v1))\n-        for b25 in range(2):\n-            for b22 in range(2):\n-                for b18 in range(2):\n-                    fail_txs.append(bip112txs_vary_OP_CSV_v1[0][b25][b22][b18])\n-                    fail_txs.append(bip112txs_vary_OP_CSV_9_v1[0][b25][b22][b18])\n-\n+        fail_txs = all_rlt_txs(bip112txs_vary_nSequence_v1)\n+        fail_txs += all_rlt_txs(bip112txs_vary_nSequence_9_v1)\n+        fail_txs += [tx['tx'] for tx in bip112txs_vary_OP_CSV_9_v1 if not tx['sdf']]\n+        fail_txs += [tx['tx'] for tx in bip112txs_vary_OP_CSV_9_v1 if not tx['sdf']]\n         for tx in fail_txs:\n             yield TestInstance([[self.create_test_block([tx]), False]])\n \n@@ -486,64 +441,44 @@ def get_tests(self):\n         yield TestInstance([[self.create_test_block([bip112tx_special_v2]), False]])\n \n         # If SEQUENCE_LOCKTIME_DISABLE_FLAG is set in argument to OP_CSV, version 2 txs should pass (all sequence locks are met)\n-        success_txs = []\n-        for b25 in range(2):\n-            for b22 in range(2):\n-                for b18 in range(2):\n-                    success_txs.append(bip112txs_vary_OP_CSV_v2[1][b25][b22][b18])  # 8/16 of vary_OP_CSV\n-                    success_txs.append(bip112txs_vary_OP_CSV_9_v2[1][b25][b22][b18])  # 8/16 of vary_OP_CSV_9\n+        success_txs = [tx['tx'] for tx in bip112txs_vary_OP_CSV_v2 if tx['sdf']]\n+        success_txs += [tx['tx'] for tx in bip112txs_vary_OP_CSV_9_v2 if tx['sdf']]\n \n         yield TestInstance([[self.create_test_block(success_txs), True]])\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n         # SEQUENCE_LOCKTIME_DISABLE_FLAG is unset in argument to OP_CSV for all remaining txs ##\n \n         # All txs with nSequence 9 should fail either due to earlier mismatch or failing the CSV check\n-        fail_txs = []\n-        fail_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v2))  # 16/16 of vary_nSequence_9\n-        for b25 in range(2):\n-            for b22 in range(2):\n-                for b18 in range(2):\n-                    fail_txs.append(bip112txs_vary_OP_CSV_9_v2[0][b25][b22][b18])  # 16/16 of vary_OP_CSV_9\n-\n+        fail_txs = all_rlt_txs(bip112txs_vary_nSequence_9_v2)\n+        fail_txs += [tx['tx'] for tx in bip112txs_vary_OP_CSV_9_v2 if not tx['sdf']]\n         for tx in fail_txs:\n             yield TestInstance([[self.create_test_block([tx]), False]])\n \n         # If SEQUENCE_LOCKTIME_DISABLE_FLAG is set in nSequence, tx should fail\n-        fail_txs = []\n-        for b25 in range(2):\n-            for b22 in range(2):\n-                for b18 in range(2):\n-                    fail_txs.append(bip112txs_vary_nSequence_v2[1][b25][b22][b18])  # 8/16 of vary_nSequence\n+        fail_txs = [tx['tx'] for tx in bip112txs_vary_nSequence_v2 if tx['sdf']]\n         for tx in fail_txs:\n             yield TestInstance([[self.create_test_block([tx]), False]])\n \n         # If sequencelock types mismatch, tx should fail\n-        fail_txs = []\n-        for b25 in range(2):\n-            for b18 in range(2):\n-                fail_txs.append(bip112txs_vary_nSequence_v2[0][b25][1][b18])  # 12/16 of vary_nSequence\n-                fail_txs.append(bip112txs_vary_OP_CSV_v2[0][b25][1][b18])  # 12/16 of vary_OP_CSV\n+        fail_txs = [tx['tx'] for tx in bip112txs_vary_nSequence_v2 if not tx['sdf'] and tx['stf']]\n+        fail_txs += [tx['tx'] for tx in bip112txs_vary_OP_CSV_v2 if not tx['sdf'] and tx['stf']]\n         for tx in fail_txs:\n             yield TestInstance([[self.create_test_block([tx]), False]])\n \n         # Remaining txs should pass, just test masking works properly\n-        success_txs = []\n-        for b25 in range(2):\n-            for b18 in range(2):\n-                success_txs.append(bip112txs_vary_nSequence_v2[0][b25][0][b18])  # 16/16 of vary_nSequence\n-                success_txs.append(bip112txs_vary_OP_CSV_v2[0][b25][0][b18])  # 16/16 of vary_OP_CSV\n+        success_txs = [tx['tx'] for tx in bip112txs_vary_nSequence_v2 if not tx['sdf'] and not tx['stf']]\n+        success_txs += [tx['tx'] for tx in bip112txs_vary_OP_CSV_v2 if not tx['sdf'] and not tx['stf']]\n         yield TestInstance([[self.create_test_block(success_txs), True]])  # 124\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n         # Additional test, of checking that comparison of two time types works properly\n         time_txs = []\n-        for b25 in range(2):\n-            for b18 in range(2):\n-                tx = bip112txs_vary_OP_CSV_v2[0][b25][1][b18]\n-                tx.vin[0].nSequence = base_relative_locktime | seq_type_flag\n-                signtx = self.sign_transaction(self.nodes[0], tx)\n-                time_txs.append(signtx)\n+        for tx in [tx['tx'] for tx in bip112txs_vary_OP_CSV_v2 if not tx['sdf'] and tx['stf']]:\n+            tx.vin[0].nSequence = BASE_RELATIVE_LOCKTIME | SEQ_TYPE_FLAG\n+            signtx = self.sign_transaction(self.nodes[0], tx)\n+            time_txs.append(signtx)\n+\n         yield TestInstance([[self.create_test_block(time_txs), True]])\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n "
      }
    ]
  },
  {
    "sha": "db7ffb9d1b9dbdf19b49cc397a7d5e31db244214",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkYjdmZmI5ZDFiOWRiZGYxOWI0OWNjMzk3YTdkNWUzMWRiMjQ0MjE0",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-30T22:36:53Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-03-22T13:37:00Z"
      },
      "message": "[tests] Move utility functions in feature_csv_activation.py out of class.",
      "tree": {
        "sha": "ae0af1e52101a2520cdb4acb10ec34365b2a258e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ae0af1e52101a2520cdb4acb10ec34365b2a258e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/db7ffb9d1b9dbdf19b49cc397a7d5e31db244214",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/db7ffb9d1b9dbdf19b49cc397a7d5e31db244214",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/db7ffb9d1b9dbdf19b49cc397a7d5e31db244214",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/db7ffb9d1b9dbdf19b49cc397a7d5e31db244214/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0842edf9ee7d659408e48b8897ac4a272e48b716",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0842edf9ee7d659408e48b8897ac4a272e48b716",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0842edf9ee7d659408e48b8897ac4a272e48b716"
      }
    ],
    "stats": {
      "total": 180,
      "additions": 90,
      "deletions": 90
    },
    "files": [
      {
        "sha": "2ad6877ef154a1ad515700568e3fa412903fc71e",
        "filename": "test/functional/feature_csv_activation.py",
        "status": "modified",
        "additions": 90,
        "deletions": 90,
        "changes": 180,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/db7ffb9d1b9dbdf19b49cc397a7d5e31db244214/test/functional/feature_csv_activation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/db7ffb9d1b9dbdf19b49cc397a7d5e31db244214/test/functional/feature_csv_activation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_csv_activation.py?ref=db7ffb9d1b9dbdf19b49cc397a7d5e31db244214",
        "patch": "@@ -85,6 +85,70 @@ def relative_locktime(sdf, srhb, stf, srlb):\n def all_rlt_txs(txs):\n     return [tx['tx'] for tx in txs]\n \n+def create_transaction(node, txid, to_address, amount):\n+    inputs = [{\"txid\": txid, \"vout\": 0}]\n+    outputs = {to_address: amount}\n+    rawtx = node.createrawtransaction(inputs, outputs)\n+    tx = CTransaction()\n+    f = BytesIO(hex_str_to_bytes(rawtx))\n+    tx.deserialize(f)\n+    return tx\n+\n+def sign_transaction(node, unsignedtx):\n+    rawtx = ToHex(unsignedtx)\n+    signresult = node.signrawtransactionwithwallet(rawtx)\n+    tx = CTransaction()\n+    f = BytesIO(hex_str_to_bytes(signresult['hex']))\n+    tx.deserialize(f)\n+    return tx\n+\n+def create_bip112special(node, input, txversion, address):\n+    tx = create_transaction(node, input, address, Decimal(\"49.98\"))\n+    tx.nVersion = txversion\n+    signtx = sign_transaction(node, tx)\n+    signtx.vin[0].scriptSig = CScript([-1, OP_CHECKSEQUENCEVERIFY, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n+    return signtx\n+\n+def send_generic_input_tx(node, coinbases, address):\n+    amount = Decimal(\"49.99\")\n+    return node.sendrawtransaction(ToHex(sign_transaction(node, create_transaction(node, node.getblock(coinbases.pop())['tx'][0], address, amount))))\n+\n+def create_bip68txs(node, bip68inputs, txversion, address, locktime_delta=0):\n+    \"\"\"Returns a list of bip68 transactions with different bits set.\"\"\"\n+    txs = []\n+    assert(len(bip68inputs) >= 16)\n+    for i, (sdf, srhb, stf, srlb) in enumerate(product(*[[True, False]] * 4)):\n+        locktime = relative_locktime(sdf, srhb, stf, srlb)\n+        tx = create_transaction(node, bip68inputs[i], address, Decimal(\"49.98\"))\n+        tx.nVersion = txversion\n+        tx.vin[0].nSequence = locktime + locktime_delta\n+        tx = sign_transaction(node, tx)\n+        tx.rehash()\n+        txs.append({'tx': tx, 'sdf': sdf, 'stf': stf})\n+\n+    return txs\n+\n+def create_bip112txs(node, bip112inputs, varyOP_CSV, txversion, address, locktime_delta=0):\n+    \"\"\"Returns a list of bip68 transactions with different bits set.\"\"\"\n+    txs = []\n+    assert(len(bip112inputs) >= 16)\n+    for i, (sdf, srhb, stf, srlb) in enumerate(product(*[[True, False]] * 4)):\n+        locktime = relative_locktime(sdf, srhb, stf, srlb)\n+        tx = create_transaction(node, bip112inputs[i], address, Decimal(\"49.98\"))\n+        if (varyOP_CSV):  # if varying OP_CSV, nSequence is fixed\n+            tx.vin[0].nSequence = BASE_RELATIVE_LOCKTIME + locktime_delta\n+        else:  # vary nSequence instead, OP_CSV is fixed\n+            tx.vin[0].nSequence = locktime + locktime_delta\n+        tx.nVersion = txversion\n+        signtx = sign_transaction(node, tx)\n+        if (varyOP_CSV):\n+            signtx.vin[0].scriptSig = CScript([locktime, OP_CHECKSEQUENCEVERIFY, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n+        else:\n+            signtx.vin[0].scriptSig = CScript([BASE_RELATIVE_LOCKTIME, OP_CHECKSEQUENCEVERIFY, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n+        tx.rehash()\n+        txs.append({'tx': signtx, 'sdf': sdf, 'stf': stf})\n+    return txs\n+\n class BIP68_112_113Test(ComparisonTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 1\n@@ -97,27 +161,6 @@ def run_test(self):\n         network_thread_start()\n         test.run()\n \n-    def send_generic_input_tx(self, node, coinbases):\n-        amount = Decimal(\"49.99\")\n-        return node.sendrawtransaction(ToHex(self.sign_transaction(node, self.create_transaction(node, node.getblock(coinbases.pop())['tx'][0], self.nodeaddress, amount))))\n-\n-    def create_transaction(self, node, txid, to_address, amount):\n-        inputs = [{\"txid\": txid, \"vout\": 0}]\n-        outputs = {to_address: amount}\n-        rawtx = node.createrawtransaction(inputs, outputs)\n-        tx = CTransaction()\n-        f = BytesIO(hex_str_to_bytes(rawtx))\n-        tx.deserialize(f)\n-        return tx\n-\n-    def sign_transaction(self, node, unsignedtx):\n-        rawtx = ToHex(unsignedtx)\n-        signresult = node.signrawtransactionwithwallet(rawtx)\n-        tx = CTransaction()\n-        f = BytesIO(hex_str_to_bytes(signresult['hex']))\n-        tx.deserialize(f)\n-        return tx\n-\n     def generate_blocks(self, number, version, test_blocks=[]):\n         for i in range(number):\n             block = self.create_test_block([], version)\n@@ -136,49 +179,6 @@ def create_test_block(self, txs, version=536870912):\n         block.solve()\n         return block\n \n-    def create_bip68txs(self, bip68inputs, txversion, locktime_delta=0):\n-        \"\"\"Returns a list of bip68 transactions with different bits set.\"\"\"\n-        txs = []\n-        assert(len(bip68inputs) >= 16)\n-        for i, (sdf, srhb, stf, srlb) in enumerate(product(*[[True, False]] * 4)):\n-            locktime = relative_locktime(sdf, srhb, stf, srlb)\n-            tx = self.create_transaction(self.nodes[0], bip68inputs[i], self.nodeaddress, Decimal(\"49.98\"))\n-            tx.nVersion = txversion\n-            tx.vin[0].nSequence = locktime + locktime_delta\n-            tx = self.sign_transaction(self.nodes[0], tx)\n-            tx.rehash()\n-            txs.append({'tx': tx, 'sdf': sdf, 'stf': stf})\n-\n-        return txs\n-\n-    def create_bip112special(self, input, txversion):\n-        tx = self.create_transaction(self.nodes[0], input, self.nodeaddress, Decimal(\"49.98\"))\n-        tx.nVersion = txversion\n-        signtx = self.sign_transaction(self.nodes[0], tx)\n-        signtx.vin[0].scriptSig = CScript([-1, OP_CHECKSEQUENCEVERIFY, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n-        return signtx\n-\n-    def create_bip112txs(self, bip112inputs, varyOP_CSV, txversion, locktime_delta=0):\n-        \"\"\"Returns a list of bip68 transactions with different bits set.\"\"\"\n-        txs = []\n-        assert(len(bip112inputs) >= 16)\n-        for i, (sdf, srhb, stf, srlb) in enumerate(product(*[[True, False]] * 4)):\n-            locktime = relative_locktime(sdf, srhb, stf, srlb)\n-            tx = self.create_transaction(self.nodes[0], bip112inputs[i], self.nodeaddress, Decimal(\"49.98\"))\n-            if (varyOP_CSV):  # if varying OP_CSV, nSequence is fixed\n-                tx.vin[0].nSequence = BASE_RELATIVE_LOCKTIME + locktime_delta\n-            else:  # vary nSequence instead, OP_CSV is fixed\n-                tx.vin[0].nSequence = locktime + locktime_delta\n-            tx.nVersion = txversion\n-            signtx = self.sign_transaction(self.nodes[0], tx)\n-            if (varyOP_CSV):\n-                signtx.vin[0].scriptSig = CScript([locktime, OP_CHECKSEQUENCEVERIFY, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n-            else:\n-                signtx.vin[0].scriptSig = CScript([BASE_RELATIVE_LOCKTIME, OP_CHECKSEQUENCEVERIFY, OP_DROP] + list(CScript(signtx.vin[0].scriptSig)))\n-            tx.rehash()\n-            txs.append({'tx': signtx, 'sdf': sdf, 'stf': stf})\n-        return txs\n-\n     def get_tests(self):\n         self.log.info(\"Generate blocks in the past for coinbase outputs.\")\n         long_past_time = int(time.time()) - 600 * 1000  # enough to build up to 1000 blocks 10 minutes apart without worrying about getting into the future\n@@ -233,29 +233,29 @@ def get_tests(self):\n         # 16 normal inputs\n         bip68inputs = []\n         for i in range(16):\n-            bip68inputs.append(self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks))\n+            bip68inputs.append(send_generic_input_tx(self.nodes[0], self.coinbase_blocks, self.nodeaddress))\n \n         # 2 sets of 16 inputs with 10 OP_CSV OP_DROP (actually will be prepended to spending scriptSig)\n         bip112basicinputs = []\n         for j in range(2):\n             inputs = []\n             for i in range(16):\n-                inputs.append(self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks))\n+                inputs.append(send_generic_input_tx(self.nodes[0], self.coinbase_blocks, self.nodeaddress))\n             bip112basicinputs.append(inputs)\n \n         # 2 sets of 16 varied inputs with (relative_lock_time) OP_CSV OP_DROP (actually will be prepended to spending scriptSig)\n         bip112diverseinputs = []\n         for j in range(2):\n             inputs = []\n             for i in range(16):\n-                inputs.append(self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks))\n+                inputs.append(send_generic_input_tx(self.nodes[0], self.coinbase_blocks, self.nodeaddress))\n             bip112diverseinputs.append(inputs)\n \n         # 1 special input with -1 OP_CSV OP_DROP (actually will be prepended to spending scriptSig)\n-        bip112specialinput = self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks)\n+        bip112specialinput = send_generic_input_tx(self.nodes[0], self.coinbase_blocks, self.nodeaddress)\n \n         # 1 normal input\n-        bip113input = self.send_generic_input_tx(self.nodes[0], self.coinbase_blocks)\n+        bip113input = send_generic_input_tx(self.nodes[0], self.coinbase_blocks, self.nodeaddress)\n \n         self.nodes[0].setmocktime(self.last_block_time + 600)\n         inputblockhash = self.nodes[0].generate(1)[0]  # 1 block generated for inputs to be in chain at height 572\n@@ -274,33 +274,33 @@ def get_tests(self):\n \n         # Test both version 1 and version 2 transactions for all tests\n         # BIP113 test transaction will be modified before each use to put in appropriate block time\n-        bip113tx_v1 = self.create_transaction(self.nodes[0], bip113input, self.nodeaddress, Decimal(\"49.98\"))\n+        bip113tx_v1 = create_transaction(self.nodes[0], bip113input, self.nodeaddress, Decimal(\"49.98\"))\n         bip113tx_v1.vin[0].nSequence = 0xFFFFFFFE\n         bip113tx_v1.nVersion = 1\n-        bip113tx_v2 = self.create_transaction(self.nodes[0], bip113input, self.nodeaddress, Decimal(\"49.98\"))\n+        bip113tx_v2 = create_transaction(self.nodes[0], bip113input, self.nodeaddress, Decimal(\"49.98\"))\n         bip113tx_v2.vin[0].nSequence = 0xFFFFFFFE\n         bip113tx_v2.nVersion = 2\n \n         # For BIP68 test all 16 relative sequence locktimes\n-        bip68txs_v1 = self.create_bip68txs(bip68inputs, 1)\n-        bip68txs_v2 = self.create_bip68txs(bip68inputs, 2)\n+        bip68txs_v1 = create_bip68txs(self.nodes[0], bip68inputs, 1, self.nodeaddress)\n+        bip68txs_v2 = create_bip68txs(self.nodes[0], bip68inputs, 2, self.nodeaddress)\n \n         # For BIP112 test:\n         # 16 relative sequence locktimes of 10 against 10 OP_CSV OP_DROP inputs\n-        bip112txs_vary_nSequence_v1 = self.create_bip112txs(bip112basicinputs[0], False, 1)\n-        bip112txs_vary_nSequence_v2 = self.create_bip112txs(bip112basicinputs[0], False, 2)\n+        bip112txs_vary_nSequence_v1 = create_bip112txs(self.nodes[0], bip112basicinputs[0], False, 1, self.nodeaddress)\n+        bip112txs_vary_nSequence_v2 = create_bip112txs(self.nodes[0], bip112basicinputs[0], False, 2, self.nodeaddress)\n         # 16 relative sequence locktimes of 9 against 10 OP_CSV OP_DROP inputs\n-        bip112txs_vary_nSequence_9_v1 = self.create_bip112txs(bip112basicinputs[1], False, 1, -1)\n-        bip112txs_vary_nSequence_9_v2 = self.create_bip112txs(bip112basicinputs[1], False, 2, -1)\n+        bip112txs_vary_nSequence_9_v1 = create_bip112txs(self.nodes[0], bip112basicinputs[1], False, 1, self.nodeaddress, -1)\n+        bip112txs_vary_nSequence_9_v2 = create_bip112txs(self.nodes[0], bip112basicinputs[1], False, 2, self.nodeaddress, -1)\n         # sequence lock time of 10 against 16 (relative_lock_time) OP_CSV OP_DROP inputs\n-        bip112txs_vary_OP_CSV_v1 = self.create_bip112txs(bip112diverseinputs[0], True, 1)\n-        bip112txs_vary_OP_CSV_v2 = self.create_bip112txs(bip112diverseinputs[0], True, 2)\n+        bip112txs_vary_OP_CSV_v1 = create_bip112txs(self.nodes[0], bip112diverseinputs[0], True, 1, self.nodeaddress)\n+        bip112txs_vary_OP_CSV_v2 = create_bip112txs(self.nodes[0], bip112diverseinputs[0], True, 2, self.nodeaddress)\n         # sequence lock time of 9 against 16 (relative_lock_time) OP_CSV OP_DROP inputs\n-        bip112txs_vary_OP_CSV_9_v1 = self.create_bip112txs(bip112diverseinputs[1], True, 1, -1)\n-        bip112txs_vary_OP_CSV_9_v2 = self.create_bip112txs(bip112diverseinputs[1], True, 2, -1)\n+        bip112txs_vary_OP_CSV_9_v1 = create_bip112txs(self.nodes[0], bip112diverseinputs[1], True, 1, self.nodeaddress, -1)\n+        bip112txs_vary_OP_CSV_9_v2 = create_bip112txs(self.nodes[0], bip112diverseinputs[1], True, 2, self.nodeaddress, -1)\n         # -1 OP_CSV OP_DROP input\n-        bip112tx_special_v1 = self.create_bip112special(bip112specialinput, 1)\n-        bip112tx_special_v2 = self.create_bip112special(bip112specialinput, 2)\n+        bip112tx_special_v1 = create_bip112special(self.nodes[0], bip112specialinput, 1, self.nodeaddress)\n+        bip112tx_special_v2 = create_bip112special(self.nodes[0], bip112specialinput, 2, self.nodeaddress)\n \n         self.log.info(\"TESTING\")\n \n@@ -310,7 +310,7 @@ def get_tests(self):\n         success_txs = []\n         # add BIP113 tx and -1 CSV tx\n         bip113tx_v1.nLockTime = self.last_block_time - 600 * 5  # = MTP of prior block (not <) but < time put on current block\n-        bip113signed1 = self.sign_transaction(self.nodes[0], bip113tx_v1)\n+        bip113signed1 = sign_transaction(self.nodes[0], bip113tx_v1)\n         success_txs.append(bip113signed1)\n         success_txs.append(bip112tx_special_v1)\n         # add BIP 68 txs\n@@ -329,7 +329,7 @@ def get_tests(self):\n         success_txs = []\n         # add BIP113 tx and -1 CSV tx\n         bip113tx_v2.nLockTime = self.last_block_time - 600 * 5  # = MTP of prior block (not <) but < time put on current block\n-        bip113signed2 = self.sign_transaction(self.nodes[0], bip113tx_v2)\n+        bip113signed2 = sign_transaction(self.nodes[0], bip113tx_v2)\n         success_txs.append(bip113signed2)\n         success_txs.append(bip112tx_special_v2)\n         # add BIP 68 txs\n@@ -353,16 +353,16 @@ def get_tests(self):\n         self.log.info(\"BIP 113 tests\")\n         # BIP 113 tests should now fail regardless of version number if nLockTime isn't satisfied by new rules\n         bip113tx_v1.nLockTime = self.last_block_time - 600 * 5  # = MTP of prior block (not <) but < time put on current block\n-        bip113signed1 = self.sign_transaction(self.nodes[0], bip113tx_v1)\n+        bip113signed1 = sign_transaction(self.nodes[0], bip113tx_v1)\n         bip113tx_v2.nLockTime = self.last_block_time - 600 * 5  # = MTP of prior block (not <) but < time put on current block\n-        bip113signed2 = self.sign_transaction(self.nodes[0], bip113tx_v2)\n+        bip113signed2 = sign_transaction(self.nodes[0], bip113tx_v2)\n         for bip113tx in [bip113signed1, bip113signed2]:\n             yield TestInstance([[self.create_test_block([bip113tx]), False]])\n         # BIP 113 tests should now pass if the locktime is < MTP\n         bip113tx_v1.nLockTime = self.last_block_time - 600 * 5 - 1  # < MTP of prior block\n-        bip113signed1 = self.sign_transaction(self.nodes[0], bip113tx_v1)\n+        bip113signed1 = sign_transaction(self.nodes[0], bip113tx_v1)\n         bip113tx_v2.nLockTime = self.last_block_time - 600 * 5 - 1  # < MTP of prior block\n-        bip113signed2 = self.sign_transaction(self.nodes[0], bip113tx_v2)\n+        bip113signed2 = sign_transaction(self.nodes[0], bip113tx_v2)\n         for bip113tx in [bip113signed1, bip113signed2]:\n             yield TestInstance([[self.create_test_block([bip113tx]), True]])\n             self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n@@ -476,7 +476,7 @@ def get_tests(self):\n         time_txs = []\n         for tx in [tx['tx'] for tx in bip112txs_vary_OP_CSV_v2 if not tx['sdf'] and tx['stf']]:\n             tx.vin[0].nSequence = BASE_RELATIVE_LOCKTIME | SEQ_TYPE_FLAG\n-            signtx = self.sign_transaction(self.nodes[0], tx)\n+            signtx = sign_transaction(self.nodes[0], tx)\n             time_txs.append(signtx)\n \n         yield TestInstance([[self.create_test_block(time_txs), True]])"
      }
    ]
  },
  {
    "sha": "12982682a602ee656ce74b5733747a05d70907f8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMjk4MjY4MmE2MDJlZTY1NmNlNzRiNTczMzc0N2EwNWQ3MDkwN2Y4",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-12-01T18:05:10Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-03-22T13:38:31Z"
      },
      "message": "[tests] Change feature_csv_activation.py to use BitcoinTestFramework",
      "tree": {
        "sha": "b6f1be027b3f2b0b7c211c3bae891c1f6fd524ae",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b6f1be027b3f2b0b7c211c3bae891c1f6fd524ae"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/12982682a602ee656ce74b5733747a05d70907f8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/12982682a602ee656ce74b5733747a05d70907f8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/12982682a602ee656ce74b5733747a05d70907f8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/12982682a602ee656ce74b5733747a05d70907f8/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "db7ffb9d1b9dbdf19b49cc397a7d5e31db244214",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/db7ffb9d1b9dbdf19b49cc397a7d5e31db244214",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/db7ffb9d1b9dbdf19b49cc397a7d5e31db244214"
      }
    ],
    "stats": {
      "total": 94,
      "additions": 50,
      "deletions": 44
    },
    "files": [
      {
        "sha": "37d60aad61f3ccad68400de3e8ea79b525b4f774",
        "filename": "test/functional/feature_csv_activation.py",
        "status": "modified",
        "additions": 50,
        "deletions": 44,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/12982682a602ee656ce74b5733747a05d70907f8/test/functional/feature_csv_activation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/12982682a602ee656ce74b5733747a05d70907f8/test/functional/feature_csv_activation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_csv_activation.py?ref=12982682a602ee656ce74b5733747a05d70907f8",
        "patch": "@@ -48,14 +48,14 @@\n import time\n \n from test_framework.blocktools import create_coinbase, create_block\n-from test_framework.comptool import TestInstance, TestManager\n-from test_framework.mininode import ToHex, CTransaction, network_thread_start\n+from test_framework.messages import ToHex, CTransaction\n+from test_framework.mininode import network_thread_start, P2PDataStore\n from test_framework.script import (\n     CScript,\n     OP_CHECKSEQUENCEVERIFY,\n     OP_DROP,\n )\n-from test_framework.test_framework import ComparisonTestFramework\n+from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n     get_bip9_status,\n@@ -149,22 +149,18 @@ def create_bip112txs(node, bip112inputs, varyOP_CSV, txversion, address, locktim\n         txs.append({'tx': signtx, 'sdf': sdf, 'stf': stf})\n     return txs\n \n-class BIP68_112_113Test(ComparisonTestFramework):\n+class BIP68_112_113Test(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 1\n         self.setup_clean_chain = True\n         self.extra_args = [['-whitelist=127.0.0.1', '-blockversion=4', '-addresstype=legacy']]\n \n-    def run_test(self):\n-        test = TestManager(self, self.options.tmpdir)\n-        test.add_all_connections(self.nodes)\n-        network_thread_start()\n-        test.run()\n-\n-    def generate_blocks(self, number, version, test_blocks=[]):\n+    def generate_blocks(self, number, version, test_blocks=None):\n+        if test_blocks is None:\n+            test_blocks = []\n         for i in range(number):\n             block = self.create_test_block([], version)\n-            test_blocks.append([block, True])\n+            test_blocks.append(block)\n             self.last_block_time += 600\n             self.tip = block.sha256\n             self.tipheight += 1\n@@ -179,7 +175,17 @@ def create_test_block(self, txs, version=536870912):\n         block.solve()\n         return block\n \n-    def get_tests(self):\n+    def sync_blocks(self, blocks, success=True, reject_code=None, reject_reason=None, request_block=True):\n+        \"\"\"Sends blocks to test node. Syncs and verifies that tip has advanced to most recent block.\n+\n+        Call with success = False if the tip shouldn't advance to the most recent block.\"\"\"\n+        self.nodes[0].p2p.send_blocks_and_test(blocks, self.nodes[0], success=success, reject_code=reject_code, reject_reason=reject_reason, request_block=request_block)\n+\n+    def run_test(self):\n+        self.nodes[0].add_p2p_connection(P2PDataStore())\n+        network_thread_start()\n+        self.nodes[0].p2p.wait_for_verack()\n+\n         self.log.info(\"Generate blocks in the past for coinbase outputs.\")\n         long_past_time = int(time.time()) - 600 * 1000  # enough to build up to 1000 blocks 10 minutes apart without worrying about getting into the future\n         self.nodes[0].setmocktime(long_past_time - 100)  # enough so that the generated blocks will still all be before long_past_time\n@@ -193,7 +199,7 @@ def get_tests(self):\n         self.log.info(\"Test that the csv softfork is DEFINED\")\n         assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'defined')\n         test_blocks = self.generate_blocks(61, 4)\n-        yield TestInstance(test_blocks, sync_every_block=False)\n+        self.sync_blocks(test_blocks)\n \n         self.log.info(\"Advance from DEFINED to STARTED, height = 143\")\n         assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'started')\n@@ -205,7 +211,7 @@ def get_tests(self):\n         test_blocks = self.generate_blocks(20, 4, test_blocks)  # 0x00000004 (signalling not)\n         test_blocks = self.generate_blocks(50, 536871169, test_blocks)  # 0x20000101 (signalling ready)\n         test_blocks = self.generate_blocks(24, 536936448, test_blocks)  # 0x20010000 (signalling not)\n-        yield TestInstance(test_blocks, sync_every_block=False)\n+        self.sync_blocks(test_blocks)\n \n         self.log.info(\"Failed to advance past STARTED, height = 287\")\n         assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'started')\n@@ -217,14 +223,14 @@ def get_tests(self):\n         test_blocks = self.generate_blocks(26, 4, test_blocks)  # 0x00000004 (signalling not)\n         test_blocks = self.generate_blocks(50, 536871169, test_blocks)  # 0x20000101 (signalling ready)\n         test_blocks = self.generate_blocks(10, 536936448, test_blocks)  # 0x20010000 (signalling not)\n-        yield TestInstance(test_blocks, sync_every_block=False)\n+        self.sync_blocks(test_blocks)\n \n         self.log.info(\"Advanced from STARTED to LOCKED_IN, height = 431\")\n         assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'locked_in')\n \n         # Generate 140 more version 4 blocks\n         test_blocks = self.generate_blocks(140, 4)\n-        yield TestInstance(test_blocks, sync_every_block=False)\n+        self.sync_blocks(test_blocks)\n \n         # Inputs at height = 572\n         #\n@@ -267,7 +273,7 @@ def get_tests(self):\n \n         # 2 more version 4 blocks\n         test_blocks = self.generate_blocks(2, 4)\n-        yield TestInstance(test_blocks, sync_every_block=False)\n+        self.sync_blocks(test_blocks)\n \n         self.log.info(\"Not yet advanced to ACTIVE, height = 574 (will activate for block 576, not 575)\")\n         assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'locked_in')\n@@ -321,7 +327,7 @@ def get_tests(self):\n         # try BIP 112 with seq=9 txs\n         success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v1))\n         success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_9_v1))\n-        yield TestInstance([[self.create_test_block(success_txs), True]])\n+        self.sync_blocks([self.create_test_block(success_txs)])\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n         self.log.info(\"Test version 2 txs\")\n@@ -340,12 +346,12 @@ def get_tests(self):\n         # try BIP 112 with seq=9 txs\n         success_txs.extend(all_rlt_txs(bip112txs_vary_nSequence_9_v2))\n         success_txs.extend(all_rlt_txs(bip112txs_vary_OP_CSV_9_v2))\n-        yield TestInstance([[self.create_test_block(success_txs), True]])\n+        self.sync_blocks([self.create_test_block(success_txs)])\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n         # 1 more version 4 block to get us to height 575 so the fork should now be active for the next block\n         test_blocks = self.generate_blocks(1, 4)\n-        yield TestInstance(test_blocks, sync_every_block=False)\n+        self.sync_blocks(test_blocks)\n         assert_equal(get_bip9_status(self.nodes[0], 'csv')['status'], 'active')\n \n         self.log.info(\"Post-Soft Fork Tests.\")\n@@ -357,74 +363,74 @@ def get_tests(self):\n         bip113tx_v2.nLockTime = self.last_block_time - 600 * 5  # = MTP of prior block (not <) but < time put on current block\n         bip113signed2 = sign_transaction(self.nodes[0], bip113tx_v2)\n         for bip113tx in [bip113signed1, bip113signed2]:\n-            yield TestInstance([[self.create_test_block([bip113tx]), False]])\n+            self.sync_blocks([self.create_test_block([bip113tx])], success=False)\n         # BIP 113 tests should now pass if the locktime is < MTP\n         bip113tx_v1.nLockTime = self.last_block_time - 600 * 5 - 1  # < MTP of prior block\n         bip113signed1 = sign_transaction(self.nodes[0], bip113tx_v1)\n         bip113tx_v2.nLockTime = self.last_block_time - 600 * 5 - 1  # < MTP of prior block\n         bip113signed2 = sign_transaction(self.nodes[0], bip113tx_v2)\n         for bip113tx in [bip113signed1, bip113signed2]:\n-            yield TestInstance([[self.create_test_block([bip113tx]), True]])\n+            self.sync_blocks([self.create_test_block([bip113tx])])\n             self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n         # Next block height = 580 after 4 blocks of random version\n         test_blocks = self.generate_blocks(4, 1234)\n-        yield TestInstance(test_blocks, sync_every_block=False)\n+        self.sync_blocks(test_blocks)\n \n         self.log.info(\"BIP 68 tests\")\n         self.log.info(\"Test version 1 txs - all should still pass\")\n \n         success_txs = []\n         success_txs.extend(all_rlt_txs(bip68txs_v1))\n-        yield TestInstance([[self.create_test_block(success_txs), True]])\n+        self.sync_blocks([self.create_test_block(success_txs)])\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n         self.log.info(\"Test version 2 txs\")\n \n         # All txs with SEQUENCE_LOCKTIME_DISABLE_FLAG set pass\n         bip68success_txs = [tx['tx'] for tx in bip68txs_v2 if tx['sdf']]\n-        yield TestInstance([[self.create_test_block(bip68success_txs), True]])\n+        self.sync_blocks([self.create_test_block(bip68success_txs)])\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n         # All txs without flag fail as we are at delta height = 8 < 10 and delta time = 8 * 600 < 10 * 512\n         bip68timetxs = [tx['tx'] for tx in bip68txs_v2 if not tx['sdf'] and tx['stf']]\n         for tx in bip68timetxs:\n-            yield TestInstance([[self.create_test_block([tx]), False]])\n+            self.sync_blocks([self.create_test_block([tx])], success=False)\n \n         bip68heighttxs = [tx['tx'] for tx in bip68txs_v2 if not tx['sdf'] and not tx['stf']]\n         for tx in bip68heighttxs:\n-            yield TestInstance([[self.create_test_block([tx]), False]])\n+            self.sync_blocks([self.create_test_block([tx])], success=False)\n \n         # Advance one block to 581\n         test_blocks = self.generate_blocks(1, 1234)\n-        yield TestInstance(test_blocks, sync_every_block=False)\n+        self.sync_blocks(test_blocks)\n \n         # Height txs should fail and time txs should now pass 9 * 600 > 10 * 512\n         bip68success_txs.extend(bip68timetxs)\n-        yield TestInstance([[self.create_test_block(bip68success_txs), True]])\n+        self.sync_blocks([self.create_test_block(bip68success_txs)])\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n         for tx in bip68heighttxs:\n-            yield TestInstance([[self.create_test_block([tx]), False]])\n+            self.sync_blocks([self.create_test_block([tx])], success=False)\n \n         # Advance one block to 582\n         test_blocks = self.generate_blocks(1, 1234)\n-        yield TestInstance(test_blocks, sync_every_block=False)\n+        self.sync_blocks(test_blocks)\n \n         # All BIP 68 txs should pass\n         bip68success_txs.extend(bip68heighttxs)\n-        yield TestInstance([[self.create_test_block(bip68success_txs), True]])\n+        self.sync_blocks([self.create_test_block(bip68success_txs)])\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n         self.log.info(\"BIP 112 tests\")\n         self.log.info(\"Test version 1 txs\")\n \n         # -1 OP_CSV tx should fail\n-        yield TestInstance([[self.create_test_block([bip112tx_special_v1]), False]])\n+        self.sync_blocks([self.create_test_block([bip112tx_special_v1])], success=False)\n         # If SEQUENCE_LOCKTIME_DISABLE_FLAG is set in argument to OP_CSV, version 1 txs should still pass\n \n         success_txs = [tx['tx'] for tx in bip112txs_vary_OP_CSV_v1 if tx['sdf']]\n         success_txs += [tx['tx'] for tx in bip112txs_vary_OP_CSV_9_v1 if tx['sdf']]\n-        yield TestInstance([[self.create_test_block(success_txs), True]])\n+        self.sync_blocks([self.create_test_block(success_txs)])\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n         # If SEQUENCE_LOCKTIME_DISABLE_FLAG is unset in argument to OP_CSV, version 1 txs should now fail\n@@ -433,18 +439,18 @@ def get_tests(self):\n         fail_txs += [tx['tx'] for tx in bip112txs_vary_OP_CSV_9_v1 if not tx['sdf']]\n         fail_txs += [tx['tx'] for tx in bip112txs_vary_OP_CSV_9_v1 if not tx['sdf']]\n         for tx in fail_txs:\n-            yield TestInstance([[self.create_test_block([tx]), False]])\n+            self.sync_blocks([self.create_test_block([tx])], success=False)\n \n-        self.log.info(\"Version 2 txs\")\n+        self.log.info(\"Test version 2 txs\")\n \n         # -1 OP_CSV tx should fail\n-        yield TestInstance([[self.create_test_block([bip112tx_special_v2]), False]])\n+        self.sync_blocks([self.create_test_block([bip112tx_special_v2])], success=False)\n \n         # If SEQUENCE_LOCKTIME_DISABLE_FLAG is set in argument to OP_CSV, version 2 txs should pass (all sequence locks are met)\n         success_txs = [tx['tx'] for tx in bip112txs_vary_OP_CSV_v2 if tx['sdf']]\n         success_txs += [tx['tx'] for tx in bip112txs_vary_OP_CSV_9_v2 if tx['sdf']]\n \n-        yield TestInstance([[self.create_test_block(success_txs), True]])\n+        self.sync_blocks([self.create_test_block(success_txs)])\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n         # SEQUENCE_LOCKTIME_DISABLE_FLAG is unset in argument to OP_CSV for all remaining txs ##\n@@ -453,23 +459,23 @@ def get_tests(self):\n         fail_txs = all_rlt_txs(bip112txs_vary_nSequence_9_v2)\n         fail_txs += [tx['tx'] for tx in bip112txs_vary_OP_CSV_9_v2 if not tx['sdf']]\n         for tx in fail_txs:\n-            yield TestInstance([[self.create_test_block([tx]), False]])\n+            self.sync_blocks([self.create_test_block([tx])], success=False)\n \n         # If SEQUENCE_LOCKTIME_DISABLE_FLAG is set in nSequence, tx should fail\n         fail_txs = [tx['tx'] for tx in bip112txs_vary_nSequence_v2 if tx['sdf']]\n         for tx in fail_txs:\n-            yield TestInstance([[self.create_test_block([tx]), False]])\n+            self.sync_blocks([self.create_test_block([tx])], success=False)\n \n         # If sequencelock types mismatch, tx should fail\n         fail_txs = [tx['tx'] for tx in bip112txs_vary_nSequence_v2 if not tx['sdf'] and tx['stf']]\n         fail_txs += [tx['tx'] for tx in bip112txs_vary_OP_CSV_v2 if not tx['sdf'] and tx['stf']]\n         for tx in fail_txs:\n-            yield TestInstance([[self.create_test_block([tx]), False]])\n+            self.sync_blocks([self.create_test_block([tx])], success=False)\n \n         # Remaining txs should pass, just test masking works properly\n         success_txs = [tx['tx'] for tx in bip112txs_vary_nSequence_v2 if not tx['sdf'] and not tx['stf']]\n         success_txs += [tx['tx'] for tx in bip112txs_vary_OP_CSV_v2 if not tx['sdf'] and not tx['stf']]\n-        yield TestInstance([[self.create_test_block(success_txs), True]])  # 124\n+        self.sync_blocks([self.create_test_block(success_txs)])\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n         # Additional test, of checking that comparison of two time types works properly\n@@ -479,7 +485,7 @@ def get_tests(self):\n             signtx = sign_transaction(self.nodes[0], tx)\n             time_txs.append(signtx)\n \n-        yield TestInstance([[self.create_test_block(time_txs), True]])\n+        self.sync_blocks([self.create_test_block(time_txs)])\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n         # TODO: Test empty stack fails"
      }
    ]
  }
]