[
  {
    "sha": "709afb2a7de283a9188e7df51476830012e0a4e5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3MDlhZmIyYTdkZTI4M2E5MTg4ZTdkZjUxNDc2ODMwMDEyZTBhNGU1",
    "commit": {
      "author": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2019-10-23T08:29:55Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2019-12-06T09:15:56Z"
      },
      "message": "tests: Test serialisation as part of deserialisation fuzzing. Test round-trip equality where possible. Avoid code repetition.",
      "tree": {
        "sha": "5190b3e68b85616988cbba7da4a844fba8629fd5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5190b3e68b85616988cbba7da4a844fba8629fd5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/709afb2a7de283a9188e7df51476830012e0a4e5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/709afb2a7de283a9188e7df51476830012e0a4e5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/709afb2a7de283a9188e7df51476830012e0a4e5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/709afb2a7de283a9188e7df51476830012e0a4e5/comments",
    "author": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cb11324a63ef10475bfc4d8e45148d5ae6f3e71e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cb11324a63ef10475bfc4d8e45148d5ae6f3e71e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cb11324a63ef10475bfc4d8e45148d5ae6f3e71e"
      }
    ],
    "stats": {
      "total": 254,
      "additions": 98,
      "deletions": 156
    },
    "files": [
      {
        "sha": "bd05283b785e3efc3bf7eb2a496d9dd04ca01393",
        "filename": "src/test/fuzz/deserialize.cpp",
        "status": "modified",
        "additions": 98,
        "deletions": 156,
        "changes": 254,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/709afb2a7de283a9188e7df51476830012e0a4e5/src/test/fuzz/deserialize.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/709afb2a7de283a9188e7df51476830012e0a4e5/src/test/fuzz/deserialize.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/deserialize.cpp?ref=709afb2a7de283a9188e7df51476830012e0a4e5",
        "patch": "@@ -22,6 +22,7 @@\n #include <undo.h>\n #include <version.h>\n \n+#include <exception>\n #include <stdexcept>\n #include <stdint.h>\n #include <unistd.h>\n@@ -36,245 +37,186 @@ void initialize()\n     static const auto verify_handle = MakeUnique<ECCVerifyHandle>();\n }\n \n-void test_one_input(const std::vector<uint8_t>& buffer)\n+namespace {\n+\n+struct invalid_fuzzing_input_exception : public std::exception {\n+};\n+\n+template <typename T>\n+CDataStream Serialize(const T& obj)\n+{\n+    CDataStream ds(SER_NETWORK, INIT_PROTO_VERSION);\n+    ds << obj;\n+    return ds;\n+}\n+\n+template <typename T>\n+T Deserialize(CDataStream ds)\n+{\n+    T obj;\n+    ds >> obj;\n+    return obj;\n+}\n+\n+template <typename T>\n+void DeserializeFromFuzzingInput(const std::vector<uint8_t>& buffer, T& obj)\n {\n     CDataStream ds(buffer, SER_NETWORK, INIT_PROTO_VERSION);\n     try {\n-        int nVersion;\n-        ds >> nVersion;\n-        ds.SetVersion(nVersion);\n+        int version;\n+        ds >> version;\n+        ds.SetVersion(version);\n     } catch (const std::ios_base::failure&) {\n-        return;\n+        throw invalid_fuzzing_input_exception();\n     }\n-\n-#if BLOCK_FILTER_DESERIALIZE\n     try {\n-        BlockFilter block_filter;\n-        ds >> block_filter;\n+        ds >> obj;\n     } catch (const std::ios_base::failure&) {\n+        throw invalid_fuzzing_input_exception();\n     }\n-#elif ADDR_INFO_DESERIALIZE\n+    assert(buffer.empty() || !Serialize(obj).empty());\n+}\n+\n+template <typename T>\n+void AssertEqualAfterSerializeDeserialize(const T& obj)\n+{\n+    assert(Deserialize<T>(Serialize(obj)) == obj);\n+}\n+\n+} // namespace\n+\n+void test_one_input(const std::vector<uint8_t>& buffer)\n+{\n     try {\n+#if BLOCK_FILTER_DESERIALIZE\n+        BlockFilter block_filter;\n+        DeserializeFromFuzzingInput(buffer, block_filter);\n+#elif ADDR_INFO_DESERIALIZE\n         CAddrInfo addr_info;\n-        ds >> addr_info;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, addr_info);\n #elif BLOCK_FILE_INFO_DESERIALIZE\n-    try {\n         CBlockFileInfo block_file_info;\n-        ds >> block_file_info;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, block_file_info);\n #elif BLOCK_HEADER_AND_SHORT_TXIDS_DESERIALIZE\n-    try {\n         CBlockHeaderAndShortTxIDs block_header_and_short_txids;\n-        ds >> block_header_and_short_txids;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, block_header_and_short_txids);\n #elif FEE_RATE_DESERIALIZE\n-    try {\n         CFeeRate fee_rate;\n-        ds >> fee_rate;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, fee_rate);\n+        AssertEqualAfterSerializeDeserialize(fee_rate);\n #elif MERKLE_BLOCK_DESERIALIZE\n-    try {\n         CMerkleBlock merkle_block;\n-        ds >> merkle_block;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, merkle_block);\n #elif OUT_POINT_DESERIALIZE\n-    try {\n         COutPoint out_point;\n-        ds >> out_point;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, out_point);\n+        AssertEqualAfterSerializeDeserialize(out_point);\n #elif PARTIAL_MERKLE_TREE_DESERIALIZE\n-    try {\n         CPartialMerkleTree partial_merkle_tree;\n-        ds >> partial_merkle_tree;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, partial_merkle_tree);\n #elif PUB_KEY_DESERIALIZE\n-    try {\n         CPubKey pub_key;\n-        ds >> pub_key;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, pub_key);\n+        // TODO: The following equivalence should hold for CPubKey? Fix.\n+        // AssertEqualAfterSerializeDeserialize(pub_key);\n #elif SCRIPT_DESERIALIZE\n-    try {\n         CScript script;\n-        ds >> script;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, script);\n #elif SUB_NET_DESERIALIZE\n-    try {\n         CSubNet sub_net;\n-        ds >> sub_net;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, sub_net);\n+        AssertEqualAfterSerializeDeserialize(sub_net);\n #elif TX_IN_DESERIALIZE\n-    try {\n         CTxIn tx_in;\n-        ds >> tx_in;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, tx_in);\n+        AssertEqualAfterSerializeDeserialize(tx_in);\n #elif FLAT_FILE_POS_DESERIALIZE\n-    try {\n         FlatFilePos flat_file_pos;\n-        ds >> flat_file_pos;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, flat_file_pos);\n+        AssertEqualAfterSerializeDeserialize(flat_file_pos);\n #elif KEY_ORIGIN_INFO_DESERIALIZE\n-    try {\n         KeyOriginInfo key_origin_info;\n-        ds >> key_origin_info;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, key_origin_info);\n+        AssertEqualAfterSerializeDeserialize(key_origin_info);\n #elif PARTIALLY_SIGNED_TRANSACTION_DESERIALIZE\n-    try {\n         PartiallySignedTransaction partially_signed_transaction;\n-        ds >> partially_signed_transaction;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, partially_signed_transaction);\n #elif PREFILLED_TRANSACTION_DESERIALIZE\n-    try {\n         PrefilledTransaction prefilled_transaction;\n-        ds >> prefilled_transaction;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, prefilled_transaction);\n #elif PSBT_INPUT_DESERIALIZE\n-    try {\n         PSBTInput psbt_input;\n-        ds >> psbt_input;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, psbt_input);\n #elif PSBT_OUTPUT_DESERIALIZE\n-    try {\n         PSBTOutput psbt_output;\n-        ds >> psbt_output;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, psbt_output);\n #elif BLOCK_DESERIALIZE\n-    try {\n         CBlock block;\n-        ds >> block;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, block);\n #elif BLOCKLOCATOR_DESERIALIZE\n-    try {\n         CBlockLocator bl;\n-        ds >> bl;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, bl);\n #elif BLOCKMERKLEROOT\n-    try {\n         CBlock block;\n-        ds >> block;\n+        DeserializeFromFuzzingInput(buffer, block);\n         bool mutated;\n         BlockMerkleRoot(block, &mutated);\n-    } catch (const std::ios_base::failure&) {\n-    }\n #elif ADDRMAN_DESERIALIZE\n-    try {\n         CAddrMan am;\n-        ds >> am;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, am);\n #elif BLOCKHEADER_DESERIALIZE\n-    try {\n         CBlockHeader bh;\n-        ds >> bh;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, bh);\n #elif BANENTRY_DESERIALIZE\n-    try {\n         CBanEntry be;\n-        ds >> be;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, be);\n #elif TXUNDO_DESERIALIZE\n-    try {\n         CTxUndo tu;\n-        ds >> tu;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, tu);\n #elif BLOCKUNDO_DESERIALIZE\n-    try {\n         CBlockUndo bu;\n-        ds >> bu;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, bu);\n #elif COINS_DESERIALIZE\n-    try {\n         Coin coin;\n-        ds >> coin;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, coin);\n #elif NETADDR_DESERIALIZE\n-    try {\n         CNetAddr na;\n-        ds >> na;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, na);\n+        AssertEqualAfterSerializeDeserialize(na);\n #elif SERVICE_DESERIALIZE\n-    try {\n         CService s;\n-        ds >> s;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, s);\n+        AssertEqualAfterSerializeDeserialize(s);\n #elif MESSAGEHEADER_DESERIALIZE\n-    CMessageHeader::MessageStartChars pchMessageStart = {0x00, 0x00, 0x00, 0x00};\n-    try {\n+        const CMessageHeader::MessageStartChars pchMessageStart = {0x00, 0x00, 0x00, 0x00};\n         CMessageHeader mh(pchMessageStart);\n-        ds >> mh;\n+        DeserializeFromFuzzingInput(buffer, mh);\n         (void)mh.IsValid(pchMessageStart);\n-    } catch (const std::ios_base::failure&) {\n-    }\n #elif ADDRESS_DESERIALIZE\n-    try {\n         CAddress a;\n-        ds >> a;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, a);\n #elif INV_DESERIALIZE\n-    try {\n         CInv i;\n-        ds >> i;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, i);\n #elif BLOOMFILTER_DESERIALIZE\n-    try {\n         CBloomFilter bf;\n-        ds >> bf;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, bf);\n #elif DISKBLOCKINDEX_DESERIALIZE\n-    try {\n         CDiskBlockIndex dbi;\n-        ds >> dbi;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, dbi);\n #elif TXOUTCOMPRESSOR_DESERIALIZE\n-    CTxOut to;\n-    CTxOutCompressor toc(to);\n-    try {\n-        ds >> toc;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        CTxOut to;\n+        CTxOutCompressor toc(to);\n+        DeserializeFromFuzzingInput(buffer, toc);\n #elif BLOCKTRANSACTIONS_DESERIALIZE\n-    try {\n         BlockTransactions bt;\n-        ds >> bt;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, bt);\n #elif BLOCKTRANSACTIONSREQUEST_DESERIALIZE\n-    try {\n         BlockTransactionsRequest btr;\n-        ds >> btr;\n-    } catch (const std::ios_base::failure&) {\n-    }\n+        DeserializeFromFuzzingInput(buffer, btr);\n #else\n #error Need at least one fuzz target to compile\n #endif\n+    } catch (const invalid_fuzzing_input_exception&) {\n+    }\n }"
      }
    ]
  }
]