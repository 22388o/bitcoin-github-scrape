[
  {
    "sha": "ab9edbd6b6eb3efbca11f16fa467c3c0ef905708",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphYjllZGJkNmI2ZWIzZWZiY2ExMWYxNmZhNDY3YzNjMGVmOTA1NzA4",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2014-11-01T03:29:12Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2014-11-14T21:25:53Z"
      },
      "message": "script: create sane error return codes for script validation and remove logging\n\nAttempt to codify the possible error statuses associated with script\nvalidation. script/types.h has been created with the expectation that it will\nbe part of the public lib interface. The other flag enums will be moved here in\na future commit.\n\nLogging has also been removed in order to drop the dependency on core.h. It can\nbe re-added to bitcoind as-needed. This makes script verification finally free\nof application state and boost!",
      "tree": {
        "sha": "bf904532ea259aedb390ec74e16479db7905c883",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bf904532ea259aedb390ec74e16479db7905c883"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ab9edbd6b6eb3efbca11f16fa467c3c0ef905708",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ab9edbd6b6eb3efbca11f16fa467c3c0ef905708",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ab9edbd6b6eb3efbca11f16fa467c3c0ef905708",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ab9edbd6b6eb3efbca11f16fa467c3c0ef905708/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3d3ce7421e11ed693840e04bee4d18fb9d396309",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3d3ce7421e11ed693840e04bee4d18fb9d396309",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3d3ce7421e11ed693840e04bee4d18fb9d396309"
      }
    ],
    "stats": {
      "total": 425,
      "additions": 306,
      "deletions": 119
    },
    "files": [
      {
        "sha": "b3b41e3d170dd6b10f88e2619873d06cd629152d",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ab9edbd6b6eb3efbca11f16fa467c3c0ef905708/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ab9edbd6b6eb3efbca11f16fa467c3c0ef905708/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=ab9edbd6b6eb3efbca11f16fa467c3c0ef905708",
        "patch": "@@ -112,6 +112,7 @@ BITCOIN_CORE_H = \\\n   script/sigcache.h \\\n   script/sign.h \\\n   script/standard.h \\\n+  script/script_error.h \\\n   serialize.h \\\n   streams.h \\\n   sync.h \\\n@@ -235,6 +236,7 @@ libbitcoin_common_a_SOURCES = \\\n   script/script.cpp \\\n   script/sign.cpp \\\n   script/standard.cpp \\\n+  script/script_error.cpp \\\n   $(BITCOIN_CORE_H)\n \n # util: shared between all executables."
      },
      {
        "sha": "cf81fe30a29150a42b0bd5cf7b9cbaf6978e6317",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 180,
        "deletions": 117,
        "changes": 297,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ab9edbd6b6eb3efbca11f16fa467c3c0ef905708/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ab9edbd6b6eb3efbca11f16fa467c3c0ef905708/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=ab9edbd6b6eb3efbca11f16fa467c3c0ef905708",
        "patch": "@@ -13,7 +13,6 @@\n #include \"pubkey.h\"\n #include \"script/script.h\"\n #include \"uint256.h\"\n-#include \"util.h\"\n \n using namespace std;\n \n@@ -26,6 +25,24 @@ static const CScriptNum bnOne(1);\n static const CScriptNum bnFalse(0);\n static const CScriptNum bnTrue(1);\n \n+namespace {\n+\n+inline bool set_success(ScriptError* ret)\n+{\n+    if (ret)\n+        *ret = SCRIPT_ERR_OK;\n+    return true;\n+}\n+\n+inline bool set_error(ScriptError* ret, const ScriptError serror)\n+{\n+    if (ret)\n+        *ret = serror;\n+    return false;\n+}\n+\n+} // anon namespace\n+\n bool CastToBool(const valtype& vch)\n {\n     for (unsigned int i = 0; i < vch.size(); i++)\n@@ -55,16 +72,23 @@ static inline void popstack(vector<valtype>& stack)\n }\n \n bool static IsCompressedOrUncompressedPubKey(const valtype &vchPubKey) {\n-    if (vchPubKey.size() < 33)\n-        return error(\"Non-canonical public key: too short\");\n+    if (vchPubKey.size() < 33) {\n+        //  Non-canonical public key: too short\n+        return false;\n+    }\n     if (vchPubKey[0] == 0x04) {\n-        if (vchPubKey.size() != 65)\n-            return error(\"Non-canonical public key: invalid length for uncompressed key\");\n+        if (vchPubKey.size() != 65) {\n+            //  Non-canonical public key: invalid length for uncompressed key\n+            return false;\n+        }\n     } else if (vchPubKey[0] == 0x02 || vchPubKey[0] == 0x03) {\n-        if (vchPubKey.size() != 33)\n-            return error(\"Non-canonical public key: invalid length for compressed key\");\n+        if (vchPubKey.size() != 33) {\n+            //  Non-canonical public key: invalid length for compressed key\n+            return false;\n+        }\n     } else {\n-        return error(\"Non-canonical public key: neither compressed nor uncompressed\");\n+          //  Non-canonical public key: neither compressed nor uncompressed\n+          return false;\n     }\n     return true;\n }\n@@ -79,47 +103,74 @@ bool static IsCompressedOrUncompressedPubKey(const valtype &vchPubKey) {\n  */\n bool static IsDERSignature(const valtype &vchSig) {\n \n-    if (vchSig.size() < 9)\n-        return error(\"Non-canonical signature: too short\");\n-    if (vchSig.size() > 73)\n-        return error(\"Non-canonical signature: too long\");\n-    if (vchSig[0] != 0x30)\n-        return error(\"Non-canonical signature: wrong type\");\n-    if (vchSig[1] != vchSig.size()-3)\n-        return error(\"Non-canonical signature: wrong length marker\");\n+    if (vchSig.size() < 9) {\n+        //  Non-canonical signature: too short\n+        return false;\n+    }\n+    if (vchSig.size() > 73) {\n+        // Non-canonical signature: too long\n+        return false;\n+    }\n+    if (vchSig[0] != 0x30) {\n+        //  Non-canonical signature: wrong type\n+        return false;\n+    }\n+    if (vchSig[1] != vchSig.size()-3) {\n+        //  Non-canonical signature: wrong length marker\n+        return false;\n+    }\n     unsigned int nLenR = vchSig[3];\n-    if (5 + nLenR >= vchSig.size())\n-        return error(\"Non-canonical signature: S length misplaced\");\n+    if (5 + nLenR >= vchSig.size()) {\n+        //  Non-canonical signature: S length misplaced\n+        return false;\n+    }\n     unsigned int nLenS = vchSig[5+nLenR];\n-    if ((unsigned long)(nLenR+nLenS+7) != vchSig.size())\n-        return error(\"Non-canonical signature: R+S length mismatch\");\n+    if ((unsigned long)(nLenR+nLenS+7) != vchSig.size()) {\n+        //  Non-canonical signature: R+S length mismatch\n+        return false;\n+    }\n \n     const unsigned char *R = &vchSig[4];\n-    if (R[-2] != 0x02)\n-        return error(\"Non-canonical signature: R value type mismatch\");\n-    if (nLenR == 0)\n-        return error(\"Non-canonical signature: R length is zero\");\n-    if (R[0] & 0x80)\n-        return error(\"Non-canonical signature: R value negative\");\n-    if (nLenR > 1 && (R[0] == 0x00) && !(R[1] & 0x80))\n-        return error(\"Non-canonical signature: R value excessively padded\");\n+    if (R[-2] != 0x02) {\n+        //  Non-canonical signature: R value type mismatch\n+        return false;\n+    }\n+    if (nLenR == 0) {\n+        //  Non-canonical signature: R length is zero\n+        return false;\n+    }\n+    if (R[0] & 0x80) {\n+        //  Non-canonical signature: R value negative\n+        return false;\n+    }\n+    if (nLenR > 1 && (R[0] == 0x00) && !(R[1] & 0x80)) {\n+        //  Non-canonical signature: R value excessively padded\n+        return false;\n+    }\n \n     const unsigned char *S = &vchSig[6+nLenR];\n-    if (S[-2] != 0x02)\n-        return error(\"Non-canonical signature: S value type mismatch\");\n-    if (nLenS == 0)\n-        return error(\"Non-canonical signature: S length is zero\");\n-    if (S[0] & 0x80)\n-        return error(\"Non-canonical signature: S value negative\");\n-    if (nLenS > 1 && (S[0] == 0x00) && !(S[1] & 0x80))\n-        return error(\"Non-canonical signature: S value excessively padded\");\n-\n+    if (S[-2] != 0x02) {\n+        //  Non-canonical signature: S value type mismatch\n+        return false;\n+    }\n+    if (nLenS == 0) {\n+        //  Non-canonical signature: S length is zero\n+        return false;\n+    }\n+    if (S[0] & 0x80) {\n+        //  Non-canonical signature: S value negative\n+        return false;\n+    }\n+    if (nLenS > 1 && (S[0] == 0x00) && !(S[1] & 0x80)) {\n+        //  Non-canonical signature: S value excessively padded\n+        return false;\n+    }\n     return true;\n }\n \n-bool static IsLowDERSignature(const valtype &vchSig) {\n+bool static IsLowDERSignature(const valtype &vchSig, ScriptError* serror) {\n     if (!IsDERSignature(vchSig)) {\n-        return false;\n+        return set_error(serror, SCRIPT_ERR_SIG_DER);\n     }\n     unsigned int nLenR = vchSig[3];\n     unsigned int nLenS = vchSig[5+nLenR];\n@@ -128,7 +179,7 @@ bool static IsLowDERSignature(const valtype &vchSig) {\n     // complement modulo the order could have been used instead, which is\n     // one byte shorter when encoded correctly.\n     if (!eccrypto::CheckSignatureElement(S, nLenS, true))\n-        return error(\"Non-canonical signature: S value is unnecessarily high\");\n+        return set_error(serror, SCRIPT_ERR_SIG_HIGH_S);\n \n     return true;\n }\n@@ -139,18 +190,19 @@ bool static IsDefinedHashtypeSignature(const valtype &vchSig) {\n     }\n     unsigned char nHashType = vchSig[vchSig.size() - 1] & (~(SIGHASH_ANYONECANPAY));\n     if (nHashType < SIGHASH_ALL || nHashType > SIGHASH_SINGLE)\n-        return error(\"Non-canonical signature: unknown hashtype byte\");\n+        return false;\n \n     return true;\n }\n \n-bool static CheckSignatureEncoding(const valtype &vchSig, unsigned int flags) {\n+bool static CheckSignatureEncoding(const valtype &vchSig, unsigned int flags, ScriptError* serror) {\n     if ((flags & (SCRIPT_VERIFY_DERSIG | SCRIPT_VERIFY_LOW_S | SCRIPT_VERIFY_STRICTENC)) != 0 && !IsDERSignature(vchSig)) {\n-        return false;\n-    } else if ((flags & SCRIPT_VERIFY_LOW_S) != 0 && !IsLowDERSignature(vchSig)) {\n+        return set_error(serror, SCRIPT_ERR_SIG_DER);\n+    } else if ((flags & SCRIPT_VERIFY_LOW_S) != 0 && !IsLowDERSignature(vchSig, serror)) {\n+        // serror is set\n         return false;\n     } else if ((flags & SCRIPT_VERIFY_STRICTENC) != 0 && !IsDefinedHashtypeSignature(vchSig)) {\n-        return false;\n+        return set_error(serror, SCRIPT_ERR_SIG_HASHTYPE);\n     }\n     return true;\n }\n@@ -185,7 +237,7 @@ bool static CheckMinimalPush(const valtype& data, opcodetype opcode) {\n     return true;\n }\n \n-bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker)\n+bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n {\n     CScript::const_iterator pc = script.begin();\n     CScript::const_iterator pend = script.end();\n@@ -194,8 +246,9 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n     valtype vchPushValue;\n     vector<bool> vfExec;\n     vector<valtype> altstack;\n+    set_error(serror, SCRIPT_ERR_UNKNOWN_ERROR);\n     if (script.size() > 10000)\n-        return false;\n+        return set_error(serror, SCRIPT_ERR_SCRIPT_SIZE);\n     int nOpCount = 0;\n     bool fRequireMinimal = (flags & SCRIPT_VERIFY_MINIMALDATA) != 0;\n \n@@ -209,13 +262,13 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n             // Read instruction\n             //\n             if (!script.GetOp(pc, opcode, vchPushValue))\n-                return false;\n+                return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n             if (vchPushValue.size() > MAX_SCRIPT_ELEMENT_SIZE)\n-                return false;\n+                return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n \n             // Note how OP_RESERVED does not count towards the opcode limit.\n             if (opcode > OP_16 && ++nOpCount > 201)\n-                return false;\n+                return set_error(serror, SCRIPT_ERR_OP_COUNT);\n \n             if (opcode == OP_CAT ||\n                 opcode == OP_SUBSTR ||\n@@ -232,11 +285,11 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 opcode == OP_MOD ||\n                 opcode == OP_LSHIFT ||\n                 opcode == OP_RSHIFT)\n-                return false; // Disabled opcodes.\n+                return set_error(serror, SCRIPT_ERR_DISABLED_OPCODE); // Disabled opcodes.\n \n             if (fExec && 0 <= opcode && opcode <= OP_PUSHDATA4) {\n                 if (fRequireMinimal && !CheckMinimalPush(vchPushValue, opcode)) {\n-                    return false;\n+                    return set_error(serror, SCRIPT_ERR_MINIMALDATA);\n                 }\n                 stack.push_back(vchPushValue);\n             } else if (fExec || (OP_IF <= opcode && opcode <= OP_ENDIF))\n@@ -288,7 +341,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                     if (fExec)\n                     {\n                         if (stack.size() < 1)\n-                            return false;\n+                            return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);\n                         valtype& vch = stacktop(-1);\n                         fValue = CastToBool(vch);\n                         if (opcode == OP_NOTIF)\n@@ -302,15 +355,15 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 case OP_ELSE:\n                 {\n                     if (vfExec.empty())\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);\n                     vfExec.back() = !vfExec.back();\n                 }\n                 break;\n \n                 case OP_ENDIF:\n                 {\n                     if (vfExec.empty())\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);\n                     vfExec.pop_back();\n                 }\n                 break;\n@@ -320,18 +373,18 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                     // (true -- ) or\n                     // (false -- false) and return\n                     if (stack.size() < 1)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     bool fValue = CastToBool(stacktop(-1));\n                     if (fValue)\n                         popstack(stack);\n                     else\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_VERIFY);\n                 }\n                 break;\n \n                 case OP_RETURN:\n                 {\n-                    return false;\n+                    return set_error(serror, SCRIPT_ERR_OP_RETURN);\n                 }\n                 break;\n \n@@ -342,7 +395,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 case OP_TOALTSTACK:\n                 {\n                     if (stack.size() < 1)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     altstack.push_back(stacktop(-1));\n                     popstack(stack);\n                 }\n@@ -351,7 +404,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 case OP_FROMALTSTACK:\n                 {\n                     if (altstack.size() < 1)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_ALTSTACK_OPERATION);\n                     stack.push_back(altstacktop(-1));\n                     popstack(altstack);\n                 }\n@@ -361,7 +414,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x1 x2 -- )\n                     if (stack.size() < 2)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     popstack(stack);\n                     popstack(stack);\n                 }\n@@ -371,7 +424,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x1 x2 -- x1 x2 x1 x2)\n                     if (stack.size() < 2)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     valtype vch1 = stacktop(-2);\n                     valtype vch2 = stacktop(-1);\n                     stack.push_back(vch1);\n@@ -383,7 +436,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n                     if (stack.size() < 3)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     valtype vch1 = stacktop(-3);\n                     valtype vch2 = stacktop(-2);\n                     valtype vch3 = stacktop(-1);\n@@ -397,7 +450,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n                     if (stack.size() < 4)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     valtype vch1 = stacktop(-4);\n                     valtype vch2 = stacktop(-3);\n                     stack.push_back(vch1);\n@@ -409,7 +462,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n                     if (stack.size() < 6)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     valtype vch1 = stacktop(-6);\n                     valtype vch2 = stacktop(-5);\n                     stack.erase(stack.end()-6, stack.end()-4);\n@@ -422,7 +475,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n                     if (stack.size() < 4)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     swap(stacktop(-4), stacktop(-2));\n                     swap(stacktop(-3), stacktop(-1));\n                 }\n@@ -432,7 +485,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x - 0 | x x)\n                     if (stack.size() < 1)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     valtype vch = stacktop(-1);\n                     if (CastToBool(vch))\n                         stack.push_back(vch);\n@@ -451,7 +504,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x -- )\n                     if (stack.size() < 1)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     popstack(stack);\n                 }\n                 break;\n@@ -460,7 +513,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x -- x x)\n                     if (stack.size() < 1)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     valtype vch = stacktop(-1);\n                     stack.push_back(vch);\n                 }\n@@ -470,7 +523,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x1 x2 -- x2)\n                     if (stack.size() < 2)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     stack.erase(stack.end() - 2);\n                 }\n                 break;\n@@ -479,7 +532,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x1 x2 -- x1 x2 x1)\n                     if (stack.size() < 2)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     valtype vch = stacktop(-2);\n                     stack.push_back(vch);\n                 }\n@@ -491,11 +544,11 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                     // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n                     // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n                     if (stack.size() < 2)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     int n = CScriptNum(stacktop(-1), fRequireMinimal).getint();\n                     popstack(stack);\n                     if (n < 0 || n >= (int)stack.size())\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     valtype vch = stacktop(-n-1);\n                     if (opcode == OP_ROLL)\n                         stack.erase(stack.end()-n-1);\n@@ -509,7 +562,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                     //  x2 x1 x3  after first swap\n                     //  x2 x3 x1  after second swap\n                     if (stack.size() < 3)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     swap(stacktop(-3), stacktop(-2));\n                     swap(stacktop(-2), stacktop(-1));\n                 }\n@@ -519,7 +572,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x1 x2 -- x2 x1)\n                     if (stack.size() < 2)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     swap(stacktop(-2), stacktop(-1));\n                 }\n                 break;\n@@ -528,7 +581,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x1 x2 -- x2 x1 x2)\n                     if (stack.size() < 2)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     valtype vch = stacktop(-1);\n                     stack.insert(stack.end()-2, vch);\n                 }\n@@ -539,7 +592,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (in -- in size)\n                     if (stack.size() < 1)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     CScriptNum bn(stacktop(-1).size());\n                     stack.push_back(bn.getvch());\n                 }\n@@ -555,7 +608,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x1 x2 - bool)\n                     if (stack.size() < 2)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     valtype& vch1 = stacktop(-2);\n                     valtype& vch2 = stacktop(-1);\n                     bool fEqual = (vch1 == vch2);\n@@ -572,7 +625,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                         if (fEqual)\n                             popstack(stack);\n                         else\n-                            return false;\n+                            return set_error(serror, SCRIPT_ERR_EQUALVERIFY);\n                     }\n                 }\n                 break;\n@@ -590,7 +643,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (in -- out)\n                     if (stack.size() < 1)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     CScriptNum bn(stacktop(-1), fRequireMinimal);\n                     switch (opcode)\n                     {\n@@ -623,7 +676,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x1 x2 -- out)\n                     if (stack.size() < 2)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     CScriptNum bn1(stacktop(-2), fRequireMinimal);\n                     CScriptNum bn2(stacktop(-1), fRequireMinimal);\n                     CScriptNum bn(0);\n@@ -659,7 +712,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                         if (CastToBool(stacktop(-1)))\n                             popstack(stack);\n                         else\n-                            return false;\n+                            return set_error(serror, SCRIPT_ERR_NUMEQUALVERIFY);\n                     }\n                 }\n                 break;\n@@ -668,7 +721,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (x min max -- out)\n                     if (stack.size() < 3)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     CScriptNum bn1(stacktop(-3), fRequireMinimal);\n                     CScriptNum bn2(stacktop(-2), fRequireMinimal);\n                     CScriptNum bn3(stacktop(-1), fRequireMinimal);\n@@ -692,7 +745,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (in -- hash)\n                     if (stack.size() < 1)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     valtype& vch = stacktop(-1);\n                     valtype vchHash((opcode == OP_RIPEMD160 || opcode == OP_SHA1 || opcode == OP_HASH160) ? 20 : 32);\n                     if (opcode == OP_RIPEMD160)\n@@ -722,7 +775,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                 {\n                     // (sig pubkey -- bool)\n                     if (stack.size() < 2)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n \n                     valtype& vchSig    = stacktop(-2);\n                     valtype& vchPubKey = stacktop(-1);\n@@ -733,10 +786,10 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                     // Drop the signature, since there's no way for a signature to sign itself\n                     scriptCode.FindAndDelete(CScript(vchSig));\n \n-                    if (!CheckSignatureEncoding(vchSig, flags)) {\n+                    if (!CheckSignatureEncoding(vchSig, flags, serror)) {\n+                        //serror is set\n                         return false;\n                     }\n-\n                     bool fSuccess = CheckPubKeyEncoding(vchPubKey, flags) && checker.CheckSig(vchSig, vchPubKey, scriptCode);\n \n                     popstack(stack);\n@@ -747,7 +800,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                         if (fSuccess)\n                             popstack(stack);\n                         else\n-                            return false;\n+                            return set_error(serror, SCRIPT_ERR_CHECKSIGVERIFY);\n                     }\n                 }\n                 break;\n@@ -759,26 +812,26 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n \n                     int i = 1;\n                     if ((int)stack.size() < i)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n \n                     int nKeysCount = CScriptNum(stacktop(-i), fRequireMinimal).getint();\n                     if (nKeysCount < 0 || nKeysCount > 20)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_PUBKEY_COUNT);\n                     nOpCount += nKeysCount;\n                     if (nOpCount > 201)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_OP_COUNT);\n                     int ikey = ++i;\n                     i += nKeysCount;\n                     if ((int)stack.size() < i)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n \n                     int nSigsCount = CScriptNum(stacktop(-i), fRequireMinimal).getint();\n                     if (nSigsCount < 0 || nSigsCount > nKeysCount)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_SIG_COUNT);\n                     int isig = ++i;\n                     i += nSigsCount;\n                     if ((int)stack.size() < i)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n \n                     // Subset of script starting at the most recent codeseparator\n                     CScript scriptCode(pbegincodehash, pend);\n@@ -796,7 +849,8 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                         valtype& vchSig    = stacktop(-isig);\n                         valtype& vchPubKey = stacktop(-ikey);\n \n-                        if (!CheckSignatureEncoding(vchSig, flags)) {\n+                        if (!CheckSignatureEncoding(vchSig, flags, serror)) {\n+                            // serror is set\n                             return false;\n                         }\n \n@@ -827,9 +881,9 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                     // so optionally verify it is exactly equal to zero prior\n                     // to removing it from the stack.\n                     if (stack.size() < 1)\n-                        return false;\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n                     if ((flags & SCRIPT_VERIFY_NULLDUMMY) && stacktop(-1).size())\n-                        return error(\"CHECKMULTISIG dummy argument not null\");\n+                        return set_error(serror, SCRIPT_ERR_SIG_NULLDUMMY);\n                     popstack(stack);\n \n                     stack.push_back(fSuccess ? vchTrue : vchFalse);\n@@ -839,29 +893,29 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                         if (fSuccess)\n                             popstack(stack);\n                         else\n-                            return false;\n+                            return set_error(serror, SCRIPT_ERR_CHECKMULTISIGVERIFY);\n                     }\n                 }\n                 break;\n \n                 default:\n-                    return false;\n+                    return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n             }\n \n             // Size limits\n             if (stack.size() + altstack.size() > 1000)\n-                return false;\n+                return set_error(serror, SCRIPT_ERR_STACK_SIZE);\n         }\n     }\n     catch (...)\n     {\n-        return false;\n+        return set_error(serror, SCRIPT_ERR_UNKNOWN_ERROR);\n     }\n \n     if (!vfExec.empty())\n-        return false;\n+        return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);\n \n-    return true;\n+    return set_success(serror);\n }\n \n namespace {\n@@ -966,14 +1020,14 @@ class CTransactionSignatureSerializer {\n uint256 SignatureHash(const CScript& scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType)\n {\n     if (nIn >= txTo.vin.size()) {\n-        LogPrintf(\"ERROR: SignatureHash() : nIn=%d out of range\\n\", nIn);\n+        //  nIn out of range\n         return 1;\n     }\n \n     // Check for invalid use of SIGHASH_SINGLE\n     if ((nHashType & 0x1f) == SIGHASH_SINGLE) {\n         if (nIn >= txTo.vout.size()) {\n-            LogPrintf(\"ERROR: SignatureHash() : nOut=%d out of range\\n\", nIn);\n+            //  nOut out of range\n             return 1;\n         }\n     }\n@@ -1013,30 +1067,35 @@ bool SignatureChecker::CheckSig(const vector<unsigned char>& vchSigIn, const vec\n     return true;\n }\n \n-bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, unsigned int flags, const BaseSignatureChecker& checker)\n+bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n {\n+    set_error(serror, SCRIPT_ERR_UNKNOWN_ERROR);\n+\n     if ((flags & SCRIPT_VERIFY_SIGPUSHONLY) != 0 && !scriptSig.IsPushOnly()) {\n-        return false;\n+        return set_error(serror, SCRIPT_ERR_SIG_PUSHONLY);\n     }\n \n     vector<vector<unsigned char> > stack, stackCopy;\n-    if (!EvalScript(stack, scriptSig, flags, checker))\n+    if (!EvalScript(stack, scriptSig, flags, checker, serror))\n+        // serror is set\n         return false;\n     if (flags & SCRIPT_VERIFY_P2SH)\n         stackCopy = stack;\n-    if (!EvalScript(stack, scriptPubKey, flags, checker))\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, serror))\n+        // serror is set\n         return false;\n     if (stack.empty())\n-        return false;\n+        return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n \n     if (CastToBool(stack.back()) == false)\n-        return false;\n+        return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n \n     // Additional validation for spend-to-script-hash transactions:\n     if ((flags & SCRIPT_VERIFY_P2SH) && scriptPubKey.IsPayToScriptHash())\n     {\n-        if (!scriptSig.IsPushOnly()) // scriptSig must be literals-only\n-            return false;            // or validation fails\n+        // scriptSig must be literals-only or validation fails\n+        if (!scriptSig.IsPushOnly())\n+            return set_error(serror, SCRIPT_ERR_SIG_PUSHONLY);\n \n         // stackCopy cannot be empty here, because if it was the\n         // P2SH  HASH <> EQUAL  scriptPubKey would be evaluated with\n@@ -1047,12 +1106,16 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, unsigne\n         CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end());\n         popstack(stackCopy);\n \n-        if (!EvalScript(stackCopy, pubKey2, flags, checker))\n+        if (!EvalScript(stackCopy, pubKey2, flags, checker, serror))\n+            // serror is set\n             return false;\n         if (stackCopy.empty())\n-            return false;\n-        return CastToBool(stackCopy.back());\n+            return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n+        if (!CastToBool(stackCopy.back()))\n+            return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n+        else\n+            return set_success(serror);\n     }\n \n-    return true;\n+    return set_success(serror);\n }"
      },
      {
        "sha": "14cccc558f329130cbc8196e8f06274b4a1bbe51",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ab9edbd6b6eb3efbca11f16fa467c3c0ef905708/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ab9edbd6b6eb3efbca11f16fa467c3c0ef905708/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=ab9edbd6b6eb3efbca11f16fa467c3c0ef905708",
        "patch": "@@ -6,6 +6,8 @@\n #ifndef BITCOIN_SCRIPT_INTERPRETER_H\n #define BITCOIN_SCRIPT_INTERPRETER_H\n \n+#include \"script_error.h\"\n+\n #include <vector>\n #include <stdint.h>\n #include <string>\n@@ -85,7 +87,7 @@ class SignatureChecker : public BaseSignatureChecker\n     bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode) const;\n };\n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker);\n-bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, unsigned int flags, const BaseSignatureChecker& checker);\n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* error = NULL);\n+bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* error = NULL);\n \n #endif // BITCOIN_SCRIPT_INTERPRETER_H"
      },
      {
        "sha": "4a3df268ec8bc9def7090885618cd85258f8efb3",
        "filename": "src/script/script_error.cpp",
        "status": "added",
        "additions": 67,
        "deletions": 0,
        "changes": 67,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ab9edbd6b6eb3efbca11f16fa467c3c0ef905708/src/script/script_error.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ab9edbd6b6eb3efbca11f16fa467c3c0ef905708/src/script/script_error.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script_error.cpp?ref=ab9edbd6b6eb3efbca11f16fa467c3c0ef905708",
        "patch": "@@ -0,0 +1,67 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2014 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"script_error.h\"\n+\n+const char* ScriptErrorString(const ScriptError serror)\n+{\n+    switch (serror)\n+    {\n+        case SCRIPT_ERR_OK:\n+            return \"No error\";\n+        case SCRIPT_ERR_EVAL_FALSE:\n+            return \"Script evaluated without error but finished with a false/empty top stack element\";\n+        case SCRIPT_ERR_VERIFY:\n+            return \"Script failed an OP_VERIFY operation\";\n+        case SCRIPT_ERR_EQUALVERIFY:\n+            return \"Script failed an OP_EQUALVERIFY operation\";\n+        case SCRIPT_ERR_CHECKMULTISIGVERIFY:\n+            return \"Script failed an OP_CHECKMULTISIGVERIFY operation\";\n+        case SCRIPT_ERR_CHECKSIGVERIFY:\n+            return \"Script failed an OP_CHECKSIGVERIFY operation\";\n+        case SCRIPT_ERR_NUMEQUALVERIFY:\n+            return \"Script failed an OP_NUMEQUALVERIFY operation\";\n+        case SCRIPT_ERR_SCRIPT_SIZE:\n+            return \"Script is too big\";\n+        case SCRIPT_ERR_PUSH_SIZE:\n+            return \"Push value size limit exceeded\";\n+        case SCRIPT_ERR_OP_COUNT:\n+            return \"Operation limit exceeded\";\n+        case SCRIPT_ERR_STACK_SIZE:\n+            return \"Stack size limit exceeded\";\n+        case SCRIPT_ERR_SIG_COUNT:\n+            return \"Signature count negative or greater than pubkey count\";\n+        case SCRIPT_ERR_PUBKEY_COUNT:\n+            return \"Pubkey count negative or limit exceeded\";\n+        case SCRIPT_ERR_BAD_OPCODE:\n+            return \"Opcode missing or not understood\";\n+        case SCRIPT_ERR_DISABLED_OPCODE:\n+            return \"Attempted to use a disabled opcode\";\n+        case SCRIPT_ERR_INVALID_STACK_OPERATION:\n+            return \"Operation not valid with the current stack size\";\n+        case SCRIPT_ERR_INVALID_ALTSTACK_OPERATION:\n+            return \"Operation not valid with the current altstack size\";\n+        case SCRIPT_ERR_OP_RETURN:\n+            return \"OP_RETURN was encountered\";\n+        case SCRIPT_ERR_UNBALANCED_CONDITIONAL:\n+            return \"Invalid OP_IF construction\";\n+        case SCRIPT_ERR_SIG_HASHTYPE:\n+            return \"Signature hash type missing or not understood\";\n+        case SCRIPT_ERR_SIG_DER:\n+            return \"Non-canonical DER signature\";\n+        case SCRIPT_ERR_MINIMALDATA:\n+            return \"Data push larger than necessary\";\n+        case SCRIPT_ERR_SIG_PUSHONLY:\n+            return \"Only non-push operators allowed in signatures\";\n+        case SCRIPT_ERR_SIG_HIGH_S:\n+            return \"Non-canonical signature: S value is unnecessarily high\";\n+        case SCRIPT_ERR_SIG_NULLDUMMY:\n+            return \"Dummy CHECKMULTISIG argument must be zero\";\n+        case SCRIPT_ERR_UNKNOWN_ERROR:\n+        case SCRIPT_ERR_ERROR_COUNT:\n+        default: break;\n+    }\n+    return \"unknown error\";\n+}"
      },
      {
        "sha": "ae6626b2573922b9b8d761c5d36a3e606ac3a86a",
        "filename": "src/script/script_error.h",
        "status": "added",
        "additions": 53,
        "deletions": 0,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ab9edbd6b6eb3efbca11f16fa467c3c0ef905708/src/script/script_error.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ab9edbd6b6eb3efbca11f16fa467c3c0ef905708/src/script/script_error.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script_error.h?ref=ab9edbd6b6eb3efbca11f16fa467c3c0ef905708",
        "patch": "@@ -0,0 +1,53 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2014 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_ERROR_H\n+#define BITCOIN_SCRIPT_ERROR_H\n+\n+typedef enum ScriptError_t\n+{\n+    SCRIPT_ERR_OK = 0,\n+    SCRIPT_ERR_UNKNOWN_ERROR,\n+    SCRIPT_ERR_EVAL_FALSE,\n+    SCRIPT_ERR_OP_RETURN,\n+\n+    /* Max sizes */\n+    SCRIPT_ERR_SCRIPT_SIZE,\n+    SCRIPT_ERR_PUSH_SIZE,\n+    SCRIPT_ERR_OP_COUNT,\n+    SCRIPT_ERR_STACK_SIZE,\n+    SCRIPT_ERR_SIG_COUNT,\n+    SCRIPT_ERR_PUBKEY_COUNT,\n+\n+    /* Failed verify operations */\n+    SCRIPT_ERR_VERIFY,\n+    SCRIPT_ERR_EQUALVERIFY,\n+    SCRIPT_ERR_CHECKMULTISIGVERIFY,\n+    SCRIPT_ERR_CHECKSIGVERIFY,\n+    SCRIPT_ERR_NUMEQUALVERIFY,\n+\n+    /* Logical/Format/Canonical errors */\n+    SCRIPT_ERR_BAD_OPCODE,\n+    SCRIPT_ERR_DISABLED_OPCODE,\n+    SCRIPT_ERR_INVALID_STACK_OPERATION,\n+    SCRIPT_ERR_INVALID_ALTSTACK_OPERATION,\n+    SCRIPT_ERR_UNBALANCED_CONDITIONAL,\n+\n+    /* BIP62 */\n+    SCRIPT_ERR_SIG_HASHTYPE,\n+    SCRIPT_ERR_SIG_DER,\n+    SCRIPT_ERR_MINIMALDATA,\n+    SCRIPT_ERR_SIG_PUSHONLY,\n+    SCRIPT_ERR_SIG_HIGH_S,\n+    SCRIPT_ERR_SIG_NULLDUMMY,\n+\n+    SCRIPT_ERR_ERROR_COUNT\n+} ScriptError;\n+\n+#define SCRIPT_ERR_LAST SCRIPT_ERR_ERROR_COUNT\n+\n+const char* ScriptErrorString(const ScriptError error);\n+\n+#endif // BITCOIN_SCRIPT_ERROR_H"
      }
    ]
  },
  {
    "sha": "219a1470c4ca05579cf5f3d75db0d632d17c13d4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMTlhMTQ3MGM0Y2EwNTU3OWNmNWYzZDc1ZGIwZDYzMmQxN2MxM2Q0",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2014-11-13T19:27:38Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2014-11-14T21:25:53Z"
      },
      "message": "script: check ScriptError values in script tests",
      "tree": {
        "sha": "47282737ef43f9db50d789c51ae217b512f95d0d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/47282737ef43f9db50d789c51ae217b512f95d0d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/219a1470c4ca05579cf5f3d75db0d632d17c13d4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/219a1470c4ca05579cf5f3d75db0d632d17c13d4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/219a1470c4ca05579cf5f3d75db0d632d17c13d4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/219a1470c4ca05579cf5f3d75db0d632d17c13d4/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ab9edbd6b6eb3efbca11f16fa467c3c0ef905708",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ab9edbd6b6eb3efbca11f16fa467c3c0ef905708",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ab9edbd6b6eb3efbca11f16fa467c3c0ef905708"
      }
    ],
    "stats": {
      "total": 132,
      "additions": 94,
      "deletions": 38
    },
    "files": [
      {
        "sha": "8d06caa147c3ce795c5162b266e1fbf09d2eda88",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 9,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/219a1470c4ca05579cf5f3d75db0d632d17c13d4/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/219a1470c4ca05579cf5f3d75db0d632d17c13d4/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=219a1470c4ca05579cf5f3d75db0d632d17c13d4",
        "patch": "@@ -6,6 +6,7 @@\n #include \"keystore.h\"\n #include \"main.h\"\n #include \"script/script.h\"\n+#include \"script/script_error.h\"\n #include \"script/interpreter.h\"\n #include \"script/sign.h\"\n #include \"uint256.h\"\n@@ -46,6 +47,7 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n {\n     unsigned int flags = SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC;\n \n+    ScriptError err;\n     CKey key[4];\n     for (int i = 0; i < 4; i++)\n         key[i].MakeNewKey(true);\n@@ -82,19 +84,22 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n     keys.clear();\n     keys += key[0],key[1]; // magic operator+= from boost.assign\n     s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-    BOOST_CHECK(VerifyScript(s, a_and_b, flags, SignatureChecker(txTo[0], 0)));\n+    BOOST_CHECK(VerifyScript(s, a_and_b, flags, SignatureChecker(txTo[0], 0), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     for (int i = 0; i < 4; i++)\n     {\n         keys.clear();\n         keys += key[i];\n         s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, flags, SignatureChecker(txTo[0], 0)), strprintf(\"a&b 1: %d\", i));\n+        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, flags, SignatureChecker(txTo[0], 0), &err), strprintf(\"a&b 1: %d\", i));\n+        BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_INVALID_STACK_OPERATION, ScriptErrorString(err));\n \n         keys.clear();\n         keys += key[1],key[i];\n         s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, flags, SignatureChecker(txTo[0], 0)), strprintf(\"a&b 2: %d\", i));\n+        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, flags, SignatureChecker(txTo[0], 0), &err), strprintf(\"a&b 2: %d\", i));\n+        BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n     }\n \n     // Test a OR b:\n@@ -104,16 +109,24 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n         keys += key[i];\n         s = sign_multisig(a_or_b, keys, txTo[1], 0);\n         if (i == 0 || i == 1)\n-            BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, flags, SignatureChecker(txTo[1], 0)), strprintf(\"a|b: %d\", i));\n+        {\n+            BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, flags, SignatureChecker(txTo[1], 0), &err), strprintf(\"a|b: %d\", i));\n+            BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n+        }\n         else\n-            BOOST_CHECK_MESSAGE(!VerifyScript(s, a_or_b, flags, SignatureChecker(txTo[1], 0)), strprintf(\"a|b: %d\", i));\n+        {\n+            BOOST_CHECK_MESSAGE(!VerifyScript(s, a_or_b, flags, SignatureChecker(txTo[1], 0), &err), strprintf(\"a|b: %d\", i));\n+            BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n+        }\n     }\n     s.clear();\n     s << OP_0 << OP_0;\n-    BOOST_CHECK(!VerifyScript(s, a_or_b, flags, SignatureChecker(txTo[1], 0)));\n+    BOOST_CHECK(!VerifyScript(s, a_or_b, flags, SignatureChecker(txTo[1], 0), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_SIG_DER, ScriptErrorString(err));\n     s.clear();\n     s << OP_0 << OP_1;\n-    BOOST_CHECK(!VerifyScript(s, a_or_b, flags, SignatureChecker(txTo[1], 0)));\n+    BOOST_CHECK(!VerifyScript(s, a_or_b, flags, SignatureChecker(txTo[1], 0), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_SIG_DER, ScriptErrorString(err));\n \n \n     for (int i = 0; i < 4; i++)\n@@ -123,9 +136,15 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n             keys += key[i],key[j];\n             s = sign_multisig(escrow, keys, txTo[2], 0);\n             if (i < j && i < 3 && j < 3)\n-                BOOST_CHECK_MESSAGE(VerifyScript(s, escrow, flags, SignatureChecker(txTo[2], 0)), strprintf(\"escrow 1: %d %d\", i, j));\n+            {\n+                BOOST_CHECK_MESSAGE(VerifyScript(s, escrow, flags, SignatureChecker(txTo[2], 0), &err), strprintf(\"escrow 1: %d %d\", i, j));\n+                BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n+            }\n             else\n-                BOOST_CHECK_MESSAGE(!VerifyScript(s, escrow, flags, SignatureChecker(txTo[2], 0)), strprintf(\"escrow 2: %d %d\", i, j));\n+            {\n+                BOOST_CHECK_MESSAGE(!VerifyScript(s, escrow, flags, SignatureChecker(txTo[2], 0), &err), strprintf(\"escrow 2: %d %d\", i, j));\n+                BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n+            }\n         }\n }\n "
      },
      {
        "sha": "a969eefa05370113010fea4fe1fab0037fbd4451",
        "filename": "src/test/script_P2SH_tests.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 6,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/219a1470c4ca05579cf5f3d75db0d632d17c13d4/src/test/script_P2SH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/219a1470c4ca05579cf5f3d75db0d632d17c13d4/src/test/script_P2SH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2SH_tests.cpp?ref=219a1470c4ca05579cf5f3d75db0d632d17c13d4",
        "patch": "@@ -6,6 +6,7 @@\n #include \"keystore.h\"\n #include \"main.h\"\n #include \"script/script.h\"\n+#include \"script/script_error.h\"\n #include \"script/sign.h\"\n \n #ifdef ENABLE_WALLET\n@@ -27,7 +28,7 @@ Serialize(const CScript& s)\n }\n \n static bool\n-Verify(const CScript& scriptSig, const CScript& scriptPubKey, bool fStrict)\n+Verify(const CScript& scriptSig, const CScript& scriptPubKey, bool fStrict, ScriptError& err)\n {\n     // Create dummy to/from transactions:\n     CMutableTransaction txFrom;\n@@ -42,7 +43,7 @@ Verify(const CScript& scriptSig, const CScript& scriptPubKey, bool fStrict)\n     txTo.vin[0].scriptSig = scriptSig;\n     txTo.vout[0].nValue = 1;\n \n-    return VerifyScript(scriptSig, scriptPubKey, fStrict ? SCRIPT_VERIFY_P2SH : SCRIPT_VERIFY_NONE, SignatureChecker(txTo, 0));\n+    return VerifyScript(scriptSig, scriptPubKey, fStrict ? SCRIPT_VERIFY_P2SH : SCRIPT_VERIFY_NONE, SignatureChecker(txTo, 0), &err);\n }\n \n \n@@ -124,6 +125,7 @@ BOOST_AUTO_TEST_CASE(sign)\n \n BOOST_AUTO_TEST_CASE(norecurse)\n {\n+    ScriptError err;\n     // Make sure only the outer pay-to-script-hash does the\n     // extra-validation thing:\n     CScript invalidAsScript;\n@@ -135,15 +137,17 @@ BOOST_AUTO_TEST_CASE(norecurse)\n     scriptSig << Serialize(invalidAsScript);\n \n     // Should not verify, because it will try to execute OP_INVALIDOPCODE\n-    BOOST_CHECK(!Verify(scriptSig, p2sh, true));\n+    BOOST_CHECK(!Verify(scriptSig, p2sh, true, err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_BAD_OPCODE, ScriptErrorString(err));\n \n     // Try to recur, and verification should succeed because\n     // the inner HASH160 <> EQUAL should only check the hash:\n     CScript p2sh2 = GetScriptForDestination(CScriptID(p2sh));\n     CScript scriptSig2;\n     scriptSig2 << Serialize(invalidAsScript) << Serialize(p2sh);\n \n-    BOOST_CHECK(Verify(scriptSig2, p2sh2, true));\n+    BOOST_CHECK(Verify(scriptSig2, p2sh2, true, err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n }\n \n BOOST_AUTO_TEST_CASE(set)\n@@ -238,6 +242,7 @@ BOOST_AUTO_TEST_CASE(switchover)\n {\n     // Test switch over code\n     CScript notValid;\n+    ScriptError err;\n     notValid << OP_11 << OP_12 << OP_EQUALVERIFY;\n     CScript scriptSig;\n     scriptSig << Serialize(notValid);\n@@ -246,9 +251,11 @@ BOOST_AUTO_TEST_CASE(switchover)\n \n \n     // Validation should succeed under old rules (hash is correct):\n-    BOOST_CHECK(Verify(scriptSig, fund, false));\n+    BOOST_CHECK(Verify(scriptSig, fund, false, err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n     // Fail under new:\n-    BOOST_CHECK(!Verify(scriptSig, fund, true));\n+    BOOST_CHECK(!Verify(scriptSig, fund, true, err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EQUALVERIFY, ScriptErrorString(err));\n }\n \n BOOST_AUTO_TEST_CASE(AreInputsStandard)"
      },
      {
        "sha": "ede13b23c292a3d0b806cb3db918026b1b88c3ca",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 46,
        "deletions": 20,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/219a1470c4ca05579cf5f3d75db0d632d17c13d4/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/219a1470c4ca05579cf5f3d75db0d632d17c13d4/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=219a1470c4ca05579cf5f3d75db0d632d17c13d4",
        "patch": "@@ -10,6 +10,7 @@\n #include \"keystore.h\"\n #include \"main.h\"\n #include \"script/script.h\"\n+#include \"script/script_error.h\"\n #include \"script/sign.h\"\n #include \"util.h\"\n \n@@ -92,7 +93,9 @@ CMutableTransaction BuildSpendingTransaction(const CScript& scriptSig, const CMu\n \n void DoTest(const CScript& scriptPubKey, const CScript& scriptSig, int flags, bool expect, const std::string& message)\n {\n-    BOOST_CHECK_MESSAGE(VerifyScript(scriptSig, scriptPubKey, flags, SignatureChecker(BuildSpendingTransaction(scriptSig, BuildCreditingTransaction(scriptPubKey)), 0)) == expect, message);\n+    ScriptError err;\n+    BOOST_CHECK_MESSAGE(VerifyScript(scriptSig, scriptPubKey, flags, SignatureChecker(BuildSpendingTransaction(scriptSig, BuildCreditingTransaction(scriptPubKey)), 0), &err) == expect, message);\n+    BOOST_CHECK_MESSAGE(expect == (err == SCRIPT_ERR_OK), std::string(ScriptErrorString(err)) + \": \" + message);\n }\n \n void static NegateSignatureS(std::vector<unsigned char>& vchSig) {\n@@ -590,20 +593,25 @@ BOOST_AUTO_TEST_CASE(script_PushData)\n     static const unsigned char pushdata2[] = { OP_PUSHDATA2, 1, 0, 0x5a };\n     static const unsigned char pushdata4[] = { OP_PUSHDATA4, 1, 0, 0, 0, 0x5a };\n \n+    ScriptError err;\n     vector<vector<unsigned char> > directStack;\n-    BOOST_CHECK(EvalScript(directStack, CScript(&direct[0], &direct[sizeof(direct)]), true, BaseSignatureChecker()));\n+    BOOST_CHECK(EvalScript(directStack, CScript(&direct[0], &direct[sizeof(direct)]), true, BaseSignatureChecker(), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     vector<vector<unsigned char> > pushdata1Stack;\n-    BOOST_CHECK(EvalScript(pushdata1Stack, CScript(&pushdata1[0], &pushdata1[sizeof(pushdata1)]), true, BaseSignatureChecker()));\n+    BOOST_CHECK(EvalScript(pushdata1Stack, CScript(&pushdata1[0], &pushdata1[sizeof(pushdata1)]), true, BaseSignatureChecker(), &err));\n     BOOST_CHECK(pushdata1Stack == directStack);\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     vector<vector<unsigned char> > pushdata2Stack;\n-    BOOST_CHECK(EvalScript(pushdata2Stack, CScript(&pushdata2[0], &pushdata2[sizeof(pushdata2)]), true, BaseSignatureChecker()));\n+    BOOST_CHECK(EvalScript(pushdata2Stack, CScript(&pushdata2[0], &pushdata2[sizeof(pushdata2)]), true, BaseSignatureChecker(), &err));\n     BOOST_CHECK(pushdata2Stack == directStack);\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     vector<vector<unsigned char> > pushdata4Stack;\n-    BOOST_CHECK(EvalScript(pushdata4Stack, CScript(&pushdata4[0], &pushdata4[sizeof(pushdata4)]), true, BaseSignatureChecker()));\n+    BOOST_CHECK(EvalScript(pushdata4Stack, CScript(&pushdata4[0], &pushdata4[sizeof(pushdata4)]), true, BaseSignatureChecker(), &err));\n     BOOST_CHECK(pushdata4Stack == directStack);\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n }\n \n CScript\n@@ -640,6 +648,7 @@ sign_multisig(CScript scriptPubKey, const CKey &key, CTransaction transaction)\n \n BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG12)\n {\n+    ScriptError err;\n     CKey key1, key2, key3;\n     key1.MakeNewKey(true);\n     key2.MakeNewKey(false);\n@@ -652,19 +661,24 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG12)\n     CMutableTransaction txTo12 = BuildSpendingTransaction(CScript(), txFrom12);\n \n     CScript goodsig1 = sign_multisig(scriptPubKey12, key1, txTo12);\n-    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey12, flags, SignatureChecker(txTo12, 0)));\n+    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey12, flags, SignatureChecker(txTo12, 0), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n     txTo12.vout[0].nValue = 2;\n-    BOOST_CHECK(!VerifyScript(goodsig1, scriptPubKey12, flags, SignatureChecker(txTo12, 0)));\n+    BOOST_CHECK(!VerifyScript(goodsig1, scriptPubKey12, flags, SignatureChecker(txTo12, 0), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     CScript goodsig2 = sign_multisig(scriptPubKey12, key2, txTo12);\n-    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey12, flags, SignatureChecker(txTo12, 0)));\n+    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey12, flags, SignatureChecker(txTo12, 0), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     CScript badsig1 = sign_multisig(scriptPubKey12, key3, txTo12);\n-    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey12, flags, SignatureChecker(txTo12, 0)));\n+    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey12, flags, SignatureChecker(txTo12, 0), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n }\n \n BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n {\n+    ScriptError err;\n     CKey key1, key2, key3, key4;\n     key1.MakeNewKey(true);\n     key2.MakeNewKey(false);\n@@ -680,46 +694,55 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n     std::vector<CKey> keys;\n     keys.push_back(key1); keys.push_back(key2);\n     CScript goodsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey23, flags, SignatureChecker(txTo23, 0)));\n+    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey23, flags, SignatureChecker(txTo23, 0), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key1); keys.push_back(key3);\n     CScript goodsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey23, flags, SignatureChecker(txTo23, 0)));\n+    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey23, flags, SignatureChecker(txTo23, 0), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key3);\n     CScript goodsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig3, scriptPubKey23, flags, SignatureChecker(txTo23, 0)));\n+    BOOST_CHECK(VerifyScript(goodsig3, scriptPubKey23, flags, SignatureChecker(txTo23, 0), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key2); // Can't re-use sig\n     CScript badsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey23, flags, SignatureChecker(txTo23, 0)));\n+    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey23, flags, SignatureChecker(txTo23, 0), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key1); // sigs must be in correct order\n     CScript badsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig2, scriptPubKey23, flags, SignatureChecker(txTo23, 0)));\n+    BOOST_CHECK(!VerifyScript(badsig2, scriptPubKey23, flags, SignatureChecker(txTo23, 0), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key3); keys.push_back(key2); // sigs must be in correct order\n     CScript badsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig3, scriptPubKey23, flags, SignatureChecker(txTo23, 0)));\n+    BOOST_CHECK(!VerifyScript(badsig3, scriptPubKey23, flags, SignatureChecker(txTo23, 0), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key4); keys.push_back(key2); // sigs must match pubkeys\n     CScript badsig4 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig4, scriptPubKey23, flags, SignatureChecker(txTo23, 0)));\n+    BOOST_CHECK(!VerifyScript(badsig4, scriptPubKey23, flags, SignatureChecker(txTo23, 0), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key1); keys.push_back(key4); // sigs must match pubkeys\n     CScript badsig5 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig5, scriptPubKey23, flags, SignatureChecker(txTo23, 0)));\n+    BOOST_CHECK(!VerifyScript(badsig5, scriptPubKey23, flags, SignatureChecker(txTo23, 0), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear(); // Must have signatures\n     CScript badsig6 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig6, scriptPubKey23, flags, SignatureChecker(txTo23, 0)));\n+    BOOST_CHECK(!VerifyScript(badsig6, scriptPubKey23, flags, SignatureChecker(txTo23, 0), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_INVALID_STACK_OPERATION, ScriptErrorString(err));\n }    \n \n BOOST_AUTO_TEST_CASE(script_combineSigs)\n@@ -833,19 +856,22 @@ BOOST_AUTO_TEST_CASE(script_combineSigs)\n \n BOOST_AUTO_TEST_CASE(script_standard_push)\n {\n+    ScriptError err;\n     for (int i=0; i<67000; i++) {\n         CScript script;\n         script << i;\n         BOOST_CHECK_MESSAGE(script.IsPushOnly(), \"Number \" << i << \" is not pure push.\");\n-        BOOST_CHECK_MESSAGE(VerifyScript(script, CScript() << OP_1, SCRIPT_VERIFY_MINIMALDATA, BaseSignatureChecker()), \"Number \" << i << \" push is not minimal data.\");\n+        BOOST_CHECK_MESSAGE(VerifyScript(script, CScript() << OP_1, SCRIPT_VERIFY_MINIMALDATA, BaseSignatureChecker(), &err), \"Number \" << i << \" push is not minimal data.\");\n+        BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n     }\n \n     for (unsigned int i=0; i<=MAX_SCRIPT_ELEMENT_SIZE; i++) {\n         std::vector<unsigned char> data(i, '\\111');\n         CScript script;\n         script << data;\n         BOOST_CHECK_MESSAGE(script.IsPushOnly(), \"Length \" << i << \" is not pure push.\");\n-        BOOST_CHECK_MESSAGE(VerifyScript(script, CScript() << OP_1, SCRIPT_VERIFY_MINIMALDATA, BaseSignatureChecker()), \"Length \" << i << \" push is not minimal data.\");\n+        BOOST_CHECK_MESSAGE(VerifyScript(script, CScript() << OP_1, SCRIPT_VERIFY_MINIMALDATA, BaseSignatureChecker(), &err), \"Length \" << i << \" push is not minimal data.\");\n+        BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n     }\n }\n "
      },
      {
        "sha": "bf3a60c04f55cd2b068505b872d37eb6b7f7cbcf",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 3,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/219a1470c4ca05579cf5f3d75db0d632d17c13d4/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/219a1470c4ca05579cf5f3d75db0d632d17c13d4/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=219a1470c4ca05579cf5f3d75db0d632d17c13d4",
        "patch": "@@ -10,6 +10,7 @@\n #include \"keystore.h\"\n #include \"main.h\"\n #include \"script/script.h\"\n+#include \"script/script_error.h\"\n #include \"core_io.h\"\n \n #include <map>\n@@ -86,6 +87,7 @@ BOOST_AUTO_TEST_CASE(tx_valid)\n     // verifyFlags is a comma separated list of script verification flags to apply, or \"NONE\"\n     Array tests = read_json(std::string(json_tests::tx_valid, json_tests::tx_valid + sizeof(json_tests::tx_valid)));\n \n+    ScriptError err;\n     BOOST_FOREACH(Value& tv, tests)\n     {\n         Array test = tv.get_array();\n@@ -142,8 +144,9 @@ BOOST_AUTO_TEST_CASE(tx_valid)\n \n                 unsigned int verify_flags = ParseScriptFlags(test[2].get_str());\n                 BOOST_CHECK_MESSAGE(VerifyScript(tx.vin[i].scriptSig, mapprevOutScriptPubKeys[tx.vin[i].prevout],\n-                                                 verify_flags, SignatureChecker(tx, i)),\n+                                                 verify_flags, SignatureChecker(tx, i), &err),\n                                     strTest);\n+                BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n             }\n         }\n     }\n@@ -160,6 +163,7 @@ BOOST_AUTO_TEST_CASE(tx_invalid)\n     // verifyFlags is a comma separated list of script verification flags to apply, or \"NONE\"\n     Array tests = read_json(std::string(json_tests::tx_invalid, json_tests::tx_invalid + sizeof(json_tests::tx_invalid)));\n \n+    ScriptError err;\n     BOOST_FOREACH(Value& tv, tests)\n     {\n         Array test = tv.get_array();\n@@ -215,10 +219,10 @@ BOOST_AUTO_TEST_CASE(tx_invalid)\n \n                 unsigned int verify_flags = ParseScriptFlags(test[2].get_str());\n                 fValid = VerifyScript(tx.vin[i].scriptSig, mapprevOutScriptPubKeys[tx.vin[i].prevout],\n-                                      verify_flags, SignatureChecker(tx, i));\n+                                      verify_flags, SignatureChecker(tx, i), &err);\n             }\n-\n             BOOST_CHECK_MESSAGE(!fValid, strTest);\n+            BOOST_CHECK_MESSAGE(err != SCRIPT_ERR_OK, ScriptErrorString(err));\n         }\n     }\n }"
      }
    ]
  }
]