[
  {
    "sha": "f994ceaa5f7862f7ed2c6142cb44c0736ad905b6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmOTk0Y2VhYTVmNzg2MmY3ZWQyYzYxNDJjYjQ0YzA3MzZhZDkwNWI2",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2012-05-05T19:41:17Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2012-05-18T03:13:30Z"
      },
      "message": "Add comment for constant pubkey.",
      "tree": {
        "sha": "e008ddbdfa615bfc76cd957d9b95b39a6247a684",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e008ddbdfa615bfc76cd957d9b95b39a6247a684"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f994ceaa5f7862f7ed2c6142cb44c0736ad905b6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f994ceaa5f7862f7ed2c6142cb44c0736ad905b6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f994ceaa5f7862f7ed2c6142cb44c0736ad905b6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f994ceaa5f7862f7ed2c6142cb44c0736ad905b6/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "49232d1abf96f85f785e0ee95fbb79d0338855bc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/49232d1abf96f85f785e0ee95fbb79d0338855bc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/49232d1abf96f85f785e0ee95fbb79d0338855bc"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 1,
      "deletions": 0
    },
    "files": [
      {
        "sha": "a2ecfa428657d8849479359cf64a38fb0ee821c3",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f994ceaa5f7862f7ed2c6142cb44c0736ad905b6/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f994ceaa5f7862f7ed2c6142cb44c0736ad905b6/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=f994ceaa5f7862f7ed2c6142cb44c0736ad905b6",
        "patch": "@@ -1587,6 +1587,7 @@ class CAlert : public CUnsignedAlert\n     bool CheckSignature()\n     {\n         CKey key;\n+        // The following key is a pubkey to which only Gavin, Satoshi, and theymos are known to have the private key\n         if (!key.SetPubKey(ParseHex(\"04fc9702847840aaf195de8442ebecedf5b095cdbb9bc716bda9110971b28a49e0ead8564ff0db22209e0374782c093bb899692d524e9d6a6956e7c5ecbcd68284\")))\n             return error(\"CAlert::CheckSignature() : SetPubKey failed\");\n         if (!key.Verify(Hash(vchMsg.begin(), vchMsg.end()), vchSig))"
      }
    ]
  },
  {
    "sha": "000f04150d61b405b62299a74a53c7a4ba8637ad",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMDBmMDQxNTBkNjFiNDA1YjYyMjk5YTc0YTUzYzdhNGJhODYzN2Fk",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2012-04-01T01:26:12Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2012-05-18T03:13:30Z"
      },
      "message": "Change Bitcoin's flow to use a CBlockStore class\nwhich net/wallets send/recieve blocks to/from.\n\nThis commit is designed to not change any bitcoin functionality or operation.\n\nLargest changes:\n* ProcessMessage(s)/SendMessages moved to protocol.cpp\n* Many globals removed from main.h and abstracted to CBlockStore\n* Calls to CWallet::AddToWalletIfInvolvingMe no longer block Block verification,\n  resulting in a small, but measureable block verification speed increase.\n\nThere is still a lot of abstraction to go, but this is a step in the right direction.",
      "tree": {
        "sha": "cddc3a6c72015c1435691e0e6722989fc9f5f752",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cddc3a6c72015c1435691e0e6722989fc9f5f752"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/000f04150d61b405b62299a74a53c7a4ba8637ad",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/000f04150d61b405b62299a74a53c7a4ba8637ad",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/000f04150d61b405b62299a74a53c7a4ba8637ad",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/000f04150d61b405b62299a74a53c7a4ba8637ad/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "f994ceaa5f7862f7ed2c6142cb44c0736ad905b6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f994ceaa5f7862f7ed2c6142cb44c0736ad905b6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f994ceaa5f7862f7ed2c6142cb44c0736ad905b6"
      }
    ],
    "stats": {
      "total": 3420,
      "additions": 1889,
      "deletions": 1531
    },
    "files": [
      {
        "sha": "ae58013f2c05a681a12950cd4a697707eb6f8de8",
        "filename": "bitcoin-qt.pro",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/000f04150d61b405b62299a74a53c7a4ba8637ad/bitcoin-qt.pro",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/000f04150d61b405b62299a74a53c7a4ba8637ad/bitcoin-qt.pro",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/bitcoin-qt.pro?ref=000f04150d61b405b62299a74a53c7a4ba8637ad",
        "patch": "@@ -161,7 +161,8 @@ HEADERS += src/qt/bitcoingui.h \\\n     src/allocators.h \\\n     src/ui_interface.h \\\n     src/qt/rpcconsole.h \\\n-    src/qt/verifymessagedialog.h\n+    src/qt/verifymessagedialog.h \\\n+    src/blockstore.h\n \n SOURCES += src/qt/bitcoin.cpp src/qt/bitcoingui.cpp \\\n     src/qt/transactiontablemodel.cpp \\\n@@ -218,7 +219,8 @@ SOURCES += src/qt/bitcoin.cpp src/qt/bitcoingui.cpp \\\n     src/qt/notificator.cpp \\\n     src/qt/qtipcserver.cpp \\\n     src/qt/rpcconsole.cpp \\\n-    src/qt/verifymessagedialog.cpp\n+    src/qt/verifymessagedialog.cpp \\\n+    src/blockstore.cpp\n \n RESOURCES += \\\n     src/qt/bitcoin.qrc"
      },
      {
        "sha": "98e1e80f09f3bacf58bec3a20370664930c30a8d",
        "filename": "src/bitcoinrpc.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 36,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/000f04150d61b405b62299a74a53c7a4ba8637ad/src/bitcoinrpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/000f04150d61b405b62299a74a53c7a4ba8637ad/src/bitcoinrpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.cpp?ref=000f04150d61b405b62299a74a53c7a4ba8637ad",
        "patch": "@@ -62,10 +62,10 @@ double GetDifficulty(const CBlockIndex* blockindex = NULL)\n     // minimum difficulty = 1.0.\n     if (blockindex == NULL)\n     {\n-        if (pindexBest == NULL)\n+        if (pblockstore->GetBestBlockIndex() == NULL)\n             return 1.0;\n         else\n-            blockindex = pindexBest;\n+            blockindex = pblockstore->GetBestBlockIndex();\n     }\n \n     int nShift = (blockindex->nBits >> 24) & 0xff;\n@@ -165,7 +165,7 @@ ScriptSigToJSON(const CTxIn& txin, Object& out)\n \n     CTransaction txprev;\n     uint256 hashTxprevBlock;\n-    if (!GetTransaction(txin.prevout.hash, txprev, hashTxprevBlock))\n+    if (!pblockstore->GetTransaction(txin.prevout.hash, txprev, hashTxprevBlock))\n         return;\n \n     txnouttype type;\n@@ -435,7 +435,7 @@ Value getblockcount(const Array& params, bool fHelp)\n             \"getblockcount\\n\"\n             \"Returns the number of blocks in the longest block chain.\");\n \n-    return nBestHeight;\n+    return pblockstore->GetBestBlockIndex()->nHeight;\n }\n \n \n@@ -447,7 +447,7 @@ Value getblocknumber(const Array& params, bool fHelp)\n             \"getblocknumber\\n\"\n             \"Deprecated.  Use getblockcount.\");\n \n-    return nBestHeight;\n+    return pblockstore->GetBestBlockIndex()->nHeight;\n }\n \n \n@@ -535,7 +535,7 @@ Value getinfo(const Array& params, bool fHelp)\n     obj.push_back(Pair(\"protocolversion\",(int)PROTOCOL_VERSION));\n     obj.push_back(Pair(\"walletversion\", pwalletMain->GetVersion()));\n     obj.push_back(Pair(\"balance\",       ValueFromAmount(pwalletMain->GetBalance())));\n-    obj.push_back(Pair(\"blocks\",        (int)nBestHeight));\n+    obj.push_back(Pair(\"blocks\",        (int)pblockstore->GetBestBlockIndex()->nHeight));\n     obj.push_back(Pair(\"connections\",   (int)vNodes.size()));\n     obj.push_back(Pair(\"proxy\",         (fUseProxy ? addrProxy.ToStringIPPort() : string())));\n     obj.push_back(Pair(\"difficulty\",    (double)GetDifficulty()));\n@@ -558,7 +558,7 @@ Value getmininginfo(const Array& params, bool fHelp)\n             \"Returns an object containing mining-related information.\");\n \n     Object obj;\n-    obj.push_back(Pair(\"blocks\",        (int)nBestHeight));\n+    obj.push_back(Pair(\"blocks\",        (int)pblockstore->GetBestBlockIndex()->nHeight));\n     obj.push_back(Pair(\"currentblocksize\",(uint64_t)nLastBlockSize));\n     obj.push_back(Pair(\"currentblocktx\",(uint64_t)nLastBlockTx));\n     obj.push_back(Pair(\"difficulty\",    (double)GetDifficulty()));\n@@ -1606,7 +1606,7 @@ Value listsinceblock(const Array& params, bool fHelp)\n             \"listsinceblock [blockhash] [target-confirmations]\\n\"\n             \"Get all transactions in blocks since block [blockhash], or all transactions if omitted\");\n \n-    CBlockIndex *pindex = NULL;\n+    const CBlockIndex *pindex = NULL;\n     int target_confirms = 1;\n \n     if (params.size() > 0)\n@@ -1625,7 +1625,7 @@ Value listsinceblock(const Array& params, bool fHelp)\n             throw JSONRPCError(-8, \"Invalid parameter\");\n     }\n \n-    int depth = pindex ? (1 + nBestHeight - pindex->nHeight) : -1;\n+    int depth = pindex ? (1 + pblockstore->GetBestBlockIndex()->nHeight - pindex->nHeight) : -1;\n \n     Array transactions;\n \n@@ -1641,14 +1641,14 @@ Value listsinceblock(const Array& params, bool fHelp)\n \n     if (target_confirms == 1)\n     {\n-        lastblock = hashBestChain;\n+        lastblock = *(pblockstore->GetBestBlockIndex()->phashBlock);\n     }\n     else\n     {\n-        int target_height = pindexBest->nHeight + 1 - target_confirms;\n+        int target_height = pblockstore->GetBestBlockIndex()->nHeight + 1 - target_confirms;\n \n-        CBlockIndex *block;\n-        for (block = pindexBest;\n+        const CBlockIndex *block;\n+        for (block = pblockstore->GetBestBlockIndex();\n              block && block->nHeight > target_height;\n              block = block->pprev)  { }\n \n@@ -1690,7 +1690,7 @@ AnyTxToJSON(const uint256 hash, const CTransaction* ptx, Object& entry, const Ob\n     {\n         CTransaction tx;\n         uint256 hashBlock = 0;\n-        if ((!ptx) && GetTransaction(hash, tx, hashBlock))\n+        if ((!ptx) && pblockstore->GetTransaction(hash, tx, hashBlock))\n             ptx = &tx;\n         if (ptx)\n         {\n@@ -1701,13 +1701,12 @@ AnyTxToJSON(const uint256 hash, const CTransaction* ptx, Object& entry, const Ob\n             else\n             {\n                 entry.push_back(Pair(\"blockhash\", hashBlock.GetHex()));\n-                map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n-                if (mi != mapBlockIndex.end() && (*mi).second)\n+                const CBlockIndex* pindex = pblockstore->GetBlockIndex(hashBlock);\n+                if (pindex != NULL)\n                 {\n-                    CBlockIndex* pindex = (*mi).second;\n                     if (pindex->IsInMainChain())\n                     {\n-                        entry.push_back(Pair(\"confirmations\", 1 + nBestHeight - pindex->nHeight));\n+                        entry.push_back(Pair(\"confirmations\", 1 + pblockstore->GetBestBlockIndex()->nHeight - pindex->nHeight));\n                         entry.push_back(Pair(\"time\", (boost::int64_t)pindex->nTime));\n                     }\n                     else\n@@ -2019,9 +2018,12 @@ Value getwork(const Array& params, bool fHelp)\n     if (vNodes.empty())\n         throw JSONRPCError(-9, \"Bitcoin is not connected!\");\n \n-    if (IsInitialBlockDownload())\n+    if (pblockstore->IsInitialBlockDownload())\n         throw JSONRPCError(-10, \"Bitcoin is downloading blocks...\");\n \n+    if (!pblockstore->HasFullBlocks())\n+        throw JSONRPCError(-18, \"Bitcoin does not have full blocks for transaction verification...\");\n+\n     typedef map<uint256, pair<CBlock*, CScript> > mapNewBlock_t;\n     static mapNewBlock_t mapNewBlock;    // FIXME: thread safety\n     static vector<CBlock*> vNewBlock;\n@@ -2031,13 +2033,13 @@ Value getwork(const Array& params, bool fHelp)\n     {\n         // Update block\n         static unsigned int nTransactionsUpdatedLast;\n-        static CBlockIndex* pindexPrev;\n+        static const CBlockIndex* pindexPrev;\n         static int64 nStart;\n         static CBlock* pblock;\n-        if (pindexPrev != pindexBest ||\n+        if (pindexPrev != pblockstore->GetBestBlockIndex() ||\n             (nTransactionsUpdated != nTransactionsUpdatedLast && GetTime() - nStart > 60))\n         {\n-            if (pindexPrev != pindexBest)\n+            if (pindexPrev != pblockstore->GetBestBlockIndex())\n             {\n                 // Deallocate old blocks since they're obsolete now\n                 mapNewBlock.clear();\n@@ -2046,7 +2048,7 @@ Value getwork(const Array& params, bool fHelp)\n                 vNewBlock.clear();\n             }\n             nTransactionsUpdatedLast = nTransactionsUpdated;\n-            pindexPrev = pindexBest;\n+            pindexPrev = pblockstore->GetBestBlockIndex();\n             nStart = GetTime();\n \n             // Create new block\n@@ -2126,26 +2128,29 @@ Value getmemorypool(const Array& params, bool fHelp)\n             \"  \\\"bits\\\" : compressed target of next block\\n\"\n             \"If [data] is specified, tries to solve the block and returns true if it was successful.\");\n \n+    if (!pblockstore->HasFullBlocks())\n+        throw JSONRPCError(-18, \"Bitcoin does not have full blocks for transaction verification...\");\n+\n     if (params.size() == 0)\n     {\n         if (vNodes.empty())\n             throw JSONRPCError(-9, \"Bitcoin is not connected!\");\n \n-        if (IsInitialBlockDownload())\n+        if (pblockstore->IsInitialBlockDownload())\n             throw JSONRPCError(-10, \"Bitcoin is downloading blocks...\");\n \n         static CReserveKey reservekey(pwalletMain);\n \n         // Update block\n         static unsigned int nTransactionsUpdatedLast;\n-        static CBlockIndex* pindexPrev;\n+        static const CBlockIndex* pindexPrev;\n         static int64 nStart;\n         static CBlock* pblock;\n-        if (pindexPrev != pindexBest ||\n+        if (pindexPrev != pblockstore->GetBestBlockIndex() ||\n             (nTransactionsUpdated != nTransactionsUpdatedLast && GetTime() - nStart > 5))\n         {\n             nTransactionsUpdatedLast = nTransactionsUpdated;\n-            pindexPrev = pindexBest;\n+            pindexPrev = pblockstore->GetBestBlockIndex();\n             nStart = GetTime();\n \n             // Create new block\n@@ -2188,10 +2193,10 @@ Value getmemorypool(const Array& params, bool fHelp)\n     {\n         // Parse parameters\n         CDataStream ssBlock(ParseHex(params[0].get_str()), SER_NETWORK, PROTOCOL_VERSION);\n-        CBlock pblock;\n-        ssBlock >> pblock;\n+        CBlock block;\n+        ssBlock >> block;\n \n-        return ProcessBlock(NULL, &pblock);\n+        return pblockstore->EmitBlock(block);\n     }\n }\n \n@@ -2203,11 +2208,11 @@ Value getblockhash(const Array& params, bool fHelp)\n             \"Returns hash of block in best-block-chain at <index>.\");\n \n     int nHeight = params[0].get_int();\n-    if (nHeight < 0 || nHeight > nBestHeight)\n+    if (nHeight < 0 || nHeight > pblockstore->GetBestBlockIndex()->nHeight)\n         throw runtime_error(\"Block number out of range.\");\n \n     CBlock block;\n-    CBlockIndex* pblockindex = mapBlockIndex[hashBestChain];\n+    const CBlockIndex* pblockindex = pblockstore->GetBestBlockIndex();\n     while (pblockindex->nHeight > nHeight)\n         pblockindex = pblockindex->pprev;\n     return pblockindex->phashBlock->GetHex();\n@@ -2223,11 +2228,11 @@ Value getblock(const Array& params, bool fHelp)\n     std::string strHash = params[0].get_str();\n     uint256 hash(strHash);\n \n-    if (mapBlockIndex.count(hash) == 0)\n+    CBlock block;\n+    const CBlockIndex* pblockindex = pblockstore->GetBlockIndex(hash);\n+    if (!pblockindex)\n         throw JSONRPCError(-5, \"Block not found\");\n \n-    CBlock block;\n-    CBlockIndex* pblockindex = mapBlockIndex[hash];\n     block.ReadFromDisk(pblockindex, true);\n \n     return blockToJSON(block, pblockindex,\n@@ -2841,7 +2846,7 @@ json_spirit::Value CRPCTable::execute(const std::string &strMethod, const json_s\n         // Execute\n         Value result;\n         {\n-            LOCK2(cs_main, pwalletMain->cs_wallet);\n+            LOCK(pwalletMain->cs_wallet);\n             result = pcmd->actor(params, false);\n         }\n         return result;"
      },
      {
        "sha": "793708c78fde46dcd01419fb0411befd59a53cd6",
        "filename": "src/blockstore.cpp",
        "status": "added",
        "additions": 94,
        "deletions": 0,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/000f04150d61b405b62299a74a53c7a4ba8637ad/src/blockstore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/000f04150d61b405b62299a74a53c7a4ba8637ad/src/blockstore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockstore.cpp?ref=000f04150d61b405b62299a74a53c7a4ba8637ad",
        "patch": "@@ -0,0 +1,94 @@\n+#include \"blockstore.h\"\n+#include \"main.h\"\n+\n+void ProcessCallbacks(void* parg)\n+{\n+    ((CBlockStore*)parg)->ProcessCallbacks();\n+}\n+\n+void CBlockStore::ProcessCallbacks()\n+{\n+    loop\n+    {\n+        bool fHaveDoneSomething = false;\n+\n+        std::pair<uint256, uint256> hashParams;\n+        {\n+            LOCK(cs_callbacks);\n+            if (!queueAskForBlocksCallbacks.empty())\n+            {\n+                hashParams = queueAskForBlocksCallbacks.front();\n+                queueAskForBlocksCallbacks.pop();\n+                fHaveDoneSomething = true;\n+            }\n+        }\n+        if (fHaveDoneSomething)\n+            sigAskForBlocks(hashParams.first, hashParams.second);\n+\n+        uint256 hashRelayed;\n+        bool fRelayedToBeCalled = false;\n+        {\n+            LOCK(cs_callbacks);\n+            if (!queueRelayedCallbacks.empty())\n+            {\n+                hashRelayed = queueRelayedCallbacks.front();\n+                queueRelayedCallbacks.pop();\n+                fHaveDoneSomething = fRelayedToBeCalled = true;\n+            }\n+        }\n+        if (fRelayedToBeCalled)\n+            sigRelayed(hashRelayed);\n+\n+        uint256 hashTransactionReplaced;\n+        bool fTransactionReplacedToBeCalled = false;\n+        {\n+            LOCK(cs_callbacks);\n+            if (!queueTransactionReplacedCallbacks.empty())\n+            {\n+                hashTransactionReplaced = queueTransactionReplacedCallbacks.front();\n+                queueTransactionReplacedCallbacks.pop();\n+                fHaveDoneSomething = fTransactionReplacedToBeCalled = true;\n+            }\n+        }\n+        if (fTransactionReplacedToBeCalled)\n+            sigRelayed(hashTransactionReplaced);\n+\n+        CBlock* pBlockToProcess = NULL;\n+        {\n+            LOCK(cs_callbacks);\n+            if (!queueCommitBlockCallbacks.empty())\n+            {\n+                pBlockToProcess = queueCommitBlockCallbacks.front();\n+                queueCommitBlockCallbacks.pop();\n+                fHaveDoneSomething = true;\n+            }\n+        }\n+        if (pBlockToProcess)\n+        {\n+            sigCommitBlock(*pBlockToProcess);\n+            delete pBlockToProcess;\n+        }\n+\n+        CTransaction* pTxToProcess = NULL;\n+        {\n+            LOCK(cs_callbacks);\n+            if (!queueCommitTransactionToMemoryPoolCallbacks.empty())\n+            {\n+                pTxToProcess = queueCommitTransactionToMemoryPoolCallbacks.front();\n+                queueCommitTransactionToMemoryPoolCallbacks.pop();\n+                fHaveDoneSomething = true;\n+            }\n+        }\n+        if (pTxToProcess)\n+        {\n+            sigCommitTransactionToMemoryPool(*pTxToProcess);\n+            delete pTxToProcess;\n+        }\n+\n+        if (!fHaveDoneSomething)\n+            Sleep(100);\n+\n+        if (fShutdown)\n+            return;\n+    }\n+}"
      },
      {
        "sha": "3b0ebd1d4193e76cd29d19f0c97b87f76598b585",
        "filename": "src/blockstore.h",
        "status": "added",
        "additions": 175,
        "deletions": 0,
        "changes": 175,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/000f04150d61b405b62299a74a53c7a4ba8637ad/src/blockstore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/000f04150d61b405b62299a74a53c7a4ba8637ad/src/blockstore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockstore.h?ref=000f04150d61b405b62299a74a53c7a4ba8637ad",
        "patch": "@@ -0,0 +1,175 @@\n+#ifndef BITCOIN_BLOCKSTORE_H\n+#define BITCOIN_BLOCKSTORE_H\n+\n+#include <boost/signals2/signal.hpp>\n+#include <queue>\n+\n+#include \"util.h\"\n+\n+\n+class CInv;\n+class CBlock;\n+class CBlockIndex;\n+class CBlockLocator;\n+class CTransaction;\n+class CAlert;\n+class CNode;\n+\n+// Combiners for boost::signal2\n+template<typename T>\n+struct anyTrue\n+{\n+    typedef T result_type;\n+\n+    template<typename InputIterator>\n+    T operator()(InputIterator first, InputIterator last) const\n+    {\n+        // If there are no slots to call, just return the\n+        // default-constructed value\n+        if (first == last) return T();\n+        T anyTrue = *first++;\n+        while (first != last)\n+        {\n+            if (*first)\n+            {\n+                anyTrue = *first;\n+                return anyTrue;\n+            }\n+            ++first;\n+        }\n+        return anyTrue;\n+    }\n+};\n+\n+// This API is considered stable ONLY for existing bitcoin codebases,\n+// any futher uses are not yet supported.\n+// This API is subject to change dramatically overnight, do not\n+// depend on it for anything.\n+\n+class CBlockStore\n+{\n+private:\n+    CCriticalSection cs_signals;\n+\n+    boost::signals2::signal<void (const CBlock&)> sigCommitBlock;\n+\n+    boost::signals2::signal<void (const CTransaction&)> sigCommitTransactionToMemoryPool;\n+    boost::signals2::signal<void (const uint256)> sigTransactionReplaced;\n+\n+    boost::signals2::signal<void (const CAlert&)> sigCommitAlert;\n+\n+    boost::signals2::signal<void (const uint256, const uint256)> sigAskForBlocks;\n+    boost::signals2::signal<void (const uint256)> sigRelayed;\n+    boost::signals2::signal<bool (const CTransaction&), anyTrue<bool> > sigIsTransactionFromMe;\n+    boost::signals2::signal<bool (const uint256), anyTrue<bool> > sigIsTransactionFromMeByHash;\n+\n+    CCriticalSection cs_callbacks;\n+    std::queue<CBlock*> queueCommitBlockCallbacks;\n+    std::queue<std::pair<uint256, uint256> > queueAskForBlocksCallbacks;\n+    std::queue<uint256> queueRelayedCallbacks;\n+    std::queue<CTransaction*> queueCommitTransactionToMemoryPoolCallbacks;\n+    std::queue<uint256> queueTransactionReplacedCallbacks;\n+public:\n+//Util methods\n+    // Loops to process callbacks (call ProcessCallbacks(void* parg) with a CBlockStore as parg to launch in a thread)\n+    void ProcessCallbacks();\n+\n+//Register methods\n+    // Register a handler (of the form void f(const CBlock& block)) to be called after every block commit\n+    void RegisterCommitBlock(boost::function<void (const CBlock&)> func) { sigCommitBlock.connect(func); }\n+\n+    // Register a handler (of the form void f(const CTransaction& block)) to be called after every transaction commit to memory pool\n+    void RegisterCommitTransactionToMemoryPool(boost::function<void (const CTransaction&)> func) { sigCommitTransactionToMemoryPool.connect(func); }\n+\n+    // Register a handler (of the form void f(const uint256)) to be called when a transaciton is replaced\n+    void RegisterTransactionReplaced(boost::function<void (const uint256)> func) {sigTransactionReplaced.connect(func); }\n+\n+    //void RegisterCommitAlert(boost::function<void (const CAlert*)> func) { sigCommitAlert.connect(func); }\n+\n+    // Register a handler (of the form void f(const uint256 hashEnd, const uint256 hashOriginator)) to be called when we need to ask for blocks up to hashEnd\n+    //   Should always start from the best block (GetBestBlockIndex())\n+    //   The receiver should check if it has a peer which is known to have a block with hash hashOriginator and if it does, it should\n+    //    send the block query to that node.\n+    void RegisterAskForBlocks(boost::function<void (const uint256, const uint256)> func) { sigAskForBlocks.connect(func); }\n+\n+    // Register a handler (of the form void f(const uint256 hash)) to be called when a node announces or requests an Inv with hash hash\n+    //   Ideal for wallets which want to keep track of whether their transactions are being relayed to other nodes\n+    void RegisterRelayedNotification(boost::function<void (const uint256)> func) { sigRelayed.connect(func); }\n+\n+    // Register a handler (of the form bool f(const CTransaction& tx)) which will return true if a given transaction is from a locally attached user\n+    //   This is used to determine how transactions should be handled in the free transaction and transaction relay logic \n+    void RegisterIsTransactionFromMe(boost::function<bool (const CTransaction&)> func) { sigIsTransactionFromMe.connect(func); }\n+\n+    // Register a handler (of the form bool f(const uint256)) which will return true if a transaction with the given hash is from a locally attached user\n+    //   This is used to determine how transactions should be handled in the free transaction and transaction relay logic \n+    void RegisterIsTransactionFromMeByHash(boost::function<bool (const uint256)> func) { sigIsTransactionFromMeByHash.connect(func); }\n+\n+//Blockchain access methods\n+    // Emit methods will verify the object, commit it to memory/disk and then place it in queue to\n+    //   be handled by listeners\n+\n+    bool EmitBlock(CBlock& block);\n+    // Do not call EmitTransaction except for loose transactions (ie transactions not in a block)\n+    bool EmitTransaction(CTransaction& transaction);\n+    bool EmitAlert(CAlert& palert);\n+\n+    // Returns the CBlockIndex that points to the block with specified hash or NULL\n+    const CBlockIndex* GetBlockIndex(const uint256 nBlockHash);\n+\n+    // Returns the CBlockIndex that points to the block at the tip of the longest chain we have\n+    const CBlockIndex* GetBestBlockIndex() const;\n+\n+    // Returns the CBlockIndex that points to the genesis block\n+    const CBlockIndex* GetGenesisBlockIndex() const;\n+\n+    // Returns true if an inv should be requested or false otherwise\n+    bool NeedInv(const CInv* pinv);\n+\n+    // Returns false if we are an SPV node, ie we can't provide full blocks when requested\n+    inline bool HasFullBlocks() { return true; }\n+\n+    bool IsInitialBlockDownload();\n+\n+    // Return transaction with hash in tx, and if it was found inside a block, its hash is placed in hashBlock\n+    bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock);\n+\n+//Connected wallet/etc access methods\n+\n+    // Ask that any listeners who have access to ask other nodes for blocks\n+    // (ie net) ask for all blocks between GetBestBlockIndex() and hashEnd\n+    // If hashOriginator is specified, then a node which is known to have a block\n+    //   with that hash will be the one to get the block request, unless no connected\n+    //   nodes are known to have this block, in which case a random one will be queried.\n+    void AskForBlocks(const uint256 hashEnd, const uint256 hashOriginator)\n+    {\n+        LOCK(cs_callbacks);\n+        queueAskForBlocksCallbacks.push(std::make_pair(hashEnd, hashOriginator));\n+    }\n+\n+    // Relay all alerts we have to pnode\n+    void RelayAlerts(CNode* pnode);\n+\n+    // Used to indicate a transaction is being relayed/has been announced by a peer\n+    //   (used eg for wallets counting relays of their txes)\n+    void Relayed(const uint256 hash)\n+    {\n+        LOCK(cs_callbacks);\n+        queueRelayedCallbacks.push(hash);\n+    }\n+\n+    // Returns true if a given transaction is from a connected wallet\n+    bool IsTransactionFromMe(const CTransaction& tx) { return sigIsTransactionFromMe(tx); }\n+    bool IsTransactionFromMe(const uint256 hash) { return sigIsTransactionFromMeByHash(hash); }\n+\n+    void TransactionReplaced(const uint256 hash)\n+    {\n+        LOCK(cs_callbacks);\n+        queueTransactionReplacedCallbacks.push(hash);\n+    }\n+};\n+\n+extern CBlockStore* pblockstore;\n+\n+void ProcessCallbacks(void* parg);\n+\n+#endif"
      },
      {
        "sha": "49d828ef573faf50688e061a938e333cde336599",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 111,
        "deletions": 110,
        "changes": 221,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/000f04150d61b405b62299a74a53c7a4ba8637ad/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/000f04150d61b405b62299a74a53c7a4ba8637ad/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=000f04150d61b405b62299a74a53c7a4ba8637ad",
        "patch": "@@ -168,7 +168,7 @@ void CDB::Close()\n         nMinutes = 2;\n     if (strFile == \"blkindex.dat\")\n         nMinutes = 2;\n-    if (strFile == \"blkindex.dat\" && IsInitialBlockDownload())\n+    if (strFile == \"blkindex.dat\" && pblockstore->IsInitialBlockDownload())\n         nMinutes = 5;\n \n     dbenv.txn_checkpoint(nMinutes ? GetArg(\"-dblogsize\", 100)*1024 : 0, nMinutes, 0);\n@@ -343,20 +343,20 @@ void DBFlush(bool fShutdown)\n \n bool CTxDB::ReadTxIndex(uint256 hash, CTxIndex& txindex)\n {\n-    assert(!fClient);\n+    assert(pblockstore->HasFullBlocks());\n     txindex.SetNull();\n     return Read(make_pair(string(\"tx\"), hash), txindex);\n }\n \n bool CTxDB::UpdateTxIndex(uint256 hash, const CTxIndex& txindex)\n {\n-    assert(!fClient);\n+    assert(pblockstore->HasFullBlocks());\n     return Write(make_pair(string(\"tx\"), hash), txindex);\n }\n \n bool CTxDB::AddTxIndex(const CTransaction& tx, const CDiskTxPos& pos, int nHeight)\n {\n-    assert(!fClient);\n+    assert(pblockstore->HasFullBlocks());\n \n     // Add to tx index\n     uint256 hash = tx.GetHash();\n@@ -366,21 +366,21 @@ bool CTxDB::AddTxIndex(const CTransaction& tx, const CDiskTxPos& pos, int nHeigh\n \n bool CTxDB::EraseTxIndex(const CTransaction& tx)\n {\n-    assert(!fClient);\n+    assert(pblockstore->HasFullBlocks());\n     uint256 hash = tx.GetHash();\n \n     return Erase(make_pair(string(\"tx\"), hash));\n }\n \n bool CTxDB::ContainsTx(uint256 hash)\n {\n-    assert(!fClient);\n+    assert(pblockstore->HasFullBlocks());\n     return Exists(make_pair(string(\"tx\"), hash));\n }\n \n bool CTxDB::ReadOwnerTxes(uint160 hash160, int nMinHeight, vector<CTransaction>& vtx)\n {\n-    assert(!fClient);\n+    assert(pblockstore->HasFullBlocks());\n     vtx.clear();\n \n     // Get cursor\n@@ -434,7 +434,7 @@ bool CTxDB::ReadOwnerTxes(uint160 hash160, int nMinHeight, vector<CTransaction>&\n \n bool CTxDB::ReadDiskTx(uint256 hash, CTransaction& tx, CTxIndex& txindex)\n {\n-    assert(!fClient);\n+    assert(pblockstore->HasFullBlocks());\n     tx.SetNull();\n     if (!ReadTxIndex(hash, txindex))\n         return false;\n@@ -488,7 +488,7 @@ bool CTxDB::WriteBestInvalidWork(CBigNum bnBestInvalidWork)\n     return Write(string(\"bnBestInvalidWork\"), bnBestInvalidWork);\n }\n \n-CBlockIndex static * InsertBlockIndex(uint256 hash)\n+CBlockIndex static * InsertBlockIndex(std::map<uint256, CBlockIndex*>& mapBlockIndex, uint256 hash)\n {\n     if (hash == 0)\n         return NULL;\n@@ -508,7 +508,7 @@ CBlockIndex static * InsertBlockIndex(uint256 hash)\n     return pindexNew;\n }\n \n-bool CTxDB::LoadBlockIndex()\n+bool CTxDB::LoadBlockIndex(std::map<uint256, CBlockIndex*>& mapBlockIndex, CBlockIndex* &pindexGenesisBlock, CBlockIndex* &pindexBest, uint256& hashBestChain, CBigNum& bnBestInvalidWork)\n {\n     // Get database cursor\n     Dbc* pcursor = GetCursor();\n@@ -540,9 +540,9 @@ bool CTxDB::LoadBlockIndex()\n             ssValue >> diskindex;\n \n             // Construct block index object\n-            CBlockIndex* pindexNew = InsertBlockIndex(diskindex.GetBlockHash());\n-            pindexNew->pprev          = InsertBlockIndex(diskindex.hashPrev);\n-            pindexNew->pnext          = InsertBlockIndex(diskindex.hashNext);\n+            CBlockIndex* pindexNew = InsertBlockIndex(mapBlockIndex, diskindex.GetBlockHash());\n+            pindexNew->pprev          = InsertBlockIndex(mapBlockIndex, diskindex.hashPrev);\n+            pindexNew->pnext          = InsertBlockIndex(mapBlockIndex, diskindex.hashNext);\n             pindexNew->nFile          = diskindex.nFile;\n             pindexNew->nBlockPos      = diskindex.nBlockPos;\n             pindexNew->nHeight        = diskindex.nHeight;\n@@ -594,136 +594,137 @@ bool CTxDB::LoadBlockIndex()\n     if (!mapBlockIndex.count(hashBestChain))\n         return error(\"CTxDB::LoadBlockIndex() : hashBestChain not found in the block index\");\n     pindexBest = mapBlockIndex[hashBestChain];\n-    nBestHeight = pindexBest->nHeight;\n-    bnBestChainWork = pindexBest->bnChainWork;\n-    printf(\"LoadBlockIndex(): hashBestChain=%s  height=%d\\n\", hashBestChain.ToString().substr(0,20).c_str(), nBestHeight);\n+    printf(\"LoadBlockIndex(): hashBestChain=%s  height=%d\\n\", hashBestChain.ToString().substr(0,20).c_str(), pindexBest->nHeight);\n \n     // Load bnBestInvalidWork, OK if it doesn't exist\n     ReadBestInvalidWork(bnBestInvalidWork);\n \n     // Verify blocks in the best chain\n-    int nCheckLevel = GetArg(\"-checklevel\", 1);\n-    int nCheckDepth = GetArg( \"-checkblocks\", 2500);\n-    if (nCheckDepth == 0)\n-        nCheckDepth = 1000000000; // suffices until the year 19000\n-    if (nCheckDepth > nBestHeight)\n-        nCheckDepth = nBestHeight;\n-    printf(\"Verifying last %i blocks at level %i\\n\", nCheckDepth, nCheckLevel);\n-    CBlockIndex* pindexFork = NULL;\n-    map<pair<unsigned int, unsigned int>, CBlockIndex*> mapBlockPos;\n-    for (CBlockIndex* pindex = pindexBest; pindex && pindex->pprev; pindex = pindex->pprev)\n+    if (pblockstore->HasFullBlocks())\n     {\n-        if (fRequestShutdown || pindex->nHeight < nBestHeight-nCheckDepth)\n-            break;\n-        CBlock block;\n-        if (!block.ReadFromDisk(pindex))\n-            return error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n-        // check level 1: verify block validity\n-        if (nCheckLevel>0 && !block.CheckBlock())\n-        {\n-            printf(\"LoadBlockIndex() : *** found bad block at %d, hash=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n-            pindexFork = pindex->pprev;\n-        }\n-        // check level 2: verify transaction index validity\n-        if (nCheckLevel>1)\n+        int nCheckLevel = GetArg(\"-checklevel\", 1);\n+        int nCheckDepth = GetArg( \"-checkblocks\", 2500);\n+        if (nCheckDepth == 0)\n+            nCheckDepth = 1000000000; // suffices until the year 19000\n+        if (nCheckDepth > pblockstore->GetBestBlockIndex()->nHeight)\n+            nCheckDepth = pblockstore->GetBestBlockIndex()->nHeight;\n+        printf(\"Verifying last %i blocks at level %i\\n\", nCheckDepth, nCheckLevel);\n+        CBlockIndex* pindexFork = NULL;\n+        map<pair<unsigned int, unsigned int>, CBlockIndex*> mapBlockPos;\n+        for (CBlockIndex* pindex = pindexBest; pindex && pindex->pprev; pindex = pindex->pprev)\n         {\n-            pair<unsigned int, unsigned int> pos = make_pair(pindex->nFile, pindex->nBlockPos);\n-            mapBlockPos[pos] = pindex;\n-            BOOST_FOREACH(const CTransaction &tx, block.vtx)\n+            if (fRequestShutdown || pindex->nHeight < pblockstore->GetBestBlockIndex()->nHeight - nCheckDepth)\n+                break;\n+            CBlock block;\n+            if (!block.ReadFromDisk(pindex))\n+                return error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n+            // check level 1: verify block validity\n+            if (nCheckLevel>0 && !block.CheckBlock())\n+            {\n+                printf(\"LoadBlockIndex() : *** found bad block at %d, hash=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n+                pindexFork = pindex->pprev;\n+            }\n+            // check level 2: verify transaction index validity\n+            if (nCheckLevel>1)\n             {\n-                uint256 hashTx = tx.GetHash();\n-                CTxIndex txindex;\n-                if (ReadTxIndex(hashTx, txindex))\n+                pair<unsigned int, unsigned int> pos = make_pair(pindex->nFile, pindex->nBlockPos);\n+                mapBlockPos[pos] = pindex;\n+                BOOST_FOREACH(const CTransaction &tx, block.vtx)\n                 {\n-                    // check level 3: checker transaction hashes\n-                    if (nCheckLevel>2 || pindex->nFile != txindex.pos.nFile || pindex->nBlockPos != txindex.pos.nBlockPos)\n+                    uint256 hashTx = tx.GetHash();\n+                    CTxIndex txindex;\n+                    if (ReadTxIndex(hashTx, txindex))\n                     {\n-                        // either an error or a duplicate transaction\n-                        CTransaction txFound;\n-                        if (!txFound.ReadFromDisk(txindex.pos))\n+                        // check level 3: checker transaction hashes\n+                        if (nCheckLevel>2 || pindex->nFile != txindex.pos.nFile || pindex->nBlockPos != txindex.pos.nBlockPos)\n                         {\n-                            printf(\"LoadBlockIndex() : *** cannot read mislocated transaction %s\\n\", hashTx.ToString().c_str());\n-                            pindexFork = pindex->pprev;\n-                        }\n-                        else\n-                            if (txFound.GetHash() != hashTx) // not a duplicate tx\n+                            // either an error or a duplicate transaction\n+                            CTransaction txFound;\n+                            if (!txFound.ReadFromDisk(txindex.pos))\n                             {\n-                                printf(\"LoadBlockIndex(): *** invalid tx position for %s\\n\", hashTx.ToString().c_str());\n+                                printf(\"LoadBlockIndex() : *** cannot read mislocated transaction %s\\n\", hashTx.ToString().c_str());\n                                 pindexFork = pindex->pprev;\n                             }\n-                    }\n-                    // check level 4: check whether spent txouts were spent within the main chain\n-                    unsigned int nOutput = 0;\n-                    if (nCheckLevel>3)\n-                    {\n-                        BOOST_FOREACH(const CDiskTxPos &txpos, txindex.vSpent)\n-                        {\n-                            if (!txpos.IsNull())\n-                            {\n-                                pair<unsigned int, unsigned int> posFind = make_pair(txpos.nFile, txpos.nBlockPos);\n-                                if (!mapBlockPos.count(posFind))\n+                            else\n+                                if (txFound.GetHash() != hashTx) // not a duplicate tx\n                                 {\n-                                    printf(\"LoadBlockIndex(): *** found bad spend at %d, hashBlock=%s, hashTx=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str(), hashTx.ToString().c_str());\n+                                    printf(\"LoadBlockIndex(): *** invalid tx position for %s\\n\", hashTx.ToString().c_str());\n                                     pindexFork = pindex->pprev;\n                                 }\n-                                // check level 6: check whether spent txouts were spent by a valid transaction that consume them\n-                                if (nCheckLevel>5)\n+                        }\n+                        // check level 4: check whether spent txouts were spent within the main chain\n+                        unsigned int nOutput = 0;\n+                        if (nCheckLevel>3)\n+                        {\n+                            BOOST_FOREACH(const CDiskTxPos &txpos, txindex.vSpent)\n+                            {\n+                                if (!txpos.IsNull())\n                                 {\n-                                    CTransaction txSpend;\n-                                    if (!txSpend.ReadFromDisk(txpos))\n+                                    pair<unsigned int, unsigned int> posFind = make_pair(txpos.nFile, txpos.nBlockPos);\n+                                    if (!mapBlockPos.count(posFind))\n                                     {\n-                                        printf(\"LoadBlockIndex(): *** cannot read spending transaction of %s:%i from disk\\n\", hashTx.ToString().c_str(), nOutput);\n+                                        printf(\"LoadBlockIndex(): *** found bad spend at %d, hashBlock=%s, hashTx=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str(), hashTx.ToString().c_str());\n                                         pindexFork = pindex->pprev;\n                                     }\n-                                    else if (!txSpend.CheckTransaction())\n+                                    // check level 6: check whether spent txouts were spent by a valid transaction that consume them\n+                                    if (nCheckLevel>5)\n                                     {\n-                                        printf(\"LoadBlockIndex(): *** spending transaction of %s:%i is invalid\\n\", hashTx.ToString().c_str(), nOutput);\n-                                        pindexFork = pindex->pprev;\n-                                    }\n-                                    else\n-                                    {\n-                                        bool fFound = false;\n-                                        BOOST_FOREACH(const CTxIn &txin, txSpend.vin)\n-                                            if (txin.prevout.hash == hashTx && txin.prevout.n == nOutput)\n-                                                fFound = true;\n-                                        if (!fFound)\n+                                        CTransaction txSpend;\n+                                        if (!txSpend.ReadFromDisk(txpos))\n+                                        {\n+                                            printf(\"LoadBlockIndex(): *** cannot read spending transaction of %s:%i from disk\\n\", hashTx.ToString().c_str(), nOutput);\n+                                            pindexFork = pindex->pprev;\n+                                        }\n+                                        else if (!txSpend.CheckTransaction())\n                                         {\n-                                            printf(\"LoadBlockIndex(): *** spending transaction of %s:%i does not spend it\\n\", hashTx.ToString().c_str(), nOutput);\n+                                            printf(\"LoadBlockIndex(): *** spending transaction of %s:%i is invalid\\n\", hashTx.ToString().c_str(), nOutput);\n                                             pindexFork = pindex->pprev;\n                                         }\n+                                        else\n+                                        {\n+                                            bool fFound = false;\n+                                            BOOST_FOREACH(const CTxIn &txin, txSpend.vin)\n+                                                if (txin.prevout.hash == hashTx && txin.prevout.n == nOutput)\n+                                                    fFound = true;\n+                                            if (!fFound)\n+                                            {\n+                                                printf(\"LoadBlockIndex(): *** spending transaction of %s:%i does not spend it\\n\", hashTx.ToString().c_str(), nOutput);\n+                                                pindexFork = pindex->pprev;\n+                                            }\n+                                        }\n                                     }\n                                 }\n+                                nOutput++;\n                             }\n-                            nOutput++;\n                         }\n                     }\n-                }\n-                // check level 5: check whether all prevouts are marked spent\n-                if (nCheckLevel>4)\n-                {\n-                     BOOST_FOREACH(const CTxIn &txin, tx.vin)\n-                     {\n-                          CTxIndex txindex;\n-                          if (ReadTxIndex(txin.prevout.hash, txindex))\n-                              if (txindex.vSpent.size()-1 < txin.prevout.n || txindex.vSpent[txin.prevout.n].IsNull())\n-                              {\n-                                  printf(\"LoadBlockIndex(): *** found unspent prevout %s:%i in %s\\n\", txin.prevout.hash.ToString().c_str(), txin.prevout.n, hashTx.ToString().c_str());\n-                                  pindexFork = pindex->pprev;\n-                              }\n-                     }\n+                    // check level 5: check whether all prevouts are marked spent\n+                    if (nCheckLevel>4)\n+                    {\n+                         BOOST_FOREACH(const CTxIn &txin, tx.vin)\n+                         {\n+                              CTxIndex txindex;\n+                              if (ReadTxIndex(txin.prevout.hash, txindex))\n+                                  if (txindex.vSpent.size()-1 < txin.prevout.n || txindex.vSpent[txin.prevout.n].IsNull())\n+                                  {\n+                                      printf(\"LoadBlockIndex(): *** found unspent prevout %s:%i in %s\\n\", txin.prevout.hash.ToString().c_str(), txin.prevout.n, hashTx.ToString().c_str());\n+                                      pindexFork = pindex->pprev;\n+                                  }\n+                         }\n+                    }\n                 }\n             }\n         }\n-    }\n-    if (pindexFork && !fRequestShutdown)\n-    {\n-        // Reorg back to the fork\n-        printf(\"LoadBlockIndex() : *** moving best chain pointer back to block %d\\n\", pindexFork->nHeight);\n-        CBlock block;\n-        if (!block.ReadFromDisk(pindexFork))\n-            return error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n-        CTxDB txdb;\n-        block.SetBestChain(txdb, pindexFork);\n+        if (pindexFork && !fRequestShutdown)\n+        {\n+            // Reorg back to the fork\n+            printf(\"LoadBlockIndex() : *** moving best chain pointer back to block %d\\n\", pindexFork->nHeight);\n+            CBlock block;\n+            if (!block.ReadFromDisk(pindexFork))\n+                return error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n+            CTxDB txdb;\n+            block.SetBestChain(txdb, pindexFork);\n+        }\n     }\n \n     return true;"
      },
      {
        "sha": "c2aed5cc734abd3cb6e7da568e575812d0a89031",
        "filename": "src/db.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/000f04150d61b405b62299a74a53c7a4ba8637ad/src/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/000f04150d61b405b62299a74a53c7a4ba8637ad/src/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.h?ref=000f04150d61b405b62299a74a53c7a4ba8637ad",
        "patch": "@@ -290,7 +290,7 @@ class CTxDB : public CDB\n     bool WriteHashBestChain(uint256 hashBestChain);\n     bool ReadBestInvalidWork(CBigNum& bnBestInvalidWork);\n     bool WriteBestInvalidWork(CBigNum bnBestInvalidWork);\n-    bool LoadBlockIndex();\n+    bool LoadBlockIndex(std::map<uint256, CBlockIndex*>& mapBlockIndex, CBlockIndex* &pindexGenesisBlock, CBlockIndex* &pindexBest, uint256& hashBestChain, CBigNum& bnBestInvalidWork);\n };\n \n "
      },
      {
        "sha": "7a6aee858b6d1bd20c0ac6095767cab028fbd1aa",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 11,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/000f04150d61b405b62299a74a53c7a4ba8637ad/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/000f04150d61b405b62299a74a53c7a4ba8637ad/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=000f04150d61b405b62299a74a53c7a4ba8637ad",
        "patch": "@@ -13,6 +13,7 @@\n #include <boost/filesystem/fstream.hpp>\n #include <boost/filesystem/convenience.hpp>\n #include <boost/interprocess/sync/file_lock.hpp>\n+#include <boost/algorithm/string/replace.hpp>\n \n #ifndef WIN32\n #include <signal.h>\n@@ -58,7 +59,6 @@ void Shutdown(void* parg)\n         StopNode();\n         DBFlush(true);\n         boost::filesystem::remove(GetPidFile());\n-        UnregisterWallet(pwalletMain);\n         delete pwalletMain;\n         CreateThread(ExitTimeout, NULL);\n         Sleep(50);\n@@ -85,6 +85,33 @@ void HandleSIGTERM(int)\n \n \n \n+//////////////////////////////////////////////////////////////////////////////\n+//\n+// Helper\n+//\n+static void runCommand(std::string strCommand)\n+{\n+    int nErr = ::system(strCommand.c_str());\n+    if (nErr)\n+        printf(\"runCommand error: system(%s) returned %d\\n\", strCommand.c_str(), nErr);\n+}\n+\n+void BlockNotifyCommitBlockHandler(const CBlock& block)\n+{\n+    std::string strCmd = GetArg(\"-blocknotify\", \"\");\n+\n+    if (!pblockstore->IsInitialBlockDownload() && !strCmd.empty())\n+    {\n+        boost::replace_all(strCmd, \"%s\", block.GetHash().GetHex());\n+        boost::thread t(runCommand, strCmd); // thread runs free\n+    }\n+}\n+\n+\n+\n+\n+\n+\n //////////////////////////////////////////////////////////////////////////////\n //\n // Start\n@@ -346,8 +373,7 @@ bool AppInit2()\n \n     if (GetBoolArg(\"-loadblockindextest\"))\n     {\n-        CTxDB txdb(\"r\");\n-        txdb.LoadBlockIndex();\n+        LoadBlockIndex();\n         PrintBlockTree();\n         return false;\n     }\n@@ -360,6 +386,13 @@ bool AppInit2()\n     if (!lock.try_lock())\n         return InitError(strprintf(_(\"Cannot obtain a lock on data directory %s.  Bitcoin is probably already running.\"), GetDataDir().string().c_str()));\n \n+    pblockstore = new CBlockStore();\n+    if (!CreateThread(ProcessCallbacks, pblockstore))\n+    {\n+        ThreadSafeMessageBox(_(\"Error: CreateThread(ProcessCallbacks) failed\"), \"Bitcoin\");\n+        return false;\n+    }\n+\n     std::ostringstream strErrors;\n     //\n     // Load data files\n@@ -455,22 +488,23 @@ bool AppInit2()\n     printf(\"%s\", strErrors.str().c_str());\n     printf(\" wallet      %15\"PRI64d\"ms\\n\", GetTimeMillis() - nStart);\n \n-    RegisterWallet(pwalletMain);\n+    pwalletMain->RegisterWithBlockStore(pblockstore);\n \n-    CBlockIndex *pindexRescan = pindexBest;\n+    const CBlockIndex *pindexRescan = pblockstore->GetBestBlockIndex();\n     if (GetBoolArg(\"-rescan\"))\n-        pindexRescan = pindexGenesisBlock;\n+        pindexRescan = pblockstore->GetGenesisBlockIndex();\n     else\n     {\n         CWalletDB walletdb(\"wallet.dat\");\n         CBlockLocator locator;\n         if (walletdb.ReadBestBlock(locator))\n             pindexRescan = locator.GetBlockIndex();\n     }\n-    if (pindexBest != pindexRescan)\n+    if (pblockstore->GetBestBlockIndex() != pindexRescan)\n     {\n+        assert(pblockstore->HasFullBlocks());\n         InitMessage(_(\"Rescanning...\"));\n-        printf(\"Rescanning last %i blocks (from block %i)...\\n\", pindexBest->nHeight - pindexRescan->nHeight, pindexRescan->nHeight);\n+        printf(\"Rescanning last %i blocks (from block %i)...\\n\", pblockstore->GetBestBlockIndex()->nHeight - pindexRescan->nHeight, pindexRescan->nHeight);\n         nStart = GetTimeMillis();\n         pwalletMain->ScanForWalletTransactions(pindexRescan, true);\n         printf(\" rescan      %15\"PRI64d\"ms\\n\", GetTimeMillis() - nStart);\n@@ -480,8 +514,8 @@ bool AppInit2()\n     printf(\"Done loading\\n\");\n \n     //// debug print\n-    printf(\"mapBlockIndex.size() = %d\\n\",   mapBlockIndex.size());\n-    printf(\"nBestHeight = %d\\n\",            nBestHeight);\n+    //printf(\"mapBlockIndex.size() = %d\\n\",   mapBlockIndex.size());\n+    printf(\"BestBlockHeight = %d\\n\",        pblockstore->GetBestBlockIndex()->nHeight);\n     printf(\"setKeyPool.size() = %d\\n\",      pwalletMain->setKeyPool.size());\n     printf(\"mapWallet.size() = %d\\n\",       pwalletMain->mapWallet.size());\n     printf(\"mapAddressBook.size() = %d\\n\",  pwalletMain->mapAddressBook.size());\n@@ -512,6 +546,7 @@ bool AppInit2()\n             nConnectTimeout = nNewTimeout;\n     }\n \n+    /* Go use blockexplorer or bitcointools\n     if (mapArgs.count(\"-printblock\"))\n     {\n         string strMatch = mapArgs[\"-printblock\"];\n@@ -533,7 +568,7 @@ bool AppInit2()\n         if (nFound == 0)\n             printf(\"No blocks matching %s were found\\n\", strMatch.c_str());\n         return false;\n-    }\n+    }*/\n \n     if (mapArgs.count(\"-proxy\"))\n     {\n@@ -630,6 +665,9 @@ bool AppInit2()\n             return InitError(_(\"Not listening on any port\"));\n     }\n \n+    // Put this here as AddLocal indirectly uses nLocalServices (though it shouldn't matter)\n+    nLocalServices = pblockstore->HasFullBlocks() ? NODE_NETWORK : 0;\n+\n     if (mapArgs.count(\"-externalip\"))\n     {\n         BOOST_FOREACH(string strAddr, mapMultiArgs[\"-externalip\"]) {\n@@ -662,6 +700,9 @@ bool AppInit2()\n     if (fServer)\n         CreateThread(ThreadRPCServer, NULL);\n \n+    if (mapArgs.count(\"-blocknotify\"))\n+        pblockstore->RegisterCommitBlock(&BlockNotifyCommitBlockHandler);\n+\n #if !defined(QT_GUI)\n     // Loop until process is exit()ed from shutdown() function,\n     // called from ThreadRPCServer thread when a \"stop\" command is received."
      },
      {
        "sha": "1cc292da603fc23f93b73f628f098cca6ece7266",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 383,
        "deletions": 1217,
        "changes": 1600,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/000f04150d61b405b62299a74a53c7a4ba8637ad/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/000f04150d61b405b62299a74a53c7a4ba8637ad/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=000f04150d61b405b62299a74a53c7a4ba8637ad",
        "patch": "@@ -18,6 +18,8 @@ using namespace boost;\n // Global state\n //\n \n+CBlockStore* pblockstore;\n+\n CCriticalSection cs_setpwalletRegistered;\n set<CWallet*> setpwalletRegistered;\n \n@@ -37,13 +39,11 @@ uint256 hashBestChain = 0;\n CBlockIndex* pindexBest = NULL;\n int64 nTimeBestReceived = 0;\n \n-CMedianFilter<int> cPeerBlockCounts(5, 0); // Amount of blocks that other nodes claim to have\n-\n map<uint256, CBlock*> mapOrphanBlocks;\n multimap<uint256, CBlock*> mapOrphanBlocksByPrev;\n \n-map<uint256, CDataStream*> mapOrphanTransactions;\n-multimap<uint256, CDataStream*> mapOrphanTransactionsByPrev;\n+map<uint256, CTransaction*> mapOrphanTransactions;\n+multimap<uint256, CTransaction*> mapOrphanTransactionsByPrev;\n \n // Constant stuff for coinbase transactions we create:\n CScript COINBASE_FLAGS;\n@@ -63,90 +63,11 @@ int64 nTransactionFee = 0;\n // dispatching functions\n //\n \n-// These functions dispatch to one or all registered wallets\n-\n-\n-void RegisterWallet(CWallet* pwalletIn)\n-{\n-    {\n-        LOCK(cs_setpwalletRegistered);\n-        setpwalletRegistered.insert(pwalletIn);\n-    }\n-}\n-\n-void UnregisterWallet(CWallet* pwalletIn)\n-{\n-    {\n-        LOCK(cs_setpwalletRegistered);\n-        setpwalletRegistered.erase(pwalletIn);\n-    }\n-}\n-\n-// check whether the passed transaction is from us\n-bool static IsFromMe(CTransaction& tx)\n-{\n-    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n-        if (pwallet->IsFromMe(tx))\n-            return true;\n-    return false;\n-}\n-\n-// get the wallet transaction with the given hash (if it exists)\n-bool static GetTransaction(const uint256& hashTx, CWalletTx& wtx)\n-{\n-    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n-        if (pwallet->GetTransaction(hashTx,wtx))\n-            return true;\n-    return false;\n-}\n-\n-// erases transaction with the given hash from all wallets\n-void static EraseFromWallets(uint256 hash)\n-{\n-    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n-        pwallet->EraseFromWallet(hash);\n-}\n-\n-// make sure all wallets know about the given transaction, in the given block\n-void static SyncWithWallets(const CTransaction& tx, const CBlock* pblock = NULL, bool fUpdate = false)\n-{\n-    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n-        pwallet->AddToWalletIfInvolvingMe(tx, pblock, fUpdate);\n-}\n-\n-// notify wallets about a new best chain\n-void static SetBestChain(const CBlockLocator& loc)\n-{\n-    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n-        pwallet->SetBestChain(loc);\n-}\n-\n-// notify wallets about an updated transaction\n-void static UpdatedTransaction(const uint256& hashTx)\n-{\n-    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n-        pwallet->UpdatedTransaction(hashTx);\n-}\n-\n // dump all wallets\n+// TODO: abstract this to CBlockStore (but not just blindly printing, that is stupid)\n void static PrintWallets(const CBlock& block)\n {\n-    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n-        pwallet->PrintWallet(block);\n-}\n-\n-// notify wallets about an incoming inventory (for request counts)\n-void static Inventory(const uint256& hash)\n-{\n-    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n-        pwallet->Inventory(hash);\n-}\n-\n-// ask wallets to resend their transactions\n-void static ResendWalletTransactions()\n-{\n-    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n-        pwallet->ResendWalletTransactions();\n+    pwalletMain->PrintWallet(block);\n }\n \n \n@@ -160,38 +81,34 @@ void static ResendWalletTransactions()\n // mapOrphanTransactions\n //\n \n-void AddOrphanTx(const CDataStream& vMsg)\n+void AddOrphanTx(const CTransaction& tx)\n {\n-    CTransaction tx;\n-    CDataStream(vMsg) >> tx;\n     uint256 hash = tx.GetHash();\n     if (mapOrphanTransactions.count(hash))\n         return;\n \n-    CDataStream* pvMsg = mapOrphanTransactions[hash] = new CDataStream(vMsg);\n+    CTransaction* pTx = mapOrphanTransactions[hash] = new CTransaction(tx);\n     BOOST_FOREACH(const CTxIn& txin, tx.vin)\n-        mapOrphanTransactionsByPrev.insert(make_pair(txin.prevout.hash, pvMsg));\n+        mapOrphanTransactionsByPrev.insert(make_pair(txin.prevout.hash, pTx));\n }\n \n void static EraseOrphanTx(uint256 hash)\n {\n     if (!mapOrphanTransactions.count(hash))\n         return;\n-    const CDataStream* pvMsg = mapOrphanTransactions[hash];\n-    CTransaction tx;\n-    CDataStream(*pvMsg) >> tx;\n-    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+    const CTransaction* pTx = mapOrphanTransactions[hash];\n+    BOOST_FOREACH(const CTxIn& txin, pTx->vin)\n     {\n-        for (multimap<uint256, CDataStream*>::iterator mi = mapOrphanTransactionsByPrev.lower_bound(txin.prevout.hash);\n+        for (multimap<uint256, CTransaction*>::iterator mi = mapOrphanTransactionsByPrev.lower_bound(txin.prevout.hash);\n              mi != mapOrphanTransactionsByPrev.upper_bound(txin.prevout.hash);)\n         {\n-            if ((*mi).second == pvMsg)\n+            if ((*mi).second == pTx)\n                 mapOrphanTransactionsByPrev.erase(mi++);\n             else\n                 mi++;\n         }\n     }\n-    delete pvMsg;\n+    delete pTx;\n     mapOrphanTransactions.erase(hash);\n }\n \n@@ -204,7 +121,7 @@ unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)\n         std::vector<unsigned char> randbytes(32);\n         RAND_bytes(&randbytes[0], 32);\n         uint256 randomhash(randbytes);\n-        map<uint256, CDataStream*>::iterator it = mapOrphanTransactions.lower_bound(randomhash);\n+        map<uint256, CTransaction*>::iterator it = mapOrphanTransactions.lower_bound(randomhash);\n         if (it == mapOrphanTransactions.end())\n             it = mapOrphanTransactions.begin();\n         EraseOrphanTx(it->first);\n@@ -353,7 +270,7 @@ CTransaction::GetLegacySigOpCount() const\n \n int CMerkleTx::SetMerkleBranch(const CBlock* pblock)\n {\n-    if (fClient)\n+    if (!pblockstore->HasFullBlocks())\n     {\n         if (hashBlock == 0)\n             return 0;\n@@ -562,7 +479,7 @@ bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n                 nLastTime = nNow;\n                 // -limitfreerelay unit is thousand-bytes-per-minute\n                 // At default rate it would take over a month to fill 1GB\n-                if (dFreeCount > GetArg(\"-limitfreerelay\", 15)*10*1000 && !IsFromMe(tx))\n+                if (dFreeCount > GetArg(\"-limitfreerelay\", 15)*10*1000 && !pblockstore->IsTransactionFromMe(tx))\n                     return error(\"CTxMemPool::accept() : free transaction rejected by rate limiter\");\n                 if (fDebug)\n                     printf(\"Rate limit dFreeCount: %g => %g\\n\", dFreeCount, dFreeCount+nSize);\n@@ -592,7 +509,7 @@ bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n     ///// are we sure this is ok when loading transactions or restoring block txes\n     // If updated, erase old tx from wallet\n     if (ptxOld)\n-        EraseFromWallets(ptxOld->GetHash());\n+        pblockstore->TransactionReplaced(ptxOld->GetHash());\n \n     printf(\"CTxMemPool::accept() : accepted %s (poolsz %u)\\n\",\n            hash.ToString().substr(0,10).c_str(),\n@@ -638,6 +555,23 @@ bool CTxMemPool::remove(CTransaction &tx)\n     return true;\n }\n \n+bool CTransaction::IsFinal(int nBlockHeight, int64 nBlockTime) const\n+{\n+    // Time based nLockTime implemented in 0.1.6\n+    if (nLockTime == 0)\n+        return true;\n+    if (nBlockHeight == 0)\n+        nBlockHeight = pblockstore->GetBestBlockIndex()->nHeight;\n+    if (nBlockTime == 0)\n+        nBlockTime = GetAdjustedTime();\n+    if ((int64)nLockTime < ((int64)nLockTime < LOCKTIME_THRESHOLD ? (int64)nBlockHeight : nBlockTime))\n+        return true;\n+    BOOST_FOREACH(const CTxIn& txin, vin)\n+        if (!txin.IsFinal())\n+            return false;\n+    return true;\n+}\n+\n \n \n \n@@ -679,7 +613,7 @@ int CMerkleTx::GetBlocksToMaturity() const\n \n bool CMerkleTx::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs)\n {\n-    if (fClient)\n+    if (!pblockstore->HasFullBlocks())\n     {\n         if (!IsInMainChain() && !ClientConnectInputs())\n             return false;\n@@ -742,7 +676,7 @@ int CTxIndex::GetDepthInMainChain() const\n }\n \n // Return transaction in tx, and if it was found inside a block, its hash is placed in hashBlock\n-bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock)\n+bool CBlockStore::GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock)\n {\n     {\n         LOCK(cs_main);\n@@ -919,13 +853,7 @@ bool CheckProofOfWork(uint256 hash, unsigned int nBits)\n     return true;\n }\n \n-// Return maximum amount of blocks that other nodes claim to have\n-int GetNumBlocksOfPeers()\n-{\n-    return std::max(cPeerBlockCounts.median(), Checkpoints::GetTotalBlocksEstimate());\n-}\n-\n-bool IsInitialBlockDownload()\n+bool CBlockStore::IsInitialBlockDownload()\n {\n     if (pindexBest == NULL || nBestHeight < Checkpoints::GetTotalBlocksEstimate())\n         return true;\n@@ -1372,10 +1300,6 @@ bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n             return error(\"ConnectBlock() : WriteBlockIndex failed\");\n     }\n \n-    // Watch for transactions paying to me\n-    BOOST_FOREACH(CTransaction& tx, vtx)\n-        SyncWithWallets(tx, this, true);\n-\n     return true;\n }\n \n@@ -1477,14 +1401,6 @@ bool static Reorganize(CTxDB& txdb, CBlockIndex* pindexNew)\n }\n \n \n-static void\n-runCommand(std::string strCommand)\n-{\n-    int nErr = ::system(strCommand.c_str());\n-    if (nErr)\n-        printf(\"runCommand error: system(%s) returned %d\\n\", strCommand.c_str(), nErr);\n-}\n-\n // Called from inside SetBestChain: attaches a block to the new best chain being built\n bool CBlock::SetBestChainInner(CTxDB& txdb, CBlockIndex *pindexNew)\n {\n@@ -1570,14 +1486,6 @@ bool CBlock::SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew)\n         }\n     }\n \n-    // Update best block in wallet (so we can detect restored wallets)\n-    bool fIsInitialDownload = IsInitialBlockDownload();\n-    if (!fIsInitialDownload)\n-    {\n-        const CBlockLocator locator(pindexNew);\n-        ::SetBestChain(locator);\n-    }\n-\n     // New best block\n     hashBestChain = hash;\n     pindexBest = pindexNew;\n@@ -1587,14 +1495,6 @@ bool CBlock::SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew)\n     nTransactionsUpdated++;\n     printf(\"SetBestChain: new best=%s  height=%d  work=%s\\n\", hashBestChain.ToString().substr(0,20).c_str(), nBestHeight, bnBestChainWork.ToString().c_str());\n \n-    std::string strCmd = GetArg(\"-blocknotify\", \"\");\n-\n-    if (!fIsInitialDownload && !strCmd.empty())\n-    {\n-        boost::replace_all(strCmd, \"%s\", hashBestChain.GetHex());\n-        boost::thread t(runCommand, strCmd); // thread runs free\n-    }\n-\n     return true;\n }\n \n@@ -1633,14 +1533,6 @@ bool CBlock::AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos)\n \n     txdb.Close();\n \n-    if (pindexNew == pindexBest)\n-    {\n-        // Notify UI to display prev block's coinbase if it was ours\n-        static uint256 hashPrevBestCoinBase;\n-        UpdatedTransaction(hashPrevBestCoinBase);\n-        hashPrevBestCoinBase = vtx[0].GetHash();\n-    }\n-\n     MainFrameRepaint();\n     return true;\n }\n@@ -1743,94 +1635,115 @@ bool CBlock::AcceptBlock()\n     if (!AddToBlockIndex(nFile, nBlockPos))\n         return error(\"AcceptBlock() : AddToBlockIndex failed\");\n \n-    // Relay inventory, but don't relay old inventory during initial block download\n-    int nBlockEstimate = Checkpoints::GetTotalBlocksEstimate();\n-    if (hashBestChain == hash)\n-    {\n-        LOCK(cs_vNodes);\n-        BOOST_FOREACH(CNode* pnode, vNodes)\n-            if (nBestHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : nBlockEstimate))\n-                pnode->PushInventory(CInv(MSG_BLOCK, hash));\n-    }\n-\n     return true;\n }\n \n-bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n+bool CBlock::WriteToDisk(unsigned int& nFileRet, unsigned int& nBlockPosRet)\n {\n-    // Check for duplicate\n-    uint256 hash = pblock->GetHash();\n-    if (mapBlockIndex.count(hash))\n-        return error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n-    if (mapOrphanBlocks.count(hash))\n-        return error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n+    // Open history file to append\n+    CAutoFile fileout = CAutoFile(AppendBlockFile(nFileRet), SER_DISK, CLIENT_VERSION);\n+    if (!fileout)\n+        return error(\"CBlock::WriteToDisk() : AppendBlockFile failed\");\n+\n+    // Write index header\n+    unsigned int nSize = fileout.GetSerializeSize(*this);\n+    fileout << FLATDATA(pchMessageStart) << nSize;\n \n-    // Preliminary checks\n-    if (!pblock->CheckBlock())\n-        return error(\"ProcessBlock() : CheckBlock FAILED\");\n+    // Write block\n+    long fileOutPos = ftell(fileout);\n+    if (fileOutPos < 0)\n+        return error(\"CBlock::WriteToDisk() : ftell failed\");\n+    nBlockPosRet = fileOutPos;\n+    fileout << *this;\n \n-    CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(mapBlockIndex);\n-    if (pcheckpoint && pblock->hashPrevBlock != hashBestChain)\n+    // Flush stdio buffers and commit to disk before returning\n+    fflush(fileout);\n+    if (!pblockstore->IsInitialBlockDownload() || (pblockstore->GetBestBlockIndex() ? pblockstore->GetBestBlockIndex()->nHeight+1 : 1) % 500 == 0)\n     {\n-        // Extra checks to prevent \"fill up memory by spamming with bogus blocks\"\n-        int64 deltaTime = pblock->GetBlockTime() - pcheckpoint->nTime;\n-        if (deltaTime < 0)\n-        {\n-            if (pfrom)\n-                pfrom->Misbehaving(100);\n-            return error(\"ProcessBlock() : block with timestamp before last checkpoint\");\n-        }\n-        CBigNum bnNewBlock;\n-        bnNewBlock.SetCompact(pblock->nBits);\n-        CBigNum bnRequired;\n-        bnRequired.SetCompact(ComputeMinWork(pcheckpoint->nBits, deltaTime));\n-        if (bnNewBlock > bnRequired)\n-        {\n-            if (pfrom)\n-                pfrom->Misbehaving(100);\n-            return error(\"ProcessBlock() : block with too little proof-of-work\");\n-        }\n+#ifdef WIN32\n+        _commit(_fileno(fileout));\n+#else\n+        fsync(fileno(fileout));\n+#endif\n     }\n \n+    return true;\n+}\n \n-    // If don't already have its previous block, shunt it off to holding area until we get it\n-    if (!mapBlockIndex.count(pblock->hashPrevBlock))\n+bool CBlockStore::EmitBlock(CBlock& block)\n+{\n     {\n-        printf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().substr(0,20).c_str());\n-        CBlock* pblock2 = new CBlock(*pblock);\n-        mapOrphanBlocks.insert(make_pair(hash, pblock2));\n-        mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n+        LOCK(cs_main);\n+        // Check for duplicate\n+        uint256 hash = block.GetHash();\n+        if (mapBlockIndex.count(hash))\n+            return error(\"CBlockStore::EmitBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n+        if (mapOrphanBlocks.count(hash))\n+            return error(\"CBlockStore::EmitBlock() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n+\n+        // Preliminary checks\n+        if (!block.CheckBlock())\n+            return error(\"CBlockStore::EmitBlock() : CheckBlock FAILED\");\n+\n+        CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(mapBlockIndex);\n+        if (pcheckpoint && block.hashPrevBlock != hashBestChain)\n+        {\n+            // Extra checks to prevent \"fill up memory by spamming with bogus blocks\"\n+            int64 deltaTime = block.GetBlockTime() - pcheckpoint->nTime;\n+            if (deltaTime < 0)\n+                return block.DoS(100, error(\"CBlockStore::EmitBlock() : block with timestamp before last checkpoint\"));\n+            CBigNum bnNewBlock;\n+            bnNewBlock.SetCompact(block.nBits);\n+            CBigNum bnRequired;\n+            bnRequired.SetCompact(ComputeMinWork(pcheckpoint->nBits, deltaTime));\n+            if (bnNewBlock > bnRequired)\n+                return block.DoS(100, error(\"CBlockStore::EmitBlock() : block with too little proof-of-work\"));\n+        }\n+\n+        // If don't already have its previous block, shunt it off to holding area until we get it\n+        if (!mapBlockIndex.count(block.hashPrevBlock))\n+        {\n+            printf(\"CBlockStore::EmitBlock: ORPHAN BLOCK, prev=%s\\n\", block.hashPrevBlock.ToString().substr(0,20).c_str());\n+            CBlock* pblock = new CBlock(block);\n+            mapOrphanBlocks.insert(make_pair(hash, pblock));\n+            mapOrphanBlocksByPrev.insert(make_pair(pblock->hashPrevBlock, pblock));\n+\n+            // Ask this guy to fill in what we're missing\n+            AskForBlocks(GetOrphanRoot(pblock), hash);\n+            return true;\n+        }\n \n-        // Ask this guy to fill in what we're missing\n-        if (pfrom)\n-            pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(pblock2));\n-        return true;\n-    }\n+        // Store to disk\n+        if (!block.AcceptBlock())\n+            return error(\"CBlockStore::EmitBlock() : AcceptBlock FAILED\");\n \n-    // Store to disk\n-    if (!pblock->AcceptBlock())\n-        return error(\"ProcessBlock() : AcceptBlock FAILED\");\n+        // Recursively process any orphan blocks that depended on this one\n+        vector<uint256> vWorkQueue;\n+        vWorkQueue.push_back(hash);\n+        for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n+        {\n+            uint256 hashPrev = vWorkQueue[i];\n+            for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n+                 mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);\n+                 ++mi)\n+            {\n+                CBlock* pblockOrphan = (*mi).second;\n+                if (pblockOrphan->AcceptBlock())\n+                    vWorkQueue.push_back(pblockOrphan->GetHash());\n+                mapOrphanBlocks.erase(pblockOrphan->GetHash());\n+                delete pblockOrphan;\n+            }\n+            mapOrphanBlocksByPrev.erase(hashPrev);\n+        }\n+\n+        printf(\"CBlockStore::EmitBlock: ACCEPTED\\n\");\n \n-    // Recursively process any orphan blocks that depended on this one\n-    vector<uint256> vWorkQueue;\n-    vWorkQueue.push_back(hash);\n-    for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n-    {\n-        uint256 hashPrev = vWorkQueue[i];\n-        for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n-             mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);\n-             ++mi)\n         {\n-            CBlock* pblockOrphan = (*mi).second;\n-            if (pblockOrphan->AcceptBlock())\n-                vWorkQueue.push_back(pblockOrphan->GetHash());\n-            mapOrphanBlocks.erase(pblockOrphan->GetHash());\n-            delete pblockOrphan;\n+            LOCK(cs_callbacks);\n+            queueCommitBlockCallbacks.push(new CBlock(block));\n         }\n-        mapOrphanBlocksByPrev.erase(hashPrev);\n     }\n \n-    printf(\"ProcessBlock: ACCEPTED\\n\");\n     return true;\n }\n \n@@ -1916,8 +1829,13 @@ bool LoadBlockIndex(bool fAllowNew)\n     // Load block index\n     //\n     CTxDB txdb(\"cr\");\n-    if (!txdb.LoadBlockIndex())\n+    if (!txdb.LoadBlockIndex(mapBlockIndex, pindexGenesisBlock, pindexBest, hashBestChain, bnBestInvalidWork))\n         return false;\n+    if (pindexBest)\n+    {\n+        nBestHeight = pindexBest->nHeight;\n+        bnBestChainWork = pindexBest->bnChainWork;\n+    }\n     txdb.Close();\n \n     //\n@@ -2094,7 +2012,7 @@ bool LoadExternalBlockFile(FILE* fileIn)\n                 {\n                     CBlock block;\n                     blkdat >> block;\n-                    if (ProcessBlock(NULL,&block))\n+                    if (pblockstore->EmitBlock(block))\n                     {\n                         nLoaded++;\n                         nPos += 4 + nSize;\n@@ -2123,7 +2041,7 @@ bool LoadExternalBlockFile(FILE* fileIn)\n // CAlert\n //\n \n-map<uint256, CAlert> mapAlerts;\n+map<uint256, CAlert*> mapAlerts;\n CCriticalSection cs_mapAlerts;\n \n string GetWarnings(string strFor)\n@@ -2151,9 +2069,9 @@ string GetWarnings(string strFor)\n     // Alerts\n     {\n         LOCK(cs_mapAlerts);\n-        BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n+        BOOST_FOREACH(PAIRTYPE(const uint256, CAlert*)& item, mapAlerts)\n         {\n-            const CAlert& alert = item.second;\n+            const CAlert& alert = *(item.second);\n             if (alert.AppliesToMe() && alert.nPriority > nPriority)\n             {\n                 nPriority = alert.nPriority;\n@@ -2170,49 +2088,49 @@ string GetWarnings(string strFor)\n     return \"error\";\n }\n \n-bool CAlert::ProcessAlert()\n+bool CBlockStore::EmitAlert(CAlert& alert)\n {\n-    if (!CheckSignature())\n+    if (!alert.CheckSignature())\n         return false;\n-    if (!IsInEffect())\n+    if (!alert.IsInEffect())\n         return false;\n \n     {\n         LOCK(cs_mapAlerts);\n         // Cancel previous alerts\n-        for (map<uint256, CAlert>::iterator mi = mapAlerts.begin(); mi != mapAlerts.end();)\n+        for (map<uint256, CAlert*>::iterator mi = mapAlerts.begin(); mi != mapAlerts.end();)\n         {\n-            const CAlert& alert = (*mi).second;\n-            if (Cancels(alert))\n+            if (alert.Cancels(*(mi->second)))\n             {\n-                printf(\"cancelling alert %d\\n\", alert.nID);\n+                printf(\"cancelling alert %d\\n\", mi->second->nID);\n+                delete mi->second;\n                 mapAlerts.erase(mi++);\n             }\n-            else if (!alert.IsInEffect())\n+            else if (!mi->second->IsInEffect())\n             {\n-                printf(\"expiring alert %d\\n\", alert.nID);\n+                printf(\"expiring alert %d\\n\", mi->second->nID);\n+                delete mi->second;\n                 mapAlerts.erase(mi++);\n             }\n             else\n                 mi++;\n         }\n \n         // Check if this alert has been cancelled\n-        BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n+        BOOST_FOREACH(PAIRTYPE(const uint256, CAlert*)& item, mapAlerts)\n         {\n-            const CAlert& alert = item.second;\n-            if (alert.Cancels(*this))\n+            if (item.second->Cancels(alert))\n             {\n-                printf(\"alert already cancelled by %d\\n\", alert.nID);\n+                printf(\"alert already cancelled by %d\\n\", item.second->nID);\n                 return false;\n             }\n         }\n \n         // Add to mapAlerts\n-        mapAlerts.insert(make_pair(GetHash(), *this));\n+        mapAlerts.insert(make_pair(alert.GetHash(), new CAlert(alert)));\n     }\n \n-    printf(\"accepted alert %d, AppliesToMe()=%d\\n\", nID, AppliesToMe());\n+    printf(\"accepted alert %d, AppliesToMe()=%d\\n\", alert.nID, alert.AppliesToMe());\n     MainFrameRepaint();\n     return true;\n }\n@@ -2230,1027 +2148,169 @@ bool CAlert::ProcessAlert()\n //\n \n \n-bool static AlreadyHave(CTxDB& txdb, const CInv& inv)\n+bool CBlockStore::NeedInv(const CInv* pinv)\n {\n-    switch (inv.type)\n     {\n-    case MSG_TX:\n+        LOCK(cs_main);\n+        CTxDB txdb(\"r\");\n+        switch (pinv->type)\n         {\n-        bool txInMap = false;\n+        case MSG_TX:\n             {\n-            LOCK(mempool.cs);\n-            txInMap = (mempool.exists(inv.hash));\n+            bool txNotInMap = false;\n+                {\n+                LOCK(mempool.cs);\n+                txNotInMap = !(mempool.exists(pinv->hash));\n+                }\n+            if (pblockstore->IsInitialBlockDownload())\n+                return false;\n+            return txNotInMap &&\n+                   !mapOrphanTransactions.count(pinv->hash) &&\n+                   !txdb.ContainsTx(pinv->hash);\n             }\n-        return txInMap ||\n-               mapOrphanTransactions.count(inv.hash) ||\n-               txdb.ContainsTx(inv.hash);\n+        case MSG_BLOCK:\n+            if (mapOrphanBlocks.count(pinv->hash))\n+                AskForBlocks(GetOrphanRoot(mapOrphanBlocks[pinv->hash]), pinv->hash);\n+            return !mapBlockIndex.count(pinv->hash) &&\n+                   !mapOrphanBlocks.count(pinv->hash);\n         }\n-\n-    case MSG_BLOCK:\n-        return mapBlockIndex.count(inv.hash) ||\n-               mapOrphanBlocks.count(inv.hash);\n     }\n-    // Don't know what it is, just say we already got one\n-    return true;\n+    // Don't know what it is, guess we don't need one\n+    return false;\n }\n \n \n \n \n-// The message start string is designed to be unlikely to occur in normal data.\n-// The characters are rarely used upper ascii, not valid as UTF-8, and produce\n-// a large 4-byte int at any alignment.\n-unsigned char pchMessageStart[4] = { 0xf9, 0xbe, 0xb4, 0xd9 };\n-\n-\n-bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n-{\n-    static map<CService, vector<unsigned char> > mapReuseKey;\n-    RandAddSeedPerfmon();\n-    if (fDebug)\n-        printf(\"received: %s (%d bytes)\\n\", strCommand.c_str(), vRecv.size());\n-    if (mapArgs.count(\"-dropmessagestest\") && GetRand(atoi(mapArgs[\"-dropmessagestest\"])) == 0)\n-    {\n-        printf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n-        return true;\n-    }\n-\n-\n \n \n \n-    if (strCommand == \"version\")\n-    {\n-        // Each connection can only send one version message\n-        if (pfrom->nVersion != 0)\n-        {\n-            pfrom->Misbehaving(1);\n-            return false;\n-        }\n \n-        int64 nTime;\n-        CAddress addrMe;\n-        CAddress addrFrom;\n-        uint64 nNonce = 1;\n-        vRecv >> pfrom->nVersion >> pfrom->nServices >> nTime >> addrMe;\n-        if (pfrom->nVersion < MIN_PROTO_VERSION)\n-        {\n-            // Since February 20, 2012, the protocol is initiated at version 209,\n-            // and earlier versions are no longer supported\n-            printf(\"partner %s using obsolete version %i; disconnecting\\n\", pfrom->addr.ToString().c_str(), pfrom->nVersion);\n-            pfrom->fDisconnect = true;\n-            return false;\n-        }\n \n-        if (pfrom->nVersion == 10300)\n-            pfrom->nVersion = 300;\n-        if (!vRecv.empty())\n-            vRecv >> addrFrom >> nNonce;\n-        if (!vRecv.empty())\n-            vRecv >> pfrom->strSubVer;\n-        if (!vRecv.empty())\n-            vRecv >> pfrom->nStartingHeight;\n+//////////////////////////////////////////////////////////////////////////////\n+//\n+// BitcoinMiner\n+//\n \n-        if (pfrom->fInbound && addrMe.IsRoutable())\n-        {\n-            pfrom->addrLocal = addrMe;\n-            SeenLocal(addrMe);\n-        }\n+int static FormatHashBlocks(void* pbuffer, unsigned int len)\n+{\n+    unsigned char* pdata = (unsigned char*)pbuffer;\n+    unsigned int blocks = 1 + ((len + 8) / 64);\n+    unsigned char* pend = pdata + 64 * blocks;\n+    memset(pdata + len, 0, 64 * blocks - len);\n+    pdata[len] = 0x80;\n+    unsigned int bits = len * 8;\n+    pend[-1] = (bits >> 0) & 0xff;\n+    pend[-2] = (bits >> 8) & 0xff;\n+    pend[-3] = (bits >> 16) & 0xff;\n+    pend[-4] = (bits >> 24) & 0xff;\n+    return blocks;\n+}\n \n-        // Disconnect if we connected to ourself\n-        if (nNonce == nLocalHostNonce && nNonce > 1)\n-        {\n-            printf(\"connected to self at %s, disconnecting\\n\", pfrom->addr.ToString().c_str());\n-            pfrom->fDisconnect = true;\n-            return true;\n-        }\n+static const unsigned int pSHA256InitState[8] =\n+{0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19};\n \n-        // Be shy and don't send version until we hear\n-        if (pfrom->fInbound)\n-            pfrom->PushVersion();\n+void SHA256Transform(void* pstate, void* pinput, const void* pinit)\n+{\n+    SHA256_CTX ctx;\n+    unsigned char data[64];\n \n-        pfrom->fClient = !(pfrom->nServices & NODE_NETWORK);\n+    SHA256_Init(&ctx);\n \n-        AddTimeData(pfrom->addr, nTime);\n+    for (int i = 0; i < 16; i++)\n+        ((uint32_t*)data)[i] = ByteReverse(((uint32_t*)pinput)[i]);\n \n-        // Change version\n-        pfrom->PushMessage(\"verack\");\n-        pfrom->vSend.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n+    for (int i = 0; i < 8; i++)\n+        ctx.h[i] = ((uint32_t*)pinit)[i];\n \n-        if (!pfrom->fInbound)\n-        {\n-            // Advertise our address\n-            if (!fNoListen && !fUseProxy && !IsInitialBlockDownload())\n-            {\n-                CAddress addr = GetLocalAddress(&pfrom->addr);\n-                if (addr.IsRoutable())\n-                    pfrom->PushAddress(addr);\n-            }\n+    SHA256_Update(&ctx, data, sizeof(data));\n+    for (int i = 0; i < 8; i++) \n+        ((uint32_t*)pstate)[i] = ctx.h[i];\n+}\n \n-            // Get recent addresses\n-            if (pfrom->fOneShot || pfrom->nVersion >= CADDR_TIME_VERSION || addrman.size() < 1000)\n-            {\n-                pfrom->PushMessage(\"getaddr\");\n-                pfrom->fGetAddr = true;\n-            }\n-            addrman.Good(pfrom->addr);\n-        } else {\n-            if (((CNetAddr)pfrom->addr) == (CNetAddr)addrFrom)\n-            {\n-                addrman.Add(addrFrom, addrFrom);\n-                addrman.Good(addrFrom);\n-            }\n-        }\n+//\n+// ScanHash scans nonces looking for a hash with at least some zero bits.\n+// It operates on big endian data.  Caller does the byte reversing.\n+// All input buffers are 16-byte aligned.  nNonce is usually preserved\n+// between calls, but periodically or if nNonce is 0xffff0000 or above,\n+// the block is rebuilt and nNonce starts over at zero.\n+//\n+unsigned int static ScanHash_CryptoPP(char* pmidstate, char* pdata, char* phash1, char* phash, unsigned int& nHashesDone)\n+{\n+    unsigned int& nNonce = *(unsigned int*)(pdata + 12);\n+    for (;;)\n+    {\n+        // Crypto++ SHA-256\n+        // Hash pdata using pmidstate as the starting state into\n+        // preformatted buffer phash1, then hash phash1 into phash\n+        nNonce++;\n+        SHA256Transform(phash1, pdata, pmidstate);\n+        SHA256Transform(phash, phash1, pSHA256InitState);\n \n-        // Ask the first connected node for block updates\n-        static int nAskedForBlocks = 0;\n-        if (!pfrom->fClient && !pfrom->fOneShot &&\n-            (pfrom->nVersion < NOBLKS_VERSION_START ||\n-             pfrom->nVersion >= NOBLKS_VERSION_END) &&\n-             (nAskedForBlocks < 1 || vNodes.size() <= 1))\n-        {\n-            nAskedForBlocks++;\n-            pfrom->PushGetBlocks(pindexBest, uint256(0));\n-        }\n+        // Return the nonce if the hash has at least some zero bits,\n+        // caller will check if it has enough to reach the target\n+        if (((unsigned short*)phash)[14] == 0)\n+            return nNonce;\n \n-        // Relay alerts\n+        // If nothing found after trying for a while, return -1\n+        if ((nNonce & 0xffff) == 0)\n         {\n-            LOCK(cs_mapAlerts);\n-            BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n-                item.second.RelayTo(pfrom);\n+            nHashesDone = 0xffff+1;\n+            return -1;\n         }\n-\n-        pfrom->fSuccessfullyConnected = true;\n-\n-        printf(\"version message: version %d, blocks=%d\\n\", pfrom->nVersion, pfrom->nStartingHeight);\n-\n-        cPeerBlockCounts.input(pfrom->nStartingHeight);\n     }\n+}\n \n+// Some explaining would be appreciated\n+class COrphan\n+{\n+public:\n+    CTransaction* ptx;\n+    set<uint256> setDependsOn;\n+    double dPriority;\n \n-    else if (pfrom->nVersion == 0)\n+    COrphan(CTransaction* ptxIn)\n     {\n-        // Must have a version message before anything else\n-        pfrom->Misbehaving(1);\n-        return false;\n+        ptx = ptxIn;\n+        dPriority = 0;\n     }\n \n-\n-    else if (strCommand == \"verack\")\n+    void print() const\n     {\n-        pfrom->vRecv.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n+        printf(\"COrphan(hash=%s, dPriority=%.1f)\\n\", ptx->GetHash().ToString().substr(0,10).c_str(), dPriority);\n+        BOOST_FOREACH(uint256 hash, setDependsOn)\n+            printf(\"   setDependsOn %s\\n\", hash.ToString().substr(0,10).c_str());\n     }\n+};\n \n \n-    else if (strCommand == \"addr\")\n-    {\n-        vector<CAddress> vAddr;\n-        vRecv >> vAddr;\n+uint64 nLastBlockTx = 0;\n+uint64 nLastBlockSize = 0;\n \n-        // Don't want addr from older versions unless seeding\n-        if (pfrom->nVersion < CADDR_TIME_VERSION && addrman.size() > 1000)\n-            return true;\n-        if (vAddr.size() > 1000)\n-        {\n-            pfrom->Misbehaving(20);\n-            return error(\"message addr size() = %d\", vAddr.size());\n-        }\n+CBlock* CreateNewBlock(CReserveKey& reservekey)\n+{\n+    CBlockIndex* pindexPrev = pindexBest;\n \n-        // Store the new addresses\n-        vector<CAddress> vAddrOk;\n-        int64 nNow = GetAdjustedTime();\n-        int64 nSince = nNow - 10 * 60;\n-        BOOST_FOREACH(CAddress& addr, vAddr)\n-        {\n-            if (fShutdown)\n-                return true;\n-            if (addr.nTime <= 100000000 || addr.nTime > nNow + 10 * 60)\n-                addr.nTime = nNow - 5 * 24 * 60 * 60;\n-            pfrom->AddAddressKnown(addr);\n-            bool fReachable = IsReachable(addr);\n-            if (addr.nTime > nSince && !pfrom->fGetAddr && vAddr.size() <= 10 && addr.IsRoutable())\n-            {\n-                // Relay to a limited number of other nodes\n-                {\n-                    LOCK(cs_vNodes);\n-                    // Use deterministic randomness to send to the same nodes for 24 hours\n-                    // at a time so the setAddrKnowns of the chosen nodes prevent repeats\n-                    static uint256 hashSalt;\n-                    if (hashSalt == 0)\n-                        RAND_bytes((unsigned char*)&hashSalt, sizeof(hashSalt));\n-                    int64 hashAddr = addr.GetHash();\n-                    uint256 hashRand = hashSalt ^ (hashAddr<<32) ^ ((GetTime()+hashAddr)/(24*60*60));\n-                    hashRand = Hash(BEGIN(hashRand), END(hashRand));\n-                    multimap<uint256, CNode*> mapMix;\n-                    BOOST_FOREACH(CNode* pnode, vNodes)\n-                    {\n-                        if (pnode->nVersion < CADDR_TIME_VERSION)\n-                            continue;\n-                        unsigned int nPointer;\n-                        memcpy(&nPointer, &pnode, sizeof(nPointer));\n-                        uint256 hashKey = hashRand ^ nPointer;\n-                        hashKey = Hash(BEGIN(hashKey), END(hashKey));\n-                        mapMix.insert(make_pair(hashKey, pnode));\n-                    }\n-                    int nRelayNodes = fReachable ? 2 : 1; // limited relaying of addresses outside our network(s)\n-                    for (multimap<uint256, CNode*>::iterator mi = mapMix.begin(); mi != mapMix.end() && nRelayNodes-- > 0; ++mi)\n-                        ((*mi).second)->PushAddress(addr);\n-                }\n-            }\n-            // Do not store addresses outside our network\n-            if (fReachable)\n-                vAddrOk.push_back(addr);\n-        }\n-        addrman.Add(vAddrOk, pfrom->addr, 2 * 60 * 60);\n-        if (vAddr.size() < 1000)\n-            pfrom->fGetAddr = false;\n-        if (pfrom->fOneShot)\n-            pfrom->fDisconnect = true;\n-    }\n+    // Create new block\n+    auto_ptr<CBlock> pblock(new CBlock());\n+    if (!pblock.get())\n+        return NULL;\n \n+    // Create coinbase tx\n+    CTransaction txNew;\n+    txNew.vin.resize(1);\n+    txNew.vin[0].prevout.SetNull();\n+    txNew.vout.resize(1);\n+    txNew.vout[0].scriptPubKey << reservekey.GetReservedKey() << OP_CHECKSIG;\n+\n+    // Add our coinbase tx as first transaction\n+    pblock->vtx.push_back(txNew);\n \n-    else if (strCommand == \"inv\")\n+    // Collect memory pool transactions into the block\n+    int64 nFees = 0;\n     {\n-        vector<CInv> vInv;\n-        vRecv >> vInv;\n-        if (vInv.size() > 50000)\n-        {\n-            pfrom->Misbehaving(20);\n-            return error(\"message inv size() = %d\", vInv.size());\n-        }\n-\n-        // find last block in inv vector\n-        unsigned int nLastBlock = (unsigned int)(-1);\n-        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++) {\n-            if (vInv[vInv.size() - 1 - nInv].type == MSG_BLOCK) {\n-                nLastBlock = vInv.size() - 1 - nInv;\n-                break;\n-            }\n-        }\n-        CTxDB txdb(\"r\");\n-        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++)\n-        {\n-            const CInv &inv = vInv[nInv];\n-\n-            if (fShutdown)\n-                return true;\n-            pfrom->AddInventoryKnown(inv);\n-\n-            bool fAlreadyHave = AlreadyHave(txdb, inv);\n-            if (fDebug)\n-                printf(\"  got inventory: %s  %s\\n\", inv.ToString().c_str(), fAlreadyHave ? \"have\" : \"new\");\n-\n-            if (!fAlreadyHave)\n-                pfrom->AskFor(inv);\n-            else if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash)) {\n-                pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(mapOrphanBlocks[inv.hash]));\n-            } else if (nInv == nLastBlock) {\n-                // In case we are on a very long side-chain, it is possible that we already have\n-                // the last block in an inv bundle sent in response to getblocks. Try to detect\n-                // this situation and push another getblocks to continue.\n-                std::vector<CInv> vGetData(1,inv);\n-                pfrom->PushGetBlocks(mapBlockIndex[inv.hash], uint256(0));\n-                if (fDebug)\n-                    printf(\"force request: %s\\n\", inv.ToString().c_str());\n-            }\n-\n-            // Track requests for our stuff\n-            Inventory(inv.hash);\n-        }\n-    }\n-\n-\n-    else if (strCommand == \"getdata\")\n-    {\n-        vector<CInv> vInv;\n-        vRecv >> vInv;\n-        if (vInv.size() > 50000)\n-        {\n-            pfrom->Misbehaving(20);\n-            return error(\"message getdata size() = %d\", vInv.size());\n-        }\n-\n-        BOOST_FOREACH(const CInv& inv, vInv)\n-        {\n-            if (fShutdown)\n-                return true;\n-            printf(\"received getdata for: %s\\n\", inv.ToString().c_str());\n-\n-            if (inv.type == MSG_BLOCK)\n-            {\n-                // Send block from disk\n-                map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(inv.hash);\n-                if (mi != mapBlockIndex.end())\n-                {\n-                    CBlock block;\n-                    block.ReadFromDisk((*mi).second);\n-                    pfrom->PushMessage(\"block\", block);\n-\n-                    // Trigger them to send a getblocks request for the next batch of inventory\n-                    if (inv.hash == pfrom->hashContinue)\n-                    {\n-                        // Bypass PushInventory, this must send even if redundant,\n-                        // and we want it right after the last block so they don't\n-                        // wait for other stuff first.\n-                        vector<CInv> vInv;\n-                        vInv.push_back(CInv(MSG_BLOCK, hashBestChain));\n-                        pfrom->PushMessage(\"inv\", vInv);\n-                        pfrom->hashContinue = 0;\n-                    }\n-                }\n-            }\n-            else if (inv.IsKnownType())\n-            {\n-                // Send stream from relay memory\n-                {\n-                    LOCK(cs_mapRelay);\n-                    map<CInv, CDataStream>::iterator mi = mapRelay.find(inv);\n-                    if (mi != mapRelay.end())\n-                        pfrom->PushMessage(inv.GetCommand(), (*mi).second);\n-                }\n-            }\n-\n-            // Track requests for our stuff\n-            Inventory(inv.hash);\n-        }\n-    }\n-\n-\n-    else if (strCommand == \"getblocks\")\n-    {\n-        CBlockLocator locator;\n-        uint256 hashStop;\n-        vRecv >> locator >> hashStop;\n-\n-        // Find the last block the caller has in the main chain\n-        CBlockIndex* pindex = locator.GetBlockIndex();\n-\n-        // Send the rest of the chain\n-        if (pindex)\n-            pindex = pindex->pnext;\n-        int nLimit = 500 + locator.GetDistanceBack();\n-        unsigned int nBytes = 0;\n-        printf(\"getblocks %d to %s limit %d\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str(), nLimit);\n-        for (; pindex; pindex = pindex->pnext)\n-        {\n-            if (pindex->GetBlockHash() == hashStop)\n-            {\n-                printf(\"  getblocks stopping at %d %s (%u bytes)\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str(), nBytes);\n-                break;\n-            }\n-            pfrom->PushInventory(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n-            CBlock block;\n-            block.ReadFromDisk(pindex, true);\n-            nBytes += block.GetSerializeSize(SER_NETWORK, PROTOCOL_VERSION);\n-            if (--nLimit <= 0 || nBytes >= SendBufferSize()/2)\n-            {\n-                // When this block is requested, we'll send an inv that'll make them\n-                // getblocks the next batch of inventory.\n-                printf(\"  getblocks stopping at limit %d %s (%u bytes)\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str(), nBytes);\n-                pfrom->hashContinue = pindex->GetBlockHash();\n-                break;\n-            }\n-        }\n-    }\n-\n-\n-    else if (strCommand == \"getheaders\")\n-    {\n-        CBlockLocator locator;\n-        uint256 hashStop;\n-        vRecv >> locator >> hashStop;\n-\n-        CBlockIndex* pindex = NULL;\n-        if (locator.IsNull())\n-        {\n-            // If locator is null, return the hashStop block\n-            map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashStop);\n-            if (mi == mapBlockIndex.end())\n-                return true;\n-            pindex = (*mi).second;\n-        }\n-        else\n-        {\n-            // Find the last block the caller has in the main chain\n-            pindex = locator.GetBlockIndex();\n-            if (pindex)\n-                pindex = pindex->pnext;\n-        }\n-\n-        vector<CBlock> vHeaders;\n-        int nLimit = 2000;\n-        printf(\"getheaders %d to %s\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str());\n-        for (; pindex; pindex = pindex->pnext)\n-        {\n-            vHeaders.push_back(pindex->GetBlockHeader());\n-            if (--nLimit <= 0 || pindex->GetBlockHash() == hashStop)\n-                break;\n-        }\n-        pfrom->PushMessage(\"headers\", vHeaders);\n-    }\n-\n-\n-    else if (strCommand == \"tx\")\n-    {\n-        vector<uint256> vWorkQueue;\n-        CDataStream vMsg(vRecv);\n-        CTxDB txdb(\"r\");\n-        CTransaction tx;\n-        vRecv >> tx;\n-\n-        CInv inv(MSG_TX, tx.GetHash());\n-        pfrom->AddInventoryKnown(inv);\n-\n-        bool fMissingInputs = false;\n-        if (tx.AcceptToMemoryPool(txdb, true, &fMissingInputs))\n-        {\n-            SyncWithWallets(tx, NULL, true);\n-            RelayMessage(inv, vMsg);\n-            mapAlreadyAskedFor.erase(inv);\n-            vWorkQueue.push_back(inv.hash);\n-\n-            // Recursively process any orphan transactions that depended on this one\n-            for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n-            {\n-                uint256 hashPrev = vWorkQueue[i];\n-                for (multimap<uint256, CDataStream*>::iterator mi = mapOrphanTransactionsByPrev.lower_bound(hashPrev);\n-                     mi != mapOrphanTransactionsByPrev.upper_bound(hashPrev);\n-                     ++mi)\n-                {\n-                    const CDataStream& vMsg = *((*mi).second);\n-                    CTransaction tx;\n-                    CDataStream(vMsg) >> tx;\n-                    CInv inv(MSG_TX, tx.GetHash());\n-\n-                    if (tx.AcceptToMemoryPool(txdb, true))\n-                    {\n-                        printf(\"   accepted orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n-                        SyncWithWallets(tx, NULL, true);\n-                        RelayMessage(inv, vMsg);\n-                        mapAlreadyAskedFor.erase(inv);\n-                        vWorkQueue.push_back(inv.hash);\n-                    }\n-                }\n-            }\n-\n-            BOOST_FOREACH(uint256 hash, vWorkQueue)\n-                EraseOrphanTx(hash);\n-        }\n-        else if (fMissingInputs)\n-        {\n-            printf(\"storing orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n-            AddOrphanTx(vMsg);\n-\n-            // DoS prevention: do not allow mapOrphanTransactions to grow unbounded\n-            unsigned int nEvicted = LimitOrphanTxSize(MAX_ORPHAN_TRANSACTIONS);\n-            if (nEvicted > 0)\n-                printf(\"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n-        }\n-        if (tx.nDoS) pfrom->Misbehaving(tx.nDoS);\n-    }\n-\n-\n-    else if (strCommand == \"block\")\n-    {\n-        CBlock block;\n-        vRecv >> block;\n-\n-        printf(\"received block %s\\n\", block.GetHash().ToString().substr(0,20).c_str());\n-        // block.print();\n-\n-        CInv inv(MSG_BLOCK, block.GetHash());\n-        pfrom->AddInventoryKnown(inv);\n-\n-        if (ProcessBlock(pfrom, &block))\n-            mapAlreadyAskedFor.erase(inv);\n-        if (block.nDoS) pfrom->Misbehaving(block.nDoS);\n-    }\n-\n-\n-    else if (strCommand == \"getaddr\")\n-    {\n-        pfrom->vAddrToSend.clear();\n-        vector<CAddress> vAddr = addrman.GetAddr();\n-        BOOST_FOREACH(const CAddress &addr, vAddr)\n-            pfrom->PushAddress(addr);\n-    }\n-\n-\n-    else if (strCommand == \"checkorder\")\n-    {\n-        uint256 hashReply;\n-        vRecv >> hashReply;\n-\n-        if (!GetBoolArg(\"-allowreceivebyip\"))\n-        {\n-            pfrom->PushMessage(\"reply\", hashReply, (int)2, string(\"\"));\n-            return true;\n-        }\n-\n-        CWalletTx order;\n-        vRecv >> order;\n-\n-        /// we have a chance to check the order here\n-\n-        // Keep giving the same key to the same ip until they use it\n-        if (!mapReuseKey.count(pfrom->addr))\n-            pwalletMain->GetKeyFromPool(mapReuseKey[pfrom->addr], true);\n-\n-        // Send back approval of order and pubkey to use\n-        CScript scriptPubKey;\n-        scriptPubKey << mapReuseKey[pfrom->addr] << OP_CHECKSIG;\n-        pfrom->PushMessage(\"reply\", hashReply, (int)0, scriptPubKey);\n-    }\n-\n-\n-    else if (strCommand == \"reply\")\n-    {\n-        uint256 hashReply;\n-        vRecv >> hashReply;\n-\n-        CRequestTracker tracker;\n-        {\n-            LOCK(pfrom->cs_mapRequests);\n-            map<uint256, CRequestTracker>::iterator mi = pfrom->mapRequests.find(hashReply);\n-            if (mi != pfrom->mapRequests.end())\n-            {\n-                tracker = (*mi).second;\n-                pfrom->mapRequests.erase(mi);\n-            }\n-        }\n-        if (!tracker.IsNull())\n-            tracker.fn(tracker.param1, vRecv);\n-    }\n-\n-\n-    else if (strCommand == \"ping\")\n-    {\n-        if (pfrom->nVersion > BIP0031_VERSION)\n-        {\n-            uint64 nonce = 0;\n-            vRecv >> nonce;\n-            // Echo the message back with the nonce. This allows for two useful features:\n-            //\n-            // 1) A remote node can quickly check if the connection is operational\n-            // 2) Remote nodes can measure the latency of the network thread. If this node\n-            //    is overloaded it won't respond to pings quickly and the remote node can\n-            //    avoid sending us more work, like chain download requests.\n-            //\n-            // The nonce stops the remote getting confused between different pings: without\n-            // it, if the remote node sends a ping once per second and this node takes 5\n-            // seconds to respond to each, the 5th ping the remote sends would appear to\n-            // return very quickly.\n-            pfrom->PushMessage(\"pong\", nonce);\n-        }\n-    }\n-\n-\n-    else if (strCommand == \"alert\")\n-    {\n-        CAlert alert;\n-        vRecv >> alert;\n-\n-        if (alert.ProcessAlert())\n-        {\n-            // Relay\n-            pfrom->setKnown.insert(alert.GetHash());\n-            {\n-                LOCK(cs_vNodes);\n-                BOOST_FOREACH(CNode* pnode, vNodes)\n-                    alert.RelayTo(pnode);\n-            }\n-        }\n-    }\n-\n-\n-    else\n-    {\n-        // Ignore unknown commands for extensibility\n-    }\n-\n-\n-    // Update the last seen time for this node's address\n-    if (pfrom->fNetworkNode)\n-        if (strCommand == \"version\" || strCommand == \"addr\" || strCommand == \"inv\" || strCommand == \"getdata\" || strCommand == \"ping\")\n-            AddressCurrentlyConnected(pfrom->addr);\n-\n-\n-    return true;\n-}\n-\n-bool ProcessMessages(CNode* pfrom)\n-{\n-    CDataStream& vRecv = pfrom->vRecv;\n-    if (vRecv.empty())\n-        return true;\n-    //if (fDebug)\n-    //    printf(\"ProcessMessages(%u bytes)\\n\", vRecv.size());\n-\n-    //\n-    // Message format\n-    //  (4) message start\n-    //  (12) command\n-    //  (4) size\n-    //  (4) checksum\n-    //  (x) data\n-    //\n-\n-    loop\n-    {\n-        // Scan for message start\n-        CDataStream::iterator pstart = search(vRecv.begin(), vRecv.end(), BEGIN(pchMessageStart), END(pchMessageStart));\n-        int nHeaderSize = vRecv.GetSerializeSize(CMessageHeader());\n-        if (vRecv.end() - pstart < nHeaderSize)\n-        {\n-            if ((int)vRecv.size() > nHeaderSize)\n-            {\n-                printf(\"\\n\\nPROCESSMESSAGE MESSAGESTART NOT FOUND\\n\\n\");\n-                vRecv.erase(vRecv.begin(), vRecv.end() - nHeaderSize);\n-            }\n-            break;\n-        }\n-        if (pstart - vRecv.begin() > 0)\n-            printf(\"\\n\\nPROCESSMESSAGE SKIPPED %d BYTES\\n\\n\", pstart - vRecv.begin());\n-        vRecv.erase(vRecv.begin(), pstart);\n-\n-        // Read header\n-        vector<char> vHeaderSave(vRecv.begin(), vRecv.begin() + nHeaderSize);\n-        CMessageHeader hdr;\n-        vRecv >> hdr;\n-        if (!hdr.IsValid())\n-        {\n-            printf(\"\\n\\nPROCESSMESSAGE: ERRORS IN HEADER %s\\n\\n\\n\", hdr.GetCommand().c_str());\n-            continue;\n-        }\n-        string strCommand = hdr.GetCommand();\n-\n-        // Message size\n-        unsigned int nMessageSize = hdr.nMessageSize;\n-        if (nMessageSize > MAX_SIZE)\n-        {\n-            printf(\"ProcessMessage(%s, %u bytes) : nMessageSize > MAX_SIZE\\n\", strCommand.c_str(), nMessageSize);\n-            continue;\n-        }\n-        if (nMessageSize > vRecv.size())\n-        {\n-            // Rewind and wait for rest of message\n-            vRecv.insert(vRecv.begin(), vHeaderSave.begin(), vHeaderSave.end());\n-            break;\n-        }\n-\n-        // Checksum\n-        uint256 hash = Hash(vRecv.begin(), vRecv.begin() + nMessageSize);\n-        unsigned int nChecksum = 0;\n-        memcpy(&nChecksum, &hash, sizeof(nChecksum));\n-        if (nChecksum != hdr.nChecksum)\n-        {\n-            printf(\"ProcessMessage(%s, %u bytes) : CHECKSUM ERROR nChecksum=%08x hdr.nChecksum=%08x\\n\",\n-               strCommand.c_str(), nMessageSize, nChecksum, hdr.nChecksum);\n-            continue;\n-        }\n-\n-        // Copy message to its own buffer\n-        CDataStream vMsg(vRecv.begin(), vRecv.begin() + nMessageSize, vRecv.nType, vRecv.nVersion);\n-        vRecv.ignore(nMessageSize);\n-\n-        // Process message\n-        bool fRet = false;\n-        try\n-        {\n-            {\n-                LOCK(cs_main);\n-                fRet = ProcessMessage(pfrom, strCommand, vMsg);\n-            }\n-            if (fShutdown)\n-                return true;\n-        }\n-        catch (std::ios_base::failure& e)\n-        {\n-            if (strstr(e.what(), \"end of data\"))\n-            {\n-                // Allow exceptions from underlength message on vRecv\n-                printf(\"ProcessMessage(%s, %u bytes) : Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", strCommand.c_str(), nMessageSize, e.what());\n-            }\n-            else if (strstr(e.what(), \"size too large\"))\n-            {\n-                // Allow exceptions from overlong size\n-                printf(\"ProcessMessage(%s, %u bytes) : Exception '%s' caught\\n\", strCommand.c_str(), nMessageSize, e.what());\n-            }\n-            else\n-            {\n-                PrintExceptionContinue(&e, \"ProcessMessage()\");\n-            }\n-        }\n-        catch (std::exception& e) {\n-            PrintExceptionContinue(&e, \"ProcessMessage()\");\n-        } catch (...) {\n-            PrintExceptionContinue(NULL, \"ProcessMessage()\");\n-        }\n-\n-        if (!fRet)\n-            printf(\"ProcessMessage(%s, %u bytes) FAILED\\n\", strCommand.c_str(), nMessageSize);\n-    }\n-\n-    vRecv.Compact();\n-    return true;\n-}\n-\n-\n-bool SendMessages(CNode* pto, bool fSendTrickle)\n-{\n-    TRY_LOCK(cs_main, lockMain);\n-    if (lockMain) {\n-        // Don't send anything until we get their version message\n-        if (pto->nVersion == 0)\n-            return true;\n-\n-        // Keep-alive ping. We send a nonce of zero because we don't use it anywhere \n-        // right now.\n-        if (pto->nLastSend && GetTime() - pto->nLastSend > 30 * 60 && pto->vSend.empty()) {\n-            if (pto->nVersion > BIP0031_VERSION)\n-                pto->PushMessage(\"ping\", 0);\n-            else\n-                pto->PushMessage(\"ping\");\n-        }\n-\n-        // Resend wallet transactions that haven't gotten in a block yet\n-        ResendWalletTransactions();\n-\n-        // Address refresh broadcast\n-        static int64 nLastRebroadcast;\n-        if (!IsInitialBlockDownload() && (GetTime() - nLastRebroadcast > 24 * 60 * 60))\n-        {\n-            {\n-                LOCK(cs_vNodes);\n-                BOOST_FOREACH(CNode* pnode, vNodes)\n-                {\n-                    // Periodically clear setAddrKnown to allow refresh broadcasts\n-                    if (nLastRebroadcast)\n-                        pnode->setAddrKnown.clear();\n-\n-                    // Rebroadcast our address\n-                    if (!fNoListen && !fUseProxy)\n-                    {\n-                        CAddress addr = GetLocalAddress(&pnode->addr);\n-                        if (addr.IsRoutable())\n-                            pnode->PushAddress(addr);\n-                    }\n-                }\n-            }\n-            nLastRebroadcast = GetTime();\n-        }\n-\n-        //\n-        // Message: addr\n-        //\n-        if (fSendTrickle)\n-        {\n-            vector<CAddress> vAddr;\n-            vAddr.reserve(pto->vAddrToSend.size());\n-            BOOST_FOREACH(const CAddress& addr, pto->vAddrToSend)\n-            {\n-                // returns true if wasn't already contained in the set\n-                if (pto->setAddrKnown.insert(addr).second)\n-                {\n-                    vAddr.push_back(addr);\n-                    // receiver rejects addr messages larger than 1000\n-                    if (vAddr.size() >= 1000)\n-                    {\n-                        pto->PushMessage(\"addr\", vAddr);\n-                        vAddr.clear();\n-                    }\n-                }\n-            }\n-            pto->vAddrToSend.clear();\n-            if (!vAddr.empty())\n-                pto->PushMessage(\"addr\", vAddr);\n-        }\n-\n-\n-        //\n-        // Message: inventory\n-        //\n-        vector<CInv> vInv;\n-        vector<CInv> vInvWait;\n-        {\n-            LOCK(pto->cs_inventory);\n-            vInv.reserve(pto->vInventoryToSend.size());\n-            vInvWait.reserve(pto->vInventoryToSend.size());\n-            BOOST_FOREACH(const CInv& inv, pto->vInventoryToSend)\n-            {\n-                if (pto->setInventoryKnown.count(inv))\n-                    continue;\n-\n-                // trickle out tx inv to protect privacy\n-                if (inv.type == MSG_TX && !fSendTrickle)\n-                {\n-                    // 1/4 of tx invs blast to all immediately\n-                    static uint256 hashSalt;\n-                    if (hashSalt == 0)\n-                        RAND_bytes((unsigned char*)&hashSalt, sizeof(hashSalt));\n-                    uint256 hashRand = inv.hash ^ hashSalt;\n-                    hashRand = Hash(BEGIN(hashRand), END(hashRand));\n-                    bool fTrickleWait = ((hashRand & 3) != 0);\n-\n-                    // always trickle our own transactions\n-                    if (!fTrickleWait)\n-                    {\n-                        CWalletTx wtx;\n-                        if (GetTransaction(inv.hash, wtx))\n-                            if (wtx.fFromMe)\n-                                fTrickleWait = true;\n-                    }\n-\n-                    if (fTrickleWait)\n-                    {\n-                        vInvWait.push_back(inv);\n-                        continue;\n-                    }\n-                }\n-\n-                // returns true if wasn't already contained in the set\n-                if (pto->setInventoryKnown.insert(inv).second)\n-                {\n-                    vInv.push_back(inv);\n-                    if (vInv.size() >= 1000)\n-                    {\n-                        pto->PushMessage(\"inv\", vInv);\n-                        vInv.clear();\n-                    }\n-                }\n-            }\n-            pto->vInventoryToSend = vInvWait;\n-        }\n-        if (!vInv.empty())\n-            pto->PushMessage(\"inv\", vInv);\n-\n-\n-        //\n-        // Message: getdata\n-        //\n-        vector<CInv> vGetData;\n-        int64 nNow = GetTime() * 1000000;\n-        CTxDB txdb(\"r\");\n-        while (!pto->mapAskFor.empty() && (*pto->mapAskFor.begin()).first <= nNow)\n-        {\n-            const CInv& inv = (*pto->mapAskFor.begin()).second;\n-            if (!AlreadyHave(txdb, inv))\n-            {\n-                printf(\"sending getdata: %s\\n\", inv.ToString().c_str());\n-                vGetData.push_back(inv);\n-                if (vGetData.size() >= 1000)\n-                {\n-                    pto->PushMessage(\"getdata\", vGetData);\n-                    vGetData.clear();\n-                }\n-            }\n-            mapAlreadyAskedFor[inv] = nNow;\n-            pto->mapAskFor.erase(pto->mapAskFor.begin());\n-        }\n-        if (!vGetData.empty())\n-            pto->PushMessage(\"getdata\", vGetData);\n-\n-    }\n-    return true;\n-}\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-//////////////////////////////////////////////////////////////////////////////\n-//\n-// BitcoinMiner\n-//\n-\n-int static FormatHashBlocks(void* pbuffer, unsigned int len)\n-{\n-    unsigned char* pdata = (unsigned char*)pbuffer;\n-    unsigned int blocks = 1 + ((len + 8) / 64);\n-    unsigned char* pend = pdata + 64 * blocks;\n-    memset(pdata + len, 0, 64 * blocks - len);\n-    pdata[len] = 0x80;\n-    unsigned int bits = len * 8;\n-    pend[-1] = (bits >> 0) & 0xff;\n-    pend[-2] = (bits >> 8) & 0xff;\n-    pend[-3] = (bits >> 16) & 0xff;\n-    pend[-4] = (bits >> 24) & 0xff;\n-    return blocks;\n-}\n-\n-static const unsigned int pSHA256InitState[8] =\n-{0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19};\n-\n-void SHA256Transform(void* pstate, void* pinput, const void* pinit)\n-{\n-    SHA256_CTX ctx;\n-    unsigned char data[64];\n-\n-    SHA256_Init(&ctx);\n-\n-    for (int i = 0; i < 16; i++)\n-        ((uint32_t*)data)[i] = ByteReverse(((uint32_t*)pinput)[i]);\n-\n-    for (int i = 0; i < 8; i++)\n-        ctx.h[i] = ((uint32_t*)pinit)[i];\n-\n-    SHA256_Update(&ctx, data, sizeof(data));\n-    for (int i = 0; i < 8; i++) \n-        ((uint32_t*)pstate)[i] = ctx.h[i];\n-}\n-\n-//\n-// ScanHash scans nonces looking for a hash with at least some zero bits.\n-// It operates on big endian data.  Caller does the byte reversing.\n-// All input buffers are 16-byte aligned.  nNonce is usually preserved\n-// between calls, but periodically or if nNonce is 0xffff0000 or above,\n-// the block is rebuilt and nNonce starts over at zero.\n-//\n-unsigned int static ScanHash_CryptoPP(char* pmidstate, char* pdata, char* phash1, char* phash, unsigned int& nHashesDone)\n-{\n-    unsigned int& nNonce = *(unsigned int*)(pdata + 12);\n-    for (;;)\n-    {\n-        // Crypto++ SHA-256\n-        // Hash pdata using pmidstate as the starting state into\n-        // preformatted buffer phash1, then hash phash1 into phash\n-        nNonce++;\n-        SHA256Transform(phash1, pdata, pmidstate);\n-        SHA256Transform(phash, phash1, pSHA256InitState);\n-\n-        // Return the nonce if the hash has at least some zero bits,\n-        // caller will check if it has enough to reach the target\n-        if (((unsigned short*)phash)[14] == 0)\n-            return nNonce;\n-\n-        // If nothing found after trying for a while, return -1\n-        if ((nNonce & 0xffff) == 0)\n-        {\n-            nHashesDone = 0xffff+1;\n-            return (unsigned int) -1;\n-        }\n-    }\n-}\n-\n-// Some explaining would be appreciated\n-class COrphan\n-{\n-public:\n-    CTransaction* ptx;\n-    set<uint256> setDependsOn;\n-    double dPriority;\n-\n-    COrphan(CTransaction* ptxIn)\n-    {\n-        ptx = ptxIn;\n-        dPriority = 0;\n-    }\n-\n-    void print() const\n-    {\n-        printf(\"COrphan(hash=%s, dPriority=%.1f)\\n\", ptx->GetHash().ToString().substr(0,10).c_str(), dPriority);\n-        BOOST_FOREACH(uint256 hash, setDependsOn)\n-            printf(\"   setDependsOn %s\\n\", hash.ToString().substr(0,10).c_str());\n-    }\n-};\n-\n-\n-uint64 nLastBlockTx = 0;\n-uint64 nLastBlockSize = 0;\n-\n-CBlock* CreateNewBlock(CReserveKey& reservekey)\n-{\n-    CBlockIndex* pindexPrev = pindexBest;\n-\n-    // Create new block\n-    auto_ptr<CBlock> pblock(new CBlock());\n-    if (!pblock.get())\n-        return NULL;\n-\n-    // Create coinbase tx\n-    CTransaction txNew;\n-    txNew.vin.resize(1);\n-    txNew.vin[0].prevout.SetNull();\n-    txNew.vout.resize(1);\n-    txNew.vout[0].scriptPubKey << reservekey.GetReservedKey() << OP_CHECKSIG;\n-\n-    // Add our coinbase tx as first transaction\n-    pblock->vtx.push_back(txNew);\n-\n-    // Collect memory pool transactions into the block\n-    int64 nFees = 0;\n-    {\n-        LOCK2(cs_main, mempool.cs);\n-        CTxDB txdb(\"r\");\n+        LOCK2(cs_main, mempool.cs);\n+        CTxDB txdb(\"r\");\n \n         // Priority order to process transactions\n         list<COrphan> vOrphan; // list memory doesn't move\n@@ -3398,7 +2458,7 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n }\n \n \n-void IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int& nExtraNonce)\n+void IncrementExtraNonce(CBlock* pblock, const CBlockIndex* pindexPrev, unsigned int& nExtraNonce)\n {\n     // Update nExtraNonce\n     static uint256 hashPrevBlock;\n@@ -3491,8 +2551,8 @@ bool CheckWork(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey)\n         }\n \n         // Process this block the same as if we had received it from another node\n-        if (!ProcessBlock(NULL, pblock))\n-            return error(\"BitcoinMiner : ProcessBlock, block not accepted\");\n+        if (!pblockstore->EmitBlock(*pblock))\n+            return error(\"BitcoinMiner : EmitBlock, block not accepted\");\n     }\n \n     return true;\n@@ -3517,7 +2577,7 @@ void static BitcoinMiner(CWallet *pwallet)\n     {\n         if (fShutdown)\n             return;\n-        while (vNodes.empty() || IsInitialBlockDownload())\n+        while (vNodes.empty() || pblockstore->IsInitialBlockDownload())\n         {\n             Sleep(1000);\n             if (fShutdown)\n@@ -3697,3 +2757,109 @@ void GenerateBitcoins(bool fGenerate, CWallet* pwallet)\n         }\n     }\n }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+bool CBlockStore::EmitTransaction(CTransaction& transaction)\n+{\n+    {\n+        LOCK(cs_main);\n+        vector<uint256> vWorkQueue;\n+        CTxDB txdb(\"r\");\n+        bool fMissingInputs = false;\n+\n+        if (transaction.AcceptToMemoryPool(txdb, true, &fMissingInputs))\n+        {\n+            {\n+                LOCK(cs_callbacks);\n+                queueCommitTransactionToMemoryPoolCallbacks.push(new CTransaction(transaction));\n+            }\n+\n+            vWorkQueue.push_back(transaction.GetHash());\n+\n+            // Recursively process any orphan transactions that depended on this one\n+            for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n+            {\n+                uint256 hashPrev = vWorkQueue[i];\n+                for (multimap<uint256, CTransaction*>::iterator mi = mapOrphanTransactionsByPrev.lower_bound(hashPrev);\n+                     mi != mapOrphanTransactionsByPrev.upper_bound(hashPrev);\n+                     ++mi)\n+                {\n+                    CTransaction& tx = *((*mi).second);\n+                    uint256 hash = tx.GetHash();\n+\n+                    if (tx.AcceptToMemoryPool(txdb, true))\n+                    {\n+                        printf(\"   accepted orphan tx %s\\n\", hash.ToString().substr(0,10).c_str());\n+                        {\n+                            LOCK(cs_callbacks);\n+                            queueCommitTransactionToMemoryPoolCallbacks.push(new CTransaction(tx));\n+                        }\n+                        vWorkQueue.push_back(hash);\n+                    }\n+                }\n+            }\n+\n+            BOOST_FOREACH(uint256 hash, vWorkQueue)\n+                EraseOrphanTx(hash);\n+\n+            return true;\n+        }\n+        else if (fMissingInputs)\n+        {\n+            printf(\"storing orphan tx %s\\n\", transaction.GetHash().ToString().substr(0,10).c_str());\n+            AddOrphanTx(transaction);\n+\n+            // DoS prevention: do not allow mapOrphanTransactions to grow unbounded\n+            unsigned int nEvicted = LimitOrphanTxSize(MAX_ORPHAN_TRANSACTIONS);\n+            if (nEvicted > 0)\n+                printf(\"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n+        }\n+    }\n+    return false;\n+}\n+\n+const CBlockIndex* CBlockStore::GetBestBlockIndex() const\n+{\n+    LOCK(cs_main);\n+    return pindexBest;\n+}\n+\n+const CBlockIndex* CBlockStore::GetGenesisBlockIndex() const\n+{\n+    LOCK(cs_main);\n+    return pindexGenesisBlock;\n+}\n+\n+void CBlockStore::RelayAlerts(CNode* pnode)\n+{\n+    LOCK(cs_mapAlerts);\n+    BOOST_FOREACH(PAIRTYPE(const uint256, CAlert*)& item, mapAlerts)\n+        item.second->RelayTo(pnode);\n+}\n+\n+const CBlockIndex* CBlockStore::GetBlockIndex(const uint256 nBlockHash)\n+{\n+    LOCK(cs_main);\n+    std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(nBlockHash);\n+    if (mi != mapBlockIndex.end())\n+        return (*mi).second;\n+    return NULL;\n+}\n+"
      },
      {
        "sha": "8e914cbb7f9ffcdf5ad35f89e394c656e1aed427",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 21,
        "deletions": 89,
        "changes": 110,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/000f04150d61b405b62299a74a53c7a4ba8637ad/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/000f04150d61b405b62299a74a53c7a4ba8637ad/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=000f04150d61b405b62299a74a53c7a4ba8637ad",
        "patch": "@@ -7,6 +7,7 @@\n \n #include \"bignum.h\"\n #include \"sync.h\"\n+#include \"blockstore.h\"\n #include \"net.h\"\n #include \"script.h\"\n \n@@ -53,23 +54,14 @@ extern CScript COINBASE_FLAGS;\n \n \n extern CCriticalSection cs_main;\n-extern std::map<uint256, CBlockIndex*> mapBlockIndex;\n extern uint256 hashGenesisBlock;\n-extern CBlockIndex* pindexGenesisBlock;\n-extern int nBestHeight;\n-extern CBigNum bnBestChainWork;\n-extern CBigNum bnBestInvalidWork;\n-extern uint256 hashBestChain;\n-extern CBlockIndex* pindexBest;\n extern unsigned int nTransactionsUpdated;\n extern uint64 nLastBlockTx;\n extern uint64 nLastBlockSize;\n extern const std::string strMessageMagic;\n extern double dHashesPerSec;\n extern int64 nHPSTimerStart;\n extern int64 nTimeBestReceived;\n-extern CCriticalSection cs_setpwalletRegistered;\n-extern std::set<CWallet*> setpwalletRegistered;\n extern unsigned char pchMessageStart[4];\n \n // Settings\n@@ -83,28 +75,20 @@ class CReserveKey;\n class CTxDB;\n class CTxIndex;\n \n-void RegisterWallet(CWallet* pwalletIn);\n-void UnregisterWallet(CWallet* pwalletIn);\n-bool ProcessBlock(CNode* pfrom, CBlock* pblock);\n bool CheckDiskSpace(uint64 nAdditionalBytes=0);\n FILE* OpenBlockFile(unsigned int nFile, unsigned int nBlockPos, const char* pszMode=\"rb\");\n FILE* AppendBlockFile(unsigned int& nFileRet);\n bool LoadBlockIndex(bool fAllowNew=true);\n void PrintBlockTree();\n-bool ProcessMessages(CNode* pfrom);\n-bool SendMessages(CNode* pto, bool fSendTrickle);\n bool LoadExternalBlockFile(FILE* fileIn);\n void GenerateBitcoins(bool fGenerate, CWallet* pwallet);\n CBlock* CreateNewBlock(CReserveKey& reservekey);\n-void IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int& nExtraNonce);\n+void IncrementExtraNonce(CBlock* pblock, const CBlockIndex* pindexPrev, unsigned int& nExtraNonce);\n void FormatHashBuffers(CBlock* pblock, char* pmidstate, char* pdata, char* phash1);\n bool CheckWork(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey);\n bool CheckProofOfWork(uint256 hash, unsigned int nBits);\n unsigned int ComputeMinWork(unsigned int nBase, int64 nTime);\n-int GetNumBlocksOfPeers();\n-bool IsInitialBlockDownload();\n std::string GetWarnings(std::string strFor);\n-bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock);\n \n \n \n@@ -116,8 +100,6 @@ bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock);\n \n \n \n-bool GetWalletFile(CWallet* pwallet, std::string &strWalletFileOut);\n-\n /** Position on disk for a particular transaction. */\n class CDiskTxPos\n {\n@@ -431,22 +413,7 @@ class CTransaction\n         return SerializeHash(*this);\n     }\n \n-    bool IsFinal(int nBlockHeight=0, int64 nBlockTime=0) const\n-    {\n-        // Time based nLockTime implemented in 0.1.6\n-        if (nLockTime == 0)\n-            return true;\n-        if (nBlockHeight == 0)\n-            nBlockHeight = nBestHeight;\n-        if (nBlockTime == 0)\n-            nBlockTime = GetAdjustedTime();\n-        if ((int64)nLockTime < ((int64)nLockTime < LOCKTIME_THRESHOLD ? (int64)nBlockHeight : nBlockTime))\n-            return true;\n-        BOOST_FOREACH(const CTxIn& txin, vin)\n-            if (!txin.IsFinal())\n-                return false;\n-        return true;\n-    }\n+    bool IsFinal(int nBlockHeight=0, int64 nBlockTime=0) const;\n \n     bool IsNewerThan(const CTransaction& old) const\n     {\n@@ -935,37 +902,7 @@ class CBlock\n     }\n \n \n-    bool WriteToDisk(unsigned int& nFileRet, unsigned int& nBlockPosRet)\n-    {\n-        // Open history file to append\n-        CAutoFile fileout = CAutoFile(AppendBlockFile(nFileRet), SER_DISK, CLIENT_VERSION);\n-        if (!fileout)\n-            return error(\"CBlock::WriteToDisk() : AppendBlockFile failed\");\n-\n-        // Write index header\n-        unsigned int nSize = fileout.GetSerializeSize(*this);\n-        fileout << FLATDATA(pchMessageStart) << nSize;\n-\n-        // Write block\n-        long fileOutPos = ftell(fileout);\n-        if (fileOutPos < 0)\n-            return error(\"CBlock::WriteToDisk() : ftell failed\");\n-        nBlockPosRet = fileOutPos;\n-        fileout << *this;\n-\n-        // Flush stdio buffers and commit to disk before returning\n-        fflush(fileout);\n-        if (!IsInitialBlockDownload() || (nBestHeight+1) % 500 == 0)\n-        {\n-#ifdef WIN32\n-            _commit(_fileno(fileout));\n-#else\n-            fsync(fileno(fileout));\n-#endif\n-        }\n-\n-        return true;\n-    }\n+    bool WriteToDisk(unsigned int& nFileRet, unsigned int& nBlockPosRet);\n \n     bool ReadFromDisk(unsigned int nFile, unsigned int nBlockPos, bool fReadTransactions=true)\n     {\n@@ -1122,7 +1059,7 @@ class CBlockIndex\n \n     bool IsInMainChain() const\n     {\n-        return (pnext || this == pindexBest);\n+        return (pnext || this == pblockstore->GetBestBlockIndex());\n     }\n \n     bool CheckIndex() const\n@@ -1287,9 +1224,9 @@ class CBlockLocator\n \n     explicit CBlockLocator(uint256 hashBlock)\n     {\n-        std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n-        if (mi != mapBlockIndex.end())\n-            Set((*mi).second);\n+        const CBlockIndex* pblockIndex = pblockstore->GetBlockIndex(hashBlock);\n+        if (pblockIndex != NULL)\n+            Set(pblockIndex);\n     }\n \n     CBlockLocator(const std::vector<uint256>& vHaveIn)\n@@ -1338,11 +1275,10 @@ class CBlockLocator\n         int nStep = 1;\n         BOOST_FOREACH(const uint256& hash, vHave)\n         {\n-            std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n-            if (mi != mapBlockIndex.end())\n+            const CBlockIndex* pblockIndex = pblockstore->GetBlockIndex(hash);\n+            if (pblockIndex != NULL)\n             {\n-                CBlockIndex* pindex = (*mi).second;\n-                if (pindex->IsInMainChain())\n+                if (pblockIndex->IsInMainChain())\n                     return nDistance;\n             }\n             nDistance += nStep;\n@@ -1352,32 +1288,30 @@ class CBlockLocator\n         return nDistance;\n     }\n \n-    CBlockIndex* GetBlockIndex()\n+    const CBlockIndex* GetBlockIndex()\n     {\n         // Find the first block the caller has in the main chain\n         BOOST_FOREACH(const uint256& hash, vHave)\n         {\n-            std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n-            if (mi != mapBlockIndex.end())\n+            const CBlockIndex* pblockIndex = pblockstore->GetBlockIndex(hash);\n+            if (pblockIndex != NULL)\n             {\n-                CBlockIndex* pindex = (*mi).second;\n-                if (pindex->IsInMainChain())\n-                    return pindex;\n+                if (pblockIndex->IsInMainChain())\n+                    return pblockIndex;\n             }\n         }\n-        return pindexGenesisBlock;\n+        return pblockstore->GetGenesisBlockIndex();\n     }\n \n     uint256 GetBlockHash()\n     {\n         // Find the first block the caller has in the main chain\n         BOOST_FOREACH(const uint256& hash, vHave)\n         {\n-            std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n-            if (mi != mapBlockIndex.end())\n+            const CBlockIndex* pblockIndex = pblockstore->GetBlockIndex(hash);\n+            if (pblockIndex != NULL)\n             {\n-                CBlockIndex* pindex = (*mi).second;\n-                if (pindex->IsInMainChain())\n+                if (pblockIndex->IsInMainChain())\n                     return hash;\n             }\n         }\n@@ -1386,7 +1320,7 @@ class CBlockLocator\n \n     int GetHeight()\n     {\n-        CBlockIndex* pindex = GetBlockIndex();\n+        const CBlockIndex* pindex = GetBlockIndex();\n         if (!pindex)\n             return 0;\n         return pindex->nHeight;\n@@ -1598,8 +1532,6 @@ class CAlert : public CUnsignedAlert\n         sMsg >> *(CUnsignedAlert*)this;\n         return true;\n     }\n-\n-    bool ProcessAlert();\n };\n \n class CTxMemPool"
      },
      {
        "sha": "376d5de25ba74e01ef91ee4d218dbb577b5cc5c4",
        "filename": "src/makefile.linux-mingw",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/000f04150d61b405b62299a74a53c7a4ba8637ad/src/makefile.linux-mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/000f04150d61b405b62299a74a53c7a4ba8637ad/src/makefile.linux-mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.linux-mingw?ref=000f04150d61b405b62299a74a53c7a4ba8637ad",
        "patch": "@@ -65,7 +65,8 @@ OBJS= \\\n     obj/util.o \\\n     obj/wallet.o \\\n     obj/walletdb.o \\\n-    obj/noui.o\n+    obj/noui.o \\\n+    obj/blockstore.o\n \n all: bitcoind.exe\n "
      },
      {
        "sha": "5870deb55a1a90e4883e1c49113dcb73714e6fe0",
        "filename": "src/makefile.mingw",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/000f04150d61b405b62299a74a53c7a4ba8637ad/src/makefile.mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/000f04150d61b405b62299a74a53c7a4ba8637ad/src/makefile.mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.mingw?ref=000f04150d61b405b62299a74a53c7a4ba8637ad",
        "patch": "@@ -62,7 +62,8 @@ OBJS= \\\n     obj/util.o \\\n     obj/wallet.o \\\n     obj/walletdb.o \\\n-    obj/noui.o\n+    obj/noui.o \\\n+    obj/blockstore.o\n \n \n all: bitcoind.exe"
      },
      {
        "sha": "b69d34aadd249a9b2d1b825a982c50e6dc7c4abd",
        "filename": "src/makefile.osx",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/000f04150d61b405b62299a74a53c7a4ba8637ad/src/makefile.osx",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/000f04150d61b405b62299a74a53c7a4ba8637ad/src/makefile.osx",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.osx?ref=000f04150d61b405b62299a74a53c7a4ba8637ad",
        "patch": "@@ -89,7 +89,8 @@ OBJS= \\\n     obj/util.o \\\n     obj/wallet.o \\\n     obj/walletdb.o \\\n-    obj/noui.o\n+    obj/noui.o \\\n+    obj/blockstore.o\n \n ifdef USE_UPNP\n \tDEFS += -DUSE_UPNP=$(USE_UPNP)"
      },
      {
        "sha": "be489f20957a9943e85b71d91aa3f73a2107509c",
        "filename": "src/makefile.unix",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/000f04150d61b405b62299a74a53c7a4ba8637ad/src/makefile.unix",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/000f04150d61b405b62299a74a53c7a4ba8637ad/src/makefile.unix",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.unix?ref=000f04150d61b405b62299a74a53c7a4ba8637ad",
        "patch": "@@ -109,7 +109,8 @@ OBJS= \\\n     obj/util.o \\\n     obj/wallet.o \\\n     obj/walletdb.o \\\n-    obj/noui.o\n+    obj/noui.o \\\n+    obj/blockstore.o\n \n \n all: bitcoind"
      },
      {
        "sha": "559c83a549d7b1eb326d13e6f7e727a92878b4f5",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 65,
        "deletions": 4,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/000f04150d61b405b62299a74a53c7a4ba8637ad/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/000f04150d61b405b62299a74a53c7a4ba8637ad/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=000f04150d61b405b62299a74a53c7a4ba8637ad",
        "patch": "@@ -3,6 +3,7 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file license.txt or http://www.opensource.org/licenses/mit-license.php.\n \n+#include \"checkpoints.h\"\n #include \"irc.h\"\n #include \"db.h\"\n #include \"net.h\"\n@@ -46,9 +47,8 @@ struct LocalServiceInfo {\n //\n // Global state variables\n //\n-bool fClient = false;\n static bool fUseUPnP = false;\n-uint64 nLocalServices = (fClient ? 0 : NODE_NETWORK);\n+uint64 nLocalServices;\n static CCriticalSection cs_mapLocalHost;\n static map<CNetAddr, LocalServiceInfo> mapLocalHost;\n static bool vfReachable[NET_MAX] = {};\n@@ -64,6 +64,7 @@ CCriticalSection cs_vNodes;\n map<CInv, CDataStream> mapRelay;\n deque<pair<int64, CInv> > vRelayExpiration;\n CCriticalSection cs_mapRelay;\n+CCriticalSection cs_mapAlreadyAskedFor;\n map<CInv, int64> mapAlreadyAskedFor;\n \n static deque<string> vOneShots;\n@@ -80,12 +81,67 @@ void AddOneShot(string strDest)\n     vOneShots.push_back(strDest);\n }\n \n+\n+\n+\n+void HandleCommitTransactionToMemoryPool(const CTransaction& tx)\n+{\n+    CInv inv(MSG_TX, tx.GetHash());\n+    RelayMessage(inv, tx);\n+\n+    LOCK(cs_mapAlreadyAskedFor);\n+    mapAlreadyAskedFor.erase(inv);\n+}\n+\n+void HandleCommitBlock(const CBlock& block)\n+{\n+    // Relay inventory, but don't relay old inventory during initial block download\n+    int nBlockEstimate = Checkpoints::GetTotalBlocksEstimate();\n+    const CBlockIndex* index = pblockstore->GetBestBlockIndex();\n+    if (*(index->phashBlock) == block.GetHash())\n+    {\n+        LOCK(cs_vNodes);\n+        BOOST_FOREACH(CNode* pnode, vNodes)\n+            if (index->nHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : nBlockEstimate))\n+                pnode->PushInventory(CInv(MSG_BLOCK, *(index->phashBlock)));\n+    }\n+}\n+\n+\n+\n+\n+\n unsigned short GetListenPort()\n {\n     return (unsigned short)(GetArg(\"-port\", GetDefaultPort()));\n }\n \n-void CNode::PushGetBlocks(CBlockIndex* pindexBegin, uint256 hashEnd)\n+void AskForBlocks(const uint256 hashEnd, const uint256 hashOriginator)\n+{\n+    CInv inv(MSG_BLOCK, hashOriginator);\n+    CNode* pnodeToAsk = NULL;\n+    {\n+        LOCK(cs_vNodes);\n+        if (hashOriginator != 0)\n+        {\n+            BOOST_FOREACH(CNode* pnode, vNodes)\n+            {\n+                if (pnode->setInventoryKnown.count(inv))\n+                {\n+                    pnodeToAsk = pnode;\n+                    break;\n+                }\n+            }\n+        }\n+        if (pnodeToAsk == NULL)\n+            pnodeToAsk = vNodes.front();\n+        pnodeToAsk->AddRef();\n+    }\n+    pnodeToAsk->PushGetBlocks(pblockstore->GetBestBlockIndex(), hashEnd);\n+    pnodeToAsk->Release();\n+}\n+\n+void CNode::PushGetBlocks(const CBlockIndex* pindexBegin, uint256 hashEnd)\n {\n     // Filter out duplicate requests\n     if (pindexBegin == pindexLastGetBlocksBegin && hashEnd == hashLastGetBlocksEnd)\n@@ -546,7 +602,7 @@ void CNode::PushVersion()\n     CAddress addrMe = GetLocalAddress(&addr);\n     RAND_bytes((unsigned char*)&nLocalHostNonce, sizeof(nLocalHostNonce));\n     PushMessage(\"version\", PROTOCOL_VERSION, nLocalServices, nTime, addrYou, addrMe,\n-                nLocalHostNonce, FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, std::vector<string>()), nBestHeight);\n+                nLocalHostNonce, FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, std::vector<string>()), pblockstore->GetBestBlockIndex()->nHeight);\n }\n \n \n@@ -1838,6 +1894,10 @@ void static Discover()\n \n void StartNode(void* parg)\n {\n+    pblockstore->RegisterCommitTransactionToMemoryPool(&HandleCommitTransactionToMemoryPool);\n+    pblockstore->RegisterCommitBlock(&HandleCommitBlock);\n+    pblockstore->RegisterAskForBlocks(&AskForBlocks);\n+\n #ifdef USE_UPNP\n #if USE_UPNP\n     fUseUPnP = GetBoolArg(\"-upnp\", true);\n@@ -1960,3 +2020,4 @@ class CNetCleanup\n     }\n }\n instance_of_cnetcleanup;\n+"
      },
      {
        "sha": "846f4c586d408f1f2f4e2d8d7aedb508d5b91953",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/000f04150d61b405b62299a74a53c7a4ba8637ad/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/000f04150d61b405b62299a74a53c7a4ba8637ad/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=000f04150d61b405b62299a74a53c7a4ba8637ad",
        "patch": "@@ -21,9 +21,8 @@\n \n class CAddrDB;\n class CRequestTracker;\n-class CNode;\n class CBlockIndex;\n-extern int nBestHeight;\n+class CTransaction;\n \n \n \n@@ -42,6 +41,7 @@ unsigned short GetListenPort();\n bool BindListenPort(const CService &bindAddr, std::string& strError=REF(std::string()));\n void StartNode(void* parg);\n bool StopNode();\n+void HandleCommitTransactionToMemoryPool(const CTransaction& tx);\n \n enum\n {\n@@ -110,7 +110,6 @@ enum threadId\n     THREAD_MAX\n };\n \n-extern bool fClient;\n extern uint64 nLocalServices;\n extern uint64 nLocalHostNonce;\n extern boost::array<int, THREAD_MAX> vnThreadsRunning;\n@@ -121,6 +120,7 @@ extern CCriticalSection cs_vNodes;\n extern std::map<CInv, CDataStream> mapRelay;\n extern std::deque<std::pair<int64, CInv> > vRelayExpiration;\n extern CCriticalSection cs_mapRelay;\n+extern CCriticalSection cs_mapAlreadyAskedFor;\n extern std::map<CInv, int64> mapAlreadyAskedFor;\n \n \n@@ -171,7 +171,7 @@ class CNode\n     std::map<uint256, CRequestTracker> mapRequests;\n     CCriticalSection cs_mapRequests;\n     uint256 hashContinue;\n-    CBlockIndex* pindexLastGetBlocksBegin;\n+    const CBlockIndex* pindexLastGetBlocksBegin;\n     uint256 hashLastGetBlocksEnd;\n     int nStartingHeight;\n \n@@ -294,6 +294,7 @@ class CNode\n     {\n         // We're using mapAskFor as a priority queue,\n         // the key is the earliest time the request can be sent\n+        LOCK(cs_mapAlreadyAskedFor);\n         int64& nRequestTime = mapAlreadyAskedFor[inv];\n         printf(\"askfor %s   %\"PRI64d\"\\n\", inv.ToString().c_str(), nRequestTime);\n \n@@ -589,7 +590,7 @@ class CNode\n \n \n \n-    void PushGetBlocks(CBlockIndex* pindexBegin, uint256 hashEnd);\n+    void PushGetBlocks(const CBlockIndex* pindexBegin, uint256 hashEnd);\n     bool IsSubscribed(unsigned int nChannel);\n     void Subscribe(unsigned int nChannel, unsigned int nHops=0);\n     void CancelSubscribe(unsigned int nChannel);"
      },
      {
        "sha": "51f7b5bdeec9e03cb19e0afbf6a799eb525b4fb7",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 831,
        "deletions": 7,
        "changes": 838,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/000f04150d61b405b62299a74a53c7a4ba8637ad/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/000f04150d61b405b62299a74a53c7a4ba8637ad/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=000f04150d61b405b62299a74a53c7a4ba8637ad",
        "patch": "@@ -6,11 +6,24 @@\n #include \"protocol.h\"\n #include \"util.h\"\n #include \"netbase.h\"\n+#include \"net.h\"\n+#include \"blockstore.h\"\n+#include \"checkpoints.h\"\n+#include \"db.h\"\n+#include \"main.h\"\n+#include \"wallet.h\"\n+#include \"init.h\"\n \n #ifndef WIN32\n # include <arpa/inet.h>\n #endif\n \n+using namespace std;\n+\n+CMedianFilter<int> cPeerBlockCounts(5, 0); // Amount of blocks that other nodes claim to have\n+\n+static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n+\n static const char* ppszTypeName[] =\n {\n     \"ERROR\",\n@@ -35,12 +48,12 @@ CMessageHeader::CMessageHeader(const char* pszCommand, unsigned int nMessageSize\n     nChecksum = 0;\n }\n \n-std::string CMessageHeader::GetCommand() const\n+string CMessageHeader::GetCommand() const\n {\n     if (pchCommand[COMMAND_SIZE-1] == 0)\n-        return std::string(pchCommand, pchCommand + strlen(pchCommand));\n+        return string(pchCommand, pchCommand + strlen(pchCommand));\n     else\n-        return std::string(pchCommand, pchCommand + COMMAND_SIZE);\n+        return string(pchCommand, pchCommand + COMMAND_SIZE);\n }\n \n bool CMessageHeader::IsValid() const\n@@ -105,7 +118,7 @@ CInv::CInv(int typeIn, const uint256& hashIn)\n     hash = hashIn;\n }\n \n-CInv::CInv(const std::string& strType, const uint256& hashIn)\n+CInv::CInv(const string& strType, const uint256& hashIn)\n {\n     unsigned int i;\n     for (i = 1; i < ARRAYLEN(ppszTypeName); i++)\n@@ -117,7 +130,7 @@ CInv::CInv(const std::string& strType, const uint256& hashIn)\n         }\n     }\n     if (i == ARRAYLEN(ppszTypeName))\n-        throw std::out_of_range(strprintf(\"CInv::CInv(string, uint256) : unknown type '%s'\", strType.c_str()));\n+        throw out_of_range(strprintf(\"CInv::CInv(string, uint256) : unknown type '%s'\", strType.c_str()));\n     hash = hashIn;\n }\n \n@@ -134,11 +147,11 @@ bool CInv::IsKnownType() const\n const char* CInv::GetCommand() const\n {\n     if (!IsKnownType())\n-        throw std::out_of_range(strprintf(\"CInv::GetCommand() : type=%d unknown type\", type));\n+        throw out_of_range(strprintf(\"CInv::GetCommand() : type=%d unknown type\", type));\n     return ppszTypeName[type];\n }\n \n-std::string CInv::ToString() const\n+string CInv::ToString() const\n {\n     return strprintf(\"%s %s\", GetCommand(), hash.ToString().substr(0,20).c_str());\n }\n@@ -148,3 +161,814 @@ void CInv::print() const\n     printf(\"CInv(%s)\\n\", ToString().c_str());\n }\n \n+// Return maximum amount of blocks that other nodes claim to have\n+int GetNumBlocksOfPeers()\n+{\n+    return std::max(cPeerBlockCounts.median(), Checkpoints::GetTotalBlocksEstimate());\n+}\n+\n+\n+\n+// The message start string is designed to be unlikely to occur in normal data.\n+// The characters are rarely used upper ascii, not valid as UTF-8, and produce\n+// a large 4-byte int at any alignment.\n+unsigned char pchMessageStart[4] = { 0xf9, 0xbe, 0xb4, 0xd9 };\n+\n+\n+bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n+{\n+    static map<CService, vector<unsigned char> > mapReuseKey;\n+    RandAddSeedPerfmon();\n+    if (fDebug)\n+        printf(\"received: %s (%d bytes)\\n\", strCommand.c_str(), vRecv.size());\n+    if (mapArgs.count(\"-dropmessagestest\") && GetRand(atoi(mapArgs[\"-dropmessagestest\"])) == 0)\n+    {\n+        printf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n+        return true;\n+    }\n+\n+\n+\n+\n+\n+    if (strCommand == \"version\")\n+    {\n+        // Each connection can only send one version message\n+        if (pfrom->nVersion != 0)\n+        {\n+            pfrom->Misbehaving(1);\n+            return false;\n+        }\n+\n+        int64 nTime;\n+        CAddress addrMe;\n+        CAddress addrFrom;\n+        uint64 nNonce = 1;\n+        vRecv >> pfrom->nVersion >> pfrom->nServices >> nTime >> addrMe;\n+        if (pfrom->nVersion < MIN_PROTO_VERSION)\n+        {\n+            // Since February 20, 2012, the protocol is initiated at version 209,\n+            // and earlier versions are no longer supported\n+            printf(\"partner %s using obsolete version %i; disconnecting\\n\", pfrom->addr.ToString().c_str(), pfrom->nVersion);\n+            pfrom->fDisconnect = true;\n+            return false;\n+        }\n+\n+        if (pfrom->nVersion == 10300)\n+            pfrom->nVersion = 300;\n+        if (!vRecv.empty())\n+            vRecv >> addrFrom >> nNonce;\n+        if (!vRecv.empty())\n+            vRecv >> pfrom->strSubVer;\n+        if (!vRecv.empty())\n+            vRecv >> pfrom->nStartingHeight;\n+\n+        if (pfrom->fInbound && addrMe.IsRoutable())\n+        {\n+            pfrom->addrLocal = addrMe;\n+            SeenLocal(addrMe);\n+        }\n+\n+        // Disconnect if we connected to ourself\n+        if (nNonce == nLocalHostNonce && nNonce > 1)\n+        {\n+            printf(\"connected to self at %s, disconnecting\\n\", pfrom->addr.ToString().c_str());\n+            pfrom->fDisconnect = true;\n+            return true;\n+        }\n+\n+        // Be shy and don't send version until we hear\n+        if (pfrom->fInbound)\n+            pfrom->PushVersion();\n+\n+        pfrom->fClient = !(pfrom->nServices & NODE_NETWORK);\n+\n+        AddTimeData(pfrom->addr, nTime);\n+\n+        // Change version\n+        pfrom->PushMessage(\"verack\");\n+        pfrom->vSend.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n+\n+        if (!pfrom->fInbound)\n+        {\n+            // Advertise our address\n+            if (!fNoListen && !fUseProxy && !pblockstore->IsInitialBlockDownload())\n+            {\n+                CAddress addr = GetLocalAddress(&pfrom->addr);\n+                if (addr.IsRoutable())\n+                    pfrom->PushAddress(addr);\n+            }\n+\n+            // Get recent addresses\n+            if (pfrom->fOneShot || pfrom->nVersion >= CADDR_TIME_VERSION || addrman.size() < 1000)\n+            {\n+                pfrom->PushMessage(\"getaddr\");\n+                pfrom->fGetAddr = true;\n+            }\n+            addrman.Good(pfrom->addr);\n+        } else {\n+            if (((CNetAddr)pfrom->addr) == (CNetAddr)addrFrom)\n+            {\n+                addrman.Add(addrFrom, addrFrom);\n+                addrman.Good(addrFrom);\n+            }\n+        }\n+\n+        // Ask the first connected node for block updates\n+        static int nAskedForBlocks = 0;\n+        if (!pfrom->fClient && !pfrom->fOneShot &&\n+            (pfrom->nVersion < NOBLKS_VERSION_START ||\n+       pfrom->nVersion >= NOBLKS_VERSION_END) &&\n+             (nAskedForBlocks < 1 || vNodes.size() <= 1))\n+        {\n+            nAskedForBlocks++;\n+            pfrom->PushGetBlocks(pblockstore->GetBestBlockIndex(), uint256(0));\n+        }\n+\n+        // Relay alerts\n+        pblockstore->RelayAlerts(pfrom);\n+\n+        pfrom->fSuccessfullyConnected = true;\n+\n+        printf(\"version message: version %d, blocks=%d\\n\", pfrom->nVersion, pfrom->nStartingHeight);\n+\n+        cPeerBlockCounts.input(pfrom->nStartingHeight);\n+    }\n+\n+\n+    else if (pfrom->nVersion == 0)\n+    {\n+        // Must have a version message before anything else\n+        pfrom->Misbehaving(1);\n+        return false;\n+    }\n+\n+\n+    else if (strCommand == \"verack\")\n+    {\n+        pfrom->vRecv.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n+    }\n+\n+\n+    else if (strCommand == \"addr\")\n+    {\n+        vector<CAddress> vAddr;\n+        vRecv >> vAddr;\n+\n+        // Don't want addr from older versions unless seeding\n+        if (pfrom->nVersion < CADDR_TIME_VERSION && addrman.size() > 1000)\n+            return true;\n+        if (vAddr.size() > 1000)\n+        {\n+            pfrom->Misbehaving(20);\n+            return error(\"message addr size() = %d\", vAddr.size());\n+        }\n+\n+        // Store the new addresses\n+        vector<CAddress> vAddrOk;\n+        int64 nNow = GetAdjustedTime();\n+        int64 nSince = nNow - 10 * 60;\n+        BOOST_FOREACH(CAddress& addr, vAddr)\n+        {\n+            if (fShutdown)\n+                return true;\n+            if (addr.nTime <= 100000000 || addr.nTime > nNow + 10 * 60)\n+                addr.nTime = nNow - 5 * 24 * 60 * 60;\n+            pfrom->AddAddressKnown(addr);\n+            bool fReachable = IsReachable(addr);\n+            if (addr.nTime > nSince && !pfrom->fGetAddr && vAddr.size() <= 10 && addr.IsRoutable())\n+            {\n+                // Relay to a limited number of other nodes\n+                {\n+                    LOCK(cs_vNodes);\n+                    // Use deterministic randomness to send to the same nodes for 24 hours\n+                    // at a time so the setAddrKnowns of the chosen nodes prevent repeats\n+                    static uint256 hashSalt;\n+                    if (hashSalt == 0)\n+                        RAND_bytes((unsigned char*)&hashSalt, sizeof(hashSalt));\n+                    int64 hashAddr = addr.GetHash();\n+                    uint256 hashRand = hashSalt ^ (hashAddr<<32) ^ ((GetTime()+hashAddr)/(24*60*60));\n+                    hashRand = Hash(BEGIN(hashRand), END(hashRand));\n+                    multimap<uint256, CNode*> mapMix;\n+                    BOOST_FOREACH(CNode* pnode, vNodes)\n+                    {\n+                        if (pnode->nVersion < CADDR_TIME_VERSION)\n+                            continue;\n+                        unsigned int nPointer;\n+                        memcpy(&nPointer, &pnode, sizeof(nPointer));\n+                        uint256 hashKey = hashRand ^ nPointer;\n+                        hashKey = Hash(BEGIN(hashKey), END(hashKey));\n+                        mapMix.insert(make_pair(hashKey, pnode));\n+                    }\n+                    int nRelayNodes = fReachable ? 2 : 1; // limited relaying of addresses outside our network(s)\n+                    for (multimap<uint256, CNode*>::iterator mi = mapMix.begin(); mi != mapMix.end() && nRelayNodes-- > 0; ++mi)\n+                        ((*mi).second)->PushAddress(addr);\n+                }\n+            }\n+            // Do not store addresses outside our network\n+            if (fReachable)\n+                vAddrOk.push_back(addr);\n+        }\n+        addrman.Add(vAddrOk, pfrom->addr, 2 * 60 * 60);\n+        if (vAddr.size() < 1000)\n+            pfrom->fGetAddr = false;\n+        if (pfrom->fOneShot)\n+            pfrom->fDisconnect = true;\n+    }\n+\n+\n+    else if (strCommand == \"inv\")\n+    {\n+        vector<CInv> vInv;\n+        vRecv >> vInv;\n+        if (vInv.size() > 50000)\n+        {\n+            pfrom->Misbehaving(20);\n+            return error(\"message inv size() = %d\", vInv.size());\n+        }\n+\n+        // find last block in inv vector\n+        unsigned int nLastBlock = (unsigned int)(-1);\n+        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++) {\n+            if (vInv[vInv.size() - 1 - nInv].type == MSG_BLOCK) {\n+                nLastBlock = vInv.size() - 1 - nInv;\n+                break;\n+            }\n+        }\n+        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++)\n+        {\n+            const CInv &inv = vInv[nInv];\n+\n+            if (fShutdown)\n+                return true;\n+            pfrom->AddInventoryKnown(inv);\n+\n+            bool fNeedInv = pblockstore->NeedInv(&inv);\n+            if (fDebug)\n+                printf(\"  got inventory: %s  %s\\n\", inv.ToString().c_str(), fNeedInv ? \"need\" : \"don't need\");\n+\n+            if (fNeedInv)\n+                pfrom->AskFor(inv);\n+            else if (nInv == nLastBlock) {\n+                // In case we are on a very long side-chain, it is possible that we already have\n+                // the last block in an inv bundle sent in response to getblocks. Try to detect\n+                // this situation and push another getblocks to continue.\n+                std::vector<CInv> vGetData(1,inv);\n+                pfrom->PushGetBlocks(pblockstore->GetBlockIndex(inv.hash), uint256(0));\n+                if (fDebug)\n+                    printf(\"force request: %s\\n\", inv.ToString().c_str());\n+            }\n+\n+            // Track requests for our stuff\n+            pblockstore->Relayed(inv.hash);\n+        }\n+    }\n+\n+\n+    else if (strCommand == \"getdata\")\n+    {\n+        vector<CInv> vInv;\n+        vRecv >> vInv;\n+        if (vInv.size() > 50000)\n+        {\n+            pfrom->Misbehaving(20);\n+            return error(\"message getdata size() = %d\", vInv.size());\n+        }\n+\n+        BOOST_FOREACH(const CInv& inv, vInv)\n+        {\n+            if (fShutdown)\n+                return true;\n+            printf(\"received getdata for: %s\\n\", inv.ToString().c_str());\n+\n+            if (inv.type == MSG_BLOCK)\n+            {\n+                if (!pblockstore->HasFullBlocks())\n+                {\n+                    pfrom->Misbehaving(10);\n+                    printf(\"recieved block getdata though we don't have blocks\");\n+                    continue;\n+                }\n+\n+                // Send block from disk\n+                const CBlockIndex* blockIndex = pblockstore->GetBlockIndex(inv.hash);\n+                if (blockIndex != NULL)\n+                {\n+                    CBlock block;\n+                    block.ReadFromDisk(blockIndex);\n+                    pfrom->PushMessage(\"block\", block);\n+\n+                    // Trigger them to send a getblocks request for the next batch of inventory\n+                    if (inv.hash == pfrom->hashContinue)\n+                    {\n+                        // Bypass PushInventory, this must send even if redundant,\n+                        // and we want it right after the last block so they don't\n+                        // wait for other stuff first.\n+                        vector<CInv> vInv;\n+                        vInv.push_back(CInv(MSG_BLOCK, *(pblockstore->GetBestBlockIndex()->phashBlock)));\n+                        pfrom->PushMessage(\"inv\", vInv);\n+                        pfrom->hashContinue = 0;\n+                    }\n+                }\n+            }\n+            else if (inv.IsKnownType())\n+            {\n+                // Send stream from relay memory\n+                {\n+                    LOCK(cs_mapRelay);\n+                    map<CInv, CDataStream>::iterator mi = mapRelay.find(inv);\n+                    if (mi != mapRelay.end())\n+                        pfrom->PushMessage(inv.GetCommand(), (*mi).second);\n+                }\n+            }\n+\n+            // Track requests for our stuff\n+            pblockstore->Relayed(inv.hash);\n+        }\n+    }\n+\n+\n+    else if (strCommand == \"getblocks\")\n+    {\n+        CBlockLocator locator;\n+        uint256 hashStop;\n+        vRecv >> locator >> hashStop;\n+\n+        // Find the last block the caller has in the main chain\n+        const CBlockIndex* pindex = locator.GetBlockIndex();\n+\n+        // Send the rest of the chain\n+        if (pindex)\n+            pindex = pindex->pnext;\n+        int nLimit = 500 + locator.GetDistanceBack();\n+        unsigned int nBytes = 0;\n+        printf(\"getblocks %d to %s limit %d\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str(), nLimit);\n+        for (; pindex; pindex = pindex->pnext)\n+        {\n+            if (pindex->GetBlockHash() == hashStop)\n+            {\n+                printf(\"  getblocks stopping at %d %s (%u bytes)\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str(), nBytes);\n+                break;\n+            }\n+            pfrom->PushInventory(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n+            CBlock block;\n+            block.ReadFromDisk(pindex, true);\n+            nBytes += block.GetSerializeSize(SER_NETWORK, PROTOCOL_VERSION);\n+            if (--nLimit <= 0 || nBytes >= SendBufferSize()/2)\n+            {\n+                // When this block is requested, we'll send an inv that'll make them\n+                // getblocks the next batch of inventory.\n+                printf(\"  getblocks stopping at limit %d %s (%u bytes)\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str(), nBytes);\n+                pfrom->hashContinue = pindex->GetBlockHash();\n+                break;\n+            }\n+        }\n+    }\n+\n+\n+    else if (strCommand == \"getheaders\")\n+    {\n+        CBlockLocator locator;\n+        uint256 hashStop;\n+        vRecv >> locator >> hashStop;\n+\n+        const CBlockIndex* pindex = NULL;\n+        if (locator.IsNull())\n+        {\n+            // If locator is null, return the hashStop block\n+            pindex = pblockstore->GetBlockIndex(hashStop);\n+            if (pindex == NULL)\n+                return true;\n+        }\n+        else\n+        {\n+            // Find the last block the caller has in the main chain\n+            pindex = locator.GetBlockIndex();\n+            if (pindex)\n+                pindex = pindex->pnext;\n+        }\n+\n+        vector<CBlock> vHeaders;\n+        int nLimit = 2000;\n+        printf(\"getheaders %d to %s\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str());\n+        for (; pindex; pindex = pindex->pnext)\n+        {\n+            vHeaders.push_back(pindex->GetBlockHeader());\n+            if (--nLimit <= 0 || pindex->GetBlockHash() == hashStop)\n+                break;\n+        }\n+        pfrom->PushMessage(\"headers\", vHeaders);\n+    }\n+\n+\n+    else if (strCommand == \"tx\")\n+    {\n+        CDataStream vMsg(vRecv);\n+        CTransaction tx;\n+        vRecv >> tx;\n+\n+        CInv inv(MSG_TX, tx.GetHash());\n+        pfrom->AddInventoryKnown(inv);\n+\n+        pblockstore->EmitTransaction(tx);\n+        if (tx.nDoS) pfrom->Misbehaving(tx.nDoS);\n+    }\n+\n+\n+    else if (strCommand == \"block\")\n+    {\n+        CBlock block;\n+        vRecv >> block;\n+\n+        printf(\"received block %s\\n\", block.GetHash().ToString().substr(0,20).c_str());\n+        // block.print();\n+\n+        CInv inv(MSG_BLOCK, block.GetHash());\n+        pfrom->AddInventoryKnown(inv);\n+\n+        if (pblockstore->EmitBlock(block))\n+        {\n+            LOCK(cs_mapAlreadyAskedFor);\n+            mapAlreadyAskedFor.erase(inv);\n+        }\n+        if (block.nDoS) pfrom->Misbehaving(block.nDoS);\n+    }\n+\n+\n+    else if (strCommand == \"getaddr\")\n+    {\n+        pfrom->vAddrToSend.clear();\n+        vector<CAddress> vAddr = addrman.GetAddr();\n+        BOOST_FOREACH(const CAddress &addr, vAddr)\n+            pfrom->PushAddress(addr);\n+    }\n+\n+\n+    else if (strCommand == \"checkorder\")\n+    {\n+        uint256 hashReply;\n+        vRecv >> hashReply;\n+\n+        if (!GetBoolArg(\"-allowreceivebyip\"))\n+        {\n+            pfrom->PushMessage(\"reply\", hashReply, (int)2, string(\"\"));\n+            return true;\n+        }\n+\n+        CWalletTx order;\n+        vRecv >> order;\n+\n+        /// we have a chance to check the order here\n+\n+        // Keep giving the same key to the same ip until they use it\n+        if (!mapReuseKey.count(pfrom->addr))\n+            pwalletMain->GetKeyFromPool(mapReuseKey[pfrom->addr], true);\n+\n+        // Send back approval of order and pubkey to use\n+        CScript scriptPubKey;\n+        scriptPubKey << mapReuseKey[pfrom->addr] << OP_CHECKSIG;\n+        pfrom->PushMessage(\"reply\", hashReply, (int)0, scriptPubKey);\n+    }\n+\n+\n+    else if (strCommand == \"reply\")\n+    {\n+        uint256 hashReply;\n+        vRecv >> hashReply;\n+\n+        CRequestTracker tracker;\n+        {\n+            LOCK(pfrom->cs_mapRequests);\n+            map<uint256, CRequestTracker>::iterator mi = pfrom->mapRequests.find(hashReply);\n+            if (mi != pfrom->mapRequests.end())\n+            {\n+                tracker = (*mi).second;\n+                pfrom->mapRequests.erase(mi);\n+            }\n+        }\n+        if (!tracker.IsNull())\n+            tracker.fn(tracker.param1, vRecv);\n+    }\n+\n+\n+    else if (strCommand == \"ping\")\n+    {\n+        if (pfrom->nVersion > BIP0031_VERSION)\n+        {\n+            uint64 nonce = 0;\n+            vRecv >> nonce;\n+            // Echo the message back with the nonce. This allows for two useful features:\n+            //\n+            // 1) A remote node can quickly check if the connection is operational\n+            // 2) Remote nodes can measure the latency of the network thread. If this node\n+            //    is overloaded it won't respond to pings quickly and the remote node can\n+            //    avoid sending us more work, like chain download requests.\n+            //\n+            // The nonce stops the remote getting confused between different pings: without\n+            // it, if the remote node sends a ping once per second and this node takes 5\n+            // seconds to respond to each, the 5th ping the remote sends would appear to\n+            // return very quickly.\n+            pfrom->PushMessage(\"pong\", nonce);\n+        }\n+    }\n+\n+\n+    else if (strCommand == \"alert\")\n+    {\n+        CAlert alert;\n+        vRecv >> alert;\n+\n+        if (pblockstore->EmitAlert(alert))\n+        {\n+            // Relay\n+            pfrom->setKnown.insert(alert.GetHash());\n+            {\n+                LOCK(cs_vNodes);\n+                BOOST_FOREACH(CNode* pnode, vNodes)\n+                    alert.RelayTo(pnode);\n+            }\n+        }\n+    }\n+\n+\n+    else\n+    {\n+        // Ignore unknown commands for extensibility\n+    }\n+\n+\n+    // Update the last seen time for this node's address\n+    if (pfrom->fNetworkNode)\n+        if (strCommand == \"version\" || strCommand == \"addr\" || strCommand == \"inv\" || strCommand == \"getdata\" || strCommand == \"ping\")\n+            AddressCurrentlyConnected(pfrom->addr);\n+\n+\n+    return true;\n+}\n+\n+bool ProcessMessages(CNode* pfrom)\n+{\n+    CDataStream& vRecv = pfrom->vRecv;\n+    if (vRecv.empty())\n+        return true;\n+    //if (fDebug)\n+    //    printf(\"ProcessMessages(%u bytes)\\n\", vRecv.size());\n+\n+    //\n+    // Message format\n+    //  (4) message start\n+    //  (12) command\n+    //  (4) size\n+    //  (4) checksum\n+    //  (x) data\n+    //\n+\n+    loop\n+    {\n+        // Scan for message start\n+        CDataStream::iterator pstart = search(vRecv.begin(), vRecv.end(), BEGIN(pchMessageStart), END(pchMessageStart));\n+        int nHeaderSize = vRecv.GetSerializeSize(CMessageHeader());\n+        if (vRecv.end() - pstart < nHeaderSize)\n+        {\n+            if ((int)vRecv.size() > nHeaderSize)\n+            {\n+                printf(\"\\n\\nPROCESSMESSAGE MESSAGESTART NOT FOUND\\n\\n\");\n+                vRecv.erase(vRecv.begin(), vRecv.end() - nHeaderSize);\n+            }\n+            break;\n+        }\n+        if (pstart - vRecv.begin() > 0)\n+            printf(\"\\n\\nPROCESSMESSAGE SKIPPED %d BYTES\\n\\n\", pstart - vRecv.begin());\n+        vRecv.erase(vRecv.begin(), pstart);\n+\n+        // Read header\n+        vector<char> vHeaderSave(vRecv.begin(), vRecv.begin() + nHeaderSize);\n+        CMessageHeader hdr;\n+        vRecv >> hdr;\n+        if (!hdr.IsValid())\n+        {\n+            printf(\"\\n\\nPROCESSMESSAGE: ERRORS IN HEADER %s\\n\\n\\n\", hdr.GetCommand().c_str());\n+            continue;\n+        }\n+        string strCommand = hdr.GetCommand();\n+\n+        // Message size\n+        unsigned int nMessageSize = hdr.nMessageSize;\n+        if (nMessageSize > MAX_SIZE)\n+        {\n+            printf(\"ProcessMessage(%s, %u bytes) : nMessageSize > MAX_SIZE\\n\", strCommand.c_str(), nMessageSize);\n+            continue;\n+        }\n+        if (nMessageSize > vRecv.size())\n+        {\n+            // Rewind and wait for rest of message\n+            vRecv.insert(vRecv.begin(), vHeaderSave.begin(), vHeaderSave.end());\n+            break;\n+        }\n+\n+        // Checksum\n+        uint256 hash = Hash(vRecv.begin(), vRecv.begin() + nMessageSize);\n+        unsigned int nChecksum = 0;\n+        memcpy(&nChecksum, &hash, sizeof(nChecksum));\n+        if (nChecksum != hdr.nChecksum)\n+        {\n+            printf(\"ProcessMessage(%s, %u bytes) : CHECKSUM ERROR nChecksum=%08x hdr.nChecksum=%08x\\n\",\n+                   strCommand.c_str(), nMessageSize, nChecksum, hdr.nChecksum);\n+            continue;\n+        }\n+\n+        // Copy message to its own buffer\n+        CDataStream vMsg(vRecv.begin(), vRecv.begin() + nMessageSize, vRecv.nType, vRecv.nVersion);\n+        vRecv.ignore(nMessageSize);\n+\n+        // Process message\n+        bool fRet = false;\n+        try\n+        {\n+            fRet = ProcessMessage(pfrom, strCommand, vMsg);\n+            if (fShutdown)\n+                return true;\n+        }\n+        catch (ios_base::failure& e)\n+        {\n+            if (strstr(e.what(), \"end of data\"))\n+            {\n+                // Allow exceptions from underlength message on vRecv\n+                printf(\"ProcessMessage(%s, %u bytes) : Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", strCommand.c_str(), nMessageSize, e.what());\n+            }\n+            else if (strstr(e.what(), \"size too large\"))\n+            {\n+                // Allow exceptions from overlong size\n+                printf(\"ProcessMessage(%s, %u bytes) : Exception '%s' caught\\n\", strCommand.c_str(), nMessageSize, e.what());\n+            }\n+            else\n+            {\n+                PrintExceptionContinue(&e, \"ProcessMessage()\");\n+            }\n+        }\n+        catch (exception& e) {\n+            PrintExceptionContinue(&e, \"ProcessMessage()\");\n+        } catch (...) {\n+            PrintExceptionContinue(NULL, \"ProcessMessage()\");\n+        }\n+\n+        if (!fRet)\n+            printf(\"ProcessMessage(%s, %u bytes) FAILED\\n\", strCommand.c_str(), nMessageSize);\n+    }\n+\n+    vRecv.Compact();\n+    return true;\n+}\n+\n+\n+bool SendMessages(CNode* pto, bool fSendTrickle)\n+{\n+    // Don't send anything until we get their version message\n+    if (pto->nVersion == 0)\n+        return true;\n+\n+    // Keep-alive ping. We send a nonce of zero because we don't use it anywhere \n+    // right now.\n+    if (pto->nLastSend && GetTime() - pto->nLastSend > 30 * 60 && pto->vSend.empty()) {\n+        if (pto->nVersion > BIP0031_VERSION)\n+            pto->PushMessage(\"ping\", 0);\n+        else\n+            pto->PushMessage(\"ping\");\n+    }\n+\n+    // Address refresh broadcast\n+    static int64 nLastRebroadcast;\n+    if (!pblockstore->IsInitialBlockDownload() && (GetTime() - nLastRebroadcast > 24 * 60 * 60))\n+    {\n+        {\n+            LOCK(cs_vNodes);\n+            BOOST_FOREACH(CNode* pnode, vNodes)\n+            {\n+                // Periodically clear setAddrKnown to allow refresh broadcasts\n+                if (nLastRebroadcast)\n+                    pnode->setAddrKnown.clear();\n+\n+                // Rebroadcast our address\n+                if (!fNoListen && !fUseProxy)\n+                {\n+                        CAddress addr = GetLocalAddress(&pnode->addr);\n+                        if (addr.IsRoutable())\n+                            pnode->PushAddress(addr);\n+                }\n+            }\n+        }\n+        nLastRebroadcast = GetTime();\n+    }\n+\n+    //\n+    // Message: addr\n+    //\n+    if (fSendTrickle)\n+    {\n+        vector<CAddress> vAddr;\n+        vAddr.reserve(pto->vAddrToSend.size());\n+        BOOST_FOREACH(const CAddress& addr, pto->vAddrToSend)\n+        {\n+            // returns true if wasn't already contained in the set\n+            if (pto->setAddrKnown.insert(addr).second)\n+            {\n+                vAddr.push_back(addr);\n+                // receiver rejects addr messages larger than 1000\n+                if (vAddr.size() >= 1000)\n+                {\n+                    pto->PushMessage(\"addr\", vAddr);\n+                    vAddr.clear();\n+                }\n+            }\n+        }\n+        pto->vAddrToSend.clear();\n+        if (!vAddr.empty())\n+            pto->PushMessage(\"addr\", vAddr);\n+    }\n+\n+\n+    //\n+    // Message: inventory\n+    //\n+    vector<CInv> vInv;\n+    vector<CInv> vInvWait;\n+    {\n+        LOCK(pto->cs_inventory);\n+        vInv.reserve(pto->vInventoryToSend.size());\n+        vInvWait.reserve(pto->vInventoryToSend.size());\n+        BOOST_FOREACH(const CInv& inv, pto->vInventoryToSend)\n+        {\n+            if (pto->setInventoryKnown.count(inv))\n+                continue;\n+\n+            // trickle out tx inv to protect privacy\n+            if (inv.type == MSG_TX && !fSendTrickle)\n+            {\n+                // 1/4 of tx invs blast to all immediately\n+                static uint256 hashSalt;\n+                if (hashSalt == 0)\n+                    RAND_bytes((unsigned char*)&hashSalt, sizeof(hashSalt));\n+                uint256 hashRand = inv.hash ^ hashSalt;\n+                hashRand = Hash(BEGIN(hashRand), END(hashRand));\n+                bool fTrickleWait = ((hashRand & 3) != 0);\n+\n+                // always trickle our own transactions\n+                if (!fTrickleWait)\n+                {\n+                    CWalletTx wtx;\n+                    if (pblockstore->IsTransactionFromMe(inv.hash))\n+                            fTrickleWait = true;\n+                }\n+\n+                if (fTrickleWait)\n+                {\n+                    vInvWait.push_back(inv);\n+                    continue;\n+                }\n+            }\n+\n+            // returns true if wasn't already contained in the set\n+            if (pto->setInventoryKnown.insert(inv).second)\n+            {\n+                vInv.push_back(inv);\n+                if (vInv.size() >= 1000)\n+                {\n+                    pto->PushMessage(\"inv\", vInv);\n+                    vInv.clear();\n+                }\n+            }\n+        }\n+        pto->vInventoryToSend = vInvWait;\n+    }\n+    if (!vInv.empty())\n+        pto->PushMessage(\"inv\", vInv);\n+\n+\n+    //\n+    // Message: getdata\n+    //\n+    vector<CInv> vGetData;\n+    int64 nNow = GetTime() * 1000000;\n+    while (!pto->mapAskFor.empty() && (*pto->mapAskFor.begin()).first <= nNow)\n+    {\n+        const CInv& inv = (*pto->mapAskFor.begin()).second;\n+        if (pblockstore->NeedInv(&inv))\n+        {\n+            printf(\"sending getdata: %s\\n\", inv.ToString().c_str());\n+            vGetData.push_back(inv);\n+            if (vGetData.size() >= 1000)\n+            {\n+                pto->PushMessage(\"getdata\", vGetData);\n+                vGetData.clear();\n+            }\n+        }\n+        LOCK(cs_mapAlreadyAskedFor);\n+        mapAlreadyAskedFor[inv] = nNow;\n+        pto->mapAskFor.erase(pto->mapAskFor.begin());\n+    }\n+    if (!vGetData.empty())\n+        pto->PushMessage(\"getdata\", vGetData);\n+\n+    return true;\n+}\n+"
      },
      {
        "sha": "3c2cf3997d8f59db98ba63d8533405f7a1141e97",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/000f04150d61b405b62299a74a53c7a4ba8637ad/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/000f04150d61b405b62299a74a53c7a4ba8637ad/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=000f04150d61b405b62299a74a53c7a4ba8637ad",
        "patch": "@@ -15,6 +15,8 @@\n #include <string>\n #include \"uint256.h\"\n \n+class CNode;\n+\n extern bool fTestNet;\n static inline unsigned short GetDefaultPort(const bool testnet = fTestNet)\n {\n@@ -126,4 +128,8 @@ class CInv\n         uint256 hash;\n };\n \n+bool ProcessMessages(CNode* pfrom);\n+bool SendMessages(CNode* pto, bool fSendTrickle);\n+int GetNumBlocksOfPeers();\n+\n #endif // __INCLUDED_PROTOCOL_H__"
      },
      {
        "sha": "fb6686f9235241b6effb928627a7167565f3b24f",
        "filename": "src/qt/clientmodel.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/000f04150d61b405b62299a74a53c7a4ba8637ad/src/qt/clientmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/000f04150d61b405b62299a74a53c7a4ba8637ad/src/qt/clientmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.cpp?ref=000f04150d61b405b62299a74a53c7a4ba8637ad",
        "patch": "@@ -23,7 +23,7 @@ int ClientModel::getNumConnections() const\n \n int ClientModel::getNumBlocks() const\n {\n-    return nBestHeight;\n+    return pblockstore->GetBestBlockIndex()->nHeight;\n }\n \n int ClientModel::getNumBlocksAtStartup()\n@@ -34,7 +34,7 @@ int ClientModel::getNumBlocksAtStartup()\n \n QDateTime ClientModel::getLastBlockDate() const\n {\n-    return QDateTime::fromTime_t(pindexBest->GetBlockTime());\n+    return QDateTime::fromTime_t(pblockstore->GetBestBlockIndex()->GetBlockTime());\n }\n \n void ClientModel::update()\n@@ -67,7 +67,7 @@ bool ClientModel::isTestNet() const\n \n bool ClientModel::inInitialBlockDownload() const\n {\n-    return IsInitialBlockDownload();\n+    return pblockstore->IsInitialBlockDownload();\n }\n \n int ClientModel::getNumBlocksOfPeers() const"
      },
      {
        "sha": "e9dde18626022be1162349c8df7ca4035fb12ac3",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/000f04150d61b405b62299a74a53c7a4ba8637ad/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/000f04150d61b405b62299a74a53c7a4ba8637ad/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=000f04150d61b405b62299a74a53c7a4ba8637ad",
        "patch": "@@ -17,7 +17,7 @@ QString TransactionDesc::FormatTxStatus(const CWalletTx& wtx)\n     if (!wtx.IsFinal())\n     {\n         if (wtx.nLockTime < LOCKTIME_THRESHOLD)\n-            return tr(\"Open for %1 blocks\").arg(nBestHeight - wtx.nLockTime);\n+            return tr(\"Open for %1 blocks\").arg(pblockstore->GetBestBlockIndex()->nHeight - wtx.nLockTime);\n         else\n             return tr(\"Open until %1\").arg(GUIUtil::dateTimeStr(wtx.nLockTime));\n     }"
      },
      {
        "sha": "421bbc61b4cbbf97ecb1ae2fad896ff3b8232751",
        "filename": "src/qt/transactionrecord.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 7,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/000f04150d61b405b62299a74a53c7a4ba8637ad/src/qt/transactionrecord.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/000f04150d61b405b62299a74a53c7a4ba8637ad/src/qt/transactionrecord.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.cpp?ref=000f04150d61b405b62299a74a53c7a4ba8637ad",
        "patch": "@@ -159,10 +159,7 @@ void TransactionRecord::updateStatus(const CWalletTx &wtx)\n     // Determine transaction status\n \n     // Find the block the tx is in\n-    CBlockIndex* pindex = NULL;\n-    std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(wtx.hashBlock);\n-    if (mi != mapBlockIndex.end())\n-        pindex = (*mi).second;\n+    const CBlockIndex* pindex = pblockstore->GetBlockIndex(wtx.hashBlock);\n \n     // Sort order, unrecorded transactions sort to the top\n     status.sortKey = strprintf(\"%010d-%01d-%010u-%03d\",\n@@ -172,14 +169,14 @@ void TransactionRecord::updateStatus(const CWalletTx &wtx)\n         idx);\n     status.confirmed = wtx.IsConfirmed();\n     status.depth = wtx.GetDepthInMainChain();\n-    status.cur_num_blocks = nBestHeight;\n+    status.cur_num_blocks = pblockstore->GetBestBlockIndex()->nHeight;\n \n     if (!wtx.IsFinal())\n     {\n         if (wtx.nLockTime < LOCKTIME_THRESHOLD)\n         {\n             status.status = TransactionStatus::OpenUntilBlock;\n-            status.open_for = nBestHeight - wtx.nLockTime;\n+            status.open_for = pblockstore->GetBestBlockIndex()->nHeight - wtx.nLockTime;\n         }\n         else\n         {\n@@ -233,7 +230,7 @@ void TransactionRecord::updateStatus(const CWalletTx &wtx)\n \n bool TransactionRecord::statusUpdateNeeded()\n {\n-    return status.cur_num_blocks != nBestHeight;\n+    return status.cur_num_blocks != pblockstore->GetBestBlockIndex()->nHeight;\n }\n \n std::string TransactionRecord::getTxID()"
      },
      {
        "sha": "ca0b19d598d83ccca3e91a288b2dc14340a80bbd",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/000f04150d61b405b62299a74a53c7a4ba8637ad/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/000f04150d61b405b62299a74a53c7a4ba8637ad/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=000f04150d61b405b62299a74a53c7a4ba8637ad",
        "patch": "@@ -115,7 +115,7 @@ WalletModel::SendCoinsReturn WalletModel::sendCoins(const QList<SendCoinsRecipie\n     }\n \n     {\n-        LOCK2(cs_main, wallet->cs_wallet);\n+        LOCK(wallet->cs_wallet);\n \n         // Sendmany\n         std::vector<std::pair<CScript, int64> > vecSend;"
      },
      {
        "sha": "e0cd982c3c1b42034aa2ec405cb424323371845e",
        "filename": "src/rpcdump.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/000f04150d61b405b62299a74a53c7a4ba8637ad/src/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/000f04150d61b405b62299a74a53c7a4ba8637ad/src/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcdump.cpp?ref=000f04150d61b405b62299a74a53c7a4ba8637ad",
        "patch": "@@ -61,15 +61,15 @@ Value importprivkey(const Array& params, bool fHelp)\n     CBitcoinAddress vchAddress = CBitcoinAddress(key.GetPubKey());\n \n     {\n-        LOCK2(cs_main, pwalletMain->cs_wallet);\n+        LOCK(pwalletMain->cs_wallet);\n \n         pwalletMain->MarkDirty();\n         pwalletMain->SetAddressBookName(vchAddress, strLabel);\n \n         if (!pwalletMain->AddKey(key))\n             throw JSONRPCError(-4,\"Error adding key to wallet\");\n \n-        pwalletMain->ScanForWalletTransactions(pindexGenesisBlock, true);\n+        pwalletMain->ScanForWalletTransactions(pblockstore->GetGenesisBlockIndex(), true);\n         pwalletMain->ReacceptWalletTransactions();\n     }\n "
      },
      {
        "sha": "2d2509d58836740f5768f1106157f7917435749c",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 13,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/000f04150d61b405b62299a74a53c7a4ba8637ad/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/000f04150d61b405b62299a74a53c7a4ba8637ad/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=000f04150d61b405b62299a74a53c7a4ba8637ad",
        "patch": "@@ -13,10 +13,10 @@\n #include <stdint.h>\n \n // Tests this internal-to-main.cpp method:\n-extern void AddOrphanTx(const CDataStream& vMsg);\n+extern void AddOrphanTx(const CTransaction& tx);\n extern unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans);\n-extern std::map<uint256, CDataStream*> mapOrphanTransactions;\n-extern std::multimap<uint256, CDataStream*> mapOrphanTransactionsByPrev;\n+extern std::map<uint256, CTransaction*> mapOrphanTransactions;\n+extern std::multimap<uint256, CTransaction*> mapOrphanTransactionsByPrev;\n \n CService ip(uint32_t i)\n {\n@@ -139,13 +139,12 @@ static uint256 RandomHash()\n \n CTransaction RandomOrphan()\n {\n-    std::map<uint256, CDataStream*>::iterator it;\n+    std::map<uint256, CTransaction*>::iterator it;\n     it = mapOrphanTransactions.lower_bound(RandomHash());\n     if (it == mapOrphanTransactions.end())\n         it = mapOrphanTransactions.begin();\n-    const CDataStream* pvMsg = it->second;\n-    CTransaction tx;\n-    CDataStream(*pvMsg) >> tx;\n+    const CTransaction* pTx = it->second;\n+    CTransaction tx(*pTx);\n     return tx;\n }\n \n@@ -168,9 +167,7 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n         tx.vout[0].nValue = 1*CENT;\n         tx.vout[0].scriptPubKey.SetBitcoinAddress(key.GetPubKey());\n \n-        CDataStream ds(SER_DISK, CLIENT_VERSION);\n-        ds << tx;\n-        AddOrphanTx(ds);\n+        AddOrphanTx(tx);\n     }\n \n     // ... and 50 that depend on other orphans:\n@@ -187,9 +184,7 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n         tx.vout[0].scriptPubKey.SetBitcoinAddress(key.GetPubKey());\n         SignSignature(keystore, txPrev, tx, 0);\n \n-        CDataStream ds(SER_DISK, CLIENT_VERSION);\n-        ds << tx;\n-        AddOrphanTx(ds);\n+        AddOrphanTx(tx);\n     }\n \n     // Test LimitOrphanTxSize() function:"
      },
      {
        "sha": "f1b227b4e4f61d661410dd78269807fa46e625b8",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/000f04150d61b405b62299a74a53c7a4ba8637ad/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/000f04150d61b405b62299a74a53c7a4ba8637ad/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=000f04150d61b405b62299a74a53c7a4ba8637ad",
        "patch": "@@ -11,7 +11,10 @@ struct TestingSetup {\n     TestingSetup() {\n         fPrintToConsole = true; // don't want to write to debug.log file\n         pwalletMain = new CWallet();\n-        RegisterWallet(pwalletMain);\n+        //pblockstore = new CBlockStore();\n+        //if (!CreateThread(ProcessCallbacks, pblockstore))\n+        //    wxMessageBox(_(\"Error: CreateThread(ProcessCallbacks) failed\"), \"Bitcoin\");\n+        //pwalletMain->RegisterWithBlockStore(pblockstore);\n     }\n     ~TestingSetup()\n     {"
      },
      {
        "sha": "ca2225caf985e28ff5e37126cd4422739ace9dad",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 54,
        "deletions": 14,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/000f04150d61b405b62299a74a53c7a4ba8637ad/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/000f04150d61b405b62299a74a53c7a4ba8637ad/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=000f04150d61b405b62299a74a53c7a4ba8637ad",
        "patch": "@@ -11,6 +11,24 @@\n using namespace std;\n \n \n+//////////////////////////////////////////////////////////////////////////////\n+//\n+//  CBlockStore handling\n+//\n+\n+void CWallet::RegisterWithBlockStore(CBlockStore* pBlockStoreToRegisterWith)\n+{\n+    if (!pBlockStoreToCall)\n+        pBlockStoreToCall = pBlockStoreToRegisterWith;\n+    pBlockStoreToRegisterWith->RegisterRelayedNotification(boost::bind(&CWallet::Inventory, this, _1));\n+    pBlockStoreToRegisterWith->RegisterIsTransactionFromMe(boost::bind(&CWallet::IsFromMe, this, _1));\n+    pBlockStoreToRegisterWith->RegisterIsTransactionFromMeByHash(boost::bind(&CWallet::IsFromMeByHash, this, _1));\n+    pBlockStoreToRegisterWith->RegisterCommitTransactionToMemoryPool(boost::bind(&CWallet::HandleCommitTransactionToMemoryPool, this, _1));\n+    pBlockStoreToRegisterWith->RegisterCommitBlock(boost::bind(&CWallet::HandleCommitBlock, this, _1));\n+    pBlockStoreToRegisterWith->RegisterTransactionReplaced(boost::bind(&CWallet::EraseFromWallet, this, _1));\n+}\n+\n+\n //////////////////////////////////////////////////////////////////////////////\n //\n // mapWallet\n@@ -408,6 +426,27 @@ bool CWallet::AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pbl\n     return false;\n }\n \n+void CWallet::HandleCommitBlock(const CBlock& block)\n+{\n+    BOOST_FOREACH(const CTransaction& tx, block.vtx)\n+        AddToWalletIfInvolvingMe(tx, &block, true);\n+\n+    // we can write best chain locator more often because its in a separate thread from the actual chain download\n+    if (!pblockstore->IsInitialBlockDownload() || pblockstore->GetBestBlockIndex()->nHeight % 500 == 0)\n+    {\n+        const CBlockLocator locator(pblockstore->GetBestBlockIndex());\n+        SetBestChain(locator);\n+    }\n+\n+    // Notify UI to display prev block's coinbase if it was ours\n+    static uint256 hashPrevBestCoinBase;\n+    UpdatedTransaction(hashPrevBestCoinBase);\n+    hashPrevBestCoinBase = block.vtx[0].GetHash();\n+\n+    // Resend wallet transactions on each new block since it doesn't have to happen often anyway\n+    ResendWalletTransactions();\n+}\n+\n bool CWallet::EraseFromWallet(uint256 hash)\n {\n     if (!fFileBacked)\n@@ -640,7 +679,7 @@ void CWalletTx::AddSupportingTransactions(CTxDB& txdb)\n                 {\n                     tx = *mapWalletPrev[hash];\n                 }\n-                else if (!fClient && txdb.ReadDiskTx(hash, tx))\n+                else if (pblockstore->HasFullBlocks() && txdb.ReadDiskTx(hash, tx))\n                 {\n                     ;\n                 }\n@@ -673,11 +712,11 @@ bool CWalletTx::WriteToDisk()\n // Scan the block chain (starting in pindexStart) for transactions\n // from or to us. If fUpdate is true, found transactions that already\n // exist in the wallet will be updated.\n-int CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n+int CWallet::ScanForWalletTransactions(const CBlockIndex* pindexStart, bool fUpdate)\n {\n     int ret = 0;\n \n-    CBlockIndex* pindex = pindexStart;\n+    const CBlockIndex* pindex = pindexStart;\n     {\n         LOCK(cs_wallet);\n         while (pindex)\n@@ -757,7 +796,7 @@ void CWallet::ReacceptWalletTransactions()\n         if (!vMissingTx.empty())\n         {\n             // TODO: optimize this to scan just part of the block chain?\n-            if (ScanForWalletTransactions(pindexGenesisBlock))\n+            if (ScanForWalletTransactions(pblockstore->GetGenesisBlockIndex()))\n                 fRepeat = true;  // Found missing transactions: re-do Reaccept.\n         }\n     }\n@@ -1159,7 +1198,7 @@ bool CWallet::CreateTransaction(CScript scriptPubKey, int64 nValue, CWalletTx& w\n bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n {\n     {\n-        LOCK2(cs_main, cs_wallet);\n+        LOCK(cs_wallet);\n         printf(\"CommitTransaction:\\n%s\", wtxNew.ToString().c_str());\n         {\n             // This is only to keep the database open to defeat the auto-flush for the\n@@ -1193,7 +1232,7 @@ bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n         mapRequestCount[wtxNew.GetHash()] = 0;\n \n         // Broadcast\n-        if (!wtxNew.AcceptToMemoryPool())\n+        if (!pblockstore->EmitTransaction((CTransaction&)wtxNew))\n         {\n             // This must not fail. The transaction has already been signed and recorded.\n             printf(\"CommitTransaction() : Error: Transaction not valid\");\n@@ -1319,6 +1358,15 @@ void CWallet::PrintWallet(const CBlock& block)\n     printf(\"\\n\");\n }\n \n+bool CWallet::IsFromMeByHash(const uint256 hash) const\n+{\n+    LOCK(cs_wallet);\n+    map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(hash);\n+    if (mi != mapWallet.end())\n+        return (*mi).second.fFromMe;\n+    return false;\n+}\n+\n bool CWallet::GetTransaction(const uint256 &hashTx, CWalletTx& wtx)\n {\n     {\n@@ -1344,14 +1392,6 @@ bool CWallet::SetDefaultKey(const std::vector<unsigned char> &vchPubKey)\n     return true;\n }\n \n-bool GetWalletFile(CWallet* pwallet, string &strWalletFileOut)\n-{\n-    if (!pwallet->fFileBacked)\n-        return false;\n-    strWalletFileOut = pwallet->strWalletFile;\n-    return true;\n-}\n-\n //\n // Mark old keypool keys as used,\n // and generate all new keys"
      },
      {
        "sha": "650589abfacab6723dd6074fd6ef6897e9692774",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 14,
        "deletions": 3,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/000f04150d61b405b62299a74a53c7a4ba8637ad/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/000f04150d61b405b62299a74a53c7a4ba8637ad/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=000f04150d61b405b62299a74a53c7a4ba8637ad",
        "patch": "@@ -70,6 +70,8 @@ class CWallet : public CCryptoKeyStore\n     // the maxmimum wallet format version: memory-only variable that specifies to what version this wallet may be upgraded\n     int nWalletMaxVersion;\n \n+    CBlockStore* pBlockStoreToCall;\n+\n public:\n     mutable CCriticalSection cs_wallet;\n \n@@ -90,6 +92,7 @@ class CWallet : public CCryptoKeyStore\n         fFileBacked = false;\n         nMasterKeyMaxID = 0;\n         pwalletdbEncryption = NULL;\n+        pBlockStoreToCall = NULL;\n     }\n     CWallet(std::string strWalletFileIn)\n     {\n@@ -99,8 +102,12 @@ class CWallet : public CCryptoKeyStore\n         fFileBacked = true;\n         nMasterKeyMaxID = 0;\n         pwalletdbEncryption = NULL;\n+        pBlockStoreToCall = NULL;\n     }\n \n+    // Registers with the specified blockstore, and sets pBlockStoreToCall to pBlockStoreToRegisterWith if its not already set\n+    void RegisterWithBlockStore(CBlockStore* pBlockStoreToRegisterWith);\n+\n     std::map<uint256, CWalletTx> mapWallet;\n     std::vector<uint256> vWalletUpdated;\n \n@@ -137,9 +144,14 @@ class CWallet : public CCryptoKeyStore\n     void MarkDirty();\n     bool AddToWallet(const CWalletTx& wtxIn);\n     bool AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pblock, bool fUpdate = false, bool fFindBlock = false);\n+    void HandleCommitBlock(const CBlock& block);\n+    void HandleCommitTransactionToMemoryPool(const CTransaction& tx)\n+    {\n+        AddToWalletIfInvolvingMe(tx, NULL, true);\n+    }\n     bool EraseFromWallet(uint256 hash);\n     void WalletUpdateSpent(const CTransaction& prevout);\n-    int ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate = false);\n+    int ScanForWalletTransactions(const CBlockIndex* pindexStart, bool fUpdate = false);\n     int ScanForWalletTransaction(const uint256& hashTx);\n     void ReacceptWalletTransactions();\n     void ResendWalletTransactions();\n@@ -191,6 +203,7 @@ class CWallet : public CCryptoKeyStore\n     {\n         return (GetDebit(tx) > 0);\n     }\n+    bool IsFromMeByHash(const uint256 hash) const;\n     int64 GetDebit(const CTransaction& tx) const\n     {\n         int64 nDebit = 0;\n@@ -697,6 +710,4 @@ class CAccountingEntry\n     )\n };\n \n-bool GetWalletFile(CWallet* pwallet, std::string &strWalletFileOut);\n-\n #endif"
      }
    ]
  },
  {
    "sha": "b421ce6fcb0c4fcada193df3ed07a76d89bdcdec",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNDIxY2U2ZmNiMGM0ZmNhZGExOTNkZjNlZDA3YTc2ZDg5YmRjZGVj",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2012-01-19T22:32:00Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2012-05-18T03:13:30Z"
      },
      "message": "A start on SPV mode for a CBlockStore-based bitcoin.\n\nYou can enable \"SPV Mode\" by changing HasFullBlocks() to return\nfalse in src/blockstore.h.\n\nIn \"SPV Mode\", blocks are still written to disk, but if any code\nattempts to read blocks, bitcoin will assert fail.\n\nThis is not a complete implementation of non-block-reading\n\"SPV Mode\", it is just the fixing of areas of code which read\nblocks when I tested it.",
      "tree": {
        "sha": "e1f2bfc14a7762bd269b5cdb7c042a7e6ee84cd3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e1f2bfc14a7762bd269b5cdb7c042a7e6ee84cd3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b421ce6fcb0c4fcada193df3ed07a76d89bdcdec",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b421ce6fcb0c4fcada193df3ed07a76d89bdcdec",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b421ce6fcb0c4fcada193df3ed07a76d89bdcdec",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b421ce6fcb0c4fcada193df3ed07a76d89bdcdec/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "000f04150d61b405b62299a74a53c7a4ba8637ad",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/000f04150d61b405b62299a74a53c7a4ba8637ad",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/000f04150d61b405b62299a74a53c7a4ba8637ad"
      }
    ],
    "stats": {
      "total": 188,
      "additions": 105,
      "deletions": 83
    },
    "files": [
      {
        "sha": "6bd0b70bf34c39774a7db6c39733d58134cccdcb",
        "filename": "src/bitcoinrpc.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b421ce6fcb0c4fcada193df3ed07a76d89bdcdec/src/bitcoinrpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b421ce6fcb0c4fcada193df3ed07a76d89bdcdec/src/bitcoinrpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.cpp?ref=b421ce6fcb0c4fcada193df3ed07a76d89bdcdec",
        "patch": "@@ -2225,6 +2225,9 @@ Value getblock(const Array& params, bool fHelp)\n             \"getblock <hash> [decompositions]\\n\"\n             \"Returns details of a block with given block-hash.\");\n \n+    if (!pblockstore->HasFullBlocks())\n+        throw JSONRPCError(-18, \"Bitcoin does not have full blocks for transaction verification...\");\n+\n     std::string strHash = params[0].get_str();\n     uint256 hash(strHash);\n "
      },
      {
        "sha": "e7acf2cc70ab2ef378724480e769b5c24b0651b4",
        "filename": "src/blockstore.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b421ce6fcb0c4fcada193df3ed07a76d89bdcdec/src/blockstore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b421ce6fcb0c4fcada193df3ed07a76d89bdcdec/src/blockstore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockstore.h?ref=b421ce6fcb0c4fcada193df3ed07a76d89bdcdec",
        "patch": "@@ -79,6 +79,7 @@ class CBlockStore\n     void RegisterCommitBlock(boost::function<void (const CBlock&)> func) { sigCommitBlock.connect(func); }\n \n     // Register a handler (of the form void f(const CTransaction& block)) to be called after every transaction commit to memory pool\n+    //   CommitTransactionToMemoryPool is called even when !HasFullBlocks() and txes should NOT be forwarded in that case.\n     void RegisterCommitTransactionToMemoryPool(boost::function<void (const CTransaction&)> func) { sigCommitTransactionToMemoryPool.connect(func); }\n \n     // Register a handler (of the form void f(const uint256)) to be called when a transaciton is replaced"
      },
      {
        "sha": "953859a34c26b3c4c2ca8c54e278bff073210784",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b421ce6fcb0c4fcada193df3ed07a76d89bdcdec/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b421ce6fcb0c4fcada193df3ed07a76d89bdcdec/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=b421ce6fcb0c4fcada193df3ed07a76d89bdcdec",
        "patch": "@@ -500,9 +500,9 @@ bool AppInit2()\n         if (walletdb.ReadBestBlock(locator))\n             pindexRescan = locator.GetBlockIndex();\n     }\n-    if (pblockstore->GetBestBlockIndex() != pindexRescan)\n+    //TODO: support downloading blocks that are needed for a rescan\n+    if (pblockstore->HasFullBlocks() && pblockstore->GetBestBlockIndex() != pindexRescan)\n     {\n-        assert(pblockstore->HasFullBlocks());\n         InitMessage(_(\"Rescanning...\"));\n         printf(\"Rescanning last %i blocks (from block %i)...\\n\", pblockstore->GetBestBlockIndex()->nHeight - pindexRescan->nHeight, pindexRescan->nHeight);\n         nStart = GetTimeMillis();\n@@ -524,7 +524,9 @@ bool AppInit2()\n         return InitError(strErrors.str());\n \n     // Add wallet transactions that aren't already in a block to mapTransactions\n-    pwalletMain->ReacceptWalletTransactions();\n+    // TODO Implement this for SPV mode?\n+    if (pblockstore->HasFullBlocks())\n+        pwalletMain->ReacceptWalletTransactions();\n \n     // Note: Bitcoin-QT stores several settings in the wallet, so we want\n     // to load the wallet BEFORE parsing command-line arguments, so"
      },
      {
        "sha": "4b5224f70b62faab9c61931825b117b48d2e1835",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 83,
        "deletions": 76,
        "changes": 159,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b421ce6fcb0c4fcada193df3ed07a76d89bdcdec/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b421ce6fcb0c4fcada193df3ed07a76d89bdcdec/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=b421ce6fcb0c4fcada193df3ed07a76d89bdcdec",
        "patch": "@@ -383,8 +383,9 @@ bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n         return error(\"CTxMemPool::accept() : CheckTransaction failed\");\n \n     // Coinbase is only valid in a block, not as a loose transaction\n-    if (tx.IsCoinBase())\n-        return tx.DoS(100, error(\"CTxMemPool::accept() : coinbase as individual tx\"));\n+    if (pblockstore->HasFullBlocks())\n+        if (tx.IsCoinBase())\n+            return tx.DoS(100, error(\"CTxMemPool::accept() : coinbase as individual tx\"));\n \n     // To help v0.1.5 clients who would see it as a negative number\n     if ((int64)tx.nLockTime > std::numeric_limits<int>::max())\n@@ -611,27 +612,6 @@ int CMerkleTx::GetBlocksToMaturity() const\n }\n \n \n-bool CMerkleTx::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs)\n-{\n-    if (!pblockstore->HasFullBlocks())\n-    {\n-        if (!IsInMainChain() && !ClientConnectInputs())\n-            return false;\n-        return CTransaction::AcceptToMemoryPool(txdb, false);\n-    }\n-    else\n-    {\n-        return CTransaction::AcceptToMemoryPool(txdb, fCheckInputs);\n-    }\n-}\n-\n-bool CMerkleTx::AcceptToMemoryPool()\n-{\n-    CTxDB txdb(\"r\");\n-    return AcceptToMemoryPool(txdb);\n-}\n-\n-\n \n bool CWalletTx::AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs)\n {\n@@ -1205,10 +1185,10 @@ bool CBlock::DisconnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n     return true;\n }\n \n-bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n+bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex, bool fHeadersOnly)\n {\n     // Check it again in case a previous version let a bad block in\n-    if (!CheckBlock())\n+    if (!CheckBlock(fHeadersOnly))\n         return false;\n \n     // Do not allow blocks that contain transactions which 'overwrite' older transactions,\n@@ -1255,7 +1235,7 @@ bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n         nTxPos += ::GetSerializeSize(tx, SER_DISK, CLIENT_VERSION);\n \n         MapPrevTx mapInputs;\n-        if (!tx.IsCoinBase())\n+        if (!tx.IsCoinBase() && pblockstore->HasFullBlocks())\n         {\n             bool fInvalid;\n             if (!tx.FetchInputs(txdb, mapQueuedChanges, true, false, mapInputs, fInvalid))\n@@ -1277,18 +1257,23 @@ bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n                 return false;\n         }\n \n-        mapQueuedChanges[tx.GetHash()] = CTxIndex(posThisTx, tx.vout.size());\n+        if (pblockstore->HasFullBlocks())\n+            mapQueuedChanges[tx.GetHash()] = CTxIndex(posThisTx, tx.vout.size());\n     }\n \n-    // Write queued txindex changes\n-    for (map<uint256, CTxIndex>::iterator mi = mapQueuedChanges.begin(); mi != mapQueuedChanges.end(); ++mi)\n+    if (pblockstore->HasFullBlocks())\n     {\n-        if (!txdb.UpdateTxIndex((*mi).first, (*mi).second))\n-            return error(\"ConnectBlock() : UpdateTxIndex failed\");\n-    }\n+        // Write queued txindex changes\n+        for (map<uint256, CTxIndex>::iterator mi = mapQueuedChanges.begin(); mi != mapQueuedChanges.end(); ++mi)\n+        {\n+            if (!txdb.UpdateTxIndex((*mi).first, (*mi).second))\n+                return error(\"ConnectBlock() : UpdateTxIndex failed\");\n+        }\n \n-    if (vtx[0].GetValueOut() > GetBlockValue(pindex->nHeight, nFees))\n-        return false;\n+        // No way to calculate fees on a node which doesnt have a full blockstore\n+        if (vtx[0].GetValueOut() > GetBlockValue(pindex->nHeight, nFees))\n+            return false;\n+    }\n \n     // Update block index on disk without changing it in memory.\n     // The memory index structure will be changed after the db commits.\n@@ -1340,7 +1325,7 @@ bool static Reorganize(CTxDB& txdb, CBlockIndex* pindexNew)\n     BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)\n     {\n         CBlock block;\n-        if (!block.ReadFromDisk(pindex))\n+        if (!block.ReadFromDisk(pindex, pblockstore->HasFullBlocks()))\n             return error(\"Reorganize() : ReadFromDisk for disconnect failed\");\n         if (!block.DisconnectBlock(txdb, pindex))\n             return error(\"Reorganize() : DisconnectBlock %s failed\", pindex->GetBlockHash().ToString().substr(0,20).c_str());\n@@ -1357,9 +1342,9 @@ bool static Reorganize(CTxDB& txdb, CBlockIndex* pindexNew)\n     {\n         CBlockIndex* pindex = vConnect[i];\n         CBlock block;\n-        if (!block.ReadFromDisk(pindex))\n+        if(!block.ReadFromDisk(pindex, pblockstore->HasFullBlocks()))\n             return error(\"Reorganize() : ReadFromDisk for connect failed\");\n-        if (!block.ConnectBlock(txdb, pindex))\n+        if (!block.ConnectBlock(txdb, pindex, true))\n         {\n             // Invalid block\n             txdb.TxnAbort();\n@@ -1540,14 +1525,20 @@ bool CBlock::AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos)\n \n \n \n-bool CBlock::CheckBlock() const\n+bool CBlock::CheckBlock(bool fHeadersOnly) const\n {\n     // These are checks that are independent of context\n     // that can be verified before saving an orphan block.\n \n     // Size limits\n-    if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n-        return DoS(100, error(\"CheckBlock() : size limits failed\"));\n+    if (!fHeadersOnly)\n+    {\n+        if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n+            return DoS(100, error(\"CheckBlock() : size limits failed\"));\n+    }else{\n+        if (vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n+            return DoS(100, error(\"CheckBlock() : size limits failed\"));\n+    }\n \n     // Check proof of work matches claimed amount\n     if (!CheckProofOfWork(GetHash(), nBits))\n@@ -1558,38 +1549,41 @@ bool CBlock::CheckBlock() const\n         return error(\"CheckBlock() : block timestamp too far in the future\");\n \n     // First transaction must be coinbase, the rest must not be\n-    if (vtx.empty() || !vtx[0].IsCoinBase())\n-        return DoS(100, error(\"CheckBlock() : first tx is not coinbase\"));\n-    for (unsigned int i = 1; i < vtx.size(); i++)\n-        if (vtx[i].IsCoinBase())\n-            return DoS(100, error(\"CheckBlock() : more than one coinbase\"));\n-\n-    // Check transactions\n-    BOOST_FOREACH(const CTransaction& tx, vtx)\n-        if (!tx.CheckTransaction())\n-            return DoS(tx.nDoS, error(\"CheckBlock() : CheckTransaction failed\"));\n+    if (!fHeadersOnly)\n+    {\n+        if (vtx.empty() || !vtx[0].IsCoinBase())\n+            return DoS(100, error(\"CheckBlock() : first tx is not coinbase\"));\n+        for (unsigned int i = 1; i < vtx.size(); i++)\n+            if (vtx[i].IsCoinBase())\n+                return DoS(100, error(\"CheckBlock() : more than one coinbase\"));\n+\n+        // Check transactions\n+        BOOST_FOREACH(const CTransaction& tx, vtx)\n+            if (!tx.CheckTransaction())\n+                return DoS(tx.nDoS, error(\"CheckBlock() : CheckTransaction failed\"));\n+\n+        // Check for duplicate txids. This is caught by ConnectInputs(),\n+        // but catching it earlier avoids a potential DoS attack:\n+        set<uint256> uniqueTx;\n+        BOOST_FOREACH(const CTransaction& tx, vtx)\n+        {\n+            uniqueTx.insert(tx.GetHash());\n+        }\n+        if (uniqueTx.size() != vtx.size())\n+            return DoS(100, error(\"CheckBlock() : duplicate transaction\"));\n \n-    // Check for duplicate txids. This is caught by ConnectInputs(),\n-    // but catching it earlier avoids a potential DoS attack:\n-    set<uint256> uniqueTx;\n-    BOOST_FOREACH(const CTransaction& tx, vtx)\n-    {\n-        uniqueTx.insert(tx.GetHash());\n-    }\n-    if (uniqueTx.size() != vtx.size())\n-        return DoS(100, error(\"CheckBlock() : duplicate transaction\"));\n+        unsigned int nSigOps = 0;\n+        BOOST_FOREACH(const CTransaction& tx, vtx)\n+        {\n+            nSigOps += tx.GetLegacySigOpCount();\n+        }\n+        if (nSigOps > MAX_BLOCK_SIGOPS)\n+            return DoS(100, error(\"CheckBlock() : out-of-bounds SigOpCount\"));\n \n-    unsigned int nSigOps = 0;\n-    BOOST_FOREACH(const CTransaction& tx, vtx)\n-    {\n-        nSigOps += tx.GetLegacySigOpCount();\n+        // Check merkleroot\n+        if (hashMerkleRoot != BuildMerkleTree())\n+            return DoS(100, error(\"CheckBlock() : hashMerkleRoot mismatch\"));\n     }\n-    if (nSigOps > MAX_BLOCK_SIGOPS)\n-        return DoS(100, error(\"CheckBlock() : out-of-bounds SigOpCount\"));\n-\n-    // Check merkleroot\n-    if (hashMerkleRoot != BuildMerkleTree())\n-        return DoS(100, error(\"CheckBlock() : hashMerkleRoot mismatch\"));\n \n     return true;\n }\n@@ -2152,21 +2146,29 @@ bool CBlockStore::NeedInv(const CInv* pinv)\n {\n     {\n         LOCK(cs_main);\n-        CTxDB txdb(\"r\");\n         switch (pinv->type)\n         {\n         case MSG_TX:\n             {\n+            if (pblockstore->IsInitialBlockDownload())\n+                return false;\n+\n             bool txNotInMap = false;\n                 {\n                 LOCK(mempool.cs);\n                 txNotInMap = !(mempool.exists(pinv->hash));\n                 }\n-            if (pblockstore->IsInitialBlockDownload())\n-                return false;\n-            return txNotInMap &&\n-                   !mapOrphanTransactions.count(pinv->hash) &&\n-                   !txdb.ContainsTx(pinv->hash);\n+\n+            if (pblockstore->HasFullBlocks())\n+            {\n+                CTxDB txdb(\"r\");\n+                return txNotInMap &&\n+                       !mapOrphanTransactions.count(pinv->hash) &&\n+                       !txdb.ContainsTx(pinv->hash);\n+            }\n+            else\n+                return txNotInMap &&\n+                       !mapOrphanTransactions.count(pinv->hash);\n             }\n         case MSG_BLOCK:\n             if (mapOrphanBlocks.count(pinv->hash))\n@@ -2780,11 +2782,16 @@ bool CBlockStore::EmitTransaction(CTransaction& transaction)\n {\n     {\n         LOCK(cs_main);\n+\n+        if (!pblockstore->HasFullBlocks())\n+            if (!transaction.ClientConnectInputs())\n+                return false;\n+\n         vector<uint256> vWorkQueue;\n         CTxDB txdb(\"r\");\n         bool fMissingInputs = false;\n \n-        if (transaction.AcceptToMemoryPool(txdb, true, &fMissingInputs))\n+        if (transaction.AcceptToMemoryPool(txdb, pblockstore->HasFullBlocks(), &fMissingInputs))\n         {\n             {\n                 LOCK(cs_callbacks);"
      },
      {
        "sha": "2a1f62cc16ee68b3a124487c90f0c60e79b26e67",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b421ce6fcb0c4fcada193df3ed07a76d89bdcdec/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b421ce6fcb0c4fcada193df3ed07a76d89bdcdec/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=b421ce6fcb0c4fcada193df3ed07a76d89bdcdec",
        "patch": "@@ -702,8 +702,6 @@ class CMerkleTx : public CTransaction\n     int GetDepthInMainChain() const { CBlockIndex *pindexRet; return GetDepthInMainChain(pindexRet); }\n     bool IsInMainChain() const { return GetDepthInMainChain() > 0; }\n     int GetBlocksToMaturity() const;\n-    bool AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs=true);\n-    bool AcceptToMemoryPool();\n };\n \n \n@@ -949,11 +947,11 @@ class CBlock\n \n \n     bool DisconnectBlock(CTxDB& txdb, CBlockIndex* pindex);\n-    bool ConnectBlock(CTxDB& txdb, CBlockIndex* pindex);\n+    bool ConnectBlock(CTxDB& txdb, CBlockIndex* pindex, bool fHeadersOnly=false);\n     bool ReadFromDisk(const CBlockIndex* pindex, bool fReadTransactions=true);\n     bool SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew);\n     bool AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos);\n-    bool CheckBlock() const;\n+    bool CheckBlock(bool fHeadersOnly=false) const;\n     bool AcceptBlock();\n \n private:"
      },
      {
        "sha": "76af9c6018b15265d5ac5be1bde15b0eada6e586",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b421ce6fcb0c4fcada193df3ed07a76d89bdcdec/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b421ce6fcb0c4fcada193df3ed07a76d89bdcdec/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=b421ce6fcb0c4fcada193df3ed07a76d89bdcdec",
        "patch": "@@ -86,6 +86,8 @@ void AddOneShot(string strDest)\n \n void HandleCommitTransactionToMemoryPool(const CTransaction& tx)\n {\n+    if (!pblockstore->HasFullBlocks())\n+        return;\n     CInv inv(MSG_TX, tx.GetHash());\n     RelayMessage(inv, tx);\n "
      },
      {
        "sha": "d7ed5123bb038207e45bf180028dd1ce597c8b7a",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b421ce6fcb0c4fcada193df3ed07a76d89bdcdec/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b421ce6fcb0c4fcada193df3ed07a76d89bdcdec/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=b421ce6fcb0c4fcada193df3ed07a76d89bdcdec",
        "patch": "@@ -745,6 +745,7 @@ int CWallet::ScanForWalletTransaction(const uint256& hashTx)\n \n void CWallet::ReacceptWalletTransactions()\n {\n+    assert(pblockstore->HasFullBlocks());\n     CTxDB txdb(\"r\");\n     bool fRepeat = true;\n     while (fRepeat)\n@@ -1231,6 +1232,14 @@ bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n         // Track how many getdata requests our transaction gets\n         mapRequestCount[wtxNew.GetHash()] = 0;\n \n+        // Add previous supporting transactions first (in case we are running in SPV mode, in\n+        // which case the lack of these transactions might result in a failure to AddToMemoryPool)\n+        if (!pblockstore->HasFullBlocks())\n+        {\n+            BOOST_FOREACH(CMerkleTx& tx, wtxNew.vtxPrev)\n+                pblockstore->EmitTransaction((CTransaction&)tx);\n+        }\n+\n         // Broadcast\n         if (!pblockstore->EmitTransaction((CTransaction&)wtxNew))\n         {"
      }
    ]
  },
  {
    "sha": "a422455c485cd050c0399bf2b247108a2fc7c453",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNDIyNDU1YzQ4NWNkMDUwYzAzOTliZjJiMjQ3MTA4YTJmYzdjNDUz",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2012-01-28T09:10:01Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2012-05-18T03:13:30Z"
      },
      "message": "Potentially unsafe optimization.",
      "tree": {
        "sha": "27d7f120116d403e3e266e1b75cd6821adabd38e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/27d7f120116d403e3e266e1b75cd6821adabd38e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a422455c485cd050c0399bf2b247108a2fc7c453",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a422455c485cd050c0399bf2b247108a2fc7c453",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a422455c485cd050c0399bf2b247108a2fc7c453",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a422455c485cd050c0399bf2b247108a2fc7c453/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "b421ce6fcb0c4fcada193df3ed07a76d89bdcdec",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b421ce6fcb0c4fcada193df3ed07a76d89bdcdec",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b421ce6fcb0c4fcada193df3ed07a76d89bdcdec"
      }
    ],
    "stats": {
      "total": 26,
      "additions": 16,
      "deletions": 10
    },
    "files": [
      {
        "sha": "6adb3941b62c65e98328719ac946a0909d774a19",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 10,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a422455c485cd050c0399bf2b247108a2fc7c453/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a422455c485cd050c0399bf2b247108a2fc7c453/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=a422455c485cd050c0399bf2b247108a2fc7c453",
        "patch": "@@ -2844,29 +2844,35 @@ bool CBlockStore::EmitTransaction(CTransaction& transaction)\n \n const CBlockIndex* CBlockStore::GetBestBlockIndex() const\n {\n-    LOCK(cs_main);\n+    // TODO: This should have a cs_main lock around it,\n+    // however such a lock causes noticeable lag in the UI and is thus missing.\n+    // This should not be a problem as setting a pointer is an atomic operation on most machines,\n+    // and it is unlikely that gcc will reorder functions which set pindexBest,\n+    // however it is not guaranteed and should be further researched.\n+    // see: http://stackoverflow.com/questions/879077/is-changing-a-pointer-considered-an-atomic-action-in-c\n     return pindexBest;\n }\n \n const CBlockIndex* CBlockStore::GetGenesisBlockIndex() const\n {\n-    LOCK(cs_main);\n     return pindexGenesisBlock;\n }\n \n-void CBlockStore::RelayAlerts(CNode* pnode)\n-{\n-    LOCK(cs_mapAlerts);\n-    BOOST_FOREACH(PAIRTYPE(const uint256, CAlert*)& item, mapAlerts)\n-        item.second->RelayTo(pnode);\n-}\n-\n const CBlockIndex* CBlockStore::GetBlockIndex(const uint256 nBlockHash)\n {\n-    LOCK(cs_main);\n+    // TODO: This should also have a cs_main lock, however this is not the only place\n+    // This exact code doesn't get such a lock, see, for example, src/qt/transactionrecord.cpp:191\n+    // which calls CMerkleTx::GetDepthInMainChain() without a cs_main lock\n+    // Also note that this code was usually not locked pre-CBlockStore\n     std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(nBlockHash);\n     if (mi != mapBlockIndex.end())\n         return (*mi).second;\n     return NULL;\n }\n \n+void CBlockStore::RelayAlerts(CNode* pnode)\n+{\n+    LOCK(cs_mapAlerts);\n+    BOOST_FOREACH(PAIRTYPE(const uint256, CAlert*)& item, mapAlerts)\n+        item.second->RelayTo(pnode);\n+}"
      }
    ]
  },
  {
    "sha": "c482016a01ab8a0a8796248e14f46f2d83ec698d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNDgyMDE2YTAxYWI4YTBhODc5NjI0OGUxNGY0NmYyZDgzZWM2OThk",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2012-02-18T07:30:29Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2012-05-18T03:13:30Z"
      },
      "message": "Clean up getmininginfo's API.",
      "tree": {
        "sha": "ed60dd8711df4d278a33961c71fc39be9daa809e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ed60dd8711df4d278a33961c71fc39be9daa809e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c482016a01ab8a0a8796248e14f46f2d83ec698d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c482016a01ab8a0a8796248e14f46f2d83ec698d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c482016a01ab8a0a8796248e14f46f2d83ec698d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c482016a01ab8a0a8796248e14f46f2d83ec698d/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "a422455c485cd050c0399bf2b247108a2fc7c453",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a422455c485cd050c0399bf2b247108a2fc7c453",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a422455c485cd050c0399bf2b247108a2fc7c453"
      }
    ],
    "stats": {
      "total": 59,
      "additions": 35,
      "deletions": 24
    },
    "files": [
      {
        "sha": "2b761a669918176dba835548d77379c9fde939fb",
        "filename": "src/bitcoinrpc.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 17,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c482016a01ab8a0a8796248e14f46f2d83ec698d/src/bitcoinrpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c482016a01ab8a0a8796248e14f46f2d83ec698d/src/bitcoinrpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.cpp?ref=c482016a01ab8a0a8796248e14f46f2d83ec698d",
        "patch": "@@ -41,6 +41,9 @@ static std::string strRPCUserColonPass;\n static int64 nWalletUnlockTime;\n static CCriticalSection cs_nWalletUnlockTime;\n \n+static CBlock* pLastBlockReturned;\n+static CCriticalSection cs_pLastBlockReturned;\n+\n extern Value dumpprivkey(const Array& params, bool fHelp);\n extern Value importprivkey(const Array& params, bool fHelp);\n \n@@ -558,15 +561,19 @@ Value getmininginfo(const Array& params, bool fHelp)\n             \"Returns an object containing mining-related information.\");\n \n     Object obj;\n+    {\n+        LOCK(cs_pLastBlockReturned);\n+        if(pLastBlockReturned)\n+            obj.push_back(Pair(\"currentblocktx\",(uint64_t)pLastBlockReturned->vtx.size()));\n+    }\n     obj.push_back(Pair(\"blocks\",        (int)pblockstore->GetBestBlockIndex()->nHeight));\n     obj.push_back(Pair(\"currentblocksize\",(uint64_t)nLastBlockSize));\n-    obj.push_back(Pair(\"currentblocktx\",(uint64_t)nLastBlockTx));\n     obj.push_back(Pair(\"difficulty\",    (double)GetDifficulty()));\n     obj.push_back(Pair(\"errors\",        GetWarnings(\"statusbar\")));\n     obj.push_back(Pair(\"generate\",      GetBoolArg(\"-gen\")));\n     obj.push_back(Pair(\"genproclimit\",  (int)GetArg(\"-genproclimit\", -1)));\n     obj.push_back(Pair(\"hashespersec\",  gethashespersec(params, false)));\n-    obj.push_back(Pair(\"pooledtx\",      (uint64_t)mempool.size()));\n+    obj.push_back(Pair(\"pooledtx\",      (uint64_t)pblockstore->GetPooledTxSize()));\n     obj.push_back(Pair(\"testnet\",       fTestNet));\n     return obj;\n }\n@@ -2039,23 +2046,27 @@ Value getwork(const Array& params, bool fHelp)\n         if (pindexPrev != pblockstore->GetBestBlockIndex() ||\n             (nTransactionsUpdated != nTransactionsUpdatedLast && GetTime() - nStart > 60))\n         {\n-            if (pindexPrev != pblockstore->GetBestBlockIndex())\n             {\n-                // Deallocate old blocks since they're obsolete now\n-                mapNewBlock.clear();\n-                BOOST_FOREACH(CBlock* pblock, vNewBlock)\n-                    delete pblock;\n-                vNewBlock.clear();\n+                LOCK(cs_pLastBlockReturned);\n+                if (pindexPrev != pblockstore->GetBestBlockIndex())\n+                {\n+                    // Deallocate old blocks since they're obsolete now\n+                    mapNewBlock.clear();\n+                    BOOST_FOREACH(CBlock* pblock, vNewBlock)\n+                        delete pblock;\n+                    vNewBlock.clear();\n+                }\n+                nTransactionsUpdatedLast = nTransactionsUpdated;\n+                pindexPrev = pblockstore->GetBestBlockIndex();\n+                nStart = GetTime();\n+\n+                // Create new block\n+                pblock = CreateNewBlock(reservekey);\n+                pLastBlockReturned = pblock;\n+                if (!pblock)\n+                    throw JSONRPCError(-7, \"Out of memory\");\n+                vNewBlock.push_back(pblock);\n             }\n-            nTransactionsUpdatedLast = nTransactionsUpdated;\n-            pindexPrev = pblockstore->GetBestBlockIndex();\n-            nStart = GetTime();\n-\n-            // Create new block\n-            pblock = CreateNewBlock(reservekey);\n-            if (!pblock)\n-                throw JSONRPCError(-7, \"Out of memory\");\n-            vNewBlock.push_back(pblock);\n         }\n \n         // Update nTime"
      },
      {
        "sha": "f1a80d7c2d88ac8629fc3e95e794c87f4de7025c",
        "filename": "src/blockstore.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c482016a01ab8a0a8796248e14f46f2d83ec698d/src/blockstore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c482016a01ab8a0a8796248e14f46f2d83ec698d/src/blockstore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockstore.h?ref=c482016a01ab8a0a8796248e14f46f2d83ec698d",
        "patch": "@@ -134,6 +134,8 @@ class CBlockStore\n     // Return transaction with hash in tx, and if it was found inside a block, its hash is placed in hashBlock\n     bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock);\n \n+    unsigned long GetPooledTxSize();\n+\n //Connected wallet/etc access methods\n \n     // Ask that any listeners who have access to ask other nodes for blocks"
      },
      {
        "sha": "c49faa3d2bc8820ac1f963105d6577f59338bea4",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c482016a01ab8a0a8796248e14f46f2d83ec698d/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c482016a01ab8a0a8796248e14f46f2d83ec698d/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=c482016a01ab8a0a8796248e14f46f2d83ec698d",
        "patch": "@@ -523,6 +523,11 @@ bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMi\n     return mempool.accept(txdb, *this, fCheckInputs, pfMissingInputs);\n }\n \n+unsigned long CBlockStore::GetPooledTxSize()\n+{\n+    return mempool.size();\n+}\n+\n bool CTxMemPool::addUnchecked(CTransaction &tx)\n {\n     // Add to memory pool without checking anything.  Don't call this directly,\n@@ -2286,7 +2291,6 @@ class COrphan\n };\n \n \n-uint64 nLastBlockTx = 0;\n uint64 nLastBlockSize = 0;\n \n CBlock* CreateNewBlock(CReserveKey& reservekey)\n@@ -2375,7 +2379,6 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n         // Collect transactions into block\n         map<uint256, CTxIndex> mapTestPool;\n         uint64 nBlockSize = 1000;\n-        uint64 nBlockTx = 0;\n         int nBlockSigOps = 100;\n         while (!mapPriority.empty())\n         {\n@@ -2422,7 +2425,6 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n             // Added\n             pblock->vtx.push_back(tx);\n             nBlockSize += nTxSize;\n-            ++nBlockTx;\n             nBlockSigOps += nTxSigOps;\n             nFees += nTxFees;\n \n@@ -2442,7 +2444,6 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n             }\n         }\n \n-        nLastBlockTx = nBlockTx;\n         nLastBlockSize = nBlockSize;\n         printf(\"CreateNewBlock(): total size %lu\\n\", nBlockSize);\n "
      },
      {
        "sha": "578b08f8ec0157592bc2e80e22521b21e51a1d3f",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c482016a01ab8a0a8796248e14f46f2d83ec698d/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c482016a01ab8a0a8796248e14f46f2d83ec698d/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=c482016a01ab8a0a8796248e14f46f2d83ec698d",
        "patch": "@@ -56,7 +56,6 @@ extern CScript COINBASE_FLAGS;\n extern CCriticalSection cs_main;\n extern uint256 hashGenesisBlock;\n extern unsigned int nTransactionsUpdated;\n-extern uint64 nLastBlockTx;\n extern uint64 nLastBlockSize;\n extern const std::string strMessageMagic;\n extern double dHashesPerSec;\n@@ -1561,6 +1560,4 @@ class CTxMemPool\n     }\n };\n \n-extern CTxMemPool mempool;\n-\n #endif"
      }
    ]
  },
  {
    "sha": "b0233aa94f81e7f8670460aab510e47911bd9d03",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMDIzM2FhOTRmODFlN2Y4NjcwNDYwYWFiNTEwZTQ3OTExYmQ5ZDAz",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2012-05-05T07:42:40Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2012-05-18T03:13:30Z"
      },
      "message": "Add basic unit test support and abstract a bit more.",
      "tree": {
        "sha": "5c6f1585e3ba3a7af00665caa4f69858c6038fe0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5c6f1585e3ba3a7af00665caa4f69858c6038fe0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b0233aa94f81e7f8670460aab510e47911bd9d03",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b0233aa94f81e7f8670460aab510e47911bd9d03",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b0233aa94f81e7f8670460aab510e47911bd9d03",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b0233aa94f81e7f8670460aab510e47911bd9d03/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "c482016a01ab8a0a8796248e14f46f2d83ec698d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c482016a01ab8a0a8796248e14f46f2d83ec698d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c482016a01ab8a0a8796248e14f46f2d83ec698d"
      }
    ],
    "stats": {
      "total": 210,
      "additions": 156,
      "deletions": 54
    },
    "files": [
      {
        "sha": "637222a236d8a19d6726bef07ee49d70e1cb55ee",
        "filename": "src/blockstore.h",
        "status": "modified",
        "additions": 14,
        "deletions": 2,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0233aa94f81e7f8670460aab510e47911bd9d03/src/blockstore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0233aa94f81e7f8670460aab510e47911bd9d03/src/blockstore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockstore.h?ref=b0233aa94f81e7f8670460aab510e47911bd9d03",
        "patch": "@@ -69,6 +69,8 @@ class CBlockStore\n     std::queue<uint256> queueRelayedCallbacks;\n     std::queue<CTransaction*> queueCommitTransactionToMemoryPoolCallbacks;\n     std::queue<uint256> queueTransactionReplacedCallbacks;\n+\n+    bool fTesting;\n public:\n //Util methods\n     // Loops to process callbacks (call ProcessCallbacks(void* parg) with a CBlockStore as parg to launch in a thread)\n@@ -111,7 +113,9 @@ class CBlockStore\n \n     bool EmitBlock(CBlock& block);\n     // Do not call EmitTransaction except for loose transactions (ie transactions not in a block)\n-    bool EmitTransaction(CTransaction& transaction);\n+    //   fCheckInputs can only ever be set to false if IsInitialBlockDownload() || !HasFullBlocks()\n+    //   Only set fCheckInputs when transaction is a supporting tx for one of our own\n+    bool EmitTransaction(CTransaction& transaction, bool fCheckInputs=true);\n     bool EmitAlert(CAlert& palert);\n \n     // Returns the CBlockIndex that points to the block with specified hash or NULL\n@@ -127,7 +131,7 @@ class CBlockStore\n     bool NeedInv(const CInv* pinv);\n \n     // Returns false if we are an SPV node, ie we can't provide full blocks when requested\n-    inline bool HasFullBlocks() { return true; }\n+    inline bool HasFullBlocks() { return !fTesting; }\n \n     bool IsInitialBlockDownload();\n \n@@ -169,6 +173,14 @@ class CBlockStore\n         LOCK(cs_callbacks);\n         queueTransactionReplacedCallbacks.push(hash);\n     }\n+\n+    // fTesting does not read/write to disk\n+    //   like everything here, it will not always work/doesnt apply to several functions;\n+    //   only for the cases in src/blockstore_tests.cpp\n+    CBlockStore(bool fTestingIn = false)\n+    {\n+        fTesting = fTestingIn;\n+    }\n };\n \n extern CBlockStore* pblockstore;"
      },
      {
        "sha": "cbabcd06ac1c8cfc61a50bf1b62a027a394de50d",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 43,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0233aa94f81e7f8670460aab510e47911bd9d03/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0233aa94f81e7f8670460aab510e47911bd9d03/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=b0233aa94f81e7f8670460aab510e47911bd9d03",
        "patch": "@@ -373,9 +373,13 @@ bool CTransaction::CheckTransaction() const\n     return true;\n }\n \n-bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n+bool CTxMemPool::accept(CTxDB *ptxdb, CTransaction &tx, bool fCheckInputs,\n                         bool* pfMissingInputs)\n {\n+    //ptxdb should always be set if (pblockstore->HasFullBlocks())\n+    if (pblockstore->HasFullBlocks())\n+        assert(ptxdb);\n+\n     if (pfMissingInputs)\n         *pfMissingInputs = false;\n \n@@ -402,8 +406,8 @@ bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n         if (mapTx.count(hash))\n             return false;\n     }\n-    if (fCheckInputs)\n-        if (txdb.ContainsTx(hash))\n+    if (fCheckInputs && ptxdb)\n+        if (ptxdb->ContainsTx(hash))\n             return false;\n \n     // Check for conflicts with in-memory transactions\n@@ -439,7 +443,7 @@ bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n         MapPrevTx mapInputs;\n         map<uint256, CTxIndex> mapUnused;\n         bool fInvalid = false;\n-        if (!tx.FetchInputs(txdb, mapUnused, false, false, mapInputs, fInvalid))\n+        if (!tx.FetchInputs(ptxdb, mapUnused, false, false, mapInputs, fInvalid))\n         {\n             if (fInvalid)\n                 return error(\"CTxMemPool::accept() : FetchInputs found invalid tx %s\", hash.ToString().substr(0,10).c_str());\n@@ -518,9 +522,9 @@ bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n     return true;\n }\n \n-bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMissingInputs)\n+bool CTransaction::AcceptToMemoryPool(CTxDB* ptxdb, bool fCheckInputs, bool* pfMissingInputs)\n {\n-    return mempool.accept(txdb, *this, fCheckInputs, pfMissingInputs);\n+    return mempool.accept(ptxdb, *this, fCheckInputs, pfMissingInputs);\n }\n \n unsigned long CBlockStore::GetPooledTxSize()\n@@ -618,32 +622,6 @@ int CMerkleTx::GetBlocksToMaturity() const\n \n \n \n-bool CWalletTx::AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs)\n-{\n-\n-    {\n-        LOCK(mempool.cs);\n-        // Add previous supporting transactions first\n-        BOOST_FOREACH(CMerkleTx& tx, vtxPrev)\n-        {\n-            if (!tx.IsCoinBase())\n-            {\n-                uint256 hash = tx.GetHash();\n-                if (!mempool.exists(hash) && !txdb.ContainsTx(hash))\n-                    tx.AcceptToMemoryPool(txdb, fCheckInputs);\n-            }\n-        }\n-        return AcceptToMemoryPool(txdb, fCheckInputs);\n-    }\n-    return false;\n-}\n-\n-bool CWalletTx::AcceptWalletTransaction() \n-{\n-    CTxDB txdb(\"r\");\n-    return AcceptWalletTransaction(txdb);\n-}\n-\n int CTxIndex::GetDepthInMainChain() const\n {\n     // Read block header\n@@ -922,7 +900,7 @@ bool CTransaction::DisconnectInputs(CTxDB& txdb)\n }\n \n \n-bool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTestPool,\n+bool CTransaction::FetchInputs(CTxDB* ptxdb, const map<uint256, CTxIndex>& mapTestPool,\n                                bool fBlock, bool fMiner, MapPrevTx& inputsRet, bool& fInvalid)\n {\n     // FetchInputs can return false either because we just haven't seen some inputs\n@@ -950,8 +928,12 @@ bool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTes\n         }\n         else\n         {\n-            // Read txindex from txdb\n-            fFound = txdb.ReadTxIndex(prevout.hash, txindex);\n+            if (ptxdb)\n+            {\n+                // Read txindex from ptxdb\n+                fFound = ptxdb->ReadTxIndex(prevout.hash, txindex);\n+            }else\n+                fFound = false;\n         }\n         if (!fFound && (fBlock || fMiner))\n             return fMiner ? false : error(\"FetchInputs() : %s prev tx %s index entry not found\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n@@ -1243,7 +1225,7 @@ bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex, bool fHeadersOnly)\n         if (!tx.IsCoinBase() && pblockstore->HasFullBlocks())\n         {\n             bool fInvalid;\n-            if (!tx.FetchInputs(txdb, mapQueuedChanges, true, false, mapInputs, fInvalid))\n+            if (!tx.FetchInputs(&txdb, mapQueuedChanges, true, false, mapInputs, fInvalid))\n                 return false;\n \n             if (fStrictPayToScriptHash)\n@@ -1379,7 +1361,7 @@ bool static Reorganize(CTxDB& txdb, CBlockIndex* pindexNew)\n \n     // Resurrect memory transactions that were in the disconnected branch\n     BOOST_FOREACH(CTransaction& tx, vResurrect)\n-        tx.AcceptToMemoryPool(txdb, false);\n+        tx.AcceptToMemoryPool(&txdb, false);\n \n     // Delete redundant memory transactions that are in the connected branch\n     BOOST_FOREACH(CTransaction& tx, vDelete)\n@@ -2406,7 +2388,7 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n             map<uint256, CTxIndex> mapTestPoolTmp(mapTestPool);\n             MapPrevTx mapInputs;\n             bool fInvalid;\n-            if (!tx.FetchInputs(txdb, mapTestPoolTmp, false, true, mapInputs, fInvalid))\n+            if (!tx.FetchInputs(&txdb, mapTestPoolTmp, false, true, mapInputs, fInvalid))\n                 continue;\n \n             int64 nTxFees = tx.GetValueIn(mapInputs)-tx.GetValueOut();\n@@ -2779,20 +2761,26 @@ void GenerateBitcoins(bool fGenerate, CWallet* pwallet)\n \n \n \n-bool CBlockStore::EmitTransaction(CTransaction& transaction)\n+bool CBlockStore::EmitTransaction(CTransaction& transaction, bool fCheckInputs)\n {\n+    if (!IsInitialBlockDownload() && HasFullBlocks())\n+        fCheckInputs = true;\n+\n     {\n         LOCK(cs_main);\n \n-        if (!pblockstore->HasFullBlocks())\n+        if (!pblockstore->HasFullBlocks() && fCheckInputs)\n             if (!transaction.ClientConnectInputs())\n                 return false;\n \n         vector<uint256> vWorkQueue;\n-        CTxDB txdb(\"r\");\n         bool fMissingInputs = false;\n \n-        if (transaction.AcceptToMemoryPool(txdb, pblockstore->HasFullBlocks(), &fMissingInputs))\n+        CTxDB* ptxdb = NULL;\n+        if (pblockstore->HasFullBlocks())\n+            ptxdb = new CTxDB(\"r\");\n+\n+        if (transaction.AcceptToMemoryPool(ptxdb, fCheckInputs, &fMissingInputs))\n         {\n             {\n                 LOCK(cs_callbacks);\n@@ -2812,7 +2800,7 @@ bool CBlockStore::EmitTransaction(CTransaction& transaction)\n                     CTransaction& tx = *((*mi).second);\n                     uint256 hash = tx.GetHash();\n \n-                    if (tx.AcceptToMemoryPool(txdb, true))\n+                    if (tx.AcceptToMemoryPool(ptxdb, true))\n                     {\n                         printf(\"   accepted orphan tx %s\\n\", hash.ToString().substr(0,10).c_str());\n                         {"
      },
      {
        "sha": "4869fb493551f529669b8cb711aa712e2e9d4c81",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0233aa94f81e7f8670460aab510e47911bd9d03/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0233aa94f81e7f8670460aab510e47911bd9d03/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=b0233aa94f81e7f8670460aab510e47911bd9d03",
        "patch": "@@ -618,15 +618,15 @@ class CTransaction\n \n     /** Fetch from memory and/or disk. inputsRet keys are transaction hashes.\n \n-     @param[in] txdb\tTransaction database\n+     @param[in] ptxdb\tTransaction database\n      @param[in] mapTestPool\tList of pending changes to the transaction index database\n      @param[in] fBlock\tTrue if being called to add a new best-block to the chain\n      @param[in] fMiner\tTrue if being called by CreateNewBlock\n      @param[out] inputsRet\tPointers to this transaction's inputs\n      @param[out] fInvalid\treturns true if transaction is invalid\n      @return\tReturns true if all inputs are in txdb or mapTestPool\n      */\n-    bool FetchInputs(CTxDB& txdb, const std::map<uint256, CTxIndex>& mapTestPool,\n+    bool FetchInputs(CTxDB* ptxdb, const std::map<uint256, CTxIndex>& mapTestPool,\n                      bool fBlock, bool fMiner, MapPrevTx& inputsRet, bool& fInvalid);\n \n     /** Sanity check previous transactions, then, if all checks succeed,\n@@ -646,7 +646,7 @@ class CTransaction\n                        const CBlockIndex* pindexBlock, bool fBlock, bool fMiner, bool fStrictPayToScriptHash=true);\n     bool ClientConnectInputs();\n     bool CheckTransaction() const;\n-    bool AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs=true, bool* pfMissingInputs=NULL);\n+    bool AcceptToMemoryPool(CTxDB *ptxdb, bool fCheckInputs=true, bool* pfMissingInputs=NULL);\n \n protected:\n     const CTxOut& GetOutputFor(const CTxIn& input, const MapPrevTx& inputs) const;\n@@ -1538,7 +1538,7 @@ class CTxMemPool\n     std::map<uint256, CTransaction> mapTx;\n     std::map<COutPoint, CInPoint> mapNextTx;\n \n-    bool accept(CTxDB& txdb, CTransaction &tx,\n+    bool accept(CTxDB* ptxdb, CTransaction &tx,\n                 bool fCheckInputs, bool* pfMissingInputs);\n     bool addUnchecked(CTransaction &tx);\n     bool remove(CTransaction &tx);"
      },
      {
        "sha": "68f789adae023e8d3395ab0d03ca453aded45255",
        "filename": "src/test/blockstore_tests.cpp",
        "status": "added",
        "additions": 61,
        "deletions": 0,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0233aa94f81e7f8670460aab510e47911bd9d03/src/test/blockstore_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0233aa94f81e7f8670460aab510e47911bd9d03/src/test/blockstore_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/blockstore_tests.cpp?ref=b0233aa94f81e7f8670460aab510e47911bd9d03",
        "patch": "@@ -0,0 +1,61 @@\n+#include <boost/test/unit_test.hpp>\n+\n+#include \"main.h\"\n+\n+using namespace std;\n+\n+uint256 hashTxCommittedToMemoryPool;\n+bool fCommitted;\n+\n+void TestHandleCommitTransactionToMemoryPool(const CTransaction& tx)\n+{\n+    hashTxCommittedToMemoryPool = tx.GetHash();\n+    fCommitted = true;\n+}\n+\n+BOOST_AUTO_TEST_SUITE(blockstore_tests)\n+\n+// Much of these test cases shamelessly stolen from transaction_tests.cpp\n+BOOST_AUTO_TEST_CASE(cblockstore_emittransaction)\n+{\n+    // Random real transaction (e2769b09e784f32f62ef849763d4f45b98e07ba658647343b915ff832b110436)\n+    unsigned char ch[] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x6b, 0xff, 0x7f, 0xcd, 0x4f, 0x85, 0x65, 0xef, 0x40, 0x6d, 0xd5, 0xd6, 0x3d, 0x4f, 0xf9, 0x4f, 0x31, 0x8f, 0xe8, 0x20, 0x27, 0xfd, 0x4d, 0xc4, 0x51, 0xb0, 0x44, 0x74, 0x01, 0x9f, 0x74, 0xb4, 0x00, 0x00, 0x00, 0x00, 0x8c, 0x49, 0x30, 0x46, 0x02, 0x21, 0x00, 0xda, 0x0d, 0xc6, 0xae, 0xce, 0xfe, 0x1e, 0x06, 0xef, 0xdf, 0x05, 0x77, 0x37, 0x57, 0xde, 0xb1, 0x68, 0x82, 0x09, 0x30, 0xe3, 0xb0, 0xd0, 0x3f, 0x46, 0xf5, 0xfc, 0xf1, 0x50, 0xbf, 0x99, 0x0c, 0x02, 0x21, 0x00, 0xd2, 0x5b, 0x5c, 0x87, 0x04, 0x00, 0x76, 0xe4, 0xf2, 0x53, 0xf8, 0x26, 0x2e, 0x76, 0x3e, 0x2d, 0xd5, 0x1e, 0x7f, 0xf0, 0xbe, 0x15, 0x77, 0x27, 0xc4, 0xbc, 0x42, 0x80, 0x7f, 0x17, 0xbd, 0x39, 0x01, 0x41, 0x04, 0xe6, 0xc2, 0x6e, 0xf6, 0x7d, 0xc6, 0x10, 0xd2, 0xcd, 0x19, 0x24, 0x84, 0x78, 0x9a, 0x6c, 0xf9, 0xae, 0xa9, 0x93, 0x0b, 0x94, 0x4b, 0x7e, 0x2d, 0xb5, 0x34, 0x2b, 0x9d, 0x9e, 0x5b, 0x9f, 0xf7, 0x9a, 0xff, 0x9a, 0x2e, 0xe1, 0x97, 0x8d, 0xd7, 0xfd, 0x01, 0xdf, 0xc5, 0x22, 0xee, 0x02, 0x28, 0x3d, 0x3b, 0x06, 0xa9, 0xd0, 0x3a, 0xcf, 0x80, 0x96, 0x96, 0x8d, 0x7d, 0xbb, 0x0f, 0x91, 0x78, 0xff, 0xff, 0xff, 0xff, 0x02, 0x8b, 0xa7, 0x94, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xba, 0xde, 0xec, 0xfd, 0xef, 0x05, 0x07, 0x24, 0x7f, 0xc8, 0xf7, 0x42, 0x41, 0xd7, 0x3b, 0xc0, 0x39, 0x97, 0x2d, 0x7b, 0x88, 0xac, 0x40, 0x94, 0xa8, 0x02, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xc1, 0x09, 0x32, 0x48, 0x3f, 0xec, 0x93, 0xed, 0x51, 0xf5, 0xfe, 0x95, 0xe7, 0x25, 0x59, 0xf2, 0xcc, 0x70, 0x43, 0xf9, 0x88, 0xac, 0x00, 0x00, 0x00, 0x00, 0x00};\n+    vector<unsigned char> vch(ch, ch + sizeof(ch) -1);\n+    CDataStream stream(vch, SER_NETWORK, CLIENT_VERSION);\n+    CTransaction tx;\n+    stream >> tx;\n+\n+    pblockstore->RegisterCommitTransactionToMemoryPool(TestHandleCommitTransactionToMemoryPool);\n+\n+    fCommitted = false;\n+    BOOST_CHECK_MESSAGE(!pblockstore->EmitTransaction(tx), \"Transaction without inputs in memory pool shouldnt be accepted.\");\n+    Sleep(200); // Might take a sec before ProcessCallbacks gets around to calling back\n+    BOOST_CHECK_MESSAGE(!fCommitted, \"CommitToMemoryPool callbacks should not be made on a transaction that is missing inputs.\");\n+\n+    uint256 hashTx = tx.GetHash();\n+    fCommitted = false;\n+    BOOST_CHECK_MESSAGE(pblockstore->EmitTransaction(tx, false), \"Simple deserialized transaction should be valid.\");\n+    Sleep(200); // Might take a sec before ProcessCallbacks gets around to calling back\n+    BOOST_CHECK_MESSAGE(fCommitted, \"CommitToMemoryPool callbacks should complete within 200 msec.\");\n+    BOOST_CHECK_MESSAGE(hashTx == hashTxCommittedToMemoryPool, \"Hash of committed transaction should be equal to the emitted one.\");\n+\n+    // Spends e2769b09e784f32f62ef849763d4f45b98e07ba658647343b915ff832b110436[0] (bbf5cd27127f19dc359bdabb3a4ea2391e14062c748235ff81b98b43315756ac)\n+    unsigned char ch2[] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x36, 0x04, 0x11, 0x2b, 0x83, 0xff, 0x15, 0xb9, 0x43, 0x73, 0x64, 0x58, 0xa6, 0x7b, 0xe0, 0x98, 0x5b, 0xf4, 0xd4, 0x63, 0x97, 0x84, 0xef, 0x62, 0x2f, 0xf3, 0x84, 0xe7, 0x09, 0x9b, 0x76, 0xe2, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x6b, 0x85, 0x77, 0x09, 0x8e, 0x34, 0x68, 0x84, 0xe6, 0x3b, 0xe3, 0x8e, 0xcd, 0x24, 0xaf, 0x53, 0x5a, 0x4d, 0x7c, 0x97, 0x32, 0x64, 0x7a, 0x9a, 0xad, 0x09, 0x47, 0x2e, 0xde, 0x2f, 0x51, 0x7b, 0x02, 0x20, 0x15, 0x51, 0xcf, 0x53, 0xde, 0x83, 0xc5, 0xcc, 0x3f, 0x6a, 0x5c, 0x4a, 0xdc, 0x4d, 0xf9, 0x52, 0x06, 0xff, 0xf8, 0x88, 0x78, 0x4c, 0xaf, 0xd4, 0x1e, 0x15, 0x5b, 0xfb, 0xee, 0x8b, 0x99, 0xac, 0x01, 0x41, 0x04, 0x38, 0x2b, 0x53, 0x80, 0x8e, 0x0f, 0xda, 0xdc, 0x56, 0x0b, 0x28, 0x40, 0xa3, 0xb6, 0xb0, 0xbe, 0x0b, 0xcc, 0x50, 0x22, 0x62, 0xe9, 0xc6, 0x96, 0xef, 0x0f, 0xbe, 0xd2, 0x1a, 0xc8, 0xc5, 0x6d, 0x7a, 0xe5, 0x60, 0x5e, 0x3c, 0xea, 0x26, 0xa5, 0x93, 0xb4, 0x61, 0xfd, 0x64, 0xf6, 0xba, 0x5c, 0xf2, 0xce, 0xac, 0xd1, 0x81, 0xd3, 0x60, 0xf2, 0x3d, 0x8b, 0x8b, 0xad, 0x84, 0xd8, 0xbb, 0x73, 0xff, 0xff, 0xff, 0xff, 0x02, 0x6e, 0x7e, 0xaa, 0x07, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xb6, 0x00, 0x21, 0x76, 0xec, 0x7b, 0x40, 0x7d, 0xd6, 0x7c, 0x26, 0x5d, 0x8a, 0xcd, 0x4e, 0x4b, 0xf1, 0x09, 0x62, 0xc3, 0x88, 0xac, 0xcd, 0x65, 0xe9, 0x06, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x5b, 0xbf, 0x91, 0x3a, 0x24, 0xa4, 0xc5, 0xc5, 0x2f, 0x1d, 0x3a, 0x68, 0x33, 0x25, 0x63, 0xdb, 0xd3, 0x00, 0x81, 0x04, 0x88, 0xac, 0x00, 0x00, 0x00, 0x00, 0x00};\n+    vch = vector<unsigned char> (ch2, ch2 + sizeof(ch2) -1);\n+    stream = CDataStream(vch, SER_NETWORK, CLIENT_VERSION);\n+    stream >> tx;\n+\n+    hashTx = tx.GetHash();\n+    fCommitted = false;\n+    BOOST_CHECK_MESSAGE(pblockstore->EmitTransaction(tx), \"Spending transaction should be valid.\");\n+    Sleep(200); // Might take a sec before ProcessCallbacks gets around to calling back\n+    BOOST_CHECK_MESSAGE(fCommitted, \"CommitToMemoryPool callbacks should complete within 200 msec.\");\n+    BOOST_CHECK_MESSAGE(hashTx == hashTxCommittedToMemoryPool, \"Hash of committed transaction should be equal to the emitted one.\");\n+\n+    fCommitted = false;\n+    BOOST_CHECK_MESSAGE(!pblockstore->EmitTransaction(tx), \"Double emit shouldn't be valid.\");\n+    Sleep(200); // Might take a sec before ProcessCallbacks gets around to calling back\n+    BOOST_CHECK_MESSAGE(!fCommitted, \"CommitToMemoryPool callbacks should not be made on a double emit.\");\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "5dfe12a6cc6174c47bbf3bb931b909df54c77d2a",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0233aa94f81e7f8670460aab510e47911bd9d03/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0233aa94f81e7f8670460aab510e47911bd9d03/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=b0233aa94f81e7f8670460aab510e47911bd9d03",
        "patch": "@@ -11,9 +11,10 @@ struct TestingSetup {\n     TestingSetup() {\n         fPrintToConsole = true; // don't want to write to debug.log file\n         pwalletMain = new CWallet();\n-        //pblockstore = new CBlockStore();\n-        //if (!CreateThread(ProcessCallbacks, pblockstore))\n-        //    wxMessageBox(_(\"Error: CreateThread(ProcessCallbacks) failed\"), \"Bitcoin\");\n+        pblockstore = new CBlockStore(true);\n+        // TODO: have to make sure util_tests are run before blockstore_tests to\n+        //   identify thread issues before they show up as blockstore issues\n+        CreateThread(ProcessCallbacks, pblockstore);\n         //pwalletMain->RegisterWithBlockStore(pblockstore);\n     }\n     ~TestingSetup()"
      },
      {
        "sha": "f1ec78aae20cee60adb4294a54476c0aaeed1ddb",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 0,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0233aa94f81e7f8670460aab510e47911bd9d03/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0233aa94f81e7f8670460aab510e47911bd9d03/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=b0233aa94f81e7f8670460aab510e47911bd9d03",
        "patch": "@@ -10,6 +10,36 @@ using namespace std;\n \n BOOST_AUTO_TEST_SUITE(util_tests)\n \n+CCriticalSection shared_cs;\n+bool fIsInCS = false;\n+\n+void ThreadTwo(void* parg)\n+{\n+    Sleep(100);\n+    {\n+        LOCK(shared_cs);\n+        BOOST_CHECK_MESSAGE(!fIsInCS, \"CCriticalSection doesnt lock?\");\n+        fIsInCS = true;\n+        Sleep(100);\n+        fIsInCS = false;\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_threadedcriticalsection)\n+{\n+    BOOST_CHECK_MESSAGE(CreateThread(ThreadTwo, NULL), \"CreateThread Failed!\");\n+    {\n+        LOCK(shared_cs);\n+        fIsInCS = true;\n+        Sleep(200);\n+        fIsInCS = false;\n+    }\n+    Sleep(50);\n+    BOOST_CHECK_MESSAGE(fIsInCS, \"LOCK doesnt unlock or CreateThread doesnt create a thread.\");\n+    Sleep(55);\n+    BOOST_CHECK_MESSAGE(!fIsInCS, \"Didnt ever leave CS???\");\n+}\n+\n BOOST_AUTO_TEST_CASE(util_criticalsection)\n {\n     CCriticalSection cs;"
      },
      {
        "sha": "983bc5759ce2e2616a8eda585136eec6c59ef41e",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 1,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0233aa94f81e7f8670460aab510e47911bd9d03/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0233aa94f81e7f8670460aab510e47911bd9d03/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=b0233aa94f81e7f8670460aab510e47911bd9d03",
        "patch": "@@ -743,6 +743,17 @@ int CWallet::ScanForWalletTransaction(const uint256& hashTx)\n     return 0;\n }\n \n+bool CWalletTx::AcceptWalletTransaction()\n+{\n+    // Add previous supporting transactions first\n+    BOOST_FOREACH(CMerkleTx& tx, vtxPrev)\n+    {\n+        if (!tx.IsCoinBase())\n+            pblockstore->EmitTransaction(tx, false);\n+    }\n+    return pblockstore->EmitTransaction(*this);\n+}\n+\n void CWallet::ReacceptWalletTransactions()\n {\n     assert(pblockstore->HasFullBlocks());\n@@ -791,7 +802,7 @@ void CWallet::ReacceptWalletTransactions()\n             {\n                 // Reaccept any txes of ours that aren't already in a block\n                 if (!wtx.IsCoinBase())\n-                    wtx.AcceptWalletTransaction(txdb, false);\n+                    wtx.AcceptWalletTransaction();\n             }\n         }\n         if (!vMissingTx.empty())"
      },
      {
        "sha": "299d72e84bafdbeaed900adeec137add647d498d",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b0233aa94f81e7f8670460aab510e47911bd9d03/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b0233aa94f81e7f8670460aab510e47911bd9d03/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=b0233aa94f81e7f8670460aab510e47911bd9d03",
        "patch": "@@ -603,7 +603,6 @@ class CWalletTx : public CMerkleTx\n \n     void AddSupportingTransactions(CTxDB& txdb);\n \n-    bool AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs=true);\n     bool AcceptWalletTransaction();\n \n     void RelayWalletTransaction(CTxDB& txdb);"
      }
    ]
  },
  {
    "sha": "1af7ffcc36ea991f156ade26003b853052058903",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxYWY3ZmZjYzM2ZWE5OTFmMTU2YWRlMjYwMDNiODUzMDUyMDU4OTAz",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-05-05T07:46:51Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2012-05-18T03:13:30Z"
      },
      "message": "CBlockStoreCallback and derived classes",
      "tree": {
        "sha": "ae6b05e3800477e825193ac09aa865948d2e0914",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ae6b05e3800477e825193ac09aa865948d2e0914"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1af7ffcc36ea991f156ade26003b853052058903",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1af7ffcc36ea991f156ade26003b853052058903",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1af7ffcc36ea991f156ade26003b853052058903",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1af7ffcc36ea991f156ade26003b853052058903/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": null,
    "parents": [
      {
        "sha": "b0233aa94f81e7f8670460aab510e47911bd9d03",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b0233aa94f81e7f8670460aab510e47911bd9d03",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b0233aa94f81e7f8670460aab510e47911bd9d03"
      }
    ],
    "stats": {
      "total": 228,
      "additions": 117,
      "deletions": 111
    },
    "files": [
      {
        "sha": "b64a28fddba78162872fedf80863e3c3d32871ac",
        "filename": "src/blockstore.cpp",
        "status": "modified",
        "additions": 83,
        "deletions": 68,
        "changes": 151,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af7ffcc36ea991f156ade26003b853052058903/src/blockstore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af7ffcc36ea991f156ade26003b853052058903/src/blockstore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockstore.cpp?ref=1af7ffcc36ea991f156ade26003b853052058903",
        "patch": "@@ -1,6 +1,81 @@\n #include \"blockstore.h\"\n #include \"main.h\"\n \n+class CBlockStoreCallbackCommitBlock : public CBlockStoreCallback\n+{\n+private:\n+    CBlock block;\n+public:\n+    CBlockStoreCallbackCommitBlock(const CBlock &blockIn) : block(blockIn) {}\n+    void Signal(const CBlockStoreSignalTable& sigtable) { sigtable.sigCommitBlock(block); }\n+};\n+\n+class CBlockStoreCallbackAskForBlocks : public CBlockStoreCallback\n+{\n+private:\n+    uint256 hashEnd, hashOrig;\n+public:\n+    CBlockStoreCallbackAskForBlocks(uint256 hashEndIn, uint256 hashOrigIn) : hashEnd(hashEndIn), hashOrig(hashOrigIn) {}\n+    void Signal(const CBlockStoreSignalTable& sigtable) { sigtable.sigAskForBlocks(hashEnd, hashOrig); }\n+};\n+\n+class CBlockStoreCallbackRelayed : public CBlockStoreCallback\n+{\n+private:\n+    uint256 hash;\n+public:\n+    CBlockStoreCallbackRelayed(uint256 hashIn) : hash(hashIn) {}\n+    void Signal(const CBlockStoreSignalTable& sigtable) { sigtable.sigRelayed(hash); }\n+};\n+\n+class CBlockStoreCallbackTransactionReplaced : public CBlockStoreCallback\n+{\n+private:\n+    uint256 hash;\n+public:\n+    CBlockStoreCallbackTransactionReplaced(uint256 hashIn) : hash(hashIn) {}\n+    void Signal(const CBlockStoreSignalTable& sigtable) { sigtable.sigTransactionReplaced(hash); }\n+};\n+\n+class CBlockStoreCallbackCommitTransactionToMemoryPool : public CBlockStoreCallback\n+{\n+private:\n+    CTransaction tx;\n+public:\n+    CBlockStoreCallbackCommitTransactionToMemoryPool(const CTransaction &txIn) : tx(txIn) {}\n+    void Signal(const CBlockStoreSignalTable& sigtable) { sigtable.sigCommitTransactionToMemoryPool(tx); }\n+};\n+\n+void CBlockStore::AskForBlocks(const uint256 hashEnd, const uint256 hashOriginator)\n+{\n+    LOCK(cs_callbacks);\n+    queueCallbacks.push(new CBlockStoreCallbackAskForBlocks(hashEnd, hashOriginator));\n+}\n+\n+void CBlockStore::Relayed(const uint256 hash)\n+{\n+    LOCK(cs_callbacks);\n+    queueCallbacks.push(new CBlockStoreCallbackRelayed(hash));\n+}\n+\n+void CBlockStore::TransactionReplaced(const uint256 hash)\n+{\n+    LOCK(cs_callbacks);\n+    queueCallbacks.push(new CBlockStoreCallbackTransactionReplaced(hash));\n+}\n+\n+void CBlockStore::SubmitCallbackCommitTransactionToMemoryPool(const CTransaction &tx)\n+{\n+    LOCK(cs_callbacks);\n+    queueCallbacks.push(new CBlockStoreCallbackCommitTransactionToMemoryPool(tx));\n+}\n+\n+void CBlockStore::SubmitCallbackCommitBlock(const CBlock &block)\n+{\n+    LOCK(cs_callbacks);\n+    queueCallbacks.push(new CBlockStoreCallbackCommitBlock(block));\n+}\n+\n void ProcessCallbacks(void* parg)\n {\n     ((CBlockStore*)parg)->ProcessCallbacks();\n@@ -10,82 +85,22 @@ void CBlockStore::ProcessCallbacks()\n {\n     loop\n     {\n-        bool fHaveDoneSomething = false;\n-\n-        std::pair<uint256, uint256> hashParams;\n+        CBlockStoreCallback *pcallback = NULL;\n         {\n             LOCK(cs_callbacks);\n-            if (!queueAskForBlocksCallbacks.empty())\n+            if (!queueCallbacks.empty())\n             {\n-                hashParams = queueAskForBlocksCallbacks.front();\n-                queueAskForBlocksCallbacks.pop();\n-                fHaveDoneSomething = true;\n+                pcallback = queueCallbacks.front();\n+                queueCallbacks.pop();\n             }\n         }\n-        if (fHaveDoneSomething)\n-            sigAskForBlocks(hashParams.first, hashParams.second);\n \n-        uint256 hashRelayed;\n-        bool fRelayedToBeCalled = false;\n+        if (pcallback)\n         {\n-            LOCK(cs_callbacks);\n-            if (!queueRelayedCallbacks.empty())\n-            {\n-                hashRelayed = queueRelayedCallbacks.front();\n-                queueRelayedCallbacks.pop();\n-                fHaveDoneSomething = fRelayedToBeCalled = true;\n-            }\n-        }\n-        if (fRelayedToBeCalled)\n-            sigRelayed(hashRelayed);\n-\n-        uint256 hashTransactionReplaced;\n-        bool fTransactionReplacedToBeCalled = false;\n-        {\n-            LOCK(cs_callbacks);\n-            if (!queueTransactionReplacedCallbacks.empty())\n-            {\n-                hashTransactionReplaced = queueTransactionReplacedCallbacks.front();\n-                queueTransactionReplacedCallbacks.pop();\n-                fHaveDoneSomething = fTransactionReplacedToBeCalled = true;\n-            }\n-        }\n-        if (fTransactionReplacedToBeCalled)\n-            sigRelayed(hashTransactionReplaced);\n-\n-        CBlock* pBlockToProcess = NULL;\n-        {\n-            LOCK(cs_callbacks);\n-            if (!queueCommitBlockCallbacks.empty())\n-            {\n-                pBlockToProcess = queueCommitBlockCallbacks.front();\n-                queueCommitBlockCallbacks.pop();\n-                fHaveDoneSomething = true;\n-            }\n-        }\n-        if (pBlockToProcess)\n-        {\n-            sigCommitBlock(*pBlockToProcess);\n-            delete pBlockToProcess;\n+            pcallback->Signal(sigtable);\n+            delete pcallback;\n         }\n-\n-        CTransaction* pTxToProcess = NULL;\n-        {\n-            LOCK(cs_callbacks);\n-            if (!queueCommitTransactionToMemoryPoolCallbacks.empty())\n-            {\n-                pTxToProcess = queueCommitTransactionToMemoryPoolCallbacks.front();\n-                queueCommitTransactionToMemoryPoolCallbacks.pop();\n-                fHaveDoneSomething = true;\n-            }\n-        }\n-        if (pTxToProcess)\n-        {\n-            sigCommitTransactionToMemoryPool(*pTxToProcess);\n-            delete pTxToProcess;\n-        }\n-\n-        if (!fHaveDoneSomething)\n+        else\n             Sleep(100);\n \n         if (fShutdown)"
      },
      {
        "sha": "89d4f10c09a446fd5a4a5961226ac3061e25cf4e",
        "filename": "src/blockstore.h",
        "status": "modified",
        "additions": 31,
        "deletions": 31,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af7ffcc36ea991f156ade26003b853052058903/src/blockstore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af7ffcc36ea991f156ade26003b853052058903/src/blockstore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockstore.h?ref=1af7ffcc36ea991f156ade26003b853052058903",
        "patch": "@@ -46,9 +46,9 @@ struct anyTrue\n // This API is subject to change dramatically overnight, do not\n // depend on it for anything.\n \n-class CBlockStore\n+class CBlockStoreSignalTable\n {\n-private:\n+public:\n     CCriticalSection cs_signals;\n \n     boost::signals2::signal<void (const CBlock&)> sigCommitBlock;\n@@ -62,50 +62,62 @@ class CBlockStore\n     boost::signals2::signal<void (const uint256)> sigRelayed;\n     boost::signals2::signal<bool (const CTransaction&), anyTrue<bool> > sigIsTransactionFromMe;\n     boost::signals2::signal<bool (const uint256), anyTrue<bool> > sigIsTransactionFromMeByHash;\n+};\n+\n+class CBlockStoreCallback\n+{\n+public:\n+    virtual ~CBlockStoreCallback() {};\n+    virtual void Signal(const CBlockStoreSignalTable& sigtable) =0;\n+};\n+\n+class CBlockStore\n+{\n+private:\n+    CBlockStoreSignalTable sigtable;\n \n     CCriticalSection cs_callbacks;\n-    std::queue<CBlock*> queueCommitBlockCallbacks;\n-    std::queue<std::pair<uint256, uint256> > queueAskForBlocksCallbacks;\n-    std::queue<uint256> queueRelayedCallbacks;\n-    std::queue<CTransaction*> queueCommitTransactionToMemoryPoolCallbacks;\n-    std::queue<uint256> queueTransactionReplacedCallbacks;\n+    std::queue<CBlockStoreCallback*> queueCallbacks;\n \n     bool fTesting;\n+\n+    void SubmitCallbackCommitTransactionToMemoryPool(const CTransaction &tx);\n+    void SubmitCallbackCommitBlock(const CBlock &block);\n public:\n //Util methods\n     // Loops to process callbacks (call ProcessCallbacks(void* parg) with a CBlockStore as parg to launch in a thread)\n     void ProcessCallbacks();\n \n //Register methods\n     // Register a handler (of the form void f(const CBlock& block)) to be called after every block commit\n-    void RegisterCommitBlock(boost::function<void (const CBlock&)> func) { sigCommitBlock.connect(func); }\n+    void RegisterCommitBlock(boost::function<void (const CBlock&)> func) { sigtable.sigCommitBlock.connect(func); }\n \n     // Register a handler (of the form void f(const CTransaction& block)) to be called after every transaction commit to memory pool\n     //   CommitTransactionToMemoryPool is called even when !HasFullBlocks() and txes should NOT be forwarded in that case.\n-    void RegisterCommitTransactionToMemoryPool(boost::function<void (const CTransaction&)> func) { sigCommitTransactionToMemoryPool.connect(func); }\n+    void RegisterCommitTransactionToMemoryPool(boost::function<void (const CTransaction&)> func) { sigtable.sigCommitTransactionToMemoryPool.connect(func); }\n \n     // Register a handler (of the form void f(const uint256)) to be called when a transaciton is replaced\n-    void RegisterTransactionReplaced(boost::function<void (const uint256)> func) {sigTransactionReplaced.connect(func); }\n+    void RegisterTransactionReplaced(boost::function<void (const uint256)> func) {sigtable.sigTransactionReplaced.connect(func); }\n \n     //void RegisterCommitAlert(boost::function<void (const CAlert*)> func) { sigCommitAlert.connect(func); }\n \n     // Register a handler (of the form void f(const uint256 hashEnd, const uint256 hashOriginator)) to be called when we need to ask for blocks up to hashEnd\n     //   Should always start from the best block (GetBestBlockIndex())\n     //   The receiver should check if it has a peer which is known to have a block with hash hashOriginator and if it does, it should\n     //    send the block query to that node.\n-    void RegisterAskForBlocks(boost::function<void (const uint256, const uint256)> func) { sigAskForBlocks.connect(func); }\n+    void RegisterAskForBlocks(boost::function<void (const uint256, const uint256)> func) { sigtable.sigAskForBlocks.connect(func); }\n \n     // Register a handler (of the form void f(const uint256 hash)) to be called when a node announces or requests an Inv with hash hash\n     //   Ideal for wallets which want to keep track of whether their transactions are being relayed to other nodes\n-    void RegisterRelayedNotification(boost::function<void (const uint256)> func) { sigRelayed.connect(func); }\n+    void RegisterRelayedNotification(boost::function<void (const uint256)> func) { sigtable.sigRelayed.connect(func); }\n \n     // Register a handler (of the form bool f(const CTransaction& tx)) which will return true if a given transaction is from a locally attached user\n     //   This is used to determine how transactions should be handled in the free transaction and transaction relay logic \n-    void RegisterIsTransactionFromMe(boost::function<bool (const CTransaction&)> func) { sigIsTransactionFromMe.connect(func); }\n+    void RegisterIsTransactionFromMe(boost::function<bool (const CTransaction&)> func) { sigtable.sigIsTransactionFromMe.connect(func); }\n \n     // Register a handler (of the form bool f(const uint256)) which will return true if a transaction with the given hash is from a locally attached user\n     //   This is used to determine how transactions should be handled in the free transaction and transaction relay logic \n-    void RegisterIsTransactionFromMeByHash(boost::function<bool (const uint256)> func) { sigIsTransactionFromMeByHash.connect(func); }\n+    void RegisterIsTransactionFromMeByHash(boost::function<bool (const uint256)> func) { sigtable.sigIsTransactionFromMeByHash.connect(func); }\n \n //Blockchain access methods\n     // Emit methods will verify the object, commit it to memory/disk and then place it in queue to\n@@ -147,32 +159,20 @@ class CBlockStore\n     // If hashOriginator is specified, then a node which is known to have a block\n     //   with that hash will be the one to get the block request, unless no connected\n     //   nodes are known to have this block, in which case a random one will be queried.\n-    void AskForBlocks(const uint256 hashEnd, const uint256 hashOriginator)\n-    {\n-        LOCK(cs_callbacks);\n-        queueAskForBlocksCallbacks.push(std::make_pair(hashEnd, hashOriginator));\n-    }\n+    void AskForBlocks(const uint256 hashEnd, const uint256 hashOriginator);\n \n     // Relay all alerts we have to pnode\n     void RelayAlerts(CNode* pnode);\n \n     // Used to indicate a transaction is being relayed/has been announced by a peer\n     //   (used eg for wallets counting relays of their txes)\n-    void Relayed(const uint256 hash)\n-    {\n-        LOCK(cs_callbacks);\n-        queueRelayedCallbacks.push(hash);\n-    }\n+    void Relayed(const uint256 hash);\n \n     // Returns true if a given transaction is from a connected wallet\n-    bool IsTransactionFromMe(const CTransaction& tx) { return sigIsTransactionFromMe(tx); }\n-    bool IsTransactionFromMe(const uint256 hash) { return sigIsTransactionFromMeByHash(hash); }\n+    bool IsTransactionFromMe(const CTransaction& tx) { return sigtable.sigIsTransactionFromMe(tx); }\n+    bool IsTransactionFromMe(const uint256 hash) { return sigtable.sigIsTransactionFromMeByHash(hash); }\n \n-    void TransactionReplaced(const uint256 hash)\n-    {\n-        LOCK(cs_callbacks);\n-        queueTransactionReplacedCallbacks.push(hash);\n-    }\n+    void TransactionReplaced(const uint256 hash);\n \n     // fTesting does not read/write to disk\n     //   like everything here, it will not always work/doesnt apply to several functions;"
      },
      {
        "sha": "80894107f4c283014f9629aeeaf3b94df2005f78",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 12,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1af7ffcc36ea991f156ade26003b853052058903/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1af7ffcc36ea991f156ade26003b853052058903/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=1af7ffcc36ea991f156ade26003b853052058903",
        "patch": "@@ -1719,10 +1719,7 @@ bool CBlockStore::EmitBlock(CBlock& block)\n \n         printf(\"CBlockStore::EmitBlock: ACCEPTED\\n\");\n \n-        {\n-            LOCK(cs_callbacks);\n-            queueCommitBlockCallbacks.push(new CBlock(block));\n-        }\n+        SubmitCallbackCommitBlock(block);\n     }\n \n     return true;\n@@ -2782,10 +2779,7 @@ bool CBlockStore::EmitTransaction(CTransaction& transaction, bool fCheckInputs)\n \n         if (transaction.AcceptToMemoryPool(ptxdb, fCheckInputs, &fMissingInputs))\n         {\n-            {\n-                LOCK(cs_callbacks);\n-                queueCommitTransactionToMemoryPoolCallbacks.push(new CTransaction(transaction));\n-            }\n+            SubmitCallbackCommitTransactionToMemoryPool(transaction);\n \n             vWorkQueue.push_back(transaction.GetHash());\n \n@@ -2803,10 +2797,7 @@ bool CBlockStore::EmitTransaction(CTransaction& transaction, bool fCheckInputs)\n                     if (tx.AcceptToMemoryPool(ptxdb, true))\n                     {\n                         printf(\"   accepted orphan tx %s\\n\", hash.ToString().substr(0,10).c_str());\n-                        {\n-                            LOCK(cs_callbacks);\n-                            queueCommitTransactionToMemoryPoolCallbacks.push(new CTransaction(tx));\n-                        }\n+                        SubmitCallbackCommitTransactionToMemoryPool(tx);\n                         vWorkQueue.push_back(hash);\n                     }\n                 }"
      }
    ]
  },
  {
    "sha": "e99b0bc4355c63eeccd6d7cf825e61245b672287",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplOTliMGJjNDM1NWM2M2VlY2NkNmQ3Y2Y4MjVlNjEyNDViNjcyMjg3",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-05-05T07:53:03Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2012-05-18T03:13:30Z"
      },
      "message": "Use condition waiting instead of polling for callbacks\n\nModified to use CSemaphore instead of CConditionVariable by Matt\n- blame Matt if this breaks something.",
      "tree": {
        "sha": "d9a7241f058af670fb150d9ed37ecedc2b9c0e87",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d9a7241f058af670fb150d9ed37ecedc2b9c0e87"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e99b0bc4355c63eeccd6d7cf825e61245b672287",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e99b0bc4355c63eeccd6d7cf825e61245b672287",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e99b0bc4355c63eeccd6d7cf825e61245b672287",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e99b0bc4355c63eeccd6d7cf825e61245b672287/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": null,
    "parents": [
      {
        "sha": "1af7ffcc36ea991f156ade26003b853052058903",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1af7ffcc36ea991f156ade26003b853052058903",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1af7ffcc36ea991f156ade26003b853052058903"
      }
    ],
    "stats": {
      "total": 61,
      "additions": 40,
      "deletions": 21
    },
    "files": [
      {
        "sha": "b2104d42c04246e0e57f63fd16bd43466cbe3f4a",
        "filename": "src/blockstore.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 19,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e99b0bc4355c63eeccd6d7cf825e61245b672287/src/blockstore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e99b0bc4355c63eeccd6d7cf825e61245b672287/src/blockstore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockstore.cpp?ref=e99b0bc4355c63eeccd6d7cf825e61245b672287",
        "patch": "@@ -49,31 +49,36 @@ class CBlockStoreCallbackCommitTransactionToMemoryPool : public CBlockStoreCallb\n void CBlockStore::AskForBlocks(const uint256 hashEnd, const uint256 hashOriginator)\n {\n     LOCK(cs_callbacks);\n-    queueCallbacks.push(new CBlockStoreCallbackAskForBlocks(hashEnd, hashOriginator));\n+        queueCallbacks.push(new CBlockStoreCallbackAskForBlocks(hashEnd, hashOriginator));\n+    sem_callbacks.post();\n }\n \n void CBlockStore::Relayed(const uint256 hash)\n {\n     LOCK(cs_callbacks);\n-    queueCallbacks.push(new CBlockStoreCallbackRelayed(hash));\n+        queueCallbacks.push(new CBlockStoreCallbackRelayed(hash));\n+    sem_callbacks.post();\n }\n \n void CBlockStore::TransactionReplaced(const uint256 hash)\n {\n     LOCK(cs_callbacks);\n-    queueCallbacks.push(new CBlockStoreCallbackTransactionReplaced(hash));\n+        queueCallbacks.push(new CBlockStoreCallbackTransactionReplaced(hash));\n+    sem_callbacks.post();\n }\n \n void CBlockStore::SubmitCallbackCommitTransactionToMemoryPool(const CTransaction &tx)\n {\n     LOCK(cs_callbacks);\n-    queueCallbacks.push(new CBlockStoreCallbackCommitTransactionToMemoryPool(tx));\n+        queueCallbacks.push(new CBlockStoreCallbackCommitTransactionToMemoryPool(tx));\n+    sem_callbacks.post();\n }\n \n void CBlockStore::SubmitCallbackCommitBlock(const CBlock &block)\n {\n     LOCK(cs_callbacks);\n-    queueCallbacks.push(new CBlockStoreCallbackCommitBlock(block));\n+        queueCallbacks.push(new CBlockStoreCallbackCommitBlock(block));\n+    sem_callbacks.post();\n }\n \n void ProcessCallbacks(void* parg)\n@@ -83,27 +88,36 @@ void ProcessCallbacks(void* parg)\n \n void CBlockStore::ProcessCallbacks()\n {\n+    {\n+        LOCK(cs_callbacks);\n+        fProcessCallbacks = true;\n+    }\n+\n     loop\n     {\n         CBlockStoreCallback *pcallback = NULL;\n+        sem_callbacks.wait();\n+        if (fProcessCallbacks)\n         {\n             LOCK(cs_callbacks);\n-            if (!queueCallbacks.empty())\n-            {\n-                pcallback = queueCallbacks.front();\n-                queueCallbacks.pop();\n-            }\n-        }\n-\n-        if (pcallback)\n-        {\n-            pcallback->Signal(sigtable);\n-            delete pcallback;\n+            assert(queueCallbacks.size() > 0);\n+            pcallback = queueCallbacks.front();\n+            queueCallbacks.pop();\n         }\n         else\n-            Sleep(100);\n-\n-        if (fShutdown)\n             return;\n+\n+        pcallback->Signal(sigtable);\n+        delete pcallback;\n+    }\n+}\n+\n+void CBlockStore::StopProcessCallbacks()\n+{\n+    {\n+        LOCK(cs_callbacks);\n+        fProcessCallbacks = false;\n+        //TODO: This needs to happen n times where n is the number of callback threads\n+        sem_callbacks.post();\n     }\n }"
      },
      {
        "sha": "79a6ddc9f684ec13e5fab795d7c512694638ceca",
        "filename": "src/blockstore.h",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e99b0bc4355c63eeccd6d7cf825e61245b672287/src/blockstore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e99b0bc4355c63eeccd6d7cf825e61245b672287/src/blockstore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockstore.h?ref=e99b0bc4355c63eeccd6d7cf825e61245b672287",
        "patch": "@@ -4,7 +4,8 @@\n #include <boost/signals2/signal.hpp>\n #include <queue>\n \n-#include \"util.h\"\n+#include \"uint256.h\"\n+#include \"sync.h\"\n \n \n class CInv;\n@@ -78,15 +79,18 @@ class CBlockStore\n \n     CCriticalSection cs_callbacks;\n     std::queue<CBlockStoreCallback*> queueCallbacks;\n+    CSemaphore sem_callbacks;\n \n     bool fTesting;\n+    bool fProcessCallbacks;\n \n     void SubmitCallbackCommitTransactionToMemoryPool(const CTransaction &tx);\n     void SubmitCallbackCommitBlock(const CBlock &block);\n public:\n //Util methods\n     // Loops to process callbacks (call ProcessCallbacks(void* parg) with a CBlockStore as parg to launch in a thread)\n     void ProcessCallbacks();\n+    void StopProcessCallbacks();\n \n //Register methods\n     // Register a handler (of the form void f(const CBlock& block)) to be called after every block commit\n@@ -177,7 +181,7 @@ class CBlockStore\n     // fTesting does not read/write to disk\n     //   like everything here, it will not always work/doesnt apply to several functions;\n     //   only for the cases in src/blockstore_tests.cpp\n-    CBlockStore(bool fTestingIn = false)\n+    CBlockStore(bool fTestingIn = false) : sem_callbacks(0)\n     {\n         fTesting = fTestingIn;\n     }"
      },
      {
        "sha": "2ae00318e129060308dc6ee135b6a001ce4b41d8",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e99b0bc4355c63eeccd6d7cf825e61245b672287/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e99b0bc4355c63eeccd6d7cf825e61245b672287/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=e99b0bc4355c63eeccd6d7cf825e61245b672287",
        "patch": "@@ -54,6 +54,7 @@ void Shutdown(void* parg)\n     if (fFirstThread)\n     {\n         fShutdown = true;\n+        if (pblockstore) pblockstore->StopProcessCallbacks();\n         nTransactionsUpdated++;\n         DBFlush(false);\n         StopNode();"
      }
    ]
  },
  {
    "sha": "de08772730c0247f290ef5b26baeef55e115f1bd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkZTA4NzcyNzMwYzAyNDdmMjkwZWY1YjI2YmFlZWY1NWUxMTVmMWJk",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2012-05-05T20:35:28Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2012-05-18T03:13:30Z"
      },
      "message": "Fix coding style after 865a0c1674dd13563498608dfff27fa6da7b8357",
      "tree": {
        "sha": "0ca6ddd91a3a6117fe4918eb7539a02afae2f9ab",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0ca6ddd91a3a6117fe4918eb7539a02afae2f9ab"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/de08772730c0247f290ef5b26baeef55e115f1bd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/de08772730c0247f290ef5b26baeef55e115f1bd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/de08772730c0247f290ef5b26baeef55e115f1bd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/de08772730c0247f290ef5b26baeef55e115f1bd/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "e99b0bc4355c63eeccd6d7cf825e61245b672287",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e99b0bc4355c63eeccd6d7cf825e61245b672287",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e99b0bc4355c63eeccd6d7cf825e61245b672287"
      }
    ],
    "stats": {
      "total": 7,
      "additions": 4,
      "deletions": 3
    },
    "files": [
      {
        "sha": "21c8ee82a9e54ed0d570b048fe607ade55ee28b8",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de08772730c0247f290ef5b26baeef55e115f1bd/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de08772730c0247f290ef5b26baeef55e115f1bd/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=de08772730c0247f290ef5b26baeef55e115f1bd",
        "patch": "@@ -278,8 +278,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         static int nAskedForBlocks = 0;\n         if (!pfrom->fClient && !pfrom->fOneShot &&\n             (pfrom->nVersion < NOBLKS_VERSION_START ||\n-       pfrom->nVersion >= NOBLKS_VERSION_END) &&\n-             (nAskedForBlocks < 1 || vNodes.size() <= 1))\n+             pfrom->nVersion >= NOBLKS_VERSION_END) &&\n+            (nAskedForBlocks < 1 || vNodes.size() <= 1))\n         {\n             nAskedForBlocks++;\n             pfrom->PushGetBlocks(pblockstore->GetBestBlockIndex(), uint256(0));\n@@ -829,7 +829,8 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n \n     // Keep-alive ping. We send a nonce of zero because we don't use it anywhere \n     // right now.\n-    if (pto->nLastSend && GetTime() - pto->nLastSend > 30 * 60 && pto->vSend.empty()) {\n+    if (pto->nLastSend && GetTime() - pto->nLastSend > 30 * 60 && pto->vSend.empty())\n+    {\n         if (pto->nVersion > BIP0031_VERSION)\n             pto->PushMessage(\"ping\", 0);\n         else"
      }
    ]
  },
  {
    "sha": "4ac3a19b4bb842b86ede06468a44d099aa838d01",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0YWMzYTE5YjRiYjg0MmI4NmVkZTA2NDY4YTQ0ZDA5OWFhODM4ZDAx",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2012-05-07T07:08:42Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2012-05-18T03:13:30Z"
      },
      "message": "Allow setting -callbackconcurrency, default 1 thread.\n\nPurposefully not documented in -? as it is only useful\nfor debugging.",
      "tree": {
        "sha": "a3e430d8869371f89531e23b3e2ef1eb6978e312",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a3e430d8869371f89531e23b3e2ef1eb6978e312"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4ac3a19b4bb842b86ede06468a44d099aa838d01",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ac3a19b4bb842b86ede06468a44d099aa838d01",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4ac3a19b4bb842b86ede06468a44d099aa838d01",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ac3a19b4bb842b86ede06468a44d099aa838d01/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "de08772730c0247f290ef5b26baeef55e115f1bd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/de08772730c0247f290ef5b26baeef55e115f1bd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/de08772730c0247f290ef5b26baeef55e115f1bd"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 3,
      "deletions": 3
    },
    "files": [
      {
        "sha": "107f9a937ebb8fe666f6d865fb908bd8317be692",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4ac3a19b4bb842b86ede06468a44d099aa838d01/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4ac3a19b4bb842b86ede06468a44d099aa838d01/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=4ac3a19b4bb842b86ede06468a44d099aa838d01",
        "patch": "@@ -388,10 +388,10 @@ bool AppInit2()\n         return InitError(strprintf(_(\"Cannot obtain a lock on data directory %s.  Bitcoin is probably already running.\"), GetDataDir().string().c_str()));\n \n     pblockstore = new CBlockStore();\n-    if (!CreateThread(ProcessCallbacks, pblockstore))\n+    for (int i = 0; i < GetArg(\"-callbackconcurrency\", 1); i++)\n     {\n-        ThreadSafeMessageBox(_(\"Error: CreateThread(ProcessCallbacks) failed\"), \"Bitcoin\");\n-        return false;\n+        if (!CreateThread(ProcessCallbacks, pblockstore))\n+            return InitError(_(\"Error: CreateThread(ProcessCallbacks) failed\"));\n     }\n \n     std::ostringstream strErrors;"
      }
    ]
  },
  {
    "sha": "3bb9fee812528cfd68276ae43f34695a97c1d3f5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozYmI5ZmVlODEyNTI4Y2ZkNjgyNzZhZTQzZjM0Njk1YTk3YzFkM2Y1",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2012-05-08T00:07:10Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2012-05-18T03:13:30Z"
      },
      "message": "Use callbacks for RelayMessage in wallet.cpp to avoid a deadlock.",
      "tree": {
        "sha": "5c0fd8c874cb99652dc99ba4c6e867999d96780f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5c0fd8c874cb99652dc99ba4c6e867999d96780f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3bb9fee812528cfd68276ae43f34695a97c1d3f5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3bb9fee812528cfd68276ae43f34695a97c1d3f5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3bb9fee812528cfd68276ae43f34695a97c1d3f5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3bb9fee812528cfd68276ae43f34695a97c1d3f5/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "4ac3a19b4bb842b86ede06468a44d099aa838d01",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ac3a19b4bb842b86ede06468a44d099aa838d01",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4ac3a19b4bb842b86ede06468a44d099aa838d01"
      }
    ],
    "stats": {
      "total": 56,
      "additions": 54,
      "deletions": 2
    },
    "files": [
      {
        "sha": "09d95f27a6def606f5714d3f3412cb71fa2c1fd0",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3bb9fee812528cfd68276ae43f34695a97c1d3f5/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3bb9fee812528cfd68276ae43f34695a97c1d3f5/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=3bb9fee812528cfd68276ae43f34695a97c1d3f5",
        "patch": "@@ -55,6 +55,7 @@ void Shutdown(void* parg)\n     {\n         fShutdown = true;\n         if (pblockstore) pblockstore->StopProcessCallbacks();\n+        StopRelayTransactionCallbacksThread();\n         nTransactionsUpdated++;\n         DBFlush(false);\n         StopNode();\n@@ -393,6 +394,8 @@ bool AppInit2()\n         if (!CreateThread(ProcessCallbacks, pblockstore))\n             return InitError(_(\"Error: CreateThread(ProcessCallbacks) failed\"));\n     }\n+    if (!CreateThread(HandleRelayTransactionCallbacks, NULL))\n+        return InitError(_(\"Error: CreateThread(HandleRelayTransactionCallbacks) failed\"));\n \n     std::ostringstream strErrors;\n     //"
      },
      {
        "sha": "b434d05841e38ead9e79b668eab466ddc5744ba2",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 48,
        "deletions": 2,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3bb9fee812528cfd68276ae43f34695a97c1d3f5/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3bb9fee812528cfd68276ae43f34695a97c1d3f5/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=3bb9fee812528cfd68276ae43f34695a97c1d3f5",
        "patch": "@@ -814,6 +814,52 @@ void CWallet::ReacceptWalletTransactions()\n     }\n }\n \n+CCriticalSection cs_queueRelayTransactionCallbacks;\n+queue<pair<CInv*, CTransaction*> > queueRelayTransactionCallbacks;\n+CSemaphore semRelayTransactionCallbacks(0);\n+bool fProcessRelayTransactionCallbacks;\n+\n+void SubmitCallbackRelayTransaction(const uint256 hash, const CTransaction& txIn)\n+{\n+    CInv* pinv = new CInv(MSG_TX, hash);\n+    CTransaction* ptx = new CTransaction(txIn);\n+    LOCK(cs_queueRelayTransactionCallbacks);\n+        queueRelayTransactionCallbacks.push(make_pair(pinv, ptx));\n+    semRelayTransactionCallbacks.post();\n+}\n+\n+void StopRelayTransactionCallbacksThread()\n+{\n+    LOCK(cs_queueRelayTransactionCallbacks);\n+        fProcessRelayTransactionCallbacks = false;\n+    semRelayTransactionCallbacks.post();\n+}\n+\n+void HandleRelayTransactionCallbacks(void* parg)\n+{\n+    {\n+        LOCK(cs_queueRelayTransactionCallbacks);\n+        fProcessRelayTransactionCallbacks = true;\n+    }\n+\n+    loop\n+    {\n+        pair<CInv*, CTransaction*> callback;\n+        semRelayTransactionCallbacks.wait();\n+        if (!fProcessRelayTransactionCallbacks)\n+            return;\n+        {\n+            LOCK(cs_queueRelayTransactionCallbacks);\n+            assert(queueRelayTransactionCallbacks.size()>0);\n+            callback = queueRelayTransactionCallbacks.front();\n+            queueRelayTransactionCallbacks.pop();\n+        }\n+        RelayMessage(*(callback.first), *(callback.second));\n+        delete callback.first;\n+        delete callback.second;\n+    }\n+}\n+\n void CWalletTx::RelayWalletTransaction(CTxDB& txdb)\n {\n     BOOST_FOREACH(const CMerkleTx& tx, vtxPrev)\n@@ -822,7 +868,7 @@ void CWalletTx::RelayWalletTransaction(CTxDB& txdb)\n         {\n             uint256 hash = tx.GetHash();\n             if (!txdb.ContainsTx(hash))\n-                RelayMessage(CInv(MSG_TX, hash), (CTransaction)tx);\n+                SubmitCallbackRelayTransaction(hash, (CTransaction)tx);\n         }\n     }\n     if (!IsCoinBase())\n@@ -831,7 +877,7 @@ void CWalletTx::RelayWalletTransaction(CTxDB& txdb)\n         if (!txdb.ContainsTx(hash))\n         {\n             printf(\"Relaying wtx %s\\n\", hash.ToString().substr(0,10).c_str());\n-            RelayMessage(CInv(MSG_TX, hash), (CTransaction)*this);\n+            SubmitCallbackRelayTransaction(hash, (CTransaction)*this);\n         }\n     }\n }"
      },
      {
        "sha": "01f152c02e1f3e54bc2e113228697ca6afbb5c58",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3bb9fee812528cfd68276ae43f34695a97c1d3f5/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3bb9fee812528cfd68276ae43f34695a97c1d3f5/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=3bb9fee812528cfd68276ae43f34695a97c1d3f5",
        "patch": "@@ -709,4 +709,7 @@ class CAccountingEntry\n     )\n };\n \n+void HandleRelayTransactionCallbacks(void* parg);\n+void StopRelayTransactionCallbacksThread();\n+\n #endif"
      }
    ]
  },
  {
    "sha": "201617ef32cc3c5da83fddff6c27ffb26c610a22",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMDE2MTdlZjMyY2MzYzVkYTgzZmRkZmY2YzI3ZmZiMjZjNjEwYTIy",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2012-05-11T18:25:00Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2012-05-18T03:13:30Z"
      },
      "message": "Remove AcceptToMemoryPool entirely.",
      "tree": {
        "sha": "834c60ee6539f7d13732e0943ab8ebd6eeea7636",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/834c60ee6539f7d13732e0943ab8ebd6eeea7636"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/201617ef32cc3c5da83fddff6c27ffb26c610a22",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/201617ef32cc3c5da83fddff6c27ffb26c610a22",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/201617ef32cc3c5da83fddff6c27ffb26c610a22",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/201617ef32cc3c5da83fddff6c27ffb26c610a22/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "3bb9fee812528cfd68276ae43f34695a97c1d3f5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3bb9fee812528cfd68276ae43f34695a97c1d3f5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3bb9fee812528cfd68276ae43f34695a97c1d3f5"
      }
    ],
    "stats": {
      "total": 18,
      "additions": 6,
      "deletions": 12
    },
    "files": [
      {
        "sha": "eaeeb994d8449d28589cae8115b7cf4ec863dd85",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 10,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/201617ef32cc3c5da83fddff6c27ffb26c610a22/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/201617ef32cc3c5da83fddff6c27ffb26c610a22/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=201617ef32cc3c5da83fddff6c27ffb26c610a22",
        "patch": "@@ -522,11 +522,6 @@ bool CTxMemPool::accept(CTxDB *ptxdb, CTransaction &tx, bool fCheckInputs,\n     return true;\n }\n \n-bool CTransaction::AcceptToMemoryPool(CTxDB* ptxdb, bool fCheckInputs, bool* pfMissingInputs)\n-{\n-    return mempool.accept(ptxdb, *this, fCheckInputs, pfMissingInputs);\n-}\n-\n unsigned long CBlockStore::GetPooledTxSize()\n {\n     return mempool.size();\n@@ -1028,7 +1023,7 @@ bool CTransaction::ConnectInputs(MapPrevTx inputs,\n     // Take over previous transactions' spent pointers\n     // fBlock is true when this is called from AcceptBlock when a new best-block is added to the blockchain\n     // fMiner is true when called from the internal bitcoin miner\n-    // ... both are false when called from CTransaction::AcceptToMemoryPool\n+    // ... both are false when called from CTxMemPool::accept\n     if (!IsCoinBase())\n     {\n         int64 nValueIn = 0;\n@@ -1184,7 +1179,7 @@ bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex, bool fHeadersOnly)\n     // can be duplicated to remove the ability to spend the first instance -- even after\n     // being sent to another address.\n     // See BIP30 and http://r6.ca/blog/20120206T005236Z.html for more information.\n-    // This logic is not necessary for memory pool transactions, as AcceptToMemoryPool\n+    // This logic is not necessary for memory pool transactions, as CTxMemPool::accept\n     // already refuses previously-known transaction id's entirely.\n     // This rule applies to all blocks whose timestamp is after March 15, 2012, 0:00 UTC.\n     // On testnet it is enabled as of februari 20, 2012, 0:00 UTC.\n@@ -1361,7 +1356,7 @@ bool static Reorganize(CTxDB& txdb, CBlockIndex* pindexNew)\n \n     // Resurrect memory transactions that were in the disconnected branch\n     BOOST_FOREACH(CTransaction& tx, vResurrect)\n-        tx.AcceptToMemoryPool(&txdb, false);\n+        mempool.accept(&txdb, tx, false);\n \n     // Delete redundant memory transactions that are in the connected branch\n     BOOST_FOREACH(CTransaction& tx, vDelete)\n@@ -2777,7 +2772,7 @@ bool CBlockStore::EmitTransaction(CTransaction& transaction, bool fCheckInputs)\n         if (pblockstore->HasFullBlocks())\n             ptxdb = new CTxDB(\"r\");\n \n-        if (transaction.AcceptToMemoryPool(ptxdb, fCheckInputs, &fMissingInputs))\n+        if (mempool.accept(ptxdb, transaction, fCheckInputs, &fMissingInputs))\n         {\n             SubmitCallbackCommitTransactionToMemoryPool(transaction);\n \n@@ -2794,7 +2789,7 @@ bool CBlockStore::EmitTransaction(CTransaction& transaction, bool fCheckInputs)\n                     CTransaction& tx = *((*mi).second);\n                     uint256 hash = tx.GetHash();\n \n-                    if (tx.AcceptToMemoryPool(ptxdb, true))\n+                    if (mempool.accept(ptxdb, tx, true))\n                     {\n                         printf(\"   accepted orphan tx %s\\n\", hash.ToString().substr(0,10).c_str());\n                         SubmitCallbackCommitTransactionToMemoryPool(tx);"
      },
      {
        "sha": "81bf8ee8cd475d62def50266cdba465cde27973c",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/201617ef32cc3c5da83fddff6c27ffb26c610a22/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/201617ef32cc3c5da83fddff6c27ffb26c610a22/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=201617ef32cc3c5da83fddff6c27ffb26c610a22",
        "patch": "@@ -646,7 +646,6 @@ class CTransaction\n                        const CBlockIndex* pindexBlock, bool fBlock, bool fMiner, bool fStrictPayToScriptHash=true);\n     bool ClientConnectInputs();\n     bool CheckTransaction() const;\n-    bool AcceptToMemoryPool(CTxDB *ptxdb, bool fCheckInputs=true, bool* pfMissingInputs=NULL);\n \n protected:\n     const CTxOut& GetOutputFor(const CTxIn& input, const MapPrevTx& inputs) const;\n@@ -1539,7 +1538,7 @@ class CTxMemPool\n     std::map<COutPoint, CInPoint> mapNextTx;\n \n     bool accept(CTxDB* ptxdb, CTransaction &tx,\n-                bool fCheckInputs, bool* pfMissingInputs);\n+                bool fCheckInputs=true, bool* pfMissingInputs=NULL);\n     bool addUnchecked(CTransaction &tx);\n     bool remove(CTransaction &tx);\n "
      }
    ]
  },
  {
    "sha": "83148eadbb8c62ab97308b73fe0440b0db69524a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4MzE0OGVhZGJiOGM2MmFiOTczMDhiNzNmZTA0NDBiMGRiNjk1MjRh",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2012-05-16T00:34:13Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2012-05-18T03:13:30Z"
      },
      "message": "Fix DEBUG_LOCKORDER.",
      "tree": {
        "sha": "6a1e128a09cade573942b026d8fa1751af77ef96",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6a1e128a09cade573942b026d8fa1751af77ef96"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/83148eadbb8c62ab97308b73fe0440b0db69524a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/83148eadbb8c62ab97308b73fe0440b0db69524a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/83148eadbb8c62ab97308b73fe0440b0db69524a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/83148eadbb8c62ab97308b73fe0440b0db69524a/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "201617ef32cc3c5da83fddff6c27ffb26c610a22",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/201617ef32cc3c5da83fddff6c27ffb26c610a22",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/201617ef32cc3c5da83fddff6c27ffb26c610a22"
      }
    ],
    "stats": {
      "total": 33,
      "additions": 20,
      "deletions": 13
    },
    "files": [
      {
        "sha": "e99dfbe62a64fc7833a98d24ef610232779fa6d3",
        "filename": "src/sync.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 13,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/83148eadbb8c62ab97308b73fe0440b0db69524a/src/sync.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/83148eadbb8c62ab97308b73fe0440b0db69524a/src/sync.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.cpp?ref=83148eadbb8c62ab97308b73fe0440b0db69524a",
        "patch": "@@ -7,6 +7,11 @@\n \n \n #ifdef DEBUG_LOCKORDER\n+\n+#include \"util.h\"\n+#include <boost/foreach.hpp>\n+#include <boost/interprocess/sync/interprocess_mutex.hpp>\n+\n //\n // Early deadlock detection.\n // Problem being solved:\n@@ -66,7 +71,6 @@ static void potential_deadlock_detected(const std::pair<void*, void*>& mismatch,\n \n static void push_lock(void* c, const CLockLocation& locklocation, bool fTry)\n {\n-    bool fOrderOK = true;\n     if (lockstack.get() == NULL)\n         lockstack.reset(new LockStack);\n \n@@ -75,20 +79,23 @@ static void push_lock(void* c, const CLockLocation& locklocation, bool fTry)\n \n     (*lockstack).push_back(std::make_pair(c, locklocation));\n \n-    if (!fTry) BOOST_FOREACH(const PAIRTYPE(void*, CLockLocation)& i, (*lockstack))\n+    if (!fTry)\n     {\n-        if (i.first == c) break;\n-\n-        std::pair<void*, void*> p1 = std::make_pair(i.first, c);\n-        if (lockorders.count(p1))\n-            continue;\n-        lockorders[p1] = (*lockstack);\n-\n-        std::pair<void*, void*> p2 = std::make_pair(c, i.first);\n-        if (lockorders.count(p2))\n+        BOOST_FOREACH(const PAIRTYPE(void*, CLockLocation)& i, (*lockstack))\n         {\n-            potential_deadlock_detected(p1, lockorders[p2], lockorders[p1]);\n-            break;\n+            if (i.first == c) break;\n+\n+            std::pair<void*, void*> p1 = std::make_pair(i.first, c);\n+            if (lockorders.count(p1))\n+                continue;\n+            lockorders[p1] = (*lockstack);\n+\n+            std::pair<void*, void*> p2 = std::make_pair(c, i.first);\n+            if (lockorders.count(p2))\n+            {\n+                potential_deadlock_detected(p1, lockorders[p2], lockorders[p1]);\n+                break;\n+            }\n         }\n     }\n     dd_mutex.unlock();"
      }
    ]
  },
  {
    "sha": "cb16f39e6fd45a268ca895b4328282dbb2718e8b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjYjE2ZjM5ZTZmZDQ1YTI2OGNhODk1YjQzMjgyODJkYmIyNzE4ZThi",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2012-05-18T02:00:15Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2012-05-18T03:13:30Z"
      },
      "message": "Add debug stuff - REMOVE BEFORE MERGE",
      "tree": {
        "sha": "051a2e3f95aa25f724bfca5956ed08c202882dca",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/051a2e3f95aa25f724bfca5956ed08c202882dca"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cb16f39e6fd45a268ca895b4328282dbb2718e8b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cb16f39e6fd45a268ca895b4328282dbb2718e8b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cb16f39e6fd45a268ca895b4328282dbb2718e8b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cb16f39e6fd45a268ca895b4328282dbb2718e8b/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "83148eadbb8c62ab97308b73fe0440b0db69524a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/83148eadbb8c62ab97308b73fe0440b0db69524a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/83148eadbb8c62ab97308b73fe0440b0db69524a"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 2,
      "deletions": 2
    },
    "files": [
      {
        "sha": "e7b2053e0a08e716852d2d763635b718d8f0b97c",
        "filename": "bitcoin-qt.pro",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cb16f39e6fd45a268ca895b4328282dbb2718e8b/bitcoin-qt.pro",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cb16f39e6fd45a268ca895b4328282dbb2718e8b/bitcoin-qt.pro",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/bitcoin-qt.pro?ref=cb16f39e6fd45a268ca895b4328282dbb2718e8b",
        "patch": "@@ -2,8 +2,8 @@ TEMPLATE = app\n TARGET =\n VERSION = 0.6.99\n INCLUDEPATH += src src/json src/qt\n-DEFINES += QT_GUI BOOST_THREAD_USE_LIB USE_IPV6\n-CONFIG += no_include_pwd\n+DEFINES += QT_GUI BOOST_THREAD_USE_LIB USE_IPV6 DEBUG_LOCKORDER DEBUG_LOCKCONTENTION\n+CONFIG += no_include_pwd debug\n \n # for boost 1.37, add -mt to the boost libraries \n # use: qmake BOOST_LIB_SUFFIX=-mt"
      }
    ]
  }
]