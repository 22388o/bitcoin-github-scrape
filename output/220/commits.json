[
  {
    "sha": "68e308e1a1671f5bce026f6e7bfb8e19b4e26669",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2OGUzMDhlMWExNjcxZjViY2UwMjZmNmU3YmZiOGUxOWI0ZTI2NjY5",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2011-07-17T19:14:58Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2011-12-19T15:39:04Z"
      },
      "message": "Key removal\n\nIntroduces a new RPC call, defined in rpcdump.cpp:\n* removeprivkey: delete a private key from your wallet",
      "tree": {
        "sha": "577679da5a02637f5e8c059d5ad01b58b9166ffa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/577679da5a02637f5e8c059d5ad01b58b9166ffa"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/68e308e1a1671f5bce026f6e7bfb8e19b4e26669",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/68e308e1a1671f5bce026f6e7bfb8e19b4e26669",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/68e308e1a1671f5bce026f6e7bfb8e19b4e26669",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/68e308e1a1671f5bce026f6e7bfb8e19b4e26669/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "99a289f531e9dc42aa81ea32ff84b807a46b6a9c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/99a289f531e9dc42aa81ea32ff84b807a46b6a9c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/99a289f531e9dc42aa81ea32ff84b807a46b6a9c"
      }
    ],
    "stats": {
      "total": 171,
      "additions": 144,
      "deletions": 27
    },
    "files": [
      {
        "sha": "d56197a5f2884d808eb306a815f6d47da8a26e2f",
        "filename": "src/bitcoinrpc.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/68e308e1a1671f5bce026f6e7bfb8e19b4e26669/src/bitcoinrpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/68e308e1a1671f5bce026f6e7bfb8e19b4e26669/src/bitcoinrpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.cpp?ref=68e308e1a1671f5bce026f6e7bfb8e19b4e26669",
        "patch": "@@ -45,6 +45,7 @@ static CCriticalSection cs_nWalletUnlockTime;\n \n extern Value dumpprivkey(const Array& params, bool fHelp);\n extern Value importprivkey(const Array& params, bool fHelp);\n+extern Value removeprivkey(const Array& params, bool fHelp);\n \n Object JSONRPCError(int code, const string& message)\n {\n@@ -365,6 +366,10 @@ CBitcoinAddress GetAccountAddress(string strAccount, bool bForceNew=false)\n     CAccount account;\n     walletdb.ReadAccount(strAccount, account);\n \n+    // delayed removal of deleted keys\n+    if (!pwalletMain->HaveKey(CBitcoinAddress(account.vchPubKey)))\n+        account.vchPubKey.clear();\n+\n     bool bKeyUsed = false;\n \n     // Check if the current key has been used\n@@ -1851,7 +1856,8 @@ pair<string, rpcfn_type> pCallTable[] =\n     make_pair(\"getmemorypool\",          &getmemorypool),\n     make_pair(\"listsinceblock\",         &listsinceblock),\n     make_pair(\"dumpprivkey\",            &dumpprivkey),\n-    make_pair(\"importprivkey\",          &importprivkey)\n+    make_pair(\"importprivkey\",          &importprivkey),\n+    make_pair(\"removeprivkey\",          &removeprivkey),\n };\n map<string, rpcfn_type> mapCallTable(pCallTable, pCallTable + sizeof(pCallTable)/sizeof(pCallTable[0]));\n "
      },
      {
        "sha": "54c7a8e59bb78923326fa793dc49f1038d6ba14e",
        "filename": "src/db.h",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/68e308e1a1671f5bce026f6e7bfb8e19b4e26669/src/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/68e308e1a1671f5bce026f6e7bfb8e19b4e26669/src/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.h?ref=68e308e1a1671f5bce026f6e7bfb8e19b4e26669",
        "patch": "@@ -401,6 +401,18 @@ class CWalletDB : public CDB\n         return Write(std::make_pair(std::string(\"key\"), vchPubKey), vchPrivKey, false);\n     }\n \n+    bool EraseKey(const std::vector<unsigned char>& vchPubKey)\n+    {\n+        nWalletDBUpdated++;\n+        return Erase(std::make_pair(std::string(\"key\"), vchPubKey));\n+    }\n+\n+    bool EraseCryptedKey(const std::vector<unsigned char>& vchPubKey)\n+    {\n+        nWalletDBUpdated++;\n+        return Erase(std::make_pair(std::string(\"ckey\"), vchPubKey));\n+    }\n+\n     bool WriteCryptedKey(const std::vector<unsigned char>& vchPubKey, const std::vector<unsigned char>& vchCryptedSecret, bool fEraseUnencryptedKey = true)\n     {\n         nWalletDBUpdated++;"
      },
      {
        "sha": "4f88721c13376fb9b2664ba3d0de2c53920bd605",
        "filename": "src/keystore.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/68e308e1a1671f5bce026f6e7bfb8e19b4e26669/src/keystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/68e308e1a1671f5bce026f6e7bfb8e19b4e26669/src/keystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.cpp?ref=68e308e1a1671f5bce026f6e7bfb8e19b4e26669",
        "patch": "@@ -46,6 +46,13 @@ bool CCryptoKeyStore::SetCrypted()\n     return true;\n }\n \n+bool CBasicKeyStore::RemoveKey(const CBitcoinAddress& address)\n+{\n+    CRITICAL_BLOCK(cs_KeyStore)\n+        mapKeys.erase(address);\n+    return true;\n+}\n+\n std::vector<unsigned char> CCryptoKeyStore::GenerateNewKey()\n {\n     RandAddSeedPerfmon();\n@@ -103,6 +110,17 @@ bool CCryptoKeyStore::AddKey(const CKey& key)\n     return true;\n }\n \n+bool CCryptoKeyStore::RemoveKey(const CBitcoinAddress& address)\n+{\n+    CRITICAL_BLOCK(cs_KeyStore)\n+    {\n+        if (!IsCrypted())\n+            return CBasicKeyStore::RemoveKey(address);\n+        mapCryptedKeys.erase(address);\n+    }\n+    return true;\n+}\n+\n \n bool CCryptoKeyStore::AddCryptedKey(const std::vector<unsigned char> &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret)\n {"
      },
      {
        "sha": "a42dd1fdc4cd0356145f23c2541ae3dcb404ad6f",
        "filename": "src/keystore.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/68e308e1a1671f5bce026f6e7bfb8e19b4e26669/src/keystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/68e308e1a1671f5bce026f6e7bfb8e19b4e26669/src/keystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.h?ref=68e308e1a1671f5bce026f6e7bfb8e19b4e26669",
        "patch": "@@ -19,6 +19,7 @@ class CKeyStore\n \n     // Check whether a key corresponding to a given address is present in the store.\n     virtual bool HaveKey(const CBitcoinAddress &address) const =0;\n+    virtual bool RemoveKey(const CBitcoinAddress &address) =0;\n     virtual bool GetKey(const CBitcoinAddress &address, CKey& keyOut) const \n     {\n         CSecret vchSecret;\n@@ -60,6 +61,7 @@ class CBasicKeyStore : public CKeyStore\n             result = (mapKeys.count(address) > 0);\n         return result;\n     }\n+    bool RemoveKey(const CBitcoinAddress &address);\n     void GetKeys(std::set<CBitcoinAddress> &setAddress) const\n     {\n         setAddress.clear();\n@@ -145,6 +147,7 @@ class CCryptoKeyStore : public CBasicKeyStore\n     virtual bool AddCryptedKey(const std::vector<unsigned char> &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret);\n     std::vector<unsigned char> GenerateNewKey();\n     bool AddKey(const CKey& key);\n+    bool RemoveKey(const CBitcoinAddress &address);\n     bool HaveKey(const CBitcoinAddress &address) const\n     {\n         CRITICAL_BLOCK(cs_KeyStore)"
      },
      {
        "sha": "c64e8930c96fb5783a86decf07587c326f3f6bfa",
        "filename": "src/rpcdump.cpp",
        "status": "modified",
        "additions": 34,
        "deletions": 18,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/68e308e1a1671f5bce026f6e7bfb8e19b4e26669/src/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/68e308e1a1671f5bce026f6e7bfb8e19b4e26669/src/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcdump.cpp?ref=68e308e1a1671f5bce026f6e7bfb8e19b4e26669",
        "patch": "@@ -27,24 +27,6 @@ using namespace std;\n \n extern Object JSONRPCError(int code, const string& message);\n \n-class CTxDump\n-{\n-public:\n-    CBlockIndex *pindex;\n-    int64 nValue;\n-    bool fSpent;\n-    CWalletTx* ptx;\n-    int nOut;\n-    CTxDump(CWalletTx* ptx = NULL, int nOut = -1)\n-    {\n-        pindex = NULL;\n-        nValue = 0;\n-        fSpent = false;\n-        this->ptx = ptx;\n-        this->nOut = nOut;\n-    }\n-};\n-\n Value importprivkey(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() < 1 || params.size() > 2)\n@@ -83,6 +65,40 @@ Value importprivkey(const Array& params, bool fHelp)\n     return Value::null;\n }\n \n+Value removeprivkey(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 1 || params.size() > 1)\n+        throw runtime_error(\n+            \"removeprivkey <bitcoinprivkey>\\n\"\n+            \"Removes a private key (as returned by dumpprivkey) from your wallet.\\n\"\n+            \"Warning: this will remove transactions from your wallet, and may change the balance of unrelated accounts.\\n\");\n+\n+    string strSecret = params[0].get_str();\n+    CBitcoinSecret vchSecret;\n+    bool fGood = vchSecret.SetString(strSecret);\n+\n+    if (!fGood) throw JSONRPCError(-5,\"Invalid private key\");\n+\n+    CKey key;\n+    key.SetSecret(vchSecret.GetSecret());\n+    CBitcoinAddress address(key.GetPubKey());\n+\n+    CRITICAL_BLOCK(pwalletMain->cs_wallet)\n+    {\n+        pwalletMain->MarkDirty();\n+        if (!pwalletMain->RemoveKey(address))\n+            throw JSONRPCError(-4,\"Error removing key from wallet\");\n+\n+        pwalletMain->DelAddressBookName(address);\n+    }\n+\n+    MainFrameRepaint();\n+\n+    return Value::null;\n+}\n+\n+\n+\n Value dumpprivkey(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() != 1)"
      },
      {
        "sha": "bff65cba293a1bd73c6c4667a5b918923bbb5412",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 66,
        "deletions": 7,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/68e308e1a1671f5bce026f6e7bfb8e19b4e26669/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/68e308e1a1671f5bce026f6e7bfb8e19b4e26669/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=68e308e1a1671f5bce026f6e7bfb8e19b4e26669",
        "patch": "@@ -336,12 +336,15 @@ bool CWallet::EraseFromWallet(uint256 hash)\n     CRITICAL_BLOCK(cs_wallet)\n     {\n         if (mapWallet.erase(hash))\n-            CWalletDB(strWalletFile).EraseTx(hash);\n+        {\n+            if (fFileBacked)\n+                if (!CWalletDB(strWalletFile).EraseTx(hash))\n+                    return false;\n+        }\n     }\n     return true;\n }\n \n-\n bool CWallet::IsMine(const CTxIn &txin) const\n {\n     CRITICAL_BLOCK(cs_wallet)\n@@ -358,6 +361,64 @@ bool CWallet::IsMine(const CTxIn &txin) const\n     return false;\n }\n \n+int CWallet::PurgeWallet()\n+{\n+    int nPurged=0;\n+\n+    CRITICAL_BLOCK(cs_wallet)\n+    {\n+        vector<uint256> vToDelete;\n+        map<uint256, CWalletTx>::iterator mi = mapWallet.begin();\n+        while (mi != mapWallet.end())\n+        {\n+            CWalletTx &wtx = (*mi).second;\n+            if (!IsMine(wtx) && !IsFromMe(wtx))\n+                vToDelete.push_back(wtx.GetHash());\n+            mi++;\n+        }\n+        vector<uint256>::iterator mi2 = vToDelete.begin();\n+        while (mi2 != vToDelete.end())\n+        {\n+            if (EraseFromWallet(*mi2))\n+                nPurged++;\n+            mi2++;\n+        }\n+    }\n+    return nPurged;\n+}\n+\n+bool CWallet::RemoveKey(const CBitcoinAddress &address)\n+{\n+    CRITICAL_BLOCK(cs_KeyStore)\n+    CRITICAL_BLOCK(cs_wallet)\n+    {\n+        map<CBitcoinAddress,int64> mapReserveAddresses;\n+        GetAllReserveAddresses(mapReserveAddresses);\n+        vector<unsigned char> vchPubKey;\n+        bool fRet = GetPubKey(address, vchPubKey);\n+        if (!fRet)\n+            return false;\n+        fRet = CCryptoKeyStore::RemoveKey(address);\n+        if (!fRet)\n+            return false;\n+        if (IsCrypted())\n+            fRet = CWalletDB(strWalletFile).EraseCryptedKey(vchPubKey);\n+        else\n+            fRet = CWalletDB(strWalletFile).EraseKey(vchPubKey);\n+        if (!fRet)\n+            return false;\n+        if (mapReserveAddresses.count(address))\n+        {\n+            int64 nIndex = mapReserveAddresses[address];\n+            setKeyPool.erase(nIndex);\n+            KeepKey(nIndex);\n+        }\n+        PurgeWallet();\n+        return true;\n+    }\n+    return false;\n+}\n+\n int64 CWallet::GetDebit(const CTxIn &txin) const\n {\n     CRITICAL_BLOCK(cs_wallet)\n@@ -1345,7 +1406,6 @@ void CWallet::ReserveKeyFromKeyPool(int64& nIndex, CKeyPool& keypool)\n \n int64 CWallet::AddReserveKey(const CKeyPool& keypool)\n {\n-    CRITICAL_BLOCK(cs_main)\n     CRITICAL_BLOCK(cs_wallet)\n     {\n         CWalletDB walletdb(strWalletFile);\n@@ -1447,13 +1507,12 @@ void CReserveKey::ReturnKey()\n     vchPubKey.clear();\n }\n \n-void CWallet::GetAllReserveAddresses(set<CBitcoinAddress>& setAddress)\n+void CWallet::GetAllReserveAddresses(map<CBitcoinAddress,int64>& mapAddress)\n {\n-    setAddress.clear();\n+    mapAddress.clear();\n \n     CWalletDB walletdb(strWalletFile);\n \n-    CRITICAL_BLOCK(cs_main)\n     CRITICAL_BLOCK(cs_wallet)\n     BOOST_FOREACH(const int64& id, setKeyPool)\n     {\n@@ -1464,6 +1523,6 @@ void CWallet::GetAllReserveAddresses(set<CBitcoinAddress>& setAddress)\n         assert(!keypool.vchPubKey.empty());\n         if (!HaveKey(address))\n             throw runtime_error(\"GetAllReserveKeyHashes() : unknown key in key pool\");\n-        setAddress.insert(address);\n+        mapAddress[address] = id;\n     }\n }"
      },
      {
        "sha": "0d1888253cd1ecfc02780a1539831bcc83e3fc64",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/68e308e1a1671f5bce026f6e7bfb8e19b4e26669/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/68e308e1a1671f5bce026f6e7bfb8e19b4e26669/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=68e308e1a1671f5bce026f6e7bfb8e19b4e26669",
        "patch": "@@ -62,6 +62,8 @@ class CWallet : public CCryptoKeyStore\n     // keystore implementation\n     // Adds a key to the store, and saves it to disk.\n     bool AddKey(const CKey& key);\n+    // Remove a key from the store\n+    bool RemoveKey(const CBitcoinAddress &address);\n     // Adds a key to the store, without saving it to disk (used by LoadWallet)\n     bool LoadKey(const CKey& key) { return CCryptoKeyStore::AddKey(key); }\n \n@@ -78,6 +80,7 @@ class CWallet : public CCryptoKeyStore\n     bool AddToWallet(const CWalletTx& wtxIn);\n     bool AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pblock, bool fUpdate = false, bool fFindBlock = false);\n     bool EraseFromWallet(uint256 hash);\n+    int PurgeWallet();\n     void WalletUpdateSpent(const CTransaction& prevout);\n     int ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate = false);\n     int ScanForWalletTransaction(const uint256& hashTx);\n@@ -100,7 +103,7 @@ class CWallet : public CCryptoKeyStore\n     void ReturnKey(int64 nIndex);\n     bool GetKeyFromPool(std::vector<unsigned char> &key, bool fAllowReuse=true);\n     int64 GetOldestKeyPoolTime();\n-    void GetAllReserveAddresses(std::set<CBitcoinAddress>& setAddress);\n+    void GetAllReserveAddresses(std::map<CBitcoinAddress,int64>& mapAddress);\n \n     bool IsMine(const CTxIn& txin) const;\n     int64 GetDebit(const CTxIn& txin) const;"
      }
    ]
  },
  {
    "sha": "5e920af78f17aa4bd73ad41879d1f34477908c62",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ZTkyMGFmNzhmMTdhYTRiZDczYWQ0MTg3OWQxZjM0NDc3OTA4YzYy",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2011-07-11T19:50:44Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2011-12-19T15:39:04Z"
      },
      "message": "Wallet import and export\n\nIntroduces two new RPC calls, defined in rpcdump.cpp:\n* dumpwallet: export the contents of your wallet in various ways\n* importwallet: import/merge a dumped wallet into your own.",
      "tree": {
        "sha": "6a3112ca76302f759b75d0a949c1b67bd425a26e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6a3112ca76302f759b75d0a949c1b67bd425a26e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5e920af78f17aa4bd73ad41879d1f34477908c62",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5e920af78f17aa4bd73ad41879d1f34477908c62",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5e920af78f17aa4bd73ad41879d1f34477908c62",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5e920af78f17aa4bd73ad41879d1f34477908c62/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "68e308e1a1671f5bce026f6e7bfb8e19b4e26669",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/68e308e1a1671f5bce026f6e7bfb8e19b4e26669",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/68e308e1a1671f5bce026f6e7bfb8e19b4e26669"
      }
    ],
    "stats": {
      "total": 458,
      "additions": 456,
      "deletions": 2
    },
    "files": [
      {
        "sha": "409e4a5d79fc48e658ba40c1af9657e5d8df6c97",
        "filename": "src/bitcoinrpc.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 2,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e920af78f17aa4bd73ad41879d1f34477908c62/src/bitcoinrpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e920af78f17aa4bd73ad41879d1f34477908c62/src/bitcoinrpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.cpp?ref=5e920af78f17aa4bd73ad41879d1f34477908c62",
        "patch": "@@ -14,10 +14,9 @@\n #include <boost/iostreams/stream.hpp>\n #include <boost/algorithm/string.hpp>\n #include <boost/lexical_cast.hpp>\n+#include <fstream>\n #ifdef USE_SSL\n #include <boost/asio/ssl.hpp> \n-#include <boost/filesystem.hpp>\n-#include <boost/filesystem/fstream.hpp>\n typedef boost::asio::ssl::stream<boost::asio::ip::tcp::socket> SSLStream;\n #endif\n #include \"json/json_spirit_reader_template.h\"\n@@ -46,6 +45,8 @@ static CCriticalSection cs_nWalletUnlockTime;\n extern Value dumpprivkey(const Array& params, bool fHelp);\n extern Value importprivkey(const Array& params, bool fHelp);\n extern Value removeprivkey(const Array& params, bool fHelp);\n+extern Value dumpwallet(const Array& params, bool fHelp);\n+extern Value importwallet(const Array& params, bool fHelp);\n \n Object JSONRPCError(int code, const string& message)\n {\n@@ -1858,6 +1859,8 @@ pair<string, rpcfn_type> pCallTable[] =\n     make_pair(\"dumpprivkey\",            &dumpprivkey),\n     make_pair(\"importprivkey\",          &importprivkey),\n     make_pair(\"removeprivkey\",          &removeprivkey),\n+    make_pair(\"dumpwallet\",             &dumpwallet),\n+    make_pair(\"importwallet\",           &importwallet),\n };\n map<string, rpcfn_type> mapCallTable(pCallTable, pCallTable + sizeof(pCallTable)/sizeof(pCallTable[0]));\n \n@@ -2490,6 +2493,19 @@ int CommandLineRPC(int argc, char *argv[])\n             params[1] = v.get_obj();\n         }\n         if (strMethod == \"sendmany\"                && n > 2) ConvertTo<boost::int64_t>(params[2]);\n+        if (strMethod == \"importwallet\"            && n > 0)\n+        {\n+            ifstream file;\n+            file.open(params[0].get_str().c_str());\n+            if (!file.good())\n+                throw runtime_error(\"cannot read file\");\n+            stringbuf buf;\n+            file.get(buf, -1);\n+            Value v;\n+            if (!read_string(buf.str(), v))\n+                throw runtime_error(\"cannot parse file\");\n+            params[0] = v.get_obj();\n+        }\n \n         // Execute\n         Object reply = CallRPC(strMethod, params);"
      },
      {
        "sha": "3e7dac249b82a62f3db14966b44869f30213dc06",
        "filename": "src/rpcdump.cpp",
        "status": "modified",
        "additions": 438,
        "deletions": 0,
        "changes": 438,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5e920af78f17aa4bd73ad41879d1f34477908c62/src/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5e920af78f17aa4bd73ad41879d1f34477908c62/src/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcdump.cpp?ref=5e920af78f17aa4bd73ad41879d1f34477908c62",
        "patch": "@@ -27,6 +27,130 @@ using namespace std;\n \n extern Object JSONRPCError(int code, const string& message);\n \n+class CTxDump\n+{\n+public:\n+    CBlockIndex *pindex;\n+    int64 nValue;\n+    bool fSpent;\n+    CWalletTx* ptx;\n+    int nOut;\n+    CTxDump(CWalletTx* ptx = NULL, int nOut = -1)\n+    {\n+        pindex = NULL;\n+        nValue = 0;\n+        fSpent = false;\n+        this->ptx = ptx;\n+        this->nOut = nOut;\n+    }\n+};\n+\n+class CKeyDump\n+{\n+private:\n+    void Init()\n+    {\n+        strLabel = \"\";\n+        pindexUsed = NULL;\n+        pindexAvail = NULL;\n+        nValue = 0;\n+        nAvail = 0;\n+        fReserve = false;\n+        fUsed = false;\n+        fLabel = false;\n+    }\n+public:\n+    CBitcoinSecret secret;\n+    string strLabel;\n+    bool fLabel;\n+    CBlockIndex *pindexUsed;\n+    CBlockIndex *pindexAvail;\n+    int64 nValue;\n+    int64 nAvail;\n+    vector<CTxDump> vtxdmp;\n+    bool fReserve;\n+    bool fUsed;\n+    CKeyDump(const CSecret &vchSecretIn) : secret(vchSecretIn)\n+    {\n+        Init();\n+    }\n+    CKeyDump()\n+    {\n+        Init();\n+    }\n+};\n+\n+void static GetWalletDump(map<CBitcoinAddress,CKeyDump> &mapDump)\n+{\n+    CRITICAL_BLOCK(cs_main)\n+    CRITICAL_BLOCK(pwalletMain->cs_wallet)\n+    {\n+        set<CBitcoinAddress> setAddress;\n+        pwalletMain->GetKeys(setAddress);\n+        for (set<CBitcoinAddress>::iterator it = setAddress.begin(); it != setAddress.end(); ++it)\n+        {\n+            CKey key;\n+            if (pwalletMain->GetKey(*it, key))\n+                mapDump[*it] = CKeyDump(key.GetSecret());\n+        }\n+        for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n+        {\n+            CWalletTx* coin=&(*it).second;\n+            CBlockIndex *pindex;\n+            if (coin->GetDepthInMainChain(pindex)>0)\n+            {\n+                for (int i=0; i < coin->vout.size(); i++) \n+                {\n+                    CTxOut &out = coin->vout[i];\n+                    int64 nCredit = pwalletMain->GetCredit(out);\n+                    if (nCredit > 0)\n+                    {\n+                        CTxDump txdmp(coin,i);\n+                        txdmp.pindex = pindex;\n+                        txdmp.nValue = nCredit;\n+                        txdmp.fSpent = coin->IsSpent(i);\n+                        CBitcoinAddress vchAddress;\n+                        ExtractAddress(out.scriptPubKey, pwalletMain, vchAddress);\n+                        if (mapDump.count(vchAddress) == 0)\n+                        {\n+                            CSecret vchSecretDummy;\n+                            mapDump[vchAddress] = CKeyDump(vchSecretDummy);\n+                        }\n+                        CKeyDump &keydump = mapDump[vchAddress];\n+                        if (keydump.pindexUsed==NULL || keydump.pindexUsed->nHeight > txdmp.pindex->nHeight)\n+                            keydump.pindexUsed = txdmp.pindex;\n+                        if (!txdmp.fSpent && (keydump.pindexAvail==NULL || keydump.pindexAvail->nHeight > txdmp.pindex->nHeight))\n+                            keydump.pindexAvail = txdmp.pindex;\n+                        keydump.nValue += txdmp.nValue;\n+                        if (!txdmp.fSpent)\n+                            keydump.nAvail += txdmp.nValue;\n+                        keydump.vtxdmp.push_back(txdmp);\n+                        keydump.fUsed = true;\n+                    }\n+                }\n+            }\n+        }\n+        map<CBitcoinAddress, int64> mapReserveAddresses;\n+        pwalletMain->GetAllReserveAddresses(mapReserveAddresses);\n+        for (map<CBitcoinAddress, int64>::const_iterator it = mapReserveAddresses.begin(); it != mapReserveAddresses.end(); ++it)\n+        {\n+             const CBitcoinAddress &address = (*it).first;\n+             if (mapDump.count(address) && !mapDump[address].fUsed)\n+                 mapDump[address].fReserve = true;\n+        }\n+        for (map<CBitcoinAddress, CKeyDump>::iterator it = mapDump.begin(); it != mapDump.end(); ++it)\n+        {\n+            const CBitcoinAddress& vchAddress = (*it).first;\n+            if (pwalletMain->mapAddressBook.count(vchAddress))\n+            {\n+                (*it).second.fLabel = true;\n+                (*it).second.fReserve = false;\n+                (*it).second.strLabel = pwalletMain->mapAddressBook[vchAddress];\n+            }\n+        }\n+    }\n+}\n+\n Value importprivkey(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() < 1 || params.size() > 2)\n@@ -115,3 +239,317 @@ Value dumpprivkey(const Array& params, bool fHelp)\n         throw JSONRPCError(-4,\"Private key for address \" + strAddress + \" is not known\");\n     return CBitcoinSecret(vchSecret).ToString();\n }\n+\n+Value importwallet(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 1)\n+        throw runtime_error(\n+            \"importwallet <file> [options]...\\n\"\n+            \"Import dumped wallet.\\nOptions:\\n\"\n+            \"    rescan:   rescan for transactions after dump was made\\n\"\n+        );\n+\n+    bool fRescan=false;\n+    for (int i = 1; i<params.size(); i++)\n+    {\n+        string strArg = params[i].get_str();\n+        if (strArg == \"rescan\")\n+            fRescan = true;\n+    }\n+\n+    CRITICAL_BLOCK(cs_main)\n+    CRITICAL_BLOCK(pwalletMain->cs_wallet)\n+    {\n+        pwalletMain->MarkDirty();\n+\n+        int nKnownHeight = 0;\n+        int nRescanHeight = pindexBest->nHeight;\n+        set<uint256> setRescanTx;\n+        set<CBitcoinAddress> setReserveKey;\n+\n+        Object objDump = params[0].get_obj();\n+\n+        Value valLoc = find_value(objDump, \"loc\");\n+        if (valLoc.type() != null_type)\n+        {\n+            vector<uint256> vblockKnown;\n+            Object objLoc = valLoc.get_obj();\n+            map<string,Value> mapLoc;\n+            obj_to_map(objLoc, mapLoc);\n+            BOOST_FOREACH(PAIRTYPE(const string, Value)& item, mapLoc)\n+                vblockKnown.push_back(uint256(item.first));\n+            CBlockLocator locatorDump = vblockKnown;\n+            nKnownHeight = locatorDump.GetHeight();\n+            printf(\"import: known height: %i\\n\", nKnownHeight);\n+        }\n+\n+        if (fRescan)\n+            nRescanHeight = nKnownHeight;\n+\n+        Value valKeys = find_value(objDump, \"keys\");\n+        if (valKeys.type() != null_type)\n+        {\n+            Array arrKeys = valKeys.get_array();\n+            BOOST_FOREACH(const Value& valKey, arrKeys)\n+            {\n+                // iterate over keys\n+                Object objKey = valKey.get_obj();\n+                string strSecret = find_value(objKey, \"sec\").get_str();\n+                CBitcoinSecret secret;\n+                if (!secret.SetString(strSecret))\n+                    continue;\n+                CKey key;\n+                if (!key.SetSecret(secret.GetSecret()))\n+                    continue;\n+                vector<unsigned char> vchPubKey = key.GetPubKey();\n+                CBitcoinAddress address(vchPubKey);\n+                string strAddress = address.ToString();\n+                printf(\"import: added address %s\\n\",strAddress.c_str());\n+                pwalletMain->AddKey(key);\n+                Value valLabel = find_value(objKey, \"label\");\n+                if (valLabel.type() != null_type)\n+                {\n+                    string strLabel = valLabel.get_str();\n+                    pwalletMain->SetAddressBookName(address, strLabel);\n+                    printf(\"import: set label of address %s to '%s'\\n\",strAddress.c_str(),strLabel.c_str());\n+                }\n+                if (find_value(objKey, \"reserve\").type() != null_type)\n+                {\n+                    setReserveKey.insert(address);\n+                    printf(\"import: %s preliminarily marked reserve\\n\",strAddress.c_str());\n+                }\n+                Value valTxs = find_value(objKey, \"tx\");\n+                if (valTxs.type() != null_type) // transactions are listed, check them\n+                {\n+                    Object objTxs = valTxs.get_obj();\n+                    map<string, Value> mapTxs;\n+                    obj_to_map(objTxs, mapTxs);\n+                    BOOST_FOREACH(PAIRTYPE(const string, Value)& item, mapTxs) // loop over transactions\n+                    {\n+                        Object objTx = item.second.get_obj();\n+                        Value valTxHeight = find_value(objTx, \"height\");\n+                        int nTxHeight = -1;\n+                        string strTxOut = item.first;\n+                        size_t nPos = strTxOut.find_first_of(':');\n+                        if (nPos != string::npos) // strip off nOut from tx string\n+                            strTxOut = strTxOut.substr(0, nPos);\n+                        if (valTxHeight.type() != null_type)\n+                            nTxHeight = valTxHeight.get_int();\n+                        if (nTxHeight <= nRescanHeight) // tx height is unknown, or below height from which we will rescan anyway\n+                        {\n+                            uint256 hashTx = uint256(strTxOut);\n+                            setRescanTx.insert(hashTx);\n+                            printf(\"import: %s will cause rescan of tx %s\\n\",hashTx.GetHex().c_str());\n+                        }\n+                    }\n+                }\n+                else\n+                {\n+                    Value valHeight = find_value(objKey, \"height\");\n+                    if (valHeight.type() != null_type)\n+                    {\n+                        int nHeight = valHeight.get_int();\n+                        if (nHeight <= nRescanHeight) // height is below height from which we will rescan anyway\n+                        {\n+                            nRescanHeight = nHeight-1;\n+                            printf(\"import: %s will need rescan from block %i\\n\",strAddress.c_str(),nHeight);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        // rescan separate tx's\n+        BOOST_FOREACH(const uint256& hashTx, setRescanTx)\n+        {\n+            printf(\"import: rescanning tx %s\\n\",hashTx.GetHex().c_str());\n+            pwalletMain->ScanForWalletTransaction(hashTx);\n+        }\n+        CBlockIndex* pindex = pindexGenesisBlock;\n+        while (pindex && pindex->nHeight <= nRescanHeight)\n+            pindex = pindex->pnext;\n+        // rescan the end completely\n+        printf(\"import: rescanning from height %i\\n\",nRescanHeight+1);\n+        pwalletMain->ScanForWalletTransactions(pindex, true);\n+\n+        if (nRescanHeight != pindexBest->nHeight && !setReserveKey.empty())\n+        {\n+            printf(\"import: scanning preliminary reserve keys\\n\");\n+            // scan wallet for transactions crediting imported reserve keys\n+            BOOST_FOREACH(const PAIRTYPE(uint256,CWalletTx)& item, pwalletMain->mapWallet)\n+            {\n+                BOOST_FOREACH(const CTxOut& txout, item.second.vout)\n+                {\n+                    CBitcoinAddress address;\n+                    if (ExtractAddress(txout.scriptPubKey, pwalletMain, address))\n+                    {\n+                        if (setReserveKey.count(address))\n+                        {\n+                            printf(\"import: wallettx %s credits %s: not reserve\\n\",item.first.GetHex().c_str(),address.ToString().c_str());\n+                            setReserveKey.erase(address);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        // add remaining reserve keys to pool\n+        BOOST_FOREACH(const CBitcoinAddress& address, setReserveKey)\n+        {\n+            vector<unsigned char> vchPubKey;\n+            if (!pwalletMain->GetPubKey(address, vchPubKey))\n+                continue;\n+            printf(\"import: adding %s to key pool\\n\",address.ToString().c_str());\n+            pwalletMain->AddReserveKey(CKeyPool(vchPubKey));\n+        }\n+\n+        pwalletMain->ReacceptWalletTransactions();\n+    }\n+\n+    MainFrameRepaint();\n+\n+    printf(\"import: done\\n\");\n+    return \"\";\n+}\n+\n+Value dumpwallet(const Array& params, bool fHelp)\n+{\n+    if (fHelp)\n+        throw runtime_error(\n+            \"dumpwallet [option]...\\n\"\n+            \"Dump wallet.\\nOptions:\\n\"\n+            \"    block:      include block information\\n\"\n+            \"    tx:         include transaction-specific information\\n\"\n+            \"    noreserve:  do not dump reserve keys\\n\"\n+            \"    nolabel:    do not include address labels\\n\"\n+            \"    nospent:    do not include spent keys/transactions\\n\"\n+            \"    terse:      do not include addresses and amounts\\n\"\n+            \"    compact:    no indentation or newlines\\n\"\n+            \"Not included in dump: configuration settings, unconfirmed\\n\"\n+            \"transactions, account information\"\n+        );\n+\n+    bool fBlock=false, fTx=false, fReserve=true, fLabel=true, fSpent=true,\n+         fAddr=true, fAmount=true, fCompact=false;\n+    for (int i = 0; i<params.size(); i++)\n+    {\n+        string strArg = params[i].get_str();\n+        if (strArg == \"block\")\n+            fBlock = true;\n+        if (strArg == \"tx\")\n+            fTx = true;\n+        if (strArg == \"noreserve\")\n+            fReserve = false;\n+        if (strArg == \"nolabel\")\n+            fLabel = false;\n+        if (strArg == \"nospent\")\n+            fSpent = false;\n+        if (strArg == \"terse\")\n+        {\n+            fAddr = false;\n+            fAmount = false;\n+        }\n+        if (strArg == \"compact\")\n+            fCompact = true;\n+        if (strArg == \"backup\")\n+        {\n+            fReserve = true;\n+            fLabel = true;\n+            fSpent = true;\n+        }\n+        if (strArg == \"scratchoff\")\n+        {\n+            fBlock = false;\n+            fTx = true;\n+            fReserve = false;\n+            fLabel = false;\n+            fSpent = false;\n+            fAddr = false;\n+            fAmount = false;\n+            fCompact = true;\n+        }\n+    }\n+\n+    map<CBitcoinAddress,CKeyDump> mapDump;\n+    GetWalletDump(mapDump);\n+    Array keys;\n+    int nHeight = pindexBest->nHeight;\n+    for (map<CBitcoinAddress, CKeyDump>::iterator it = mapDump.begin(); it != mapDump.end(); ++it)\n+    {\n+        CKeyDump &keydump = (*it).second;\n+        if (!fReserve && keydump.fReserve)\n+            continue;\n+        if (!fSpent && keydump.nAvail==0)\n+            continue;\n+        Object jsonKey;\n+        if (fAddr)\n+            jsonKey.push_back(Pair(\"addr\",(*it).first.ToString()));\n+        jsonKey.push_back(Pair(\"sec\",keydump.secret.ToString()));\n+        if (fLabel && keydump.fLabel)\n+            jsonKey.push_back(Pair(\"label\",keydump.strLabel));\n+        if (fBlock && !fTx && fSpent)\n+        {\n+            if (keydump.pindexUsed)\n+                jsonKey.push_back(Pair(\"height\",(boost::int64_t)keydump.pindexUsed->nHeight));\n+            else\n+                jsonKey.push_back(Pair(\"height\",(boost::int64_t)nHeight));\n+        }\n+        if (fBlock && !fTx)\n+        {\n+            if (keydump.pindexAvail)\n+                jsonKey.push_back(Pair(\"heightAvail\",(boost::int64_t)keydump.pindexAvail->nHeight));\n+            else\n+                jsonKey.push_back(Pair(\"heightAvail\",(boost::int64_t)nHeight));\n+        }\n+        if (fAmount && !fTx && keydump.fUsed && fSpent)\n+            jsonKey.push_back(Pair(\"value\",FormatMoney(keydump.nValue)));\n+        if (fAmount && !fTx && keydump.nAvail>0)\n+            jsonKey.push_back(Pair(\"valueAvail\",FormatMoney(keydump.nAvail)));\n+        if (keydump.fReserve)\n+            jsonKey.push_back(Pair(\"reserve\",(boost::int64_t)1));\n+        if (fTx)\n+        {\n+            Object jsonTxs;\n+            BOOST_FOREACH(CTxDump& txdump, keydump.vtxdmp)\n+            {\n+                Object jsonTx;\n+                if (!fSpent && txdump.fSpent)\n+                    continue;\n+                if (txdump.pindex)\n+                {\n+                    if (fBlock) \n+                        jsonTx.push_back(Pair(\"height\",(boost::int64_t)txdump.pindex->nHeight));\n+                }\n+                if (fAmount)\n+                    jsonTx.push_back(Pair(\"value\",FormatMoney(txdump.nValue)));\n+                if (txdump.fSpent)\n+                    jsonTx.push_back(Pair(\"spent\",(boost::int64_t)1));\n+                jsonTxs.push_back(Pair(txdump.ptx->GetHash().GetHex() + \":\" + boost::lexical_cast<std::string>(txdump.nOut),jsonTx));\n+            }\n+            jsonKey.push_back(Pair(\"tx\",jsonTxs));\n+        }\n+        keys.push_back(jsonKey);\n+    }\n+    Object ret;\n+    ret.push_back(Pair(\"keys\",keys));\n+    if (fBlock)\n+    {\n+        Object loc;\n+        CBlockIndex* pindexLoop = pindexBest;\n+        int nStep = 1;\n+        int nElem = 0;\n+        while (pindexLoop)\n+        {\n+            loc.push_back(Pair(pindexLoop->GetBlockHash().GetHex(),pindexLoop->nHeight));\n+            nElem++;\n+            for (int i = 0; pindexLoop && i < nStep; i++)\n+                pindexLoop = pindexLoop->pprev;\n+            if (nElem > 5)\n+                nStep *= 2;\n+        }\n+        ret.push_back(Pair(\"loc\",loc));\n+    }\n+    if (fCompact)\n+        return write_string(Value(ret), false);\n+    return ret;\n+}"
      }
    ]
  }
]