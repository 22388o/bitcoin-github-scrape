[
  {
    "sha": "0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowYTBkYjE1ZmM3ZDA5NjBkMDYwMTBkMmY4NWFlNmNlYjNiZDUzYTE2",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-08-16T03:33:53Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-08-16T03:33:53Z"
      },
      "message": "Squashed 'src/secp256k1/' changes from 2ed54da18a..5e5fb28b4a\n\n5e5fb28b4a Use additional system macros to figure out endianness\n979961c506 Merge #787: Use preprocessor macros instead of autoconf to detect endianness\n887bd1f8b6 Merge #793: Make scalar/field choice depend on C-detected __int128 availability\n0dccf98a21 Use preprocessor macros instead of autoconf to detect endianness\nb2c8c42cf1 Merge #795: Avoid linking libcrypto in the valgrind ct test.\n57d3a3c64c Avoid linking libcrypto in the valgrind ct test.\n79f1f7a4f1 Autodetect __int128 availability on the C side\n0d7727f95e Add SECP256K1_FE_STORAGE_CONST_GET to 5x52 field\n805082de11 Merge #696: Run a Travis test on s390x (big endian)\n39295362cf Test travis s390x (big endian)\n6034a04fb1 Merge #778: secp256k1_gej_double_nonzero supports infinity\nf60915906d Merge #779: travis: Fix argument quoting for ./configure\n9e49a9b255 travis: Fix argument quoting for ./configure\n18d36327fd secp256k1_gej_double_nonzero supports infinity\n214cb3c321 Merge #772: Improve constant-timeness on PowerPC\n40412b1930 Merge #774: tests: Abort if malloc() fails during context cloning tests\n2e1b9e0458 tests: Abort if malloc() fails during context cloning tests\n67a429f31f Suppress a harmless variable-time optimization by clang in _int_cmov\n5b196338f0 Remove redundant \"? 1 : 0\" after comparisons in scalar code\n3e5cfc5c73 Merge #741: Remove unnecessary sign variable from wnaf_const\n66bb9320c0 Merge #773: Fix some compile problems on weird/old compilers.\n1309c03c45 Fix some compile problems on weird/old compilers.\n2309c7dd4a Merge #769: Undef HAVE___INT128 in basic-config.h to fix gen_context compilation\n22e578bb11 Undef HAVE___INT128 in basic-config.h to fix gen_context compilation\n3f4a5a10e4 Merge #765: remove dead store in ecdsa_signature_parse_der_lax\nf00d6575ca remove dead store in ecdsa_signature_parse_der_lax\ndbd41db16a Merge #759: Fix uninitialized variables in ecmult_multi test\n2e7fc5b537 Fix uninitialized variables in ecmult_multi test\n37dba329c6 Remove unnecessary sign variable from wnaf_const\n6bb0b77e15 Fix test_constant_wnaf for -1 and add a test for it.\n\ngit-subtree-dir: src/secp256k1\ngit-subtree-split: 5e5fb28b4a45d7e35e55b5f5feead2be07bccc28",
      "tree": {
        "sha": "d02e8c0d7a975b5a3c3e6351946c182572afb9af",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d02e8c0d7a975b5a3c3e6351946c182572afb9af"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "67f232b5d874b501c114bced5d764db7f4f5ce99",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/67f232b5d874b501c114bced5d764db7f4f5ce99",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/67f232b5d874b501c114bced5d764db7f4f5ce99"
      }
    ],
    "stats": {
      "total": 379,
      "additions": 191,
      "deletions": 188
    },
    "files": [
      {
        "sha": "81d1ba894f15d397962faacc050e049b23d23c70",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 14,
        "deletions": 10,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16",
        "patch": "@@ -17,17 +17,17 @@ compiler:\n   - gcc\n env:\n   global:\n-    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ECMULTGENPRECISION=auto  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no  EXPERIMENTAL=no CTIMETEST=yes BENCH=yes ITERS=2\n+    - WIDEMUL=auto  BIGNUM=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ECMULTGENPRECISION=auto  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no  EXPERIMENTAL=no CTIMETEST=yes BENCH=yes ITERS=2\n   matrix:\n-    - SCALAR=32bit    RECOVERY=yes\n-    - SCALAR=32bit    FIELD=32bit       ECDH=yes  EXPERIMENTAL=yes\n-    - SCALAR=64bit\n-    - FIELD=64bit     RECOVERY=yes\n-    - FIELD=64bit     ENDOMORPHISM=yes\n-    - FIELD=64bit     ENDOMORPHISM=yes  ECDH=yes EXPERIMENTAL=yes\n-    - FIELD=64bit                       ASM=x86_64\n-    - FIELD=64bit     ENDOMORPHISM=yes  ASM=x86_64\n-    - FIELD=32bit     ENDOMORPHISM=yes\n+    - WIDEMUL=int64   RECOVERY=yes\n+    - WIDEMUL=int64   ECDH=yes  EXPERIMENTAL=yes\n+    - WIDEMUL=int64   ENDOMORPHISM=yes\n+    - WIDEMUL=int128\n+    - WIDEMUL=int128  RECOVERY=yes\n+    - WIDEMUL=int128  ENDOMORPHISM=yes\n+    - WIDEMUL=int128  ENDOMORPHISM=yes  ECDH=yes EXPERIMENTAL=yes\n+    - WIDEMUL=int128                    ASM=x86_64\n+    - WIDEMUL=int128  ENDOMORPHISM=yes  ASM=x86_64\n     - BIGNUM=no\n     - BIGNUM=no       ENDOMORPHISM=yes RECOVERY=yes EXPERIMENTAL=yes\n     - BIGNUM=no       STATICPRECOMPUTATION=no\n@@ -83,6 +83,10 @@ matrix:\n             - valgrind\n             - libtool-bin\n             - libc6-dbg:i386\n+    # S390x build (big endian system)\n+    - compiler: gcc\n+      env: HOST=s390x-unknown-linux-gnu ECDH=yes RECOVERY=yes EXPERIMENTAL=yes CTIMETEST=\n+      arch: s390x\n \n # We use this to install macOS dependencies instead of the built in `homebrew` plugin,\n # because in xcode earlier than 11 they have a bug requiring updating the system which overall takes ~8 minutes."
      },
      {
        "sha": "a30a84cd599c77a6ef52d7719129dfe97f140619",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16",
        "patch": "@@ -99,7 +99,7 @@ if VALGRIND_ENABLED\n tests_CPPFLAGS += -DVALGRIND\n noinst_PROGRAMS += valgrind_ctime_test\n valgrind_ctime_test_SOURCES = src/valgrind_ctime_test.c\n-valgrind_ctime_test_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n+valgrind_ctime_test_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_LIBS) $(COMMON_LIB)\n endif\n if !ENABLE_COVERAGE\n tests_CPPFLAGS += -DVERIFY"
      },
      {
        "sha": "57595f4499d8e10646e6cbb56417a831803786cd",
        "filename": "build-aux/m4/bitcoin_secp.m4",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/build-aux/m4/bitcoin_secp.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/build-aux/m4/bitcoin_secp.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/bitcoin_secp.m4?ref=0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16",
        "patch": "@@ -1,8 +1,3 @@\n-dnl libsecp25k1 helper checks\n-AC_DEFUN([SECP_INT128_CHECK],[\n-has_int128=$ac_cv_type___int128\n-])\n-\n dnl escape \"$0x\" below using the m4 quadrigaph @S|@, and escape it again with a \\ for the shell.\n AC_DEFUN([SECP_64BIT_ASM_CHECK],[\n AC_MSG_CHECKING(for x86_64 assembly availability)"
      },
      {
        "sha": "743f7f7ba9887a772a7159b9fcbe828c6b32794b",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 16,
        "deletions": 88,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16",
        "patch": "@@ -141,15 +141,13 @@ AC_ARG_ENABLE(external_default_callbacks,\n     [use_external_default_callbacks=$enableval],\n     [use_external_default_callbacks=no])\n \n-AC_ARG_WITH([field], [AS_HELP_STRING([--with-field=64bit|32bit|auto],\n-[finite field implementation to use [default=auto]])],[req_field=$withval], [req_field=auto])\n+dnl Test-only override of the (autodetected by the C code) \"widemul\" setting.\n+dnl Legal values are int64 (for [u]int64_t), int128 (for [unsigned] __int128), and auto (the default).\n+AC_ARG_WITH([test-override-wide-multiply], [] ,[set_widemul=$withval], [set_widemul=auto])\n \n AC_ARG_WITH([bignum], [AS_HELP_STRING([--with-bignum=gmp|no|auto],\n [bignum implementation to use [default=auto]])],[req_bignum=$withval], [req_bignum=auto])\n \n-AC_ARG_WITH([scalar], [AS_HELP_STRING([--with-scalar=64bit|32bit|auto],\n-[scalar implementation to use [default=auto]])],[req_scalar=$withval], [req_scalar=auto])\n-\n AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|arm|no|auto],\n [assembly optimizations to use\u00a0(experimental: arm) [default=auto]])],[req_asm=$withval], [req_asm=auto])\n \n@@ -170,8 +168,6 @@ AC_ARG_WITH([ecmult-gen-precision], [AS_HELP_STRING([--with-ecmult-gen-precision\n )],\n [req_ecmult_gen_precision=$withval], [req_ecmult_gen_precision=auto])\n \n-AC_CHECK_TYPES([__int128])\n-\n AC_CHECK_HEADER([valgrind/memcheck.h], [enable_valgrind=yes], [enable_valgrind=no], [])\n AM_CONDITIONAL([VALGRIND_ENABLED],[test \"$enable_valgrind\" = \"yes\"])\n \n@@ -265,63 +261,6 @@ else\n   esac\n fi\n \n-if test x\"$req_field\" = x\"auto\"; then\n-  if test x\"set_asm\" = x\"x86_64\"; then\n-    set_field=64bit\n-  fi\n-  if test x\"$set_field\" = x; then\n-    SECP_INT128_CHECK\n-    if test x\"$has_int128\" = x\"yes\"; then\n-      set_field=64bit\n-    fi\n-  fi\n-  if test x\"$set_field\" = x; then\n-    set_field=32bit\n-  fi\n-else\n-  set_field=$req_field\n-  case $set_field in\n-  64bit)\n-    if test x\"$set_asm\" != x\"x86_64\"; then\n-      SECP_INT128_CHECK\n-      if test x\"$has_int128\" != x\"yes\"; then\n-        AC_MSG_ERROR([64bit field explicitly requested but neither __int128 support or x86_64 assembly available])\n-      fi\n-    fi\n-    ;;\n-  32bit)\n-    ;;\n-  *)\n-    AC_MSG_ERROR([invalid field implementation selection])\n-    ;;\n-  esac\n-fi\n-\n-if test x\"$req_scalar\" = x\"auto\"; then\n-  SECP_INT128_CHECK\n-  if test x\"$has_int128\" = x\"yes\"; then\n-    set_scalar=64bit\n-  fi\n-  if test x\"$set_scalar\" = x; then\n-    set_scalar=32bit\n-  fi\n-else\n-  set_scalar=$req_scalar\n-  case $set_scalar in\n-  64bit)\n-    SECP_INT128_CHECK\n-    if test x\"$has_int128\" != x\"yes\"; then\n-      AC_MSG_ERROR([64bit scalar explicitly requested but __int128 support not available])\n-    fi\n-    ;;\n-  32bit)\n-    ;;\n-  *)\n-    AC_MSG_ERROR([invalid scalar implementation selected])\n-    ;;\n-  esac\n-fi\n-\n if test x\"$req_bignum\" = x\"auto\"; then\n   SECP_GMP_CHECK\n   if test x\"$has_gmp\" = x\"yes\"; then\n@@ -365,16 +304,18 @@ no)\n   ;;\n esac\n \n-# select field implementation\n-case $set_field in\n-64bit)\n-  AC_DEFINE(USE_FIELD_5X52, 1, [Define this symbol to use the FIELD_5X52 implementation])\n+# select wide multiplication implementation\n+case $set_widemul in\n+int128)\n+  AC_DEFINE(USE_FORCE_WIDEMUL_INT128, 1, [Define this symbol to force the use of the (unsigned) __int128 based wide multiplication implementation])\n+  ;;\n+int64)\n+  AC_DEFINE(USE_FORCE_WIDEMUL_INT64, 1, [Define this symbol to force the use of the (u)int64_t based wide multiplication implementation])\n   ;;\n-32bit)\n-  AC_DEFINE(USE_FIELD_10X26, 1, [Define this symbol to use the FIELD_10X26 implementation])\n+auto)\n   ;;\n *)\n-  AC_MSG_ERROR([invalid field implementation])\n+  AC_MSG_ERROR([invalid wide multiplication implementation])\n   ;;\n esac\n \n@@ -396,19 +337,6 @@ no)\n   ;;\n esac\n \n-#select scalar implementation\n-case $set_scalar in\n-64bit)\n-  AC_DEFINE(USE_SCALAR_4X64, 1, [Define this symbol to use the 4x64 scalar implementation])\n-  ;;\n-32bit)\n-  AC_DEFINE(USE_SCALAR_8X32, 1, [Define this symbol to use the 8x32 scalar implementation])\n-  ;;\n-*)\n-  AC_MSG_ERROR([invalid scalar implementation])\n-  ;;\n-esac\n-\n #set ecmult window size\n if test x\"$req_ecmult_window\" = x\"auto\"; then\n   set_ecmult_window=15\n@@ -493,8 +421,6 @@ if test x\"$enable_module_recovery\" = x\"yes\"; then\n   AC_DEFINE(ENABLE_MODULE_RECOVERY, 1, [Define this symbol to enable the ECDSA pubkey recovery module])\n fi\n \n-AC_C_BIGENDIAN()\n-\n if test x\"$use_external_asm\" = x\"yes\"; then\n   AC_DEFINE(USE_EXTERNAL_ASM, 1, [Define this symbol if an external (non-inline) assembly implementation is used])\n fi\n@@ -553,10 +479,12 @@ echo \"  module recovery         = $enable_module_recovery\"\n echo\n echo \"  asm                     = $set_asm\"\n echo \"  bignum                  = $set_bignum\"\n-echo \"  field                   = $set_field\"\n-echo \"  scalar                  = $set_scalar\"\n echo \"  ecmult window size      = $set_ecmult_window\"\n echo \"  ecmult gen prec. bits   = $set_ecmult_gen_precision\"\n+dnl Hide test-only options unless they're used.\n+if test x\"$set_widemul\" != xauto; then\n+echo \"  wide multiplication     = $set_widemul\"\n+fi\n echo\n echo \"  valgrind                = $enable_valgrind\"\n echo \"  CC                      = $CC\""
      },
      {
        "sha": "f71db4b53524cc1254190cb915f810adf3113ad7",
        "filename": "contrib/lax_der_parsing.c",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/contrib/lax_der_parsing.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/contrib/lax_der_parsing.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/lax_der_parsing.c?ref=0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16",
        "patch": "@@ -112,7 +112,6 @@ int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_\n         return 0;\n     }\n     spos = pos;\n-    pos += slen;\n \n     /* Ignore leading zeroes in R */\n     while (rlen > 0 && input[rpos] == 0) {"
      },
      {
        "sha": "2023d0b5ae984e69487111ce5bf6e245e95ac3ff",
        "filename": "contrib/travis.sh",
        "status": "modified",
        "additions": 3,
        "deletions": 6,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/contrib/travis.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/contrib/travis.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/travis.sh?ref=0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16",
        "patch": "@@ -3,10 +3,6 @@\n set -e\n set -x\n \n-if [ -n \"$HOST\" ]\n-then\n-    export USE_HOST=\"--host=$HOST\"\n-fi\n if [ \"$HOST\" = \"i686-linux-gnu\" ]\n then\n     export CC=\"$CC -m32\"\n@@ -18,9 +14,10 @@ fi\n \n ./configure \\\n     --enable-experimental=\"$EXPERIMENTAL\" --enable-endomorphism=\"$ENDOMORPHISM\" \\\n-    --with-field=\"$FIELD\" --with-bignum=\"$BIGNUM\" --with-asm=\"$ASM\" --with-scalar=\"$SCALAR\" \\\n+    --with-test-override-wide-multiply=\"$WIDEMUL\" --with-bignum=\"$BIGNUM\" --with-asm=\"$ASM\" \\\n     --enable-ecmult-static-precomputation=\"$STATICPRECOMPUTATION\" --with-ecmult-gen-precision=\"$ECMULTGENPRECISION\" \\\n-    --enable-module-ecdh=\"$ECDH\" --enable-module-recovery=\"$RECOVERY\" \"$EXTRAFLAGS\" \"$USE_HOST\"\n+    --enable-module-ecdh=\"$ECDH\" --enable-module-recovery=\"$RECOVERY\" \\\n+    --host=\"$HOST\" $EXTRAFLAGS\n \n if [ -n \"$BUILD\" ]\n then"
      },
      {
        "sha": "2178c8e2d6f1864b563f0087c829372804f2cd78",
        "filename": "include/secp256k1.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1.h?ref=0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16",
        "patch": "@@ -134,7 +134,7 @@ typedef int (*secp256k1_nonce_function)(\n #  else\n #   define SECP256K1_API\n #  endif\n-# elif defined(__GNUC__) && defined(SECP256K1_BUILD)\n+# elif defined(__GNUC__) && (__GNUC__ >= 4) && defined(SECP256K1_BUILD)\n #  define SECP256K1_API __attribute__ ((visibility (\"default\")))\n # else\n #  define SECP256K1_API"
      },
      {
        "sha": "83dbe6f25b0e2fabef3537e476757ce3395536a7",
        "filename": "src/basic-config.h",
        "status": "modified",
        "additions": 3,
        "deletions": 6,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/basic-config.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/basic-config.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/basic-config.h?ref=0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16",
        "patch": "@@ -14,23 +14,20 @@\n #undef USE_ENDOMORPHISM\n #undef USE_EXTERNAL_ASM\n #undef USE_EXTERNAL_DEFAULT_CALLBACKS\n-#undef USE_FIELD_10X26\n-#undef USE_FIELD_5X52\n #undef USE_FIELD_INV_BUILTIN\n #undef USE_FIELD_INV_NUM\n #undef USE_NUM_GMP\n #undef USE_NUM_NONE\n-#undef USE_SCALAR_4X64\n-#undef USE_SCALAR_8X32\n #undef USE_SCALAR_INV_BUILTIN\n #undef USE_SCALAR_INV_NUM\n+#undef USE_FORCE_WIDEMUL_INT64\n+#undef USE_FORCE_WIDEMUL_INT128\n #undef ECMULT_WINDOW_SIZE\n \n #define USE_NUM_NONE 1\n #define USE_FIELD_INV_BUILTIN 1\n #define USE_SCALAR_INV_BUILTIN 1\n-#define USE_FIELD_10X26 1\n-#define USE_SCALAR_8X32 1\n+#define USE_WIDEMUL_64 1\n #define ECMULT_WINDOW_SIZE 15\n \n #endif /* USE_BASIC_CONFIG */"
      },
      {
        "sha": "55b61e49372cbc68d57464b4e59fd1cc72eacf6d",
        "filename": "src/ecmult_const_impl.h",
        "status": "modified",
        "additions": 11,
        "deletions": 5,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/ecmult_const_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/ecmult_const_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_const_impl.h?ref=0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16",
        "patch": "@@ -105,16 +105,22 @@ static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w\n     /* 4 */\n     u_last = secp256k1_scalar_shr_int(&s, w);\n     do {\n-        int sign;\n         int even;\n \n         /* 4.1 4.4 */\n         u = secp256k1_scalar_shr_int(&s, w);\n         /* 4.2 */\n         even = ((u & 1) == 0);\n-        sign = 2 * (u_last > 0) - 1;\n-        u += sign * even;\n-        u_last -= sign * even * (1 << w);\n+        /* In contrast to the original algorithm, u_last is always > 0 and\n+         * therefore we do not need to check its sign. In particular, it's easy\n+         * to see that u_last is never < 0 because u is never < 0. Moreover,\n+         * u_last is never = 0 because u is never even after a loop\n+         * iteration. The same holds analogously for the initial value of\n+         * u_last (in the first loop iteration). */\n+        VERIFY_CHECK(u_last > 0);\n+        VERIFY_CHECK((u_last & 1) == 1);\n+        u += even;\n+        u_last -= even * (1 << w);\n \n         /* 4.3, adapted for global sign change */\n         wnaf[word++] = u_last * global_sign;\n@@ -202,7 +208,7 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n         int n;\n         int j;\n         for (j = 0; j < WINDOW_A - 1; ++j) {\n-            secp256k1_gej_double_nonzero(r, r);\n+            secp256k1_gej_double(r, r);\n         }\n \n         n = wnaf_1[i];"
      },
      {
        "sha": "aca1fb72c5084e99b44056d5dd979d5252889743",
        "filename": "src/field.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/field.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/field.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field.h?ref=0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16",
        "patch": "@@ -22,16 +22,16 @@\n #include \"libsecp256k1-config.h\"\n #endif\n \n-#if defined(USE_FIELD_10X26)\n-#include \"field_10x26.h\"\n-#elif defined(USE_FIELD_5X52)\n+#include \"util.h\"\n+\n+#if defined(SECP256K1_WIDEMUL_INT128)\n #include \"field_5x52.h\"\n+#elif defined(SECP256K1_WIDEMUL_INT64)\n+#include \"field_10x26.h\"\n #else\n-#error \"Please select field implementation\"\n+#error \"Please select wide multiplication implementation\"\n #endif\n \n-#include \"util.h\"\n-\n /** Normalize a field element. This brings the field element to a canonical representation, reduces\n  *  its magnitude to 1, and reduces it modulo field size `p`.\n  */"
      },
      {
        "sha": "6a068484c28a0d386fd62cfad107e3ca1b15ae02",
        "filename": "src/field_5x52.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/field_5x52.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/field_5x52.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_5x52.h?ref=0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16",
        "patch": "@@ -46,4 +46,10 @@ typedef struct {\n     (d6) | (((uint64_t)(d7)) << 32) \\\n }}\n \n+#define SECP256K1_FE_STORAGE_CONST_GET(d) \\\n+    (uint32_t)(d.n[3] >> 32), (uint32_t)d.n[3], \\\n+    (uint32_t)(d.n[2] >> 32), (uint32_t)d.n[2], \\\n+    (uint32_t)(d.n[1] >> 32), (uint32_t)d.n[1], \\\n+    (uint32_t)(d.n[0] >> 32), (uint32_t)d.n[0]\n+\n #endif /* SECP256K1_FIELD_REPR_H */"
      },
      {
        "sha": "18e4d2f30ea66450e9de4020d6e7a26d337e9985",
        "filename": "src/field_impl.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/field_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/field_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_impl.h?ref=0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16",
        "patch": "@@ -14,12 +14,12 @@\n #include \"util.h\"\n #include \"num.h\"\n \n-#if defined(USE_FIELD_10X26)\n-#include \"field_10x26_impl.h\"\n-#elif defined(USE_FIELD_5X52)\n+#if defined(SECP256K1_WIDEMUL_INT128)\n #include \"field_5x52_impl.h\"\n+#elif defined(SECP256K1_WIDEMUL_INT64)\n+#include \"field_10x26_impl.h\"\n #else\n-#error \"Please select field implementation\"\n+#error \"Please select wide multiplication implementation\"\n #endif\n \n SECP256K1_INLINE static int secp256k1_fe_equal(const secp256k1_fe *a, const secp256k1_fe *b) {"
      },
      {
        "sha": "6185be052db065e4c42e085e1889dbae5aa10429",
        "filename": "src/group.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/group.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/group.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/group.h?ref=0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16",
        "patch": "@@ -95,8 +95,8 @@ static int secp256k1_gej_is_infinity(const secp256k1_gej *a);\n /** Check whether a group element's y coordinate is a quadratic residue. */\n static int secp256k1_gej_has_quad_y_var(const secp256k1_gej *a);\n \n-/** Set r equal to the double of a, a cannot be infinity. Constant time. */\n-static void secp256k1_gej_double_nonzero(secp256k1_gej *r, const secp256k1_gej *a);\n+/** Set r equal to the double of a. Constant time. */\n+static void secp256k1_gej_double(secp256k1_gej *r, const secp256k1_gej *a);\n \n /** Set r equal to the double of a. If rzr is not-NULL this sets *rzr such that r->z == a->z * *rzr (where infinity means an implicit z = 0). */\n static void secp256k1_gej_double_var(secp256k1_gej *r, const secp256k1_gej *a, secp256k1_fe *rzr);"
      },
      {
        "sha": "fbfd34897ac2009c5f173b63af110752c8a6a405",
        "filename": "src/group_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/group_impl.h?ref=0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16",
        "patch": "@@ -303,7 +303,7 @@ static int secp256k1_ge_is_valid_var(const secp256k1_ge *a) {\n     return secp256k1_fe_equal_var(&y2, &x3);\n }\n \n-static SECP256K1_INLINE void secp256k1_gej_double_nonzero(secp256k1_gej *r, const secp256k1_gej *a) {\n+static SECP256K1_INLINE void secp256k1_gej_double(secp256k1_gej *r, const secp256k1_gej *a) {\n     /* Operations: 3 mul, 4 sqr, 0 normalize, 12 mul_int/add/negate.\n      *\n      * Note that there is an implementation described at\n@@ -313,8 +313,7 @@ static SECP256K1_INLINE void secp256k1_gej_double_nonzero(secp256k1_gej *r, cons\n      */\n     secp256k1_fe t1,t2,t3,t4;\n \n-    VERIFY_CHECK(!secp256k1_gej_is_infinity(a));\n-    r->infinity = 0;\n+    r->infinity = a->infinity;\n \n     secp256k1_fe_mul(&r->z, &a->z, &a->y);\n     secp256k1_fe_mul_int(&r->z, 2);       /* Z' = 2*Y*Z (2) */\n@@ -363,7 +362,7 @@ static void secp256k1_gej_double_var(secp256k1_gej *r, const secp256k1_gej *a, s\n         secp256k1_fe_mul_int(rzr, 2);\n     }\n \n-    secp256k1_gej_double_nonzero(r, a);\n+    secp256k1_gej_double(r, a);\n }\n \n static void secp256k1_gej_add_var(secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_gej *b, secp256k1_fe *rzr) {"
      },
      {
        "sha": "1985a07836daf2938332ab0588c614d7f3dab880",
        "filename": "src/hash_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/hash_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/hash_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash_impl.h?ref=0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16",
        "patch": "@@ -8,6 +8,7 @@\n #define SECP256K1_HASH_IMPL_H\n \n #include \"hash.h\"\n+#include \"util.h\"\n \n #include <stdlib.h>\n #include <stdint.h>\n@@ -27,9 +28,9 @@\n     (h) = t1 + t2; \\\n } while(0)\n \n-#ifdef WORDS_BIGENDIAN\n+#if defined(SECP256K1_BIG_ENDIAN)\n #define BE32(x) (x)\n-#else\n+#elif defined(SECP256K1_LITTLE_ENDIAN)\n #define BE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n #endif\n "
      },
      {
        "sha": "95d3e326c9c6f0f6959b90b30f191de988b509eb",
        "filename": "src/scalar.h",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/scalar.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/scalar.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar.h?ref=0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16",
        "patch": "@@ -8,19 +8,20 @@\n #define SECP256K1_SCALAR_H\n \n #include \"num.h\"\n+#include \"util.h\"\n \n #if defined HAVE_CONFIG_H\n #include \"libsecp256k1-config.h\"\n #endif\n \n #if defined(EXHAUSTIVE_TEST_ORDER)\n #include \"scalar_low.h\"\n-#elif defined(USE_SCALAR_4X64)\n+#elif defined(SECP256K1_WIDEMUL_INT128)\n #include \"scalar_4x64.h\"\n-#elif defined(USE_SCALAR_8X32)\n+#elif defined(SECP256K1_WIDEMUL_INT64)\n #include \"scalar_8x32.h\"\n #else\n-#error \"Please select scalar implementation\"\n+#error \"Please select wide multiplication implementation\"\n #endif\n \n /** Clear a scalar to prevent the leak of sensitive data. */"
      },
      {
        "sha": "7f3992786101cf0f603aa447deb673afcdde125f",
        "filename": "src/scalar_4x64_impl.h",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/scalar_4x64_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/scalar_4x64_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_4x64_impl.h?ref=0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16",
        "patch": "@@ -192,9 +192,9 @@ static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n         tl = t; \\\n     } \\\n     c0 += tl;                 /* overflow is handled on the next line */ \\\n-    th += (c0 < tl) ? 1 : 0;  /* at most 0xFFFFFFFFFFFFFFFF */ \\\n+    th += (c0 < tl);          /* at most 0xFFFFFFFFFFFFFFFF */ \\\n     c1 += th;                 /* overflow is handled on the next line */ \\\n-    c2 += (c1 < th) ? 1 : 0;  /* never overflows by contract (verified in the next line) */ \\\n+    c2 += (c1 < th);          /* never overflows by contract (verified in the next line) */ \\\n     VERIFY_CHECK((c1 >= th) || (c2 != 0)); \\\n }\n \n@@ -207,7 +207,7 @@ static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n         tl = t; \\\n     } \\\n     c0 += tl;                 /* overflow is handled on the next line */ \\\n-    th += (c0 < tl) ? 1 : 0;  /* at most 0xFFFFFFFFFFFFFFFF */ \\\n+    th += (c0 < tl);          /* at most 0xFFFFFFFFFFFFFFFF */ \\\n     c1 += th;                 /* never overflows by contract (verified in the next line) */ \\\n     VERIFY_CHECK(c1 >= th); \\\n }\n@@ -221,32 +221,32 @@ static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n         tl = t; \\\n     } \\\n     th2 = th + th;                  /* at most 0xFFFFFFFFFFFFFFFE (in case th was 0x7FFFFFFFFFFFFFFF) */ \\\n-    c2 += (th2 < th) ? 1 : 0;       /* never overflows by contract (verified the next line) */ \\\n+    c2 += (th2 < th);               /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((th2 >= th) || (c2 != 0)); \\\n     tl2 = tl + tl;                  /* at most 0xFFFFFFFFFFFFFFFE (in case the lowest 63 bits of tl were 0x7FFFFFFFFFFFFFFF) */ \\\n-    th2 += (tl2 < tl) ? 1 : 0;      /* at most 0xFFFFFFFFFFFFFFFF */ \\\n+    th2 += (tl2 < tl);              /* at most 0xFFFFFFFFFFFFFFFF */ \\\n     c0 += tl2;                      /* overflow is handled on the next line */ \\\n-    th2 += (c0 < tl2) ? 1 : 0;      /* second overflow is handled on the next line */ \\\n+    th2 += (c0 < tl2);              /* second overflow is handled on the next line */ \\\n     c2 += (c0 < tl2) & (th2 == 0);  /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((c0 >= tl2) || (th2 != 0) || (c2 != 0)); \\\n     c1 += th2;                      /* overflow is handled on the next line */ \\\n-    c2 += (c1 < th2) ? 1 : 0;       /* never overflows by contract (verified the next line) */ \\\n+    c2 += (c1 < th2);               /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((c1 >= th2) || (c2 != 0)); \\\n }\n \n /** Add a to the number defined by (c0,c1,c2). c2 must never overflow. */\n #define sumadd(a) { \\\n     unsigned int over; \\\n     c0 += (a);                  /* overflow is handled on the next line */ \\\n-    over = (c0 < (a)) ? 1 : 0; \\\n+    over = (c0 < (a));         \\\n     c1 += over;                 /* overflow is handled on the next line */ \\\n-    c2 += (c1 < over) ? 1 : 0;  /* never overflows by contract */ \\\n+    c2 += (c1 < over);          /* never overflows by contract */ \\\n }\n \n /** Add a to the number defined by (c0,c1). c1 must never overflow, c2 must be zero. */\n #define sumadd_fast(a) { \\\n     c0 += (a);                 /* overflow is handled on the next line */ \\\n-    c1 += (c0 < (a)) ? 1 : 0;  /* never overflows by contract (verified the next line) */ \\\n+    c1 += (c0 < (a));          /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((c1 != 0) | (c0 >= (a))); \\\n     VERIFY_CHECK(c2 == 0); \\\n }"
      },
      {
        "sha": "f8c7fa7efaba92980d6f74599c93b877887504be",
        "filename": "src/scalar_8x32_impl.h",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/scalar_8x32_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/scalar_8x32_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_8x32_impl.h?ref=0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16",
        "patch": "@@ -271,9 +271,9 @@ static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n         tl = t; \\\n     } \\\n     c0 += tl;                 /* overflow is handled on the next line */ \\\n-    th += (c0 < tl) ? 1 : 0;  /* at most 0xFFFFFFFF */ \\\n+    th += (c0 < tl);          /* at most 0xFFFFFFFF */ \\\n     c1 += th;                 /* overflow is handled on the next line */ \\\n-    c2 += (c1 < th) ? 1 : 0;  /* never overflows by contract (verified in the next line) */ \\\n+    c2 += (c1 < th);          /* never overflows by contract (verified in the next line) */ \\\n     VERIFY_CHECK((c1 >= th) || (c2 != 0)); \\\n }\n \n@@ -286,7 +286,7 @@ static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n         tl = t; \\\n     } \\\n     c0 += tl;                 /* overflow is handled on the next line */ \\\n-    th += (c0 < tl) ? 1 : 0;  /* at most 0xFFFFFFFF */ \\\n+    th += (c0 < tl);          /* at most 0xFFFFFFFF */ \\\n     c1 += th;                 /* never overflows by contract (verified in the next line) */ \\\n     VERIFY_CHECK(c1 >= th); \\\n }\n@@ -300,32 +300,32 @@ static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n         tl = t; \\\n     } \\\n     th2 = th + th;                  /* at most 0xFFFFFFFE (in case th was 0x7FFFFFFF) */ \\\n-    c2 += (th2 < th) ? 1 : 0;       /* never overflows by contract (verified the next line) */ \\\n+    c2 += (th2 < th);               /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((th2 >= th) || (c2 != 0)); \\\n     tl2 = tl + tl;                  /* at most 0xFFFFFFFE (in case the lowest 63 bits of tl were 0x7FFFFFFF) */ \\\n-    th2 += (tl2 < tl) ? 1 : 0;      /* at most 0xFFFFFFFF */ \\\n+    th2 += (tl2 < tl);              /* at most 0xFFFFFFFF */ \\\n     c0 += tl2;                      /* overflow is handled on the next line */ \\\n-    th2 += (c0 < tl2) ? 1 : 0;      /* second overflow is handled on the next line */ \\\n+    th2 += (c0 < tl2);              /* second overflow is handled on the next line */ \\\n     c2 += (c0 < tl2) & (th2 == 0);  /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((c0 >= tl2) || (th2 != 0) || (c2 != 0)); \\\n     c1 += th2;                      /* overflow is handled on the next line */ \\\n-    c2 += (c1 < th2) ? 1 : 0;       /* never overflows by contract (verified the next line) */ \\\n+    c2 += (c1 < th2);               /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((c1 >= th2) || (c2 != 0)); \\\n }\n \n /** Add a to the number defined by (c0,c1,c2). c2 must never overflow. */\n #define sumadd(a) { \\\n     unsigned int over; \\\n     c0 += (a);                  /* overflow is handled on the next line */ \\\n-    over = (c0 < (a)) ? 1 : 0; \\\n+    over = (c0 < (a)); \\\n     c1 += over;                 /* overflow is handled on the next line */ \\\n-    c2 += (c1 < over) ? 1 : 0;  /* never overflows by contract */ \\\n+    c2 += (c1 < over);          /* never overflows by contract */ \\\n }\n \n /** Add a to the number defined by (c0,c1). c1 must never overflow, c2 must be zero. */\n #define sumadd_fast(a) { \\\n     c0 += (a);                 /* overflow is handled on the next line */ \\\n-    c1 += (c0 < (a)) ? 1 : 0;  /* never overflows by contract (verified the next line) */ \\\n+    c1 += (c0 < (a));          /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((c1 != 0) | (c0 >= (a))); \\\n     VERIFY_CHECK(c2 == 0); \\\n }"
      },
      {
        "sha": "2ec04b1ae9aa27c26ee1a6483a90ce3b292b2a16",
        "filename": "src/scalar_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_impl.h?ref=0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16",
        "patch": "@@ -16,12 +16,12 @@\n \n #if defined(EXHAUSTIVE_TEST_ORDER)\n #include \"scalar_low_impl.h\"\n-#elif defined(USE_SCALAR_4X64)\n+#elif defined(SECP256K1_WIDEMUL_INT128)\n #include \"scalar_4x64_impl.h\"\n-#elif defined(USE_SCALAR_8X32)\n+#elif defined(SECP256K1_WIDEMUL_INT64)\n #include \"scalar_8x32_impl.h\"\n #else\n-#error \"Please select scalar implementation\"\n+#error \"Please select wide multiplication implementation\"\n #endif\n \n static const secp256k1_scalar secp256k1_scalar_one = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 1);"
      },
      {
        "sha": "3e7926503825dd4d868da82bcaba9be9822a416c",
        "filename": "src/secp256k1.c",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1.c?ref=0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16",
        "patch": "@@ -291,7 +291,7 @@ int secp256k1_ec_pubkey_serialize(const secp256k1_context* ctx, unsigned char *o\n \n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(outputlen != NULL);\n-    ARG_CHECK(*outputlen >= ((flags & SECP256K1_FLAGS_BIT_COMPRESSION) ? 33 : 65));\n+    ARG_CHECK(*outputlen >= ((flags & SECP256K1_FLAGS_BIT_COMPRESSION) ? 33u : 65u));\n     len = *outputlen;\n     *outputlen = 0;\n     ARG_CHECK(output != NULL);"
      },
      {
        "sha": "58d2ad2fa2a5a400a01d93cea4e129feada3ef98",
        "filename": "src/tests.c",
        "status": "modified",
        "additions": 38,
        "deletions": 9,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests.c?ref=0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16",
        "patch": "@@ -182,8 +182,10 @@ void run_context_tests(int use_prealloc) {\n     ecount2 = 10;\n     secp256k1_context_set_illegal_callback(vrfy, counting_illegal_callback_fn, &ecount);\n     secp256k1_context_set_illegal_callback(sign, counting_illegal_callback_fn, &ecount2);\n-    secp256k1_context_set_error_callback(sign, counting_illegal_callback_fn, NULL);\n-    CHECK(vrfy->error_callback.fn != sign->error_callback.fn);\n+    /* set error callback (to a function that still aborts in case malloc() fails in secp256k1_context_clone() below) */\n+    secp256k1_context_set_error_callback(sign, secp256k1_default_illegal_callback_fn, NULL);\n+    CHECK(sign->error_callback.fn != vrfy->error_callback.fn);\n+    CHECK(sign->error_callback.fn == secp256k1_default_illegal_callback_fn);\n \n     /* check if sizes for cloning are consistent */\n     CHECK(secp256k1_context_preallocated_clone_size(none) == secp256k1_context_preallocated_size(SECP256K1_CONTEXT_NONE));\n@@ -239,7 +241,8 @@ void run_context_tests(int use_prealloc) {\n     }\n \n     /* Verify that the error callback makes it across the clone. */\n-    CHECK(vrfy->error_callback.fn != sign->error_callback.fn);\n+    CHECK(sign->error_callback.fn != vrfy->error_callback.fn);\n+    CHECK(sign->error_callback.fn == secp256k1_default_illegal_callback_fn);\n     /* And that it resets back to default. */\n     secp256k1_context_set_error_callback(sign, NULL, NULL);\n     CHECK(vrfy->error_callback.fn == sign->error_callback.fn);\n@@ -2215,6 +2218,9 @@ void test_ge(void) {\n                 /* Normal doubling. */\n                 secp256k1_gej_double_var(&resj, &gej[i2], NULL);\n                 ge_equals_gej(&ref, &resj);\n+                /* Constant-time doubling. */\n+                secp256k1_gej_double(&resj, &gej[i2]);\n+                ge_equals_gej(&ref, &resj);\n             }\n \n             /* Test adding opposites. */\n@@ -2967,14 +2973,16 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n \n void test_ecmult_multi_batch_single(secp256k1_ecmult_multi_func ecmult_multi) {\n     secp256k1_scalar szero;\n-    secp256k1_scalar sc[32];\n-    secp256k1_ge pt[32];\n+    secp256k1_scalar sc;\n+    secp256k1_ge pt;\n     secp256k1_gej r;\n     ecmult_multi_data data;\n     secp256k1_scratch *scratch_empty;\n \n-    data.sc = sc;\n-    data.pt = pt;\n+    random_group_element_test(&pt);\n+    random_scalar_order(&sc);\n+    data.sc = &sc;\n+    data.pt = &pt;\n     secp256k1_scalar_set_int(&szero, 0);\n \n     /* Try to multiply 1 point, but scratch space is empty.*/\n@@ -3232,6 +3240,7 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n     int skew;\n     int bits = 256;\n     secp256k1_scalar num = *number;\n+    secp256k1_scalar scalar_skew;\n \n     secp256k1_scalar_set_int(&x, 0);\n     secp256k1_scalar_set_int(&shift, 1 << w);\n@@ -3262,7 +3271,8 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n         secp256k1_scalar_add(&x, &x, &t);\n     }\n     /* Skew num because when encoding numbers as odd we use an offset */\n-    secp256k1_scalar_cadd_bit(&num, skew == 2, 1);\n+    secp256k1_scalar_set_int(&scalar_skew, 1 << (skew == 2));\n+    secp256k1_scalar_add(&num, &num, &scalar_skew);\n     CHECK(secp256k1_scalar_eq(&x, &num));\n }\n \n@@ -3374,13 +3384,32 @@ void run_wnaf(void) {\n     int i;\n     secp256k1_scalar n = {{0}};\n \n+    test_constant_wnaf(&n, 4);\n     /* Sanity check: 1 and 2 are the smallest odd and even numbers and should\n      *               have easier-to-diagnose failure modes  */\n     n.d[0] = 1;\n     test_constant_wnaf(&n, 4);\n     n.d[0] = 2;\n     test_constant_wnaf(&n, 4);\n-    /* Test 0 */\n+    /* Test -1, because it's a special case in wnaf_const */\n+    n = secp256k1_scalar_one;\n+    secp256k1_scalar_negate(&n, &n);\n+    test_constant_wnaf(&n, 4);\n+\n+    /* Test -2, which may not lead to overflows in wnaf_const */\n+    secp256k1_scalar_add(&n, &secp256k1_scalar_one, &secp256k1_scalar_one);\n+    secp256k1_scalar_negate(&n, &n);\n+    test_constant_wnaf(&n, 4);\n+\n+    /* Test (1/2) - 1 = 1/-2 and 1/2 = (1/-2) + 1\n+       as corner cases of negation handling in wnaf_const */\n+    secp256k1_scalar_inverse(&n, &n);\n+    test_constant_wnaf(&n, 4);\n+\n+    secp256k1_scalar_add(&n, &n, &secp256k1_scalar_one);\n+    test_constant_wnaf(&n, 4);\n+\n+    /* Test 0 for fixed wnaf */\n     test_fixed_wnaf_small();\n     /* Random tests */\n     for (i = 0; i < count; i++) {"
      },
      {
        "sha": "8f346701aa7af3cc7ab25a2ae4faabd3f34730ef",
        "filename": "src/tests_exhaustive.c",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests_exhaustive.c?ref=0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16",
        "patch": "@@ -141,10 +141,8 @@ void test_exhaustive_addition(const secp256k1_ge *group, const secp256k1_gej *gr\n     /* Check doubling */\n     for (i = 0; i < order; i++) {\n         secp256k1_gej tmp;\n-        if (i > 0) {\n-            secp256k1_gej_double_nonzero(&tmp, &groupj[i]);\n-            ge_equals_gej(&group[(2 * i) % order], &tmp);\n-        }\n+        secp256k1_gej_double(&tmp, &groupj[i]);\n+        ge_equals_gej(&group[(2 * i) % order], &tmp);\n         secp256k1_gej_double_var(&tmp, &groupj[i], NULL);\n         ge_equals_gej(&group[(2 * i) % order], &tmp);\n     }"
      },
      {
        "sha": "e8d7015c5dfad7423e5acc178f5f12561870271e",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 50,
        "deletions": 7,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16",
        "patch": "@@ -170,13 +170,35 @@ static SECP256K1_INLINE void *manual_alloc(void** prealloc_ptr, size_t alloc_siz\n # define I64uFORMAT \"llu\"\n #endif\n \n-#if defined(HAVE___INT128)\n-# if defined(__GNUC__)\n-#  define SECP256K1_GNUC_EXT __extension__\n-# else\n-#  define SECP256K1_GNUC_EXT\n+#if defined(__GNUC__)\n+# define SECP256K1_GNUC_EXT __extension__\n+#else\n+# define SECP256K1_GNUC_EXT\n+#endif\n+\n+/* If SECP256K1_{LITTLE,BIG}_ENDIAN is not explicitly provided, infer from various other system macros. */\n+#if !defined(SECP256K1_LITTLE_ENDIAN) && !defined(SECP256K1_BIG_ENDIAN)\n+/* Inspired by https://github.com/rofl0r/endianness.h/blob/9853923246b065a3b52d2c43835f3819a62c7199/endianness.h#L52L73 */\n+# if (defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) || \\\n+     defined(_X86_) || defined(__x86_64__) || defined(__i386__) || \\\n+     defined(__i486__) || defined(__i586__) || defined(__i686__) || \\\n+     defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL) || \\\n+     defined(__ARMEL__) || defined(__AARCH64EL__) || \\\n+     (defined(__LITTLE_ENDIAN__) && __LITTLE_ENDIAN__ == 1) || \\\n+     (defined(_LITTLE_ENDIAN) && _LITTLE_ENDIAN == 1) || \\\n+     defined(_M_IX86) || defined(_M_AMD64) || defined(_M_ARM) /* MSVC */\n+#  define SECP256K1_LITTLE_ENDIAN\n # endif\n-SECP256K1_GNUC_EXT typedef unsigned __int128 uint128_t;\n+# if (defined(__BYTE_ORDER__) && defined(__ORDER_BIG_ENDIAN__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__) || \\\n+     defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB) || \\\n+     defined(__MICROBLAZEEB__) || defined(__ARMEB__) || defined(__AARCH64EB__) || \\\n+     (defined(__BIG_ENDIAN__) && __BIG_ENDIAN__ == 1) || \\\n+     (defined(_BIG_ENDIAN) && _BIG_ENDIAN == 1)\n+#  define SECP256K1_BIG_ENDIAN\n+# endif\n+#endif\n+#if defined(SECP256K1_LITTLE_ENDIAN) == defined(SECP256K1_BIG_ENDIAN)\n+# error Please make sure that either SECP256K1_LITTLE_ENDIAN or SECP256K1_BIG_ENDIAN is set, see src/util.h.\n #endif\n \n /* Zero memory if flag == 1. Flag must be 0 or 1. Constant time. */\n@@ -197,15 +219,36 @@ static SECP256K1_INLINE void memczero(void *s, size_t len, int flag) {\n /** If flag is true, set *r equal to *a; otherwise leave it. Constant-time.  Both *r and *a must be initialized and non-negative.*/\n static SECP256K1_INLINE void secp256k1_int_cmov(int *r, const int *a, int flag) {\n     unsigned int mask0, mask1, r_masked, a_masked;\n+    /* Access flag with a volatile-qualified lvalue.\n+       This prevents clang from figuring out (after inlining) that flag can\n+       take only be 0 or 1, which leads to variable time code. */\n+    volatile int vflag = flag;\n+\n     /* Casting a negative int to unsigned and back to int is implementation defined behavior */\n     VERIFY_CHECK(*r >= 0 && *a >= 0);\n \n-    mask0 = (unsigned int)flag + ~0u;\n+    mask0 = (unsigned int)vflag + ~0u;\n     mask1 = ~mask0;\n     r_masked = ((unsigned int)*r & mask0);\n     a_masked = ((unsigned int)*a & mask1);\n \n     *r = (int)(r_masked | a_masked);\n }\n \n+/* If USE_FORCE_WIDEMUL_{INT128,INT64} is set, use that wide multiplication implementation.\n+ * Otherwise use the presence of __SIZEOF_INT128__ to decide.\n+ */\n+#if defined(USE_FORCE_WIDEMUL_INT128)\n+# define SECP256K1_WIDEMUL_INT128 1\n+#elif defined(USE_FORCE_WIDEMUL_INT64)\n+# define SECP256K1_WIDEMUL_INT64 1\n+#elif defined(__SIZEOF_INT128__)\n+# define SECP256K1_WIDEMUL_INT128 1\n+#else\n+# define SECP256K1_WIDEMUL_INT64 1\n+#endif\n+#if defined(SECP256K1_WIDEMUL_INT128)\n+SECP256K1_GNUC_EXT typedef unsigned __int128 uint128_t;\n+#endif\n+\n #endif /* SECP256K1_UTIL_H */"
      }
    ]
  },
  {
    "sha": "d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMGRjZjk5YjQ2NzM4ZGQ3Y2UwNTQ3ZDNkMWUwNmZlMmIyNGM1MGQ2",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-08-16T03:33:53Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-08-16T03:33:53Z"
      },
      "message": "libsecp256k1 PR 799",
      "tree": {
        "sha": "23652d2ee043805a4a67d616093fc2b44d77cd5f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/23652d2ee043805a4a67d616093fc2b44d77cd5f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3ab2582c7fe76d2839ab493512758d5601903c86",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3ab2582c7fe76d2839ab493512758d5601903c86",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3ab2582c7fe76d2839ab493512758d5601903c86"
      },
      {
        "sha": "0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0a0db15fc7d0960d06010d2f85ae6ceb3bd53a16"
      }
    ],
    "stats": {
      "total": 379,
      "additions": 191,
      "deletions": 188
    },
    "files": [
      {
        "sha": "81d1ba894f15d397962faacc050e049b23d23c70",
        "filename": "src/secp256k1/.travis.yml",
        "status": "modified",
        "additions": 14,
        "deletions": 10,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.travis.yml?ref=d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6",
        "patch": "@@ -17,17 +17,17 @@ compiler:\n   - gcc\n env:\n   global:\n-    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ECMULTGENPRECISION=auto  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no  EXPERIMENTAL=no CTIMETEST=yes BENCH=yes ITERS=2\n+    - WIDEMUL=auto  BIGNUM=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ECMULTGENPRECISION=auto  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no  EXPERIMENTAL=no CTIMETEST=yes BENCH=yes ITERS=2\n   matrix:\n-    - SCALAR=32bit    RECOVERY=yes\n-    - SCALAR=32bit    FIELD=32bit       ECDH=yes  EXPERIMENTAL=yes\n-    - SCALAR=64bit\n-    - FIELD=64bit     RECOVERY=yes\n-    - FIELD=64bit     ENDOMORPHISM=yes\n-    - FIELD=64bit     ENDOMORPHISM=yes  ECDH=yes EXPERIMENTAL=yes\n-    - FIELD=64bit                       ASM=x86_64\n-    - FIELD=64bit     ENDOMORPHISM=yes  ASM=x86_64\n-    - FIELD=32bit     ENDOMORPHISM=yes\n+    - WIDEMUL=int64   RECOVERY=yes\n+    - WIDEMUL=int64   ECDH=yes  EXPERIMENTAL=yes\n+    - WIDEMUL=int64   ENDOMORPHISM=yes\n+    - WIDEMUL=int128\n+    - WIDEMUL=int128  RECOVERY=yes\n+    - WIDEMUL=int128  ENDOMORPHISM=yes\n+    - WIDEMUL=int128  ENDOMORPHISM=yes  ECDH=yes EXPERIMENTAL=yes\n+    - WIDEMUL=int128                    ASM=x86_64\n+    - WIDEMUL=int128  ENDOMORPHISM=yes  ASM=x86_64\n     - BIGNUM=no\n     - BIGNUM=no       ENDOMORPHISM=yes RECOVERY=yes EXPERIMENTAL=yes\n     - BIGNUM=no       STATICPRECOMPUTATION=no\n@@ -83,6 +83,10 @@ matrix:\n             - valgrind\n             - libtool-bin\n             - libc6-dbg:i386\n+    # S390x build (big endian system)\n+    - compiler: gcc\n+      env: HOST=s390x-unknown-linux-gnu ECDH=yes RECOVERY=yes EXPERIMENTAL=yes CTIMETEST=\n+      arch: s390x\n \n # We use this to install macOS dependencies instead of the built in `homebrew` plugin,\n # because in xcode earlier than 11 they have a bug requiring updating the system which overall takes ~8 minutes."
      },
      {
        "sha": "a30a84cd599c77a6ef52d7719129dfe97f140619",
        "filename": "src/secp256k1/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/Makefile.am?ref=d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6",
        "patch": "@@ -99,7 +99,7 @@ if VALGRIND_ENABLED\n tests_CPPFLAGS += -DVALGRIND\n noinst_PROGRAMS += valgrind_ctime_test\n valgrind_ctime_test_SOURCES = src/valgrind_ctime_test.c\n-valgrind_ctime_test_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n+valgrind_ctime_test_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_LIBS) $(COMMON_LIB)\n endif\n if !ENABLE_COVERAGE\n tests_CPPFLAGS += -DVERIFY"
      },
      {
        "sha": "57595f4499d8e10646e6cbb56417a831803786cd",
        "filename": "src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/build-aux/m4/bitcoin_secp.m4?ref=d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6",
        "patch": "@@ -1,8 +1,3 @@\n-dnl libsecp25k1 helper checks\n-AC_DEFUN([SECP_INT128_CHECK],[\n-has_int128=$ac_cv_type___int128\n-])\n-\n dnl escape \"$0x\" below using the m4 quadrigaph @S|@, and escape it again with a \\ for the shell.\n AC_DEFUN([SECP_64BIT_ASM_CHECK],[\n AC_MSG_CHECKING(for x86_64 assembly availability)"
      },
      {
        "sha": "743f7f7ba9887a772a7159b9fcbe828c6b32794b",
        "filename": "src/secp256k1/configure.ac",
        "status": "modified",
        "additions": 16,
        "deletions": 88,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/configure.ac?ref=d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6",
        "patch": "@@ -141,15 +141,13 @@ AC_ARG_ENABLE(external_default_callbacks,\n     [use_external_default_callbacks=$enableval],\n     [use_external_default_callbacks=no])\n \n-AC_ARG_WITH([field], [AS_HELP_STRING([--with-field=64bit|32bit|auto],\n-[finite field implementation to use [default=auto]])],[req_field=$withval], [req_field=auto])\n+dnl Test-only override of the (autodetected by the C code) \"widemul\" setting.\n+dnl Legal values are int64 (for [u]int64_t), int128 (for [unsigned] __int128), and auto (the default).\n+AC_ARG_WITH([test-override-wide-multiply], [] ,[set_widemul=$withval], [set_widemul=auto])\n \n AC_ARG_WITH([bignum], [AS_HELP_STRING([--with-bignum=gmp|no|auto],\n [bignum implementation to use [default=auto]])],[req_bignum=$withval], [req_bignum=auto])\n \n-AC_ARG_WITH([scalar], [AS_HELP_STRING([--with-scalar=64bit|32bit|auto],\n-[scalar implementation to use [default=auto]])],[req_scalar=$withval], [req_scalar=auto])\n-\n AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|arm|no|auto],\n [assembly optimizations to use\u00a0(experimental: arm) [default=auto]])],[req_asm=$withval], [req_asm=auto])\n \n@@ -170,8 +168,6 @@ AC_ARG_WITH([ecmult-gen-precision], [AS_HELP_STRING([--with-ecmult-gen-precision\n )],\n [req_ecmult_gen_precision=$withval], [req_ecmult_gen_precision=auto])\n \n-AC_CHECK_TYPES([__int128])\n-\n AC_CHECK_HEADER([valgrind/memcheck.h], [enable_valgrind=yes], [enable_valgrind=no], [])\n AM_CONDITIONAL([VALGRIND_ENABLED],[test \"$enable_valgrind\" = \"yes\"])\n \n@@ -265,63 +261,6 @@ else\n   esac\n fi\n \n-if test x\"$req_field\" = x\"auto\"; then\n-  if test x\"set_asm\" = x\"x86_64\"; then\n-    set_field=64bit\n-  fi\n-  if test x\"$set_field\" = x; then\n-    SECP_INT128_CHECK\n-    if test x\"$has_int128\" = x\"yes\"; then\n-      set_field=64bit\n-    fi\n-  fi\n-  if test x\"$set_field\" = x; then\n-    set_field=32bit\n-  fi\n-else\n-  set_field=$req_field\n-  case $set_field in\n-  64bit)\n-    if test x\"$set_asm\" != x\"x86_64\"; then\n-      SECP_INT128_CHECK\n-      if test x\"$has_int128\" != x\"yes\"; then\n-        AC_MSG_ERROR([64bit field explicitly requested but neither __int128 support or x86_64 assembly available])\n-      fi\n-    fi\n-    ;;\n-  32bit)\n-    ;;\n-  *)\n-    AC_MSG_ERROR([invalid field implementation selection])\n-    ;;\n-  esac\n-fi\n-\n-if test x\"$req_scalar\" = x\"auto\"; then\n-  SECP_INT128_CHECK\n-  if test x\"$has_int128\" = x\"yes\"; then\n-    set_scalar=64bit\n-  fi\n-  if test x\"$set_scalar\" = x; then\n-    set_scalar=32bit\n-  fi\n-else\n-  set_scalar=$req_scalar\n-  case $set_scalar in\n-  64bit)\n-    SECP_INT128_CHECK\n-    if test x\"$has_int128\" != x\"yes\"; then\n-      AC_MSG_ERROR([64bit scalar explicitly requested but __int128 support not available])\n-    fi\n-    ;;\n-  32bit)\n-    ;;\n-  *)\n-    AC_MSG_ERROR([invalid scalar implementation selected])\n-    ;;\n-  esac\n-fi\n-\n if test x\"$req_bignum\" = x\"auto\"; then\n   SECP_GMP_CHECK\n   if test x\"$has_gmp\" = x\"yes\"; then\n@@ -365,16 +304,18 @@ no)\n   ;;\n esac\n \n-# select field implementation\n-case $set_field in\n-64bit)\n-  AC_DEFINE(USE_FIELD_5X52, 1, [Define this symbol to use the FIELD_5X52 implementation])\n+# select wide multiplication implementation\n+case $set_widemul in\n+int128)\n+  AC_DEFINE(USE_FORCE_WIDEMUL_INT128, 1, [Define this symbol to force the use of the (unsigned) __int128 based wide multiplication implementation])\n+  ;;\n+int64)\n+  AC_DEFINE(USE_FORCE_WIDEMUL_INT64, 1, [Define this symbol to force the use of the (u)int64_t based wide multiplication implementation])\n   ;;\n-32bit)\n-  AC_DEFINE(USE_FIELD_10X26, 1, [Define this symbol to use the FIELD_10X26 implementation])\n+auto)\n   ;;\n *)\n-  AC_MSG_ERROR([invalid field implementation])\n+  AC_MSG_ERROR([invalid wide multiplication implementation])\n   ;;\n esac\n \n@@ -396,19 +337,6 @@ no)\n   ;;\n esac\n \n-#select scalar implementation\n-case $set_scalar in\n-64bit)\n-  AC_DEFINE(USE_SCALAR_4X64, 1, [Define this symbol to use the 4x64 scalar implementation])\n-  ;;\n-32bit)\n-  AC_DEFINE(USE_SCALAR_8X32, 1, [Define this symbol to use the 8x32 scalar implementation])\n-  ;;\n-*)\n-  AC_MSG_ERROR([invalid scalar implementation])\n-  ;;\n-esac\n-\n #set ecmult window size\n if test x\"$req_ecmult_window\" = x\"auto\"; then\n   set_ecmult_window=15\n@@ -493,8 +421,6 @@ if test x\"$enable_module_recovery\" = x\"yes\"; then\n   AC_DEFINE(ENABLE_MODULE_RECOVERY, 1, [Define this symbol to enable the ECDSA pubkey recovery module])\n fi\n \n-AC_C_BIGENDIAN()\n-\n if test x\"$use_external_asm\" = x\"yes\"; then\n   AC_DEFINE(USE_EXTERNAL_ASM, 1, [Define this symbol if an external (non-inline) assembly implementation is used])\n fi\n@@ -553,10 +479,12 @@ echo \"  module recovery         = $enable_module_recovery\"\n echo\n echo \"  asm                     = $set_asm\"\n echo \"  bignum                  = $set_bignum\"\n-echo \"  field                   = $set_field\"\n-echo \"  scalar                  = $set_scalar\"\n echo \"  ecmult window size      = $set_ecmult_window\"\n echo \"  ecmult gen prec. bits   = $set_ecmult_gen_precision\"\n+dnl Hide test-only options unless they're used.\n+if test x\"$set_widemul\" != xauto; then\n+echo \"  wide multiplication     = $set_widemul\"\n+fi\n echo\n echo \"  valgrind                = $enable_valgrind\"\n echo \"  CC                      = $CC\""
      },
      {
        "sha": "f71db4b53524cc1254190cb915f810adf3113ad7",
        "filename": "src/secp256k1/contrib/lax_der_parsing.c",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/contrib/lax_der_parsing.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/contrib/lax_der_parsing.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/contrib/lax_der_parsing.c?ref=d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6",
        "patch": "@@ -112,7 +112,6 @@ int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_\n         return 0;\n     }\n     spos = pos;\n-    pos += slen;\n \n     /* Ignore leading zeroes in R */\n     while (rlen > 0 && input[rpos] == 0) {"
      },
      {
        "sha": "2023d0b5ae984e69487111ce5bf6e245e95ac3ff",
        "filename": "src/secp256k1/contrib/travis.sh",
        "status": "modified",
        "additions": 3,
        "deletions": 6,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/contrib/travis.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/contrib/travis.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/contrib/travis.sh?ref=d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6",
        "patch": "@@ -3,10 +3,6 @@\n set -e\n set -x\n \n-if [ -n \"$HOST\" ]\n-then\n-    export USE_HOST=\"--host=$HOST\"\n-fi\n if [ \"$HOST\" = \"i686-linux-gnu\" ]\n then\n     export CC=\"$CC -m32\"\n@@ -18,9 +14,10 @@ fi\n \n ./configure \\\n     --enable-experimental=\"$EXPERIMENTAL\" --enable-endomorphism=\"$ENDOMORPHISM\" \\\n-    --with-field=\"$FIELD\" --with-bignum=\"$BIGNUM\" --with-asm=\"$ASM\" --with-scalar=\"$SCALAR\" \\\n+    --with-test-override-wide-multiply=\"$WIDEMUL\" --with-bignum=\"$BIGNUM\" --with-asm=\"$ASM\" \\\n     --enable-ecmult-static-precomputation=\"$STATICPRECOMPUTATION\" --with-ecmult-gen-precision=\"$ECMULTGENPRECISION\" \\\n-    --enable-module-ecdh=\"$ECDH\" --enable-module-recovery=\"$RECOVERY\" \"$EXTRAFLAGS\" \"$USE_HOST\"\n+    --enable-module-ecdh=\"$ECDH\" --enable-module-recovery=\"$RECOVERY\" \\\n+    --host=\"$HOST\" $EXTRAFLAGS\n \n if [ -n \"$BUILD\" ]\n then"
      },
      {
        "sha": "2178c8e2d6f1864b563f0087c829372804f2cd78",
        "filename": "src/secp256k1/include/secp256k1.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1.h?ref=d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6",
        "patch": "@@ -134,7 +134,7 @@ typedef int (*secp256k1_nonce_function)(\n #  else\n #   define SECP256K1_API\n #  endif\n-# elif defined(__GNUC__) && defined(SECP256K1_BUILD)\n+# elif defined(__GNUC__) && (__GNUC__ >= 4) && defined(SECP256K1_BUILD)\n #  define SECP256K1_API __attribute__ ((visibility (\"default\")))\n # else\n #  define SECP256K1_API"
      },
      {
        "sha": "83dbe6f25b0e2fabef3537e476757ce3395536a7",
        "filename": "src/secp256k1/src/basic-config.h",
        "status": "modified",
        "additions": 3,
        "deletions": 6,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/basic-config.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/basic-config.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/basic-config.h?ref=d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6",
        "patch": "@@ -14,23 +14,20 @@\n #undef USE_ENDOMORPHISM\n #undef USE_EXTERNAL_ASM\n #undef USE_EXTERNAL_DEFAULT_CALLBACKS\n-#undef USE_FIELD_10X26\n-#undef USE_FIELD_5X52\n #undef USE_FIELD_INV_BUILTIN\n #undef USE_FIELD_INV_NUM\n #undef USE_NUM_GMP\n #undef USE_NUM_NONE\n-#undef USE_SCALAR_4X64\n-#undef USE_SCALAR_8X32\n #undef USE_SCALAR_INV_BUILTIN\n #undef USE_SCALAR_INV_NUM\n+#undef USE_FORCE_WIDEMUL_INT64\n+#undef USE_FORCE_WIDEMUL_INT128\n #undef ECMULT_WINDOW_SIZE\n \n #define USE_NUM_NONE 1\n #define USE_FIELD_INV_BUILTIN 1\n #define USE_SCALAR_INV_BUILTIN 1\n-#define USE_FIELD_10X26 1\n-#define USE_SCALAR_8X32 1\n+#define USE_WIDEMUL_64 1\n #define ECMULT_WINDOW_SIZE 15\n \n #endif /* USE_BASIC_CONFIG */"
      },
      {
        "sha": "55b61e49372cbc68d57464b4e59fd1cc72eacf6d",
        "filename": "src/secp256k1/src/ecmult_const_impl.h",
        "status": "modified",
        "additions": 11,
        "deletions": 5,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/ecmult_const_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/ecmult_const_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_const_impl.h?ref=d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6",
        "patch": "@@ -105,16 +105,22 @@ static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w\n     /* 4 */\n     u_last = secp256k1_scalar_shr_int(&s, w);\n     do {\n-        int sign;\n         int even;\n \n         /* 4.1 4.4 */\n         u = secp256k1_scalar_shr_int(&s, w);\n         /* 4.2 */\n         even = ((u & 1) == 0);\n-        sign = 2 * (u_last > 0) - 1;\n-        u += sign * even;\n-        u_last -= sign * even * (1 << w);\n+        /* In contrast to the original algorithm, u_last is always > 0 and\n+         * therefore we do not need to check its sign. In particular, it's easy\n+         * to see that u_last is never < 0 because u is never < 0. Moreover,\n+         * u_last is never = 0 because u is never even after a loop\n+         * iteration. The same holds analogously for the initial value of\n+         * u_last (in the first loop iteration). */\n+        VERIFY_CHECK(u_last > 0);\n+        VERIFY_CHECK((u_last & 1) == 1);\n+        u += even;\n+        u_last -= even * (1 << w);\n \n         /* 4.3, adapted for global sign change */\n         wnaf[word++] = u_last * global_sign;\n@@ -202,7 +208,7 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n         int n;\n         int j;\n         for (j = 0; j < WINDOW_A - 1; ++j) {\n-            secp256k1_gej_double_nonzero(r, r);\n+            secp256k1_gej_double(r, r);\n         }\n \n         n = wnaf_1[i];"
      },
      {
        "sha": "aca1fb72c5084e99b44056d5dd979d5252889743",
        "filename": "src/secp256k1/src/field.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/field.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/field.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field.h?ref=d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6",
        "patch": "@@ -22,16 +22,16 @@\n #include \"libsecp256k1-config.h\"\n #endif\n \n-#if defined(USE_FIELD_10X26)\n-#include \"field_10x26.h\"\n-#elif defined(USE_FIELD_5X52)\n+#include \"util.h\"\n+\n+#if defined(SECP256K1_WIDEMUL_INT128)\n #include \"field_5x52.h\"\n+#elif defined(SECP256K1_WIDEMUL_INT64)\n+#include \"field_10x26.h\"\n #else\n-#error \"Please select field implementation\"\n+#error \"Please select wide multiplication implementation\"\n #endif\n \n-#include \"util.h\"\n-\n /** Normalize a field element. This brings the field element to a canonical representation, reduces\n  *  its magnitude to 1, and reduces it modulo field size `p`.\n  */"
      },
      {
        "sha": "6a068484c28a0d386fd62cfad107e3ca1b15ae02",
        "filename": "src/secp256k1/src/field_5x52.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/field_5x52.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/field_5x52.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52.h?ref=d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6",
        "patch": "@@ -46,4 +46,10 @@ typedef struct {\n     (d6) | (((uint64_t)(d7)) << 32) \\\n }}\n \n+#define SECP256K1_FE_STORAGE_CONST_GET(d) \\\n+    (uint32_t)(d.n[3] >> 32), (uint32_t)d.n[3], \\\n+    (uint32_t)(d.n[2] >> 32), (uint32_t)d.n[2], \\\n+    (uint32_t)(d.n[1] >> 32), (uint32_t)d.n[1], \\\n+    (uint32_t)(d.n[0] >> 32), (uint32_t)d.n[0]\n+\n #endif /* SECP256K1_FIELD_REPR_H */"
      },
      {
        "sha": "18e4d2f30ea66450e9de4020d6e7a26d337e9985",
        "filename": "src/secp256k1/src/field_impl.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/field_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/field_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_impl.h?ref=d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6",
        "patch": "@@ -14,12 +14,12 @@\n #include \"util.h\"\n #include \"num.h\"\n \n-#if defined(USE_FIELD_10X26)\n-#include \"field_10x26_impl.h\"\n-#elif defined(USE_FIELD_5X52)\n+#if defined(SECP256K1_WIDEMUL_INT128)\n #include \"field_5x52_impl.h\"\n+#elif defined(SECP256K1_WIDEMUL_INT64)\n+#include \"field_10x26_impl.h\"\n #else\n-#error \"Please select field implementation\"\n+#error \"Please select wide multiplication implementation\"\n #endif\n \n SECP256K1_INLINE static int secp256k1_fe_equal(const secp256k1_fe *a, const secp256k1_fe *b) {"
      },
      {
        "sha": "6185be052db065e4c42e085e1889dbae5aa10429",
        "filename": "src/secp256k1/src/group.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/group.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/group.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group.h?ref=d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6",
        "patch": "@@ -95,8 +95,8 @@ static int secp256k1_gej_is_infinity(const secp256k1_gej *a);\n /** Check whether a group element's y coordinate is a quadratic residue. */\n static int secp256k1_gej_has_quad_y_var(const secp256k1_gej *a);\n \n-/** Set r equal to the double of a, a cannot be infinity. Constant time. */\n-static void secp256k1_gej_double_nonzero(secp256k1_gej *r, const secp256k1_gej *a);\n+/** Set r equal to the double of a. Constant time. */\n+static void secp256k1_gej_double(secp256k1_gej *r, const secp256k1_gej *a);\n \n /** Set r equal to the double of a. If rzr is not-NULL this sets *rzr such that r->z == a->z * *rzr (where infinity means an implicit z = 0). */\n static void secp256k1_gej_double_var(secp256k1_gej *r, const secp256k1_gej *a, secp256k1_fe *rzr);"
      },
      {
        "sha": "fbfd34897ac2009c5f173b63af110752c8a6a405",
        "filename": "src/secp256k1/src/group_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group_impl.h?ref=d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6",
        "patch": "@@ -303,7 +303,7 @@ static int secp256k1_ge_is_valid_var(const secp256k1_ge *a) {\n     return secp256k1_fe_equal_var(&y2, &x3);\n }\n \n-static SECP256K1_INLINE void secp256k1_gej_double_nonzero(secp256k1_gej *r, const secp256k1_gej *a) {\n+static SECP256K1_INLINE void secp256k1_gej_double(secp256k1_gej *r, const secp256k1_gej *a) {\n     /* Operations: 3 mul, 4 sqr, 0 normalize, 12 mul_int/add/negate.\n      *\n      * Note that there is an implementation described at\n@@ -313,8 +313,7 @@ static SECP256K1_INLINE void secp256k1_gej_double_nonzero(secp256k1_gej *r, cons\n      */\n     secp256k1_fe t1,t2,t3,t4;\n \n-    VERIFY_CHECK(!secp256k1_gej_is_infinity(a));\n-    r->infinity = 0;\n+    r->infinity = a->infinity;\n \n     secp256k1_fe_mul(&r->z, &a->z, &a->y);\n     secp256k1_fe_mul_int(&r->z, 2);       /* Z' = 2*Y*Z (2) */\n@@ -363,7 +362,7 @@ static void secp256k1_gej_double_var(secp256k1_gej *r, const secp256k1_gej *a, s\n         secp256k1_fe_mul_int(rzr, 2);\n     }\n \n-    secp256k1_gej_double_nonzero(r, a);\n+    secp256k1_gej_double(r, a);\n }\n \n static void secp256k1_gej_add_var(secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_gej *b, secp256k1_fe *rzr) {"
      },
      {
        "sha": "1985a07836daf2938332ab0588c614d7f3dab880",
        "filename": "src/secp256k1/src/hash_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/hash_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/hash_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/hash_impl.h?ref=d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6",
        "patch": "@@ -8,6 +8,7 @@\n #define SECP256K1_HASH_IMPL_H\n \n #include \"hash.h\"\n+#include \"util.h\"\n \n #include <stdlib.h>\n #include <stdint.h>\n@@ -27,9 +28,9 @@\n     (h) = t1 + t2; \\\n } while(0)\n \n-#ifdef WORDS_BIGENDIAN\n+#if defined(SECP256K1_BIG_ENDIAN)\n #define BE32(x) (x)\n-#else\n+#elif defined(SECP256K1_LITTLE_ENDIAN)\n #define BE32(p) ((((p) & 0xFF) << 24) | (((p) & 0xFF00) << 8) | (((p) & 0xFF0000) >> 8) | (((p) & 0xFF000000) >> 24))\n #endif\n "
      },
      {
        "sha": "95d3e326c9c6f0f6959b90b30f191de988b509eb",
        "filename": "src/secp256k1/src/scalar.h",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/scalar.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/scalar.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar.h?ref=d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6",
        "patch": "@@ -8,19 +8,20 @@\n #define SECP256K1_SCALAR_H\n \n #include \"num.h\"\n+#include \"util.h\"\n \n #if defined HAVE_CONFIG_H\n #include \"libsecp256k1-config.h\"\n #endif\n \n #if defined(EXHAUSTIVE_TEST_ORDER)\n #include \"scalar_low.h\"\n-#elif defined(USE_SCALAR_4X64)\n+#elif defined(SECP256K1_WIDEMUL_INT128)\n #include \"scalar_4x64.h\"\n-#elif defined(USE_SCALAR_8X32)\n+#elif defined(SECP256K1_WIDEMUL_INT64)\n #include \"scalar_8x32.h\"\n #else\n-#error \"Please select scalar implementation\"\n+#error \"Please select wide multiplication implementation\"\n #endif\n \n /** Clear a scalar to prevent the leak of sensitive data. */"
      },
      {
        "sha": "7f3992786101cf0f603aa447deb673afcdde125f",
        "filename": "src/secp256k1/src/scalar_4x64_impl.h",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/scalar_4x64_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/scalar_4x64_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_4x64_impl.h?ref=d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6",
        "patch": "@@ -192,9 +192,9 @@ static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n         tl = t; \\\n     } \\\n     c0 += tl;                 /* overflow is handled on the next line */ \\\n-    th += (c0 < tl) ? 1 : 0;  /* at most 0xFFFFFFFFFFFFFFFF */ \\\n+    th += (c0 < tl);          /* at most 0xFFFFFFFFFFFFFFFF */ \\\n     c1 += th;                 /* overflow is handled on the next line */ \\\n-    c2 += (c1 < th) ? 1 : 0;  /* never overflows by contract (verified in the next line) */ \\\n+    c2 += (c1 < th);          /* never overflows by contract (verified in the next line) */ \\\n     VERIFY_CHECK((c1 >= th) || (c2 != 0)); \\\n }\n \n@@ -207,7 +207,7 @@ static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n         tl = t; \\\n     } \\\n     c0 += tl;                 /* overflow is handled on the next line */ \\\n-    th += (c0 < tl) ? 1 : 0;  /* at most 0xFFFFFFFFFFFFFFFF */ \\\n+    th += (c0 < tl);          /* at most 0xFFFFFFFFFFFFFFFF */ \\\n     c1 += th;                 /* never overflows by contract (verified in the next line) */ \\\n     VERIFY_CHECK(c1 >= th); \\\n }\n@@ -221,32 +221,32 @@ static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n         tl = t; \\\n     } \\\n     th2 = th + th;                  /* at most 0xFFFFFFFFFFFFFFFE (in case th was 0x7FFFFFFFFFFFFFFF) */ \\\n-    c2 += (th2 < th) ? 1 : 0;       /* never overflows by contract (verified the next line) */ \\\n+    c2 += (th2 < th);               /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((th2 >= th) || (c2 != 0)); \\\n     tl2 = tl + tl;                  /* at most 0xFFFFFFFFFFFFFFFE (in case the lowest 63 bits of tl were 0x7FFFFFFFFFFFFFFF) */ \\\n-    th2 += (tl2 < tl) ? 1 : 0;      /* at most 0xFFFFFFFFFFFFFFFF */ \\\n+    th2 += (tl2 < tl);              /* at most 0xFFFFFFFFFFFFFFFF */ \\\n     c0 += tl2;                      /* overflow is handled on the next line */ \\\n-    th2 += (c0 < tl2) ? 1 : 0;      /* second overflow is handled on the next line */ \\\n+    th2 += (c0 < tl2);              /* second overflow is handled on the next line */ \\\n     c2 += (c0 < tl2) & (th2 == 0);  /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((c0 >= tl2) || (th2 != 0) || (c2 != 0)); \\\n     c1 += th2;                      /* overflow is handled on the next line */ \\\n-    c2 += (c1 < th2) ? 1 : 0;       /* never overflows by contract (verified the next line) */ \\\n+    c2 += (c1 < th2);               /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((c1 >= th2) || (c2 != 0)); \\\n }\n \n /** Add a to the number defined by (c0,c1,c2). c2 must never overflow. */\n #define sumadd(a) { \\\n     unsigned int over; \\\n     c0 += (a);                  /* overflow is handled on the next line */ \\\n-    over = (c0 < (a)) ? 1 : 0; \\\n+    over = (c0 < (a));         \\\n     c1 += over;                 /* overflow is handled on the next line */ \\\n-    c2 += (c1 < over) ? 1 : 0;  /* never overflows by contract */ \\\n+    c2 += (c1 < over);          /* never overflows by contract */ \\\n }\n \n /** Add a to the number defined by (c0,c1). c1 must never overflow, c2 must be zero. */\n #define sumadd_fast(a) { \\\n     c0 += (a);                 /* overflow is handled on the next line */ \\\n-    c1 += (c0 < (a)) ? 1 : 0;  /* never overflows by contract (verified the next line) */ \\\n+    c1 += (c0 < (a));          /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((c1 != 0) | (c0 >= (a))); \\\n     VERIFY_CHECK(c2 == 0); \\\n }"
      },
      {
        "sha": "f8c7fa7efaba92980d6f74599c93b877887504be",
        "filename": "src/secp256k1/src/scalar_8x32_impl.h",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/scalar_8x32_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/scalar_8x32_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_8x32_impl.h?ref=d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6",
        "patch": "@@ -271,9 +271,9 @@ static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n         tl = t; \\\n     } \\\n     c0 += tl;                 /* overflow is handled on the next line */ \\\n-    th += (c0 < tl) ? 1 : 0;  /* at most 0xFFFFFFFF */ \\\n+    th += (c0 < tl);          /* at most 0xFFFFFFFF */ \\\n     c1 += th;                 /* overflow is handled on the next line */ \\\n-    c2 += (c1 < th) ? 1 : 0;  /* never overflows by contract (verified in the next line) */ \\\n+    c2 += (c1 < th);          /* never overflows by contract (verified in the next line) */ \\\n     VERIFY_CHECK((c1 >= th) || (c2 != 0)); \\\n }\n \n@@ -286,7 +286,7 @@ static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n         tl = t; \\\n     } \\\n     c0 += tl;                 /* overflow is handled on the next line */ \\\n-    th += (c0 < tl) ? 1 : 0;  /* at most 0xFFFFFFFF */ \\\n+    th += (c0 < tl);          /* at most 0xFFFFFFFF */ \\\n     c1 += th;                 /* never overflows by contract (verified in the next line) */ \\\n     VERIFY_CHECK(c1 >= th); \\\n }\n@@ -300,32 +300,32 @@ static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n         tl = t; \\\n     } \\\n     th2 = th + th;                  /* at most 0xFFFFFFFE (in case th was 0x7FFFFFFF) */ \\\n-    c2 += (th2 < th) ? 1 : 0;       /* never overflows by contract (verified the next line) */ \\\n+    c2 += (th2 < th);               /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((th2 >= th) || (c2 != 0)); \\\n     tl2 = tl + tl;                  /* at most 0xFFFFFFFE (in case the lowest 63 bits of tl were 0x7FFFFFFF) */ \\\n-    th2 += (tl2 < tl) ? 1 : 0;      /* at most 0xFFFFFFFF */ \\\n+    th2 += (tl2 < tl);              /* at most 0xFFFFFFFF */ \\\n     c0 += tl2;                      /* overflow is handled on the next line */ \\\n-    th2 += (c0 < tl2) ? 1 : 0;      /* second overflow is handled on the next line */ \\\n+    th2 += (c0 < tl2);              /* second overflow is handled on the next line */ \\\n     c2 += (c0 < tl2) & (th2 == 0);  /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((c0 >= tl2) || (th2 != 0) || (c2 != 0)); \\\n     c1 += th2;                      /* overflow is handled on the next line */ \\\n-    c2 += (c1 < th2) ? 1 : 0;       /* never overflows by contract (verified the next line) */ \\\n+    c2 += (c1 < th2);               /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((c1 >= th2) || (c2 != 0)); \\\n }\n \n /** Add a to the number defined by (c0,c1,c2). c2 must never overflow. */\n #define sumadd(a) { \\\n     unsigned int over; \\\n     c0 += (a);                  /* overflow is handled on the next line */ \\\n-    over = (c0 < (a)) ? 1 : 0; \\\n+    over = (c0 < (a)); \\\n     c1 += over;                 /* overflow is handled on the next line */ \\\n-    c2 += (c1 < over) ? 1 : 0;  /* never overflows by contract */ \\\n+    c2 += (c1 < over);          /* never overflows by contract */ \\\n }\n \n /** Add a to the number defined by (c0,c1). c1 must never overflow, c2 must be zero. */\n #define sumadd_fast(a) { \\\n     c0 += (a);                 /* overflow is handled on the next line */ \\\n-    c1 += (c0 < (a)) ? 1 : 0;  /* never overflows by contract (verified the next line) */ \\\n+    c1 += (c0 < (a));          /* never overflows by contract (verified the next line) */ \\\n     VERIFY_CHECK((c1 != 0) | (c0 >= (a))); \\\n     VERIFY_CHECK(c2 == 0); \\\n }"
      },
      {
        "sha": "2ec04b1ae9aa27c26ee1a6483a90ce3b292b2a16",
        "filename": "src/secp256k1/src/scalar_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_impl.h?ref=d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6",
        "patch": "@@ -16,12 +16,12 @@\n \n #if defined(EXHAUSTIVE_TEST_ORDER)\n #include \"scalar_low_impl.h\"\n-#elif defined(USE_SCALAR_4X64)\n+#elif defined(SECP256K1_WIDEMUL_INT128)\n #include \"scalar_4x64_impl.h\"\n-#elif defined(USE_SCALAR_8X32)\n+#elif defined(SECP256K1_WIDEMUL_INT64)\n #include \"scalar_8x32_impl.h\"\n #else\n-#error \"Please select scalar implementation\"\n+#error \"Please select wide multiplication implementation\"\n #endif\n \n static const secp256k1_scalar secp256k1_scalar_one = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 1);"
      },
      {
        "sha": "3e7926503825dd4d868da82bcaba9be9822a416c",
        "filename": "src/secp256k1/src/secp256k1.c",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/secp256k1.c?ref=d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6",
        "patch": "@@ -291,7 +291,7 @@ int secp256k1_ec_pubkey_serialize(const secp256k1_context* ctx, unsigned char *o\n \n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(outputlen != NULL);\n-    ARG_CHECK(*outputlen >= ((flags & SECP256K1_FLAGS_BIT_COMPRESSION) ? 33 : 65));\n+    ARG_CHECK(*outputlen >= ((flags & SECP256K1_FLAGS_BIT_COMPRESSION) ? 33u : 65u));\n     len = *outputlen;\n     *outputlen = 0;\n     ARG_CHECK(output != NULL);"
      },
      {
        "sha": "58d2ad2fa2a5a400a01d93cea4e129feada3ef98",
        "filename": "src/secp256k1/src/tests.c",
        "status": "modified",
        "additions": 38,
        "deletions": 9,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests.c?ref=d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6",
        "patch": "@@ -182,8 +182,10 @@ void run_context_tests(int use_prealloc) {\n     ecount2 = 10;\n     secp256k1_context_set_illegal_callback(vrfy, counting_illegal_callback_fn, &ecount);\n     secp256k1_context_set_illegal_callback(sign, counting_illegal_callback_fn, &ecount2);\n-    secp256k1_context_set_error_callback(sign, counting_illegal_callback_fn, NULL);\n-    CHECK(vrfy->error_callback.fn != sign->error_callback.fn);\n+    /* set error callback (to a function that still aborts in case malloc() fails in secp256k1_context_clone() below) */\n+    secp256k1_context_set_error_callback(sign, secp256k1_default_illegal_callback_fn, NULL);\n+    CHECK(sign->error_callback.fn != vrfy->error_callback.fn);\n+    CHECK(sign->error_callback.fn == secp256k1_default_illegal_callback_fn);\n \n     /* check if sizes for cloning are consistent */\n     CHECK(secp256k1_context_preallocated_clone_size(none) == secp256k1_context_preallocated_size(SECP256K1_CONTEXT_NONE));\n@@ -239,7 +241,8 @@ void run_context_tests(int use_prealloc) {\n     }\n \n     /* Verify that the error callback makes it across the clone. */\n-    CHECK(vrfy->error_callback.fn != sign->error_callback.fn);\n+    CHECK(sign->error_callback.fn != vrfy->error_callback.fn);\n+    CHECK(sign->error_callback.fn == secp256k1_default_illegal_callback_fn);\n     /* And that it resets back to default. */\n     secp256k1_context_set_error_callback(sign, NULL, NULL);\n     CHECK(vrfy->error_callback.fn == sign->error_callback.fn);\n@@ -2215,6 +2218,9 @@ void test_ge(void) {\n                 /* Normal doubling. */\n                 secp256k1_gej_double_var(&resj, &gej[i2], NULL);\n                 ge_equals_gej(&ref, &resj);\n+                /* Constant-time doubling. */\n+                secp256k1_gej_double(&resj, &gej[i2]);\n+                ge_equals_gej(&ref, &resj);\n             }\n \n             /* Test adding opposites. */\n@@ -2967,14 +2973,16 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n \n void test_ecmult_multi_batch_single(secp256k1_ecmult_multi_func ecmult_multi) {\n     secp256k1_scalar szero;\n-    secp256k1_scalar sc[32];\n-    secp256k1_ge pt[32];\n+    secp256k1_scalar sc;\n+    secp256k1_ge pt;\n     secp256k1_gej r;\n     ecmult_multi_data data;\n     secp256k1_scratch *scratch_empty;\n \n-    data.sc = sc;\n-    data.pt = pt;\n+    random_group_element_test(&pt);\n+    random_scalar_order(&sc);\n+    data.sc = &sc;\n+    data.pt = &pt;\n     secp256k1_scalar_set_int(&szero, 0);\n \n     /* Try to multiply 1 point, but scratch space is empty.*/\n@@ -3232,6 +3240,7 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n     int skew;\n     int bits = 256;\n     secp256k1_scalar num = *number;\n+    secp256k1_scalar scalar_skew;\n \n     secp256k1_scalar_set_int(&x, 0);\n     secp256k1_scalar_set_int(&shift, 1 << w);\n@@ -3262,7 +3271,8 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n         secp256k1_scalar_add(&x, &x, &t);\n     }\n     /* Skew num because when encoding numbers as odd we use an offset */\n-    secp256k1_scalar_cadd_bit(&num, skew == 2, 1);\n+    secp256k1_scalar_set_int(&scalar_skew, 1 << (skew == 2));\n+    secp256k1_scalar_add(&num, &num, &scalar_skew);\n     CHECK(secp256k1_scalar_eq(&x, &num));\n }\n \n@@ -3374,13 +3384,32 @@ void run_wnaf(void) {\n     int i;\n     secp256k1_scalar n = {{0}};\n \n+    test_constant_wnaf(&n, 4);\n     /* Sanity check: 1 and 2 are the smallest odd and even numbers and should\n      *               have easier-to-diagnose failure modes  */\n     n.d[0] = 1;\n     test_constant_wnaf(&n, 4);\n     n.d[0] = 2;\n     test_constant_wnaf(&n, 4);\n-    /* Test 0 */\n+    /* Test -1, because it's a special case in wnaf_const */\n+    n = secp256k1_scalar_one;\n+    secp256k1_scalar_negate(&n, &n);\n+    test_constant_wnaf(&n, 4);\n+\n+    /* Test -2, which may not lead to overflows in wnaf_const */\n+    secp256k1_scalar_add(&n, &secp256k1_scalar_one, &secp256k1_scalar_one);\n+    secp256k1_scalar_negate(&n, &n);\n+    test_constant_wnaf(&n, 4);\n+\n+    /* Test (1/2) - 1 = 1/-2 and 1/2 = (1/-2) + 1\n+       as corner cases of negation handling in wnaf_const */\n+    secp256k1_scalar_inverse(&n, &n);\n+    test_constant_wnaf(&n, 4);\n+\n+    secp256k1_scalar_add(&n, &n, &secp256k1_scalar_one);\n+    test_constant_wnaf(&n, 4);\n+\n+    /* Test 0 for fixed wnaf */\n     test_fixed_wnaf_small();\n     /* Random tests */\n     for (i = 0; i < count; i++) {"
      },
      {
        "sha": "8f346701aa7af3cc7ab25a2ae4faabd3f34730ef",
        "filename": "src/secp256k1/src/tests_exhaustive.c",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests_exhaustive.c?ref=d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6",
        "patch": "@@ -141,10 +141,8 @@ void test_exhaustive_addition(const secp256k1_ge *group, const secp256k1_gej *gr\n     /* Check doubling */\n     for (i = 0; i < order; i++) {\n         secp256k1_gej tmp;\n-        if (i > 0) {\n-            secp256k1_gej_double_nonzero(&tmp, &groupj[i]);\n-            ge_equals_gej(&group[(2 * i) % order], &tmp);\n-        }\n+        secp256k1_gej_double(&tmp, &groupj[i]);\n+        ge_equals_gej(&group[(2 * i) % order], &tmp);\n         secp256k1_gej_double_var(&tmp, &groupj[i], NULL);\n         ge_equals_gej(&group[(2 * i) % order], &tmp);\n     }"
      },
      {
        "sha": "e8d7015c5dfad7423e5acc178f5f12561870271e",
        "filename": "src/secp256k1/src/util.h",
        "status": "modified",
        "additions": 50,
        "deletions": 7,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6/src/secp256k1/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/util.h?ref=d0dcf99b46738dd7ce0547d3d1e06fe2b24c50d6",
        "patch": "@@ -170,13 +170,35 @@ static SECP256K1_INLINE void *manual_alloc(void** prealloc_ptr, size_t alloc_siz\n # define I64uFORMAT \"llu\"\n #endif\n \n-#if defined(HAVE___INT128)\n-# if defined(__GNUC__)\n-#  define SECP256K1_GNUC_EXT __extension__\n-# else\n-#  define SECP256K1_GNUC_EXT\n+#if defined(__GNUC__)\n+# define SECP256K1_GNUC_EXT __extension__\n+#else\n+# define SECP256K1_GNUC_EXT\n+#endif\n+\n+/* If SECP256K1_{LITTLE,BIG}_ENDIAN is not explicitly provided, infer from various other system macros. */\n+#if !defined(SECP256K1_LITTLE_ENDIAN) && !defined(SECP256K1_BIG_ENDIAN)\n+/* Inspired by https://github.com/rofl0r/endianness.h/blob/9853923246b065a3b52d2c43835f3819a62c7199/endianness.h#L52L73 */\n+# if (defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) || \\\n+     defined(_X86_) || defined(__x86_64__) || defined(__i386__) || \\\n+     defined(__i486__) || defined(__i586__) || defined(__i686__) || \\\n+     defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL) || \\\n+     defined(__ARMEL__) || defined(__AARCH64EL__) || \\\n+     (defined(__LITTLE_ENDIAN__) && __LITTLE_ENDIAN__ == 1) || \\\n+     (defined(_LITTLE_ENDIAN) && _LITTLE_ENDIAN == 1) || \\\n+     defined(_M_IX86) || defined(_M_AMD64) || defined(_M_ARM) /* MSVC */\n+#  define SECP256K1_LITTLE_ENDIAN\n # endif\n-SECP256K1_GNUC_EXT typedef unsigned __int128 uint128_t;\n+# if (defined(__BYTE_ORDER__) && defined(__ORDER_BIG_ENDIAN__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__) || \\\n+     defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB) || \\\n+     defined(__MICROBLAZEEB__) || defined(__ARMEB__) || defined(__AARCH64EB__) || \\\n+     (defined(__BIG_ENDIAN__) && __BIG_ENDIAN__ == 1) || \\\n+     (defined(_BIG_ENDIAN) && _BIG_ENDIAN == 1)\n+#  define SECP256K1_BIG_ENDIAN\n+# endif\n+#endif\n+#if defined(SECP256K1_LITTLE_ENDIAN) == defined(SECP256K1_BIG_ENDIAN)\n+# error Please make sure that either SECP256K1_LITTLE_ENDIAN or SECP256K1_BIG_ENDIAN is set, see src/util.h.\n #endif\n \n /* Zero memory if flag == 1. Flag must be 0 or 1. Constant time. */\n@@ -197,15 +219,36 @@ static SECP256K1_INLINE void memczero(void *s, size_t len, int flag) {\n /** If flag is true, set *r equal to *a; otherwise leave it. Constant-time.  Both *r and *a must be initialized and non-negative.*/\n static SECP256K1_INLINE void secp256k1_int_cmov(int *r, const int *a, int flag) {\n     unsigned int mask0, mask1, r_masked, a_masked;\n+    /* Access flag with a volatile-qualified lvalue.\n+       This prevents clang from figuring out (after inlining) that flag can\n+       take only be 0 or 1, which leads to variable time code. */\n+    volatile int vflag = flag;\n+\n     /* Casting a negative int to unsigned and back to int is implementation defined behavior */\n     VERIFY_CHECK(*r >= 0 && *a >= 0);\n \n-    mask0 = (unsigned int)flag + ~0u;\n+    mask0 = (unsigned int)vflag + ~0u;\n     mask1 = ~mask0;\n     r_masked = ((unsigned int)*r & mask0);\n     a_masked = ((unsigned int)*a & mask1);\n \n     *r = (int)(r_masked | a_masked);\n }\n \n+/* If USE_FORCE_WIDEMUL_{INT128,INT64} is set, use that wide multiplication implementation.\n+ * Otherwise use the presence of __SIZEOF_INT128__ to decide.\n+ */\n+#if defined(USE_FORCE_WIDEMUL_INT128)\n+# define SECP256K1_WIDEMUL_INT128 1\n+#elif defined(USE_FORCE_WIDEMUL_INT64)\n+# define SECP256K1_WIDEMUL_INT64 1\n+#elif defined(__SIZEOF_INT128__)\n+# define SECP256K1_WIDEMUL_INT128 1\n+#else\n+# define SECP256K1_WIDEMUL_INT64 1\n+#endif\n+#if defined(SECP256K1_WIDEMUL_INT128)\n+SECP256K1_GNUC_EXT typedef unsigned __int128 uint128_t;\n+#endif\n+\n #endif /* SECP256K1_UTIL_H */"
      }
    ]
  }
]