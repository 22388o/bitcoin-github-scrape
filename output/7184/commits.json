[
  {
    "sha": "c6c2f0fd782ccf607027414012f45c8f48561a30",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNmMyZjBmZDc4MmNjZjYwNzAyNzQxNDAxMmY0NWM4ZjQ4NTYxYTMw",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-12-07T20:44:16Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2016-02-10T20:35:33Z"
      },
      "message": "Implement SequenceLocks functions\n\nSequenceLocks functions are used to evaluate sequence lock times or heights per BIP 68.\n\nThe majority of this code is copied from maaku in #6312\nFurther credit: btcdrak, sipa, NicolasDorier",
      "tree": {
        "sha": "851d2b78c132cf851fafb35b6d62b7bf8f562ac6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/851d2b78c132cf851fafb35b6d62b7bf8f562ac6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c6c2f0fd782ccf607027414012f45c8f48561a30",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c6c2f0fd782ccf607027414012f45c8f48561a30",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c6c2f0fd782ccf607027414012f45c8f48561a30",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c6c2f0fd782ccf607027414012f45c8f48561a30/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "dc0305d15aa02819cd4763e1efe3876d674faea7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dc0305d15aa02819cd4763e1efe3876d674faea7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/dc0305d15aa02819cd4763e1efe3876d674faea7"
      }
    ],
    "stats": {
      "total": 351,
      "additions": 301,
      "deletions": 50
    },
    "files": [
      {
        "sha": "1b28bb3203b0ed943895602390c4393aec27d4a2",
        "filename": "src/consensus/consensus.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6c2f0fd782ccf607027414012f45c8f48561a30/src/consensus/consensus.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6c2f0fd782ccf607027414012f45c8f48561a30/src/consensus/consensus.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/consensus.h?ref=c6c2f0fd782ccf607027414012f45c8f48561a30",
        "patch": "@@ -13,8 +13,11 @@ static const unsigned int MAX_BLOCK_SIGOPS = MAX_BLOCK_SIZE/50;\n /** Coinbase transaction outputs can only be spent after this number of new blocks (network rule) */\n static const int COINBASE_MATURITY = 100;\n \n-/** Flags for LockTime() */\n+/** Flags for nSequence and nLockTime locks */\n enum {\n+    /* Interpret sequence numbers as relative lock-time constraints. */\n+    LOCKTIME_VERIFY_SEQUENCE = (1 << 0),\n+\n     /* Use GetMedianTimePast() instead of nTime for end point timestamp. */\n     LOCKTIME_MEDIAN_TIME_PAST = (1 << 1),\n };"
      },
      {
        "sha": "d9bf3bd7570346477742a7e0a0f983051cb0e2f4",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 148,
        "deletions": 2,
        "changes": 150,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6c2f0fd782ccf607027414012f45c8f48561a30/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6c2f0fd782ccf607027414012f45c8f48561a30/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=c6c2f0fd782ccf607027414012f45c8f48561a30",
        "patch": "@@ -667,9 +667,10 @@ bool IsFinalTx(const CTransaction &tx, int nBlockHeight, int64_t nBlockTime)\n         return true;\n     if ((int64_t)tx.nLockTime < ((int64_t)tx.nLockTime < LOCKTIME_THRESHOLD ? (int64_t)nBlockHeight : nBlockTime))\n         return true;\n-    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n-        if (!txin.IsFinal())\n+    BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n+        if (!(txin.nSequence == CTxIn::SEQUENCE_FINAL))\n             return false;\n+    }\n     return true;\n }\n \n@@ -705,6 +706,128 @@ bool CheckFinalTx(const CTransaction &tx, int flags)\n     return IsFinalTx(tx, nBlockHeight, nBlockTime);\n }\n \n+/**\n+ * Calculates the block height and previous block's median time past at\n+ * which the transaction will be considered final in the context of BIP 68.\n+ * Also removes from the vector of input heights any entries which did not\n+ * correspond to sequence locked inputs as they do not affect the calculation.\n+ */\n+static std::pair<int, int64_t> CalculateSequenceLocks(const CTransaction &tx, int flags, std::vector<int>* prevHeights, const CBlockIndex& block)\n+{\n+    assert(prevHeights->size() == tx.vin.size());\n+\n+    // Will be set to the equivalent height- and time-based nLockTime\n+    // values that would be necessary to satisfy all relative lock-\n+    // time constraints given our view of block chain history.\n+    // The semantics of nLockTime are the last invalid height/time, so\n+    // use -1 to have the effect of any height or time being valid.\n+    int nMinHeight = -1;\n+    int64_t nMinTime = -1;\n+\n+    // tx.nVersion is signed integer so requires cast to unsigned otherwise\n+    // we would be doing a signed comparison and half the range of nVersion\n+    // wouldn't support BIP 68.\n+    bool fEnforceBIP68 = static_cast<uint32_t>(tx.nVersion) >= 2\n+                      && flags & LOCKTIME_VERIFY_SEQUENCE;\n+\n+    // Do not enforce sequence numbers as a relative lock time\n+    // unless we have been instructed to\n+    if (!fEnforceBIP68) {\n+        return std::make_pair(nMinHeight, nMinTime);\n+    }\n+\n+    for (size_t txinIndex = 0; txinIndex < tx.vin.size(); txinIndex++) {\n+        const CTxIn& txin = tx.vin[txinIndex];\n+\n+        // Sequence numbers with the most significant bit set are not\n+        // treated as relative lock-times, nor are they given any\n+        // consensus-enforced meaning at this point.\n+        if (txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_DISABLE_FLAG) {\n+            // The height of this input is not relevant for sequence locks\n+            (*prevHeights)[txinIndex] = 0;\n+            continue;\n+        }\n+\n+        int nCoinHeight = (*prevHeights)[txinIndex];\n+\n+        if (txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG) {\n+            int64_t nCoinTime = block.GetAncestor(std::max(nCoinHeight-1, 0))->GetMedianTimePast();\n+            // NOTE: Subtract 1 to maintain nLockTime semantics\n+            // BIP 68 relative lock times have the semantics of calculating\n+            // the first block or time at which the transaction would be\n+            // valid. When calculating the effective block time or height\n+            // for the entire transaction, we switch to using the\n+            // semantics of nLockTime which is the last invalid block\n+            // time or height.  Thus we subtract 1 from the calculated\n+            // time or height.\n+\n+            // Time-based relative lock-times are measured from the\n+            // smallest allowed timestamp of the block containing the\n+            // txout being spent, which is the median time past of the\n+            // block prior.\n+            nMinTime = std::max(nMinTime, nCoinTime + (int64_t)((txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_MASK) << CTxIn::SEQUENCE_LOCKTIME_GRANULARITY) - 1);\n+        } else {\n+            nMinHeight = std::max(nMinHeight, nCoinHeight + (int)(txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_MASK) - 1);\n+        }\n+    }\n+\n+    return std::make_pair(nMinHeight, nMinTime);\n+}\n+\n+static bool EvaluateSequenceLocks(const CBlockIndex& block, std::pair<int, int64_t> lockPair)\n+{\n+    assert(block.pprev);\n+    int64_t nBlockTime = block.pprev->GetMedianTimePast();\n+    if (lockPair.first >= block.nHeight || lockPair.second >= nBlockTime)\n+        return false;\n+\n+    return true;\n+}\n+\n+bool SequenceLocks(const CTransaction &tx, int flags, std::vector<int>* prevHeights, const CBlockIndex& block)\n+{\n+    return EvaluateSequenceLocks(block, CalculateSequenceLocks(tx, flags, prevHeights, block));\n+}\n+\n+bool CheckSequenceLocks(const CTransaction &tx, int flags)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(mempool.cs);\n+\n+    CBlockIndex* tip = chainActive.Tip();\n+    CBlockIndex index;\n+    index.pprev = tip;\n+    // CheckSequenceLocks() uses chainActive.Height()+1 to evaluate\n+    // height based locks because when SequenceLocks() is called within\n+    // CBlock::AcceptBlock(), the height of the block *being*\n+    // evaluated is what is used. Thus if we want to know if a\n+    // transaction can be part of the *next* block, we need to call\n+    // SequenceLocks() with one more than chainActive.Height().\n+    index.nHeight = tip->nHeight + 1;\n+\n+    // pcoinsTip contains the UTXO set for chainActive.Tip()\n+    CCoinsViewMemPool viewMemPool(pcoinsTip, mempool);\n+    std::vector<int> prevheights;\n+    prevheights.resize(tx.vin.size());\n+    for (size_t txinIndex = 0; txinIndex < tx.vin.size(); txinIndex++) {\n+        const CTxIn& txin = tx.vin[txinIndex];\n+        CCoins coins;\n+        if (!viewMemPool.GetCoins(txin.prevout.hash, coins)) {\n+            return error(\"%s: Missing input\", __func__);\n+        }\n+        if (coins.nHeight == MEMPOOL_HEIGHT) {\n+            // Assume all mempool transaction confirm in the next block\n+            prevheights[txinIndex] = tip->nHeight + 1;\n+        } else {\n+            prevheights[txinIndex] = coins.nHeight;\n+        }\n+    }\n+\n+    std::pair<int, int64_t> lockPair = CalculateSequenceLocks(tx, flags, &prevheights, index);\n+    return EvaluateSequenceLocks(index, lockPair);\n+}\n+\n+\n unsigned int GetLegacySigOpCount(const CTransaction& tx)\n {\n     unsigned int nSigOps = 0;\n@@ -949,6 +1072,14 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState &state, const C\n \n         // we have all inputs cached now, so switch back to dummy, so we don't need to keep lock on mempool\n         view.SetBackend(dummy);\n+\n+        // Only accept BIP68 sequence locked transactions that can be mined in the next\n+        // block; we don't want our mempool filled up with transactions that can't\n+        // be mined yet.\n+        // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n+        // CoinsViewCache instead of create its own\n+        if (!CheckSequenceLocks(tx, STANDARD_LOCKTIME_VERIFY_FLAGS))\n+            return state.DoS(0, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n         }\n \n         // Check for non-standard pay-to-script-hash in inputs\n@@ -2075,6 +2206,8 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n \n     CCheckQueueControl<CScriptCheck> control(fScriptChecks && nScriptCheckThreads ? &scriptcheckqueue : NULL);\n \n+    std::vector<int> prevheights;\n+    int nLockTimeFlags = 0;\n     CAmount nFees = 0;\n     int nInputs = 0;\n     unsigned int nSigOps = 0;\n@@ -2098,6 +2231,19 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n                 return state.DoS(100, error(\"ConnectBlock(): inputs missing/spent\"),\n                                  REJECT_INVALID, \"bad-txns-inputs-missingorspent\");\n \n+            // Check that transaction is BIP68 final\n+            // BIP68 lock checks (as opposed to nLockTime checks) must\n+            // be in ConnectBlock because they require the UTXO set\n+            prevheights.resize(tx.vin.size());\n+            for (size_t j = 0; j < tx.vin.size(); j++) {\n+                prevheights[j] = view.AccessCoins(tx.vin[j].prevout.hash)->nHeight;\n+            }\n+\n+            if (!SequenceLocks(tx, nLockTimeFlags, &prevheights, *pindex)) {\n+                return state.DoS(100, error(\"ConnectBlock(): contains a non-BIP68-final transaction\", __func__),\n+                                 REJECT_INVALID, \"bad-txns-nonfinal\");\n+            }\n+\n             if (fStrictPayToScriptHash)\n             {\n                 // Add in sigops done by pay-to-script-hash inputs;"
      },
      {
        "sha": "66b766316ee2587a6c8bb4310e6bf7ba8c1ad172",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 16,
        "deletions": 1,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6c2f0fd782ccf607027414012f45c8f48561a30/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6c2f0fd782ccf607027414012f45c8f48561a30/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=c6c2f0fd782ccf607027414012f45c8f48561a30",
        "patch": "@@ -341,7 +341,22 @@ bool IsFinalTx(const CTransaction &tx, int nBlockHeight, int64_t nBlockTime);\n  */\n bool CheckFinalTx(const CTransaction &tx, int flags = -1);\n \n-/** \n+/**\n+ * Check if transaction is final per BIP 68 sequence numbers and can be included in a block.\n+ * Consensus critical. Takes as input a list of heights at which tx's inputs (in order) confirmed.\n+ */\n+bool SequenceLocks(const CTransaction &tx, int flags, std::vector<int>* prevHeights, const CBlockIndex& block);\n+\n+/**\n+ * Check if transaction will be BIP 68 final in the next block to be created.\n+ *\n+ * Calls SequenceLocks() with data from the tip of the current active chain.\n+ *\n+ * See consensus/consensus.h for flag definitions.\n+ */\n+bool CheckSequenceLocks(const CTransaction &tx, int flags);\n+\n+/**\n  * Closure representing one script verification\n  * Note that this stores references to the spending transaction \n  */"
      },
      {
        "sha": "5034b238632f406aa758d5a26f1fe7487539dccf",
        "filename": "src/policy/policy.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6c2f0fd782ccf607027414012f45c8f48561a30/src/policy/policy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6c2f0fd782ccf607027414012f45c8f48561a30/src/policy/policy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.h?ref=c6c2f0fd782ccf607027414012f45c8f48561a30",
        "patch": "@@ -45,8 +45,9 @@ static const unsigned int STANDARD_SCRIPT_VERIFY_FLAGS = MANDATORY_SCRIPT_VERIFY\n /** For convenience, standard but not mandatory verify flags. */\n static const unsigned int STANDARD_NOT_MANDATORY_VERIFY_FLAGS = STANDARD_SCRIPT_VERIFY_FLAGS & ~MANDATORY_SCRIPT_VERIFY_FLAGS;\n \n-/** Used as the flags parameter to CheckFinalTx() in non-consensus code */\n-static const unsigned int STANDARD_LOCKTIME_VERIFY_FLAGS = LOCKTIME_MEDIAN_TIME_PAST;\n+/** Used as the flags parameter to LockTime() in non-consensus code. */\n+static const unsigned int STANDARD_LOCKTIME_VERIFY_FLAGS = LOCKTIME_VERIFY_SEQUENCE |\n+                                                           LOCKTIME_MEDIAN_TIME_PAST;\n \n bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType);\n     /**"
      },
      {
        "sha": "7d0b2083986ca266ea3e44bf9e363e7e1af18242",
        "filename": "src/primitives/transaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6c2f0fd782ccf607027414012f45c8f48561a30/src/primitives/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6c2f0fd782ccf607027414012f45c8f48561a30/src/primitives/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.cpp?ref=c6c2f0fd782ccf607027414012f45c8f48561a30",
        "patch": "@@ -37,7 +37,7 @@ std::string CTxIn::ToString() const\n         str += strprintf(\", coinbase %s\", HexStr(scriptSig));\n     else\n         str += strprintf(\", scriptSig=%s\", HexStr(scriptSig).substr(0, 24));\n-    if (nSequence != std::numeric_limits<unsigned int>::max())\n+    if (nSequence != SEQUENCE_FINAL)\n         str += strprintf(\", nSequence=%u\", nSequence);\n     str += \")\";\n     return str;"
      },
      {
        "sha": "1dca378b524d7d14455a5dcd2e92149996536d54",
        "filename": "src/primitives/transaction.h",
        "status": "modified",
        "additions": 30,
        "deletions": 8,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6c2f0fd782ccf607027414012f45c8f48561a30/src/primitives/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6c2f0fd782ccf607027414012f45c8f48561a30/src/primitives/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.h?ref=c6c2f0fd782ccf607027414012f45c8f48561a30",
        "patch": "@@ -61,13 +61,40 @@ class CTxIn\n     CScript scriptSig;\n     uint32_t nSequence;\n \n+    /* Setting nSequence to this value for every input in a transaction\n+     * disables nLockTime. */\n+    static const uint32_t SEQUENCE_FINAL = 0xffffffff;\n+\n+    /* Below flags apply in the context of BIP 68*/\n+    /* If this flag set, CTxIn::nSequence is NOT interpreted as a\n+     * relative lock-time. */\n+    static const uint32_t SEQUENCE_LOCKTIME_DISABLE_FLAG = (1 << 31);\n+\n+    /* If CTxIn::nSequence encodes a relative lock-time and this flag\n+     * is set, the relative lock-time has units of 512 seconds,\n+     * otherwise it specifies blocks with a granularity of 1. */\n+    static const uint32_t SEQUENCE_LOCKTIME_TYPE_FLAG = (1 << 22);\n+\n+    /* If CTxIn::nSequence encodes a relative lock-time, this mask is\n+     * applied to extract that lock-time from the sequence field. */\n+    static const uint32_t SEQUENCE_LOCKTIME_MASK = 0x0000ffff;\n+\n+    /* In order to use the same number of bits to encode roughly the\n+     * same wall-clock duration, and because blocks are naturally\n+     * limited to occur every 600s on average, the minimum granularity\n+     * for time-based relative lock-time is fixed at 512 seconds.\n+     * Converting from CTxIn::nSequence to seconds is performed by\n+     * multiplying by 512 = 2^9, or equivalently shifting up by\n+     * 9 bits. */\n+    static const int SEQUENCE_LOCKTIME_GRANULARITY = 9;\n+\n     CTxIn()\n     {\n-        nSequence = std::numeric_limits<unsigned int>::max();\n+        nSequence = SEQUENCE_FINAL;\n     }\n \n-    explicit CTxIn(COutPoint prevoutIn, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=std::numeric_limits<unsigned int>::max());\n-    CTxIn(uint256 hashPrevTx, uint32_t nOut, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=std::numeric_limits<uint32_t>::max());\n+    explicit CTxIn(COutPoint prevoutIn, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL);\n+    CTxIn(uint256 hashPrevTx, uint32_t nOut, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL);\n \n     ADD_SERIALIZE_METHODS;\n \n@@ -78,11 +105,6 @@ class CTxIn\n         READWRITE(nSequence);\n     }\n \n-    bool IsFinal() const\n-    {\n-        return (nSequence == std::numeric_limits<uint32_t>::max());\n-    }\n-\n     friend bool operator==(const CTxIn& a, const CTxIn& b)\n     {\n         return (a.prevout   == b.prevout &&"
      },
      {
        "sha": "ac753a9d5b9b3fb63f19c2b48ba8df2205fa61ff",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6c2f0fd782ccf607027414012f45c8f48561a30/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6c2f0fd782ccf607027414012f45c8f48561a30/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=c6c2f0fd782ccf607027414012f45c8f48561a30",
        "patch": "@@ -1147,7 +1147,7 @@ bool TransactionSignatureChecker::CheckLockTime(const CScriptNum& nLockTime) con\n     // prevent this condition. Alternatively we could test all\n     // inputs, but testing just this input minimizes the data\n     // required to prove correct CHECKLOCKTIMEVERIFY execution.\n-    if (txTo->vin[nIn].IsFinal())\n+    if (CTxIn::SEQUENCE_FINAL == txTo->vin[nIn].nSequence)\n         return false;\n \n     return true;"
      },
      {
        "sha": "138ba808e3966717c1650f943b2dfd843d2612c0",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 95,
        "deletions": 31,
        "changes": 126,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6c2f0fd782ccf607027414012f45c8f48561a30/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6c2f0fd782ccf607027414012f45c8f48561a30/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=c6c2f0fd782ccf607027414012f45c8f48561a30",
        "patch": "@@ -57,6 +57,20 @@ struct {\n     {2, 0xbbbeb305}, {2, 0xfe1c810a},\n };\n \n+CBlockIndex CreateBlockIndex(int nHeight)\n+{\n+    CBlockIndex index;\n+    index.nHeight = nHeight;\n+    index.pprev = chainActive.Tip();\n+    return index;\n+}\n+\n+bool TestSequenceLocks(const CTransaction &tx, int flags)\n+{\n+    LOCK(mempool.cs);\n+    return CheckSequenceLocks(tx, flags);\n+}\n+\n // NOTE: These tests rely on CreateNewBlock doing its own self-validation!\n BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n {\n@@ -79,6 +93,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n \n     // We can't make transactions until we have inputs\n     // Therefore, load 100 blocks :)\n+    int baseheight = 0;\n     std::vector<CTransaction*>txFirst;\n     for (unsigned int i = 0; i < sizeof(blockinfo)/sizeof(*blockinfo); ++i)\n     {\n@@ -92,7 +107,9 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         txCoinbase.vin[0].scriptSig.push_back(chainActive.Height());\n         txCoinbase.vout[0].scriptPubKey = CScript();\n         pblock->vtx[0] = CTransaction(txCoinbase);\n-        if (txFirst.size() < 2)\n+        if (txFirst.size() == 0)\n+            baseheight = chainActive.Height();\n+        if (txFirst.size() < 4)\n             txFirst.push_back(new CTransaction(pblock->vtx[0]));\n         pblock->hashMerkleRoot = BlockMerkleRoot(*pblock);\n         pblock->nNonce = blockinfo[i].nonce;\n@@ -240,49 +257,96 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n \n     // non-final txs in mempool\n     SetMockTime(chainActive.Tip()->GetMedianTimePast()+1);\n+    int flags = LOCKTIME_VERIFY_SEQUENCE|LOCKTIME_MEDIAN_TIME_PAST;\n+    // height map\n+    std::vector<int> prevheights;\n \n-    // height locked\n-    tx.vin[0].prevout.hash = txFirst[0]->GetHash();\n+    // relative height locked\n+    tx.nVersion = 2;\n+    tx.vin.resize(1);\n+    prevheights.resize(1);\n+    tx.vin[0].prevout.hash = txFirst[0]->GetHash(); // only 1 transaction\n+    tx.vin[0].prevout.n = 0;\n     tx.vin[0].scriptSig = CScript() << OP_1;\n-    tx.vin[0].nSequence = 0;\n+    tx.vin[0].nSequence = chainActive.Tip()->nHeight + 1; // txFirst[0] is the 2nd block\n+    prevheights[0] = baseheight + 1;\n+    tx.vout.resize(1);\n     tx.vout[0].nValue = 4900000000LL;\n     tx.vout[0].scriptPubKey = CScript() << OP_1;\n-    tx.nLockTime = chainActive.Tip()->nHeight+1;\n+    tx.nLockTime = 0;\n     hash = tx.GetHash();\n     mempool.addUnchecked(hash, entry.Fee(100000000L).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n-    BOOST_CHECK(!CheckFinalTx(tx, LOCKTIME_MEDIAN_TIME_PAST));\n-\n-    // time locked\n-    tx2.vin.resize(1);\n-    tx2.vin[0].prevout.hash = txFirst[1]->GetHash();\n-    tx2.vin[0].prevout.n = 0;\n-    tx2.vin[0].scriptSig = CScript() << OP_1;\n-    tx2.vin[0].nSequence = 0;\n-    tx2.vout.resize(1);\n-    tx2.vout[0].nValue = 4900000000LL;\n-    tx2.vout[0].scriptPubKey = CScript() << OP_1;\n-    tx2.nLockTime = chainActive.Tip()->GetMedianTimePast()+1;\n-    hash = tx2.GetHash();\n-    mempool.addUnchecked(hash, entry.Fee(100000000L).Time(GetTime()).SpendsCoinbase(true).FromTx(tx2));\n-    BOOST_CHECK(!CheckFinalTx(tx2, LOCKTIME_MEDIAN_TIME_PAST));\n+    BOOST_CHECK(CheckFinalTx(tx, flags)); // Locktime passes\n+    BOOST_CHECK(!TestSequenceLocks(tx, flags)); // Sequence locks fail\n+    BOOST_CHECK(SequenceLocks(tx, flags, &prevheights, CreateBlockIndex(chainActive.Tip()->nHeight + 2))); // Sequence locks pass on 2nd block\n+\n+    // relative time locked\n+    tx.vin[0].prevout.hash = txFirst[1]->GetHash();\n+    tx.vin[0].nSequence = CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG | (((chainActive.Tip()->GetMedianTimePast()+1-chainActive[1]->GetMedianTimePast()) >> CTxIn::SEQUENCE_LOCKTIME_GRANULARITY) + 1); // txFirst[1] is the 3rd block\n+    prevheights[0] = baseheight + 2;\n+    hash = tx.GetHash();\n+    mempool.addUnchecked(hash, entry.Time(GetTime()).FromTx(tx));\n+    BOOST_CHECK(CheckFinalTx(tx, flags)); // Locktime passes\n+    BOOST_CHECK(!TestSequenceLocks(tx, flags)); // Sequence locks fail\n+\n+    for (int i = 0; i < CBlockIndex::nMedianTimeSpan; i++)\n+        chainActive.Tip()->GetAncestor(chainActive.Tip()->nHeight - i)->nTime += 512; //Trick the MedianTimePast\n+    BOOST_CHECK(SequenceLocks(tx, flags, &prevheights, CreateBlockIndex(chainActive.Tip()->nHeight + 1))); // Sequence locks pass 512 seconds later\n+    for (int i = 0; i < CBlockIndex::nMedianTimeSpan; i++)\n+        chainActive.Tip()->GetAncestor(chainActive.Tip()->nHeight - i)->nTime -= 512; //undo tricked MTP\n+\n+    // absolute height locked\n+    tx.vin[0].prevout.hash = txFirst[2]->GetHash();\n+    tx.vin[0].nSequence = CTxIn::SEQUENCE_FINAL - 1;\n+    prevheights[0] = baseheight + 3;\n+    tx.nLockTime = chainActive.Tip()->nHeight + 1;\n+    hash = tx.GetHash();\n+    mempool.addUnchecked(hash, entry.Time(GetTime()).FromTx(tx));\n+    BOOST_CHECK(!CheckFinalTx(tx, flags)); // Locktime fails\n+    BOOST_CHECK(TestSequenceLocks(tx, flags)); // Sequence locks pass\n+    BOOST_CHECK(IsFinalTx(tx, chainActive.Tip()->nHeight + 2, chainActive.Tip()->GetMedianTimePast())); // Locktime passes on 2nd block\n+\n+    // absolute time locked\n+    tx.vin[0].prevout.hash = txFirst[3]->GetHash();\n+    tx.nLockTime = chainActive.Tip()->GetMedianTimePast();\n+    prevheights.resize(1);\n+    prevheights[0] = baseheight + 4;\n+    hash = tx.GetHash();\n+    mempool.addUnchecked(hash, entry.Time(GetTime()).FromTx(tx));\n+    BOOST_CHECK(!CheckFinalTx(tx, flags)); // Locktime fails\n+    BOOST_CHECK(TestSequenceLocks(tx, flags)); // Sequence locks pass\n+    BOOST_CHECK(IsFinalTx(tx, chainActive.Tip()->nHeight + 2, chainActive.Tip()->GetMedianTimePast() + 1)); // Locktime passes 1 second later\n+\n+    // mempool-dependent transactions (not added)\n+    tx.vin[0].prevout.hash = hash;\n+    prevheights[0] = chainActive.Tip()->nHeight + 1;\n+    tx.nLockTime = 0;\n+    tx.vin[0].nSequence = 0;\n+    BOOST_CHECK(CheckFinalTx(tx, flags)); // Locktime passes\n+    BOOST_CHECK(TestSequenceLocks(tx, flags)); // Sequence locks pass\n+    tx.vin[0].nSequence = 1;\n+    BOOST_CHECK(!TestSequenceLocks(tx, flags)); // Sequence locks fail\n+    tx.vin[0].nSequence = CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG;\n+    BOOST_CHECK(TestSequenceLocks(tx, flags)); // Sequence locks pass\n+    tx.vin[0].nSequence = CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG | 1;\n+    BOOST_CHECK(!TestSequenceLocks(tx, flags)); // Sequence locks fail\n \n     BOOST_CHECK(pblocktemplate = CreateNewBlock(chainparams, scriptPubKey));\n \n-    // Neither tx should have make it into the template.\n-    BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 1);\n+    // None of the of the absolute height/time locked tx should have made\n+    // it into the template because we still check IsFinalTx in CreateNewBlock,\n+    // but relative locked txs will if inconsistently added to mempool.\n+    // For now these will still generate a valid template until BIP68 soft fork\n+    BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 3);\n     delete pblocktemplate;\n-\n-    // However if we advance height and time by one, both will.\n+    // However if we advance height by 1 and time by 512, all of them should be mined\n+    for (int i = 0; i < CBlockIndex::nMedianTimeSpan; i++)\n+        chainActive.Tip()->GetAncestor(chainActive.Tip()->nHeight - i)->nTime += 512; //Trick the MedianTimePast\n     chainActive.Tip()->nHeight++;\n-    SetMockTime(chainActive.Tip()->GetMedianTimePast()+2);\n-\n-    // FIXME: we should *actually* create a new block so the following test\n-    //        works; CheckFinalTx() isn't fooled by monkey-patching nHeight.\n-    //BOOST_CHECK(CheckFinalTx(tx));\n-    //BOOST_CHECK(CheckFinalTx(tx2));\n+    SetMockTime(chainActive.Tip()->GetMedianTimePast() + 1);\n \n     BOOST_CHECK(pblocktemplate = CreateNewBlock(chainparams, scriptPubKey));\n-    BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 2);\n+    BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 5);\n     delete pblocktemplate;\n \n     chainActive.Tip()->nHeight--;"
      },
      {
        "sha": "90822c71d75ad6dfd4a5dcab07154a4e31ed50e3",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6c2f0fd782ccf607027414012f45c8f48561a30/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6c2f0fd782ccf607027414012f45c8f48561a30/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=c6c2f0fd782ccf607027414012f45c8f48561a30",
        "patch": "@@ -63,7 +63,7 @@ CMutableTransaction BuildCreditingTransaction(const CScript& scriptPubKey)\n     txCredit.vout.resize(1);\n     txCredit.vin[0].prevout.SetNull();\n     txCredit.vin[0].scriptSig = CScript() << CScriptNum(0) << CScriptNum(0);\n-    txCredit.vin[0].nSequence = std::numeric_limits<unsigned int>::max();\n+    txCredit.vin[0].nSequence = CTxIn::SEQUENCE_FINAL;\n     txCredit.vout[0].scriptPubKey = scriptPubKey;\n     txCredit.vout[0].nValue = 0;\n \n@@ -80,7 +80,7 @@ CMutableTransaction BuildSpendingTransaction(const CScript& scriptSig, const CMu\n     txSpend.vin[0].prevout.hash = txCredit.GetHash();\n     txSpend.vin[0].prevout.n = 0;\n     txSpend.vin[0].scriptSig = scriptSig;\n-    txSpend.vin[0].nSequence = std::numeric_limits<unsigned int>::max();\n+    txSpend.vin[0].nSequence = CTxIn::SEQUENCE_FINAL;\n     txSpend.vout[0].scriptPubKey = CScript();\n     txSpend.vout[0].nValue = 0;\n "
      },
      {
        "sha": "67001cf7df1f06eeee9893eab1e21a576258d107",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6c2f0fd782ccf607027414012f45c8f48561a30/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6c2f0fd782ccf607027414012f45c8f48561a30/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=c6c2f0fd782ccf607027414012f45c8f48561a30",
        "patch": "@@ -504,7 +504,7 @@ void CTxMemPool::removeForReorg(const CCoinsViewCache *pcoins, unsigned int nMem\n     list<CTransaction> transactionsToRemove;\n     for (indexed_transaction_set::const_iterator it = mapTx.begin(); it != mapTx.end(); it++) {\n         const CTransaction& tx = it->GetTx();\n-        if (!CheckFinalTx(tx, flags)) {\n+        if (!CheckFinalTx(tx, flags) || !CheckSequenceLocks(tx, flags)) {\n             transactionsToRemove.push_back(tx);\n         } else if (it->GetSpendsCoinbase()) {\n             BOOST_FOREACH(const CTxIn& txin, tx.vin) {"
      }
    ]
  },
  {
    "sha": "da6ad5f684b91975cae3f37495ccbd041499e86b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkYTZhZDVmNjg0YjkxOTc1Y2FlM2YzNzQ5NWNjYmQwNDE0OTllODZi",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2015-12-08T22:25:28Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2016-02-10T20:35:33Z"
      },
      "message": "Add RPC test exercising BIP68 (mempool only)",
      "tree": {
        "sha": "04ef32caaaf2b838295f39cffbdd87468f3657c9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/04ef32caaaf2b838295f39cffbdd87468f3657c9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/da6ad5f684b91975cae3f37495ccbd041499e86b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/da6ad5f684b91975cae3f37495ccbd041499e86b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/da6ad5f684b91975cae3f37495ccbd041499e86b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/da6ad5f684b91975cae3f37495ccbd041499e86b/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c6c2f0fd782ccf607027414012f45c8f48561a30",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c6c2f0fd782ccf607027414012f45c8f48561a30",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c6c2f0fd782ccf607027414012f45c8f48561a30"
      }
    ],
    "stats": {
      "total": 396,
      "additions": 396,
      "deletions": 0
    },
    "files": [
      {
        "sha": "45b4f22c0ba2665375b6ba27a35f312a6ca7d516",
        "filename": "qa/rpc-tests/bip68-sequence.py",
        "status": "added",
        "additions": 388,
        "deletions": 0,
        "changes": 388,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/da6ad5f684b91975cae3f37495ccbd041499e86b/qa/rpc-tests/bip68-sequence.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/da6ad5f684b91975cae3f37495ccbd041499e86b/qa/rpc-tests/bip68-sequence.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bip68-sequence.py?ref=da6ad5f684b91975cae3f37495ccbd041499e86b",
        "patch": "@@ -0,0 +1,388 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014-2015 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test BIP68 implementation (mempool only)\n+#\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.script import *\n+from test_framework.mininode import *\n+from test_framework.blocktools import *\n+\n+COIN = 100000000\n+SEQUENCE_LOCKTIME_DISABLE_FLAG = (1<<31)\n+SEQUENCE_LOCKTIME_TYPE_FLAG = (1<<22) # this means use time (0 means height)\n+SEQUENCE_LOCKTIME_GRANULARITY = 9 # this is a bit-shift\n+SEQUENCE_LOCKTIME_MASK = 0x0000ffff\n+\n+# RPC error for non-BIP68 final transactions\n+NOT_FINAL_ERROR = \"64: non-BIP68-final\"\n+\n+class BIP68Test(BitcoinTestFramework):\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-blockprioritysize=0\"]))\n+        self.is_network_split = False\n+        self.relayfee = self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+\n+    def run_test(self):\n+        # Generate some coins\n+        self.nodes[0].generate(110)\n+\n+        print \"Running test disable flag\"\n+        self.test_disable_flag()\n+\n+        print \"Running test sequence-lock-confirmed-inputs\"\n+        self.test_sequence_lock_confirmed_inputs()\n+\n+        print \"Running test sequence-lock-unconfirmed-inputs\"\n+        self.test_sequence_lock_unconfirmed_inputs()\n+\n+        # This test needs to change when BIP68 becomes consensus\n+        print \"Running test BIP68 not consensus\"\n+        self.test_bip68_not_consensus()\n+\n+        print \"Passed\\n\"\n+\n+    # Test that BIP68 is not in effect if tx version is 1, or if\n+    # the first sequence bit is set.\n+    def test_disable_flag(self):\n+        # Create some unconfirmed inputs\n+        new_addr = self.nodes[0].getnewaddress()\n+        self.nodes[0].sendtoaddress(new_addr, 2) # send 2 BTC\n+\n+        utxos = self.nodes[0].listunspent(0, 0)\n+        assert(len(utxos) > 0)\n+\n+        utxo = utxos[0]\n+\n+        tx1 = CTransaction()\n+        value = satoshi_round(utxo[\"amount\"] - self.relayfee)*COIN\n+\n+        # Check that the disable flag disables relative locktime.\n+        # If sequence locks were used, this would require 1 block for the\n+        # input to mature.\n+        sequence_value = SEQUENCE_LOCKTIME_DISABLE_FLAG | 1\n+        tx1.vin = [CTxIn(COutPoint(int(utxo[\"txid\"], 16), utxo[\"vout\"]), nSequence=sequence_value)] \n+        tx1.vout = [CTxOut(value, CScript([b'a']))]\n+\n+        tx1_signed = self.nodes[0].signrawtransaction(ToHex(tx1))[\"hex\"]\n+        tx1_id = self.nodes[0].sendrawtransaction(tx1_signed)\n+        tx1_id = int(tx1_id, 16)\n+\n+        # This transaction will enable sequence-locks, so this transaction should\n+        # fail\n+        tx2 = CTransaction()\n+        tx2.nVersion = 2\n+        sequence_value = sequence_value & 0x7fffffff\n+        tx2.vin = [CTxIn(COutPoint(tx1_id, 0), nSequence=sequence_value)]\n+        tx2.vout = [CTxOut(int(value-self.relayfee*COIN), CScript([b'a']))]\n+        tx2.rehash()\n+\n+        try:\n+            self.nodes[0].sendrawtransaction(ToHex(tx2))\n+        except JSONRPCException as exp:\n+            assert_equal(exp.error[\"message\"], NOT_FINAL_ERROR)\n+        else:\n+            assert(False)\n+\n+        # Setting the version back down to 1 should disable the sequence lock,\n+        # so this should be accepted.\n+        tx2.nVersion = 1\n+\n+        self.nodes[0].sendrawtransaction(ToHex(tx2))\n+\n+    # Calculate the median time past of a prior block (\"confirmations\" before\n+    # the current tip).\n+    def get_median_time_past(self, confirmations):\n+        block_hash = self.nodes[0].getblockhash(self.nodes[0].getblockcount()-confirmations)\n+        return self.nodes[0].getblockheader(block_hash)[\"mediantime\"]\n+\n+    # Test that sequence locks are respected for transactions spending confirmed inputs.\n+    def test_sequence_lock_confirmed_inputs(self):\n+        # Create lots of confirmed utxos, and use them to generate lots of random\n+        # transactions.\n+        max_outputs = 50\n+        addresses = []\n+        while len(addresses) < max_outputs:\n+            addresses.append(self.nodes[0].getnewaddress())\n+        while len(self.nodes[0].listunspent()) < 200:\n+            import random\n+            random.shuffle(addresses)\n+            num_outputs = random.randint(1, max_outputs)\n+            outputs = {}\n+            for i in xrange(num_outputs):\n+                outputs[addresses[i]] = random.randint(1, 20)*0.01\n+            self.nodes[0].sendmany(\"\", outputs)\n+            self.nodes[0].generate(1)\n+\n+        utxos = self.nodes[0].listunspent()\n+\n+        # Try creating a lot of random transactions.\n+        # Each time, choose a random number of inputs, and randomly set\n+        # some of those inputs to be sequence locked (and randomly choose\n+        # between height/time locking). Small random chance of making the locks\n+        # all pass.\n+        for i in xrange(400):\n+            # Randomly choose up to 10 inputs\n+            num_inputs = random.randint(1, 10)\n+            random.shuffle(utxos)\n+\n+            # Track whether any sequence locks used should fail\n+            should_pass = True\n+            \n+            # Track whether this transaction was built with sequence locks\n+            using_sequence_locks = False\n+\n+            tx = CTransaction()\n+            tx.nVersion = 2\n+            value = 0\n+            for j in xrange(num_inputs):\n+                sequence_value = 0xfffffffe # this disables sequence locks\n+\n+                # 50% chance we enable sequence locks\n+                if random.randint(0,1):\n+                    using_sequence_locks = True\n+\n+                    # 10% of the time, make the input sequence value pass\n+                    input_will_pass = (random.randint(1,10) == 1)\n+                    sequence_value = utxos[j][\"confirmations\"]\n+                    if not input_will_pass:\n+                        sequence_value += 1\n+                        should_pass = False\n+\n+                    # Figure out what the median-time-past was for the confirmed input\n+                    # Note that if an input has N confirmations, we're going back N blocks\n+                    # from the tip so that we're looking up MTP of the block\n+                    # PRIOR to the one the input appears in, as per the BIP68 spec.\n+                    orig_time = self.get_median_time_past(utxos[j][\"confirmations\"])\n+                    cur_time = self.get_median_time_past(0) # MTP of the tip\n+\n+                    # can only timelock this input if it's not too old -- otherwise use height\n+                    can_time_lock = True\n+                    if ((cur_time - orig_time) >> SEQUENCE_LOCKTIME_GRANULARITY) >= SEQUENCE_LOCKTIME_MASK:\n+                        can_time_lock = False\n+\n+                    # if time-lockable, then 50% chance we make this a time lock\n+                    if random.randint(0,1) and can_time_lock:\n+                        # Find first time-lock value that fails, or latest one that succeeds\n+                        time_delta = sequence_value << SEQUENCE_LOCKTIME_GRANULARITY\n+                        if input_will_pass and time_delta > cur_time - orig_time:\n+                            sequence_value = ((cur_time - orig_time) >> SEQUENCE_LOCKTIME_GRANULARITY)\n+                        elif (not input_will_pass and time_delta <= cur_time - orig_time):\n+                            sequence_value = ((cur_time - orig_time) >> SEQUENCE_LOCKTIME_GRANULARITY)+1\n+                        sequence_value |= SEQUENCE_LOCKTIME_TYPE_FLAG\n+                tx.vin.append(CTxIn(COutPoint(int(utxos[j][\"txid\"], 16), utxos[j][\"vout\"]), nSequence=sequence_value))\n+                value += utxos[j][\"amount\"]*COIN\n+            # Overestimate the size of the tx - signatures should be less than 120 bytes, and leave 50 for the output\n+            tx_size = len(ToHex(tx))/2 + 120*num_inputs + 50\n+            tx.vout.append(CTxOut(value-self.relayfee*tx_size*COIN/1000, CScript([b'a'])))\n+            rawtx = self.nodes[0].signrawtransaction(ToHex(tx))[\"hex\"]\n+\n+            try:\n+                self.nodes[0].sendrawtransaction(rawtx)\n+            except JSONRPCException as exp:\n+                assert(not should_pass and using_sequence_locks)\n+                assert_equal(exp.error[\"message\"], NOT_FINAL_ERROR)\n+            else:\n+                assert(should_pass or not using_sequence_locks)\n+                # Recalculate utxos if we successfully sent the transaction\n+                utxos = self.nodes[0].listunspent()\n+\n+    # Test that sequence locks on unconfirmed inputs must have nSequence\n+    # height or time of 0 to be accepted.\n+    # Then test that BIP68-invalid transactions are removed from the mempool\n+    # after a reorg.\n+    def test_sequence_lock_unconfirmed_inputs(self):\n+        # Store height so we can easily reset the chain at the end of the test\n+        cur_height = self.nodes[0].getblockcount()\n+\n+        utxos = self.nodes[0].listunspent()\n+\n+        # Create a mempool tx.\n+        txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 2)\n+        tx1 = FromHex(CTransaction(), self.nodes[0].getrawtransaction(txid))\n+        tx1.rehash()\n+\n+        # Anyone-can-spend mempool tx.\n+        # Sequence lock of 0 should pass.\n+        tx2 = CTransaction()\n+        tx2.nVersion = 2\n+        tx2.vin = [CTxIn(COutPoint(tx1.sha256, 0), nSequence=0)]\n+        tx2.vout = [CTxOut(int(tx1.vout[0].nValue - self.relayfee*COIN), CScript([b'a']))]\n+        tx2_raw = self.nodes[0].signrawtransaction(ToHex(tx2))[\"hex\"]\n+        tx2 = FromHex(tx2, tx2_raw)\n+        tx2.rehash()\n+\n+        self.nodes[0].sendrawtransaction(tx2_raw)\n+\n+        # Create a spend of the 0th output of orig_tx with a sequence lock\n+        # of 1, and test what happens when submitting.\n+        # orig_tx.vout[0] must be an anyone-can-spend output\n+        def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n+            sequence_value = 1\n+            if not use_height_lock:\n+                sequence_value |= SEQUENCE_LOCKTIME_TYPE_FLAG\n+\n+            tx = CTransaction()\n+            tx.nVersion = 2\n+            tx.vin = [CTxIn(COutPoint(orig_tx.sha256, 0), nSequence=sequence_value)]\n+            tx.vout = [CTxOut(int(orig_tx.vout[0].nValue - relayfee*COIN), CScript([b'a']))]\n+            tx.rehash()\n+\n+            try:\n+                node.sendrawtransaction(ToHex(tx))\n+            except JSONRPCException as exp:\n+                assert_equal(exp.error[\"message\"], NOT_FINAL_ERROR)\n+                assert(orig_tx.hash in node.getrawmempool())\n+            else:\n+                # orig_tx must not be in mempool\n+                assert(orig_tx.hash not in node.getrawmempool())\n+            return tx\n+\n+        test_nonzero_locks(tx2, self.nodes[0], self.relayfee, use_height_lock=True)\n+        test_nonzero_locks(tx2, self.nodes[0], self.relayfee, use_height_lock=False)\n+\n+        # Now mine some blocks, but make sure tx2 doesn't get mined.\n+        # Use prioritisetransaction to lower the effective feerate to 0\n+        self.nodes[0].prioritisetransaction(tx2.hash, -1e15, int(-self.relayfee*COIN))\n+        cur_time = int(time.time())\n+        for i in xrange(10):\n+            self.nodes[0].setmocktime(cur_time + 600)\n+            self.nodes[0].generate(1)\n+            cur_time += 600\n+\n+        assert(tx2.hash in self.nodes[0].getrawmempool())\n+\n+        test_nonzero_locks(tx2, self.nodes[0], self.relayfee, use_height_lock=True)\n+        test_nonzero_locks(tx2, self.nodes[0], self.relayfee, use_height_lock=False)\n+\n+        # Mine tx2, and then try again\n+        self.nodes[0].prioritisetransaction(tx2.hash, 1e15, int(self.relayfee*COIN))\n+\n+        # Advance the time on the node so that we can test timelocks\n+        self.nodes[0].setmocktime(cur_time+600)\n+        self.nodes[0].generate(1)\n+        assert(tx2.hash not in self.nodes[0].getrawmempool())\n+\n+        # Now that tx2 is not in the mempool, a sequence locked spend should\n+        # succeed\n+        tx3 = test_nonzero_locks(tx2, self.nodes[0], self.relayfee, use_height_lock=False)\n+        assert(tx3.hash in self.nodes[0].getrawmempool())\n+\n+        self.nodes[0].generate(1)\n+        assert(tx3.hash not in self.nodes[0].getrawmempool())\n+\n+        # One more test, this time using height locks\n+        tx4 = test_nonzero_locks(tx3, self.nodes[0], self.relayfee, use_height_lock=True)\n+        assert(tx4.hash in self.nodes[0].getrawmempool())\n+\n+        # Now try combining confirmed and unconfirmed inputs\n+        tx5 = test_nonzero_locks(tx4, self.nodes[0], self.relayfee, use_height_lock=True)\n+        assert(tx5.hash not in self.nodes[0].getrawmempool())\n+\n+        tx5.vin.append(CTxIn(COutPoint(int(utxos[0][\"txid\"], 16), utxos[0][\"vout\"]), nSequence=1))\n+        tx5.vout[0].nValue += int(utxos[0][\"amount\"]*COIN)\n+        raw_tx5 = self.nodes[0].signrawtransaction(ToHex(tx5))[\"hex\"]\n+\n+        try:\n+            self.nodes[0].sendrawtransaction(raw_tx5)\n+        except JSONRPCException as exp:\n+            assert_equal(exp.error[\"message\"], NOT_FINAL_ERROR)\n+        else:\n+            assert(False)\n+\n+        # Test mempool-BIP68 consistency after reorg\n+        #\n+        # State of the transactions in the last blocks:\n+        # ... -> [ tx2 ] ->  [ tx3 ]\n+        #         tip-1        tip\n+        # And currently tx4 is in the mempool.\n+        #\n+        # If we invalidate the tip, tx3 should get added to the mempool, causing\n+        # tx4 to be removed (fails sequence-lock).\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+        assert(tx4.hash not in self.nodes[0].getrawmempool())\n+        assert(tx3.hash in self.nodes[0].getrawmempool())\n+\n+        # Now mine 2 empty blocks to reorg out the current tip (labeled tip-1 in\n+        # diagram above).\n+        # This would cause tx2 to be added back to the mempool, which in turn causes\n+        # tx3 to be removed.\n+        tip = int(self.nodes[0].getblockhash(self.nodes[0].getblockcount()-1), 16)\n+        height = self.nodes[0].getblockcount()\n+        for i in xrange(2):\n+            block = create_block(tip, create_coinbase(height), cur_time)\n+            block.nVersion = 3\n+            block.rehash()\n+            block.solve()\n+            tip = block.sha256\n+            height += 1\n+            self.nodes[0].submitblock(ToHex(block))\n+            cur_time += 1\n+\n+        mempool = self.nodes[0].getrawmempool()\n+        assert(tx3.hash not in mempool)\n+        assert(tx2.hash in mempool)\n+\n+        # Reset the chain and get rid of the mocktimed-blocks\n+        self.nodes[0].setmocktime(0)\n+        self.nodes[0].invalidateblock(self.nodes[0].getblockhash(cur_height+1))\n+        self.nodes[0].generate(10)\n+\n+    # Make sure that BIP68 isn't being used to validate blocks.\n+    def test_bip68_not_consensus(self):\n+        txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 2)\n+\n+        tx1 = FromHex(CTransaction(), self.nodes[0].getrawtransaction(txid))\n+        tx1.rehash()\n+\n+        # Make an anyone-can-spend transaction\n+        tx2 = CTransaction()\n+        tx2.nVersion = 1\n+        tx2.vin = [CTxIn(COutPoint(tx1.sha256, 0), nSequence=0)]\n+        tx2.vout = [CTxOut(int(tx1.vout[0].nValue - self.relayfee*COIN), CScript([b'a']))]\n+\n+        # sign tx2\n+        tx2_raw = self.nodes[0].signrawtransaction(ToHex(tx2))[\"hex\"]\n+        tx2 = FromHex(tx2, tx2_raw)\n+        tx2.rehash()\n+\n+        self.nodes[0].sendrawtransaction(ToHex(tx2))\n+        \n+        # Now make an invalid spend of tx2 according to BIP68\n+        sequence_value = 100 # 100 block relative locktime\n+\n+        tx3 = CTransaction()\n+        tx3.nVersion = 2\n+        tx3.vin = [CTxIn(COutPoint(tx2.sha256, 0), nSequence=sequence_value)]\n+        tx3.vout = [CTxOut(int(tx2.vout[0].nValue - self.relayfee*COIN), CScript([b'a']))]\n+        tx3.rehash()\n+\n+        try:\n+            self.nodes[0].sendrawtransaction(ToHex(tx3))\n+        except JSONRPCException as exp:\n+            assert_equal(exp.error[\"message\"], NOT_FINAL_ERROR)\n+        else:\n+            assert(False)\n+\n+        # make a block that violates bip68; ensure that the tip updates\n+        tip = int(self.nodes[0].getbestblockhash(), 16)\n+        block = create_block(tip, create_coinbase(self.nodes[0].getblockcount()+1))\n+        block.nVersion = 3\n+        block.vtx.extend([tx1, tx2, tx3])\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        block.rehash()\n+        block.solve()\n+\n+        self.nodes[0].submitblock(ToHex(block))\n+        assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n+\n+\n+if __name__ == '__main__':\n+    BIP68Test().main()"
      },
      {
        "sha": "259dba71c3eb10134f6562870940e8f1ff186053",
        "filename": "qa/rpc-tests/test_framework/mininode.py",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/da6ad5f684b91975cae3f37495ccbd041499e86b/qa/rpc-tests/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/da6ad5f684b91975cae3f37495ccbd041499e86b/qa/rpc-tests/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/mininode.py?ref=da6ad5f684b91975cae3f37495ccbd041499e86b",
        "patch": "@@ -230,6 +230,14 @@ def ser_int_vector(l):\n         r += struct.pack(\"<i\", i)\n     return r\n \n+# Deserialize from a hex string representation (eg from RPC)\n+def FromHex(obj, hex_string):\n+    obj.deserialize(cStringIO.StringIO(binascii.unhexlify(hex_string)))\n+    return obj\n+\n+# Convert a binary-serializable object to hex (eg for submission via RPC)\n+def ToHex(obj):\n+    return binascii.hexlify(obj.serialize()).decode('utf-8')\n \n # Objects that map to bitcoind objects, which can be serialized/deserialized\n "
      }
    ]
  },
  {
    "sha": "a51c79be6b8ef060697287dce3195876069899bd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNTFjNzliZTZiOGVmMDYwNjk3Mjg3ZGNlMzE5NTg3NjA2OTg5OWJk",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2016-02-10T21:01:04Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2016-02-10T21:01:04Z"
      },
      "message": "Bug fix to RPC test",
      "tree": {
        "sha": "85af7f550143d618185f1cb92b63ecf20d0c80a4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/85af7f550143d618185f1cb92b63ecf20d0c80a4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a51c79be6b8ef060697287dce3195876069899bd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a51c79be6b8ef060697287dce3195876069899bd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a51c79be6b8ef060697287dce3195876069899bd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a51c79be6b8ef060697287dce3195876069899bd/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "da6ad5f684b91975cae3f37495ccbd041499e86b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/da6ad5f684b91975cae3f37495ccbd041499e86b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/da6ad5f684b91975cae3f37495ccbd041499e86b"
      }
    ],
    "stats": {
      "total": 3,
      "additions": 1,
      "deletions": 2
    },
    "files": [
      {
        "sha": "bd61282fa18e49a2530cd2ba89db137f713bee21",
        "filename": "qa/rpc-tests/bip68-sequence.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a51c79be6b8ef060697287dce3195876069899bd/qa/rpc-tests/bip68-sequence.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a51c79be6b8ef060697287dce3195876069899bd/qa/rpc-tests/bip68-sequence.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bip68-sequence.py?ref=a51c79be6b8ef060697287dce3195876069899bd",
        "patch": "@@ -202,8 +202,6 @@ def test_sequence_lock_unconfirmed_inputs(self):\n         # Store height so we can easily reset the chain at the end of the test\n         cur_height = self.nodes[0].getblockcount()\n \n-        utxos = self.nodes[0].listunspent()\n-\n         # Create a mempool tx.\n         txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 2)\n         tx1 = FromHex(CTransaction(), self.nodes[0].getrawtransaction(txid))\n@@ -286,6 +284,7 @@ def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n         tx5 = test_nonzero_locks(tx4, self.nodes[0], self.relayfee, use_height_lock=True)\n         assert(tx5.hash not in self.nodes[0].getrawmempool())\n \n+        utxos = self.nodes[0].listunspent()\n         tx5.vin.append(CTxIn(COutPoint(int(utxos[0][\"txid\"], 16), utxos[0][\"vout\"]), nSequence=1))\n         tx5.vout[0].nValue += int(utxos[0][\"amount\"]*COIN)\n         raw_tx5 = self.nodes[0].signrawtransaction(ToHex(tx5))[\"hex\"]"
      }
    ]
  },
  {
    "sha": "b043c4b746c8199ce948aa5e8b186e0d1a61ad68",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMDQzYzRiNzQ2YzgxOTljZTk0OGFhNWU4YjE4NmUwZDFhNjFhZDY4",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2016-02-11T20:34:04Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2016-02-11T20:34:04Z"
      },
      "message": "fix sdaftuar's nits again\n\nit boggles the mind why these nits can't be delivered on a more timely basis",
      "tree": {
        "sha": "4fdcc4c38f5bafb50f9ad9921aac0edc0e2ed8a3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4fdcc4c38f5bafb50f9ad9921aac0edc0e2ed8a3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b043c4b746c8199ce948aa5e8b186e0d1a61ad68",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b043c4b746c8199ce948aa5e8b186e0d1a61ad68",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b043c4b746c8199ce948aa5e8b186e0d1a61ad68",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b043c4b746c8199ce948aa5e8b186e0d1a61ad68/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a51c79be6b8ef060697287dce3195876069899bd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a51c79be6b8ef060697287dce3195876069899bd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a51c79be6b8ef060697287dce3195876069899bd"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 7,
      "deletions": 7
    },
    "files": [
      {
        "sha": "7d75e2ea651880c4e3f25aa9d655b28b5a17c8be",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b043c4b746c8199ce948aa5e8b186e0d1a61ad68/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b043c4b746c8199ce948aa5e8b186e0d1a61ad68/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=b043c4b746c8199ce948aa5e8b186e0d1a61ad68",
        "patch": "@@ -799,10 +799,10 @@ bool CheckSequenceLocks(const CTransaction &tx, int flags)\n     index.pprev = tip;\n     // CheckSequenceLocks() uses chainActive.Height()+1 to evaluate\n     // height based locks because when SequenceLocks() is called within\n-    // CBlock::AcceptBlock(), the height of the block *being*\n-    // evaluated is what is used. Thus if we want to know if a\n-    // transaction can be part of the *next* block, we need to call\n-    // SequenceLocks() with one more than chainActive.Height().\n+    // ConnectBlock(), the height of the block *being*\n+    // evaluated is what is used.\n+    // Thus if we want to know if a transaction can be part of the\n+    // *next* block, we need to use one more than chainActive.Height()\n     index.nHeight = tip->nHeight + 1;\n \n     // pcoinsTip contains the UTXO set for chainActive.Tip()\n@@ -2240,7 +2240,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n             }\n \n             if (!SequenceLocks(tx, nLockTimeFlags, &prevheights, *pindex)) {\n-                return state.DoS(100, error(\"ConnectBlock(): contains a non-BIP68-final transaction\", __func__),\n+                return state.DoS(100, error(\"%s: contains a non-BIP68-final transaction\", __func__),\n                                  REJECT_INVALID, \"bad-txns-nonfinal\");\n             }\n "
      },
      {
        "sha": "a576078f067e37989ceb4d195034cf449698752f",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b043c4b746c8199ce948aa5e8b186e0d1a61ad68/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b043c4b746c8199ce948aa5e8b186e0d1a61ad68/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=b043c4b746c8199ce948aa5e8b186e0d1a61ad68",
        "patch": "@@ -350,7 +350,7 @@ bool SequenceLocks(const CTransaction &tx, int flags, std::vector<int>* prevHeig\n /**\n  * Check if transaction will be BIP 68 final in the next block to be created.\n  *\n- * Calls SequenceLocks() with data from the tip of the current active chain.\n+ * Simulates calling SequenceLocks() with data from the tip of the current active chain.\n  *\n  * See consensus/consensus.h for flag definitions.\n  */"
      },
      {
        "sha": "f25dbf22d5d58d8eb98f2881bfadbad463f2db21",
        "filename": "src/policy/policy.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b043c4b746c8199ce948aa5e8b186e0d1a61ad68/src/policy/policy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b043c4b746c8199ce948aa5e8b186e0d1a61ad68/src/policy/policy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.h?ref=b043c4b746c8199ce948aa5e8b186e0d1a61ad68",
        "patch": "@@ -45,7 +45,7 @@ static const unsigned int STANDARD_SCRIPT_VERIFY_FLAGS = MANDATORY_SCRIPT_VERIFY\n /** For convenience, standard but not mandatory verify flags. */\n static const unsigned int STANDARD_NOT_MANDATORY_VERIFY_FLAGS = STANDARD_SCRIPT_VERIFY_FLAGS & ~MANDATORY_SCRIPT_VERIFY_FLAGS;\n \n-/** Used as the flags parameter to LockTime() in non-consensus code. */\n+/** Used as the flags parameter to sequence and nLocktime checks in non-consensus code. */\n static const unsigned int STANDARD_LOCKTIME_VERIFY_FLAGS = LOCKTIME_VERIFY_SEQUENCE |\n                                                            LOCKTIME_MEDIAN_TIME_PAST;\n "
      }
    ]
  }
]