[
  {
    "sha": "2a4e60b48261d3f0ec3d85f97af998ef989134e0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyYTRlNjBiNDgyNjFkM2YwZWMzZDg1Zjk3YWY5OThlZjk4OTEzNGUw",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-09-10T17:58:41Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-09-10T18:54:50Z"
      },
      "message": "Fix block index inconsistency in InvalidateBlock()\n\nPreviously, we could release cs_main while leaving the block index in a state\nthat would fail CheckBlockIndex, because setBlockIndexCandidates was not being\nfully populated before releasing cs_main.",
      "tree": {
        "sha": "9c80a637185174eef64b1c77d1004dc926d5e0ad",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9c80a637185174eef64b1c77d1004dc926d5e0ad"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2a4e60b48261d3f0ec3d85f97af998ef989134e0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2a4e60b48261d3f0ec3d85f97af998ef989134e0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2a4e60b48261d3f0ec3d85f97af998ef989134e0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2a4e60b48261d3f0ec3d85f97af998ef989134e0/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1985c4efda56b48f6f9c04f39d69268ee8f0b40a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1985c4efda56b48f6f9c04f39d69268ee8f0b40a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1985c4efda56b48f6f9c04f39d69268ee8f0b40a"
      }
    ],
    "stats": {
      "total": 54,
      "additions": 52,
      "deletions": 2
    },
    "files": [
      {
        "sha": "62de023e2de6a1368437221a03aa94a96e8a9fc8",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 2,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a4e60b48261d3f0ec3d85f97af998ef989134e0/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a4e60b48261d3f0ec3d85f97af998ef989134e0/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=2a4e60b48261d3f0ec3d85f97af998ef989134e0",
        "patch": "@@ -2778,6 +2778,38 @@ bool CChainState::InvalidateBlock(CValidationState& state, const CChainParams& c\n     bool pindex_was_in_chain = false;\n     int disconnected = 0;\n \n+    // We do not allow ActivateBestChain() to run while InvalidateBlock() is\n+    // running, as that could cause the tip to change while we disconnect\n+    // blocks.\n+    LOCK(m_cs_chainstate);\n+\n+    // We'll be acquiring and releasing cs_main below, to allow the validation\n+    // callbacks to run. However, we should keep the block index in a\n+    // consistent state as we disconnect blocks -- in particular we need to\n+    // add equal-work blocks to setBlockIndexCandidates as we disconnect.\n+    // To avoid walking the block index repeatedly in search of candidates,\n+    // build a map once so that we can look up candidate blocks by chain\n+    // work as we go.\n+    std::multimap<const arith_uint256, CBlockIndex *> candidate_blocks_by_work;\n+\n+    {\n+        LOCK(cs_main);\n+        for (const auto& entry : m_blockman.m_block_index) {\n+            CBlockIndex *candidate = entry.second;\n+            // We don't need to put anything in our active chain into the\n+            // multimap, because those candidates will be found and considered\n+            // as we disconnect.\n+            // Instead, consider only non-active-chain blocks that have at\n+            // least as much work as where we expect the new tip to end up.\n+            if (!m_chain.Contains(candidate) &&\n+                    !CBlockIndexWorkComparator()(candidate, pindex->pprev) &&\n+                    candidate->IsValid(BLOCK_VALID_TRANSACTIONS) &&\n+                    candidate->HaveTxsDownloaded()) {\n+                candidate_blocks_by_work.insert(std::make_pair(candidate->nChainWork, candidate));\n+            }\n+        }\n+    }\n+\n     // Disconnect (descendants of) pindex, and mark them invalid.\n     while (true) {\n         if (ShutdownRequested()) break;\n@@ -2820,11 +2852,24 @@ bool CChainState::InvalidateBlock(CValidationState& state, const CChainParams& c\n             setDirtyBlockIndex.insert(to_mark_failed);\n         }\n \n+        // Add any equal or more work headers to setBlockIndexCandidates\n+        auto candidate_it = candidate_blocks_by_work.lower_bound(invalid_walk_tip->pprev->nChainWork);\n+        while (candidate_it != candidate_blocks_by_work.end()) {\n+            if (!CBlockIndexWorkComparator()(candidate_it->second, invalid_walk_tip->pprev)) {\n+                setBlockIndexCandidates.insert(candidate_it->second);\n+                candidate_it = candidate_blocks_by_work.erase(candidate_it);\n+            } else {\n+                ++candidate_it;\n+            }\n+        }\n+\n         // Track the last disconnected block, so we can correct its BLOCK_FAILED_CHILD status in future\n         // iterations, or, if it's the last one, call InvalidChainFound on it.\n         to_mark_failed = invalid_walk_tip;\n     }\n \n+    CheckBlockIndex(chainparams.GetConsensus());\n+\n     {\n         LOCK(cs_main);\n         if (m_chain.Contains(to_mark_failed)) {\n@@ -2838,8 +2883,13 @@ bool CChainState::InvalidateBlock(CValidationState& state, const CChainParams& c\n         setBlockIndexCandidates.erase(to_mark_failed);\n         m_blockman.m_failed_blocks.insert(to_mark_failed);\n \n-        // The resulting new best tip may not be in setBlockIndexCandidates anymore, so\n-        // add it again.\n+        // If any new blocks somehow arrived while we were disconnecting\n+        // (above), then the pre-calculation of what should go into\n+        // setBlockIndexCandidates may have missed entries. This would\n+        // technically be an inconsistency in the block index, but if we clean\n+        // it up here, this should be an essentially unobservable error.\n+        // Loop back over all block index entries and add any missing entries\n+        // to setBlockIndexCandidates.\n         BlockMap::iterator it = m_blockman.m_block_index.begin();\n         while (it != m_blockman.m_block_index.end()) {\n             if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->HaveTxsDownloaded() && !setBlockIndexCandidates.value_comp()(it->second, m_chain.Tip())) {"
      }
    ]
  }
]