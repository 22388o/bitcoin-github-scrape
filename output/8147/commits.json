[
  {
    "sha": "8f5734abe519f0d2f029f9db84ac5815b3ce56ce",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4ZjU3MzRhYmU1MTlmMGQyZjAyOWY5ZGI4NGFjNTgxNWIzY2U1NmNl",
    "commit": {
      "author": {
        "name": "Kaz Wesley",
        "email": "keziahw@gmail.com",
        "date": "2016-06-14T22:06:26Z"
      },
      "committer": {
        "name": "Kaz Wesley",
        "email": "keziahw@gmail.com",
        "date": "2016-06-16T14:05:25Z"
      },
      "message": "Split and encapsulate CNodeState; reduce locking.\n\nMove the CNodeState properties that aren't currently closely tied to cs_main\ndata into separately-encapsulated domains of a Peer object; each domain handles\nits synchronization internally. Move a few main-only CNode fields to Peer.\nReduce main's usage of CNode fields by determining Peer properties based on the\nCNode at the time the Peer is created.\n\nReduce data guarded by cs_main, cs_filter, cs_feeFilter.\n\nAllow punishing (ban/disconnect) nodes that haven't sent versions yet.",
      "tree": {
        "sha": "8b69a409eaef4f6ca7835a65c2c1c1defe17253f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8b69a409eaef4f6ca7835a65c2c1c1defe17253f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8f5734abe519f0d2f029f9db84ac5815b3ce56ce",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8f5734abe519f0d2f029f9db84ac5815b3ce56ce",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8f5734abe519f0d2f029f9db84ac5815b3ce56ce",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8f5734abe519f0d2f029f9db84ac5815b3ce56ce/comments",
    "author": {
      "login": "kazcw",
      "id": 1047859,
      "node_id": "MDQ6VXNlcjEwNDc4NTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1047859?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kazcw",
      "html_url": "https://github.com/kazcw",
      "followers_url": "https://api.github.com/users/kazcw/followers",
      "following_url": "https://api.github.com/users/kazcw/following{/other_user}",
      "gists_url": "https://api.github.com/users/kazcw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kazcw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kazcw/subscriptions",
      "organizations_url": "https://api.github.com/users/kazcw/orgs",
      "repos_url": "https://api.github.com/users/kazcw/repos",
      "events_url": "https://api.github.com/users/kazcw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kazcw/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kazcw",
      "id": 1047859,
      "node_id": "MDQ6VXNlcjEwNDc4NTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1047859?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kazcw",
      "html_url": "https://github.com/kazcw",
      "followers_url": "https://api.github.com/users/kazcw/followers",
      "following_url": "https://api.github.com/users/kazcw/following{/other_user}",
      "gists_url": "https://api.github.com/users/kazcw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kazcw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kazcw/subscriptions",
      "organizations_url": "https://api.github.com/users/kazcw/orgs",
      "repos_url": "https://api.github.com/users/kazcw/repos",
      "events_url": "https://api.github.com/users/kazcw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kazcw/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fb0ac482eee761ec17ed2c11df11e054347a026d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fb0ac482eee761ec17ed2c11df11e054347a026d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fb0ac482eee761ec17ed2c11df11e054347a026d"
      }
    ],
    "stats": {
      "total": 934,
      "additions": 671,
      "deletions": 263
    },
    "files": [
      {
        "sha": "f865f2bc288750441e37fe6132c942b0c6e3cb28",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f5734abe519f0d2f029f9db84ac5815b3ce56ce/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f5734abe519f0d2f029f9db84ac5815b3ce56ce/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=8f5734abe519f0d2f029f9db84ac5815b3ce56ce",
        "patch": "@@ -106,6 +106,7 @@ BITCOIN_CORE_H = \\\n   net.h \\\n   netbase.h \\\n   noui.h \\\n+  peer.h \\\n   policy/fees.h \\\n   policy/policy.h \\\n   policy/rbf.h \\\n@@ -174,6 +175,7 @@ libbitcoin_server_a_SOURCES = \\\n   miner.cpp \\\n   net.cpp \\\n   noui.cpp \\\n+  peer.cpp \\\n   policy/fees.cpp \\\n   policy/policy.cpp \\\n   pow.cpp \\"
      },
      {
        "sha": "aba99837b49d1c5327e092a1007b276d191cbaaa",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f5734abe519f0d2f029f9db84ac5815b3ce56ce/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f5734abe519f0d2f029f9db84ac5815b3ce56ce/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=8f5734abe519f0d2f029f9db84ac5815b3ce56ce",
        "patch": "@@ -63,6 +63,7 @@ BITCOIN_TESTS =\\\n   test/multisig_tests.cpp \\\n   test/net_tests.cpp \\\n   test/netbase_tests.cpp \\\n+  test/peer_tests.cpp \\\n   test/pmt_tests.cpp \\\n   test/policyestimator_tests.cpp \\\n   test/pow_tests.cpp \\"
      },
      {
        "sha": "bac279433c58090022db223e240258784b736559",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 144,
        "deletions": 208,
        "changes": 352,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f5734abe519f0d2f029f9db84ac5815b3ce56ce/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f5734abe519f0d2f029f9db84ac5815b3ce56ce/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=8f5734abe519f0d2f029f9db84ac5815b3ce56ce",
        "patch": "@@ -17,6 +17,7 @@\n #include \"init.h\"\n #include \"merkleblock.h\"\n #include \"net.h\"\n+#include \"peer.h\"\n #include \"policy/fees.h\"\n #include \"policy/policy.h\"\n #include \"pow.h\"\n@@ -81,6 +82,8 @@ uint64_t nPruneTarget = 0;\n int64_t nMaxTipAge = DEFAULT_MAX_TIP_AGE;\n bool fEnableReplacement = DEFAULT_ENABLE_REPLACEMENT;\n \n+PeerManager peermgr;\n+HeaderSync headersync;\n \n CFeeRate minRelayTxFee = CFeeRate(DEFAULT_MIN_RELAY_TX_FEE);\n CAmount maxTxFee = DEFAULT_TRANSACTION_MAXFEE;\n@@ -140,8 +143,6 @@ namespace {\n      * missing the data for the block.\n      */\n     set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexCandidates;\n-    /** Number of nodes with fSyncStarted. */\n-    int nSyncStarted = 0;\n     /** All pairs A->B, where A (or one of its ancestors) misses transactions, but B has transactions.\n      * Pruned nodes may have entries where B is missing data.\n      */\n@@ -169,7 +170,7 @@ namespace {\n      * messages or ban them when processing happens afterwards. Protected by\n      * cs_main.\n      */\n-    map<uint256, NodeId> mapBlockSource;\n+    map<uint256, std::weak_ptr<Peer>> mapBlockSource;\n \n     /**\n      * Filter for transactions that were recently rejected by\n@@ -202,9 +203,6 @@ namespace {\n     };\n     map<uint256, pair<NodeId, list<QueuedBlock>::iterator> > mapBlocksInFlight;\n \n-    /** Number of preferable block download peers. */\n-    int nPreferredDownload = 0;\n-\n     /** Dirty block index entries. */\n     set<CBlockIndex*> setDirtyBlockIndex;\n \n@@ -221,38 +219,35 @@ namespace {\n     std::deque<std::pair<int64_t, MapRelay::iterator>> vRelayExpiration;\n } // anon namespace\n \n+namespace {\n+    void LogMisbehavior(const Peer& peer, int badnessBefore, int badnessAfter) {\n+        bool ban = Misbehavior::IsExcessive(badnessAfter);\n+        auto comment = (ban ? \" BAN THRESHOLD EXCEEDED\" : \"\");\n+        LogPrintf(\"%s: %s (%d -> %d)%s\\n\", __func__, peer.GetName(), badnessBefore, badnessAfter, comment);\n+    }\n+\n+    void InitPeerSignals() EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n+        static bool done = false;\n+        if (!done) {\n+            Misbehavior::GetSignals().OnMisbehavior.connect(LogMisbehavior);\n+        }\n+    }\n+} // anon namespace\n+\n //////////////////////////////////////////////////////////////////////////////\n //\n // Registration of network node signals.\n //\n \n namespace {\n \n-struct CBlockReject {\n-    unsigned char chRejectCode;\n-    string strRejectReason;\n-    uint256 hashBlock;\n-};\n-\n /**\n  * Maintain validation-specific state about nodes, protected by cs_main, instead\n  * by CNode's own locks. This simplifies asynchronous operation, where\n  * processing of incoming data is done after the ProcessMessage call returns,\n  * and we're no longer holding the node's locks.\n  */\n struct CNodeState {\n-    //! The peer's address\n-    CService address;\n-    //! Whether we have a fully established connection.\n-    bool fCurrentlyConnected;\n-    //! Accumulated misbehaviour score for this peer.\n-    int nMisbehavior;\n-    //! Whether this peer should be disconnected and banned (unless whitelisted).\n-    bool fShouldBan;\n-    //! String name of this peer (debugging/logging purposes).\n-    std::string name;\n-    //! List of asynchronously-determined block rejections to notify this peer about.\n-    std::vector<CBlockReject> rejects;\n     //! The best known block we know this peer has announced.\n     CBlockIndex *pindexBestKnownBlock;\n     //! The hash of the last unknown block this peer has announced.\n@@ -270,15 +265,8 @@ struct CNodeState {\n     int64_t nDownloadingSince;\n     int nBlocksInFlight;\n     int nBlocksInFlightValidHeaders;\n-    //! Whether we consider this a preferred download peer.\n-    bool fPreferredDownload;\n-    //! Whether this peer wants invs or headers (when possible) for block announcements.\n-    bool fPreferHeaders;\n \n     CNodeState() {\n-        fCurrentlyConnected = false;\n-        nMisbehavior = 0;\n-        fShouldBan = false;\n         pindexBestKnownBlock = NULL;\n         hashLastUnknownBlock.SetNull();\n         pindexLastCommonBlock = NULL;\n@@ -288,8 +276,6 @@ struct CNodeState {\n         nDownloadingSince = 0;\n         nBlocksInFlight = 0;\n         nBlocksInFlightValidHeaders = 0;\n-        fPreferredDownload = false;\n-        fPreferHeaders = false;\n     }\n };\n \n@@ -310,50 +296,34 @@ int GetHeight()\n     return chainActive.Height();\n }\n \n-void UpdatePreferredDownload(CNode* node, CNodeState* state)\n-{\n-    nPreferredDownload -= state->fPreferredDownload;\n-\n-    // Whether this node should be marked as a preferred download node.\n-    state->fPreferredDownload = (!node->fInbound || node->fWhitelisted) && !node->fOneShot && !node->fClient;\n-\n-    nPreferredDownload += state->fPreferredDownload;\n-}\n-\n void InitializeNode(NodeId nodeid, const CNode *pnode) {\n+    Peer::Params params{nodeid, pnode->addrName};\n+    params.fNoBan = pnode->fWhitelisted || pnode->addr.IsLocal();\n+    params.fNoDisconnect = pnode->fWhitelisted;\n+    if (pnode->fOneShot)\n+        params.preferedness = DownloadPreferredness::BELOW_NORMAL;\n+    else if (!pnode->fInbound || pnode->fWhitelisted)\n+        params.preferedness = DownloadPreferredness::ABOVE_NORMAL;\n+    if (pnode->fWhitelisted && GetBoolArg(\"-whitelistforcerelay\", DEFAULT_WHITELISTFORCERELAY))\n+        params.fAlwaysRelayTx = true;\n+    peermgr.Register(nodeid, std::make_shared<Peer>(std::move(params)));\n+\n     LOCK(cs_main);\n     CNodeState &state = mapNodeState.insert(std::make_pair(nodeid, CNodeState())).first->second;\n-    state.name = pnode->addrName;\n-    state.address = pnode->addr;\n }\n \n-void FinalizeNode(NodeId nodeid) {\n-    LOCK(cs_main);\n-    CNodeState *state = State(nodeid);\n-\n-    if (state->fSyncStarted)\n-        nSyncStarted--;\n-\n-    if (state->nMisbehavior == 0 && state->fCurrentlyConnected) {\n-        AddressCurrentlyConnected(state->address);\n+bool FinalizeNode(NodeId nodeid) {\n+    bool fWasGood;\n+    {\n+        auto ppeer = peermgr.Get(nodeid);\n+        assert(ppeer);\n+        fWasGood = (ppeer->GetMisbehavior() == 0 && ppeer->IsHandshakeCompleted());\n     }\n+    peermgr.Unregister(nodeid);\n \n-    BOOST_FOREACH(const QueuedBlock& entry, state->vBlocksInFlight) {\n-        mapBlocksInFlight.erase(entry.hash);\n-    }\n+    LOCK(cs_main);\n     EraseOrphansFor(nodeid);\n-    nPreferredDownload -= state->fPreferredDownload;\n-    nPeersWithValidatedDownloads -= (state->nBlocksInFlightValidHeaders != 0);\n-    assert(nPeersWithValidatedDownloads >= 0);\n-\n-    mapNodeState.erase(nodeid);\n-\n-    if (mapNodeState.empty()) {\n-        // Do a consistency check after the last peer is removed.\n-        assert(mapBlocksInFlight.empty());\n-        assert(nPreferredDownload == 0);\n-        assert(nPeersWithValidatedDownloads == 0);\n-    }\n+    return fWasGood;\n }\n \n // Requires cs_main.\n@@ -557,11 +527,15 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<CBl\n } // anon namespace\n \n bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n+    auto ppeer = peermgr.Get(nodeid);\n+    if (!ppeer)\n+        return false;\n     LOCK(cs_main);\n     CNodeState *state = State(nodeid);\n     if (state == NULL)\n         return false;\n-    stats.nMisbehavior = state->nMisbehavior;\n+    stats.nMisbehavior = ppeer->GetMisbehavior();\n+    stats.fRelayTxes = ppeer->CanRelayTx();\n     stats.nSyncHeight = state->pindexBestKnownBlock ? state->pindexBestKnownBlock->nHeight : -1;\n     stats.nCommonHeight = state->pindexLastCommonBlock ? state->pindexLastCommonBlock->nHeight : -1;\n     BOOST_FOREACH(const QueuedBlock& queue, state->vBlocksInFlight) {\n@@ -1699,26 +1673,6 @@ void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip)\n     CheckForkWarningConditions();\n }\n \n-// Requires cs_main.\n-void Misbehaving(NodeId pnode, int howmuch)\n-{\n-    if (howmuch == 0)\n-        return;\n-\n-    CNodeState *state = State(pnode);\n-    if (state == NULL)\n-        return;\n-\n-    state->nMisbehavior += howmuch;\n-    int banscore = GetArg(\"-banscore\", DEFAULT_BANSCORE_THRESHOLD);\n-    if (state->nMisbehavior >= banscore && state->nMisbehavior - howmuch < banscore)\n-    {\n-        LogPrintf(\"%s: %s (%d -> %d) BAN THRESHOLD EXCEEDED\\n\", __func__, state->name, state->nMisbehavior-howmuch, state->nMisbehavior);\n-        state->fShouldBan = true;\n-    } else\n-        LogPrintf(\"%s: %s (%d -> %d)\\n\", __func__, state->name, state->nMisbehavior-howmuch, state->nMisbehavior);\n-}\n-\n void static InvalidChainFound(CBlockIndex* pindexNew)\n {\n     if (!pindexBestInvalid || pindexNew->nChainWork > pindexBestInvalid->nChainWork)\n@@ -1739,13 +1693,15 @@ void static InvalidChainFound(CBlockIndex* pindexNew)\n void static InvalidBlockFound(CBlockIndex *pindex, const CValidationState &state) {\n     int nDoS = 0;\n     if (state.IsInvalid(nDoS)) {\n-        std::map<uint256, NodeId>::iterator it = mapBlockSource.find(pindex->GetBlockHash());\n-        if (it != mapBlockSource.end() && State(it->second)) {\n+        auto it = mapBlockSource.find(pindex->GetBlockHash());\n+        if (it != mapBlockSource.end()) {\n             assert (state.GetRejectCode() < REJECT_INTERNAL); // Blocks are never rejected with internal reject codes\n-            CBlockReject reject = {(unsigned char)state.GetRejectCode(), state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), pindex->GetBlockHash()};\n-            State(it->second)->rejects.push_back(reject);\n-            if (nDoS > 0)\n-                Misbehaving(it->second, nDoS);\n+            if (auto pSender = it->second.lock()) {\n+                if (!Misbehavior::IsExcessive(pSender->Misbehaving(nDoS))) {\n+                    pSender->RejectBlock(pindex, (uint8_t)state.GetRejectCode(),\n+                        state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH));\n+                }\n+            }\n         }\n     }\n     if (!state.CorruptionPossible()) {\n@@ -3526,7 +3482,7 @@ static bool IsSuperMajority(int minVersion, const CBlockIndex* pstart, unsigned\n }\n \n \n-bool ProcessNewBlock(CValidationState& state, const CChainParams& chainparams, const CNode* pfrom, const CBlock* pblock, bool fForceProcessing, const CDiskBlockPos* dbp)\n+static bool ProcessNewBlock(CValidationState& state, const CChainParams& chainparams, const CBlock* pblock, std::shared_ptr<Peer>& ppeer, bool fForceProcessing, const CDiskBlockPos* dbp)\n {\n     {\n         LOCK(cs_main);\n@@ -3536,8 +3492,8 @@ bool ProcessNewBlock(CValidationState& state, const CChainParams& chainparams, c\n         // Store to disk\n         CBlockIndex *pindex = NULL;\n         bool ret = AcceptBlock(*pblock, state, chainparams, &pindex, fRequested, dbp);\n-        if (pindex && pfrom) {\n-            mapBlockSource[pindex->GetBlockHash()] = pfrom->GetId();\n+        if (pindex && ppeer) {\n+            mapBlockSource[pindex->GetBlockHash()] = ppeer;\n         }\n         CheckBlockIndex(chainparams.GetConsensus());\n         if (!ret)\n@@ -3551,6 +3507,11 @@ bool ProcessNewBlock(CValidationState& state, const CChainParams& chainparams, c\n \n     return true;\n }\n+bool ProcessNewBlock(CValidationState& state, const CChainParams& chainparams, const CBlock* pblock)\n+{\n+    std::shared_ptr<Peer> noSender{nullptr};\n+    return ProcessNewBlock(state, chainparams, pblock, noSender, true, nullptr);\n+}\n \n bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams, const CBlock& block, CBlockIndex* pindexPrev, bool fCheckPOW, bool fCheckMerkleRoot)\n {\n@@ -3973,14 +3934,12 @@ void UnloadBlockIndex()\n     mempool.clear();\n     mapOrphanTransactions.clear();\n     mapOrphanTransactionsByPrev.clear();\n-    nSyncStarted = 0;\n     mapBlocksUnlinked.clear();\n     vinfoBlockFile.clear();\n     nLastBlockFile = 0;\n     nBlockSequenceId = 1;\n     mapBlockSource.clear();\n     mapBlocksInFlight.clear();\n-    nPreferredDownload = 0;\n     setDirtyBlockIndex.clear();\n     setDirtyFileInfo.clear();\n     mapNodeState.clear();\n@@ -4009,6 +3968,8 @@ bool InitBlockIndex(const CChainParams& chainparams)\n {\n     LOCK(cs_main);\n \n+    Misbehavior::_SetBanscore(GetArg(\"-banscore\", DEFAULT_BANSCORE_THRESHOLD));\n+\n     // Initialize global variables that cannot be constructed at startup.\n     recentRejects.reset(new CRollingBloomFilter(120000, 0.000001));\n \n@@ -4432,7 +4393,7 @@ bool static AlreadyHave(const CInv& inv) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n     return true;\n }\n \n-void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParams)\n+void static ProcessGetData(std::shared_ptr<Peer>& ppeer, CNode* pfrom, const Consensus::Params& consensusParams)\n {\n     std::deque<CInv>::iterator it = pfrom->vRecvGetData.begin();\n \n@@ -4474,7 +4435,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                 // disconnect node in case we have reached the outbound limit for serving historical blocks\n                 // never disconnect whitelisted nodes\n                 static const int nOneWeek = 7 * 24 * 60 * 60; // assume > 1 week = historical\n-                if (send && CNode::OutboundTargetReached(true) && ( ((pindexBestHeader != NULL) && (pindexBestHeader->GetBlockTime() - mi->second->GetBlockTime() > nOneWeek)) || inv.type == MSG_FILTERED_BLOCK) && !pfrom->fWhitelisted)\n+                if (send && CNode::OutboundTargetReached(true) && ( ((pindexBestHeader != NULL) && (pindexBestHeader->GetBlockTime() - mi->second->GetBlockTime() > nOneWeek)) || inv.type == MSG_FILTERED_BLOCK) && ppeer->CanDisconnect())\n                 {\n                     LogPrint(\"net\", \"historical block serving limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n \n@@ -4570,7 +4531,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n     }\n }\n \n-bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams)\n+bool static ProcessMessage(std::shared_ptr<Peer>& ppeer, CNode* pfrom, string strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams)\n {\n     LogPrint(\"net\", \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->id);\n     if (mapArgs.count(\"-dropmessagestest\") && GetRand(atoi(mapArgs[\"-dropmessagestest\"])) == 0)\n@@ -4579,33 +4540,31 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         return true;\n     }\n \n-\n     if (!(nLocalServices & NODE_BLOOM) &&\n               (strCommand == NetMsgType::FILTERLOAD ||\n                strCommand == NetMsgType::FILTERADD ||\n                strCommand == NetMsgType::FILTERCLEAR))\n     {\n         if (pfrom->nVersion >= NO_BLOOM_VERSION) {\n-            LOCK(cs_main);\n-            Misbehaving(pfrom->GetId(), 100);\n+            ppeer->Misbehaving(100);\n             return false;\n         } else {\n             pfrom->fDisconnect = true;\n             return false;\n         }\n     }\n \n-\n+    const Peer::ConnectedInfo* pconnected = ppeer->GetConnectedInfo();\n     if (strCommand == NetMsgType::VERSION)\n     {\n         // Each connection can only send one version message\n-        if (pfrom->nVersion != 0)\n+        if (pconnected)\n         {\n             pfrom->PushMessage(NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, string(\"Duplicate version message\"));\n-            LOCK(cs_main);\n-            Misbehaving(pfrom->GetId(), 1);\n+            ppeer->Misbehaving(1);\n             return false;\n         }\n+        std::unique_ptr<Peer::ConnectedInfo> pconnectedNew{new Peer::ConnectedInfo{}};\n \n         int64_t nTime;\n         CAddress addrMe;\n@@ -4636,6 +4595,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             pfrom->fDisconnect = true;\n             return false;\n         }\n+        pconnectedNew->SetPingSupported(pfrom->nVersion > BIP0031_VERSION);\n \n         if (pfrom->nVersion == 10300)\n             pfrom->nVersion = 300;\n@@ -4648,13 +4608,10 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         if (!vRecv.empty()) {\n             vRecv >> pfrom->nStartingHeight;\n         }\n-        {\n-            LOCK(pfrom->cs_filter);\n-            if (!vRecv.empty())\n-                vRecv >> pfrom->fRelayTxes; // set to true after we get the first filter* message\n-            else\n-                pfrom->fRelayTxes = true;\n-        }\n+        bool fRelay = true;\n+        if (!vRecv.empty())\n+            vRecv >> fRelay; // set to true after we get the first filter* message\n+        ppeer->SetRelayTx(fRelay);\n \n         // Disconnect if we connected to ourself\n         if (nNonce == nLocalHostNonce && nNonce > 1)\n@@ -4674,13 +4631,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         if (pfrom->fInbound)\n             pfrom->PushVersion();\n \n-        pfrom->fClient = !(pfrom->nServices & NODE_NETWORK);\n-\n-        // Potentially mark this peer as a preferred download peer.\n-        {\n-        LOCK(cs_main);\n-        UpdatePreferredDownload(pfrom, State(pfrom->GetId()));\n-        }\n+        pconnectedNew->SetCanDownload(pfrom->nServices & NODE_NETWORK);\n \n         // Change version\n         pfrom->PushMessage(NetMsgType::VERACK);\n@@ -4719,6 +4670,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         }\n \n         pfrom->fSuccessfullyConnected = true;\n+        peermgr.SetConnected(*ppeer, std::move(pconnectedNew));\n \n         string remoteAddr;\n         if (fLogIPs)\n@@ -4735,11 +4687,10 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n-    else if (pfrom->nVersion == 0)\n+    else if (!pconnected)\n     {\n         // Must have a version message before anything else\n-        LOCK(cs_main);\n-        Misbehaving(pfrom->GetId(), 1);\n+        ppeer->Misbehaving(1);\n         return false;\n     }\n \n@@ -4750,8 +4701,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n         // Mark this node as currently connected, so we update its timestamp later.\n         if (pfrom->fNetworkNode) {\n-            LOCK(cs_main);\n-            State(pfrom->GetId())->fCurrentlyConnected = true;\n+            ppeer->SetHandshakeCompleted();\n         }\n \n         if (pfrom->nVersion >= SENDHEADERS_VERSION) {\n@@ -4774,8 +4724,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         if (vAddr.size() > 1000)\n         {\n-            LOCK(cs_main);\n-            Misbehaving(pfrom->GetId(), 20);\n+            ppeer->Misbehaving(20);\n             return error(\"message addr size() = %u\", vAddr.size());\n         }\n \n@@ -4831,8 +4780,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n     else if (strCommand == NetMsgType::SENDHEADERS)\n     {\n-        LOCK(cs_main);\n-        State(pfrom->GetId())->fPreferHeaders = true;\n+        ppeer->SetPrefersHeaders();\n     }\n \n \n@@ -4842,8 +4790,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         vRecv >> vInv;\n         if (vInv.size() > MAX_INV_SZ)\n         {\n-            LOCK(cs_main);\n-            Misbehaving(pfrom->GetId(), 20);\n+            ppeer->Misbehaving(20);\n             return error(\"message inv size() = %u\", vInv.size());\n         }\n \n@@ -4902,7 +4849,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             GetMainSignals().Inventory(inv.hash);\n \n             if (pfrom->nSendSize > (SendBufferSize() * 2)) {\n-                Misbehaving(pfrom->GetId(), 50);\n+                ppeer->Misbehaving(50);\n                 return error(\"send buffer size() = %u\", pfrom->nSendSize);\n             }\n         }\n@@ -4918,8 +4865,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         vRecv >> vInv;\n         if (vInv.size() > MAX_INV_SZ)\n         {\n-            LOCK(cs_main);\n-            Misbehaving(pfrom->GetId(), 20);\n+            ppeer->Misbehaving(20);\n             return error(\"message getdata size() = %u\", vInv.size());\n         }\n \n@@ -4930,7 +4876,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             LogPrint(\"net\", \"received getdata for: %s peer=%d\\n\", vInv[0].ToString(), pfrom->id);\n \n         pfrom->vRecvGetData.insert(pfrom->vRecvGetData.end(), vInv.begin(), vInv.end());\n-        ProcessGetData(pfrom, chainparams.GetConsensus());\n+        ProcessGetData(ppeer, pfrom, chainparams.GetConsensus());\n     }\n \n \n@@ -5059,7 +5005,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             vWorkQueue.push_back(inv.hash);\n \n             LogPrint(\"mempool\", \"AcceptToMemoryPool: peer=%d: accepted %s (poolsz %u txn, %u kB)\\n\",\n-                pfrom->id,\n+                ppeer->GetId(),\n                 tx.GetHash().ToString(),\n                 mempool.size(), mempool.DynamicMemoryUsage() / 1000);\n \n@@ -5098,7 +5044,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                         if (stateDummy.IsInvalid(nDos) && nDos > 0)\n                         {\n                             // Punish peer that gave us an invalid orphan tx\n-                            Misbehaving(fromPeer, nDos);\n+                            if (auto ppeer = peermgr.Get(fromPeer))\n+                                ppeer->Misbehaving(nDos);\n                             setMisbehaving.insert(fromPeer);\n                             LogPrint(\"mempool\", \"   invalid orphan tx %s\\n\", orphanHash.ToString());\n                         }\n@@ -5129,7 +5076,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             assert(recentRejects);\n             recentRejects->insert(tx.GetHash());\n \n-            if (pfrom->fWhitelisted && GetBoolArg(\"-whitelistforcerelay\", DEFAULT_WHITELISTFORCERELAY)) {\n+            if (ppeer->AlwaysRelayTx()) {\n                 // Always relay transactions received from whitelisted peers, even\n                 // if they were already in the mempool or rejected from it due\n                 // to policy, allowing the node to function as a gateway for\n@@ -5157,7 +5104,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 pfrom->PushMessage(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n                                    state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), inv.hash);\n             if (nDoS > 0)\n-                Misbehaving(pfrom->GetId(), nDoS);\n+                ppeer->Misbehaving(nDoS);\n         }\n         FlushStateToDisk(state, FLUSH_STATE_PERIODIC);\n     }\n@@ -5170,8 +5117,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         // Bypass the normal CBlock deserialization, as we don't want to risk deserializing 2000 full blocks.\n         unsigned int nCount = ReadCompactSize(vRecv);\n         if (nCount > MAX_HEADERS_RESULTS) {\n-            LOCK(cs_main);\n-            Misbehaving(pfrom->GetId(), 20);\n+            ppeer->Misbehaving(20);\n             return error(\"headers message size = %u\", nCount);\n         }\n         headers.resize(nCount);\n@@ -5199,14 +5145,14 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         BOOST_FOREACH(const CBlockHeader& header, headers) {\n             CValidationState state;\n             if (pindexLast != NULL && header.hashPrevBlock != pindexLast->GetBlockHash()) {\n-                Misbehaving(pfrom->GetId(), 20);\n+                ppeer->Misbehaving(20);\n                 return error(\"non-continuous headers sequence\");\n             }\n             if (!AcceptBlockHeader(header, state, chainparams, &pindexLast)) {\n                 int nDoS;\n                 if (state.IsInvalid(nDoS)) {\n                     if (nDoS > 0)\n-                        Misbehaving(pfrom->GetId(), nDoS);\n+                        ppeer->Misbehaving(nDoS);\n                     return error(\"invalid header received\");\n                 }\n             }\n@@ -5289,15 +5235,14 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         // Such an unrequested block may still be processed, subject to the\n         // conditions in AcceptBlock().\n         bool forceProcessing = pfrom->fWhitelisted && !IsInitialBlockDownload();\n-        ProcessNewBlock(state, chainparams, pfrom, &block, forceProcessing, NULL);\n+        ProcessNewBlock(state, chainparams, &block, ppeer, forceProcessing, NULL);\n         int nDoS;\n         if (state.IsInvalid(nDoS)) {\n             assert (state.GetRejectCode() < REJECT_INTERNAL); // Blocks are never rejected with internal reject codes\n             pfrom->PushMessage(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n                                state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), block.GetHash());\n             if (nDoS > 0) {\n-                LOCK(cs_main);\n-                Misbehaving(pfrom->GetId(), nDoS);\n+                ppeer->Misbehaving(nDoS);\n             }\n         }\n \n@@ -5333,14 +5278,14 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n     else if (strCommand == NetMsgType::MEMPOOL)\n     {\n-        if (!(nLocalServices & NODE_BLOOM) && !pfrom->fWhitelisted)\n+        if (!(nLocalServices & NODE_BLOOM) && ppeer->CanDisconnect())\n         {\n             LogPrint(\"net\", \"mempool request with bloom filters disabled, disconnect peer=%d\\n\", pfrom->GetId());\n             pfrom->fDisconnect = true;\n             return true;\n         }\n \n-        if (CNode::OutboundTargetReached(false) && !pfrom->fWhitelisted)\n+        if (CNode::OutboundTargetReached(false) && ppeer->CanDisconnect())\n         {\n             LogPrint(\"net\", \"mempool request with bandwidth limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n             pfrom->fDisconnect = true;\n@@ -5354,7 +5299,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n     else if (strCommand == NetMsgType::PING)\n     {\n-        if (pfrom->nVersion > BIP0031_VERSION)\n+        if (pconnected->IsPingSupported())\n         {\n             uint64_t nonce = 0;\n             vRecv >> nonce;\n@@ -5419,7 +5364,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n         if (!(sProblem.empty())) {\n             LogPrint(\"net\", \"pong peer=%d: %s, %x expected, %x received, %u bytes\\n\",\n-                pfrom->id,\n+                ppeer->GetId(),\n                 sProblem,\n                 pfrom->nPingNonceSent,\n                 nonce,\n@@ -5441,16 +5386,15 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         if (!filter.IsWithinSizeConstraints())\n         {\n             // There is no excuse for sending a too-large filter\n-            LOCK(cs_main);\n-            Misbehaving(pfrom->GetId(), 100);\n+            ppeer->Misbehaving(100);\n         }\n         else\n         {\n             delete pfrom->pfilter;\n             pfrom->pfilter = new CBloomFilter(filter);\n             pfrom->pfilter->UpdateEmptyFull();\n         }\n-        pfrom->fRelayTxes = true;\n+        ppeer->SetRelayTx(true);\n     }\n \n \n@@ -5463,16 +5407,14 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         // and thus, the maximum size any matched object can have) in a filteradd message\n         if (vData.size() > MAX_SCRIPT_ELEMENT_SIZE)\n         {\n-            LOCK(cs_main);\n-            Misbehaving(pfrom->GetId(), 100);\n+            ppeer->Misbehaving(100);\n         } else {\n             LOCK(pfrom->cs_filter);\n             if (pfrom->pfilter)\n                 pfrom->pfilter->insert(vData);\n             else\n             {\n-                LOCK(cs_main);\n-                Misbehaving(pfrom->GetId(), 100);\n+                ppeer->Misbehaving(100);\n             }\n         }\n     }\n@@ -5483,7 +5425,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         LOCK(pfrom->cs_filter);\n         delete pfrom->pfilter;\n         pfrom->pfilter = new CBloomFilter();\n-        pfrom->fRelayTxes = true;\n+        ppeer->SetRelayTx(true);\n     }\n \n \n@@ -5515,10 +5457,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         CAmount newFeeFilter = 0;\n         vRecv >> newFeeFilter;\n         if (MoneyRange(newFeeFilter)) {\n-            {\n-                LOCK(pfrom->cs_feeFilter);\n-                pfrom->minFeeFilter = newFeeFilter;\n-            }\n+            ppeer->SetMinFeeFilter(newFeeFilter);\n             LogPrint(\"net\", \"received: feefilter of %s from peer=%d\\n\", CFeeRate(newFeeFilter).ToString(), pfrom->id);\n         }\n     }\n@@ -5550,8 +5489,11 @@ bool ProcessMessages(CNode* pfrom)\n     //\n     bool fOk = true;\n \n+    std::shared_ptr<Peer> ppeer = peermgr.Get(pfrom->GetId());\n+    assert(ppeer);\n+\n     if (!pfrom->vRecvGetData.empty())\n-        ProcessGetData(pfrom, chainparams.GetConsensus());\n+        ProcessGetData(ppeer, pfrom, chainparams.GetConsensus());\n \n     // this maintains the order of responses\n     if (!pfrom->vRecvGetData.empty()) return fOk;\n@@ -5611,7 +5553,7 @@ bool ProcessMessages(CNode* pfrom)\n         bool fRet = false;\n         try\n         {\n-            fRet = ProcessMessage(pfrom, strCommand, vRecv, msg.nTime, chainparams);\n+            fRet = ProcessMessage(ppeer, pfrom, strCommand, vRecv, msg.nTime, chainparams);\n             boost::this_thread::interruption_point();\n         }\n         catch (const std::ios_base::failure& e)\n@@ -5678,10 +5620,27 @@ class CompareInvMempoolOrder\n \n bool SendMessages(CNode* pto)\n {\n+    std::shared_ptr<Peer> ppeer = peermgr.Get(pto->GetId());\n+    assert(ppeer);\n     const Consensus::Params& consensusParams = Params().GetConsensus();\n     {\n+        // Check for bad peer\n+        if (ppeer->ExceededMisbehaviorThreshold()) {\n+            if (ppeer->CanDisconnect()) {\n+                pto->fDisconnect = true;\n+                if (ppeer->CanBan()) {\n+                    CNode::Ban(pto->addr, BanReasonNodeMisbehaving);\n+                } else {\n+                    LogPrintf(\"Warning: not banning local peer %s!\\n\", pto->addr.ToString());\n+                }\n+            } else {\n+                LogPrintf(\"Warning: not punishing whitelisted peer %s!\\n\", pto->addr.ToString());\n+            }\n+        }\n+\n         // Don't send anything until we get its version message\n-        if (pto->nVersion == 0)\n+        const Peer::ConnectedInfo* pconnected = ppeer->GetConnectedInfo();\n+        if (!pconnected)\n             return true;\n \n         //\n@@ -5713,6 +5672,11 @@ bool SendMessages(CNode* pto)\n             }\n         }\n \n+        for (const auto& reject: ppeer->GetBlockRejections()) {\n+            pto->PushMessage(NetMsgType::REJECT, std::string{NetMsgType::BLOCK},\n+                reject.chRejectCode, reject.strRejectReason, reject.pindex->GetBlockHash());\n+        }\n+\n         TRY_LOCK(cs_main, lockMain); // Acquire cs_main for IsInitialBlockDownload() and CNodeState()\n         if (!lockMain)\n             return true;\n@@ -5754,34 +5718,15 @@ bool SendMessages(CNode* pto)\n         }\n \n         CNodeState &state = *State(pto->GetId());\n-        if (state.fShouldBan) {\n-            if (pto->fWhitelisted)\n-                LogPrintf(\"Warning: not punishing whitelisted peer %s!\\n\", pto->addr.ToString());\n-            else {\n-                pto->fDisconnect = true;\n-                if (pto->addr.IsLocal())\n-                    LogPrintf(\"Warning: not banning local peer %s!\\n\", pto->addr.ToString());\n-                else\n-                {\n-                    CNode::Ban(pto->addr, BanReasonNodeMisbehaving);\n-                }\n-            }\n-            state.fShouldBan = false;\n-        }\n-\n-        BOOST_FOREACH(const CBlockReject& reject, state.rejects)\n-            pto->PushMessage(NetMsgType::REJECT, (string)NetMsgType::BLOCK, reject.chRejectCode, reject.strRejectReason, reject.hashBlock);\n-        state.rejects.clear();\n \n         // Start block sync\n         if (pindexBestHeader == NULL)\n             pindexBestHeader = chainActive.Tip();\n-        bool fFetch = state.fPreferredDownload || (nPreferredDownload == 0 && !pto->fClient && !pto->fOneShot); // Download if this is a nice peer, or we have no nice peers and this one might do.\n-        if (!state.fSyncStarted && !pto->fClient && !fImporting && !fReindex) {\n+        bool fFetch = peermgr.IsPreferred(*ppeer);\n+        if (!fImporting && !fReindex && pconnected->CanDownload() && !ppeer->IsSyncStarted()) {\n             // Only actively request headers from a single peer, unless we're close to today.\n-            if ((nSyncStarted == 0 && fFetch) || pindexBestHeader->GetBlockTime() > GetAdjustedTime() - 24 * 60 * 60) {\n-                state.fSyncStarted = true;\n-                nSyncStarted++;\n+            bool fClose = pindexBestHeader->GetBlockTime() > GetAdjustedTime() - 24 * 60 * 60;\n+            if ((fFetch && headersync.StartFirst(*ppeer)) || (fClose && headersync.Start(*ppeer))) {\n                 const CBlockIndex *pindexStart = pindexBestHeader;\n                 /* If possible, start at the block preceding the currently\n                    best known header.  This ensures that we always get a\n@@ -5818,7 +5763,7 @@ bool SendMessages(CNode* pto)\n             // add all to the inv queue.\n             LOCK(pto->cs_inventory);\n             vector<CBlock> vHeaders;\n-            bool fRevertToInv = (!state.fPreferHeaders || pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n+            bool fRevertToInv = (!ppeer->PrefersHeaders() || pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n             CBlockIndex *pBestIndex = NULL; // last header queued for delivery\n             ProcessBlockAvailability(pto->id); // ensure pindexBestKnownBlock is up-to-date\n \n@@ -5938,20 +5883,15 @@ bool SendMessages(CNode* pto)\n             }\n \n             // Time to send but the peer has requested we not relay transactions.\n-            if (fSendTrickle) {\n-                LOCK(pto->cs_filter);\n-                if (!pto->fRelayTxes) pto->setInventoryTxToSend.clear();\n+            if (fSendTrickle && !ppeer->CanRelayTx()) {\n+                pto->setInventoryTxToSend.clear();\n             }\n \n             // Respond to BIP35 mempool requests\n             if (fSendTrickle && pto->fSendMempool) {\n                 auto vtxinfo = mempool.infoAll();\n                 pto->fSendMempool = false;\n-                CAmount filterrate = 0;\n-                {\n-                    LOCK(pto->cs_feeFilter);\n-                    filterrate = pto->minFeeFilter;\n-                }\n+                CAmount filterrate = ppeer->GetMinFeeFilter();\n \n                 LOCK(pto->cs_filter);\n \n@@ -5984,11 +5924,7 @@ bool SendMessages(CNode* pto)\n                 for (std::set<uint256>::iterator it = pto->setInventoryTxToSend.begin(); it != pto->setInventoryTxToSend.end(); it++) {\n                     vInvTx.push_back(it);\n                 }\n-                CAmount filterrate = 0;\n-                {\n-                    LOCK(pto->cs_feeFilter);\n-                    filterrate = pto->minFeeFilter;\n-                }\n+                CAmount filterrate = ppeer->GetMinFeeFilter();\n                 // Topologically and fee-rate sort the inventory we send for privacy and priority reasons.\n                 // A heap is used so that not all items need sorting if only a few are being sent.\n                 CompareInvMempoolOrder compareInvMempoolOrder(&mempool);\n@@ -6072,7 +6008,7 @@ bool SendMessages(CNode* pto)\n         // Message: getdata (blocks)\n         //\n         vector<CInv> vGetData;\n-        if (!pto->fDisconnect && !pto->fClient && (fFetch || !IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+        if (!pto->fDisconnect && pconnected->CanDownload() && (fFetch || !IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n             vector<CBlockIndex*> vToDownload;\n             NodeId staller = -1;\n             FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller);"
      },
      {
        "sha": "347d776728974a3c129f4382a0fb22f0b786421c",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 2,
        "deletions": 6,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f5734abe519f0d2f029f9db84ac5815b3ce56ce/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f5734abe519f0d2f029f9db84ac5815b3ce56ce/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=8f5734abe519f0d2f029f9db84ac5815b3ce56ce",
        "patch": "@@ -209,13 +209,10 @@ void UnregisterNodeSignals(CNodeSignals& nodeSignals);\n  * specific block passed to it has been checked for validity!\n  * \n  * @param[out]  state   This may be set to an Error state if any error occurred processing it, including during validation/connection/etc of otherwise unrelated blocks during reorganisation; or it may be set to an Invalid state if pblock is itself invalid (but this is not guaranteed even when the block is checked). If you want to *possibly* get feedback on whether pblock is valid, you must also install a CValidationInterface (see validationinterface.h) - this will have its BlockChecked method called whenever *any* block completes validation.\n- * @param[in]   pfrom   The node which we are receiving the block from; it is added to mapBlockSource and may be penalised if the block is invalid.\n  * @param[in]   pblock  The block we want to process.\n- * @param[in]   fForceProcessing Process this block even if unrequested; used for non-network block sources and whitelisted peers.\n- * @param[out]  dbp     The already known disk position of pblock, or NULL if not yet stored.\n  * @return True if state.IsValid()\n  */\n-bool ProcessNewBlock(CValidationState& state, const CChainParams& chainparams, const CNode* pfrom, const CBlock* pblock, bool fForceProcessing, const CDiskBlockPos* dbp);\n+bool ProcessNewBlock(CValidationState& state, const CChainParams& chainparams, const CBlock* pblock);\n /** Check whether enough disk space is available for an incoming block */\n bool CheckDiskSpace(uint64_t nAdditionalBytes = 0);\n /** Open a block file (blk?????.dat) */\n@@ -286,8 +283,6 @@ void UnlinkPrunedFiles(std::set<int>& setFilesToPrune);\n CBlockIndex * InsertBlockIndex(uint256 hash);\n /** Get statistics from node state */\n bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats);\n-/** Increase a node's misbehavior score. */\n-void Misbehaving(NodeId nodeid, int howmuch);\n /** Flush all state, indexes and buffers to disk. */\n void FlushStateToDisk();\n /** Prune block files and flush state to disk. */\n@@ -305,6 +300,7 @@ ThresholdState VersionBitsTipState(const Consensus::Params& params, Consensus::D\n \n struct CNodeStateStats {\n     int nMisbehavior;\n+    bool fRelayTxes;\n     int nSyncHeight;\n     int nCommonHeight;\n     std::vector<int> vHeightInFlight;"
      },
      {
        "sha": "0b6f4f6e6af9b88d9796b7f45252d2704af6b315",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 16,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f5734abe519f0d2f029f9db84ac5815b3ce56ce/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f5734abe519f0d2f029f9db84ac5815b3ce56ce/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=8f5734abe519f0d2f029f9db84ac5815b3ce56ce",
        "patch": "@@ -368,7 +368,7 @@ CNode* FindNode(const CService& addr)\n     return NULL;\n }\n \n-CNode* ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure)\n+CNode* ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, bool fOneShot)\n {\n     if (pszDest == NULL) {\n         if (IsLocal(addrConnect))\n@@ -403,7 +403,7 @@ CNode* ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure\n         addrman.Attempt(addrConnect, fCountFailure);\n \n         // Add node\n-        CNode* pnode = new CNode(hSocket, addrConnect, pszDest ? pszDest : \"\", false);\n+        CNode* pnode = new CNode(hSocket, addrConnect, pszDest ? pszDest : \"\", false, fOneShot);\n         pnode->AddRef();\n \n         {\n@@ -650,7 +650,6 @@ void CNode::copyStats(CNodeStats &stats)\n {\n     stats.nodeid = this->GetId();\n     X(nServices);\n-    X(fRelayTxes);\n     X(nLastSend);\n     X(nLastRecv);\n     X(nTimeConnected);\n@@ -1010,9 +1009,8 @@ static void AcceptConnection(const ListenSocket& hListenSocket) {\n         }\n     }\n \n-    CNode* pnode = new CNode(hSocket, addr, \"\", true);\n+    CNode* pnode = new CNode(hSocket, addr, \"\", true, whitelisted);\n     pnode->AddRef();\n-    pnode->fWhitelisted = whitelisted;\n \n     LogPrint(\"net\", \"connection from %s accepted\\n\", addr.ToString());\n \n@@ -1697,16 +1695,14 @@ bool OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSem\n     } else if (FindNode(std::string(pszDest)))\n         return false;\n \n-    CNode* pnode = ConnectNode(addrConnect, pszDest, fCountFailure);\n+    CNode* pnode = ConnectNode(addrConnect, pszDest, fCountFailure, fOneShot);\n     boost::this_thread::interruption_point();\n \n     if (!pnode)\n         return false;\n     if (grantOutbound)\n         grantOutbound->MoveTo(pnode->grantOutbound);\n     pnode->fNetworkNode = true;\n-    if (fOneShot)\n-        pnode->fOneShot = true;\n \n     return true;\n }\n@@ -2326,12 +2322,14 @@ bool CAddrDB::Read(CAddrMan& addr, CDataStream& ssPeers)\n unsigned int ReceiveFloodSize() { return 1000*GetArg(\"-maxreceivebuffer\", DEFAULT_MAXRECEIVEBUFFER); }\n unsigned int SendBufferSize() { return 1000*GetArg(\"-maxsendbuffer\", DEFAULT_MAXSENDBUFFER); }\n \n-CNode::CNode(SOCKET hSocketIn, const CAddress& addrIn, const std::string& addrNameIn, bool fInboundIn) :\n+CNode::CNode(SOCKET hSocketIn, const CAddress& addrIn, const std::string& addrNameIn, bool fInboundIn, bool fWhitelistedIn, bool fOneShotIn) :\n     ssSend(SER_NETWORK, INIT_PROTO_VERSION),\n     addr(addrIn),\n     nKeyedNetGroup(CalculateKeyedNetGroup(addrIn)),\n     addrKnown(5000, 0.001),\n-    filterInventoryKnown(50000, 0.000001)\n+    filterInventoryKnown(50000, 0.000001),\n+    fWhitelisted(fWhitelistedIn),\n+    fOneShot(fOneShotIn)\n {\n     nServices = NODE_NONE;\n     nServicesExpected = NODE_NONE;\n@@ -2346,9 +2344,6 @@ CNode::CNode(SOCKET hSocketIn, const CAddress& addrIn, const std::string& addrNa\n     addrName = addrNameIn == \"\" ? addr.ToStringIPPort() : addrNameIn;\n     nVersion = 0;\n     strSubVer = \"\";\n-    fWhitelisted = false;\n-    fOneShot = false;\n-    fClient = false; // set by version message\n     fInbound = fInboundIn;\n     fNetworkNode = false;\n     fSuccessfullyConnected = false;\n@@ -2364,7 +2359,6 @@ CNode::CNode(SOCKET hSocketIn, const CAddress& addrIn, const std::string& addrNa\n     nNextLocalAddrSend = 0;\n     nNextAddrSend = 0;\n     nNextInvSend = 0;\n-    fRelayTxes = false;\n     fSentAddr = false;\n     pfilter = new CBloomFilter();\n     timeLastMempoolReq = 0;\n@@ -2373,7 +2367,6 @@ CNode::CNode(SOCKET hSocketIn, const CAddress& addrIn, const std::string& addrNa\n     nPingUsecTime = 0;\n     fPingQueued = false;\n     nMinPingUsecTime = std::numeric_limits<int64_t>::max();\n-    minFeeFilter = 0;\n     lastSentFeeFilter = 0;\n     nextSendTimeFeeFilter = 0;\n \n@@ -2405,7 +2398,8 @@ CNode::~CNode()\n     if (pfilter)\n         delete pfilter;\n \n-    GetNodeSignals().FinalizeNode(GetId());\n+    if (GetNodeSignals().FinalizeNode(GetId()))\n+        AddressCurrentlyConnected(addr);\n }\n \n void CNode::AskFor(const CInv& inv)"
      },
      {
        "sha": "de58d9f8ddfe7e8720f82a9caf91b099ecf9730f",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 4,
        "deletions": 14,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f5734abe519f0d2f029f9db84ac5815b3ce56ce/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f5734abe519f0d2f029f9db84ac5815b3ce56ce/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=8f5734abe519f0d2f029f9db84ac5815b3ce56ce",
        "patch": "@@ -118,7 +118,7 @@ struct CNodeSignals\n     boost::signals2::signal<bool (CNode*), CombinerAll> ProcessMessages;\n     boost::signals2::signal<bool (CNode*), CombinerAll> SendMessages;\n     boost::signals2::signal<void (NodeId, const CNode*)> InitializeNode;\n-    boost::signals2::signal<void (NodeId)> FinalizeNode;\n+    boost::signals2::signal<bool (NodeId)> FinalizeNode;\n };\n \n \n@@ -189,7 +189,6 @@ class CNodeStats\n public:\n     NodeId nodeid;\n     ServiceFlags nServices;\n-    bool fRelayTxes;\n     int64_t nLastSend;\n     int64_t nLastRecv;\n     int64_t nTimeConnected;\n@@ -347,18 +346,12 @@ class CNode\n     // store the sanitized version in cleanSubVer. The original should be used when dealing with\n     // the network or wire types and the cleaned string used when displayed or logged.\n     std::string strSubVer, cleanSubVer;\n-    bool fWhitelisted; // This peer can bypass DoS banning.\n-    bool fOneShot;\n-    bool fClient;\n+    const bool fWhitelisted; // This peer can bypass DoS banning.\n+    const bool fOneShot;\n     bool fInbound;\n     bool fNetworkNode;\n     bool fSuccessfullyConnected;\n     bool fDisconnect;\n-    // We use fRelayTxes for two purposes -\n-    // a) it allows us to not relay tx invs before receiving the peer's version message\n-    // b) the peer may tell us in its version message that we should not relay tx invs\n-    //    unless it loads a bloom filter.\n-    bool fRelayTxes; //protected by cs_filter\n     bool fSentAddr;\n     CSemaphoreGrant grantOutbound;\n     CCriticalSection cs_filter;\n@@ -430,13 +423,10 @@ class CNode\n     int64_t nMinPingUsecTime;\n     // Whether a ping is requested.\n     bool fPingQueued;\n-    // Minimum fee rate with which to filter inv's to this node\n-    CAmount minFeeFilter;\n-    CCriticalSection cs_feeFilter;\n     CAmount lastSentFeeFilter;\n     int64_t nextSendTimeFeeFilter;\n \n-    CNode(SOCKET hSocketIn, const CAddress &addrIn, const std::string &addrNameIn = \"\", bool fInboundIn = false);\n+    CNode(SOCKET hSocketIn, const CAddress &addrIn, const std::string &addrNameIn = \"\", bool fInboundIn = false, bool fWhitelistedIn = false, bool fOneShotIn = false);\n     ~CNode();\n \n private:"
      },
      {
        "sha": "d0ad93256d99a9fe4fc549464e4efbb019e06e04",
        "filename": "src/peer.cpp",
        "status": "added",
        "additions": 49,
        "deletions": 0,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f5734abe519f0d2f029f9db84ac5815b3ce56ce/src/peer.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f5734abe519f0d2f029f9db84ac5815b3ce56ce/src/peer.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/peer.cpp?ref=8f5734abe519f0d2f029f9db84ac5815b3ce56ce",
        "patch": "@@ -0,0 +1,49 @@\n+#include \"peer.h\"\n+\n+int Misbehavior::PeerInfo::Misbehaving(int delta) {\n+    int badnessBefore = badness.fetch_add(delta, std::memory_order_relaxed);\n+    int badnessAfter = badnessBefore + delta;\n+    GetSignals().OnMisbehavior(static_cast<const Peer&>(*this), badnessBefore, badnessAfter);\n+    if (IsExcessive(badnessAfter) && !IsExcessive(badnessBefore))\n+        fExceeded.store(true, std::memory_order_release);\n+    return badnessAfter;\n+}\n+\n+void PeerManager::Register(NodeId id, std::shared_ptr<Peer>&& peer) {\n+    lock_guard guard{csById};\n+    auto ret = _byId.emplace(std::piecewise_construct,\n+                            std::forward_as_tuple(id),\n+                            std::forward_as_tuple(peer));\n+    assert(ret.second);\n+}\n+\n+void PeerManager::Unregister(NodeId id) {\n+    lock_guard guard{csById};\n+    auto it = _byId.find(id);\n+    assert(it != _byId.end());\n+    {\n+        std::shared_ptr<Peer> ppeer = it->second;\n+        const Peer::ConnectedInfo* pconnected = ppeer->GetConnectedInfo();\n+        if (pconnected && pconnected->CanDownload() && ppeer->GetPreferredness() == DownloadPreferredness::ABOVE_NORMAL)\n+            nPreferredDownload.fetch_sub(1, std::memory_order_relaxed);\n+    }\n+    _byId.erase(it);\n+}\n+\n+std::shared_ptr<Peer> PeerManager::Get(NodeId id) {\n+    lock_guard guard{csById};\n+    auto it = _byId.find(id);\n+    if (it == _byId.end())\n+        return { nullptr };\n+    else\n+        return it->second;\n+}\n+\n+bool PeerManager::IsPreferred(Peer& peer) const {\n+    switch (peer.GetPreferredness()) {\n+    case DownloadPreferredness::ABOVE_NORMAL: return true;\n+    case DownloadPreferredness::BELOW_NORMAL: return false;\n+    case DownloadPreferredness::NORMAL: return nPreferredDownload.load(std::memory_order_relaxed) == 0;\n+    default: assert(!\"unreachable!\");\n+    }\n+}"
      },
      {
        "sha": "ded64a6d174581b22a1ff13caaf247823ed4ee0f",
        "filename": "src/peer.h",
        "status": "added",
        "additions": 292,
        "deletions": 0,
        "changes": 292,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f5734abe519f0d2f029f9db84ac5815b3ce56ce/src/peer.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f5734abe519f0d2f029f9db84ac5815b3ce56ce/src/peer.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/peer.h?ref=8f5734abe519f0d2f029f9db84ac5815b3ce56ce",
        "patch": "@@ -0,0 +1,292 @@\n+#ifndef BITCOIN_PEER_H\n+#define BITCOIN_PEER_H\n+\n+#include <boost/signals2/signal.hpp>\n+\n+#include <atomic>\n+#include <list>\n+#include <map>\n+#include <mutex>\n+#include <string>\n+\n+class CBlockIndex;\n+typedef int NodeId;\n+typedef int64_t CAmount;\n+\n+class Peer;\n+\n+namespace BlockAccountability {\n+    namespace {\n+        std::mutex csBlockRejects;\n+    }\n+    struct CBlockReject {\n+        const CBlockIndex* pindex;\n+        uint8_t chRejectCode;\n+        std::string strRejectReason;\n+        inline CBlockReject(const CBlockIndex* pindexIn, uint8_t chRejectCodeIn, std::string&& strRejectReasonIn)\n+            : pindex(pindexIn), chRejectCode(chRejectCodeIn), strRejectReason(std::move(strRejectReasonIn)) {}\n+    };\n+    class PeerInfo {\n+        typedef std::lock_guard<std::mutex> lock_guard;\n+    public:\n+        struct Params {};\n+        inline PeerInfo(const Params& in) : fHaveRejects(false), _vRejects() {}\n+        inline std::list<CBlockReject> GetBlockRejections() {\n+            std::list<CBlockReject> ret;\n+            if (fHaveRejects.load(std::memory_order_relaxed)) {\n+                lock_guard guard{csBlockRejects};\n+                ret.swap(_vRejects);\n+                fHaveRejects.store(false, std::memory_order_relaxed);\n+            }\n+            return ret;\n+        }\n+        template <class... Args> void RejectBlock(Args&&... args) {\n+            lock_guard guard{csBlockRejects};\n+            _vRejects.emplace_back(std::forward<Args>(args)...);\n+            fHaveRejects.store(true, std::memory_order_relaxed);\n+        }\n+    private:\n+        // flag to skip the mutex for the common case\n+        std::atomic<bool> fHaveRejects;\n+        std::list<CBlockReject> _vRejects;\n+    };\n+} // namespace BlockAccountability\n+\n+namespace Misbehavior {\n+    namespace {\n+        int _banscore = 0;\n+    }\n+    // only set during initial setup\n+    inline void _SetBanscore(int score) { _banscore = score; }\n+    inline int GetBanscore() { return _banscore; }\n+    inline bool IsExcessive(int score) { return score >= GetBanscore(); }\n+\n+    /// Hook for logging etc. when a peer misbehaves.\n+    struct Signals {\n+        boost::signals2::signal<void(const Peer&, int, int)> OnMisbehavior;\n+    };\n+    inline Signals& GetSignals() { static Signals s{}; return s; }\n+\n+    struct PeerInfo {\n+        struct Params {\n+            inline Params() : fNoBan(false), fNoDisconnect(false) {}\n+            bool fNoBan;\n+            bool fNoDisconnect;\n+        };\n+        inline PeerInfo(const Params& in)\n+            : noDisconnect(in.fNoDisconnect)\n+            , noBan(in.fNoBan)\n+            , badness(0)\n+            , fExceeded(false)\n+        {}\n+\n+        inline int GetMisbehavior() const { return badness.load(std::memory_order_relaxed); }\n+        int Misbehaving(int delta);\n+\n+        /// If a call to Misbehaving causes a peer's misbehavior to exceed GetBanscore(),\n+        /// this function will return true exactly once. Otherwise returns false.\n+        inline bool ExceededMisbehaviorThreshold() {\n+            // Quick check for the usual case.\n+            if (!fExceeded.load(std::memory_order_relaxed))\n+                return false;\n+            // Reread in case multiple concurrent callers.\n+            // Release-acquire sync with Misbehaving() so if we return true,\n+            // subsequent GetMisbehavior() will return at least GetBanscore().\n+            return fExceeded.exchange(false, std::memory_order_acquire);\n+        }\n+\n+        inline bool CanDisconnect() const { return !noDisconnect; }\n+        inline bool CanBan() const { return !noBan; }\n+    private:\n+        const bool noDisconnect;\n+        const bool noBan;\n+        std::atomic<int> badness;\n+        std::atomic<bool> fExceeded;\n+    };\n+} // namespace Misbehavior\n+\n+struct HeaderSync {\n+    struct PeerInfo {\n+        friend class HeaderSync;\n+        struct Params {};\n+        inline PeerInfo(const Params& in)\n+            : fPreferHeaders(false)\n+            , fSyncStarted(false)\n+        {}\n+\n+        inline bool PrefersHeaders() const { return fPreferHeaders.load(std::memory_order_relaxed); }\n+        inline void SetPrefersHeaders() { fPreferHeaders.store(true, std::memory_order_relaxed); }\n+        inline bool IsSyncStarted() const { return fSyncStarted.load(std::memory_order_relaxed); }\n+    private:\n+        // sets fSyncStarted to true exactly once\n+        // returns whether successfully changed\n+        inline bool SetStarted() { return fSyncStarted.exchange(true, std::memory_order_relaxed); }\n+\n+        //! Whether the peer prefers headers to block invs\n+        std::atomic<bool> fPreferHeaders;\n+        //! Whether we've started headers synchronization with this peer.\n+        std::atomic<bool> fSyncStarted;\n+    };\n+    inline HeaderSync() : fHaveSyncStarted(false) {}\n+    /// Sets sync started, unless sync is already started.\n+    /// Returns whether SyncStarted has been changed.\n+    inline bool Start(PeerInfo& peer) {\n+        // unconditional store - SetStarted only fails when the peer is already started\n+        fHaveSyncStarted.store(true, std::memory_order_relaxed);\n+        return peer.SetStarted();\n+    }\n+    /// Sets sync started, if no peers are already syncing.\n+    /// Returns whether the peer has been set to started.\n+    inline bool StartFirst(PeerInfo& peer) {\n+        // quick check for the common case\n+        if (fHaveSyncStarted.load(std::memory_order_relaxed) == true)\n+            return false;\n+        // if concurrent StartFirsts, only 1 may pass\n+        if (fHaveSyncStarted.exchange(true, std::memory_order_relaxed) == true)\n+            return false;\n+        // will succeed unless concurrent unconditional Start for the same peer\n+        return peer.SetStarted();\n+    }\n+private:\n+    std::atomic<bool> fHaveSyncStarted;\n+};\n+\n+namespace TxRelay {\n+    struct PeerInfo {\n+        struct Params {\n+            inline Params() : fAlwaysRelayTx(false) {}\n+            bool fAlwaysRelayTx;\n+        };\n+        inline PeerInfo(const Params& in) : fRelayTx(false), amtMinFeeFilter(0), fAlwaysRelayTx(in.fAlwaysRelayTx) {}\n+\n+        inline void SetRelayTx(bool value) { fRelayTx.store(value, std::memory_order_relaxed); }\n+        inline bool CanRelayTx() { return fRelayTx.load(std::memory_order_relaxed); }\n+\n+        inline bool AlwaysRelayTx() { return fAlwaysRelayTx; }\n+\n+        inline void SetMinFeeFilter(CAmount value) { return amtMinFeeFilter.store(value, std::memory_order_relaxed); }\n+        inline CAmount GetMinFeeFilter() const { return amtMinFeeFilter.load(std::memory_order_relaxed); }\n+    private:\n+        std::atomic<bool> fRelayTx;\n+        std::atomic<CAmount> amtMinFeeFilter;\n+        const bool fAlwaysRelayTx;\n+    };\n+} // namespace TxRelay\n+\n+enum class DownloadPreferredness { BELOW_NORMAL, NORMAL, ABOVE_NORMAL };\n+\n+/// Peer holds high-level information about a peer.\n+class Peer\n+    : public BlockAccountability::PeerInfo\n+    , public Misbehavior::PeerInfo\n+    , public HeaderSync::PeerInfo\n+    , public TxRelay::PeerInfo\n+{\n+    friend class PeerManager;\n+public:\n+    struct Params\n+        : public BlockAccountability::PeerInfo::Params\n+        , public Misbehavior::PeerInfo::Params\n+        , public HeaderSync::PeerInfo::Params\n+        , public TxRelay::PeerInfo::Params\n+    {\n+        friend class Peer;\n+        inline Params(NodeId idIn, const std::string& strNameIn)\n+            : preferedness(DownloadPreferredness::NORMAL)\n+            , id(idIn)\n+            , strName(strNameIn)\n+        {}\n+        DownloadPreferredness preferedness;\n+    private:\n+        const NodeId id;\n+        std::string strName;\n+    };\n+\n+    // Applicable to a peer that has finished connecting (by sending its version\n+    // message, though the handshake may not yet have been completed with a verack).\n+    struct ConnectedInfo {\n+        inline ConnectedInfo() : fEnableDownload(false), fPingSupported(false) {}\n+\n+        inline bool CanDownload() const { return fEnableDownload; }\n+        inline bool IsPingSupported() const { return fPingSupported; }\n+\n+        inline void SetCanDownload(bool value) { fEnableDownload = value; }\n+        inline void SetPingSupported(bool value) { fPingSupported = value; }\n+    private:\n+        // These properties can only be written before giving the ConnectedInfo\n+        // to SetConnected; once they're accessible through GetConnectedInfo,\n+        // only read access is allowed.\n+        bool fEnableDownload;\n+        bool fPingSupported;\n+    };\n+\n+    inline Peer(Params&& in)\n+        : BlockAccountability::PeerInfo(in)\n+        , Misbehavior::PeerInfo(in)\n+        , HeaderSync::PeerInfo(in)\n+        , TxRelay::PeerInfo(in)\n+        , id(in.id)\n+        , strName(std::move(in.strName))\n+        , preferedness(in.preferedness)\n+        , pconnected(nullptr)\n+    {}\n+    inline ~Peer() { delete pconnected.load(std::memory_order_consume); }\n+\n+    inline NodeId GetId() const { return id; }\n+    inline const std::string& GetName() const { return strName; }\n+    inline bool operator!=(const Peer& other) const { return GetId() != other.GetId(); }\n+    inline bool operator==(const Peer& other) const { return GetId() == other.GetId(); }\n+\n+    inline void SetHandshakeCompleted() { fHandshook.store(true, std::memory_order_relaxed); }\n+    inline bool IsHandshakeCompleted() { return fHandshook.load(std::memory_order_relaxed); }\n+\n+    [[carries_dependency]] inline const ConnectedInfo* GetConnectedInfo() const {\n+        // Release-consume because consumer must not observe pointer value that\n+        // is more recent than the value written to it.\n+        return pconnected.load(std::memory_order_consume);\n+    }\n+private:\n+    inline void SetConnectedInfo(std::unique_ptr<ConnectedInfo>&& pnew) {\n+        return pconnected.store(pnew.release(), std::memory_order_release);\n+    }\n+\n+    inline DownloadPreferredness GetPreferredness() const { return preferedness; }\n+\n+    const NodeId id;\n+    const std::string strName;\n+    //! Whether we have a fully-established connection.\n+    std::atomic<bool> fHandshook;\n+    //! Whether we consider this a preferred download peer.\n+    const DownloadPreferredness preferedness;\n+    std::atomic<ConnectedInfo*> pconnected;\n+};\n+\n+class PeerManager {\n+    typedef std::lock_guard<std::mutex> lock_guard;\n+public:\n+    inline void SetConnected(Peer& peer, std::unique_ptr<Peer::ConnectedInfo>&& pconnected) {\n+        if (pconnected->CanDownload()) {\n+            if (peer.GetPreferredness() == DownloadPreferredness::ABOVE_NORMAL)\n+                nPreferredDownload.fetch_add(1, std::memory_order_relaxed);\n+        }\n+        peer.SetConnectedInfo(std::move(pconnected));\n+    }\n+\n+    void Register(NodeId id, std::shared_ptr<Peer>&& peer);\n+    void Unregister(NodeId id);\n+    std::shared_ptr<Peer> Get(NodeId id);\n+\n+    inline void Clear() {\n+        lock_guard guard{csById};\n+        _byId.clear();\n+    }\n+\n+    bool IsPreferred(Peer& peer) const;\n+private:\n+    std::atomic<uint32_t> nPreferredDownload;\n+\n+    std::mutex csById;\n+    std::map<NodeId, std::shared_ptr<Peer>> _byId;\n+};\n+\n+#endif // BITCOIN_PEER_H"
      },
      {
        "sha": "edb87049d5ba39d56038d25f6cb644cff91aaff0",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f5734abe519f0d2f029f9db84ac5815b3ce56ce/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f5734abe519f0d2f029f9db84ac5815b3ce56ce/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=8f5734abe519f0d2f029f9db84ac5815b3ce56ce",
        "patch": "@@ -131,7 +131,7 @@ UniValue generateBlocks(boost::shared_ptr<CReserveScript> coinbaseScript, int nG\n             continue;\n         }\n         CValidationState state;\n-        if (!ProcessNewBlock(state, Params(), NULL, pblock, true, NULL))\n+        if (!ProcessNewBlock(state, Params(), pblock))\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"ProcessNewBlock, block not accepted\");\n         ++nHeight;\n         blockHashes.push_back(pblock->GetHash().GetHex());\n@@ -722,7 +722,7 @@ UniValue submitblock(const UniValue& params, bool fHelp)\n     CValidationState state;\n     submitblock_StateCatcher sc(block.GetHash());\n     RegisterValidationInterface(&sc);\n-    bool fAccepted = ProcessNewBlock(state, Params(), NULL, &block, true, NULL);\n+    bool fAccepted = ProcessNewBlock(state, Params(), &block);\n     UnregisterValidationInterface(&sc);\n     if (fBlockPresent)\n     {"
      },
      {
        "sha": "dc624a7e2312f2857f2c7aeeb97e85bf60702dcd",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f5734abe519f0d2f029f9db84ac5815b3ce56ce/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f5734abe519f0d2f029f9db84ac5815b3ce56ce/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=8f5734abe519f0d2f029f9db84ac5815b3ce56ce",
        "patch": "@@ -143,7 +143,7 @@ UniValue getpeerinfo(const UniValue& params, bool fHelp)\n         if (!(stats.addrLocal.empty()))\n             obj.push_back(Pair(\"addrlocal\", stats.addrLocal));\n         obj.push_back(Pair(\"services\", strprintf(\"%016x\", stats.nServices)));\n-        obj.push_back(Pair(\"relaytxes\", stats.fRelayTxes));\n+        obj.push_back(Pair(\"relaytxes\", statestats.fRelayTxes));\n         obj.push_back(Pair(\"lastsend\", stats.nLastSend));\n         obj.push_back(Pair(\"lastrecv\", stats.nLastRecv));\n         obj.push_back(Pair(\"bytessent\", stats.nSendBytes));"
      },
      {
        "sha": "b283c110841842250c01d4e0a3aeee1576b44298",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 59,
        "deletions": 14,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f5734abe519f0d2f029f9db84ac5815b3ce56ce/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f5734abe519f0d2f029f9db84ac5815b3ce56ce/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=8f5734abe519f0d2f029f9db84ac5815b3ce56ce",
        "patch": "@@ -8,6 +8,7 @@\n #include \"keystore.h\"\n #include \"main.h\"\n #include \"net.h\"\n+#include \"peer.h\"\n #include \"pow.h\"\n #include \"script/sign.h\"\n #include \"serialize.h\"\n@@ -32,6 +33,7 @@ struct COrphanTx {\n };\n extern std::map<uint256, COrphanTx> mapOrphanTransactions;\n extern std::map<uint256, std::set<uint256> > mapOrphanTransactionsByPrev;\n+extern PeerManager peermgr;\n \n CService ip(uint32_t i)\n {\n@@ -46,42 +48,53 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n {\n     CNode::ClearBanned();\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n+    assert(!addr1.IsLocal());\n     CNode dummyNode1(INVALID_SOCKET, addr1, \"\", true);\n-    dummyNode1.nVersion = 1;\n-    Misbehaving(dummyNode1.GetId(), 100); // Should get banned\n+    auto ppeer1 = peermgr.Get(dummyNode1.GetId());\n+    assert(ppeer1);\n+    ppeer1->Misbehaving(100); // Should get banned\n+    BOOST_CHECK(ppeer1->CanBan());\n     SendMessages(&dummyNode1);\n     BOOST_CHECK(CNode::IsBanned(addr1));\n     BOOST_CHECK(!CNode::IsBanned(ip(0xa0b0c001|0x0000ff00))); // Different IP, not banned\n \n     CAddress addr2(ip(0xa0b0c002), NODE_NONE);\n+    assert(!addr2.IsLocal());\n     CNode dummyNode2(INVALID_SOCKET, addr2, \"\", true);\n-    dummyNode2.nVersion = 1;\n-    Misbehaving(dummyNode2.GetId(), 50);\n+    auto ppeer2 = peermgr.Get(dummyNode2.GetId());\n+    assert(ppeer2);\n+    ppeer2->Misbehaving(50);\n+    BOOST_CHECK(ppeer2->CanBan());\n     SendMessages(&dummyNode2);\n     BOOST_CHECK(!CNode::IsBanned(addr2)); // 2 not banned yet...\n     BOOST_CHECK(CNode::IsBanned(addr1));  // ... but 1 still should be\n-    Misbehaving(dummyNode2.GetId(), 50);\n+    ppeer2->Misbehaving(50);\n     SendMessages(&dummyNode2);\n     BOOST_CHECK(CNode::IsBanned(addr2));\n }\n \n BOOST_AUTO_TEST_CASE(DoS_banscore)\n {\n     CNode::ClearBanned();\n-    mapArgs[\"-banscore\"] = \"111\"; // because 11 is my favorite number\n+    auto banscoreOld = Misbehavior::GetBanscore();\n+    Misbehavior::_SetBanscore(111); // because 11 is Gavin's favorite number\n+    BOOST_CHECK(Misbehavior::GetBanscore() == 111);\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n+    assert(!addr1.IsLocal());\n     CNode dummyNode1(INVALID_SOCKET, addr1, \"\", true);\n-    dummyNode1.nVersion = 1;\n-    Misbehaving(dummyNode1.GetId(), 100);\n+    auto ppeer1 = peermgr.Get(dummyNode1.GetId());\n+    assert(ppeer1);\n+    BOOST_CHECK(ppeer1->CanBan());\n+    ppeer1->Misbehaving(100);\n     SendMessages(&dummyNode1);\n     BOOST_CHECK(!CNode::IsBanned(addr1));\n-    Misbehaving(dummyNode1.GetId(), 10);\n+    ppeer1->Misbehaving(10);\n     SendMessages(&dummyNode1);\n     BOOST_CHECK(!CNode::IsBanned(addr1));\n-    Misbehaving(dummyNode1.GetId(), 1);\n+    ppeer1->Misbehaving(1);\n     SendMessages(&dummyNode1);\n     BOOST_CHECK(CNode::IsBanned(addr1));\n-    mapArgs.erase(\"-banscore\");\n+    Misbehavior::_SetBanscore(banscoreOld);\n }\n \n BOOST_AUTO_TEST_CASE(DoS_bantime)\n@@ -91,10 +104,12 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     SetMockTime(nStartTime); // Overrides future calls to GetTime()\n \n     CAddress addr(ip(0xa0b0c001), NODE_NONE);\n+    assert(!addr.IsLocal());\n     CNode dummyNode(INVALID_SOCKET, addr, \"\", true);\n-    dummyNode.nVersion = 1;\n-\n-    Misbehaving(dummyNode.GetId(), 100);\n+    auto ppeer = peermgr.Get(dummyNode.GetId());\n+    assert(ppeer);\n+    BOOST_CHECK(ppeer->CanBan());\n+    ppeer->Misbehaving(100);\n     SendMessages(&dummyNode);\n     BOOST_CHECK(CNode::IsBanned(addr));\n \n@@ -105,6 +120,36 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     BOOST_CHECK(!CNode::IsBanned(addr));\n }\n \n+BOOST_AUTO_TEST_CASE(DoS_noban_whitelist)\n+{\n+    CNode::ClearBanned();\n+    CAddress addr(ip(0xa0b0c001), NODE_NONE);\n+    assert(!addr.IsLocal());\n+    CNode dummyNode(INVALID_SOCKET, addr, \"\", true, true);\n+    auto ppeer = peermgr.Get(dummyNode.GetId());\n+    assert(ppeer);\n+    ppeer->Misbehaving(200);\n+    BOOST_CHECK(!ppeer->CanBan());\n+    BOOST_CHECK(!ppeer->CanDisconnect());\n+    SendMessages(&dummyNode);\n+    BOOST_CHECK(!CNode::IsBanned(addr));\n+}\n+\n+BOOST_AUTO_TEST_CASE(DoS_noban_local)\n+{\n+    CNode::ClearBanned();\n+    CAddress addr(CService(\"127.0.0.24\", 1039), NODE_NONE);\n+    assert(addr.IsLocal());\n+    CNode dummyNode(INVALID_SOCKET, addr, \"\", true);\n+    auto ppeer = peermgr.Get(dummyNode.GetId());\n+    assert(ppeer);\n+    ppeer->Misbehaving(200);\n+    BOOST_CHECK(!ppeer->CanBan());\n+    BOOST_CHECK(ppeer->CanDisconnect());\n+    SendMessages(&dummyNode);\n+    BOOST_CHECK(!CNode::IsBanned(addr));\n+}\n+\n CTransaction RandomOrphan()\n {\n     std::map<uint256, COrphanTx>::iterator it;"
      },
      {
        "sha": "0ac05afb12f077a70ea4604fcb040945b382187d",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f5734abe519f0d2f029f9db84ac5815b3ce56ce/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f5734abe519f0d2f029f9db84ac5815b3ce56ce/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=8f5734abe519f0d2f029f9db84ac5815b3ce56ce",
        "patch": "@@ -114,7 +114,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         pblock->hashMerkleRoot = BlockMerkleRoot(*pblock);\n         pblock->nNonce = blockinfo[i].nonce;\n         CValidationState state;\n-        BOOST_CHECK(ProcessNewBlock(state, chainparams, NULL, pblock, true, NULL));\n+        BOOST_CHECK(ProcessNewBlock(state, chainparams, pblock));\n         BOOST_CHECK(state.IsValid());\n         pblock->hashPrevBlock = pblock->GetHash();\n     }"
      },
      {
        "sha": "af19cbe9d2062576fc217a2f9264db14b774d184",
        "filename": "src/test/peer_tests.cpp",
        "status": "added",
        "additions": 103,
        "deletions": 0,
        "changes": 103,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f5734abe519f0d2f029f9db84ac5815b3ce56ce/src/test/peer_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f5734abe519f0d2f029f9db84ac5815b3ce56ce/src/test/peer_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/peer_tests.cpp?ref=8f5734abe519f0d2f029f9db84ac5815b3ce56ce",
        "patch": "@@ -0,0 +1,103 @@\n+// Copyright (c) 2011-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+// Unit tests for Peer code\n+\n+#include \"peer.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(Peer_tests)\n+\n+PeerManager pm;\n+\n+BOOST_AUTO_TEST_CASE(Peer_peermgr)\n+{\n+    // make and register a typical peer\n+    constexpr int NODE_ID = 15;\n+    const std::string NODE_NAME = \"node name\";\n+    Peer::Params params{NODE_ID, NODE_NAME};\n+    params.fNoBan = false;\n+    params.fNoDisconnect = false;\n+    pm.Register(NODE_ID, std::make_shared<Peer>(std::move(params)));\n+\n+    // get it back\n+    {\n+        auto ppeer = pm.Get(NODE_ID);\n+        BOOST_CHECK(ppeer->GetId() == NODE_ID);\n+        BOOST_CHECK(ppeer->GetName() == NODE_NAME);\n+        BOOST_CHECK(ppeer->CanDisconnect() == true);\n+        BOOST_CHECK(ppeer->CanBan() == true);\n+    }\n+\n+    pm.Unregister(NODE_ID);\n+    assert(!pm.Get(NODE_ID));\n+}\n+\n+static void SetConnectedDownloadable(Peer& peer)\n+{\n+    std::unique_ptr<Peer::ConnectedInfo> pconn{new Peer::ConnectedInfo};\n+    pconn->SetCanDownload(true);\n+    pm.SetConnected(peer, std::move(pconn));\n+}\n+\n+BOOST_AUTO_TEST_CASE(Peer_prefer)\n+{\n+    // low priority peer\n+    Peer::Params params1{1, \"\"};\n+    params1.preferedness = DownloadPreferredness::BELOW_NORMAL;\n+    pm.Register(1, std::make_shared<Peer>(std::move(params1)));\n+    auto pLow = pm.Get(1);\n+    SetConnectedDownloadable(*pLow);\n+    BOOST_CHECK(!pm.IsPreferred(*pLow));\n+\n+    // normal priority\n+    Peer::Params params2{2, \"\"};\n+    pm.Register(2, std::make_shared<Peer>(std::move(params2)));\n+    auto pNormal1 = pm.Get(2);\n+    SetConnectedDownloadable(*pNormal1);\n+    BOOST_CHECK(pm.IsPreferred(*pNormal1));\n+    Peer::Params params3{3, \"\"};\n+    pm.Register(3, std::make_shared<Peer>(std::move(params3)));\n+    auto pNormal2 = pm.Get(3);\n+    SetConnectedDownloadable(*pNormal2);\n+    BOOST_CHECK(pm.IsPreferred(*pNormal2));\n+\n+    // high priority\n+    Peer::Params params4{4, \"\"};\n+    params4.preferedness = DownloadPreferredness::ABOVE_NORMAL;\n+    pm.Register(4, std::make_shared<Peer>(std::move(params4)));\n+    auto pHigh1 = pm.Get(4);\n+    SetConnectedDownloadable(*pHigh1);\n+    BOOST_CHECK(pm.IsPreferred(*pHigh1));\n+    BOOST_CHECK(!pm.IsPreferred(*pNormal1));\n+    BOOST_CHECK(!pm.IsPreferred(*pNormal2));\n+    Peer::Params params5{5, \"\"};\n+    params5.preferedness = DownloadPreferredness::ABOVE_NORMAL;\n+    pm.Register(5, std::make_shared<Peer>(std::move(params5)));\n+    auto pHigh2 = pm.Get(5);\n+    SetConnectedDownloadable(*pHigh2);\n+    BOOST_CHECK(pm.IsPreferred(*pHigh2));\n+    BOOST_CHECK(!pm.IsPreferred(*pNormal1));\n+    BOOST_CHECK(!pm.IsPreferred(*pNormal2));\n+}\n+\n+BOOST_AUTO_TEST_CASE(Peer_misbehavior_threshold)\n+{\n+    BOOST_CHECK(Misbehavior::GetBanscore() == 100);\n+    Peer::Params params{40, \"\"};\n+    pm.Register(40, std::make_shared<Peer>(std::move(params)));\n+    auto ppeer = pm.Get(40);\n+    assert(ppeer);\n+    BOOST_CHECK(ppeer->GetMisbehavior() == 0);\n+    BOOST_CHECK(!ppeer->ExceededMisbehaviorThreshold());\n+    BOOST_CHECK(!Misbehavior::IsExcessive(ppeer->Misbehaving(50)));\n+    BOOST_CHECK(!ppeer->ExceededMisbehaviorThreshold());\n+    BOOST_CHECK(Misbehavior::IsExcessive(ppeer->Misbehaving(50)));\n+    BOOST_CHECK(ppeer->ExceededMisbehaviorThreshold());\n+    BOOST_CHECK(!ppeer->ExceededMisbehaviorThreshold());\n+    BOOST_CHECK(Misbehavior::IsExcessive(ppeer->GetMisbehavior()));\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "26a32b2429f92a36905f338464976427c2997a11",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f5734abe519f0d2f029f9db84ac5815b3ce56ce/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f5734abe519f0d2f029f9db84ac5815b3ce56ce/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=8f5734abe519f0d2f029f9db84ac5815b3ce56ce",
        "patch": "@@ -112,7 +112,7 @@ TestChain100Setup::CreateAndProcessBlock(const std::vector<CMutableTransaction>&\n     while (!CheckProofOfWork(block.GetHash(), block.nBits, chainparams.GetConsensus())) ++block.nNonce;\n \n     CValidationState state;\n-    ProcessNewBlock(state, chainparams, NULL, &block, true, NULL);\n+    ProcessNewBlock(state, chainparams, &block);\n \n     CBlock result = block;\n     delete pblocktemplate;"
      }
    ]
  }
]