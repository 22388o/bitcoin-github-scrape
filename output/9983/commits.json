[
  {
    "sha": "01217188c9e9281d0d1ad0e6a54035d52cfedaa9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMTIxNzE4OGM5ZTkyODFkMGQxYWQwZTZhNTQwMzVkNTJjZmVkYWE5",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2017-03-13T08:44:57Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2017-03-13T08:47:24Z"
      },
      "message": "tests: Convert selected tests to named arguments\n\nConvert selected tests to use named arguments in RPC calls.\nThis covers:\n\n- `assumevalid.py`\n- `blockchain.py`\n- `merkle_blocks.py`\n- `segwit.py`\n\nAs well as the test framework itself, `util.py`.\n\nThis makes invocations easier to read especially if booleans or lots of\narguments are involved.\n\nTo review I'd suggest using the command:\n\n    git diff --word-diff --word-diff-regex='[^[:space:],\\(\\)=]+'\n\nThis will regard the added argument names as one words, making it easy\nto see what is added.",
      "tree": {
        "sha": "44adcc1fd32d751d98db99713f2753894035fab1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/44adcc1fd32d751d98db99713f2753894035fab1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/01217188c9e9281d0d1ad0e6a54035d52cfedaa9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/01217188c9e9281d0d1ad0e6a54035d52cfedaa9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/01217188c9e9281d0d1ad0e6a54035d52cfedaa9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/01217188c9e9281d0d1ad0e6a54035d52cfedaa9/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fa99663bec1d9471235844494c56c3922f9bc305",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa99663bec1d9471235844494c56c3922f9bc305",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fa99663bec1d9471235844494c56c3922f9bc305"
      }
    ],
    "stats": {
      "total": 252,
      "additions": 126,
      "deletions": 126
    },
    "files": [
      {
        "sha": "1e154f25f0a8325935f8cbfe413750c975b99359",
        "filename": "qa/rpc-tests/assumevalid.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/01217188c9e9281d0d1ad0e6a54035d52cfedaa9/qa/rpc-tests/assumevalid.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/01217188c9e9281d0d1ad0e6a54035d52cfedaa9/qa/rpc-tests/assumevalid.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/assumevalid.py?ref=01217188c9e9281d0d1ad0e6a54035d52cfedaa9",
        "patch": "@@ -88,7 +88,7 @@ def run_test(self):\n \n         # Build the blockchain\n         self.tip = int(self.nodes[0].getbestblockhash(), 16)\n-        self.block_time = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['time'] + 1\n+        self.block_time = self.nodes[0].getblock(blockhash=self.nodes[0].getbestblockhash())['time'] + 1\n \n         self.blocks = []\n \n@@ -171,20 +171,20 @@ def run_test(self):\n             node0.send_message(msg_block(self.blocks[i]))\n         node0.sync_with_ping() # make sure the most recent block is synced\n         node0.send_message(msg_block(self.blocks[101]))\n-        assert_equal(self.nodes[0].getblock(self.nodes[0].getbestblockhash())['height'], 101)\n+        assert_equal(self.nodes[0].getblock(blockhash=self.nodes[0].getbestblockhash())['height'], 101)\n \n         # Send 3102 blocks to node1. All blocks will be accepted.\n         for i in range(2202):\n             node1.send_message(msg_block(self.blocks[i]))\n         node1.sync_with_ping() # make sure the most recent block is synced\n-        assert_equal(self.nodes[1].getblock(self.nodes[1].getbestblockhash())['height'], 2202)\n+        assert_equal(self.nodes[1].getblock(blockhash=self.nodes[1].getbestblockhash())['height'], 2202)\n \n         # Send 102 blocks to node2. Block 102 will be rejected.\n         for i in range(101):\n             node2.send_message(msg_block(self.blocks[i]))\n         node2.sync_with_ping() # make sure the most recent block is synced\n         node2.send_message(msg_block(self.blocks[101]))\n-        assert_equal(self.nodes[2].getblock(self.nodes[2].getbestblockhash())['height'], 101)\n+        assert_equal(self.nodes[2].getblock(blockhash=self.nodes[2].getbestblockhash())['height'], 101)\n \n if __name__ == '__main__':\n     SendHeadersTest().main()"
      },
      {
        "sha": "4ba9c2238609b03a52aef37af013a78e91fc28a9",
        "filename": "qa/rpc-tests/blockchain.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/01217188c9e9281d0d1ad0e6a54035d52cfedaa9/qa/rpc-tests/blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/01217188c9e9281d0d1ad0e6a54035d52cfedaa9/qa/rpc-tests/blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/blockchain.py?ref=01217188c9e9281d0d1ad0e6a54035d52cfedaa9",
        "patch": "@@ -41,7 +41,7 @@ def setup_network(self, split=False):\n     def run_test(self):\n         self._test_gettxoutsetinfo()\n         self._test_getblockheader()\n-        self.nodes[0].verifychain(4, 0)\n+        self.nodes[0].verifychain(checklevel=4, nblocks=0)\n \n     def _test_gettxoutsetinfo(self):\n         node = self.nodes[0]\n@@ -59,11 +59,11 @@ def _test_getblockheader(self):\n         node = self.nodes[0]\n \n         assert_raises(\n-            JSONRPCException, lambda: node.getblockheader('nonsense'))\n+            JSONRPCException, lambda: node.getblockheader(blockhash='nonsense'))\n \n         besthash = node.getbestblockhash()\n-        secondbesthash = node.getblockhash(199)\n-        header = node.getblockheader(besthash)\n+        secondbesthash = node.getblockhash(height=199)\n+        header = node.getblockheader(blockhash=besthash)\n \n         assert_equal(header['hash'], besthash)\n         assert_equal(header['height'], 200)"
      },
      {
        "sha": "166bd8a760957f925d7fb7e982790fde5109504e",
        "filename": "qa/rpc-tests/merkle_blocks.py",
        "status": "modified",
        "additions": 23,
        "deletions": 23,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/01217188c9e9281d0d1ad0e6a54035d52cfedaa9/qa/rpc-tests/merkle_blocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/01217188c9e9281d0d1ad0e6a54035d52cfedaa9/qa/rpc-tests/merkle_blocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/merkle_blocks.py?ref=01217188c9e9281d0d1ad0e6a54035d52cfedaa9",
        "patch": "@@ -31,55 +31,55 @@ def setup_network(self):\n \n     def run_test(self):\n         self.log.info(\"Mining blocks...\")\n-        self.nodes[0].generate(105)\n+        self.nodes[0].generate(nblocks=105)\n         self.sync_all()\n \n         chain_height = self.nodes[1].getblockcount()\n         assert_equal(chain_height, 105)\n         assert_equal(self.nodes[1].getbalance(), 0)\n         assert_equal(self.nodes[2].getbalance(), 0)\n \n-        node0utxos = self.nodes[0].listunspent(1)\n-        tx1 = self.nodes[0].createrawtransaction([node0utxos.pop()], {self.nodes[1].getnewaddress(): 49.99})\n-        txid1 = self.nodes[0].sendrawtransaction(self.nodes[0].signrawtransaction(tx1)[\"hex\"])\n-        tx2 = self.nodes[0].createrawtransaction([node0utxos.pop()], {self.nodes[1].getnewaddress(): 49.99})\n-        txid2 = self.nodes[0].sendrawtransaction(self.nodes[0].signrawtransaction(tx2)[\"hex\"])\n-        assert_raises(JSONRPCException, self.nodes[0].gettxoutproof, [txid1])\n+        node0utxos = self.nodes[0].listunspent(minconf=1)\n+        tx1 = self.nodes[0].createrawtransaction(transactions=[node0utxos.pop()], outputs={self.nodes[1].getnewaddress(): 49.99})\n+        txid1 = self.nodes[0].sendrawtransaction(hexstring=self.nodes[0].signrawtransaction(hexstring=tx1)[\"hex\"])\n+        tx2 = self.nodes[0].createrawtransaction(transactions=[node0utxos.pop()], outputs={self.nodes[1].getnewaddress(): 49.99})\n+        txid2 = self.nodes[0].sendrawtransaction(hexstring=self.nodes[0].signrawtransaction(hexstring=tx2)[\"hex\"])\n+        assert_raises(JSONRPCException, self.nodes[0].gettxoutproof, txids=[txid1])\n \n-        self.nodes[0].generate(1)\n-        blockhash = self.nodes[0].getblockhash(chain_height + 1)\n+        self.nodes[0].generate(nblocks=1)\n+        blockhash = self.nodes[0].getblockhash(height=chain_height + 1)\n         self.sync_all()\n \n         txlist = []\n-        blocktxn = self.nodes[0].getblock(blockhash, True)[\"tx\"]\n+        blocktxn = self.nodes[0].getblock(blockhash=blockhash, verbose=True)[\"tx\"]\n         txlist.append(blocktxn[1])\n         txlist.append(blocktxn[2])\n \n-        assert_equal(self.nodes[2].verifytxoutproof(self.nodes[2].gettxoutproof([txid1])), [txid1])\n-        assert_equal(self.nodes[2].verifytxoutproof(self.nodes[2].gettxoutproof([txid1, txid2])), txlist)\n-        assert_equal(self.nodes[2].verifytxoutproof(self.nodes[2].gettxoutproof([txid1, txid2], blockhash)), txlist)\n+        assert_equal(self.nodes[2].verifytxoutproof(proof=self.nodes[2].gettxoutproof(txids=[txid1])), [txid1])\n+        assert_equal(self.nodes[2].verifytxoutproof(proof=self.nodes[2].gettxoutproof(txids=[txid1, txid2])), txlist)\n+        assert_equal(self.nodes[2].verifytxoutproof(proof=self.nodes[2].gettxoutproof(txids=[txid1, txid2], blockhash=blockhash)), txlist)\n \n-        txin_spent = self.nodes[1].listunspent(1).pop()\n-        tx3 = self.nodes[1].createrawtransaction([txin_spent], {self.nodes[0].getnewaddress(): 49.98})\n-        self.nodes[0].sendrawtransaction(self.nodes[1].signrawtransaction(tx3)[\"hex\"])\n-        self.nodes[0].generate(1)\n+        txin_spent = self.nodes[1].listunspent(minconf=1).pop()\n+        tx3 = self.nodes[1].createrawtransaction(transactions=[txin_spent], outputs={self.nodes[0].getnewaddress(): 49.98})\n+        self.nodes[0].sendrawtransaction(hexstring=self.nodes[1].signrawtransaction(hexstring=tx3)[\"hex\"])\n+        self.nodes[0].generate(nblocks=1)\n         self.sync_all()\n \n         txid_spent = txin_spent[\"txid\"]\n         txid_unspent = txid1 if txin_spent[\"txid\"] != txid1 else txid2\n \n         # We can't find the block from a fully-spent tx\n-        assert_raises(JSONRPCException, self.nodes[2].gettxoutproof, [txid_spent])\n+        assert_raises(JSONRPCException, self.nodes[2].gettxoutproof, txids=[txid_spent])\n         # ...but we can if we specify the block\n-        assert_equal(self.nodes[2].verifytxoutproof(self.nodes[2].gettxoutproof([txid_spent], blockhash)), [txid_spent])\n+        assert_equal(self.nodes[2].verifytxoutproof(proof=self.nodes[2].gettxoutproof(txids=[txid_spent], blockhash=blockhash)), [txid_spent])\n         # ...or if the first tx is not fully-spent\n-        assert_equal(self.nodes[2].verifytxoutproof(self.nodes[2].gettxoutproof([txid_unspent])), [txid_unspent])\n+        assert_equal(self.nodes[2].verifytxoutproof(proof=self.nodes[2].gettxoutproof(txids=[txid_unspent])), [txid_unspent])\n         try:\n-            assert_equal(self.nodes[2].verifytxoutproof(self.nodes[2].gettxoutproof([txid1, txid2])), txlist)\n+            assert_equal(self.nodes[2].verifytxoutproof(proof=self.nodes[2].gettxoutproof(txids=[txid1, txid2])), txlist)\n         except JSONRPCException:\n-            assert_equal(self.nodes[2].verifytxoutproof(self.nodes[2].gettxoutproof([txid2, txid1])), txlist)\n+            assert_equal(self.nodes[2].verifytxoutproof(proof=self.nodes[2].gettxoutproof(txids=[txid2, txid1])), txlist)\n         # ...or if we have a -txindex\n-        assert_equal(self.nodes[2].verifytxoutproof(self.nodes[3].gettxoutproof([txid_spent])), [txid_spent])\n+        assert_equal(self.nodes[2].verifytxoutproof(proof=self.nodes[3].gettxoutproof(txids=[txid_spent])), [txid_spent])\n \n if __name__ == '__main__':\n     MerkleBlockTest().main()"
      },
      {
        "sha": "e4ef1de4bbabfd3698d4fb0926116ba3f337b6e0",
        "filename": "qa/rpc-tests/segwit.py",
        "status": "modified",
        "additions": 88,
        "deletions": 88,
        "changes": 176,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/01217188c9e9281d0d1ad0e6a54035d52cfedaa9/qa/rpc-tests/segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/01217188c9e9281d0d1ad0e6a54035d52cfedaa9/qa/rpc-tests/segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/segwit.py?ref=01217188c9e9281d0d1ad0e6a54035d52cfedaa9",
        "patch": "@@ -45,22 +45,22 @@ def create_witnessprogram(version, node, utxo, pubkey, encode_p2sh, amount):\n     inputs.append({ \"txid\" : utxo[\"txid\"], \"vout\" : utxo[\"vout\"]} )\n     DUMMY_P2SH = \"2MySexEGVzZpRgNQ1JdjdP5bRETznm3roQ2\" # P2SH of \"OP_1 OP_DROP\"\n     outputs[DUMMY_P2SH] = amount\n-    tx_to_witness = node.createrawtransaction(inputs,outputs)\n+    tx_to_witness = node.createrawtransaction(transactions=inputs,outputs=outputs)\n     #replace dummy output with our own\n     tx_to_witness = tx_to_witness[0:110] + addlength(pkscript) + tx_to_witness[-8:]\n     return tx_to_witness\n \n def send_to_witness(version, node, utxo, pubkey, encode_p2sh, amount, sign=True, insert_redeem_script=\"\"):\n     tx_to_witness = create_witnessprogram(version, node, utxo, pubkey, encode_p2sh, amount)\n     if (sign):\n-        signed = node.signrawtransaction(tx_to_witness)\n+        signed = node.signrawtransaction(hexstring=tx_to_witness)\n         assert(\"errors\" not in signed or len([\"errors\"]) == 0)\n-        return node.sendrawtransaction(signed[\"hex\"])\n+        return node.sendrawtransaction(hexstring=signed[\"hex\"])\n     else:\n         if (insert_redeem_script):\n             tx_to_witness = tx_to_witness[0:82] + addlength(insert_redeem_script) + tx_to_witness[84:]\n \n-    return node.sendrawtransaction(tx_to_witness)\n+    return node.sendrawtransaction(hexstring=tx_to_witness)\n \n def getutxo(txid):\n     utxo = {}\n@@ -93,14 +93,14 @@ def setup_network(self):\n \n     def success_mine(self, node, txid, sign, redeem_script=\"\"):\n         send_to_witness(1, node, getutxo(txid), self.pubkey[0], False, Decimal(\"49.998\"), sign, redeem_script)\n-        block = node.generate(1)\n-        assert_equal(len(node.getblock(block[0])[\"tx\"]), 2)\n+        block = node.generate(nblocks=1)\n+        assert_equal(len(node.getblock(blockhash=block[0])[\"tx\"]), 2)\n         sync_blocks(self.nodes)\n \n     def skip_mine(self, node, txid, sign, redeem_script=\"\"):\n         send_to_witness(1, node, getutxo(txid), self.pubkey[0], False, Decimal(\"49.998\"), sign, redeem_script)\n-        block = node.generate(1)\n-        assert_equal(len(node.getblock(block[0])[\"tx\"]), 1)\n+        block = node.generate(nblocks=1)\n+        assert_equal(len(node.getblock(blockhash=block[0])[\"tx\"]), 1)\n         sync_blocks(self.nodes)\n \n     def fail_accept(self, node, txid, sign, redeem_script=\"\"):\n@@ -114,42 +114,42 @@ def fail_accept(self, node, txid, sign, redeem_script=\"\"):\n     def fail_mine(self, node, txid, sign, redeem_script=\"\"):\n         send_to_witness(1, node, getutxo(txid), self.pubkey[0], False, Decimal(\"49.998\"), sign, redeem_script)\n         try:\n-            node.generate(1)\n+            node.generate(nblocks=1)\n         except JSONRPCException as exp:\n             assert(exp.error[\"code\"] == -1)\n         else:\n             raise AssertionError(\"Created valid block when TestBlockValidity should have failed\")\n         sync_blocks(self.nodes)\n \n     def run_test(self):\n-        self.nodes[0].generate(161) #block 161\n+        self.nodes[0].generate(nblocks=161) #block 161\n \n         self.log.info(\"Verify sigops are counted in GBT with pre-BIP141 rules before the fork\")\n-        txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n-        tmpl = self.nodes[0].getblocktemplate({})\n+        txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1)\n+        tmpl = self.nodes[0].getblocktemplate(template_request={})\n         assert(tmpl['sizelimit'] == 1000000)\n         assert('weightlimit' not in tmpl)\n         assert(tmpl['sigoplimit'] == 20000)\n         assert(tmpl['transactions'][0]['hash'] == txid)\n         assert(tmpl['transactions'][0]['sigops'] == 2)\n-        tmpl = self.nodes[0].getblocktemplate({'rules':['segwit']})\n+        tmpl = self.nodes[0].getblocktemplate(template_request={'rules':['segwit']})\n         assert(tmpl['sizelimit'] == 1000000)\n         assert('weightlimit' not in tmpl)\n         assert(tmpl['sigoplimit'] == 20000)\n         assert(tmpl['transactions'][0]['hash'] == txid)\n         assert(tmpl['transactions'][0]['sigops'] == 2)\n-        self.nodes[0].generate(1) #block 162\n+        self.nodes[0].generate(nblocks=1) #block 162\n \n         balance_presetup = self.nodes[0].getbalance()\n         self.pubkey = []\n         p2sh_ids = [] # p2sh_ids[NODE][VER] is an array of txids that spend to a witness version VER pkscript to an address for NODE embedded in p2sh\n         wit_ids = [] # wit_ids[NODE][VER] is an array of txids that spend to a witness version VER pkscript to an address for NODE via bare witness\n         for i in range(3):\n             newaddress = self.nodes[i].getnewaddress()\n-            self.pubkey.append(self.nodes[i].validateaddress(newaddress)[\"pubkey\"])\n-            multiaddress = self.nodes[i].addmultisigaddress(1, [self.pubkey[-1]])\n-            self.nodes[i].addwitnessaddress(newaddress)\n-            self.nodes[i].addwitnessaddress(multiaddress)\n+            self.pubkey.append(self.nodes[i].validateaddress(address=newaddress)[\"pubkey\"])\n+            multiaddress = self.nodes[i].addmultisigaddress(nrequired=1, keys=[self.pubkey[-1]])\n+            self.nodes[i].addwitnessaddress(address=newaddress)\n+            self.nodes[i].addwitnessaddress(address=multiaddress)\n             p2sh_ids.append([])\n             wit_ids.append([])\n             for v in range(2):\n@@ -162,15 +162,15 @@ def run_test(self):\n                     wit_ids[n][v].append(send_to_witness(v, self.nodes[0], find_unspent(self.nodes[0], 50), self.pubkey[n], False, Decimal(\"49.999\")))\n                     p2sh_ids[n][v].append(send_to_witness(v, self.nodes[0], find_unspent(self.nodes[0], 50), self.pubkey[n], True, Decimal(\"49.999\")))\n \n-        self.nodes[0].generate(1) #block 163\n+        self.nodes[0].generate(nblocks=1) #block 163\n         sync_blocks(self.nodes)\n \n         # Make sure all nodes recognize the transactions as theirs\n         assert_equal(self.nodes[0].getbalance(), balance_presetup - 60*50 + 20*Decimal(\"49.999\") + 50)\n         assert_equal(self.nodes[1].getbalance(), 20*Decimal(\"49.999\"))\n         assert_equal(self.nodes[2].getbalance(), 20*Decimal(\"49.999\"))\n \n-        self.nodes[0].generate(260) #block 423\n+        self.nodes[0].generate(nblocks=260) #block 423\n         sync_blocks(self.nodes)\n \n         self.log.info(\"Verify default node can't accept any witness format txs before fork\")\n@@ -210,22 +210,22 @@ def run_test(self):\n \n         self.log.info(\"Verify previous witness txs skipped for mining can now be mined\")\n         assert_equal(len(self.nodes[2].getrawmempool()), 4)\n-        block = self.nodes[2].generate(1) #block 432 (first block with new rules; 432 = 144 * 3)\n+        block = self.nodes[2].generate(nblocks=1) #block 432 (first block with new rules; 432 = 144 * 3)\n         sync_blocks(self.nodes)\n         assert_equal(len(self.nodes[2].getrawmempool()), 0)\n-        segwit_tx_list = self.nodes[2].getblock(block[0])[\"tx\"]\n+        segwit_tx_list = self.nodes[2].getblock(blockhash=block[0])[\"tx\"]\n         assert_equal(len(segwit_tx_list), 5)\n \n         self.log.info(\"Verify block and transaction serialization rpcs return differing serializations depending on rpc serialization flag\")\n-        assert(self.nodes[2].getblock(block[0], False) !=  self.nodes[0].getblock(block[0], False))\n-        assert(self.nodes[1].getblock(block[0], False) ==  self.nodes[2].getblock(block[0], False))\n+        assert(self.nodes[2].getblock(blockhash=block[0], verbose=False) !=  self.nodes[0].getblock(blockhash=block[0], verbose=False))\n+        assert(self.nodes[1].getblock(blockhash=block[0], verbose=False) ==  self.nodes[2].getblock(blockhash=block[0], verbose=False))\n         for i in range(len(segwit_tx_list)):\n-            tx = FromHex(CTransaction(), self.nodes[2].gettransaction(segwit_tx_list[i])[\"hex\"])\n-            assert(self.nodes[2].getrawtransaction(segwit_tx_list[i]) != self.nodes[0].getrawtransaction(segwit_tx_list[i]))\n-            assert(self.nodes[1].getrawtransaction(segwit_tx_list[i], 0) == self.nodes[2].getrawtransaction(segwit_tx_list[i]))\n-            assert(self.nodes[0].getrawtransaction(segwit_tx_list[i]) != self.nodes[2].gettransaction(segwit_tx_list[i])[\"hex\"])\n-            assert(self.nodes[1].getrawtransaction(segwit_tx_list[i]) == self.nodes[2].gettransaction(segwit_tx_list[i])[\"hex\"])\n-            assert(self.nodes[0].getrawtransaction(segwit_tx_list[i]) == bytes_to_hex_str(tx.serialize_without_witness()))\n+            tx = FromHex(CTransaction(), self.nodes[2].gettransaction(txid=segwit_tx_list[i])[\"hex\"])\n+            assert(self.nodes[2].getrawtransaction(txid=segwit_tx_list[i]) != self.nodes[0].getrawtransaction(txid=segwit_tx_list[i]))\n+            assert(self.nodes[1].getrawtransaction(txid=segwit_tx_list[i], verbose=0) == self.nodes[2].getrawtransaction(txid=segwit_tx_list[i]))\n+            assert(self.nodes[0].getrawtransaction(txid=segwit_tx_list[i]) != self.nodes[2].gettransaction(txid=segwit_tx_list[i])[\"hex\"])\n+            assert(self.nodes[1].getrawtransaction(txid=segwit_tx_list[i]) == self.nodes[2].gettransaction(txid=segwit_tx_list[i])[\"hex\"])\n+            assert(self.nodes[0].getrawtransaction(txid=segwit_tx_list[i]) == bytes_to_hex_str(tx.serialize_without_witness()))\n \n         self.log.info(\"Verify witness txs without witness data are invalid after the fork\")\n         self.fail_mine(self.nodes[2], wit_ids[NODE_2][WIT_V0][2], False)\n@@ -240,8 +240,8 @@ def run_test(self):\n         self.success_mine(self.nodes[0], p2sh_ids[NODE_0][WIT_V1][0], True) #block 435\n \n         self.log.info(\"Verify sigops are counted in GBT with BIP141 rules after the fork\")\n-        txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n-        tmpl = self.nodes[0].getblocktemplate({'rules':['segwit']})\n+        txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1)\n+        tmpl = self.nodes[0].getblocktemplate(template_request={'rules':['segwit']})\n         assert(tmpl['sizelimit'] >= 3999577)  # actual maximum size is lower due to minimum mandatory non-witness data\n         assert(tmpl['weightlimit'] == 4000000)\n         assert(tmpl['sigoplimit'] == 80000)\n@@ -250,7 +250,7 @@ def run_test(self):\n \n         self.log.info(\"Non-segwit miners are not able to use GBT response after activation.\")\n         send_to_witness(1, self.nodes[0], find_unspent(self.nodes[0], 50), self.pubkey[0], False, Decimal(\"49.998\"))\n-        assert_raises_jsonrpc(-8, \"Support for 'segwit' rule requires explicit client support\", self.nodes[0].getblocktemplate, {})\n+        assert_raises_jsonrpc(-8, \"Support for 'segwit' rule requires explicit client support\", self.nodes[0].getblocktemplate, template_request={})\n \n         self.log.info(\"Verify behaviour of importaddress, addwitnessaddress and listunspent\")\n \n@@ -266,18 +266,18 @@ def run_test(self):\n         ]\n \n         # Import a compressed key and an uncompressed key, generate some multisig addresses\n-        self.nodes[0].importprivkey(\"92e6XLo5jVAVwrQKPNTs93oQco8f8sDNBcpv73Dsrs397fQtFQn\")\n+        self.nodes[0].importprivkey(privkey=\"92e6XLo5jVAVwrQKPNTs93oQco8f8sDNBcpv73Dsrs397fQtFQn\")\n         uncompressed_spendable_address = [\"mvozP4UwyGD2mGZU4D2eMvMLPB9WkMmMQu\"]\n-        self.nodes[0].importprivkey(\"cNC8eQ5dg3mFAVePDX4ddmPYpPbw41r9bm2jd1nLJT77e6RrzTRR\")\n+        self.nodes[0].importprivkey(privkey=\"cNC8eQ5dg3mFAVePDX4ddmPYpPbw41r9bm2jd1nLJT77e6RrzTRR\")\n         compressed_spendable_address = [\"mmWQubrDomqpgSYekvsU7HWEVjLFHAakLe\"]\n-        assert ((self.nodes[0].validateaddress(uncompressed_spendable_address[0])['iscompressed'] == False))\n-        assert ((self.nodes[0].validateaddress(compressed_spendable_address[0])['iscompressed'] == True))\n+        assert ((self.nodes[0].validateaddress(address=uncompressed_spendable_address[0])['iscompressed'] == False))\n+        assert ((self.nodes[0].validateaddress(address=compressed_spendable_address[0])['iscompressed'] == True))\n \n-        self.nodes[0].importpubkey(pubkeys[0])\n+        self.nodes[0].importpubkey(pubkey=pubkeys[0])\n         compressed_solvable_address = [key_to_p2pkh(pubkeys[0])]\n-        self.nodes[0].importpubkey(pubkeys[1])\n+        self.nodes[0].importpubkey(pubkey=pubkeys[1])\n         compressed_solvable_address.append(key_to_p2pkh(pubkeys[1]))\n-        self.nodes[0].importpubkey(pubkeys[2])\n+        self.nodes[0].importpubkey(pubkey=pubkeys[2])\n         uncompressed_solvable_address = [key_to_p2pkh(pubkeys[2])]\n \n         spendable_anytime = []                      # These outputs should be seen anytime after importprivkey and addmultisigaddress\n@@ -287,24 +287,24 @@ def run_test(self):\n         solvable_anytime = []                       # These outputs should be solvable after importpubkey\n         unseen_anytime = []                         # These outputs should never be seen\n \n-        uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [uncompressed_spendable_address[0], compressed_spendable_address[0]]))\n-        uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [uncompressed_spendable_address[0], uncompressed_spendable_address[0]]))\n-        compressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_spendable_address[0]]))\n-        uncompressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], uncompressed_solvable_address[0]]))\n-        compressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_solvable_address[0]]))\n-        compressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_solvable_address[0], compressed_solvable_address[1]]))\n+        uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(nrequired=2, keys=[uncompressed_spendable_address[0], compressed_spendable_address[0]]))\n+        uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(nrequired=2, keys=[uncompressed_spendable_address[0], uncompressed_spendable_address[0]]))\n+        compressed_spendable_address.append(self.nodes[0].addmultisigaddress(nrequired=2, keys=[compressed_spendable_address[0], compressed_spendable_address[0]]))\n+        uncompressed_solvable_address.append(self.nodes[0].addmultisigaddress(nrequired=2, keys=[compressed_spendable_address[0], uncompressed_solvable_address[0]]))\n+        compressed_solvable_address.append(self.nodes[0].addmultisigaddress(nrequired=2, keys=[compressed_spendable_address[0], compressed_solvable_address[0]]))\n+        compressed_solvable_address.append(self.nodes[0].addmultisigaddress(nrequired=2, keys=[compressed_solvable_address[0], compressed_solvable_address[1]]))\n         unknown_address = [\"mtKKyoHabkk6e4ppT7NaM7THqPUt7AzPrT\", \"2NDP3jLWAFT8NDAiUa9qiE6oBt2awmMq7Dx\"]\n \n         # Test multisig_without_privkey\n         # We have 2 public keys without private keys, use addmultisigaddress to add to wallet.\n         # Money sent to P2SH of multisig of this should only be seen after importaddress with the BASE58 P2SH address.\n \n-        multisig_without_privkey_address = self.nodes[0].addmultisigaddress(2, [pubkeys[3], pubkeys[4]])\n+        multisig_without_privkey_address = self.nodes[0].addmultisigaddress(nrequired=2, keys=[pubkeys[3], pubkeys[4]])\n         script = CScript([OP_2, hex_str_to_bytes(pubkeys[3]), hex_str_to_bytes(pubkeys[4]), OP_2, OP_CHECKMULTISIG])\n         solvable_after_importaddress.append(CScript([OP_HASH160, hash160(script), OP_EQUAL]))\n \n         for i in compressed_spendable_address:\n-            v = self.nodes[0].validateaddress(i)\n+            v = self.nodes[0].validateaddress(address=i)\n             if (v['isscript']):\n                 [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n                 # bare and p2sh multisig with compressed keys should always be spendable\n@@ -319,7 +319,7 @@ def run_test(self):\n                 spendable_after_importaddress.extend([p2wpkh, p2sh_p2wpkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh])\n \n         for i in uncompressed_spendable_address:\n-            v = self.nodes[0].validateaddress(i)\n+            v = self.nodes[0].validateaddress(address=i)\n             if (v['isscript']):\n                 [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n                 # bare and p2sh multisig with uncompressed keys should always be spendable\n@@ -336,7 +336,7 @@ def run_test(self):\n                 unseen_anytime.extend([p2wpkh, p2sh_p2wpkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh])\n \n         for i in compressed_solvable_address:\n-            v = self.nodes[0].validateaddress(i)\n+            v = self.nodes[0].validateaddress(address=i)\n             if (v['isscript']):\n                 # Multisig without private is not seen after addmultisigaddress, but seen after importaddress\n                 [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n@@ -349,7 +349,7 @@ def run_test(self):\n                 solvable_after_importaddress.extend([p2wpkh, p2sh_p2wpkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh])\n \n         for i in uncompressed_solvable_address:\n-            v = self.nodes[0].validateaddress(i)\n+            v = self.nodes[0].validateaddress(address=i)\n             if (v['isscript']):\n                 [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n                 # Base uncompressed multisig without private is not seen after addmultisigaddress, but seen after importaddress\n@@ -389,7 +389,7 @@ def run_test(self):\n \n         importlist = []\n         for i in compressed_spendable_address + uncompressed_spendable_address + compressed_solvable_address + uncompressed_solvable_address:\n-            v = self.nodes[0].validateaddress(i)\n+            v = self.nodes[0].validateaddress(address=i)\n             if (v['isscript']):\n                 bare = hex_str_to_bytes(v['hex'])\n                 importlist.append(bytes_to_hex_str(bare))\n@@ -411,12 +411,12 @@ def run_test(self):\n \n         for i in importlist:\n             try:\n-                self.nodes[0].importaddress(i,\"\",False,True)\n+                self.nodes[0].importaddress(address=i,label=\"\",rescan=False,p2sh=True)\n             except JSONRPCException as exp:\n                 assert_equal(exp.error[\"message\"], \"The wallet already contains the private key for this address or script\")\n \n-        self.nodes[0].importaddress(script_to_p2sh(op0)) # import OP_0 as address only\n-        self.nodes[0].importaddress(multisig_without_privkey_address) # Test multisig_without_privkey\n+        self.nodes[0].importaddress(address=script_to_p2sh(op0)) # import OP_0 as address only\n+        self.nodes[0].importaddress(address=multisig_without_privkey_address) # Test multisig_without_privkey\n \n         spendable_txid.append(self.mine_and_test_listunspent(spendable_anytime + spendable_after_importaddress, 2))\n         solvable_txid.append(self.mine_and_test_listunspent(solvable_anytime + solvable_after_importaddress, 1))\n@@ -429,16 +429,16 @@ def run_test(self):\n         # the multisig_without_privkey_address will fail because its keys were not added with importpubkey\n         for i in uncompressed_spendable_address + uncompressed_solvable_address + unknown_address + unsolvable_address + [multisig_without_privkey_address]:\n             try:\n-                self.nodes[0].addwitnessaddress(i)\n+                self.nodes[0].addwitnessaddress(address=i)\n             except JSONRPCException as exp:\n                 assert_equal(exp.error[\"message\"], \"Public key or redeemscript not known to wallet, or the key is uncompressed\")\n             else:\n                 assert(False)\n \n         for i in compressed_spendable_address + compressed_solvable_address:\n-            witaddress = self.nodes[0].addwitnessaddress(i)\n+            witaddress = self.nodes[0].addwitnessaddress(address=i)\n             # addwitnessaddress should return the same address if it is a known P2SH-witness address\n-            assert_equal(witaddress, self.nodes[0].addwitnessaddress(witaddress))\n+            assert_equal(witaddress, self.nodes[0].addwitnessaddress(address=witaddress))\n \n         spendable_txid.append(self.mine_and_test_listunspent(spendable_anytime + spendable_after_importaddress, 2))\n         solvable_txid.append(self.mine_and_test_listunspent(solvable_anytime + solvable_after_importaddress, 1))\n@@ -447,30 +447,30 @@ def run_test(self):\n \n         # Repeat some tests. This time we don't add witness scripts with importaddress\n         # Import a compressed key and an uncompressed key, generate some multisig addresses\n-        self.nodes[0].importprivkey(\"927pw6RW8ZekycnXqBQ2JS5nPyo1yRfGNN8oq74HeddWSpafDJH\")\n+        self.nodes[0].importprivkey(privkey=\"927pw6RW8ZekycnXqBQ2JS5nPyo1yRfGNN8oq74HeddWSpafDJH\")\n         uncompressed_spendable_address = [\"mguN2vNSCEUh6rJaXoAVwY3YZwZvEmf5xi\"]\n-        self.nodes[0].importprivkey(\"cMcrXaaUC48ZKpcyydfFo8PxHAjpsYLhdsp6nmtB3E2ER9UUHWnw\")\n+        self.nodes[0].importprivkey(privkey=\"cMcrXaaUC48ZKpcyydfFo8PxHAjpsYLhdsp6nmtB3E2ER9UUHWnw\")\n         compressed_spendable_address = [\"n1UNmpmbVUJ9ytXYXiurmGPQ3TRrXqPWKL\"]\n \n-        self.nodes[0].importpubkey(pubkeys[5])\n+        self.nodes[0].importpubkey(pubkey=pubkeys[5])\n         compressed_solvable_address = [key_to_p2pkh(pubkeys[5])]\n-        self.nodes[0].importpubkey(pubkeys[6])\n+        self.nodes[0].importpubkey(pubkey=pubkeys[6])\n         uncompressed_solvable_address = [key_to_p2pkh(pubkeys[6])]\n \n         spendable_after_addwitnessaddress = []      # These outputs should be seen after importaddress\n         solvable_after_addwitnessaddress=[]         # These outputs should be seen after importaddress but not spendable\n         unseen_anytime = []                         # These outputs should never be seen\n \n-        uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [uncompressed_spendable_address[0], compressed_spendable_address[0]]))\n-        uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [uncompressed_spendable_address[0], uncompressed_spendable_address[0]]))\n-        compressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_spendable_address[0]]))\n-        uncompressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_solvable_address[0], uncompressed_solvable_address[0]]))\n-        compressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_solvable_address[0]]))\n+        uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(nrequired=2, keys=[uncompressed_spendable_address[0], compressed_spendable_address[0]]))\n+        uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(nrequired=2, keys=[uncompressed_spendable_address[0], uncompressed_spendable_address[0]]))\n+        compressed_spendable_address.append(self.nodes[0].addmultisigaddress(nrequired=2, keys=[compressed_spendable_address[0], compressed_spendable_address[0]]))\n+        uncompressed_solvable_address.append(self.nodes[0].addmultisigaddress(nrequired=2, keys=[compressed_solvable_address[0], uncompressed_solvable_address[0]]))\n+        compressed_solvable_address.append(self.nodes[0].addmultisigaddress(nrequired=2, keys=[compressed_spendable_address[0], compressed_solvable_address[0]]))\n \n         premature_witaddress = []\n \n         for i in compressed_spendable_address:\n-            v = self.nodes[0].validateaddress(i)\n+            v = self.nodes[0].validateaddress(address=i)\n             if (v['isscript']):\n                 [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n                 # P2WSH and P2SH(P2WSH) multisig with compressed keys are spendable after addwitnessaddress\n@@ -483,7 +483,7 @@ def run_test(self):\n                 premature_witaddress.append(script_to_p2sh(p2wpkh))\n \n         for i in uncompressed_spendable_address + uncompressed_solvable_address:\n-            v = self.nodes[0].validateaddress(i)\n+            v = self.nodes[0].validateaddress(address=i)\n             if (v['isscript']):\n                 [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n                 # P2WSH and P2SH(P2WSH) multisig with uncompressed keys are never seen\n@@ -494,7 +494,7 @@ def run_test(self):\n                 unseen_anytime.extend([p2wpkh, p2sh_p2wpkh])\n \n         for i in compressed_solvable_address:\n-            v = self.nodes[0].validateaddress(i)\n+            v = self.nodes[0].validateaddress(address=i)\n             if (v['isscript']):\n                 # P2WSH multisig without private key are seen after addwitnessaddress\n                 [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n@@ -513,18 +513,18 @@ def run_test(self):\n         # premature_witaddress are not accepted until the script is added with addwitnessaddress first\n         for i in uncompressed_spendable_address + uncompressed_solvable_address + premature_witaddress + [compressed_solvable_address[1]]:\n             try:\n-                self.nodes[0].addwitnessaddress(i)\n+                self.nodes[0].addwitnessaddress(address=i)\n             except JSONRPCException as exp:\n                 assert_equal(exp.error[\"message\"], \"Public key or redeemscript not known to wallet, or the key is uncompressed\")\n             else:\n                 assert(False)\n \n         # after importaddress it should pass addwitnessaddress\n-        v = self.nodes[0].validateaddress(compressed_solvable_address[1])\n-        self.nodes[0].importaddress(v['hex'],\"\",False,True)\n+        v = self.nodes[0].validateaddress(address=compressed_solvable_address[1])\n+        self.nodes[0].importaddress(address=v['hex'],label=\"\",rescan=False,p2sh=True)\n         for i in compressed_spendable_address + compressed_solvable_address + premature_witaddress:\n-            witaddress = self.nodes[0].addwitnessaddress(i)\n-            assert_equal(witaddress, self.nodes[0].addwitnessaddress(witaddress))\n+            witaddress = self.nodes[0].addwitnessaddress(address=i)\n+            assert_equal(witaddress, self.nodes[0].addwitnessaddress(address=witaddress))\n \n         spendable_txid.append(self.mine_and_test_listunspent(spendable_after_addwitnessaddress, 2))\n         solvable_txid.append(self.mine_and_test_listunspent(solvable_after_addwitnessaddress, 1))\n@@ -534,12 +534,12 @@ def run_test(self):\n         self.create_and_mine_tx_from_txids(spendable_txid)\n \n         # import all the private keys so solvable addresses become spendable\n-        self.nodes[0].importprivkey(\"cPiM8Ub4heR9NBYmgVzJQiUH1if44GSBGiqaeJySuL2BKxubvgwb\")\n-        self.nodes[0].importprivkey(\"cPpAdHaD6VoYbW78kveN2bsvb45Q7G5PhaPApVUGwvF8VQ9brD97\")\n-        self.nodes[0].importprivkey(\"91zqCU5B9sdWxzMt1ca3VzbtVm2YM6Hi5Rxn4UDtxEaN9C9nzXV\")\n-        self.nodes[0].importprivkey(\"cPQFjcVRpAUBG8BA9hzr2yEzHwKoMgLkJZBBtK9vJnvGJgMjzTbd\")\n-        self.nodes[0].importprivkey(\"cQGtcm34xiLjB1v7bkRa4V3aAc9tS2UTuBZ1UnZGeSeNy627fN66\")\n-        self.nodes[0].importprivkey(\"cTW5mR5M45vHxXkeChZdtSPozrFwFgmEvTNnanCW6wrqwaCZ1X7K\")\n+        self.nodes[0].importprivkey(privkey=\"cPiM8Ub4heR9NBYmgVzJQiUH1if44GSBGiqaeJySuL2BKxubvgwb\")\n+        self.nodes[0].importprivkey(privkey=\"cPpAdHaD6VoYbW78kveN2bsvb45Q7G5PhaPApVUGwvF8VQ9brD97\")\n+        self.nodes[0].importprivkey(privkey=\"91zqCU5B9sdWxzMt1ca3VzbtVm2YM6Hi5Rxn4UDtxEaN9C9nzXV\")\n+        self.nodes[0].importprivkey(privkey=\"cPQFjcVRpAUBG8BA9hzr2yEzHwKoMgLkJZBBtK9vJnvGJgMjzTbd\")\n+        self.nodes[0].importprivkey(privkey=\"cQGtcm34xiLjB1v7bkRa4V3aAc9tS2UTuBZ1UnZGeSeNy627fN66\")\n+        self.nodes[0].importprivkey(privkey=\"cTW5mR5M45vHxXkeChZdtSPozrFwFgmEvTNnanCW6wrqwaCZ1X7K\")\n         self.create_and_mine_tx_from_txids(solvable_txid)\n \n     def mine_and_test_listunspent(self, script_list, ismine):\n@@ -549,9 +549,9 @@ def mine_and_test_listunspent(self, script_list, ismine):\n         for i in script_list:\n             tx.vout.append(CTxOut(10000000, i))\n         tx.rehash()\n-        signresults = self.nodes[0].signrawtransaction(bytes_to_hex_str(tx.serialize_without_witness()))['hex']\n-        txid = self.nodes[0].sendrawtransaction(signresults, True)\n-        self.nodes[0].generate(1)\n+        signresults = self.nodes[0].signrawtransaction(hexstring=bytes_to_hex_str(tx.serialize_without_witness()))['hex']\n+        txid = self.nodes[0].sendrawtransaction(hexstring=signresults, allowhighfees=True)\n+        self.nodes[0].generate(nblocks=1)\n         sync_blocks(self.nodes)\n         watchcount = 0\n         spendcount = 0\n@@ -594,16 +594,16 @@ def create_and_mine_tx_from_txids(self, txids, success = True):\n         tx = CTransaction()\n         for i in txids:\n             txtmp = CTransaction()\n-            txraw = self.nodes[0].getrawtransaction(i)\n+            txraw = self.nodes[0].getrawtransaction(txid=i)\n             f = BytesIO(hex_str_to_bytes(txraw))\n             txtmp.deserialize(f)\n             for j in range(len(txtmp.vout)):\n                 tx.vin.append(CTxIn(COutPoint(int('0x'+i,0), j)))\n         tx.vout.append(CTxOut(0, CScript()))\n         tx.rehash()\n-        signresults = self.nodes[0].signrawtransaction(bytes_to_hex_str(tx.serialize_without_witness()))['hex']\n-        self.nodes[0].sendrawtransaction(signresults, True)\n-        self.nodes[0].generate(1)\n+        signresults = self.nodes[0].signrawtransaction(hexstring=bytes_to_hex_str(tx.serialize_without_witness()))['hex']\n+        self.nodes[0].sendrawtransaction(hexstring=signresults, allowhighfees=True)\n+        self.nodes[0].generate(nblocks=1)\n         sync_blocks(self.nodes)\n \n "
      },
      {
        "sha": "0cfded8ec66e7b533f74a843e0cb66af2eea7e09",
        "filename": "qa/rpc-tests/test_framework/util.py",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/01217188c9e9281d0d1ad0e6a54035d52cfedaa9/qa/rpc-tests/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/01217188c9e9281d0d1ad0e6a54035d52cfedaa9/qa/rpc-tests/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/util.py?ref=01217188c9e9281d0d1ad0e6a54035d52cfedaa9",
        "patch": "@@ -136,7 +136,7 @@ def sync_blocks(rpc_connections, *, wait=1, timeout=60):\n     maxheight = max(x.getblockcount() for x in rpc_connections)\n     start_time = cur_time = time.time()\n     while cur_time <= start_time + timeout:\n-        tips = [r.waitforblockheight(maxheight, int(wait * 1000)) for r in rpc_connections]\n+        tips = [r.waitforblockheight(height=maxheight, timeout=int(wait * 1000)) for r in rpc_connections]\n         if all(t[\"height\"] == maxheight for t in tips):\n             if all(t[\"hash\"] == tips[0][\"hash\"] for t in tips):\n                 return\n@@ -279,7 +279,7 @@ def initialize_chain(test_dir, num_nodes, cachedir):\n             for peer in range(4):\n                 for j in range(25):\n                     set_node_times(rpcs, block_time)\n-                    rpcs[peer].generate(1)\n+                    rpcs[peer].generate(nblocks=1)\n                     block_time += 10*60\n                 # Must sync before next peer starts generating blocks\n                 sync_blocks(rpcs)\n@@ -383,11 +383,11 @@ def stop_nodes(nodes):\n \n def set_node_times(nodes, t):\n     for node in nodes:\n-        node.setmocktime(t)\n+        node.setmocktime(timestamp=t)\n \n def connect_nodes(from_connection, node_num):\n     ip_port = \"127.0.0.1:\"+str(p2p_port(node_num))\n-    from_connection.addnode(ip_port, \"onetry\")\n+    from_connection.addnode(node=ip_port, command=\"onetry\")\n     # poll until version handshake complete to avoid race conditions\n     # with transaction relaying\n     while any(peer['version'] == 0 for peer in from_connection.getpeerinfo()):\n@@ -578,7 +578,7 @@ def satoshi_round(amount):\n # Helper to create at least \"count\" utxos\n # Pass in a fee that is sufficient for relay and mining new transactions.\n def create_confirmed_utxos(fee, node, count):\n-    node.generate(int(0.5*count)+101)\n+    node.generate(nblocks=int(0.5*count)+101)\n     utxos = node.listunspent()\n     iterations = count - len(utxos)\n     addr1 = node.getnewaddress()\n@@ -598,7 +598,7 @@ def create_confirmed_utxos(fee, node, count):\n         txid = node.sendrawtransaction(signed_tx)\n \n     while (node.getmempoolinfo()['size'] > 0):\n-        node.generate(1)\n+        node.generate(nblocks=1)\n \n     utxos = node.listunspent()\n     assert(len(utxos) >= count)\n@@ -663,7 +663,7 @@ def mine_large_block(node, utxos=None):\n         utxos.extend(node.listunspent())\n     fee = 100 * node.getnetworkinfo()[\"relayfee\"]\n     create_lots_of_big_transactions(node, txouts, utxos, num, fee=fee)\n-    node.generate(1)\n+    node.generate(nblocks=1)\n \n def get_bip9_status(node, key):\n     info = node.getblockchaininfo()"
      }
    ]
  }
]