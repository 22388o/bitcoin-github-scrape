[
  {
    "sha": "999e4c91c2cd93f4cd8760b3572780c9d568f2f0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5OTllNGM5MWMyY2Q5M2Y0Y2Q4NzYwYjM1NzI3ODBjOWQ1NjhmMmYw",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-09-18T06:23:29Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-10-19T14:17:33Z"
      },
      "message": "wallet: Change CCrypter to use vectors with secure allocator\n\nChange CCrypter to use vectors with secure allocator instead of buffers\non in the object itself which will end up on the stack. This avoids\nhaving to call LockedPageManager to lock stack memory pages to prevent the\nmemory from being swapped to disk. This is wasteful.",
      "tree": {
        "sha": "6a7abfb39a4a697f84fa63ed600a60c1e5079618",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6a7abfb39a4a697f84fa63ed600a60c1e5079618"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/999e4c91c2cd93f4cd8760b3572780c9d568f2f0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/999e4c91c2cd93f4cd8760b3572780c9d568f2f0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/999e4c91c2cd93f4cd8760b3572780c9d568f2f0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/999e4c91c2cd93f4cd8760b3572780c9d568f2f0/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "97c7f7362f9b59247753d6e8fa8022a6205f9c09",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/97c7f7362f9b59247753d6e8fa8022a6205f9c09",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/97c7f7362f9b59247753d6e8fa8022a6205f9c09"
      }
    ],
    "stats": {
      "total": 45,
      "additions": 19,
      "deletions": 26
    },
    "files": [
      {
        "sha": "31ee060677104bbc231018354a82277ae5c834ea",
        "filename": "src/wallet/crypter.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/999e4c91c2cd93f4cd8760b3572780c9d568f2f0/src/wallet/crypter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/999e4c91c2cd93f4cd8760b3572780c9d568f2f0/src/wallet/crypter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/crypter.cpp?ref=999e4c91c2cd93f4cd8760b3572780c9d568f2f0",
        "patch": "@@ -48,12 +48,12 @@ bool CCrypter::SetKeyFromPassphrase(const SecureString& strKeyData, const std::v\n \n     int i = 0;\n     if (nDerivationMethod == 0)\n-        i = BytesToKeySHA512AES(chSalt, strKeyData, nRounds, chKey, chIV);\n+        i = BytesToKeySHA512AES(chSalt, strKeyData, nRounds, vchKey.data(), vchIV.data());\n \n     if (i != (int)WALLET_CRYPTO_KEY_SIZE)\n     {\n-        memory_cleanse(chKey, sizeof(chKey));\n-        memory_cleanse(chIV, sizeof(chIV));\n+        memory_cleanse(vchKey.data(), vchKey.size());\n+        memory_cleanse(vchIV.data(), vchIV.size());\n         return false;\n     }\n \n@@ -66,8 +66,8 @@ bool CCrypter::SetKey(const CKeyingMaterial& chNewKey, const std::vector<unsigne\n     if (chNewKey.size() != WALLET_CRYPTO_KEY_SIZE || chNewIV.size() != WALLET_CRYPTO_IV_SIZE)\n         return false;\n \n-    memcpy(&chKey[0], &chNewKey[0], sizeof chKey);\n-    memcpy(&chIV[0], &chNewIV[0], sizeof chIV);\n+    memcpy(vchKey.data(), chNewKey.data(), chNewKey.size());\n+    memcpy(vchIV.data(), chNewIV.data(), chNewIV.size());\n \n     fKeySet = true;\n     return true;\n@@ -82,7 +82,7 @@ bool CCrypter::Encrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned\n     // n + AES_BLOCKSIZE bytes\n     vchCiphertext.resize(vchPlaintext.size() + AES_BLOCKSIZE);\n \n-    AES256CBCEncrypt enc(chKey, chIV, true);\n+    AES256CBCEncrypt enc(vchKey.data(), vchIV.data(), true);\n     size_t nLen = enc.Encrypt(&vchPlaintext[0], vchPlaintext.size(), &vchCiphertext[0]);\n     if(nLen < vchPlaintext.size())\n         return false;\n@@ -101,7 +101,7 @@ bool CCrypter::Decrypt(const std::vector<unsigned char>& vchCiphertext, CKeyingM\n \n     vchPlaintext.resize(nLen);\n \n-    AES256CBCDecrypt dec(chKey, chIV, true);\n+    AES256CBCDecrypt dec(vchKey.data(), vchIV.data(), true);\n     nLen = dec.Decrypt(&vchCiphertext[0], vchCiphertext.size(), &vchPlaintext[0]);\n     if(nLen == 0)\n         return false;"
      },
      {
        "sha": "f00f7fa7315b1c4808619bc6c5a54aa77021d9bf",
        "filename": "src/wallet/crypter.h",
        "status": "modified",
        "additions": 6,
        "deletions": 13,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/999e4c91c2cd93f4cd8760b3572780c9d568f2f0/src/wallet/crypter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/999e4c91c2cd93f4cd8760b3572780c9d568f2f0/src/wallet/crypter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/crypter.h?ref=999e4c91c2cd93f4cd8760b3572780c9d568f2f0",
        "patch": "@@ -77,8 +77,8 @@ class CCrypter\n {\n friend class wallet_crypto::TestCrypter; // for test access to chKey/chIV\n private:\n-    unsigned char chKey[WALLET_CRYPTO_KEY_SIZE];\n-    unsigned char chIV[WALLET_CRYPTO_IV_SIZE];\n+    std::vector<unsigned char, secure_allocator<unsigned char>> vchKey;\n+    std::vector<unsigned char, secure_allocator<unsigned char>> vchIV;\n     bool fKeySet;\n \n     int BytesToKeySHA512AES(const std::vector<unsigned char>& chSalt, const SecureString& strKeyData, int count, unsigned char *key,unsigned char *iv) const;\n@@ -91,28 +91,21 @@ friend class wallet_crypto::TestCrypter; // for test access to chKey/chIV\n \n     void CleanKey()\n     {\n-        memory_cleanse(chKey, sizeof(chKey));\n-        memory_cleanse(chIV, sizeof(chIV));\n+        memory_cleanse(vchKey.data(), vchKey.size());\n+        memory_cleanse(vchIV.data(), vchIV.size());\n         fKeySet = false;\n     }\n \n     CCrypter()\n     {\n         fKeySet = false;\n-\n-        // Try to keep the key data out of swap (and be a bit over-careful to keep the IV that we don't even use out of swap)\n-        // Note that this does nothing about suspend-to-disk (which will put all our key data on disk)\n-        // Note as well that at no point in this program is any attempt made to prevent stealing of keys by reading the memory of the running process.\n-        LockedPageManager::Instance().LockRange(&chKey[0], sizeof chKey);\n-        LockedPageManager::Instance().LockRange(&chIV[0], sizeof chIV);\n+        vchKey.resize(WALLET_CRYPTO_KEY_SIZE);\n+        vchIV.resize(WALLET_CRYPTO_IV_SIZE);\n     }\n \n     ~CCrypter()\n     {\n         CleanKey();\n-\n-        LockedPageManager::Instance().UnlockRange(&chKey[0], sizeof chKey);\n-        LockedPageManager::Instance().UnlockRange(&chIV[0], sizeof chIV);\n     }\n };\n "
      },
      {
        "sha": "ce35c53c48737b7461fceab32144dbccf4540b82",
        "filename": "src/wallet/test/crypto_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/999e4c91c2cd93f4cd8760b3572780c9d568f2f0/src/wallet/test/crypto_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/999e4c91c2cd93f4cd8760b3572780c9d568f2f0/src/wallet/test/crypto_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/crypto_tests.cpp?ref=999e4c91c2cd93f4cd8760b3572780c9d568f2f0",
        "patch": "@@ -97,10 +97,10 @@ static void TestPassphraseSingle(const std::vector<unsigned char>& vchSalt, cons\n \n     OldSetKeyFromPassphrase(passphrase, vchSalt, rounds, 0, chKey, chIV);\n \n-    BOOST_CHECK_MESSAGE(memcmp(chKey, crypt.chKey, sizeof(chKey)) == 0, \\\n-        HexStr(chKey, chKey+sizeof(chKey)) + std::string(\" != \") + HexStr(crypt.chKey, crypt.chKey + (sizeof crypt.chKey)));\n-    BOOST_CHECK_MESSAGE(memcmp(chIV, crypt.chIV, sizeof(chIV)) == 0, \\\n-        HexStr(chIV, chIV+sizeof(chIV)) + std::string(\" != \") + HexStr(crypt.chIV, crypt.chIV + (sizeof crypt.chIV)));\n+    BOOST_CHECK_MESSAGE(memcmp(chKey, crypt.vchKey.data(), crypt.vchKey.size()) == 0, \\\n+        HexStr(chKey, chKey+sizeof(chKey)) + std::string(\" != \") + HexStr(crypt.vchKey));\n+    BOOST_CHECK_MESSAGE(memcmp(chIV, crypt.vchIV.data(), crypt.vchIV.size()) == 0, \\\n+        HexStr(chIV, chIV+sizeof(chIV)) + std::string(\" != \") + HexStr(crypt.vchIV));\n \n     if(!correctKey.empty())\n         BOOST_CHECK_MESSAGE(memcmp(chKey, &correctKey[0], sizeof(chKey)) == 0, \\\n@@ -127,7 +127,7 @@ static void TestDecrypt(const CCrypter& crypt, const std::vector<unsigned char>&\n     CKeyingMaterial vchDecrypted2;\n     int result1, result2;\n     result1 = crypt.Decrypt(vchCiphertext, vchDecrypted1);\n-    result2 = OldDecrypt(vchCiphertext, vchDecrypted2, crypt.chKey, crypt.chIV);\n+    result2 = OldDecrypt(vchCiphertext, vchDecrypted2, crypt.vchKey.data(), crypt.vchIV.data());\n     BOOST_CHECK(result1 == result2);\n \n     // These two should be equal. However, OpenSSL 1.0.1j introduced a change\n@@ -152,7 +152,7 @@ static void TestEncryptSingle(const CCrypter& crypt, const CKeyingMaterial& vchP\n     std::vector<unsigned char> vchCiphertext2;\n     int result1 = crypt.Encrypt(vchPlaintext, vchCiphertext1);\n \n-    int result2 = OldEncrypt(vchPlaintext, vchCiphertext2, crypt.chKey, crypt.chIV);\n+    int result2 = OldEncrypt(vchPlaintext, vchCiphertext2, crypt.vchKey.data(), crypt.vchIV.data());\n     BOOST_CHECK(result1 == result2);\n     BOOST_CHECK(vchCiphertext1 == vchCiphertext2);\n "
      }
    ]
  },
  {
    "sha": "f4d1fc259b5a62580d952c180b1189ccaa6af1bc",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNGQxZmMyNTliNWE2MjU4MGQ5NTJjMTgwYjExODljY2FhNmFmMWJj",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-09-18T06:40:14Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-10-19T14:17:33Z"
      },
      "message": "wallet: Get rid of LockObject and UnlockObject calls in key.h\n\nReplace these with vectors allocated from the secure allocator.\n\nThis avoids mlock syscall churn on stack pages, as well as makes\nit possible to get rid of these functions.\n\nPlease review this commit and the previous one carefully that\nno `sizeof(vectortype)` remains in the memcpys and memcmps usage\n(ick!), and `.data()` or `&vec[x]` is used as appropriate instead of\n&vec.",
      "tree": {
        "sha": "38a7786c54effd74d44d04e0394eccc987fca24a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/38a7786c54effd74d44d04e0394eccc987fca24a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f4d1fc259b5a62580d952c180b1189ccaa6af1bc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f4d1fc259b5a62580d952c180b1189ccaa6af1bc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f4d1fc259b5a62580d952c180b1189ccaa6af1bc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f4d1fc259b5a62580d952c180b1189ccaa6af1bc/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "999e4c91c2cd93f4cd8760b3572780c9d568f2f0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/999e4c91c2cd93f4cd8760b3572780c9d568f2f0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/999e4c91c2cd93f4cd8760b3572780c9d568f2f0"
      }
    ],
    "stats": {
      "total": 78,
      "additions": 23,
      "deletions": 55
    },
    "files": [
      {
        "sha": "b3ea98fb92e6dfad91f148a5c5ec5095713d26ca",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 20,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4d1fc259b5a62580d952c180b1189ccaa6af1bc/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4d1fc259b5a62580d952c180b1189ccaa6af1bc/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=f4d1fc259b5a62580d952c180b1189ccaa6af1bc",
        "patch": "@@ -125,8 +125,8 @@ bool CKey::Check(const unsigned char *vch) {\n \n void CKey::MakeNewKey(bool fCompressedIn) {\n     do {\n-        GetStrongRandBytes(vch, sizeof(vch));\n-    } while (!Check(vch));\n+        GetStrongRandBytes(keydata.data(), keydata.size());\n+    } while (!Check(keydata.data()));\n     fValid = true;\n     fCompressed = fCompressedIn;\n }\n@@ -224,20 +224,18 @@ bool CKey::Load(CPrivKey &privkey, CPubKey &vchPubKey, bool fSkipCheck=false) {\n bool CKey::Derive(CKey& keyChild, ChainCode &ccChild, unsigned int nChild, const ChainCode& cc) const {\n     assert(IsValid());\n     assert(IsCompressed());\n-    unsigned char out[64];\n-    LockObject(out);\n+    std::vector<unsigned char, secure_allocator<unsigned char>> vout(64);\n     if ((nChild >> 31) == 0) {\n         CPubKey pubkey = GetPubKey();\n         assert(pubkey.begin() + 33 == pubkey.end());\n-        BIP32Hash(cc, nChild, *pubkey.begin(), pubkey.begin()+1, out);\n+        BIP32Hash(cc, nChild, *pubkey.begin(), pubkey.begin()+1, vout.data());\n     } else {\n         assert(begin() + 32 == end());\n-        BIP32Hash(cc, nChild, 0, begin(), out);\n+        BIP32Hash(cc, nChild, 0, begin(), vout.data());\n     }\n-    memcpy(ccChild.begin(), out+32, 32);\n+    memcpy(ccChild.begin(), vout.data()+32, 32);\n     memcpy((unsigned char*)keyChild.begin(), begin(), 32);\n-    bool ret = secp256k1_ec_privkey_tweak_add(secp256k1_context_sign, (unsigned char*)keyChild.begin(), out);\n-    UnlockObject(out);\n+    bool ret = secp256k1_ec_privkey_tweak_add(secp256k1_context_sign, (unsigned char*)keyChild.begin(), vout.data());\n     keyChild.fCompressed = true;\n     keyChild.fValid = ret;\n     return ret;\n@@ -253,12 +251,10 @@ bool CExtKey::Derive(CExtKey &out, unsigned int _nChild) const {\n \n void CExtKey::SetMaster(const unsigned char *seed, unsigned int nSeedLen) {\n     static const unsigned char hashkey[] = {'B','i','t','c','o','i','n',' ','s','e','e','d'};\n-    unsigned char out[64];\n-    LockObject(out);\n-    CHMAC_SHA512(hashkey, sizeof(hashkey)).Write(seed, nSeedLen).Finalize(out);\n-    key.Set(&out[0], &out[32], true);\n-    memcpy(chaincode.begin(), &out[32], 32);\n-    UnlockObject(out);\n+    std::vector<unsigned char, secure_allocator<unsigned char>> vout(64);\n+    CHMAC_SHA512(hashkey, sizeof(hashkey)).Write(seed, nSeedLen).Finalize(vout.data());\n+    key.Set(&vout[0], &vout[32], true);\n+    memcpy(chaincode.begin(), &vout[32], 32);\n     nDepth = 0;\n     nChild = 0;\n     memset(vchFingerprint, 0, sizeof(vchFingerprint));\n@@ -308,12 +304,10 @@ void ECC_Start() {\n \n     {\n         // Pass in a random blinding seed to the secp256k1 context.\n-        unsigned char seed[32];\n-        LockObject(seed);\n-        GetRandBytes(seed, 32);\n-        bool ret = secp256k1_context_randomize(ctx, seed);\n+        std::vector<unsigned char, secure_allocator<unsigned char>> vseed(32);\n+        GetRandBytes(vseed.data(), 32);\n+        bool ret = secp256k1_context_randomize(ctx, vseed.data());\n         assert(ret);\n-        UnlockObject(seed);\n     }\n \n     secp256k1_context_sign = ctx;"
      },
      {
        "sha": "48a07d62c9ccd170f1d0be81fd1c8bf4cd320a28",
        "filename": "src/key.h",
        "status": "modified",
        "additions": 9,
        "deletions": 18,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4d1fc259b5a62580d952c180b1189ccaa6af1bc/src/key.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4d1fc259b5a62580d952c180b1189ccaa6af1bc/src/key.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.h?ref=f4d1fc259b5a62580d952c180b1189ccaa6af1bc",
        "patch": "@@ -43,9 +43,7 @@ class CKey\n     bool fCompressed;\n \n     //! The actual byte data\n-    unsigned char vch[32];\n-\n-    static_assert(sizeof(vch) == 32, \"vch must be 32 bytes in length to not break serialization\");\n+    std::vector<unsigned char, secure_allocator<unsigned char> > keydata;\n \n     //! Check whether the 32-byte array pointed to be vch is valid keydata.\n     bool static Check(const unsigned char* vch);\n@@ -54,37 +52,30 @@ class CKey\n     //! Construct an invalid private key.\n     CKey() : fValid(false), fCompressed(false)\n     {\n-        LockObject(vch);\n-    }\n-\n-    //! Copy constructor. This is necessary because of memlocking.\n-    CKey(const CKey& secret) : fValid(secret.fValid), fCompressed(secret.fCompressed)\n-    {\n-        LockObject(vch);\n-        memcpy(vch, secret.vch, sizeof(vch));\n+        // Important: vch must be 32 bytes in length to not break serialization\n+        keydata.resize(32);\n     }\n \n     //! Destructor (again necessary because of memlocking).\n     ~CKey()\n     {\n-        UnlockObject(vch);\n     }\n \n     friend bool operator==(const CKey& a, const CKey& b)\n     {\n         return a.fCompressed == b.fCompressed &&\n             a.size() == b.size() &&\n-            memcmp(&a.vch[0], &b.vch[0], a.size()) == 0;\n+            memcmp(a.keydata.data(), b.keydata.data(), a.size()) == 0;\n     }\n \n     //! Initialize using begin and end iterators to byte data.\n     template <typename T>\n     void Set(const T pbegin, const T pend, bool fCompressedIn)\n     {\n-        if (pend - pbegin != sizeof(vch)) {\n+        if (size_t(pend - pbegin) != keydata.size()) {\n             fValid = false;\n         } else if (Check(&pbegin[0])) {\n-            memcpy(vch, (unsigned char*)&pbegin[0], sizeof(vch));\n+            memcpy(keydata.data(), (unsigned char*)&pbegin[0], keydata.size());\n             fValid = true;\n             fCompressed = fCompressedIn;\n         } else {\n@@ -93,9 +84,9 @@ class CKey\n     }\n \n     //! Simple read-only vector-like interface.\n-    unsigned int size() const { return (fValid ? sizeof(vch) : 0); }\n-    const unsigned char* begin() const { return vch; }\n-    const unsigned char* end() const { return vch + size(); }\n+    unsigned int size() const { return (fValid ? keydata.size() : 0); }\n+    const unsigned char* begin() const { return keydata.data(); }\n+    const unsigned char* end() const { return keydata.data() + size(); }\n \n     //! Check whether this private key is valid.\n     bool IsValid() const { return fValid; }"
      },
      {
        "sha": "042144fad5614e976e06d93a10950be5eb10e13e",
        "filename": "src/support/pagelocker.h",
        "status": "modified",
        "additions": 0,
        "deletions": 17,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4d1fc259b5a62580d952c180b1189ccaa6af1bc/src/support/pagelocker.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4d1fc259b5a62580d952c180b1189ccaa6af1bc/src/support/pagelocker.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/pagelocker.h?ref=f4d1fc259b5a62580d952c180b1189ccaa6af1bc",
        "patch": "@@ -157,21 +157,4 @@ class LockedPageManager : public LockedPageManagerBase<MemoryPageLocker>\n     static boost::once_flag init_flag;\n };\n \n-//\n-// Functions for directly locking/unlocking memory objects.\n-// Intended for non-dynamically allocated structures.\n-//\n-template <typename T>\n-void LockObject(const T& t)\n-{\n-    LockedPageManager::Instance().LockRange((void*)(&t), sizeof(T));\n-}\n-\n-template <typename T>\n-void UnlockObject(const T& t)\n-{\n-    memory_cleanse((void*)(&t), sizeof(T));\n-    LockedPageManager::Instance().UnlockRange((void*)(&t), sizeof(T));\n-}\n-\n #endif // BITCOIN_SUPPORT_PAGELOCKER_H"
      }
    ]
  },
  {
    "sha": "4536148b15595229d0563fb60913b23cb78788ed",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NTM2MTQ4YjE1NTk1MjI5ZDA1NjNmYjYwOTEzYjIzY2I3ODc4OGVk",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-09-18T07:55:14Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-10-27T11:17:25Z"
      },
      "message": "support: Add LockedPool\n\nAdd a pool for locked memory chunks, replacing LockedPageManager.\n\nThis is something I've been wanting to do for a long time. The current\napproach of locking objects where they happen to be on the stack or heap\nin-place causes a lot of mlock/munlock system call overhead, slowing\ndown any handling of keys.\n\nAlso locked memory is a limited resource on many operating systems (and\nusing a lot of it bogs down the system), so the previous approach of\nlocking every page that may contain any key information (but also other\ninformation) is wasteful.",
      "tree": {
        "sha": "a59197c39e82d2d16e78ed85940e18227c4105b5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a59197c39e82d2d16e78ed85940e18227c4105b5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4536148b15595229d0563fb60913b23cb78788ed",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4536148b15595229d0563fb60913b23cb78788ed",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4536148b15595229d0563fb60913b23cb78788ed",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4536148b15595229d0563fb60913b23cb78788ed/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f4d1fc259b5a62580d952c180b1189ccaa6af1bc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f4d1fc259b5a62580d952c180b1189ccaa6af1bc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f4d1fc259b5a62580d952c180b1189ccaa6af1bc"
      }
    ],
    "stats": {
      "total": 1160,
      "additions": 832,
      "deletions": 328
    },
    "files": [
      {
        "sha": "54abd2ce46936862e5934b832ff5e4914a50fca2",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4536148b15595229d0563fb60913b23cb78788ed/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4536148b15595229d0563fb60913b23cb78788ed/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=4536148b15595229d0563fb60913b23cb78788ed",
        "patch": "@@ -133,7 +133,7 @@ BITCOIN_CORE_H = \\\n   support/allocators/secure.h \\\n   support/allocators/zeroafterfree.h \\\n   support/cleanse.h \\\n-  support/pagelocker.h \\\n+  support/lockedpool.h \\\n   sync.h \\\n   threadsafety.h \\\n   timedata.h \\\n@@ -310,7 +310,7 @@ libbitcoin_common_a_SOURCES = \\\n libbitcoin_util_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n libbitcoin_util_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_util_a_SOURCES = \\\n-  support/pagelocker.cpp \\\n+  support/lockedpool.cpp \\\n   chainparamsbase.cpp \\\n   clientversion.cpp \\\n   compat/glibc_sanity.cpp \\"
      },
      {
        "sha": "67064314ef1fb42e62b5f439cdfa453178d318d1",
        "filename": "src/support/allocators/secure.h",
        "status": "modified",
        "additions": 4,
        "deletions": 8,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4536148b15595229d0563fb60913b23cb78788ed/src/support/allocators/secure.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4536148b15595229d0563fb60913b23cb78788ed/src/support/allocators/secure.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/allocators/secure.h?ref=4536148b15595229d0563fb60913b23cb78788ed",
        "patch": "@@ -6,7 +6,8 @@\n #ifndef BITCOIN_SUPPORT_ALLOCATORS_SECURE_H\n #define BITCOIN_SUPPORT_ALLOCATORS_SECURE_H\n \n-#include \"support/pagelocker.h\"\n+#include \"support/lockedpool.h\"\n+#include \"support/cleanse.h\"\n \n #include <string>\n \n@@ -39,20 +40,15 @@ struct secure_allocator : public std::allocator<T> {\n \n     T* allocate(std::size_t n, const void* hint = 0)\n     {\n-        T* p;\n-        p = std::allocator<T>::allocate(n, hint);\n-        if (p != NULL)\n-            LockedPageManager::Instance().LockRange(p, sizeof(T) * n);\n-        return p;\n+        return static_cast<T*>(LockedPoolManager::Instance().alloc(sizeof(T) * n));\n     }\n \n     void deallocate(T* p, std::size_t n)\n     {\n         if (p != NULL) {\n             memory_cleanse(p, sizeof(T) * n);\n-            LockedPageManager::Instance().UnlockRange(p, sizeof(T) * n);\n         }\n-        std::allocator<T>::deallocate(p, n);\n+        LockedPoolManager::Instance().free(p);\n     }\n };\n "
      },
      {
        "sha": "63050f006b0536f640159f2d09f28fe1e1565483",
        "filename": "src/support/lockedpool.cpp",
        "status": "added",
        "additions": 383,
        "deletions": 0,
        "changes": 383,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4536148b15595229d0563fb60913b23cb78788ed/src/support/lockedpool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4536148b15595229d0563fb60913b23cb78788ed/src/support/lockedpool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/lockedpool.cpp?ref=4536148b15595229d0563fb60913b23cb78788ed",
        "patch": "@@ -0,0 +1,383 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"support/lockedpool.h\"\n+#include \"support/cleanse.h\"\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#ifdef WIN32\n+#ifdef _WIN32_WINNT\n+#undef _WIN32_WINNT\n+#endif\n+#define _WIN32_WINNT 0x0501\n+#define WIN32_LEAN_AND_MEAN 1\n+#ifndef NOMINMAX\n+#define NOMINMAX\n+#endif\n+#include <windows.h>\n+#else\n+#include <sys/mman.h> // for mmap\n+#include <sys/resource.h> // for getrlimit\n+#include <limits.h> // for PAGESIZE\n+#include <unistd.h> // for sysconf\n+#endif\n+\n+LockedPoolManager* LockedPoolManager::_instance = NULL;\n+std::once_flag LockedPoolManager::init_flag;\n+\n+/*******************************************************************************/\n+// Utilities\n+//\n+/** Align up to power of 2 */\n+static inline size_t align_up(size_t x, size_t align)\n+{\n+    return (x + align - 1) & ~(align - 1);\n+}\n+\n+/*******************************************************************************/\n+// Implementation: Arena\n+\n+Arena::Arena(void *base_in, size_t size_in, size_t alignment_in):\n+    base(static_cast<char*>(base_in)), end(static_cast<char*>(base_in) + size_in), alignment(alignment_in)\n+{\n+    // Start with one free chunk that covers the entire arena\n+    chunks.emplace(base, Chunk(size_in, false));\n+}\n+\n+Arena::~Arena()\n+{\n+}\n+\n+void* Arena::alloc(size_t size)\n+{\n+    // Round to next multiple of alignment\n+    size = align_up(size, alignment);\n+\n+    // Don't handle zero-sized chunks, or those bigger than MAX_SIZE\n+    if (size == 0 || size >= Chunk::MAX_SIZE) {\n+        return nullptr;\n+    }\n+\n+    for (auto& chunk: chunks) {\n+        if (!chunk.second.isInUse() && size <= chunk.second.getSize()) {\n+            char* base = chunk.first;\n+            size_t leftover = chunk.second.getSize() - size;\n+            if (leftover > 0) { // Split chunk\n+                chunks.emplace(base + size, Chunk(leftover, false));\n+                chunk.second.setSize(size);\n+            }\n+            chunk.second.setInUse(true);\n+            return reinterpret_cast<void*>(base);\n+        }\n+    }\n+    return nullptr;\n+}\n+\n+void Arena::free(void *ptr)\n+{\n+    // Freeing the NULL pointer is OK.\n+    if (ptr == nullptr) {\n+        return;\n+    }\n+    auto i = chunks.find(static_cast<char*>(ptr));\n+    if (i == chunks.end() || !i->second.isInUse()) {\n+        throw std::runtime_error(\"Arena: invalid or double free\");\n+    }\n+\n+    i->second.setInUse(false);\n+\n+    if (i != chunks.begin()) { // Absorb into previous chunk if exists and free\n+        auto prev = i;\n+        --prev;\n+        if (!prev->second.isInUse()) {\n+            // Absorb current chunk size into previous chunk.\n+            prev->second.setSize(prev->second.getSize() + i->second.getSize());\n+            // Erase current chunk. Erasing does not invalidate current\n+            // iterators for a map, except for that pointing to the object\n+            // itself, which will be overwritten in the next statement.\n+            chunks.erase(i);\n+            // From here on, the previous chunk is our current chunk.\n+            i = prev;\n+        }\n+    }\n+    auto next = i;\n+    ++next;\n+    if (next != chunks.end()) { // Absorb next chunk if exists and free\n+        if (!next->second.isInUse()) {\n+            // Absurb next chunk size into current chunk\n+            i->second.setSize(i->second.getSize() + next->second.getSize());\n+            // Erase next chunk.\n+            chunks.erase(next);\n+        }\n+    }\n+}\n+\n+Arena::Stats Arena::stats() const\n+{\n+    Arena::Stats r;\n+    r.used = r.free = r.total = r.chunks_used = r.chunks_free = 0;\n+    for (const auto& chunk: chunks) {\n+        if (chunk.second.isInUse()) {\n+            r.used += chunk.second.getSize();\n+            r.chunks_used += 1;\n+        } else {\n+            r.free += chunk.second.getSize();\n+            r.chunks_free += 1;\n+        }\n+        r.total += chunk.second.getSize();\n+    }\n+    return r;\n+}\n+\n+#ifdef ARENA_DEBUG\n+void Arena::walk() const\n+{\n+    for (const auto& chunk: chunks) {\n+        std::cout <<\n+            \"0x\" << std::hex << std::setw(16) << std::setfill('0') << chunk.first <<\n+            \" 0x\" << std::hex << std::setw(16) << std::setfill('0') << chunk.second.getSize() <<\n+            \" 0x\" << chunk.second.isInUse() << std::endl;\n+    }\n+    std::cout << std::endl;\n+}\n+#endif\n+\n+/*******************************************************************************/\n+// Implementation: Win32LockedPageAllocator\n+\n+#ifdef WIN32\n+/** LockedPageAllocator specialized for Windows.\n+ */\n+class Win32LockedPageAllocator: public LockedPageAllocator\n+{\n+public:\n+    Win32LockedPageAllocator();\n+    void* AllocateLocked(size_t len, bool *lockingSuccess);\n+    void FreeLocked(void* addr, size_t len);\n+    size_t GetLimit();\n+private:\n+    size_t page_size;\n+};\n+\n+Win32LockedPageAllocator::Win32LockedPageAllocator()\n+{\n+    // Determine system page size in bytes\n+    SYSTEM_INFO sSysInfo;\n+    GetSystemInfo(&sSysInfo);\n+    page_size = sSysInfo.dwPageSize;\n+}\n+void *Win32LockedPageAllocator::AllocateLocked(size_t len, bool *lockingSuccess)\n+{\n+    len = align_up(len, page_size);\n+    void *addr = VirtualAlloc(nullptr, len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n+    if (addr) {\n+        // VirtualLock is used to attempt to keep keying material out of swap. Note\n+        // that it does not provide this as a guarantee, but, in practice, memory\n+        // that has been VirtualLock'd almost never gets written to the pagefile\n+        // except in rare circumstances where memory is extremely low.\n+        *lockingSuccess = VirtualLock(const_cast<void*>(addr), len) != 0;\n+    }\n+    return addr;\n+}\n+void Win32LockedPageAllocator::FreeLocked(void* addr, size_t len)\n+{\n+    len = align_up(len, page_size);\n+    memory_cleanse(addr, len);\n+    VirtualUnlock(const_cast<void*>(addr), len);\n+}\n+\n+size_t Win32LockedPageAllocator::GetLimit()\n+{\n+    // TODO is there a limit on windows, how to get it?\n+    return std::numeric_limits<size_t>::max();\n+}\n+#endif\n+\n+/*******************************************************************************/\n+// Implementation: PosixLockedPageAllocator\n+\n+#ifndef WIN32\n+/** LockedPageAllocator specialized for OSes that don't try to be\n+ * special snowflakes.\n+ */\n+class PosixLockedPageAllocator: public LockedPageAllocator\n+{\n+public:\n+    PosixLockedPageAllocator();\n+    void* AllocateLocked(size_t len, bool *lockingSuccess);\n+    void FreeLocked(void* addr, size_t len);\n+    size_t GetLimit();\n+private:\n+    size_t page_size;\n+};\n+\n+PosixLockedPageAllocator::PosixLockedPageAllocator()\n+{\n+    // Determine system page size in bytes\n+#if defined(PAGESIZE) // defined in limits.h\n+    page_size = PAGESIZE;\n+#else                   // assume some POSIX OS\n+    page_size = sysconf(_SC_PAGESIZE);\n+#endif\n+}\n+void *PosixLockedPageAllocator::AllocateLocked(size_t len, bool *lockingSuccess)\n+{\n+    void *addr;\n+    len = align_up(len, page_size);\n+    addr = mmap(nullptr, len, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n+    if (addr) {\n+        *lockingSuccess = mlock(addr, len) == 0;\n+    }\n+    return addr;\n+}\n+void PosixLockedPageAllocator::FreeLocked(void* addr, size_t len)\n+{\n+    len = align_up(len, page_size);\n+    memory_cleanse(addr, len);\n+    munlock(addr, len);\n+    munmap(addr, len);\n+}\n+size_t PosixLockedPageAllocator::GetLimit()\n+{\n+#ifdef RLIMIT_MEMLOCK\n+    struct rlimit rlim;\n+    if (getrlimit(RLIMIT_MEMLOCK, &rlim) == 0) {\n+        if (rlim.rlim_cur != RLIM_INFINITY) {\n+            return rlim.rlim_cur;\n+        }\n+    }\n+#endif\n+    return std::numeric_limits<size_t>::max();\n+}\n+#endif\n+\n+/*******************************************************************************/\n+// Implementation: LockedPool\n+\n+LockedPool::LockedPool(std::unique_ptr<LockedPageAllocator> allocator_in, LockingFailed_Callback lf_cb_in):\n+    allocator(std::move(allocator_in)), lf_cb(lf_cb_in), cumulative_bytes_locked(0)\n+{\n+}\n+\n+LockedPool::~LockedPool()\n+{\n+}\n+void* LockedPool::alloc(size_t size)\n+{\n+    std::lock_guard<std::mutex> lock(mutex);\n+    // Try allocating from each current arena\n+    for (auto &arena: arenas) {\n+        void *addr = arena.alloc(size);\n+        if (addr) {\n+            return addr;\n+        }\n+    }\n+    // If that fails, create a new one\n+    if (new_arena(ARENA_SIZE, ARENA_ALIGN)) {\n+        return arenas.back().alloc(size);\n+    }\n+    return nullptr;\n+}\n+\n+void LockedPool::free(void *ptr)\n+{\n+    std::lock_guard<std::mutex> lock(mutex);\n+    // TODO we can do better than this linear search by keeping a map of arena\n+    // extents to arena, and looking up the address.\n+    for (auto &arena: arenas) {\n+        if (arena.addressInArena(ptr)) {\n+            arena.free(ptr);\n+            return;\n+        }\n+    }\n+    throw std::runtime_error(\"LockedPool: invalid address not pointing to any arena\");\n+}\n+\n+LockedPool::Stats LockedPool::stats() const\n+{\n+    std::lock_guard<std::mutex> lock(mutex);\n+    LockedPool::Stats r;\n+    r.used = r.free = r.total = r.chunks_used = r.chunks_free = 0;\n+    r.locked = cumulative_bytes_locked;\n+    for (const auto &arena: arenas) {\n+        Arena::Stats i = arena.stats();\n+        r.used += i.used;\n+        r.free += i.free;\n+        r.total += i.total;\n+        r.chunks_used += i.chunks_used;\n+        r.chunks_free += i.chunks_free;\n+    }\n+    return r;\n+}\n+\n+bool LockedPool::new_arena(size_t size, size_t align)\n+{\n+    bool locked;\n+    // If this is the first arena, handle this specially: Cap the upper size\n+    // by the process limit. This makes sure that the first arena will at least\n+    // be locked. An exception to this is if the process limit is 0:\n+    // in this case no memory can be locked at all so we'll skip past this logic.\n+    if (arenas.empty()) {\n+        size_t limit = allocator->GetLimit();\n+        if (limit > 0) {\n+            size = std::min(size, limit);\n+        }\n+    }\n+    void *addr = allocator->AllocateLocked(size, &locked);\n+    if (!addr) {\n+        return false;\n+    }\n+    if (locked) {\n+        cumulative_bytes_locked += size;\n+    } else if (lf_cb) { // Call the locking-failed callback if locking failed\n+        if (!lf_cb()) { // If the callback returns false, free the memory and fail, otherwise consider the user warned and proceed.\n+            allocator->FreeLocked(addr, size);\n+            return false;\n+        }\n+    }\n+    arenas.emplace_back(allocator.get(), addr, size, align);\n+    return true;\n+}\n+\n+LockedPool::LockedPageArena::LockedPageArena(LockedPageAllocator *allocator_in, void *base_in, size_t size_in, size_t align_in):\n+    Arena(base_in, size_in, align_in), base(base_in), size(size_in), allocator(allocator_in)\n+{\n+}\n+LockedPool::LockedPageArena::~LockedPageArena()\n+{\n+    allocator->FreeLocked(base, size);\n+}\n+\n+/*******************************************************************************/\n+// Implementation: LockedPoolManager\n+//\n+LockedPoolManager::LockedPoolManager(std::unique_ptr<LockedPageAllocator> allocator):\n+    LockedPool(std::move(allocator), &LockedPoolManager::LockingFailed)\n+{\n+}\n+\n+bool LockedPoolManager::LockingFailed()\n+{\n+    // TODO: log something but how? without including util.h\n+    return true;\n+}\n+\n+void LockedPoolManager::CreateInstance()\n+{\n+    // Using a local static instance guarantees that the object is initialized\n+    // when it's first needed and also deinitialized after all objects that use\n+    // it are done with it.  I can think of one unlikely scenario where we may\n+    // have a static deinitialization order/problem, but the check in\n+    // LockedPoolManagerBase's destructor helps us detect if that ever happens.\n+#ifdef WIN32\n+    std::unique_ptr<LockedPageAllocator> allocator(new Win32LockedPageAllocator());\n+#else\n+    std::unique_ptr<LockedPageAllocator> allocator(new PosixLockedPageAllocator());\n+#endif\n+    static LockedPoolManager instance(std::move(allocator));\n+    LockedPoolManager::_instance = &instance;\n+}"
      },
      {
        "sha": "526c17a73fe764d72fec3e52f71b123efab47bd7",
        "filename": "src/support/lockedpool.h",
        "status": "added",
        "additions": 251,
        "deletions": 0,
        "changes": 251,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4536148b15595229d0563fb60913b23cb78788ed/src/support/lockedpool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4536148b15595229d0563fb60913b23cb78788ed/src/support/lockedpool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/lockedpool.h?ref=4536148b15595229d0563fb60913b23cb78788ed",
        "patch": "@@ -0,0 +1,251 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_LOCKEDPOOL_H\n+#define BITCOIN_SUPPORT_LOCKEDPOOL_H\n+\n+#include <stdint.h>\n+#include <list>\n+#include <map>\n+#include <mutex>\n+#include <memory>\n+\n+/**\n+ * OS-dependent allocation and deallocation of locked/pinned memory pages.\n+ * Abstract base class.\n+ */\n+class LockedPageAllocator\n+{\n+public:\n+    virtual ~LockedPageAllocator() {}\n+    /** Allocate and lock memory pages.\n+     * If len is not a multiple of the system page size, it is rounded up.\n+     * Returns 0 in case of allocation failure.\n+     *\n+     * If locking the memory pages could not be accomplished it will still\n+     * return the memory, however the lockingSuccess flag will be false.\n+     * lockingSuccess is undefined if the allocation fails.\n+     */\n+    virtual void* AllocateLocked(size_t len, bool *lockingSuccess) = 0;\n+\n+    /** Unlock and free memory pages.\n+     * Clear the memory before unlocking.\n+     */\n+    virtual void FreeLocked(void* addr, size_t len) = 0;\n+\n+    /** Get the total limit on the amount of memory that may be locked by this\n+     * process, in bytes. Return size_t max if there is no limit or the limit\n+     * is unknown. Return 0 if no memory can be locked at all.\n+     */\n+    virtual size_t GetLimit() = 0;\n+};\n+\n+/* An arena manages a contiguous region of memory by dividing it into\n+ * chunks.\n+ */\n+class Arena\n+{\n+public:\n+    Arena(void *base, size_t size, size_t alignment);\n+    virtual ~Arena();\n+\n+    /** A chunk of memory.\n+     */\n+    struct Chunk\n+    {\n+        /** Most significant bit of size_t. This is used to mark\n+         * in-usedness of chunk.\n+         */\n+        const static size_t SIZE_MSB = 1LLU << ((sizeof(size_t)*8)-1);\n+        /** Maximum size of a chunk */\n+        const static size_t MAX_SIZE = SIZE_MSB - 1;\n+\n+        Chunk(size_t size_in, bool used_in):\n+            size(size_in | (used_in ? SIZE_MSB : 0)) {}\n+\n+        bool isInUse() const { return size & SIZE_MSB; }\n+        void setInUse(bool used_in) { size = (size & ~SIZE_MSB) | (used_in ? SIZE_MSB : 0); }\n+        size_t getSize() const { return size & ~SIZE_MSB; }\n+        void setSize(size_t size_in) { size = (size & SIZE_MSB) | size_in; }\n+    private:\n+        size_t size;\n+    };\n+    /** Memory statistics. */\n+    struct Stats\n+    {\n+        size_t used;\n+        size_t free;\n+        size_t total;\n+        size_t chunks_used;\n+        size_t chunks_free;\n+    };\n+\n+    /** Allocate size bytes from this arena.\n+     * Returns pointer on success, or 0 if memory is full or\n+     * the application tried to allocate 0 bytes.\n+     */\n+    void* alloc(size_t size);\n+\n+    /** Free a previously allocated chunk of memory.\n+     * Freeing the zero pointer has no effect.\n+     * Raises std::runtime_error in case of error.\n+     */\n+    void free(void *ptr);\n+\n+    /** Get arena usage statistics */\n+    Stats stats() const;\n+\n+#ifdef ARENA_DEBUG\n+    void walk() const;\n+#endif\n+\n+    /** Return whether a pointer points inside this arena.\n+     * This returns base <= ptr < (base+size) so only use it for (inclusive)\n+     * chunk starting addresses.\n+     */\n+    bool addressInArena(void *ptr) const { return ptr >= base && ptr < end; }\n+private:\n+    Arena(const Arena& other) = delete; // non construction-copyable\n+    Arena& operator=(const Arena&) = delete; // non copyable\n+\n+    /** Map of chunk address to chunk information. This class makes use of the\n+     * sorted order to merge previous and next chunks during deallocation.\n+     */\n+    std::map<char*, Chunk> chunks;\n+    /** Base address of arena */\n+    char* base;\n+    /** End address of arena */\n+    char* end;\n+    /** Minimum chunk alignment */\n+    size_t alignment;\n+};\n+\n+/** Pool for locked memory chunks.\n+ *\n+ * To avoid sensitive key data from being swapped to disk, the memory in this pool\n+ * is locked/pinned.\n+ *\n+ * An arena manages a contiguous region of memory. The pool starts out with one arena\n+ * but can grow to multiple arenas if the need arises.\n+ *\n+ * Unlike a normal C heap, the administrative structures are seperate from the managed\n+ * memory. This has been done as the sizes and bases of objects are not in themselves sensitive\n+ * information, as to conserve precious locked memory. In some operating systems\n+ * the amount of memory that can be locked is small.\n+ */\n+class LockedPool\n+{\n+public:\n+    /** Size of one arena of locked memory. This is a compromise.\n+     * Do not set this too low, as managing many arenas will increase\n+     * allocation and deallocation overhead. Setting it too high allocates\n+     * more locked memory from the OS than strictly necessary.\n+     */\n+    static const size_t ARENA_SIZE = 256*1024;\n+    /** Chunk alignment. Another compromise. Setting this too high will waste\n+     * memory, setting it too low will facilitate fragmentation.\n+     */\n+    static const size_t ARENA_ALIGN = 16;\n+\n+    /** Callback when allocation succeeds but locking fails.\n+     */\n+    typedef bool (*LockingFailed_Callback)();\n+\n+    /** Memory statistics. */\n+    struct Stats\n+    {\n+        size_t used;\n+        size_t free;\n+        size_t total;\n+        size_t locked;\n+        size_t chunks_used;\n+        size_t chunks_free;\n+    };\n+\n+    /** Create a new LockedPool. This takes ownership of the MemoryPageLocker,\n+     * you can only instantiate this with LockedPool(std::move(...)).\n+     *\n+     * The second argument is an optional callback when locking a newly allocated arena failed.\n+     * If this callback is provided and returns false, the allocation fails (hard fail), if\n+     * it returns true the allocation proceeds, but it could warn.\n+     */\n+    LockedPool(std::unique_ptr<LockedPageAllocator> allocator, LockingFailed_Callback lf_cb_in = 0);\n+    ~LockedPool();\n+\n+    /** Allocate size bytes from this arena.\n+     * Returns pointer on success, or 0 if memory is full or\n+     * the application tried to allocate 0 bytes.\n+     */\n+    void* alloc(size_t size);\n+\n+    /** Free a previously allocated chunk of memory.\n+     * Freeing the zero pointer has no effect.\n+     * Raises std::runtime_error in case of error.\n+     */\n+    void free(void *ptr);\n+\n+    /** Get pool usage statistics */\n+    Stats stats() const;\n+private:\n+    LockedPool(const LockedPool& other) = delete; // non construction-copyable\n+    LockedPool& operator=(const LockedPool&) = delete; // non copyable\n+\n+    std::unique_ptr<LockedPageAllocator> allocator;\n+\n+    /** Create an arena from locked pages */\n+    class LockedPageArena: public Arena\n+    {\n+    public:\n+        LockedPageArena(LockedPageAllocator *alloc_in, void *base_in, size_t size, size_t align);\n+        ~LockedPageArena();\n+    private:\n+        void *base;\n+        size_t size;\n+        LockedPageAllocator *allocator;\n+    };\n+\n+    bool new_arena(size_t size, size_t align);\n+\n+    std::list<LockedPageArena> arenas;\n+    LockingFailed_Callback lf_cb;\n+    size_t cumulative_bytes_locked;\n+    /** Mutex protects access to this pool's data structures, including arenas.\n+     */\n+    mutable std::mutex mutex;\n+};\n+\n+/**\n+ * Singleton class to keep track of locked (ie, non-swappable) memory, for use in\n+ * std::allocator templates.\n+ *\n+ * Some implementations of the STL allocate memory in some constructors (i.e., see\n+ * MSVC's vector<T> implementation where it allocates 1 byte of memory in the allocator.)\n+ * Due to the unpredictable order of static initializers, we have to make sure the\n+ * LockedPoolManager instance exists before any other STL-based objects that use\n+ * secure_allocator are created. So instead of having LockedPoolManager also be\n+ * static-initialized, it is created on demand.\n+ */\n+class LockedPoolManager : public LockedPool\n+{\n+public:\n+    /** Return the current instance, or create it once */\n+    static LockedPoolManager& Instance()\n+    {\n+        std::call_once(LockedPoolManager::init_flag, LockedPoolManager::CreateInstance);\n+        return *LockedPoolManager::_instance;\n+    }\n+\n+private:\n+    LockedPoolManager(std::unique_ptr<LockedPageAllocator> allocator);\n+\n+    /** Create a new LockedPoolManager specialized to the OS */\n+    static void CreateInstance();\n+    /** Called when locking fails, warn the user here */\n+    static bool LockingFailed();\n+\n+    static LockedPoolManager* _instance;\n+    static std::once_flag init_flag;\n+};\n+\n+#endif // BITCOIN_SUPPORT_LOCKEDPOOL_H"
      },
      {
        "sha": "7cea2d88c55c61947b33080bd32e4ab7b126ccbe",
        "filename": "src/support/pagelocker.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 70,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4d1fc259b5a62580d952c180b1189ccaa6af1bc/src/support/pagelocker.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4d1fc259b5a62580d952c180b1189ccaa6af1bc/src/support/pagelocker.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/pagelocker.cpp?ref=f4d1fc259b5a62580d952c180b1189ccaa6af1bc",
        "patch": "@@ -1,70 +0,0 @@\n-// Copyright (c) 2009-2015 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include \"support/pagelocker.h\"\n-\n-#if defined(HAVE_CONFIG_H)\n-#include \"config/bitcoin-config.h\"\n-#endif\n-\n-#ifdef WIN32\n-#ifdef _WIN32_WINNT\n-#undef _WIN32_WINNT\n-#endif\n-#define _WIN32_WINNT 0x0501\n-#define WIN32_LEAN_AND_MEAN 1\n-#ifndef NOMINMAX\n-#define NOMINMAX\n-#endif\n-#include <windows.h>\n-// This is used to attempt to keep keying material out of swap\n-// Note that VirtualLock does not provide this as a guarantee on Windows,\n-// but, in practice, memory that has been VirtualLock'd almost never gets written to\n-// the pagefile except in rare circumstances where memory is extremely low.\n-#else\n-#include <sys/mman.h>\n-#include <limits.h> // for PAGESIZE\n-#include <unistd.h> // for sysconf\n-#endif\n-\n-LockedPageManager* LockedPageManager::_instance = NULL;\n-boost::once_flag LockedPageManager::init_flag = BOOST_ONCE_INIT;\n-\n-/** Determine system page size in bytes */\n-static inline size_t GetSystemPageSize()\n-{\n-    size_t page_size;\n-#if defined(WIN32)\n-    SYSTEM_INFO sSysInfo;\n-    GetSystemInfo(&sSysInfo);\n-    page_size = sSysInfo.dwPageSize;\n-#elif defined(PAGESIZE) // defined in limits.h\n-    page_size = PAGESIZE;\n-#else                   // assume some POSIX OS\n-    page_size = sysconf(_SC_PAGESIZE);\n-#endif\n-    return page_size;\n-}\n-\n-bool MemoryPageLocker::Lock(const void* addr, size_t len)\n-{\n-#ifdef WIN32\n-    return VirtualLock(const_cast<void*>(addr), len) != 0;\n-#else\n-    return mlock(addr, len) == 0;\n-#endif\n-}\n-\n-bool MemoryPageLocker::Unlock(const void* addr, size_t len)\n-{\n-#ifdef WIN32\n-    return VirtualUnlock(const_cast<void*>(addr), len) != 0;\n-#else\n-    return munlock(addr, len) == 0;\n-#endif\n-}\n-\n-LockedPageManager::LockedPageManager() : LockedPageManagerBase<MemoryPageLocker>(GetSystemPageSize())\n-{\n-}"
      },
      {
        "sha": "042144fad5614e976e06d93a10950be5eb10e13e",
        "filename": "src/support/pagelocker.h",
        "status": "removed",
        "additions": 0,
        "deletions": 160,
        "changes": 160,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4d1fc259b5a62580d952c180b1189ccaa6af1bc/src/support/pagelocker.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4d1fc259b5a62580d952c180b1189ccaa6af1bc/src/support/pagelocker.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/pagelocker.h?ref=f4d1fc259b5a62580d952c180b1189ccaa6af1bc",
        "patch": "@@ -1,160 +0,0 @@\n-// Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2015 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#ifndef BITCOIN_SUPPORT_PAGELOCKER_H\n-#define BITCOIN_SUPPORT_PAGELOCKER_H\n-\n-#include \"support/cleanse.h\"\n-\n-#include <map>\n-\n-#include <boost/thread/mutex.hpp>\n-#include <boost/thread/once.hpp>\n-\n-/**\n- * Thread-safe class to keep track of locked (ie, non-swappable) memory pages.\n- *\n- * Memory locks do not stack, that is, pages which have been locked several times by calls to mlock()\n- * will be unlocked by a single call to munlock(). This can result in keying material ending up in swap when\n- * those functions are used naively. This class simulates stacking memory locks by keeping a counter per page.\n- *\n- * @note By using a map from each page base address to lock count, this class is optimized for\n- * small objects that span up to a few pages, mostly smaller than a page. To support large allocations,\n- * something like an interval tree would be the preferred data structure.\n- */\n-template <class Locker>\n-class LockedPageManagerBase\n-{\n-public:\n-    LockedPageManagerBase(size_t _page_size) : page_size(_page_size)\n-    {\n-        // Determine bitmask for extracting page from address\n-        assert(!(_page_size & (_page_size - 1))); // size must be power of two\n-        page_mask = ~(_page_size - 1);\n-    }\n-\n-    ~LockedPageManagerBase()\n-    {\n-    }\n-\n-\n-    // For all pages in affected range, increase lock count\n-    void LockRange(void* p, size_t size)\n-    {\n-        boost::mutex::scoped_lock lock(mutex);\n-        if (!size)\n-            return;\n-        const size_t base_addr = reinterpret_cast<size_t>(p);\n-        const size_t start_page = base_addr & page_mask;\n-        const size_t end_page = (base_addr + size - 1) & page_mask;\n-        for (size_t page = start_page; page <= end_page; page += page_size) {\n-            Histogram::iterator it = histogram.find(page);\n-            if (it == histogram.end()) // Newly locked page\n-            {\n-                locker.Lock(reinterpret_cast<void*>(page), page_size);\n-                histogram.insert(std::make_pair(page, 1));\n-            } else // Page was already locked; increase counter\n-            {\n-                it->second += 1;\n-            }\n-        }\n-    }\n-\n-    // For all pages in affected range, decrease lock count\n-    void UnlockRange(void* p, size_t size)\n-    {\n-        boost::mutex::scoped_lock lock(mutex);\n-        if (!size)\n-            return;\n-        const size_t base_addr = reinterpret_cast<size_t>(p);\n-        const size_t start_page = base_addr & page_mask;\n-        const size_t end_page = (base_addr + size - 1) & page_mask;\n-        for (size_t page = start_page; page <= end_page; page += page_size) {\n-            Histogram::iterator it = histogram.find(page);\n-            assert(it != histogram.end()); // Cannot unlock an area that was not locked\n-            // Decrease counter for page, when it is zero, the page will be unlocked\n-            it->second -= 1;\n-            if (it->second == 0) // Nothing on the page anymore that keeps it locked\n-            {\n-                // Unlock page and remove the count from histogram\n-                locker.Unlock(reinterpret_cast<void*>(page), page_size);\n-                histogram.erase(it);\n-            }\n-        }\n-    }\n-\n-    // Get number of locked pages for diagnostics\n-    int GetLockedPageCount()\n-    {\n-        boost::mutex::scoped_lock lock(mutex);\n-        return histogram.size();\n-    }\n-\n-private:\n-    Locker locker;\n-    boost::mutex mutex;\n-    size_t page_size, page_mask;\n-    // map of page base address to lock count\n-    typedef std::map<size_t, int> Histogram;\n-    Histogram histogram;\n-};\n-\n-\n-/**\n- * OS-dependent memory page locking/unlocking.\n- * Defined as policy class to make stubbing for test possible.\n- */\n-class MemoryPageLocker\n-{\n-public:\n-    /** Lock memory pages.\n-     * addr and len must be a multiple of the system page size\n-     */\n-    bool Lock(const void* addr, size_t len);\n-    /** Unlock memory pages.\n-     * addr and len must be a multiple of the system page size\n-     */\n-    bool Unlock(const void* addr, size_t len);\n-};\n-\n-/**\n- * Singleton class to keep track of locked (ie, non-swappable) memory pages, for use in\n- * std::allocator templates.\n- *\n- * Some implementations of the STL allocate memory in some constructors (i.e., see\n- * MSVC's vector<T> implementation where it allocates 1 byte of memory in the allocator.)\n- * Due to the unpredictable order of static initializers, we have to make sure the\n- * LockedPageManager instance exists before any other STL-based objects that use\n- * secure_allocator are created. So instead of having LockedPageManager also be\n- * static-initialized, it is created on demand.\n- */\n-class LockedPageManager : public LockedPageManagerBase<MemoryPageLocker>\n-{\n-public:\n-    static LockedPageManager& Instance()\n-    {\n-        boost::call_once(LockedPageManager::CreateInstance, LockedPageManager::init_flag);\n-        return *LockedPageManager::_instance;\n-    }\n-\n-private:\n-    LockedPageManager();\n-\n-    static void CreateInstance()\n-    {\n-        // Using a local static instance guarantees that the object is initialized\n-        // when it's first needed and also deinitialized after all objects that use\n-        // it are done with it.  I can think of one unlikely scenario where we may\n-        // have a static deinitialization order/problem, but the check in\n-        // LockedPageManagerBase's destructor helps us detect if that ever happens.\n-        static LockedPageManager instance;\n-        LockedPageManager::_instance = &instance;\n-    }\n-\n-    static LockedPageManager* _instance;\n-    static boost::once_flag init_flag;\n-};\n-\n-#endif // BITCOIN_SUPPORT_PAGELOCKER_H"
      },
      {
        "sha": "f0e848655f2056ad25b4d274fd42dbc055bb05f4",
        "filename": "src/test/allocator_tests.cpp",
        "status": "modified",
        "additions": 192,
        "deletions": 88,
        "changes": 280,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4536148b15595229d0563fb60913b23cb78788ed/src/test/allocator_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4536148b15595229d0563fb60913b23cb78788ed/src/test/allocator_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/allocator_tests.cpp?ref=4536148b15595229d0563fb60913b23cb78788ed",
        "patch": "@@ -11,110 +11,214 @@\n \n BOOST_FIXTURE_TEST_SUITE(allocator_tests, BasicTestingSetup)\n \n-// Dummy memory page locker for platform independent tests\n-static const void *last_lock_addr, *last_unlock_addr;\n-static size_t last_lock_len, last_unlock_len;\n-class TestLocker\n+BOOST_AUTO_TEST_CASE(arena_tests)\n {\n-public:\n-    bool Lock(const void *addr, size_t len)\n+    // Fake memory base address for testing\n+    // without actually using memory.\n+    void *synth_base = reinterpret_cast<void*>(0x08000000);\n+    const size_t synth_size = 1024*1024;\n+    Arena b(synth_base, synth_size, 16);\n+    void *chunk = b.alloc(1000);\n+#ifdef ARENA_DEBUG\n+    b.walk();\n+#endif\n+    BOOST_CHECK(chunk != nullptr);\n+    BOOST_CHECK(b.stats().used == 1008); // Aligned to 16\n+    BOOST_CHECK(b.stats().total == synth_size); // Nothing has disappeared?\n+    b.free(chunk);\n+#ifdef ARENA_DEBUG\n+    b.walk();\n+#endif\n+    BOOST_CHECK(b.stats().used == 0);\n+    BOOST_CHECK(b.stats().free == synth_size);\n+    try { // Test exception on double-free\n+        b.free(chunk);\n+        BOOST_CHECK(0);\n+    } catch(std::runtime_error &)\n     {\n-        last_lock_addr = addr;\n-        last_lock_len = len;\n-        return true;\n     }\n-    bool Unlock(const void *addr, size_t len)\n-    {\n-        last_unlock_addr = addr;\n-        last_unlock_len = len;\n-        return true;\n+\n+    void *a0 = b.alloc(128);\n+    BOOST_CHECK(a0 == synth_base); // first allocation must start at beginning\n+    void *a1 = b.alloc(256);\n+    void *a2 = b.alloc(512);\n+    BOOST_CHECK(b.stats().used == 896);\n+    BOOST_CHECK(b.stats().total == synth_size);\n+#ifdef ARENA_DEBUG\n+    b.walk();\n+#endif\n+    b.free(a0);\n+#ifdef ARENA_DEBUG\n+    b.walk();\n+#endif\n+    BOOST_CHECK(b.stats().used == 768);\n+    b.free(a1);\n+    BOOST_CHECK(b.stats().used == 512);\n+    void *a3 = b.alloc(128);\n+#ifdef ARENA_DEBUG\n+    b.walk();\n+#endif\n+    BOOST_CHECK(b.stats().used == 640);\n+    b.free(a2);\n+    BOOST_CHECK(b.stats().used == 128);\n+    b.free(a3);\n+    BOOST_CHECK(b.stats().used == 0);\n+    BOOST_CHECK(b.stats().total == synth_size);\n+    BOOST_CHECK(b.stats().free == synth_size);\n+\n+    std::vector<void*> addr;\n+    BOOST_CHECK(b.alloc(0) == nullptr); // allocating 0 always returns nullptr\n+#ifdef ARENA_DEBUG\n+    b.walk();\n+#endif\n+    // Sweeping allocate all memory\n+    for (int x=0; x<1024; ++x)\n+        addr.push_back(b.alloc(1024));\n+    BOOST_CHECK(addr[0] == synth_base); // first allocation must start at beginning\n+    BOOST_CHECK(b.stats().free == 0);\n+    BOOST_CHECK(b.alloc(1024) == nullptr); // memory is full, this must return nullptr\n+    BOOST_CHECK(b.alloc(0) == nullptr);\n+    for (int x=0; x<1024; ++x)\n+        b.free(addr[x]);\n+    addr.clear();\n+    BOOST_CHECK(b.stats().total == synth_size);\n+    BOOST_CHECK(b.stats().free == synth_size);\n+\n+    // Now in the other direction...\n+    for (int x=0; x<1024; ++x)\n+        addr.push_back(b.alloc(1024));\n+    for (int x=0; x<1024; ++x)\n+        b.free(addr[1023-x]);\n+    addr.clear();\n+\n+    // Now allocate in smaller unequal chunks, then deallocate haphazardly\n+    // Not all the chunks will succeed allocating, but freeing nullptr is\n+    // allowed so that is no problem.\n+    for (int x=0; x<2048; ++x)\n+        addr.push_back(b.alloc(x+1));\n+    for (int x=0; x<2048; ++x)\n+        b.free(addr[((x*23)%2048)^242]);\n+    addr.clear();\n+\n+    // Go entirely wild: free and alloc interleaved,\n+    // generate targets and sizes using pseudo-randomness.\n+    for (int x=0; x<2048; ++x)\n+        addr.push_back(0);\n+    uint32_t s = 0x12345678;\n+    for (int x=0; x<5000; ++x) {\n+        int idx = s & (addr.size()-1);\n+        if (s & 0x80000000) {\n+            b.free(addr[idx]);\n+            addr[idx] = 0;\n+        } else if(!addr[idx]) {\n+            addr[idx] = b.alloc((s >> 16) & 2047);\n+        }\n+        bool lsb = s & 1;\n+        s >>= 1;\n+        if (lsb)\n+            s ^= 0xf00f00f0; // LFSR period 0xf7ffffe0\n     }\n-};\n+    for (void *ptr: addr)\n+        b.free(ptr);\n+    addr.clear();\n \n-BOOST_AUTO_TEST_CASE(test_LockedPageManagerBase)\n+    BOOST_CHECK(b.stats().total == synth_size);\n+    BOOST_CHECK(b.stats().free == synth_size);\n+}\n+\n+/** Mock LockedPageAllocator for testing */\n+class TestLockedPageAllocator: public LockedPageAllocator\n {\n-    const size_t test_page_size = 4096;\n-    LockedPageManagerBase<TestLocker> lpm(test_page_size);\n-    size_t addr;\n-    last_lock_addr = last_unlock_addr = 0;\n-    last_lock_len = last_unlock_len = 0;\n-\n-    /* Try large number of small objects */\n-    addr = 0;\n-    for(int i=0; i<1000; ++i)\n-    {\n-        lpm.LockRange(reinterpret_cast<void*>(addr), 33);\n-        addr += 33;\n-    }\n-    /* Try small number of page-sized objects, straddling two pages */\n-    addr = test_page_size*100 + 53;\n-    for(int i=0; i<100; ++i)\n-    {\n-        lpm.LockRange(reinterpret_cast<void*>(addr), test_page_size);\n-        addr += test_page_size;\n-    }\n-    /* Try small number of page-sized objects aligned to exactly one page */\n-    addr = test_page_size*300;\n-    for(int i=0; i<100; ++i)\n-    {\n-        lpm.LockRange(reinterpret_cast<void*>(addr), test_page_size);\n-        addr += test_page_size;\n-    }\n-    /* one very large object, straddling pages */\n-    lpm.LockRange(reinterpret_cast<void*>(test_page_size*600+1), test_page_size*500);\n-    BOOST_CHECK(last_lock_addr == reinterpret_cast<void*>(test_page_size*(600+500)));\n-    /* one very large object, page aligned */\n-    lpm.LockRange(reinterpret_cast<void*>(test_page_size*1200), test_page_size*500-1);\n-    BOOST_CHECK(last_lock_addr == reinterpret_cast<void*>(test_page_size*(1200+500-1)));\n-\n-    BOOST_CHECK(lpm.GetLockedPageCount() == (\n-        (1000*33+test_page_size-1)/test_page_size + // small objects\n-        101 + 100 +  // page-sized objects\n-        501 + 500)); // large objects\n-    BOOST_CHECK((last_lock_len & (test_page_size-1)) == 0); // always lock entire pages\n-    BOOST_CHECK(last_unlock_len == 0); // nothing unlocked yet\n-\n-    /* And unlock again */\n-    addr = 0;\n-    for(int i=0; i<1000; ++i)\n+public:\n+    TestLockedPageAllocator(int count_in, int lockedcount_in): count(count_in), lockedcount(lockedcount_in) {}\n+    void* AllocateLocked(size_t len, bool *lockingSuccess)\n     {\n-        lpm.UnlockRange(reinterpret_cast<void*>(addr), 33);\n-        addr += 33;\n+        *lockingSuccess = false;\n+        if (count > 0) {\n+            --count;\n+\n+            if (lockedcount > 0) {\n+                --lockedcount;\n+                *lockingSuccess = true;\n+            }\n+\n+            return reinterpret_cast<void*>(0x08000000 + (count<<24)); // Fake address, do not actually use this memory\n+        }\n+        return 0;\n     }\n-    addr = test_page_size*100 + 53;\n-    for(int i=0; i<100; ++i)\n+    void FreeLocked(void* addr, size_t len)\n     {\n-        lpm.UnlockRange(reinterpret_cast<void*>(addr), test_page_size);\n-        addr += test_page_size;\n     }\n-    addr = test_page_size*300;\n-    for(int i=0; i<100; ++i)\n+    size_t GetLimit()\n     {\n-        lpm.UnlockRange(reinterpret_cast<void*>(addr), test_page_size);\n-        addr += test_page_size;\n+        return std::numeric_limits<size_t>::max();\n     }\n-    lpm.UnlockRange(reinterpret_cast<void*>(test_page_size*600+1), test_page_size*500);\n-    lpm.UnlockRange(reinterpret_cast<void*>(test_page_size*1200), test_page_size*500-1);\n+private:\n+    int count;\n+    int lockedcount;\n+};\n \n-    /* Check that everything is released */\n-    BOOST_CHECK(lpm.GetLockedPageCount() == 0);\n+BOOST_AUTO_TEST_CASE(lockedpool_tests_mock)\n+{\n+    // Test over three virtual arenas, of which one will succeed being locked\n+    std::unique_ptr<LockedPageAllocator> x(new TestLockedPageAllocator(3, 1));\n+    LockedPool pool(std::move(x));\n+    BOOST_CHECK(pool.stats().total == 0);\n+    BOOST_CHECK(pool.stats().locked == 0);\n \n-    /* A few and unlocks of size zero (should have no effect) */\n-    addr = 0;\n-    for(int i=0; i<1000; ++i)\n-    {\n-        lpm.LockRange(reinterpret_cast<void*>(addr), 0);\n-        addr += 1;\n-    }\n-    BOOST_CHECK(lpm.GetLockedPageCount() == 0);\n-    addr = 0;\n-    for(int i=0; i<1000; ++i)\n+    void *a0 = pool.alloc(LockedPool::ARENA_SIZE / 2);\n+    BOOST_CHECK(a0);\n+    BOOST_CHECK(pool.stats().locked == LockedPool::ARENA_SIZE);\n+    void *a1 = pool.alloc(LockedPool::ARENA_SIZE / 2);\n+    BOOST_CHECK(a1);\n+    void *a2 = pool.alloc(LockedPool::ARENA_SIZE / 2);\n+    BOOST_CHECK(a2);\n+    void *a3 = pool.alloc(LockedPool::ARENA_SIZE / 2);\n+    BOOST_CHECK(a3);\n+    void *a4 = pool.alloc(LockedPool::ARENA_SIZE / 2);\n+    BOOST_CHECK(a4);\n+    void *a5 = pool.alloc(LockedPool::ARENA_SIZE / 2);\n+    BOOST_CHECK(a5);\n+    // We've passed a count of three arenas, so this allocation should fail\n+    void *a6 = pool.alloc(16);\n+    BOOST_CHECK(!a6);\n+\n+    pool.free(a0);\n+    pool.free(a2);\n+    pool.free(a4);\n+    pool.free(a1);\n+    pool.free(a3);\n+    pool.free(a5);\n+    BOOST_CHECK(pool.stats().total == 3*LockedPool::ARENA_SIZE);\n+    BOOST_CHECK(pool.stats().locked == LockedPool::ARENA_SIZE);\n+    BOOST_CHECK(pool.stats().used == 0);\n+}\n+\n+// These tests used the live LockedPoolManager object, this is also used\n+// by other tests so the conditions are somewhat less controllable and thus the\n+// tests are somewhat more error-prone.\n+BOOST_AUTO_TEST_CASE(lockedpool_tests_live)\n+{\n+    LockedPoolManager &pool = LockedPoolManager::Instance();\n+    LockedPool::Stats initial = pool.stats();\n+\n+    void *a0 = pool.alloc(16);\n+    BOOST_CHECK(a0);\n+    // Test reading and writing the allocated memory\n+    *((uint32_t*)a0) = 0x1234;\n+    BOOST_CHECK(*((uint32_t*)a0) == 0x1234);\n+\n+    pool.free(a0);\n+    try { // Test exception on double-free\n+        pool.free(a0);\n+        BOOST_CHECK(0);\n+    } catch(std::runtime_error &)\n     {\n-        lpm.UnlockRange(reinterpret_cast<void*>(addr), 0);\n-        addr += 1;\n     }\n-    BOOST_CHECK(lpm.GetLockedPageCount() == 0);\n-    BOOST_CHECK((last_unlock_len & (test_page_size-1)) == 0); // always unlock entire pages\n+    // If more than one new arena was allocated for the above tests, something is wrong\n+    BOOST_CHECK(pool.stats().total <= (initial.total + LockedPool::ARENA_SIZE));\n+    // Usage must be back to where it started\n+    BOOST_CHECK(pool.stats().used == initial.used);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "65679990967c0fa4fc0320907d9cd33c801faf5a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NTY3OTk5MDk2N2MwZmE0ZmMwMzIwOTA3ZDljZDMzYzgwMWZhZjVh",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-09-18T08:22:30Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-10-27T11:17:26Z"
      },
      "message": "rpc: Add `getmemoryinfo` call\n\n```\ngetmemoryinfo\nReturns an object containing information about memory usage.\n\nResult:\n{\n  \"locked\": {               (json object) Information about locked memory manager\n    \"used\": xxxxx,          (numeric) Number of bytes used\n    \"free\": xxxxx,          (numeric) Number of bytes available in current arenas\n    \"total\": xxxxxxx,       (numeric) Total number of bytes managed\n    \"locked\": xxxxxx,       (numeric) Amount of bytes that succeeded locking. If this number is smaller than total, locking pages failed at some point and key data could be swapped to disk.\n  }\n}\n\nExamples:\n> bitcoin-cli getmemoryinfo\n> curl --user myusername --data-binary '{\"jsonrpc\": \"1.0\", \"id\":\"curltest\", \"method\": \"getmemoryinfo\", \"params\": [] }' -H 'content-type: text/plain;' http://127.0.0.1:8332/\n```",
      "tree": {
        "sha": "79d56f6c8ac32fffda84e49c16a87216b15f618c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/79d56f6c8ac32fffda84e49c16a87216b15f618c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/65679990967c0fa4fc0320907d9cd33c801faf5a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/65679990967c0fa4fc0320907d9cd33c801faf5a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/65679990967c0fa4fc0320907d9cd33c801faf5a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/65679990967c0fa4fc0320907d9cd33c801faf5a/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4536148b15595229d0563fb60913b23cb78788ed",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4536148b15595229d0563fb60913b23cb78788ed",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4536148b15595229d0563fb60913b23cb78788ed"
      }
    ],
    "stats": {
      "total": 43,
      "additions": 43,
      "deletions": 0
    },
    "files": [
      {
        "sha": "30db06dd321b53126f6bc9164dffb40652ad44b2",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 43,
        "deletions": 0,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/65679990967c0fa4fc0320907d9cd33c801faf5a/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/65679990967c0fa4fc0320907d9cd33c801faf5a/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=65679990967c0fa4fc0320907d9cd33c801faf5a",
        "patch": "@@ -450,10 +450,53 @@ UniValue setmocktime(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+static UniValue RPCLockedMemoryInfo()\n+{\n+    LockedPool::Stats stats = LockedPoolManager::Instance().stats();\n+    UniValue obj(UniValue::VOBJ);\n+    obj.push_back(Pair(\"used\", uint64_t(stats.used)));\n+    obj.push_back(Pair(\"free\", uint64_t(stats.free)));\n+    obj.push_back(Pair(\"total\", uint64_t(stats.total)));\n+    obj.push_back(Pair(\"locked\", uint64_t(stats.locked)));\n+    obj.push_back(Pair(\"chunks_used\", uint64_t(stats.chunks_used)));\n+    obj.push_back(Pair(\"chunks_free\", uint64_t(stats.chunks_free)));\n+    return obj;\n+}\n+\n+UniValue getmemoryinfo(const JSONRPCRequest& request)\n+{\n+    /* Please, avoid using the word \"pool\" here in the RPC interface or help,\n+     * as users will undoubtedly confuse it with the other \"memory pool\"\n+     */\n+    if (request.fHelp || request.params.size() != 0)\n+        throw runtime_error(\n+            \"getmemoryinfo\\n\"\n+            \"Returns an object containing information about memory usage.\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"locked\\\": {               (json object) Information about locked memory manager\\n\"\n+            \"    \\\"used\\\": xxxxx,          (numeric) Number of bytes used\\n\"\n+            \"    \\\"free\\\": xxxxx,          (numeric) Number of bytes available in current arenas\\n\"\n+            \"    \\\"total\\\": xxxxxxx,       (numeric) Total number of bytes managed\\n\"\n+            \"    \\\"locked\\\": xxxxxx,       (numeric) Amount of bytes that succeeded locking. If this number is smaller than total, locking pages failed at some point and key data could be swapped to disk.\\n\"\n+            \"    \\\"chunks_used\\\": xxxxx,   (numeric) Number allocated chunks\\n\"\n+            \"    \\\"chunks_free\\\": xxxxx,   (numeric) Number unused chunks\\n\"\n+            \"  }\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getmemoryinfo\", \"\")\n+            + HelpExampleRpc(\"getmemoryinfo\", \"\")\n+        );\n+    UniValue obj(UniValue::VOBJ);\n+    obj.push_back(Pair(\"locked\", RPCLockedMemoryInfo()));\n+    return obj;\n+}\n+\n static const CRPCCommand commands[] =\n { //  category              name                      actor (function)         okSafeMode\n   //  --------------------- ------------------------  -----------------------  ----------\n     { \"control\",            \"getinfo\",                &getinfo,                true  }, /* uses wallet if enabled */\n+    { \"control\",            \"getmemoryinfo\",          &getmemoryinfo,          true  },\n     { \"util\",               \"validateaddress\",        &validateaddress,        true  }, /* uses wallet if enabled */\n     { \"util\",               \"createmultisig\",         &createmultisig,         true  },\n     { \"util\",               \"verifymessage\",          &verifymessage,          true  },"
      }
    ]
  },
  {
    "sha": "444c673d85ba0787b2c2ff1ab0f3814ce02622a5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NDRjNjczZDg1YmEwNzg3YjJjMmZmMWFiMGYzODE0Y2UwMjYyMmE1",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-10-18T15:49:02Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-10-27T11:17:26Z"
      },
      "message": "bench: Add benchmark for lockedpool allocation/deallocation",
      "tree": {
        "sha": "b735ab146b3703e10ed4ed4b697667bcb05f197d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b735ab146b3703e10ed4ed4b697667bcb05f197d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/444c673d85ba0787b2c2ff1ab0f3814ce02622a5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/444c673d85ba0787b2c2ff1ab0f3814ce02622a5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/444c673d85ba0787b2c2ff1ab0f3814ce02622a5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/444c673d85ba0787b2c2ff1ab0f3814ce02622a5/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "65679990967c0fa4fc0320907d9cd33c801faf5a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/65679990967c0fa4fc0320907d9cd33c801faf5a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/65679990967c0fa4fc0320907d9cd33c801faf5a"
      }
    ],
    "stats": {
      "total": 50,
      "additions": 49,
      "deletions": 1
    },
    "files": [
      {
        "sha": "9760ad089c93cb433926a1e53e7d7f8abbcd723a",
        "filename": "src/Makefile.bench.include",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/444c673d85ba0787b2c2ff1ab0f3814ce02622a5/src/Makefile.bench.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/444c673d85ba0787b2c2ff1ab0f3814ce02622a5/src/Makefile.bench.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.bench.include?ref=444c673d85ba0787b2c2ff1ab0f3814ce02622a5",
        "patch": "@@ -17,7 +17,8 @@ bench_bench_bitcoin_SOURCES = \\\n   bench/ccoins_caching.cpp \\\n   bench/mempool_eviction.cpp \\\n   bench/verify_script.cpp \\\n-  bench/base58.cpp\n+  bench/base58.cpp \\\n+  bench/lockedpool.cpp\n \n bench_bench_bitcoin_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(EVENT_CLFAGS) $(EVENT_PTHREADS_CFLAGS) -I$(builddir)/bench/\n bench_bench_bitcoin_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)"
      },
      {
        "sha": "5df5b1ac6e640a795306101cdd7df0097b51186e",
        "filename": "src/bench/lockedpool.cpp",
        "status": "added",
        "additions": 47,
        "deletions": 0,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/444c673d85ba0787b2c2ff1ab0f3814ce02622a5/src/bench/lockedpool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/444c673d85ba0787b2c2ff1ab0f3814ce02622a5/src/bench/lockedpool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/lockedpool.cpp?ref=444c673d85ba0787b2c2ff1ab0f3814ce02622a5",
        "patch": "@@ -0,0 +1,47 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"bench.h\"\n+\n+#include \"support/lockedpool.h\"\n+\n+#include <iostream>\n+#include <vector>\n+\n+#define ASIZE 2048\n+#define BITER 5000\n+#define MSIZE 2048\n+\n+static void LockedPool(benchmark::State& state)\n+{\n+    void *synth_base = reinterpret_cast<void*>(0x08000000);\n+    const size_t synth_size = 1024*1024;\n+    Arena b(synth_base, synth_size, 16);\n+\n+    std::vector<void*> addr;\n+    for (int x=0; x<ASIZE; ++x)\n+        addr.push_back(0);\n+    uint32_t s = 0x12345678;\n+    while (state.KeepRunning()) {\n+        for (int x=0; x<BITER; ++x) {\n+            int idx = s & (addr.size()-1);\n+            if (s & 0x80000000) {\n+                b.free(addr[idx]);\n+                addr[idx] = 0;\n+            } else if(!addr[idx]) {\n+                addr[idx] = b.alloc((s >> 16) & (MSIZE-1));\n+            }\n+            bool lsb = s & 1;\n+            s >>= 1;\n+            if (lsb)\n+                s ^= 0xf00f00f0; // LFSR period 0xf7ffffe0\n+        }\n+    }\n+    for (void *ptr: addr)\n+        b.free(ptr);\n+    addr.clear();\n+}\n+\n+BENCHMARK(LockedPool);\n+"
      }
    ]
  }
]