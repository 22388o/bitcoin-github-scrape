[
  {
    "sha": "fac2e6a6045e4ddd6b473f4f3ddbb69d9d6921f6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYWMyZTZhNjA0NWU0ZGRkNmI0NzNmNGYzZGRiYjY5ZDlkNjkyMWY2",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-07-26T20:14:36Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-07-26T20:11:26Z"
      },
      "message": "test: Fail early on disconnect in mininode.wait_for_*",
      "tree": {
        "sha": "3bd41ae25b190f0b6c9aaa1658885e684ea8f06a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3bd41ae25b190f0b6c9aaa1658885e684ea8f06a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fac2e6a6045e4ddd6b473f4f3ddbb69d9d6921f6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUh7Rgv9FPOsSwme/7I7pQfhuQnd0xL/z5hWrsJLnGUEgjvn8hGIs0x8BxJINmw3\n9h8XDbeJAugO1y6wuSu5+/6odJ+FxYYwdmxz/POM6R2eEe/1tZ/3wXWwIVNzBbNb\numf/ELcWO9WbnBpgyEUb9jATxDSECkO/rSh336HC5Lnq3RKKb4PBvBCPgOVGc7iW\nQMtkDXb8COHCNgJwIzVUp5SFb1gz6GWmoYOXYrrPvE9PIxR1qGlYib75mFWFqBlC\n5YGRwzCc3NpvGDZ/u40y7sqSE8cYgKCAZ1GrgpMhsPFtqb88DpCWOVjyzVnHwo0R\n9GVI1a6/HXJm0tnZO1Huhc6He1TAoEYpQTXksrcD+Z7vf0LGxHpQuI5EWDNV+x0C\ncPzsS4atXgh1XJdmnplEofs+pcOeHMdGzJM5wXSSsjaxi0A/fewrfDG1gYNfLwDL\nI9/QIiTZ2Wf9ftlI5DfG904z3xzmHN8g/s+TX6F2uONVRwDMrEkKsiAlm5rqZ+Hv\nlVVPMGsP\n=PUVF\n-----END PGP SIGNATURE-----",
        "payload": "tree 3bd41ae25b190f0b6c9aaa1658885e684ea8f06a\nparent dbf4f3f86a8fd954cd25d8d70afde781c2fe24ce\nauthor MarcoFalke <falke.marco@gmail.com> 1564172076 -0400\ncommitter MarcoFalke <falke.marco@gmail.com> 1564171886 -0400\n\ntest: Fail early on disconnect in mininode.wait_for_*\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fac2e6a6045e4ddd6b473f4f3ddbb69d9d6921f6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fac2e6a6045e4ddd6b473f4f3ddbb69d9d6921f6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fac2e6a6045e4ddd6b473f4f3ddbb69d9d6921f6/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "dbf4f3f86a8fd954cd25d8d70afde781c2fe24ce",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dbf4f3f86a8fd954cd25d8d70afde781c2fe24ce",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/dbf4f3f86a8fd954cd25d8d70afde781c2fe24ce"
      }
    ],
    "stats": {
      "total": 35,
      "additions": 29,
      "deletions": 6
    },
    "files": [
      {
        "sha": "779863df7963227a8056a76d1a36bc8b2b32e94c",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 29,
        "deletions": 6,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fac2e6a6045e4ddd6b473f4f3ddbb69d9d6921f6/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fac2e6a6045e4ddd6b473f4f3ddbb69d9d6921f6/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=fac2e6a6045e4ddd6b473f4f3ddbb69d9d6921f6",
        "patch": "@@ -363,18 +363,23 @@ def wait_for_disconnect(self, timeout=60):\n \n     def wait_for_tx(self, txid, timeout=60):\n         def test_function():\n+            assert self.is_connected\n             if not self.last_message.get('tx'):\n                 return False\n             return self.last_message['tx'].tx.rehash() == txid\n \n         wait_until(test_function, timeout=timeout, lock=mininode_lock)\n \n     def wait_for_block(self, blockhash, timeout=60):\n-        test_function = lambda: self.last_message.get(\"block\") and self.last_message[\"block\"].block.rehash() == blockhash\n+        def test_function():\n+            assert self.is_connected\n+            return self.last_message.get(\"block\") and self.last_message[\"block\"].block.rehash() == blockhash\n+\n         wait_until(test_function, timeout=timeout, lock=mininode_lock)\n \n     def wait_for_header(self, blockhash, timeout=60):\n         def test_function():\n+            assert self.is_connected\n             last_headers = self.last_message.get('headers')\n             if not last_headers:\n                 return False\n@@ -389,7 +394,11 @@ def wait_for_getdata(self, timeout=60):\n         value must be explicitly cleared before calling this method, or this will return\n         immediately with success. TODO: change this method to take a hash value and only\n         return true if the correct block/tx has been requested.\"\"\"\n-        test_function = lambda: self.last_message.get(\"getdata\")\n+\n+        def test_function():\n+            assert self.is_connected\n+            return self.last_message.get(\"getdata\")\n+\n         wait_until(test_function, timeout=timeout, lock=mininode_lock)\n \n     def wait_for_getheaders(self, timeout=60):\n@@ -399,20 +408,30 @@ def wait_for_getheaders(self, timeout=60):\n         value must be explicitly cleared before calling this method, or this will return\n         immediately with success. TODO: change this method to take a hash value and only\n         return true if the correct block header has been requested.\"\"\"\n-        test_function = lambda: self.last_message.get(\"getheaders\")\n+\n+        def test_function():\n+            assert self.is_connected\n+            return self.last_message.get(\"getheaders\")\n+\n         wait_until(test_function, timeout=timeout, lock=mininode_lock)\n \n     def wait_for_inv(self, expected_inv, timeout=60):\n         \"\"\"Waits for an INV message and checks that the first inv object in the message was as expected.\"\"\"\n         if len(expected_inv) > 1:\n             raise NotImplementedError(\"wait_for_inv() will only verify the first inv object\")\n-        test_function = lambda: self.last_message.get(\"inv\") and \\\n+\n+        def test_function():\n+            assert self.is_connected\n+            return self.last_message.get(\"inv\") and \\\n                                 self.last_message[\"inv\"].inv[0].type == expected_inv[0].type and \\\n                                 self.last_message[\"inv\"].inv[0].hash == expected_inv[0].hash\n+\n         wait_until(test_function, timeout=timeout, lock=mininode_lock)\n \n     def wait_for_verack(self, timeout=60):\n-        test_function = lambda: self.message_count[\"verack\"]\n+        def test_function():\n+            return self.message_count[\"verack\"]\n+\n         wait_until(test_function, timeout=timeout, lock=mininode_lock)\n \n     # Message sending helper functions\n@@ -424,7 +443,11 @@ def send_and_ping(self, message, timeout=60):\n     # Sync up with the node\n     def sync_with_ping(self, timeout=60):\n         self.send_message(msg_ping(nonce=self.ping_counter))\n-        test_function = lambda: self.last_message.get(\"pong\") and self.last_message[\"pong\"].nonce == self.ping_counter\n+\n+        def test_function():\n+            assert self.is_connected\n+            return self.last_message.get(\"pong\") and self.last_message[\"pong\"].nonce == self.ping_counter\n+\n         wait_until(test_function, timeout=timeout, lock=mininode_lock)\n         self.ping_counter += 1\n "
      }
    ]
  }
]