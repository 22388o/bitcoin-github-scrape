[
  {
    "sha": "e40797b0bfd0e410890abfe26ee879756483d399",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNDA3OTdiMGJmZDBlNDEwODkwYWJmZTI2ZWU4Nzk3NTY0ODNkMzk5",
    "commit": {
      "author": {
        "name": "Prayank",
        "email": "prayank23@outlook.com",
        "date": "2021-02-09T12:52:12Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-02-09T12:52:12Z"
      },
      "message": "Highlight DNS requests note",
      "tree": {
        "sha": "05cd959a31cfd8704d222f09cc789cdc06140cd2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/05cd959a31cfd8704d222f09cc789cdc06140cd2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e40797b0bfd0e410890abfe26ee879756483d399",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgIoV8CRBK7hj4Ov3rIwAAdHIIAATH5ogqkf4Lih8ERBDT5FkV\ngHhR3a7TxqbqFJtVRSHSIya8EwAYDIFzvHmPAdnSGFhb02MRkWIAXKYS1K9G2H04\nE4WxZy31NDzjv33C0U6Qdy6IkjZ45YDJ06pgH/WbNktKZ7Fp3lCCFFLBa0OYqcBj\ni6RzBS5ImHuNctC/B+OpuDuBxbHcTEER5nSqrL1JnMPCi+C2IqLPzSH5j96j5cjj\nUkcu1cdLOKF7OSrh5fyDP3QSUpBro8pZSfLn9TbagKU0byIxZa8lq0TsAPlIPzMH\nTybceO/LyQjUuIfx924HfqGgBTmo+oLvVWW+flOE1temqmBbeZMW8MA5Rlq4gp0=\n=Urdj\n-----END PGP SIGNATURE-----\n",
        "payload": "tree 05cd959a31cfd8704d222f09cc789cdc06140cd2\nparent 6c6140846f37de8c132b3b6abf09f3d7940554a7\nauthor Prayank <prayank23@outlook.com> 1612875132 +0530\ncommitter GitHub <noreply@github.com> 1612875132 +0530\n\nHighlight DNS requests note"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e40797b0bfd0e410890abfe26ee879756483d399",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e40797b0bfd0e410890abfe26ee879756483d399",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e40797b0bfd0e410890abfe26ee879756483d399/comments",
    "author": {
      "login": "prayank23",
      "id": 13405205,
      "node_id": "MDQ6VXNlcjEzNDA1MjA1",
      "avatar_url": "https://avatars.githubusercontent.com/u/13405205?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/prayank23",
      "html_url": "https://github.com/prayank23",
      "followers_url": "https://api.github.com/users/prayank23/followers",
      "following_url": "https://api.github.com/users/prayank23/following{/other_user}",
      "gists_url": "https://api.github.com/users/prayank23/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/prayank23/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/prayank23/subscriptions",
      "organizations_url": "https://api.github.com/users/prayank23/orgs",
      "repos_url": "https://api.github.com/users/prayank23/repos",
      "events_url": "https://api.github.com/users/prayank23/events{/privacy}",
      "received_events_url": "https://api.github.com/users/prayank23/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6c6140846f37de8c132b3b6abf09f3d7940554a7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6c6140846f37de8c132b3b6abf09f3d7940554a7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6c6140846f37de8c132b3b6abf09f3d7940554a7"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 2,
      "deletions": 3
    },
    "files": [
      {
        "sha": "c037980960dcd7af67af6bef75f28b64aee0f20e",
        "filename": "doc/tor.md",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e40797b0bfd0e410890abfe26ee879756483d399/doc/tor.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e40797b0bfd0e410890abfe26ee879756483d399/doc/tor.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/tor.md?ref=e40797b0bfd0e410890abfe26ee879756483d399",
        "patch": "@@ -29,9 +29,8 @@ outgoing connections, but more is possible.\n \t-onion=ip:port  Set the proxy server to use for Tor onion services. You do not\n \t                need to set this if it's the same as -proxy. You can use -onion=0\n \t                to explicitly disable access to onion services.\n-\t                Note: Only the -proxy option sets the proxy for DNS requests;\n-\t                with -onion they will not route over Tor, so use -proxy if you\n-\t                have privacy concerns.\n+\t\t\t\n+**Note:** _Only the -proxy option sets the proxy for DNS requests with -onion they will not route over Tor, so use -proxy if you have privacy concerns._\n \n \t-listen         When using -proxy, listening is disabled by default. If you want\n \t                to manually configure an onion service (see section 3), you'll"
      }
    ]
  },
  {
    "sha": "d2b75c0c8beef15b2711cf73406ead6f09a1025a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMmI3NWMwYzhiZWVmMTViMjcxMWNmNzM0MDZlYWQ2ZjA5YTEwMjVh",
    "commit": {
      "author": {
        "name": "unknown",
        "email": "prayank23@outlook.com",
        "date": "2021-02-09T13:25:35Z"
      },
      "committer": {
        "name": "unknown",
        "email": "prayank23@outlook.com",
        "date": "2021-02-09T13:25:35Z"
      },
      "message": "Add 2 privacy recommendations",
      "tree": {
        "sha": "2d4bc35625b622e56180f40682b287d2add66ba1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2d4bc35625b622e56180f40682b287d2add66ba1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d2b75c0c8beef15b2711cf73406ead6f09a1025a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d2b75c0c8beef15b2711cf73406ead6f09a1025a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d2b75c0c8beef15b2711cf73406ead6f09a1025a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d2b75c0c8beef15b2711cf73406ead6f09a1025a/comments",
    "author": {
      "login": "prayank23",
      "id": 13405205,
      "node_id": "MDQ6VXNlcjEzNDA1MjA1",
      "avatar_url": "https://avatars.githubusercontent.com/u/13405205?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/prayank23",
      "html_url": "https://github.com/prayank23",
      "followers_url": "https://api.github.com/users/prayank23/followers",
      "following_url": "https://api.github.com/users/prayank23/following{/other_user}",
      "gists_url": "https://api.github.com/users/prayank23/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/prayank23/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/prayank23/subscriptions",
      "organizations_url": "https://api.github.com/users/prayank23/orgs",
      "repos_url": "https://api.github.com/users/prayank23/repos",
      "events_url": "https://api.github.com/users/prayank23/events{/privacy}",
      "received_events_url": "https://api.github.com/users/prayank23/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "prayank23",
      "id": 13405205,
      "node_id": "MDQ6VXNlcjEzNDA1MjA1",
      "avatar_url": "https://avatars.githubusercontent.com/u/13405205?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/prayank23",
      "html_url": "https://github.com/prayank23",
      "followers_url": "https://api.github.com/users/prayank23/followers",
      "following_url": "https://api.github.com/users/prayank23/following{/other_user}",
      "gists_url": "https://api.github.com/users/prayank23/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/prayank23/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/prayank23/subscriptions",
      "organizations_url": "https://api.github.com/users/prayank23/orgs",
      "repos_url": "https://api.github.com/users/prayank23/repos",
      "events_url": "https://api.github.com/users/prayank23/events{/privacy}",
      "received_events_url": "https://api.github.com/users/prayank23/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e40797b0bfd0e410890abfe26ee879756483d399",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e40797b0bfd0e410890abfe26ee879756483d399",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e40797b0bfd0e410890abfe26ee879756483d399"
      }
    ],
    "stats": {
      "total": 12,
      "additions": 11,
      "deletions": 1
    },
    "files": [
      {
        "sha": "fe9a97541e065a01ea27cc3666db50bc1cad4d35",
        "filename": "doc/tor.md",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d2b75c0c8beef15b2711cf73406ead6f09a1025a/doc/tor.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d2b75c0c8beef15b2711cf73406ead6f09a1025a/doc/tor.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/tor.md?ref=d2b75c0c8beef15b2711cf73406ead6f09a1025a",
        "patch": "@@ -29,7 +29,7 @@ outgoing connections, but more is possible.\n \t-onion=ip:port  Set the proxy server to use for Tor onion services. You do not\n \t                need to set this if it's the same as -proxy. You can use -onion=0\n \t                to explicitly disable access to onion services.\n-\t\t\t\n+\n **Note:** _Only the -proxy option sets the proxy for DNS requests with -onion they will not route over Tor, so use -proxy if you have privacy concerns._\n \n \t-listen         When using -proxy, listening is disabled by default. If you want\n@@ -210,3 +210,13 @@ for normal IPv4/IPv6 communication, use:\n   Otherwise it is trivial to link them, which may reduce privacy. Onion\n   services created automatically (as in section 2) always have only one port\n   open.\n+\n+- If you are in an environment that does not permit direct Tor connections,\n+  and does not permit the public bridges, then considering the trade-offs\n+  it probably isn't safe enough to use the Tor network. Example: few places\n+  in China and India\n+\n+- If someone is operating in paranoid mode then the correct move is to not\n+  listen at all on the node they are trying to protect, because any listening\n+  lets attackers actively connect into them. Frequently changing local onion\n+  address will not be helpful."
      }
    ]
  },
  {
    "sha": "48cb025458607ce8b6b63b773f5f32fbe293ee04",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0OGNiMDI1NDU4NjA3Y2U4YjZiNjNiNzczZjVmMzJmYmUyOTNlZTA0",
    "commit": {
      "author": {
        "name": "unknown",
        "email": "prayank23@outlook.com",
        "date": "2021-02-11T18:04:49Z"
      },
      "committer": {
        "name": "unknown",
        "email": "prayank23@outlook.com",
        "date": "2021-02-11T21:18:54Z"
      },
      "message": "Add example",
      "tree": {
        "sha": "4c1a33546498c39dc953106cfb94c0d0e9af51d4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4c1a33546498c39dc953106cfb94c0d0e9af51d4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/48cb025458607ce8b6b63b773f5f32fbe293ee04",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/48cb025458607ce8b6b63b773f5f32fbe293ee04",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/48cb025458607ce8b6b63b773f5f32fbe293ee04",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/48cb025458607ce8b6b63b773f5f32fbe293ee04/comments",
    "author": {
      "login": "prayank23",
      "id": 13405205,
      "node_id": "MDQ6VXNlcjEzNDA1MjA1",
      "avatar_url": "https://avatars.githubusercontent.com/u/13405205?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/prayank23",
      "html_url": "https://github.com/prayank23",
      "followers_url": "https://api.github.com/users/prayank23/followers",
      "following_url": "https://api.github.com/users/prayank23/following{/other_user}",
      "gists_url": "https://api.github.com/users/prayank23/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/prayank23/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/prayank23/subscriptions",
      "organizations_url": "https://api.github.com/users/prayank23/orgs",
      "repos_url": "https://api.github.com/users/prayank23/repos",
      "events_url": "https://api.github.com/users/prayank23/events{/privacy}",
      "received_events_url": "https://api.github.com/users/prayank23/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "prayank23",
      "id": 13405205,
      "node_id": "MDQ6VXNlcjEzNDA1MjA1",
      "avatar_url": "https://avatars.githubusercontent.com/u/13405205?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/prayank23",
      "html_url": "https://github.com/prayank23",
      "followers_url": "https://api.github.com/users/prayank23/followers",
      "following_url": "https://api.github.com/users/prayank23/following{/other_user}",
      "gists_url": "https://api.github.com/users/prayank23/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/prayank23/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/prayank23/subscriptions",
      "organizations_url": "https://api.github.com/users/prayank23/orgs",
      "repos_url": "https://api.github.com/users/prayank23/repos",
      "events_url": "https://api.github.com/users/prayank23/events{/privacy}",
      "received_events_url": "https://api.github.com/users/prayank23/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d2b75c0c8beef15b2711cf73406ead6f09a1025a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d2b75c0c8beef15b2711cf73406ead6f09a1025a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d2b75c0c8beef15b2711cf73406ead6f09a1025a"
      }
    ],
    "stats": {
      "total": 1798,
      "additions": 1201,
      "deletions": 597
    },
    "files": [
      {
        "sha": "691582239e868ddee8b70809c1c288dd5dc16d8d",
        "filename": ".cirrus.yml",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/.cirrus.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/.cirrus.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.cirrus.yml?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -82,10 +82,10 @@ task:\n     FILE_ENV: \"./ci/test/00_setup_env_arm.sh\"\n \n task:\n-  name: 'Win64 [unit tests, no gui tests, no boost::process, no functional tests] [bionic]'\n+  name: 'Win64 [unit tests, no gui tests, no boost::process, no functional tests] [focal]'\n   << : *GLOBAL_TASK_TEMPLATE\n   container:\n-    image: ubuntu:bionic\n+    image: ubuntu:focal\n   env:\n     FILE_ENV: \"./ci/test/00_setup_env_win64.sh\"\n \n@@ -160,10 +160,10 @@ task:\n     FILE_ENV: \"./ci/test/00_setup_env_native_nowallet.sh\"\n \n task:\n-  name: 'macOS 10.14 [gui, no tests] [bionic]'\n+  name: 'macOS 10.14 [gui, no tests] [focal]'\n   << : *GLOBAL_TASK_TEMPLATE\n   container:\n-    image: ubuntu:bionic\n+    image: ubuntu:focal\n   env:\n     FILE_ENV: \"./ci/test/00_setup_env_mac.sh\"\n "
      },
      {
        "sha": "4967e675f642f9877f91a41e2635fc9424c58cda",
        "filename": ".editorconfig",
        "status": "added",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/.editorconfig",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/.editorconfig",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.editorconfig?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -0,0 +1,26 @@\n+# This is the top-most EditorConfig file.\n+root = true\n+\n+# For all files.\n+[*]\n+charset = utf-8\n+end_of_line = lf\n+indent_style = space\n+insert_final_newline = true\n+trim_trailing_whitespace = true\n+\n+# Source code files\n+[*.{h,cpp,py,sh}]\n+indent_size = 4\n+\n+# .cirrus.yml, .appveyor.yml, .fuzzbuzz.yml, etc.\n+[*.yml]\n+indent_size = 2\n+\n+# Makefiles\n+[{*.am,Makefile.*.include}]\n+indent_style = tab\n+\n+# Autoconf scripts\n+[configure.ac]\n+indent_size = 2"
      },
      {
        "sha": "6da011d19b3ed01e6f859d4569b97f071e6e6c95",
        "filename": "ci/test/00_setup_env_mac.sh",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/ci/test/00_setup_env_mac.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/ci/test/00_setup_env_mac.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_mac.sh?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -7,9 +7,9 @@\n export LC_ALL=C.UTF-8\n \n export CONTAINER_NAME=ci_macos_cross\n-export DOCKER_NAME_TAG=ubuntu:18.04  # Check that bionic can cross-compile to macos (bionic is used in the gitian build as well)\n+export DOCKER_NAME_TAG=ubuntu:20.04  # Check that Focal can cross-compile to macos (Focal is used in the gitian build as well)\n export HOST=x86_64-apple-darwin18\n-export PACKAGES=\"cmake imagemagick libcap-dev librsvg2-bin libz-dev libbz2-dev libtiff-tools python3-dev python3-setuptools xorriso\"\n+export PACKAGES=\"cmake imagemagick libcap-dev librsvg2-bin libz-dev libbz2-dev libtiff-tools libtinfo5 python3-dev python3-setuptools xorriso\"\n export XCODE_VERSION=11.3.1\n export XCODE_BUILD_ID=11C505\n export RUN_UNIT_TESTS=false"
      },
      {
        "sha": "bbc43cfabdb166919c5d49ba1c437f924e7a40e5",
        "filename": "ci/test/00_setup_env_native_qt5.sh",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/ci/test/00_setup_env_native_qt5.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/ci/test/00_setup_env_native_qt5.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_native_qt5.sh?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -16,4 +16,5 @@ export RUN_UNIT_TESTS_SEQUENTIAL=\"true\"\n export RUN_UNIT_TESTS=\"false\"\n export GOAL=\"install\"\n export PREVIOUS_RELEASES_TO_DOWNLOAD=\"v0.15.2 v0.16.3 v0.17.2 v0.18.1 v0.19.1\"\n-export BITCOIN_CONFIG=\"--enable-zmq --with-libs=no --with-gui=qt5 --enable-glibc-back-compat --enable-reduce-exports --enable-debug CFLAGS=\\\"-g0 -O2 -funsigned-char\\\" CXXFLAGS=\\\"-g0 -O2 -funsigned-char\\\" --with-boost-process\"\n+export BITCOIN_CONFIG=\"--enable-zmq --with-libs=no --with-gui=qt5 --enable-glibc-back-compat --enable-reduce-exports\n+--enable-debug --disable-fuzz-binary  CFLAGS=\\\"-g0 -O2 -funsigned-char\\\" CXXFLAGS=\\\"-g0 -O2 -funsigned-char\\\" --with-boost-process\""
      },
      {
        "sha": "3eea0a4565a8e16593c1d6a1fb88f13bec1ff255",
        "filename": "ci/test/00_setup_env_win64.sh",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/ci/test/00_setup_env_win64.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/ci/test/00_setup_env_win64.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_win64.sh?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -7,13 +7,13 @@\n export LC_ALL=C.UTF-8\n \n export CONTAINER_NAME=ci_win64\n-export DOCKER_NAME_TAG=ubuntu:18.04  # Check that bionic can cross-compile to win64 (bionic is used in the gitian build as well)\n+export DOCKER_NAME_TAG=ubuntu:20.04  # Check that Focal can cross-compile to win64 (Focal is used in the gitian build as well)\n export HOST=x86_64-w64-mingw32\n-export PACKAGES=\"python3 nsis g++-mingw-w64-x86-64 wine-binfmt wine64 file\"\n+export DPKG_ADD_ARCH=\"i386\"\n+export PACKAGES=\"python3 nsis g++-mingw-w64-x86-64 wine-binfmt wine64 wine32 file\"\n export RUN_FUNCTIONAL_TESTS=false\n-export RUN_SECURITY_TESTS=\"true\"\n export GOAL=\"deploy\"\n-export BITCOIN_CONFIG=\"--enable-reduce-exports --disable-gui-tests --without-boost-process\"\n+export BITCOIN_CONFIG=\"--enable-reduce-exports --disable-fuzz-binary --disable-gui-tests --without-boost-process\"\n \n # Compiler for MinGW-w64 causes false -Wreturn-type warning.\n # See https://sourceforge.net/p/mingw-w64/bugs/306/"
      },
      {
        "sha": "82964897e133f4e6459665382983ea88319c930a",
        "filename": "ci/test/wrap-wine.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/ci/test/wrap-wine.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/ci/test/wrap-wine.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/wrap-wine.sh?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -13,7 +13,7 @@ for b_name in {\"${BASE_OUTDIR}/bin\"/*,src/secp256k1/*tests,src/univalue/{no_nul,\n         echo \"Wrap $b ...\"\n         mv \"$b\" \"${b}_orig\"\n         echo '#!/usr/bin/env bash' > \"$b\"\n-        echo \"wine64 \\\"${b}_orig\\\" \\\"\\$@\\\"\" >> \"$b\"\n+        echo \"( wine \\\"${b}_orig\\\" \\\"\\$@\\\" ) || ( sleep 1 && wine \\\"${b}_orig\\\" \\\"\\$@\\\" )\" >> \"$b\"\n         chmod +x \"$b\"\n       fi\n     done"
      },
      {
        "sha": "4ac985abdcafaf0ad8d5dd965c42a1d6cc5575e0",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 19,
        "deletions": 4,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -184,10 +184,16 @@ AC_ARG_ENABLE([extended-functional-tests],\n \n AC_ARG_ENABLE([fuzz],\n     AS_HELP_STRING([--enable-fuzz],\n-    [enable building of fuzz targets (default no). enabling this will disable all other targets]),\n+    [build for fuzzing (default no). enabling this will disable all other targets and override --{enable,disable}-fuzz-binary]),\n     [enable_fuzz=$enableval],\n     [enable_fuzz=no])\n \n+AC_ARG_ENABLE([fuzz-binary],\n+    AS_HELP_STRING([--enable-fuzz-binary],\n+    [enable building of fuzz binary (default yes).]),\n+    [enable_fuzz_binary=$enableval],\n+    [enable_fuzz_binary=yes])\n+\n AC_ARG_ENABLE([danger_fuzz_link_all],\n     AS_HELP_STRING([--enable-danger-fuzz-link-all],\n     [Danger! Modifies source code. Needs git and gnu sed installed. Link each fuzz target (default no).]),\n@@ -854,7 +860,10 @@ if test x$use_hardening != xno; then\n   AX_CHECK_COMPILE_FLAG([-Wstack-protector],[HARDENED_CXXFLAGS=\"$HARDENED_CXXFLAGS -Wstack-protector\"])\n   AX_CHECK_COMPILE_FLAG([-fstack-protector-all],[HARDENED_CXXFLAGS=\"$HARDENED_CXXFLAGS -fstack-protector-all\"])\n \n-  AX_CHECK_COMPILE_FLAG([-fcf-protection=full],[HARDENED_CXXFLAGS=\"$HARDENED_CXXFLAGS -fcf-protection=full\"])\n+  dnl -fcf-protection used with Clang 7 causes ld to emit warnings:\n+  dnl ld: error: ... <corrupt x86 feature size: 0x8>\n+  dnl Use CHECK_LINK_FLAG & --fatal-warnings to ensure we wont use the flag in this case.\n+  AX_CHECK_LINK_FLAG([-fcf-protection=full],[HARDENED_CXXFLAGS=\"$HARDENED_CXXFLAGS -fcf-protection=full\"],, [[$LDFLAG_WERROR]])\n \n   dnl stack-clash-protection does not work properly when building for Windows.\n   dnl We use the test case from https://gcc.gnu.org/bugzilla/show_bug.cgi?id=90458\n@@ -1224,7 +1233,7 @@ AC_DEFUN([SUPPRESS_WARNINGS],\n \n dnl enable-fuzz should disable all other targets\n if test \"x$enable_fuzz\" = \"xyes\"; then\n-  AC_MSG_WARN(enable-fuzz will disable all other targets)\n+  AC_MSG_WARN(enable-fuzz will disable all other targets and force --enable-fuzz-binary=yes)\n   build_bitcoin_utils=no\n   build_bitcoin_cli=no\n   build_bitcoin_tx=no\n@@ -1240,10 +1249,11 @@ if test \"x$enable_fuzz\" = \"xyes\"; then\n   use_upnp=no\n   use_natpmp=no\n   use_zmq=no\n+  enable_fuzz_binary=yes\n \n   AX_CHECK_PREPROC_FLAG([-DABORT_ON_FAILED_ASSUME],[[DEBUG_CPPFLAGS=\"$DEBUG_CPPFLAGS -DABORT_ON_FAILED_ASSUME\"]],,[[$CXXFLAG_WERROR]])\n \n-  AC_MSG_CHECKING([whether main function is needed])\n+  AC_MSG_CHECKING([whether main function is needed for fuzz binary])\n   AX_CHECK_LINK_FLAG(\n     [[-fsanitize=$use_sanitizers]],\n     [AC_MSG_RESULT([no])],\n@@ -1271,6 +1281,8 @@ else\n     QT_DBUS_INCLUDES=SUPPRESS_WARNINGS($QT_DBUS_INCLUDES)\n     QT_TEST_INCLUDES=SUPPRESS_WARNINGS($QT_TEST_INCLUDES)\n   fi\n+\n+  CPPFLAGS=\"$CPPFLAGS -DPROVIDE_MAIN_FUNCTION\"\n fi\n \n if test x$enable_wallet != xno; then\n@@ -1716,6 +1728,7 @@ AM_CONDITIONAL([USE_BDB], [test \"x$use_bdb\" = \"xyes\"])\n AM_CONDITIONAL([ENABLE_TRACING],[test x$have_sdt = xyes])\n AM_CONDITIONAL([ENABLE_TESTS],[test x$BUILD_TEST = xyes])\n AM_CONDITIONAL([ENABLE_FUZZ],[test x$enable_fuzz = xyes])\n+AM_CONDITIONAL([ENABLE_FUZZ_BINARY],[test x$enable_fuzz_binary = xyes])\n AM_CONDITIONAL([ENABLE_FUZZ_LINK_ALL],[test x$enable_danger_fuzz_link_all = xyes])\n AM_CONDITIONAL([ENABLE_QT],[test x$bitcoin_enable_qt = xyes])\n AM_CONDITIONAL([ENABLE_QT_TESTS],[test x$BUILD_TEST_QT = xyes])\n@@ -1732,6 +1745,8 @@ AM_CONDITIONAL([ENABLE_SHANI],[test x$enable_shani = xyes])\n AM_CONDITIONAL([ENABLE_ARM_CRC],[test x$enable_arm_crc = xyes])\n AM_CONDITIONAL([USE_ASM],[test x$use_asm = xyes])\n AM_CONDITIONAL([WORDS_BIGENDIAN],[test x$ac_cv_c_bigendian = xyes])\n+AM_CONDITIONAL([USE_NATPMP],[test x$use_natpmp = xyes])\n+AM_CONDITIONAL([USE_UPNP],[test x$use_upnp = xyes])\n \n AC_DEFINE(CLIENT_VERSION_MAJOR, _CLIENT_VERSION_MAJOR, [Major version])\n AC_DEFINE(CLIENT_VERSION_MINOR, _CLIENT_VERSION_MINOR, [Minor version])"
      },
      {
        "sha": "60acb0d59333b41e58079ddcff6e5a150d37df4a",
        "filename": "contrib/gitian-build.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/contrib/gitian-build.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/contrib/gitian-build.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-build.py?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -35,14 +35,14 @@ def setup():\n     if not os.path.isdir('bitcoin'):\n         subprocess.check_call(['git', 'clone', 'https://github.com/bitcoin/bitcoin.git'])\n     os.chdir('gitian-builder')\n-    make_image_prog = ['bin/make-base-vm', '--suite', 'bionic', '--arch', 'amd64']\n+    make_image_prog = ['bin/make-base-vm', '--suite', 'focal', '--arch', 'amd64']\n     if args.docker:\n         make_image_prog += ['--docker']\n     elif not args.kvm:\n-        make_image_prog += ['--lxc']\n+        make_image_prog += ['--lxc', '--disksize', '13000']\n     subprocess.check_call(make_image_prog)\n     os.chdir(workdir)\n-    if args.is_bionic and not args.kvm and not args.docker:\n+    if args.is_focal and not args.kvm and not args.docker:\n         subprocess.check_call(['sudo', 'sed', '-i', 's/lxcbr0/br0/', '/etc/default/lxc-net'])\n         print('Reboot is required')\n         sys.exit(0)\n@@ -176,7 +176,7 @@ def main():\n     args = parser.parse_args()\n     workdir = os.getcwd()\n \n-    args.is_bionic = b'bionic' in subprocess.check_output(['lsb_release', '-cs'])\n+    args.is_focal = b'focal' in subprocess.check_output(['lsb_release', '-cs'])\n \n     if args.kvm and args.docker:\n         raise Exception('Error: cannot have both kvm and docker')"
      },
      {
        "sha": "b06fc782a314ada1c0de7fc2d81f96f5ddbb9fba",
        "filename": "contrib/gitian-descriptors/gitian-linux.yml",
        "status": "modified",
        "additions": 7,
        "deletions": 5,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/contrib/gitian-descriptors/gitian-linux.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/contrib/gitian-descriptors/gitian-linux.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-linux.yml?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -3,7 +3,7 @@ name: \"bitcoin-core-linux-22\"\n enable_cache: true\n distro: \"ubuntu\"\n suites:\n-- \"bionic\"\n+- \"focal\"\n architectures:\n - \"amd64\"\n packages:\n@@ -15,6 +15,8 @@ packages:\n - \"ca-certificates\"\n - \"curl\"\n - \"faketime\"\n+- \"g++-8\"\n+- \"gcc-8\"\n - \"git\"\n - \"libtool\"\n - \"patch\"\n@@ -45,7 +47,7 @@ script: |\n \n   WRAP_DIR=$HOME/wrapped\n   HOSTS=\"x86_64-linux-gnu arm-linux-gnueabihf aarch64-linux-gnu powerpc64-linux-gnu powerpc64le-linux-gnu riscv64-linux-gnu\"\n-  CONFIGFLAGS=\"--enable-glibc-back-compat --enable-reduce-exports --disable-bench --disable-gui-tests\"\n+  CONFIGFLAGS=\"--enable-glibc-back-compat --enable-reduce-exports --disable-bench --disable-gui-tests --disable-fuzz-binary\"\n   FAKETIME_HOST_PROGS=\"gcc g++\"\n   FAKETIME_PROGS=\"date ar ranlib nm\"\n   HOST_CFLAGS=\"-O2 -g\"\n@@ -107,7 +109,7 @@ script: |\n   BASEPREFIX=\"${PWD}/depends\"\n   # Build dependencies for each host\n   for i in $HOSTS; do\n-    make ${MAKEOPTS} -C ${BASEPREFIX} HOST=\"${i}\"\n+    make ${MAKEOPTS} -C ${BASEPREFIX} HOST=\"${i}\" CC=${i}-gcc-8 CXX=${i}-g++-8\n   done\n \n   # Faketime for binaries\n@@ -130,7 +132,7 @@ script: |\n   # Extract the git archive into a dir for each host and build\n   for i in ${HOSTS}; do\n     export PATH=${BASEPREFIX}/${i}/native/bin:${ORIGPATH}\n-    if [ \"${i}\" = \"riscv64-linux-gnu\" ] || [ \"${i}\" = \"powerpc64-linux-gnu\" ] || [ \"${i}\" = \"powerpc64le-linux-gnu\" ]; then\n+    if [ \"${i}\" = \"powerpc64-linux-gnu\" ]; then\n       # Workaround for https://bugs.launchpad.net/ubuntu/+source/gcc-8-cross-ports/+bug/1853740\n       # TODO: remove this when no longer needed\n       HOST_LDFLAGS=\"${HOST_LDFLAGS_BASE} -Wl,-z,noexecstack\"\n@@ -144,7 +146,7 @@ script: |\n     tar --strip-components=1 -xf \"${GIT_ARCHIVE}\"\n \n     ./autogen.sh\n-    CONFIG_SITE=${BASEPREFIX}/${i}/share/config.site ./configure --prefix=/ --disable-ccache --disable-maintainer-mode --disable-dependency-tracking ${CONFIGFLAGS} CFLAGS=\"${HOST_CFLAGS}\" CXXFLAGS=\"${HOST_CXXFLAGS}\" LDFLAGS=\"${HOST_LDFLAGS}\"\n+    CONFIG_SITE=${BASEPREFIX}/${i}/share/config.site ./configure --prefix=/ --disable-ccache --disable-maintainer-mode --disable-dependency-tracking ${CONFIGFLAGS} CFLAGS=\"${HOST_CFLAGS}\" CXXFLAGS=\"${HOST_CXXFLAGS}\" LDFLAGS=\"${HOST_LDFLAGS}\" CC=${i}-gcc-8 CXX=${i}-g++-8\n     make ${MAKEOPTS}\n     make ${MAKEOPTS} -C src check-security\n     make ${MAKEOPTS} -C src check-symbols"
      },
      {
        "sha": "3f0c0c3332c7981cfda48763af8c67e72ccd0acc",
        "filename": "contrib/gitian-descriptors/gitian-osx-signer.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/contrib/gitian-descriptors/gitian-osx-signer.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/contrib/gitian-descriptors/gitian-osx-signer.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-osx-signer.yml?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -2,7 +2,7 @@\n name: \"bitcoin-dmg-signer\"\n distro: \"ubuntu\"\n suites:\n-- \"bionic\"\n+- \"focal\"\n architectures:\n - \"amd64\"\n packages:"
      },
      {
        "sha": "0dc531df0e686a611912492bbbb65f3abdb4afec",
        "filename": "contrib/gitian-descriptors/gitian-osx.yml",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/contrib/gitian-descriptors/gitian-osx.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/contrib/gitian-descriptors/gitian-osx.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-osx.yml?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -3,7 +3,7 @@ name: \"bitcoin-core-osx-22\"\n enable_cache: true\n distro: \"ubuntu\"\n suites:\n-- \"bionic\"\n+- \"focal\"\n architectures:\n - \"amd64\"\n packages:\n@@ -29,6 +29,7 @@ packages:\n - \"python3-setuptools\"\n - \"fonts-tuffy\"\n - \"xorriso\"\n+- \"libtinfo5\"\n remotes:\n - \"url\": \"https://github.com/bitcoin/bitcoin.git\"\n   \"dir\": \"bitcoin\"\n@@ -39,7 +40,7 @@ script: |\n \n   WRAP_DIR=$HOME/wrapped\n   HOSTS=\"x86_64-apple-darwin18\"\n-  CONFIGFLAGS=\"--enable-reduce-exports --disable-bench --disable-gui-tests XORRISOFS=${WRAP_DIR}/xorrisofs DMG=${WRAP_DIR}/dmg\"\n+  CONFIGFLAGS=\"--enable-reduce-exports --disable-bench --disable-gui-tests --disable-fuzz-binary XORRISOFS=${WRAP_DIR}/xorrisofs DMG=${WRAP_DIR}/dmg\"\n   FAKETIME_HOST_PROGS=\"\"\n   FAKETIME_PROGS=\"ar ranlib date dmg xorrisofs\"\n "
      },
      {
        "sha": "c13c24c3cc332316c044fcf3a1a41227894fa1b2",
        "filename": "contrib/gitian-descriptors/gitian-win-signer.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/contrib/gitian-descriptors/gitian-win-signer.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/contrib/gitian-descriptors/gitian-win-signer.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-win-signer.yml?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -2,7 +2,7 @@\n name: \"bitcoin-win-signer\"\n distro: \"ubuntu\"\n suites:\n-- \"bionic\"\n+- \"focal\"\n architectures:\n - \"amd64\"\n packages:"
      },
      {
        "sha": "95cf0185e24f0f39178a1a892bfec1bb195f8dd1",
        "filename": "contrib/gitian-descriptors/gitian-win.yml",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/contrib/gitian-descriptors/gitian-win.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/contrib/gitian-descriptors/gitian-win.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-win.yml?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -3,7 +3,7 @@ name: \"bitcoin-core-win-22\"\n enable_cache: true\n distro: \"ubuntu\"\n suites:\n-- \"bionic\"\n+- \"focal\"\n architectures:\n - \"amd64\"\n packages:\n@@ -31,7 +31,7 @@ script: |\n \n   WRAP_DIR=$HOME/wrapped\n   HOSTS=\"x86_64-w64-mingw32\"\n-  CONFIGFLAGS=\"--enable-reduce-exports --disable-bench --disable-gui-tests\"\n+  CONFIGFLAGS=\"--enable-reduce-exports --disable-bench --disable-gui-tests --disable-fuzz-binary\"\n   FAKETIME_HOST_PROGS=\"ar ranlib nm windres strip objcopy\"\n   FAKETIME_PROGS=\"date makensis zip\"\n   HOST_CFLAGS=\"-O2 -g -fno-ident\""
      },
      {
        "sha": "8ea9e0059644cf03496a376cabd330aa86069e72",
        "filename": "contrib/guix/libexec/build.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/contrib/guix/libexec/build.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/contrib/guix/libexec/build.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/guix/libexec/build.sh?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -204,7 +204,7 @@ fi\n ###########################\n \n # CONFIGFLAGS\n-CONFIGFLAGS=\"--enable-reduce-exports --disable-bench --disable-gui-tests\"\n+CONFIGFLAGS=\"--enable-reduce-exports --disable-bench --disable-gui-tests --disable-fuzz-binary\"\n case \"$HOST\" in\n     *linux*) CONFIGFLAGS+=\" --enable-glibc-back-compat\" ;;\n esac"
      },
      {
        "sha": "ea06952af49a00029a92c78226060d5c416ebae7",
        "filename": "doc/REST-interface.md",
        "status": "modified",
        "additions": 1,
        "deletions": 6,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/doc/REST-interface.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/doc/REST-interface.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/REST-interface.md?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -111,12 +111,7 @@ $ curl localhost:18332/rest/getutxos/checkmempool/b2cdfd7b89def827ff8af7cd9bff76\n \n Returns various information about the TX mempool.\n Only supports JSON as output format.\n-* loaded : (boolean) if the mempool is fully loaded\n-* size : (numeric) the number of transactions in the TX mempool\n-* bytes : (numeric) size of the TX mempool in bytes\n-* usage : (numeric) total TX mempool memory usage\n-* maxmempool : (numeric) maximum memory usage for the mempool in bytes\n-* mempoolminfee : (numeric) minimum feerate (BTC per KB) for tx to be accepted\n+Refer to the `getmempoolinfo` RPC for documentation of the fields.\n \n `GET /rest/mempool/contents.json`\n "
      },
      {
        "sha": "40514408865908b173e6b9df351ed5f9dc14c807",
        "filename": "doc/build-unix.md",
        "status": "modified",
        "additions": 15,
        "deletions": 15,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/doc/build-unix.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/doc/build-unix.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-unix.md?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -9,7 +9,7 @@ Note\n Always use absolute paths to configure and compile Bitcoin Core and the dependencies.\n For example, when specifying the path of the dependency:\n \n-\t../dist/configure --enable-cxx --disable-shared --with-pic --prefix=$BDB_PREFIX\n+    ../dist/configure --enable-cxx --disable-shared --with-pic --prefix=$BDB_PREFIX\n \n Here BDB_PREFIX must be an absolute path - it is defined using $(pwd) which ensures\n the usage of the absolute path.\n@@ -166,9 +166,9 @@ miniupnpc\n https://miniupnp.tuxfamily.org/files/).  UPnP support is compiled in and\n turned off by default.  See the configure options for UPnP behavior desired:\n \n-\t--without-miniupnpc      No UPnP support, miniupnp not required\n-\t--disable-upnp-default   (the default) UPnP support turned off by default at runtime\n-\t--enable-upnp-default    UPnP support turned on by default at runtime\n+    --without-miniupnpc      No UPnP support, miniupnp not required\n+    --disable-upnp-default   (the default) UPnP support turned off by default at runtime\n+    --enable-upnp-default    UPnP support turned on by default at runtime\n \n libnatpmp\n ---------\n@@ -177,9 +177,9 @@ libnatpmp\n from [here](https://miniupnp.tuxfamily.org/files/). NAT-PMP support is compiled in and\n turned off by default. See the configure options for NAT-PMP behavior desired:\n \n-\t--without-natpmp          No NAT-PMP support, libnatpmp not required\n-\t--disable-natpmp-default  (the default) NAT-PMP support turned off by default at runtime\n-\t--enable-natpmp-default   NAT-PMP support turned on by default at runtime\n+    --without-natpmp          No NAT-PMP support, libnatpmp not required\n+    --disable-natpmp-default  (the default) NAT-PMP support turned off by default at runtime\n+    --enable-natpmp-default   NAT-PMP support turned on by default at runtime\n \n Berkeley DB\n -----------\n@@ -199,9 +199,9 @@ Boost\n -----\n If you need to build Boost yourself:\n \n-\tsudo su\n-\t./bootstrap.sh\n-\t./bjam install\n+    sudo su\n+    ./bootstrap.sh\n+    ./bjam install\n \n \n Security\n@@ -212,8 +212,8 @@ This can be disabled with:\n \n Hardening Flags:\n \n-\t./configure --enable-hardening\n-\t./configure --disable-hardening\n+    ./configure --enable-hardening\n+    ./configure --disable-hardening\n \n \n Hardening enables the following features:\n@@ -228,7 +228,7 @@ Hardening enables the following features:\n \n     To test that you have built PIE executable, install scanelf, part of paxutils, and use:\n \n-    \tscanelf -e ./bitcoin\n+        scanelf -e ./bitcoin\n \n     The output should contain:\n \n@@ -245,8 +245,8 @@ Hardening enables the following features:\n     `scanelf -e ./bitcoin`\n \n     The output should contain:\n-\tSTK/REL/PTL\n-\tRW- R-- RW-\n+    STK/REL/PTL\n+    RW- R-- RW-\n \n     The STK RW- means that the stack is readable and writeable but not executable.\n "
      },
      {
        "sha": "c4fc2a66bf2810cc4c6dc5ffed8f367cdddc1572",
        "filename": "doc/descriptors.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/doc/descriptors.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/doc/descriptors.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/descriptors.md?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -191,7 +191,7 @@ steps, or for dumping wallet descriptors including private key material.\n In order to easily represent the sets of scripts currently supported by\n existing Bitcoin Core wallets, a convenience function `combo` is\n provided, which takes as input a public key, and describes a set of P2PK,\n-P2PKH, P2WPKH, and P2SH-P2WPH scripts for that key. In case the key is\n+P2PKH, P2WPKH, and P2SH-P2WPKH scripts for that key. In case the key is\n uncompressed, the set only includes P2PK and P2PKH scripts.\n \n ### Checksums"
      },
      {
        "sha": "399b819bf4141859b1b359fa689cd214ad56007b",
        "filename": "doc/init.md",
        "status": "modified",
        "additions": 10,
        "deletions": 9,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/doc/init.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/doc/init.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/init.md?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -53,11 +53,12 @@ Paths\n \n All three configurations assume several paths that might need to be adjusted.\n \n-Binary:              `/usr/bin/bitcoind`\n-Configuration file:  `/etc/bitcoin/bitcoin.conf`\n-Data directory:      `/var/lib/bitcoind`\n-PID file:            `/var/run/bitcoind/bitcoind.pid` (OpenRC and Upstart) or `/run/bitcoind/bitcoind.pid` (systemd)\n-Lock file:           `/var/lock/subsys/bitcoind` (CentOS)\n+    Binary:              /usr/bin/bitcoind\n+    Configuration file:  /etc/bitcoin/bitcoin.conf\n+    Data directory:      /var/lib/bitcoind\n+    PID file:            /var/run/bitcoind/bitcoind.pid (OpenRC and Upstart) or\n+                         /run/bitcoind/bitcoind.pid (systemd)\n+    Lock file:           /var/lock/subsys/bitcoind (CentOS)\n \n The PID directory (if applicable) and data directory should both be owned by the\n bitcoin user and group. It is advised for security reasons to make the\n@@ -83,10 +84,10 @@ OpenRC).\n \n ### macOS\n \n-Binary:              `/usr/local/bin/bitcoind`\n-Configuration file:  `~/Library/Application Support/Bitcoin/bitcoin.conf`\n-Data directory:      `~/Library/Application Support/Bitcoin`\n-Lock file:           `~/Library/Application Support/Bitcoin/.lock`\n+    Binary:              /usr/local/bin/bitcoind\n+    Configuration file:  ~/Library/Application Support/Bitcoin/bitcoin.conf\n+    Data directory:      ~/Library/Application Support/Bitcoin\n+    Lock file:           ~/Library/Application Support/Bitcoin/.lock\n \n Installing Service Configuration\n -----------------------------------"
      },
      {
        "sha": "7519cf38bd4a4bfb4659b53569eb1f1ac5390399",
        "filename": "doc/tor.md",
        "status": "modified",
        "additions": 104,
        "deletions": 57,
        "changes": 161,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/doc/tor.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/doc/tor.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/tor.md?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -21,38 +21,39 @@ information in the debug log about your Tor configuration.\n The first step is running Bitcoin Core behind a Tor proxy. This will already anonymize all\n outgoing connections, but more is possible.\n \n-\t-proxy=ip:port  Set the proxy server. If SOCKS5 is selected (default), this proxy\n-\t                server will be used to try to reach .onion addresses as well.\n-\t                You need to use -noonion or -onion=0 to explicitly disable\n-\t                outbound access to onion services.\n-\n-\t-onion=ip:port  Set the proxy server to use for Tor onion services. You do not\n-\t                need to set this if it's the same as -proxy. You can use -onion=0\n-\t                to explicitly disable access to onion services.\n-\n-**Note:** _Only the -proxy option sets the proxy for DNS requests with -onion they will not route over Tor, so use -proxy if you have privacy concerns._\n-\n-\t-listen         When using -proxy, listening is disabled by default. If you want\n-\t                to manually configure an onion service (see section 3), you'll\n-\t                need to enable it explicitly.\n-\n-\t-connect=X      When behind a Tor proxy, you can specify .onion addresses instead\n-\t-addnode=X      of IP addresses or hostnames in these parameters. It requires\n-\t-seednode=X     SOCKS5. In Tor mode, such addresses can also be exchanged with\n-\t                other P2P nodes.\n-\n-\t-onlynet=onion  Make outgoing connections only to .onion addresses. Incoming\n-\t                connections are not affected by this option. This option can be\n-\t                specified multiple times to allow multiple network types, e.g.\n-\t                ipv4, ipv6 or onion. If you use this option with values other\n-\t                than onion you *cannot* disable onion connections; outgoing onion\n-\t                connections will be enabled when you use -proxy or -onion. Use\n-\t                -noonion or -onion=0 if you want to be sure there are no outbound\n-\t                onion connections over the default proxy or your defined -proxy.\n+    -proxy=ip:port  Set the proxy server. If SOCKS5 is selected (default), this proxy\n+                    server will be used to try to reach .onion addresses as well.\n+                    You need to use -noonion or -onion=0 to explicitly disable\n+                    outbound access to onion services.\n+\n+    -onion=ip:port  Set the proxy server to use for Tor onion services. You do not\n+                    need to set this if it's the same as -proxy. You can use -onion=0\n+                    to explicitly disable access to onion services.\n+\n+    **Note:** _Only the -proxy option sets the proxy for DNS requests with -onion they\n+    will not route over Tor, so use -proxy if you have privacy concerns._\n+\n+    -listen         When using -proxy, listening is disabled by default. If you want\n+                    to manually configure an onion service (see section 3), you'll\n+                    need to enable it explicitly.\n+\n+    -connect=X      When behind a Tor proxy, you can specify .onion addresses instead\n+    -addnode=X      of IP addresses or hostnames in these parameters. It requires\n+    -seednode=X     SOCKS5. In Tor mode, such addresses can also be exchanged with\n+                    other P2P nodes.\n+\n+    -onlynet=onion  Make outgoing connections only to .onion addresses. Incoming\n+                    connections are not affected by this option. This option can be\n+                    specified multiple times to allow multiple network types, e.g.\n+                    ipv4, ipv6 or onion. If you use this option with values other\n+                    than onion you *cannot* disable onion connections; outgoing onion\n+                    connections will be enabled when you use -proxy or -onion. Use\n+                    -noonion or -onion=0 if you want to be sure there are no outbound\n+                    onion connections over the default proxy or your defined -proxy.\n \n In a typical situation, this suffices to run behind a Tor proxy:\n \n-\t./bitcoind -proxy=127.0.0.1:9050\n+    ./bitcoind -proxy=127.0.0.1:9050\n \n ## 2. Automatically create a Bitcoin Core onion service\n \n@@ -145,63 +146,109 @@ password` (refer to the [Tor Dev\n Manual](https://2019.www.torproject.org/docs/tor-manual.html.en) for more\n details).\n \n+## Example: Bitcoin Core Onion Service on Ubuntu 20.04.2 LTS\n+\n+- Assuming Bitcoin Core already exists on this machine.\n+\n+   Install Tor:\n+\n+  `sudo apt install tor`\n+\n+   Setup Control Port:\n+\n+  `sudo nano /etc/tor/torrc`\n+\n+  Add below lines and save:\n+\n+  ```\n+  ControlPort 9051\n+  CookieAuthentication 1\n+  CookieAuthFileGroupReadable 1\n+  ```\n+  Add user('satoshi' in this example) to Tor group:\n+\n+  `sudo usermod -a -G debian-tor satoshi`\n+\n+  Restart Tor:\n+\n+  `sudo systemctl restart tor`\n+\n+- Details of `bitcoin.conf` file:\n+\n+  ```\n+  listen=1\n+  torcontrol=127.0.0.1:9051\n+  onlynet=onion\n+  debug=tor\n+  ```\n+- Result for `getnetworkinfo`:\n+\n+  ```\n+  localaddresses\": [\n+    {\n+      \"address\": \"omy7kj7zwvfg5luayideh73uqb2latkoyyy5h65y4atv3fymnlxlzwqd.onion\",\n+      \"port\": 18333,\n+      \"score\": 4\n+    }\n+  ]\n+  ```\n \n ## 3. Manually create a Bitcoin Core onion service\n \n You can also manually configure your node to be reachable from the Tor network.\n Add these lines to your `/etc/tor/torrc` (or equivalent config file):\n \n-\tHiddenServiceDir /var/lib/tor/bitcoin-service/\n-\tHiddenServicePort 8333 127.0.0.1:8334\n+    HiddenServiceDir /var/lib/tor/bitcoin-service/\n+    HiddenServicePort 8333 127.0.0.1:8334\n \n The directory can be different of course, but virtual port numbers should be equal to\n your bitcoind's P2P listen port (8333 by default), and target addresses and ports\n should be equal to binding address and port for inbound Tor connections (127.0.0.1:8334 by default).\n \n-\t-externalip=X   You can tell bitcoin about its publicly reachable addresses using\n-\t                this option, and this can be an onion address. Given the above\n-\t                configuration, you can find your onion address in\n-\t                /var/lib/tor/bitcoin-service/hostname. For connections\n-\t                coming from unroutable addresses (such as 127.0.0.1, where the\n-\t                Tor proxy typically runs), onion addresses are given\n-\t                preference for your node to advertise itself with.\n-\n-\t                You can set multiple local addresses with -externalip. The\n-\t                one that will be rumoured to a particular peer is the most\n-\t                compatible one and also using heuristics, e.g. the address\n-\t                with the most incoming connections, etc.\n-\n-\t-listen         You'll need to enable listening for incoming connections, as this\n-\t                is off by default behind a proxy.\n-\n-\t-discover       When -externalip is specified, no attempt is made to discover local\n-\t                IPv4 or IPv6 addresses. If you want to run a dual stack, reachable\n-\t                from both Tor and IPv4 (or IPv6), you'll need to either pass your\n-\t                other addresses using -externalip, or explicitly enable -discover.\n-\t                Note that both addresses of a dual-stack system may be easily\n-\t                linkable using traffic analysis.\n+    -externalip=X   You can tell bitcoin about its publicly reachable addresses using\n+                    this option, and this can be an onion address. Given the above\n+                    configuration, you can find your onion address in\n+                    /var/lib/tor/bitcoin-service/hostname. For connections\n+                    coming from unroutable addresses (such as 127.0.0.1, where the\n+                    Tor proxy typically runs), onion addresses are given\n+                    preference for your node to advertise itself with.\n+\n+                    You can set multiple local addresses with -externalip. The\n+                    one that will be rumoured to a particular peer is the most\n+                    compatible one and also using heuristics, e.g. the address\n+                    with the most incoming connections, etc.\n+\n+    -listen         You'll need to enable listening for incoming connections, as this\n+                    is off by default behind a proxy.\n+\n+    -discover       When -externalip is specified, no attempt is made to discover local\n+                    IPv4 or IPv6 addresses. If you want to run a dual stack, reachable\n+                    from both Tor and IPv4 (or IPv6), you'll need to either pass your\n+                    other addresses using -externalip, or explicitly enable -discover.\n+                    Note that both addresses of a dual-stack system may be easily\n+                    linkable using traffic analysis.\n \n In a typical situation, where you're only reachable via Tor, this should suffice:\n \n-\t./bitcoind -proxy=127.0.0.1:9050 -externalip=7zvj7a2imdgkdbg4f2dryd5rgtrn7upivr5eeij4cicjh65pooxeshid.onion -listen\n+    ./bitcoind -proxy=127.0.0.1:9050 -externalip=7zvj7a2imdgkdbg4f2dryd5rgtrn7upivr5eeij4cicjh65pooxeshid.onion -listen\n \n (obviously, replace the .onion address with your own). It should be noted that you still\n listen on all devices and another node could establish a clearnet connection, when knowing\n your address. To mitigate this, additionally bind the address of your Tor proxy:\n \n-\t./bitcoind ... -bind=127.0.0.1\n+    ./bitcoind ... -bind=127.0.0.1\n \n If you don't care too much about hiding your node, and want to be reachable on IPv4\n as well, use `discover` instead:\n \n-\t./bitcoind ... -discover\n+    ./bitcoind ... -discover\n \n and open port 8333 on your firewall (or use port mapping, i.e., `-upnp` or `-natpmp`).\n \n If you only want to use Tor to reach .onion addresses, but not use it as a proxy\n for normal IPv4/IPv6 communication, use:\n \n-\t./bitcoind -onion=127.0.0.1:9050 -externalip=7zvj7a2imdgkdbg4f2dryd5rgtrn7upivr5eeij4cicjh65pooxeshid.onion -discover\n+    ./bitcoind -onion=127.0.0.1:9050 -externalip=7zvj7a2imdgkdbg4f2dryd5rgtrn7upivr5eeij4cicjh65pooxeshid.onion -discover\n \n ## 4. Privacy recommendations\n "
      },
      {
        "sha": "bc661fccbb6775d39c3ca9003c6dabf0121f7298",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -233,6 +233,7 @@ BITCOIN_CORE_H = \\\n   util/check.h \\\n   util/error.h \\\n   util/fees.h \\\n+  util/getuniquepath.h \\\n   util/golombrice.h \\\n   util/hasher.h \\\n   util/macros.h \\\n@@ -242,6 +243,7 @@ BITCOIN_CORE_H = \\\n   util/rbf.h \\\n   util/ref.h \\\n   util/settings.h \\\n+  util/sock.h \\\n   util/spanparsing.h \\\n   util/string.h \\\n   util/system.h \\\n@@ -556,7 +558,9 @@ libbitcoin_util_a_SOURCES = \\\n   util/bytevectorhash.cpp \\\n   util/error.cpp \\\n   util/fees.cpp \\\n+  util/getuniquepath.cpp \\\n   util/hasher.cpp \\\n+  util/sock.cpp \\\n   util/system.cpp \\\n   util/message.cpp \\\n   util/moneystr.cpp \\"
      },
      {
        "sha": "e817bb2ee258fbb3fd3707724048c2553818260f",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 22,
        "deletions": 6,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -2,9 +2,11 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-if ENABLE_FUZZ\n+if ENABLE_FUZZ_BINARY\n noinst_PROGRAMS += test/fuzz/fuzz\n-else\n+endif\n+\n+if !ENABLE_FUZZ\n bin_PROGRAMS += test/test_bitcoin\n endif\n \n@@ -50,6 +52,14 @@ FUZZ_SUITE_LD_COMMON = \\\n  $(EVENT_LIBS) \\\n  $(EVENT_PTHREADS_LIBS)\n \n+if USE_UPNP\n+FUZZ_SUITE_LD_COMMON += $(MINIUPNPC_LIBS)\n+endif\n+\n+if USE_NATPMP\n+FUZZ_SUITE_LD_COMMON += $(NATPMP_LIBS)\n+endif\n+\n # test_bitcoin binary #\n BITCOIN_TESTS =\\\n   test/arith_uint256_tests.cpp \\\n@@ -114,6 +124,7 @@ BITCOIN_TESTS =\\\n   test/sighash_tests.cpp \\\n   test/sigopcount_tests.cpp \\\n   test/skiplist_tests.cpp \\\n+  test/sock_tests.cpp \\\n   test/streams_tests.cpp \\\n   test/sync_tests.cpp \\\n   test/system_tests.cpp \\\n@@ -145,10 +156,16 @@ BITCOIN_TESTS += \\\n   wallet/test/ismine_tests.cpp \\\n   wallet/test/scriptpubkeyman_tests.cpp\n \n+FUZZ_SUITE_LD_COMMON +=\\\n+ $(LIBBITCOIN_WALLET) \\\n+ $(SQLITE_LIBS) \\\n+ $(BDB_LIBS)\n+\n if USE_BDB\n BITCOIN_TESTS += wallet/test/db_tests.cpp\n endif\n \n+\n BITCOIN_TEST_SUITE += \\\n   wallet/test/wallet_test_fixture.cpp \\\n   wallet/test/wallet_test_fixture.h \\\n@@ -172,12 +189,12 @@ test_test_bitcoin_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS) $(\n \n if ENABLE_ZMQ\n test_test_bitcoin_LDADD += $(LIBBITCOIN_ZMQ) $(ZMQ_LIBS)\n+FUZZ_SUITE_LD_COMMON += $(LIBBITCOIN_ZMQ) $(ZMQ_LIBS)\n endif\n \n-if ENABLE_FUZZ\n-\n FUZZ_SUITE_LDFLAGS_COMMON = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS) $(PTHREAD_FLAGS)\n \n+if ENABLE_FUZZ_BINARY\n test_fuzz_fuzz_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n test_fuzz_fuzz_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_fuzz_LDADD = $(FUZZ_SUITE_LD_COMMON)\n@@ -278,8 +295,7 @@ test_fuzz_fuzz_SOURCES = \\\n  test/fuzz/tx_in.cpp \\\n  test/fuzz/tx_out.cpp \\\n  test/fuzz/txrequest.cpp\n-\n-endif # ENABLE_FUZZ\n+endif # ENABLE_FUZZ_BINARY\n \n nodist_test_test_bitcoin_SOURCES = $(GENERATED_TEST_FILES)\n "
      },
      {
        "sha": "92a5570953076b78a9230173f0159d7543f6d2f6",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 54,
        "deletions": 40,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -335,22 +335,20 @@ friend class CAddrManTest;\n      * * nNew\n      * * nTried\n      * * number of \"new\" buckets XOR 2**30\n-     * * all nNew addrinfos in vvNew\n-     * * all nTried addrinfos in vvTried\n-     * * for each bucket:\n+     * * all new addresses (total count: nNew)\n+     * * all tried addresses (total count: nTried)\n+     * * for each new bucket:\n      *   * number of elements\n-     *   * for each element: index\n+     *   * for each element: index in the serialized \"all new addresses\"\n+     * * asmap checksum\n      *\n      * 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it\n      * as incompatible. This is necessary because it did not check the version number on\n      * deserialization.\n      *\n-     * Notice that vvTried, mapAddr and vVector are never encoded explicitly;\n+     * vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;\n      * they are instead reconstructed from the other information.\n      *\n-     * vvNew is serialized, but only used if ADDRMAN_UNKNOWN_BUCKET_COUNT didn't change,\n-     * otherwise it is reconstructed as well.\n-     *\n      * This format is more complex, but significantly smaller (at most 1.5 MiB), and supports\n      * changes to the ADDRMAN_ parameters without breaking the on-disk structure.\n      *\n@@ -413,13 +411,13 @@ friend class CAddrManTest;\n                 }\n             }\n         }\n-        // Store asmap version after bucket entries so that it\n+        // Store asmap checksum after bucket entries so that it\n         // can be ignored by older clients for backward compatibility.\n-        uint256 asmap_version;\n+        uint256 asmap_checksum;\n         if (m_asmap.size() != 0) {\n-            asmap_version = SerializeHash(m_asmap);\n+            asmap_checksum = SerializeHash(m_asmap);\n         }\n-        s << asmap_version;\n+        s << asmap_checksum;\n     }\n \n     template <typename Stream>\n@@ -500,47 +498,63 @@ friend class CAddrManTest;\n         nTried -= nLost;\n \n         // Store positions in the new table buckets to apply later (if possible).\n-        std::map<int, int> entryToBucket; // Represents which entry belonged to which bucket when serializing\n-\n-        for (int bucket = 0; bucket < nUBuckets; bucket++) {\n-            int nSize = 0;\n-            s >> nSize;\n-            for (int n = 0; n < nSize; n++) {\n-                int nIndex = 0;\n-                s >> nIndex;\n-                if (nIndex >= 0 && nIndex < nNew) {\n-                    entryToBucket[nIndex] = bucket;\n+        // An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,\n+        // so we store all bucket-entry_index pairs to iterate through later.\n+        std::vector<std::pair<int, int>> bucket_entries;\n+\n+        for (int bucket = 0; bucket < nUBuckets; ++bucket) {\n+            int num_entries{0};\n+            s >> num_entries;\n+            for (int n = 0; n < num_entries; ++n) {\n+                int entry_index{0};\n+                s >> entry_index;\n+                if (entry_index >= 0 && entry_index < nNew) {\n+                    bucket_entries.emplace_back(bucket, entry_index);\n                 }\n             }\n         }\n \n-        uint256 supplied_asmap_version;\n+        // If the bucket count and asmap checksum haven't changed, then attempt\n+        // to restore the entries to the buckets/positions they were in before\n+        // serialization.\n+        uint256 supplied_asmap_checksum;\n         if (m_asmap.size() != 0) {\n-            supplied_asmap_version = SerializeHash(m_asmap);\n+            supplied_asmap_checksum = SerializeHash(m_asmap);\n         }\n-        uint256 serialized_asmap_version;\n+        uint256 serialized_asmap_checksum;\n         if (format >= Format::V2_ASMAP) {\n-            s >> serialized_asmap_version;\n+            s >> serialized_asmap_checksum;\n         }\n+        const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&\n+                                     serialized_asmap_checksum == supplied_asmap_checksum};\n \n-        for (int n = 0; n < nNew; n++) {\n-            CAddrInfo &info = mapInfo[n];\n-            int bucket = entryToBucket[n];\n-            int nUBucketPos = info.GetBucketPosition(nKey, true, bucket);\n-            if (format >= Format::V2_ASMAP && nUBuckets == ADDRMAN_NEW_BUCKET_COUNT && vvNew[bucket][nUBucketPos] == -1 &&\n-                info.nRefCount < ADDRMAN_NEW_BUCKETS_PER_ADDRESS && serialized_asmap_version == supplied_asmap_version) {\n+        if (!restore_bucketing) {\n+            LogPrint(BCLog::ADDRMAN, \"Bucketing method was updated, re-bucketing addrman entries from disk\\n\");\n+        }\n+\n+        for (auto bucket_entry : bucket_entries) {\n+            int bucket{bucket_entry.first};\n+            const int entry_index{bucket_entry.second};\n+            CAddrInfo& info = mapInfo[entry_index];\n+\n+            // The entry shouldn't appear in more than\n+            // ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip\n+            // this bucket_entry.\n+            if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;\n+\n+            int bucket_position = info.GetBucketPosition(nKey, true, bucket);\n+            if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {\n                 // Bucketing has not changed, using existing bucket positions for the new table\n-                vvNew[bucket][nUBucketPos] = n;\n-                info.nRefCount++;\n+                vvNew[bucket][bucket_position] = entry_index;\n+                ++info.nRefCount;\n             } else {\n-                // In case the new table data cannot be used (format unknown, bucket count wrong or new asmap),\n+                // In case the new table data cannot be used (bucket count wrong or new asmap),\n                 // try to give them a reference based on their primary source address.\n-                LogPrint(BCLog::ADDRMAN, \"Bucketing method was updated, re-bucketing addrman entries from disk\\n\");\n                 bucket = info.GetNewBucket(nKey, m_asmap);\n-                nUBucketPos = info.GetBucketPosition(nKey, true, bucket);\n-                if (vvNew[bucket][nUBucketPos] == -1) {\n-                    vvNew[bucket][nUBucketPos] = n;\n-                    info.nRefCount++;\n+                bucket_position = info.GetBucketPosition(nKey, true, bucket);\n+                if (vvNew[bucket][bucket_position] == -1) {\n+                    vvNew[bucket][bucket_position] = entry_index;\n+                    ++info.nRefCount;\n                 }\n             }\n         }"
      },
      {
        "sha": "9f7d582e8a5d00c314dcbdaef876b988cbb641f5",
        "filename": "src/bench/block_assemble.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/bench/block_assemble.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/bench/block_assemble.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/block_assemble.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -48,9 +48,8 @@ static void AssembleBlock(benchmark::Bench& bench)\n         LOCK(::cs_main); // Required for ::AcceptToMemoryPool.\n \n         for (const auto& txr : txs) {\n-            TxValidationState state;\n-            bool ret{::AcceptToMemoryPool(*test_setup.m_node.mempool, state, txr, nullptr /* plTxnReplaced */, false /* bypass_limits */)};\n-            assert(ret);\n+            const MempoolAcceptResult res = ::AcceptToMemoryPool(*test_setup.m_node.mempool, txr, false /* bypass_limits */);\n+            assert(res.m_result_type == MempoolAcceptResult::ResultType::VALID);\n         }\n     }\n "
      },
      {
        "sha": "5fa405a69056038f5e2f4e912c1a5129450a71ff",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 24,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -20,6 +20,7 @@\n #include <protocol.h>\n #include <random.h>\n #include <scheduler.h>\n+#include <util/sock.h>\n #include <util/strencodings.h>\n #include <util/translation.h>\n \n@@ -429,51 +430,53 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n \n     // Connect\n     bool connected = false;\n-    SOCKET hSocket = INVALID_SOCKET;\n+    std::unique_ptr<Sock> sock;\n     proxyType proxy;\n     if (addrConnect.IsValid()) {\n         bool proxyConnectionFailed = false;\n \n         if (GetProxy(addrConnect.GetNetwork(), proxy)) {\n-            hSocket = CreateSocket(proxy.proxy);\n-            if (hSocket == INVALID_SOCKET) {\n+            sock = CreateSock(proxy.proxy);\n+            if (!sock) {\n                 return nullptr;\n             }\n-            connected = ConnectThroughProxy(proxy, addrConnect.ToStringIP(), addrConnect.GetPort(), hSocket, nConnectTimeout, proxyConnectionFailed);\n+            connected = ConnectThroughProxy(proxy, addrConnect.ToStringIP(), addrConnect.GetPort(),\n+                                            *sock, nConnectTimeout, proxyConnectionFailed);\n         } else {\n             // no proxy needed (none set for target network)\n-            hSocket = CreateSocket(addrConnect);\n-            if (hSocket == INVALID_SOCKET) {\n+            sock = CreateSock(addrConnect);\n+            if (!sock) {\n                 return nullptr;\n             }\n-            connected = ConnectSocketDirectly(addrConnect, hSocket, nConnectTimeout, conn_type == ConnectionType::MANUAL);\n+            connected = ConnectSocketDirectly(addrConnect, sock->Get(), nConnectTimeout,\n+                                              conn_type == ConnectionType::MANUAL);\n         }\n         if (!proxyConnectionFailed) {\n             // If a connection to the node was attempted, and failure (if any) is not caused by a problem connecting to\n             // the proxy, mark this as an attempt.\n             addrman.Attempt(addrConnect, fCountFailure);\n         }\n     } else if (pszDest && GetNameProxy(proxy)) {\n-        hSocket = CreateSocket(proxy.proxy);\n-        if (hSocket == INVALID_SOCKET) {\n+        sock = CreateSock(proxy.proxy);\n+        if (!sock) {\n             return nullptr;\n         }\n         std::string host;\n         int port = default_port;\n         SplitHostPort(std::string(pszDest), port, host);\n         bool proxyConnectionFailed;\n-        connected = ConnectThroughProxy(proxy, host, port, hSocket, nConnectTimeout, proxyConnectionFailed);\n+        connected = ConnectThroughProxy(proxy, host, port, *sock, nConnectTimeout,\n+                                        proxyConnectionFailed);\n     }\n     if (!connected) {\n-        CloseSocket(hSocket);\n         return nullptr;\n     }\n \n     // Add node\n     NodeId id = GetNewNodeId();\n     uint64_t nonce = GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize();\n-    CAddress addr_bind = GetBindAddress(hSocket);\n-    CNode* pnode = new CNode(id, nLocalServices, hSocket, addrConnect, CalculateKeyedNetGroup(addrConnect), nonce, addr_bind, pszDest ? pszDest : \"\", conn_type);\n+    CAddress addr_bind = GetBindAddress(sock->Get());\n+    CNode* pnode = new CNode(id, nLocalServices, sock->Release(), addrConnect, CalculateKeyedNetGroup(addrConnect), nonce, addr_bind, pszDest ? pszDest : \"\", conn_type);\n     pnode->AddRef();\n \n     // We're making a new connection, harvest entropy from the time (and our peer count)\n@@ -2188,53 +2191,50 @@ bool CConnman::BindListenPort(const CService& addrBind, bilingual_str& strError,\n         return false;\n     }\n \n-    SOCKET hListenSocket = CreateSocket(addrBind);\n-    if (hListenSocket == INVALID_SOCKET)\n-    {\n+    std::unique_ptr<Sock> sock = CreateSock(addrBind);\n+    if (!sock) {\n         strError = strprintf(Untranslated(\"Error: Couldn't open socket for incoming connections (socket returned error %s)\"), NetworkErrorString(WSAGetLastError()));\n         LogPrintf(\"%s\\n\", strError.original);\n         return false;\n     }\n \n     // Allow binding if the port is still in TIME_WAIT state after\n     // the program was closed and restarted.\n-    setsockopt(hListenSocket, SOL_SOCKET, SO_REUSEADDR, (sockopt_arg_type)&nOne, sizeof(int));\n+    setsockopt(sock->Get(), SOL_SOCKET, SO_REUSEADDR, (sockopt_arg_type)&nOne, sizeof(int));\n \n     // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n     // and enable it by default or not. Try to enable it, if possible.\n     if (addrBind.IsIPv6()) {\n #ifdef IPV6_V6ONLY\n-        setsockopt(hListenSocket, IPPROTO_IPV6, IPV6_V6ONLY, (sockopt_arg_type)&nOne, sizeof(int));\n+        setsockopt(sock->Get(), IPPROTO_IPV6, IPV6_V6ONLY, (sockopt_arg_type)&nOne, sizeof(int));\n #endif\n #ifdef WIN32\n         int nProtLevel = PROTECTION_LEVEL_UNRESTRICTED;\n-        setsockopt(hListenSocket, IPPROTO_IPV6, IPV6_PROTECTION_LEVEL, (const char*)&nProtLevel, sizeof(int));\n+        setsockopt(sock->Get(), IPPROTO_IPV6, IPV6_PROTECTION_LEVEL, (const char*)&nProtLevel, sizeof(int));\n #endif\n     }\n \n-    if (::bind(hListenSocket, (struct sockaddr*)&sockaddr, len) == SOCKET_ERROR)\n+    if (::bind(sock->Get(), (struct sockaddr*)&sockaddr, len) == SOCKET_ERROR)\n     {\n         int nErr = WSAGetLastError();\n         if (nErr == WSAEADDRINUSE)\n             strError = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"), addrBind.ToString(), PACKAGE_NAME);\n         else\n             strError = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"), addrBind.ToString(), NetworkErrorString(nErr));\n         LogPrintf(\"%s\\n\", strError.original);\n-        CloseSocket(hListenSocket);\n         return false;\n     }\n     LogPrintf(\"Bound to %s\\n\", addrBind.ToString());\n \n     // Listen for incoming connections\n-    if (listen(hListenSocket, SOMAXCONN) == SOCKET_ERROR)\n+    if (listen(sock->Get(), SOMAXCONN) == SOCKET_ERROR)\n     {\n         strError = strprintf(_(\"Error: Listening for incoming connections failed (listen returned error %s)\"), NetworkErrorString(WSAGetLastError()));\n         LogPrintf(\"%s\\n\", strError.original);\n-        CloseSocket(hListenSocket);\n         return false;\n     }\n \n-    vhListenSocket.push_back(ListenSocket(hListenSocket, permissions));\n+    vhListenSocket.push_back(ListenSocket(sock->Release(), permissions));\n     return true;\n }\n "
      },
      {
        "sha": "4340eb120cbdb6b0063673b110c6d30c0d05ca09",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 8,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -2178,10 +2178,10 @@ void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n         if (orphan_it == mapOrphanTransactions.end()) continue;\n \n         const CTransactionRef porphanTx = orphan_it->second.tx;\n-        TxValidationState state;\n-        std::list<CTransactionRef> removed_txn;\n+        const MempoolAcceptResult result = AcceptToMemoryPool(m_mempool, porphanTx, false /* bypass_limits */);\n+        const TxValidationState& state = result.m_state;\n \n-        if (AcceptToMemoryPool(m_mempool, state, porphanTx, &removed_txn, false /* bypass_limits */)) {\n+        if (result.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n             LogPrint(BCLog::MEMPOOL, \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n             RelayTransaction(orphanHash, porphanTx->GetWitnessHash(), m_connman);\n             for (unsigned int i = 0; i < porphanTx->vout.size(); i++) {\n@@ -2193,7 +2193,7 @@ void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n                 }\n             }\n             EraseOrphanTx(orphanHash);\n-            for (const CTransactionRef& removedTx : removed_txn) {\n+            for (const CTransactionRef& removedTx : result.m_replaced_transactions.value()) {\n                 AddToCompactExtraTransactions(removedTx);\n             }\n             break;\n@@ -2489,6 +2489,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         bool fRelay = true;\n \n         vRecv >> nVersion >> nServiceInt >> nTime >> addrMe;\n+        if (nTime < 0) {\n+            nTime = 0;\n+        }\n         nServices = ServiceFlags(nServiceInt);\n         if (!pfrom.IsInboundConn())\n         {\n@@ -3197,10 +3200,10 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             return;\n         }\n \n-        TxValidationState state;\n-        std::list<CTransactionRef> lRemovedTxn;\n+        const MempoolAcceptResult result = AcceptToMemoryPool(m_mempool, ptx, false /* bypass_limits */);\n+        const TxValidationState& state = result.m_state;\n \n-        if (AcceptToMemoryPool(m_mempool, state, ptx, &lRemovedTxn, false /* bypass_limits */)) {\n+        if (result.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n             m_mempool.check(&::ChainstateActive().CoinsTip());\n             // As this version of the transaction was acceptable, we can forget about any\n             // requests for it.\n@@ -3223,7 +3226,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 tx.GetHash().ToString(),\n                 m_mempool.size(), m_mempool.DynamicMemoryUsage() / 1000);\n \n-            for (const CTransactionRef& removedTx : lRemovedTxn) {\n+            for (const CTransactionRef& removedTx : result.m_replaced_transactions.value()) {\n                 AddToCompactExtraTransactions(removedTx);\n             }\n "
      },
      {
        "sha": "24188f83c6bfdf25ca4cdb22d24fb7037233edb8",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 39,
        "deletions": 113,
        "changes": 152,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -7,13 +7,17 @@\n \n #include <sync.h>\n #include <tinyformat.h>\n+#include <util/sock.h>\n #include <util/strencodings.h>\n #include <util/string.h>\n #include <util/system.h>\n+#include <util/time.h>\n \n #include <atomic>\n #include <cstdint>\n+#include <functional>\n #include <limits>\n+#include <memory>\n \n #ifndef WIN32\n #include <fcntl.h>\n@@ -271,14 +275,6 @@ CService LookupNumeric(const std::string& name, int portDefault)\n     return addr;\n }\n \n-struct timeval MillisToTimeval(int64_t nTimeout)\n-{\n-    struct timeval timeout;\n-    timeout.tv_sec  = nTimeout / 1000;\n-    timeout.tv_usec = (nTimeout % 1000) * 1000;\n-    return timeout;\n-}\n-\n /** SOCKS version */\n enum SOCKSVersion: uint8_t {\n     SOCKS4 = 0x04,\n@@ -336,8 +332,7 @@ enum class IntrRecvError {\n  * @param data The buffer where the read bytes should be stored.\n  * @param len The number of bytes to read into the specified buffer.\n  * @param timeout The total timeout in milliseconds for this read.\n- * @param hSocket The socket (has to be in non-blocking mode) from which to read\n- *                bytes.\n+ * @param sock The socket (has to be in non-blocking mode) from which to read bytes.\n  *\n  * @returns An IntrRecvError indicating the resulting status of this read.\n  *          IntrRecvError::OK only if all of the specified number of bytes were\n@@ -347,15 +342,15 @@ enum class IntrRecvError {\n  *      Sockets can be made non-blocking with SetSocketNonBlocking(const\n  *      SOCKET&, bool).\n  */\n-static IntrRecvError InterruptibleRecv(uint8_t* data, size_t len, int timeout, const SOCKET& hSocket)\n+static IntrRecvError InterruptibleRecv(uint8_t* data, size_t len, int timeout, const Sock& sock)\n {\n     int64_t curTime = GetTimeMillis();\n     int64_t endTime = curTime + timeout;\n     // Maximum time to wait for I/O readiness. It will take up until this time\n     // (in millis) to break off in case of an interruption.\n     const int64_t maxWait = 1000;\n     while (len > 0 && curTime < endTime) {\n-        ssize_t ret = recv(hSocket, (char*)data, len, 0); // Optimistically try the recv first\n+        ssize_t ret = sock.Recv(data, len, 0); // Optimistically try the recv first\n         if (ret > 0) {\n             len -= ret;\n             data += ret;\n@@ -364,25 +359,10 @@ static IntrRecvError InterruptibleRecv(uint8_t* data, size_t len, int timeout, c\n         } else { // Other error or blocking\n             int nErr = WSAGetLastError();\n             if (nErr == WSAEINPROGRESS || nErr == WSAEWOULDBLOCK || nErr == WSAEINVAL) {\n-                if (!IsSelectableSocket(hSocket)) {\n-                    return IntrRecvError::NetworkError;\n-                }\n                 // Only wait at most maxWait milliseconds at a time, unless\n                 // we're approaching the end of the specified total timeout\n                 int timeout_ms = std::min(endTime - curTime, maxWait);\n-#ifdef USE_POLL\n-                struct pollfd pollfd = {};\n-                pollfd.fd = hSocket;\n-                pollfd.events = POLLIN;\n-                int nRet = poll(&pollfd, 1, timeout_ms);\n-#else\n-                struct timeval tval = MillisToTimeval(timeout_ms);\n-                fd_set fdset;\n-                FD_ZERO(&fdset);\n-                FD_SET(hSocket, &fdset);\n-                int nRet = select(hSocket + 1, &fdset, nullptr, nullptr, &tval);\n-#endif\n-                if (nRet == SOCKET_ERROR) {\n+                if (!sock.Wait(std::chrono::milliseconds{timeout_ms}, Sock::RECV)) {\n                     return IntrRecvError::NetworkError;\n                 }\n             } else {\n@@ -436,7 +416,7 @@ static std::string Socks5ErrorString(uint8_t err)\n  * @param port The destination port.\n  * @param auth The credentials with which to authenticate with the specified\n  *             SOCKS5 proxy.\n- * @param hSocket The SOCKS5 proxy socket.\n+ * @param sock The SOCKS5 proxy socket.\n  *\n  * @returns Whether or not the operation succeeded.\n  *\n@@ -446,7 +426,7 @@ static std::string Socks5ErrorString(uint8_t err)\n  * @see <a href=\"https://www.ietf.org/rfc/rfc1928.txt\">RFC1928: SOCKS Protocol\n  *      Version 5</a>\n  */\n-static bool Socks5(const std::string& strDest, int port, const ProxyCredentials *auth, const SOCKET& hSocket)\n+static bool Socks5(const std::string& strDest, int port, const ProxyCredentials* auth, const Sock& sock)\n {\n     IntrRecvError recvr;\n     LogPrint(BCLog::NET, \"SOCKS5 connecting %s\\n\", strDest);\n@@ -464,12 +444,12 @@ static bool Socks5(const std::string& strDest, int port, const ProxyCredentials\n         vSocks5Init.push_back(0x01); // 1 method identifier follows...\n         vSocks5Init.push_back(SOCKS5Method::NOAUTH);\n     }\n-    ssize_t ret = send(hSocket, (const char*)vSocks5Init.data(), vSocks5Init.size(), MSG_NOSIGNAL);\n+    ssize_t ret = sock.Send(vSocks5Init.data(), vSocks5Init.size(), MSG_NOSIGNAL);\n     if (ret != (ssize_t)vSocks5Init.size()) {\n         return error(\"Error sending to proxy\");\n     }\n     uint8_t pchRet1[2];\n-    if ((recvr = InterruptibleRecv(pchRet1, 2, SOCKS5_RECV_TIMEOUT, hSocket)) != IntrRecvError::OK) {\n+    if ((recvr = InterruptibleRecv(pchRet1, 2, SOCKS5_RECV_TIMEOUT, sock)) != IntrRecvError::OK) {\n         LogPrintf(\"Socks5() connect to %s:%d failed: InterruptibleRecv() timeout or other failure\\n\", strDest, port);\n         return false;\n     }\n@@ -486,13 +466,13 @@ static bool Socks5(const std::string& strDest, int port, const ProxyCredentials\n         vAuth.insert(vAuth.end(), auth->username.begin(), auth->username.end());\n         vAuth.push_back(auth->password.size());\n         vAuth.insert(vAuth.end(), auth->password.begin(), auth->password.end());\n-        ret = send(hSocket, (const char*)vAuth.data(), vAuth.size(), MSG_NOSIGNAL);\n+        ret = sock.Send(vAuth.data(), vAuth.size(), MSG_NOSIGNAL);\n         if (ret != (ssize_t)vAuth.size()) {\n             return error(\"Error sending authentication to proxy\");\n         }\n         LogPrint(BCLog::PROXY, \"SOCKS5 sending proxy authentication %s:%s\\n\", auth->username, auth->password);\n         uint8_t pchRetA[2];\n-        if ((recvr = InterruptibleRecv(pchRetA, 2, SOCKS5_RECV_TIMEOUT, hSocket)) != IntrRecvError::OK) {\n+        if ((recvr = InterruptibleRecv(pchRetA, 2, SOCKS5_RECV_TIMEOUT, sock)) != IntrRecvError::OK) {\n             return error(\"Error reading proxy authentication response\");\n         }\n         if (pchRetA[0] != 0x01 || pchRetA[1] != 0x00) {\n@@ -512,12 +492,12 @@ static bool Socks5(const std::string& strDest, int port, const ProxyCredentials\n     vSocks5.insert(vSocks5.end(), strDest.begin(), strDest.end());\n     vSocks5.push_back((port >> 8) & 0xFF);\n     vSocks5.push_back((port >> 0) & 0xFF);\n-    ret = send(hSocket, (const char*)vSocks5.data(), vSocks5.size(), MSG_NOSIGNAL);\n+    ret = sock.Send(vSocks5.data(), vSocks5.size(), MSG_NOSIGNAL);\n     if (ret != (ssize_t)vSocks5.size()) {\n         return error(\"Error sending to proxy\");\n     }\n     uint8_t pchRet2[4];\n-    if ((recvr = InterruptibleRecv(pchRet2, 4, SOCKS5_RECV_TIMEOUT, hSocket)) != IntrRecvError::OK) {\n+    if ((recvr = InterruptibleRecv(pchRet2, 4, SOCKS5_RECV_TIMEOUT, sock)) != IntrRecvError::OK) {\n         if (recvr == IntrRecvError::Timeout) {\n             /* If a timeout happens here, this effectively means we timed out while connecting\n              * to the remote node. This is very common for Tor, so do not print an\n@@ -541,58 +521,52 @@ static bool Socks5(const std::string& strDest, int port, const ProxyCredentials\n     uint8_t pchRet3[256];\n     switch (pchRet2[3])\n     {\n-        case SOCKS5Atyp::IPV4: recvr = InterruptibleRecv(pchRet3, 4, SOCKS5_RECV_TIMEOUT, hSocket); break;\n-        case SOCKS5Atyp::IPV6: recvr = InterruptibleRecv(pchRet3, 16, SOCKS5_RECV_TIMEOUT, hSocket); break;\n+        case SOCKS5Atyp::IPV4: recvr = InterruptibleRecv(pchRet3, 4, SOCKS5_RECV_TIMEOUT, sock); break;\n+        case SOCKS5Atyp::IPV6: recvr = InterruptibleRecv(pchRet3, 16, SOCKS5_RECV_TIMEOUT, sock); break;\n         case SOCKS5Atyp::DOMAINNAME:\n         {\n-            recvr = InterruptibleRecv(pchRet3, 1, SOCKS5_RECV_TIMEOUT, hSocket);\n+            recvr = InterruptibleRecv(pchRet3, 1, SOCKS5_RECV_TIMEOUT, sock);\n             if (recvr != IntrRecvError::OK) {\n                 return error(\"Error reading from proxy\");\n             }\n             int nRecv = pchRet3[0];\n-            recvr = InterruptibleRecv(pchRet3, nRecv, SOCKS5_RECV_TIMEOUT, hSocket);\n+            recvr = InterruptibleRecv(pchRet3, nRecv, SOCKS5_RECV_TIMEOUT, sock);\n             break;\n         }\n         default: return error(\"Error: malformed proxy response\");\n     }\n     if (recvr != IntrRecvError::OK) {\n         return error(\"Error reading from proxy\");\n     }\n-    if ((recvr = InterruptibleRecv(pchRet3, 2, SOCKS5_RECV_TIMEOUT, hSocket)) != IntrRecvError::OK) {\n+    if ((recvr = InterruptibleRecv(pchRet3, 2, SOCKS5_RECV_TIMEOUT, sock)) != IntrRecvError::OK) {\n         return error(\"Error reading from proxy\");\n     }\n     LogPrint(BCLog::NET, \"SOCKS5 connected %s\\n\", strDest);\n     return true;\n }\n \n-/**\n- * Try to create a socket file descriptor with specific properties in the\n- * communications domain (address family) of the specified service.\n- *\n- * For details on the desired properties, see the inline comments in the source\n- * code.\n- */\n-SOCKET CreateSocket(const CService &addrConnect)\n+std::unique_ptr<Sock> CreateSockTCP(const CService& address_family)\n {\n     // Create a sockaddr from the specified service.\n     struct sockaddr_storage sockaddr;\n     socklen_t len = sizeof(sockaddr);\n-    if (!addrConnect.GetSockAddr((struct sockaddr*)&sockaddr, &len)) {\n-        LogPrintf(\"Cannot create socket for %s: unsupported network\\n\", addrConnect.ToString());\n-        return INVALID_SOCKET;\n+    if (!address_family.GetSockAddr((struct sockaddr*)&sockaddr, &len)) {\n+        LogPrintf(\"Cannot create socket for %s: unsupported network\\n\", address_family.ToString());\n+        return nullptr;\n     }\n \n     // Create a TCP socket in the address family of the specified service.\n     SOCKET hSocket = socket(((struct sockaddr*)&sockaddr)->sa_family, SOCK_STREAM, IPPROTO_TCP);\n-    if (hSocket == INVALID_SOCKET)\n-        return INVALID_SOCKET;\n+    if (hSocket == INVALID_SOCKET) {\n+        return nullptr;\n+    }\n \n     // Ensure that waiting for I/O on this socket won't result in undefined\n     // behavior.\n     if (!IsSelectableSocket(hSocket)) {\n         CloseSocket(hSocket);\n         LogPrintf(\"Cannot create connection: non-selectable socket created (fd >= FD_SETSIZE ?)\\n\");\n-        return INVALID_SOCKET;\n+        return nullptr;\n     }\n \n #ifdef SO_NOSIGPIPE\n@@ -608,11 +582,14 @@ SOCKET CreateSocket(const CService &addrConnect)\n     // Set the non-blocking option on the socket.\n     if (!SetSocketNonBlocking(hSocket, true)) {\n         CloseSocket(hSocket);\n-        LogPrintf(\"CreateSocket: Setting socket to non-blocking failed, error %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        LogPrintf(\"Error setting socket to non-blocking: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return nullptr;\n     }\n-    return hSocket;\n+    return std::make_unique<Sock>(hSocket);\n }\n \n+std::function<std::unique_ptr<Sock>(const CService&)> CreateSock = CreateSockTCP;\n+\n template<typename... Args>\n static void LogConnectFailure(bool manual_connection, const char* fmt, const Args&... args) {\n     std::string error_message = tfm::format(fmt, args...);\n@@ -786,18 +763,18 @@ bool IsProxy(const CNetAddr &addr) {\n  * @param proxy The SOCKS5 proxy.\n  * @param strDest The destination service to which to connect.\n  * @param port The destination port.\n- * @param hSocket The socket on which to connect to the SOCKS5 proxy.\n+ * @param sock The socket on which to connect to the SOCKS5 proxy.\n  * @param nTimeout Wait this many milliseconds for the connection to the SOCKS5\n  *                 proxy to be established.\n  * @param[out] outProxyConnectionFailed Whether or not the connection to the\n  *                                      SOCKS5 proxy failed.\n  *\n  * @returns Whether or not the operation succeeded.\n  */\n-bool ConnectThroughProxy(const proxyType &proxy, const std::string& strDest, int port, const SOCKET& hSocket, int nTimeout, bool& outProxyConnectionFailed)\n+bool ConnectThroughProxy(const proxyType& proxy, const std::string& strDest, int port, const Sock& sock, int nTimeout, bool& outProxyConnectionFailed)\n {\n     // first connect to proxy server\n-    if (!ConnectSocketDirectly(proxy.proxy, hSocket, nTimeout, true)) {\n+    if (!ConnectSocketDirectly(proxy.proxy, sock.Get(), nTimeout, true)) {\n         outProxyConnectionFailed = true;\n         return false;\n     }\n@@ -806,11 +783,11 @@ bool ConnectThroughProxy(const proxyType &proxy, const std::string& strDest, int\n         ProxyCredentials random_auth;\n         static std::atomic_int counter(0);\n         random_auth.username = random_auth.password = strprintf(\"%i\", counter++);\n-        if (!Socks5(strDest, (uint16_t)port, &random_auth, hSocket)) {\n+        if (!Socks5(strDest, (uint16_t)port, &random_auth, sock)) {\n             return false;\n         }\n     } else {\n-        if (!Socks5(strDest, (uint16_t)port, 0, hSocket)) {\n+        if (!Socks5(strDest, (uint16_t)port, 0, sock)) {\n             return false;\n         }\n     }\n@@ -869,57 +846,6 @@ bool LookupSubNet(const std::string& strSubnet, CSubNet& ret)\n     return false;\n }\n \n-#ifdef WIN32\n-std::string NetworkErrorString(int err)\n-{\n-    wchar_t buf[256];\n-    buf[0] = 0;\n-    if(FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,\n-            nullptr, err, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n-            buf, ARRAYSIZE(buf), nullptr))\n-    {\n-        return strprintf(\"%s (%d)\", std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>,wchar_t>().to_bytes(buf), err);\n-    }\n-    else\n-    {\n-        return strprintf(\"Unknown error (%d)\", err);\n-    }\n-}\n-#else\n-std::string NetworkErrorString(int err)\n-{\n-    char buf[256];\n-    buf[0] = 0;\n-    /* Too bad there are two incompatible implementations of the\n-     * thread-safe strerror. */\n-    const char *s;\n-#ifdef STRERROR_R_CHAR_P /* GNU variant can return a pointer outside the passed buffer */\n-    s = strerror_r(err, buf, sizeof(buf));\n-#else /* POSIX variant always returns message in buffer */\n-    s = buf;\n-    if (strerror_r(err, buf, sizeof(buf)))\n-        buf[0] = 0;\n-#endif\n-    return strprintf(\"%s (%d)\", s, err);\n-}\n-#endif\n-\n-bool CloseSocket(SOCKET& hSocket)\n-{\n-    if (hSocket == INVALID_SOCKET)\n-        return false;\n-#ifdef WIN32\n-    int ret = closesocket(hSocket);\n-#else\n-    int ret = close(hSocket);\n-#endif\n-    if (ret) {\n-        LogPrintf(\"Socket close failed: %d. Error: %s\\n\", hSocket, NetworkErrorString(WSAGetLastError()));\n-    }\n-    hSocket = INVALID_SOCKET;\n-    return ret != SOCKET_ERROR;\n-}\n-\n bool SetSocketNonBlocking(const SOCKET& hSocket, bool fNonBlocking)\n {\n     if (fNonBlocking) {"
      },
      {
        "sha": "afc373ef49bf0e4c89c622a1127b907a51c96628",
        "filename": "src/netbase.h",
        "status": "modified",
        "additions": 17,
        "deletions": 10,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/netbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/netbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.h?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -12,7 +12,10 @@\n #include <compat.h>\n #include <netaddress.h>\n #include <serialize.h>\n+#include <util/sock.h>\n \n+#include <functional>\n+#include <memory>\n #include <stdint.h>\n #include <string>\n #include <vector>\n@@ -51,21 +54,25 @@ bool Lookup(const std::string& name, CService& addr, int portDefault, bool fAllo\n bool Lookup(const std::string& name, std::vector<CService>& vAddr, int portDefault, bool fAllowLookup, unsigned int nMaxSolutions);\n CService LookupNumeric(const std::string& name, int portDefault = 0);\n bool LookupSubNet(const std::string& strSubnet, CSubNet& subnet);\n-SOCKET CreateSocket(const CService &addrConnect);\n+\n+/**\n+ * Create a TCP socket in the given address family.\n+ * @param[in] address_family The socket is created in the same address family as this address.\n+ * @return pointer to the created Sock object or unique_ptr that owns nothing in case of failure\n+ */\n+std::unique_ptr<Sock> CreateSockTCP(const CService& address_family);\n+\n+/**\n+ * Socket factory. Defaults to `CreateSockTCP()`, but can be overridden by unit tests.\n+ */\n+extern std::function<std::unique_ptr<Sock>(const CService&)> CreateSock;\n+\n bool ConnectSocketDirectly(const CService &addrConnect, const SOCKET& hSocketRet, int nTimeout, bool manual_connection);\n-bool ConnectThroughProxy(const proxyType &proxy, const std::string& strDest, int port, const SOCKET& hSocketRet, int nTimeout, bool& outProxyConnectionFailed);\n-/** Return readable error string for a network error code */\n-std::string NetworkErrorString(int err);\n-/** Close socket and set hSocket to INVALID_SOCKET */\n-bool CloseSocket(SOCKET& hSocket);\n+bool ConnectThroughProxy(const proxyType& proxy, const std::string& strDest, int port, const Sock& sock, int nTimeout, bool& outProxyConnectionFailed);\n /** Disable or enable blocking-mode for a socket */\n bool SetSocketNonBlocking(const SOCKET& hSocket, bool fNonBlocking);\n /** Set the TCP_NODELAY flag on a socket */\n bool SetSocketNoDelay(const SOCKET& hSocket);\n-/**\n- * Convert milliseconds to a struct timeval for e.g. select.\n- */\n-struct timeval MillisToTimeval(int64_t nTimeout);\n void InterruptSocks5(bool interrupt);\n \n #endif // BITCOIN_NETBASE_H"
      },
      {
        "sha": "6f5acf41e32855d1d673b5503e4949ccf0dccabc",
        "filename": "src/node/transaction.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/node/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/node/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/transaction.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -50,22 +50,22 @@ TransactionError BroadcastTransaction(NodeContext& node, const CTransactionRef t\n     }\n     if (!node.mempool->exists(hashTx)) {\n         // Transaction is not already in the mempool.\n-        TxValidationState state;\n         if (max_tx_fee > 0) {\n             // First, call ATMP with test_accept and check the fee. If ATMP\n             // fails here, return error immediately.\n-            CAmount fee{0};\n-            if (!AcceptToMemoryPool(*node.mempool, state, tx,\n-                nullptr /* plTxnReplaced */, false /* bypass_limits */, /* test_accept */ true, &fee)) {\n-                return HandleATMPError(state, err_string);\n-            } else if (fee > max_tx_fee) {\n+            const MempoolAcceptResult result = AcceptToMemoryPool(*node.mempool, tx, false /* bypass_limits */,\n+                                                                  true /* test_accept */);\n+            if (result.m_result_type != MempoolAcceptResult::ResultType::VALID) {\n+                return HandleATMPError(result.m_state, err_string);\n+            } else if (result.m_base_fees.value() > max_tx_fee) {\n                 return TransactionError::MAX_FEE_EXCEEDED;\n             }\n         }\n         // Try to submit the transaction to the mempool.\n-        if (!AcceptToMemoryPool(*node.mempool, state, tx,\n-                nullptr /* plTxnReplaced */, false /* bypass_limits */)) {\n-            return HandleATMPError(state, err_string);\n+        const MempoolAcceptResult result = AcceptToMemoryPool(*node.mempool, tx, false /* bypass_limits */,\n+                                                              false /* test_accept */);\n+        if (result.m_result_type != MempoolAcceptResult::ResultType::VALID) {\n+            return HandleATMPError(result.m_state, err_string);\n         }\n \n         // Transaction was accepted to the mempool."
      },
      {
        "sha": "6e2a7c330e84d02f45c2183ede4c8ef5e47f1925",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 23,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -17,8 +17,8 @@\n #include <node/coinstats.h>\n #include <node/context.h>\n #include <node/utxo_snapshot.h>\n-#include <policy/fees.h>\n #include <policy/feerate.h>\n+#include <policy/fees.h>\n #include <policy/policy.h>\n #include <policy/rbf.h>\n #include <primitives/transaction.h>\n@@ -156,21 +156,11 @@ UniValue blockheaderToJSON(const CBlockIndex* tip, const CBlockIndex* blockindex\n \n UniValue blockToJSON(const CBlock& block, const CBlockIndex* tip, const CBlockIndex* blockindex, bool txDetails)\n {\n-    // Serialize passed information without accessing chain state of the active chain!\n-    AssertLockNotHeld(cs_main); // For performance reasons\n+    UniValue result = blockheaderToJSON(tip, blockindex);\n \n-    UniValue result(UniValue::VOBJ);\n-    result.pushKV(\"hash\", blockindex->GetBlockHash().GetHex());\n-    const CBlockIndex* pnext;\n-    int confirmations = ComputeNextBlockAndDepth(tip, blockindex, pnext);\n-    result.pushKV(\"confirmations\", confirmations);\n     result.pushKV(\"strippedsize\", (int)::GetSerializeSize(block, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS));\n     result.pushKV(\"size\", (int)::GetSerializeSize(block, PROTOCOL_VERSION));\n     result.pushKV(\"weight\", (int)::GetBlockWeight(block));\n-    result.pushKV(\"height\", blockindex->nHeight);\n-    result.pushKV(\"version\", block.nVersion);\n-    result.pushKV(\"versionHex\", strprintf(\"%08x\", block.nVersion));\n-    result.pushKV(\"merkleroot\", block.hashMerkleRoot.GetHex());\n     UniValue txs(UniValue::VARR);\n     if (txDetails) {\n         CBlockUndo blockUndo;\n@@ -189,18 +179,7 @@ UniValue blockToJSON(const CBlock& block, const CBlockIndex* tip, const CBlockIn\n         }\n     }\n     result.pushKV(\"tx\", txs);\n-    result.pushKV(\"time\", block.GetBlockTime());\n-    result.pushKV(\"mediantime\", (int64_t)blockindex->GetMedianTimePast());\n-    result.pushKV(\"nonce\", (uint64_t)block.nNonce);\n-    result.pushKV(\"bits\", strprintf(\"%08x\", block.nBits));\n-    result.pushKV(\"difficulty\", GetDifficulty(blockindex));\n-    result.pushKV(\"chainwork\", blockindex->nChainWork.GetHex());\n-    result.pushKV(\"nTx\", (uint64_t)blockindex->nTx);\n \n-    if (blockindex->pprev)\n-        result.pushKV(\"previousblockhash\", blockindex->pprev->GetBlockHash().GetHex());\n-    if (pnext)\n-        result.pushKV(\"nextblockhash\", pnext->GetBlockHash().GetHex());\n     return result;\n }\n \n@@ -1500,6 +1479,7 @@ UniValue MempoolInfoToJSON(const CTxMemPool& pool)\n     ret.pushKV(\"size\", (int64_t)pool.size());\n     ret.pushKV(\"bytes\", (int64_t)pool.GetTotalTxSize());\n     ret.pushKV(\"usage\", (int64_t)pool.DynamicMemoryUsage());\n+    ret.pushKV(\"total_fee\", ValueFromAmount(pool.GetTotalFee()));\n     size_t maxmempool = gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n     ret.pushKV(\"maxmempool\", (int64_t) maxmempool);\n     ret.pushKV(\"mempoolminfee\", ValueFromAmount(std::max(pool.GetMinFee(maxmempool), ::minRelayTxFee).GetFeePerK()));\n@@ -1520,6 +1500,7 @@ static RPCHelpMan getmempoolinfo()\n                         {RPCResult::Type::NUM, \"size\", \"Current tx count\"},\n                         {RPCResult::Type::NUM, \"bytes\", \"Sum of all virtual transaction sizes as defined in BIP 141. Differs from actual serialized size because witness data is discounted\"},\n                         {RPCResult::Type::NUM, \"usage\", \"Total memory usage for the mempool\"},\n+                        {RPCResult::Type::STR_AMOUNT, \"total_fee\", \"Total fees for the mempool in \" + CURRENCY_UNIT + \", ignoring modified fees through prioritizetransaction\"},\n                         {RPCResult::Type::NUM, \"maxmempool\", \"Maximum memory usage for the mempool\"},\n                         {RPCResult::Type::STR_AMOUNT, \"mempoolminfee\", \"Minimum fee rate in \" + CURRENCY_UNIT + \"/kB for tx to be accepted. Is the maximum of minrelaytxfee and minimum mempool fee\"},\n                         {RPCResult::Type::STR_AMOUNT, \"minrelaytxfee\", \"Current minimum relay fee for transactions\"},"
      },
      {
        "sha": "38a0bddddb0fa43244d865f8f9d01587248b7bef",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 8,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -365,13 +365,13 @@ static RPCHelpMan signmessagewithprivkey()\n static RPCHelpMan setmocktime()\n {\n     return RPCHelpMan{\"setmocktime\",\n-                \"\\nSet the local time to given timestamp (-regtest only)\\n\",\n-                {\n-                    {\"timestamp\", RPCArg::Type::NUM, RPCArg::Optional::NO, UNIX_EPOCH_TIME + \"\\n\"\n-            \"   Pass 0 to go back to using the system time.\"},\n-                },\n-                RPCResult{RPCResult::Type::NONE, \"\", \"\"},\n-                RPCExamples{\"\"},\n+        \"\\nSet the local time to given timestamp (-regtest only)\\n\",\n+        {\n+            {\"timestamp\", RPCArg::Type::NUM, RPCArg::Optional::NO, UNIX_EPOCH_TIME + \"\\n\"\n+             \"Pass 0 to go back to using the system time.\"},\n+        },\n+        RPCResult{RPCResult::Type::NONE, \"\", \"\"},\n+        RPCExamples{\"\"},\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n     if (!Params().IsMockableChain()) {\n@@ -386,7 +386,10 @@ static RPCHelpMan setmocktime()\n     LOCK(cs_main);\n \n     RPCTypeCheck(request.params, {UniValue::VNUM});\n-    int64_t time = request.params[0].get_int64();\n+    const int64_t time{request.params[0].get_int64()};\n+    if (time < 0) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Mocktime can not be negative: %s.\", time));\n+    }\n     SetMockTime(time);\n     if (request.context.Has<NodeContext>()) {\n         for (const auto& chain_client : request.context.Get<NodeContext>().chain_clients) {"
      },
      {
        "sha": "784a53e0605c97d76f4ba3b4d3c022781650393d",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 30,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -946,44 +946,35 @@ static RPCHelpMan testmempoolaccept()\n     result_0.pushKV(\"txid\", tx->GetHash().GetHex());\n     result_0.pushKV(\"wtxid\", tx->GetWitnessHash().GetHex());\n \n-    TxValidationState state;\n-    bool test_accept_res;\n-    CAmount fee{0};\n-    {\n-        LOCK(cs_main);\n-        test_accept_res = AcceptToMemoryPool(mempool, state, std::move(tx),\n-            nullptr /* plTxnReplaced */, false /* bypass_limits */, /* test_accept */ true, &fee);\n-    }\n-\n-    // Check that fee does not exceed maximum fee\n-    if (test_accept_res && max_raw_tx_fee && fee > max_raw_tx_fee) {\n-        result_0.pushKV(\"allowed\", false);\n-        result_0.pushKV(\"reject-reason\", \"max-fee-exceeded\");\n-        result.push_back(std::move(result_0));\n-        return result;\n-    }\n-    result_0.pushKV(\"allowed\", test_accept_res);\n+    const MempoolAcceptResult accept_result = WITH_LOCK(cs_main, return AcceptToMemoryPool(mempool, std::move(tx),\n+                                                  false /* bypass_limits */, /* test_accept */ true));\n \n     // Only return the fee and vsize if the transaction would pass ATMP.\n     // These can be used to calculate the feerate.\n-    if (test_accept_res) {\n-        result_0.pushKV(\"vsize\", virtual_size);\n-        UniValue fees(UniValue::VOBJ);\n-        fees.pushKV(\"base\", ValueFromAmount(fee));\n-        result_0.pushKV(\"fees\", fees);\n+    if (accept_result.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n+        const CAmount fee = accept_result.m_base_fees.value();\n+        // Check that fee does not exceed maximum fee\n+        if (max_raw_tx_fee && fee > max_raw_tx_fee) {\n+            result_0.pushKV(\"allowed\", false);\n+            result_0.pushKV(\"reject-reason\", \"max-fee-exceeded\");\n+        } else {\n+            result_0.pushKV(\"allowed\", true);\n+            result_0.pushKV(\"vsize\", virtual_size);\n+            UniValue fees(UniValue::VOBJ);\n+            fees.pushKV(\"base\", ValueFromAmount(fee));\n+            result_0.pushKV(\"fees\", fees);\n+        }\n+        result.push_back(std::move(result_0));\n     } else {\n-        if (state.IsInvalid()) {\n-            if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n-                result_0.pushKV(\"reject-reason\", \"missing-inputs\");\n-            } else {\n-                result_0.pushKV(\"reject-reason\", strprintf(\"%s\", state.GetRejectReason()));\n-            }\n+        result_0.pushKV(\"allowed\", false);\n+        const TxValidationState state = accept_result.m_state;\n+        if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n+            result_0.pushKV(\"reject-reason\", \"missing-inputs\");\n         } else {\n             result_0.pushKV(\"reject-reason\", state.GetRejectReason());\n         }\n+        result.push_back(std::move(result_0));\n     }\n-\n-    result.push_back(std::move(result_0));\n     return result;\n },\n     };"
      },
      {
        "sha": "dba5ce621ad73800afb883a8e0a7bdf8f5baf718",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 6,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -106,8 +106,7 @@ static bool SignStep(const SigningProvider& provider, const BaseSignatureCreator\n     std::vector<valtype> vSolutions;\n     whichTypeRet = Solver(scriptPubKey, vSolutions);\n \n-    switch (whichTypeRet)\n-    {\n+    switch (whichTypeRet) {\n     case TxoutType::NONSTANDARD:\n     case TxoutType::NULL_DATA:\n     case TxoutType::WITNESS_UNKNOWN:\n@@ -173,10 +172,8 @@ static bool SignStep(const SigningProvider& provider, const BaseSignatureCreator\n         // Could not find witnessScript, add to missing\n         sigdata.missing_witness_script = uint256(vSolutions[0]);\n         return false;\n-\n-    default:\n-        return false;\n-    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n }\n \n static CScript PushAll(const std::vector<valtype>& values)"
      },
      {
        "sha": "4d882cd1f18a577f3b40d365ba5a4c9b73976e35",
        "filename": "src/script/standard.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 12,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/script/standard.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/script/standard.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -45,8 +45,7 @@ WitnessV0ScriptHash::WitnessV0ScriptHash(const CScript& in)\n \n std::string GetTxnOutputType(TxoutType t)\n {\n-    switch (t)\n-    {\n+    switch (t) {\n     case TxoutType::NONSTANDARD: return \"nonstandard\";\n     case TxoutType::PUBKEY: return \"pubkey\";\n     case TxoutType::PUBKEYHASH: return \"pubkeyhash\";\n@@ -182,43 +181,51 @@ bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)\n     std::vector<valtype> vSolutions;\n     TxoutType whichType = Solver(scriptPubKey, vSolutions);\n \n-    if (whichType == TxoutType::PUBKEY) {\n+    switch (whichType) {\n+    case TxoutType::PUBKEY: {\n         CPubKey pubKey(vSolutions[0]);\n         if (!pubKey.IsValid())\n             return false;\n \n         addressRet = PKHash(pubKey);\n         return true;\n     }\n-    else if (whichType == TxoutType::PUBKEYHASH)\n-    {\n+    case TxoutType::PUBKEYHASH: {\n         addressRet = PKHash(uint160(vSolutions[0]));\n         return true;\n     }\n-    else if (whichType == TxoutType::SCRIPTHASH)\n-    {\n+    case TxoutType::SCRIPTHASH: {\n         addressRet = ScriptHash(uint160(vSolutions[0]));\n         return true;\n-    } else if (whichType == TxoutType::WITNESS_V0_KEYHASH) {\n+    }\n+    case TxoutType::WITNESS_V0_KEYHASH: {\n         WitnessV0KeyHash hash;\n         std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());\n         addressRet = hash;\n         return true;\n-    } else if (whichType == TxoutType::WITNESS_V0_SCRIPTHASH) {\n+    }\n+    case TxoutType::WITNESS_V0_SCRIPTHASH: {\n         WitnessV0ScriptHash hash;\n         std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());\n         addressRet = hash;\n         return true;\n-    } else if (whichType == TxoutType::WITNESS_UNKNOWN || whichType == TxoutType::WITNESS_V1_TAPROOT) {\n+    }\n+    case TxoutType::WITNESS_UNKNOWN:\n+    case TxoutType::WITNESS_V1_TAPROOT: {\n         WitnessUnknown unk;\n         unk.version = vSolutions[0][0];\n         std::copy(vSolutions[1].begin(), vSolutions[1].end(), unk.program);\n         unk.length = vSolutions[1].size();\n         addressRet = unk;\n         return true;\n     }\n-    // Multisig txns have more than one address...\n-    return false;\n+    case TxoutType::MULTISIG:\n+        // Multisig txns have more than one address...\n+    case TxoutType::NULL_DATA:\n+    case TxoutType::NONSTANDARD:\n+        return false;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n }\n \n bool ExtractDestinations(const CScript& scriptPubKey, TxoutType& typeRet, std::vector<CTxDestination>& addressRet, int& nRequiredRet)"
      },
      {
        "sha": "e52cd5230c9b89049f24d44674f1bfe2e169cde8",
        "filename": "src/test/fs_tests.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 1,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/test/fs_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/test/fs_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fs_tests.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -5,6 +5,7 @@\n #include <fs.h>\n #include <test/util/setup_common.h>\n #include <util/system.h>\n+#include <util/getuniquepath.h>\n \n #include <boost/test/unit_test.hpp>\n \n@@ -69,6 +70,21 @@ BOOST_AUTO_TEST_CASE(fsbridge_fstream)\n         BOOST_CHECK_EQUAL(tmpfile1, fsbridge::AbsPathJoin(tmpfile1, \"\"));\n         BOOST_CHECK_EQUAL(tmpfile1, fsbridge::AbsPathJoin(tmpfile1, {}));\n     }\n+    {\n+        fs::path p1 = GetUniquePath(tmpfolder);\n+        fs::path p2 = GetUniquePath(tmpfolder);\n+        fs::path p3 = GetUniquePath(tmpfolder);\n+\n+        // Ensure that the parent path is always the same.\n+        BOOST_CHECK_EQUAL(tmpfolder, p1.parent_path());\n+        BOOST_CHECK_EQUAL(tmpfolder, p2.parent_path());\n+        BOOST_CHECK_EQUAL(tmpfolder, p3.parent_path());\n+\n+        // Ensure that generated paths are actually different.\n+        BOOST_CHECK(p1 != p2);\n+        BOOST_CHECK(p2 != p3);\n+        BOOST_CHECK(p1 != p3);\n+    }\n }\n \n-BOOST_AUTO_TEST_SUITE_END()\n+BOOST_AUTO_TEST_SUITE_END()\n\\ No newline at end of file"
      },
      {
        "sha": "45151258b354c119bcf20a1939e4d1f583960a16",
        "filename": "src/test/fuzz/fuzz.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/test/fuzz/fuzz.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/test/fuzz/fuzz.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/fuzz.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -13,15 +13,15 @@\n \n const std::function<void(const std::string&)> G_TEST_LOG_FUN{};\n \n-std::map<std::string_view, std::tuple<TypeTestOneInput, TypeInitialize>>& FuzzTargets()\n+std::map<std::string_view, std::tuple<TypeTestOneInput, TypeInitialize, TypeHidden>>& FuzzTargets()\n {\n-    static std::map<std::string_view, std::tuple<TypeTestOneInput, TypeInitialize>> g_fuzz_targets;\n+    static std::map<std::string_view, std::tuple<TypeTestOneInput, TypeInitialize, TypeHidden>> g_fuzz_targets;\n     return g_fuzz_targets;\n }\n \n-void FuzzFrameworkRegisterTarget(std::string_view name, TypeTestOneInput target, TypeInitialize init)\n+void FuzzFrameworkRegisterTarget(std::string_view name, TypeTestOneInput target, TypeInitialize init, TypeHidden hidden)\n {\n-    const auto it_ins = FuzzTargets().try_emplace(name, std::move(target), std::move(init));\n+    const auto it_ins = FuzzTargets().try_emplace(name, std::move(target), std::move(init), hidden);\n     Assert(it_ins.second);\n }\n \n@@ -31,6 +31,7 @@ void initialize()\n {\n     if (std::getenv(\"PRINT_ALL_FUZZ_TARGETS_AND_ABORT\")) {\n         for (const auto& t : FuzzTargets()) {\n+            if (std::get<2>(t.second)) continue;\n             std::cout << t.first << std::endl;\n         }\n         Assert(false);"
      },
      {
        "sha": "4abc52c15a6173112b446b4bc188e64f592353c0",
        "filename": "src/test/fuzz/fuzz.h",
        "status": "modified",
        "additions": 16,
        "deletions": 12,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/test/fuzz/fuzz.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/test/fuzz/fuzz.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/fuzz.h?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -15,22 +15,26 @@ using FuzzBufferType = Span<const uint8_t>;\n \n using TypeTestOneInput = std::function<void(FuzzBufferType)>;\n using TypeInitialize = std::function<void()>;\n+using TypeHidden = bool;\n \n-void FuzzFrameworkRegisterTarget(std::string_view name, TypeTestOneInput target, TypeInitialize init);\n+void FuzzFrameworkRegisterTarget(std::string_view name, TypeTestOneInput target, TypeInitialize init, TypeHidden hidden);\n \n-inline void FuzzFrameworkEmptyFun() {}\n+inline void FuzzFrameworkEmptyInitFun() {}\n \n #define FUZZ_TARGET(name) \\\n-    FUZZ_TARGET_INIT(name, FuzzFrameworkEmptyFun)\n-\n-#define FUZZ_TARGET_INIT(name, init_fun)                                      \\\n-    void name##_fuzz_target(FuzzBufferType);                                  \\\n-    struct name##_Before_Main {                                               \\\n-        name##_Before_Main()                                                  \\\n-        {                                                                     \\\n-            FuzzFrameworkRegisterTarget(#name, name##_fuzz_target, init_fun); \\\n-        }                                                                     \\\n-    } const static g_##name##_before_main;                                    \\\n+    FUZZ_TARGET_INIT(name, FuzzFrameworkEmptyInitFun)\n+\n+#define FUZZ_TARGET_INIT(name, init_fun) \\\n+    FUZZ_TARGET_INIT_HIDDEN(name, init_fun, false)\n+\n+#define FUZZ_TARGET_INIT_HIDDEN(name, init_fun, hidden)                               \\\n+    void name##_fuzz_target(FuzzBufferType);                                          \\\n+    struct name##_Before_Main {                                                       \\\n+        name##_Before_Main()                                                          \\\n+        {                                                                             \\\n+            FuzzFrameworkRegisterTarget(#name, name##_fuzz_target, init_fun, hidden); \\\n+        }                                                                             \\\n+    } const static g_##name##_before_main;                                            \\\n     void name##_fuzz_target(FuzzBufferType buffer)\n \n #endif // BITCOIN_TEST_FUZZ_FUZZ_H"
      },
      {
        "sha": "a42080eb662cbb6fe849b50045bfc4a26453cf7b",
        "filename": "src/test/fuzz/netaddress.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/test/fuzz/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/test/fuzz/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/netaddress.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -9,7 +9,6 @@\n \n #include <cassert>\n #include <cstdint>\n-#include <netinet/in.h>\n #include <vector>\n \n FUZZ_TARGET(netaddress)"
      },
      {
        "sha": "442e32d4ca9a0f8ad6be993ac4523df0af09974a",
        "filename": "src/test/fuzz/process_message.cpp",
        "status": "modified",
        "additions": 54,
        "deletions": 25,
        "changes": 79,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/test/fuzz/process_message.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/test/fuzz/process_message.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/process_message.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -35,8 +35,27 @@ namespace {\n const TestingSetup* g_setup;\n } // namespace\n \n+size_t& GetNumMsgTypes()\n+{\n+    static size_t g_num_msg_types{0};\n+    return g_num_msg_types;\n+}\n+#define FUZZ_TARGET_MSG(msg_type)                                            \\\n+    struct msg_type##_Count_Before_Main {                                    \\\n+        msg_type##_Count_Before_Main()                                       \\\n+        {                                                                    \\\n+            ++GetNumMsgTypes();                                              \\\n+        }                                                                    \\\n+    } const static g_##msg_type##_count_before_main;                         \\\n+    FUZZ_TARGET_INIT(process_message_##msg_type, initialize_process_message) \\\n+    {                                                                        \\\n+        fuzz_target(buffer, #msg_type);                                      \\\n+    }\n+\n void initialize_process_message()\n {\n+    Assert(GetNumMsgTypes() == getAllNetMessageTypes().size()); // If this fails, add or remove the message type below\n+\n     static const auto testing_setup = MakeFuzzingContext<const TestingSetup>();\n     g_setup = testing_setup.get();\n     for (int i = 0; i < 2 * COINBASE_MATURITY; i++) {\n@@ -60,7 +79,7 @@ void fuzz_target(FuzzBufferType buffer, const std::string& LIMIT_TO_MESSAGE_TYPE\n     }\n     CNode& p2p_node = *ConsumeNodeAsUniquePtr(fuzzed_data_provider).release();\n \n-    const bool successfully_connected{true};\n+    const bool successfully_connected{fuzzed_data_provider.ConsumeBool()};\n     p2p_node.fSuccessfullyConnected = successfully_connected;\n     connman.AddTestNode(p2p_node);\n     g_setup->m_node.peerman->InitializeNode(&p2p_node);\n@@ -86,27 +105,37 @@ void fuzz_target(FuzzBufferType buffer, const std::string& LIMIT_TO_MESSAGE_TYPE\n }\n \n FUZZ_TARGET_INIT(process_message, initialize_process_message) { fuzz_target(buffer, \"\"); }\n-FUZZ_TARGET_INIT(process_message_addr, initialize_process_message) { fuzz_target(buffer, \"addr\"); }\n-FUZZ_TARGET_INIT(process_message_block, initialize_process_message) { fuzz_target(buffer, \"block\"); }\n-FUZZ_TARGET_INIT(process_message_blocktxn, initialize_process_message) { fuzz_target(buffer, \"blocktxn\"); }\n-FUZZ_TARGET_INIT(process_message_cmpctblock, initialize_process_message) { fuzz_target(buffer, \"cmpctblock\"); }\n-FUZZ_TARGET_INIT(process_message_feefilter, initialize_process_message) { fuzz_target(buffer, \"feefilter\"); }\n-FUZZ_TARGET_INIT(process_message_filteradd, initialize_process_message) { fuzz_target(buffer, \"filteradd\"); }\n-FUZZ_TARGET_INIT(process_message_filterclear, initialize_process_message) { fuzz_target(buffer, \"filterclear\"); }\n-FUZZ_TARGET_INIT(process_message_filterload, initialize_process_message) { fuzz_target(buffer, \"filterload\"); }\n-FUZZ_TARGET_INIT(process_message_getaddr, initialize_process_message) { fuzz_target(buffer, \"getaddr\"); }\n-FUZZ_TARGET_INIT(process_message_getblocks, initialize_process_message) { fuzz_target(buffer, \"getblocks\"); }\n-FUZZ_TARGET_INIT(process_message_getblocktxn, initialize_process_message) { fuzz_target(buffer, \"getblocktxn\"); }\n-FUZZ_TARGET_INIT(process_message_getdata, initialize_process_message) { fuzz_target(buffer, \"getdata\"); }\n-FUZZ_TARGET_INIT(process_message_getheaders, initialize_process_message) { fuzz_target(buffer, \"getheaders\"); }\n-FUZZ_TARGET_INIT(process_message_headers, initialize_process_message) { fuzz_target(buffer, \"headers\"); }\n-FUZZ_TARGET_INIT(process_message_inv, initialize_process_message) { fuzz_target(buffer, \"inv\"); }\n-FUZZ_TARGET_INIT(process_message_mempool, initialize_process_message) { fuzz_target(buffer, \"mempool\"); }\n-FUZZ_TARGET_INIT(process_message_notfound, initialize_process_message) { fuzz_target(buffer, \"notfound\"); }\n-FUZZ_TARGET_INIT(process_message_ping, initialize_process_message) { fuzz_target(buffer, \"ping\"); }\n-FUZZ_TARGET_INIT(process_message_pong, initialize_process_message) { fuzz_target(buffer, \"pong\"); }\n-FUZZ_TARGET_INIT(process_message_sendcmpct, initialize_process_message) { fuzz_target(buffer, \"sendcmpct\"); }\n-FUZZ_TARGET_INIT(process_message_sendheaders, initialize_process_message) { fuzz_target(buffer, \"sendheaders\"); }\n-FUZZ_TARGET_INIT(process_message_tx, initialize_process_message) { fuzz_target(buffer, \"tx\"); }\n-FUZZ_TARGET_INIT(process_message_verack, initialize_process_message) { fuzz_target(buffer, \"verack\"); }\n-FUZZ_TARGET_INIT(process_message_version, initialize_process_message) { fuzz_target(buffer, \"version\"); }\n+FUZZ_TARGET_MSG(addr);\n+FUZZ_TARGET_MSG(addrv2);\n+FUZZ_TARGET_MSG(block);\n+FUZZ_TARGET_MSG(blocktxn);\n+FUZZ_TARGET_MSG(cfcheckpt);\n+FUZZ_TARGET_MSG(cfheaders);\n+FUZZ_TARGET_MSG(cfilter);\n+FUZZ_TARGET_MSG(cmpctblock);\n+FUZZ_TARGET_MSG(feefilter);\n+FUZZ_TARGET_MSG(filteradd);\n+FUZZ_TARGET_MSG(filterclear);\n+FUZZ_TARGET_MSG(filterload);\n+FUZZ_TARGET_MSG(getaddr);\n+FUZZ_TARGET_MSG(getblocks);\n+FUZZ_TARGET_MSG(getblocktxn);\n+FUZZ_TARGET_MSG(getcfcheckpt);\n+FUZZ_TARGET_MSG(getcfheaders);\n+FUZZ_TARGET_MSG(getcfilters);\n+FUZZ_TARGET_MSG(getdata);\n+FUZZ_TARGET_MSG(getheaders);\n+FUZZ_TARGET_MSG(headers);\n+FUZZ_TARGET_MSG(inv);\n+FUZZ_TARGET_MSG(mempool);\n+FUZZ_TARGET_MSG(merkleblock);\n+FUZZ_TARGET_MSG(notfound);\n+FUZZ_TARGET_MSG(ping);\n+FUZZ_TARGET_MSG(pong);\n+FUZZ_TARGET_MSG(sendaddrv2);\n+FUZZ_TARGET_MSG(sendcmpct);\n+FUZZ_TARGET_MSG(sendheaders);\n+FUZZ_TARGET_MSG(tx);\n+FUZZ_TARGET_MSG(verack);\n+FUZZ_TARGET_MSG(version);\n+FUZZ_TARGET_MSG(wtxidrelay);"
      },
      {
        "sha": "ef45196671ed5e18ab9b63ae4e0ab24a627f7c0f",
        "filename": "src/test/fuzz/process_messages.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/test/fuzz/process_messages.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/test/fuzz/process_messages.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/process_messages.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -46,7 +46,7 @@ FUZZ_TARGET_INIT(process_messages, initialize_process_messages)\n         peers.push_back(ConsumeNodeAsUniquePtr(fuzzed_data_provider, i).release());\n         CNode& p2p_node = *peers.back();\n \n-        const bool successfully_connected{true};\n+        const bool successfully_connected{fuzzed_data_provider.ConsumeBool()};\n         p2p_node.fSuccessfullyConnected = successfully_connected;\n         p2p_node.fPauseSend = false;\n         g_setup->m_node.peerman->InitializeNode(&p2p_node);"
      },
      {
        "sha": "8d9a939dab3cd8e2ca1c1a72f41606eac33107da",
        "filename": "src/test/fuzz/script_assets_test_minimizer.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/test/fuzz/script_assets_test_minimizer.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/test/fuzz/script_assets_test_minimizer.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/script_assets_test_minimizer.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -28,12 +28,12 @@\n //\n // (normal build)\n // $ mkdir dump\n-// $ for N in $(seq 1 10); do TEST_DUMP_DIR=dump test/functional/feature_taproot --dumptests; done\n+// $ for N in $(seq 1 10); do TEST_DUMP_DIR=dump test/functional/feature_taproot.py --dumptests; done\n // $ ...\n //\n-// (fuzz test build)\n+// (libFuzzer build)\n // $ mkdir dump-min\n-// $ ./src/test/fuzz/script_assets_test_minimizer -merge=1 dump-min/ dump/\n+// $ FUZZ=script_assets_test_minimizer ./src/test/fuzz/fuzz -merge=1 -use_value_profile=1 dump-min/ dump/\n // $ (echo -en '[\\n'; cat dump-min/* | head -c -2; echo -en '\\n]') >script_assets_test.json\n \n namespace {\n@@ -190,7 +190,7 @@ ECCVerifyHandle handle;\n \n } // namespace\n \n-FUZZ_TARGET(script_assets_test_minimizer)\n+FUZZ_TARGET_INIT_HIDDEN(script_assets_test_minimizer, FuzzFrameworkEmptyInitFun, /* hidden */ true)\n {\n     if (buffer.size() < 2 || buffer.back() != '\\n' || buffer[buffer.size() - 2] != ',') return;\n     const std::string str((const char*)buffer.data(), buffer.size() - 2);"
      },
      {
        "sha": "d6bbb17f63c8cb650655a7311f89e7a7db5b987c",
        "filename": "src/test/fuzz/string.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/test/fuzz/string.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/test/fuzz/string.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/string.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -78,7 +78,9 @@ FUZZ_TARGET(string)\n     }\n     (void)SanitizeString(random_string_1);\n     (void)SanitizeString(random_string_1, fuzzed_data_provider.ConsumeIntegralInRange<int>(0, 3));\n+#ifndef WIN32\n     (void)ShellEscape(random_string_1);\n+#endif // WIN32\n     int port_out;\n     std::string host_out;\n     SplitHostPort(random_string_1, port_out, host_out);"
      },
      {
        "sha": "4dc0dd5f5110cd8efa36776719e550a7a4776c42",
        "filename": "src/test/script_standard_tests.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/test/script_standard_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/test/script_standard_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_standard_tests.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -107,6 +107,22 @@ BOOST_AUTO_TEST_CASE(script_standard_Solver_success)\n     BOOST_CHECK_EQUAL(solutions.size(), 1U);\n     BOOST_CHECK(solutions[0] == ToByteVector(scriptHash));\n \n+    // TxoutType::WITNESS_V1_TAPROOT\n+    s.clear();\n+    s << OP_1 << ToByteVector(uint256::ZERO);\n+    BOOST_CHECK_EQUAL(Solver(s, solutions), TxoutType::WITNESS_V1_TAPROOT);\n+    BOOST_CHECK_EQUAL(solutions.size(), 2U);\n+    BOOST_CHECK(solutions[0] == std::vector<unsigned char>{1});\n+    BOOST_CHECK(solutions[1] == ToByteVector(uint256::ZERO));\n+\n+    // TxoutType::WITNESS_UNKNOWN\n+    s.clear();\n+    s << OP_16 << ToByteVector(uint256::ONE);\n+    BOOST_CHECK_EQUAL(Solver(s, solutions), TxoutType::WITNESS_UNKNOWN);\n+    BOOST_CHECK_EQUAL(solutions.size(), 2U);\n+    BOOST_CHECK(solutions[0] == std::vector<unsigned char>{16});\n+    BOOST_CHECK(solutions[1] == ToByteVector(uint256::ONE));\n+\n     // TxoutType::NONSTANDARD\n     s.clear();\n     s << OP_9 << OP_ADD << OP_11 << OP_EQUAL;"
      },
      {
        "sha": "cc0e6e70575c89d8f4c4765c45fb4d2b50bf7e63",
        "filename": "src/test/sock_tests.cpp",
        "status": "added",
        "additions": 149,
        "deletions": 0,
        "changes": 149,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/test/sock_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/test/sock_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sock_tests.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -0,0 +1,149 @@\n+// Copyright (c) 2021-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compat.h>\n+#include <test/util/setup_common.h>\n+#include <util/sock.h>\n+#include <util/system.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <thread>\n+\n+using namespace std::chrono_literals;\n+\n+BOOST_FIXTURE_TEST_SUITE(sock_tests, BasicTestingSetup)\n+\n+static bool SocketIsClosed(const SOCKET& s)\n+{\n+    // Notice that if another thread is running and creates its own socket after `s` has been\n+    // closed, it may be assigned the same file descriptor number. In this case, our test will\n+    // wrongly pretend that the socket is not closed.\n+    int type;\n+    socklen_t len = sizeof(type);\n+    return getsockopt(s, SOL_SOCKET, SO_TYPE, (sockopt_arg_type)&type, &len) == SOCKET_ERROR;\n+}\n+\n+static SOCKET CreateSocket()\n+{\n+    const SOCKET s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n+    BOOST_REQUIRE(s != static_cast<SOCKET>(SOCKET_ERROR));\n+    return s;\n+}\n+\n+BOOST_AUTO_TEST_CASE(constructor_and_destructor)\n+{\n+    const SOCKET s = CreateSocket();\n+    Sock* sock = new Sock(s);\n+    BOOST_CHECK_EQUAL(sock->Get(), s);\n+    BOOST_CHECK(!SocketIsClosed(s));\n+    delete sock;\n+    BOOST_CHECK(SocketIsClosed(s));\n+}\n+\n+BOOST_AUTO_TEST_CASE(move_constructor)\n+{\n+    const SOCKET s = CreateSocket();\n+    Sock* sock1 = new Sock(s);\n+    Sock* sock2 = new Sock(std::move(*sock1));\n+    delete sock1;\n+    BOOST_CHECK(!SocketIsClosed(s));\n+    BOOST_CHECK_EQUAL(sock2->Get(), s);\n+    delete sock2;\n+    BOOST_CHECK(SocketIsClosed(s));\n+}\n+\n+BOOST_AUTO_TEST_CASE(move_assignment)\n+{\n+    const SOCKET s = CreateSocket();\n+    Sock* sock1 = new Sock(s);\n+    Sock* sock2 = new Sock();\n+    *sock2 = std::move(*sock1);\n+    delete sock1;\n+    BOOST_CHECK(!SocketIsClosed(s));\n+    BOOST_CHECK_EQUAL(sock2->Get(), s);\n+    delete sock2;\n+    BOOST_CHECK(SocketIsClosed(s));\n+}\n+\n+BOOST_AUTO_TEST_CASE(release)\n+{\n+    SOCKET s = CreateSocket();\n+    Sock* sock = new Sock(s);\n+    BOOST_CHECK_EQUAL(sock->Release(), s);\n+    delete sock;\n+    BOOST_CHECK(!SocketIsClosed(s));\n+    BOOST_REQUIRE(CloseSocket(s));\n+}\n+\n+BOOST_AUTO_TEST_CASE(reset)\n+{\n+    const SOCKET s = CreateSocket();\n+    Sock sock(s);\n+    sock.Reset();\n+    BOOST_CHECK(SocketIsClosed(s));\n+}\n+\n+#ifndef WIN32 // Windows does not have socketpair(2).\n+\n+static void CreateSocketPair(int s[2])\n+{\n+    BOOST_REQUIRE_EQUAL(socketpair(AF_UNIX, SOCK_STREAM, 0, s), 0);\n+}\n+\n+static void SendAndRecvMessage(const Sock& sender, const Sock& receiver)\n+{\n+    const char* msg = \"abcd\";\n+    constexpr size_t msg_len = 4;\n+    char recv_buf[10];\n+\n+    BOOST_CHECK_EQUAL(sender.Send(msg, msg_len, 0), msg_len);\n+    BOOST_CHECK_EQUAL(receiver.Recv(recv_buf, sizeof(recv_buf), 0), msg_len);\n+    BOOST_CHECK_EQUAL(strncmp(msg, recv_buf, msg_len), 0);\n+}\n+\n+BOOST_AUTO_TEST_CASE(send_and_receive)\n+{\n+    int s[2];\n+    CreateSocketPair(s);\n+\n+    Sock* sock0 = new Sock(s[0]);\n+    Sock* sock1 = new Sock(s[1]);\n+\n+    SendAndRecvMessage(*sock0, *sock1);\n+\n+    Sock* sock0moved = new Sock(std::move(*sock0));\n+    Sock* sock1moved = new Sock();\n+    *sock1moved = std::move(*sock1);\n+\n+    delete sock0;\n+    delete sock1;\n+\n+    SendAndRecvMessage(*sock1moved, *sock0moved);\n+\n+    delete sock0moved;\n+    delete sock1moved;\n+\n+    BOOST_CHECK(SocketIsClosed(s[0]));\n+    BOOST_CHECK(SocketIsClosed(s[1]));\n+}\n+\n+BOOST_AUTO_TEST_CASE(wait)\n+{\n+    int s[2];\n+    CreateSocketPair(s);\n+\n+    Sock sock0(s[0]);\n+    Sock sock1(s[1]);\n+\n+    std::thread waiter([&sock0]() { sock0.Wait(24h, Sock::RECV); });\n+\n+    BOOST_REQUIRE_EQUAL(sock1.Send(\"a\", 1, 0), 1);\n+\n+    waiter.join();\n+}\n+\n+#endif /* WIN32 */\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "9b0d2e3135f591ec0a52c512c298f3237b20f2f1",
        "filename": "src/test/txvalidation_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 10,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/test/txvalidation_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/test/txvalidation_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidation_tests.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -30,25 +30,21 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_reject_coinbase, TestChain100Setup)\n \n     BOOST_CHECK(CTransaction(coinbaseTx).IsCoinBase());\n \n-    TxValidationState state;\n-\n     LOCK(cs_main);\n \n     unsigned int initialPoolSize = m_node.mempool->size();\n+    const MempoolAcceptResult result = AcceptToMemoryPool(*m_node.mempool, MakeTransactionRef(coinbaseTx),\n+                true /* bypass_limits */);\n \n-    BOOST_CHECK_EQUAL(\n-            false,\n-            AcceptToMemoryPool(*m_node.mempool, state, MakeTransactionRef(coinbaseTx),\n-                nullptr /* plTxnReplaced */,\n-                true /* bypass_limits */));\n+    BOOST_CHECK(result.m_result_type == MempoolAcceptResult::ResultType::INVALID);\n \n     // Check that the transaction hasn't been added to mempool.\n     BOOST_CHECK_EQUAL(m_node.mempool->size(), initialPoolSize);\n \n     // Check that the validation state reflects the unsuccessful attempt.\n-    BOOST_CHECK(state.IsInvalid());\n-    BOOST_CHECK_EQUAL(state.GetRejectReason(), \"coinbase\");\n-    BOOST_CHECK(state.GetResult() == TxValidationResult::TX_CONSENSUS);\n+    BOOST_CHECK(result.m_state.IsInvalid());\n+    BOOST_CHECK_EQUAL(result.m_state.GetRejectReason(), \"coinbase\");\n+    BOOST_CHECK(result.m_state.GetResult() == TxValidationResult::TX_CONSENSUS);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "af0090cc10877df4cc4372db6adbc1fcdaec9928",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -28,9 +28,9 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)\n     const auto ToMemPool = [this](const CMutableTransaction& tx) {\n         LOCK(cs_main);\n \n-        TxValidationState state;\n-        return AcceptToMemoryPool(*m_node.mempool, state, MakeTransactionRef(tx),\n-            nullptr /* plTxnReplaced */, true /* bypass_limits */);\n+        const MempoolAcceptResult result = AcceptToMemoryPool(*m_node.mempool, MakeTransactionRef(tx),\n+            true /* bypass_limits */);\n+        return result.m_result_type == MempoolAcceptResult::ResultType::VALID;\n     };\n \n     // Create a double-spend of mature coinbase txn:"
      },
      {
        "sha": "dccbf00d6fe4e034e645a772e080177325e84379",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -13,6 +13,7 @@\n #include <test/util/setup_common.h>\n #include <test/util/str.h>\n #include <uint256.h>\n+#include <util/getuniquepath.h>\n #include <util/message.h> // For MessageSign(), MessageVerify(), MESSAGE_MAGIC\n #include <util/moneystr.h>\n #include <util/spanparsing.h>\n@@ -1816,7 +1817,7 @@ BOOST_AUTO_TEST_CASE(test_DirIsWritable)\n     BOOST_CHECK_EQUAL(DirIsWritable(tmpdirname), true);\n \n     // Should not be able to write to a non-existent dir.\n-    tmpdirname = tmpdirname / fs::unique_path();\n+    tmpdirname = GetUniquePath(tmpdirname);\n     BOOST_CHECK_EQUAL(DirIsWritable(tmpdirname), false);\n \n     fs::create_directory(tmpdirname);"
      },
      {
        "sha": "6c18a9e1bb01bad6144199e33e694587deae22ee",
        "filename": "src/test/validation_block_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 8,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/test/validation_block_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/test/validation_block_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_block_tests.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -283,15 +283,9 @@ BOOST_AUTO_TEST_CASE(mempool_locks_reorg)\n         // Add the txs to the tx pool\n         {\n             LOCK(cs_main);\n-            TxValidationState state;\n-            std::list<CTransactionRef> plTxnReplaced;\n             for (const auto& tx : txs) {\n-                BOOST_REQUIRE(AcceptToMemoryPool(\n-                    *m_node.mempool,\n-                    state,\n-                    tx,\n-                    &plTxnReplaced,\n-                    /* bypass_limits */ false));\n+                const MempoolAcceptResult result = AcceptToMemoryPool(*m_node.mempool, tx, false /* bypass_limits */);\n+                BOOST_REQUIRE(result.m_result_type == MempoolAcceptResult::ResultType::VALID);\n             }\n         }\n "
      },
      {
        "sha": "605c77fc3a857136573230bbafbb830c8e22f585",
        "filename": "src/torcontrol.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/torcontrol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/torcontrol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/torcontrol.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -14,6 +14,7 @@\n #include <netbase.h>\n #include <util/strencodings.h>\n #include <util/system.h>\n+#include <util/time.h>\n \n #include <deque>\n #include <functional>"
      },
      {
        "sha": "9fa7b4e2512d6e826d2c7a4ea107bd41f4ceb9e5",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 4,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -9,14 +9,14 @@\n #include <consensus/tx_verify.h>\n #include <consensus/validation.h>\n #include <optional.h>\n-#include <validation.h>\n-#include <policy/policy.h>\n #include <policy/fees.h>\n+#include <policy/policy.h>\n #include <policy/settings.h>\n #include <reverse_iterator.h>\n-#include <util/system.h>\n #include <util/moneystr.h>\n+#include <util/system.h>\n #include <util/time.h>\n+#include <validation.h>\n #include <validationinterface.h>\n \n CTxMemPoolEntry::CTxMemPoolEntry(const CTransactionRef& _tx, const CAmount& _nFee,\n@@ -396,7 +396,10 @@ void CTxMemPool::addUnchecked(const CTxMemPoolEntry &entry, setEntries &setAnces\n \n     nTransactionsUpdated++;\n     totalTxSize += entry.GetTxSize();\n-    if (minerPolicyEstimator) {minerPolicyEstimator->processTransaction(entry, validFeeEstimate);}\n+    m_total_fee += entry.GetFee();\n+    if (minerPolicyEstimator) {\n+        minerPolicyEstimator->processTransaction(entry, validFeeEstimate);\n+    }\n \n     vTxHashes.emplace_back(tx.GetWitnessHash(), newit);\n     newit->vTxHashesIdx = vTxHashes.size() - 1;\n@@ -432,6 +435,7 @@ void CTxMemPool::removeUnchecked(txiter it, MemPoolRemovalReason reason)\n         vTxHashes.clear();\n \n     totalTxSize -= it->GetTxSize();\n+    m_total_fee -= it->GetFee();\n     cachedInnerUsage -= it->DynamicMemoryUsage();\n     cachedInnerUsage -= memusage::DynamicUsage(it->GetMemPoolParentsConst()) + memusage::DynamicUsage(it->GetMemPoolChildrenConst());\n     mapTx.erase(it);\n@@ -590,6 +594,7 @@ void CTxMemPool::_clear()\n     mapTx.clear();\n     mapNextTx.clear();\n     totalTxSize = 0;\n+    m_total_fee = 0;\n     cachedInnerUsage = 0;\n     lastRollingFeeUpdate = GetTime();\n     blockSinceLastRollingFeeBump = false;\n@@ -623,6 +628,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n     LogPrint(BCLog::MEMPOOL, \"Checking mempool with %u transactions and %u inputs\\n\", (unsigned int)mapTx.size(), (unsigned int)mapNextTx.size());\n \n     uint64_t checkTotal = 0;\n+    CAmount check_total_fee{0};\n     uint64_t innerUsage = 0;\n \n     CCoinsViewCache mempoolDuplicate(const_cast<CCoinsViewCache*>(pcoins));\n@@ -632,6 +638,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n     for (indexed_transaction_set::const_iterator it = mapTx.begin(); it != mapTx.end(); it++) {\n         unsigned int i = 0;\n         checkTotal += it->GetTxSize();\n+        check_total_fee += it->GetFee();\n         innerUsage += it->DynamicMemoryUsage();\n         const CTransaction& tx = it->GetTx();\n         innerUsage += memusage::DynamicUsage(it->GetMemPoolParentsConst()) + memusage::DynamicUsage(it->GetMemPoolChildrenConst());\n@@ -726,6 +733,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n     }\n \n     assert(totalTxSize == checkTotal);\n+    assert(m_total_fee == check_total_fee);\n     assert(innerUsage == cachedInnerUsage);\n }\n "
      },
      {
        "sha": "c0df33fe1374f474201bd2c8c02834ba7382692b",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 10,
        "deletions": 3,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -19,8 +19,8 @@\n #include <optional.h>\n #include <policy/feerate.h>\n #include <primitives/transaction.h>\n-#include <sync.h>\n #include <random.h>\n+#include <sync.h>\n #include <util/hasher.h>\n \n #include <boost/multi_index_container.hpp>\n@@ -478,8 +478,9 @@ class CTxMemPool\n     std::atomic<unsigned int> nTransactionsUpdated{0}; //!< Used by getblocktemplate to trigger CreateNewBlock() invocation\n     CBlockPolicyEstimator* minerPolicyEstimator;\n \n-    uint64_t totalTxSize;      //!< sum of all mempool tx's virtual sizes. Differs from serialized tx size since witness data is discounted. Defined in BIP 141.\n-    uint64_t cachedInnerUsage; //!< sum of dynamic memory usage of all the map elements (NOT the maps themselves)\n+    uint64_t totalTxSize GUARDED_BY(cs);      //!< sum of all mempool tx's virtual sizes. Differs from serialized tx size since witness data is discounted. Defined in BIP 141.\n+    CAmount m_total_fee GUARDED_BY(cs);       //!< sum of all mempool tx's fees (NOT modified fee)\n+    uint64_t cachedInnerUsage GUARDED_BY(cs); //!< sum of dynamic memory usage of all the map elements (NOT the maps themselves)\n \n     mutable int64_t lastRollingFeeUpdate;\n     mutable bool blockSinceLastRollingFeeBump;\n@@ -724,6 +725,12 @@ class CTxMemPool\n         return totalTxSize;\n     }\n \n+    CAmount GetTotalFee() const EXCLUSIVE_LOCKS_REQUIRED(cs)\n+    {\n+        AssertLockHeld(cs);\n+        return m_total_fee;\n+    }\n+\n     bool exists(const GenTxid& gtxid) const\n     {\n         LOCK(cs);"
      },
      {
        "sha": "9839d2f6246e57903af41c816fdf8926acbb6747",
        "filename": "src/util/getuniquepath.cpp",
        "status": "added",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/util/getuniquepath.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/util/getuniquepath.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/getuniquepath.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -0,0 +1,10 @@\n+#include <random.h>\n+#include <fs.h>\n+#include <util/strencodings.h>\n+\n+fs::path GetUniquePath(const fs::path& base)\n+{\n+    FastRandomContext rnd;\n+    fs::path tmpFile = base / HexStr(rnd.randbytes(8));\n+    return tmpFile;\n+}\n\\ No newline at end of file"
      },
      {
        "sha": "e0c6147876b6d880bea36ebe7ea4613d34aebb60",
        "filename": "src/util/getuniquepath.h",
        "status": "added",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/util/getuniquepath.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/util/getuniquepath.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/getuniquepath.h?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -0,0 +1,19 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_GETUNIQUEPATH_H\n+#define BITCOIN_UTIL_GETUNIQUEPATH_H\n+\n+#include <fs.h>\n+\n+/**\n+ * Helper function for getting a unique path\n+ *\n+ * @param[in] base  Base path\n+ * @returns base joined with a random 8-character long string.\n+ * @post Returned path is unique with high probability.\n+ */\n+fs::path GetUniquePath(const fs::path& base);\n+\n+#endif // BITCOIN_UTIL_GETUNIQUEPATH_H\n\\ No newline at end of file"
      },
      {
        "sha": "4c65b5b68094664a7ceb9d40efa1b2307ad5545f",
        "filename": "src/util/sock.cpp",
        "status": "added",
        "additions": 149,
        "deletions": 0,
        "changes": 149,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/util/sock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/util/sock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/sock.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -0,0 +1,149 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compat.h>\n+#include <logging.h>\n+#include <tinyformat.h>\n+#include <util/sock.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <codecvt>\n+#include <cwchar>\n+#include <locale>\n+#include <string>\n+\n+#ifdef USE_POLL\n+#include <poll.h>\n+#endif\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+ssize_t Sock::Send(const void* data, size_t len, int flags) const\n+{\n+    return send(m_socket, static_cast<const char*>(data), len, flags);\n+}\n+\n+ssize_t Sock::Recv(void* buf, size_t len, int flags) const\n+{\n+    return recv(m_socket, static_cast<char*>(buf), len, flags);\n+}\n+\n+bool Sock::Wait(std::chrono::milliseconds timeout, Event requested) const\n+{\n+#ifdef USE_POLL\n+    pollfd fd;\n+    fd.fd = m_socket;\n+    fd.events = 0;\n+    if (requested & RECV) {\n+        fd.events |= POLLIN;\n+    }\n+    if (requested & SEND) {\n+        fd.events |= POLLOUT;\n+    }\n+\n+    return poll(&fd, 1, count_milliseconds(timeout)) != SOCKET_ERROR;\n+#else\n+    if (!IsSelectableSocket(m_socket)) {\n+        return false;\n+    }\n+\n+    fd_set fdset_recv;\n+    fd_set fdset_send;\n+    FD_ZERO(&fdset_recv);\n+    FD_ZERO(&fdset_send);\n+\n+    if (requested & RECV) {\n+        FD_SET(m_socket, &fdset_recv);\n+    }\n+\n+    if (requested & SEND) {\n+        FD_SET(m_socket, &fdset_send);\n+    }\n+\n+    timeval timeout_struct = MillisToTimeval(timeout);\n+\n+    return select(m_socket + 1, &fdset_recv, &fdset_send, nullptr, &timeout_struct) != SOCKET_ERROR;\n+#endif /* USE_POLL */\n+}\n+\n+#ifdef WIN32\n+std::string NetworkErrorString(int err)\n+{\n+    wchar_t buf[256];\n+    buf[0] = 0;\n+    if(FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,\n+            nullptr, err, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n+            buf, ARRAYSIZE(buf), nullptr))\n+    {\n+        return strprintf(\"%s (%d)\", std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>,wchar_t>().to_bytes(buf), err);\n+    }\n+    else\n+    {\n+        return strprintf(\"Unknown error (%d)\", err);\n+    }\n+}\n+#else\n+std::string NetworkErrorString(int err)\n+{\n+    char buf[256];\n+    buf[0] = 0;\n+    /* Too bad there are two incompatible implementations of the\n+     * thread-safe strerror. */\n+    const char *s;\n+#ifdef STRERROR_R_CHAR_P /* GNU variant can return a pointer outside the passed buffer */\n+    s = strerror_r(err, buf, sizeof(buf));\n+#else /* POSIX variant always returns message in buffer */\n+    s = buf;\n+    if (strerror_r(err, buf, sizeof(buf)))\n+        buf[0] = 0;\n+#endif\n+    return strprintf(\"%s (%d)\", s, err);\n+}\n+#endif\n+\n+bool CloseSocket(SOCKET& hSocket)\n+{\n+    if (hSocket == INVALID_SOCKET)\n+        return false;\n+#ifdef WIN32\n+    int ret = closesocket(hSocket);\n+#else\n+    int ret = close(hSocket);\n+#endif\n+    if (ret) {\n+        LogPrintf(\"Socket close failed: %d. Error: %s\\n\", hSocket, NetworkErrorString(WSAGetLastError()));\n+    }\n+    hSocket = INVALID_SOCKET;\n+    return ret != SOCKET_ERROR;\n+}"
      },
      {
        "sha": "26fe60f18f76094cb5a89f77d0a3503276ac40ce",
        "filename": "src/util/sock.h",
        "status": "added",
        "additions": 118,
        "deletions": 0,
        "changes": 118,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/util/sock.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/util/sock.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/sock.h?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -0,0 +1,118 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_SOCK_H\n+#define BITCOIN_UTIL_SOCK_H\n+\n+#include <compat.h>\n+\n+#include <chrono>\n+#include <string>\n+\n+/**\n+ * RAII helper class that manages a socket. Mimics `std::unique_ptr`, but instead of a pointer it\n+ * contains a socket and closes it automatically when it goes out of scope.\n+ */\n+class Sock\n+{\n+public:\n+    /**\n+     * Default constructor, creates an empty object that does nothing when destroyed.\n+     */\n+    Sock();\n+\n+    /**\n+     * Take ownership of an existent socket.\n+     */\n+    explicit Sock(SOCKET s);\n+\n+    /**\n+     * Copy constructor, disabled because closing the same socket twice is undesirable.\n+     */\n+    Sock(const Sock&) = delete;\n+\n+    /**\n+     * Move constructor, grab the socket from another object and close ours (if set).\n+     */\n+    Sock(Sock&& other);\n+\n+    /**\n+     * Destructor, close the socket or do nothing if empty.\n+     */\n+    virtual ~Sock();\n+\n+    /**\n+     * Copy assignment operator, disabled because closing the same socket twice is undesirable.\n+     */\n+    Sock& operator=(const Sock&) = delete;\n+\n+    /**\n+     * Move assignment operator, grab the socket from another object and close ours (if set).\n+     */\n+    virtual Sock& operator=(Sock&& other);\n+\n+    /**\n+     * Get the value of the contained socket.\n+     * @return socket or INVALID_SOCKET if empty\n+     */\n+    virtual SOCKET Get() const;\n+\n+    /**\n+     * Get the value of the contained socket and drop ownership. It will not be closed by the\n+     * destructor after this call.\n+     * @return socket or INVALID_SOCKET if empty\n+     */\n+    virtual SOCKET Release();\n+\n+    /**\n+     * Close if non-empty.\n+     */\n+    virtual void Reset();\n+\n+    /**\n+     * send(2) wrapper. Equivalent to `send(this->Get(), data, len, flags);`. Code that uses this\n+     * wrapper can be unit-tested if this method is overridden by a mock Sock implementation.\n+     */\n+    virtual ssize_t Send(const void* data, size_t len, int flags) const;\n+\n+    /**\n+     * recv(2) wrapper. Equivalent to `recv(this->Get(), buf, len, flags);`. Code that uses this\n+     * wrapper can be unit-tested if this method is overridden by a mock Sock implementation.\n+     */\n+    virtual ssize_t Recv(void* buf, size_t len, int flags) const;\n+\n+    using Event = uint8_t;\n+\n+    /**\n+     * If passed to `Wait()`, then it will wait for readiness to read from the socket.\n+     */\n+    static constexpr Event RECV = 0b01;\n+\n+    /**\n+     * If passed to `Wait()`, then it will wait for readiness to send to the socket.\n+     */\n+    static constexpr Event SEND = 0b10;\n+\n+    /**\n+     * Wait for readiness for input (recv) or output (send).\n+     * @param[in] timeout Wait this much for at least one of the requested events to occur.\n+     * @param[in] requested Wait for those events, bitwise-or of `RECV` and `SEND`.\n+     * @return true on success and false otherwise\n+     */\n+    virtual bool Wait(std::chrono::milliseconds timeout, Event requested) const;\n+\n+private:\n+    /**\n+     * Contained socket. `INVALID_SOCKET` designates the object is empty.\n+     */\n+    SOCKET m_socket;\n+};\n+\n+/** Return readable error string for a network error code */\n+std::string NetworkErrorString(int err);\n+\n+/** Close socket and set hSocket to INVALID_SOCKET */\n+bool CloseSocket(SOCKET& hSocket);\n+\n+#endif // BITCOIN_UTIL_SOCK_H"
      },
      {
        "sha": "9a2e719bbc80dc78f9bc6b8751c51d8f9d14bd61",
        "filename": "src/util/system.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/util/system.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/util/system.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/system.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -12,6 +12,7 @@\n #include <chainparamsbase.h>\n #include <sync.h>\n #include <util/check.h>\n+#include <util/getuniquepath.h>\n #include <util/strencodings.h>\n #include <util/string.h>\n #include <util/translation.h>\n@@ -124,7 +125,7 @@ void ReleaseDirectoryLocks()\n \n bool DirIsWritable(const fs::path& directory)\n {\n-    fs::path tmpFile = directory / fs::unique_path();\n+    fs::path tmpFile = GetUniquePath(directory);\n \n     FILE* file = fsbridge::fopen(tmpFile, \"a\");\n     if (!file) return false;"
      },
      {
        "sha": "295806c54af0686d06d9de28406160b70b1eebdf",
        "filename": "src/util/time.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 1,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/util/time.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/util/time.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/time.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -7,8 +7,11 @@\n #include <config/bitcoin-config.h>\n #endif\n \n+#include <compat.h>\n #include <util/time.h>\n \n+#include <util/check.h>\n+\n #include <atomic>\n #include <boost/date_time/posix_time/posix_time.hpp>\n #include <ctime>\n@@ -18,7 +21,7 @@\n \n void UninterruptibleSleep(const std::chrono::microseconds& n) { std::this_thread::sleep_for(n); }\n \n-static std::atomic<int64_t> nMockTime(0); //!< For unit testing\n+static std::atomic<int64_t> nMockTime(0); //!< For testing\n \n int64_t GetTime()\n {\n@@ -46,6 +49,7 @@ template std::chrono::microseconds GetTime();\n \n void SetMockTime(int64_t nMockTimeIn)\n {\n+    Assert(nMockTimeIn >= 0);\n     nMockTime.store(nMockTimeIn, std::memory_order_relaxed);\n }\n \n@@ -114,3 +118,16 @@ int64_t ParseISO8601DateTime(const std::string& str)\n         return 0;\n     return (ptime - epoch).total_seconds();\n }\n+\n+struct timeval MillisToTimeval(int64_t nTimeout)\n+{\n+    struct timeval timeout;\n+    timeout.tv_sec  = nTimeout / 1000;\n+    timeout.tv_usec = (nTimeout % 1000) * 1000;\n+    return timeout;\n+}\n+\n+struct timeval MillisToTimeval(std::chrono::milliseconds ms)\n+{\n+    return MillisToTimeval(count_milliseconds(ms));\n+}"
      },
      {
        "sha": "03b75b5be56193b3ae73ed956f1fdee7e1e34e75",
        "filename": "src/util/time.h",
        "status": "modified",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/util/time.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/util/time.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/time.h?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -6,6 +6,8 @@\n #ifndef BITCOIN_UTIL_TIME_H\n #define BITCOIN_UTIL_TIME_H\n \n+#include <compat.h>\n+\n #include <chrono>\n #include <stdint.h>\n #include <string>\n@@ -25,6 +27,7 @@ void UninterruptibleSleep(const std::chrono::microseconds& n);\n  * interface that doesn't support std::chrono (e.g. RPC, debug log, or the GUI)\n  */\n inline int64_t count_seconds(std::chrono::seconds t) { return t.count(); }\n+inline int64_t count_milliseconds(std::chrono::milliseconds t) { return t.count(); }\n inline int64_t count_microseconds(std::chrono::microseconds t) { return t.count(); }\n \n /**\n@@ -57,4 +60,14 @@ std::string FormatISO8601DateTime(int64_t nTime);\n std::string FormatISO8601Date(int64_t nTime);\n int64_t ParseISO8601DateTime(const std::string& str);\n \n+/**\n+ * Convert milliseconds to a struct timeval for e.g. select.\n+ */\n+struct timeval MillisToTimeval(int64_t nTimeout);\n+\n+/**\n+ * Convert milliseconds to a struct timeval for e.g. select.\n+ */\n+struct timeval MillisToTimeval(std::chrono::milliseconds ms);\n+\n #endif // BITCOIN_UTIL_TIME_H"
      },
      {
        "sha": "9938b626405bb7af25e62fdadd46f491d30c315d",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 42,
        "deletions": 55,
        "changes": 97,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -380,10 +380,8 @@ static void UpdateMempoolForReorg(CTxMemPool& mempool, DisconnectedBlockTransact\n     auto it = disconnectpool.queuedTx.get<insertion_order>().rbegin();\n     while (it != disconnectpool.queuedTx.get<insertion_order>().rend()) {\n         // ignore validation errors in resurrected transactions\n-        TxValidationState stateDummy;\n         if (!fAddToMempool || (*it)->IsCoinBase() ||\n-            !AcceptToMemoryPool(mempool, stateDummy, *it,\n-                                nullptr /* plTxnReplaced */, true /* bypass_limits */)) {\n+            AcceptToMemoryPool(mempool, *it, true /* bypass_limits */).m_result_type != MempoolAcceptResult::ResultType::VALID) {\n             // If the transaction doesn't make it in to the mempool, remove any\n             // transactions that depend on it (which would now be orphans).\n             mempool.removeRecursive(**it, MemPoolRemovalReason::REORG);\n@@ -463,9 +461,7 @@ class MemPoolAccept\n     // around easier.\n     struct ATMPArgs {\n         const CChainParams& m_chainparams;\n-        TxValidationState &m_state;\n         const int64_t m_accept_time;\n-        std::list<CTransactionRef>* m_replaced_transactions;\n         const bool m_bypass_limits;\n         /*\n          * Return any outpoints which were not previously present in the coins\n@@ -476,11 +472,10 @@ class MemPoolAccept\n          */\n         std::vector<COutPoint>& m_coins_to_uncache;\n         const bool m_test_accept;\n-        CAmount* m_fee_out;\n     };\n \n     // Single transaction acceptance\n-    bool AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs& args) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    MempoolAcceptResult AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs& args) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n private:\n     // All the intermediate state that gets passed between the various levels\n@@ -491,14 +486,17 @@ class MemPoolAccept\n         CTxMemPool::setEntries m_all_conflicting;\n         CTxMemPool::setEntries m_ancestors;\n         std::unique_ptr<CTxMemPoolEntry> m_entry;\n+        std::list<CTransactionRef> m_replaced_transactions;\n \n         bool m_replacement_transaction;\n+        CAmount m_base_fees;\n         CAmount m_modified_fees;\n         CAmount m_conflicting_fees;\n         size_t m_conflicting_size;\n \n         const CTransactionRef& m_ptx;\n         const uint256& m_hash;\n+        TxValidationState m_state;\n     };\n \n     // Run the policy checks on a given transaction, excluding any script checks.\n@@ -509,18 +507,18 @@ class MemPoolAccept\n \n     // Run the script checks using our policy flags. As this can be slow, we should\n     // only invoke this on transactions that have otherwise passed policy checks.\n-    bool PolicyScriptChecks(ATMPArgs& args, const Workspace& ws, PrecomputedTransactionData& txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);\n+    bool PolicyScriptChecks(const ATMPArgs& args, Workspace& ws, PrecomputedTransactionData& txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);\n \n     // Re-run the script checks, using consensus flags, and try to cache the\n     // result in the scriptcache. This should be done after\n     // PolicyScriptChecks(). This requires that all inputs either be in our\n     // utxo set or in the mempool.\n-    bool ConsensusScriptChecks(ATMPArgs& args, const Workspace& ws, PrecomputedTransactionData &txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);\n+    bool ConsensusScriptChecks(const ATMPArgs& args, Workspace& ws, PrecomputedTransactionData &txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);\n \n     // Try to add the transaction to the mempool, removing any conflicts first.\n     // Returns true if the transaction is in the mempool after any size\n     // limiting is performed, false otherwise.\n-    bool Finalize(ATMPArgs& args, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);\n+    bool Finalize(const ATMPArgs& args, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);\n \n     // Compare a package's feerate against minimum allowed.\n     bool CheckFeeRate(size_t package_size, CAmount package_fee, TxValidationState& state) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs)\n@@ -558,12 +556,12 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     const uint256& hash = ws.m_hash;\n \n     // Copy/alias what we need out of args\n-    TxValidationState &state = args.m_state;\n     const int64_t nAcceptTime = args.m_accept_time;\n     const bool bypass_limits = args.m_bypass_limits;\n     std::vector<COutPoint>& coins_to_uncache = args.m_coins_to_uncache;\n \n     // Alias what we need out of ws\n+    TxValidationState& state = ws.m_state;\n     std::set<uint256>& setConflicts = ws.m_conflicts;\n     CTxMemPool::setEntries& allConflicting = ws.m_all_conflicting;\n     CTxMemPool::setEntries& setAncestors = ws.m_ancestors;\n@@ -683,16 +681,10 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     if (!CheckSequenceLocks(m_pool, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n         return state.Invalid(TxValidationResult::TX_PREMATURE_SPEND, \"non-BIP68-final\");\n \n-    CAmount nFees = 0;\n-    if (!Consensus::CheckTxInputs(tx, state, m_view, g_chainman.m_blockman.GetSpendHeight(m_view), nFees)) {\n+    if (!Consensus::CheckTxInputs(tx, state, m_view, g_chainman.m_blockman.GetSpendHeight(m_view), ws.m_base_fees)) {\n         return false; // state filled in by CheckTxInputs\n     }\n \n-    // If fee_out is passed, return the fee to the caller\n-    if (args.m_fee_out) {\n-        *args.m_fee_out = nFees;\n-    }\n-\n     // Check for non-standard pay-to-script-hash in inputs\n     const auto& params = args.m_chainparams.GetConsensus();\n     auto taproot_state = VersionBitsState(::ChainActive().Tip(), params, Consensus::DEPLOYMENT_TAPROOT, versionbitscache);\n@@ -707,7 +699,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     int64_t nSigOpsCost = GetTransactionSigOpCost(tx, m_view, STANDARD_SCRIPT_VERIFY_FLAGS);\n \n     // nModifiedFees includes any fee deltas from PrioritiseTransaction\n-    nModifiedFees = nFees;\n+    nModifiedFees = ws.m_base_fees;\n     m_pool.ApplyDelta(hash, nModifiedFees);\n \n     // Keep track of transactions that spend a coinbase, which we re-scan\n@@ -721,7 +713,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n         }\n     }\n \n-    entry.reset(new CTxMemPoolEntry(ptx, nFees, nAcceptTime, ::ChainActive().Height(),\n+    entry.reset(new CTxMemPoolEntry(ptx, ws.m_base_fees, nAcceptTime, ::ChainActive().Height(),\n             fSpendsCoinbase, nSigOpsCost, lp));\n     unsigned int nSize = entry->GetTxSize();\n \n@@ -925,11 +917,10 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     return true;\n }\n \n-bool MemPoolAccept::PolicyScriptChecks(ATMPArgs& args, const Workspace& ws, PrecomputedTransactionData& txdata)\n+bool MemPoolAccept::PolicyScriptChecks(const ATMPArgs& args, Workspace& ws, PrecomputedTransactionData& txdata)\n {\n     const CTransaction& tx = *ws.m_ptx;\n-\n-    TxValidationState &state = args.m_state;\n+    TxValidationState& state = ws.m_state;\n \n     constexpr unsigned int scriptVerifyFlags = STANDARD_SCRIPT_VERIFY_FLAGS;\n \n@@ -952,12 +943,11 @@ bool MemPoolAccept::PolicyScriptChecks(ATMPArgs& args, const Workspace& ws, Prec\n     return true;\n }\n \n-bool MemPoolAccept::ConsensusScriptChecks(ATMPArgs& args, const Workspace& ws, PrecomputedTransactionData& txdata)\n+bool MemPoolAccept::ConsensusScriptChecks(const ATMPArgs& args, Workspace& ws, PrecomputedTransactionData& txdata)\n {\n     const CTransaction& tx = *ws.m_ptx;\n     const uint256& hash = ws.m_hash;\n-\n-    TxValidationState &state = args.m_state;\n+    TxValidationState& state = ws.m_state;\n     const CChainParams& chainparams = args.m_chainparams;\n \n     // Check again against the current block tip's script verification\n@@ -984,11 +974,11 @@ bool MemPoolAccept::ConsensusScriptChecks(ATMPArgs& args, const Workspace& ws, P\n     return true;\n }\n \n-bool MemPoolAccept::Finalize(ATMPArgs& args, Workspace& ws)\n+bool MemPoolAccept::Finalize(const ATMPArgs& args, Workspace& ws)\n {\n     const CTransaction& tx = *ws.m_ptx;\n     const uint256& hash = ws.m_hash;\n-    TxValidationState &state = args.m_state;\n+    TxValidationState& state = ws.m_state;\n     const bool bypass_limits = args.m_bypass_limits;\n \n     CTxMemPool::setEntries& allConflicting = ws.m_all_conflicting;\n@@ -1007,8 +997,7 @@ bool MemPoolAccept::Finalize(ATMPArgs& args, Workspace& ws)\n                 hash.ToString(),\n                 FormatMoney(nModifiedFees - nConflictingFees),\n                 (int)entry->GetTxSize() - (int)nConflictingSize);\n-        if (args.m_replaced_transactions)\n-            args.m_replaced_transactions->push_back(it->GetSharedTx());\n+        ws.m_replaced_transactions.push_back(it->GetSharedTx());\n     }\n     m_pool.RemoveStaged(allConflicting, false, MemPoolRemovalReason::REPLACED);\n \n@@ -1031,46 +1020,50 @@ bool MemPoolAccept::Finalize(ATMPArgs& args, Workspace& ws)\n     return true;\n }\n \n-bool MemPoolAccept::AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs& args)\n+MempoolAcceptResult MemPoolAccept::AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs& args)\n {\n     AssertLockHeld(cs_main);\n     LOCK(m_pool.cs); // mempool \"read lock\" (held through GetMainSignals().TransactionAddedToMempool())\n \n-    Workspace workspace(ptx);\n+    Workspace ws(ptx);\n \n-    if (!PreChecks(args, workspace)) return false;\n+    if (!PreChecks(args, ws)) return MempoolAcceptResult(ws.m_state);\n \n     // Only compute the precomputed transaction data if we need to verify\n     // scripts (ie, other policy checks pass). We perform the inexpensive\n     // checks first and avoid hashing and signature verification unless those\n     // checks pass, to mitigate CPU exhaustion denial-of-service attacks.\n     PrecomputedTransactionData txdata;\n \n-    if (!PolicyScriptChecks(args, workspace, txdata)) return false;\n+    if (!PolicyScriptChecks(args, ws, txdata)) return MempoolAcceptResult(ws.m_state);\n \n-    if (!ConsensusScriptChecks(args, workspace, txdata)) return false;\n+    if (!ConsensusScriptChecks(args, ws, txdata)) return MempoolAcceptResult(ws.m_state);\n \n     // Tx was accepted, but not added\n-    if (args.m_test_accept) return true;\n+    if (args.m_test_accept) {\n+        return MempoolAcceptResult(std::move(ws.m_replaced_transactions), ws.m_base_fees);\n+    }\n \n-    if (!Finalize(args, workspace)) return false;\n+    if (!Finalize(args, ws)) return MempoolAcceptResult(ws.m_state);\n \n     GetMainSignals().TransactionAddedToMempool(ptx, m_pool.GetAndIncrementSequence());\n \n-    return true;\n+    return MempoolAcceptResult(std::move(ws.m_replaced_transactions), ws.m_base_fees);\n }\n \n } // anon namespace\n \n /** (try to) add transaction to memory pool with a specified acceptance time **/\n-static bool AcceptToMemoryPoolWithTime(const CChainParams& chainparams, CTxMemPool& pool, TxValidationState &state, const CTransactionRef &tx,\n-                        int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                        bool bypass_limits, bool test_accept, CAmount* fee_out=nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+static MempoolAcceptResult AcceptToMemoryPoolWithTime(const CChainParams& chainparams, CTxMemPool& pool,\n+                                                      const CTransactionRef &tx, int64_t nAcceptTime,\n+                                                      bool bypass_limits, bool test_accept)\n+                                                      EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     std::vector<COutPoint> coins_to_uncache;\n-    MemPoolAccept::ATMPArgs args { chainparams, state, nAcceptTime, plTxnReplaced, bypass_limits, coins_to_uncache, test_accept, fee_out };\n-    bool res = MemPoolAccept(pool).AcceptSingleTransaction(tx, args);\n-    if (!res) {\n+    MemPoolAccept::ATMPArgs args { chainparams, nAcceptTime, bypass_limits, coins_to_uncache, test_accept };\n+\n+    const MempoolAcceptResult result = MemPoolAccept(pool).AcceptSingleTransaction(tx, args);\n+    if (result.m_result_type != MempoolAcceptResult::ResultType::VALID) {\n         // Remove coins that were not present in the coins cache before calling ATMPW;\n         // this is to prevent memory DoS in case we receive a large number of\n         // invalid transactions that attempt to overrun the in-memory coins cache\n@@ -1082,15 +1075,12 @@ static bool AcceptToMemoryPoolWithTime(const CChainParams& chainparams, CTxMemPo\n     // After we've (potentially) uncached entries, ensure our coins cache is still within its size limits\n     BlockValidationState state_dummy;\n     ::ChainstateActive().FlushStateToDisk(chainparams, state_dummy, FlushStateMode::PERIODIC);\n-    return res;\n+    return result;\n }\n \n-bool AcceptToMemoryPool(CTxMemPool& pool, TxValidationState &state, const CTransactionRef &tx,\n-                        std::list<CTransactionRef>* plTxnReplaced,\n-                        bool bypass_limits, bool test_accept, CAmount* fee_out)\n+MempoolAcceptResult AcceptToMemoryPool(CTxMemPool& pool, const CTransactionRef &tx, bool bypass_limits, bool test_accept)\n {\n-    const CChainParams& chainparams = Params();\n-    return AcceptToMemoryPoolWithTime(chainparams, pool, state, tx, GetTime(), plTxnReplaced, bypass_limits, test_accept, fee_out);\n+    return AcceptToMemoryPoolWithTime(Params(), pool, tx, GetTime(), bypass_limits, test_accept);\n }\n \n CTransactionRef GetTransaction(const CBlockIndex* const block_index, const CTxMemPool* const mempool, const uint256& hash, const Consensus::Params& consensusParams, uint256& hashBlock)\n@@ -5029,13 +5019,10 @@ bool LoadMempool(CTxMemPool& pool)\n             if (amountdelta) {\n                 pool.PrioritiseTransaction(tx->GetHash(), amountdelta);\n             }\n-            TxValidationState state;\n             if (nTime > nNow - nExpiryTimeout) {\n                 LOCK(cs_main);\n-                AcceptToMemoryPoolWithTime(chainparams, pool, state, tx, nTime,\n-                                           nullptr /* plTxnReplaced */, false /* bypass_limits */,\n-                                           false /* test_accept */);\n-                if (state.IsValid()) {\n+                if (AcceptToMemoryPoolWithTime(chainparams, pool, tx, nTime, false /* bypass_limits */,\n+                                               false /* test_accept */).m_result_type == MempoolAcceptResult::ResultType::VALID) {\n                     ++count;\n                 } else {\n                     // mempool may contain the transaction already, e.g. from"
      },
      {
        "sha": "238d6009b4cc26b62fecc75cdf7c4b347b3ded3e",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 42,
        "deletions": 7,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -12,6 +12,7 @@\n \n #include <amount.h>\n #include <coins.h>\n+#include <consensus/validation.h>\n #include <crypto/common.h> // for ReadLE64\n #include <fs.h>\n #include <optional.h>\n@@ -23,6 +24,7 @@\n #include <txdb.h>\n #include <versionbits.h>\n #include <serialize.h>\n+#include <util/check.h>\n #include <util/hasher.h>\n \n #include <atomic>\n@@ -46,7 +48,6 @@ class CConnman;\n class CScriptCheck;\n class CTxMemPool;\n class ChainstateManager;\n-class TxValidationState;\n struct ChainTxData;\n \n struct DisconnectedBlockTransactions;\n@@ -181,12 +182,46 @@ void UnlinkPrunedFiles(const std::set<int>& setFilesToPrune);\n /** Prune block files up to a given height */\n void PruneBlockFilesManual(int nManualPruneHeight);\n \n-/** (try to) add transaction to memory pool\n- * plTxnReplaced will be appended to with all transactions replaced from mempool\n- * @param[out] fee_out optional argument to return tx fee to the caller **/\n-bool AcceptToMemoryPool(CTxMemPool& pool, TxValidationState &state, const CTransactionRef &tx,\n-                        std::list<CTransactionRef>* plTxnReplaced,\n-                        bool bypass_limits, bool test_accept=false, CAmount* fee_out=nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+/**\n+* Validation result for a single transaction mempool acceptance.\n+*/\n+struct MempoolAcceptResult {\n+    /** Used to indicate the results of mempool validation,\n+    * including the possibility of unfinished validation.\n+    */\n+    enum class ResultType {\n+        VALID, //!> Fully validated, valid.\n+        INVALID, //!> Invalid.\n+    };\n+    ResultType m_result_type;\n+    TxValidationState m_state;\n+\n+    // The following fields are only present when m_result_type = ResultType::VALID\n+    /** Mempool transactions replaced by the tx per BIP 125 rules. */\n+    std::optional<std::list<CTransactionRef>> m_replaced_transactions;\n+    /** Raw base fees. */\n+    std::optional<CAmount> m_base_fees;\n+\n+    /** Constructor for failure case */\n+    explicit MempoolAcceptResult(TxValidationState state)\n+        : m_result_type(ResultType::INVALID),\n+        m_state(state), m_replaced_transactions(nullopt), m_base_fees(nullopt) {\n+            Assume(!state.IsValid()); // Can be invalid or error\n+        }\n+\n+    /** Constructor for success case */\n+    explicit MempoolAcceptResult(std::list<CTransactionRef>&& replaced_txns, CAmount fees)\n+        : m_result_type(ResultType::VALID), m_state(TxValidationState{}),\n+        m_replaced_transactions(std::move(replaced_txns)), m_base_fees(fees) {}\n+};\n+\n+/**\n+ * (Try to) add a transaction to the memory pool.\n+ * @param[in]  bypass_limits   When true, don't enforce mempool fee limits.\n+ * @param[in]  test_accept     When true, run validation checks but don't submit to mempool.\n+ */\n+MempoolAcceptResult AcceptToMemoryPool(CTxMemPool& pool, const CTransactionRef& tx,\n+                                       bool bypass_limits, bool test_accept=false) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n /** Get the BIP9 state for a given deployment at the current tip. */\n ThresholdState VersionBitsTipState(const Consensus::Params& params, Consensus::DeploymentPos pos);"
      },
      {
        "sha": "99803a91d2724ff2b2284335d92dd6ae781ee631",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -934,9 +934,9 @@ static std::string RecurseImportData(const CScript& script, ImportData& import_d\n     case TxoutType::NONSTANDARD:\n     case TxoutType::WITNESS_UNKNOWN:\n     case TxoutType::WITNESS_V1_TAPROOT:\n-    default:\n         return \"unrecognized script\";\n-    }\n+    } // no default case, so the compiler can warn about missing cases\n+    CHECK_NONFATAL(false);\n }\n \n static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data, std::vector<CKeyID>& ordered_pubkeys)"
      },
      {
        "sha": "55110f30d90fa81f0d71635ae6fff66c4fa02465",
        "filename": "src/wallet/scriptpubkeyman.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/wallet/scriptpubkeyman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/wallet/scriptpubkeyman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/scriptpubkeyman.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -94,8 +94,7 @@ IsMineResult IsMineInner(const LegacyScriptPubKeyMan& keystore, const CScript& s\n     TxoutType whichType = Solver(scriptPubKey, vSolutions);\n \n     CKeyID keyID;\n-    switch (whichType)\n-    {\n+    switch (whichType) {\n     case TxoutType::NONSTANDARD:\n     case TxoutType::NULL_DATA:\n     case TxoutType::WITNESS_UNKNOWN:\n@@ -194,7 +193,7 @@ IsMineResult IsMineInner(const LegacyScriptPubKeyMan& keystore, const CScript& s\n         }\n         break;\n     }\n-    }\n+    } // no default case, so the compiler can warn about missing cases\n \n     if (ret == IsMineResult::NO && keystore.HaveWatchOnly(scriptPubKey)) {\n         ret = std::max(ret, IsMineResult::WATCH_ONLY);"
      },
      {
        "sha": "b2eb8e4bcaccdd3b0539c5d841609285bbd4519f",
        "filename": "src/wallet/test/db_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/wallet/test/db_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/wallet/test/db_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/db_tests.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -30,8 +30,8 @@ BOOST_AUTO_TEST_CASE(getwalletenv_file)\n \n     std::string filename;\n     std::shared_ptr<BerkeleyEnvironment> env = GetWalletEnv(file_path, filename);\n-    BOOST_CHECK(filename == test_name);\n-    BOOST_CHECK(env->Directory() == datadir);\n+    BOOST_CHECK_EQUAL(filename, test_name);\n+    BOOST_CHECK_EQUAL(env->Directory(), datadir);\n }\n \n BOOST_AUTO_TEST_CASE(getwalletenv_directory)\n@@ -41,8 +41,8 @@ BOOST_AUTO_TEST_CASE(getwalletenv_directory)\n \n     std::string filename;\n     std::shared_ptr<BerkeleyEnvironment> env = GetWalletEnv(datadir, filename);\n-    BOOST_CHECK(filename == expected_name);\n-    BOOST_CHECK(env->Directory() == datadir);\n+    BOOST_CHECK_EQUAL(filename, expected_name);\n+    BOOST_CHECK_EQUAL(env->Directory(), datadir);\n }\n \n BOOST_AUTO_TEST_CASE(getwalletenv_g_dbenvs_multiple)"
      },
      {
        "sha": "45e1b8c4b89b7f70fe654447c12f25dc85874733",
        "filename": "src/wallet/test/init_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/wallet/test/init_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/src/wallet/test/init_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/init_tests.cpp?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -19,7 +19,7 @@ BOOST_AUTO_TEST_CASE(walletinit_verify_walletdir_default)\n     BOOST_CHECK(result == true);\n     fs::path walletdir = gArgs.GetArg(\"-walletdir\", \"\");\n     fs::path expected_path = fs::canonical(m_walletdir_path_cases[\"default\"]);\n-    BOOST_CHECK(walletdir == expected_path);\n+    BOOST_CHECK_EQUAL(walletdir, expected_path);\n }\n \n BOOST_AUTO_TEST_CASE(walletinit_verify_walletdir_custom)\n@@ -29,7 +29,7 @@ BOOST_AUTO_TEST_CASE(walletinit_verify_walletdir_custom)\n     BOOST_CHECK(result == true);\n     fs::path walletdir = gArgs.GetArg(\"-walletdir\", \"\");\n     fs::path expected_path = fs::canonical(m_walletdir_path_cases[\"custom\"]);\n-    BOOST_CHECK(walletdir == expected_path);\n+    BOOST_CHECK_EQUAL(walletdir, expected_path);\n }\n \n BOOST_AUTO_TEST_CASE(walletinit_verify_walletdir_does_not_exist)\n@@ -69,7 +69,7 @@ BOOST_AUTO_TEST_CASE(walletinit_verify_walletdir_no_trailing)\n     BOOST_CHECK(result == true);\n     fs::path walletdir = gArgs.GetArg(\"-walletdir\", \"\");\n     fs::path expected_path = fs::canonical(m_walletdir_path_cases[\"default\"]);\n-    BOOST_CHECK(walletdir == expected_path);\n+    BOOST_CHECK_EQUAL(walletdir, expected_path);\n }\n \n BOOST_AUTO_TEST_CASE(walletinit_verify_walletdir_no_trailing2)\n@@ -79,7 +79,7 @@ BOOST_AUTO_TEST_CASE(walletinit_verify_walletdir_no_trailing2)\n     BOOST_CHECK(result == true);\n     fs::path walletdir = gArgs.GetArg(\"-walletdir\", \"\");\n     fs::path expected_path = fs::canonical(m_walletdir_path_cases[\"default\"]);\n-    BOOST_CHECK(walletdir == expected_path);\n+    BOOST_CHECK_EQUAL(walletdir, expected_path);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "fab921ef193a534cd26ac41ab04380b024b24938",
        "filename": "test/functional/data/invalid_txs.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/test/functional/data/invalid_txs.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/test/functional/data/invalid_txs.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/data/invalid_txs.py?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -57,7 +57,7 @@ class BadTxTemplate:\n     __metaclass__ = abc.ABCMeta\n \n     # The expected error code given by bitcoind upon submission of the tx.\n-    reject_reason = \"\"  # type: Optional[str]\n+    reject_reason: Optional[str] = \"\"\n \n     # Only specified if it differs from mempool acceptance error.\n     block_reject_reason = \"\""
      },
      {
        "sha": "1a148f04f477292cbb76dd9778de5b2f42b212e5",
        "filename": "test/functional/feature_assumevalid.py",
        "status": "modified",
        "additions": 8,
        "deletions": 22,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/test/functional/feature_assumevalid.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/test/functional/feature_assumevalid.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_assumevalid.py?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -29,9 +29,11 @@\n       block 200. node2 will reject block 102 since it's assumed valid, but it\n       isn't buried by at least two weeks' work.\n \"\"\"\n-import time\n \n-from test_framework.blocktools import (create_block, create_coinbase)\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n from test_framework.key import ECKey\n from test_framework.messages import (\n     CBlockHeader,\n@@ -79,24 +81,6 @@ def send_blocks_until_disconnected(self, p2p_conn):\n                 assert not p2p_conn.is_connected\n                 break\n \n-    def assert_blockchain_height(self, node, height):\n-        \"\"\"Wait until the blockchain is no longer advancing and verify it's reached the expected height.\"\"\"\n-        last_height = node.getblock(node.getbestblockhash())['height']\n-        timeout = 10\n-        while True:\n-            time.sleep(0.25)\n-            current_height = node.getblock(node.getbestblockhash())['height']\n-            if current_height != last_height:\n-                last_height = current_height\n-                if timeout < 0:\n-                    assert False, \"blockchain too short after timeout: %d\" % current_height\n-                timeout - 0.25\n-                continue\n-            elif current_height > height:\n-                assert False, \"blockchain too long: %d\" % current_height\n-            elif current_height == height:\n-                break\n-\n     def run_test(self):\n         p2p0 = self.nodes[0].add_p2p_connection(BaseNode())\n \n@@ -177,7 +161,8 @@ def run_test(self):\n \n         # Send blocks to node0. Block 102 will be rejected.\n         self.send_blocks_until_disconnected(p2p0)\n-        self.assert_blockchain_height(self.nodes[0], 101)\n+        self.wait_until(lambda: self.nodes[0].getblockcount() >= 101)\n+        assert_equal(self.nodes[0].getblockcount(), 101)\n \n         # Send all blocks to node1. All blocks will be accepted.\n         for i in range(2202):\n@@ -188,7 +173,8 @@ def run_test(self):\n \n         # Send blocks to node2. Block 102 will be rejected.\n         self.send_blocks_until_disconnected(p2p2)\n-        self.assert_blockchain_height(self.nodes[2], 101)\n+        self.wait_until(lambda: self.nodes[2].getblockcount() >= 101)\n+        assert_equal(self.nodes[2].getblockcount(), 101)\n \n \n if __name__ == '__main__':"
      },
      {
        "sha": "5027a9828f1703877fe388d3305da67ce7796124",
        "filename": "test/functional/feature_taproot.py",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/test/functional/feature_taproot.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/test/functional/feature_taproot.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_taproot.py?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -517,7 +517,6 @@ def add_spender(spenders, *args, **kwargs):\n \n def random_checksig_style(pubkey):\n     \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n-    return bytes(CScript([pubkey, OP_CHECKSIG]))\n     opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n     if (opcode == OP_CHECKSIGVERIFY):\n         ret = CScript([pubkey, opcode, OP_1])"
      },
      {
        "sha": "752b925b926b9914142a3143314ce086b45ece58",
        "filename": "test/functional/mempool_persist.py",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/test/functional/mempool_persist.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/test/functional/mempool_persist.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_persist.py?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -69,13 +69,19 @@ def run_test(self):\n         assert_equal(len(self.nodes[0].getrawmempool()), 5)\n         assert_equal(len(self.nodes[1].getrawmempool()), 5)\n \n+        total_fee_old = self.nodes[0].getmempoolinfo()['total_fee']\n+\n         self.log.debug(\"Prioritize a transaction on node0\")\n         fees = self.nodes[0].getmempoolentry(txid=last_txid)['fees']\n         assert_equal(fees['base'], fees['modified'])\n         self.nodes[0].prioritisetransaction(txid=last_txid, fee_delta=1000)\n         fees = self.nodes[0].getmempoolentry(txid=last_txid)['fees']\n         assert_equal(fees['base'] + Decimal('0.00001000'), fees['modified'])\n \n+        self.log.info('Check the total base fee is unchanged after prioritisetransaction')\n+        assert_equal(total_fee_old, self.nodes[0].getmempoolinfo()['total_fee'])\n+        assert_equal(total_fee_old, sum(v['fees']['base'] for k, v in self.nodes[0].getrawmempool(verbose=True).items()))\n+\n         tx_creation_time = self.nodes[0].getmempoolentry(txid=last_txid)['time']\n         assert_greater_than_or_equal(tx_creation_time, tx_creation_time_lower)\n         assert_greater_than_or_equal(tx_creation_time_higher, tx_creation_time)"
      },
      {
        "sha": "080b2d93ad6e94e85585b04e53819150a140d68c",
        "filename": "test/functional/p2p_message_capture.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/test/functional/p2p_message_capture.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/test/functional/p2p_message_capture.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_message_capture.py?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -42,14 +42,14 @@ def mini_parser(dat_file):\n             if not tmp_header_raw:\n                 break\n             tmp_header = BytesIO(tmp_header_raw)\n-            int.from_bytes(tmp_header.read(TIME_SIZE), \"little\")      # type: int\n+            tmp_header.read(TIME_SIZE) # skip the timestamp field\n             raw_msgtype = tmp_header.read(MSGTYPE_SIZE)\n-            msgtype = raw_msgtype.split(b'\\x00', 1)[0]     # type: bytes\n+            msgtype: bytes = raw_msgtype.split(b'\\x00', 1)[0]\n             remainder =  raw_msgtype.split(b'\\x00', 1)[1]\n             assert(len(msgtype) > 0)\n             assert(msgtype in MESSAGEMAP)\n             assert(len(remainder) == 0 or not remainder.decode().isprintable())\n-            length = int.from_bytes(tmp_header.read(LENGTH_SIZE), \"little\")  # type: int\n+            length: int = int.from_bytes(tmp_header.read(LENGTH_SIZE), \"little\")\n             data = f_in.read(length)\n             assert_equal(len(data), length)\n "
      },
      {
        "sha": "6177970872a056426d7eee72c5803a0e8db222f2",
        "filename": "test/functional/rpc_uptime.py",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/test/functional/rpc_uptime.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/test/functional/rpc_uptime.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_uptime.py?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -10,6 +10,7 @@\n import time\n \n from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error\n \n \n class UptimeTest(BitcoinTestFramework):\n@@ -18,8 +19,12 @@ def set_test_params(self):\n         self.setup_clean_chain = True\n \n     def run_test(self):\n+        self._test_negative_time()\n         self._test_uptime()\n \n+    def _test_negative_time(self):\n+        assert_raises_rpc_error(-8, \"Mocktime can not be negative: -1.\", self.nodes[0].setmocktime, -1)\n+\n     def _test_uptime(self):\n         wait_time = 10\n         self.nodes[0].setmocktime(int(time.time() + wait_time))"
      },
      {
        "sha": "97b9c1d6d0472d4f2547133aa2d442a69b65d419",
        "filename": "test/functional/test_framework/bdb.py",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/test/functional/test_framework/bdb.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/test/functional/test_framework/bdb.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/bdb.py?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -51,7 +51,6 @@ def dump_leaf_page(data):\n     page_info['pgno'] = pgno\n     page_info['prev_pgno'] = prev_pgno\n     page_info['next_pgno'] = next_pgno\n-    page_info['entries'] = entries\n     page_info['hf_offset'] = hf_offset\n     page_info['level'] = level\n     page_info['pg_type'] = pg_type"
      },
      {
        "sha": "c35533698c7d521ab581a70606376ae16d33ac38",
        "filename": "test/functional/test_framework/script.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/test/functional/test_framework/script.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/test/functional/test_framework/script.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/script.py?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -29,8 +29,6 @@\n LOCKTIME_THRESHOLD = 500000000\n ANNEX_TAG = 0x50\n \n-OPCODE_NAMES = {}  # type: Dict[CScriptOp, str]\n-\n LEAF_VERSION_TAPSCRIPT = 0xc0\n \n def hash160(s):\n@@ -47,7 +45,6 @@ def bn2vch(v):\n     # Serialize to bytes\n     return encoded_v.to_bytes(n_bytes, 'little')\n \n-_opcode_instances = []  # type: List[CScriptOp]\n class CScriptOp(int):\n     \"\"\"A single script opcode\"\"\"\n     __slots__ = ()\n@@ -111,6 +108,9 @@ def __new__(cls, n):\n             _opcode_instances.append(super().__new__(cls, n))\n             return _opcode_instances[n]\n \n+OPCODE_NAMES: Dict[CScriptOp, str] = {}\n+_opcode_instances: List[CScriptOp] = []\n+\n # Populate opcode instance table\n for n in range(0xff + 1):\n     CScriptOp(n)"
      },
      {
        "sha": "611061072f265bc15303f6134b1e46e11d053fdf",
        "filename": "test/fuzz/test_runner.py",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48cb025458607ce8b6b63b773f5f32fbe293ee04/test/fuzz/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48cb025458607ce8b6b63b773f5f32fbe293ee04/test/fuzz/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/fuzz/test_runner.py?ref=48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "patch": "@@ -225,6 +225,8 @@ def merge_inputs(*, fuzz_pool, corpus, test_list, src_dir, build_dir, merge_dir)\n         args = [\n             os.path.join(build_dir, 'src', 'test', 'fuzz', 'fuzz'),\n             '-merge=1',\n+            '-shuffle=0',\n+            '-prefer_small=1',\n             '-use_value_profile=1',  # Also done by oss-fuzz https://github.com/google/oss-fuzz/issues/1406#issuecomment-387790487\n             os.path.join(corpus, t),\n             os.path.join(merge_dir, t),"
      }
    ]
  },
  {
    "sha": "53d92807a4cc1a6df808e8ea09fe9a1cab61f102",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1M2Q5MjgwN2E0Y2MxYTZkZjgwOGU4ZWEwOWZlOWExY2FiNjFmMTAy",
    "commit": {
      "author": {
        "name": "unknown",
        "email": "prayank23@outlook.com",
        "date": "2021-02-11T21:26:20Z"
      },
      "committer": {
        "name": "unknown",
        "email": "prayank23@outlook.com",
        "date": "2021-02-11T21:26:20Z"
      },
      "message": "Update",
      "tree": {
        "sha": "1cbe46781fc60e6a9a952ec7c8944af864f0b984",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1cbe46781fc60e6a9a952ec7c8944af864f0b984"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/53d92807a4cc1a6df808e8ea09fe9a1cab61f102",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/53d92807a4cc1a6df808e8ea09fe9a1cab61f102",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/53d92807a4cc1a6df808e8ea09fe9a1cab61f102",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/53d92807a4cc1a6df808e8ea09fe9a1cab61f102/comments",
    "author": {
      "login": "prayank23",
      "id": 13405205,
      "node_id": "MDQ6VXNlcjEzNDA1MjA1",
      "avatar_url": "https://avatars.githubusercontent.com/u/13405205?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/prayank23",
      "html_url": "https://github.com/prayank23",
      "followers_url": "https://api.github.com/users/prayank23/followers",
      "following_url": "https://api.github.com/users/prayank23/following{/other_user}",
      "gists_url": "https://api.github.com/users/prayank23/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/prayank23/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/prayank23/subscriptions",
      "organizations_url": "https://api.github.com/users/prayank23/orgs",
      "repos_url": "https://api.github.com/users/prayank23/repos",
      "events_url": "https://api.github.com/users/prayank23/events{/privacy}",
      "received_events_url": "https://api.github.com/users/prayank23/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "prayank23",
      "id": 13405205,
      "node_id": "MDQ6VXNlcjEzNDA1MjA1",
      "avatar_url": "https://avatars.githubusercontent.com/u/13405205?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/prayank23",
      "html_url": "https://github.com/prayank23",
      "followers_url": "https://api.github.com/users/prayank23/followers",
      "following_url": "https://api.github.com/users/prayank23/following{/other_user}",
      "gists_url": "https://api.github.com/users/prayank23/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/prayank23/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/prayank23/subscriptions",
      "organizations_url": "https://api.github.com/users/prayank23/orgs",
      "repos_url": "https://api.github.com/users/prayank23/repos",
      "events_url": "https://api.github.com/users/prayank23/events{/privacy}",
      "received_events_url": "https://api.github.com/users/prayank23/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/48cb025458607ce8b6b63b773f5f32fbe293ee04",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/48cb025458607ce8b6b63b773f5f32fbe293ee04"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 1,
      "deletions": 0
    },
    "files": [
      {
        "sha": "7d954e120af9bc745dc93bfbb9ea26228d36f299",
        "filename": "doc/tor.md",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/53d92807a4cc1a6df808e8ea09fe9a1cab61f102/doc/tor.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/53d92807a4cc1a6df808e8ea09fe9a1cab61f102/doc/tor.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/tor.md?ref=53d92807a4cc1a6df808e8ea09fe9a1cab61f102",
        "patch": "@@ -193,6 +193,7 @@ details).\n   ]\n   ```\n \n+\n ## 3. Manually create a Bitcoin Core onion service\n \n You can also manually configure your node to be reachable from the Tor network."
      }
    ]
  }
]