[
  {
    "sha": "910e7bb0fc519eacca6aff996dec31e9f0185bc8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MTBlN2JiMGZjNTE5ZWFjY2E2YWZmOTk2ZGVjMzFlOWYwMTg1YmM4",
    "commit": {
      "author": {
        "name": "Nicolas DORIER",
        "email": "nicolas.dorier@gmail.com",
        "date": "2016-01-19T13:05:44Z"
      },
      "committer": {
        "name": "NicolasDorier",
        "email": "nicolas.dorier@gmail.com",
        "date": "2016-08-05T20:48:39Z"
      },
      "message": "Cache hashes",
      "tree": {
        "sha": "eaa1d6299eebef048c766eaf700195884d0a7f0a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/eaa1d6299eebef048c766eaf700195884d0a7f0a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/910e7bb0fc519eacca6aff996dec31e9f0185bc8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/910e7bb0fc519eacca6aff996dec31e9f0185bc8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/910e7bb0fc519eacca6aff996dec31e9f0185bc8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/910e7bb0fc519eacca6aff996dec31e9f0185bc8/comments",
    "author": {
      "login": "NicolasDorier",
      "id": 3020646,
      "node_id": "MDQ6VXNlcjMwMjA2NDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3020646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/NicolasDorier",
      "html_url": "https://github.com/NicolasDorier",
      "followers_url": "https://api.github.com/users/NicolasDorier/followers",
      "following_url": "https://api.github.com/users/NicolasDorier/following{/other_user}",
      "gists_url": "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/NicolasDorier/subscriptions",
      "organizations_url": "https://api.github.com/users/NicolasDorier/orgs",
      "repos_url": "https://api.github.com/users/NicolasDorier/repos",
      "events_url": "https://api.github.com/users/NicolasDorier/events{/privacy}",
      "received_events_url": "https://api.github.com/users/NicolasDorier/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "NicolasDorier",
      "id": 3020646,
      "node_id": "MDQ6VXNlcjMwMjA2NDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3020646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/NicolasDorier",
      "html_url": "https://github.com/NicolasDorier",
      "followers_url": "https://api.github.com/users/NicolasDorier/followers",
      "following_url": "https://api.github.com/users/NicolasDorier/following{/other_user}",
      "gists_url": "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/NicolasDorier/subscriptions",
      "organizations_url": "https://api.github.com/users/NicolasDorier/orgs",
      "repos_url": "https://api.github.com/users/NicolasDorier/repos",
      "events_url": "https://api.github.com/users/NicolasDorier/events{/privacy}",
      "received_events_url": "https://api.github.com/users/NicolasDorier/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ea268747b6d417a406977e9b4931badce29b9d7a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ea268747b6d417a406977e9b4931badce29b9d7a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ea268747b6d417a406977e9b4931badce29b9d7a"
      }
    ],
    "stats": {
      "total": 268,
      "additions": 231,
      "deletions": 37
    },
    "files": [
      {
        "sha": "587a1f32325094c6e869ea477aa98638523e1c96",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/910e7bb0fc519eacca6aff996dec31e9f0185bc8/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/910e7bb0fc519eacca6aff996dec31e9f0185bc8/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=910e7bb0fc519eacca6aff996dec31e9f0185bc8",
        "patch": "@@ -119,6 +119,7 @@ BITCOIN_CORE_H = \\\n   rpc/server.h \\\n   rpc/register.h \\\n   scheduler.h \\\n+  script/cachedhashesmap.h \\\n   script/sigcache.h \\\n   script/sign.h \\\n   script/standard.h \\\n@@ -186,6 +187,7 @@ libbitcoin_server_a_SOURCES = \\\n   rpc/net.cpp \\\n   rpc/rawtransaction.cpp \\\n   rpc/server.cpp \\\n+  script/cachedhashesmap.cpp \\\n   script/sigcache.cpp \\\n   script/ismine.cpp \\\n   timedata.cpp \\"
      },
      {
        "sha": "881e693cde03c81ca55296613f0ccaf6911a2bd8",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 12,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/910e7bb0fc519eacca6aff996dec31e9f0185bc8/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/910e7bb0fc519eacca6aff996dec31e9f0185bc8/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=910e7bb0fc519eacca6aff996dec31e9f0185bc8",
        "patch": "@@ -24,6 +24,7 @@\n #include \"primitives/block.h\"\n #include \"primitives/transaction.h\"\n #include \"random.h\"\n+#include \"script/cachedhashesmap.h\"\n #include \"script/script.h\"\n #include \"script/sigcache.h\"\n #include \"script/standard.h\"\n@@ -1495,14 +1496,16 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n             scriptVerifyFlags = GetArg(\"-promiscuousmempoolflags\", scriptVerifyFlags);\n         }\n \n+        CachedHashesMap cachedHashesMap;\n+\n         // Check against previous transactions\n         // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n-        if (!CheckInputs(tx, state, view, true, scriptVerifyFlags, true)) {\n+        if (!CheckInputs(tx, state, view, true, scriptVerifyFlags, true, cachedHashesMap)) {\n             // SCRIPT_VERIFY_CLEANSTACK requires SCRIPT_VERIFY_WITNESS, so we\n             // need to turn both off, and compare against just turning off CLEANSTACK\n             // to see if the failure is specifically due to witness validation.\n-            if (CheckInputs(tx, state, view, true, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true) &&\n-                !CheckInputs(tx, state, view, true, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true)) {\n+            if (CheckInputs(tx, state, view, true, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, cachedHashesMap) &&\n+                !CheckInputs(tx, state, view, true, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, cachedHashesMap)) {\n                 // Only the witness is wrong, so the transaction itself may be fine.\n                 state.SetCorruptionPossible();\n             }\n@@ -1518,7 +1521,7 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         // There is a similar check in CreateNewBlock() to prevent creating\n         // invalid blocks, however allowing such transactions into the mempool\n         // can be exploited as a DoS attack.\n-        if (!CheckInputs(tx, state, view, true, MANDATORY_SCRIPT_VERIFY_FLAGS, true))\n+        if (!CheckInputs(tx, state, view, true, MANDATORY_SCRIPT_VERIFY_FLAGS, true, cachedHashesMap))\n         {\n             return error(\"%s: BUG! PLEASE REPORT THIS! ConnectInputs failed against MANDATORY but not STANDARD flags %s, %s\",\n                 __func__, hash.ToString(), FormatStateMessage(state));\n@@ -1915,10 +1918,24 @@ void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, int nHeight)\n bool CScriptCheck::operator()() {\n     const CScript &scriptSig = ptxTo->vin[nIn].scriptSig;\n     const CScriptWitness *witness = (nIn < ptxTo->wit.vtxinwit.size()) ? &ptxTo->wit.vtxinwit[nIn].scriptWitness : NULL;\n-    if (!VerifyScript(scriptSig, scriptPubKey, witness, nFlags, CachingTransactionSignatureChecker(ptxTo, nIn, amount, cacheStore), &error)) {\n-        return false;\n-    }\n-    return true;\n+    CachedHashes cachedHashes;\n+    int version;\n+    std::vector<unsigned char> program;\n+    // if the cache map is available, and we get a cache miss, then we'll need to update the cache later\n+    // if the scriptPubKey is not witness program, no need for cachedHashes, so do not read the map (it would acquire the lock needlessly)\n+    bool addCachedHashesToMap = cachedHashesMap != NULL &&\n+                                scriptPubKey.IsWitnessProgram(version, program);\n+    if (addCachedHashesToMap) {\n+        cachedHashesMap->TryGet(this->ptxTo->GetHash(), &cachedHashes);\n+    }\n+    CachedHashes originalCachedHashes = cachedHashes;\n+    bool result = VerifyScript(scriptSig, scriptPubKey, witness, nFlags, CachingTransactionSignatureChecker(ptxTo, nIn, amount, cacheStore, cachedHashes), &error);\n+    // do not update the cache if cachedHashes has not been updated\n+    addCachedHashesToMap &= !(originalCachedHashes == cachedHashes);\n+    if (addCachedHashesToMap) {\n+        cachedHashesMap->TrySet(this->ptxTo->GetHash(), cachedHashes);\n+    }\n+    return result;\n }\n \n int GetSpendHeight(const CCoinsViewCache& inputs)\n@@ -1974,7 +1991,7 @@ bool CheckTxInputs(const CTransaction& tx, CValidationState& state, const CCoins\n }\n }// namespace Consensus\n \n-bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheStore, std::vector<CScriptCheck> *pvChecks)\n+bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheStore, CachedHashesMap& cachedHashesMap, std::vector<CScriptCheck> *pvChecks)\n {\n     if (!tx.IsCoinBase())\n     {\n@@ -2001,7 +2018,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                 assert(coins);\n \n                 // Verify signature\n-                CScriptCheck check(*coins, tx, i, flags, cacheStore);\n+                CScriptCheck check(*coins, tx, i, flags, cacheStore, &cachedHashesMap);\n                 if (pvChecks) {\n                     pvChecks->push_back(CScriptCheck());\n                     check.swap(pvChecks->back());\n@@ -2014,7 +2031,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                         // avoid splitting the network between upgraded and\n                         // non-upgraded nodes.\n                         CScriptCheck check2(*coins, tx, i,\n-                                flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheStore);\n+                                flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheStore, &cachedHashesMap);\n                         if (check2())\n                             return state.Invalid(false, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n                     }\n@@ -2412,6 +2429,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n     std::vector<std::pair<uint256, CDiskTxPos> > vPos;\n     vPos.reserve(block.vtx.size());\n     blockundo.vtxundo.reserve(block.vtx.size() - 1);\n+    CachedHashesMap cachedHashesMap;\n     for (unsigned int i = 0; i < block.vtx.size(); i++)\n     {\n         const CTransaction &tx = block.vtx[i];\n@@ -2464,7 +2482,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n \n             std::vector<CScriptCheck> vChecks;\n             bool fCacheResults = fJustCheck; /* Don't cache results if we're actually connecting blocks (still consult the cache, though) */\n-            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, nScriptCheckThreads ? &vChecks : NULL))\n+            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, cachedHashesMap, nScriptCheckThreads ? &vChecks : NULL))\n                 return error(\"ConnectBlock(): CheckInputs on %s failed with %s\",\n                     tx.GetHash().ToString(), FormatStateMessage(state));\n             control.Add(vChecks);"
      },
      {
        "sha": "5729c144c54f50893471067b1968616e75999c72",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 7,
        "deletions": 3,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/910e7bb0fc519eacca6aff996dec31e9f0185bc8/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/910e7bb0fc519eacca6aff996dec31e9f0185bc8/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=910e7bb0fc519eacca6aff996dec31e9f0185bc8",
        "patch": "@@ -38,6 +38,8 @@ class CScriptCheck;\n class CTxMemPool;\n class CValidationInterface;\n class CValidationState;\n+class CachedHashes;\n+class CachedHashesMap;\n \n struct CNodeStateStats;\n struct LockPoints;\n@@ -347,7 +349,7 @@ int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& i\n  * instead of being performed inline.\n  */\n bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &view, bool fScriptChecks,\n-                 unsigned int flags, bool cacheStore, std::vector<CScriptCheck> *pvChecks = NULL);\n+                 unsigned int flags, bool cacheStore, CachedHashesMap& cachedHashesMap, std::vector<CScriptCheck> *pvChecks = NULL);\n \n /** Apply the effects of this transaction on the UTXO set represented by view */\n void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, int nHeight);\n@@ -421,12 +423,13 @@ class CScriptCheck\n     unsigned int nFlags;\n     bool cacheStore;\n     ScriptError error;\n+    CachedHashesMap *cachedHashesMap;\n \n public:\n     CScriptCheck(): amount(0), ptxTo(0), nIn(0), nFlags(0), cacheStore(false), error(SCRIPT_ERR_UNKNOWN_ERROR) {}\n-    CScriptCheck(const CCoins& txFromIn, const CTransaction& txToIn, unsigned int nInIn, unsigned int nFlagsIn, bool cacheIn) :\n+    CScriptCheck(const CCoins& txFromIn, const CTransaction& txToIn, unsigned int nInIn, unsigned int nFlagsIn, bool cacheIn, CachedHashesMap* cachedHashesMapIn) :\n         scriptPubKey(txFromIn.vout[txToIn.vin[nInIn].prevout.n].scriptPubKey), amount(txFromIn.vout[txToIn.vin[nInIn].prevout.n].nValue),\n-        ptxTo(&txToIn), nIn(nInIn), nFlags(nFlagsIn), cacheStore(cacheIn), error(SCRIPT_ERR_UNKNOWN_ERROR) { }\n+        ptxTo(&txToIn), nIn(nInIn), nFlags(nFlagsIn), cacheStore(cacheIn), error(SCRIPT_ERR_UNKNOWN_ERROR), cachedHashesMap(cachedHashesMapIn) { }\n \n     bool operator()();\n \n@@ -438,6 +441,7 @@ class CScriptCheck\n         std::swap(nFlags, check.nFlags);\n         std::swap(cacheStore, check.cacheStore);\n         std::swap(error, check.error);\n+        std::swap(cachedHashesMap, check.cachedHashesMap);\n     }\n \n     ScriptError GetScriptError() const { return error; }"
      },
      {
        "sha": "37de2170eefe34cec6cb9fda7a2d37e79df28787",
        "filename": "src/script/bitcoinconsensus.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/910e7bb0fc519eacca6aff996dec31e9f0185bc8/src/script/bitcoinconsensus.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/910e7bb0fc519eacca6aff996dec31e9f0185bc8/src/script/bitcoinconsensus.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/bitcoinconsensus.cpp?ref=910e7bb0fc519eacca6aff996dec31e9f0185bc8",
        "patch": "@@ -84,8 +84,8 @@ static int verify_script(const unsigned char *scriptPubKey, unsigned int scriptP\n \n         // Regardless of the verification result, the tx did not error.\n         set_error(err, bitcoinconsensus_ERR_OK);\n-\n-        return VerifyScript(tx.vin[nIn].scriptSig, CScript(scriptPubKey, scriptPubKey + scriptPubKeyLen), nIn < tx.wit.vtxinwit.size() ? &tx.wit.vtxinwit[nIn].scriptWitness : NULL, flags, TransactionSignatureChecker(&tx, nIn, amount), NULL);\n+        CachedHashes cachedHashes;\n+        return VerifyScript(tx.vin[nIn].scriptSig, CScript(scriptPubKey, scriptPubKey + scriptPubKeyLen), nIn < tx.wit.vtxinwit.size() ? &tx.wit.vtxinwit[nIn].scriptWitness : NULL, flags, TransactionSignatureChecker(&tx, nIn, amount, cachedHashes), NULL);\n     } catch (const std::exception&) {\n         return set_error(err, bitcoinconsensus_ERR_TX_DESERIALIZE); // Error deserializing\n     }"
      },
      {
        "sha": "fca444fbd678be984b2263e534d5ac0a5643750e",
        "filename": "src/script/cachedhashesmap.cpp",
        "status": "added",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/910e7bb0fc519eacca6aff996dec31e9f0185bc8/src/script/cachedhashesmap.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/910e7bb0fc519eacca6aff996dec31e9f0185bc8/src/script/cachedhashesmap.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/cachedhashesmap.cpp?ref=910e7bb0fc519eacca6aff996dec31e9f0185bc8",
        "patch": "@@ -0,0 +1,21 @@\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"cachedhashesmap.h\"\n+\n+bool CachedHashesMap::TryGet(const uint256& txId, CachedHashes* hashes)\n+{\n+    LOCK(cs);\n+    auto iter = map.find(txId);\n+    if (iter == map.end())\n+        return false;\n+    *hashes = iter->second;\n+    return true;\n+}\n+\n+void CachedHashesMap::TrySet(const uint256& txId, const CachedHashes& hashes)\n+{\n+    LOCK(cs);\n+    map[txId].Merge(hashes);\n+}"
      },
      {
        "sha": "5893bfdf6e1c57c76c6229f9090e628da386c4a7",
        "filename": "src/script/cachedhashesmap.h",
        "status": "added",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/910e7bb0fc519eacca6aff996dec31e9f0185bc8/src/script/cachedhashesmap.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/910e7bb0fc519eacca6aff996dec31e9f0185bc8/src/script/cachedhashesmap.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/cachedhashesmap.h?ref=910e7bb0fc519eacca6aff996dec31e9f0185bc8",
        "patch": "@@ -0,0 +1,27 @@\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef SRC_CACHEDHASHESMAP_H\n+#define SRC_CACHEDHASHESMAP_H\n+\n+\n+#include \"script/interpreter.h\"\n+#include \"sync.h\"\n+\n+class CachedHashes;\n+/**\n+ * A thread safe map which caches mid state witness signature hash calculation by transaction id\n+ */\n+class CachedHashesMap\n+{\n+private:\n+    std::map<uint256, CachedHashes> map;\n+    CCriticalSection cs;\n+public:\n+    bool TryGet(const uint256& txId, CachedHashes* hashes);\n+    void TrySet(const uint256& txId, const CachedHashes& hashes);\n+};\n+\n+\n+#endif //SRC_CACHEDHASHESMAP_H"
      },
      {
        "sha": "7cde8ea122383e132f8c2ca24f7bc9161a48a8ae",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 14,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/910e7bb0fc519eacca6aff996dec31e9f0185bc8/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/910e7bb0fc519eacca6aff996dec31e9f0185bc8/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=910e7bb0fc519eacca6aff996dec31e9f0185bc8",
        "patch": "@@ -1110,35 +1110,50 @@ class CTransactionSignatureSerializer {\n \n } // anon namespace\n \n-uint256 SignatureHash(const CScript& scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion)\n+uint256 SignatureHash(const CScript& scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion, CachedHashes* cache)\n {\n+    CachedHashes empty;\n+    if (cache == NULL) {\n+        cache = &empty;\n+    }\n+\n     if (sigversion == SIGVERSION_WITNESS_V0) {\n         uint256 hashPrevouts;\n         uint256 hashSequence;\n         uint256 hashOutputs;\n \n         if (!(nHashType & SIGHASH_ANYONECANPAY)) {\n-            CHashWriter ss(SER_GETHASH, 0);\n-            for (unsigned int n = 0; n < txTo.vin.size(); n++) {\n-                ss << txTo.vin[n].prevout;\n+            if (cache->hashPrevouts == uint256()) {\n+                CHashWriter ss(SER_GETHASH, 0);\n+                for (unsigned int n = 0; n < txTo.vin.size(); n++) {\n+                    ss << txTo.vin[n].prevout;\n+                }\n+                cache->hashPrevouts = ss.GetHash();\n             }\n-            hashPrevouts = ss.GetHash(); // TODO: cache this value for all signatures in a transaction\n+            hashPrevouts = cache->hashPrevouts;\n         }\n \n         if (!(nHashType & SIGHASH_ANYONECANPAY) && (nHashType & 0x1f) != SIGHASH_SINGLE && (nHashType & 0x1f) != SIGHASH_NONE) {\n-            CHashWriter ss(SER_GETHASH, 0);\n-            for (unsigned int n = 0; n < txTo.vin.size(); n++) {\n-                ss << txTo.vin[n].nSequence;\n+            if (cache->hashSequence == uint256()) {\n+                CHashWriter ss(SER_GETHASH, 0);\n+                for (unsigned int n = 0; n < txTo.vin.size(); n++) {\n+                    ss << txTo.vin[n].nSequence;\n+                }\n+                cache->hashSequence = ss.GetHash();\n             }\n-            hashSequence = ss.GetHash(); // TODO: cache this value for all signatures in a transaction\n+            hashSequence = cache->hashSequence;\n         }\n \n+\n         if ((nHashType & 0x1f) != SIGHASH_SINGLE && (nHashType & 0x1f) != SIGHASH_NONE) {\n-            CHashWriter ss(SER_GETHASH, 0);\n-            for (unsigned int n = 0; n < txTo.vout.size(); n++) {\n-                ss << txTo.vout[n];\n+            if (cache->hashOutputs == uint256()) {\n+                CHashWriter ss(SER_GETHASH, 0);\n+                for (unsigned int n = 0; n < txTo.vout.size(); n++) {\n+                    ss << txTo.vout[n];\n+                }\n+                cache->hashOutputs = ss.GetHash();\n             }\n-            hashOutputs = ss.GetHash(); // TODO: cache this value for all signatures in a transaction\n+            hashOutputs = cache->hashOutputs;\n         } else if ((nHashType & 0x1f) == SIGHASH_SINGLE && nIn < txTo.vout.size()) {\n             CHashWriter ss(SER_GETHASH, 0);\n             ss << txTo.vout[nIn];\n@@ -1209,7 +1224,7 @@ bool TransactionSignatureChecker::CheckSig(const vector<unsigned char>& vchSigIn\n     int nHashType = vchSig.back();\n     vchSig.pop_back();\n \n-    uint256 sighash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion);\n+    uint256 sighash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion, this->cachedHashes);\n \n     if (!VerifySignature(vchSig, pubkey, sighash))\n         return false;"
      },
      {
        "sha": "adc37eebe64603001c8421000838484d27b37a04",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 23,
        "deletions": 2,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/910e7bb0fc519eacca6aff996dec31e9f0185bc8/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/910e7bb0fc519eacca6aff996dec31e9f0185bc8/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=910e7bb0fc519eacca6aff996dec31e9f0185bc8",
        "patch": "@@ -98,13 +98,32 @@ enum\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n+struct CachedHashes\n+{\n+    uint256 hashPrevouts, hashSequence, hashOutputs;\n+\n+    void Merge(const CachedHashes& hashes)\n+    {\n+        if (hashPrevouts.IsNull()) hashPrevouts = hashes.hashPrevouts;\n+        if (hashSequence.IsNull()) hashSequence = hashes.hashSequence;\n+        if (hashOutputs.IsNull()) hashOutputs = hashes.hashOutputs;\n+    }\n+\n+    bool operator==(const CachedHashes& rhs) const\n+    {\n+        return hashPrevouts == rhs.hashPrevouts &&\n+               hashSequence == rhs.hashSequence &&\n+               hashOutputs == rhs.hashOutputs;\n+    }\n+};\n+\n enum SigVersion\n {\n     SIGVERSION_BASE = 0,\n     SIGVERSION_WITNESS_V0 = 1,\n };\n \n-uint256 SignatureHash(const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion);\n+uint256 SignatureHash(const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion, CachedHashes* cache = NULL);\n \n class BaseSignatureChecker\n {\n@@ -133,12 +152,14 @@ class TransactionSignatureChecker : public BaseSignatureChecker\n     const CTransaction* txTo;\n     unsigned int nIn;\n     const CAmount amount;\n+    CachedHashes* cachedHashes;\n \n protected:\n     virtual bool VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash) const;\n \n public:\n-    TransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn) : txTo(txToIn), nIn(nInIn), amount(amountIn) {}\n+    TransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), cachedHashes(NULL) {}\n+    TransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, CachedHashes& cachedHashesIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), cachedHashes(&cachedHashesIn) {}\n     bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const;\n     bool CheckLockTime(const CScriptNum& nLockTime) const;\n     bool CheckSequence(const CScriptNum& nSequence) const;"
      },
      {
        "sha": "551f8b2253e760aee66b50535bd3ef0336784ae3",
        "filename": "src/script/sigcache.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/910e7bb0fc519eacca6aff996dec31e9f0185bc8/src/script/sigcache.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/910e7bb0fc519eacca6aff996dec31e9f0185bc8/src/script/sigcache.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sigcache.h?ref=910e7bb0fc519eacca6aff996dec31e9f0185bc8",
        "patch": "@@ -22,7 +22,7 @@ class CachingTransactionSignatureChecker : public TransactionSignatureChecker\n     bool store;\n \n public:\n-    CachingTransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amount, bool storeIn) : TransactionSignatureChecker(txToIn, nInIn, amount), store(storeIn) {}\n+    CachingTransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amount, bool storeIn, CachedHashes& cachedHashesIn) : TransactionSignatureChecker(txToIn, nInIn, amount, cachedHashesIn), store(storeIn) {}\n \n     bool VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash) const;\n };"
      },
      {
        "sha": "01c2fd425c0e12f5255a10331513b3662d577fff",
        "filename": "src/test/script_P2SH_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/910e7bb0fc519eacca6aff996dec31e9f0185bc8/src/test/script_P2SH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/910e7bb0fc519eacca6aff996dec31e9f0185bc8/src/test/script_P2SH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2SH_tests.cpp?ref=910e7bb0fc519eacca6aff996dec31e9f0185bc8",
        "patch": "@@ -7,6 +7,7 @@\n #include \"keystore.h\"\n #include \"main.h\"\n #include \"policy/policy.h\"\n+#include \"script/cachedhashesmap.h\"\n #include \"script/script.h\"\n #include \"script/script_error.h\"\n #include \"script/sign.h\"\n@@ -105,14 +106,15 @@ BOOST_AUTO_TEST_CASE(sign)\n     {\n         BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0, SIGHASH_ALL), strprintf(\"SignSignature %d\", i));\n     }\n+    CachedHashesMap cachedHashesMap;\n     // All of the above should be OK, and the txTos have valid signatures\n     // Check to make sure signature verification fails if we use the wrong ScriptSig:\n     for (int i = 0; i < 8; i++)\n         for (int j = 0; j < 8; j++)\n         {\n             CScript sigSave = txTo[i].vin[0].scriptSig;\n             txTo[i].vin[0].scriptSig = txTo[j].vin[0].scriptSig;\n-            bool sigOK = CScriptCheck(CCoins(txFrom, 0), txTo[i], 0, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC, false)();\n+            bool sigOK = CScriptCheck(CCoins(txFrom, 0), txTo[i], 0, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC, false, &cachedHashesMap)();\n             if (i == j)\n                 BOOST_CHECK_MESSAGE(sigOK, strprintf(\"VerifySignature %d %d\", i, j));\n             else"
      },
      {
        "sha": "0e480a43ab67b1d635b2af585531518b0d391b69",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 86,
        "deletions": 2,
        "changes": 88,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/910e7bb0fc519eacca6aff996dec31e9f0185bc8/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/910e7bb0fc519eacca6aff996dec31e9f0185bc8/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=910e7bb0fc519eacca6aff996dec31e9f0185bc8",
        "patch": "@@ -7,12 +7,14 @@\n #include \"test/test_bitcoin.h\"\n \n #include \"clientversion.h\"\n+#include \"checkqueue.h\"\n #include \"consensus/validation.h\"\n #include \"core_io.h\"\n #include \"key.h\"\n #include \"keystore.h\"\n #include \"main.h\" // For CheckTransaction\n #include \"policy/policy.h\"\n+#include \"script/cachedhashesmap.h\"\n #include \"script/script.h\"\n #include \"script/sign.h\"\n #include \"script/script_error.h\"\n@@ -153,6 +155,7 @@ BOOST_AUTO_TEST_CASE(tx_valid)\n             BOOST_CHECK_MESSAGE(CheckTransaction(tx, state), strTest);\n             BOOST_CHECK(state.IsValid());\n \n+            CachedHashes cachedHashes;\n             for (unsigned int i = 0; i < tx.vin.size(); i++)\n             {\n                 if (!mapprevOutScriptPubKeys.count(tx.vin[i].prevout))\n@@ -168,7 +171,7 @@ BOOST_AUTO_TEST_CASE(tx_valid)\n                 unsigned int verify_flags = ParseScriptFlags(test[2].get_str());\n                 const CScriptWitness *witness = (i < tx.wit.vtxinwit.size()) ? &tx.wit.vtxinwit[i].scriptWitness : NULL;\n                 BOOST_CHECK_MESSAGE(VerifyScript(tx.vin[i].scriptSig, mapprevOutScriptPubKeys[tx.vin[i].prevout],\n-                                                 witness, verify_flags, TransactionSignatureChecker(&tx, i, amount), &err),\n+                                                 witness, verify_flags, TransactionSignatureChecker(&tx, i, amount, cachedHashes), &err),\n                                     strTest);\n                 BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n             }\n@@ -237,6 +240,7 @@ BOOST_AUTO_TEST_CASE(tx_invalid)\n             CValidationState state;\n             fValid = CheckTransaction(tx, state) && state.IsValid();\n \n+            CachedHashes cachedHashes;\n             for (unsigned int i = 0; i < tx.vin.size() && fValid; i++)\n             {\n                 if (!mapprevOutScriptPubKeys.count(tx.vin[i].prevout))\n@@ -252,7 +256,7 @@ BOOST_AUTO_TEST_CASE(tx_invalid)\n                 }\n                 const CScriptWitness *witness = (i < tx.wit.vtxinwit.size()) ? &tx.wit.vtxinwit[i].scriptWitness : NULL;\n                 fValid = VerifyScript(tx.vin[i].scriptSig, mapprevOutScriptPubKeys[tx.vin[i].prevout],\n-                                      witness, verify_flags, TransactionSignatureChecker(&tx, i, amount), &err);\n+                                      witness, verify_flags, TransactionSignatureChecker(&tx, i, amount, cachedHashes), &err);\n             }\n             BOOST_CHECK_MESSAGE(!fValid, strTest);\n             BOOST_CHECK_MESSAGE(err != SCRIPT_ERR_OK, ScriptErrorString(err));\n@@ -419,6 +423,86 @@ void ReplaceRedeemScript(CScript& script, const CScript& redeemScript)\n     script = PushAll(stack);\n }\n \n+BOOST_AUTO_TEST_CASE(test_big_witness_transaction) {\n+    CMutableTransaction mtx;\n+    mtx.nVersion = 1;\n+\n+    CKey key;\n+    key.MakeNewKey(false);\n+    CBasicKeyStore keystore;\n+    keystore.AddKeyPubKey(key, key.GetPubKey());\n+    CKeyID hash = key.GetPubKey().GetID();\n+    CScript scriptPubKey = CScript() << OP_0 << std::vector<unsigned char>(hash.begin(), hash.end());\n+\n+    vector<int> sigHashes;\n+    sigHashes.push_back(SIGHASH_NONE | SIGHASH_ANYONECANPAY);\n+    sigHashes.push_back(SIGHASH_SINGLE | SIGHASH_ANYONECANPAY);\n+    sigHashes.push_back(SIGHASH_ALL | SIGHASH_ANYONECANPAY);\n+    sigHashes.push_back(SIGHASH_NONE);\n+    sigHashes.push_back(SIGHASH_SINGLE);\n+    sigHashes.push_back(SIGHASH_ALL);\n+\n+    // create a big transaction of 4500 inputs signed by the same key\n+    for(uint32_t ij = 0; ij < 4500; ij++) {\n+        uint32_t i = mtx.vin.size();\n+        uint256 prevId;\n+        prevId.SetHex(\"0000000000000000000000000000000000000000000000000000000000000100\");\n+        COutPoint outpoint(prevId, i);\n+\n+        mtx.vin.resize(mtx.vin.size() + 1);\n+        mtx.vin[i].prevout = outpoint;\n+        mtx.vin[i].scriptSig = CScript();\n+\n+        mtx.vout.resize(mtx.vout.size() + 1);\n+        mtx.vout[i].nValue = 1000;\n+        mtx.vout[i].scriptPubKey = CScript() << OP_1;\n+    }\n+\n+    // sign all inputs\n+    for(uint32_t i = 0; i < mtx.vin.size(); i++) {\n+        bool hashSigned = SignSignature(keystore, scriptPubKey, mtx, i, 1000, sigHashes.at(i % sigHashes.size()));\n+        assert(hashSigned);\n+    }\n+\n+    CTransaction tx;\n+    CDataStream ssout(SER_NETWORK, PROTOCOL_VERSION);\n+    WithOrVersion(&ssout, 0) << mtx;\n+    WithOrVersion(&ssout, 0) >> tx;\n+\n+    // check all inputs concurrently, with the cache\n+    CachedHashesMap cachedHashesMap;\n+    boost::thread_group threadGroup;\n+    CCheckQueue<CScriptCheck> scriptcheckqueue(128);\n+    CCheckQueueControl<CScriptCheck> control(&scriptcheckqueue);\n+\n+    for (int i=0; i<20; i++)\n+        threadGroup.create_thread(boost::bind(&CCheckQueue<CScriptCheck>::Thread, boost::ref(scriptcheckqueue)));\n+\n+    CCoins coins;\n+    coins.nVersion = 1;\n+    coins.fCoinBase = false;\n+    for(uint32_t i = 0; i < mtx.vin.size(); i++) {\n+        CTxOut txout;\n+        txout.nValue = 1000;\n+        txout.scriptPubKey = scriptPubKey;\n+        coins.vout.push_back(txout);\n+    }\n+\n+    for(uint32_t i = 0; i < mtx.vin.size(); i++) {\n+        std::vector<CScriptCheck> vChecks;\n+        CScriptCheck check(coins, tx, i, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false, &cachedHashesMap);\n+        vChecks.push_back(CScriptCheck());\n+        check.swap(vChecks.back());\n+        control.Add(vChecks);\n+    }\n+\n+    bool controlCheck = control.Wait();\n+    assert(controlCheck);\n+\n+    threadGroup.interrupt_all();\n+    threadGroup.join_all();\n+}\n+\n BOOST_AUTO_TEST_CASE(test_witness)\n {\n     CBasicKeyStore keystore, keystore2;"
      }
    ]
  }
]