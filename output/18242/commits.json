[
  {
    "sha": "1cfd3fef3e88f70a30860b6aee57d918ff0dd07f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxY2ZkM2ZlZjNlODhmNzBhMzA4NjBiNmFlZTU3ZDkxOGZmMGRkMDdm",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2021-01-06T08:48:08Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2021-01-19T10:24:54Z"
      },
      "message": "Alter the ChaCha20Poly1305@Bitcoin AEAD to the new specification",
      "tree": {
        "sha": "484a47daf6cad0af3c5765025235e77af7484d78",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/484a47daf6cad0af3c5765025235e77af7484d78"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1cfd3fef3e88f70a30860b6aee57d918ff0dd07f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1cfd3fef3e88f70a30860b6aee57d918ff0dd07f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1cfd3fef3e88f70a30860b6aee57d918ff0dd07f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1cfd3fef3e88f70a30860b6aee57d918ff0dd07f/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "43f3ada27b835e6b198f9a669e4955d06f5c4d08",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/43f3ada27b835e6b198f9a669e4955d06f5c4d08",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/43f3ada27b835e6b198f9a669e4955d06f5c4d08"
      }
    ],
    "stats": {
      "total": 427,
      "additions": 182,
      "deletions": 245
    },
    "files": [
      {
        "sha": "a38125b60598e146fa12a888eea4d0bbf6116606",
        "filename": "src/bench/chacha_poly_aead.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 21,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1cfd3fef3e88f70a30860b6aee57d918ff0dd07f/src/bench/chacha_poly_aead.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1cfd3fef3e88f70a30860b6aee57d918ff0dd07f/src/bench/chacha_poly_aead.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/chacha_poly_aead.cpp?ref=1cfd3fef3e88f70a30860b6aee57d918ff0dd07f",
        "patch": "@@ -25,37 +25,19 @@ static void CHACHA20_POLY1305_AEAD(benchmark::Bench& bench, size_t buffersize, b\n {\n     std::vector<unsigned char> in(buffersize + CHACHA20_POLY1305_AEAD_AAD_LEN + POLY1305_TAGLEN, 0);\n     std::vector<unsigned char> out(buffersize + CHACHA20_POLY1305_AEAD_AAD_LEN + POLY1305_TAGLEN, 0);\n-    uint64_t seqnr_payload = 0;\n-    uint64_t seqnr_aad = 0;\n-    int aad_pos = 0;\n     uint32_t len = 0;\n     bench.batch(buffersize).unit(\"byte\").run([&] {\n         // encrypt or decrypt the buffer with a static key\n-        const bool crypt_ok_1 = aead.Crypt(seqnr_payload, seqnr_aad, aad_pos, out.data(), out.size(), in.data(), buffersize, true);\n+        const bool crypt_ok_1 = aead.Crypt(out.data(), out.size(), in.data(), buffersize, true);\n         assert(crypt_ok_1);\n \n         if (include_decryption) {\n             // if we decrypt, include the GetLength\n-            const bool get_length_ok = aead.GetLength(&len, seqnr_aad, aad_pos, in.data());\n+            const bool get_length_ok = aead.DecryptLength(&len, in.data());\n             assert(get_length_ok);\n-            const bool crypt_ok_2 = aead.Crypt(seqnr_payload, seqnr_aad, aad_pos, out.data(), out.size(), in.data(), buffersize, true);\n+            const bool crypt_ok_2 = aead.Crypt(out.data(), out.size(), in.data(), buffersize, true);\n             assert(crypt_ok_2);\n         }\n-\n-        // increase main sequence number\n-        seqnr_payload++;\n-        // increase aad position (position in AAD keystream)\n-        aad_pos += CHACHA20_POLY1305_AEAD_AAD_LEN;\n-        if (aad_pos + CHACHA20_POLY1305_AEAD_AAD_LEN > CHACHA20_ROUND_OUTPUT) {\n-            aad_pos = 0;\n-            seqnr_aad++;\n-        }\n-        if (seqnr_payload + 1 == std::numeric_limits<uint64_t>::max()) {\n-            // reuse of nonce+key is okay while benchmarking.\n-            seqnr_payload = 0;\n-            seqnr_aad = 0;\n-            aad_pos = 0;\n-        }\n     });\n }\n "
      },
      {
        "sha": "bf261df558e0ca78735d3395f64e2b9246ed03c7",
        "filename": "src/crypto/chacha_poly_aead.cpp",
        "status": "modified",
        "additions": 70,
        "deletions": 49,
        "changes": 119,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1cfd3fef3e88f70a30860b6aee57d918ff0dd07f/src/crypto/chacha_poly_aead.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1cfd3fef3e88f70a30860b6aee57d918ff0dd07f/src/crypto/chacha_poly_aead.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/chacha_poly_aead.cpp?ref=1cfd3fef3e88f70a30860b6aee57d918ff0dd07f",
        "patch": "@@ -4,6 +4,7 @@\n \n #include <crypto/chacha_poly_aead.h>\n \n+#include <crypto/common.h>\n #include <crypto/poly1305.h>\n #include <support/cleanse.h>\n \n@@ -27,19 +28,52 @@ int timingsafe_bcmp(const unsigned char* b1, const unsigned char* b2, size_t n)\n \n #endif // TIMINGSAFE_BCMP\n \n+void ChaCha20ReKey4096::SetKey(const unsigned char* key, size_t keylen) {\n+    assert(keylen == 32);\n+    m_ctx.SetKey(key, keylen);\n+\n+    // set initial sequence number\n+    m_seqnr = 0;\n+    m_ctx.SetIV(m_seqnr);\n+\n+    // precompute first chunk of keystream\n+    m_ctx.Keystream(m_keystream, KEYSTREAM_SIZE);\n+    m_keystream_pos = 0;\n+}\n+\n+void ChaCha20ReKey4096::Crypt(const unsigned char* input, unsigned char* output, size_t bytes) {\n+    size_t message_pos = 0;\n+\n+    // TODO: speedup with a block approach (rather then looping over every byte)\n+    while (bytes > message_pos) {\n+        output[message_pos] = input[message_pos] ^ ReadLE32(&m_keystream[m_keystream_pos]);\n+        m_keystream_pos++;\n+        message_pos++;\n+        if (m_keystream_pos == KEYSTREAM_SIZE-CHACHA20_POLY1305_AEAD_KEY_LEN) {\n+            // we reached the end of the keystream\n+            // rekey with the remaining and last 32 bytes and precompute the next 4096 bytes\n+            m_ctx.SetKey(&m_keystream[m_keystream_pos], CHACHA20_POLY1305_AEAD_KEY_LEN);\n+            m_ctx.SetIV(++m_seqnr);\n+            m_ctx.Keystream(m_keystream, KEYSTREAM_SIZE);\n+            // reset keystream position\n+            m_keystream_pos = 0;\n+        }\n+    }\n+}\n+\n+ChaCha20ReKey4096::~ChaCha20ReKey4096() {\n+    memory_cleanse(m_keystream, KEYSTREAM_SIZE);\n+}\n+\n ChaCha20Poly1305AEAD::ChaCha20Poly1305AEAD(const unsigned char* K_1, size_t K_1_len, const unsigned char* K_2, size_t K_2_len)\n {\n     assert(K_1_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n     assert(K_2_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n     m_chacha_main.SetKey(K_1, CHACHA20_POLY1305_AEAD_KEY_LEN);\n     m_chacha_header.SetKey(K_2, CHACHA20_POLY1305_AEAD_KEY_LEN);\n-\n-    // set the cached sequence number to uint64 max which hints for an unset cache.\n-    // we can't hit uint64 max since the rekey rule (which resets the sequence number) is 1GB\n-    m_cached_aad_seqnr = std::numeric_limits<uint64_t>::max();\n }\n \n-bool ChaCha20Poly1305AEAD::Crypt(uint64_t seqnr_payload, uint64_t seqnr_aad, int aad_pos, unsigned char* dest, size_t dest_len /* length of the output buffer for sanity checks */, const unsigned char* src, size_t src_len, bool is_encrypt)\n+bool ChaCha20Poly1305AEAD::Crypt(unsigned char* dest, size_t dest_len /* length of the output buffer for sanity checks */, const unsigned char* src, size_t src_len, bool is_encrypt)\n {\n     // check buffer boundaries\n     if (\n@@ -52,18 +86,24 @@ bool ChaCha20Poly1305AEAD::Crypt(uint64_t seqnr_payload, uint64_t seqnr_aad, int\n \n     unsigned char expected_tag[POLY1305_TAGLEN], poly_key[POLY1305_KEYLEN];\n     memset(poly_key, 0, sizeof(poly_key));\n-    m_chacha_main.SetIV(seqnr_payload);\n \n-    // block counter 0 for the poly1305 key\n-    // use lower 32bytes for the poly1305 key\n-    // (throws away 32 unused bytes (upper 32) from this ChaCha20 round)\n-    m_chacha_main.Seek(0);\n-    m_chacha_main.Crypt(poly_key, poly_key, sizeof(poly_key));\n+    // 1. AAD (the encrypted packet length), use the header-keystream\n+    if (is_encrypt) {\n+        m_chacha_header.Crypt(src, dest, 3);\n+    } else {\n+        // we must use ChaCha20Poly1305AEAD::DecryptLength before calling ChaCha20Poly1305AEAD::Crypt\n+        // thus the length has already been encrypted, avoid doing it again and messing up the keystream position\n+        // keep the encrypted version of the AAD to not break verifying the MAC\n+        memcpy(dest, src, 3);\n+    }\n \n-    // if decrypting, verify the tag prior to decryption\n+    // 2. derive the poly1305 key from the header-keystream\n+    m_chacha_header.Crypt(poly_key, poly_key, sizeof(poly_key));\n+\n+    // 3. if decrypting, verify the MAC prior to decryption\n     if (!is_encrypt) {\n-        const unsigned char* tag = src + src_len - POLY1305_TAGLEN;\n-        poly1305_auth(expected_tag, src, src_len - POLY1305_TAGLEN, poly_key);\n+        const unsigned char* tag = src + src_len - POLY1305_TAGLEN; //the MAC appended in the package\n+        poly1305_auth(expected_tag, src, src_len - POLY1305_TAGLEN, poly_key); //the calculated MAC\n \n         // constant time compare the calculated MAC with the provided MAC\n         if (timingsafe_bcmp(expected_tag, tag, POLY1305_TAGLEN) != 0) {\n@@ -72,54 +112,35 @@ bool ChaCha20Poly1305AEAD::Crypt(uint64_t seqnr_payload, uint64_t seqnr_aad, int\n             return false;\n         }\n         memory_cleanse(expected_tag, sizeof(expected_tag));\n-        // MAC has been successfully verified, make sure we don't covert it in decryption\n+        // MAC has been successfully verified, make sure we don't decrypt it\n         src_len -= POLY1305_TAGLEN;\n     }\n \n-    // calculate and cache the next 64byte keystream block if requested sequence number is not yet the cache\n-    if (m_cached_aad_seqnr != seqnr_aad) {\n-        m_cached_aad_seqnr = seqnr_aad;\n-        m_chacha_header.SetIV(seqnr_aad);\n-        m_chacha_header.Seek(0);\n-        m_chacha_header.Keystream(m_aad_keystream_buffer, CHACHA20_ROUND_OUTPUT);\n-    }\n-    // crypt the AAD (3 bytes message length) with given position in AAD cipher instance keystream\n-    dest[0] = src[0] ^ m_aad_keystream_buffer[aad_pos];\n-    dest[1] = src[1] ^ m_aad_keystream_buffer[aad_pos + 1];\n-    dest[2] = src[2] ^ m_aad_keystream_buffer[aad_pos + 2];\n-\n-    // Set the playload ChaCha instance block counter to 1 and crypt the payload\n-    m_chacha_main.Seek(1);\n+    // 4. crypt the payload\n     m_chacha_main.Crypt(src + CHACHA20_POLY1305_AEAD_AAD_LEN, dest + CHACHA20_POLY1305_AEAD_AAD_LEN, src_len - CHACHA20_POLY1305_AEAD_AAD_LEN);\n \n-    // If encrypting, calculate and append tag\n+    // 5. If encrypting, calculate and append MAC\n     if (is_encrypt) {\n-        // the poly1305 tag expands over the AAD (3 bytes length) & encrypted payload\n+        // the poly1305 MAC expands over the AAD (3 bytes length) & encrypted payload\n         poly1305_auth(dest + src_len, dest, src_len, poly_key);\n     }\n \n-    // cleanse no longer required MAC and polykey\n+    // cleanse no longer required polykey\n     memory_cleanse(poly_key, sizeof(poly_key));\n     return true;\n }\n \n-bool ChaCha20Poly1305AEAD::GetLength(uint32_t* len24_out, uint64_t seqnr_aad, int aad_pos, const uint8_t* ciphertext)\n+bool ChaCha20Poly1305AEAD::DecryptLength(uint32_t* len24_out, const uint8_t* ciphertext)\n {\n-    // enforce valid aad position to avoid accessing outside of the 64byte keystream cache\n-    // (there is space for 21 times 3 bytes)\n-    assert(aad_pos >= 0 && aad_pos < CHACHA20_ROUND_OUTPUT - CHACHA20_POLY1305_AEAD_AAD_LEN);\n-    if (m_cached_aad_seqnr != seqnr_aad) {\n-        // we need to calculate the 64 keystream bytes since we reached a new aad sequence number\n-        m_cached_aad_seqnr = seqnr_aad;\n-        m_chacha_header.SetIV(seqnr_aad);                                         // use LE for the nonce\n-        m_chacha_header.Seek(0);                                                  // block counter 0\n-        m_chacha_header.Keystream(m_aad_keystream_buffer, CHACHA20_ROUND_OUTPUT); // write keystream to the cache\n-    }\n-\n-    // decrypt the ciphertext length by XORing the right position of the 64byte keystream cache with the ciphertext\n-    *len24_out = (ciphertext[0] ^ m_aad_keystream_buffer[aad_pos + 0]) |\n-                 (ciphertext[1] ^ m_aad_keystream_buffer[aad_pos + 1]) << 8 |\n-                 (ciphertext[2] ^ m_aad_keystream_buffer[aad_pos + 2]) << 16;\n-\n+    // decrypt the length\n+    // once we hit the re-key limit in the keystream (byte 4064) we can't go back to decrypt the length again\n+    // we need to keep the decrypted and the encrypted version in memory to check the max packet length and\n+    // to have the capability to verify the MAC\n+    unsigned char length_buffer[CHACHA20_POLY1305_AEAD_AAD_LEN];\n+    m_chacha_header.Crypt(ciphertext, length_buffer, sizeof(length_buffer));\n+\n+    *len24_out = (length_buffer[0]) |\n+                 (length_buffer[1]) << 8 |\n+                 (length_buffer[2]) << 16;\n     return true;\n }"
      },
      {
        "sha": "a6fc908e1d488393a922600eb0eaed306a26dccf",
        "filename": "src/crypto/chacha_poly_aead.h",
        "status": "modified",
        "additions": 83,
        "deletions": 87,
        "changes": 170,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1cfd3fef3e88f70a30860b6aee57d918ff0dd07f/src/crypto/chacha_poly_aead.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1cfd3fef3e88f70a30860b6aee57d918ff0dd07f/src/crypto/chacha_poly_aead.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/chacha_poly_aead.h?ref=1cfd3fef3e88f70a30860b6aee57d918ff0dd07f",
        "patch": "@@ -6,6 +6,7 @@\n #define BITCOIN_CRYPTO_CHACHA_POLY_AEAD_H\n \n #include <crypto/chacha20.h>\n+#include <crypto/poly1305.h>\n \n #include <cmath>\n \n@@ -36,111 +37,106 @@ static constexpr int AAD_PACKAGES_PER_ROUND = 21;        /* 64 / 3 round down*/\n  *\n  * ==== Detailed Construction ====\n  *\n- * The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n- * output from the key exchange. Each key (K_1 and K_2) are used by two separate\n- * instances of chacha20.\n- *\n- * The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3\n- * byte packet length field and has its own sequence number. The second instance,\n- * keyed by K_2, is used in conjunction with poly1305 to build an AEAD\n- * (Authenticated Encryption with Associated Data) that is used to encrypt and\n- * authenticate the entire packet.\n- *\n- * Two separate cipher instances are used here so as to keep the packet lengths\n- * confidential but not create an oracle for the packet payload cipher by\n- * decrypting and using the packet length prior to checking the MAC. By using an\n- * independently-keyed cipher instance to encrypt the length, an active attacker\n- * seeking to exploit the packet input handling as a decryption oracle can learn\n- * nothing about the payload contents or its MAC (assuming key derivation,\n- * ChaCha20 and Poly1305 are secure).\n- *\n- * The AEAD is constructed as follows: for each packet, generate a Poly1305 key by\n- * taking the first 256 bits of ChaCha20 stream output generated using K_2, an IV\n- * consisting of the packet sequence number encoded as an LE uint64 and a ChaCha20\n- * block counter of zero. The K_2 ChaCha20 block counter is then set to the\n- * little-endian encoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance\n- * is used for encryption of the packet payload.\n- *\n- * ==== Packet Handling ====\n- *\n- * When receiving a packet, the length must be decrypted first. When 3 bytes of\n- * ciphertext length have been received, they may be decrypted.\n- *\n- * A ChaCha20 round always calculates 64bytes which is sufficient to crypt 21\n- * times a 3 bytes length field (21*3 = 63). The length field sequence number can\n- * thus be used 21 times (keystream caching).\n- *\n- * The length field must be enc-/decrypted with the ChaCha20 keystream keyed with\n- * K_1 defined by block counter 0, the length field sequence number in little\n- * endian and a keystream position from 0 to 60.\n- *\n- * Once the entire packet has been received, the MAC MUST be checked before\n- * decryption. A per-packet Poly1305 key is generated as described above and the\n- * MAC tag calculated using Poly1305 with this key over the ciphertext of the\n- * packet length and the payload together. The calculated MAC is then compared in\n- * constant time with the one appended to the packet and the packet decrypted\n- * using ChaCha20 as described above (with K_2, the packet sequence number as\n- * nonce and a starting block counter of 1).\n- *\n- * Detection of an invalid MAC MUST lead to immediate connection termination.\n- *\n- * To send a packet, first encode the 3 byte length and encrypt it using K_1 as\n- * described above. Encrypt the packet payload (using K_2) and append it to the\n- * encrypted length. Finally, calculate a MAC tag and append it.\n- *\n- * The initiating peer MUST use <code>K_1_A, K_2_A</code> to encrypt messages on\n- * the send channel, <code>K_1_B, K_2_B</code> MUST be used to decrypt messages on\n- * the receive channel.\n- *\n- * The responding peer MUST use <code>K_1_A, K_2_A</code> to decrypt messages on\n- * the receive channel, <code>K_1_B, K_2_B</code> MUST be used to encrypt messages\n- * on the send channel.\n- *\n- * Optimized implementations of ChaCha20-Poly1305@bitcoin are relatively fast in\n- * general, therefore it is very likely that encrypted messages require not more\n- * CPU cycles per bytes then the current unencrypted p2p message format\n- * (ChaCha20/Poly1305 versus double SHA256).\n- *\n- * The initial packet sequence numbers are 0.\n- *\n- * K_2 ChaCha20 cipher instance (payload) must never reuse a {key, nonce} for\n- * encryption nor may it be used to encrypt more than 2^70 bytes under the same\n- * {key, nonce}.\n- *\n- * K_1 ChaCha20 cipher instance (length field/AAD) must never reuse a {key, nonce,\n- * position-in-keystream} for encryption nor may it be used to encrypt more than\n- * 2^70 bytes under the same {key, nonce}.\n- *\n- * We use message sequence numbers for both communication directions.\n- */\n+The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n+* output from the key exchange. Each key (K_1 and K_2) are used by two separate\n+* instances of chacha20.\n+*\n+* The instance keyed by K_1 is a stream cipher that is used for the per-message\n+* metadata, specifically for the poly1305 authentication key as well as for the\n+* length encryption. The second instance, keyed by K_2, is used to encrypt the\n+* entire payload.\n+*\n+* Two separate cipher instances are used here so as to keep the packet lengths\n+* confidential (best effort; for passive observing) but not create an oracle for\n+* the packet payload cipher by decrypting and using the packet length prior to\n+* checking the MAC. By using an independently-keyed cipher instance to encrypt\n+* the length, an active attacker seeking to exploit the packet input handling as\n+* a decryption oracle can learn nothing about the payload contents or its MAC\n+* (assuming key derivation, ChaCha20 and Poly1305 are secure). Active observers\n+* can still obtain the message length (ex. active ciphertext bit flipping or\n+* traffic shemantics analysis)\n+*\n+* The AEAD is constructed as follows: generate two ChaCha20 streams, initially\n+* keyed with K_1 and K_2 and IV of 0 and a block counter of 0 and a sequence\n+* number 0 as IV. After encrypting 4064 bytes, the following 32 bytes are used to\n+* re-key the ChaCha20 context.\n+*\n+* Byte-level forward security is possible by precomputing 4096 bytes of stream\n+* output, caching it, resetting the key to the final 32 bytes of the output, and\n+* then wiping the remaining 4064 bytes of cached data as it gets used.\n+*\n+* For each packet, use 3 bytes from the remaining ChaCha20 stream generated using\n+* K_1 to encrypt the length. Use additional 32 bytes of the same stream to\n+* generate a Poly1305 key.\n+*\n+* If we reach bytes 4064 on the ChaCha20 stream, use the next 32 bytes (byte\n+* 4065-4096) and set is as the new ChaCha20 key, reset the counter to 0 while\n+* incrementing the sequence number + 1 and set is as IV (little endian encoding).\n+*\n+* For the payload, use the ChaCha20 stream keyed with K_1 and apply the same\n+* re-key rules.\n+*\n+*\n+* ==== Packet Handling ====\n+*\n+* When receiving a packet, the length must be decrypted first. When 3 bytes of\n+* ciphertext length have been received, they MUST be decrypted.\n+*\n+* Once the entire packet has been received, the MAC MUST be checked before\n+* decryption. A per-packet Poly1305 key is generated as described above and the\n+* MAC tag is calculated using Poly1305 with this key over the ciphertext of the\n+* packet length and the payload together. The calculated MAC is then compared in\n+* constant time with the one appended to the packet and the packet decrypted\n+* using ChaCha20 as described above (with K_2, the packet sequence number as\n+* nonce and a starting block counter of 1).\n+*\n+* Detection of an invalid MAC MUST lead to immediate connection termination.\n+*\n+* To send a packet, first encode the 3 byte length and encrypt it using the\n+* ChaCha20 stream keyed with K_1 as described above. Encrypt the packet payload\n+* (using the ChaCha20 stream keyed with K_2) and append it to the encrypted\n+* length. Finally, calculate a MAC tag and append it.\n+*/\n+\n+const int KEYSTREAM_SIZE = 4096;\n+\n+class ChaCha20ReKey4096 {\n+private:\n+    ChaCha20 m_ctx;\n+    uint64_t m_seqnr{0};\n+    size_t m_keystream_pos{0};\n+    unsigned char m_keystream[KEYSTREAM_SIZE] = {0};\n+public:\n+    ~ChaCha20ReKey4096();\n+    void SetKey(const unsigned char* key, size_t keylen);\n+    void Crypt(const unsigned char* input, unsigned char* output, size_t bytes);\n+};\n \n class ChaCha20Poly1305AEAD\n {\n private:\n-    ChaCha20 m_chacha_main;                                      // payload and poly1305 key-derivation cipher instance\n-    ChaCha20 m_chacha_header;                                    // AAD cipher instance (encrypted length)\n-    unsigned char m_aad_keystream_buffer[CHACHA20_ROUND_OUTPUT]; // aad keystream cache\n-    uint64_t m_cached_aad_seqnr;                                 // aad keystream cache hint\n+    ChaCha20ReKey4096 m_chacha_main;                                      // payload and poly1305 key-derivation cipher instance\n+    ChaCha20ReKey4096 m_chacha_header;                                    // AAD cipher instance (encrypted length)\n \n public:\n     ChaCha20Poly1305AEAD(const unsigned char* K_1, size_t K_1_len, const unsigned char* K_2, size_t K_2_len);\n \n     explicit ChaCha20Poly1305AEAD(const ChaCha20Poly1305AEAD&) = delete;\n \n     /** Encrypts/decrypts a packet\n-        seqnr_payload, the message sequence number\n-        seqnr_aad, the messages AAD sequence number which allows reuse of the AAD keystream\n-        aad_pos, position to use in the AAD keystream to encrypt the AAD\n         dest, output buffer, must be of a size equal or larger then CHACHA20_POLY1305_AEAD_AAD_LEN + payload (+ POLY1305_TAG_LEN in encryption) bytes\n         destlen, length of the destination buffer\n         src, the AAD+payload to encrypt or the AAD+payload+MAC to decrypt\n         src_len, the length of the source buffer\n         is_encrypt, set to true if we encrypt (creates and appends the MAC instead of verifying it)\n         */\n-    bool Crypt(uint64_t seqnr_payload, uint64_t seqnr_aad, int aad_pos, unsigned char* dest, size_t dest_len, const unsigned char* src, size_t src_len, bool is_encrypt);\n+    bool Crypt(unsigned char* dest, size_t dest_len, const unsigned char* src, size_t src_len, bool is_encrypt);\n \n-    /** decrypts the 3 bytes AAD data and decodes it into a uint32_t field */\n-    bool GetLength(uint32_t* len24_out, uint64_t seqnr_aad, int aad_pos, const uint8_t* ciphertext);\n+    /** decrypts the 3 bytes AAD data (the packet length) and decodes it into a uint32_t field\n+        the ciphertext will not be manipulated but the AEAD state changes (can't be called multiple times)\n+        Ciphertext needs to stay encrypted due to the MAC check that will follow (requires encrypted length)\n+        */\n+    bool DecryptLength(uint32_t* len24_out, const uint8_t* ciphertext);\n };\n \n #endif // BITCOIN_CRYPTO_CHACHA_POLY_AEAD_H"
      },
      {
        "sha": "b3e912bf03701edf8a7613da5b454bc897133947",
        "filename": "src/test/crypto_tests.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 69,
        "changes": 93,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1cfd3fef3e88f70a30860b6aee57d918ff0dd07f/src/test/crypto_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1cfd3fef3e88f70a30860b6aee57d918ff0dd07f/src/test/crypto_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/crypto_tests.cpp?ref=1cfd3fef3e88f70a30860b6aee57d918ff0dd07f",
        "patch": "@@ -590,37 +590,24 @@ BOOST_AUTO_TEST_CASE(hkdf_hmac_sha256_l32_tests)\n                 \"8da4e775a563c18f715f802a063c5a31b8a11f5c5ee1879ec3454e5f3c738d2d\");\n }\n \n-static void TestChaCha20Poly1305AEAD(bool must_succeed, unsigned int expected_aad_length, const std::string& hex_m, const std::string& hex_k1, const std::string& hex_k2, const std::string& hex_aad_keystream, const std::string& hex_encrypted_message, const std::string& hex_encrypted_message_seq_999)\n+static void TestChaCha20Poly1305AEAD(bool must_succeed, unsigned int expected_aad_length, const std::string& hex_m, const std::string& hex_k1, const std::string& hex_k2, const std::string& hex_encrypted_message, const std::string& hex_encrypted_message_seq_999)\n {\n-    // we need two sequence numbers, one for the payload cipher instance...\n-    uint32_t seqnr_payload = 0;\n-    // ... and one for the AAD (length) cipher instance\n-    uint32_t seqnr_aad = 0;\n-    // we need to keep track of the position in the AAD cipher instance\n-    // keystream since we use the same 64byte output 21 times\n-    // (21 times 3 bytes length < 64)\n-    int aad_pos = 0;\n-\n     std::vector<unsigned char> aead_K_1 = ParseHex(hex_k1);\n     std::vector<unsigned char> aead_K_2 = ParseHex(hex_k2);\n     std::vector<unsigned char> plaintext_buf = ParseHex(hex_m);\n-    std::vector<unsigned char> expected_aad_keystream = ParseHex(hex_aad_keystream);\n     std::vector<unsigned char> expected_ciphertext_and_mac = ParseHex(hex_encrypted_message);\n     std::vector<unsigned char> expected_ciphertext_and_mac_sequence999 = ParseHex(hex_encrypted_message_seq_999);\n \n     std::vector<unsigned char> ciphertext_buf(plaintext_buf.size() + POLY1305_TAGLEN, 0);\n     std::vector<unsigned char> plaintext_buf_new(plaintext_buf.size(), 0);\n-    std::vector<unsigned char> cmp_ctx_buffer(64);\n     uint32_t out_len = 0;\n \n     // create the AEAD instance\n-    ChaCha20Poly1305AEAD aead(aead_K_1.data(), aead_K_1.size(), aead_K_2.data(), aead_K_2.size());\n-\n-    // create a chacha20 instance to compare against\n-    ChaCha20 cmp_ctx(aead_K_2.data(), 32);\n+    ChaCha20Poly1305AEAD aead_out(aead_K_1.data(), aead_K_1.size(), aead_K_2.data(), aead_K_2.size());\n+    ChaCha20Poly1305AEAD aead_in(aead_K_1.data(), aead_K_1.size(), aead_K_2.data(), aead_K_2.size());\n \n     // encipher\n-    bool res = aead.Crypt(seqnr_payload, seqnr_aad, aad_pos, ciphertext_buf.data(), ciphertext_buf.size(), plaintext_buf.data(), plaintext_buf.size(), true);\n+    bool res = aead_out.Crypt(ciphertext_buf.data(), ciphertext_buf.size(), plaintext_buf.data(), plaintext_buf.size(), true);\n     // make sure the operation succeeded if expected to succeed\n     BOOST_CHECK_EQUAL(res, must_succeed);\n     if (!res) return;\n@@ -629,56 +616,27 @@ static void TestChaCha20Poly1305AEAD(bool must_succeed, unsigned int expected_aa\n     BOOST_CHECK_EQUAL(expected_ciphertext_and_mac.size(), ciphertext_buf.size());\n     BOOST_CHECK(memcmp(ciphertext_buf.data(), expected_ciphertext_and_mac.data(), ciphertext_buf.size()) == 0);\n \n-    // manually construct the AAD keystream\n-    cmp_ctx.SetIV(seqnr_aad);\n-    cmp_ctx.Seek(0);\n-    cmp_ctx.Keystream(cmp_ctx_buffer.data(), 64);\n-    BOOST_CHECK(memcmp(expected_aad_keystream.data(), cmp_ctx_buffer.data(), expected_aad_keystream.size()) == 0);\n-    // crypt the 3 length bytes and compare the length\n-    uint32_t len_cmp = 0;\n-    len_cmp = (ciphertext_buf[0] ^ cmp_ctx_buffer[aad_pos + 0]) |\n-              (ciphertext_buf[1] ^ cmp_ctx_buffer[aad_pos + 1]) << 8 |\n-              (ciphertext_buf[2] ^ cmp_ctx_buffer[aad_pos + 2]) << 16;\n-    BOOST_CHECK_EQUAL(len_cmp, expected_aad_length);\n-\n-    // encrypt / decrypt 1000 packets\n+    BOOST_CHECK(aead_in.DecryptLength(&out_len, ciphertext_buf.data()));\n+    aead_in.Crypt(plaintext_buf.data(), plaintext_buf.size(), ciphertext_buf.data(), ciphertext_buf.size(), false);\n+    WriteLE32(plaintext_buf.data(), out_len);\n+\n+    // encrypt / decrypt the packet 1000 times\n     for (size_t i = 0; i < 1000; ++i) {\n-        res = aead.Crypt(seqnr_payload, seqnr_aad, aad_pos, ciphertext_buf.data(), ciphertext_buf.size(), plaintext_buf.data(), plaintext_buf.size(), true);\n+        res = aead_out.Crypt(ciphertext_buf.data(), ciphertext_buf.size(), plaintext_buf.data(), plaintext_buf.size(), true);\n         BOOST_CHECK(res);\n-        BOOST_CHECK(aead.GetLength(&out_len, seqnr_aad, aad_pos, ciphertext_buf.data()));\n+        BOOST_CHECK(aead_in.DecryptLength(&out_len, ciphertext_buf.data()));\n         BOOST_CHECK_EQUAL(out_len, expected_aad_length);\n-        res = aead.Crypt(seqnr_payload, seqnr_aad, aad_pos, plaintext_buf_new.data(), plaintext_buf_new.size(), ciphertext_buf.data(), ciphertext_buf.size(), false);\n+        res = aead_in.Crypt(plaintext_buf_new.data(), plaintext_buf_new.size(), ciphertext_buf.data(), ciphertext_buf.size(), false);\n         BOOST_CHECK(res);\n \n+        // length is not decrypted, copy it over\n+        WriteLE32(plaintext_buf_new.data(), out_len);\n+\n         // make sure we repetitive get the same plaintext\n         BOOST_CHECK(memcmp(plaintext_buf.data(), plaintext_buf_new.data(), plaintext_buf.size()) == 0);\n \n-        // compare sequence number 999 against the test vector\n-        if (seqnr_payload == 999) {\n-            BOOST_CHECK(memcmp(ciphertext_buf.data(), expected_ciphertext_and_mac_sequence999.data(), expected_ciphertext_and_mac_sequence999.size()) == 0);\n-        }\n-        // set nonce and block counter, output the keystream\n-        cmp_ctx.SetIV(seqnr_aad);\n-        cmp_ctx.Seek(0);\n-        cmp_ctx.Keystream(cmp_ctx_buffer.data(), 64);\n-\n-        // crypt the 3 length bytes and compare the length\n-        len_cmp = 0;\n-        len_cmp = (ciphertext_buf[0] ^ cmp_ctx_buffer[aad_pos + 0]) |\n-                  (ciphertext_buf[1] ^ cmp_ctx_buffer[aad_pos + 1]) << 8 |\n-                  (ciphertext_buf[2] ^ cmp_ctx_buffer[aad_pos + 2]) << 16;\n-        BOOST_CHECK_EQUAL(len_cmp, expected_aad_length);\n-\n-        // increment the sequence number(s)\n-        // always increment the payload sequence number\n-        // increment the AAD keystream position by its size (3)\n-        // increment the AAD sequence number if we would hit the 64 byte limit\n-        seqnr_payload++;\n-        aad_pos += CHACHA20_POLY1305_AEAD_AAD_LEN;\n-        if (aad_pos + CHACHA20_POLY1305_AEAD_AAD_LEN > CHACHA20_ROUND_OUTPUT) {\n-            aad_pos = 0;\n-            seqnr_aad++;\n-        }\n+        // compare at iteration 999 against the test vector\n+        if (i == 999) BOOST_CHECK(memcmp(ciphertext_buf.data(), expected_ciphertext_and_mac_sequence999.data(), expected_ciphertext_and_mac_sequence999.size()) == 0);\n     }\n }\n \n@@ -690,29 +648,26 @@ BOOST_AUTO_TEST_CASE(chacha20_poly1305_aead_testvector)\n     TestChaCha20Poly1305AEAD(false, 0,\n         \"\",\n         \"0000000000000000000000000000000000000000000000000000000000000000\",\n-        \"0000000000000000000000000000000000000000000000000000000000000000\", \"\", \"\", \"\");\n+        \"0000000000000000000000000000000000000000000000000000000000000000\", \"\", \"\");\n \n     TestChaCha20Poly1305AEAD(true, 0,\n         /* m  */ \"0000000000000000000000000000000000000000000000000000000000000000\",\n         /* k1 (payload) */ \"0000000000000000000000000000000000000000000000000000000000000000\",\n         /* k2 (AAD) */ \"0000000000000000000000000000000000000000000000000000000000000000\",\n-        /* AAD keystream */ \"76b8e0ada0f13d90405d6ae55386bd28bdd219b8a08ded1aa836efcc8b770dc7da41597c5157488d7724e03fb8d84a376a43b8f41518a11cc387b669b2ee6586\",\n-        /* encrypted message & MAC */ \"76b8e09f07e7be5551387a98ba977c732d080dcb0f29a048e3656912c6533e32d2fc11829c1b6c1df1f551cd6131ff08\",\n-        /* encrypted message & MAC at sequence 999 */ \"b0a03d5bd2855d60699e7d3a3133fa47be740fe4e4c1f967555e2d9271f31c3aaa7aa16ec62c5e24f040c08bb20c3598\");\n+        /* encrypted message & MAC */ \"76b8e076b8e0ada0f13d90405d6ae55386bd28bdd219b8a08ded1aa836efcc8bdfcd91c875ee88718b63345d750c684a\",\n+        /* encrypted message & MAC at encrypt/decrypt-loop 999 */ \"c91eef105710ba88ef076f28e735cc672bde84505fbaeb0faa627ff5067a8609e9a60282f34f1a96c281da7a6225f866\");\n     TestChaCha20Poly1305AEAD(true, 1,\n         \"0100000000000000000000000000000000000000000000000000000000000000\",\n         \"0000000000000000000000000000000000000000000000000000000000000000\",\n         \"0000000000000000000000000000000000000000000000000000000000000000\",\n-        \"76b8e0ada0f13d90405d6ae55386bd28bdd219b8a08ded1aa836efcc8b770dc7da41597c5157488d7724e03fb8d84a376a43b8f41518a11cc387b669b2ee6586\",\n-        \"77b8e09f07e7be5551387a98ba977c732d080dcb0f29a048e3656912c6533e32baf0c85b6dff8602b06cf52a6aefc62e\",\n-        \"b1a03d5bd2855d60699e7d3a3133fa47be740fe4e4c1f967555e2d9271f31c3a8bd94d54b5ecabbc41ffbb0c90924080\");\n+        \"77b8e076b8e0ada0f13d90405d6ae55386bd28bdd219b8a08ded1aa836efcc8bfb6cf9dcd7e2ee807d5ff981eb4a135a\",\n+        \"c81eef105710ba88ef076f28e735cc672bde84505fbaeb0faa627ff5067a860942b2888c98e0c1003d0611e527776e88\");\n     TestChaCha20Poly1305AEAD(true, 255,\n         \"ff0000f195e66982105ffb640bb7757f579da31602fc93ec01ac56f85ac3c134a4547b733b46413042c9440049176905d3be59ea1c53f15916155c2be8241a38008b9a26bc35941e2444177c8ade6689de95264986d95889fb60e84629c9bd9a5acb1cc118be563eb9b3a4a472f82e09a7e778492b562ef7130e88dfe031c79db9d4f7c7a899151b9a475032b63fc385245fe054e3dd5a97a5f576fe064025d3ce042c566ab2c507b138db853e3d6959660996546cc9c4a6eafdc777c040d70eaf46f76dad3979e5c5360c3317166a1c894c94a371876a94df7628fe4eaaf2ccb27d5aaae0ad7ad0f9d4b6ad3b54098746d4524d38407a6deb3ab78fab78c9\",\n         \"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\",\n         \"ff0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\",\n-        \"c640c1711e3ee904ac35c57ab9791c8a1c408603a90b77a83b54f6c844cb4b06d94e7fc6c800e165acd66147e80ec45a567f6ce66d05ec0cae679dceeb890017\",\n-        \"3940c1e92da4582ff6f92a776aeb14d014d384eeb30f660dacf70a14a23fd31e91212701334e2ce1acf5199dc84f4d61ddbe6571bca5af874b4c9226c26e650995d157644e1848b96ed6c2102d5489a050e71d29a5a66ece11de5fb5c9558d54da28fe45b0bc4db4e5b88030bfc4a352b4b7068eccf656bae7ad6a35615315fc7c49d4200388d5eca67c2e822e069336c69b40db67e0f3c81209c50f3216a4b89fb3ae1b984b7851a2ec6f68ab12b101ab120e1ea7313bb93b5a0f71185c7fea017ddb92769861c29dba4fbc432280d5dff21b36d1c4c790128b22699950bb18bf74c448cdfe547d8ed4f657d8005fdc0cd7a050c2d46050a44c4376355858981fbe8b184288276e7a93eabc899c4a\",\n-        \"f039c6689eaeef0456685200feaab9d54bbd9acde4410a3b6f4321296f4a8ca2604b49727d8892c57e005d799b2a38e85e809f20146e08eec75169691c8d4f54a0d51a1e1c7b381e0474eb02f994be9415ef3ffcbd2343f0601e1f3b172a1d494f838824e4df570f8e3b0c04e27966e36c82abd352d07054ef7bd36b84c63f9369afe7ed79b94f953873006b920c3fa251a771de1b63da927058ade119aa898b8c97e42a606b2f6df1e2d957c22f7593c1e2002f4252f4c9ae4bf773499e5cfcfe14dfc1ede26508953f88553bf4a76a802f6a0068d59295b01503fd9a600067624203e880fdf53933b96e1f4d9eb3f4e363dd8165a278ff667a41ee42b9892b077cefff92b93441f7be74cf10e6cd\");\n+        \"3940c1c868cd145bd54691e9b6b402c78bd7ea9c3724fc50dfc69a4a96be8dec4e70e958188aa69222eaef3f47f8003f1bc13dcf9e661be8e1b671e9cf46ba705bca963e0477a5b3c2e2c66feb8207269ddb01b1372aad68563bb4aad135afb06fbe40b310b63bef578ff939f3a00a6da9e744d28ba070294e5746d2ca7bb8ac2c8e3a855ab4c9bcd0d5855e11b52cacaa2ddb34c0a26cd04f4bc10de6dc151d4ee7ced2c2b0de8ded33ff11f301e4027559e8938b69bceb1e5e259d4122056f6adbd48a0628b912f90d72838f2f3aaf6b88342cf5bac3cb688a9b0f7afc73a7e3cad8e71254c786ea000240ae7bd1df8bcfca07f3b885723a9d7f897364617ac8d935a41bf9546432360e1c543708\",\n+        \"c5ab314a18d3b9eb02b7990e91adb4f005fb185d741277c066c4d002560dabea96b07009b1ae287931224e90fd70324fb02857019499f3d9ec774dd3f412a1ac13dc2f603e8b22abef71c9c7c688c1b7d835f76d32a32886f3326f70701f5b3617de21723a9d575bd572815696ad8410da643603a9a1c1a5aedc0c88ceb2c6610c685a4918e09f36f01c646f071c8ec668fd794ff4fc8bd671663a8e36a96ea8d4ea4c3d2893258237bddf7562af50785043cfb78e06cfe6d00145a46a76c9fedc450c776af4a4319ecb92ef818d2174baab3714cabb823a4c456cf51c0143a9451676db428b6b5aca7f8ff4a51fd717bc3293955aca0363ec663abdc8c8e7bd214de0e986fbb1e04de90db8dfb055\");\n }\n \n BOOST_AUTO_TEST_CASE(countbits_tests)"
      },
      {
        "sha": "eb59e55c059e856731f95960e5bca1f085c05846",
        "filename": "src/test/fuzz/crypto_chacha20_poly1305_aead.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 19,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1cfd3fef3e88f70a30860b6aee57d918ff0dd07f/src/test/fuzz/crypto_chacha20_poly1305_aead.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1cfd3fef3e88f70a30860b6aee57d918ff0dd07f/src/test/fuzz/crypto_chacha20_poly1305_aead.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/crypto_chacha20_poly1305_aead.cpp?ref=1cfd3fef3e88f70a30860b6aee57d918ff0dd07f",
        "patch": "@@ -21,9 +21,6 @@ FUZZ_TARGET(crypto_chacha20_poly1305_aead)\n     const std::vector<uint8_t> k2 = ConsumeFixedLengthByteVector(fuzzed_data_provider, CHACHA20_POLY1305_AEAD_KEY_LEN);\n \n     ChaCha20Poly1305AEAD aead(k1.data(), k1.size(), k2.data(), k2.size());\n-    uint64_t seqnr_payload = 0;\n-    uint64_t seqnr_aad = 0;\n-    int aad_pos = 0;\n     size_t buffer_size = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096);\n     std::vector<uint8_t> in(buffer_size + CHACHA20_POLY1305_AEAD_AAD_LEN + POLY1305_TAGLEN, 0);\n     std::vector<uint8_t> out(buffer_size + CHACHA20_POLY1305_AEAD_AAD_LEN + POLY1305_TAGLEN, 0);\n@@ -37,27 +34,13 @@ FUZZ_TARGET(crypto_chacha20_poly1305_aead)\n                 out = std::vector<uint8_t>(buffer_size + CHACHA20_POLY1305_AEAD_AAD_LEN + POLY1305_TAGLEN, 0);\n             },\n             [&] {\n-                (void)aead.Crypt(seqnr_payload, seqnr_aad, aad_pos, out.data(), out.size(), in.data(), buffer_size, is_encrypt);\n+                (void)aead.Crypt(out.data(), out.size(), in.data(), buffer_size, is_encrypt);\n             },\n             [&] {\n                 uint32_t len = 0;\n-                const bool ok = aead.GetLength(&len, seqnr_aad, aad_pos, in.data());\n+                const bool ok = aead.DecryptLength(&len, in.data());\n                 assert(ok);\n             },\n-            [&] {\n-                seqnr_payload += 1;\n-                aad_pos += CHACHA20_POLY1305_AEAD_AAD_LEN;\n-                if (aad_pos + CHACHA20_POLY1305_AEAD_AAD_LEN > CHACHA20_ROUND_OUTPUT) {\n-                    aad_pos = 0;\n-                    seqnr_aad += 1;\n-                }\n-            },\n-            [&] {\n-                seqnr_payload = fuzzed_data_provider.ConsumeIntegral<int>();\n-            },\n-            [&] {\n-                seqnr_aad = fuzzed_data_provider.ConsumeIntegral<int>();\n-            },\n             [&] {\n                 is_encrypt = fuzzed_data_provider.ConsumeBool();\n             });"
      }
    ]
  },
  {
    "sha": "9d008a4b34781d79b15fe260dad25612774e939c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZDAwOGE0YjM0NzgxZDc5YjE1ZmUyNjBkYWQyNTYxMjc3NGU5Mzlj",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2019-08-09T13:31:53Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2021-01-19T10:24:54Z"
      },
      "message": "Expose MAC length in chacha_poly_aead.h",
      "tree": {
        "sha": "fbcf13f3262661006c176935428427ee58f8599f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fbcf13f3262661006c176935428427ee58f8599f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9d008a4b34781d79b15fe260dad25612774e939c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9d008a4b34781d79b15fe260dad25612774e939c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9d008a4b34781d79b15fe260dad25612774e939c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9d008a4b34781d79b15fe260dad25612774e939c/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1cfd3fef3e88f70a30860b6aee57d918ff0dd07f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1cfd3fef3e88f70a30860b6aee57d918ff0dd07f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1cfd3fef3e88f70a30860b6aee57d918ff0dd07f"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 1,
      "deletions": 0
    },
    "files": [
      {
        "sha": "9b4076a01d365d462475f0c50bfd2ed3930c0436",
        "filename": "src/crypto/chacha_poly_aead.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9d008a4b34781d79b15fe260dad25612774e939c/src/crypto/chacha_poly_aead.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9d008a4b34781d79b15fe260dad25612774e939c/src/crypto/chacha_poly_aead.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/chacha_poly_aead.h?ref=9d008a4b34781d79b15fe260dad25612774e939c",
        "patch": "@@ -12,6 +12,7 @@\n \n static constexpr int CHACHA20_POLY1305_AEAD_KEY_LEN = 32;\n static constexpr int CHACHA20_POLY1305_AEAD_AAD_LEN = 3; /* 3 bytes length */\n+static constexpr int CHACHA20_POLY1305_AEAD_TAG_LEN = 16; /* 16 bytes poly1305 tag */\n static constexpr int CHACHA20_ROUND_OUTPUT = 64;         /* 64 bytes per round */\n static constexpr int AAD_PACKAGES_PER_ROUND = 21;        /* 64 / 3 round down*/\n "
      }
    ]
  },
  {
    "sha": "88e2c3f84efe2c74cae95b20101beb90f8ef0e5a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4OGUyYzNmODRlZmUyYzc0Y2FlOTViMjAxMDFiZWI5MGY4ZWYwZTVh",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2019-08-09T13:32:26Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2021-01-19T10:24:54Z"
      },
      "message": "Add BIP324 short-IDs to protocol.cpp",
      "tree": {
        "sha": "5a4236ff2fbc1b5075d68a8778bcbbe2464193b3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5a4236ff2fbc1b5075d68a8778bcbbe2464193b3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/88e2c3f84efe2c74cae95b20101beb90f8ef0e5a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/88e2c3f84efe2c74cae95b20101beb90f8ef0e5a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/88e2c3f84efe2c74cae95b20101beb90f8ef0e5a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/88e2c3f84efe2c74cae95b20101beb90f8ef0e5a/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9d008a4b34781d79b15fe260dad25612774e939c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9d008a4b34781d79b15fe260dad25612774e939c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9d008a4b34781d79b15fe260dad25612774e939c"
      }
    ],
    "stats": {
      "total": 115,
      "additions": 73,
      "deletions": 42
    },
    "files": [
      {
        "sha": "e3bce1a0bbd1f6ba1eadcdf0727379f594c3e6c7",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/88e2c3f84efe2c74cae95b20101beb90f8ef0e5a/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/88e2c3f84efe2c74cae95b20101beb90f8ef0e5a/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=88e2c3f84efe2c74cae95b20101beb90f8ef0e5a",
        "patch": "@@ -2836,8 +2836,9 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, SOCKET hSocketIn, const\n         m_addr_known = MakeUnique<CRollingBloomFilter>(5000, 0.001);\n     }\n \n-    for (const std::string &msg : getAllNetMessageTypes())\n-        mapRecvBytesPerMsgCmd[msg] = 0;\n+    for (const auto &msg : getAllNetMessageTypes()) {\n+        mapRecvBytesPerMsgCmd[msg.second] = 0;\n+    }\n     mapRecvBytesPerMsgCmd[NET_MESSAGE_COMMAND_OTHER] = 0;\n \n     if (fLogIPs) {"
      },
      {
        "sha": "18334e628dfbcd3d160ec34b73ecd358b2a1df66",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 58,
        "deletions": 39,
        "changes": 97,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/88e2c3f84efe2c74cae95b20101beb90f8ef0e5a/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/88e2c3f84efe2c74cae95b20101beb90f8ef0e5a/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=88e2c3f84efe2c74cae95b20101beb90f8ef0e5a",
        "patch": "@@ -47,46 +47,45 @@ const char *CFCHECKPT=\"cfcheckpt\";\n const char *WTXIDRELAY=\"wtxidrelay\";\n } // namespace NetMsgType\n \n-/** All known message types. Keep this in the same order as the list of\n+/** All known message types including the short-ID. Keep this in the same order as the list of\n  * messages above and in protocol.h.\n  */\n-const static std::string allNetMessageTypes[] = {\n-    NetMsgType::VERSION,\n-    NetMsgType::VERACK,\n-    NetMsgType::ADDR,\n-    NetMsgType::ADDRV2,\n-    NetMsgType::SENDADDRV2,\n-    NetMsgType::INV,\n-    NetMsgType::GETDATA,\n-    NetMsgType::MERKLEBLOCK,\n-    NetMsgType::GETBLOCKS,\n-    NetMsgType::GETHEADERS,\n-    NetMsgType::TX,\n-    NetMsgType::HEADERS,\n-    NetMsgType::BLOCK,\n-    NetMsgType::GETADDR,\n-    NetMsgType::MEMPOOL,\n-    NetMsgType::PING,\n-    NetMsgType::PONG,\n-    NetMsgType::NOTFOUND,\n-    NetMsgType::FILTERLOAD,\n-    NetMsgType::FILTERADD,\n-    NetMsgType::FILTERCLEAR,\n-    NetMsgType::SENDHEADERS,\n-    NetMsgType::FEEFILTER,\n-    NetMsgType::SENDCMPCT,\n-    NetMsgType::CMPCTBLOCK,\n-    NetMsgType::GETBLOCKTXN,\n-    NetMsgType::BLOCKTXN,\n-    NetMsgType::GETCFILTERS,\n-    NetMsgType::CFILTER,\n-    NetMsgType::GETCFHEADERS,\n-    NetMsgType::CFHEADERS,\n-    NetMsgType::GETCFCHECKPT,\n-    NetMsgType::CFCHECKPT,\n-    NetMsgType::WTXIDRELAY,\n+const static std::map<uint8_t, std::string> allNetMessageTypes = {\n+    {38, NetMsgType::VERSION},\n+    {37, NetMsgType::VERACK},\n+    {13, NetMsgType::ADDR},\n+    {46, NetMsgType::ADDRV2},\n+    {47, NetMsgType::SENDADDRV2},\n+    {27, NetMsgType::INV},\n+    {24, NetMsgType::GETDATA},\n+    {29, NetMsgType::MERKLEBLOCK},\n+    {22, NetMsgType::GETBLOCKS},\n+    {25, NetMsgType::GETHEADERS},\n+    {36, NetMsgType::TX},\n+    {26, NetMsgType::HEADERS},\n+    {14, NetMsgType::BLOCK},\n+    {21, NetMsgType::GETADDR},\n+    {28, NetMsgType::MEMPOOL},\n+    {31, NetMsgType::PING},\n+    {32, NetMsgType::PONG},\n+    {30, NetMsgType::NOTFOUND},\n+    {20, NetMsgType::FILTERLOAD},\n+    {18, NetMsgType::FILTERADD},\n+    {19, NetMsgType::FILTERCLEAR},\n+    {35, NetMsgType::SENDHEADERS},\n+    {17, NetMsgType::FEEFILTER},\n+    {34, NetMsgType::SENDCMPCT},\n+    {16, NetMsgType::CMPCTBLOCK},\n+    {23, NetMsgType::GETBLOCKTXN},\n+    {15, NetMsgType::BLOCKTXN},\n+    {39, NetMsgType::GETCFILTERS},\n+    {40, NetMsgType::CFILTER},\n+    {41, NetMsgType::GETCFHEADERS},\n+    {42, NetMsgType::CFHEADERS},\n+    {43, NetMsgType::GETCFCHECKPT},\n+    {44, NetMsgType::CFCHECKPT},\n+    {45, NetMsgType::WTXIDRELAY}\n };\n-const static std::vector<std::string> allNetMessageTypesVec(allNetMessageTypes, allNetMessageTypes+ARRAYLEN(allNetMessageTypes));\n \n CMessageHeader::CMessageHeader()\n {\n@@ -187,9 +186,9 @@ std::string CInv::ToString() const\n     }\n }\n \n-const std::vector<std::string> &getAllNetMessageTypes()\n+const std::map<uint8_t, std::string> &getAllNetMessageTypes()\n {\n-    return allNetMessageTypesVec;\n+    return allNetMessageTypes;\n }\n \n /**\n@@ -236,3 +235,23 @@ GenTxid ToGenTxid(const CInv& inv)\n     assert(inv.IsGenTxMsg());\n     return {inv.IsMsgWtx(), inv.hash};\n }\n+\n+Optional<uint8_t> GetShortCommandIDFromCommand(const std::string& cmd)\n+{\n+    for (const std::pair<uint8_t, std::string> entry : allNetMessageTypes) {\n+        if (entry.second == cmd) {\n+            return entry.first;\n+        }\n+    }\n+    return {};\n+}\n+\n+bool GetCommandFromShortCommandID(uint8_t shortID, std::string& cmd)\n+{\n+    auto it = allNetMessageTypes.find(shortID);\n+    if (it != allNetMessageTypes.end()) {\n+        cmd = it->second;\n+        return true;\n+    }\n+    return false;\n+}"
      },
      {
        "sha": "e0fbc10ee6096aefc2475f998370d5108f1a1d66",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 12,
        "deletions": 1,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/88e2c3f84efe2c74cae95b20101beb90f8ef0e5a/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/88e2c3f84efe2c74cae95b20101beb90f8ef0e5a/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=88e2c3f84efe2c74cae95b20101beb90f8ef0e5a",
        "patch": "@@ -11,6 +11,7 @@\n #define BITCOIN_PROTOCOL_H\n \n #include <netaddress.h>\n+#include <optional.h>\n #include <primitives/transaction.h>\n #include <serialize.h>\n #include <uint256.h>\n@@ -263,7 +264,17 @@ extern const char* WTXIDRELAY;\n }; // namespace NetMsgType\n \n /* Get a vector of all valid message types (see above) */\n-const std::vector<std::string>& getAllNetMessageTypes();\n+const std::map<uint8_t, std::string>& getAllNetMessageTypes();\n+\n+/** Short Command IDs are a low bandwidth representations of a message type\n+ *   The mapping is a peer to peer agreement\n+ *\n+ *   returns the short command ID for a command (if command has a short ID) */\n+Optional<uint8_t> GetShortCommandIDFromCommand(const std::string& cmd);\n+\n+/** returns the command (string) from a short command ID\n+ * returns an empty string if short command ID has not been found */\n+bool GetCommandFromShortCommandID(uint8_t shortID, std::string& cmd);\n \n /** nServices flags */\n enum ServiceFlags : uint64_t {"
      }
    ]
  },
  {
    "sha": "7ea1831ce01cc3b60df278e34ca7e27baf7eb645",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZWExODMxY2UwMWNjM2I2MGRmMjc4ZTM0Y2E3ZTI3YmFmN2ViNjQ1",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2020-03-02T13:30:45Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2021-01-20T09:15:37Z"
      },
      "message": "Add BIP324 v2 transport serializer and deserializer",
      "tree": {
        "sha": "e7b5f481d88b8e2c73b9652a9a9b31e337213a02",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e7b5f481d88b8e2c73b9652a9a9b31e337213a02"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7ea1831ce01cc3b60df278e34ca7e27baf7eb645",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7ea1831ce01cc3b60df278e34ca7e27baf7eb645",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7ea1831ce01cc3b60df278e34ca7e27baf7eb645",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7ea1831ce01cc3b60df278e34ca7e27baf7eb645/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "88e2c3f84efe2c74cae95b20101beb90f8ef0e5a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/88e2c3f84efe2c74cae95b20101beb90f8ef0e5a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/88e2c3f84efe2c74cae95b20101beb90f8ef0e5a"
      }
    ],
    "stats": {
      "total": 230,
      "additions": 230,
      "deletions": 0
    },
    "files": [
      {
        "sha": "57f5e9eb81b863a3cdf4a137258cbbc07595e7f8",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 160,
        "deletions": 0,
        "changes": 160,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7ea1831ce01cc3b60df278e34ca7e27baf7eb645/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7ea1831ce01cc3b60df278e34ca7e27baf7eb645/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=7ea1831ce01cc3b60df278e34ca7e27baf7eb645",
        "patch": "@@ -21,6 +21,7 @@\n #include <random.h>\n #include <scheduler.h>\n #include <util/strencodings.h>\n+#include <util/string.h>\n #include <util/translation.h>\n \n #ifdef WIN32\n@@ -101,6 +102,8 @@ const std::string NET_MESSAGE_COMMAND_OTHER = \"*other*\";\n static const uint64_t RANDOMIZER_ID_NETGROUP = 0x6c0edd8036ef4036ULL; // SHA256(\"netgroup\")[0:8]\n static const uint64_t RANDOMIZER_ID_LOCALHOSTNONCE = 0xd93e69e2bbfa5735ULL; // SHA256(\"localhostnonce\")[0:8]\n static const uint64_t RANDOMIZER_ID_ADDRCACHE = 0x1cf2e4ddd306dda9ULL; // SHA256(\"addrcache\")[0:8]\n+\n+static constexpr uint8_t NET_P2P_V2_CMD_MAX_CHARS_SIZE = 12; //maximal length for V2 (BIP324) string message commands\n //\n // Global state variables\n //\n@@ -767,6 +770,163 @@ Optional<CNetMessage> V1TransportDeserializer::GetMessage(const std::chrono::mic\n     return msg;\n }\n \n+int V2TransportDeserializer::readHeader(Span<const uint8_t> msg_bytes) {\n+    // copy data to temporary parsing buffer\n+    const unsigned int remaining = CHACHA20_POLY1305_AEAD_AAD_LEN - m_hdr_pos;\n+    const unsigned int copy_bytes = std::min<unsigned int>(remaining, msg_bytes.size());\n+\n+    memcpy(&vRecv[m_hdr_pos], msg_bytes.data(), copy_bytes);\n+    m_hdr_pos += copy_bytes;\n+\n+    // if AAD incomplete, exit\n+    if (m_hdr_pos < CHACHA20_POLY1305_AEAD_AAD_LEN) {\n+        return copy_bytes;\n+    }\n+\n+    // we got the AAD bytes at this point (3 bytes encrypted packet length)\n+    // we keep the sequence numbers unchanged at this point. Once the message is authenticated and decrypted, we increase the sequence numbers (or the aad_pos)\n+    if (!m_aead->DecryptLength(&m_message_size, (const uint8_t*)vRecv.data())) {\n+        return -1;\n+    }\n+\n+    // reject messages larger than MAX_SIZE\n+    if (m_message_size > MAX_SIZE) {\n+        return -1;\n+    }\n+\n+    // switch state to reading message data\n+    m_in_data = true;\n+\n+    return copy_bytes;\n+}\n+int V2TransportDeserializer::readData(Span<const uint8_t> msg_bytes) {\n+    // Read the message data (command, payload & MAC)\n+    const unsigned int remaining = m_message_size + CHACHA20_POLY1305_AEAD_TAG_LEN - m_data_pos;\n+    const unsigned int copy_bytes = std::min<unsigned int>(remaining, msg_bytes.size());\n+\n+    // extend buffer, respect previous copied AAD part\n+    if (vRecv.size() < CHACHA20_POLY1305_AEAD_AAD_LEN + m_data_pos + copy_bytes) {\n+        // Allocate up to 256 KiB ahead, but never more than the total message size (incl. AAD & TAG).\n+        vRecv.resize(std::min(CHACHA20_POLY1305_AEAD_AAD_LEN + m_message_size + CHACHA20_POLY1305_AEAD_TAG_LEN, CHACHA20_POLY1305_AEAD_AAD_LEN + m_data_pos + copy_bytes + 256 * 1024 + CHACHA20_POLY1305_AEAD_TAG_LEN));\n+    }\n+\n+    memcpy(&vRecv[CHACHA20_POLY1305_AEAD_AAD_LEN + m_data_pos], msg_bytes.data(), copy_bytes);\n+    m_data_pos += copy_bytes;\n+\n+    return copy_bytes;\n+}\n+\n+Optional<CNetMessage> V2TransportDeserializer::GetMessage(std::chrono::microseconds time, uint32_t& out_err_raw_size)\n+{\n+    // In v2, vRecv contains the encrypted payload plus the MAC tag (1+bytes serialized message command + ? bytes message payload + 16 byte mac tag)\n+    assert(Complete());\n+\n+    // defensive decoding (MAC check, decryption, command deserialization)\n+    // we'll always return a CNetMessage (even if decryption fails), we always increase the AEAD sequence numbers\n+    bool valid_checksum = false;\n+    bool valid_header = false;\n+    std::string command_name;\n+\n+    if (m_aead->Crypt((unsigned char*)vRecv.data(), vRecv.size(), (const uint8_t*)vRecv.data(), vRecv.size(), false)) {\n+        // MAC check was successful\n+        valid_checksum = true;\n+\n+        // okay, we could decrypt it, now remove packet length and MAC tag\n+        assert(vRecv.size() > CHACHA20_POLY1305_AEAD_AAD_LEN + CHACHA20_POLY1305_AEAD_TAG_LEN);\n+        // CDataStream::erase at the begin will just increase the read pos\n+        vRecv.erase(vRecv.begin(), vRecv.begin() + CHACHA20_POLY1305_AEAD_AAD_LEN);\n+        vRecv.erase(vRecv.end() - CHACHA20_POLY1305_AEAD_TAG_LEN, vRecv.end());\n+\n+        uint8_t size_or_shortid = 0;\n+        try {\n+            vRecv >> size_or_shortid;\n+        } catch (const std::ios_base::failure&) {\n+            LogPrint(BCLog::NET, \"Invalid command name\\n\");\n+        }\n+        valid_header = true;\n+        if (size_or_shortid > 0 && size_or_shortid <= NET_P2P_V2_CMD_MAX_CHARS_SIZE && vRecv.size() >= size_or_shortid) {\n+            // first byte is a number between 1 and 12. Must be a string command.\n+            // use direct read since we already read the varlens size uint8_t\n+            command_name.resize(size_or_shortid);\n+            vRecv.read(&command_name[0], size_or_shortid);\n+        } else {\n+            // try for short ID in case the first byte is a number larger than 12\n+            if (!GetCommandFromShortCommandID(size_or_shortid, command_name)) {\n+                // unknown-short-id\n+                // results in a valid but unknown message (will be skipped)\n+                command_name = \"unknown-\" + ToString(size_or_shortid);\n+            }\n+        }\n+    }\n+    if (!valid_header) {\n+        LogPrint(BCLog::NET, \"PACKAGE FORMAT ERROR, peer=%d\\n\", m_node_id);\n+        Reset();\n+        return nullopt;\n+    }\n+    else if (!valid_checksum) {\n+        LogPrint(BCLog::NET, \"DECRYPTION INVALID MAC, peer=%d\\n\", m_node_id);\n+        Reset();\n+        return nullopt;\n+    }\n+\n+    // decompose a single CNetMessage from the TransportDeserializer\n+    Optional<CNetMessage> msg(std::move(vRecv)); // result in a message with CDataStream with readpos pointing to the message payload\n+    msg->m_command = command_name;\n+\n+    // store command string, payload size, wire message size\n+    msg->m_message_size = msg->m_recv.size();                                                                    //message payload size (excluding command)\n+    msg->m_raw_message_size = CHACHA20_POLY1305_AEAD_AAD_LEN + m_message_size + CHACHA20_POLY1305_AEAD_TAG_LEN; // raw wire size\n+\n+    // store receive time\n+    msg->m_time = time;\n+\n+    Reset();\n+    return msg;\n+}\n+\n+void V2TransportSerializer::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header)\n+{\n+    size_t serialized_command_size = 1; // short-IDs are 1 byte\n+    Optional<uint8_t> cmd_short_id = GetShortCommandIDFromCommand(msg.m_type);\n+    if (!cmd_short_id) {\n+        // message command without an assigned short-ID\n+        assert(msg.m_type.size() <= NET_P2P_V2_CMD_MAX_CHARS_SIZE);\n+        // encode as varstr, max 12 chars\n+        serialized_command_size = ::GetSerializeSize(msg.m_type, PROTOCOL_VERSION);\n+    }\n+    // prepare the packet length that will later be encrypted and part of the MAC (AD)\n+    // the packet length excludes the 16 byte MAC tag\n+    uint32_t packet_length = serialized_command_size + msg.data.size();\n+\n+    // prepare the packet length & message command and reserve 4 bytes (3bytes AAD + 1byte short-ID)\n+    std::vector<unsigned char> serialized_header(CHACHA20_POLY1305_AEAD_AAD_LEN + 1);\n+    // LE serialize the 24bits length\n+    // we do \"manually\" encode this since there is no helper for 24bit serialization\n+    packet_length = htole32(packet_length);\n+    memcpy(serialized_header.data(), &packet_length, 3);\n+\n+    // append the short-ID or (eventually) the varstr of the command\n+    CVectorWriter vector_writer(SER_NETWORK, INIT_PROTO_VERSION, serialized_header, 3);\n+    if (cmd_short_id) {\n+        // append the single byte short ID...\n+        vector_writer << cmd_short_id.value();\n+    } else {\n+        // or the ASCII command string\n+        vector_writer << msg.m_type;\n+    }\n+\n+    // insert header directly into the CSerializedNetMsg data buffer (insert at begin)\n+    // TODO: if we refactor the ChaCha20Poly1350 crypt function to allow separate buffers for\n+    //       the AD, payload and MAC, we could avoid a insert and thus a potential reallocation\n+    msg.data.insert(msg.data.begin(), serialized_header.begin(), serialized_header.end());\n+\n+    // resize the message buffer to make space for the MAC tag\n+    msg.data.resize(msg.data.size() + CHACHA20_POLY1305_AEAD_TAG_LEN, 0);\n+\n+    // encrypt the payload, ignore return code since it can't fail in this case (controlled buffers, don't check the MAC during encrypting)\n+    m_aead->Crypt(msg.data.data(), msg.data.size(), msg.data.data(), msg.data.size() - CHACHA20_POLY1305_AEAD_TAG_LEN, true);\n+}\n+\n void V1TransportSerializer::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) {\n     // create dbl-sha256 checksum\n     uint256 hash = Hash(msg.data);"
      },
      {
        "sha": "0ca3283b77a40b9be96931cf999808057ca26507",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 70,
        "deletions": 0,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7ea1831ce01cc3b60df278e34ca7e27baf7eb645/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7ea1831ce01cc3b60df278e34ca7e27baf7eb645/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=7ea1831ce01cc3b60df278e34ca7e27baf7eb645",
        "patch": "@@ -12,8 +12,10 @@\n #include <bloom.h>\n #include <chainparams.h>\n #include <compat.h>\n+#include <crypto/chacha_poly_aead.h>\n #include <crypto/siphash.h>\n #include <hash.h>\n+#include <key.h>\n #include <net_permissions.h>\n #include <netaddress.h>\n #include <optional.h>\n@@ -370,6 +372,59 @@ class V1TransportDeserializer final : public TransportDeserializer\n     Optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err_raw_size) override;\n };\n \n+/** V2TransportDeserializer is a transport deserializer after BIP324 */\n+class V2TransportDeserializer final : public TransportDeserializer\n+{\n+private:\n+    std::unique_ptr<ChaCha20Poly1305AEAD> m_aead;\n+    const NodeId m_node_id;       // Only for logging\n+    bool m_in_data = false;       // parsing header (false) or data (true)\n+    uint32_t m_message_size = 0;  // expected message size\n+    CDataStream vRecv;            // received message data\n+    unsigned int m_hdr_pos = 0;   // read pos in header\n+    unsigned int m_data_pos = 0;  // read pos in data\n+\n+public:\n+    V2TransportDeserializer(const NodeId node_id, const CPrivKey& k1, const CPrivKey& k2) : m_aead(new ChaCha20Poly1305AEAD(k1.data(), k1.size(), k2.data(), k2.size())), m_node_id(node_id), vRecv(SER_NETWORK, INIT_PROTO_VERSION)\n+    {\n+        Reset();\n+    }\n+\n+    void Reset()\n+    {\n+        vRecv.clear();\n+        vRecv.resize(CHACHA20_POLY1305_AEAD_AAD_LEN);\n+        m_in_data = false;\n+        m_hdr_pos = 0;\n+        m_message_size = 0;\n+        m_data_pos = 0;\n+    }\n+    bool Complete() const override\n+    {\n+        if (!m_in_data) {\n+            return false;\n+        }\n+        return (m_message_size + CHACHA20_POLY1305_AEAD_TAG_LEN == m_data_pos);\n+    }\n+    void SetVersion(int nVersionIn) override\n+    {\n+        vRecv.SetVersion(nVersionIn);\n+    }\n+    int readHeader(Span<const uint8_t> msg_bytes);\n+    int readData(Span<const uint8_t> msg_bytes);\n+    int Read(Span<const uint8_t>& msg_bytes) override\n+    {\n+        int ret = m_in_data ? readData(msg_bytes) : readHeader(msg_bytes);\n+        if (ret < 0) {\n+            Reset();\n+        } else {\n+            msg_bytes = msg_bytes.subspan(ret);\n+        }\n+        return ret;\n+    }\n+    Optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err_raw_size) override;\n+};\n+\n /** The TransportSerializer prepares messages for the network transport\n  */\n class TransportSerializer {\n@@ -384,6 +439,21 @@ class V1TransportSerializer  : public TransportSerializer {\n     void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) override;\n };\n \n+class V2TransportSerializer : public TransportSerializer\n+{\n+private:\n+    std::unique_ptr<ChaCha20Poly1305AEAD> m_aead;\n+    CPrivKey m_aead_k1; //keep the keys for a later rekeying\n+    CPrivKey m_aead_k2;\n+\n+public:\n+    V2TransportSerializer(const CPrivKey& k1, const CPrivKey& k2) : m_aead(new ChaCha20Poly1305AEAD(k1.data(), k1.size(), k2.data(), k2.size())), m_aead_k1(k1), m_aead_k2(k2)\n+    {\n+    }\n+    // prepare for next message\n+    void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) override;\n+};\n+\n /** Information about a peer */\n class CNode\n {"
      }
    ]
  },
  {
    "sha": "645d70eb276f3bb96ef7108205f63cbac0640595",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NDVkNzBlYjI3NmYzYmI5NmVmNzEwODIwNWY2M2NiYWMwNjQwNTk1",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2020-03-02T12:53:06Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2021-01-20T09:15:53Z"
      },
      "message": "Add p2p network v2 serializer/deserializer unit tests\n\n# Conflicts:\n#\tsrc/test/net_tests.cpp",
      "tree": {
        "sha": "8c0a2688c35ca7c256f025c2e001062eec106faf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8c0a2688c35ca7c256f025c2e001062eec106faf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/645d70eb276f3bb96ef7108205f63cbac0640595",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/645d70eb276f3bb96ef7108205f63cbac0640595",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/645d70eb276f3bb96ef7108205f63cbac0640595",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/645d70eb276f3bb96ef7108205f63cbac0640595/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7ea1831ce01cc3b60df278e34ca7e27baf7eb645",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7ea1831ce01cc3b60df278e34ca7e27baf7eb645",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7ea1831ce01cc3b60df278e34ca7e27baf7eb645"
      }
    ],
    "stats": {
      "total": 80,
      "additions": 80,
      "deletions": 0
    },
    "files": [
      {
        "sha": "0abd1d3e063f4a8742d5433e91139ceae3a3f3e2",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 80,
        "deletions": 0,
        "changes": 80,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/645d70eb276f3bb96ef7108205f63cbac0640595/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/645d70eb276f3bb96ef7108205f63cbac0640595/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=645d70eb276f3bb96ef7108205f63cbac0640595",
        "patch": "@@ -9,6 +9,7 @@\n #include <cstdint>\n #include <net.h>\n #include <netbase.h>\n+#include <netmessagemaker.h>\n #include <optional.h>\n #include <serialize.h>\n #include <span.h>\n@@ -929,4 +930,83 @@ BOOST_AUTO_TEST_CASE(node_eviction_test)\n     }\n }\n \n+void message_serialize_deserialize_test(bool v2, const std::vector<CSerializedNetMsg>& test_msgs)\n+{\n+    // use 32 byte keys with all zeros\n+    CPrivKey k1(32, 0);\n+    CPrivKey k2(32, 0);\n+\n+    // construct the serializers\n+    std::unique_ptr<TransportSerializer> serializer;\n+    std::unique_ptr<TransportDeserializer> deserializer;\n+\n+    if (v2) {\n+        serializer = MakeUnique<V2TransportSerializer>(V2TransportSerializer(k1, k2));\n+        deserializer = MakeUnique<V2TransportDeserializer>(V2TransportDeserializer((NodeId)0, k1, k2));\n+    } else {\n+        serializer = MakeUnique<V1TransportSerializer>(V1TransportSerializer());\n+        deserializer = MakeUnique<V1TransportDeserializer>(V1TransportDeserializer(Params(), (NodeId)0, SER_NETWORK, INIT_PROTO_VERSION));\n+    }\n+    // run a couple of times through all messages with the same AEAD instance\n+    for (unsigned int i = 0; i < 100; i++) {\n+        for (const CSerializedNetMsg& msg_orig : test_msgs) {\n+            // bypass the copy protection\n+            CSerializedNetMsg msg;\n+            msg.data = msg_orig.data;\n+            msg.m_type = msg_orig.m_type;\n+            size_t raw_msg_size = msg.data.size();\n+\n+            std::vector<unsigned char> serialized_header;\n+            serializer->prepareForTransport(msg, serialized_header);\n+\n+            // read two times\n+            //  first: read header\n+            size_t read_bytes = 0;\n+            Span<const uint8_t> span_header(serialized_header.data(), serialized_header.size());\n+            if (serialized_header.size() > 0) read_bytes += deserializer->Read(span_header);\n+            //  second: read the encrypted payload (if required)\n+            Span<const uint8_t> span_msg(msg.data.data(), msg.data.size());\n+            if (msg.data.size() > 0) read_bytes += deserializer->Read(span_msg);\n+            if (msg.data.size() > read_bytes && msg.data.size() - read_bytes > 0) {\n+                Span<const uint8_t> span_msg(msg.data.data() + read_bytes, msg.data.size() - read_bytes);\n+                read_bytes += deserializer->Read(span_msg);\n+            }\n+            BOOST_CHECK(deserializer->Complete());\n+            BOOST_CHECK_EQUAL(read_bytes, msg.data.size() + serialized_header.size());\n+            // message must be complete\n+            uint32_t out_err_raw_size{0};\n+            Optional<CNetMessage> result{deserializer->GetMessage(GetTime<std::chrono::microseconds>(), out_err_raw_size)};\n+            BOOST_CHECK_EQUAL(result->m_command, msg.m_type);\n+            BOOST_CHECK_EQUAL(raw_msg_size, result->m_message_size);\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(net_v2)\n+{\n+    // create some messages where we perform serialization and deserialization\n+    std::vector<CSerializedNetMsg> test_msgs;\n+    test_msgs.push_back(CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERACK));\n+    test_msgs.push_back(CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERSION, PROTOCOL_VERSION, (int)NODE_NETWORK, 123, CAddress(CService(), NODE_NONE), CAddress(CService(), NODE_NONE), 123, \"foobar\", 500000, true));\n+    test_msgs.push_back(CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::PING, 123456));\n+    CDataStream stream(ParseHex(\"020000000001013107ca31e1950a9b44b75ce3e8f30127e4d823ed8add1263a1cc8adcc8e49164000000001716001487835ecf51ea0351ef266d216a7e7a3e74b84b4efeffffff02082268590000000017a9144a94391b99e672b03f56d3f60800ef28bc304c4f8700ca9a3b0000000017a9146d5df9e79f752e3c53fc468db89cafda4f7d00cb87024730440220677de5b11a5617d541ba06a1fa5921ab6b4509f8028b23f18ab8c01c5eb1fcfb02202fe382e6e87653f60ff157aeb3a18fc888736720f27ced546b0b77431edabdb0012102608c772598e9645933a86bcd662a3b939e02fb3e77966c9713db5648d5ba8a0006010000\"), SER_NETWORK, PROTOCOL_VERSION);\n+    test_msgs.push_back(CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::TX, CTransaction(deserialize, stream)));\n+    std::vector<CInv> vInv;\n+    for (unsigned int i = 0; i < 1000; i++) {\n+        vInv.push_back(CInv(MSG_BLOCK, Params().GenesisBlock().GetHash()));\n+    }\n+    test_msgs.push_back(CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::INV, vInv));\n+\n+    // add a dummy message\n+    std::string dummy;\n+    for (unsigned int i = 0; i < 100; i++) {\n+        dummy += \"020000000001013107ca31e1950a9b44b75ce3e8f30127e4d823ed8add1263a1cc8adcc8e49164000000001716001487835ecf51ea0351ef266d216a7e7a3e74b84b4efeffffff02082268590000000017a9144a94391b99e672b03f56d3f60800ef28bc304c4f8700ca9a3b0000000017a9146d5df9e79f752e3c53fc468db89cafda4f7d00cb87024730440220677de5b11a5617d541ba06a1fa5921ab6b4509f8028b23f18ab8c01c5eb1fcfb02202fe382e6e87653f60ff157aeb3a18fc888736720f27ced546b0b77431edabdb0012102608c772598e9645933a86bcd662a3b939e02fb3e77966c9713db5648d5ba8a0006010000\";\n+    }\n+    test_msgs.push_back(CNetMsgMaker(INIT_PROTO_VERSION).Make(\"foobar\", dummy));\n+\n+    message_serialize_deserialize_test(true, test_msgs);\n+    message_serialize_deserialize_test(false, test_msgs);\n+}\n+\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "4fbf5c9f7e3715352f3c4f390da83fb911c65f07",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ZmJmNWM5ZjdlMzcxNTM1MmYzYzRmMzkwZGE4M2ZiOTExYzY1ZjA3",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2020-03-02T14:52:09Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2021-01-20T09:23:26Z"
      },
      "message": "Fuzzing: extend the p2p_transport_deserializer fuzz-test to cover v2 transport",
      "tree": {
        "sha": "8caeafdd54b4e73e886a994836f53b7a2b9aa706",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8caeafdd54b4e73e886a994836f53b7a2b9aa706"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4fbf5c9f7e3715352f3c4f390da83fb911c65f07",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4fbf5c9f7e3715352f3c4f390da83fb911c65f07",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4fbf5c9f7e3715352f3c4f390da83fb911c65f07",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4fbf5c9f7e3715352f3c4f390da83fb911c65f07/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "645d70eb276f3bb96ef7108205f63cbac0640595",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/645d70eb276f3bb96ef7108205f63cbac0640595",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/645d70eb276f3bb96ef7108205f63cbac0640595"
      }
    ],
    "stats": {
      "total": 30,
      "additions": 20,
      "deletions": 10
    },
    "files": [
      {
        "sha": "18dab03a740ccff808c696ff26953c8a0b090a2c",
        "filename": "src/test/fuzz/p2p_transport_deserializer.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 10,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4fbf5c9f7e3715352f3c4f390da83fb911c65f07/src/test/fuzz/p2p_transport_deserializer.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4fbf5c9f7e3715352f3c4f390da83fb911c65f07/src/test/fuzz/p2p_transport_deserializer.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/p2p_transport_deserializer.cpp?ref=4fbf5c9f7e3715352f3c4f390da83fb911c65f07",
        "patch": "@@ -17,26 +17,36 @@ void initialize_p2p_transport_deserializer()\n     SelectParams(CBaseChainParams::REGTEST);\n }\n \n-FUZZ_TARGET_INIT(p2p_transport_deserializer, initialize_p2p_transport_deserializer)\n-{\n-    // Construct deserializer, with a dummy NodeId\n-    V1TransportDeserializer deserializer{Params(), (NodeId)0, SER_NETWORK, INIT_PROTO_VERSION};\n-    Span<const uint8_t> msg_bytes{buffer};\n+void test_deserializer(std::unique_ptr<TransportDeserializer>& deserializer, Span<const uint8_t> msg_bytes, const int header_size) {\n+    size_t original_size = msg_bytes.size();\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n+        const int handled = deserializer->Read(msg_bytes);\n         if (handled < 0) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (deserializer->Complete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             uint32_t out_err_raw_size{0};\n-            Optional<CNetMessage> result{deserializer.GetMessage(m_time, out_err_raw_size)};\n+            Optional<CNetMessage> result{deserializer->GetMessage(m_time, out_err_raw_size)};\n             if (result) {\n                 assert(result->m_command.size() <= CMessageHeader::COMMAND_SIZE);\n-                assert(result->m_raw_message_size <= buffer.size());\n-                assert(result->m_raw_message_size == CMessageHeader::HEADER_SIZE + result->m_message_size);\n+                assert(result->m_raw_message_size <= original_size);\n+                assert(result->m_raw_message_size == header_size + result->m_message_size);\n                 assert(result->m_time == m_time);\n             }\n         }\n     }\n }\n+FUZZ_TARGET_INIT(p2p_transport_deserializer, initialize_p2p_transport_deserializer)\n+{\n+    // Construct deserializer, with a dummy NodeId\n+    std::unique_ptr<TransportDeserializer> v1_deserializer = MakeUnique<V1TransportDeserializer>(Params(), (NodeId)0, SER_NETWORK, INIT_PROTO_VERSION);\n+    Span<const uint8_t> msg_bytes_v1{buffer};\n+    test_deserializer(v1_deserializer, msg_bytes_v1, CMessageHeader::HEADER_SIZE);\n+\n+    const CPrivKey k1(32, 0);\n+    const CPrivKey k2(32, 0);\n+    Span<const uint8_t> msg_bytes_v2{buffer};\n+    std::unique_ptr<TransportDeserializer> v2_deserializer = MakeUnique<V2TransportDeserializer>(V2TransportDeserializer((NodeId)0, k1, k2));\n+    test_deserializer(v2_deserializer, msg_bytes_v2, CHACHA20_POLY1305_AEAD_AAD_LEN + CHACHA20_POLY1305_AEAD_TAG_LEN);\n+}"
      }
    ]
  },
  {
    "sha": "9e81bc49b1de0e084fdc7baeb48bb39b8550ca89",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZTgxYmM0OWIxZGUwZTA4NGZkYzdiYWViNDhiYjM5Yjg1NTBjYTg5",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2020-11-02T10:54:55Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2021-01-20T09:23:28Z"
      },
      "message": "Fix: deduct message header if MAC-check/decryption failed\n\nIn order to conform to the TransportDeserializer protocol, we need to reduce the header from the messge size\n\n# Conflicts:\n#\tsrc/net.cpp",
      "tree": {
        "sha": "88f16b53f8a3e6a7dba78ff3d4331239ea2204a9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/88f16b53f8a3e6a7dba78ff3d4331239ea2204a9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9e81bc49b1de0e084fdc7baeb48bb39b8550ca89",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9e81bc49b1de0e084fdc7baeb48bb39b8550ca89",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9e81bc49b1de0e084fdc7baeb48bb39b8550ca89",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9e81bc49b1de0e084fdc7baeb48bb39b8550ca89/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4fbf5c9f7e3715352f3c4f390da83fb911c65f07",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4fbf5c9f7e3715352f3c4f390da83fb911c65f07",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4fbf5c9f7e3715352f3c4f390da83fb911c65f07"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 4,
      "deletions": 2
    },
    "files": [
      {
        "sha": "ebdc47a8b8762329dcc5ba39052adee753a7fd5d",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e81bc49b1de0e084fdc7baeb48bb39b8550ca89/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e81bc49b1de0e084fdc7baeb48bb39b8550ca89/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=9e81bc49b1de0e084fdc7baeb48bb39b8550ca89",
        "patch": "@@ -873,8 +873,10 @@ Optional<CNetMessage> V2TransportDeserializer::GetMessage(std::chrono::microseco\n     Optional<CNetMessage> msg(std::move(vRecv)); // result in a message with CDataStream with readpos pointing to the message payload\n     msg->m_command = command_name;\n \n-    // store command string, payload size, wire message size\n-    msg->m_message_size = msg->m_recv.size();                                                                    //message payload size (excluding command)\n+    // if we could successfully decrypt the message, the message no longer contains the \"header\" (AAD & MAC)\n+    // if failed to decrypt \u2013 which we tolerate at this point \u2013 we need to reduce the message size by the length of the AAD & MAC\n+    // to conform to the abstract TransportDeserializer protocol\n+    msg->m_message_size = valid_checksum ? msg->m_recv.size() : (msg->m_recv.size() - CHACHA20_POLY1305_AEAD_AAD_LEN - CHACHA20_POLY1305_AEAD_TAG_LEN);\n     msg->m_raw_message_size = CHACHA20_POLY1305_AEAD_AAD_LEN + m_message_size + CHACHA20_POLY1305_AEAD_TAG_LEN; // raw wire size\n \n     // store receive time"
      }
    ]
  }
]