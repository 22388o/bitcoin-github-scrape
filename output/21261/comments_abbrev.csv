DrahtBot,2021-02-22 03:17:19,"<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #21160 (net/net processing: Move tx inventory into net_processing by jnewbery)\n\nIf you consider this pull request import",https://github.com/bitcoin/bitcoin/pull/21261#issuecomment-783026889,783026889,
vasild,2021-02-25 08:18:37,Concept ACK,https://github.com/bitcoin/bitcoin/pull/21261#issuecomment-785710010,785710010,
mzumsande,2021-04-29 23:26:53,"Concept ACK, will review more closely soon.",https://github.com/bitcoin/bitcoin/pull/21261#issuecomment-829668926,829668926,
laanwj,2021-05-10 15:04:35,Concept ACK,https://github.com/bitcoin/bitcoin/pull/21261#issuecomment-836811768,836811768,
jonatack,2021-05-17 12:22:48,"> Approach ACK [4890e2f](https://github.com/bitcoin/bitcoin/commit/4890e2f2fdefaa18b0e96bcaf3691fb3f0213572)\n> \n> Some squashing is warranted.\n\nThanks! Indeed. Re-arranging.",https://github.com/bitcoin/bitcoin/pull/21261#issuecomment-842280881,842280881,
dunxen,2021-06-03 06:40:06,Concept ACK. Will take a closer look later today :),https://github.com/bitcoin/bitcoin/pull/21261#issuecomment-853612805,853612805,
jonatack,2021-06-07 07:05:11,"Thanks for the concept ACKs @mzumsande, @duncandean and @laanwj and the approach ACKs @vasild and @ariard. Now ready for final review. \n\nThis screenshot illustrates the higher latency of I2P peers, which disadvantages them under our inbound eviction criteria even relative to onion peers.\n\n![Screenshot from 2021-06-07 08-56-56](https://user-images.githubusercontent.com/2415484/120973346-544",https://github.com/bitcoin/bitcoin/pull/21261#issuecomment-855652920,855652920,
jonatack,2021-06-11 13:23:35,"Updated per the discussions above and rebased.  The CI failure seems unrelated.  I'm running a node on this branch with `-maxconnections=40`.\n\nEdit: repushed to give the unrelated CI issue another chance.",https://github.com/bitcoin/bitcoin/pull/21261#issuecomment-859579163,859579163,
jonatack,2021-06-12 17:27:08,"Thanks for the feedback @vasild and @ariard. All the feedback taken, will re-push after reworking the tests. ",https://github.com/bitcoin/bitcoin/pull/21261#issuecomment-860083875,860083875,
jonatack,2021-06-13 16:45:51,"Updated, taking all review feedback by @vasild and @ariard, and also improving readability and updating the tests.\n\n`git diff 4253019 a457f34 --color-words`",https://github.com/bitcoin/bitcoin/pull/21261#issuecomment-860239666,860239666,
laanwj,2021-06-14 11:53:32,"I've been running this PR (various versions) on a busy node for the last weeks. Unfortunately this node has a really high `maxconnections` (500, while average number of connected peers is 200) so I just realize I haven't been actually testing the eviction behavior :blush: \n\nIn any case\nCode review (and lightly tested) ACK a457f34e5039b75ee015b273028c3ee153656d5c\nCode review re-ACK 1b1088d5",https://github.com/bitcoin/bitcoin/pull/21261#issuecomment-860624384,860624384,
jonatack,2021-06-14 12:33:53,"Thanks @vasild and @laanwj.  Updated per `git diff a457f34 1b1088d --color-words` for the review suggestion and to add 4 test cases, and updated the PR description to thank/credit @vasild and @ariard.",https://github.com/bitcoin/bitcoin/pull/21261#issuecomment-860648064,860648064,
laanwj,2021-06-14 13:23:32,"> Wow! How long does it take to get up to 200 peers? Mine is restarted a lot but never gets above 35-40.\n\nLast restart was last week, it gets connections quite quickly. Then again it is connected to all possible networks and has had a >99% uptime for a few years. Either that helps or maybe it's just all spy nodes :slightly_smiling_face: \n",https://github.com/bitcoin/bitcoin/pull/21261#issuecomment-860681508,860681508,
vasild,2021-05-03 16:33:42,"Before this PR we would have protected 25% onions. With this PR up to commit 517976187 (inclusive) we would protect 12.5% onions and with the full PR - just 8.3%. What about:\n\n```suggestion\n        const size_t protect_size_per_network{total_protect_size / networks};\n```",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r625210280,625210280,src/net.cpp
vasild,2021-05-03 16:37:09,"These are used as booleans. I would suggest something like:\n\n```cpp\nstruct {\n    bool local{false};\n    bool i2p{false};\n    bool onion{false};\n} networks;\n...\nif (node.m_is_local) {\n    networks.local = true;\n}\n\n// if (networks) becomes:\nif (networks.local || networks.i2p || networks.onion)\n```",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r625212333,625212333,src/net.cpp
vasild,2021-05-03 16:55:49,"Passing multiple booleans like `is_onion`, `is_i2p`, etc is a bit un-flexible and leaves the possibility for contradictions like having both flags set to true. Fuzzing could do that and I expect that there may be (or may be added) some legit assert somewhere in the code to ensure that nonsensical values like `is_onion==true` and `is_i2p==true` are not passed (resulting in an assertion failure duri",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r625223765,625223765,src/net.cpp
jonatack,2021-05-05 11:32:02,"Those are initial (not necessarily final) percentages iff onion, i2p and localhost peers are all present in the eviction candidates. For instance, if no i2p or localhost peers are among the candidats, then the full 25% is made available to onions. And if localhost or i2p peers are present, any initially reserved slots that they don't use are made available for onions. (See the commit messages for ",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r626485716,626485716,src/net.cpp
jonatack,2021-05-05 11:49:35,"It's used to determine the number of networks from which we have disadvantaged candidates (indeed that could be done with bools also, replacing count_if with a sum of each boolean) but I anticipate possibly also using the actual counts to determine the distribution size or order of the protected slots.",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r626495780,626495780,src/net.cpp
jonatack,2021-05-06 21:05:47,"Passing `enum Network`, instead of multiple booleans, indeed allowed rewriting this to be better abstracted and generalizable. WIP, for now the initial rewrite is in an additional commit.",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r627764474,627764474,src/net.cpp
jonatack,2021-05-17 12:26:00,"I played around with a more generous version that would protect more than 1/4 in the case of eviction candidates from multiple disadvantaged networks.  Didn't keep it for now, but memoizing the commit: e5c27dd.",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r633484515,633484515,src/net.cpp
ariard,2021-05-26 19:39:20,"Why you don't pass `k=protect_size_per_network` to `EraseLastKElements` ?\n\nLet's say initial_size=200, total_protect_size=100.\nIf you count two networks, protected_size_per_network=25.\n\nIf the first network does exist, vEvictionCandidates is reduced to 175, total_to_protect increased to 50\nAnd the second network does exist, 50 - 200 - 175, k is equal to 25\n\nIf the first network doe",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r640068051,640068051,src/net.cpp
ariard,2021-05-26 20:26:18,"What would be the purpose of the follow-up you're envisioning ?\n\nAFAIU this current patchset, any unused protected slots across a high-latency network is reallocated to the next one by summing up `protect_size_per_network` and passing through `total_to_protect` ?",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r640096971,640096971,src/net.cpp
jonatack,2021-06-02 21:28:23,You're right. The commit message was out of date. Updated.,https://github.com/bitcoin/bitcoin/pull/21261#discussion_r644332628,644332628,src/net.cpp
jonatack,2021-06-02 21:36:35,"Since the inital number of protected slots per network goes down quickly as the number of networks increases, it seems good to not waste any unused slots in this basic greedy knapsack. So we calculate `peers_to_protect` for each iteration having potential peers to protect, in order to recover any unused slots from the previous iteration.",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r644337039,644337039,src/net.cpp
jonatack,2021-06-02 21:39:32,"Hm, `s/total_to_protect/available_to_protect/`? Edit: done.",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r644338502,644338502,src/net.cpp
vasild,2021-06-08 10:37:37,"_(I needed a pen and paper for this)_\n\nLets assume `initial_size = 100`.\n\nCase 1: `candidates` contains 1 localhost peer, 20 I2P peers and 20 Tor peers. From those, the protected will be: 1 localhost, 15 I2P, 8 Tor.\n\nCase 2: `candidates` contains 0 localhost peers, 20 I2P peers and 20 Tor peers. From those, the protected will be: 12 I2P peers and 12 Tor peers.\n\nCase 2 looks strange",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r647319655,647319655,src/net.cpp
vasild,2021-06-08 10:44:11,"Why ""minimum""? I think that either `protect_size_per_network` or less peers will be protected, so that is a ""maximum"", no?",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r647322855,647322855,src/net.cpp
vasild,2021-06-08 12:57:07,"I find this hard to grasp. Some comments would be nice. For example:\n```cpp\n/**\n * Define an order between NodeEvictionCandidate objects based on network and connection time.\n * Nodes near the beginning are more likely to be disconnected, nodes near the end will be\n * protected (less likely to be disconnected).\n * - First all nodes that do not belong to `network`, among them:\n *   - ",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r647413273,647413273,src/net.cpp
vasild,2021-06-08 13:02:07,"If `network == localhost` and `a.m_is_local == b.m_is_local` then the control flow will continue to the second `if`. I think this is wrong or at least confusing because if this is the localhost comparator (`network == localhost`) then it should not sort based on `m_network`. Here is an example that does not involve passing the constant `localhost` if that makes it easier to understand, feel free t",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r647417447,647417447,src/net.cpp
jonatack,2021-06-08 14:00:59,"Unused slots can be recovered, so the number protected can be higher, and yes, if there are fewer peers of that network, the number protected can be lower. Perhaps s/minimum/initial/. ",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r647471801,647471801,src/net.cpp
jonatack,2021-06-09 06:59:45,"The suggestion is equivalent/does the same thing, assuming the following change is also made to the caller. \n```diff\n-                EraseLastKElements(candidates, CompareNodeNetworkTime(n.id, localhost), peers_to_protect,\n+                EraseLastKElements(candidates, CompareNodeNetworkTime(n.id, n.id == localhost), peers_to_protect,\n```\n",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r648020574,648020574,src/net.cpp
jonatack,2021-06-09 07:20:28,I think the outcome of Case 2 is ideal.  Case 1 protects many I2P peers because that network gets the unused slots from the localhost allocation.  What change would you suggest?  Keep in mind that this is a subcomponent seen in isolation; another 1/4 of the remaining peers will be protected based on their uptime.,https://github.com/bitcoin/bitcoin/pull/21261#discussion_r648033899,648033899,src/net.cpp
jonatack,2021-06-09 08:26:18,"Hm, maybe we can tally the number of networks that have more than `protect_size_per_network` peers and try to share the leftover slots between them so that Case 1 protects 1 / 11 / 12 instead of 1 / 15 / 8.",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r648082182,648082182,src/net.cpp
vasild,2021-06-09 10:21:45,"Right, it can be higher or lower. Neither one of ""minimum"" or ""maximum"" is suitable. `s/minimum/initial/` looks good.",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r648169448,648169448,src/net.cpp
vasild,2021-06-09 10:43:20,">  What change would you suggest?\n\n```cpp\nvoid ProtectEvictionCandidatesByRatio(std::vector<NodeEvictionCandidate>& candidates)\n{\n    // Treat localhost connections as a separate network.\n    static constexpr Network NET_LOCALHOST{NET_MAX};\n\n    const std::array<Network, 3> networks{NET_LOCALHOST, NET_I2P, NET_ONION};\n\n    // Protect the half of the remaining nodes which have b",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r648183294,648183294,src/net.cpp
jonatack,2021-06-09 19:28:26,"This seems like a nice approach, multi-pass with simpler data structures. Will adapt the tests to it to check all the test cases.  Edit: only 4 ""combined"" test cases needed to be updated, and this version does better on those. ",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r648613692,648613692,src/net.cpp
jonatack,2021-06-10 13:35:30,"It looks like we should keep the `Net` struct and `<` sort operator so the result can independent of the order of members in the `networks` array, so a hybrid approach, also adding an `is_local` member to the struct to no longer need `net == localhost` throughout the code.",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r649189169,649189169,src/net.cpp
vasild,2021-06-10 13:54:19,"Yes, with the above snippet, the result may depend on the order of elements in the `networks` array, but only up to 1 which I think it ok - after all, if we want to split evenly e.g. 10 slots among 3 networks, some network will get 4 slots and the rest will get 3 slots.\n\nThe current code also depends on the order in `networks` because it does ""stable"" sort, right?",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r649206111,649206111,src/net.cpp
jonatack,2021-06-10 14:19:47,"The results make more sense when they depend on number of peers by network, e.g. if you have 10 I2P peers and 3 onion ones, best to give first chance at unused slots to the I2P peers so we protect, say, 3 I2P and 2 onions rather than the opposite.  Stable sort only makes a difference if the peer counts are equal. I'll propose this separately in the last commit for feedback.",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r649229635,649229635,src/net.cpp
jonatack,2021-06-10 14:24:14,"What I like is that we focused on different aspects and the combined result seems to provide the best eviction protection, so this is great.",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r649233724,649233724,src/net.cpp
vasild,2021-06-10 14:35:55,"So, if we have 10 I2P peers and 3 onion ones and we want to protect 6 in total, we will protect 3 I2P and 3 onion, this is desired, right?\n\nIf we have again 10 I2P and 3 onion and want to protect 5, do we want to protect 3 I2P and 2 onion or 2 I2P and 3 onion? I am not sure. One may argue that protecting one more (but we are talking about just one here) from the rare network (onion) is better ",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r649244859,649244859,src/net.cpp
jonatack,2021-06-10 14:37:22,Updated to pass an `is_local` bool.,https://github.com/bitcoin/bitcoin/pull/21261#discussion_r649246190,649246190,src/net.cpp
jonatack,2021-06-10 14:39:15,Thanks. This line is now no longer used.,https://github.com/bitcoin/bitcoin/pull/21261#discussion_r649247964,649247964,src/net.cpp
jonatack,2021-06-10 15:11:29,"Yes, this is about tradeoffs. The simplest code was when only a `Network` was passed around all the code without the `is_local` bool everywhere, but that simplicity had a logic encapsulation drawback (perhaps some others), so I rewrote everything and brought back `is_local`. \n\nI've redone this pull several times because I'd like it to do the right thing, whether networks with more peers get fi",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r649277371,649277371,src/net.cpp
jonatack,2021-06-10 15:29:01,"My thought is that having separate protection buckets for each of the disadvantaged networks is the essential step here to improving the diversity of our inbound peer connections...and that unused protection slots should be distributed among disadvantaged networks having remaining eviction candidates by descending order of their count, and in the case of a tie, fall back to the array order.",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r649292684,649292684,src/net.cpp
jonatack,2021-06-10 19:09:44,"Done, added documentation.",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r649452442,649452442,src/net.cpp
vasild,2021-06-11 14:38:58,"_off-topic, please ignore_\n\n```cpp\nif (cond) statement;\n```\nvs\n```cpp\nif (cond) {\n    statement;\n}\n```\n\nPutting everything on one line has 3 disadvantages:\n1. It is not gdb friendly - it is not possible to set a breakpoint on `statement;` - to stop after `cond` and before `statement` (if `cond` was true).\n2. It is not friendly to line-based code coverage - it will show ",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r650032286,650032286,src/net.cpp
vasild,2021-06-11 14:51:38,"This implies that `NET_INTERNAL` has the highest value which may change in the future.\n\n```suggestion\n            /* m_network */ ALL_NETWORKS[random_context.randrange(ALL_NETWORKS.size())],\n```",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r650041974,650041974,src/test/net_peer_eviction_tests.cpp
ariard,2021-06-11 16:49:29,micro-nit: i would prefer `eviction_candidates`,https://github.com/bitcoin/bitcoin/pull/21261#discussion_r650133285,650133285,src/net.cpp
ariard,2021-06-11 17:03:11,"Maybe you can precise onion as ""torv3"" or ""tor"" ? \n\nI think even if Tor is the most well-known deployed onion routing you have multiple other existing onion routing constructions. In fact, I2P's garlic routing is widely similar to Tor's onion routing. Or [Sphinx](https://www.freehaven.net/anonbib/cache/DBLP:conf/sp/DanezisG09.pdf) as deployed on LN communication layer is also a format of onion",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r650141548,650141548,src/net.cpp
jonatack,2021-06-11 17:17:22,"Good point, looks like your suggestion with this might do it:\n```diff\n+++ b/src/test/net_peer_eviction_tests.cpp\n@@ -4,6 +4,7 @@\n #include <net.h>\n+#include <test/util/net.h>\n #include <test/util/setup_common.h>\n \n@@ -32,7 +33,7 @@ std::vector<NodeEvictionCandidate> GetRandomNodeEvictionCandidates(const int n_c\n-            /* m_network */ static_cast<Network>(random_context.rand",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r650149599,650149599,src/test/net_peer_eviction_tests.cpp
ariard,2021-06-11 17:43:22,"IIUC, in the worst-case scenario, at least 1 peer is protected among all the disadvantaged network, the one with the most candidates. \n\nI think that's an interesting property.",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r650164339,650164339,src/net.cpp
ariard,2021-06-11 17:50:00,"nit: to reduce confusion among sets of eviction candidates, maybe called this variable `disadvantaged_to_protect""\n\n`remaining_to_protect` is already used as another variable name at the end of this function.",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r650167989,650167989,src/net.cpp
ariard,2021-06-11 18:01:07,"I think I would favor sorting network by ascending candidate count, otherwise I believe it would bias towards anonymity networks with abundant peers, decreasing our local diversity of anonymity network ?\n\nI think this point has been already discussed in this [thread](https://github.com/bitcoin/bitcoin/pull/21261#discussion_r647319655). I agree it's minor.",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r650174352,650174352,src/net.cpp
ariard,2021-06-11 18:29:41,"Following diff doesn't break `net_peer_eviction_tests`, is this an expected behavior ?\n\n```\n@@ -943,7 +943,7 @@ void ProtectEvictionCandidatesByRatio(std::vector<NodeEvictionCandidate>& candid\n             if (before > after) {\n                 protected_at_least_one = true;\n                 num_protected += before - after;\n-                if (num_protected >= max_protect_by_network",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r650190229,650190229,src/net.cpp
ariard,2021-06-11 18:32:23,"What do you think about commenting the purpose of this variable ?\n\n""If not more eviction candidates remain to protect among disadvantaged networks, ensure we exit cleanly""",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r650191749,650191749,src/net.cpp
jonatack,2021-06-12 17:22:33,Brackets and newlines added,https://github.com/bitcoin/bitcoin/pull/21261#discussion_r650414862,650414862,src/net.cpp
jonatack,2021-06-12 17:22:43,Done.,https://github.com/bitcoin/bitcoin/pull/21261#discussion_r650414880,650414880,src/test/net_peer_eviction_tests.cpp
jonatack,2021-06-12 17:22:48,done,https://github.com/bitcoin/bitcoin/pull/21261#discussion_r650414897,650414897,src/net.cpp
jonatack,2021-06-12 17:22:58,done,https://github.com/bitcoin/bitcoin/pull/21261#discussion_r650414905,650414905,src/net.cpp
jonatack,2021-06-12 17:23:11,"Yes, if there are at least 4 eviction candidates. (Changed per your review feedback from the disadvantaged network with the most candidates to the one with the fewest.)",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r650414941,650414941,src/net.cpp
jonatack,2021-06-12 17:23:16,done,https://github.com/bitcoin/bitcoin/pull/21261#discussion_r650414948,650414948,src/net.cpp
jonatack,2021-06-12 17:23:48,"Done. As the unit tests show, one peer can make a difference when the numbers are low, e.g. when -maxconnections has been reduced or only one candidate will be protected. ",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r650414986,650414986,src/net.cpp
jonatack,2021-06-12 17:24:16,Done.,https://github.com/bitcoin/bitcoin/pull/21261#discussion_r650415002,650415002,src/net.cpp
jonatack,2021-06-12 17:37:49,"Thanks for checking this! Agree, the tests pass with this change:\n```diff\n-                if (num_protected >= max_protect_by_network) {\n+                assert(num_protected <= max_protect_by_network);\n+                if (num_protected == max_protect_by_network) {\n```\nI think it's expected behavior based on these lines:\n```cpp\n    while (num_protected < max_protect_by_network) {",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r650416293,650416293,src/net.cpp
jonatack,2021-06-13 17:18:33,"Huh, the CI is barfing on this change. Strange.",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r650553691,650553691,src/test/net_peer_eviction_tests.cpp
MarcoFalke,2021-06-13 17:43:17,This might be a compiler bug. I used `static constexpr auto ALL_FEE_ESTIMATE_HORIZONS = std::array{` to work around that.,https://github.com/bitcoin/bitcoin/pull/21261#discussion_r650556232,650556232,src/test/net_peer_eviction_tests.cpp
jonatack,2021-06-13 18:16:18,Thanks! Will try that.,https://github.com/bitcoin/bitcoin/pull/21261#discussion_r650559654,650559654,src/test/net_peer_eviction_tests.cpp
jonatack,2021-06-13 21:17:39,It worked 👍,https://github.com/bitcoin/bitcoin/pull/21261#discussion_r650578603,650578603,src/test/net_peer_eviction_tests.cpp
vasild,2021-06-14 10:11:49,"nit: use `true` /  `false` for `bool`:\n\n```suggestion\n    std::array<Net, 3> networks{{{false, NET_I2P, 0}, {/* localhost */ true, NET_MAX, 0}, {false, NET_ONION, 0}}};\n```",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r650818867,650818867,src/net.cpp
jonatack,2021-06-14 11:29:32,"Yeah, I did this to keep the line length down as it's a standard conversion, but sure.",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r650865137,650865137,src/net.cpp
vasild,2021-06-14 11:36:16,"Given that `num_protected` is incremented with a non-constant number, that could be larger than `1`, I assume it could become larger than `max_protect_by_network` at some point. Thus `>=` for comparison instead of `==`.\n\nHow could replacing `>=` with `==` and an assert change anything? I think if it changes anything then it must be a trigger of the assert - if it was equal before, then behavio",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r650869018,650869018,src/net.cpp
jonatack,2021-06-14 11:50:25,"Right, the assert was just for sanity testing (I wrote more tests but didn't find a way to hit the assert), no plan to add it. ",https://github.com/bitcoin/bitcoin/pull/21261#discussion_r650877124,650877124,src/net.cpp
jonatack,2021-06-14 12:04:43,Done.,https://github.com/bitcoin/bitcoin/pull/21261#discussion_r650885978,650885978,src/net.cpp
