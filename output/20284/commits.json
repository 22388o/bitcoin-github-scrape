[
  {
    "sha": "38ada892ed0ed9aaa46b1791db12a371a3c0c419",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozOGFkYTg5MmVkMGVkOWFhYTQ2YjE3OTFkYjEyYTM3MWEzYzBjNDE5",
    "commit": {
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-11-02T10:36:29Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-11-11T15:05:15Z"
      },
      "message": "addrman: ensure old versions don't parse peers.dat\n\nEven though the format of `peers.dat` was changed in an incompatible\nway (old software versions <0.21 cannot understand the new file format),\nit is not guaranteed that old versions will fail to parse it. There is a\nchance that old versions parse its contents as garbage and use it.\n\nOld versions expect the \"key size\" field to be 32 and fail the parsing\nif it is not. Thus, we put something other than 32 in it. This will make\nversions between 0.11.0 and 0.20.1 deterministically fail on the new\nformat. Versions prior to https://github.com/bitcoin/bitcoin/pull/5941\n(<0.11.0) will still parse it as garbage.\n\nAlso, introduce a way to increment the `peers.dat` format in a way that\ndoes not necessary make older versions refuse to read it.",
      "tree": {
        "sha": "873d00ac62228833700af497839f2a65698f5653",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/873d00ac62228833700af497839f2a65698f5653"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/38ada892ed0ed9aaa46b1791db12a371a3c0c419",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAl+r/a0ACgkQVN8G9ktV\ny78DHB/8Dwfk3z+K4lCfLHUCY/wHnaxy6Gg8HWUvG8McUDOvwoh17X1oaeiHDXF/\nDzO01qOQanqWBAAP6rrMOSa6nPMmyZRa0T2zyJS2zmwUxJIgTo8O/utzcw4Q1SXK\nkbck4abK4xaXAD669WJDG0XfY9Y5+glsJ9iUjYWYJSLGXdDibWGp7pqyGpYsw/f2\nFD+HmphfM3FZYeQhoD98ar27+E++AEhA97vCVDSR7wKuHBVdi98zQ84PMGXB/Fcr\nsWdOjCpkZpBo86EKnfGM+vlPKYp9w5uwLuQozGQpixJZR/YYJjikZLH8yY89IgZw\n2IbvRQQLzehbdFUkoQnbkLgKOaxkKr9xJIqTyr0s4frB+/ERL5sMhWoF048XOpil\n7bV0mJ3eBnfoySGDpk9uHcHsYLXja1pv8rY5XTvW55989Brq8D4HsO0tN5YdCLjX\n13ZO6paSlixgU6DvnQAGBk8x4DgB7cEsxAnLFCz3LiAlV32tRNBSb06yogo6Oju/\nXEIgd+GZ5CW8XWyDCzjtXwLFWiDHEFiTwYXr7kA/y0UgLeQxuOQvcQy9IguEkF5y\nzotLGcBVWA80T7X+ws2J5R9XqLQccs+mh/5mYtIOtWPRna8d+9JxGmDXkqDJH4iw\ntfgIpvcYf2YHQOgUk3d//dJ8wZ8hxo/wHRc3UdrFRYnsWzyS2llR1hSX7szVuh6q\nWR0Fa6tOTHSlfaV3X96ky/xusDPxOPeA4tgaZiD3Xt5lwBGLoAH0bOIO2boAX4ao\nZtKlxkPdsRmXwbo5dreeE8WkV86bbeU5krlAnZTs5iqzTnjjPas/jYVmRGVHEFmK\nAEv3X9u91b4bR4oWuLOhKKTyvxyVluq3/zJx39VPe1Ce9hX1zdMGCUkFzvpAjgLj\nTRURZ/AIFhSatT6pNTRwMISrieQnP91sHQ0s4awpGGM3bupPZ9x/LcgTfhryFuQQ\nq0GZwJgfWtfBnwOsjKDq5HSorEzKlfm5N0dYKCYG5SNeSXSDEuH8T7xGAf1o1Y5E\nEDTgXp4H9fCFQIPcJ3ByScyeiguG5YbtoPmveUXamOETGy/ISUMIr/V10iNPM/WU\nk5XAH0iOz+AlR7b0lN2CMIojQkFcVk2ulnhrm2h75bgavyG0v/XwKk7TmWjymBNn\nCZfMA+oThGshZHkiYSXv/XQGCfcHcb8ymH9pkOGb6kCVF1wn0RnfSacvrFBCDA6R\ngqAfb8iGMQw6yU30K4Rq9S6YyWJRCUoB4NTt7m/WtntKuwO0SvHLaKN/hC/qaDsU\ns+dLBj38vjHcNrzrfqq+tCNAisliVMJW9aEXWIOngiFH2TaGJiwFH2mXN873nNR2\nX1U1z/QVZzzBIufbK3mKbgkMXANMYw==\n=W+OH\n-----END PGP SIGNATURE-----",
        "payload": "tree 873d00ac62228833700af497839f2a65698f5653\nparent 867dbeba5f91be15ca0d4a7303a71957ff9a37ad\nauthor Vasil Dimov <vd@FreeBSD.org> 1604313389 +0100\ncommitter Vasil Dimov <vd@FreeBSD.org> 1605107115 +0100\n\naddrman: ensure old versions don't parse peers.dat\n\nEven though the format of `peers.dat` was changed in an incompatible\nway (old software versions <0.21 cannot understand the new file format),\nit is not guaranteed that old versions will fail to parse it. There is a\nchance that old versions parse its contents as garbage and use it.\n\nOld versions expect the \"key size\" field to be 32 and fail the parsing\nif it is not. Thus, we put something other than 32 in it. This will make\nversions between 0.11.0 and 0.20.1 deterministically fail on the new\nformat. Versions prior to https://github.com/bitcoin/bitcoin/pull/5941\n(<0.11.0) will still parse it as garbage.\n\nAlso, introduce a way to increment the `peers.dat` format in a way that\ndoes not necessary make older versions refuse to read it.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/38ada892ed0ed9aaa46b1791db12a371a3c0c419",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/38ada892ed0ed9aaa46b1791db12a371a3c0c419",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/38ada892ed0ed9aaa46b1791db12a371a3c0c419/comments",
    "author": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "867dbeba5f91be15ca0d4a7303a71957ff9a37ad",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/867dbeba5f91be15ca0d4a7303a71957ff9a37ad",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/867dbeba5f91be15ca0d4a7303a71957ff9a37ad"
      }
    ],
    "stats": {
      "total": 82,
      "additions": 55,
      "deletions": 27
    },
    "files": [
      {
        "sha": "0331328ff5ac85bef851663b30feea425d610854",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/38ada892ed0ed9aaa46b1791db12a371a3c0c419/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/38ada892ed0ed9aaa46b1791db12a371a3c0c419/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=38ada892ed0ed9aaa46b1791db12a371a3c0c419",
        "patch": "@@ -65,8 +65,8 @@ format of this file has been changed in a backwards-incompatible way in order to\n accommodate the storage of Tor v3 and other BIP155 addresses. This means that if\n the file is modified by 0.21.0 or newer then older versions will not be able to\n read it. Those old versions, in the event of a downgrade, will log an error\n-message that deserialization has failed and will continue normal operation\n-as if the file was missing, creating a new empty one. (#19954)\n+message \"Incorrect keysize in addrman deserialization\" and will continue normal\n+operation as if the file was missing, creating a new empty one. (#19954)\n \n Notable changes\n ==============="
      },
      {
        "sha": "04dd30b37576a310c27465aa239d9ec1ba7b6dac",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 53,
        "deletions": 25,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/38ada892ed0ed9aaa46b1791db12a371a3c0c419/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/38ada892ed0ed9aaa46b1791db12a371a3c0c419/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=38ada892ed0ed9aaa46b1791db12a371a3c0c419",
        "patch": "@@ -7,6 +7,7 @@\n #define BITCOIN_ADDRMAN_H\n \n #include <clientversion.h>\n+#include <config/bitcoin-config.h>\n #include <netaddress.h>\n #include <protocol.h>\n #include <random.h>\n@@ -176,6 +177,28 @@ friend class CAddrManTest;\n     mutable RecursiveMutex cs;\n \n private:\n+    //! Serialization versions.\n+    enum Format : uint8_t {\n+        V0_HISTORICAL = 0,    //!< historic format, before commit e6b343d88\n+        V1_DETERMINISTIC = 1, //!< for pre-asmap files\n+        V2_ASMAP = 2,         //!< for files including asmap version\n+        V3_BIP155 = 3,        //!< same as V2_ASMAP plus addresses are in BIP155 format\n+    };\n+\n+    //! The maximum format this software knows it can unserialize. Also, we always serialize\n+    //! in this format.\n+    //! The format (first byte in the serialized stream) can be higher than this and\n+    //! still this software may be able to unserialize the file - if the second byte\n+    //! (see `lowest_compatible` in `Unserialize()`) is less or equal to this.\n+    static constexpr Format FILE_FORMAT = Format::V3_BIP155;\n+\n+    //! The initial value of a field that is incremented every time an incompatible format\n+    //! change is made (such that old software versions would not be able to parse and\n+    //! understand the new file format). This is 32 because we overtook the \"key size\"\n+    //! field which was 32 historically.\n+    //! @note Don't increment this. Increment `lowest_compatible` in `Serialize()` instead.\n+    static constexpr uint8_t INCOMPATIBILITY_BASE = 32;\n+\n     //! last used nId\n     int nIdCount GUARDED_BY(cs);\n \n@@ -265,14 +288,6 @@ friend class CAddrManTest;\n     void SetServices_(const CService &addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n public:\n-    //! Serialization versions.\n-    enum class Format : uint8_t {\n-        V0_HISTORICAL = 0,    //!< historic format, before commit e6b343d88\n-        V1_DETERMINISTIC = 1, //!< for pre-asmap files\n-        V2_ASMAP = 2,         //!< for files including asmap version\n-        V3_BIP155 = 3,        //!< same as V2_ASMAP plus addresses are in BIP155 format\n-    };\n-\n     // Compressed IP->ASN mapping, loaded from a file when a node starts.\n     // Should be always empty if no file was provided.\n     // This mapping is then used for bucketing nodes in Addrman.\n@@ -295,8 +310,18 @@ friend class CAddrManTest;\n \n     /**\n      * Serialized format.\n-     * * version byte (@see `Format`)\n-     * * 0x20 + nKey (serialized as if it were a vector, for backward compatibility)\n+     * * format version byte (@see `Format`)\n+     * * lowest compatible format version byte. This is used to help old software decide\n+     *   whether to parse the file. For example:\n+     *   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is\n+     *     introduced in version N+1 that is compatible with format=3 and it is known that\n+     *     version N will be able to parse it, then version N+1 will write\n+     *     (format=4, lowest_compatible=3) in the first two bytes of the file, and so\n+     *     version N will still try to parse it.\n+     *   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write\n+     *     (format=5, lowest_compatible=5) and so any versions that do not know how to parse\n+     *     format=5 will not try to read the file.\n+     * * nKey\n      * * nNew\n      * * nTried\n      * * number of \"new\" buckets XOR 2**30\n@@ -327,12 +352,17 @@ friend class CAddrManTest;\n     {\n         LOCK(cs);\n \n-        // Always serialize in the latest version (currently Format::V3_BIP155).\n+        // Always serialize in the latest version (FILE_FORMAT).\n \n         OverrideStream<Stream> s(&s_, s_.GetType(), s_.GetVersion() | ADDRV2_FORMAT);\n \n-        s << static_cast<uint8_t>(Format::V3_BIP155);\n-        s << ((unsigned char)32);\n+        s << static_cast<uint8_t>(FILE_FORMAT);\n+\n+        // Increment `lowest_compatible` iff a newly introduced format is incompatible with\n+        // the previous one.\n+        static constexpr uint8_t lowest_compatible = Format::V3_BIP155;\n+        s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);\n+\n         s << nKey;\n         s << nNew;\n         s << nTried;\n@@ -392,15 +422,6 @@ friend class CAddrManTest;\n         Format format;\n         s_ >> Using<CustomUintFormatter<1>>(format);\n \n-        static constexpr Format maximum_supported_format = Format::V3_BIP155;\n-        if (format > maximum_supported_format) {\n-            throw std::ios_base::failure(strprintf(\n-                \"Unsupported format of addrman database: %u. Maximum supported is %u. \"\n-                \"Continuing operation without using the saved list of peers.\",\n-                static_cast<uint8_t>(format),\n-                static_cast<uint8_t>(maximum_supported_format)));\n-        }\n-\n         int stream_version = s_.GetVersion();\n         if (format >= Format::V3_BIP155) {\n             // Add ADDRV2_FORMAT to the version so that the CNetAddr and CAddress\n@@ -410,9 +431,16 @@ friend class CAddrManTest;\n \n         OverrideStream<Stream> s(&s_, s_.GetType(), stream_version);\n \n-        unsigned char nKeySize;\n-        s >> nKeySize;\n-        if (nKeySize != 32) throw std::ios_base::failure(\"Incorrect keysize in addrman deserialization\");\n+        uint8_t compat;\n+        s >> compat;\n+        const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;\n+        if (lowest_compatible > FILE_FORMAT) {\n+            throw std::ios_base::failure(strprintf(\n+                \"Unsupported format of addrman database: %u. It is compatible with formats >=%u, \"\n+                \"but the maximum supported by this version of %s is %u.\",\n+                format, lowest_compatible, PACKAGE_NAME, static_cast<uint8_t>(FILE_FORMAT)));\n+        }\n+\n         s >> nKey;\n         s >> nNew;\n         s >> nTried;"
      }
    ]
  }
]