[
  {
    "sha": "5d536619abda745c298fd827a856df775f223241",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ZDUzNjYxOWFiZGE3NDVjMjk4ZmQ4MjdhODU2ZGY3NzVmMjIzMjQx",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-04-24T19:50:00Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-05-02T21:53:23Z"
      },
      "message": "[tests] Remove 'account' API from wallet functional tests\n\nRemoves usage of account API from the following functional tests:\n\n- wallet_listreceivedby.py\n- wallet_basic.py\n- wallet_keypool_topup.py\n- wallet_txn_clone.py\n- wallet_listsinceblock.py\n- wallet_import_rescan.py\n- wallet_listtransactions.py\n- wallet_txn_doublespend.py",
      "tree": {
        "sha": "e7fabb22764c621d95777a4009ec35044afe3d9d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e7fabb22764c621d95777a4009ec35044afe3d9d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5d536619abda745c298fd827a856df775f223241",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5d536619abda745c298fd827a856df775f223241",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5d536619abda745c298fd827a856df775f223241",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5d536619abda745c298fd827a856df775f223241/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "baf6b4e3f956e5a612aa2385660e7c020f2c5c39",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/baf6b4e3f956e5a612aa2385660e7c020f2c5c39",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/baf6b4e3f956e5a612aa2385660e7c020f2c5c39"
      }
    ],
    "stats": {
      "total": 204,
      "additions": 78,
      "deletions": 126
    },
    "files": [
      {
        "sha": "9c58b84819d7aaa207c5e463a16181d0ab8b0c6e",
        "filename": "test/functional/wallet_basic.py",
        "status": "modified",
        "additions": 15,
        "deletions": 17,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d536619abda745c298fd827a856df775f223241/test/functional/wallet_basic.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d536619abda745c298fd827a856df775f223241/test/functional/wallet_basic.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_basic.py?ref=5d536619abda745c298fd827a856df775f223241",
        "patch": "@@ -22,10 +22,9 @@ class WalletTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 4\n         self.setup_clean_chain = True\n-        self.extra_args = [['-deprecatedrpc=accounts']] * 4\n \n     def setup_network(self):\n-        self.add_nodes(4, self.extra_args)\n+        self.add_nodes(4)\n         self.start_node(0)\n         self.start_node(1)\n         self.start_node(2)\n@@ -151,7 +150,7 @@ def run_test(self):\n             inputs = []\n             outputs = {}\n             inputs.append({\"txid\": utxo[\"txid\"], \"vout\": utxo[\"vout\"]})\n-            outputs[self.nodes[2].getnewaddress(\"from1\")] = utxo[\"amount\"] - 3\n+            outputs[self.nodes[2].getnewaddress()] = utxo[\"amount\"] - 3\n             raw_tx = self.nodes[0].createrawtransaction(inputs, outputs)\n             txns_to_send.append(self.nodes[0].signrawtransactionwithwallet(raw_tx))\n \n@@ -165,7 +164,6 @@ def run_test(self):\n \n         assert_equal(self.nodes[0].getbalance(), 0)\n         assert_equal(self.nodes[2].getbalance(), 94)\n-        assert_equal(self.nodes[2].getbalance(\"from1\"), 94 - 21)\n \n         # Verify that a spent output cannot be locked anymore\n         spent_0 = {\"txid\": node0utxos[0][\"txid\"], \"vout\": node0utxos[0][\"vout\"]}\n@@ -190,15 +188,15 @@ def run_test(self):\n         node_0_bal = self.check_fee_amount(self.nodes[0].getbalance(), Decimal('20'), fee_per_byte, self.get_vsize(self.nodes[2].getrawtransaction(txid)))\n \n         # Sendmany 10 BTC\n-        txid = self.nodes[2].sendmany('from1', {address: 10}, 0, \"\", [])\n+        txid = self.nodes[2].sendmany('', {address: 10}, 0, \"\", [])\n         self.nodes[2].generate(1)\n         self.sync_all([self.nodes[0:3]])\n         node_0_bal += Decimal('10')\n         node_2_bal = self.check_fee_amount(self.nodes[2].getbalance(), node_2_bal - Decimal('10'), fee_per_byte, self.get_vsize(self.nodes[2].getrawtransaction(txid)))\n         assert_equal(self.nodes[0].getbalance(), node_0_bal)\n \n         # Sendmany 10 BTC with subtract fee from amount\n-        txid = self.nodes[2].sendmany('from1', {address: 10}, 0, \"\", [address])\n+        txid = self.nodes[2].sendmany('', {address: 10}, 0, \"\", [address])\n         self.nodes[2].generate(1)\n         self.sync_all([self.nodes[0:3]])\n         node_2_bal -= Decimal('10')\n@@ -365,14 +363,14 @@ def run_test(self):\n         #   - True: unicode escaped as \\u....\n         #   - False: unicode directly as UTF-8\n         for mode in [True, False]:\n-            self.nodes[0].ensure_ascii = mode\n+            self.nodes[0].rpc.ensure_ascii = mode\n             # unicode check: Basic Multilingual Plane, Supplementary Plane respectively\n-            for s in [u'\u0440\u044b\u0431\u0430', u'\ud834\udd61']:\n-                addr = self.nodes[0].getaccountaddress(s)\n-                label = self.nodes[0].getaccount(addr)\n-                assert_equal(label, s)\n-                assert(s in self.nodes[0].listaccounts().keys())\n-        self.nodes[0].ensure_ascii = True  # restore to default\n+            for label in [u'\u0440\u044b\u0431\u0430', u'\ud834\udd61']:\n+                addr = self.nodes[0].getnewaddress()\n+                self.nodes[0].setlabel(addr, label)\n+                assert_equal(self.nodes[0].getaddressinfo(addr)['label'], label)\n+                assert(label in self.nodes[0].listlabels())\n+        self.nodes[0].rpc.ensure_ascii = True  # restore to default\n \n         # maintenance tests\n         maintenance = [\n@@ -388,9 +386,9 @@ def run_test(self):\n             self.log.info(\"check \" + m)\n             self.stop_nodes()\n             # set lower ancestor limit for later\n-            self.start_node(0, [m, \"-deprecatedrpc=accounts\", \"-limitancestorcount=\" + str(chainlimit)])\n-            self.start_node(1, [m, \"-deprecatedrpc=accounts\", \"-limitancestorcount=\" + str(chainlimit)])\n-            self.start_node(2, [m, \"-deprecatedrpc=accounts\", \"-limitancestorcount=\" + str(chainlimit)])\n+            self.start_node(0, [m, \"-limitancestorcount=\" + str(chainlimit)])\n+            self.start_node(1, [m, \"-limitancestorcount=\" + str(chainlimit)])\n+            self.start_node(2, [m, \"-limitancestorcount=\" + str(chainlimit)])\n             if m == '-reindex':\n                 # reindex will leave rpc warm up \"early\"; Wait for it to finish\n                 wait_until(lambda: [block_count] * 3 == [self.nodes[i].getblockcount() for i in range(3)])\n@@ -438,7 +436,7 @@ def run_test(self):\n         # Try with walletrejectlongchains\n         # Double chain limit but require combining inputs, so we pass SelectCoinsMinConf\n         self.stop_node(0)\n-        self.start_node(0, extra_args=[\"-deprecatedrpc=accounts\", \"-walletrejectlongchains\", \"-limitancestorcount=\" + str(2 * chainlimit)])\n+        self.start_node(0, extra_args=[\"-walletrejectlongchains\", \"-limitancestorcount=\" + str(2 * chainlimit)])\n \n         # wait for loadmempool\n         timeout = 10"
      },
      {
        "sha": "4c0ffb938b60a96ecbed8c6c56f1e463b97c2ca6",
        "filename": "test/functional/wallet_import_rescan.py",
        "status": "modified",
        "additions": 17,
        "deletions": 27,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d536619abda745c298fd827a856df775f223241/test/functional/wallet_import_rescan.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d536619abda745c298fd827a856df775f223241/test/functional/wallet_import_rescan.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_import_rescan.py?ref=5d536619abda745c298fd827a856df775f223241",
        "patch": "@@ -42,16 +42,15 @@ def try_rpc(self, func, *args, **kwargs):\n \n     def do_import(self, timestamp):\n         \"\"\"Call one key import RPC.\"\"\"\n+        rescan = self.rescan == Rescan.yes\n \n         if self.call == Call.single:\n             if self.data == Data.address:\n-                response = self.try_rpc(self.node.importaddress, self.address[\"address\"], self.label,\n-                                        self.rescan == Rescan.yes)\n+                response = self.try_rpc(self.node.importaddress, address=self.address[\"address\"], rescan=rescan)\n             elif self.data == Data.pub:\n-                response = self.try_rpc(self.node.importpubkey, self.address[\"pubkey\"], self.label,\n-                                        self.rescan == Rescan.yes)\n+                response = self.try_rpc(self.node.importpubkey, pubkey=self.address[\"pubkey\"], rescan=rescan)\n             elif self.data == Data.priv:\n-                response = self.try_rpc(self.node.importprivkey, self.key, self.label, self.rescan == Rescan.yes)\n+                response = self.try_rpc(self.node.importprivkey, privkey=self.key, rescan=rescan)\n             assert_equal(response, None)\n \n         elif self.call == Call.multi:\n@@ -62,40 +61,32 @@ def do_import(self, timestamp):\n                 \"timestamp\": timestamp + TIMESTAMP_WINDOW + (1 if self.rescan == Rescan.late_timestamp else 0),\n                 \"pubkeys\": [self.address[\"pubkey\"]] if self.data == Data.pub else [],\n                 \"keys\": [self.key] if self.data == Data.priv else [],\n-                \"label\": self.label,\n                 \"watchonly\": self.data != Data.priv\n             }], {\"rescan\": self.rescan in (Rescan.yes, Rescan.late_timestamp)})\n             assert_equal(response, [{\"success\": True}])\n \n     def check(self, txid=None, amount=None, confirmations=None):\n-        \"\"\"Verify that getbalance/listtransactions return expected values.\"\"\"\n+        \"\"\"Verify that listreceivedbyaddress returns expected values.\"\"\"\n \n-        balance = self.node.getbalance(self.label, 0, True)\n-        assert_equal(balance, self.expected_balance)\n-\n-        txs = self.node.listtransactions(self.label, 10000, 0, True)\n-        assert_equal(len(txs), self.expected_txs)\n+        addresses = self.node.listreceivedbyaddress(minconf=0, include_watchonly=True, address_filter=self.address['address'])\n+        if self.expected_txs:\n+            assert_equal(len(addresses[0][\"txids\"]), self.expected_txs)\n \n         if txid is not None:\n-            tx, = [tx for tx in txs if tx[\"txid\"] == txid]\n-            assert_equal(tx[\"label\"], self.label)\n-            assert_equal(tx[\"address\"], self.address[\"address\"])\n-            assert_equal(tx[\"amount\"], amount)\n-            assert_equal(tx[\"category\"], \"receive\")\n-            assert_equal(tx[\"label\"], self.label)\n-            assert_equal(tx[\"txid\"], txid)\n-            assert_equal(tx[\"confirmations\"], confirmations)\n-            assert_equal(\"trusted\" not in tx, True)\n+            address, = [ad for ad in addresses if txid in ad[\"txids\"]]\n+            assert_equal(address[\"address\"], self.address[\"address\"])\n+            assert_equal(address[\"amount\"], self.expected_balance)\n+            assert_equal(address[\"confirmations\"], confirmations)\n             # Verify the transaction is correctly marked watchonly depending on\n             # whether the transaction pays to an imported public key or\n             # imported private key. The test setup ensures that transaction\n             # inputs will not be from watchonly keys (important because\n             # involvesWatchonly will be true if either the transaction output\n             # or inputs are watchonly).\n             if self.data != Data.priv:\n-                assert_equal(tx[\"involvesWatchonly\"], True)\n+                assert_equal(address[\"involvesWatchonly\"], True)\n             else:\n-                assert_equal(\"involvesWatchonly\" not in tx, True)\n+                assert_equal(\"involvesWatchonly\" not in address, True)\n \n \n # List of Variants for each way a key or address could be imported.\n@@ -119,7 +110,7 @@ def set_test_params(self):\n         self.num_nodes = 2 + len(IMPORT_NODES)\n \n     def setup_network(self):\n-        extra_args = [[\"-addresstype=legacy\", '-deprecatedrpc=accounts'] for _ in range(self.num_nodes)]\n+        extra_args = [[\"-addresstype=legacy\"] for _ in range(self.num_nodes)]\n         for i, import_node in enumerate(IMPORT_NODES, 2):\n             if import_node.prune:\n                 extra_args[i] += [\"-prune=1\"]\n@@ -130,11 +121,10 @@ def setup_network(self):\n             connect_nodes(self.nodes[i], 0)\n \n     def run_test(self):\n-        # Create one transaction on node 0 with a unique amount and label for\n+        # Create one transaction on node 0 with a unique amount for\n         # each possible type of wallet import RPC.\n         for i, variant in enumerate(IMPORT_VARIANTS):\n-            variant.label = \"label {} {}\".format(i, variant)\n-            variant.address = self.nodes[1].getaddressinfo(self.nodes[1].getnewaddress(variant.label))\n+            variant.address = self.nodes[1].getaddressinfo(self.nodes[1].getnewaddress())\n             variant.key = self.nodes[1].dumpprivkey(variant.address[\"address\"])\n             variant.initial_amount = 10 - (i + 1) / 4.0\n             variant.initial_txid = self.nodes[0].sendtoaddress(variant.address[\"address\"], variant.initial_amount)"
      },
      {
        "sha": "d657dc30c4cf50ad090eeb825501acaeab97bf2a",
        "filename": "test/functional/wallet_keypool_topup.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d536619abda745c298fd827a856df775f223241/test/functional/wallet_keypool_topup.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d536619abda745c298fd827a856df775f223241/test/functional/wallet_keypool_topup.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_keypool_topup.py?ref=5d536619abda745c298fd827a856df775f223241",
        "patch": "@@ -25,7 +25,7 @@ class KeypoolRestoreTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.setup_clean_chain = True\n         self.num_nodes = 2\n-        self.extra_args = [['-deprecatedrpc=accounts'], ['-deprecatedrpc=accounts', '-keypool=100', '-keypoolmin=20']]\n+        self.extra_args = [[], ['-keypool=100']]\n \n     def run_test(self):\n         wallet_path = os.path.join(self.nodes[1].datadir, \"regtest\", \"wallets\", \"wallet.dat\")"
      },
      {
        "sha": "7447211296bf9b6ebb98767e9db662ee7a82b5d7",
        "filename": "test/functional/wallet_listreceivedby.py",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d536619abda745c298fd827a856df775f223241/test/functional/wallet_listreceivedby.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d536619abda745c298fd827a856df775f223241/test/functional/wallet_listreceivedby.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_listreceivedby.py?ref=5d536619abda745c298fd827a856df775f223241",
        "patch": "@@ -14,7 +14,6 @@\n class ReceivedByTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 2\n-        self.extra_args = [['-deprecatedrpc=accounts']] * 2\n \n     def run_test(self):\n         # Generate block to get out of IBD\n@@ -112,8 +111,9 @@ def run_test(self):\n         self.log.info(\"listreceivedbylabel + getreceivedbylabel Test\")\n \n         # set pre-state\n+        label = ''\n         address = self.nodes[1].getnewaddress()\n-        label = self.nodes[1].getaccount(address)\n+        assert_equal(self.nodes[1].getaddressinfo(address)['label'], label)\n         received_by_label_json = [r for r in self.nodes[1].listreceivedbylabel() if r[\"label\"] == label][0]\n         balance_by_label = self.nodes[1].getreceivedbylabel(label)\n \n@@ -141,7 +141,8 @@ def run_test(self):\n         assert_equal(balance, balance_by_label + Decimal(\"0.1\"))\n \n         # Create a new label named \"mynewlabel\" that has a 0 balance\n-        self.nodes[1].getlabeladdress(label=\"mynewlabel\", force=True)\n+        address = self.nodes[1].getnewaddress()\n+        self.nodes[1].setlabel(address, \"mynewlabel\")\n         received_by_label_json = [r for r in self.nodes[1].listreceivedbylabel(0, True) if r[\"label\"] == \"mynewlabel\"][0]\n \n         # Test includeempty of listreceivedbylabel"
      },
      {
        "sha": "63c179411c6e08d81dd598ed8035860013fe14f2",
        "filename": "test/functional/wallet_listsinceblock.py",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d536619abda745c298fd827a856df775f223241/test/functional/wallet_listsinceblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d536619abda745c298fd827a856df775f223241/test/functional/wallet_listsinceblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_listsinceblock.py?ref=5d536619abda745c298fd827a856df775f223241",
        "patch": "@@ -11,7 +11,6 @@ class ListSinceBlockTest (BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 4\n         self.setup_clean_chain = True\n-        self.extra_args = [['-deprecatedrpc=accounts']] * 4\n \n     def run_test(self):\n         self.nodes[2].generate(101)"
      },
      {
        "sha": "7cf2e456cfcd1891844e8dfade50a9033eb19c2c",
        "filename": "test/functional/wallet_listtransactions.py",
        "status": "modified",
        "additions": 12,
        "deletions": 14,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d536619abda745c298fd827a856df775f223241/test/functional/wallet_listtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d536619abda745c298fd827a856df775f223241/test/functional/wallet_listtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_listtransactions.py?ref=5d536619abda745c298fd827a856df775f223241",
        "patch": "@@ -25,7 +25,6 @@ def tx_from_hex(hexstring):\n class ListTransactionsTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 2\n-        self.extra_args = [['-deprecatedrpc=accounts']] * 2\n         self.enable_mocktime()\n \n     def run_test(self):\n@@ -34,19 +33,19 @@ def run_test(self):\n         self.sync_all()\n         assert_array_result(self.nodes[0].listtransactions(),\n                             {\"txid\": txid},\n-                            {\"category\": \"send\", \"account\": \"\", \"amount\": Decimal(\"-0.1\"), \"confirmations\": 0})\n+                            {\"category\": \"send\", \"amount\": Decimal(\"-0.1\"), \"confirmations\": 0})\n         assert_array_result(self.nodes[1].listtransactions(),\n                             {\"txid\": txid},\n-                            {\"category\": \"receive\", \"account\": \"\", \"amount\": Decimal(\"0.1\"), \"confirmations\": 0})\n+                            {\"category\": \"receive\", \"amount\": Decimal(\"0.1\"), \"confirmations\": 0})\n         # mine a block, confirmations should change:\n         self.nodes[0].generate(1)\n         self.sync_all()\n         assert_array_result(self.nodes[0].listtransactions(),\n                             {\"txid\": txid},\n-                            {\"category\": \"send\", \"account\": \"\", \"amount\": Decimal(\"-0.1\"), \"confirmations\": 1})\n+                            {\"category\": \"send\", \"amount\": Decimal(\"-0.1\"), \"confirmations\": 1})\n         assert_array_result(self.nodes[1].listtransactions(),\n                             {\"txid\": txid},\n-                            {\"category\": \"receive\", \"account\": \"\", \"amount\": Decimal(\"0.1\"), \"confirmations\": 1})\n+                            {\"category\": \"receive\", \"amount\": Decimal(\"0.1\"), \"confirmations\": 1})\n \n         # send-to-self:\n         txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 0.2)\n@@ -60,8 +59,8 @@ def run_test(self):\n         # sendmany from node1: twice to self, twice to node2:\n         send_to = {self.nodes[0].getnewaddress(): 0.11,\n                    self.nodes[1].getnewaddress(): 0.22,\n-                   self.nodes[0].getaccountaddress(\"from1\"): 0.33,\n-                   self.nodes[1].getaccountaddress(\"toself\"): 0.44}\n+                   self.nodes[0].getnewaddress(): 0.33,\n+                   self.nodes[1].getnewaddress(): 0.44}\n         txid = self.nodes[1].sendmany(\"\", send_to)\n         self.sync_all()\n         assert_array_result(self.nodes[1].listtransactions(),\n@@ -81,24 +80,23 @@ def run_test(self):\n                             {\"txid\": txid})\n         assert_array_result(self.nodes[0].listtransactions(),\n                             {\"category\": \"receive\", \"amount\": Decimal(\"0.33\")},\n-                            {\"txid\": txid, \"account\": \"from1\"})\n+                            {\"txid\": txid})\n         assert_array_result(self.nodes[1].listtransactions(),\n                             {\"category\": \"send\", \"amount\": Decimal(\"-0.44\")},\n-                            {\"txid\": txid, \"account\": \"\"})\n+                            {\"txid\": txid})\n         assert_array_result(self.nodes[1].listtransactions(),\n                             {\"category\": \"receive\", \"amount\": Decimal(\"0.44\")},\n-                            {\"txid\": txid, \"account\": \"toself\"})\n+                            {\"txid\": txid})\n \n         pubkey = self.nodes[1].getaddressinfo(self.nodes[1].getnewaddress())['pubkey']\n         multisig = self.nodes[1].createmultisig(1, [pubkey])\n         self.nodes[0].importaddress(multisig[\"redeemScript\"], \"watchonly\", False, True)\n         txid = self.nodes[1].sendtoaddress(multisig[\"address\"], 0.1)\n         self.nodes[1].generate(1)\n         self.sync_all()\n-        assert(len(self.nodes[0].listtransactions(\"watchonly\", 100, 0, False)) == 0)\n-        assert_array_result(self.nodes[0].listtransactions(\"watchonly\", 100, 0, True),\n-                            {\"category\": \"receive\", \"amount\": Decimal(\"0.1\")},\n-                            {\"txid\": txid, \"account\": \"watchonly\"})\n+        assert not [tx for tx in self.nodes[0].listtransactions(dummy=\"*\", count=100, skip=0, include_watchonly=False) if \"label\" in tx and tx[\"label\"] == \"watchonly\"]\n+        txs = [tx for tx in self.nodes[0].listtransactions(dummy=\"*\", count=100, skip=0, include_watchonly=True) if \"label\" in tx and tx['label'] == 'watchonly']\n+        assert_array_result(txs, {\"category\": \"receive\", \"amount\": Decimal(\"0.1\")}, {\"txid\": txid})\n \n         self.run_rbf_opt_in_test()\n "
      },
      {
        "sha": "72ae2d5db7dc99ae1e9331644953148ee135b799",
        "filename": "test/functional/wallet_txn_clone.py",
        "status": "modified",
        "additions": 15,
        "deletions": 36,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d536619abda745c298fd827a856df775f223241/test/functional/wallet_txn_clone.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d536619abda745c298fd827a856df775f223241/test/functional/wallet_txn_clone.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_txn_clone.py?ref=5d536619abda745c298fd827a856df775f223241",
        "patch": "@@ -15,7 +15,6 @@\n class TxnMallTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 4\n-        self.extra_args = [['-deprecatedrpc=accounts']] * 4\n \n     def add_options(self, parser):\n         parser.add_option(\"--mineblock\", dest=\"mine_block\", default=False, action=\"store_true\",\n@@ -39,28 +38,27 @@ def run_test(self):\n         starting_balance = 1250\n         for i in range(4):\n             assert_equal(self.nodes[i].getbalance(), starting_balance)\n-            self.nodes[i].getnewaddress(\"\")  # bug workaround, coins generated assigned to first getnewaddress!\n+            self.nodes[i].getnewaddress()  # bug workaround, coins generated assigned to first getnewaddress!\n \n-        # Assign coins to foo and bar accounts:\n         self.nodes[0].settxfee(.001)\n \n-        node0_address_foo = self.nodes[0].getnewaddress(\"foo\", output_type)\n-        fund_foo_txid = self.nodes[0].sendfrom(\"\", node0_address_foo, 1219)\n-        fund_foo_tx = self.nodes[0].gettransaction(fund_foo_txid)\n+        node0_address1 = self.nodes[0].getnewaddress(address_type=output_type)\n+        node0_txid1 = self.nodes[0].sendtoaddress(node0_address1, 1219)\n+        node0_tx1 = self.nodes[0].gettransaction(node0_txid1)\n \n-        node0_address_bar = self.nodes[0].getnewaddress(\"bar\", output_type)\n-        fund_bar_txid = self.nodes[0].sendfrom(\"\", node0_address_bar, 29)\n-        fund_bar_tx = self.nodes[0].gettransaction(fund_bar_txid)\n+        node0_address2 = self.nodes[0].getnewaddress(address_type=output_type)\n+        node0_txid2 = self.nodes[0].sendtoaddress(node0_address2, 29)\n+        node0_tx2 = self.nodes[0].gettransaction(node0_txid2)\n \n-        assert_equal(self.nodes[0].getbalance(\"\"),\n-                     starting_balance - 1219 - 29 + fund_foo_tx[\"fee\"] + fund_bar_tx[\"fee\"])\n+        assert_equal(self.nodes[0].getbalance(),\n+                     starting_balance + node0_tx1[\"fee\"] + node0_tx2[\"fee\"])\n \n         # Coins are sent to node1_address\n-        node1_address = self.nodes[1].getnewaddress(\"from0\")\n+        node1_address = self.nodes[1].getnewaddress()\n \n         # Send tx1, and another transaction tx2 that won't be cloned\n-        txid1 = self.nodes[0].sendfrom(\"foo\", node1_address, 40, 0)\n-        txid2 = self.nodes[0].sendfrom(\"bar\", node1_address, 20, 0)\n+        txid1 = self.nodes[0].sendtoaddress(node1_address, 40)\n+        txid2 = self.nodes[0].sendtoaddress(node1_address, 20)\n \n         # Construct a clone of tx1, to be malleated\n         rawtx1 = self.nodes[0].getrawtransaction(txid1, 1)\n@@ -96,28 +94,22 @@ def run_test(self):\n \n         # Node0's balance should be starting balance, plus 50BTC for another\n         # matured block, minus tx1 and tx2 amounts, and minus transaction fees:\n-        expected = starting_balance + fund_foo_tx[\"fee\"] + fund_bar_tx[\"fee\"]\n+        expected = starting_balance + node0_tx1[\"fee\"] + node0_tx2[\"fee\"]\n         if self.options.mine_block:\n             expected += 50\n         expected += tx1[\"amount\"] + tx1[\"fee\"]\n         expected += tx2[\"amount\"] + tx2[\"fee\"]\n         assert_equal(self.nodes[0].getbalance(), expected)\n \n-        # foo and bar accounts should be debited:\n-        assert_equal(self.nodes[0].getbalance(\"foo\", 0), 1219 + tx1[\"amount\"] + tx1[\"fee\"])\n-        assert_equal(self.nodes[0].getbalance(\"bar\", 0), 29 + tx2[\"amount\"] + tx2[\"fee\"])\n-\n         if self.options.mine_block:\n             assert_equal(tx1[\"confirmations\"], 1)\n             assert_equal(tx2[\"confirmations\"], 1)\n-            # Node1's \"from0\" balance should be both transaction amounts:\n-            assert_equal(self.nodes[1].getbalance(\"from0\"), -(tx1[\"amount\"] + tx2[\"amount\"]))\n         else:\n             assert_equal(tx1[\"confirmations\"], 0)\n             assert_equal(tx2[\"confirmations\"], 0)\n \n         # Send clone and its parent to miner\n-        self.nodes[2].sendrawtransaction(fund_foo_tx[\"hex\"])\n+        self.nodes[2].sendrawtransaction(node0_tx1[\"hex\"])\n         txid1_clone = self.nodes[2].sendrawtransaction(tx1_clone[\"hex\"])\n         if self.options.segwit:\n             assert_equal(txid1, txid1_clone)\n@@ -128,7 +120,7 @@ def run_test(self):\n \n         # Reconnect the split network, and sync chain:\n         connect_nodes(self.nodes[1], 2)\n-        self.nodes[2].sendrawtransaction(fund_bar_tx[\"hex\"])\n+        self.nodes[2].sendrawtransaction(node0_tx2[\"hex\"])\n         self.nodes[2].sendrawtransaction(tx2[\"hex\"])\n         self.nodes[2].generate(1)  # Mine another block to make sure we sync\n         sync_blocks(self.nodes)\n@@ -149,19 +141,6 @@ def run_test(self):\n         if (self.options.mine_block):\n             expected -= 50\n         assert_equal(self.nodes[0].getbalance(), expected)\n-        assert_equal(self.nodes[0].getbalance(\"*\", 0), expected)\n-\n-        # Check node0's individual account balances.\n-        # \"foo\" should have been debited by the equivalent clone of tx1\n-        assert_equal(self.nodes[0].getbalance(\"foo\"), 1219 + tx1[\"amount\"] + tx1[\"fee\"])\n-        # \"bar\" should have been debited by (possibly unconfirmed) tx2\n-        assert_equal(self.nodes[0].getbalance(\"bar\", 0), 29 + tx2[\"amount\"] + tx2[\"fee\"])\n-        # \"\" should have starting balance, less funding txes, plus subsidies\n-        assert_equal(self.nodes[0].getbalance(\"\", 0),\n-                     starting_balance - 1219 + fund_foo_tx[\"fee\"] - 29 + fund_bar_tx[\"fee\"] + 100)\n-\n-        # Node1's \"from0\" account balance\n-        assert_equal(self.nodes[1].getbalance(\"from0\", 0), -(tx1[\"amount\"] + tx2[\"amount\"]))\n \n if __name__ == '__main__':\n     TxnMallTest().main()"
      },
      {
        "sha": "7ee60d5611e874ce62bb0fc9f029eb4e27d3db92",
        "filename": "test/functional/wallet_txn_doublespend.py",
        "status": "modified",
        "additions": 14,
        "deletions": 27,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d536619abda745c298fd827a856df775f223241/test/functional/wallet_txn_doublespend.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d536619abda745c298fd827a856df775f223241/test/functional/wallet_txn_doublespend.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_txn_doublespend.py?ref=5d536619abda745c298fd827a856df775f223241",
        "patch": "@@ -17,7 +17,6 @@\n class TxnMallTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 4\n-        self.extra_args = [['-deprecatedrpc=accounts']] * 4\n \n     def add_options(self, parser):\n         parser.add_option(\"--mineblock\", dest=\"mine_block\", default=False, action=\"store_true\",\n@@ -36,20 +35,20 @@ def run_test(self):\n             assert_equal(self.nodes[i].getbalance(), starting_balance)\n             self.nodes[i].getnewaddress(\"\")  # bug workaround, coins generated assigned to first getnewaddress!\n \n-        # Assign coins to foo and bar accounts:\n-        node0_address_foo = self.nodes[0].getnewaddress(\"foo\")\n-        fund_foo_txid = self.nodes[0].sendfrom(\"\", node0_address_foo, 1219)\n+        # Assign coins to foo and bar addresses:\n+        node0_address_foo = self.nodes[0].getnewaddress()\n+        fund_foo_txid = self.nodes[0].sendtoaddress(node0_address_foo, 1219)\n         fund_foo_tx = self.nodes[0].gettransaction(fund_foo_txid)\n \n-        node0_address_bar = self.nodes[0].getnewaddress(\"bar\")\n-        fund_bar_txid = self.nodes[0].sendfrom(\"\", node0_address_bar, 29)\n+        node0_address_bar = self.nodes[0].getnewaddress()\n+        fund_bar_txid = self.nodes[0].sendtoaddress(node0_address_bar, 29)\n         fund_bar_tx = self.nodes[0].gettransaction(fund_bar_txid)\n \n-        assert_equal(self.nodes[0].getbalance(\"\"),\n-                     starting_balance - 1219 - 29 + fund_foo_tx[\"fee\"] + fund_bar_tx[\"fee\"])\n+        assert_equal(self.nodes[0].getbalance(),\n+                     starting_balance + fund_foo_tx[\"fee\"] + fund_bar_tx[\"fee\"])\n \n         # Coins are sent to node1_address\n-        node1_address = self.nodes[1].getnewaddress(\"from0\")\n+        node1_address = self.nodes[1].getnewaddress()\n \n         # First: use raw transaction API to send 1240 BTC to node1_address,\n         # but don't broadcast:\n@@ -70,8 +69,8 @@ def run_test(self):\n         assert_equal(doublespend[\"complete\"], True)\n \n         # Create two spends using 1 50 BTC coin each\n-        txid1 = self.nodes[0].sendfrom(\"foo\", node1_address, 40, 0)\n-        txid2 = self.nodes[0].sendfrom(\"bar\", node1_address, 20, 0)\n+        txid1 = self.nodes[0].sendtoaddress(node1_address, 40)\n+        txid2 = self.nodes[0].sendtoaddress(node1_address, 20)\n \n         # Have node0 mine a block:\n         if (self.options.mine_block):\n@@ -90,15 +89,11 @@ def run_test(self):\n         expected += tx2[\"amount\"] + tx2[\"fee\"]\n         assert_equal(self.nodes[0].getbalance(), expected)\n \n-        # foo and bar accounts should be debited:\n-        assert_equal(self.nodes[0].getbalance(\"foo\", 0), 1219 + tx1[\"amount\"] + tx1[\"fee\"])\n-        assert_equal(self.nodes[0].getbalance(\"bar\", 0), 29 + tx2[\"amount\"] + tx2[\"fee\"])\n-\n         if self.options.mine_block:\n             assert_equal(tx1[\"confirmations\"], 1)\n             assert_equal(tx2[\"confirmations\"], 1)\n-            # Node1's \"from0\" balance should be both transaction amounts:\n-            assert_equal(self.nodes[1].getbalance(\"from0\"), -(tx1[\"amount\"] + tx2[\"amount\"]))\n+            # Node1's balance should be both transaction amounts:\n+            assert_equal(self.nodes[1].getbalance(), starting_balance - tx1[\"amount\"] - tx2[\"amount\"])\n         else:\n             assert_equal(tx1[\"confirmations\"], 0)\n             assert_equal(tx2[\"confirmations\"], 0)\n@@ -129,17 +124,9 @@ def run_test(self):\n         # negative):\n         expected = starting_balance + 100 - 1240 + fund_foo_tx[\"fee\"] + fund_bar_tx[\"fee\"] + doublespend_fee\n         assert_equal(self.nodes[0].getbalance(), expected)\n-        assert_equal(self.nodes[0].getbalance(\"*\"), expected)\n-\n-        # Final \"\" balance is starting_balance - amount moved to accounts - doublespend + subsidies +\n-        # fees (which are negative)\n-        assert_equal(self.nodes[0].getbalance(\"foo\"), 1219)\n-        assert_equal(self.nodes[0].getbalance(\"bar\"), 29)\n-        assert_equal(self.nodes[0].getbalance(\"\"),\n-                     starting_balance - 1219 - 29 - 1240 + 100 + fund_foo_tx[\"fee\"] + fund_bar_tx[\"fee\"] + doublespend_fee)\n \n-        # Node1's \"from0\" account balance should be just the doublespend:\n-        assert_equal(self.nodes[1].getbalance(\"from0\"), 1240)\n+        # Node1's balance should be its initial balance (1250 for 25 block rewards) plus the doublespend:\n+        assert_equal(self.nodes[1].getbalance(), 1250 + 1240)\n \n if __name__ == '__main__':\n     TxnMallTest().main()"
      }
    ]
  }
]