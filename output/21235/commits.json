[
  {
    "sha": "fae7c0429f96e08bcac944f6fa30264636dfda8c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYWU3YzA0MjlmOTZlMDhiY2FjOTQ0ZjZmYTMwMjY0NjM2ZGZkYThj",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-02-19T09:33:49Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-03-18T08:12:37Z"
      },
      "message": "log: Clarify that block request below NODE_NETWORK_LIMITED_MIN_BLOCKS disconnects",
      "tree": {
        "sha": "a1e6acb7acc68f5d7aa2831ef5f9e31cffa8008a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a1e6acb7acc68f5d7aa2831ef5f9e31cffa8008a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fae7c0429f96e08bcac944f6fa30264636dfda8c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUjf+Qv/dVB2zT1I5HMiQ/tCGF+fQXX2Q+5h/gWbaab3Y9FlHfdWkCryap5oXUV8\n+dBRknL1ooSfhyNnkw4wgkzI+xrnLc/4rIvUHBlJZ7y+wIHdusJGvu+InYr95PzA\nVghCGsKmP1B9iKiabkSFpOsg0JCwaqoCny0jJgCc6aDc0r2G1ZnnO4ycXz3wQLKH\nIuclvi8eFxgb2nTGJt07EmIWREITTGwzIUWqAsg1/ctkbbOsmJIYTE9WzaiCDHrf\n0M0xE8X98yHzRv3Kd/NY8uMYTHt2CVnidTMpBohBFebu2YNm0JyezQkve5aizmzp\nrPNJBq8uN8ZHcIew0qKyWMkCa97QkTqp/IZN1oyIVaTCowofzmho2V+u3IHBEhkt\ny+dYhx6PoEq7ehY3GWgEIXXovkkflRfK2eDMC4UMRrUDe11EpaO4+lfGszVNf/xl\ngoq/EqoxPl+6tgujobrD0fqq0A2Y9B4/1CPIV5SJBspdN7Q7ttZBcfqjoyulVzAX\n7ABfzjOW\n=PGcS\n-----END PGP SIGNATURE-----",
        "payload": "tree a1e6acb7acc68f5d7aa2831ef5f9e31cffa8008a\nparent 6834e02c896b97ecbd2ad8251c5b09612b27bf10\nauthor MarcoFalke <falke.marco@gmail.com> 1613727229 +0100\ncommitter MarcoFalke <falke.marco@gmail.com> 1616055157 +0100\n\nlog: Clarify that block request below NODE_NETWORK_LIMITED_MIN_BLOCKS disconnects\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fae7c0429f96e08bcac944f6fa30264636dfda8c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fae7c0429f96e08bcac944f6fa30264636dfda8c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fae7c0429f96e08bcac944f6fa30264636dfda8c/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6834e02c896b97ecbd2ad8251c5b09612b27bf10",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6834e02c896b97ecbd2ad8251c5b09612b27bf10",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6834e02c896b97ecbd2ad8251c5b09612b27bf10"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 1,
      "deletions": 4
    },
    "files": [
      {
        "sha": "53034805e5e5e24a85ebe2c1aca042bf4b64a062",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fae7c0429f96e08bcac944f6fa30264636dfda8c/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fae7c0429f96e08bcac944f6fa30264636dfda8c/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=fae7c0429f96e08bcac944f6fa30264636dfda8c",
        "patch": "@@ -1580,17 +1580,14 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CInv&\n         !pfrom.HasPermission(PF_DOWNLOAD) // nodes with the download permission may exceed target\n     ) {\n         LogPrint(BCLog::NET, \"historical block serving limit reached, disconnect peer=%d\\n\", pfrom.GetId());\n-\n-        //disconnect node\n         pfrom.fDisconnect = true;\n         send = false;\n     }\n     // Avoid leaking prune-height by never sending blocks below the NODE_NETWORK_LIMITED threshold\n     if (send && !pfrom.HasPermission(PF_NOBAN) && (\n             (((pfrom.GetLocalServices() & NODE_NETWORK_LIMITED) == NODE_NETWORK_LIMITED) && ((pfrom.GetLocalServices() & NODE_NETWORK) != NODE_NETWORK) && (m_chainman.ActiveChain().Tip()->nHeight - pindex->nHeight > (int)NODE_NETWORK_LIMITED_MIN_BLOCKS + 2 /* add two blocks buffer extension for possible races */) )\n        )) {\n-        LogPrint(BCLog::NET, \"Ignore block request below NODE_NETWORK_LIMITED threshold from peer=%d\\n\", pfrom.GetId());\n-\n+        LogPrint(BCLog::NET, \"Ignore block request below NODE_NETWORK_LIMITED threshold, disconnect peer=%d\\n\", pfrom.GetId());\n         //disconnect node and prevent it from stalling (would otherwise wait for the missing block)\n         pfrom.fDisconnect = true;\n         send = false;"
      }
    ]
  },
  {
    "sha": "fae77b9e6dc9e59b355d56df49c4d9685b6f40a4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYWU3N2I5ZTZkYzllNTliMzU1ZDU2ZGY0OWM0ZDk2ODViNmY0MGE0",
    "commit": {
      "author": {
        "name": "Patrick Strateman",
        "email": "patrick.strateman@gmail.com",
        "date": "2018-05-16T23:08:26Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-03-18T08:15:16Z"
      },
      "message": "net: Simplify ProcessGetBlockData execution by removing send flag.\n\nSetting the send flag to false can be replaced by simply returning.",
      "tree": {
        "sha": "88d0044d09c321ba383f1e5cd93d9d676990c5c1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/88d0044d09c321ba383f1e5cd93d9d676990c5c1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fae77b9e6dc9e59b355d56df49c4d9685b6f40a4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUjZQAwAhaGp9jwFSNOVjW0u+58Hn+8CGB7xULlJK0AnmC2x2Q5pMQ6ytytpCEeP\n1rL+de9NjpNKtqc5nRaZSgqNkhy1ZAqpTIDs+46fUhko6yaYbR8WYj6QmXaTFoxk\nX2GhdS6jY0596/zvRr+Ahx/SUWnfkw/fVTN3BDjxZjISvwHUkw5C5PMVavohHEZK\nnd2uNbVC5BjMe+w6GCJYdfrl9qz9bm3USmi3AESV/vnb/RdrouxYFQ0J7cZ7zJj/\nH66RjQFsKBk9LArY1g8L9RrSUPC+cReUwOzjAeH+a1SnJrJFxXXU7DvKw/PB1QQ3\nD6fQtV5MPOSMAoF/GhlTBfP9Q9j8P+lJsS9WEWzyEdnM+WVFrrKlAtwZbgNXuJwn\n7lDXgFwbYIp1xlX6F4gUlUJmt7dSMzMUKjZ6lPnlbqv0sHm+3Y7Md6fdegRH2175\nf4IQgZicbM4KaNK7eCIuqhI99CQ4Z7g49nWH+XKP8eegsxQfm55TEYVkzZGKqH4d\nNGpUtkZ1\n=5OSh\n-----END PGP SIGNATURE-----",
        "payload": "tree 88d0044d09c321ba383f1e5cd93d9d676990c5c1\nparent fae7c0429f96e08bcac944f6fa30264636dfda8c\nauthor Patrick Strateman <patrick.strateman@gmail.com> 1526512106 +0200\ncommitter MarcoFalke <falke.marco@gmail.com> 1616055316 +0100\n\nnet: Simplify ProcessGetBlockData execution by removing send flag.\n\nSetting the send flag to false can be replaced by simply returning.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fae77b9e6dc9e59b355d56df49c4d9685b6f40a4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fae77b9e6dc9e59b355d56df49c4d9685b6f40a4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fae77b9e6dc9e59b355d56df49c4d9685b6f40a4/comments",
    "author": {
      "login": "pstratem",
      "id": 620611,
      "node_id": "MDQ6VXNlcjYyMDYxMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/620611?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pstratem",
      "html_url": "https://github.com/pstratem",
      "followers_url": "https://api.github.com/users/pstratem/followers",
      "following_url": "https://api.github.com/users/pstratem/following{/other_user}",
      "gists_url": "https://api.github.com/users/pstratem/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pstratem/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pstratem/subscriptions",
      "organizations_url": "https://api.github.com/users/pstratem/orgs",
      "repos_url": "https://api.github.com/users/pstratem/repos",
      "events_url": "https://api.github.com/users/pstratem/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pstratem/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fae7c0429f96e08bcac944f6fa30264636dfda8c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fae7c0429f96e08bcac944f6fa30264636dfda8c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fae7c0429f96e08bcac944f6fa30264636dfda8c"
      }
    ],
    "stats": {
      "total": 25,
      "additions": 13,
      "deletions": 12
    },
    "files": [
      {
        "sha": "413d8d332268cdbd89a8f6b2ff01f3a6b9d49aa6",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 12,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fae77b9e6dc9e59b355d56df49c4d9685b6f40a4/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fae77b9e6dc9e59b355d56df49c4d9685b6f40a4/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=fae77b9e6dc9e59b355d56df49c4d9685b6f40a4",
        "patch": "@@ -1530,7 +1530,6 @@ static void RelayAddress(const CNode& originator,\n \n void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CInv& inv)\n {\n-    bool send = false;\n     std::shared_ptr<const CBlock> a_recent_block;\n     std::shared_ptr<const CBlockHeaderAndShortTxIDs> a_recent_compact_block;\n     bool fWitnessesPresentInARecentCompactBlock;\n@@ -1566,35 +1565,37 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CInv&\n \n     LOCK(cs_main);\n     const CBlockIndex* pindex = m_chainman.m_blockman.LookupBlockIndex(inv.hash);\n-    if (pindex) {\n-        send = BlockRequestAllowed(pindex);\n-        if (!send) {\n-            LogPrint(BCLog::NET, \"%s: ignoring request from peer=%i for old block that isn't in the main chain\\n\", __func__, pfrom.GetId());\n-        }\n+    if (!pindex) {\n+        return;\n+    }\n+    if (!BlockRequestAllowed(pindex)) {\n+        LogPrint(BCLog::NET, \"%s: ignoring request from peer=%i for old block that isn't in the main chain\\n\", __func__, pfrom.GetId());\n+        return;\n     }\n     const CNetMsgMaker msgMaker(pfrom.GetCommonVersion());\n     // disconnect node in case we have reached the outbound limit for serving historical blocks\n-    if (send &&\n-        m_connman.OutboundTargetReached(true) &&\n+    if (m_connman.OutboundTargetReached(true) &&\n         (((pindexBestHeader != nullptr) && (pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() > HISTORICAL_BLOCK_AGE)) || inv.IsMsgFilteredBlk()) &&\n         !pfrom.HasPermission(PF_DOWNLOAD) // nodes with the download permission may exceed target\n     ) {\n         LogPrint(BCLog::NET, \"historical block serving limit reached, disconnect peer=%d\\n\", pfrom.GetId());\n         pfrom.fDisconnect = true;\n-        send = false;\n+        return;\n     }\n     // Avoid leaking prune-height by never sending blocks below the NODE_NETWORK_LIMITED threshold\n-    if (send && !pfrom.HasPermission(PF_NOBAN) && (\n+    if (!pfrom.HasPermission(PF_NOBAN) && (\n             (((pfrom.GetLocalServices() & NODE_NETWORK_LIMITED) == NODE_NETWORK_LIMITED) && ((pfrom.GetLocalServices() & NODE_NETWORK) != NODE_NETWORK) && (m_chainman.ActiveChain().Tip()->nHeight - pindex->nHeight > (int)NODE_NETWORK_LIMITED_MIN_BLOCKS + 2 /* add two blocks buffer extension for possible races */) )\n        )) {\n         LogPrint(BCLog::NET, \"Ignore block request below NODE_NETWORK_LIMITED threshold, disconnect peer=%d\\n\", pfrom.GetId());\n         //disconnect node and prevent it from stalling (would otherwise wait for the missing block)\n         pfrom.fDisconnect = true;\n-        send = false;\n+        return;\n     }\n     // Pruned nodes may have deleted the block, so check whether\n     // it's available before trying to send.\n-    if (send && (pindex->nStatus & BLOCK_HAVE_DATA))\n+    if (!(pindex->nStatus & BLOCK_HAVE_DATA)) {\n+        return;\n+    }\n     {\n         std::shared_ptr<const CBlock> pblock;\n         if (a_recent_block && a_recent_block->GetHash() == pindex->GetBlockHash()) {"
      }
    ]
  },
  {
    "sha": "fa8177324392c923c6ce39056cfd870af55ab673",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTgxNzczMjQzOTJjOTIzYzZjZTM5MDU2Y2ZkODcwYWY1NWFiNjcz",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-02-23T10:47:28Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-03-18T08:16:11Z"
      },
      "message": "style-only: Remove whitespace\n\nCan be reviewed with --ignore-all-space",
      "tree": {
        "sha": "93b272c7e3eff7a7d8b6909fe2d3c416ad6dcf8c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/93b272c7e3eff7a7d8b6909fe2d3c416ad6dcf8c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa8177324392c923c6ce39056cfd870af55ab673",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUjk/wv/dNvFoolOAFtmn/6l2h2pKCdNFBrV74ghEuvqfp/h7YzHcmDYHWaKXWvc\nwKlOXNUiS9WDR9NBgpSGI4TrFQ/rnJi6WhGK0Jkq7sxlxMnngiCDgeUdNo5Wa1BB\nsBSkr3z1CZxQdLqwFvjnUdhnRCnF3xvT79D1mGxxOZYuqGjU6n4cVTTFuV4WCg7O\n0W7hwAilmfXZ4+srHfBldWe/Ze60A3Mh9n1EjSMa7He5qL2AyT5P2c7R2soiXFCw\nxt2m9p/IzgcxQPiFbf67RtGK/aD6Qoc1ds5nQtVs07Re7tLm5deFYrmoal412xmh\n8UY3XnpNVNeUF/B5YhF0aoPNmQ4vK+q/nTWAOJnGUlXiE3DaoeeYkq8+iKczr4qB\nsLCZBIZ67nDRoo5JMc5T/LhtTe2RlCja71GipNg5lb1oLKim1i14bHHdDZUJOFIA\n9z15/McIfBHzHN5CBLCBgvgeEGk0bpHDX+P+uzYlwSH34MPtmBe/Ek437Dz1zBw+\nHQ8uFqL/\n=klLZ\n-----END PGP SIGNATURE-----",
        "payload": "tree 93b272c7e3eff7a7d8b6909fe2d3c416ad6dcf8c\nparent fae77b9e6dc9e59b355d56df49c4d9685b6f40a4\nauthor MarcoFalke <falke.marco@gmail.com> 1614077248 +0100\ncommitter MarcoFalke <falke.marco@gmail.com> 1616055371 +0100\n\nstyle-only: Remove whitespace\n\nCan be reviewed with --ignore-all-space\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa8177324392c923c6ce39056cfd870af55ab673",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa8177324392c923c6ce39056cfd870af55ab673",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa8177324392c923c6ce39056cfd870af55ab673/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fae77b9e6dc9e59b355d56df49c4d9685b6f40a4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fae77b9e6dc9e59b355d56df49c4d9685b6f40a4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fae77b9e6dc9e59b355d56df49c4d9685b6f40a4"
      }
    ],
    "stats": {
      "total": 146,
      "additions": 72,
      "deletions": 74
    },
    "files": [
      {
        "sha": "e561f02c4acf3fcb42bec18ff42d8d33ff731f47",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 72,
        "deletions": 74,
        "changes": 146,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa8177324392c923c6ce39056cfd870af55ab673/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa8177324392c923c6ce39056cfd870af55ab673/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=fa8177324392c923c6ce39056cfd870af55ab673",
        "patch": "@@ -1596,88 +1596,86 @@ void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CInv&\n     if (!(pindex->nStatus & BLOCK_HAVE_DATA)) {\n         return;\n     }\n-    {\n-        std::shared_ptr<const CBlock> pblock;\n-        if (a_recent_block && a_recent_block->GetHash() == pindex->GetBlockHash()) {\n-            pblock = a_recent_block;\n+    std::shared_ptr<const CBlock> pblock;\n+    if (a_recent_block && a_recent_block->GetHash() == pindex->GetBlockHash()) {\n+        pblock = a_recent_block;\n+    } else if (inv.IsMsgWitnessBlk()) {\n+        // Fast-path: in this case it is possible to serve the block directly from disk,\n+        // as the network format matches the format on disk\n+        std::vector<uint8_t> block_data;\n+        if (!ReadRawBlockFromDisk(block_data, pindex, m_chainparams.MessageStart())) {\n+            assert(!\"cannot load block from disk\");\n+        }\n+        m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::BLOCK, MakeSpan(block_data)));\n+        // Don't set pblock as we've sent the block\n+    } else {\n+        // Send block from disk\n+        std::shared_ptr<CBlock> pblockRead = std::make_shared<CBlock>();\n+        if (!ReadBlockFromDisk(*pblockRead, pindex, m_chainparams.GetConsensus())) {\n+            assert(!\"cannot load block from disk\");\n+        }\n+        pblock = pblockRead;\n+    }\n+    if (pblock) {\n+        if (inv.IsMsgBlk()) {\n+            m_connman.PushMessage(&pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, *pblock));\n         } else if (inv.IsMsgWitnessBlk()) {\n-            // Fast-path: in this case it is possible to serve the block directly from disk,\n-            // as the network format matches the format on disk\n-            std::vector<uint8_t> block_data;\n-            if (!ReadRawBlockFromDisk(block_data, pindex, m_chainparams.MessageStart())) {\n-                assert(!\"cannot load block from disk\");\n+            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::BLOCK, *pblock));\n+        } else if (inv.IsMsgFilteredBlk()) {\n+            bool sendMerkleBlock = false;\n+            CMerkleBlock merkleBlock;\n+            if (pfrom.m_tx_relay != nullptr) {\n+                LOCK(pfrom.m_tx_relay->cs_filter);\n+                if (pfrom.m_tx_relay->pfilter) {\n+                    sendMerkleBlock = true;\n+                    merkleBlock = CMerkleBlock(*pblock, *pfrom.m_tx_relay->pfilter);\n+                }\n             }\n-            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::BLOCK, MakeSpan(block_data)));\n-            // Don't set pblock as we've sent the block\n-        } else {\n-            // Send block from disk\n-            std::shared_ptr<CBlock> pblockRead = std::make_shared<CBlock>();\n-            if (!ReadBlockFromDisk(*pblockRead, pindex, m_chainparams.GetConsensus())) {\n-                assert(!\"cannot load block from disk\");\n+            if (sendMerkleBlock) {\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::MERKLEBLOCK, merkleBlock));\n+                // CMerkleBlock just contains hashes, so also push any transactions in the block the client did not see\n+                // This avoids hurting performance by pointlessly requiring a round-trip\n+                // Note that there is currently no way for a node to request any single transactions we didn't send here -\n+                // they must either disconnect and retry or request the full block.\n+                // Thus, the protocol spec specified allows for us to provide duplicate txn here,\n+                // however we MUST always provide at least what the remote peer needs\n+                typedef std::pair<unsigned int, uint256> PairType;\n+                for (PairType& pair : merkleBlock.vMatchedTxn)\n+                    m_connman.PushMessage(&pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *pblock->vtx[pair.first]));\n             }\n-            pblock = pblockRead;\n-        }\n-        if (pblock) {\n-            if (inv.IsMsgBlk()) {\n-                m_connman.PushMessage(&pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, *pblock));\n-            } else if (inv.IsMsgWitnessBlk()) {\n-                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::BLOCK, *pblock));\n-            } else if (inv.IsMsgFilteredBlk()) {\n-                bool sendMerkleBlock = false;\n-                CMerkleBlock merkleBlock;\n-                if (pfrom.m_tx_relay != nullptr) {\n-                    LOCK(pfrom.m_tx_relay->cs_filter);\n-                    if (pfrom.m_tx_relay->pfilter) {\n-                        sendMerkleBlock = true;\n-                        merkleBlock = CMerkleBlock(*pblock, *pfrom.m_tx_relay->pfilter);\n-                    }\n-                }\n-                if (sendMerkleBlock) {\n-                    m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::MERKLEBLOCK, merkleBlock));\n-                    // CMerkleBlock just contains hashes, so also push any transactions in the block the client did not see\n-                    // This avoids hurting performance by pointlessly requiring a round-trip\n-                    // Note that there is currently no way for a node to request any single transactions we didn't send here -\n-                    // they must either disconnect and retry or request the full block.\n-                    // Thus, the protocol spec specified allows for us to provide duplicate txn here,\n-                    // however we MUST always provide at least what the remote peer needs\n-                    typedef std::pair<unsigned int, uint256> PairType;\n-                    for (PairType& pair : merkleBlock.vMatchedTxn)\n-                        m_connman.PushMessage(&pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *pblock->vtx[pair.first]));\n-                }\n-                // else\n-                    // no response\n-            } else if (inv.IsMsgCmpctBlk()) {\n-                // If a peer is asking for old blocks, we're almost guaranteed\n-                // they won't have a useful mempool to match against a compact block,\n-                // and we don't feel like constructing the object for them, so\n-                // instead we respond with the full, non-compact block.\n-                bool fPeerWantsWitness = State(pfrom.GetId())->fWantsCmpctWitness;\n-                int nSendFlags = fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n-                if (CanDirectFetch() && pindex->nHeight >= m_chainman.ActiveChain().Height() - MAX_CMPCTBLOCK_DEPTH) {\n-                    if ((fPeerWantsWitness || !fWitnessesPresentInARecentCompactBlock) && a_recent_compact_block && a_recent_compact_block->header.GetHash() == pindex->GetBlockHash()) {\n-                        m_connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block));\n-                    } else {\n-                        CBlockHeaderAndShortTxIDs cmpctblock(*pblock, fPeerWantsWitness);\n-                        m_connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n-                    }\n+            // else\n+            // no response\n+        } else if (inv.IsMsgCmpctBlk()) {\n+            // If a peer is asking for old blocks, we're almost guaranteed\n+            // they won't have a useful mempool to match against a compact block,\n+            // and we don't feel like constructing the object for them, so\n+            // instead we respond with the full, non-compact block.\n+            bool fPeerWantsWitness = State(pfrom.GetId())->fWantsCmpctWitness;\n+            int nSendFlags = fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n+            if (CanDirectFetch() && pindex->nHeight >= m_chainman.ActiveChain().Height() - MAX_CMPCTBLOCK_DEPTH) {\n+                if ((fPeerWantsWitness || !fWitnessesPresentInARecentCompactBlock) && a_recent_compact_block && a_recent_compact_block->header.GetHash() == pindex->GetBlockHash()) {\n+                    m_connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block));\n                 } else {\n-                    m_connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCK, *pblock));\n+                    CBlockHeaderAndShortTxIDs cmpctblock(*pblock, fPeerWantsWitness);\n+                    m_connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n                 }\n+            } else {\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCK, *pblock));\n             }\n         }\n+    }\n \n-        {\n-            LOCK(peer.m_block_inv_mutex);\n-            // Trigger the peer node to send a getblocks request for the next batch of inventory\n-            if (inv.hash == peer.m_continuation_block) {\n-                // Send immediately. This must send even if redundant,\n-                // and we want it right after the last block so they don't\n-                // wait for other stuff first.\n-                std::vector<CInv> vInv;\n-                vInv.push_back(CInv(MSG_BLOCK, m_chainman.ActiveChain().Tip()->GetBlockHash()));\n-                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::INV, vInv));\n-                peer.m_continuation_block.SetNull();\n-            }\n+    {\n+        LOCK(peer.m_block_inv_mutex);\n+        // Trigger the peer node to send a getblocks request for the next batch of inventory\n+        if (inv.hash == peer.m_continuation_block) {\n+            // Send immediately. This must send even if redundant,\n+            // and we want it right after the last block so they don't\n+            // wait for other stuff first.\n+            std::vector<CInv> vInv;\n+            vInv.push_back(CInv(MSG_BLOCK, m_chainman.ActiveChain().Tip()->GetBlockHash()));\n+            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::INV, vInv));\n+            peer.m_continuation_block.SetNull();\n         }\n     }\n }"
      }
    ]
  }
]