NicolasDorier,2018-03-08T18:33:08Z,utACK b0928df,https://github.com/bitcoin/bitcoin/pull/12634#issuecomment-371580080,371580080,
promag,2018-05-15T13:32:07Z,utACK 8154223.,https://github.com/bitcoin/bitcoin/pull/12634#issuecomment-389167631,389167631,
jimpo,2018-05-18T22:29:35Z,"I find this whole thing unnecessarily confusing. Not your change in particular, more how the code works today.\n\nThere are two separate config limits, `-limitancestorcount` and `-limitdescendantcount`, which are treated as the same and merged into a single limit `nMaxChainLength`. Then that value is compared against both the ancestor count and descendant count of the transaction containing the ",https://github.com/bitcoin/bitcoin/pull/12634#issuecomment-390349147,390349147,
kallewoof,2018-05-19T01:44:47Z,"@jimpo Yeah it's not entirely straightforward that's for sure, and I think further consideration should be given. I don't think this PR makes the situation worse, though.",https://github.com/bitcoin/bitcoin/pull/12634#issuecomment-390369692,390369692,
jimpo,2018-05-19T17:42:33Z,"Well, I think it does make things worse because it formalizes the concept of a `chain_limit_value`, which is a broken concept. If such a value were useful, it should really be two things, the count of ancestors and the max count of descendants of any ancestor. But furthermore, to calculate them (especially the latter), it's helpful to have an explicit limit on the depth of recursive searching, whi",https://github.com/bitcoin/bitcoin/pull/12634#issuecomment-390421080,390421080,
kallewoof,2018-05-21T00:43:11Z,"@jimpo Thanks for spelling it out. To summarize:\n\n1. The max ancestors and max descendants stuff is needlessly complex and can be simplified.\n2. It is also broken.\n3. It can be replaced with a single value (e.g. `max descendants`) that checks the descendant count of the top parent in the mempool.\n\nDoes that seem accurate?",https://github.com/bitcoin/bitcoin/pull/12634#issuecomment-390526011,390526011,
kallewoof,2018-05-21T02:02:10Z,"Delving into this a bit further, the ascendant vs descendant thing is quite different. There's usually only one ascendant per transaction except if several transactions were merged together, while there can be a tree of transactions as descendants.\n\nI'm wondering if this should instead be ""max unconfirmed group size"", and default to the sum of the default values for max descendants/ascendants.",https://github.com/bitcoin/bitcoin/pull/12634#issuecomment-390533449,390533449,
kallewoof,2018-05-21T02:08:15Z,"Actually, I think the more straightforward fix here is to fix ~~the description of max descendants~~  the max descendants check, and to add it to the eligibility filter.\n\nThis PR can then be rewritten to take both max ancestors and max descendants. That would address your concerns, right?",https://github.com/bitcoin/bitcoin/pull/12634#issuecomment-390534179,390534179,
kallewoof,2018-05-21T04:06:23Z,"@jimpo \n\n* 2d8748b adds a `max_descendants` to the eligibility class and uses it in the eligibility method in coin selection\n* 4e742ba addresses the max descendants check to iterate over parents and using the top parent's descendant count. This is not exact, because a tx with multiple parents in the mempool will pick one of them and only use its values, but it's better than what we are doing",https://github.com/bitcoin/bitcoin/pull/12634#issuecomment-390547697,390547697,
ryanofsky,2018-05-23T18:05:15Z,"From https://botbot.me/freenode/bitcoin-core-dev/msg/100337736/ on motivation for this change:\n\n> \<kallewoof\> When doing coin selection on groups rather than individual outputs, the ancestor/descendant stuff becomes rather messy if you don't unify them to their corresponding maximums. In order to do that, you need the values, since they are tested against multiple limits.",https://github.com/bitcoin/bitcoin/pull/12634#issuecomment-391443804,391443804,
jimpo,2018-05-24T06:03:57Z,utACK 6e56fef. Would be nice to have a unit test for `CTxMemPool::GetTransactionAncestry` though. :-),https://github.com/bitcoin/bitcoin/pull/12634#issuecomment-391598714,391598714,
kallewoof,2018-05-24T09:52:06Z,"@jimpo I added tests in fcf1ed7 -- it would be great if you could check that the expected values matches what you would expect (checking the very last test is probably quickest, as each test simply builds on the previous one).",https://github.com/bitcoin/bitcoin/pull/12634#issuecomment-391656865,391656865,
sdaftuar,2018-05-24T12:50:56Z,"@kallewoof Sorry I missed you on IRC, but thanks for responding.\n\n> <kallewoof> When doing coin selection on groups rather than individual outputs, the ancestor/descendant stuff becomes rather messy if you don't unify them to their corresponding maximums. In order to do that, you need the values, since they are tested against multiple limits.\n\nI guess I don't understand how this relates be",https://github.com/bitcoin/bitcoin/pull/12634#issuecomment-391702756,391702756,
kallewoof,2018-05-25T04:04:22Z,"@sdaftuar Yes, I think most of the time the unspent trusted outputs will be your own and will probably not do address reuse, but I don't think it's guaranteed to always be that way.\n\nEither way, once the coin selection is done per-group rather than per-output, it has to either iterate over all the outputs and check the limits each time, or it can cache it by storing the ancestry in the group s",https://github.com/bitcoin/bitcoin/pull/12634#issuecomment-391935011,391935011,
jimpo,2018-05-30T19:05:52Z,ACK e39efa8c9da85737393ca93bcda711774115702c,https://github.com/bitcoin/bitcoin/pull/12634#issuecomment-393280940,393280940,
kallewoof,2018-05-31T04:33:59Z,Squashed fix-commits into 5ad55d2.,https://github.com/bitcoin/bitcoin/pull/12634#issuecomment-393399262,393399262,
Empact,2018-06-11T10:37:12Z,utACK f77e1d3,https://github.com/bitcoin/bitcoin/pull/12634#issuecomment-396199530,396199530,
laanwj,2018-06-11T14:25:40Z,"utACK f77e1d34fd5f17304ce319b5f962b8005592501a\n\nI'm going to ignore last-minute nits here, sorry. This has too many reviews to hold it up on nits.",https://github.com/bitcoin/bitcoin/pull/12634#issuecomment-396262231,396262231,
sdaftuar,2018-06-11T15:01:55Z,"Sorry I haven't dug into this change myself, but might this have a material performance impact on wallets with many unconfirmed coins, if the mempool is full?",https://github.com/bitcoin/bitcoin/pull/12634#issuecomment-396275287,396275287,
kallewoof,2018-06-11T16:03:47Z,"@sdaftuar I honestly doubt it, unless they have a TON of ancestors in the mempool. I was initially hesitant to make the ancestor check ""thorough"" but couldn't come up with a reason why it would ever be the case that you have enough transactions in the mempool to make the ancestor check bog down your system significantly.",https://github.com/bitcoin/bitcoin/pull/12634#issuecomment-396296243,396296243,
promag,2018-03-07T18:20:42Z,Snake case is for variables.,https://github.com/bitcoin/bitcoin/pull/12634#discussion_r172936877,172936877,src/txmempool.cpp
promag,2018-03-07T18:25:20Z,If not in the mempool could return 0 since `GetCountWithAncestors` and `GetCountWithDescendants` are always `> 0` (self is counted). In that case you can revert s/uint64_t/int64_t.,https://github.com/bitcoin/bitcoin/pull/12634#discussion_r172938327,172938327,src/txmempool.h
kallewoof,2018-03-07T18:35:00Z,"It seems like we are moving to snake case, e.g. for new code like\n\nhttps://github.com/bitcoin/bitcoin/blob/a34ac6ae0788b50e12dd2c8ac59dbda2a03a3c2e/src/cuckoocache.h#L92\n\nMaybe I'm mistaken on that one. Will check recent merges.",https://github.com/bitcoin/bitcoin/pull/12634#discussion_r172941467,172941467,src/txmempool.cpp
promag,2018-03-07T19:25:20Z,"From the developer notes:\n  - Variable and namespace names are all lowercase, and may use `_` to\n    separate words (snake_case).\n  - Class names, function names and method names are UpperCamelCase\n    (PascalCase).\n",https://github.com/bitcoin/bitcoin/pull/12634#discussion_r172956896,172956896,src/txmempool.cpp
NicolasDorier,2018-03-07T19:33:29Z,I looked in the code and it seems to me they can be both 0 and that self is not counted.,https://github.com/bitcoin/bitcoin/pull/12634#discussion_r172959441,172959441,src/txmempool.h
promag,2018-03-07T19:52:36Z,"@NicolasDorier have you checked these?\nhttps://github.com/bitcoin/bitcoin/blob/a34ac6ae0788b50e12dd2c8ac59dbda2a03a3c2e/src/txmempool.cpp#L30\nhttps://github.com/bitcoin/bitcoin/blob/a34ac6ae0788b50e12dd2c8ac59dbda2a03a3c2e/src/txmempool.cpp#L36\nhttps://github.com/bitcoin/bitcoin/blob/a34ac6ae0788b50e12dd2c8ac59dbda2a03a3c2e/src/txmempool.cpp#L317\nhttps://github.com/bitcoin/bitcoin/blob/a34",https://github.com/bitcoin/bitcoin/pull/12634#discussion_r172964915,172964915,src/txmempool.h
NicolasDorier,2018-03-07T21:07:51Z,"woops, completely missed that indeed. I failed to notice how the clients were forcing this invariant though.",https://github.com/bitcoin/bitcoin/pull/12634#discussion_r172984929,172984929,src/txmempool.h
NicolasDorier,2018-03-07T21:11:41Z,Got confused when I saw [that](https://github.com/bitcoin/bitcoin/blob/9501dc27b336fc20adb0c367e0904b57bd507f51/src/txmempool.cpp#L857) which seemed to me it could be 0.,https://github.com/bitcoin/bitcoin/pull/12634#discussion_r172985902,172985902,src/txmempool.h
kallewoof,2018-03-08T15:42:34Z,"Wow, okay. I totally missed that, thanks!",https://github.com/bitcoin/bitcoin/pull/12634#discussion_r173196924,173196924,src/txmempool.cpp
kallewoof,2018-03-08T15:43:32Z,I made the change for a reason but that reason may have been flawed. I'll try it with uint64_t and 0 again. Thanks!,https://github.com/bitcoin/bitcoin/pull/12634#discussion_r173197224,173197224,src/txmempool.h
kallewoof,2018-03-08T16:37:11Z,Fixed.,https://github.com/bitcoin/bitcoin/pull/12634#discussion_r173215045,173215045,src/txmempool.cpp
kallewoof,2018-03-08T17:08:24Z,"The thing is, the check in `SelectCoinsMinConf` checks if the chain limit value `>= nMaxAncestors`, which is `0` for `no chained ancestors` in the code. With the old method, this would be true, but with a 0 returned, it would be false.\n\nI could change the `0` to a `1` to fix it, which may be a better solution here, and is probably what I will end up doing.",https://github.com/bitcoin/bitcoin/pull/12634#discussion_r173225129,173225129,src/txmempool.h
kallewoof,2018-03-08T17:14:24Z,"If I do that, the semantics becomes misleading. It says 'max *ancestors*' so 1 makes it sound like it allows 1 ancestor or descendant, when in reality it only counts itself. I'm gonna keep the change to signed, for now.",https://github.com/bitcoin/bitcoin/pull/12634#discussion_r173226846,173226846,src/txmempool.h
NicolasDorier,2018-03-08T18:32:31Z,"Indeed, now:\n\nwith @promag suggestion,  if `nMaxAncestors==0` and the tx is not in mempool then `mempool.ChainLimitValue(pcoin->GetHash()) >= nMaxAncestors` evaluate to `true`.\n\nWhile before `!mempool.TransactionWithinChainLimit(pcoin->GetHash(), nMaxAncestors)` evaluate to `false`.",https://github.com/bitcoin/bitcoin/pull/12634#discussion_r173249025,173249025,src/txmempool.h
Empact,2018-05-21T07:43:36Z,Maybe add some bounds-checking asserts here ala `assert(int64_t(nCountWithDescendants) > 0);`,https://github.com/bitcoin/bitcoin/pull/12634#discussion_r189515577,189515577,src/txmempool.cpp
jimpo,2018-05-21T15:51:51Z,"commit: Switch to GetTransactionAncestry() in OutputEligibleForSpending\n\nI think these should be strict `>` checks, in which case you don't need to switch to signed results. This makes sense logically because ancestors and descendants counts includes the transaction queried, so if the count is at the maximum allowable, it is still valid to create one more in the chain.",https://github.com/bitcoin/bitcoin/pull/12634#discussion_r189631391,189631391,src/wallet/wallet.cpp
jimpo,2018-05-21T15:54:29Z,"commit: mempool: Fix max descendants check\n\nYou actually need to recurse down all parents and take the max `GetCountWithDescendants` of all ancestors. A transaction can have multiple chains of ancestry with different descendants counts. This is also why it kind of makes sense to take the descendants limit as a parameter to this method rather than (or in addition to) returning it -- because it ",https://github.com/bitcoin/bitcoin/pull/12634#discussion_r189632127,189632127,src/txmempool.cpp
kallewoof,2018-05-21T23:35:17Z,I was afraid that would be too resource intensive and potential for DoS. Doing a 'depth first optimistic pass' seemed like a good estimate.,https://github.com/bitcoin/bitcoin/pull/12634#discussion_r189742119,189742119,src/txmempool.cpp
kallewoof,2018-05-21T23:35:56Z,"It means having to change the parameter for all the calls (bump by 1), but I think you're right. The -1 hack is bad. Fixing.",https://github.com/bitcoin/bitcoin/pull/12634#discussion_r189742212,189742212,src/wallet/wallet.cpp
kallewoof,2018-05-21T23:36:22Z,"I'm going to switch back to unsigned, so no need.",https://github.com/bitcoin/bitcoin/pull/12634#discussion_r189742259,189742259,src/txmempool.cpp
kallewoof,2018-05-22T02:15:23Z,"I had to do one minor tweak, but otherwise the current values worked even with the change. I also switched from `nMaxChainLength` to using `max_ancestors` and `max_descendants` with their corresponding defaults. (See 6ab847bce76224ff46552dd647b542fa70350a91.)",https://github.com/bitcoin/bitcoin/pull/12634#discussion_r189761725,189761725,src/wallet/wallet.cpp
jimpo,2018-05-22T19:34:06Z,This underflows if nMaxChainLength is 0.,https://github.com/bitcoin/bitcoin/pull/12634#discussion_r190026352,190026352,src/wallet/wallet.cpp
jimpo,2018-05-22T19:38:07Z,This underflows if max_ancestors or max_descendants is 0.,https://github.com/bitcoin/bitcoin/pull/12634#discussion_r190027446,190027446,src/wallet/wallet.cpp
jimpo,2018-05-22T19:42:01Z,"Hmm, I understand the concern, but this doesn't match the advertised behavior of the flag. Also, the ancestor limit can be used to limit the depth of recursion. I'd like some more opinions on this.",https://github.com/bitcoin/bitcoin/pull/12634#discussion_r190028623,190028623,src/txmempool.cpp
kallewoof,2018-05-22T23:38:27Z,"Fixed (I set `nMaxChainLength` to `std::max(1, ...)`).",https://github.com/bitcoin/bitcoin/pull/12634#discussion_r190085632,190085632,src/wallet/wallet.cpp
kallewoof,2018-05-22T23:38:45Z,"Fixed (set both to `std::max(1, ...)`).",https://github.com/bitcoin/bitcoin/pull/12634#discussion_r190085698,190085698,src/wallet/wallet.cpp
kallewoof,2018-05-23T00:14:54Z,"After thinking about it for a bit, I am not convinced it's particularly DoS vulnerable. I pushed a commit (to squash) that calculates it the way it is advertised.",https://github.com/bitcoin/bitcoin/pull/12634#discussion_r190091440,190091440,src/txmempool.cpp
Empact,2018-06-11T10:01:23Z,nit: `++i`,https://github.com/bitcoin/bitcoin/pull/12634#discussion_r194351477,194351477,src/test/mempool_tests.cpp
Empact,2018-06-11T10:05:47Z,"nit: should be faster if you read the return value from the insertion, rather than find & insert.",https://github.com/bitcoin/bitcoin/pull/12634#discussion_r194352605,194352605,src/txmempool.cpp
kallewoof,2018-06-11T10:08:47Z,Didn't realize `set::insert` told you if the insertion happened. Nice!,https://github.com/bitcoin/bitcoin/pull/12634#discussion_r194353350,194353350,src/txmempool.cpp
Empact,2018-06-11T10:32:01Z,"nit: more true to form to use a `std::stack` here, although I see they're not used otherwise in the codebase fwiw.",https://github.com/bitcoin/bitcoin/pull/12634#discussion_r194359025,194359025,src/txmempool.cpp
promag,2018-06-11T10:42:28Z,"nit,\n```cpp\nstd::vector<txiter> candidates = {entry};\n```\nand remove `push_back` below.",https://github.com/bitcoin/bitcoin/pull/12634#discussion_r194361464,194361464,src/txmempool.cpp
promag,2018-06-11T10:55:02Z,nit `const txiter& entry`.,https://github.com/bitcoin/bitcoin/pull/12634#discussion_r194364187,194364187,src/txmempool.cpp
