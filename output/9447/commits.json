[
  {
    "sha": "d0260aea66dc3e9f5233842f088d83cceacc6cd8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMDI2MGFlYTY2ZGMzZTlmNTIzMzg0MmYwODhkODNjY2VhY2M2Y2Q4",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2016-12-29T19:44:21Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2017-02-14T18:30:00Z"
      },
      "message": "Turn mapBlocksInFlight into a multimap",
      "tree": {
        "sha": "fe84305b17f1721ef85e85143a211b20813bfc0c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fe84305b17f1721ef85e85143a211b20813bfc0c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d0260aea66dc3e9f5233842f088d83cceacc6cd8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d0260aea66dc3e9f5233842f088d83cceacc6cd8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d0260aea66dc3e9f5233842f088d83cceacc6cd8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d0260aea66dc3e9f5233842f088d83cceacc6cd8/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a441db01b527431a3d7ba169f1afd9c3bc04748f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a441db01b527431a3d7ba169f1afd9c3bc04748f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a441db01b527431a3d7ba169f1afd9c3bc04748f"
      }
    ],
    "stats": {
      "total": 137,
      "additions": 89,
      "deletions": 48
    },
    "files": [
      {
        "sha": "9d0bcf121774692b60290c773e6237fd1485a7a9",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 89,
        "deletions": 48,
        "changes": 137,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0260aea66dc3e9f5233842f088d83cceacc6cd8/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0260aea66dc3e9f5233842f088d83cceacc6cd8/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=d0260aea66dc3e9f5233842f088d83cceacc6cd8",
        "patch": "@@ -106,7 +106,8 @@ namespace {\n         bool fValidatedHeaders;                                  //!< Whether this block has validated headers at the time of request.\n         std::unique_ptr<PartiallyDownloadedBlock> partialBlock;  //!< Optional, used for CMPCTBLOCK downloads\n     };\n-    std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> > mapBlocksInFlight;\n+    typedef std::multimap<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator>> BlockDownloadMap;\n+    BlockDownloadMap mmapBlocksInFlight;\n \n     /** Stack of nodes which we have set to announce using compact blocks */\n     std::list<NodeId> lNodesAnnouncingHeaderAndIDs;\n@@ -231,7 +232,6 @@ CNodeState *State(NodeId pnode) {\n         return NULL;\n     return &it->second;\n }\n-\n void UpdatePreferredDownload(CNode* node, CNodeState* state)\n {\n     nPreferredDownload -= state->fPreferredDownload;\n@@ -274,6 +274,41 @@ void InitializeNode(CNode *pnode, CConnman& connman) {\n         PushNodeVersion(pnode, connman, GetTime());\n }\n \n+// Requires cs_main\n+// Helper function for MarkBlockAsReceived and MarkBlockAsNotInFlight\n+void ClearDownloadState(BlockDownloadMap::iterator itInFlight) {\n+    CNodeState *state = State(itInFlight->second.first);\n+    state->nBlocksInFlightValidHeaders -= itInFlight->second.second->fValidatedHeaders;\n+    if (state->nBlocksInFlightValidHeaders == 0 && itInFlight->second.second->fValidatedHeaders) {\n+        // Last validated block on the queue was received.\n+        nPeersWithValidatedDownloads--;\n+    }\n+    if (state->vBlocksInFlight.begin() == itInFlight->second.second) {\n+        // First block on the queue was received, update the start download time for the next one\n+        state->nDownloadingSince = std::max(state->nDownloadingSince, GetTimeMicros());\n+    }\n+    state->vBlocksInFlight.erase(itInFlight->second.second);\n+    state->nBlocksInFlight--;\n+    state->nStallingSince = 0;\n+}\n+\n+// Requires cs_main.\n+// Used to remove block from mmapBlocksInFlight and clear the download state for\n+// a block if for some reason block was not received. Download state clearing is\n+// skipped as an optimization in FinalizeNode.\n+void MarkBlockAsNotInFlight(const uint256& hash, NodeId nodeid, bool clearState = true) {\n+    std::pair<BlockDownloadMap::iterator, BlockDownloadMap::iterator> range = mmapBlocksInFlight.equal_range(hash);\n+    while (range.first != range.second) {\n+        BlockDownloadMap::iterator itInFlight = range.first;\n+        range.first++;\n+        if (itInFlight->second.first == nodeid) {\n+            if (clearState)\n+                ClearDownloadState(itInFlight);\n+            mmapBlocksInFlight.erase(itInFlight);\n+        }\n+    }\n+}\n+\n void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n     fUpdateConnectionTime = false;\n     LOCK(cs_main);\n@@ -287,7 +322,7 @@ void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n     }\n \n     BOOST_FOREACH(const QueuedBlock& entry, state->vBlocksInFlight) {\n-        mapBlocksInFlight.erase(entry.hash);\n+        MarkBlockAsNotInFlight(entry.hash, nodeid, false);\n     }\n     EraseOrphansFor(nodeid);\n     nPreferredDownload -= state->fPreferredDownload;\n@@ -298,35 +333,24 @@ void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n \n     if (mapNodeState.empty()) {\n         // Do a consistency check after the last peer is removed.\n-        assert(mapBlocksInFlight.empty());\n+        assert(mmapBlocksInFlight.empty());\n         assert(nPreferredDownload == 0);\n         assert(nPeersWithValidatedDownloads == 0);\n     }\n }\n \n+\n // Requires cs_main.\n // Returns a bool indicating whether we requested this block.\n-// Also used if a block was /not/ received and timed out or started with another peer\n bool MarkBlockAsReceived(const uint256& hash) {\n-    std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n-    if (itInFlight != mapBlocksInFlight.end()) {\n-        CNodeState *state = State(itInFlight->second.first);\n-        state->nBlocksInFlightValidHeaders -= itInFlight->second.second->fValidatedHeaders;\n-        if (state->nBlocksInFlightValidHeaders == 0 && itInFlight->second.second->fValidatedHeaders) {\n-            // Last validated block on the queue was received.\n-            nPeersWithValidatedDownloads--;\n-        }\n-        if (state->vBlocksInFlight.begin() == itInFlight->second.second) {\n-            // First block on the queue was received, update the start download time for the next one\n-            state->nDownloadingSince = std::max(state->nDownloadingSince, GetTimeMicros());\n-        }\n-        state->vBlocksInFlight.erase(itInFlight->second.second);\n-        state->nBlocksInFlight--;\n-        state->nStallingSince = 0;\n-        mapBlocksInFlight.erase(itInFlight);\n-        return true;\n-    }\n-    return false;\n+    bool found = false;\n+    std::pair<BlockDownloadMap::iterator, BlockDownloadMap::iterator> range = mmapBlocksInFlight.equal_range(hash);\n+    while (range.first != range.second) {\n+        found = true;\n+        ClearDownloadState(range.first);\n+        range.first = mmapBlocksInFlight.erase(range.first);\n+    }\n+    return found;\n }\n \n // Requires cs_main.\n@@ -337,15 +361,16 @@ bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Pa\n     assert(state != NULL);\n \n     // Short-circuit most stuff in case its from the same node\n-    std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n-    if (itInFlight != mapBlocksInFlight.end() && itInFlight->second.first == nodeid) {\n-        *pit = &itInFlight->second.second;\n-        return false;\n+    std::pair<BlockDownloadMap::iterator, BlockDownloadMap::iterator> range = mmapBlocksInFlight.equal_range(hash);\n+    while (range.first != range.second) {\n+        BlockDownloadMap::iterator itInFlight = range.first;\n+        range.first++;\n+        if (itInFlight->second.first == nodeid) {\n+            *pit = &itInFlight->second.second;\n+            return false;\n+        }\n     }\n \n-    // Make sure it's not listed somewhere already.\n-    MarkBlockAsReceived(hash);\n-\n     std::list<QueuedBlock>::iterator it = state->vBlocksInFlight.insert(state->vBlocksInFlight.end(),\n             {hash, pindex, pindex != NULL, std::unique_ptr<PartiallyDownloadedBlock>(pit ? new PartiallyDownloadedBlock(&mempool) : NULL)});\n     state->nBlocksInFlight++;\n@@ -357,7 +382,7 @@ bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Pa\n     if (state->nBlocksInFlightValidHeaders == 1 && pindex != NULL) {\n         nPeersWithValidatedDownloads++;\n     }\n-    itInFlight = mapBlocksInFlight.insert(std::make_pair(hash, std::make_pair(nodeid, it))).first;\n+    BlockDownloadMap::iterator itInFlight = mmapBlocksInFlight.insert(std::make_pair(hash, std::make_pair(nodeid, it)));\n     if (pit)\n         *pit = &itInFlight->second.second;\n     return true;\n@@ -532,7 +557,7 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n             if (pindex->nStatus & BLOCK_HAVE_DATA || chainActive.Contains(pindex)) {\n                 if (pindex->nChainTx)\n                     state->pindexLastCommonBlock = pindex;\n-            } else if (mapBlocksInFlight.count(pindex->GetBlockHash()) == 0) {\n+            } else if (mmapBlocksInFlight.count(pindex->GetBlockHash()) == 0) {\n                 // The block is not already downloaded, and not yet in flight.\n                 if (pindex->nHeight > nWindowEnd) {\n                     // We reached the end of the window.\n@@ -548,7 +573,7 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n                 }\n             } else if (waitingfor == -1) {\n                 // This is the first already-in-flight block.\n-                waitingfor = mapBlocksInFlight[pindex->GetBlockHash()].first;\n+                waitingfor = mmapBlocksInFlight.lower_bound(pindex->GetBlockHash())->second.first;\n             }\n         }\n     }\n@@ -871,7 +896,7 @@ void PeerLogicValidation::BlockChecked(const CBlock& block, const CValidationSta\n     //    just check that there are currently no other blocks in flight.\n     else if (state.IsValid() &&\n              !IsInitialBlockDownload() &&\n-             mapBlocksInFlight.count(hash) == mapBlocksInFlight.size()) {\n+             mmapBlocksInFlight.count(hash) == mmapBlocksInFlight.size()) {\n         if (it != mapBlockSource.end()) {\n             MaybeSetPeerAsAnnouncingHeaderAndIDs(it->second.first, *connman);\n         }\n@@ -1549,7 +1574,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n             if (inv.type == MSG_BLOCK) {\n                 UpdateBlockAvailability(pfrom->GetId(), inv.hash);\n-                if (!fAlreadyHave && !fImporting && !fReindex && !mapBlocksInFlight.count(inv.hash)) {\n+                if (!fAlreadyHave && !fImporting && !fReindex && !mmapBlocksInFlight.count(inv.hash)) {\n                     // We used to request the full block here, but since headers-announcements are now the\n                     // primary method of announcement on the network, and since, in the case that a node\n                     // fell back to inv we probably have a reorg which we should get the headers for first,\n@@ -2005,8 +2030,14 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         assert(pindex);\n         UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());\n \n-        std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());\n-        bool fAlreadyInFlight = blockInFlightIt != mapBlocksInFlight.end();\n+        std::pair<BlockDownloadMap::iterator, BlockDownloadMap::iterator> rangeInFlight = mmapBlocksInFlight.equal_range(pindex->GetBlockHash());\n+        bool fAlreadyInFlight = rangeInFlight.first != rangeInFlight.second;\n+        bool fInFlightFromSamePeer = false;\n+        while (rangeInFlight.first != rangeInFlight.second) {\n+            if (rangeInFlight.first->second.first == pfrom->GetId())\n+                fInFlightFromSamePeer = true;\n+            rangeInFlight.first++;\n+        }\n \n         if (pindex->nStatus & BLOCK_HAVE_DATA) // Nothing to do here\n             return true;\n@@ -2039,8 +2070,8 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // possibilities in compact block processing...\n         if (pindex->nHeight <= chainActive.Height() + 2) {\n             if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n-                 (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {\n-                std::list<QueuedBlock>::iterator* queuedBlockIt = NULL;\n+                fInFlightFromSamePeer) {\n+                std::list<QueuedBlock>::iterator *queuedBlockIt = NULL;\n                 if (!MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex, &queuedBlockIt)) {\n                     if (!(*queuedBlockIt)->partialBlock)\n                         (*queuedBlockIt)->partialBlock.reset(new PartiallyDownloadedBlock(&mempool));\n@@ -2054,7 +2085,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 PartiallyDownloadedBlock& partialBlock = *(*queuedBlockIt)->partialBlock;\n                 ReadStatus status = partialBlock.InitData(cmpctblock, vExtraTxnForCompact);\n                 if (status == READ_STATUS_INVALID) {\n-                    MarkBlockAsReceived(pindex->GetBlockHash()); // Reset in-flight state in case of whitelist\n+                    MarkBlockAsNotInFlight(pindex->GetBlockHash(), pfrom->GetId()); // Reset in-flight state in case of whitelist\n                     Misbehaving(pfrom->GetId(), 100);\n                     LogPrintf(\"Peer %d sent us invalid compact block\\n\", pfrom->id);\n                     return true;\n@@ -2158,17 +2189,27 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         {\n             LOCK(cs_main);\n \n-            std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator it = mapBlocksInFlight.find(resp.blockhash);\n-            if (it == mapBlocksInFlight.end() || !it->second.second->partialBlock ||\n-                    it->second.first != pfrom->GetId()) {\n+            bool fExpectedBLOCKTXN = false;\n+            std::pair<BlockDownloadMap::iterator, BlockDownloadMap::iterator> rangeInFlight = mmapBlocksInFlight.equal_range(resp.blockhash);\n+            BlockDownloadMap::iterator it = rangeInFlight.first;\n+            while (it != rangeInFlight.second) {\n+                if (it->second.first == pfrom->GetId()) {\n+                    if (it->second.second->partialBlock)\n+                        fExpectedBLOCKTXN = true;\n+                    break;\n+                }\n+                it++;\n+            }\n+\n+            if (!fExpectedBLOCKTXN) {\n                 LogPrint(\"net\", \"Peer %d sent us block transactions for block we weren't expecting\\n\", pfrom->id);\n                 return true;\n             }\n \n             PartiallyDownloadedBlock& partialBlock = *it->second.second->partialBlock;\n             ReadStatus status = partialBlock.FillBlock(*pblock, resp.txn);\n             if (status == READ_STATUS_INVALID) {\n-                MarkBlockAsReceived(resp.blockhash); // Reset in-flight state in case of whitelist\n+                MarkBlockAsNotInFlight(resp.blockhash, pfrom->GetId()); // Reset in-flight state in case of whitelist\n                 Misbehaving(pfrom->GetId(), 100);\n                 LogPrintf(\"Peer %d sent us invalid compact block/non-matching block transactions\\n\", pfrom->id);\n                 return true;\n@@ -2207,7 +2248,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         } // Don't hold cs_main when we call into ProcessNewBlock\n         if (fBlockRead) {\n             bool fNewBlock = false;\n-            // Since we requested this block (it was in mapBlocksInFlight), force it to be processed,\n+            // Since we requested this block (it was in mmapBlocksInFlight), force it to be processed,\n             // even if it would not be a candidate for new tip (missing previous block, chain not long enough, etc)\n             ProcessNewBlock(chainparams, pblock, true, &fNewBlock);\n             if (fNewBlock)\n@@ -2320,7 +2361,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // Calculate all the blocks we'd need to switch to pindexLast, up to a limit.\n             while (pindexWalk && !chainActive.Contains(pindexWalk) && vToFetch.size() <= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n                 if (!(pindexWalk->nStatus & BLOCK_HAVE_DATA) &&\n-                        !mapBlocksInFlight.count(pindexWalk->GetBlockHash()) &&\n+                        !mmapBlocksInFlight.count(pindexWalk->GetBlockHash()) &&\n                         (!IsWitnessEnabled(pindexWalk->pprev, chainparams.GetConsensus()) || State(pfrom->GetId())->fHaveWitness)) {\n                     // We don't have this block, and it's not yet in flight.\n                     vToFetch.push_back(pindexWalk);\n@@ -2354,7 +2395,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                             pindexLast->GetBlockHash().ToString(), pindexLast->nHeight);\n                 }\n                 if (vGetData.size() > 0) {\n-                    if (nodestate->fSupportsDesiredCmpctVersion && vGetData.size() == 1 && mapBlocksInFlight.size() == 1 && pindexLast->pprev->IsValid(BLOCK_VALID_CHAIN)) {\n+                    if (nodestate->fSupportsDesiredCmpctVersion && vGetData.size() == 1 && mmapBlocksInFlight.size() == 1 && pindexLast->pprev->IsValid(BLOCK_VALID_CHAIN)) {\n                         // In any case, we want to download using a compact block, not a regular one\n                         vGetData[0] = CInv(MSG_CMPCT_BLOCK, vGetData[0].hash);\n                     }"
      }
    ]
  },
  {
    "sha": "f66254fa2d7e07070a7c863708103de61b621c7e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNjYyNTRmYTJkN2UwNzA3MGE3Yzg2MzcwODEwM2RlNjFiNjIxYzdl",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2016-12-29T21:22:30Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2017-02-14T18:30:00Z"
      },
      "message": "Only mark block as received if BLOCK_VALID_TRANSACTIONS",
      "tree": {
        "sha": "cb0ad255be8ead7eaf99836b9a4d42884fd14a48",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cb0ad255be8ead7eaf99836b9a4d42884fd14a48"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f66254fa2d7e07070a7c863708103de61b621c7e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f66254fa2d7e07070a7c863708103de61b621c7e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f66254fa2d7e07070a7c863708103de61b621c7e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f66254fa2d7e07070a7c863708103de61b621c7e/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d0260aea66dc3e9f5233842f088d83cceacc6cd8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d0260aea66dc3e9f5233842f088d83cceacc6cd8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d0260aea66dc3e9f5233842f088d83cceacc6cd8"
      }
    ],
    "stats": {
      "total": 46,
      "additions": 24,
      "deletions": 22
    },
    "files": [
      {
        "sha": "8624abbef380345cf26c3f49c2a7f5fae636e745",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 22,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f66254fa2d7e07070a7c863708103de61b621c7e/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f66254fa2d7e07070a7c863708103de61b621c7e/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=f66254fa2d7e07070a7c863708103de61b621c7e",
        "patch": "@@ -275,7 +275,7 @@ void InitializeNode(CNode *pnode, CConnman& connman) {\n }\n \n // Requires cs_main\n-// Helper function for MarkBlockAsReceived and MarkBlockAsNotInFlight\n+// Helper function for MarkBlockAsReceivedIfValid and MarkBlockAsNotInFlight\n void ClearDownloadState(BlockDownloadMap::iterator itInFlight) {\n     CNodeState *state = State(itInFlight->second.first);\n     state->nBlocksInFlightValidHeaders -= itInFlight->second.second->fValidatedHeaders;\n@@ -341,16 +341,19 @@ void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n \n \n // Requires cs_main.\n-// Returns a bool indicating whether we requested this block.\n-bool MarkBlockAsReceived(const uint256& hash) {\n-    bool found = false;\n-    std::pair<BlockDownloadMap::iterator, BlockDownloadMap::iterator> range = mmapBlocksInFlight.equal_range(hash);\n-    while (range.first != range.second) {\n-        found = true;\n-        ClearDownloadState(range.first);\n-        range.first = mmapBlocksInFlight.erase(range.first);\n+// Used to remove any remaining download state and references from\n+// mmapBlocksInFlight in case of multiple downloads. But first check that it is\n+// BLOCK_VALID_TRANSACTIONS, if not, remaining outstanding requests may want to\n+// be completed to allow for the possibility of a malleated block.\n+void MarkBlockAsReceivedIfValid(const uint256& hash) {\n+    BlockMap::iterator mi = mapBlockIndex.find(hash);\n+    if (mi != mapBlockIndex.end() && mi->second->IsValid(BLOCK_VALID_TRANSACTIONS)) {\n+        std::pair<BlockDownloadMap::iterator, BlockDownloadMap::iterator> range = mmapBlocksInFlight.equal_range(hash);\n+        while (range.first != range.second) {\n+            ClearDownloadState(range.first);\n+            range.first = mmapBlocksInFlight.erase(range.first);\n+        }\n     }\n-    return found;\n }\n \n // Requires cs_main.\n@@ -2166,17 +2169,9 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             ProcessNewBlock(chainparams, pblock, true, &fNewBlock);\n             if (fNewBlock)\n                 pfrom->nLastBlockTime = GetTime();\n-\n-            LOCK(cs_main); // hold cs_main for CBlockIndex::IsValid()\n-            if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS)) {\n-                // Clear download state for this block, which is in\n-                // process from some other peer.  We do this after calling\n-                // ProcessNewBlock so that a malleated cmpctblock announcement\n-                // can't be used to interfere with block relay.\n-                MarkBlockAsReceived(pblock->GetHash());\n-            }\n+            LOCK(cs_main); // to test validity\n+            MarkBlockAsReceivedIfValid(pblock->GetHash());\n         }\n-\n     }\n \n     else if (strCommand == NetMsgType::BLOCKTXN && !fImporting && !fReindex) // Ignore blocks received while importing\n@@ -2236,7 +2231,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // though the block was successfully read, and rely on the\n                 // handling in ProcessNewBlock to ensure the block index is\n                 // updated, reject messages go out, etc.\n-                MarkBlockAsReceived(resp.blockhash); // it is now an empty pointer\n+                MarkBlockAsNotInFlight(resp.blockhash, pfrom->GetId()); // it is now an empty pointer\n                 fBlockRead = true;\n                 // mapBlockSource is only used for sending reject messages and DoS scores,\n                 // so the race between here and cs_main in ProcessNewBlock is fine.\n@@ -2253,6 +2248,8 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             ProcessNewBlock(chainparams, pblock, true, &fNewBlock);\n             if (fNewBlock)\n                 pfrom->nLastBlockTime = GetTime();\n+            LOCK(cs_main); // to test validity\n+            MarkBlockAsReceivedIfValid(pblock->GetHash());\n         }\n     }\n \n@@ -2423,7 +2420,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             LOCK(cs_main);\n             // Also always process if we requested the block explicitly, as we may\n             // need it even though it is not a candidate for a new best tip.\n-            forceProcessing |= MarkBlockAsReceived(hash);\n+            // TODO: Only process if requested from this peer?\n+            forceProcessing |= mmapBlocksInFlight.count(hash);\n+            // Block is no longer in flight from this peer\n+            MarkBlockAsNotInFlight(hash, pfrom->GetId());\n             // mapBlockSource is only used for sending reject messages and DoS scores,\n             // so the race between here and cs_main in ProcessNewBlock is fine.\n             mapBlockSource.emplace(hash, std::make_pair(pfrom->GetId(), true));\n@@ -2432,6 +2432,8 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         ProcessNewBlock(chainparams, pblock, forceProcessing, &fNewBlock);\n         if (fNewBlock)\n             pfrom->nLastBlockTime = GetTime();\n+        LOCK(cs_main); // to test validity\n+        MarkBlockAsReceivedIfValid(hash);\n     }\n \n "
      }
    ]
  },
  {
    "sha": "8ffd51f8c8d3989ae2b1d381839a504feac19901",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4ZmZkNTFmOGM4ZDM5ODlhZTJiMWQzODE4MzlhNTA0ZmVhYzE5OTAx",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2016-12-29T22:23:07Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2017-02-14T18:30:00Z"
      },
      "message": "Only request full blocks from the peer we thought had the block in-flight\n\nThis is a change in behavior so that if for some reason we request a block from a peer, we don't allow an unsolicited CMPCT_BLOCK announcement for that same block to cause a request for a full block from the uninvited peer (as some type of request is already outstanding from the original peer)",
      "tree": {
        "sha": "95e7528be5adb0b88040f5f04802897627876d5c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/95e7528be5adb0b88040f5f04802897627876d5c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8ffd51f8c8d3989ae2b1d381839a504feac19901",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8ffd51f8c8d3989ae2b1d381839a504feac19901",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8ffd51f8c8d3989ae2b1d381839a504feac19901",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8ffd51f8c8d3989ae2b1d381839a504feac19901/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f66254fa2d7e07070a7c863708103de61b621c7e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f66254fa2d7e07070a7c863708103de61b621c7e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f66254fa2d7e07070a7c863708103de61b621c7e"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 2,
      "deletions": 2
    },
    "files": [
      {
        "sha": "3032bc8bda50612ea02247512b02230aca59efe8",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8ffd51f8c8d3989ae2b1d381839a504feac19901/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8ffd51f8c8d3989ae2b1d381839a504feac19901/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=8ffd51f8c8d3989ae2b1d381839a504feac19901",
        "patch": "@@ -2047,7 +2047,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         if (pindex->nChainWork <= chainActive.Tip()->nChainWork || // We know something better\n                 pindex->nTx != 0) { // We had this block at some point, but pruned it\n-            if (fAlreadyInFlight) {\n+            if (fInFlightFromSamePeer) {\n                 // We requested this block for some reason, but our mempool will probably be useless\n                 // so we just grab the block via normal getdata\n                 std::vector<CInv> vInv(1);\n@@ -2134,7 +2134,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 }\n             }\n         } else {\n-            if (fAlreadyInFlight) {\n+            if (fInFlightFromSamePeer) {\n                 // We requested this block, but its far into the future, so our\n                 // mempool will probably be useless - request the block normally\n                 std::vector<CInv> vInv(1);"
      }
    ]
  },
  {
    "sha": "3f62b2cc1822503b35ec257ef01a64675ac33687",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozZjYyYjJjYzE4MjI1MDNiMzVlYzI1N2VmMDFhNjQ2NzVhYzMzNjg3",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2016-12-29T22:44:11Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2017-02-14T18:31:00Z"
      },
      "message": "Allow multiple compact block reconstructions simultaneously",
      "tree": {
        "sha": "4bf5ec777867d4d3423607d488f6f74d68d45263",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4bf5ec777867d4d3423607d488f6f74d68d45263"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3f62b2cc1822503b35ec257ef01a64675ac33687",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3f62b2cc1822503b35ec257ef01a64675ac33687",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3f62b2cc1822503b35ec257ef01a64675ac33687",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3f62b2cc1822503b35ec257ef01a64675ac33687/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8ffd51f8c8d3989ae2b1d381839a504feac19901",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8ffd51f8c8d3989ae2b1d381839a504feac19901",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8ffd51f8c8d3989ae2b1d381839a504feac19901"
      }
    ],
    "stats": {
      "total": 63,
      "additions": 46,
      "deletions": 17
    },
    "files": [
      {
        "sha": "a09573c8cdd96fbc668dccca5f807170fe1dca9b",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 44,
        "deletions": 17,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3f62b2cc1822503b35ec257ef01a64675ac33687/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3f62b2cc1822503b35ec257ef01a64675ac33687/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=3f62b2cc1822503b35ec257ef01a64675ac33687",
        "patch": "@@ -2036,10 +2036,19 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         std::pair<BlockDownloadMap::iterator, BlockDownloadMap::iterator> rangeInFlight = mmapBlocksInFlight.equal_range(pindex->GetBlockHash());\n         bool fAlreadyInFlight = rangeInFlight.first != rangeInFlight.second;\n         bool fInFlightFromSamePeer = false;\n+        bool fPeerWasFirstRequest = true;\n+        bool peerFound = false;\n+        size_t countPartialBlocksStarted = 0;\n         while (rangeInFlight.first != rangeInFlight.second) {\n-            if (rangeInFlight.first->second.first == pfrom->GetId())\n+            if (rangeInFlight.first->second.first == pfrom->GetId()) {\n                 fInFlightFromSamePeer = true;\n+                peerFound = true;\n+            }\n+            if (rangeInFlight.first->second.second->partialBlock)\n+                countPartialBlocksStarted++;\n             rangeInFlight.first++;\n+            if (!peerFound)\n+                fPeerWasFirstRequest = false;\n         }\n \n         if (pindex->nStatus & BLOCK_HAVE_DATA) // Nothing to do here\n@@ -2048,11 +2057,16 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (pindex->nChainWork <= chainActive.Tip()->nChainWork || // We know something better\n                 pindex->nTx != 0) { // We had this block at some point, but pruned it\n             if (fInFlightFromSamePeer) {\n-                // We requested this block for some reason, but our mempool will probably be useless\n-                // so we just grab the block via normal getdata\n-                std::vector<CInv> vInv(1);\n-                vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus()), cmpctblock.header.GetHash());\n-                connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n+                if (fPeerWasFirstRequest) {\n+                    // We requested this block for some reason, but our mempool will probably be useless\n+                    // so we just grab the block via normal getdata, but only do a full block request from first peer\n+                    std::vector<CInv> vInv(1);\n+                    vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus()), cmpctblock.header.GetHash());\n+                    connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n+                } else {\n+                    // Let first peer request full block, just update inflight state\n+                    MarkBlockAsNotInFlight(pindex->GetBlockHash(), pfrom->GetId());\n+                }\n             }\n             return true;\n         }\n@@ -2072,8 +2086,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // We want to be a bit conservative just to be extra careful about DoS\n         // possibilities in compact block processing...\n         if (pindex->nHeight <= chainActive.Height() + 2) {\n-            if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n-                fInFlightFromSamePeer) {\n+            if ((countPartialBlocksStarted < MAX_CMPCTBLOCKS_INFLIGHT_PER_BLOCK && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER)) {\n                 std::list<QueuedBlock>::iterator *queuedBlockIt = NULL;\n                 if (!MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex, &queuedBlockIt)) {\n                     if (!(*queuedBlockIt)->partialBlock)\n@@ -2094,6 +2107,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     return true;\n                 } else if (status == READ_STATUS_FAILED) {\n                     // Duplicate txindexes, the block is now in-flight, so just request it\n+                    // NOTE: This is the one place two full block requests can be outstanding\n                     std::vector<CInv> vInv(1);\n                     vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus()), cmpctblock.header.GetHash());\n                     connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n@@ -2116,9 +2130,14 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETBLOCKTXN, req));\n                 }\n             } else {\n-                // This block is either already in flight from a different\n-                // peer, or this peer has too many blocks outstanding to\n+                // This block is either already in flight from too many other\n+                // peers, or this peer has too many blocks outstanding to\n                 // download from.\n+                if (fInFlightFromSamePeer) {\n+                    // We had requested a cmpctblock from this peer, but are not\n+                    // pursuing further requests.\n+                    MarkBlockAsNotInFlight(pindex->GetBlockHash(), pfrom->GetId());\n+                }\n                 // Optimistically try to reconstruct anyway since we might be\n                 // able to without any round trips.\n                 PartiallyDownloadedBlock tempBlock(&mempool);\n@@ -2135,13 +2154,21 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             }\n         } else {\n             if (fInFlightFromSamePeer) {\n-                // We requested this block, but its far into the future, so our\n-                // mempool will probably be useless - request the block normally\n-                std::vector<CInv> vInv(1);\n-                vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus()), cmpctblock.header.GetHash());\n-                connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n-                return true;\n-            } else {\n+                if (fPeerWasFirstRequest) {\n+                    // We requested this block, but its far into the future, so our\n+                    // mempool will probably be useless - request the block normally\n+                    // Only do a full block request from first peer\n+                    std::vector<CInv> vInv(1);\n+                    vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus()), cmpctblock.header.GetHash());\n+                    connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n+                    return true;\n+                } else  {\n+                    // Let first peer request full block, just update inflight state\n+                    MarkBlockAsNotInFlight(pindex->GetBlockHash(), pfrom->GetId());\n+                }\n+            }\n+            else if (!fAlreadyInFlight) {\n+                // If block already in flight, we've already processed headers\n                 // If this was an announce-cmpctblock, we want the same treatment as a header message\n                 // Dirty hack to process as if it were just a headers message (TODO: move message handling into their own functions)\n                 std::vector<CBlock> headers;"
      },
      {
        "sha": "c786bc5231c1f0b109234ed79dc05e7358dc1c23",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3f62b2cc1822503b35ec257ef01a64675ac33687/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3f62b2cc1822503b35ec257ef01a64675ac33687/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=3f62b2cc1822503b35ec257ef01a64675ac33687",
        "patch": "@@ -9,6 +9,8 @@\n #include \"net.h\"\n #include \"validationinterface.h\"\n \n+/** Maximum number of outstanding CMPCTBLOCK requests for the same block. */\n+static const int MAX_CMPCTBLOCKS_INFLIGHT_PER_BLOCK = 2;\n /** Default for -maxorphantx, maximum number of orphan transactions kept in memory */\n static const unsigned int DEFAULT_MAX_ORPHAN_TRANSACTIONS = 100;\n /** Expiration time for orphan transactions in seconds */"
      }
    ]
  },
  {
    "sha": "5eb857dccddbf0fc31b345deeab4c4b9c4c36800",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ZWI4NTdkY2NkZGJmMGZjMzFiMzQ1ZGVlYWI0YzRiOWM0YzM2ODAw",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2016-12-29T23:19:38Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2017-02-14T18:31:00Z"
      },
      "message": "Allow second request of cmpctblock",
      "tree": {
        "sha": "fe23392dcfc76a23dfc0c729c170f19fab654f1b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fe23392dcfc76a23dfc0c729c170f19fab654f1b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5eb857dccddbf0fc31b345deeab4c4b9c4c36800",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5eb857dccddbf0fc31b345deeab4c4b9c4c36800",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5eb857dccddbf0fc31b345deeab4c4b9c4c36800",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5eb857dccddbf0fc31b345deeab4c4b9c4c36800/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3f62b2cc1822503b35ec257ef01a64675ac33687",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3f62b2cc1822503b35ec257ef01a64675ac33687",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3f62b2cc1822503b35ec257ef01a64675ac33687"
      }
    ],
    "stats": {
      "total": 16,
      "additions": 15,
      "deletions": 1
    },
    "files": [
      {
        "sha": "1190bd7a4149086354cab584e5ce9da4dd859817",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 1,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5eb857dccddbf0fc31b345deeab4c4b9c4c36800/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5eb857dccddbf0fc31b345deeab4c4b9c4c36800/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=5eb857dccddbf0fc31b345deeab4c4b9c4c36800",
        "patch": "@@ -2392,6 +2392,20 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 }\n                 pindexWalk = pindexWalk->pprev;\n             }\n+            // Special case for second cmpctblock request of tip\n+            // Must match all conditions to add to vToFetch above (except mmapBlocksInFlight.count)\n+            // and conditions to do CMPCT_BLOCK announcement below.\n+            if (vToFetch.size() == 0 && pindexLast->pprev == chainActive.Tip() &&\n+                mmapBlocksInFlight.size() == mmapBlocksInFlight.count(pindexLast->GetBlockHash()) &&\n+                mmapBlocksInFlight.count(pindexLast->GetBlockHash()) < MAX_CMPCTBLOCKS_INFLIGHT_PER_BLOCK &&\n+                !(pindexLast->nStatus & BLOCK_HAVE_DATA) &&\n+                (!IsWitnessEnabled(pindexLast->pprev, chainparams.GetConsensus()) || State(pfrom->GetId())->fHaveWitness) &&\n+                nodestate->fSupportsDesiredCmpctVersion) {\n+                vToFetch.push_back(pindexLast);\n+                LogPrint(\"net\", \"Trying opportunistic second request of block %s from  peer=%d\\n\",\n+                         pindexLast->GetBlockHash().ToString(), pfrom->id);\n+            }\n+\n             // If pindexWalk still isn't on our main chain, we're looking at a\n             // very large reorg at a time we think we're close to caught up to\n             // the main chain -- this shouldn't really happen.  Bail out on the\n@@ -2419,7 +2433,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                             pindexLast->GetBlockHash().ToString(), pindexLast->nHeight);\n                 }\n                 if (vGetData.size() > 0) {\n-                    if (nodestate->fSupportsDesiredCmpctVersion && vGetData.size() == 1 && mmapBlocksInFlight.size() == 1 && pindexLast->pprev->IsValid(BLOCK_VALID_CHAIN)) {\n+                    if (nodestate->fSupportsDesiredCmpctVersion && vGetData.size() == 1 && mmapBlocksInFlight.size() == mmapBlocksInFlight.count(vGetData[0].hash) && pindexLast->pprev->IsValid(BLOCK_VALID_CHAIN)) {\n                         // In any case, we want to download using a compact block, not a regular one\n                         vGetData[0] = CInv(MSG_CMPCT_BLOCK, vGetData[0].hash);\n                     }"
      }
    ]
  }
]