[
  {
    "sha": "632aad9e6d8369750f4327a886ca5b3d3fed89bd",
    "node_id": "C_kwDOABII59oAKDYzMmFhZDllNmQ4MzY5NzUwZjQzMjdhODg2Y2E1YjNkM2ZlZDg5YmQ",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-09-29T20:22:44Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-10-05T15:48:09Z"
      },
      "message": "Make CAddrman::Select_ select buckets, not positions, first\n\nThe original CAddrMan behaviour (before commit\ne6b343d880f50d52390c5af8623afa15fcbc65a2) was to pick a uniformly\nrandom non-empty bucket, and then pick a random element from that\nbucket. That commit, which introduced deterministic placement\nof entries in buckets, changed this to picking a uniformly random\nnon-empty bucket position instead.\n\nThis commit reverts the original high-level behavior, but in the\ndeterministic placement model.",
      "tree": {
        "sha": "ac81634d4607183d7ecc8a3b21adcbb73f38ccea",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ac81634d4607183d7ecc8a3b21adcbb73f38ccea"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/632aad9e6d8369750f4327a886ca5b3d3fed89bd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/632aad9e6d8369750f4327a886ca5b3d3fed89bd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/632aad9e6d8369750f4327a886ca5b3d3fed89bd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/632aad9e6d8369750f4327a886ca5b3d3fed89bd/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "113b863f0773999497f952daa6539a03a66a9de3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/113b863f0773999497f952daa6539a03a66a9de3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/113b863f0773999497f952daa6539a03a66a9de3"
      }
    ],
    "stats": {
      "total": 32,
      "additions": 24,
      "deletions": 8
    },
    "files": [
      {
        "sha": "08aae6f2a4f7359703c1baf6a4b66a211cc4470c",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 8,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/632aad9e6d8369750f4327a886ca5b3d3fed89bd/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/632aad9e6d8369750f4327a886ca5b3d3fed89bd/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=632aad9e6d8369750f4327a886ca5b3d3fed89bd",
        "patch": "@@ -709,38 +709,54 @@ std::pair<CAddress, int64_t> AddrManImpl::Select_(bool newOnly) const\n         // use a tried node\n         double fChanceFactor = 1.0;\n         while (1) {\n+            // Pick a tried bucket, and an initial position in that bucket.\n             int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n             int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            while (vvTried[nKBucket][nKBucketPos] == -1) {\n-                nKBucket = (nKBucket + insecure_rand.randbits(ADDRMAN_TRIED_BUCKET_COUNT_LOG2)) % ADDRMAN_TRIED_BUCKET_COUNT;\n-                nKBucketPos = (nKBucketPos + insecure_rand.randbits(ADDRMAN_BUCKET_SIZE_LOG2)) % ADDRMAN_BUCKET_SIZE;\n+            // Iterate over the positions of that bucket, starting at the initial one,\n+            // and looping around.\n+            int i;\n+            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n             }\n-            int nId = vvTried[nKBucket][nKBucketPos];\n+            // If the bucket is entirely empty, start over with a (likely) different one.\n+            if (i == ADDRMAN_BUCKET_SIZE) continue;\n+            // Find the entry to return.\n+            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n             const auto it_found{mapInfo.find(nId)};\n             assert(it_found != mapInfo.end());\n             const AddrInfo& info{it_found->second};\n+            // With probability GetChance() * fChanceFactor, return the entry.\n             if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n                 return {info, info.nLastTry};\n             }\n+            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n             fChanceFactor *= 1.2;\n         }\n     } else {\n         // use a new node\n         double fChanceFactor = 1.0;\n         while (1) {\n+            // Pick a new bucket, and an initial position in that bucket.\n             int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n             int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            while (vvNew[nUBucket][nUBucketPos] == -1) {\n-                nUBucket = (nUBucket + insecure_rand.randbits(ADDRMAN_NEW_BUCKET_COUNT_LOG2)) % ADDRMAN_NEW_BUCKET_COUNT;\n-                nUBucketPos = (nUBucketPos + insecure_rand.randbits(ADDRMAN_BUCKET_SIZE_LOG2)) % ADDRMAN_BUCKET_SIZE;\n+            // Iterate over the positions of that bucket, starting at the initial one,\n+            // and looping around.\n+            int i;\n+            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n             }\n-            int nId = vvNew[nUBucket][nUBucketPos];\n+            // If the bucket is entirely empty, start over with a (likely) different one.\n+            if (i == ADDRMAN_BUCKET_SIZE) continue;\n+            // Find the entry to return.\n+            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n             const auto it_found{mapInfo.find(nId)};\n             assert(it_found != mapInfo.end());\n             const AddrInfo& info{it_found->second};\n+            // With probability GetChance() * fChanceFactor, return the entry.\n             if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n                 return {info, info.nLastTry};\n             }\n+            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n             fChanceFactor *= 1.2;\n         }\n     }"
      }
    ]
  }
]