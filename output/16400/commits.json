[
  {
    "sha": "4a87c5cfdf7dd72d999ebeaf17db6695a7c6298d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0YTg3YzVjZmRmN2RkNzJkOTk5ZWJlYWYxN2RiNjY5NWE3YzYyOThk",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-07-10T15:38:03Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-09-16T15:07:40Z"
      },
      "message": "[refactor] Rewrite AcceptToMemoryPoolWorker() using smaller parts\n\nThis is in preparation for re-using these validation components for a new\nversion of AcceptToMemoryPool() that can operate on multiple transactions\n(\"package relay\").",
      "tree": {
        "sha": "391abb977f68eda8d95e90607def5dc30ad4a48b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/391abb977f68eda8d95e90607def5dc30ad4a48b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4a87c5cfdf7dd72d999ebeaf17db6695a7c6298d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4a87c5cfdf7dd72d999ebeaf17db6695a7c6298d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4a87c5cfdf7dd72d999ebeaf17db6695a7c6298d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4a87c5cfdf7dd72d999ebeaf17db6695a7c6298d/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cd737214ced756898883c8d940d353f0a1c4f4b9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cd737214ced756898883c8d940d353f0a1c4f4b9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cd737214ced756898883c8d940d353f0a1c4f4b9"
      }
    ],
    "stats": {
      "total": 845,
      "additions": 499,
      "deletions": 346
    },
    "files": [
      {
        "sha": "705cb70301c14f89eca43c4f1026600657b43264",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 499,
        "deletions": 346,
        "changes": 845,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a87c5cfdf7dd72d999ebeaf17db6695a7c6298d/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a87c5cfdf7dd72d999ebeaf17db6695a7c6298d/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=4a87c5cfdf7dd72d999ebeaf17db6695a7c6298d",
        "patch": "@@ -428,21 +428,134 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+namespace {\n+\n+class MemPoolAccept\n {\n-    const CTransaction& tx = *ptx;\n-    const uint256 hash = tx.GetHash();\n-    AssertLockHeld(cs_main);\n-    LOCK(pool.cs); // mempool \"read lock\" (held through GetMainSignals().TransactionAddedToMempool())\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : m_pool(mempool), m_view(&m_dummy), m_viewmempool(&::ChainstateActive().CoinsTip(), m_pool),\n+        m_limit_ancestors(gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT)),\n+        m_limit_ancestor_size(gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000),\n+        m_limit_descendants(gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT)),\n+        m_limit_descendant_size(gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000) {}\n+\n+    // We put the arguments we're handed into a struct, so we can pass them\n+    // around easier.\n+    struct ATMPArgs {\n+        const CChainParams& m_chainparams;\n+        CValidationState &m_state;\n+        bool* m_missing_inputs;\n+        const int64_t m_accept_time;\n+        std::list<CTransactionRef>* m_replaced_transactions;\n+        const bool m_bypass_limits;\n+        const CAmount& m_absurd_fee;\n+        /*\n+         * Return any outpoints which were not previously present in the coins\n+         * cache, but were added as a result of validating the tx for mempool\n+         * acceptance. This allows the caller to optionally remove the cache\n+         * additions if the associated transaction ends up being rejected by\n+         * the mempool.\n+         */\n+        std::vector<COutPoint>& m_coins_to_uncache;\n+        const bool m_test_accept;\n+    };\n+\n+    // Single transaction acceptance\n+    bool AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs& args) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+private:\n+    // All the intermediate state that gets passed between the various levels\n+    // of checking a given transaction.\n+    struct Workspace {\n+        Workspace(const CTransactionRef& ptx) : m_ptx(ptx), m_hash(ptx->GetHash()) {}\n+        std::set<uint256> m_conflicts;\n+        CTxMemPool::setEntries m_all_conflicting;\n+        CTxMemPool::setEntries m_ancestors;\n+        std::unique_ptr<CTxMemPoolEntry> m_entry;\n+\n+        bool m_replacement_transaction;\n+        CAmount m_modified_fees;\n+        CAmount m_conflicting_fees;\n+        size_t m_conflicting_size;\n+\n+        const CTransactionRef& m_ptx;\n+        const uint256& m_hash;\n+    };\n+\n+    // Run the policy checks on a given transaction, excluding any script checks.\n+    // Looks up inputs, calculates feerate, considers replacement, evaluates\n+    // package limits, etc. As this function can be invoked for \"free\" by a peer,\n+    // only tests that are fast should be done here (to avoid CPU DoS).\n+    bool PreChecks(ATMPArgs& args, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);\n+\n+    // Run the script checks using our policy flags. As this can be slow, we should\n+    // only invoke this on transactions that have otherwise passed policy checks.\n+    bool PolicyScriptChecks(ATMPArgs& args, Workspace& ws, PrecomputedTransactionData& txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    // Re-run the script checks, using consensus flags, and try to cache the\n+    // result in the scriptcache. This should be done after\n+    // PolicyScriptChecks(). This requires that all inputs either be in our\n+    // utxo set or in the mempool.\n+    bool ConsensusScriptChecks(ATMPArgs& args, Workspace& ws, PrecomputedTransactionData &txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    // Try to add the transaction to the mempool, removing any conflicts first.\n+    // Returns true if the transaction is in the mempool after any size\n+    // limiting is performed, false otherwise.\n+    bool Finalize(ATMPArgs& args, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);\n+\n+    // Compare a package's feerate against minimum allowed.\n+    bool CheckFeeRate(size_t package_size, CAmount package_fee, CValidationState& state)\n+    {\n+        CAmount mempoolRejectFee = m_pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(package_size);\n+        if (mempoolRejectFee > 0 && package_fee < mempoolRejectFee) {\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", strprintf(\"%d < %d\", package_fee, mempoolRejectFee));\n+        }\n+\n+        if (package_fee < ::minRelayTxFee.GetFee(package_size)) {\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"min relay fee not met\", strprintf(\"%d < %d\", package_fee, ::minRelayTxFee.GetFee(package_size)));\n+        }\n+        return true;\n+    }\n+\n+private:\n+    CTxMemPool& m_pool;\n+    CCoinsViewCache m_view;\n+    CCoinsViewMemPool m_viewmempool;\n+    CCoinsView m_dummy;\n+\n+    // The package limits in effect at the time of invocation.\n+    const size_t m_limit_ancestors;\n+    const size_t m_limit_ancestor_size;\n+    // These may be modified while evaluating a transaction (eg to account for\n+    // in-mempool conflicts; see below).\n+    size_t m_limit_descendants;\n+    size_t m_limit_descendant_size;\n+};\n+\n+bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n+{\n+    const CTransactionRef& ptx = ws.m_ptx;\n+    const CTransaction& tx = *ws.m_ptx;\n+    const uint256& hash = ws.m_hash;\n+\n+    // Copy/alias what we need out of args\n+    CValidationState &state = args.m_state;\n+    bool* pfMissingInputs = args.m_missing_inputs;\n+    const int64_t nAcceptTime = args.m_accept_time;\n+    const bool bypass_limits = args.m_bypass_limits;\n+    const CAmount& nAbsurdFee = args.m_absurd_fee;\n+    std::vector<COutPoint>& coins_to_uncache = args.m_coins_to_uncache;\n+\n+    // Alias what we need out of ws\n+    std::set<uint256>& setConflicts = ws.m_conflicts;\n+    CTxMemPool::setEntries& allConflicting = ws.m_all_conflicting;\n+    CTxMemPool::setEntries& setAncestors = ws.m_ancestors;\n+    std::unique_ptr<CTxMemPoolEntry>& entry = ws.m_entry;\n+    bool& fReplacementTransaction = ws.m_replacement_transaction;\n+    CAmount& nModifiedFees = ws.m_modified_fees;\n+    CAmount& nConflictingFees = ws.m_conflicting_fees;\n+    size_t& nConflictingSize = ws.m_conflicting_size;\n+\n     if (pfMissingInputs) {\n         *pfMissingInputs = false;\n     }\n@@ -472,15 +585,14 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         return state.Invalid(ValidationInvalidReason::TX_PREMATURE_SPEND, false, REJECT_NONSTANDARD, \"non-final\");\n \n     // is it already in the memory pool?\n-    if (pool.exists(hash)) {\n+    if (m_pool.exists(hash)) {\n         return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, REJECT_DUPLICATE, \"txn-already-in-mempool\");\n     }\n \n     // Check for conflicts with in-memory transactions\n-    std::set<uint256> setConflicts;\n     for (const CTxIn &txin : tx.vin)\n     {\n-        const CTransaction* ptxConflicting = pool.GetConflictTx(txin.prevout);\n+        const CTransaction* ptxConflicting = m_pool.GetConflictTx(txin.prevout);\n         if (ptxConflicting) {\n             if (!setConflicts.count(ptxConflicting->GetHash()))\n             {\n@@ -514,395 +626,436 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         }\n     }\n \n-    {\n-        CCoinsView dummy;\n-        CCoinsViewCache view(&dummy);\n-\n-        LockPoints lp;\n-        CCoinsViewCache& coins_cache = ::ChainstateActive().CoinsTip();\n-        CCoinsViewMemPool viewMemPool(&coins_cache, pool);\n-        view.SetBackend(viewMemPool);\n-\n-        // do all inputs exist?\n-        for (const CTxIn& txin : tx.vin) {\n-            if (!coins_cache.HaveCoinInCache(txin.prevout)) {\n-                coins_to_uncache.push_back(txin.prevout);\n-            }\n+    LockPoints lp;\n+    m_view.SetBackend(m_viewmempool);\n \n-            // Note: this call may add txin.prevout to the coins cache\n-            // (CoinsTip().cacheCoins) by way of FetchCoin(). It should be removed\n-            // later (via coins_to_uncache) if this tx turns out to be invalid.\n-            if (!view.HaveCoin(txin.prevout)) {\n-                // Are inputs missing because we already have the tx?\n-                for (size_t out = 0; out < tx.vout.size(); out++) {\n-                    // Optimistically just do efficient check of cache for outputs\n-                    if (coins_cache.HaveCoinInCache(COutPoint(hash, out))) {\n-                        return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, REJECT_DUPLICATE, \"txn-already-known\");\n-                    }\n-                }\n-                // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n-                if (pfMissingInputs) {\n-                    *pfMissingInputs = true;\n+    CCoinsViewCache& coins_cache = ::ChainstateActive().CoinsTip();\n+    // do all inputs exist?\n+    for (const CTxIn& txin : tx.vin) {\n+        if (!coins_cache.HaveCoinInCache(txin.prevout)) {\n+            coins_to_uncache.push_back(txin.prevout);\n+        }\n+\n+        // Note: this call may add txin.prevout to the coins cache\n+        // (coins_cache.cacheCoins) by way of FetchCoin(). It should be removed\n+        // later (via coins_to_uncache) if this tx turns out to be invalid.\n+        if (!m_view.HaveCoin(txin.prevout)) {\n+            // Are inputs missing because we already have the tx?\n+            for (size_t out = 0; out < tx.vout.size(); out++) {\n+                // Optimistically just do efficient check of cache for outputs\n+                if (coins_cache.HaveCoinInCache(COutPoint(hash, out))) {\n+                    return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, REJECT_DUPLICATE, \"txn-already-known\");\n                 }\n-                return false; // fMissingInputs and !state.IsInvalid() is used to detect this condition, don't set state.Invalid()\n             }\n+            // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n+            if (pfMissingInputs) {\n+                *pfMissingInputs = true;\n+            }\n+            return false; // fMissingInputs and !state.IsInvalid() is used to detect this condition, don't set state.Invalid()\n         }\n+    }\n \n-        // Bring the best block into scope\n-        view.GetBestBlock();\n+    // Bring the best block into scope\n+    m_view.GetBestBlock();\n \n-        // we have all inputs cached now, so switch back to dummy, so we don't need to keep lock on mempool\n-        view.SetBackend(dummy);\n+    // we have all inputs cached now, so switch back to dummy (to protect\n+    // against bugs where we pull more inputs from disk that miss being added\n+    // to coins_to_uncache)\n+    m_view.SetBackend(m_dummy);\n \n-        // Only accept BIP68 sequence locked transactions that can be mined in the next\n-        // block; we don't want our mempool filled up with transactions that can't\n-        // be mined yet.\n-        // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n-        // CoinsViewCache instead of create its own\n-        if (!CheckSequenceLocks(pool, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n-            return state.Invalid(ValidationInvalidReason::TX_PREMATURE_SPEND, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n+    // Only accept BIP68 sequence locked transactions that can be mined in the next\n+    // block; we don't want our mempool filled up with transactions that can't\n+    // be mined yet.\n+    // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n+    // CoinsViewCache instead of create its own\n+    if (!CheckSequenceLocks(m_pool, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n+        return state.Invalid(ValidationInvalidReason::TX_PREMATURE_SPEND, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n \n-        CAmount nFees = 0;\n-        if (!Consensus::CheckTxInputs(tx, state, view, GetSpendHeight(view), nFees)) {\n-            return error(\"%s: Consensus::CheckTxInputs: %s, %s\", __func__, tx.GetHash().ToString(), FormatStateMessage(state));\n-        }\n+    CAmount nFees = 0;\n+    if (!Consensus::CheckTxInputs(tx, state, m_view, GetSpendHeight(m_view), nFees)) {\n+        return error(\"%s: Consensus::CheckTxInputs: %s, %s\", __func__, tx.GetHash().ToString(), FormatStateMessage(state));\n+    }\n \n-        // Check for non-standard pay-to-script-hash in inputs\n-        if (fRequireStandard && !AreInputsStandard(tx, view))\n-            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n+    // Check for non-standard pay-to-script-hash in inputs\n+    if (fRequireStandard && !AreInputsStandard(tx, m_view))\n+        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n \n-        // Check for non-standard witness in P2WSH\n-        if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, view))\n-            return state.Invalid(ValidationInvalidReason::TX_WITNESS_MUTATED, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\");\n+    // Check for non-standard witness in P2WSH\n+    if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, m_view))\n+        return state.Invalid(ValidationInvalidReason::TX_WITNESS_MUTATED, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\");\n \n-        int64_t nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);\n+    int64_t nSigOpsCost = GetTransactionSigOpCost(tx, m_view, STANDARD_SCRIPT_VERIFY_FLAGS);\n \n-        // nModifiedFees includes any fee deltas from PrioritiseTransaction\n-        CAmount nModifiedFees = nFees;\n-        pool.ApplyDelta(hash, nModifiedFees);\n+    // nModifiedFees includes any fee deltas from PrioritiseTransaction\n+    nModifiedFees = nFees;\n+    m_pool.ApplyDelta(hash, nModifiedFees);\n \n-        // Keep track of transactions that spend a coinbase, which we re-scan\n-        // during reorgs to ensure COINBASE_MATURITY is still met.\n-        bool fSpendsCoinbase = false;\n-        for (const CTxIn &txin : tx.vin) {\n-            const Coin &coin = view.AccessCoin(txin.prevout);\n-            if (coin.IsCoinBase()) {\n-                fSpendsCoinbase = true;\n-                break;\n-            }\n+    // Keep track of transactions that spend a coinbase, which we re-scan\n+    // during reorgs to ensure COINBASE_MATURITY is still met.\n+    bool fSpendsCoinbase = false;\n+    for (const CTxIn &txin : tx.vin) {\n+        const Coin &coin = m_view.AccessCoin(txin.prevout);\n+        if (coin.IsCoinBase()) {\n+            fSpendsCoinbase = true;\n+            break;\n         }\n+    }\n \n-        CTxMemPoolEntry entry(ptx, nFees, nAcceptTime, ::ChainActive().Height(),\n-                              fSpendsCoinbase, nSigOpsCost, lp);\n-        unsigned int nSize = entry.GetTxSize();\n+    entry.reset(new CTxMemPoolEntry(ptx, nFees, nAcceptTime, ::ChainActive().Height(),\n+            fSpendsCoinbase, nSigOpsCost, lp));\n+    unsigned int nSize = entry->GetTxSize();\n \n-        if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)\n-            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\",\n+    if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)\n+        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\",\n                 strprintf(\"%d\", nSigOpsCost));\n \n-        CAmount mempoolRejectFee = pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(nSize);\n-        if (!bypass_limits && mempoolRejectFee > 0 && nModifiedFees < mempoolRejectFee) {\n-            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", strprintf(\"%d < %d\", nModifiedFees, mempoolRejectFee));\n-        }\n-\n-        // No transactions are allowed below minRelayTxFee except from disconnected blocks\n-        if (!bypass_limits && nModifiedFees < ::minRelayTxFee.GetFee(nSize)) {\n-            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"min relay fee not met\", strprintf(\"%d < %d\", nModifiedFees, ::minRelayTxFee.GetFee(nSize)));\n-        }\n+    // No transactions are allowed below minRelayTxFee except from disconnected\n+    // blocks\n+    if (!bypass_limits && !CheckFeeRate(nSize, nModifiedFees, state)) return false;\n \n-        if (nAbsurdFee && nFees > nAbsurdFee)\n-            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false,\n+    if (nAbsurdFee && nFees > nAbsurdFee)\n+        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false,\n                 REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n-        const CTxMemPool::setEntries setIterConflicting = pool.GetIterSet(setConflicts);\n-        // Calculate in-mempool ancestors, up to a limit.\n-        CTxMemPool::setEntries setAncestors;\n-        size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n-        size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n-        size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n-        size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n-\n-        if (setConflicts.size() == 1) {\n-            // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n-            // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n-            // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n-            // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't\n-            // very realistic, thus we only ensure a limited set of transactions are RBF'able despite mempool\n-            // conflicts here. Importantly, we need to ensure that some transactions which were accepted using\n-            // the below carve-out are able to be RBF'ed, without impacting the security the carve-out provides\n-            // for off-chain contract systems (see link in the comment below).\n-            //\n-            // Specifically, the subset of RBF transactions which we allow despite chain limits are those which\n-            // conflict directly with exactly one other transaction (but may evict children of said transaction),\n-            // and which are not adding any new mempool dependencies. Note that the \"no new mempool dependencies\"\n-            // check is accomplished later, so we don't bother doing anything about it here, but if BIP 125 is\n-            // amended, we may need to move that check to here instead of removing it wholesale.\n-            //\n-            // Such transactions are clearly not merging any existing packages, so we are only concerned with\n-            // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n-            // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n-            // to.\n-            //\n-            // To check these we first check if we meet the RBF criteria, above, and increment the descendant\n-            // limits by the direct conflict and its descendants (as these are recalculated in\n-            // CalculateMempoolAncestors by assuming the new transaction being added is a new descendant, with no\n-            // removals, of each parent's existing dependant set). The ancestor count limits are unmodified (as\n-            // the ancestor limits should be the same for both our new transaction and any conflicts).\n-            // We don't bother incrementing nLimitDescendants by the full removal count as that limit never comes\n-            // into force here (as we're only adding a single transaction).\n-            assert(setIterConflicting.size() == 1);\n-            CTxMemPool::txiter conflict = *setIterConflicting.begin();\n-\n-            nLimitDescendants += 1;\n-            nLimitDescendantSize += conflict->GetSizeWithDescendants();\n-        }\n-\n-        std::string errString;\n-        if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n-            setAncestors.clear();\n-            // If CalculateMemPoolAncestors fails second time, we want the original error string.\n-            std::string dummy_err_string;\n-            // Contracting/payment channels CPFP carve-out:\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n-            }\n-        }\n-\n-        // A transaction that spends outputs that would be replaced by it is invalid. Now\n-        // that we have the set of all ancestors we can detect this\n-        // pathological case by making sure setConflicts and setAncestors don't\n-        // intersect.\n-        for (CTxMemPool::txiter ancestorIt : setAncestors)\n+    const CTxMemPool::setEntries setIterConflicting = m_pool.GetIterSet(setConflicts);\n+    // Calculate in-mempool ancestors, up to a limit.\n+    if (setConflicts.size() == 1) {\n+        // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n+        // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n+        // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n+        // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't\n+        // very realistic, thus we only ensure a limited set of transactions are RBF'able despite mempool\n+        // conflicts here. Importantly, we need to ensure that some transactions which were accepted using\n+        // the below carve-out are able to be RBF'ed, without impacting the security the carve-out provides\n+        // for off-chain contract systems (see link in the comment below).\n+        //\n+        // Specifically, the subset of RBF transactions which we allow despite chain limits are those which\n+        // conflict directly with exactly one other transaction (but may evict children of said transaction),\n+        // and which are not adding any new mempool dependencies. Note that the \"no new mempool dependencies\"\n+        // check is accomplished later, so we don't bother doing anything about it here, but if BIP 125 is\n+        // amended, we may need to move that check to here instead of removing it wholesale.\n+        //\n+        // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+        // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+        // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+        // to.\n+        //\n+        // To check these we first check if we meet the RBF criteria, above, and increment the descendant\n+        // limits by the direct conflict and its descendants (as these are recalculated in\n+        // CalculateMempoolAncestors by assuming the new transaction being added is a new descendant, with no\n+        // removals, of each parent's existing dependant set). The ancestor count limits are unmodified (as\n+        // the ancestor limits should be the same for both our new transaction and any conflicts).\n+        // We don't bother incrementing m_limit_descendants by the full removal count as that limit never comes\n+        // into force here (as we're only adding a single transaction).\n+        assert(setIterConflicting.size() == 1);\n+        CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+        m_limit_descendants += 1;\n+        m_limit_descendant_size += conflict->GetSizeWithDescendants();\n+    }\n+\n+    std::string errString;\n+    if (!m_pool.CalculateMemPoolAncestors(*entry, setAncestors, m_limit_ancestors, m_limit_ancestor_size, m_limit_descendants, m_limit_descendant_size, errString)) {\n+        setAncestors.clear();\n+        // If CalculateMemPoolAncestors fails second time, we want the original error string.\n+        std::string dummy_err_string;\n+        // Contracting/payment channels CPFP carve-out:\n+        // If the new transaction is relatively small (up to 40k weight)\n+        // and has at most one ancestor (ie ancestor limit of 2, including\n+        // the new transaction), allow it if its parent has exactly the\n+        // descendant limit descendants.\n+        //\n+        // This allows protocols which rely on distrusting counterparties\n+        // being able to broadcast descendants of an unconfirmed transaction\n+        // to be secure by simply only having two immediately-spendable\n+        // outputs - one for each counterparty. For more info on the uses for\n+        // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n+        if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n+                !m_pool.CalculateMemPoolAncestors(*entry, setAncestors, 2, m_limit_ancestor_size, m_limit_descendants + 1, m_limit_descendant_size + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+        }\n+    }\n+\n+    // A transaction that spends outputs that would be replaced by it is invalid. Now\n+    // that we have the set of all ancestors we can detect this\n+    // pathological case by making sure setConflicts and setAncestors don't\n+    // intersect.\n+    for (CTxMemPool::txiter ancestorIt : setAncestors)\n+    {\n+        const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n+        if (setConflicts.count(hashAncestor))\n         {\n-            const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n-            if (setConflicts.count(hashAncestor))\n-            {\n-                return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-spends-conflicting-tx\",\n-                                 strprintf(\"%s spends conflicting transaction %s\",\n-                                           hash.ToString(),\n-                                           hashAncestor.ToString()));\n-            }\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-spends-conflicting-tx\",\n+                    strprintf(\"%s spends conflicting transaction %s\",\n+                        hash.ToString(),\n+                        hashAncestor.ToString()));\n         }\n+    }\n \n-        // Check if it's economically rational to mine this transaction rather\n-        // than the ones it replaces.\n-        CAmount nConflictingFees = 0;\n-        size_t nConflictingSize = 0;\n-        uint64_t nConflictingCount = 0;\n-        CTxMemPool::setEntries allConflicting;\n-\n-        // If we don't hold the lock allConflicting might be incomplete; the\n-        // subsequent RemoveStaged() and addUnchecked() calls don't guarantee\n-        // mempool consistency for us.\n-        const bool fReplacementTransaction = setConflicts.size();\n-        if (fReplacementTransaction)\n-        {\n-            CFeeRate newFeeRate(nModifiedFees, nSize);\n-            std::set<uint256> setConflictsParents;\n-            const int maxDescendantsToVisit = 100;\n-            for (const auto& mi : setIterConflicting) {\n-                // Don't allow the replacement to reduce the feerate of the\n-                // mempool.\n-                //\n-                // We usually don't want to accept replacements with lower\n-                // feerates than what they replaced as that would lower the\n-                // feerate of the next block. Requiring that the feerate always\n-                // be increased is also an easy-to-reason about way to prevent\n-                // DoS attacks via replacements.\n-                //\n-                // We only consider the feerates of transactions being directly\n-                // replaced, not their indirect descendants. While that does\n-                // mean high feerate children are ignored when deciding whether\n-                // or not to replace, we do require the replacement to pay more\n-                // overall fees too, mitigating most cases.\n-                CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n-                if (newFeeRate <= oldFeeRate)\n-                {\n-                    return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n-                            strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n-                                  hash.ToString(),\n-                                  newFeeRate.ToString(),\n-                                  oldFeeRate.ToString()));\n-                }\n-\n-                for (const CTxIn &txin : mi->GetTx().vin)\n-                {\n-                    setConflictsParents.insert(txin.prevout.hash);\n-                }\n+    // Check if it's economically rational to mine this transaction rather\n+    // than the ones it replaces.\n+    nConflictingFees = 0;\n+    nConflictingSize = 0;\n+    uint64_t nConflictingCount = 0;\n \n-                nConflictingCount += mi->GetCountWithDescendants();\n-            }\n-            // This potentially overestimates the number of actual descendants\n-            // but we just want to be conservative to avoid doing too much\n-            // work.\n-            if (nConflictingCount <= maxDescendantsToVisit) {\n-                // If not too many to replace, then calculate the set of\n-                // transactions that would have to be evicted\n-                for (CTxMemPool::txiter it : setIterConflicting) {\n-                    pool.CalculateDescendants(it, allConflicting);\n-                }\n-                for (CTxMemPool::txiter it : allConflicting) {\n-                    nConflictingFees += it->GetModifiedFee();\n-                    nConflictingSize += it->GetTxSize();\n-                }\n-            } else {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too many potential replacements\",\n-                        strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n+    // If we don't hold the lock allConflicting might be incomplete; the\n+    // subsequent RemoveStaged() and addUnchecked() calls don't guarantee\n+    // mempool consistency for us.\n+    fReplacementTransaction = setConflicts.size();\n+    if (fReplacementTransaction)\n+    {\n+        CFeeRate newFeeRate(nModifiedFees, nSize);\n+        std::set<uint256> setConflictsParents;\n+        const int maxDescendantsToVisit = 100;\n+        for (const auto& mi : setIterConflicting) {\n+            // Don't allow the replacement to reduce the feerate of the\n+            // mempool.\n+            //\n+            // We usually don't want to accept replacements with lower\n+            // feerates than what they replaced as that would lower the\n+            // feerate of the next block. Requiring that the feerate always\n+            // be increased is also an easy-to-reason about way to prevent\n+            // DoS attacks via replacements.\n+            //\n+            // We only consider the feerates of transactions being directly\n+            // replaced, not their indirect descendants. While that does\n+            // mean high feerate children are ignored when deciding whether\n+            // or not to replace, we do require the replacement to pay more\n+            // overall fees too, mitigating most cases.\n+            CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n+            if (newFeeRate <= oldFeeRate)\n+            {\n+                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n+                        strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n                             hash.ToString(),\n-                            nConflictingCount,\n-                            maxDescendantsToVisit));\n+                            newFeeRate.ToString(),\n+                            oldFeeRate.ToString()));\n             }\n \n-            for (unsigned int j = 0; j < tx.vin.size(); j++)\n+            for (const CTxIn &txin : mi->GetTx().vin)\n             {\n-                // We don't want to accept replacements that require low\n-                // feerate junk to be mined first. Ideally we'd keep track of\n-                // the ancestor feerates and make the decision based on that,\n-                // but for now requiring all new inputs to be confirmed works.\n-                //\n-                // Note that if you relax this to make RBF a little more useful,\n-                // this may break the CalculateMempoolAncestors RBF relaxation,\n-                // above. See the comment above the first CalculateMempoolAncestors\n-                // call for more info.\n-                if (!setConflictsParents.count(tx.vin[j].prevout.hash))\n-                {\n-                    // Rather than check the UTXO set - potentially expensive -\n-                    // it's cheaper to just check if the new input refers to a\n-                    // tx that's in the mempool.\n-                    if (pool.exists(tx.vin[j].prevout.hash)) {\n-                        return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\",\n-                                         strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n-                                                  hash.ToString(), j));\n-                    }\n-                }\n+                setConflictsParents.insert(txin.prevout.hash);\n             }\n \n-            // The replacement must pay greater fees than the transactions it\n-            // replaces - if we did the bandwidth used by those conflicting\n-            // transactions would not be paid for.\n-            if (nModifiedFees < nConflictingFees)\n-            {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n-                                 strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n-                                          hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)));\n+            nConflictingCount += mi->GetCountWithDescendants();\n+        }\n+        // This potentially overestimates the number of actual descendants\n+        // but we just want to be conservative to avoid doing too much\n+        // work.\n+        if (nConflictingCount <= maxDescendantsToVisit) {\n+            // If not too many to replace, then calculate the set of\n+            // transactions that would have to be evicted\n+            for (CTxMemPool::txiter it : setIterConflicting) {\n+                m_pool.CalculateDescendants(it, allConflicting);\n             }\n-\n-            // Finally in addition to paying more fees than the conflicts the\n-            // new transaction must pay for its own bandwidth.\n-            CAmount nDeltaFees = nModifiedFees - nConflictingFees;\n-            if (nDeltaFees < ::incrementalRelayFee.GetFee(nSize))\n-            {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n-                        strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n-                              hash.ToString(),\n-                              FormatMoney(nDeltaFees),\n-                              FormatMoney(::incrementalRelayFee.GetFee(nSize))));\n+            for (CTxMemPool::txiter it : allConflicting) {\n+                nConflictingFees += it->GetModifiedFee();\n+                nConflictingSize += it->GetTxSize();\n             }\n+        } else {\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too many potential replacements\",\n+                    strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n+                        hash.ToString(),\n+                        nConflictingCount,\n+                        maxDescendantsToVisit));\n         }\n \n-        constexpr unsigned int scriptVerifyFlags = STANDARD_SCRIPT_VERIFY_FLAGS;\n-\n-        // Check against previous transactions\n-        // The first loop above does all the inexpensive checks.\n-        // Only if ALL inputs pass do we perform expensive ECDSA signature checks.\n-        // Helps prevent CPU exhaustion denial-of-service attacks.\n-        PrecomputedTransactionData txdata(tx);\n-        if (!CheckInputs(tx, state, view, scriptVerifyFlags, true, false, txdata)) {\n-            // SCRIPT_VERIFY_CLEANSTACK requires SCRIPT_VERIFY_WITNESS, so we\n-            // need to turn both off, and compare against just turning off CLEANSTACK\n-            // to see if the failure is specifically due to witness validation.\n-            CValidationState stateDummy; // Want reported failures to be from first CheckInputs\n-            if (!tx.HasWitness() && CheckInputs(tx, stateDummy, view, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, false, txdata) &&\n-                !CheckInputs(tx, stateDummy, view, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, false, txdata)) {\n-                // Only the witness is missing, so the transaction itself may be fine.\n-                state.Invalid(ValidationInvalidReason::TX_WITNESS_MUTATED, false,\n-                        state.GetRejectCode(), state.GetRejectReason(), state.GetDebugMessage());\n+        for (unsigned int j = 0; j < tx.vin.size(); j++)\n+        {\n+            // We don't want to accept replacements that require low\n+            // feerate junk to be mined first. Ideally we'd keep track of\n+            // the ancestor feerates and make the decision based on that,\n+            // but for now requiring all new inputs to be confirmed works.\n+            //\n+            // Note that if you relax this to make RBF a little more useful,\n+            // this may break the CalculateMempoolAncestors RBF relaxation,\n+            // above. See the comment above the first CalculateMempoolAncestors\n+            // call for more info.\n+            if (!setConflictsParents.count(tx.vin[j].prevout.hash))\n+            {\n+                // Rather than check the UTXO set - potentially expensive -\n+                // it's cheaper to just check if the new input refers to a\n+                // tx that's in the mempool.\n+                if (m_pool.exists(tx.vin[j].prevout.hash)) {\n+                    return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\",\n+                            strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n+                                hash.ToString(), j));\n+                }\n             }\n-            assert(IsTransactionReason(state.GetReason()));\n-            return false; // state filled in by CheckInputs\n-        }\n-\n-        // Check again against the current block tip's script verification\n-        // flags to cache our script execution flags. This is, of course,\n-        // useless if the next block has different script flags from the\n-        // previous one, but because the cache tracks script flags for us it\n-        // will auto-invalidate and we'll just have a few blocks of extra\n-        // misses on soft-fork activation.\n-        //\n-        // This is also useful in case of bugs in the standard flags that cause\n-        // transactions to pass as valid when they're actually invalid. For\n-        // instance the STRICTENC flag was incorrectly allowing certain\n-        // CHECKSIG NOT scripts to pass, even though they were invalid.\n-        //\n-        // There is a similar check in CreateNewBlock() to prevent creating\n-        // invalid blocks (using TestBlockValidity), however allowing such\n-        // transactions into the mempool can be exploited as a DoS attack.\n-        unsigned int currentBlockScriptVerifyFlags = GetBlockScriptFlags(::ChainActive().Tip(), chainparams.GetConsensus());\n-        if (!CheckInputsFromMempoolAndCache(tx, state, view, pool, currentBlockScriptVerifyFlags, true, txdata)) {\n-            return error(\"%s: BUG! PLEASE REPORT THIS! CheckInputs failed against latest-block but not STANDARD flags %s, %s\",\n-                    __func__, hash.ToString(), FormatStateMessage(state));\n         }\n \n-        if (test_accept) {\n-            // Tx was accepted, but not added\n-            return true;\n+        // The replacement must pay greater fees than the transactions it\n+        // replaces - if we did the bandwidth used by those conflicting\n+        // transactions would not be paid for.\n+        if (nModifiedFees < nConflictingFees)\n+        {\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n+                    strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n+                        hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)));\n         }\n \n-        // Remove conflicting transactions from the mempool\n-        for (CTxMemPool::txiter it : allConflicting)\n+        // Finally in addition to paying more fees than the conflicts the\n+        // new transaction must pay for its own bandwidth.\n+        CAmount nDeltaFees = nModifiedFees - nConflictingFees;\n+        if (nDeltaFees < ::incrementalRelayFee.GetFee(nSize))\n         {\n-            LogPrint(BCLog::MEMPOOL, \"replacing tx %s with %s for %s BTC additional fees, %d delta bytes\\n\",\n-                    it->GetTx().GetHash().ToString(),\n-                    hash.ToString(),\n-                    FormatMoney(nModifiedFees - nConflictingFees),\n-                    (int)nSize - (int)nConflictingSize);\n-            if (plTxnReplaced)\n-                plTxnReplaced->push_back(it->GetSharedTx());\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n+                    strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n+                        hash.ToString(),\n+                        FormatMoney(nDeltaFees),\n+                        FormatMoney(::incrementalRelayFee.GetFee(nSize))));\n         }\n-        pool.RemoveStaged(allConflicting, false, MemPoolRemovalReason::REPLACED);\n+    }\n+    return true;\n+}\n+\n+bool MemPoolAccept::PolicyScriptChecks(ATMPArgs& args, Workspace& ws, PrecomputedTransactionData& txdata)\n+{\n+    const CTransaction& tx = *ws.m_ptx;\n \n-        // This transaction should only count for fee estimation if:\n-        // - it isn't a BIP 125 replacement transaction (may not be widely supported)\n-        // - it's not being re-added during a reorg which bypasses typical mempool fee limits\n-        // - the node is not behind\n-        // - the transaction is not dependent on any other transactions in the mempool\n-        bool validForFeeEstimation = !fReplacementTransaction && !bypass_limits && IsCurrentForFeeEstimation() && pool.HasNoInputsOf(tx);\n+    CValidationState &state = args.m_state;\n \n-        // Store transaction in memory\n-        pool.addUnchecked(entry, setAncestors, validForFeeEstimation);\n+    constexpr unsigned int scriptVerifyFlags = STANDARD_SCRIPT_VERIFY_FLAGS;\n \n-        // trim mempool and check if tx was trimmed\n-        if (!bypass_limits) {\n-            LimitMempoolSize(pool, gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, gArgs.GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n-            if (!pool.exists(hash))\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"mempool full\");\n+    // Check against previous transactions\n+    // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n+    if (!CheckInputs(tx, state, m_view, scriptVerifyFlags, true, false, txdata)) {\n+        // SCRIPT_VERIFY_CLEANSTACK requires SCRIPT_VERIFY_WITNESS, so we\n+        // need to turn both off, and compare against just turning off CLEANSTACK\n+        // to see if the failure is specifically due to witness validation.\n+        CValidationState stateDummy; // Want reported failures to be from first CheckInputs\n+        if (!tx.HasWitness() && CheckInputs(tx, stateDummy, m_view, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, false, txdata) &&\n+                !CheckInputs(tx, stateDummy, m_view, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, false, txdata)) {\n+            // Only the witness is missing, so the transaction itself may be fine.\n+            state.Invalid(ValidationInvalidReason::TX_WITNESS_MUTATED, false,\n+                    state.GetRejectCode(), state.GetRejectReason(), state.GetDebugMessage());\n         }\n+        assert(IsTransactionReason(state.GetReason()));\n+        return false; // state filled in by CheckInputs\n+    }\n+\n+    return true;\n+}\n+\n+bool MemPoolAccept::ConsensusScriptChecks(ATMPArgs& args, Workspace& ws, PrecomputedTransactionData& txdata)\n+{\n+    const CTransaction& tx = *ws.m_ptx;\n+    const uint256& hash = ws.m_hash;\n+\n+    CValidationState &state = args.m_state;\n+    const CChainParams& chainparams = args.m_chainparams;\n+\n+    // Check again against the current block tip's script verification\n+    // flags to cache our script execution flags. This is, of course,\n+    // useless if the next block has different script flags from the\n+    // previous one, but because the cache tracks script flags for us it\n+    // will auto-invalidate and we'll just have a few blocks of extra\n+    // misses on soft-fork activation.\n+    //\n+    // This is also useful in case of bugs in the standard flags that cause\n+    // transactions to pass as valid when they're actually invalid. For\n+    // instance the STRICTENC flag was incorrectly allowing certain\n+    // CHECKSIG NOT scripts to pass, even though they were invalid.\n+    //\n+    // There is a similar check in CreateNewBlock() to prevent creating\n+    // invalid blocks (using TestBlockValidity), however allowing such\n+    // transactions into the mempool can be exploited as a DoS attack.\n+    unsigned int currentBlockScriptVerifyFlags = GetBlockScriptFlags(::ChainActive().Tip(), chainparams.GetConsensus());\n+    if (!CheckInputsFromMempoolAndCache(tx, state, m_view, m_pool, currentBlockScriptVerifyFlags, true, txdata)) {\n+        return error(\"%s: BUG! PLEASE REPORT THIS! CheckInputs failed against latest-block but not STANDARD flags %s, %s\",\n+                __func__, hash.ToString(), FormatStateMessage(state));\n+    }\n+\n+    return true;\n+}\n+\n+bool MemPoolAccept::Finalize(ATMPArgs& args, Workspace& ws)\n+{\n+    const CTransaction& tx = *ws.m_ptx;\n+    const uint256& hash = ws.m_hash;\n+    CValidationState &state = args.m_state;\n+    const bool bypass_limits = args.m_bypass_limits;\n+\n+    CTxMemPool::setEntries& allConflicting = ws.m_all_conflicting;\n+    CTxMemPool::setEntries& setAncestors = ws.m_ancestors;\n+    const CAmount& nModifiedFees = ws.m_modified_fees;\n+    const CAmount& nConflictingFees = ws.m_conflicting_fees;\n+    const size_t& nConflictingSize = ws.m_conflicting_size;\n+    const bool fReplacementTransaction = ws.m_replacement_transaction;\n+    std::unique_ptr<CTxMemPoolEntry>& entry = ws.m_entry;\n+\n+    // Remove conflicting transactions from the mempool\n+    for (CTxMemPool::txiter it : allConflicting)\n+    {\n+        LogPrint(BCLog::MEMPOOL, \"replacing tx %s with %s for %s BTC additional fees, %d delta bytes\\n\",\n+                it->GetTx().GetHash().ToString(),\n+                hash.ToString(),\n+                FormatMoney(nModifiedFees - nConflictingFees),\n+                (int)entry->GetTxSize() - (int)nConflictingSize);\n+        if (args.m_replaced_transactions)\n+            args.m_replaced_transactions->push_back(it->GetSharedTx());\n+    }\n+    m_pool.RemoveStaged(allConflicting, false, MemPoolRemovalReason::REPLACED);\n+\n+    // This transaction should only count for fee estimation if:\n+    // - it isn't a BIP 125 replacement transaction (may not be widely supported)\n+    // - it's not being re-added during a reorg which bypasses typical mempool fee limits\n+    // - the node is not behind\n+    // - the transaction is not dependent on any other transactions in the mempool\n+    bool validForFeeEstimation = !fReplacementTransaction && !bypass_limits && IsCurrentForFeeEstimation() && m_pool.HasNoInputsOf(tx);\n+\n+    // Store transaction in memory\n+    m_pool.addUnchecked(*entry, setAncestors, validForFeeEstimation);\n+\n+    // trim mempool and check if tx was trimmed\n+    if (!bypass_limits) {\n+        LimitMempoolSize(m_pool, gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, gArgs.GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n+        if (!m_pool.exists(hash))\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"mempool full\");\n     }\n+    return true;\n+}\n+\n+bool MemPoolAccept::AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs& args)\n+{\n+    AssertLockHeld(cs_main);\n+    LOCK(m_pool.cs); // mempool \"read lock\" (held through GetMainSignals().TransactionAddedToMempool())\n+\n+    Workspace workspace(ptx);\n+\n+    if (!PreChecks(args, workspace)) return false;\n+\n+    // Only compute the precomputed transaction data if we need to verify\n+    // scripts (ie, other policy checks pass). We perform the inexpensive\n+    // checks first and avoid hashing and signature verification unless those\n+    // checks pass, to mitigate CPU exhaustion denial-of-service attacks.\n+    PrecomputedTransactionData txdata(*ptx);\n+\n+    if (!PolicyScriptChecks(args, workspace, txdata)) return false;\n+\n+    if (!ConsensusScriptChecks(args, workspace, txdata)) return false;\n+\n+    // Tx was accepted, but not added\n+    if (args.m_test_accept) return true;\n+\n+    if (!Finalize(args, workspace)) return false;\n \n     GetMainSignals().TransactionAddedToMempool(ptx);\n \n     return true;\n }\n \n+} // anon namespace\n+\n /** (try to) add transaction to memory pool with a specified acceptance time **/\n static bool AcceptToMemoryPoolWithTime(const CChainParams& chainparams, CTxMemPool& pool, CValidationState &state, const CTransactionRef &tx,\n                         bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n                         bool bypass_limits, const CAmount nAbsurdFee, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     std::vector<COutPoint> coins_to_uncache;\n-    bool res = AcceptToMemoryPoolWorker(chainparams, pool, state, tx, pfMissingInputs, nAcceptTime, plTxnReplaced, bypass_limits, nAbsurdFee, coins_to_uncache, test_accept);\n+    MemPoolAccept::ATMPArgs args { chainparams, state, pfMissingInputs, nAcceptTime, plTxnReplaced, bypass_limits, nAbsurdFee, coins_to_uncache, test_accept };\n+    bool res = MemPoolAccept(pool).AcceptSingleTransaction(tx, args);\n     if (!res) {\n         // Remove coins that were not present in the coins cache before calling ATMPW;\n         // this is to prevent memory DoS in case we receive a large number of"
      }
    ]
  }
]