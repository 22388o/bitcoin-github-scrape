[
  {
    "sha": "56803c27f18af4e3e4150706857501b3efb9bc37",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1NjgwM2MyN2YxOGFmNGUzZTQxNTA3MDY4NTc1MDFiM2VmYjliYzM3",
    "commit": {
      "author": {
        "name": "Kyht",
        "email": "m@kyht.com",
        "date": "2020-08-05T02:42:12Z"
      },
      "committer": {
        "name": "Kyht",
        "email": "m@kyht.com",
        "date": "2020-08-05T02:42:12Z"
      },
      "message": "Floating-Point Nakamoto Consensus\n\nImplaments a new way to resovle disagreements between the adoption of two chains of the same height.\n\n- net_processing.cppy - the protocol needed to be altered to accept updates from a competiting chain that is of the same height as it may have a higher fitness score.\n- uint256.h - wrote an addition routine to allow for the in-place addition of two 256 bit numbers.\n- validation.cpp Added the floating-point nakamoto fitness resolution protocol.",
      "tree": {
        "sha": "9213a94210c948e1b8c27086c4510ef9b97530c3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9213a94210c948e1b8c27086c4510ef9b97530c3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/56803c27f18af4e3e4150706857501b3efb9bc37",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/56803c27f18af4e3e4150706857501b3efb9bc37",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/56803c27f18af4e3e4150706857501b3efb9bc37",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/56803c27f18af4e3e4150706857501b3efb9bc37/comments",
    "author": {
      "login": "Kyht",
      "id": 56983714,
      "node_id": "MDQ6VXNlcjU2OTgzNzE0",
      "avatar_url": "https://avatars.githubusercontent.com/u/56983714?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Kyht",
      "html_url": "https://github.com/Kyht",
      "followers_url": "https://api.github.com/users/Kyht/followers",
      "following_url": "https://api.github.com/users/Kyht/following{/other_user}",
      "gists_url": "https://api.github.com/users/Kyht/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Kyht/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Kyht/subscriptions",
      "organizations_url": "https://api.github.com/users/Kyht/orgs",
      "repos_url": "https://api.github.com/users/Kyht/repos",
      "events_url": "https://api.github.com/users/Kyht/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Kyht/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "Kyht",
      "id": 56983714,
      "node_id": "MDQ6VXNlcjU2OTgzNzE0",
      "avatar_url": "https://avatars.githubusercontent.com/u/56983714?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Kyht",
      "html_url": "https://github.com/Kyht",
      "followers_url": "https://api.github.com/users/Kyht/followers",
      "following_url": "https://api.github.com/users/Kyht/following{/other_user}",
      "gists_url": "https://api.github.com/users/Kyht/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Kyht/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Kyht/subscriptions",
      "organizations_url": "https://api.github.com/users/Kyht/orgs",
      "repos_url": "https://api.github.com/users/Kyht/repos",
      "events_url": "https://api.github.com/users/Kyht/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Kyht/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bb2a9f9c8c555e6055d78a73f897bafc1c73c726",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bb2a9f9c8c555e6055d78a73f897bafc1c73c726",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bb2a9f9c8c555e6055d78a73f897bafc1c73c726"
      }
    ],
    "stats": {
      "total": 119,
      "additions": 96,
      "deletions": 23
    },
    "files": [
      {
        "sha": "d9667e2bdd306687e6e3bb1ec7abff5108d436d5",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/56803c27f18af4e3e4150706857501b3efb9bc37/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/56803c27f18af4e3e4150706857501b3efb9bc37/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=56803c27f18af4e3e4150706857501b3efb9bc37",
        "patch": "@@ -3148,7 +3148,7 @@ void ProcessMessage(\n \n         // If this was a new header with more work than our tip, update the\n         // peer's last block announcement time\n-        if (received_new_header && pindex->nChainWork > ::ChainActive().Tip()->nChainWork) {\n+        if (received_new_header && pindex->nChainWork >= ::ChainActive().Tip()->nChainWork) {\n             nodestate->m_last_block_announcement = GetTime();\n         }\n \n@@ -3158,7 +3158,7 @@ void ProcessMessage(\n         if (pindex->nStatus & BLOCK_HAVE_DATA) // Nothing to do here\n             return;\n \n-        if (pindex->nChainWork <= ::ChainActive().Tip()->nChainWork || // We know something better\n+        if (pindex->nChainWork < ::ChainActive().Tip()->nChainWork || // We know something better\n                 pindex->nTx != 0) { // We had this block at some point, but pruned it\n             if (fAlreadyInFlight) {\n                 // We requested this block for some reason, but our mempool will probably be useless"
      },
      {
        "sha": "12bc061baf264a88967c9f7051fa671cd8915cb5",
        "filename": "src/uint256.h",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/56803c27f18af4e3e4150706857501b3efb9bc37/src/uint256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/56803c27f18af4e3e4150706857501b3efb9bc37/src/uint256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/uint256.h?ref=56803c27f18af4e3e4150706857501b3efb9bc37",
        "patch": "@@ -45,6 +45,20 @@ class base_blob\n     friend inline bool operator==(const base_blob& a, const base_blob& b) { return a.Compare(b) == 0; }\n     friend inline bool operator!=(const base_blob& a, const base_blob& b) { return a.Compare(b) != 0; }\n     friend inline bool operator<(const base_blob& a, const base_blob& b) { return a.Compare(b) < 0; }\n+    friend inline bool operator>(const base_blob& a, const base_blob& b) { return a.Compare(b) > 0; }\n+    void operator+=(const base_blob& a) {\n+        uint64_t cur = 0;\n+        uint64_t overflow = 0;\n+        const unsigned char * source = a.data();\n+        for (int i = WIDTH - 1; i >= 0; i--){\n+            cur = m_data[i] + source[i] + overflow;\n+            //record the low byte:\n+            m_data[i] = cur & 0xff;\n+            //keep track of the rest.\n+            overflow = (cur >> 8);\n+        }\n+        //fitness tests will not lead to an int overflow\n+    }\n \n     std::string GetHex() const;\n     void SetHex(const char* psz);"
      },
      {
        "sha": "40d71e08cf41f3e56a87b66dd210bdddacf59c87",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 80,
        "deletions": 21,
        "changes": 101,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/56803c27f18af4e3e4150706857501b3efb9bc37/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/56803c27f18af4e3e4150706857501b3efb9bc37/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=56803c27f18af4e3e4150706857501b3efb9bc37",
        "patch": "@@ -84,7 +84,8 @@ const std::vector<std::string> CHECKLEVEL_DOC {\n \n bool CBlockIndexWorkComparator::operator()(const CBlockIndex *pa, const CBlockIndex *pb) const {\n     // First sort by most total work, ...\n-    if (pa->nChainWork > pb->nChainWork) return false;\n+    //A fitness test will be sued a a chainwork tie breaker\n+    if (pa->nChainWork >= pb->nChainWork) return false;\n     if (pa->nChainWork < pb->nChainWork) return true;\n \n     // ... then by earliest time received, ...\n@@ -2638,27 +2639,77 @@ bool CChainState::ConnectTip(BlockValidationState& state, const CChainParams& ch\n     return true;\n }\n \n+/** A method of resolving a Nakamoto-based disagreement.\n+ *  Even if both chains are the same length, one side will be more fit to succeed. */\n+CBlockIndex* GreatestNakamotoFitness(const CBlockIndex* pa, const CBlockIndex* pb) {\n+    const CBlockIndex* result;\n+    uint256 pa_fitness;\n+    uint256 pb_fitness;\n+\n+    // Beling alive makes you a contender.\n+    if(pa == nullptr){\n+        result = pb;\n+    }else if(pb == nullptr){\n+        result = pa;\n+    // Nakamoto Consensus forms around the longest chain:\n+    }else if(pb->nChainWork > pa->nChainWork){\n+        result = pb;\n+    }else if(pb->nChainWork < pa->nChainWork){\n+        result = pa;\n+    }else{\n+        // If we are here, then both sides must be equal,\n+        // This is a diagreement in the network on which block should be the tip.\n+        // Neighboring nodes will get the same block advertisements and will have to go \n+        // through this same fitness selection process\n+        LogPrint(BCLog::BENCH, \"- Disagreement in the Nakamoto Protocol:\");\n+\n+        // Which side has a better solution for the same work spent?\n+        // This is a measurement between two chains that disagree:\n+        while (pa != pb && pa && pb) {\n+            // We acclumulate the non-zero remainder of the blockhash\n+            pa_fitness += pa->GetBlockHash();\n+            pb_fitness += pb->GetBlockHash();\n+            // Go back to when the disagreement started.\n+            pa = pa->pprev;\n+            pb = pb->pprev;            \n+        }\n+\n+        // Eventually all chain branches meet at the genesis block.\n+        assert(pa == pb);\n+\n+        // Which ever side has the same number of zero-prefixed solutions, but the larged remainder wins.\n+        // This is Floating-Point Nakamoto Consensus\n+        if(pa_fitness < pb_fitness){\n+            result = pb;\n+           // LogPrint(BCLog::BENCH, \" Loosing Block's Fitness Score: %s \", pa_fitness.ToString());\n+           // LogPrint(BCLog::BENCH, \" Winning Block's Fitness Score: %s \", pb_fitness.ToString());\n+        }else{\n+            result = pa;\n+           // LogPrint(BCLog::BENCH, \" Loosing Block's Fitness Score: %s \", pb_fitness.ToString());\n+         //   LogPrint(BCLog::BENCH, \" Winning Block's Fitness Score: %s \", pa_fitness.ToString());\n+        }\n+        LogPrint(BCLog::BENCH, \" Winning Block: %s\", result->GetBlockHash().ToString());\n+    }\n+    return (CBlockIndex*)result;\n+}\n+\n /**\n  * Return the tip of the chain with the most work in it, that isn't\n  * known to be invalid (it's however far from certain to be valid).\n  */\n CBlockIndex* CChainState::FindMostWorkChain() {\n-    do {\n-        CBlockIndex *pindexNew = nullptr;\n-\n-        // Find the best candidate header.\n-        {\n-            std::set<CBlockIndex*, CBlockIndexWorkComparator>::reverse_iterator it = setBlockIndexCandidates.rbegin();\n-            if (it == setBlockIndexCandidates.rend())\n-                return nullptr;\n-            pindexNew = *it;\n-        }\n-\n+    CBlockIndex* mostWorkChain = m_chain.Tip();\n+    \n+    // Find the best candidate chain:\n+    std::set<CBlockIndex*, CBlockIndexWorkComparator>::iterator itBlockChain = setBlockIndexCandidates.begin();\n+    for(uint32_t currentCanidate = 0; currentCanidate < setBlockIndexCandidates.size(); currentCanidate++){\n+        CBlockIndex* pindexNew = *(itBlockChain++);\n+        CBlockIndex* pindexTest = pindexNew;\n         // Check whether all blocks on the path between the currently active chain and the candidate are valid.\n         // Just going until the active chain is an optimization, as we know all blocks in it are valid already.\n-        CBlockIndex *pindexTest = pindexNew;\n+        //CBlockIndex *pindexTest = pindexNew;\n         bool fInvalidAncestor = false;\n-        while (pindexTest && !m_chain.Contains(pindexTest)) {\n+        while (pindexTest){//} && !m_chain.Contains(pindexTest)) {\n             assert(pindexTest->HaveTxsDownloaded() || pindexTest->nHeight == 0);\n \n             // Pruned nodes may have entries in setBlockIndexCandidates for\n@@ -2669,8 +2720,10 @@ CBlockIndex* CChainState::FindMostWorkChain() {\n             bool fMissingData = !(pindexTest->nStatus & BLOCK_HAVE_DATA);\n             if (fFailedChain || fMissingData) {\n                 // Candidate chain is not usable (either invalid or missing data)\n-                if (fFailedChain && (pindexBestInvalid == nullptr || pindexNew->nChainWork > pindexBestInvalid->nChainWork))\n+                if (fFailedChain && (pindexBestInvalid == nullptr || pindexNew->nChainWork > pindexBestInvalid->nChainWork)){\n                     pindexBestInvalid = pindexNew;\n+                }\n+\n                 CBlockIndex *pindexFailed = pindexNew;\n                 // Remove the entire chain from the set.\n                 while (pindexTest != pindexFailed) {\n@@ -2692,9 +2745,15 @@ CBlockIndex* CChainState::FindMostWorkChain() {\n             }\n             pindexTest = pindexTest->pprev;\n         }\n-        if (!fInvalidAncestor)\n-            return pindexNew;\n-    } while(true);\n+        // Make sure that this chain is still a contendor, is it still valid?\n+        if (!fInvalidAncestor){\n+            // Keep track of the leading chain:\n+            mostWorkChain = GreatestNakamotoFitness(pindexNew, mostWorkChain);\n+        }\n+    }\n+\n+    // We compaired all canidates and this chain is the winner:\n+    return mostWorkChain;\n }\n \n /** Delete all entries in setBlockIndexCandidates that are worse than the current tip. */\n@@ -3765,7 +3824,7 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, Block\n     // process an unrequested block if it's new and has enough work to\n     // advance our tip, and isn't too many blocks ahead.\n     bool fAlreadyHave = pindex->nStatus & BLOCK_HAVE_DATA;\n-    bool fHasMoreOrSameWork = (m_chain.Tip() ? pindex->nChainWork >= m_chain.Tip()->nChainWork : true);\n+    bool fHasMoreWork = (m_chain.Tip() ? pindex->nChainWork > m_chain.Tip()->nChainWork : true);\n     // Blocks that are too out-of-order needlessly limit the effectiveness of\n     // pruning, because pruning will not delete block files that contain any\n     // blocks which are too close in height to the tip.  Apply this test\n@@ -3783,7 +3842,7 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, Block\n     if (fAlreadyHave) return true;\n     if (!fRequested) {  // If we didn't ask for it:\n         if (pindex->nTx != 0) return true;    // This is a previously-processed block that was pruned\n-        if (!fHasMoreOrSameWork) return true; // Don't process less-work chains\n+        if (!fHasMoreWork) return true;       // Don't process less-work chains\n         if (fTooFarAhead) return true;        // Block height is too high\n \n         // Protect against DoS attacks from low-work chains.\n@@ -4851,7 +4910,7 @@ void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n         assert((pindexFirstNeverProcessed == nullptr) == pindex->HaveTxsDownloaded());\n         assert((pindexFirstNotTransactionsValid == nullptr) == pindex->HaveTxsDownloaded());\n         assert(pindex->nHeight == nHeight); // nHeight must be consistent.\n-        assert(pindex->pprev == nullptr || pindex->nChainWork >= pindex->pprev->nChainWork); // For every block except the genesis block, the chainwork must be larger than the parent's.\n+        assert(pindex->pprev == nullptr || pindex->nChainWork > pindex->pprev->nChainWork); // For every block except the genesis block, the chainwork must be larger than the parent's.\n         assert(nHeight < 2 || (pindex->pskip && (pindex->pskip->nHeight < nHeight))); // The pskip pointer must point back for all but the first 2 blocks.\n         assert(pindexFirstNotTreeValid == nullptr); // All m_blockman.m_block_index entries must at least be TREE valid\n         if ((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_TREE) assert(pindexFirstNotTreeValid == nullptr); // TREE valid implies all parents are TREE valid"
      }
    ]
  },
  {
    "sha": "5bf7261c9a3bbfc0ef275c2816c2b3f3b4f216e2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1YmY3MjYxYzlhM2JiZmMwZWYyNzVjMjgxNmMyYjNmM2I0ZjIxNmUy",
    "commit": {
      "author": {
        "name": "TheRook",
        "email": "firealwaysworks@gmail.com",
        "date": "2020-08-05T02:42:12Z"
      },
      "committer": {
        "name": "Mike",
        "email": "m@lootboxcash.com",
        "date": "2020-08-05T03:01:59Z"
      },
      "message": "Floating-Point Nakamoto Consensus\n\nImplaments a new way to resovle disagreements between the adoption of two chains of the same height.\n\n- net_processing.cppy - the protocol needed to be altered to accept updates from a competiting chain that is of the same height as it may have a higher fitness score.\n- uint256.h - wrote an addition routine to allow for the in-place addition of two 256 bit numbers.\n- validation.cpp Added the floating-point nakamoto fitness resolution protocol.",
      "tree": {
        "sha": "9213a94210c948e1b8c27086c4510ef9b97530c3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9213a94210c948e1b8c27086c4510ef9b97530c3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5bf7261c9a3bbfc0ef275c2816c2b3f3b4f216e2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5bf7261c9a3bbfc0ef275c2816c2b3f3b4f216e2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5bf7261c9a3bbfc0ef275c2816c2b3f3b4f216e2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5bf7261c9a3bbfc0ef275c2816c2b3f3b4f216e2/comments",
    "author": {
      "login": "TheRook",
      "id": 521783,
      "node_id": "MDQ6VXNlcjUyMTc4Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/521783?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheRook",
      "html_url": "https://github.com/TheRook",
      "followers_url": "https://api.github.com/users/TheRook/followers",
      "following_url": "https://api.github.com/users/TheRook/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheRook/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheRook/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheRook/subscriptions",
      "organizations_url": "https://api.github.com/users/TheRook/orgs",
      "repos_url": "https://api.github.com/users/TheRook/repos",
      "events_url": "https://api.github.com/users/TheRook/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheRook/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "YunusHaas",
      "id": 55421122,
      "node_id": "MDQ6VXNlcjU1NDIxMTIy",
      "avatar_url": "https://avatars.githubusercontent.com/u/55421122?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/YunusHaas",
      "html_url": "https://github.com/YunusHaas",
      "followers_url": "https://api.github.com/users/YunusHaas/followers",
      "following_url": "https://api.github.com/users/YunusHaas/following{/other_user}",
      "gists_url": "https://api.github.com/users/YunusHaas/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/YunusHaas/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/YunusHaas/subscriptions",
      "organizations_url": "https://api.github.com/users/YunusHaas/orgs",
      "repos_url": "https://api.github.com/users/YunusHaas/repos",
      "events_url": "https://api.github.com/users/YunusHaas/events{/privacy}",
      "received_events_url": "https://api.github.com/users/YunusHaas/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bb2a9f9c8c555e6055d78a73f897bafc1c73c726",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bb2a9f9c8c555e6055d78a73f897bafc1c73c726",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bb2a9f9c8c555e6055d78a73f897bafc1c73c726"
      }
    ],
    "stats": {
      "total": 119,
      "additions": 96,
      "deletions": 23
    },
    "files": [
      {
        "sha": "d9667e2bdd306687e6e3bb1ec7abff5108d436d5",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5bf7261c9a3bbfc0ef275c2816c2b3f3b4f216e2/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5bf7261c9a3bbfc0ef275c2816c2b3f3b4f216e2/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=5bf7261c9a3bbfc0ef275c2816c2b3f3b4f216e2",
        "patch": "@@ -3148,7 +3148,7 @@ void ProcessMessage(\n \n         // If this was a new header with more work than our tip, update the\n         // peer's last block announcement time\n-        if (received_new_header && pindex->nChainWork > ::ChainActive().Tip()->nChainWork) {\n+        if (received_new_header && pindex->nChainWork >= ::ChainActive().Tip()->nChainWork) {\n             nodestate->m_last_block_announcement = GetTime();\n         }\n \n@@ -3158,7 +3158,7 @@ void ProcessMessage(\n         if (pindex->nStatus & BLOCK_HAVE_DATA) // Nothing to do here\n             return;\n \n-        if (pindex->nChainWork <= ::ChainActive().Tip()->nChainWork || // We know something better\n+        if (pindex->nChainWork < ::ChainActive().Tip()->nChainWork || // We know something better\n                 pindex->nTx != 0) { // We had this block at some point, but pruned it\n             if (fAlreadyInFlight) {\n                 // We requested this block for some reason, but our mempool will probably be useless"
      },
      {
        "sha": "12bc061baf264a88967c9f7051fa671cd8915cb5",
        "filename": "src/uint256.h",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5bf7261c9a3bbfc0ef275c2816c2b3f3b4f216e2/src/uint256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5bf7261c9a3bbfc0ef275c2816c2b3f3b4f216e2/src/uint256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/uint256.h?ref=5bf7261c9a3bbfc0ef275c2816c2b3f3b4f216e2",
        "patch": "@@ -45,6 +45,20 @@ class base_blob\n     friend inline bool operator==(const base_blob& a, const base_blob& b) { return a.Compare(b) == 0; }\n     friend inline bool operator!=(const base_blob& a, const base_blob& b) { return a.Compare(b) != 0; }\n     friend inline bool operator<(const base_blob& a, const base_blob& b) { return a.Compare(b) < 0; }\n+    friend inline bool operator>(const base_blob& a, const base_blob& b) { return a.Compare(b) > 0; }\n+    void operator+=(const base_blob& a) {\n+        uint64_t cur = 0;\n+        uint64_t overflow = 0;\n+        const unsigned char * source = a.data();\n+        for (int i = WIDTH - 1; i >= 0; i--){\n+            cur = m_data[i] + source[i] + overflow;\n+            //record the low byte:\n+            m_data[i] = cur & 0xff;\n+            //keep track of the rest.\n+            overflow = (cur >> 8);\n+        }\n+        //fitness tests will not lead to an int overflow\n+    }\n \n     std::string GetHex() const;\n     void SetHex(const char* psz);"
      },
      {
        "sha": "40d71e08cf41f3e56a87b66dd210bdddacf59c87",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 80,
        "deletions": 21,
        "changes": 101,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5bf7261c9a3bbfc0ef275c2816c2b3f3b4f216e2/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5bf7261c9a3bbfc0ef275c2816c2b3f3b4f216e2/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=5bf7261c9a3bbfc0ef275c2816c2b3f3b4f216e2",
        "patch": "@@ -84,7 +84,8 @@ const std::vector<std::string> CHECKLEVEL_DOC {\n \n bool CBlockIndexWorkComparator::operator()(const CBlockIndex *pa, const CBlockIndex *pb) const {\n     // First sort by most total work, ...\n-    if (pa->nChainWork > pb->nChainWork) return false;\n+    //A fitness test will be sued a a chainwork tie breaker\n+    if (pa->nChainWork >= pb->nChainWork) return false;\n     if (pa->nChainWork < pb->nChainWork) return true;\n \n     // ... then by earliest time received, ...\n@@ -2638,27 +2639,77 @@ bool CChainState::ConnectTip(BlockValidationState& state, const CChainParams& ch\n     return true;\n }\n \n+/** A method of resolving a Nakamoto-based disagreement.\n+ *  Even if both chains are the same length, one side will be more fit to succeed. */\n+CBlockIndex* GreatestNakamotoFitness(const CBlockIndex* pa, const CBlockIndex* pb) {\n+    const CBlockIndex* result;\n+    uint256 pa_fitness;\n+    uint256 pb_fitness;\n+\n+    // Beling alive makes you a contender.\n+    if(pa == nullptr){\n+        result = pb;\n+    }else if(pb == nullptr){\n+        result = pa;\n+    // Nakamoto Consensus forms around the longest chain:\n+    }else if(pb->nChainWork > pa->nChainWork){\n+        result = pb;\n+    }else if(pb->nChainWork < pa->nChainWork){\n+        result = pa;\n+    }else{\n+        // If we are here, then both sides must be equal,\n+        // This is a diagreement in the network on which block should be the tip.\n+        // Neighboring nodes will get the same block advertisements and will have to go \n+        // through this same fitness selection process\n+        LogPrint(BCLog::BENCH, \"- Disagreement in the Nakamoto Protocol:\");\n+\n+        // Which side has a better solution for the same work spent?\n+        // This is a measurement between two chains that disagree:\n+        while (pa != pb && pa && pb) {\n+            // We acclumulate the non-zero remainder of the blockhash\n+            pa_fitness += pa->GetBlockHash();\n+            pb_fitness += pb->GetBlockHash();\n+            // Go back to when the disagreement started.\n+            pa = pa->pprev;\n+            pb = pb->pprev;            \n+        }\n+\n+        // Eventually all chain branches meet at the genesis block.\n+        assert(pa == pb);\n+\n+        // Which ever side has the same number of zero-prefixed solutions, but the larged remainder wins.\n+        // This is Floating-Point Nakamoto Consensus\n+        if(pa_fitness < pb_fitness){\n+            result = pb;\n+           // LogPrint(BCLog::BENCH, \" Loosing Block's Fitness Score: %s \", pa_fitness.ToString());\n+           // LogPrint(BCLog::BENCH, \" Winning Block's Fitness Score: %s \", pb_fitness.ToString());\n+        }else{\n+            result = pa;\n+           // LogPrint(BCLog::BENCH, \" Loosing Block's Fitness Score: %s \", pb_fitness.ToString());\n+         //   LogPrint(BCLog::BENCH, \" Winning Block's Fitness Score: %s \", pa_fitness.ToString());\n+        }\n+        LogPrint(BCLog::BENCH, \" Winning Block: %s\", result->GetBlockHash().ToString());\n+    }\n+    return (CBlockIndex*)result;\n+}\n+\n /**\n  * Return the tip of the chain with the most work in it, that isn't\n  * known to be invalid (it's however far from certain to be valid).\n  */\n CBlockIndex* CChainState::FindMostWorkChain() {\n-    do {\n-        CBlockIndex *pindexNew = nullptr;\n-\n-        // Find the best candidate header.\n-        {\n-            std::set<CBlockIndex*, CBlockIndexWorkComparator>::reverse_iterator it = setBlockIndexCandidates.rbegin();\n-            if (it == setBlockIndexCandidates.rend())\n-                return nullptr;\n-            pindexNew = *it;\n-        }\n-\n+    CBlockIndex* mostWorkChain = m_chain.Tip();\n+    \n+    // Find the best candidate chain:\n+    std::set<CBlockIndex*, CBlockIndexWorkComparator>::iterator itBlockChain = setBlockIndexCandidates.begin();\n+    for(uint32_t currentCanidate = 0; currentCanidate < setBlockIndexCandidates.size(); currentCanidate++){\n+        CBlockIndex* pindexNew = *(itBlockChain++);\n+        CBlockIndex* pindexTest = pindexNew;\n         // Check whether all blocks on the path between the currently active chain and the candidate are valid.\n         // Just going until the active chain is an optimization, as we know all blocks in it are valid already.\n-        CBlockIndex *pindexTest = pindexNew;\n+        //CBlockIndex *pindexTest = pindexNew;\n         bool fInvalidAncestor = false;\n-        while (pindexTest && !m_chain.Contains(pindexTest)) {\n+        while (pindexTest){//} && !m_chain.Contains(pindexTest)) {\n             assert(pindexTest->HaveTxsDownloaded() || pindexTest->nHeight == 0);\n \n             // Pruned nodes may have entries in setBlockIndexCandidates for\n@@ -2669,8 +2720,10 @@ CBlockIndex* CChainState::FindMostWorkChain() {\n             bool fMissingData = !(pindexTest->nStatus & BLOCK_HAVE_DATA);\n             if (fFailedChain || fMissingData) {\n                 // Candidate chain is not usable (either invalid or missing data)\n-                if (fFailedChain && (pindexBestInvalid == nullptr || pindexNew->nChainWork > pindexBestInvalid->nChainWork))\n+                if (fFailedChain && (pindexBestInvalid == nullptr || pindexNew->nChainWork > pindexBestInvalid->nChainWork)){\n                     pindexBestInvalid = pindexNew;\n+                }\n+\n                 CBlockIndex *pindexFailed = pindexNew;\n                 // Remove the entire chain from the set.\n                 while (pindexTest != pindexFailed) {\n@@ -2692,9 +2745,15 @@ CBlockIndex* CChainState::FindMostWorkChain() {\n             }\n             pindexTest = pindexTest->pprev;\n         }\n-        if (!fInvalidAncestor)\n-            return pindexNew;\n-    } while(true);\n+        // Make sure that this chain is still a contendor, is it still valid?\n+        if (!fInvalidAncestor){\n+            // Keep track of the leading chain:\n+            mostWorkChain = GreatestNakamotoFitness(pindexNew, mostWorkChain);\n+        }\n+    }\n+\n+    // We compaired all canidates and this chain is the winner:\n+    return mostWorkChain;\n }\n \n /** Delete all entries in setBlockIndexCandidates that are worse than the current tip. */\n@@ -3765,7 +3824,7 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, Block\n     // process an unrequested block if it's new and has enough work to\n     // advance our tip, and isn't too many blocks ahead.\n     bool fAlreadyHave = pindex->nStatus & BLOCK_HAVE_DATA;\n-    bool fHasMoreOrSameWork = (m_chain.Tip() ? pindex->nChainWork >= m_chain.Tip()->nChainWork : true);\n+    bool fHasMoreWork = (m_chain.Tip() ? pindex->nChainWork > m_chain.Tip()->nChainWork : true);\n     // Blocks that are too out-of-order needlessly limit the effectiveness of\n     // pruning, because pruning will not delete block files that contain any\n     // blocks which are too close in height to the tip.  Apply this test\n@@ -3783,7 +3842,7 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, Block\n     if (fAlreadyHave) return true;\n     if (!fRequested) {  // If we didn't ask for it:\n         if (pindex->nTx != 0) return true;    // This is a previously-processed block that was pruned\n-        if (!fHasMoreOrSameWork) return true; // Don't process less-work chains\n+        if (!fHasMoreWork) return true;       // Don't process less-work chains\n         if (fTooFarAhead) return true;        // Block height is too high\n \n         // Protect against DoS attacks from low-work chains.\n@@ -4851,7 +4910,7 @@ void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n         assert((pindexFirstNeverProcessed == nullptr) == pindex->HaveTxsDownloaded());\n         assert((pindexFirstNotTransactionsValid == nullptr) == pindex->HaveTxsDownloaded());\n         assert(pindex->nHeight == nHeight); // nHeight must be consistent.\n-        assert(pindex->pprev == nullptr || pindex->nChainWork >= pindex->pprev->nChainWork); // For every block except the genesis block, the chainwork must be larger than the parent's.\n+        assert(pindex->pprev == nullptr || pindex->nChainWork > pindex->pprev->nChainWork); // For every block except the genesis block, the chainwork must be larger than the parent's.\n         assert(nHeight < 2 || (pindex->pskip && (pindex->pskip->nHeight < nHeight))); // The pskip pointer must point back for all but the first 2 blocks.\n         assert(pindexFirstNotTreeValid == nullptr); // All m_blockman.m_block_index entries must at least be TREE valid\n         if ((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_TREE) assert(pindexFirstNotTreeValid == nullptr); // TREE valid implies all parents are TREE valid"
      }
    ]
  },
  {
    "sha": "05578ac859a5f60707cc2aca88c9f5b0aaa9bc1a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNTU3OGFjODU5YTVmNjA3MDdjYzJhY2E4OGM5ZjViMGFhYTliYzFh",
    "commit": {
      "author": {
        "name": "TheRook",
        "email": "firealwaysworks@gmail.com",
        "date": "2020-08-05T03:04:03Z"
      },
      "committer": {
        "name": "Mike",
        "email": "m@lootboxcash.com",
        "date": "2020-08-05T03:05:28Z"
      },
      "message": "Merge branch 'master' of https://github.com/in-st/bitcoin",
      "tree": {
        "sha": "9213a94210c948e1b8c27086c4510ef9b97530c3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9213a94210c948e1b8c27086c4510ef9b97530c3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/05578ac859a5f60707cc2aca88c9f5b0aaa9bc1a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/05578ac859a5f60707cc2aca88c9f5b0aaa9bc1a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/05578ac859a5f60707cc2aca88c9f5b0aaa9bc1a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/05578ac859a5f60707cc2aca88c9f5b0aaa9bc1a/comments",
    "author": {
      "login": "TheRook",
      "id": 521783,
      "node_id": "MDQ6VXNlcjUyMTc4Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/521783?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheRook",
      "html_url": "https://github.com/TheRook",
      "followers_url": "https://api.github.com/users/TheRook/followers",
      "following_url": "https://api.github.com/users/TheRook/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheRook/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheRook/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheRook/subscriptions",
      "organizations_url": "https://api.github.com/users/TheRook/orgs",
      "repos_url": "https://api.github.com/users/TheRook/repos",
      "events_url": "https://api.github.com/users/TheRook/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheRook/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "YunusHaas",
      "id": 55421122,
      "node_id": "MDQ6VXNlcjU1NDIxMTIy",
      "avatar_url": "https://avatars.githubusercontent.com/u/55421122?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/YunusHaas",
      "html_url": "https://github.com/YunusHaas",
      "followers_url": "https://api.github.com/users/YunusHaas/followers",
      "following_url": "https://api.github.com/users/YunusHaas/following{/other_user}",
      "gists_url": "https://api.github.com/users/YunusHaas/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/YunusHaas/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/YunusHaas/subscriptions",
      "organizations_url": "https://api.github.com/users/YunusHaas/orgs",
      "repos_url": "https://api.github.com/users/YunusHaas/repos",
      "events_url": "https://api.github.com/users/YunusHaas/events{/privacy}",
      "received_events_url": "https://api.github.com/users/YunusHaas/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5bf7261c9a3bbfc0ef275c2816c2b3f3b4f216e2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5bf7261c9a3bbfc0ef275c2816c2b3f3b4f216e2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5bf7261c9a3bbfc0ef275c2816c2b3f3b4f216e2"
      },
      {
        "sha": "56803c27f18af4e3e4150706857501b3efb9bc37",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/56803c27f18af4e3e4150706857501b3efb9bc37",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/56803c27f18af4e3e4150706857501b3efb9bc37"
      }
    ],
    "stats": {
      "total": 0,
      "additions": 0,
      "deletions": 0
    },
    "files": []
  }
]