[
  {
    "sha": "aa7f418fe32b3ec53285693a7731decd99be4528",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphYTdmNDE4ZmUzMmIzZWM1MzI4NTY5M2E3NzMxZGVjZDk5YmU0NTI4",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-03-21T00:45:17Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-03-21T01:21:41Z"
      },
      "message": "fuzz: cleanups for versionbits fuzzer",
      "tree": {
        "sha": "6841d58113304a5fc49c1d1d27e71eaf369573a5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6841d58113304a5fc49c1d1d27e71eaf369573a5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/aa7f418fe32b3ec53285693a7731decd99be4528",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aa7f418fe32b3ec53285693a7731decd99be4528",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/aa7f418fe32b3ec53285693a7731decd99be4528",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aa7f418fe32b3ec53285693a7731decd99be4528/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "63952f73b3041468fe3b25fa54858db7899273fa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/63952f73b3041468fe3b25fa54858db7899273fa",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/63952f73b3041468fe3b25fa54858db7899273fa"
      }
    ],
    "stats": {
      "total": 42,
      "additions": 24,
      "deletions": 18
    },
    "files": [
      {
        "sha": "88c1a1a9cb81f51ccf8d3dec1542ed9104b63026",
        "filename": "src/test/fuzz/versionbits.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 18,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aa7f418fe32b3ec53285693a7731decd99be4528/src/test/fuzz/versionbits.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aa7f418fe32b3ec53285693a7731decd99be4528/src/test/fuzz/versionbits.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/versionbits.cpp?ref=aa7f418fe32b3ec53285693a7731decd99be4528",
        "patch": "@@ -25,18 +25,18 @@ class TestConditionChecker : public AbstractThresholdConditionChecker\n     const Consensus::Params dummy_params{};\n \n public:\n-    const int64_t m_begin = 0;\n-    const int64_t m_end = 0;\n-    const int m_period = 0;\n-    const int m_threshold = 0;\n-    const int m_bit = 0;\n+    const int64_t m_begin;\n+    const int64_t m_end;\n+    const int m_period;\n+    const int m_threshold;\n+    const int m_bit;\n \n     TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\n         : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n     {\n         assert(m_period > 0);\n         assert(0 <= m_threshold && m_threshold <= m_period);\n-        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+        assert(0 <= m_bit && m_bit < 32 && m_bit < VERSIONBITS_NUM_BITS);\n     }\n \n     bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n@@ -49,9 +49,10 @@ class TestConditionChecker : public AbstractThresholdConditionChecker\n     int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n     BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n \n-    bool Condition(int64_t version) const\n+    bool Condition(int32_t version) const\n     {\n-        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+        uint32_t mask = ((uint32_t)1) << m_bit;\n+        return (((version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS) && (version & mask) != 0);\n     }\n \n     bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n@@ -94,18 +95,20 @@ class Blocks\n     }\n };\n \n+std::unique_ptr<const CChainParams> g_params;\n+\n void initialize()\n {\n-    SelectParams(CBaseChainParams::MAIN);\n+    // this is actually comparatively slow, so only do it once\n+    g_params = CreateChainParams(ArgsManager{}, CBaseChainParams::MAIN);\n+    assert(g_params != nullptr);\n }\n-} // namespace\n \n-constexpr uint32_t MAX_TIME = 4102444800; // 2100-01-01\n+constexpr uint32_t MAX_START_TIME = 4102444800; // 2100-01-01\n \n FUZZ_TARGET_INIT(versionbits, initialize)\n {\n-    const CChainParams& params = Params();\n-\n+    const CChainParams& params = *g_params;\n     const int64_t interval = params.GetConsensus().nPowTargetSpacing;\n     assert(interval > 1); // need to be able to halve it\n     assert(interval < std::numeric_limits<int32_t>::max());\n@@ -122,9 +125,9 @@ FUZZ_TARGET_INIT(versionbits, initialize)\n \n     // too many blocks at 10min each might cause uint32_t time to overflow if\n     // block_start_time is at the end of the range above\n-    assert(std::numeric_limits<uint32_t>::max() - MAX_TIME > interval * max_blocks);\n+    assert(std::numeric_limits<uint32_t>::max() - MAX_START_TIME > interval * max_blocks);\n \n-    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(params.GenesisBlock().nTime, MAX_TIME);\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(params.GenesisBlock().nTime, MAX_START_TIME);\n \n     // what values for version will we use to signal / not signal?\n     const int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n@@ -173,8 +176,10 @@ FUZZ_TARGET_INIT(versionbits, initialize)\n     if (checker.Condition(ver_nosignal)) return;\n     if (ver_nosignal < 0) return;\n \n-    // TOP_BITS should ensure version will be positive\n+    // TOP_BITS should ensure version will be positive and meet min\n+    // version requirement\n     assert(ver_signal > 0);\n+    assert(ver_signal >= VERSIONBITS_LAST_OLD_BLOCK_VERSION);\n \n     // Now that we have chosen time and versions, setup to mine blocks\n     Blocks blocks(block_start_time, interval, ver_signal, ver_nosignal);\n@@ -203,7 +208,7 @@ FUZZ_TARGET_INIT(versionbits, initialize)\n         }\n \n         // don't risk exceeding max_blocks or times may wrap around\n-        if (blocks.size() + period*2 > max_blocks) break;\n+        if (blocks.size() + 2 * period > max_blocks) break;\n     }\n     // NOTE: fuzzed_data_provider may be fully consumed at this point and should not be used further\n \n@@ -316,7 +321,7 @@ FUZZ_TARGET_INIT(versionbits, initialize)\n         assert(false);\n     }\n \n-    if (blocks.size() >= max_periods * period) {\n+    if (blocks.size() >= period * max_periods) {\n         // we chose the timeout (and block times) so that by the time we have this many blocks it's all over\n         assert(state == ThresholdState::ACTIVE || state == ThresholdState::FAILED);\n     }\n@@ -343,3 +348,4 @@ FUZZ_TARGET_INIT(versionbits, initialize)\n         }\n     }\n }\n+} // namespace"
      }
    ]
  }
]