[
  {
    "sha": "e77fab05a0450dffbc96fff32ba3fa6c378adb44",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNzdmYWIwNWEwNDUwZGZmYmM5NmZmZjMyYmEzZmE2YzM3OGFkYjQ0",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-07-12T18:53:14Z"
      },
      "committer": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-07-27T16:54:59Z"
      },
      "message": "Add package-acceptance logic to mempool\n\nAccepting a single transaction to the mempool only succeeds if (among other\nthings) the feerate of the transaction is greater than both the min relay fee\nand the mempool min fee. Consequently, a transaction below the minimum fee\nmay not be accepted to the mempool, even if we later learn of a transaction\nwith a high relay fee that depends on it.\n\nThis commit adds a function that will accept a package of transactions to the\nmempool, with the following restrictions:\n\n- All package transactions must be direct parents of the final transaction.\n  This is a simple heuristic for ensuring that a candidate list of transactions\n  is in fact a package (we wouldn't want arbitrary transactions to be paying\n  for random low feerate transactions)\n\n- The feerate of the package, as a whole, exceeds the mempool min fee and the\n  min relay fee.\n\n- No transactions in the mempool conflict with any transactions in the package.\n  This is a simplification that makes the logic easier to write. Without this\n  requirement, we would need to do additional checks to ensure that no parent\n  transaction would evict a transaction from the mempool that some other child\n  depends on.\n\n- The ancestor/descendant size limits are calculated assuming that any mempool\n  ancestor of any candidate transaction is an ancestor of all the candidate\n  transactions.\n  This allows for doing simpler calculations to ensure that we're staying\n  within the mempool's package limits. If we eliminated this, we would need to\n  do much more careful package calculations for each candidate transaction and each\n  in-mempool ancestor.\n\nThis commit does not include any accessor function for utilizing this logic (eg\nby exposing this function at the p2p or rpc layer).",
      "tree": {
        "sha": "629c3ad981e9e4f18d263e941e2b64a6517a892e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/629c3ad981e9e4f18d263e941e2b64a6517a892e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e77fab05a0450dffbc96fff32ba3fa6c378adb44",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e77fab05a0450dffbc96fff32ba3fa6c378adb44",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e77fab05a0450dffbc96fff32ba3fa6c378adb44",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e77fab05a0450dffbc96fff32ba3fa6c378adb44/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": null,
    "parents": [
      {
        "sha": "ccef10261efc235c8fcc8aad54556615b0cc23be",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ccef10261efc235c8fcc8aad54556615b0cc23be",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ccef10261efc235c8fcc8aad54556615b0cc23be"
      }
    ],
    "stats": {
      "total": 205,
      "additions": 190,
      "deletions": 15
    },
    "files": [
      {
        "sha": "81ac065feffa95fb8ae8ee599518952729d1d213",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e77fab05a0450dffbc96fff32ba3fa6c378adb44/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e77fab05a0450dffbc96fff32ba3fa6c378adb44/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=e77fab05a0450dffbc96fff32ba3fa6c378adb44",
        "patch": "@@ -904,6 +904,12 @@ bool CCoinsViewMemPool::GetCoin(const COutPoint &outpoint, Coin &coin) const {\n     // conflict with the underlying cache, and it cannot have pruned entries (as it contains full)\n     // transactions. First checking the underlying cache risks returning a pruned entry instead.\n     CTransactionRef ptx = mempool.get(outpoint.hash);\n+    if (!ptx) {\n+        // If a coin is missing from the mempool, check to see if it's part of\n+        // a candidate package\n+        auto it = package_tx.find(outpoint.hash);\n+        if (it != package_tx.end()) ptx = it->second;\n+    }\n     if (ptx) {\n         if (outpoint.n < ptx->vout.size()) {\n             coin = Coin(ptx->vout[outpoint.n], MEMPOOL_HEIGHT, false);"
      },
      {
        "sha": "1888ba6d025a9671a30292675ceeb3b8585e3911",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e77fab05a0450dffbc96fff32ba3fa6c378adb44/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e77fab05a0450dffbc96fff32ba3fa6c378adb44/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=e77fab05a0450dffbc96fff32ba3fa6c378adb44",
        "patch": "@@ -862,8 +862,12 @@ class CTxMemPool\n  */\n class CCoinsViewMemPool : public CCoinsViewBacked\n {\n+public:\n+    void AddPotentialTransaction(const CTransactionRef& ptx) { package_tx.emplace(ptx->GetHash(), ptx); }\n+\n protected:\n     const CTxMemPool& mempool;\n+    std::map<uint256, const CTransactionRef> package_tx;\n \n public:\n     CCoinsViewMemPool(CCoinsView* baseIn, const CTxMemPool& mempoolIn);"
      },
      {
        "sha": "8e21a386ba2434a3b39939cf78caeee8e6e128c3",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 176,
        "deletions": 15,
        "changes": 191,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e77fab05a0450dffbc96fff32ba3fa6c378adb44/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e77fab05a0450dffbc96fff32ba3fa6c378adb44/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=e77fab05a0450dffbc96fff32ba3fa6c378adb44",
        "patch": "@@ -257,10 +257,9 @@ bool TestLockPointValidity(const LockPoints* lp)\n     return true;\n }\n \n-bool CheckSequenceLocks(const CTxMemPool& pool, const CTransaction& tx, int flags, LockPoints* lp, bool useExistingLockPoints)\n+static bool CheckSequenceLocks(CCoinsViewCache &view, const CTransaction& tx, int flags, LockPoints* lp, bool useExistingLockPoints=false) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     AssertLockHeld(cs_main);\n-    AssertLockHeld(pool.cs);\n \n     CBlockIndex* tip = ::ChainActive().Tip();\n     assert(tip != nullptr);\n@@ -282,14 +281,12 @@ bool CheckSequenceLocks(const CTxMemPool& pool, const CTransaction& tx, int flag\n         lockPair.second = lp->time;\n     }\n     else {\n-        // CoinsTip() contains the UTXO set for ::ChainActive().Tip()\n-        CCoinsViewMemPool viewMemPool(&::ChainstateActive().CoinsTip(), pool);\n         std::vector<int> prevheights;\n         prevheights.resize(tx.vin.size());\n         for (size_t txinIndex = 0; txinIndex < tx.vin.size(); txinIndex++) {\n             const CTxIn& txin = tx.vin[txinIndex];\n             Coin coin;\n-            if (!viewMemPool.GetCoin(txin.prevout, coin)) {\n+            if (!view.GetCoin(txin.prevout, coin)) {\n                 return error(\"%s: Missing input\", __func__);\n             }\n             if (coin.nHeight == MEMPOOL_HEIGHT) {\n@@ -329,6 +326,14 @@ bool CheckSequenceLocks(const CTxMemPool& pool, const CTransaction& tx, int flag\n     return EvaluateSequenceLocks(index, lockPair);\n }\n \n+bool CheckSequenceLocks(const CTxMemPool& pool, const CTransaction& tx, int flags, LockPoints* lp, bool useExistingLockPoints)\n+{\n+    AssertLockHeld(cs_main);\n+    CCoinsViewMemPool viewMemPool(&::ChainstateActive().CoinsTip(), pool);\n+    CCoinsViewCache view(&viewMemPool);\n+    return CheckSequenceLocks(view, tx, flags, lp, useExistingLockPoints);\n+}\n+\n // Returns the script flags which should be checked for a given block\n static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consensus::Params& chainparams);\n \n@@ -481,11 +486,14 @@ class MemPoolAccept\n     // Single transaction acceptance\n     bool AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs& args) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n+    // Multiple transaction acceptance\n+    bool AcceptMultipleTransactions(const std::list<CTransactionRef>& tx_list, ATMPArgs& args) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n private:\n     // All the intermediate state that gets passed between the various levels\n     // of checking a given transaction.\n     struct Workspace {\n-        Workspace(const CTransactionRef& ptx) : m_ptx(ptx), m_hash(ptx->GetHash()) {}\n+        Workspace(const CTransactionRef& ptx, bool _cpfpable) : m_cpfpable(_cpfpable), m_ptx(ptx), m_hash(ptx->GetHash()) {}\n         std::set<uint256> m_conflicts;\n         CTxMemPool::setEntries m_all_conflicting;\n         CTxMemPool::setEntries m_ancestors;\n@@ -496,6 +504,8 @@ class MemPoolAccept\n         CAmount m_conflicting_fees;\n         size_t m_conflicting_size;\n \n+        const bool m_cpfpable; // whether the fee-checks for this tx can be satisfied by another tx\n+\n         const CTransactionRef& m_ptx;\n         const uint256& m_hash;\n     };\n@@ -541,7 +551,8 @@ class MemPoolAccept\n     CCoinsViewMemPool m_viewmempool;\n     CCoinsView m_dummy;\n \n-    // The package limits in effect at the time of invocation.\n+    // Package acceptance uses a heuristic to test against these limits,\n+    // separately from what is done in PreChecks().\n     const size_t m_limit_ancestors;\n     const size_t m_limit_ancestor_size;\n     // These may be modified while evaluating a transaction (eg to account for\n@@ -559,7 +570,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     // Copy/alias what we need out of args\n     TxValidationState &state = args.m_state;\n     const int64_t nAcceptTime = args.m_accept_time;\n-    const bool bypass_limits = args.m_bypass_limits;\n+    const bool bypass_limits = args.m_bypass_limits || ws.m_cpfpable;\n     const CAmount& nAbsurdFee = args.m_absurd_fee;\n     std::vector<COutPoint>& coins_to_uncache = args.m_coins_to_uncache;\n \n@@ -678,9 +689,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     // Only accept BIP68 sequence locked transactions that can be mined in the next\n     // block; we don't want our mempool filled up with transactions that can't\n     // be mined yet.\n-    // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n-    // CoinsViewCache instead of create its own\n-    if (!CheckSequenceLocks(m_pool, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n+    if (!CheckSequenceLocks(m_view, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n         return state.Invalid(TxValidationResult::TX_PREMATURE_SPEND, \"non-BIP68-final\");\n \n     CAmount nFees = 0;\n@@ -721,8 +730,8 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n         return state.Invalid(TxValidationResult::TX_NOT_STANDARD, \"bad-txns-too-many-sigops\",\n                 strprintf(\"%d\", nSigOpsCost));\n \n-    // No transactions are allowed below minRelayTxFee except from disconnected\n-    // blocks\n+    // No transactions are allowed below minRelayTxFee/mempool min fee except\n+    // from disconnected blocks\n     if (!bypass_limits && !CheckFeeRate(nSize, nModifiedFees, state)) return false;\n \n     if (nAbsurdFee && nFees > nAbsurdFee)\n@@ -985,7 +994,7 @@ bool MemPoolAccept::Finalize(ATMPArgs& args, Workspace& ws)\n     const CTransaction& tx = *ws.m_ptx;\n     const uint256& hash = ws.m_hash;\n     TxValidationState &state = args.m_state;\n-    const bool bypass_limits = args.m_bypass_limits;\n+    const bool bypass_limits = args.m_bypass_limits || ws.m_cpfpable;\n \n     CTxMemPool::setEntries& allConflicting = ws.m_all_conflicting;\n     CTxMemPool::setEntries& setAncestors = ws.m_ancestors;\n@@ -1032,7 +1041,7 @@ bool MemPoolAccept::AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs\n     AssertLockHeld(cs_main);\n     LOCK(m_pool.cs); // mempool \"read lock\" (held through GetMainSignals().TransactionAddedToMempool())\n \n-    Workspace workspace(ptx);\n+    Workspace workspace(ptx, /* m_cpfpable */ false);\n \n     if (!PreChecks(args, workspace)) return false;\n \n@@ -1056,6 +1065,132 @@ bool MemPoolAccept::AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs\n     return true;\n }\n \n+\n+bool MemPoolAccept::AcceptMultipleTransactions(const std::list<CTransactionRef>& tx_list, ATMPArgs& args)\n+{\n+    AssertLockHeld(cs_main);\n+    LOCK(m_pool.cs);\n+\n+    std::list<Workspace> tx_workspaces;\n+\n+    for (const CTransactionRef& ptx : tx_list) {\n+        // The last transaction must be validated for making it past the fee\n+        // checks on its own, to prevent packages from including low-fee,\n+        // unnecessary children that are attached to higher fee parents.\n+        tx_workspaces.emplace_back(Workspace(ptx, ptx != tx_list.back()));\n+        Workspace &ws = tx_workspaces.back();\n+\n+        if (!PreChecks(args, ws)) return false;\n+\n+        // For now, do not allow replacements in package transactions. If we\n+        // relax this, we would need to check that no child transaction depends\n+        // on any in-mempool transaction that conflicts with any package\n+        // transaction.\n+        if (!ws.m_conflicts.empty()) {\n+            return args.m_state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"rbf-disallowed-in-package\", strprintf(\"mempool conflicts with tx %s\", ptx->GetHash().ToString()));\n+        }\n+        // Add this transaction to our coinsview, so that subsequent\n+        // transactions in this package will have their inputs available.\n+        m_viewmempool.AddPotentialTransaction(ptx);\n+    }\n+\n+    // Check overall package feerate\n+    size_t total_size=0;\n+    CAmount total_fee=0;\n+    uint64_t total_count = tx_list.size();\n+    for (const Workspace& ws : tx_workspaces) {\n+        total_size += ws.m_entry->GetTxSize();\n+        total_fee += ws.m_modified_fees;\n+    }\n+    if (!CheckFeeRate(total_size, total_fee, args.m_state)) return false;\n+\n+    // The ancestor/descendant limit calculations in PreChecks() will be overly\n+    // permissive, because not all ancestors will be known as we descend down\n+    // the package. Thus the ancestor checks done by\n+    // CalculateMemPoolAncestors() will be incomplete. If any ancestor or\n+    // descendant limit is violated in one of those checks, however, we know\n+    // the package will not be accepted when we include all ancestors, as the\n+    // ancestor/descendant size/counts only go up as we add more ancestors to\n+    // each transaction.\n+    // We will end up needing to recalculate setAncestors for each transaction\n+    // prior to calling Finalize, but we should do the correct package-size\n+    // calculations before we call ScriptChecks(), to avoid CPU-DoS.\n+\n+    // For now, do something conservative -- assume that the union of ancestors\n+    // of each transaction is an ancestor of every transaction, for package\n+    // size purposes.\n+    CTxMemPool::setEntries all_ancestors;\n+    for (const Workspace& ws : tx_workspaces) {\n+        all_ancestors.insert(ws.m_ancestors.begin(), ws.m_ancestors.end());\n+    }\n+\n+    if (total_count + all_ancestors.size() > m_limit_ancestors) {\n+        return args.m_state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"too-long-package-mempool-chain\", strprintf(\"exceeds ancestor count limit [package: %u limit: %u]\", total_count + all_ancestors.size(), m_limit_ancestors));\n+    }\n+\n+    // Check the package limits for every ancestor, assuming the whole package\n+    // descends from each.\n+    size_t ancestor_size = total_size;\n+    for (auto tx_iter : all_ancestors) {\n+        if (tx_iter->GetSizeWithDescendants() + total_size > m_limit_descendant_size) {\n+            return args.m_state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"too-long-package-mempool-chain\", strprintf(\"exceeds descendant size limit for tx %s [limit: %u]\", tx_iter->GetTx().GetHash().ToString(), m_limit_descendant_size));\n+        }\n+        if (tx_iter->GetCountWithDescendants() + total_count > m_limit_descendants) {\n+            return args.m_state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"too-long-package-mempool-chain\", strprintf(\"exceeds descendant size limit for tx %s [limit: %u]\", tx_iter->GetTx().GetHash().ToString(), m_limit_descendants));\n+        }\n+        ancestor_size += tx_iter->GetTxSize();\n+    }\n+\n+    // In case we have no in-mempool ancestors, we must check the transaction\n+    // package itself.\n+    if (total_size > m_limit_descendant_size) {\n+        return args.m_state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"too-long-package-mempool-chain\", strprintf(\"exceeds descendant size limit for tx %s [limit: %u]\", tx_list.front()->GetHash().ToString(), m_limit_descendant_size));\n+    }\n+    if (ancestor_size > m_limit_ancestor_size) {\n+        return args.m_state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"too-long-package-mempool-chain\", strprintf(\"exceeds ancestor size limit for tx %s [limit: %u]\", tx_list.back()->GetHash().ToString(), m_limit_ancestor_size));\n+    }\n+\n+    // Do the script checks after all policy checks are done\n+    std::vector<PrecomputedTransactionData> txdata;\n+    txdata.reserve(tx_list.size());\n+    for (auto wit = tx_workspaces.begin(); wit != tx_workspaces.end(); ++wit) {\n+        txdata.emplace_back(*wit->m_ptx);\n+        if (!PolicyScriptChecks(args, *wit, txdata.back())) return false;\n+    }\n+\n+    // This package should be accepted except possibly for failing in\n+    // TrimToSize(), which we can't exercise without actually adding to the\n+    // mempool and seeing what would happen. Note that we are not adding\n+    // these transactions to the script cache, unlike in the single-tx case.\n+    if (args.m_test_accept) return true;\n+\n+    // Add everything to the mempool, and make sure the last transaction makes\n+    // it in.\n+    size_t i=0;\n+    for (auto wit = tx_workspaces.begin(); wit != tx_workspaces.end(); ++wit, ++i) {\n+        // Recheck the scripts with consensus flags and cache script execution\n+        // success. We have to wait until all the inputs are in the mempool or\n+        // in the utxo set (for now) before we can invoke this. This should\n+        // not fail unless there's a logic bug in our script validation, but if\n+        // it somehow were to fail on some child tx, we would potentially be\n+        // allowing parents into the mempool with this logic.\n+        if (!ConsensusScriptChecks(args, *wit, txdata[i])) return false;\n+\n+        // Recalculate ancestors for every transaction after the first, because\n+        // previously the ancestor sets were missing package transactions that\n+        // were not yet in the mempool at the time PreChecks() was called.\n+        if (wit != tx_workspaces.begin()) {\n+            wit->m_ancestors.clear();\n+            std::string dummy_string;\n+            // Don't worry about the return value here; it must pass based on\n+            // the checks above. TODO: assert on passing?\n+            m_pool.CalculateMemPoolAncestors(*(wit->m_entry), wit->m_ancestors, m_limit_ancestors, m_limit_ancestor_size, m_limit_descendants, m_limit_descendant_size, dummy_string);\n+        }\n+        if (!Finalize(args, *wit)) return false;\n+    }\n+    return true;\n+}\n+\n } // anon namespace\n \n /** (try to) add transaction to memory pool with a specified acceptance time **/\n@@ -1081,6 +1216,32 @@ static bool AcceptToMemoryPoolWithTime(const CChainParams& chainparams, CTxMemPo\n     return res;\n }\n \n+bool AcceptPackageToMemoryPool(CTxMemPool& pool, TxValidationState &state,\n+        std::list<CTransactionRef>& tx_list, std::list<CTransactionRef>* replaced_transactions,\n+        const CAmount nAbsurdFee, bool test_accept)\n+{\n+    const CChainParams& chainparams = Params();\n+    AssertLockHeld(cs_main);\n+\n+    std::vector<COutPoint> coins_to_uncache;\n+    MemPoolAccept::ATMPArgs args { chainparams, state, GetTime(), replaced_transactions, /* m_bypass_limits */ false, nAbsurdFee, coins_to_uncache, test_accept };\n+    bool res = MemPoolAccept(pool).AcceptMultipleTransactions(tx_list, args);\n+\n+    if (!res) {\n+        // Remove coins that were not present in the coins cache beforehand;\n+        // this is to prevent memory DoS in case we receive a large number of\n+        // invalid transactions that attempt to overrun the in-memory coins cache\n+        // (`CCoinsViewCache::cacheCoins`).\n+        for (const COutPoint& hashTx : coins_to_uncache) {\n+            ::ChainstateActive().CoinsTip().Uncache(hashTx);\n+        }\n+    }\n+    // After we've (potentially) uncached entries, ensure our coins cache is still within its size limits\n+    BlockValidationState stateDummy;\n+    ::ChainstateActive().FlushStateToDisk(chainparams, stateDummy, FlushStateMode::PERIODIC);\n+    return res;\n+}\n+\n bool AcceptToMemoryPool(CTxMemPool& pool, TxValidationState &state, const CTransactionRef &tx,\n                         std::list<CTransactionRef>* plTxnReplaced,\n                         bool bypass_limits, const CAmount nAbsurdFee, bool test_accept)"
      },
      {
        "sha": "2960b2341d0263a375ea5cdf8449fdd25597a34f",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e77fab05a0450dffbc96fff32ba3fa6c378adb44/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e77fab05a0450dffbc96fff32ba3fa6c378adb44/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=e77fab05a0450dffbc96fff32ba3fa6c378adb44",
        "patch": "@@ -195,6 +195,10 @@ bool AcceptToMemoryPool(CTxMemPool& pool, TxValidationState &state, const CTrans\n                         std::list<CTransactionRef>* plTxnReplaced,\n                         bool bypass_limits, const CAmount nAbsurdFee, bool test_accept=false) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n+bool AcceptPackageToMemoryPool(CTxMemPool& pool, TxValidationState &state, std::list<CTransactionRef>& tx_list,\n+                               std::list<CTransactionRef>* replaced_transactions,\n+                               const CAmount nAbsurdFee, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n /** Get the BIP9 state for a given deployment at the current tip. */\n ThresholdState VersionBitsTipState(const Consensus::Params& params, Consensus::DeploymentPos pos);\n "
      }
    ]
  },
  {
    "sha": "71c1451a366c364deb7d775e7473dad5d03d173d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3MWMxNDUxYTM2NmMzNjRkZWI3ZDc3NWU3NDczZGFkNWQwM2QxNzNk",
    "commit": {
      "author": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-07-10T16:16:26Z"
      },
      "committer": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-07-27T19:02:27Z"
      },
      "message": "Restrain package size to 2 transactions directly dependent\n\nIn next commit, we relax restriction on conflict replacement at package\nacceptance. Package transactions may depend on conflicted ones replaced\nby other package elements, thus making its evaluation expensive. To avoid\nDoS risk while allowing feerate-increasing packages limit theirs composition\nto 2 transactions, the latter only dependent on the former.",
      "tree": {
        "sha": "923b5138849bc3973c9f06eae81cdf713f81e77b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/923b5138849bc3973c9f06eae81cdf713f81e77b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/71c1451a366c364deb7d775e7473dad5d03d173d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/71c1451a366c364deb7d775e7473dad5d03d173d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/71c1451a366c364deb7d775e7473dad5d03d173d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/71c1451a366c364deb7d775e7473dad5d03d173d/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "e77fab05a0450dffbc96fff32ba3fa6c378adb44",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e77fab05a0450dffbc96fff32ba3fa6c378adb44",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e77fab05a0450dffbc96fff32ba3fa6c378adb44"
      }
    ],
    "stats": {
      "total": 19,
      "additions": 19,
      "deletions": 0
    },
    "files": [
      {
        "sha": "e3b50fc848db7e0e152f68efd762a7f0112f9d4a",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/71c1451a366c364deb7d775e7473dad5d03d173d/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/71c1451a366c364deb7d775e7473dad5d03d173d/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=71c1451a366c364deb7d775e7473dad5d03d173d",
        "patch": "@@ -1073,6 +1073,25 @@ bool MemPoolAccept::AcceptMultipleTransactions(const std::list<CTransactionRef>&\n \n     std::list<Workspace> tx_workspaces;\n \n+    // For now, ensure package is size-limited to 2 transactions.\n+    if (tx_list.size() != 2) {\n+        return args.m_state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"non-standard-package-chain\", \"only 2-txn-sized package are allowed\");\n+    }\n+\n+    // Make sure all transactions are ancestors of the last one.\n+    // For now, just check that the last transaction has all prior transactions\n+    // as direct inputs. We can relax this in the future for bigger packages.\n+    std::set<uint256> last_tx_parents;\n+    for (auto input : tx_list.back()->vin) {\n+        last_tx_parents.insert(input.prevout.hash);\n+    }\n+    for (auto ptx : tx_list) {\n+        if (ptx == tx_list.back()) break;\n+        if (last_tx_parents.count(ptx->GetHash()) == 0) {\n+            return args.m_state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"non-standard-package-chain\", \"only direct parents are allowed in package\");\n+        }\n+    }\n+\n     for (const CTransactionRef& ptx : tx_list) {\n         // The last transaction must be validated for making it past the fee\n         // checks on its own, to prevent packages from including low-fee,"
      }
    ]
  },
  {
    "sha": "aca8c361ccd831b5397a0588494f519c55db738b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphY2E4YzM2MWNjZDgzMWI1Mzk3YTA1ODg0OTRmNTE5YzU1ZGI3Mzhi",
    "commit": {
      "author": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-07-27T19:14:06Z"
      },
      "committer": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-07-27T19:58:11Z"
      },
      "message": "Allow a package tx to bypass PreChecks() already-in/feerate-conflicts checks\n\nA package may bundle a newer CPFP with an already-in subgraph. To\nevaluate replacement correctly, collect older fees of each conflicted\ntransactions while omitting per-transaction fee/feerate checks in\nPreChecks().\n\nFor now, we don't evict conflicting duplicate, as a transaction might be in\nconflict with multiple package elements.\n\nXXX: refactor PreChecks() to dedup in AcceptMultipleTransactions ?",
      "tree": {
        "sha": "fb90675e465cc1833d36c46f4f778ad6fe56e08c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fb90675e465cc1833d36c46f4f778ad6fe56e08c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/aca8c361ccd831b5397a0588494f519c55db738b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aca8c361ccd831b5397a0588494f519c55db738b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/aca8c361ccd831b5397a0588494f519c55db738b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aca8c361ccd831b5397a0588494f519c55db738b/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "71c1451a366c364deb7d775e7473dad5d03d173d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/71c1451a366c364deb7d775e7473dad5d03d173d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/71c1451a366c364deb7d775e7473dad5d03d173d"
      }
    ],
    "stats": {
      "total": 33,
      "additions": 20,
      "deletions": 13
    },
    "files": [
      {
        "sha": "1ffe8547602fcf563344ec79989119ba4e27f8a7",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 13,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aca8c361ccd831b5397a0588494f519c55db738b/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aca8c361ccd831b5397a0588494f519c55db738b/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=aca8c361ccd831b5397a0588494f519c55db738b",
        "patch": "@@ -583,6 +583,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     CAmount& nModifiedFees = ws.m_modified_fees;\n     CAmount& nConflictingFees = ws.m_conflicting_fees;\n     size_t& nConflictingSize = ws.m_conflicting_size;\n+    const bool bypass_already_in = ws.m_cpfpable;\n \n     if (!CheckTransaction(tx, state)) {\n         return false; // state filled in by CheckTransaction\n@@ -611,8 +612,8 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n         return state.Invalid(TxValidationResult::TX_PREMATURE_SPEND, \"non-final\");\n \n     // is it already in the memory pool?\n-    if (m_pool.exists(hash)) {\n-        return state.Invalid(TxValidationResult::TX_CONFLICT, \"txn-already-in-mempool\");\n+    if (m_pool.exists(hash) && !bypass_already_in) {\n+            return state.Invalid(TxValidationResult::TX_CONFLICT, \"txn-already-in-mempool\");\n     }\n \n     // Check for conflicts with in-memory transactions\n@@ -643,7 +644,8 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n                         break;\n                     }\n                 }\n-                if (fReplacementOptOut) {\n+                // A package transaction opt-in by default to replacement.\n+                if (fReplacementOptOut && !bypass_already_in) {\n                     return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"txn-mempool-conflict\");\n                 }\n \n@@ -844,7 +846,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n             // or not to replace, we do require the replacement to pay more\n             // overall fees too, mitigating most cases.\n             CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n-            if (newFeeRate <= oldFeeRate)\n+            if (newFeeRate <= oldFeeRate && !bypass_already_in)\n             {\n                 return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"insufficient fee\",\n                         strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n@@ -908,7 +910,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n         // The replacement must pay greater fees than the transactions it\n         // replaces - if we did the bandwidth used by those conflicting\n         // transactions would not be paid for.\n-        if (nModifiedFees < nConflictingFees)\n+        if (nModifiedFees < nConflictingFees && !bypass_already_in)\n         {\n             return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"insufficient fee\",\n                     strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n@@ -918,7 +920,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n         // Finally in addition to paying more fees than the conflicts the\n         // new transaction must pay for its own bandwidth.\n         CAmount nDeltaFees = nModifiedFees - nConflictingFees;\n-        if (nDeltaFees < ::incrementalRelayFee.GetFee(nSize))\n+        if (nDeltaFees < ::incrementalRelayFee.GetFee(nSize) && !bypass_already_in)\n         {\n             return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"insufficient fee\",\n                     strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n@@ -1101,28 +1103,33 @@ bool MemPoolAccept::AcceptMultipleTransactions(const std::list<CTransactionRef>&\n \n         if (!PreChecks(args, ws)) return false;\n \n-        // For now, do not allow replacements in package transactions. If we\n-        // relax this, we would need to check that no child transaction depends\n-        // on any in-mempool transaction that conflicts with any package\n-        // transaction.\n-        if (!ws.m_conflicts.empty()) {\n-            return args.m_state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"rbf-disallowed-in-package\", strprintf(\"mempool conflicts with tx %s\", ptx->GetHash().ToString()));\n-        }\n         // Add this transaction to our coinsview, so that subsequent\n         // transactions in this package will have their inputs available.\n         m_viewmempool.AddPotentialTransaction(ptx);\n     }\n \n     // Check overall package feerate\n     size_t total_size=0;\n+    size_t total_conflicting_size=0;\n     CAmount total_fee=0;\n+    CAmount total_conflicting_fee=0;\n     uint64_t total_count = tx_list.size();\n     for (const Workspace& ws : tx_workspaces) {\n         total_size += ws.m_entry->GetTxSize();\n+        total_conflicting_size += ws.m_conflicting_size;\n         total_fee += ws.m_modified_fees;\n+        total_conflicting_fee += ws.m_conflicting_fees;\n     }\n     if (!CheckFeeRate(total_size, total_fee, args.m_state)) return false;\n \n+    // For now, don't evict conflicting duplicates, as a transaction might be\n+    // in conflict with multiple package elements.\n+    if (total_conflicting_size) {\n+        CFeeRate oldFeeRate(total_conflicting_fee, total_conflicting_size);\n+        CFeeRate newFeeRate(total_fee, total_size);\n+        if (newFeeRate <= oldFeeRate) return false;\n+    }\n+\n     // The ancestor/descendant limit calculations in PreChecks() will be overly\n     // permissive, because not all ancestors will be known as we descend down\n     // the package. Thus the ancestor checks done by"
      }
    ]
  },
  {
    "sha": "dbb426bc262e1d9152f0ab798df6c1589d7d0d18",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkYmI0MjZiYzI2MmUxZDkxNTJmMGFiNzk4ZGY2YzE1ODlkN2QwZDE4",
    "commit": {
      "author": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-07-05T04:00:08Z"
      },
      "committer": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-07-27T21:32:31Z"
      },
      "message": "Add PackageCache, a package_id -> set of wtxids map\n\nTo reduce bandwidth consumption due to package announcement, only\nannounce a 32-byte package_id, sha256 of all package transactions.\n\nTo avoid this cache being a DoS risk, allocate a number of package\nannouncements to each upstream peer. To guarantee flush, prune old\nentries after a delay (PACKAGE_CACHE_DELAY), thus requiring downstream\npackage round-trip to achieve before.",
      "tree": {
        "sha": "28347791cb764d9b7647cc27986d18f44433de2d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/28347791cb764d9b7647cc27986d18f44433de2d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dbb426bc262e1d9152f0ab798df6c1589d7d0d18",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dbb426bc262e1d9152f0ab798df6c1589d7d0d18",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dbb426bc262e1d9152f0ab798df6c1589d7d0d18",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dbb426bc262e1d9152f0ab798df6c1589d7d0d18/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "aca8c361ccd831b5397a0588494f519c55db738b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aca8c361ccd831b5397a0588494f519c55db738b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/aca8c361ccd831b5397a0588494f519c55db738b"
      }
    ],
    "stats": {
      "total": 237,
      "additions": 237,
      "deletions": 0
    },
    "files": [
      {
        "sha": "bef1d1f37bba49c5b7fbeaac2ff2111ec9e56677",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dbb426bc262e1d9152f0ab798df6c1589d7d0d18/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dbb426bc262e1d9152f0ab798df6c1589d7d0d18/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=dbb426bc262e1d9152f0ab798df6c1589d7d0d18",
        "patch": "@@ -172,6 +172,7 @@ BITCOIN_CORE_H = \\\n   noui.h \\\n   optional.h \\\n   outputtype.h \\\n+  packagecache.h\\\n   policy/feerate.h \\\n   policy/fees.h \\\n   policy/policy.h \\\n@@ -307,6 +308,7 @@ libbitcoin_server_a_SOURCES = \\\n   node/transaction.cpp \\\n   node/ui_interface.cpp \\\n   noui.cpp \\\n+  packagecache.cpp\\\n   policy/fees.cpp \\\n   policy/rbf.cpp \\\n   policy/settings.cpp \\"
      },
      {
        "sha": "0990489aa1ecd4a8bfcb463c82871df4475f5e2f",
        "filename": "src/packagecache.cpp",
        "status": "added",
        "additions": 98,
        "deletions": 0,
        "changes": 98,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dbb426bc262e1d9152f0ab798df6c1589d7d0d18/src/packagecache.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dbb426bc262e1d9152f0ab798df6c1589d7d0d18/src/packagecache.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/packagecache.cpp?ref=dbb426bc262e1d9152f0ab798df6c1589d7d0d18",
        "patch": "@@ -0,0 +1,98 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <packagecache.h>\n+\n+/** Maximum number of package per peer */\n+static constexpr int32_t MAX_PEER_PACKAGE = 1000;\n+/** How many microseconds to keep this package entry available for announcing/fetching. */\n+static constexpr std::chrono::microseconds PACKAGE_CACHE_DELAY{std::chrono::seconds{60}};\n+\n+PackageCache::PackageCache() :\n+    m_cache(boost::make_tuple(\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Package, PackageTime, &Package::ExtractTime>(),\n+            std::less<PackageTime>()\n+        ),\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Package, PackageId, &Package::ExtractId>(),\n+            std::less<PackageId>()\n+        )\n+    )) {}\n+\n+size_t PackageCache::CountPackage(uint64_t upstream_peer) const\n+{\n+    auto it = m_peerinfo.find(upstream_peer);\n+    if (it != m_peerinfo.end()) return it->second.m_total;\n+    return 0;\n+}\n+\n+void PackageCache::FlushOldPackages(std::chrono::microseconds timeout)\n+{\n+    while (!m_cache.empty()) {\n+        auto it = m_cache.get<ByTime>().begin();\n+        if (it->m_time <= timeout) {\n+            Erase<ByTime>(it);\n+        } else {\n+            break;\n+        }\n+    }\n+}\n+\n+void PackageCache::ReceivedPackage(uint64_t upstream_peer, const uint256& package_id, std:: vector<uint256> package_wtxids, std::chrono::microseconds recvtime)\n+{\n+    if (CountPackage(upstream_peer) >= MAX_PEER_PACKAGE) return;\n+\n+    // If we already know about this package ignore it.\n+    auto it = m_cache.get<ById>().find(PackageId{package_id});\n+    if (it != m_cache.get<ById>().end()) return;\n+\n+    auto ret = m_cache.get<ById>().emplace(package_id, package_wtxids, upstream_peer, recvtime + PACKAGE_CACHE_DELAY);\n+    if (ret.second) {\n+        ++m_peerinfo[upstream_peer].m_total;\n+        for (const uint256& wtxid: package_wtxids) {\n+            auto it = m_associated_pkgs.find(wtxid);\n+            if (it != m_associated_pkgs.end()) {\n+                it->second.emplace(package_id);\n+            }\n+        }\n+    }\n+}\n+\n+static const uint256 UINT256_ZERO;\n+\n+void PackageCache::GetAnnouncable(uint64_t downstream_peer, std::vector<uint256>& package_ids)\n+{\n+    auto it = m_cache.get<ById>().lower_bound(PackageId{UINT256_ZERO});\n+    while (it != m_cache.get<ById>().end()) {\n+        // If this downstream peer hasn't heard about it, mark it for announcement.\n+        if (it->m_already_announced.count(downstream_peer) == 0) {\n+            package_ids.push_back(it->m_package_id);\n+            it->m_already_announced.emplace(downstream_peer);\n+        }\n+        it++;\n+    }\n+}\n+\n+void PackageCache::GetPackageWtxids(uint64_t downstream_peer, const uint256& package_id, std::vector<uint256>& package_wtxids)\n+{\n+    auto it = m_cache.get<ById>().find(PackageId{package_id});\n+    if (it != m_cache.get<ById>().end()) {\n+        // If downstream peer hasn't be announced package id don't yet walk away\n+        if (it->m_already_announced.count(downstream_peer) == 0) return;\n+        package_wtxids = it->package_wtxids;\n+    }\n+}\n+\n+bool PackageCache::HasPackage(uint256& wtxid) {\n+    return m_associated_pkgs.count(wtxid) == 1;\n+}\n+\n+void PackageCache::AddPackageKnown(uint64_t upstream_peer, uint256 package_id) {\n+    auto it = m_cache.get<ById>().find(PackageId{package_id});\n+    if (it != m_cache.get<ById>().end()) {\n+        it->m_already_announced.emplace(upstream_peer);\n+    }\n+}"
      },
      {
        "sha": "bb632fc824d88a2dae01cd225858cd01c2735867",
        "filename": "src/packagecache.h",
        "status": "added",
        "additions": 137,
        "deletions": 0,
        "changes": 137,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dbb426bc262e1d9152f0ab798df6c1589d7d0d18/src/packagecache.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dbb426bc262e1d9152f0ab798df6c1589d7d0d18/src/packagecache.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/packagecache.h?ref=dbb426bc262e1d9152f0ab798df6c1589d7d0d18",
        "patch": "@@ -0,0 +1,137 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_PACKAGE_H\n+#define BITCOIN_PACKAGE_H\n+\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <map>\n+#include <set>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep cache and schedule package announcement from/to peers.\n+ *\n+ * Maintain a cache of package_id -> set of wtxids. As we cache data at the request\n+ * of untrusted peers we have to bound them (MAX_PEER_PACKAGE) to avoid risk of memory\n+ * DoS. We also expire package entry after PACKAGE_CACHE_DELAY to flush the cache and\n+ * avoid any late-stucking entry, which means package round-trip should have been achieved\n+ * with ever downstream peers before.\n+ *\n+ * XXX: round-robin announcements to avoid upstream peers overflowing our\n+ * downstream package bandwidth ?\n+ */\n+class PackageCache {\n+\n+    //! Tag for the PackageTime-based index.\n+    struct ByTime {};\n+    //! Tag for the PackageId-based index.\n+    struct ById {};\n+\n+    //! The ByTime index is sorted by (recvtime, id).\n+    using PackageTime = std::tuple<std::chrono::microseconds, const uint256&>;\n+\n+    //! The ById index is sorted by id.\n+    using PackageId = const uint256;\n+\n+    //! A package entry\n+    struct Package {\n+        //! Package id that was received.\n+        const uint256 m_package_id;\n+        //! List of wtxids included in this package.\n+        const std::vector<uint256> package_wtxids;\n+        //! What upstream peer sends this package.\n+        const uint64_t m_peer;\n+        //! When this package should be pruned for expiration.\n+        mutable std::chrono::microseconds m_time;\n+        //! List of downstream peers already announced to.\n+        mutable std::set<uint64_t> m_already_announced;\n+\n+        //! Construct a new entry from scratch.\n+        Package(const uint256& package_id, std::vector<uint256> wtxids, uint64_t peer, std::chrono::microseconds exptime) :\n+            m_package_id(package_id), package_wtxids(wtxids), m_peer(peer), m_time(exptime) {}\n+\n+        //! Extract the PackageTime from this Package.\n+        PackageTime ExtractTime() const { return PackageTime{m_time, m_package_id}; }\n+\n+        //! Extract the PackageId from this Package.\n+        PackageId ExtractId() const { return PackageId{m_package_id}; }\n+    };\n+\n+    //! Data type for the main data structure\n+    using Cache = boost::multi_index_container<\n+        Package,\n+        boost::multi_index::indexed_by<\n+            boost::multi_index::ordered_unique<\n+                boost::multi_index::tag<ByTime>,\n+                boost::multi_index::const_mem_fun<Package, PackageTime, &Package::ExtractTime>\n+            >,\n+            boost::multi_index::ordered_unique<\n+                boost::multi_index::tag<ById>,\n+                boost::multi_index::const_mem_fun<Package, PackageId, &Package::ExtractId>\n+            >\n+        >\n+    >;\n+\n+    Cache m_cache;\n+\n+    //! Per-peer statistics object.\n+    struct PeerInfo {\n+        size_t m_total = 0; //!< Total number of entries for this peer\n+    };\n+\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo and m_associated_pkgs up to date.\n+    template<typename Tag>\n+    typename Cache::index<Tag>::type::iterator Erase(typename Cache::index<Tag>::type::iterator it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        for (const uint256& wtxid : it->package_wtxids) {\n+            auto pkgit = m_associated_pkgs.find(wtxid);\n+            pkgit->second.erase(it->m_package_id);\n+        }\n+        return m_cache.get<Tag>().erase(it);\n+    }\n+\n+    //! Count how many packages are being cached for a peer.\n+    size_t CountPackage(uint64_t downstream_peer) const;\n+\n+    //! Delete entry older than timeout.\n+    void FlushOldPackages(std::chrono::microseconds timeout);\n+\n+    //! Per-wtxid associated packages.\n+    std::map<uint256, std::set<uint256>> m_associated_pkgs;\n+\n+public:\n+    //! Construct a PackageCache.\n+    PackageCache();\n+\n+    //! We received a new package, enter it.\n+    void ReceivedPackage(uint64_t upstream_peer, const uint256& package_id, std::vector<uint256> package_wtxids, std::chrono::microseconds recvtime);\n+\n+    //! Select package ids not already announced to this downstream peer.\n+    void GetAnnouncable(uint64_t downstream_peer, std::vector<uint256>& package_ids);\n+\n+    //! Get wtxids included inside a known package id.\n+    void GetPackageWtxids(uint64_t downstream_peer, const uint256& package_id, std::vector<uint256>& package_wtxids);\n+\n+    //! Check if we know a package associated to this txid.\n+    bool HasPackage(uint256& wtxid);\n+\n+    //! Add package known by this peer.\n+    void AddPackageKnown(uint64_t upstream_peer, uint256 package_id);\n+};\n+\n+#endif // BITCOIN_PACKAGE_H"
      }
    ]
  },
  {
    "sha": "1debaa50d1c5e1424faf33939e688e7f63ff5d67",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxZGViYWE1MGQxYzVlMTQyNGZhZjMzOTM5ZTY4OGU3ZjYzZmY1ZDY3",
    "commit": {
      "author": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-07-05T01:34:31Z"
      },
      "committer": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-07-27T22:02:47Z"
      },
      "message": "Add p2p message PACKAGE support\n\nThis new p2p message contains a serialized list of transactions, which\nupon receipt feerate of the whole must determine mempool acceptance.",
      "tree": {
        "sha": "daf649caff7ebc57b4e3318bb46561433d62502a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/daf649caff7ebc57b4e3318bb46561433d62502a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1debaa50d1c5e1424faf33939e688e7f63ff5d67",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1debaa50d1c5e1424faf33939e688e7f63ff5d67",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1debaa50d1c5e1424faf33939e688e7f63ff5d67",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1debaa50d1c5e1424faf33939e688e7f63ff5d67/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "dbb426bc262e1d9152f0ab798df6c1589d7d0d18",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dbb426bc262e1d9152f0ab798df6c1589d7d0d18",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/dbb426bc262e1d9152f0ab798df6c1589d7d0d18"
      }
    ],
    "stats": {
      "total": 23,
      "additions": 23,
      "deletions": 0
    },
    "files": [
      {
        "sha": "6f9310d545800a23d9ca710f2af27f51bc96556b",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1debaa50d1c5e1424faf33939e688e7f63ff5d67/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1debaa50d1c5e1424faf33939e688e7f63ff5d67/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=1debaa50d1c5e1424faf33939e688e7f63ff5d67",
        "patch": "@@ -47,6 +47,7 @@ const char *CFHEADERS=\"cfheaders\";\n const char *GETCFCHECKPT=\"getcfcheckpt\";\n const char *CFCHECKPT=\"cfcheckpt\";\n const char *WTXIDRELAY=\"wtxidrelay\";\n+const char *PACKAGE=\"package\";\n } // namespace NetMsgType\n \n /** All known message types. Keep this in the same order as the list of\n@@ -85,6 +86,7 @@ const static std::string allNetMessageTypes[] = {\n     NetMsgType::GETCFCHECKPT,\n     NetMsgType::CFCHECKPT,\n     NetMsgType::WTXIDRELAY,\n+    NetMsgType::PACKAGE,\n };\n const static std::vector<std::string> allNetMessageTypesVec(allNetMessageTypes, allNetMessageTypes+ARRAYLEN(allNetMessageTypes));\n "
      },
      {
        "sha": "a1817c2eefa2217d022aeb8f74c95b569b248984",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1debaa50d1c5e1424faf33939e688e7f63ff5d67/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1debaa50d1c5e1424faf33939e688e7f63ff5d67/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=1debaa50d1c5e1424faf33939e688e7f63ff5d67",
        "patch": "@@ -11,10 +11,12 @@\n #define BITCOIN_PROTOCOL_H\n \n #include <netaddress.h>\n+#include <primitives/transaction.h>\n #include <serialize.h>\n #include <uint256.h>\n #include <version.h>\n \n+#include <list>\n #include <stdint.h>\n #include <string>\n \n@@ -225,6 +227,13 @@ extern const char* GETBLOCKTXN;\n  * @since protocol version 70014 as described by BIP 152\n  */\n extern const char* BLOCKTXN;\n+/**\n+ * The package message transmits a group of transactions with\n+ * interdependencies for which the aggregated feerate should be\n+ * equal or over to recipient's announced feerate.\n+ * @since protocol 80002 as described by BIP XXX\n+ */\n+extern const char* PACKAGE;\n /**\n  * getcfilters requests compact filters for a range of blocks.\n  * Only available with service bit NODE_COMPACT_FILTERS as described by\n@@ -434,4 +443,16 @@ class CInv\n     uint256 hash;\n };\n \n+class CPackageRelay\n+{\n+public:\n+    std::vector<CTransactionRef> package_txn;\n+\n+    CPackageRelay() {}\n+    explicit CPackageRelay(const std::vector<CTransactionRef> txn) :\n+        package_txn(txn) {}\n+\n+    SERIALIZE_METHODS(CPackageRelay, obj) { READWRITE(Using<VectorFormatter<DefaultFormatter>>(obj.package_txn)); }\n+};\n+\n #endif // BITCOIN_PROTOCOL_H"
      }
    ]
  },
  {
    "sha": "11efd4662f400cfd637c6a909c472d9e093c4a92",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMWVmZDQ2NjJmNDAwY2ZkNjM3YzZhOTA5YzQ3MmQ5ZTA5M2M0YTky",
    "commit": {
      "author": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-07-24T16:29:14Z"
      },
      "committer": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-07-27T22:02:51Z"
      },
      "message": "Add CNodeState::m_package_relay",
      "tree": {
        "sha": "2b9bd2d1c12eb4931461b54e952aca3657eeb962",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2b9bd2d1c12eb4931461b54e952aca3657eeb962"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/11efd4662f400cfd637c6a909c472d9e093c4a92",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/11efd4662f400cfd637c6a909c472d9e093c4a92",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/11efd4662f400cfd637c6a909c472d9e093c4a92",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/11efd4662f400cfd637c6a909c472d9e093c4a92/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "1debaa50d1c5e1424faf33939e688e7f63ff5d67",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1debaa50d1c5e1424faf33939e688e7f63ff5d67",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1debaa50d1c5e1424faf33939e688e7f63ff5d67"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 4,
      "deletions": 0
    },
    "files": [
      {
        "sha": "780c5a63d68bf307a95d19a680513fb4b647fbe8",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/11efd4662f400cfd637c6a909c472d9e093c4a92/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/11efd4662f400cfd637c6a909c472d9e093c4a92/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=11efd4662f400cfd637c6a909c472d9e093c4a92",
        "patch": "@@ -427,6 +427,9 @@ struct CNodeState {\n     //! Whether this peer relays txs via wtxid\n     bool m_wtxid_relay{false};\n \n+    //! Whether this peer supports package relay\n+    bool m_packagerelay;\n+\n     CNodeState(CAddress addrIn, std::string addrNameIn, bool is_inbound, bool is_manual) :\n         address(addrIn), name(std::move(addrNameIn)), m_is_inbound(is_inbound),\n         m_is_manual_connection (is_manual)\n@@ -455,6 +458,7 @@ struct CNodeState {\n         m_chain_sync = { 0, nullptr, false, false };\n         m_last_block_announcement = 0;\n         m_recently_announced_invs.reset();\n+        m_packagerelay = false;\n     }\n };\n "
      }
    ]
  },
  {
    "sha": "d9a5ce17788d58fbeff1da5de9c07db39385a849",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkOWE1Y2UxNzc4OGQ1OGZiZWZmMWRhNWRlOWMwN2RiMzkzODVhODQ5",
    "commit": {
      "author": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-07-24T17:27:55Z"
      },
      "committer": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-07-27T22:02:51Z"
      },
      "message": "Add a new inv type MSG_PACKAGE\n\nThe hash being referenced is a package_id.",
      "tree": {
        "sha": "8567dc1ba613ae46aedda96da60f93b94c2287c0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8567dc1ba613ae46aedda96da60f93b94c2287c0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d9a5ce17788d58fbeff1da5de9c07db39385a849",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d9a5ce17788d58fbeff1da5de9c07db39385a849",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d9a5ce17788d58fbeff1da5de9c07db39385a849",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d9a5ce17788d58fbeff1da5de9c07db39385a849/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "11efd4662f400cfd637c6a909c472d9e093c4a92",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/11efd4662f400cfd637c6a909c472d9e093c4a92",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/11efd4662f400cfd637c6a909c472d9e093c4a92"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 4,
      "deletions": 1
    },
    "files": [
      {
        "sha": "9824ddc9aefd468d83cf3d86ca2df3690432405e",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d9a5ce17788d58fbeff1da5de9c07db39385a849/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d9a5ce17788d58fbeff1da5de9c07db39385a849/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=d9a5ce17788d58fbeff1da5de9c07db39385a849",
        "patch": "@@ -1435,6 +1435,7 @@ bool static AlreadyHave(const CInv& inv, const CTxMemPool& mempool) EXCLUSIVE_LO\n     case MSG_TX:\n     case MSG_WITNESS_TX:\n     case MSG_WTX:\n+    case MSG_PACKAGE:\n         {\n             assert(recentRejects);\n             if (::ChainActive().Tip()->GetBlockHash() != hashRecentRejectsChainTip)\n@@ -1723,7 +1724,7 @@ void static ProcessGetData(CNode& pfrom, const CChainParams& chainparams, CConnm\n     // Process as many TX items from the front of the getdata queue as\n     // possible, since they're common and it's efficient to batch process\n     // them.\n-    while (it != pfrom.vRecvGetData.end() && (it->type == MSG_TX || it->type == MSG_WITNESS_TX || it->type == MSG_WTX)) {\n+    while (it != pfrom.vRecvGetData.end() && (it->type == MSG_TX || it->type == MSG_WITNESS_TX || it->type == MSG_WTX || it->type == MSG_PACKAGE)) {\n         if (interruptMsgProc) return;\n         // The send buffer provides backpressure. If there's no space in\n         // the buffer, pause processing until the next call."
      },
      {
        "sha": "ef933c56828ad4f782d12e8d5ee7c1238392dc8b",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d9a5ce17788d58fbeff1da5de9c07db39385a849/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d9a5ce17788d58fbeff1da5de9c07db39385a849/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=d9a5ce17788d58fbeff1da5de9c07db39385a849",
        "patch": "@@ -184,6 +184,7 @@ std::string CInv::GetCommand() const\n     // WTX is not a message type, just an inv type\n     case MSG_WTX:            return cmd.append(\"wtx\");\n     case MSG_BLOCK:          return cmd.append(NetMsgType::BLOCK);\n+    case MSG_PACKAGE:        return cmd.append(NetMsgType::PACKAGE);\n     case MSG_FILTERED_BLOCK: return cmd.append(NetMsgType::MERKLEBLOCK);\n     case MSG_CMPCT_BLOCK:    return cmd.append(NetMsgType::CMPCTBLOCK);\n     default:"
      },
      {
        "sha": "90f5fd5ee4833798d03787580c43251147e914eb",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d9a5ce17788d58fbeff1da5de9c07db39385a849/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d9a5ce17788d58fbeff1da5de9c07db39385a849/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=d9a5ce17788d58fbeff1da5de9c07db39385a849",
        "patch": "@@ -418,6 +418,7 @@ enum GetDataMsg : uint32_t {\n     MSG_BLOCK = 2,\n     MSG_WTX = 5,                                      //!< Defined in BIP 339\n     // The following can only occur in getdata. Invs always use TX/WTX or BLOCK.\n+    MSG_PACKAGE = 6,                                  //!< Defined in XXX\n     MSG_FILTERED_BLOCK = 3,                           //!< Defined in BIP37\n     MSG_CMPCT_BLOCK = 4,                              //!< Defined in BIP152\n     MSG_WITNESS_BLOCK = MSG_BLOCK | MSG_WITNESS_FLAG, //!< Defined in BIP144"
      }
    ]
  },
  {
    "sha": "e13889242b2a2ea362333a2f3cb30c52c60559e0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMTM4ODkyNDJiMmEyZWEzNjIzMzNhMmYzY2IzMGM1MmM2MDU1OWUw",
    "commit": {
      "author": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-07-10T01:20:45Z"
      },
      "committer": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-07-27T22:02:51Z"
      },
      "message": "Integrate package-relay announcement\n\nAt INV sending, announce packages unknown to the processed downstream\npeer. Any transaction part of a mapped package, won't be announced\nredundantly.",
      "tree": {
        "sha": "4123d352cf314355c53696621e9b336d036c760c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4123d352cf314355c53696621e9b336d036c760c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e13889242b2a2ea362333a2f3cb30c52c60559e0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e13889242b2a2ea362333a2f3cb30c52c60559e0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e13889242b2a2ea362333a2f3cb30c52c60559e0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e13889242b2a2ea362333a2f3cb30c52c60559e0/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "d9a5ce17788d58fbeff1da5de9c07db39385a849",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d9a5ce17788d58fbeff1da5de9c07db39385a849",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d9a5ce17788d58fbeff1da5de9c07db39385a849"
      }
    ],
    "stats": {
      "total": 22,
      "additions": 22,
      "deletions": 0
    },
    "files": [
      {
        "sha": "d40d2d62307625ecdb2a76ecde75dc8df05abbf3",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e13889242b2a2ea362333a2f3cb30c52c60559e0/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e13889242b2a2ea362333a2f3cb30c52c60559e0/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=e13889242b2a2ea362333a2f3cb30c52c60559e0",
        "patch": "@@ -16,6 +16,7 @@\n #include <merkleblock.h>\n #include <netbase.h>\n #include <netmessagemaker.h>\n+#include <packagecache.h>\n #include <policy/fees.h>\n #include <policy/policy.h>\n #include <primitives/block.h>\n@@ -465,6 +466,8 @@ struct CNodeState {\n // Keeps track of the time (in microseconds) when transactions were requested last time\n limitedmap<uint256, std::chrono::microseconds> g_already_asked_for GUARDED_BY(cs_main)(MAX_INV_SZ);\n \n+static PackageCache g_packagecache GUARDED_BY(cs_main);\n+\n /** Map maintaining per-node state. */\n static std::map<NodeId, CNodeState> mapNodeState GUARDED_BY(cs_main);\n \n@@ -4357,6 +4360,12 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                         if (pto->m_tx_relay->filterInventoryKnown.contains(hash)) {\n                             continue;\n                         }\n+\n+                        // Walk away if this hash is going to be announced as part of a package.\n+                        if (state.m_packagerelay && g_packagecache.HasPackage(hash)) {\n+                            continue;\n+                        }\n+\n                         // Not in the mempool anymore? don't bother sending it.\n                         auto txinfo = m_mempool.info(hash, state.m_wtxid_relay);\n                         if (!txinfo.tx) {\n@@ -4405,6 +4414,19 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                             pto->m_tx_relay->filterInventoryKnown.insert(txid);\n                         }\n                     }\n+\n+                    // If peer signals tx-relay _and_ package relay, announce package it\n+                    if (state.m_packagerelay) {\n+                        std::vector<uint256> package_ids;\n+                        g_packagecache.GetAnnouncable(pto->GetId(), package_ids);\n+                        for (const uint256& hash : package_ids) {\n+                            vInv.push_back(CInv(MSG_PACKAGE, hash));\n+                            if (vInv.size() == MAX_INV_SZ) {\n+                                connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n+                                vInv.clear();\n+                            }\n+                        }\n+                    }\n                 }\n             }\n         }"
      }
    ]
  },
  {
    "sha": "13955ea38618449c6bb522303a02fb3492e933b0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMzk1NWVhMzg2MTg0NDljNmJiNTIyMzAzYTAyZmIzNDkyZTkzM2Iw",
    "commit": {
      "author": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-07-10T15:05:32Z"
      },
      "committer": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-07-27T22:02:51Z"
      },
      "message": "Introduce package-relay getdata reply\n\nDisallow getdata reply if this peer isn't assumed to have been\nannounced this package yet.",
      "tree": {
        "sha": "23f9a6736560112ce32049f6704bc79b7c7588be",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/23f9a6736560112ce32049f6704bc79b7c7588be"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/13955ea38618449c6bb522303a02fb3492e933b0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/13955ea38618449c6bb522303a02fb3492e933b0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/13955ea38618449c6bb522303a02fb3492e933b0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/13955ea38618449c6bb522303a02fb3492e933b0/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "e13889242b2a2ea362333a2f3cb30c52c60559e0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e13889242b2a2ea362333a2f3cb30c52c60559e0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e13889242b2a2ea362333a2f3cb30c52c60559e0"
      }
    ],
    "stats": {
      "total": 27,
      "additions": 27,
      "deletions": 0
    },
    "files": [
      {
        "sha": "eb635a9f8787b4443ca283330cf2730e53b41358",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/13955ea38618449c6bb522303a02fb3492e933b0/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/13955ea38618449c6bb522303a02fb3492e933b0/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=13955ea38618449c6bb522303a02fb3492e933b0",
        "patch": "@@ -1711,6 +1711,25 @@ CTransactionRef static FindTxForGetData(const CNode& peer, const uint256& txid_o\n     return {};\n }\n \n+//! Determine whether or not a peer can request a package and assemble it (or nullptr if failure or not allowed)\n+static void FindPackageForGetData(CNode& peer, const uint256 package_id, std::vector<CTransactionRef>& package_txn) LOCKS_EXCLUDED(cs_main)\n+{\n+    std::vector<uint256> package_wtxids;\n+    {\n+        LOCK(cs_main);\n+        if (!State(peer.GetId())->m_packagerelay) return;\n+\n+        g_packagecache.GetPackageWtxids(peer.GetId(), package_id, package_wtxids);\n+    }\n+\n+    for (auto& hash : package_wtxids) {\n+        auto txinfo = mempool.info(hash);\n+        if (txinfo.tx) {\n+            package_txn.emplace_back(txinfo.tx);\n+        }\n+    }\n+}\n+\n void static ProcessGetData(CNode& pfrom, const CChainParams& chainparams, CConnman& connman, CTxMemPool& mempool, const std::atomic<bool>& interruptMsgProc) LOCKS_EXCLUDED(cs_main)\n {\n     AssertLockNotHeld(cs_main);\n@@ -1740,6 +1759,14 @@ void static ProcessGetData(CNode& pfrom, const CChainParams& chainparams, CConnm\n             continue;\n         }\n \n+        std::vector<CTransactionRef> package_txn;\n+        FindPackageForGetData(pfrom, inv.hash, package_txn);\n+        if (!package_txn.empty()) {\n+            CPackageRelay package(std::move(package_txn));\n+            connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::PACKAGE, package));\n+            continue;\n+        }\n+\n         CTransactionRef tx = FindTxForGetData(pfrom, inv.hash, inv.type == MSG_WTX, mempool_req, now);\n         if (tx) {\n             // WTX and WITNESS_TX imply we serialize with witness"
      }
    ]
  },
  {
    "sha": "ace58efc3c298cd737f66d7f6fc70bc8bae51db9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphY2U1OGVmYzNjMjk4Y2Q3MzdmNjZkN2Y2ZmM3MGJjOGJhZTUxZGI5",
    "commit": {
      "author": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-07-27T21:56:31Z"
      },
      "committer": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-07-27T22:02:51Z"
      },
      "message": "Add RelayPackage",
      "tree": {
        "sha": "353de96b6611cad52cda06848a42de7bfb533b57",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/353de96b6611cad52cda06848a42de7bfb533b57"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ace58efc3c298cd737f66d7f6fc70bc8bae51db9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ace58efc3c298cd737f66d7f6fc70bc8bae51db9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ace58efc3c298cd737f66d7f6fc70bc8bae51db9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ace58efc3c298cd737f66d7f6fc70bc8bae51db9/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "13955ea38618449c6bb522303a02fb3492e933b0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/13955ea38618449c6bb522303a02fb3492e933b0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/13955ea38618449c6bb522303a02fb3492e933b0"
      }
    ],
    "stats": {
      "total": 21,
      "additions": 21,
      "deletions": 0
    },
    "files": [
      {
        "sha": "f84c96d12e50b0c80ca04bda9c8304bf2fe19220",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ace58efc3c298cd737f66d7f6fc70bc8bae51db9/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ace58efc3c298cd737f66d7f6fc70bc8bae51db9/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=ace58efc3c298cd737f66d7f6fc70bc8bae51db9",
        "patch": "@@ -1490,6 +1490,24 @@ void RelayTransaction(const uint256& txid, const uint256& wtxid, const CConnman&\n     });\n }\n \n+void RelayPackage(uint64_t downstream_peer, const std::list<CTransactionRef>& package)\n+{\n+    uint256 package_id;\n+    CSHA256 hasher;\n+    std::vector<uint256> package_wtxids;\n+    for (const CTransactionRef& ptx: package) {\n+        hasher.Write(ptx->GetHash().begin(), ptx->GetHash().size());\n+        package_wtxids.push_back(ptx->GetHash());\n+    }\n+    hasher.Finalize(package_id.begin());\n+    const auto current_time = GetTime<std::chrono::microseconds>();\n+    {\n+        //XXX: own lock\n+        LOCK(cs_main);\n+        g_packagecache.ReceivedPackage(downstream_peer, package_id, package_wtxids, current_time);\n+    }\n+}\n+\n static void RelayAddress(const CAddress& addr, bool fReachable, const CConnman& connman)\n {\n     unsigned int nRelayNodes = fReachable ? 2 : 1; // limited relaying of addresses outside our network(s)"
      },
      {
        "sha": "fc5a2676f5e7e981be3eb69186525ebab2fe8cb5",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ace58efc3c298cd737f66d7f6fc70bc8bae51db9/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ace58efc3c298cd737f66d7f6fc70bc8bae51db9/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=ace58efc3c298cd737f66d7f6fc70bc8bae51db9",
        "patch": "@@ -102,4 +102,7 @@ bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats);\n /** Relay transaction to every node */\n void RelayTransaction(const uint256& txid, const uint256& wtxid, const CConnman& connman) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n+/** Schedule package relay globally */\n+void RelayPackage(uint64_t downstream_peer, const std::list<CTransactionRef>& package);\n+\n #endif // BITCOIN_NET_PROCESSING_H"
      }
    ]
  },
  {
    "sha": "2f0e359f16c0cbe9b7707f0d2e43ea66c138422c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyZjBlMzU5ZjE2YzBjYmU5Yjc3MDdmMGQyZTQzZWE2NmMxMzg0MjJj",
    "commit": {
      "author": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-07-06T01:43:13Z"
      },
      "committer": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-07-27T22:02:51Z"
      },
      "message": "Introduce package processing by receiver",
      "tree": {
        "sha": "9c1ea015ef60e1468ee0bcb3e5a9b10f20325429",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9c1ea015ef60e1468ee0bcb3e5a9b10f20325429"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2f0e359f16c0cbe9b7707f0d2e43ea66c138422c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2f0e359f16c0cbe9b7707f0d2e43ea66c138422c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2f0e359f16c0cbe9b7707f0d2e43ea66c138422c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2f0e359f16c0cbe9b7707f0d2e43ea66c138422c/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "ace58efc3c298cd737f66d7f6fc70bc8bae51db9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ace58efc3c298cd737f66d7f6fc70bc8bae51db9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ace58efc3c298cd737f66d7f6fc70bc8bae51db9"
      }
    ],
    "stats": {
      "total": 85,
      "additions": 85,
      "deletions": 0
    },
    "files": [
      {
        "sha": "9800e3bececf65e63faadc89ab922e5fd7f5491a",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 85,
        "deletions": 0,
        "changes": 85,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f0e359f16c0cbe9b7707f0d2e43ea66c138422c/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f0e359f16c0cbe9b7707f0d2e43ea66c138422c/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=2f0e359f16c0cbe9b7707f0d2e43ea66c138422c",
        "patch": "@@ -2335,6 +2335,87 @@ static void ProcessGetCFCheckPt(CNode& pfrom, CDataStream& vRecv, const CChainPa\n     connman.PushMessage(&pfrom, std::move(msg));\n }\n \n+static void ProcessPackage(CNode& pfrom, CDataStream& vRecv, CConnman& connman)\n+{\n+    {\n+        LOCK(cs_main);\n+        if ((!g_relay_txes && !pfrom.HasPermission(PF_RELAY)) || (pfrom.m_tx_relay == nullptr)  || !State(pfrom.GetId())->m_packagerelay)\n+        {\n+            LogPrint(BCLog::NET, \"package sent in violation of protocol peer=%d\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+    }\n+\n+    CPackageRelay package;\n+    vRecv >> package;\n+\n+    uint256 package_id;\n+    CSHA256 hasher;\n+    std::vector<uint256> package_txids;\n+    for (const CTransactionRef& ptx: package.package_txn) {\n+        hasher.Write(ptx->GetHash().begin(), ptx->GetHash().size());\n+        package_txids.push_back(ptx->GetHash());\n+    }\n+    hasher.Finalize(package_id.begin());\n+\n+    CInv inv(MSG_PACKAGE, package_id);\n+\n+    LOCK2(cs_main, g_cs_orphans);\n+\n+    g_packagecache.AddPackageKnown(pfrom.GetId(), package_id);\n+\n+    TxValidationState package_state;\n+\n+    CNodeState *nodestate = State(pfrom.GetId());\n+    nodestate->m_tx_download.m_tx_announced.erase(inv.hash);\n+    nodestate->m_tx_download.m_tx_in_flight.erase(inv.hash);\n+    EraseTxRequest(inv.hash);\n+\n+    std::list<CTransactionRef> lRemovedTxn;\n+    std::list<CTransactionRef> tx_list;\n+\n+    std::copy(package.package_txn.begin(), package.package_txn.end(), std::back_inserter(tx_list));\n+    if (!AlreadyHave(inv, mempool) &&\n+        AcceptPackageToMemoryPool(mempool, package_state, tx_list,\n+            &lRemovedTxn, 0 /* nAbsurdFee */, false /* test_accept */)) {\n+        mempool.check(&::ChainstateActive().CoinsTip());\n+        RelayPackage(pfrom.GetId(), tx_list);\n+\n+        pfrom.nLastTXTime = GetTime();\n+\n+    } else {\n+        assert(recentRejects);\n+        recentRejects->insert(package_id);\n+        for (const CTransactionRef& ptx: package.package_txn) {\n+            if (RecursiveDynamicUsage(*ptx) < 100000) {\n+                AddToCompactExtraTransactions(ptx);\n+            }\n+        }\n+\n+        if (pfrom.HasPermission(PF_FORCERELAY)) {\n+            bool package_in_mempool = true;\n+            for (const CTransactionRef& ptx: package.package_txn) {\n+                if (!mempool.exists(ptx->GetHash())) {\n+                    package_in_mempool = false;\n+                }\n+            }\n+            if (!package_in_mempool) {\n+                RelayPackage(pfrom.GetId(), tx_list);\n+            }\n+        }\n+    }\n+\n+    for (const CTransactionRef& removedTx: lRemovedTxn)\n+        AddToCompactExtraTransactions(removedTx);\n+\n+    if (package_state.IsInvalid()) {\n+        MaybePunishNodeForTx(pfrom.GetId(), package_state);\n+    }\n+\n+    return;\n+}\n+\n void ProcessMessage(\n     CNode& pfrom,\n     const std::string& msg_type,\n@@ -3569,6 +3650,10 @@ void ProcessMessage(\n         return;\n     }\n \n+    if (msg_type == NetMsgType::PACKAGE) {\n+        ProcessPackage(pfrom, vRecv, connman);\n+    }\n+\n     if (msg_type == NetMsgType::PING) {\n         if (pfrom.nVersion > BIP0031_VERSION)\n         {"
      }
    ]
  },
  {
    "sha": "657588cf111ceaf907cbbfff09a50c3f921bf2de",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NTc1ODhjZjExMWNlYWY5MDdjYmJmZmYwOWE1MGMzZjkyMWJmMmRl",
    "commit": {
      "author": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-07-10T17:24:54Z"
      },
      "committer": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-07-27T22:03:00Z"
      },
      "message": "Add p2p message sendpackage\n\nXXX: add byte flag to signal package policy enforced",
      "tree": {
        "sha": "b6de92f94d93871667e6ccc77994d43fdc6e0992",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b6de92f94d93871667e6ccc77994d43fdc6e0992"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/657588cf111ceaf907cbbfff09a50c3f921bf2de",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/657588cf111ceaf907cbbfff09a50c3f921bf2de",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/657588cf111ceaf907cbbfff09a50c3f921bf2de",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/657588cf111ceaf907cbbfff09a50c3f921bf2de/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "2f0e359f16c0cbe9b7707f0d2e43ea66c138422c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2f0e359f16c0cbe9b7707f0d2e43ea66c138422c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2f0e359f16c0cbe9b7707f0d2e43ea66c138422c"
      }
    ],
    "stats": {
      "total": 24,
      "additions": 23,
      "deletions": 1
    },
    "files": [
      {
        "sha": "340dca2b28c8c2201a2f4017bf0b9c274f25e886",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/657588cf111ceaf907cbbfff09a50c3f921bf2de/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/657588cf111ceaf907cbbfff09a50c3f921bf2de/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=657588cf111ceaf907cbbfff09a50c3f921bf2de",
        "patch": "@@ -2511,6 +2511,10 @@ void ProcessMessage(\n             connman.PushMessage(&pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::WTXIDRELAY));\n         }\n \n+        if (nVersion >= PACKAGE_RELAY_VERSION) {\n+            connman.PushMessage(&pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::SENDPACKAGE));\n+        }\n+\n         connman.PushMessage(&pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERACK));\n \n         pfrom.nServices = nServices;\n@@ -2666,6 +2670,14 @@ void ProcessMessage(\n         return;\n     }\n \n+    if (msg_type == NetMsgType::SENDPACKAGE) {\n+        if (pfrom.nVersion >= PACKAGE_RELAY_VERSION) {\n+            LOCK(cs_main);\n+            State(pfrom.GetId())->m_packagerelay = true;\n+        }\n+        return;\n+    }\n+\n     if (!pfrom.fSuccessfullyConnected) {\n         // Must have a verack message before anything else\n         LOCK(cs_main);"
      },
      {
        "sha": "4907588668b46b1b6fd52d1a76fb6af8ac022c57",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/657588cf111ceaf907cbbfff09a50c3f921bf2de/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/657588cf111ceaf907cbbfff09a50c3f921bf2de/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=657588cf111ceaf907cbbfff09a50c3f921bf2de",
        "patch": "@@ -48,6 +48,7 @@ const char *GETCFCHECKPT=\"getcfcheckpt\";\n const char *CFCHECKPT=\"cfcheckpt\";\n const char *WTXIDRELAY=\"wtxidrelay\";\n const char *PACKAGE=\"package\";\n+const char *SENDPACKAGE=\"sendpackage\";\n } // namespace NetMsgType\n \n /** All known message types. Keep this in the same order as the list of\n@@ -87,6 +88,7 @@ const static std::string allNetMessageTypes[] = {\n     NetMsgType::CFCHECKPT,\n     NetMsgType::WTXIDRELAY,\n     NetMsgType::PACKAGE,\n+    NetMsgType::SENDPACKAGE,\n };\n const static std::vector<std::string> allNetMessageTypesVec(allNetMessageTypes, allNetMessageTypes+ARRAYLEN(allNetMessageTypes));\n "
      },
      {
        "sha": "c198617a69bac8c0e07682e7a486c696169aadef",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/657588cf111ceaf907cbbfff09a50c3f921bf2de/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/657588cf111ceaf907cbbfff09a50c3f921bf2de/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=657588cf111ceaf907cbbfff09a50c3f921bf2de",
        "patch": "@@ -276,6 +276,11 @@ extern const char* CFCHECKPT;\n  * @since protocol version 70016 as described by BIP 339.\n  */\n extern const char *WTXIDRELAY;\n+/**\n+ * Indicates that a node support package-relay\n+ * @since protocol 80002 as described by BIP XXX\n+ */\n+extern const char* SENDPACKAGE;\n }; // namespace NetMsgType\n \n /* Get a vector of all valid message types (see above) */"
      },
      {
        "sha": "6eb3a21f78059fba5ae1b757bdb62082555c32b7",
        "filename": "src/version.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/657588cf111ceaf907cbbfff09a50c3f921bf2de/src/version.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/657588cf111ceaf907cbbfff09a50c3f921bf2de/src/version.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/version.h?ref=657588cf111ceaf907cbbfff09a50c3f921bf2de",
        "patch": "@@ -9,7 +9,7 @@\n  * network protocol versioning\n  */\n \n-static const int PROTOCOL_VERSION = 70016;\n+static const int PROTOCOL_VERSION = 80002;\n \n //! initial proto version, to be increased after version/verack negotiation\n static const int INIT_PROTO_VERSION = 209;\n@@ -38,4 +38,7 @@ static const int INVALID_CB_NO_BAN_VERSION = 70015;\n //! \"wtxidrelay\" command for wtxid-based relay starts with this version\n static const int WTXID_RELAY_VERSION = 70016;\n \n+//! package-relay starts with this version\n+static const int PACKAGE_RELAY_VERSION = 80002;\n+\n #endif // BITCOIN_VERSION_H"
      }
    ]
  },
  {
    "sha": "bba7bfbe88714a2af4426430fe884fbffa9e2ea1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiYmE3YmZiZTg4NzE0YTJhZjQ0MjY0MzBmZTg4NGZiZmZhOWUyZWEx",
    "commit": {
      "author": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-07-24T17:39:34Z"
      },
      "committer": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-07-27T22:03:23Z"
      },
      "message": "Add BroadcastPackage",
      "tree": {
        "sha": "8b8bb7ae7a57a46dc8034e73f314a636d832f090",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8b8bb7ae7a57a46dc8034e73f314a636d832f090"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bba7bfbe88714a2af4426430fe884fbffa9e2ea1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bba7bfbe88714a2af4426430fe884fbffa9e2ea1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bba7bfbe88714a2af4426430fe884fbffa9e2ea1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bba7bfbe88714a2af4426430fe884fbffa9e2ea1/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "657588cf111ceaf907cbbfff09a50c3f921bf2de",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/657588cf111ceaf907cbbfff09a50c3f921bf2de",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/657588cf111ceaf907cbbfff09a50c3f921bf2de"
      }
    ],
    "stats": {
      "total": 92,
      "additions": 92,
      "deletions": 0
    },
    "files": [
      {
        "sha": "9f86d7e2f6f69fa2b2a759d9384b78b76f7d782f",
        "filename": "src/node/transaction.cpp",
        "status": "modified",
        "additions": 72,
        "deletions": 0,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bba7bfbe88714a2af4426430fe884fbffa9e2ea1/src/node/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bba7bfbe88714a2af4426430fe884fbffa9e2ea1/src/node/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/transaction.cpp?ref=bba7bfbe88714a2af4426430fe884fbffa9e2ea1",
        "patch": "@@ -88,3 +88,75 @@ TransactionError BroadcastTransaction(NodeContext& node, const CTransactionRef t\n \n     return TransactionError::OK;\n }\n+\n+\n+TransactionError BroadcastPackage(NodeContext& node, std::list<CTransactionRef>& package, std::string& err_string, bool relay, bool wait_callback)\n+{\n+    // PackageTransaction can be called by either sendpackage RPC.\n+    // node.connman is assigned both before chain clients and before RPC server is accepting calls,\n+    // and reset after chain clients and RPC sever are stopped. node.connman should never be null here.\n+    assert(node.connman);\n+    assert(node.mempool);\n+    std::promise<void> promise;\n+    bool callback_set = false;\n+\n+    { // cs_main scope\n+    LOCK(cs_main);\n+    // If one of the package transaction is already confirmed in the chain, don't do anything\n+    // and return early.\n+    CCoinsViewCache &view = ::ChainstateActive().CoinsTip();\n+    for (const CTransactionRef& ptx: package) {\n+        uint256 hashTx = ptx->GetHash();\n+        for (size_t o = 0; o < ptx->vout.size(); o++) {\n+            const Coin& existingCoin = view.AccessCoin(COutPoint(hashTx, o));\n+            // IsSpent doesn't mean the coin is spent, it means the output doesn't exist.\n+            // So if the output does exist, then this transaction exists in the chain.\n+            if (!existingCoin.IsSpent()) return TransactionError::ALREADY_IN_CHAIN;\n+        }\n+    }\n+    // If any package member is already in mempool, don't submit.\n+    TxValidationState package_state;\n+    if (!AcceptPackageToMemoryPool(*node.mempool, package_state, package,\n+            nullptr /* plTxnReplaced */, 0 /* nAbsurdFee */, false /* test_accept */)) {\n+        err_string = package_state.ToString();\n+        if (package_state.IsInvalid()) {\n+            if (package_state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n+                return TransactionError::MISSING_INPUTS;\n+            }\n+            return TransactionError::MEMPOOL_REJECTED;\n+        } else {\n+            return TransactionError::MEMPOOL_ERROR;\n+        }\n+    }\n+\n+    // Transaction was accepted to the mempool.\n+\n+    if (wait_callback) {\n+        // For transactions broadcast from outside the wallet, make sure\n+        // that the wallet has been notified of the transaction before\n+        // continuing.\n+        //\n+        // This prevents a race where a user might call sendrawtransaction\n+        // with a transaction to/from their wallet, immediately call some\n+        // wallet RPC, and get a stale result because callbacks have not\n+        // yet been processed.\n+        CallFunctionInValidationInterfaceQueue([&promise] {\n+            promise.set_value();\n+        });\n+        callback_set = true;\n+    }\n+\n+    } // cs_main\n+\n+    if (callback_set) {\n+        // Wait until Validation Interface clients have been notified of the\n+        // transaction entering the mempool.\n+        promise.get_future().wait();\n+    }\n+\n+    if (relay) {\n+        RelayPackage(0, package);\n+    }\n+\n+    return TransactionError::OK;\n+}"
      },
      {
        "sha": "961204884863d67c9c445968cd7c2ab8170b8699",
        "filename": "src/node/transaction.h",
        "status": "modified",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bba7bfbe88714a2af4426430fe884fbffa9e2ea1/src/node/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bba7bfbe88714a2af4426430fe884fbffa9e2ea1/src/node/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/transaction.h?ref=bba7bfbe88714a2af4426430fe884fbffa9e2ea1",
        "patch": "@@ -10,6 +10,8 @@\n #include <primitives/transaction.h>\n #include <util/error.h>\n \n+#include <list>\n+\n struct NodeContext;\n \n /** Maximum fee rate for sendrawtransaction and testmempoolaccept RPC calls.\n@@ -38,4 +40,22 @@ static const CFeeRate DEFAULT_MAX_RAW_TX_FEE_RATE{COIN / 10};\n  */\n NODISCARD TransactionError BroadcastTransaction(NodeContext& node, CTransactionRef tx, std::string& err_string, const CAmount& max_tx_fee, bool relay, bool wait_callback);\n \n+/**\n+ * Submit a package to the mempool and (optionally) relay it to all P2P peers.\n+ *\n+ * Mempool submission can be synchronous (will await mempool entry notification\n+ * over the CValidationInterface) or asynchronous (will submit and not wait for\n+ * notification), depending on the value of wait_callback. wait_callback MUST\n+ * NOT be set while cs_main, cs_mempool or cs_wallet are held to avoid\n+ * deadlock.\n+ *\n+ * @param[in]  node reference to node context\n+ * @param[in]  package the packaged transaction to broadcast\n+ * @param[out] err_string reference to std::string to fill with error string if available\n+ * @param[in]  relay flag if both mempool insertion and p2p relay are requested\n+ * @param[in]  wait_callback wait until callbacks have been processed to avoid stale result due to a sequentially RPC.\n+ * return error\n+ */\n+NODISCARD TransactionError BroadcastPackage(NodeContext& node, std::list<CTransactionRef>& package, std::string& err_string, bool relay, bool wait_callback);\n+\n #endif // BITCOIN_NODE_TRANSACTION_H"
      }
    ]
  },
  {
    "sha": "b3abd2fb0bc97617eb12fe0bbf2a739a897056df",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiM2FiZDJmYjBiYzk3NjE3ZWIxMmZlMGJiZjJhNzM5YTg5NzA1NmRm",
    "commit": {
      "author": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-07-07T16:05:40Z"
      },
      "committer": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-07-27T22:03:23Z"
      },
      "message": "Add sendpackage RPC command\n\nThis command let caller submit a bundle of transactions to the local\nmempool and p2p network, ensuring their summed feerate is going to be evaluated\nas a package.",
      "tree": {
        "sha": "73221ea39b553201fc181c251ffff82f066f4a28",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/73221ea39b553201fc181c251ffff82f066f4a28"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b3abd2fb0bc97617eb12fe0bbf2a739a897056df",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b3abd2fb0bc97617eb12fe0bbf2a739a897056df",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b3abd2fb0bc97617eb12fe0bbf2a739a897056df",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b3abd2fb0bc97617eb12fe0bbf2a739a897056df/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "bba7bfbe88714a2af4426430fe884fbffa9e2ea1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bba7bfbe88714a2af4426430fe884fbffa9e2ea1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bba7bfbe88714a2af4426430fe884fbffa9e2ea1"
      }
    ],
    "stats": {
      "total": 57,
      "additions": 57,
      "deletions": 0
    },
    "files": [
      {
        "sha": "0fcf8bc2ab1b2461ea5e47ea81da2ece1f3388e5",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b3abd2fb0bc97617eb12fe0bbf2a739a897056df/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b3abd2fb0bc97617eb12fe0bbf2a739a897056df/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=b3abd2fb0bc97617eb12fe0bbf2a739a897056df",
        "patch": "@@ -99,6 +99,7 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"signrawtransactionwithkey\", 2, \"prevtxs\" },\n     { \"signrawtransactionwithwallet\", 1, \"prevtxs\" },\n     { \"sendrawtransaction\", 1, \"maxfeerate\" },\n+    { \"sendpackage\", 1, \"rawtxs\" },\n     { \"testmempoolaccept\", 0, \"rawtxs\" },\n     { \"testmempoolaccept\", 1, \"maxfeerate\" },\n     { \"combinerawtransaction\", 0, \"txs\" },"
      },
      {
        "sha": "9d2ec019ad26b86445001d6e2e833454b4982a49",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 56,
        "deletions": 0,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b3abd2fb0bc97617eb12fe0bbf2a739a897056df/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b3abd2fb0bc97617eb12fe0bbf2a739a897056df/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=b3abd2fb0bc97617eb12fe0bbf2a739a897056df",
        "patch": "@@ -848,6 +848,61 @@ static UniValue sendrawtransaction(const JSONRPCRequest& request)\n     return tx->GetHash().GetHex();\n }\n \n+static UniValue sendpackage(const JSONRPCRequest& request)\n+{\n+    RPCHelpMan{\"sendpackage\",\n+                \"\\nSubmit a package (serialized, hex-encoded) to local node and network.\\n\",\n+                {\n+                    {\"rawtxs\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"An array of hex strings of raw transactions.\\n\"\n+             \"                                        Length must be two for now.\",\n+                        {\n+                            {\"rawtx\", RPCArg::Type::STR_HEX, RPCArg::Optional::OMITTED, \"\"},\n+                        },\n+                    },\n+                },\n+                RPCResult{\n+                    RPCResult::Type::STR_HEX, \"\", \"The transaction hash in hex\"\n+                },\n+                RPCExamples{\n+            \"\\nSend the package (signed hex)\\n\"\n+            + HelpExampleRpc(\"sendpackage\", \"[\\\"signedhex\\\"]\")\n+                },\n+    }.Check(request);\n+\n+    RPCTypeCheck(request.params, {\n+            UniValue::VARR\n+    });\n+\n+    if (request.params[0].get_array().size() != 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Array must contain exactly two raw transactions for now\");\n+    }\n+\n+    // parse hex string from parameter\n+    CMutableTransaction parent_mtx;\n+    if (!DecodeHexTx(parent_mtx, request.params[0].get_str()))\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"PARENT TX decode failed\");\n+    CTransactionRef parent_tx(MakeTransactionRef(std::move(parent_mtx)));\n+\n+    CMutableTransaction child_mtx;\n+    if (!DecodeHexTx(child_mtx, request.params[1].get_str()))\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"CHILD TX decode failed\");\n+    CTransactionRef child_tx(MakeTransactionRef(std::move(child_mtx)));\n+\n+    std::list<CTransactionRef> package_txn;\n+    package_txn.emplace_back(parent_tx);\n+    package_txn.emplace_back(child_tx);\n+\n+    std::string err_string;\n+    AssertLockNotHeld(cs_main);\n+    NodeContext& node = EnsureNodeContext(request.context);\n+    const TransactionError err = BroadcastPackage(node, package_txn, err_string, /*relay*/ true, /*wait_callback*/ true);\n+    if (TransactionError::OK != err) {\n+        throw JSONRPCTransactionError(err, err_string);\n+    }\n+\n+    return parent_tx->GetHash().GetHex();\n+}\n+\n static UniValue testmempoolaccept(const JSONRPCRequest& request)\n {\n     RPCHelpMan{\"testmempoolaccept\",\n@@ -1798,6 +1853,7 @@ static const CRPCCommand commands[] =\n     { \"rawtransactions\",    \"decoderawtransaction\",         &decoderawtransaction,      {\"hexstring\",\"iswitness\"} },\n     { \"rawtransactions\",    \"decodescript\",                 &decodescript,              {\"hexstring\"} },\n     { \"rawtransactions\",    \"sendrawtransaction\",           &sendrawtransaction,        {\"hexstring\",\"maxfeerate\"} },\n+    { \"rawtransactions\",    \"sendpackage\",                  &sendpackage,               {\"rawtxs\"} },\n     { \"rawtransactions\",    \"combinerawtransaction\",        &combinerawtransaction,     {\"txs\"} },\n     { \"rawtransactions\",    \"signrawtransactionwithkey\",    &signrawtransactionwithkey, {\"hexstring\",\"privkeys\",\"prevtxs\",\"sighashtype\"} },\n     { \"rawtransactions\",    \"testmempoolaccept\",            &testmempoolaccept,         {\"rawtxs\",\"maxfeerate\"} },"
      }
    ]
  },
  {
    "sha": "e62c0a6e3551d54905e57fd71778635707bd1a3a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNjJjMGE2ZTM1NTFkNTQ5MDVlNTdmZDcxNzc4NjM1NzA3YmQxYTNh",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-07-15T20:17:56Z"
      },
      "committer": {
        "name": "Antoine Riard",
        "email": "ariard@student.42.fr",
        "date": "2020-07-27T22:03:23Z"
      },
      "message": "[qa] Exercise package relay",
      "tree": {
        "sha": "f2763f8c1c8df73b26d6a1f7e540d89ac16b990f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f2763f8c1c8df73b26d6a1f7e540d89ac16b990f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e62c0a6e3551d54905e57fd71778635707bd1a3a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e62c0a6e3551d54905e57fd71778635707bd1a3a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e62c0a6e3551d54905e57fd71778635707bd1a3a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e62c0a6e3551d54905e57fd71778635707bd1a3a/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": null,
    "parents": [
      {
        "sha": "b3abd2fb0bc97617eb12fe0bbf2a739a897056df",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b3abd2fb0bc97617eb12fe0bbf2a739a897056df",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b3abd2fb0bc97617eb12fe0bbf2a739a897056df"
      }
    ],
    "stats": {
      "total": 110,
      "additions": 110,
      "deletions": 0
    },
    "files": [
      {
        "sha": "7c474d5473254875e808a9641bf9dc69beaa4e9b",
        "filename": "test/functional/feature_package_relay.py",
        "status": "added",
        "additions": 109,
        "deletions": 0,
        "changes": 109,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e62c0a6e3551d54905e57fd71778635707bd1a3a/test/functional/feature_package_relay.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e62c0a6e3551d54905e57fd71778635707bd1a3a/test/functional/feature_package_relay.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_package_relay.py?ref=e62c0a6e3551d54905e57fd71778635707bd1a3a",
        "patch": "@@ -0,0 +1,109 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test processing of two-transaction packages\"\"\"\n+\n+from io import BytesIO\n+from decimal import Decimal\n+from test_framework.messages import FromHex, CTransaction, msg_tx\n+from test_framework.mininode import P2PInterface\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import hex_str_to_bytes\n+\n+# P2PInterface is a class containing callbacks to be executed when a P2P\n+# message is received from the node-under-test. Subclass P2PInterface and\n+# override the on_*() methods if you need custom behaviour.\n+class BaseNode(P2PInterface):\n+    def __init__(self):\n+        \"\"\"Initialize the P2PInterface\n+\n+        Used to initialize custom properties for the Node that aren't\n+        included by default in the base class. Be aware that the P2PInterface\n+        base class already stores a counter for each P2P message type and the\n+        last received message of each type, which should be sufficient for the\n+        needs of most tests.\n+\n+        Call super().__init__() first for standard initialization and then\n+        initialize custom properties.\"\"\"\n+        super().__init__()\n+        # Stores a dictionary of all blocks received\n+\n+    def on_block(self, message):\n+        \"\"\"Override the standard on_block callback\n+\n+        Store the hash of a received block in the dictionary.\"\"\"\n+        message.block.calc_sha256()\n+        self.block_receive_map[message.block.sha256] += 1\n+\n+    def on_inv(self, message):\n+        \"\"\"Override the standard on_inv callback\"\"\"\n+        pass\n+\n+\n+class PackageRelay(BitcoinTestFramework):\n+    # Each functional test is a subclass of the BitcoinTestFramework class.\n+\n+    # Override the set_test_params(), skip_test_if_missing_module(), add_options(), setup_chain(), setup_network()\n+    # and setup_nodes() methods to customize the test setup as required.\n+\n+    def set_test_params(self):\n+        \"\"\"Override test parameters for your individual test.\n+\n+        This method must be overridden and num_nodes must be explicitly set.\"\"\"\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+        self.extra_args = [[], [\"-minrelaytxfee=0\", \"-mintxfee=0.00000001\"]]\n+\n+\n+    # Use skip_test_if_missing_module() to skip the test if your test requires certain modules to be present.\n+    # This test uses generate which requires wallet to be compiled\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+\n+    def run_test(self):\n+        \"\"\"Main test logic\"\"\"\n+\n+        # Create P2P connections will wait for a verack to make sure the connection is fully up\n+        self.nodes[0].add_p2p_connection(BaseNode())\n+\n+        self.nodes[1].generate(101)\n+        self.sync_all(self.nodes[0:2])\n+\n+        # On node1, generate a 0-fee transaction, and then a 2-satoshi-per-byte\n+        # transaction\n+        utxos = self.nodes[1].listunspent()\n+        assert len(utxos) == 1\n+\n+\n+        self.nodes[1].settxfee(Decimal(\"0.00000002\"))\n+        parent_txid = self.nodes[1].sendtoaddress(self.nodes[1].getnewaddress(), 1)\n+        raw_parent_tx = self.nodes[1].gettransaction(parent_txid)['hex']\n+\n+        # Deliver the 0-fee transaction it doesn't get into the mempool of node0.\n+        try:\n+            self.nodes[0].sendrawtransaction(raw_parent_tx)\n+        except:\n+            pass\n+        assert parent_txid not in self.nodes[0].getrawmempool()\n+\n+        inputs_child = []\n+        inputs_child.append({\"txid\": parent_txid, \"vout\": 0 })\n+        outputs_child = {}\n+        # Child spend parent with a 500 sat-fee\n+        outputs_child[self.nodes[1].getnewaddress()] = Decimal(\"0.99999500\")\n+        child_tx = self.nodes[1].signrawtransactionwithwallet(self.nodes[1].createrawtransaction(inputs_child, outputs_child))['hex']\n+        package_txn = [parent_tx.serialize().hex(), child_tx]\n+\n+        self.nodes[1].sendpackage(rawtxs=package_txn)\n+\n+        #XXX: wait for package\n+        time.sleep(10)\n+\n+        assert parent_txid in self.nodes[0].getrawmempool()\n+\n+\n+\n+if __name__ == '__main__':\n+    PackageRelay().main()"
      },
      {
        "sha": "265cfa56a9600968da28ffb3e3217c0575605e01",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e62c0a6e3551d54905e57fd71778635707bd1a3a/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e62c0a6e3551d54905e57fd71778635707bd1a3a/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=e62c0a6e3551d54905e57fd71778635707bd1a3a",
        "patch": "@@ -160,6 +160,7 @@\n     'wallet_disable.py',\n     'p2p_addr_relay.py',\n     'p2p_getdata.py',\n+    'feature_package_relay.py',\n     'rpc_net.py',\n     'wallet_keypool.py',\n     'wallet_keypool.py --descriptors',"
      }
    ]
  }
]