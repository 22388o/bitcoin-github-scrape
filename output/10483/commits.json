[
  {
    "sha": "90d4d89230434493c3b1e9174abed2609ba74cf1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MGQ0ZDg5MjMwNDM0NDkzYzNiMWU5MTc0YWJlZDI2MDliYTc0Y2Yx",
    "commit": {
      "author": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2017-08-07T05:36:37Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2017-08-07T05:36:37Z"
      },
      "message": "scripted-diff: Use the C++11 keyword nullptr to denote the pointer literal instead of the macro NULL\n\n-BEGIN VERIFY SCRIPT-\nsed -i 's/\\<NULL\\>/nullptr/g' src/*.cpp src/*.h src/*/*.cpp src/*/*.h src/qt/*/*.cpp src/qt/*/*.h src/wallet/*/*.cpp src/wallet/*/*.h src/support/allocators/*.h\nsed -i 's/Prefer nullptr, otherwise SAFECOOKIE./Prefer NULL, otherwise SAFECOOKIE./g' src/torcontrol.cpp\nsed -i 's/tor: Using nullptr authentication/tor: Using NULL authentication/g' src/torcontrol.cpp\nsed -i 's/METHODS=nullptr/METHODS=NULL/g' src/test/torcontrol_tests.cpp src/torcontrol.cpp\nsed -i 's/nullptr certificates/NULL certificates/g' src/qt/paymentserver.cpp\nsed -i 's/\"nullptr\"/\"NULL\"/g' src/torcontrol.cpp src/test/torcontrol_tests.cpp\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "511237508ac27f66846c0aa9405658b835c9ae43",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/511237508ac27f66846c0aa9405658b835c9ae43"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/90d4d89230434493c3b1e9174abed2609ba74cf1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/90d4d89230434493c3b1e9174abed2609ba74cf1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/90d4d89230434493c3b1e9174abed2609ba74cf1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/90d4d89230434493c3b1e9174abed2609ba74cf1/comments",
    "author": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a9dd11144152bf40fa797cc0b0c8857c03d3ad6a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a9dd11144152bf40fa797cc0b0c8857c03d3ad6a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a9dd11144152bf40fa797cc0b0c8857c03d3ad6a"
      }
    ],
    "stats": {
      "total": 1126,
      "additions": 563,
      "deletions": 563
    },
    "files": [
      {
        "sha": "a56bb4f9c1c75136f25f7e0f5b064a81f7ead431",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -69,13 +69,13 @@ CAddrInfo* CAddrMan::Find(const CNetAddr& addr, int* pnId)\n {\n     std::map<CNetAddr, int>::iterator it = mapAddr.find(addr);\n     if (it == mapAddr.end())\n-        return NULL;\n+        return nullptr;\n     if (pnId)\n         *pnId = (*it).second;\n     std::map<int, CAddrInfo>::iterator it2 = mapInfo.find((*it).second);\n     if (it2 != mapInfo.end())\n         return &(*it2).second;\n-    return NULL;\n+    return nullptr;\n }\n \n CAddrInfo* CAddrMan::Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId)"
      },
      {
        "sha": "547088aedf4f35f8b833426fccb43b1253e8e98c",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -220,11 +220,11 @@ class CAddrMan\n     FastRandomContext insecure_rand;\n \n     //! Find an entry.\n-    CAddrInfo* Find(const CNetAddr& addr, int *pnId = NULL);\n+    CAddrInfo* Find(const CNetAddr& addr, int *pnId = nullptr);\n \n     //! find an entry, creating it if necessary.\n     //! nTime and nServices of the found node are updated, if necessary.\n-    CAddrInfo* Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId = NULL);\n+    CAddrInfo* Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId = nullptr);\n \n     //! Swap two elements in vRandom.\n     void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2);"
      },
      {
        "sha": "6223e4afeb782788aa5086ba5a6ef2ced34789ec",
        "filename": "src/arith_uint256.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/arith_uint256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/arith_uint256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/arith_uint256.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -283,7 +283,7 @@ class arith_uint256 : public base_uint<256> {\n      * complexities of the sign bit and using base 256 are probably an\n      * implementation accident.\n      */\n-    arith_uint256& SetCompact(uint32_t nCompact, bool *pfNegative = NULL, bool *pfOverflow = NULL);\n+    arith_uint256& SetCompact(uint32_t nCompact, bool *pfNegative = nullptr, bool *pfOverflow = nullptr);\n     uint32_t GetCompact(bool fNegative = false) const;\n \n     friend uint256 ArithToUint256(const arith_uint256 &);"
      },
      {
        "sha": "c70e358ebb355f2d7c48d5c70a249ac0af18b1fe",
        "filename": "src/base58.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/base58.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/base58.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -37,7 +37,7 @@ bool DecodeBase58(const char* psz, std::vector<unsigned char>& vch)\n     while (*psz && !isspace(*psz)) {\n         // Decode base58 character\n         const char* ch = strchr(pszBase58, *psz);\n-        if (ch == NULL)\n+        if (ch == nullptr)\n             return false;\n         // Apply \"b256 = b256 * 58 + ch\".\n         int carry = ch - pszBase58;"
      },
      {
        "sha": "db12208f74f4acce2588f70a4203d2e7870803b5",
        "filename": "src/base58.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/base58.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/base58.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -26,7 +26,7 @@\n \n /**\n  * Encode a byte sequence as a base58-encoded string.\n- * pbegin and pend cannot be NULL, unless both are.\n+ * pbegin and pend cannot be nullptr, unless both are.\n  */\n std::string EncodeBase58(const unsigned char* pbegin, const unsigned char* pend);\n \n@@ -38,7 +38,7 @@ std::string EncodeBase58(const std::vector<unsigned char>& vch);\n /**\n  * Decode a base58-encoded string (psz) into a byte vector (vchRet).\n  * return true if decoding is successful.\n- * psz cannot be NULL.\n+ * psz cannot be nullptr.\n  */\n bool DecodeBase58(const char* psz, std::vector<unsigned char>& vchRet);\n "
      },
      {
        "sha": "ac14444eef17f5a7aea21462c153a8314900c1ef",
        "filename": "src/bench/bench.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/bench/bench.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/bench/bench.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -17,7 +17,7 @@ benchmark::BenchRunner::BenchmarkMap &benchmark::BenchRunner::benchmarks() {\n \n static double gettimedouble(void) {\n     struct timeval tv;\n-    gettimeofday(&tv, NULL);\n+    gettimeofday(&tv, nullptr);\n     return tv.tv_usec * 0.000001 + tv.tv_sec;\n }\n "
      },
      {
        "sha": "0b74f31bfefdcb55b1cb3b2826310f42a2fcf6a7",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -161,8 +161,8 @@ static void http_request_done(struct evhttp_request *req, void *ctx)\n {\n     HTTPReply *reply = static_cast<HTTPReply*>(ctx);\n \n-    if (req == NULL) {\n-        /* If req is NULL, it means an error occurred while connecting: the\n+    if (req == nullptr) {\n+        /* If req is nullptr, it means an error occurred while connecting: the\n          * error code will have been passed to http_error_cb.\n          */\n         reply->status = 0;\n@@ -210,7 +210,7 @@ UniValue CallRPC(const std::string& strMethod, const UniValue& params)\n \n     HTTPReply response;\n     raii_evhttp_request req = obtain_evhttp_request(http_request_done, (void*)&response);\n-    if (req == NULL)\n+    if (req == nullptr)\n         throw std::runtime_error(\"create http request failed\");\n #if LIBEVENT_VERSION_NUMBER >= 0x02010300\n     evhttp_request_set_error_cb(req.get(), http_error_cb);\n@@ -370,7 +370,7 @@ int CommandLineRPC(int argc, char *argv[])\n         nRet = EXIT_FAILURE;\n     }\n     catch (...) {\n-        PrintExceptionContinue(NULL, \"CommandLineRPC()\");\n+        PrintExceptionContinue(nullptr, \"CommandLineRPC()\");\n         throw;\n     }\n \n@@ -397,7 +397,7 @@ int main(int argc, char* argv[])\n         PrintExceptionContinue(&e, \"AppInitRPC()\");\n         return EXIT_FAILURE;\n     } catch (...) {\n-        PrintExceptionContinue(NULL, \"AppInitRPC()\");\n+        PrintExceptionContinue(nullptr, \"AppInitRPC()\");\n         return EXIT_FAILURE;\n     }\n \n@@ -408,7 +408,7 @@ int main(int argc, char* argv[])\n     catch (const std::exception& e) {\n         PrintExceptionContinue(&e, \"CommandLineRPC()\");\n     } catch (...) {\n-        PrintExceptionContinue(NULL, \"CommandLineRPC()\");\n+        PrintExceptionContinue(nullptr, \"CommandLineRPC()\");\n     }\n     return ret;\n }"
      },
      {
        "sha": "e5ea9f32280d9c180566b4544d2c64f88adab094",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -822,7 +822,7 @@ static int CommandLineRawTx(int argc, char* argv[])\n         nRet = EXIT_FAILURE;\n     }\n     catch (...) {\n-        PrintExceptionContinue(NULL, \"CommandLineRawTx()\");\n+        PrintExceptionContinue(nullptr, \"CommandLineRawTx()\");\n         throw;\n     }\n \n@@ -845,7 +845,7 @@ int main(int argc, char* argv[])\n         PrintExceptionContinue(&e, \"AppInitRawTx()\");\n         return EXIT_FAILURE;\n     } catch (...) {\n-        PrintExceptionContinue(NULL, \"AppInitRawTx()\");\n+        PrintExceptionContinue(nullptr, \"AppInitRawTx()\");\n         return EXIT_FAILURE;\n     }\n \n@@ -856,7 +856,7 @@ int main(int argc, char* argv[])\n     catch (const std::exception& e) {\n         PrintExceptionContinue(&e, \"CommandLineRawTx()\");\n     } catch (...) {\n-        PrintExceptionContinue(NULL, \"CommandLineRawTx()\");\n+        PrintExceptionContinue(nullptr, \"CommandLineRawTx()\");\n     }\n     return ret;\n }"
      },
      {
        "sha": "a36944952e61991fb61187ab690b2ce27ba91b70",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -170,7 +170,7 @@ bool AppInit(int argc, char* argv[])\n     catch (const std::exception& e) {\n         PrintExceptionContinue(&e, \"AppInit()\");\n     } catch (...) {\n-        PrintExceptionContinue(NULL, \"AppInit()\");\n+        PrintExceptionContinue(nullptr, \"AppInit()\");\n     }\n \n     if (!fRet)"
      },
      {
        "sha": "47acde882e875f76078270bd3b4b5d97f3c6035c",
        "filename": "src/chain.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -9,7 +9,7 @@\n  * CChain implementation\n  */\n void CChain::SetTip(CBlockIndex *pindex) {\n-    if (pindex == NULL) {\n+    if (pindex == nullptr) {\n         vChain.clear();\n         return;\n     }\n@@ -49,8 +49,8 @@ CBlockLocator CChain::GetLocator(const CBlockIndex *pindex) const {\n }\n \n const CBlockIndex *CChain::FindFork(const CBlockIndex *pindex) const {\n-    if (pindex == NULL) {\n-        return NULL;\n+    if (pindex == nullptr) {\n+        return nullptr;\n     }\n     if (pindex->nHeight > Height())\n         pindex = pindex->GetAncestor(Height());\n@@ -63,7 +63,7 @@ CBlockIndex* CChain::FindEarliestAtLeast(int64_t nTime) const\n {\n     std::vector<CBlockIndex*>::const_iterator lower = std::lower_bound(vChain.begin(), vChain.end(), nTime,\n         [](CBlockIndex* pBlock, const int64_t& time) -> bool { return pBlock->GetBlockTimeMax() < time; });\n-    return (lower == vChain.end() ? NULL : *lower);\n+    return (lower == vChain.end() ? nullptr : *lower);\n }\n \n /** Turn the lowest '1' bit in the binary representation of a number into a '0'. */\n@@ -83,14 +83,14 @@ int static inline GetSkipHeight(int height) {\n CBlockIndex* CBlockIndex::GetAncestor(int height)\n {\n     if (height > nHeight || height < 0)\n-        return NULL;\n+        return nullptr;\n \n     CBlockIndex* pindexWalk = this;\n     int heightWalk = nHeight;\n     while (heightWalk > height) {\n         int heightSkip = GetSkipHeight(heightWalk);\n         int heightSkipPrev = GetSkipHeight(heightWalk - 1);\n-        if (pindexWalk->pskip != NULL &&\n+        if (pindexWalk->pskip != nullptr &&\n             (heightSkip == height ||\n              (heightSkip > height && !(heightSkipPrev < heightSkip - 2 &&\n                                        heightSkipPrev >= height)))) {\n@@ -150,7 +150,7 @@ int64_t GetBlockProofEquivalentTime(const CBlockIndex& to, const CBlockIndex& fr\n }\n \n /** Find the last common ancestor two blocks have.\n- *  Both pa and pb must be non-NULL. */\n+ *  Both pa and pb must be non-nullptr. */\n const CBlockIndex* LastCommonAncestor(const CBlockIndex* pa, const CBlockIndex* pb) {\n     if (pa->nHeight > pb->nHeight) {\n         pa = pa->GetAncestor(pb->nHeight);"
      },
      {
        "sha": "1223539e7374b64fd4e8268adbdfbc9ec4318f7e",
        "filename": "src/chain.h",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -221,9 +221,9 @@ class CBlockIndex\n \n     void SetNull()\n     {\n-        phashBlock = NULL;\n-        pprev = NULL;\n-        pskip = NULL;\n+        phashBlock = nullptr;\n+        pprev = nullptr;\n+        pskip = nullptr;\n         nHeight = 0;\n         nFile = 0;\n         nDataPos = 0;\n@@ -437,20 +437,20 @@ class CChain {\n     std::vector<CBlockIndex*> vChain;\n \n public:\n-    /** Returns the index entry for the genesis block of this chain, or NULL if none. */\n+    /** Returns the index entry for the genesis block of this chain, or nullptr if none. */\n     CBlockIndex *Genesis() const {\n-        return vChain.size() > 0 ? vChain[0] : NULL;\n+        return vChain.size() > 0 ? vChain[0] : nullptr;\n     }\n \n-    /** Returns the index entry for the tip of this chain, or NULL if none. */\n+    /** Returns the index entry for the tip of this chain, or nullptr if none. */\n     CBlockIndex *Tip() const {\n-        return vChain.size() > 0 ? vChain[vChain.size() - 1] : NULL;\n+        return vChain.size() > 0 ? vChain[vChain.size() - 1] : nullptr;\n     }\n \n-    /** Returns the index entry at a particular height in this chain, or NULL if no such height exists. */\n+    /** Returns the index entry at a particular height in this chain, or nullptr if no such height exists. */\n     CBlockIndex *operator[](int nHeight) const {\n         if (nHeight < 0 || nHeight >= (int)vChain.size())\n-            return NULL;\n+            return nullptr;\n         return vChain[nHeight];\n     }\n \n@@ -465,12 +465,12 @@ class CChain {\n         return (*this)[pindex->nHeight] == pindex;\n     }\n \n-    /** Find the successor of a block in this chain, or NULL if the given index is not found or is the tip. */\n+    /** Find the successor of a block in this chain, or nullptr if the given index is not found or is the tip. */\n     CBlockIndex *Next(const CBlockIndex *pindex) const {\n         if (Contains(pindex))\n             return (*this)[pindex->nHeight + 1];\n         else\n-            return NULL;\n+            return nullptr;\n     }\n \n     /** Return the maximal height in the chain. Is equal to chain.Tip() ? chain.Tip()->nHeight : -1. */\n@@ -482,7 +482,7 @@ class CChain {\n     void SetTip(CBlockIndex *pindex);\n \n     /** Return a CBlockLocator that refers to a block in this chain (by default the tip). */\n-    CBlockLocator GetLocator(const CBlockIndex *pindex = NULL) const;\n+    CBlockLocator GetLocator(const CBlockIndex *pindex = nullptr) const;\n \n     /** Find the last common block between this chain and a block index entry. */\n     const CBlockIndex *FindFork(const CBlockIndex *pindex) const;"
      },
      {
        "sha": "5afe3e66b625a0e4a9888ad1a8d6eb3f84bb011a",
        "filename": "src/checkpoints.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/checkpoints.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/checkpoints.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkpoints.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -26,7 +26,7 @@ namespace Checkpoints {\n             if (t != mapBlockIndex.end())\n                 return t->second;\n         }\n-        return NULL;\n+        return nullptr;\n     }\n \n } // namespace Checkpoints"
      },
      {
        "sha": "4bc6be45f8f315428dd79e94f72b4210a8367cd0",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -183,15 +183,15 @@ class CCheckQueueControl\n     CCheckQueueControl& operator=(const CCheckQueueControl&) = delete;\n     explicit CCheckQueueControl(CCheckQueue<T> * const pqueueIn) : pqueue(pqueueIn), fDone(false)\n     {\n-        // passed queue is supposed to be unused, or NULL\n-        if (pqueue != NULL) {\n+        // passed queue is supposed to be unused, or nullptr\n+        if (pqueue != nullptr) {\n             ENTER_CRITICAL_SECTION(pqueue->ControlMutex);\n         }\n     }\n \n     bool Wait()\n     {\n-        if (pqueue == NULL)\n+        if (pqueue == nullptr)\n             return true;\n         bool fRet = pqueue->Wait();\n         fDone = true;\n@@ -200,15 +200,15 @@ class CCheckQueueControl\n \n     void Add(std::vector<T>& vChecks)\n     {\n-        if (pqueue != NULL)\n+        if (pqueue != nullptr)\n             pqueue->Add(vChecks);\n     }\n \n     ~CCheckQueueControl()\n     {\n         if (!fDone)\n             Wait();\n-        if (pqueue != NULL) {\n+        if (pqueue != nullptr) {\n             LEAVE_CRITICAL_SECTION(pqueue->ControlMutex);\n         }\n     }"
      },
      {
        "sha": "798ce4b5fd8a74a4341a482f8581086b5c3c16a1",
        "filename": "src/consensus/merkle.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/consensus/merkle.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/consensus/merkle.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/merkle.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -132,13 +132,13 @@ static void MerkleComputation(const std::vector<uint256>& leaves, uint256* proot\n \n uint256 ComputeMerkleRoot(const std::vector<uint256>& leaves, bool* mutated) {\n     uint256 hash;\n-    MerkleComputation(leaves, &hash, mutated, -1, NULL);\n+    MerkleComputation(leaves, &hash, mutated, -1, nullptr);\n     return hash;\n }\n \n std::vector<uint256> ComputeMerkleBranch(const std::vector<uint256>& leaves, uint32_t position) {\n     std::vector<uint256> ret;\n-    MerkleComputation(leaves, NULL, NULL, position, &ret);\n+    MerkleComputation(leaves, nullptr, nullptr, position, &ret);\n     return ret;\n }\n "
      },
      {
        "sha": "33764c74606946d02ade4a439879f7da742cd3c5",
        "filename": "src/consensus/merkle.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/consensus/merkle.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/consensus/merkle.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/merkle.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -12,21 +12,21 @@\n #include \"primitives/block.h\"\n #include \"uint256.h\"\n \n-uint256 ComputeMerkleRoot(const std::vector<uint256>& leaves, bool* mutated = NULL);\n+uint256 ComputeMerkleRoot(const std::vector<uint256>& leaves, bool* mutated = nullptr);\n std::vector<uint256> ComputeMerkleBranch(const std::vector<uint256>& leaves, uint32_t position);\n uint256 ComputeMerkleRootFromBranch(const uint256& leaf, const std::vector<uint256>& branch, uint32_t position);\n \n /*\n  * Compute the Merkle root of the transactions in a block.\n  * *mutated is set to true if a duplicated subtree was found.\n  */\n-uint256 BlockMerkleRoot(const CBlock& block, bool* mutated = NULL);\n+uint256 BlockMerkleRoot(const CBlock& block, bool* mutated = nullptr);\n \n /*\n  * Compute the Merkle root of the witness transactions in a block.\n  * *mutated is set to true if a duplicated subtree was found.\n  */\n-uint256 BlockWitnessMerkleRoot(const CBlock& block, bool* mutated = NULL);\n+uint256 BlockWitnessMerkleRoot(const CBlock& block, bool* mutated = nullptr);\n \n /*\n  * Compute the Merkle branch for the tree of transactions in a block, for a"
      },
      {
        "sha": "0a7b1694ce6725071a2bbdb1c4fe06b5ae10271e",
        "filename": "src/core_write.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/core_write.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/core_write.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_write.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -92,7 +92,7 @@ std::string ScriptToAsmStr(const CScript& script, const bool fAttemptSighashDeco\n                     // this won't decode correctly formatted public keys in Pubkey or Multisig scripts due to\n                     // the restrictions on the pubkey formats (see IsCompressedOrUncompressedPubKey) being incongruous with the\n                     // checks in CheckSignatureEncoding.\n-                    if (CheckSignatureEncoding(vch, SCRIPT_VERIFY_STRICTENC, NULL)) {\n+                    if (CheckSignatureEncoding(vch, SCRIPT_VERIFY_STRICTENC, nullptr)) {\n                         const unsigned char chSigHashType = vch.back();\n                         if (mapSigHashTypes.count(chSigHashType)) {\n                             strSigHashDecode = \"[\" + mapSigHashTypes.find(chSigHashType)->second + \"]\";"
      },
      {
        "sha": "4038ae9f868e054ee6baa64bafd997c85e260226",
        "filename": "src/crypto/chacha20.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/crypto/chacha20.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/crypto/chacha20.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/chacha20.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -75,7 +75,7 @@ void ChaCha20::Output(unsigned char* c, size_t bytes)\n {\n     uint32_t x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n     uint32_t j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n-    unsigned char *ctarget = NULL;\n+    unsigned char *ctarget = nullptr;\n     unsigned char tmp[64];\n     unsigned int i;\n "
      },
      {
        "sha": "27767f90b43eff822ffdce1e2e7dd390a49d98ed",
        "filename": "src/dbwrapper.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/dbwrapper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/dbwrapper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dbwrapper.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -92,7 +92,7 @@ static leveldb::Options GetOptions(size_t nCacheSize)\n \n CDBWrapper::CDBWrapper(const fs::path& path, size_t nCacheSize, bool fMemory, bool fWipe, bool obfuscate)\n {\n-    penv = NULL;\n+    penv = nullptr;\n     readoptions.verify_checksums = true;\n     iteroptions.verify_checksums = true;\n     iteroptions.fill_cache = false;\n@@ -144,15 +144,15 @@ CDBWrapper::CDBWrapper(const fs::path& path, size_t nCacheSize, bool fMemory, bo\n CDBWrapper::~CDBWrapper()\n {\n     delete pdb;\n-    pdb = NULL;\n+    pdb = nullptr;\n     delete options.filter_policy;\n-    options.filter_policy = NULL;\n+    options.filter_policy = nullptr;\n     delete options.info_log;\n-    options.info_log = NULL;\n+    options.info_log = nullptr;\n     delete options.block_cache;\n-    options.block_cache = NULL;\n+    options.block_cache = nullptr;\n     delete penv;\n-    options.env = NULL;\n+    options.env = nullptr;\n }\n \n bool CDBWrapper::WriteBatch(CDBBatch& batch, bool fSync)"
      },
      {
        "sha": "7575d207ae5a450ca073049bb69b52f0b5219608",
        "filename": "src/dbwrapper.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/dbwrapper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/dbwrapper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dbwrapper.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -177,7 +177,7 @@ class CDBWrapper\n {\n     friend const std::vector<unsigned char>& dbwrapper_private::GetObfuscateKey(const CDBWrapper &w);\n private:\n-    //! custom environment this database is using (may be NULL in case of default environment)\n+    //! custom environment this database is using (may be nullptr in case of default environment)\n     leveldb::Env* penv;\n \n     //! database options used"
      },
      {
        "sha": "5adfca40942a7ca76d4b4cad2e92cc4a6626701a",
        "filename": "src/httpserver.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/httpserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/httpserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -292,7 +292,7 @@ static void http_request_cb(struct evhttp_request* req, void* arg)\n static void http_reject_request_cb(struct evhttp_request* req, void*)\n {\n     LogPrint(BCLog::HTTP, \"Rejecting request while shutting down\\n\");\n-    evhttp_send_error(req, HTTP_SERVUNAVAIL, NULL);\n+    evhttp_send_error(req, HTTP_SERVUNAVAIL, nullptr);\n }\n \n /** Event dispatcher thread */\n@@ -334,7 +334,7 @@ static bool HTTPBindAddresses(struct evhttp* http)\n     // Bind addresses\n     for (std::vector<std::pair<std::string, uint16_t> >::iterator i = endpoints.begin(); i != endpoints.end(); ++i) {\n         LogPrint(BCLog::HTTP, \"Binding RPC on address %s port %i\\n\", i->first, i->second);\n-        evhttp_bound_socket *bind_handle = evhttp_bind_socket_with_handle(http, i->first.empty() ? NULL : i->first.c_str(), i->second);\n+        evhttp_bound_socket *bind_handle = evhttp_bind_socket_with_handle(http, i->first.empty() ? nullptr : i->first.c_str(), i->second);\n         if (bind_handle) {\n             boundSockets.push_back(bind_handle);\n         } else {\n@@ -404,7 +404,7 @@ bool InitHTTPServer()\n     evhttp_set_timeout(http, GetArg(\"-rpcservertimeout\", DEFAULT_HTTP_SERVER_TIMEOUT));\n     evhttp_set_max_headers_size(http, MAX_HEADERS_SIZE);\n     evhttp_set_max_body_size(http, MAX_SIZE);\n-    evhttp_set_gencb(http, http_request_cb, NULL);\n+    evhttp_set_gencb(http, http_request_cb, nullptr);\n \n     if (!HTTPBindAddresses(http)) {\n         LogPrintf(\"Unable to bind any endpoint for RPC server\\n\");\n@@ -464,7 +464,7 @@ void InterruptHTTPServer()\n             evhttp_del_accept_socket(eventHTTP, socket);\n         }\n         // Reject requests on current connections\n-        evhttp_set_gencb(eventHTTP, http_reject_request_cb, NULL);\n+        evhttp_set_gencb(eventHTTP, http_reject_request_cb, nullptr);\n     }\n     if (workQueue)\n         workQueue->Interrupt();\n@@ -530,7 +530,7 @@ HTTPEvent::~HTTPEvent()\n }\n void HTTPEvent::trigger(struct timeval* tv)\n {\n-    if (tv == NULL)\n+    if (tv == nullptr)\n         event_active(ev, 0, 0); // immediately trigger event in main thread\n     else\n         evtimer_add(ev, tv); // trigger after timeval passed\n@@ -573,7 +573,7 @@ std::string HTTPRequest::ReadBody()\n      * abstraction to consume the evbuffer on the fly in the parsing algorithm.\n      */\n     const char* data = (const char*)evbuffer_pullup(buf, size);\n-    if (!data) // returns NULL in case of empty buffer\n+    if (!data) // returns nullptr in case of empty buffer\n         return \"\";\n     std::string rv(data, size);\n     evbuffer_drain(buf, size);\n@@ -600,7 +600,7 @@ void HTTPRequest::WriteReply(int nStatus, const std::string& strReply)\n     assert(evb);\n     evbuffer_add(evb, strReply.data(), strReply.size());\n     HTTPEvent* ev = new HTTPEvent(eventBase, true,\n-        std::bind(evhttp_send_reply, req, nStatus, (const char*)NULL, (struct evbuffer *)NULL));\n+        std::bind(evhttp_send_reply, req, nStatus, (const char*)nullptr, (struct evbuffer *)nullptr));\n     ev->trigger(0);\n     replySent = true;\n     req = 0; // transferred back to main thread\n@@ -669,7 +669,7 @@ void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n std::string urlDecode(const std::string &urlEncoded) {\n     std::string res;\n     if (!urlEncoded.empty()) {\n-        char *decoded = evhttp_uridecode(urlEncoded.c_str(), false, NULL);\n+        char *decoded = evhttp_uridecode(urlEncoded.c_str(), false, nullptr);\n         if (decoded) {\n             res = std::string(decoded);\n             free(decoded);"
      },
      {
        "sha": "7a37b8d800355e0cf0474335925c484b219450d8",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -76,7 +76,7 @@ std::unique_ptr<CConnman> g_connman;\n std::unique_ptr<PeerLogicValidation> peerLogic;\n \n #if ENABLE_ZMQ\n-static CZMQNotificationInterface* pzmqNotificationInterface = NULL;\n+static CZMQNotificationInterface* pzmqNotificationInterface = nullptr;\n #endif\n \n #ifdef WIN32\n@@ -153,7 +153,7 @@ class CCoinsViewErrorCatcher : public CCoinsViewBacked\n     // Writes do not need similar protection, as failure to write is handled by the caller.\n };\n \n-static CCoinsViewErrorCatcher *pcoinscatcher = NULL;\n+static CCoinsViewErrorCatcher *pcoinscatcher = nullptr;\n static std::unique_ptr<ECCVerifyHandle> globalVerifyHandle;\n \n void Interrupt(boost::thread_group& threadGroup)\n@@ -232,17 +232,17 @@ void Shutdown()\n \n     {\n         LOCK(cs_main);\n-        if (pcoinsTip != NULL) {\n+        if (pcoinsTip != nullptr) {\n             FlushStateToDisk();\n         }\n         delete pcoinsTip;\n-        pcoinsTip = NULL;\n+        pcoinsTip = nullptr;\n         delete pcoinscatcher;\n-        pcoinscatcher = NULL;\n+        pcoinscatcher = nullptr;\n         delete pcoinsdbview;\n-        pcoinsdbview = NULL;\n+        pcoinsdbview = nullptr;\n         delete pblocktree;\n-        pblocktree = NULL;\n+        pblocktree = nullptr;\n     }\n #ifdef ENABLE_WALLET\n     for (CWalletRef pwallet : vpwallets) {\n@@ -254,7 +254,7 @@ void Shutdown()\n     if (pzmqNotificationInterface) {\n         UnregisterValidationInterface(pzmqNotificationInterface);\n         delete pzmqNotificationInterface;\n-        pzmqNotificationInterface = NULL;\n+        pzmqNotificationInterface = nullptr;\n     }\n #endif\n \n@@ -300,7 +300,7 @@ static void registerSignalHandler(int signal, void(*handler)(int))\n     sa.sa_handler = handler;\n     sigemptyset(&sa.sa_mask);\n     sa.sa_flags = 0;\n-    sigaction(signal, &sa, NULL);\n+    sigaction(signal, &sa, nullptr);\n }\n #endif\n \n@@ -558,7 +558,7 @@ static CConditionVariable condvar_GenesisWait;\n \n static void BlockNotifyGenesisWait(bool, const CBlockIndex *pBlockIndex)\n {\n-    if (pBlockIndex != NULL) {\n+    if (pBlockIndex != nullptr) {\n         {\n             boost::unique_lock<boost::mutex> lock_GenesisWait(cs_GenesisWait);\n             fHaveGenesis = true;\n@@ -843,7 +843,7 @@ bool AppInitBasicSetup()\n #ifdef _MSC_VER\n     // Turn off Microsoft heap dump noise\n     _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);\n-    _CrtSetReportFile(_CRT_WARN, CreateFileA(\"NUL\", GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0));\n+    _CrtSetReportFile(_CRT_WARN, CreateFileA(\"NUL\", GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0, 0));\n     // Disable confusing \"helpful\" text message on abort, Ctrl-C\n     _set_abort_behavior(0, _WRITE_ABORT_MSG | _CALL_REPORTFAULT);\n #endif\n@@ -858,7 +858,7 @@ bool AppInitBasicSetup()\n #endif\n     typedef BOOL (WINAPI *PSETPROCDEPPOL)(DWORD);\n     PSETPROCDEPPOL setProcDEPPol = (PSETPROCDEPPOL)GetProcAddress(GetModuleHandleA(\"Kernel32.dll\"), \"SetProcessDEPPolicy\");\n-    if (setProcDEPPol != NULL) setProcDEPPol(PROCESS_DEP_ENABLE);\n+    if (setProcDEPPol != nullptr) setProcDEPPol(PROCESS_DEP_ENABLE);\n #endif\n \n     if (!SetupNetworking())\n@@ -1473,7 +1473,7 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n                         strLoadError = _(\"Error initializing block database\");\n                         break;\n                     }\n-                    assert(chainActive.Tip() != NULL);\n+                    assert(chainActive.Tip() != nullptr);\n                 }\n \n                 if (!fReindex) {\n@@ -1600,7 +1600,7 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n \n     // Either install a handler to notify us when genesis activates, or set fHaveGenesis directly.\n     // No locking, as this happens before any background thread is started.\n-    if (chainActive.Tip() == NULL) {\n+    if (chainActive.Tip() == nullptr) {\n         uiInterface.NotifyBlockTip.connect(BlockNotifyGenesisWait);\n     } else {\n         fHaveGenesis = true;"
      },
      {
        "sha": "315a3978c8243ba2b21807d1b990ceeb2c48e863",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -13,7 +13,7 @@\n #include <secp256k1.h>\n #include <secp256k1_recovery.h>\n \n-static secp256k1_context* secp256k1_context_sign = NULL;\n+static secp256k1_context* secp256k1_context_sign = nullptr;\n \n /** These functions are taken from the libsecp256k1 distribution and are very ugly. */\n static int ec_privkey_import_der(const secp256k1_context* ctx, unsigned char *out32, const unsigned char *privkey, size_t privkeylen) {\n@@ -165,7 +165,7 @@ bool CKey::Sign(const uint256 &hash, std::vector<unsigned char>& vchSig, uint32_\n     unsigned char extra_entropy[32] = {0};\n     WriteLE32(extra_entropy, test_case);\n     secp256k1_ecdsa_signature sig;\n-    int ret = secp256k1_ecdsa_sign(secp256k1_context_sign, &sig, hash.begin(), begin(), secp256k1_nonce_function_rfc6979, test_case ? extra_entropy : NULL);\n+    int ret = secp256k1_ecdsa_sign(secp256k1_context_sign, &sig, hash.begin(), begin(), secp256k1_nonce_function_rfc6979, test_case ? extra_entropy : nullptr);\n     assert(ret);\n     secp256k1_ecdsa_signature_serialize_der(secp256k1_context_sign, (unsigned char*)vchSig.data(), &nSigLen, &sig);\n     vchSig.resize(nSigLen);\n@@ -192,7 +192,7 @@ bool CKey::SignCompact(const uint256 &hash, std::vector<unsigned char>& vchSig)\n     vchSig.resize(65);\n     int rec = -1;\n     secp256k1_ecdsa_recoverable_signature sig;\n-    int ret = secp256k1_ecdsa_sign_recoverable(secp256k1_context_sign, &sig, hash.begin(), begin(), secp256k1_nonce_function_rfc6979, NULL);\n+    int ret = secp256k1_ecdsa_sign_recoverable(secp256k1_context_sign, &sig, hash.begin(), begin(), secp256k1_nonce_function_rfc6979, nullptr);\n     assert(ret);\n     secp256k1_ecdsa_recoverable_signature_serialize_compact(secp256k1_context_sign, (unsigned char*)&vchSig[1], &rec, &sig);\n     assert(ret);\n@@ -289,10 +289,10 @@ bool ECC_InitSanityCheck() {\n }\n \n void ECC_Start() {\n-    assert(secp256k1_context_sign == NULL);\n+    assert(secp256k1_context_sign == nullptr);\n \n     secp256k1_context *ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n-    assert(ctx != NULL);\n+    assert(ctx != nullptr);\n \n     {\n         // Pass in a random blinding seed to the secp256k1 context.\n@@ -307,7 +307,7 @@ void ECC_Start() {\n \n void ECC_Stop() {\n     secp256k1_context *ctx = secp256k1_context_sign;\n-    secp256k1_context_sign = NULL;\n+    secp256k1_context_sign = nullptr;\n \n     if (ctx) {\n         secp256k1_context_destroy(ctx);"
      },
      {
        "sha": "0ed2196063342e6f1e82b28eb4183678524a6621",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 23,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -306,7 +306,7 @@ CNode* CConnman::FindNode(const CNetAddr& ip)\n     for (CNode* pnode : vNodes)\n         if ((CNetAddr)pnode->addr == ip)\n             return (pnode);\n-    return NULL;\n+    return nullptr;\n }\n \n CNode* CConnman::FindNode(const CSubNet& subNet)\n@@ -315,7 +315,7 @@ CNode* CConnman::FindNode(const CSubNet& subNet)\n     for (CNode* pnode : vNodes)\n     if (subNet.Match((CNetAddr)pnode->addr))\n         return (pnode);\n-    return NULL;\n+    return nullptr;\n }\n \n CNode* CConnman::FindNode(const std::string& addrName)\n@@ -326,7 +326,7 @@ CNode* CConnman::FindNode(const std::string& addrName)\n             return (pnode);\n         }\n     }\n-    return NULL;\n+    return nullptr;\n }\n \n CNode* CConnman::FindNode(const CService& addr)\n@@ -335,7 +335,7 @@ CNode* CConnman::FindNode(const CService& addr)\n     for (CNode* pnode : vNodes)\n         if ((CService)pnode->addr == addr)\n             return (pnode);\n-    return NULL;\n+    return nullptr;\n }\n \n bool CConnman::CheckIncomingNonce(uint64_t nonce)\n@@ -366,16 +366,16 @@ static CAddress GetBindAddress(SOCKET sock)\n \n CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure)\n {\n-    if (pszDest == NULL) {\n+    if (pszDest == nullptr) {\n         if (IsLocal(addrConnect))\n-            return NULL;\n+            return nullptr;\n \n         // Look for an existing connection\n         CNode* pnode = FindNode((CService)addrConnect);\n         if (pnode)\n         {\n             LogPrintf(\"Failed to open new connection, already connected\\n\");\n-            return NULL;\n+            return nullptr;\n         }\n     }\n \n@@ -393,7 +393,7 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n         if (!IsSelectableSocket(hSocket)) {\n             LogPrintf(\"Cannot create connection: non-selectable socket created (fd >= FD_SETSIZE ?)\\n\");\n             CloseSocket(hSocket);\n-            return NULL;\n+            return nullptr;\n         }\n \n         if (pszDest && addrConnect.IsValid()) {\n@@ -408,7 +408,7 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n                 pnode->MaybeSetAddrName(std::string(pszDest));\n                 CloseSocket(hSocket);\n                 LogPrintf(\"Failed to open new connection, already connected\\n\");\n-                return NULL;\n+                return nullptr;\n             }\n         }\n \n@@ -429,7 +429,7 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n         addrman.Attempt(addrConnect, fCountFailure);\n     }\n \n-    return NULL;\n+    return nullptr;\n }\n \n void CConnman::DumpBanlist()\n@@ -966,7 +966,7 @@ bool CConnman::AttemptToEvictConnection()\n             NodeEvictionCandidate candidate = {node->GetId(), node->nTimeConnected, node->nMinPingUsecTime,\n                                                node->nLastBlockTime, node->nLastTXTime,\n                                                (node->nServices & nRelevantServices) == nRelevantServices,\n-                                               node->fRelayTxes, node->pfilter != NULL, node->addr, node->nKeyedNetGroup};\n+                                               node->fRelayTxes, node->pfilter != nullptr, node->addr, node->nKeyedNetGroup};\n             vEvictionCandidates.push_back(candidate);\n         }\n     }\n@@ -1524,7 +1524,7 @@ void ThreadMapPort()\n \n void MapPort(bool fUseUPnP)\n {\n-    static boost::thread* upnp_thread = NULL;\n+    static boost::thread* upnp_thread = nullptr;\n \n     if (fUseUPnP)\n     {\n@@ -1539,7 +1539,7 @@ void MapPort(bool fUseUPnP)\n         upnp_thread->interrupt();\n         upnp_thread->join();\n         delete upnp_thread;\n-        upnp_thread = NULL;\n+        upnp_thread = nullptr;\n     }\n }\n \n@@ -1685,7 +1685,7 @@ void CConnman::ThreadOpenConnections()\n             for (const std::string& strAddr : gArgs.GetArgs(\"-connect\"))\n             {\n                 CAddress addr(CService(), NODE_NONE);\n-                OpenNetworkConnection(addr, false, NULL, strAddr.c_str());\n+                OpenNetworkConnection(addr, false, nullptr, strAddr.c_str());\n                 for (int i = 0; i < 10 && i < nLoop; i++)\n                 {\n                     if (!interruptNet.sleep_for(std::chrono::milliseconds(500)))\n@@ -1841,7 +1841,7 @@ void CConnman::ThreadOpenConnections()\n                 LogPrint(BCLog::NET, \"Making feeler connection to %s\\n\", addrConnect.ToString());\n             }\n \n-            OpenNetworkConnection(addrConnect, (int)setConnected.size() >= std::min(nMaxConnections - 1, 2), &grant, NULL, false, fFeeler);\n+            OpenNetworkConnection(addrConnect, (int)setConnected.size() >= std::min(nMaxConnections - 1, 2), &grant, nullptr, false, fFeeler);\n         }\n     }\n }\n@@ -2153,9 +2153,9 @@ void Discover(boost::thread_group& threadGroup)\n     struct ifaddrs* myaddrs;\n     if (getifaddrs(&myaddrs) == 0)\n     {\n-        for (struct ifaddrs* ifa = myaddrs; ifa != NULL; ifa = ifa->ifa_next)\n+        for (struct ifaddrs* ifa = myaddrs; ifa != nullptr; ifa = ifa->ifa_next)\n         {\n-            if (ifa->ifa_addr == NULL) continue;\n+            if (ifa->ifa_addr == nullptr) continue;\n             if ((ifa->ifa_flags & IFF_UP) == 0) continue;\n             if (strcmp(ifa->ifa_name, \"lo\") == 0) continue;\n             if (strcmp(ifa->ifa_name, \"lo0\") == 0) continue;\n@@ -2208,8 +2208,8 @@ CConnman::CConnman(uint64_t nSeed0In, uint64_t nSeed1In) : nSeed0(nSeed0In), nSe\n     nLastNodeId = 0;\n     nSendBufferMaxSize = 0;\n     nReceiveFloodSize = 0;\n-    semOutbound = NULL;\n-    semAddnode = NULL;\n+    semOutbound = nullptr;\n+    semAddnode = nullptr;\n     flagInterruptMsgProc = false;\n \n     Options connOptions;\n@@ -2312,11 +2312,11 @@ bool CConnman::Start(CScheduler& scheduler, const Options& connOptions)\n \n     fAddressesInitialized = true;\n \n-    if (semOutbound == NULL) {\n+    if (semOutbound == nullptr) {\n         // initialize semaphore\n         semOutbound = new CSemaphore(std::min((nMaxOutbound + nMaxFeeler), nMaxConnections));\n     }\n-    if (semAddnode == NULL) {\n+    if (semAddnode == nullptr) {\n         // initialize semaphore\n         semAddnode = new CSemaphore(nMaxAddnode);\n     }\n@@ -2434,9 +2434,9 @@ void CConnman::Stop()\n     vNodesDisconnected.clear();\n     vhListenSocket.clear();\n     delete semOutbound;\n-    semOutbound = NULL;\n+    semOutbound = nullptr;\n     delete semAddnode;\n-    semAddnode = NULL;\n+    semAddnode = nullptr;\n }\n \n void CConnman::DeleteNode(CNode* pnode)"
      },
      {
        "sha": "a32736aa97bf2be8153d63ee0e7fdaa3618cc99b",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -170,7 +170,7 @@ class CConnman\n     void Interrupt();\n     bool GetNetworkActive() const { return fNetworkActive; };\n     void SetNetworkActive(bool active);\n-    bool OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound = NULL, const char *strDest = NULL, bool fOneShot = false, bool fFeeler = false, bool fAddnode = false);\n+    bool OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound = nullptr, const char *strDest = nullptr, bool fOneShot = false, bool fFeeler = false, bool fAddnode = false);\n     bool CheckIncomingNonce(uint64_t nonce);\n \n     bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func);\n@@ -470,7 +470,7 @@ bool AddLocal(const CNetAddr& addr, int nScore = LOCAL_NONE);\n bool RemoveLocal(const CService& addr);\n bool SeenLocal(const CService& addr);\n bool IsLocal(const CService& addr);\n-bool GetLocal(CService &addr, const CNetAddr *paddrPeer = NULL);\n+bool GetLocal(CService &addr, const CNetAddr *paddrPeer = nullptr);\n bool IsReachable(enum Network net);\n bool IsReachable(const CNetAddr &addr);\n CAddress GetLocalAddress(const CNetAddr *paddrPeer, ServiceFlags nLocalServices);"
      },
      {
        "sha": "2e14d01f08ffb80effbe7ffd02ed4bab9759aea1",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 29,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -202,10 +202,10 @@ struct CNodeState {\n         fCurrentlyConnected = false;\n         nMisbehavior = 0;\n         fShouldBan = false;\n-        pindexBestKnownBlock = NULL;\n+        pindexBestKnownBlock = nullptr;\n         hashLastUnknownBlock.SetNull();\n-        pindexLastCommonBlock = NULL;\n-        pindexBestHeaderSent = NULL;\n+        pindexLastCommonBlock = nullptr;\n+        pindexBestHeaderSent = nullptr;\n         nUnconnectingHeaders = 0;\n         fSyncStarted = false;\n         nHeadersSyncTimeout = 0;\n@@ -230,7 +230,7 @@ std::map<NodeId, CNodeState> mapNodeState;\n CNodeState *State(NodeId pnode) {\n     std::map<NodeId, CNodeState>::iterator it = mapNodeState.find(pnode);\n     if (it == mapNodeState.end())\n-        return NULL;\n+        return nullptr;\n     return &it->second;\n }\n \n@@ -336,9 +336,9 @@ bool MarkBlockAsReceived(const uint256& hash) {\n // Requires cs_main.\n // returns false, still setting pit, if the block was already in flight from the same peer\n // pit will only be valid as long as the same cs_main lock is being held\n-bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex* pindex = NULL, std::list<QueuedBlock>::iterator** pit = NULL) {\n+bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex* pindex = nullptr, std::list<QueuedBlock>::iterator** pit = nullptr) {\n     CNodeState *state = State(nodeid);\n-    assert(state != NULL);\n+    assert(state != nullptr);\n \n     // Short-circuit most stuff in case its from the same node\n     std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n@@ -353,14 +353,14 @@ bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex*\n     MarkBlockAsReceived(hash);\n \n     std::list<QueuedBlock>::iterator it = state->vBlocksInFlight.insert(state->vBlocksInFlight.end(),\n-            {hash, pindex, pindex != NULL, std::unique_ptr<PartiallyDownloadedBlock>(pit ? new PartiallyDownloadedBlock(&mempool) : NULL)});\n+            {hash, pindex, pindex != nullptr, std::unique_ptr<PartiallyDownloadedBlock>(pit ? new PartiallyDownloadedBlock(&mempool) : nullptr)});\n     state->nBlocksInFlight++;\n     state->nBlocksInFlightValidHeaders += it->fValidatedHeaders;\n     if (state->nBlocksInFlight == 1) {\n         // We're starting a block download (batch) from this peer.\n         state->nDownloadingSince = GetTimeMicros();\n     }\n-    if (state->nBlocksInFlightValidHeaders == 1 && pindex != NULL) {\n+    if (state->nBlocksInFlightValidHeaders == 1 && pindex != nullptr) {\n         nPeersWithValidatedDownloads++;\n     }\n     itInFlight = mapBlocksInFlight.insert(std::make_pair(hash, std::make_pair(nodeid, it))).first;\n@@ -372,12 +372,12 @@ bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex*\n /** Check whether the last unknown block a peer advertised is not yet known. */\n void ProcessBlockAvailability(NodeId nodeid) {\n     CNodeState *state = State(nodeid);\n-    assert(state != NULL);\n+    assert(state != nullptr);\n \n     if (!state->hashLastUnknownBlock.IsNull()) {\n         BlockMap::iterator itOld = mapBlockIndex.find(state->hashLastUnknownBlock);\n         if (itOld != mapBlockIndex.end() && itOld->second->nChainWork > 0) {\n-            if (state->pindexBestKnownBlock == NULL || itOld->second->nChainWork >= state->pindexBestKnownBlock->nChainWork)\n+            if (state->pindexBestKnownBlock == nullptr || itOld->second->nChainWork >= state->pindexBestKnownBlock->nChainWork)\n                 state->pindexBestKnownBlock = itOld->second;\n             state->hashLastUnknownBlock.SetNull();\n         }\n@@ -387,14 +387,14 @@ void ProcessBlockAvailability(NodeId nodeid) {\n /** Update tracking information about which blocks a peer is assumed to have. */\n void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {\n     CNodeState *state = State(nodeid);\n-    assert(state != NULL);\n+    assert(state != nullptr);\n \n     ProcessBlockAvailability(nodeid);\n \n     BlockMap::iterator it = mapBlockIndex.find(hash);\n     if (it != mapBlockIndex.end() && it->second->nChainWork > 0) {\n         // An actually better block was announced.\n-        if (state->pindexBestKnownBlock == NULL || it->second->nChainWork >= state->pindexBestKnownBlock->nChainWork)\n+        if (state->pindexBestKnownBlock == nullptr || it->second->nChainWork >= state->pindexBestKnownBlock->nChainWork)\n             state->pindexBestKnownBlock = it->second;\n     } else {\n         // An unknown block was announced; just assume that the latest one is the best one.\n@@ -461,17 +461,17 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n \n     vBlocks.reserve(vBlocks.size() + count);\n     CNodeState *state = State(nodeid);\n-    assert(state != NULL);\n+    assert(state != nullptr);\n \n     // Make sure pindexBestKnownBlock is up to date, we'll need it.\n     ProcessBlockAvailability(nodeid);\n \n-    if (state->pindexBestKnownBlock == NULL || state->pindexBestKnownBlock->nChainWork < chainActive.Tip()->nChainWork || state->pindexBestKnownBlock->nChainWork < UintToArith256(consensusParams.nMinimumChainWork)) {\n+    if (state->pindexBestKnownBlock == nullptr || state->pindexBestKnownBlock->nChainWork < chainActive.Tip()->nChainWork || state->pindexBestKnownBlock->nChainWork < UintToArith256(consensusParams.nMinimumChainWork)) {\n         // This peer has nothing interesting.\n         return;\n     }\n \n-    if (state->pindexLastCommonBlock == NULL) {\n+    if (state->pindexLastCommonBlock == nullptr) {\n         // Bootstrap quickly by guessing a parent of our best tip is the forking point.\n         // Guessing wrong in either direction is not a problem.\n         state->pindexLastCommonBlock = chainActive[std::min(state->pindexBestKnownBlock->nHeight, chainActive.Height())];\n@@ -546,7 +546,7 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n     LOCK(cs_main);\n     CNodeState *state = State(nodeid);\n-    if (state == NULL)\n+    if (state == nullptr)\n         return false;\n     stats.nMisbehavior = state->nMisbehavior;\n     stats.nSyncHeight = state->pindexBestKnownBlock ? state->pindexBestKnownBlock->nHeight : -1;\n@@ -700,7 +700,7 @@ void Misbehaving(NodeId pnode, int howmuch)\n         return;\n \n     CNodeState *state = State(pnode);\n-    if (state == NULL)\n+    if (state == nullptr)\n         return;\n \n     state->nMisbehavior += howmuch;\n@@ -1006,7 +1006,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                         // To prevent fingerprinting attacks, only send blocks outside of the active\n                         // chain if they are valid, and no more than a month older (both in time, and in\n                         // best equivalent proof of work) than the best header chain we know about.\n-                        send = mi->second->IsValid(BLOCK_VALID_SCRIPTS) && (pindexBestHeader != NULL) &&\n+                        send = mi->second->IsValid(BLOCK_VALID_SCRIPTS) && (pindexBestHeader != nullptr) &&\n                             (pindexBestHeader->GetBlockTime() - mi->second->GetBlockTime() < nOneMonth) &&\n                             (GetBlockProofEquivalentTime(*pindexBestHeader, *mi->second, *pindexBestHeader, consensusParams) < nOneMonth);\n                         if (!send) {\n@@ -1017,7 +1017,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                 // disconnect node in case we have reached the outbound limit for serving historical blocks\n                 // never disconnect whitelisted nodes\n                 static const int nOneWeek = 7 * 24 * 60 * 60; // assume > 1 week = historical\n-                if (send && connman.OutboundTargetReached(true) && ( ((pindexBestHeader != NULL) && (pindexBestHeader->GetBlockTime() - mi->second->GetBlockTime() > nOneWeek)) || inv.type == MSG_FILTERED_BLOCK) && !pfrom->fWhitelisted)\n+                if (send && connman.OutboundTargetReached(true) && ( ((pindexBestHeader != nullptr) && (pindexBestHeader->GetBlockTime() - mi->second->GetBlockTime() > nOneWeek)) || inv.type == MSG_FILTERED_BLOCK) && !pfrom->fWhitelisted)\n                 {\n                     LogPrint(BCLog::NET, \"historical block serving limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n \n@@ -1723,7 +1723,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         }\n \n         CNodeState *nodestate = State(pfrom->GetId());\n-        const CBlockIndex* pindex = NULL;\n+        const CBlockIndex* pindex = nullptr;\n         if (locator.IsNull())\n         {\n             // If locator is null, return the hashStop block\n@@ -1750,7 +1750,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             if (--nLimit <= 0 || pindex->GetBlockHash() == hashStop)\n                 break;\n         }\n-        // pindex can be NULL either if we sent chainActive.Tip() OR\n+        // pindex can be nullptr either if we sent chainActive.Tip() OR\n         // if our peer has chainActive.Tip() (and thus we are sending an empty\n         // headers message). In both cases it's safe to update\n         // pindexBestHeaderSent to be our tip.\n@@ -1969,7 +1969,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         }\n         }\n \n-        const CBlockIndex *pindex = NULL;\n+        const CBlockIndex *pindex = nullptr;\n         CValidationState state;\n         if (!ProcessNewBlockHeaders({cmpctblock.header}, state, chainparams, &pindex)) {\n             int nDoS;\n@@ -2041,7 +2041,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (pindex->nHeight <= chainActive.Height() + 2) {\n             if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n                  (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {\n-                std::list<QueuedBlock>::iterator* queuedBlockIt = NULL;\n+                std::list<QueuedBlock>::iterator* queuedBlockIt = nullptr;\n                 if (!MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), pindex, &queuedBlockIt)) {\n                     if (!(*queuedBlockIt)->partialBlock)\n                         (*queuedBlockIt)->partialBlock.reset(new PartiallyDownloadedBlock(&mempool));\n@@ -2239,7 +2239,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             return true;\n         }\n \n-        const CBlockIndex *pindexLast = NULL;\n+        const CBlockIndex *pindexLast = nullptr;\n         {\n         LOCK(cs_main);\n         CNodeState *nodestate = State(pfrom->GetId());\n@@ -2744,7 +2744,7 @@ bool ProcessMessages(CNode* pfrom, CConnman& connman, const std::atomic<bool>& i\n     catch (const std::exception& e) {\n         PrintExceptionContinue(&e, \"ProcessMessages()\");\n     } catch (...) {\n-        PrintExceptionContinue(NULL, \"ProcessMessages()\");\n+        PrintExceptionContinue(nullptr, \"ProcessMessages()\");\n     }\n \n     if (!fRet) {\n@@ -2859,7 +2859,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n         }\n \n         // Start block sync\n-        if (pindexBestHeader == NULL)\n+        if (pindexBestHeader == nullptr)\n             pindexBestHeader = chainActive.Tip();\n         bool fFetch = state.fPreferredDownload || (nPreferredDownload == 0 && !pto->fClient && !pto->fOneShot); // Download if this is a nice peer, or we have no nice peers and this one might do.\n         if (!state.fSyncStarted && !pto->fClient && !fImporting && !fReindex) {\n@@ -2907,7 +2907,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             bool fRevertToInv = ((!state.fPreferHeaders &&\n                                  (!state.fPreferHeaderAndIDs || pto->vBlockHashesToAnnounce.size() > 1)) ||\n                                 pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n-            const CBlockIndex *pBestIndex = NULL; // last header queued for delivery\n+            const CBlockIndex *pBestIndex = nullptr; // last header queued for delivery\n             ProcessBlockAvailability(pto->GetId()); // ensure pindexBestKnownBlock is up-to-date\n \n             if (!fRevertToInv) {\n@@ -2924,7 +2924,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                         fRevertToInv = true;\n                         break;\n                     }\n-                    if (pBestIndex != NULL && pindex->pprev != pBestIndex) {\n+                    if (pBestIndex != nullptr && pindex->pprev != pBestIndex) {\n                         // This means that the list of blocks to announce don't\n                         // connect to each other.\n                         // This shouldn't really be possible to hit during\n@@ -2945,7 +2945,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                         vHeaders.push_back(pindex->GetBlockHeader());\n                     } else if (PeerHasHeader(&state, pindex)) {\n                         continue; // keep looking for the first new block\n-                    } else if (pindex->pprev == NULL || PeerHasHeader(&state, pindex->pprev)) {\n+                    } else if (pindex->pprev == nullptr || PeerHasHeader(&state, pindex->pprev)) {\n                         // Peer doesn't have this header but they do have the prior one.\n                         // Start sending headers.\n                         fFoundStartingHeader = true;"
      },
      {
        "sha": "b8a261c921027a7531c8e3b301668d6a301c57e5",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -271,7 +271,7 @@ std::string CNetAddr::ToStringIP() const\n     socklen_t socklen = sizeof(sockaddr);\n     if (serv.GetSockAddr((struct sockaddr*)&sockaddr, &socklen)) {\n         char name[1025] = \"\";\n-        if (!getnameinfo((const struct sockaddr*)&sockaddr, socklen, name, sizeof(name), NULL, 0, NI_NUMERICHOST))\n+        if (!getnameinfo((const struct sockaddr*)&sockaddr, socklen, name, sizeof(name), nullptr, 0, NI_NUMERICHOST))\n             return std::string(name);\n     }\n     if (IsIPv4())\n@@ -407,7 +407,7 @@ static const int NET_UNKNOWN = NET_MAX + 0;\n static const int NET_TEREDO  = NET_MAX + 1;\n int static GetExtNetwork(const CNetAddr *addr)\n {\n-    if (addr == NULL)\n+    if (addr == nullptr)\n         return NET_UNKNOWN;\n     if (addr->IsRFC4380())\n         return NET_TEREDO;"
      },
      {
        "sha": "57ce897db5e523c444b10c39a3402176fdabdd60",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -80,7 +80,7 @@ class CNetAddr\n         uint64_t GetHash() const;\n         bool GetInAddr(struct in_addr* pipv4Addr) const;\n         std::vector<unsigned char> GetGroup() const;\n-        int GetReachabilityFrom(const CNetAddr *paddrPartner = NULL) const;\n+        int GetReachabilityFrom(const CNetAddr *paddrPartner = nullptr) const;\n \n         CNetAddr(const struct in6_addr& pipv6Addr, const uint32_t scope = 0);\n         bool GetIn6Addr(struct in6_addr* pipv6Addr) const;"
      },
      {
        "sha": "05f9f6961c45d884ac8469ec9e013aff91ab7bd4",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -81,13 +81,13 @@ bool static LookupIntern(const char *pszName, std::vector<CNetAddr>& vIP, unsign\n #else\n     aiHint.ai_flags = fAllowLookup ? AI_ADDRCONFIG : AI_NUMERICHOST;\n #endif\n-    struct addrinfo *aiRes = NULL;\n-    int nErr = getaddrinfo(pszName, NULL, &aiHint, &aiRes);\n+    struct addrinfo *aiRes = nullptr;\n+    int nErr = getaddrinfo(pszName, nullptr, &aiHint, &aiRes);\n     if (nErr)\n         return false;\n \n     struct addrinfo *aiTrav = aiRes;\n-    while (aiTrav != NULL && (nMaxSolutions == 0 || vIP.size() < nMaxSolutions))\n+    while (aiTrav != nullptr && (nMaxSolutions == 0 || vIP.size() < nMaxSolutions))\n     {\n         CNetAddr resolved;\n         if (aiTrav->ai_family == AF_INET)\n@@ -227,7 +227,7 @@ static IntrRecvError InterruptibleRecv(char* data, size_t len, int timeout, cons\n                 fd_set fdset;\n                 FD_ZERO(&fdset);\n                 FD_SET(hSocket, &fdset);\n-                int nRet = select(hSocket + 1, &fdset, NULL, NULL, &tval);\n+                int nRet = select(hSocket + 1, &fdset, nullptr, nullptr, &tval);\n                 if (nRet == SOCKET_ERROR) {\n                     return IntrRecvError::NetworkError;\n                 }\n@@ -439,7 +439,7 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n             fd_set fdset;\n             FD_ZERO(&fdset);\n             FD_SET(hSocket, &fdset);\n-            int nRet = select(hSocket + 1, NULL, &fdset, NULL, &timeout);\n+            int nRet = select(hSocket + 1, nullptr, &fdset, nullptr, &timeout);\n             if (nRet == 0)\n             {\n                 LogPrint(BCLog::NET, \"connection to %s timeout\\n\", addrConnect.ToString());\n@@ -642,8 +642,8 @@ std::string NetworkErrorString(int err)\n     char buf[256];\n     buf[0] = 0;\n     if(FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,\n-            NULL, err, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n-            buf, sizeof(buf), NULL))\n+            nullptr, err, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n+            buf, sizeof(buf), nullptr))\n     {\n         return strprintf(\"%s (%d)\", buf, err);\n     }"
      },
      {
        "sha": "7d87c6bbb7dfb72470a12c573fbce9a5c85b11c6",
        "filename": "src/pow.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/pow.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/pow.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -12,7 +12,7 @@\n \n unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHeader *pblock, const Consensus::Params& params)\n {\n-    assert(pindexLast != NULL);\n+    assert(pindexLast != nullptr);\n     unsigned int nProofOfWorkLimit = UintToArith256(params.powLimit).GetCompact();\n \n     // Only change once per difficulty adjustment interval"
      },
      {
        "sha": "f7bde8911a1a1933a07e8dfae6139713a6b5cc0f",
        "filename": "src/prevector.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/prevector.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/prevector.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/prevector.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -448,7 +448,7 @@ class prevector {\n         }\n         if (!is_direct()) {\n             free(_union.indirect);\n-            _union.indirect = NULL;\n+            _union.indirect = nullptr;\n         }\n     }\n "
      },
      {
        "sha": "2da7be783f870706712927f2ad8f8f5f87cb9112",
        "filename": "src/pubkey.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/pubkey.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/pubkey.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -10,7 +10,7 @@\n namespace\n {\n /* Global secp256k1_context object used for verification. */\n-secp256k1_context* secp256k1_context_verify = NULL;\n+secp256k1_context* secp256k1_context_verify = nullptr;\n } // namespace\n \n /** This function is taken from the libsecp256k1 distribution and implements\n@@ -274,17 +274,17 @@ bool CExtPubKey::Derive(CExtPubKey &out, unsigned int _nChild) const {\n     if (!ecdsa_signature_parse_der_lax(secp256k1_context_verify, &sig, vchSig.data(), vchSig.size())) {\n         return false;\n     }\n-    return (!secp256k1_ecdsa_signature_normalize(secp256k1_context_verify, NULL, &sig));\n+    return (!secp256k1_ecdsa_signature_normalize(secp256k1_context_verify, nullptr, &sig));\n }\n \n /* static */ int ECCVerifyHandle::refcount = 0;\n \n ECCVerifyHandle::ECCVerifyHandle()\n {\n     if (refcount == 0) {\n-        assert(secp256k1_context_verify == NULL);\n+        assert(secp256k1_context_verify == nullptr);\n         secp256k1_context_verify = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n-        assert(secp256k1_context_verify != NULL);\n+        assert(secp256k1_context_verify != nullptr);\n     }\n     refcount++;\n }\n@@ -293,8 +293,8 @@ ECCVerifyHandle::~ECCVerifyHandle()\n {\n     refcount--;\n     if (refcount == 0) {\n-        assert(secp256k1_context_verify != NULL);\n+        assert(secp256k1_context_verify != nullptr);\n         secp256k1_context_destroy(secp256k1_context_verify);\n-        secp256k1_context_verify = NULL;\n+        secp256k1_context_verify = nullptr;\n     }\n }"
      },
      {
        "sha": "f295bd468957cdfb914e9932481973767b189f9f",
        "filename": "src/qt/addressbookpage.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/addressbookpage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/addressbookpage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addressbookpage.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -273,7 +273,7 @@ void AddressBookPage::on_exportButton_clicked()\n     // CSV is currently the only supported format\n     QString filename = GUIUtil::getSaveFileName(this,\n         tr(\"Export Address List\"), QString(),\n-        tr(\"Comma separated file (*.csv)\"), NULL);\n+        tr(\"Comma separated file (*.csv)\"), nullptr);\n \n     if (filename.isNull())\n         return;"
      },
      {
        "sha": "b6cfdf888752017283248a61206ac7200e7c0e5d",
        "filename": "src/qt/bitcoin.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -305,7 +305,7 @@ void BitcoinCore::initialize()\n     } catch (const std::exception& e) {\n         handleRunawayException(&e);\n     } catch (...) {\n-        handleRunawayException(NULL);\n+        handleRunawayException(nullptr);\n     }\n }\n \n@@ -322,7 +322,7 @@ void BitcoinCore::shutdown()\n     } catch (const std::exception& e) {\n         handleRunawayException(&e);\n     } catch (...) {\n-        handleRunawayException(NULL);\n+        handleRunawayException(nullptr);\n     }\n }\n \n@@ -383,7 +383,7 @@ void BitcoinApplication::createPaymentServer()\n \n void BitcoinApplication::createOptionsModel(bool resetSettings)\n {\n-    optionsModel = new OptionsModel(NULL, resetSettings);\n+    optionsModel = new OptionsModel(nullptr, resetSettings);\n }\n \n void BitcoinApplication::createWindow(const NetworkStyle *networkStyle)\n@@ -608,7 +608,7 @@ int main(int argc, char *argv[])\n     // but before showing splash screen.\n     if (IsArgSet(\"-?\") || IsArgSet(\"-h\") || IsArgSet(\"-help\") || IsArgSet(\"-version\"))\n     {\n-        HelpMessageDialog help(NULL, IsArgSet(\"-version\"));\n+        HelpMessageDialog help(nullptr, IsArgSet(\"-version\"));\n         help.showOrPrint();\n         return EXIT_SUCCESS;\n     }\n@@ -723,7 +723,7 @@ int main(int argc, char *argv[])\n         PrintExceptionContinue(&e, \"Runaway exception\");\n         app.handleRunawayException(QString::fromStdString(GetWarnings(\"gui\")));\n     } catch (...) {\n-        PrintExceptionContinue(NULL, \"Runaway exception\");\n+        PrintExceptionContinue(nullptr, \"Runaway exception\");\n         app.handleRunawayException(QString::fromStdString(GetWarnings(\"gui\")));\n     }\n     return rv;"
      },
      {
        "sha": "e3970298e61d9d573ca97cc93121c3e666756a1a",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -479,7 +479,7 @@ void BitcoinGUI::setClientModel(ClientModel *_clientModel)\n         connect(_clientModel, SIGNAL(networkActiveChanged(bool)), this, SLOT(setNetworkActive(bool)));\n \n         modalOverlay->setKnownBestHeight(_clientModel->getHeaderTipHeight(), QDateTime::fromTime_t(_clientModel->getHeaderTipTime()));\n-        setNumBlocks(_clientModel->getNumBlocks(), _clientModel->getLastBlockDate(), _clientModel->getVerificationProgress(NULL), false);\n+        setNumBlocks(_clientModel->getNumBlocks(), _clientModel->getLastBlockDate(), _clientModel->getVerificationProgress(nullptr), false);\n         connect(_clientModel, SIGNAL(numBlocksChanged(int,QDateTime,double,bool)), this, SLOT(setNumBlocks(int,QDateTime,double,bool)));\n \n         // Receive and report messages from client model\n@@ -922,7 +922,7 @@ void BitcoinGUI::message(const QString &title, const QString &message, unsigned\n         showNormalIfMinimized();\n         QMessageBox mBox((QMessageBox::Icon)nMBoxIcon, strTitle, message, buttons, this);\n         int r = mBox.exec();\n-        if (ret != NULL)\n+        if (ret != nullptr)\n             *ret = r == QMessageBox::Ok;\n     }\n     else"
      },
      {
        "sha": "aa45ea1f0a0a7a0bc5c0183520664fc8ac4a6ea1",
        "filename": "src/qt/bitcoingui.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/bitcoingui.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/bitcoingui.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -168,7 +168,7 @@ public Q_SLOTS:\n                             @see CClientUIInterface::MessageBoxFlags\n        @param[in] ret       pointer to a bool that will be modified to whether Ok was clicked (modal only)\n     */\n-    void message(const QString &title, const QString &message, unsigned int style, bool *ret = NULL);\n+    void message(const QString &title, const QString &message, unsigned int style, bool *ret = nullptr);\n \n #ifdef ENABLE_WALLET\n     /** Set the encryption status as shown in the UI."
      },
      {
        "sha": "28ffda9981c670fde60e6b973688b987cac05707",
        "filename": "src/qt/guiutil.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/guiutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/guiutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -634,19 +634,19 @@ bool SetStartOnSystemStartup(bool fAutoStart)\n \n     if (fAutoStart)\n     {\n-        CoInitialize(NULL);\n+        CoInitialize(nullptr);\n \n         // Get a pointer to the IShellLink interface.\n-        IShellLink* psl = NULL;\n-        HRESULT hres = CoCreateInstance(CLSID_ShellLink, NULL,\n+        IShellLink* psl = nullptr;\n+        HRESULT hres = CoCreateInstance(CLSID_ShellLink, nullptr,\n             CLSCTX_INPROC_SERVER, IID_IShellLink,\n             reinterpret_cast<void**>(&psl));\n \n         if (SUCCEEDED(hres))\n         {\n             // Get the current executable path\n             TCHAR pszExePath[MAX_PATH];\n-            GetModuleFileName(NULL, pszExePath, sizeof(pszExePath));\n+            GetModuleFileName(nullptr, pszExePath, sizeof(pszExePath));\n \n             // Start client minimized\n             QString strArgs = \"-min\";\n@@ -674,7 +674,7 @@ bool SetStartOnSystemStartup(bool fAutoStart)\n \n             // Query IShellLink for the IPersistFile interface for\n             // saving the shortcut in persistent storage.\n-            IPersistFile* ppf = NULL;\n+            IPersistFile* ppf = nullptr;\n             hres = psl->QueryInterface(IID_IPersistFile, reinterpret_cast<void**>(&ppf));\n             if (SUCCEEDED(hres))\n             {\n@@ -781,21 +781,21 @@ LSSharedFileListItemRef findStartupItemInList(LSSharedFileListRef list, CFURLRef\n LSSharedFileListItemRef findStartupItemInList(LSSharedFileListRef list, CFURLRef findUrl)\n {\n     // loop through the list of startup items and try to find the bitcoin app\n-    CFArrayRef listSnapshot = LSSharedFileListCopySnapshot(list, NULL);\n+    CFArrayRef listSnapshot = LSSharedFileListCopySnapshot(list, nullptr);\n     for(int i = 0; i < CFArrayGetCount(listSnapshot); i++) {\n         LSSharedFileListItemRef item = (LSSharedFileListItemRef)CFArrayGetValueAtIndex(listSnapshot, i);\n         UInt32 resolutionFlags = kLSSharedFileListNoUserInteraction | kLSSharedFileListDoNotMountVolumes;\n-        CFURLRef currentItemURL = NULL;\n+        CFURLRef currentItemURL = nullptr;\n \n #if defined(MAC_OS_X_VERSION_MAX_ALLOWED) && MAC_OS_X_VERSION_MAX_ALLOWED >= 10100\n     if(&LSSharedFileListItemCopyResolvedURL)\n-        currentItemURL = LSSharedFileListItemCopyResolvedURL(item, resolutionFlags, NULL);\n+        currentItemURL = LSSharedFileListItemCopyResolvedURL(item, resolutionFlags, nullptr);\n #if defined(MAC_OS_X_VERSION_MIN_REQUIRED) && MAC_OS_X_VERSION_MIN_REQUIRED < 10100\n     else\n-        LSSharedFileListItemResolve(item, resolutionFlags, &currentItemURL, NULL);\n+        LSSharedFileListItemResolve(item, resolutionFlags, &currentItemURL, nullptr);\n #endif\n #else\n-    LSSharedFileListItemResolve(item, resolutionFlags, &currentItemURL, NULL);\n+    LSSharedFileListItemResolve(item, resolutionFlags, &currentItemURL, nullptr);\n #endif\n \n         if(currentItemURL && CFEqual(currentItemURL, findUrl)) {\n@@ -807,26 +807,26 @@ LSSharedFileListItemRef findStartupItemInList(LSSharedFileListRef list, CFURLRef\n             CFRelease(currentItemURL);\n         }\n     }\n-    return NULL;\n+    return nullptr;\n }\n \n bool GetStartOnSystemStartup()\n {\n     CFURLRef bitcoinAppUrl = CFBundleCopyBundleURL(CFBundleGetMainBundle());\n-    LSSharedFileListRef loginItems = LSSharedFileListCreate(NULL, kLSSharedFileListSessionLoginItems, NULL);\n+    LSSharedFileListRef loginItems = LSSharedFileListCreate(nullptr, kLSSharedFileListSessionLoginItems, nullptr);\n     LSSharedFileListItemRef foundItem = findStartupItemInList(loginItems, bitcoinAppUrl);\n     return !!foundItem; // return boolified object\n }\n \n bool SetStartOnSystemStartup(bool fAutoStart)\n {\n     CFURLRef bitcoinAppUrl = CFBundleCopyBundleURL(CFBundleGetMainBundle());\n-    LSSharedFileListRef loginItems = LSSharedFileListCreate(NULL, kLSSharedFileListSessionLoginItems, NULL);\n+    LSSharedFileListRef loginItems = LSSharedFileListCreate(nullptr, kLSSharedFileListSessionLoginItems, nullptr);\n     LSSharedFileListItemRef foundItem = findStartupItemInList(loginItems, bitcoinAppUrl);\n \n     if(fAutoStart && !foundItem) {\n         // add bitcoin app to startup item list\n-        LSSharedFileListInsertItemURL(loginItems, kLSSharedFileListItemBeforeFirst, NULL, NULL, bitcoinAppUrl, NULL, NULL);\n+        LSSharedFileListInsertItemURL(loginItems, kLSSharedFileListItemBeforeFirst, nullptr, nullptr, bitcoinAppUrl, nullptr, nullptr);\n     }\n     else if(!fAutoStart && foundItem) {\n         // remove item"
      },
      {
        "sha": "3ee656d4703b15822f988f29e38a7add2bd504fc",
        "filename": "src/qt/openuridialog.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/openuridialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/openuridialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/openuridialog.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -44,7 +44,7 @@ void OpenURIDialog::accept()\n \n void OpenURIDialog::on_selectFileButton_clicked()\n {\n-    QString filename = GUIUtil::getOpenFileName(this, tr(\"Select payment request file to open\"), \"\", \"\", NULL);\n+    QString filename = GUIUtil::getOpenFileName(this, tr(\"Select payment request file to open\"), \"\", \"\", nullptr);\n     if(filename.isEmpty())\n         return;\n     QUrl fileUri = QUrl::fromLocalFile(filename);"
      },
      {
        "sha": "897762b1a7397d87c1a7168647ed635003a766bd",
        "filename": "src/qt/paymentrequestplus.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/paymentrequestplus.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/paymentrequestplus.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentrequestplus.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -66,7 +66,7 @@ bool PaymentRequestPlus::getMerchant(X509_STORE* certStore, QString& merchant) c\n \n     // One day we'll support more PKI types, but just\n     // x509 for now:\n-    const EVP_MD* digestAlgorithm = NULL;\n+    const EVP_MD* digestAlgorithm = nullptr;\n     if (paymentRequest.pki_type() == \"x509+sha256\") {\n         digestAlgorithm = EVP_sha256();\n     }\n@@ -104,7 +104,7 @@ bool PaymentRequestPlus::getMerchant(X509_STORE* certStore, QString& merchant) c\n         }\n #endif\n         const unsigned char *data = (const unsigned char *)certChain.certificate(i).data();\n-        X509 *cert = d2i_X509(NULL, &data, certChain.certificate(i).size());\n+        X509 *cert = d2i_X509(nullptr, &data, certChain.certificate(i).size());\n         if (cert)\n             certs.push_back(cert);\n     }\n@@ -129,7 +129,7 @@ bool PaymentRequestPlus::getMerchant(X509_STORE* certStore, QString& merchant) c\n         return false;\n     }\n \n-    char *website = NULL;\n+    char *website = nullptr;\n     bool fResult = true;\n     try\n     {\n@@ -169,7 +169,7 @@ bool PaymentRequestPlus::getMerchant(X509_STORE* certStore, QString& merchant) c\n #endif\n         EVP_PKEY *pubkey = X509_get_pubkey(signing_cert);\n         EVP_MD_CTX_init(ctx);\n-        if (!EVP_VerifyInit_ex(ctx, digestAlgorithm, NULL) ||\n+        if (!EVP_VerifyInit_ex(ctx, digestAlgorithm, nullptr) ||\n             !EVP_VerifyUpdate(ctx, data_to_verify.data(), data_to_verify.size()) ||\n             !EVP_VerifyFinal(ctx, (const unsigned char*)paymentRequest.signature().data(), (unsigned int)paymentRequest.signature().size(), pubkey)) {\n             throw SSLVerifyError(\"Bad signature, invalid payment request.\");\n@@ -179,7 +179,7 @@ bool PaymentRequestPlus::getMerchant(X509_STORE* certStore, QString& merchant) c\n #endif\n \n         // OpenSSL API for getting human printable strings from certs is baroque.\n-        int textlen = X509_NAME_get_text_by_NID(certname, NID_commonName, NULL, 0);\n+        int textlen = X509_NAME_get_text_by_NID(certname, NID_commonName, nullptr, 0);\n         website = new char[textlen + 1];\n         if (X509_NAME_get_text_by_NID(certname, NID_commonName, website, textlen + 1) == textlen && textlen > 0) {\n             merchant = website;"
      },
      {
        "sha": "c5e2b78c54d89fadb6603a215d47fcc1730dafe8",
        "filename": "src/qt/paymentserver.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/paymentserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/paymentserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentserver.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -274,7 +274,7 @@ bool PaymentServer::ipcSendCommandLine()\n         if (!socket->waitForConnected(BITCOIN_IPC_CONNECT_TIMEOUT))\n         {\n             delete socket;\n-            socket = NULL;\n+            socket = nullptr;\n             return false;\n         }\n \n@@ -290,7 +290,7 @@ bool PaymentServer::ipcSendCommandLine()\n         socket->disconnectFromServer();\n \n         delete socket;\n-        socket = NULL;\n+        socket = nullptr;\n         fResult = true;\n     }\n \n@@ -364,7 +364,7 @@ void PaymentServer::initNetManager()\n {\n     if (!optionsModel)\n         return;\n-    if (netManager != NULL)\n+    if (netManager != nullptr)\n         delete netManager;\n \n     // netManager is used to fetch paymentrequests given in bitcoin: URIs"
      },
      {
        "sha": "2fe6e3e7b1d7a20667d70be4dda8897ba7aebc85",
        "filename": "src/qt/paymentserver.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/paymentserver.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/paymentserver.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentserver.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -75,12 +75,12 @@ class PaymentServer : public QObject\n     PaymentServer(QObject* parent, bool startLocalServer = true);\n     ~PaymentServer();\n \n-    // Load root certificate authorities. Pass NULL (default)\n+    // Load root certificate authorities. Pass nullptr (default)\n     // to read from the file specified in the -rootcertificates setting,\n     // or, if that's not set, to use the system default root certificates.\n     // If you pass in a store, you should not X509_STORE_free it: it will be\n     // freed either at exit or when another set of CAs are loaded.\n-    static void LoadRootCAs(X509_STORE* store = NULL);\n+    static void LoadRootCAs(X509_STORE* store = nullptr);\n \n     // Return certificate store\n     static X509_STORE* getCertStore();"
      },
      {
        "sha": "4aa6375d8a1230cce9b82ff6830fca5e3df5143b",
        "filename": "src/qt/receiverequestdialog.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/receiverequestdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/receiverequestdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/receiverequestdialog.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -68,7 +68,7 @@ void QRImageWidget::saveImage()\n {\n     if(!pixmap())\n         return;\n-    QString fn = GUIUtil::getSaveFileName(this, tr(\"Save QR Code\"), QString(), tr(\"PNG Image (*.png)\"), NULL);\n+    QString fn = GUIUtil::getSaveFileName(this, tr(\"Save QR Code\"), QString(), tr(\"PNG Image (*.png)\"), nullptr);\n     if (!fn.isEmpty())\n     {\n         exportImage().save(fn);"
      },
      {
        "sha": "1c4f7aca86322ec424877f20fcf3488127ca1239",
        "filename": "src/qt/recentrequeststablemodel.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/recentrequeststablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/recentrequeststablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/recentrequeststablemodel.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -123,7 +123,7 @@ void RecentRequestsTableModel::updateAmountColumnTitle()\n /** Gets title for amount column including current display unit if optionsModel reference available. */\n QString RecentRequestsTableModel::getAmountTitle()\n {\n-    return (this->walletModel->getOptionsModel() != NULL) ? tr(\"Requested\") + \" (\"+BitcoinUnits::name(this->walletModel->getOptionsModel()->getDisplayUnit()) + \")\" : \"\";\n+    return (this->walletModel->getOptionsModel() != nullptr) ? tr(\"Requested\") + \" (\"+BitcoinUnits::name(this->walletModel->getOptionsModel()->getDisplayUnit()) + \")\" : \"\";\n }\n \n QModelIndex RecentRequestsTableModel::index(int row, int column, const QModelIndex &parent) const"
      },
      {
        "sha": "3590a98efac1893ebb89a489e147f38e3801d39c",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -60,7 +60,7 @@ const struct {\n     {\"cmd-reply\", \":/icons/tx_output\"},\n     {\"cmd-error\", \":/icons/tx_output\"},\n     {\"misc\", \":/icons/tx_inout\"},\n-    {NULL, NULL}\n+    {nullptr, nullptr}\n };\n \n namespace {\n@@ -532,7 +532,7 @@ void RPCConsole::setClientModel(ClientModel *model)\n         setNumConnections(model->getNumConnections());\n         connect(model, SIGNAL(numConnectionsChanged(int)), this, SLOT(setNumConnections(int)));\n \n-        setNumBlocks(model->getNumBlocks(), model->getLastBlockDate(), model->getVerificationProgress(NULL), false);\n+        setNumBlocks(model->getNumBlocks(), model->getLastBlockDate(), model->getVerificationProgress(nullptr), false);\n         connect(model, SIGNAL(numBlocksChanged(int,QDateTime,double,bool)), this, SLOT(setNumBlocks(int,QDateTime,double,bool)));\n \n         updateNetworkState();\n@@ -982,7 +982,7 @@ void RPCConsole::peerLayoutChanged()\n     if (!clientModel || !clientModel->getPeerTableModel())\n         return;\n \n-    const CNodeCombinedStats *stats = NULL;\n+    const CNodeCombinedStats *stats = nullptr;\n     bool fUnselect = false;\n     bool fReselect = false;\n "
      },
      {
        "sha": "da06818f877c81a7d64387fff54c17ce8d481856",
        "filename": "src/qt/rpcconsole.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/rpcconsole.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/rpcconsole.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -36,8 +36,8 @@ class RPCConsole: public QWidget\n     explicit RPCConsole(const PlatformStyle *platformStyle, QWidget *parent);\n     ~RPCConsole();\n \n-    static bool RPCParseCommandLine(std::string &strResult, const std::string &strCommand, bool fExecute, std::string * const pstrFilteredOut = NULL);\n-    static bool RPCExecuteCommandLine(std::string &strResult, const std::string &strCommand, std::string * const pstrFilteredOut = NULL) {\n+    static bool RPCParseCommandLine(std::string &strResult, const std::string &strCommand, bool fExecute, std::string * const pstrFilteredOut = nullptr);\n+    static bool RPCExecuteCommandLine(std::string &strResult, const std::string &strCommand, std::string * const pstrFilteredOut = nullptr) {\n         return RPCParseCommandLine(strResult, strCommand, true, pstrFilteredOut);\n     }\n "
      },
      {
        "sha": "d9fb8698212bd88bd8efd484541d0bace2173eb3",
        "filename": "src/qt/test/paymentservertests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/test/paymentservertests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/test/paymentservertests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/paymentservertests.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -25,7 +25,7 @@ X509 *parse_b64der_cert(const char* cert_data)\n     std::vector<unsigned char> data = DecodeBase64(cert_data);\n     assert(data.size() > 0);\n     const unsigned char* dptr = &data[0];\n-    X509 *cert = d2i_X509(NULL, &dptr, data.size());\n+    X509 *cert = d2i_X509(nullptr, &dptr, data.size());\n     assert(cert);\n     return cert;\n }\n@@ -66,7 +66,7 @@ void PaymentServerTests::paymentServerTests()\n {\n     SelectParams(CBaseChainParams::MAIN);\n     OptionsModel optionsModel;\n-    PaymentServer* server = new PaymentServer(NULL, false);\n+    PaymentServer* server = new PaymentServer(nullptr, false);\n     X509_STORE* caStore = X509_STORE_new();\n     X509_STORE_add_cert(caStore, parse_b64der_cert(caCert1_BASE64));\n     PaymentServer::LoadRootCAs(caStore);"
      },
      {
        "sha": "2ece0d0f289bb500c686dd02282c405ec837de4b",
        "filename": "src/qt/transactionrecord.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/transactionrecord.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/transactionrecord.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -167,7 +167,7 @@ void TransactionRecord::updateStatus(const CWalletTx &wtx)\n     // Determine transaction status\n \n     // Find the block the tx is in\n-    CBlockIndex* pindex = NULL;\n+    CBlockIndex* pindex = nullptr;\n     BlockMap::iterator mi = mapBlockIndex.find(wtx.hashBlock);\n     if (mi != mapBlockIndex.end())\n         pindex = (*mi).second;"
      },
      {
        "sha": "53c38da9db3d3bc41d9cfa11f7c12feb7df070f9",
        "filename": "src/qt/transactionview.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/transactionview.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/transactionview.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionview.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -343,7 +343,7 @@ void TransactionView::exportClicked()\n     // CSV is currently the only supported format\n     QString filename = GUIUtil::getSaveFileName(this,\n         tr(\"Export Transaction History\"), QString(),\n-        tr(\"Comma separated file (*.csv)\"), NULL);\n+        tr(\"Comma separated file (*.csv)\"), nullptr);\n \n     if (filename.isNull())\n         return;"
      },
      {
        "sha": "6be36a57e2563fc8fec43892783cd74ea9352bfe",
        "filename": "src/qt/walletmodel.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/walletmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/walletmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -129,7 +129,7 @@ class WalletModel : public QObject\n     TransactionTableModel *getTransactionTableModel();\n     RecentRequestsTableModel *getRecentRequestsTableModel();\n \n-    CAmount getBalance(const CCoinControl *coinControl = NULL) const;\n+    CAmount getBalance(const CCoinControl *coinControl = nullptr) const;\n     CAmount getUnconfirmedBalance() const;\n     CAmount getImmatureBalance() const;\n     bool haveWatchOnly() const;"
      },
      {
        "sha": "971f5e0e1a7e8d0a7f6895ed4f6db2732505c7c0",
        "filename": "src/qt/walletview.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/walletview.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/walletview.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletview.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -246,7 +246,7 @@ void WalletView::backupWallet()\n {\n     QString filename = GUIUtil::getSaveFileName(this,\n         tr(\"Backup Wallet\"), QString(),\n-        tr(\"Wallet Data (*.dat)\"), NULL);\n+        tr(\"Wallet Data (*.dat)\"), nullptr);\n \n     if (filename.isEmpty())\n         return;"
      },
      {
        "sha": "d78d9a2358ac2e48640a942cc661dd1e2593e04a",
        "filename": "src/qt/winshutdownmonitor.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/winshutdownmonitor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/qt/winshutdownmonitor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/winshutdownmonitor.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -57,7 +57,7 @@ void WinShutdownMonitor::registerShutdownBlockReason(const QString& strReason, c\n {\n     typedef BOOL (WINAPI *PSHUTDOWNBRCREATE)(HWND, LPCWSTR);\n     PSHUTDOWNBRCREATE shutdownBRCreate = (PSHUTDOWNBRCREATE)GetProcAddress(GetModuleHandleA(\"User32.dll\"), \"ShutdownBlockReasonCreate\");\n-    if (shutdownBRCreate == NULL) {\n+    if (shutdownBRCreate == nullptr) {\n         qWarning() << \"registerShutdownBlockReason: GetProcAddress for ShutdownBlockReasonCreate failed\";\n         return;\n     }"
      },
      {
        "sha": "3a48c72b682a3e1b3a38a7e87d5f79ea27961bd2",
        "filename": "src/random.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/random.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/random.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/random.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -152,7 +152,7 @@ static void RandAddSeedPerfmon()\n     const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n     while (true) {\n         nSize = vData.size();\n-        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", NULL, NULL, vData.data(), &nSize);\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", nullptr, nullptr, vData.data(), &nSize);\n         if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n             break;\n         vData.resize(std::max((vData.size() * 3) / 2, nMaxSize)); // Grow size of buffer exponentially\n@@ -200,7 +200,7 @@ void GetOSRand(unsigned char *ent32)\n {\n #if defined(WIN32)\n     HCRYPTPROV hProvider;\n-    int ret = CryptAcquireContextW(&hProvider, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT);\n+    int ret = CryptAcquireContextW(&hProvider, nullptr, nullptr, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT);\n     if (!ret) {\n         RandFailure();\n     }\n@@ -245,7 +245,7 @@ void GetOSRand(unsigned char *ent32)\n     int have = 0;\n     do {\n         size_t len = NUM_OS_RANDOM_BYTES - have;\n-        if (sysctl(name, ARRAYLEN(name), ent32 + have, &len, NULL, 0) != 0) {\n+        if (sysctl(name, ARRAYLEN(name), ent32 + have, &len, nullptr, 0) != 0) {\n             RandFailure();\n         }\n         have += len;"
      },
      {
        "sha": "6a4b005f9085244290f60010f99d7e01da52ed78",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -134,7 +134,7 @@ static bool rest_headers(HTTPRequest* req,\n     if (path.size() != 2)\n         return RESTERR(req, HTTP_BAD_REQUEST, \"No header count specified. Use /rest/headers/<count>/<hash>.<ext>.\");\n \n-    long count = strtol(path[0].c_str(), NULL, 10);\n+    long count = strtol(path[0].c_str(), nullptr, 10);\n     if (count < 1 || count > 2000)\n         return RESTERR(req, HTTP_BAD_REQUEST, \"Header count out of range: \" + path[0]);\n \n@@ -148,8 +148,8 @@ static bool rest_headers(HTTPRequest* req,\n     {\n         LOCK(cs_main);\n         BlockMap::const_iterator it = mapBlockIndex.find(hash);\n-        const CBlockIndex *pindex = (it != mapBlockIndex.end()) ? it->second : NULL;\n-        while (pindex != NULL && chainActive.Contains(pindex)) {\n+        const CBlockIndex *pindex = (it != mapBlockIndex.end()) ? it->second : nullptr;\n+        while (pindex != nullptr && chainActive.Contains(pindex)) {\n             headers.push_back(pindex);\n             if (headers.size() == (unsigned long)count)\n                 break;\n@@ -209,7 +209,7 @@ static bool rest_block(HTTPRequest* req,\n         return RESTERR(req, HTTP_BAD_REQUEST, \"Invalid hash: \" + hashStr);\n \n     CBlock block;\n-    CBlockIndex* pblockindex = NULL;\n+    CBlockIndex* pblockindex = nullptr;\n     {\n         LOCK(cs_main);\n         if (mapBlockIndex.count(hash) == 0)"
      },
      {
        "sha": "6975d26c69699c5a2c37a697eaa2e08d2e064507",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -48,9 +48,9 @@ extern void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue&\n \n double GetDifficulty(const CBlockIndex* blockindex)\n {\n-    if (blockindex == NULL)\n+    if (blockindex == nullptr)\n     {\n-        if (chainActive.Tip() == NULL)\n+        if (chainActive.Tip() == nullptr)\n             return 1.0;\n         else\n             blockindex = chainActive.Tip();"
      },
      {
        "sha": "f498b5c8ea87b48daf312465f49bb4608def9683",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -52,7 +52,7 @@ UniValue GetNetworkHashPS(int lookup, int height) {\n     if (height >= 0 && height < chainActive.Height())\n         pb = chainActive[height];\n \n-    if (pb == NULL || !pb->nHeight)\n+    if (pb == nullptr || !pb->nHeight)\n         return 0;\n \n     // If lookup is -1, then use blocks since last difficulty change.\n@@ -139,7 +139,7 @@ UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbaseScript, int nGen\n             continue;\n         }\n         std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(*pblock);\n-        if (!ProcessNewBlock(Params(), shared_pblock, true, NULL))\n+        if (!ProcessNewBlock(Params(), shared_pblock, true, nullptr))\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"ProcessNewBlock, block not accepted\");\n         ++nHeight;\n         blockHashes.push_back(pblock->GetHash().GetHex());\n@@ -754,7 +754,7 @@ UniValue submitblock(const JSONRPCRequest& request)\n \n     submitblock_StateCatcher sc(block.GetHash());\n     RegisterValidationInterface(&sc);\n-    bool fAccepted = ProcessNewBlock(Params(), blockptr, true, NULL);\n+    bool fAccepted = ProcessNewBlock(Params(), blockptr, true, nullptr);\n     UnregisterValidationInterface(&sc);\n     if (fBlockPresent) {\n         if (fAccepted && !sc.found) {"
      },
      {
        "sha": "08920915ae9b307e9fe0dd956508b67fdf866977",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -77,7 +77,7 @@ UniValue getinfo(const JSONRPCRequest& request)\n #ifdef ENABLE_WALLET\n     CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n \n-    LOCK2(cs_main, pwallet ? &pwallet->cs_wallet : NULL);\n+    LOCK2(cs_main, pwallet ? &pwallet->cs_wallet : nullptr);\n #else\n     LOCK(cs_main);\n #endif\n@@ -201,7 +201,7 @@ UniValue validateaddress(const JSONRPCRequest& request)\n #ifdef ENABLE_WALLET\n     CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n \n-    LOCK2(cs_main, pwallet ? &pwallet->cs_wallet : NULL);\n+    LOCK2(cs_main, pwallet ? &pwallet->cs_wallet : nullptr);\n #else\n     LOCK(cs_main);\n #endif\n@@ -321,7 +321,7 @@ UniValue createmultisig(const JSONRPCRequest& request)\n #ifdef ENABLE_WALLET\n     CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n #else\n-    CWallet * const pwallet = NULL;\n+    CWallet * const pwallet = nullptr;\n #endif\n \n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 2)"
      },
      {
        "sha": "e890f0ddcd127f3265c314650cdcbbb1c2d6fee4",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -216,7 +216,7 @@ UniValue addnode(const JSONRPCRequest& request)\n     if (strCommand == \"onetry\")\n     {\n         CAddress addr;\n-        g_connman->OpenNetworkConnection(addr, false, NULL, strNode.c_str());\n+        g_connman->OpenNetworkConnection(addr, false, nullptr, strNode.c_str());\n         return NullUniValue;\n     }\n "
      },
      {
        "sha": "81005118541a8bda2412bed4bc7491453fd45543",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -208,7 +208,7 @@ UniValue gettxoutproof(const JSONRPCRequest& request)\n \n     LOCK(cs_main);\n \n-    CBlockIndex* pblockindex = NULL;\n+    CBlockIndex* pblockindex = nullptr;\n \n     uint256 hashBlock;\n     if (!request.params[1].isNull())\n@@ -228,7 +228,7 @@ UniValue gettxoutproof(const JSONRPCRequest& request)\n         }\n     }\n \n-    if (pblockindex == NULL)\n+    if (pblockindex == nullptr)\n     {\n         CTransactionRef tx;\n         if (!GetTransaction(oneTxid, tx, Params().GetConsensus(), hashBlock, false) || hashBlock.IsNull())\n@@ -707,7 +707,7 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n         );\n \n #ifdef ENABLE_WALLET\n-    LOCK2(cs_main, pwallet ? &pwallet->cs_wallet : NULL);\n+    LOCK2(cs_main, pwallet ? &pwallet->cs_wallet : nullptr);\n #else\n     LOCK(cs_main);\n #endif\n@@ -937,7 +937,7 @@ UniValue sendrawtransaction(const JSONRPCRequest& request)\n         CValidationState state;\n         bool fMissingInputs;\n         bool fLimitFree = true;\n-        if (!AcceptToMemoryPool(mempool, state, std::move(tx), fLimitFree, &fMissingInputs, NULL, false, nMaxRawTxFee)) {\n+        if (!AcceptToMemoryPool(mempool, state, std::move(tx), fLimitFree, &fMissingInputs, nullptr, false, nMaxRawTxFee)) {\n             if (state.IsInvalid()) {\n                 throw JSONRPCError(RPC_TRANSACTION_REJECTED, strprintf(\"%i: %s\", state.GetRejectCode(), state.GetRejectReason()));\n             } else {"
      },
      {
        "sha": "c3c9d10e2a97a8fcc548629a60b3893619a24cf0",
        "filename": "src/rpc/server.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/rpc/server.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/rpc/server.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -30,7 +30,7 @@ static bool fRPCInWarmup = true;\n static std::string rpcWarmupStatus(\"RPC server started\");\n static CCriticalSection cs_rpcWarmup;\n /* Timer-creating functions */\n-static RPCTimerInterface* timerInterface = NULL;\n+static RPCTimerInterface* timerInterface = nullptr;\n /* Map of name to timer. */\n static std::map<std::string, std::unique_ptr<RPCTimerBase> > deadlineTimers;\n \n@@ -301,7 +301,7 @@ const CRPCCommand *CRPCTable::operator[](const std::string &name) const\n {\n     std::map<std::string, const CRPCCommand*>::const_iterator it = mapCommands.find(name);\n     if (it == mapCommands.end())\n-        return NULL;\n+        return nullptr;\n     return (*it).second;\n }\n \n@@ -547,7 +547,7 @@ void RPCSetTimerInterface(RPCTimerInterface *iface)\n void RPCUnsetTimerInterface(RPCTimerInterface *iface)\n {\n     if (timerInterface == iface)\n-        timerInterface = NULL;\n+        timerInterface = nullptr;\n }\n \n void RPCRunLater(const std::string& name, std::function<void(void)> func, int64_t nSeconds)"
      },
      {
        "sha": "03128917fd8fdf676faa77d5acc192f0f87fd33b",
        "filename": "src/script/bitcoinconsensus.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/script/bitcoinconsensus.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/script/bitcoinconsensus.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/bitcoinconsensus.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -28,10 +28,10 @@ class TxInputStream\n         if (nSize > m_remaining)\n             throw std::ios_base::failure(std::string(__func__) + \": end of data\");\n \n-        if (pch == NULL)\n+        if (pch == nullptr)\n             throw std::ios_base::failure(std::string(__func__) + \": bad destination buffer\");\n \n-        if (m_data == NULL)\n+        if (m_data == nullptr)\n             throw std::ios_base::failure(std::string(__func__) + \": bad source buffer\");\n \n         memcpy(pch, m_data, nSize);\n@@ -95,7 +95,7 @@ static int verify_script(const unsigned char *scriptPubKey, unsigned int scriptP\n         set_error(err, bitcoinconsensus_ERR_OK);\n \n         PrecomputedTransactionData txdata(tx);\n-        return VerifyScript(tx.vin[nIn].scriptSig, CScript(scriptPubKey, scriptPubKey + scriptPubKeyLen), &tx.vin[nIn].scriptWitness, flags, TransactionSignatureChecker(&tx, nIn, amount, txdata), NULL);\n+        return VerifyScript(tx.vin[nIn].scriptSig, CScript(scriptPubKey, scriptPubKey + scriptPubKeyLen), &tx.vin[nIn].scriptWitness, flags, TransactionSignatureChecker(&tx, nIn, amount, txdata), nullptr);\n     } catch (const std::exception&) {\n         return set_error(err, bitcoinconsensus_ERR_TX_DESERIALIZE); // Error deserializing\n     }"
      },
      {
        "sha": "33bf80e5a745823bea99662e874db6575abfe370",
        "filename": "src/script/bitcoinconsensus.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/script/bitcoinconsensus.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/script/bitcoinconsensus.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/bitcoinconsensus.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -63,7 +63,7 @@ enum\n /// Returns 1 if the input nIn of the serialized transaction pointed to by\n /// txTo correctly spends the scriptPubKey pointed to by scriptPubKey under\n /// the additional constraints specified by flags.\n-/// If not NULL, err will contain an error/success code for the operation\n+/// If not nullptr, err will contain an error/success code for the operation\n EXPORT_SYMBOL int bitcoinconsensus_verify_script(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen,\n                                                  const unsigned char *txTo        , unsigned int txToLen,\n                                                  unsigned int nIn, unsigned int flags, bitcoinconsensus_error* err);"
      },
      {
        "sha": "f9716dfc664fcd9c2836b6ccf26fad1e2ee281ab",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -1407,7 +1407,7 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n {\n     static const CScriptWitness emptyWitness;\n-    if (witness == NULL) {\n+    if (witness == nullptr) {\n         witness = &emptyWitness;\n     }\n     bool hadWitness = false;"
      },
      {
        "sha": "437826b5dd34c7128016b80f11ed4e65e56ac6fa",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -123,7 +123,7 @@ enum SigVersion\n     SIGVERSION_WITNESS_V0 = 1,\n };\n \n-uint256 SignatureHash(const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion, const PrecomputedTransactionData* cache = NULL);\n+uint256 SignatureHash(const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion, const PrecomputedTransactionData* cache = nullptr);\n \n class BaseSignatureChecker\n {\n@@ -158,7 +158,7 @@ class TransactionSignatureChecker : public BaseSignatureChecker\n     virtual bool VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash) const;\n \n public:\n-    TransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(NULL) {}\n+    TransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(nullptr) {}\n     TransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, const PrecomputedTransactionData& txdataIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(&txdataIn) {}\n     bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override;\n     bool CheckLockTime(const CScriptNum& nLockTime) const override;\n@@ -174,8 +174,8 @@ class MutableTransactionSignatureChecker : public TransactionSignatureChecker\n     MutableTransactionSignatureChecker(const CMutableTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn) : TransactionSignatureChecker(&txTo, nInIn, amountIn), txTo(*txToIn) {}\n };\n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* error = NULL);\n-bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror = NULL);\n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* error = nullptr);\n+bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror = nullptr);\n \n size_t CountWitnessSigOps(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, unsigned int flags);\n "
      },
      {
        "sha": "711ffa97f81257341d6517840fc44033ee19d51c",
        "filename": "src/script/script.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -498,7 +498,7 @@ class CScript : public CScriptBase\n     bool GetOp(iterator& pc, opcodetype& opcodeRet)\n     {\n          const_iterator pc2 = pc;\n-         bool fRet = GetOp2(pc2, opcodeRet, NULL);\n+         bool fRet = GetOp2(pc2, opcodeRet, nullptr);\n          pc = begin() + (pc2 - begin());\n          return fRet;\n     }\n@@ -510,7 +510,7 @@ class CScript : public CScriptBase\n \n     bool GetOp(const_iterator& pc, opcodetype& opcodeRet) const\n     {\n-        return GetOp2(pc, opcodeRet, NULL);\n+        return GetOp2(pc, opcodeRet, nullptr);\n     }\n \n     bool GetOp2(const_iterator& pc, opcodetype& opcodeRet, std::vector<unsigned char>* pvchRet) const"
      },
      {
        "sha": "9570b8c8d9a77e8edb72573284665fa629e1c3f9",
        "filename": "src/script/standard.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/script/standard.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/script/standard.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -31,7 +31,7 @@ const char* GetTxnOutputType(txnouttype t)\n     case TX_WITNESS_V0_KEYHASH: return \"witness_v0_keyhash\";\n     case TX_WITNESS_V0_SCRIPTHASH: return \"witness_v0_scripthash\";\n     }\n-    return NULL;\n+    return nullptr;\n }\n \n /**"
      },
      {
        "sha": "a9668b68bcb179071688ba2b568ec2f97124e54d",
        "filename": "src/streams.h",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/streams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/streams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/streams.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -479,25 +479,25 @@ class CAutoFile\n     {\n         if (file) {\n             ::fclose(file);\n-            file = NULL;\n+            file = nullptr;\n         }\n     }\n \n     /** Get wrapped FILE* with transfer of ownership.\n      * @note This will invalidate the CAutoFile object, and makes it the responsibility of the caller\n      * of this function to clean up the returned FILE*.\n      */\n-    FILE* release()             { FILE* ret = file; file = NULL; return ret; }\n+    FILE* release()             { FILE* ret = file; file = nullptr; return ret; }\n \n     /** Get wrapped FILE* without transfer of ownership.\n      * @note Ownership of the FILE* will remain with this class. Use this only if the scope of the\n      * CAutoFile outlives use of the passed pointer.\n      */\n     FILE* Get() const           { return file; }\n \n-    /** Return true if the wrapped FILE* is NULL, false otherwise.\n+    /** Return true if the wrapped FILE* is nullptr, false otherwise.\n      */\n-    bool IsNull() const         { return (file == NULL); }\n+    bool IsNull() const         { return (file == nullptr); }\n \n     //\n     // Stream subset\n@@ -508,15 +508,15 @@ class CAutoFile\n     void read(char* pch, size_t nSize)\n     {\n         if (!file)\n-            throw std::ios_base::failure(\"CAutoFile::read: file handle is NULL\");\n+            throw std::ios_base::failure(\"CAutoFile::read: file handle is nullptr\");\n         if (fread(pch, 1, nSize, file) != nSize)\n             throw std::ios_base::failure(feof(file) ? \"CAutoFile::read: end of file\" : \"CAutoFile::read: fread failed\");\n     }\n \n     void ignore(size_t nSize)\n     {\n         if (!file)\n-            throw std::ios_base::failure(\"CAutoFile::ignore: file handle is NULL\");\n+            throw std::ios_base::failure(\"CAutoFile::ignore: file handle is nullptr\");\n         unsigned char data[4096];\n         while (nSize > 0) {\n             size_t nNow = std::min<size_t>(nSize, sizeof(data));\n@@ -529,7 +529,7 @@ class CAutoFile\n     void write(const char* pch, size_t nSize)\n     {\n         if (!file)\n-            throw std::ios_base::failure(\"CAutoFile::write: file handle is NULL\");\n+            throw std::ios_base::failure(\"CAutoFile::write: file handle is nullptr\");\n         if (fwrite(pch, 1, nSize, file) != nSize)\n             throw std::ios_base::failure(\"CAutoFile::write: write failed\");\n     }\n@@ -539,7 +539,7 @@ class CAutoFile\n     {\n         // Serialize to this stream\n         if (!file)\n-            throw std::ios_base::failure(\"CAutoFile::operator<<: file handle is NULL\");\n+            throw std::ios_base::failure(\"CAutoFile::operator<<: file handle is nullptr\");\n         ::Serialize(*this, obj);\n         return (*this);\n     }\n@@ -549,7 +549,7 @@ class CAutoFile\n     {\n         // Unserialize from this stream\n         if (!file)\n-            throw std::ios_base::failure(\"CAutoFile::operator>>: file handle is NULL\");\n+            throw std::ios_base::failure(\"CAutoFile::operator>>: file handle is nullptr\");\n         ::Unserialize(*this, obj);\n         return (*this);\n     }\n@@ -616,7 +616,7 @@ class CBufferedFile\n     {\n         if (src) {\n             ::fclose(src);\n-            src = NULL;\n+            src = nullptr;\n         }\n     }\n "
      },
      {
        "sha": "f20f424941e9c993ef991beeaf464ee8cac50666",
        "filename": "src/support/allocators/secure.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/support/allocators/secure.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/support/allocators/secure.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/allocators/secure.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -45,7 +45,7 @@ struct secure_allocator : public std::allocator<T> {\n \n     void deallocate(T* p, std::size_t n)\n     {\n-        if (p != NULL) {\n+        if (p != nullptr) {\n             memory_cleanse(p, sizeof(T) * n);\n         }\n         LockedPoolManager::Instance().free(p);"
      },
      {
        "sha": "581d5d631859a2755d262aebff85c12f8d7b3281",
        "filename": "src/support/allocators/zeroafterfree.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/support/allocators/zeroafterfree.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/support/allocators/zeroafterfree.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/allocators/zeroafterfree.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -36,7 +36,7 @@ struct zero_after_free_allocator : public std::allocator<T> {\n \n     void deallocate(T* p, std::size_t n)\n     {\n-        if (p != NULL)\n+        if (p != nullptr)\n             memory_cleanse(p, sizeof(T) * n);\n         std::allocator<T>::deallocate(p, n);\n     }"
      },
      {
        "sha": "cc6d29aecdce6746dc56148dfb1846ca86f388ea",
        "filename": "src/support/events.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/support/events.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/support/events.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/events.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -47,7 +47,7 @@ inline raii_evhttp_request obtain_evhttp_request(void(*cb)(struct evhttp_request\n }\n \n inline raii_evhttp_connection obtain_evhttp_connection_base(struct event_base* base, std::string host, uint16_t port) {\n-    auto result = raii_evhttp_connection(evhttp_connection_base_new(base, NULL, host.c_str(), port));\n+    auto result = raii_evhttp_connection(evhttp_connection_base_new(base, nullptr, host.c_str(), port));\n     if (!result.get())\n         throw std::runtime_error(\"create connection failed\");\n     return result;"
      },
      {
        "sha": "2ead72185f7e1683f1a865d39d87c0588b3adfae",
        "filename": "src/support/lockedpool.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/support/lockedpool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/support/lockedpool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/lockedpool.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -28,7 +28,7 @@\n \n #include <algorithm>\n \n-LockedPoolManager* LockedPoolManager::_instance = NULL;\n+LockedPoolManager* LockedPoolManager::_instance = nullptr;\n std::once_flag LockedPoolManager::init_flag;\n \n /*******************************************************************************/\n@@ -87,7 +87,7 @@ template <class Iterator, class Pair> bool extend(Iterator it, const Pair& other\n \n void Arena::free(void *ptr)\n {\n-    // Freeing the NULL pointer is OK.\n+    // Freeing the nullptr pointer is OK.\n     if (ptr == nullptr) {\n         return;\n     }"
      },
      {
        "sha": "b82f3770e42aebeb3a9bde84ff14b3967227deec",
        "filename": "src/sync.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/sync.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/sync.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -100,7 +100,7 @@ static void potential_deadlock_detected(const std::pair<void*, void*>& mismatch,\n \n static void push_lock(void* c, const CLockLocation& locklocation, bool fTry)\n {\n-    if (lockstack.get() == NULL)\n+    if (lockstack.get() == nullptr)\n         lockstack.reset(new LockStack);\n \n     boost::unique_lock<boost::mutex> lock(lockdata.dd_mutex);"
      },
      {
        "sha": "4921aedf3993cd24da6c12e93c707d3c70179814",
        "filename": "src/sync.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/sync.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/sync.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -265,7 +265,7 @@ class CSemaphoreGrant\n         fHaveGrant = false;\n     }\n \n-    CSemaphoreGrant() : sem(NULL), fHaveGrant(false) {}\n+    CSemaphoreGrant() : sem(nullptr), fHaveGrant(false) {}\n \n     CSemaphoreGrant(CSemaphore& sema, bool fTry = false) : sem(&sema), fHaveGrant(false)\n     {"
      },
      {
        "sha": "067a9c6ff0ade7efb60b0e67db43a8fa894e5088",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -33,12 +33,12 @@ class CAddrManTest : public CAddrMan\n         return (unsigned int)(state % nMax);\n     }\n \n-    CAddrInfo* Find(const CNetAddr& addr, int* pnId = NULL)\n+    CAddrInfo* Find(const CNetAddr& addr, int* pnId = nullptr)\n     {\n         return CAddrMan::Find(addr, pnId);\n     }\n \n-    CAddrInfo* Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId = NULL)\n+    CAddrInfo* Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId = nullptr)\n     {\n         return CAddrMan::Create(addr, addrSource, pnId);\n     }\n@@ -359,7 +359,7 @@ BOOST_AUTO_TEST_CASE(addrman_delete)\n     addrman.Delete(nId);\n     BOOST_CHECK_EQUAL(addrman.size(), 0);\n     CAddrInfo* info2 = addrman.Find(addr1);\n-    BOOST_CHECK(info2 == NULL);\n+    BOOST_CHECK(info2 == nullptr);\n }\n \n BOOST_AUTO_TEST_CASE(addrman_getaddr)"
      },
      {
        "sha": "9fa9a8509c7d3e755583ff3282b289249769dc01",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -236,7 +236,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         pblock->hashMerkleRoot = BlockMerkleRoot(*pblock);\n         pblock->nNonce = blockinfo[i].nonce;\n         std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(*pblock);\n-        BOOST_CHECK(ProcessNewBlock(chainparams, shared_pblock, true, NULL));\n+        BOOST_CHECK(ProcessNewBlock(chainparams, shared_pblock, true, nullptr));\n         pblock->hashPrevBlock = pblock->GetHash();\n     }\n "
      },
      {
        "sha": "5e89ef60d2113d143dd546116833e74296c8880d",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -79,20 +79,20 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n     keys.assign(1,key[0]);\n     keys.push_back(key[1]);\n     s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-    BOOST_CHECK(VerifyScript(s, a_and_b, NULL, flags, MutableTransactionSignatureChecker(&txTo[0], 0, amount), &err));\n+    BOOST_CHECK(VerifyScript(s, a_and_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[0], 0, amount), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     for (int i = 0; i < 4; i++)\n     {\n         keys.assign(1,key[i]);\n         s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, NULL, flags, MutableTransactionSignatureChecker(&txTo[0], 0, amount), &err), strprintf(\"a&b 1: %d\", i));\n+        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[0], 0, amount), &err), strprintf(\"a&b 1: %d\", i));\n         BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_INVALID_STACK_OPERATION, ScriptErrorString(err));\n \n         keys.assign(1,key[1]);\n         keys.push_back(key[i]);\n         s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, NULL, flags, MutableTransactionSignatureChecker(&txTo[0], 0, amount), &err), strprintf(\"a&b 2: %d\", i));\n+        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[0], 0, amount), &err), strprintf(\"a&b 2: %d\", i));\n         BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n     }\n \n@@ -103,18 +103,18 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n         s = sign_multisig(a_or_b, keys, txTo[1], 0);\n         if (i == 0 || i == 1)\n         {\n-            BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, NULL, flags, MutableTransactionSignatureChecker(&txTo[1], 0, amount), &err), strprintf(\"a|b: %d\", i));\n+            BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[1], 0, amount), &err), strprintf(\"a|b: %d\", i));\n             BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n         }\n         else\n         {\n-            BOOST_CHECK_MESSAGE(!VerifyScript(s, a_or_b, NULL, flags, MutableTransactionSignatureChecker(&txTo[1], 0, amount), &err), strprintf(\"a|b: %d\", i));\n+            BOOST_CHECK_MESSAGE(!VerifyScript(s, a_or_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[1], 0, amount), &err), strprintf(\"a|b: %d\", i));\n             BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n         }\n     }\n     s.clear();\n     s << OP_0 << OP_1;\n-    BOOST_CHECK(!VerifyScript(s, a_or_b, NULL, flags, MutableTransactionSignatureChecker(&txTo[1], 0, amount), &err));\n+    BOOST_CHECK(!VerifyScript(s, a_or_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[1], 0, amount), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_SIG_DER, ScriptErrorString(err));\n \n \n@@ -126,12 +126,12 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n             s = sign_multisig(escrow, keys, txTo[2], 0);\n             if (i < j && i < 3 && j < 3)\n             {\n-                BOOST_CHECK_MESSAGE(VerifyScript(s, escrow, NULL, flags, MutableTransactionSignatureChecker(&txTo[2], 0, amount), &err), strprintf(\"escrow 1: %d %d\", i, j));\n+                BOOST_CHECK_MESSAGE(VerifyScript(s, escrow, nullptr, flags, MutableTransactionSignatureChecker(&txTo[2], 0, amount), &err), strprintf(\"escrow 1: %d %d\", i, j));\n                 BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n             }\n             else\n             {\n-                BOOST_CHECK_MESSAGE(!VerifyScript(s, escrow, NULL, flags, MutableTransactionSignatureChecker(&txTo[2], 0, amount), &err), strprintf(\"escrow 2: %d %d\", i, j));\n+                BOOST_CHECK_MESSAGE(!VerifyScript(s, escrow, nullptr, flags, MutableTransactionSignatureChecker(&txTo[2], 0, amount), &err), strprintf(\"escrow 2: %d %d\", i, j));\n                 BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n             }\n         }"
      },
      {
        "sha": "b13f2625aada7580d290dec8b566d4288f7d4d1d",
        "filename": "src/test/pow_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/test/pow_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/test/pow_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/pow_tests.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -66,7 +66,7 @@ BOOST_AUTO_TEST_CASE(GetBlockProofEquivalentTime_test)\n     const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n     std::vector<CBlockIndex> blocks(10000);\n     for (int i = 0; i < 10000; i++) {\n-        blocks[i].pprev = i ? &blocks[i - 1] : NULL;\n+        blocks[i].pprev = i ? &blocks[i - 1] : nullptr;\n         blocks[i].nHeight = i;\n         blocks[i].nTime = 1269211443 + i * chainParams->GetConsensus().nPowTargetSpacing;\n         blocks[i].nBits = 0x207fffff; /* target 0x7fffff000... */"
      },
      {
        "sha": "0d541ec7d4f26db77e71a76599bfe47c9dd6903d",
        "filename": "src/test/raii_event_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/test/raii_event_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/test/raii_event_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/raii_event_tests.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -42,18 +42,18 @@ BOOST_AUTO_TEST_CASE(raii_event_creation)\n {\n     event_set_mem_functions(tag_malloc, realloc, tag_free);\n     \n-    void* base_ptr = NULL;\n+    void* base_ptr = nullptr;\n     {\n         auto base = obtain_event_base();\n         base_ptr = (void*)base.get();\n         BOOST_CHECK(tags[base_ptr] == 1);\n     }\n     BOOST_CHECK(tags[base_ptr] == 0);\n     \n-    void* event_ptr = NULL;\n+    void* event_ptr = nullptr;\n     {\n         auto base = obtain_event_base();\n-        auto event = obtain_event(base.get(), -1, 0, NULL, NULL);\n+        auto event = obtain_event(base.get(), -1, 0, nullptr, nullptr);\n \n         base_ptr = (void*)base.get();\n         event_ptr = (void*)event.get();\n@@ -71,11 +71,11 @@ BOOST_AUTO_TEST_CASE(raii_event_order)\n {\n     event_set_mem_functions(tag_malloc, realloc, tag_free);\n     \n-    void* base_ptr = NULL;\n-    void* event_ptr = NULL;\n+    void* base_ptr = nullptr;\n+    void* event_ptr = nullptr;\n     {\n         auto base = obtain_event_base();\n-        auto event = obtain_event(base.get(), -1, 0, NULL, NULL);\n+        auto event = obtain_event(base.get(), -1, 0, nullptr, nullptr);\n \n         base_ptr = (void*)base.get();\n         event_ptr = (void*)event.get();"
      },
      {
        "sha": "efd0f77d9fc52a67bd21e688c1f24224e782bc5b",
        "filename": "src/test/script_P2SH_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/test/script_P2SH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/test/script_P2SH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2SH_tests.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -42,7 +42,7 @@ Verify(const CScript& scriptSig, const CScript& scriptPubKey, bool fStrict, Scri\n     txTo.vin[0].scriptSig = scriptSig;\n     txTo.vout[0].nValue = 1;\n \n-    return VerifyScript(scriptSig, scriptPubKey, NULL, fStrict ? SCRIPT_VERIFY_P2SH : SCRIPT_VERIFY_NONE, MutableTransactionSignatureChecker(&txTo, 0, txFrom.vout[0].nValue), &err);\n+    return VerifyScript(scriptSig, scriptPubKey, nullptr, fStrict ? SCRIPT_VERIFY_P2SH : SCRIPT_VERIFY_NONE, MutableTransactionSignatureChecker(&txTo, 0, txFrom.vout[0].nValue), &err);\n }\n \n "
      },
      {
        "sha": "06b8274f2d67b8e51f4db921c0000e98239c99b8",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 18,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -172,10 +172,10 @@ void DoTest(const CScript& scriptPubKey, const CScript& scriptSig, const CScript\n     int libconsensus_flags = flags & bitcoinconsensus_SCRIPT_FLAGS_VERIFY_ALL;\n     if (libconsensus_flags == flags) {\n         if (flags & bitcoinconsensus_SCRIPT_FLAGS_VERIFY_WITNESS) {\n-            BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script_with_amount(scriptPubKey.data(), scriptPubKey.size(), txCredit.vout[0].nValue, (const unsigned char*)&stream[0], stream.size(), 0, libconsensus_flags, NULL) == expect, message);\n+            BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script_with_amount(scriptPubKey.data(), scriptPubKey.size(), txCredit.vout[0].nValue, (const unsigned char*)&stream[0], stream.size(), 0, libconsensus_flags, nullptr) == expect, message);\n         } else {\n-            BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script_with_amount(scriptPubKey.data(), scriptPubKey.size(), 0, (const unsigned char*)&stream[0], stream.size(), 0, libconsensus_flags, NULL) == expect, message);\n-            BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), (const unsigned char*)&stream[0], stream.size(), 0, libconsensus_flags, NULL) == expect,message);\n+            BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script_with_amount(scriptPubKey.data(), scriptPubKey.size(), 0, (const unsigned char*)&stream[0], stream.size(), 0, libconsensus_flags, nullptr) == expect, message);\n+            BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), (const unsigned char*)&stream[0], stream.size(), 0, libconsensus_flags, nullptr) == expect,message);\n         }\n     }\n #endif\n@@ -1064,18 +1064,18 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG12)\n     CMutableTransaction txTo12 = BuildSpendingTransaction(CScript(), CScriptWitness(), txFrom12);\n \n     CScript goodsig1 = sign_multisig(scriptPubKey12, key1, txTo12);\n-    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey12, NULL, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n+    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey12, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n     txTo12.vout[0].nValue = 2;\n-    BOOST_CHECK(!VerifyScript(goodsig1, scriptPubKey12, NULL, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n+    BOOST_CHECK(!VerifyScript(goodsig1, scriptPubKey12, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     CScript goodsig2 = sign_multisig(scriptPubKey12, key2, txTo12);\n-    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey12, NULL, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n+    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey12, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     CScript badsig1 = sign_multisig(scriptPubKey12, key3, txTo12);\n-    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey12, NULL, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n+    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey12, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n }\n \n@@ -1097,54 +1097,54 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n     std::vector<CKey> keys;\n     keys.push_back(key1); keys.push_back(key2);\n     CScript goodsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey23, NULL, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key1); keys.push_back(key3);\n     CScript goodsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey23, NULL, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key3);\n     CScript goodsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig3, scriptPubKey23, NULL, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    BOOST_CHECK(VerifyScript(goodsig3, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key2); // Can't re-use sig\n     CScript badsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey23, NULL, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key1); // sigs must be in correct order\n     CScript badsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig2, scriptPubKey23, NULL, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    BOOST_CHECK(!VerifyScript(badsig2, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key3); keys.push_back(key2); // sigs must be in correct order\n     CScript badsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig3, scriptPubKey23, NULL, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    BOOST_CHECK(!VerifyScript(badsig3, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key4); keys.push_back(key2); // sigs must match pubkeys\n     CScript badsig4 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig4, scriptPubKey23, NULL, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    BOOST_CHECK(!VerifyScript(badsig4, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key1); keys.push_back(key4); // sigs must match pubkeys\n     CScript badsig5 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig5, scriptPubKey23, NULL, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    BOOST_CHECK(!VerifyScript(badsig5, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear(); // Must have signatures\n     CScript badsig6 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig6, scriptPubKey23, NULL, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    BOOST_CHECK(!VerifyScript(badsig6, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_INVALID_STACK_OPERATION, ScriptErrorString(err));\n }\n \n@@ -1265,7 +1265,7 @@ BOOST_AUTO_TEST_CASE(script_standard_push)\n         CScript script;\n         script << i;\n         BOOST_CHECK_MESSAGE(script.IsPushOnly(), \"Number \" << i << \" is not pure push.\");\n-        BOOST_CHECK_MESSAGE(VerifyScript(script, CScript() << OP_1, NULL, SCRIPT_VERIFY_MINIMALDATA, BaseSignatureChecker(), &err), \"Number \" << i << \" push is not minimal data.\");\n+        BOOST_CHECK_MESSAGE(VerifyScript(script, CScript() << OP_1, nullptr, SCRIPT_VERIFY_MINIMALDATA, BaseSignatureChecker(), &err), \"Number \" << i << \" push is not minimal data.\");\n         BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n     }\n \n@@ -1274,7 +1274,7 @@ BOOST_AUTO_TEST_CASE(script_standard_push)\n         CScript script;\n         script << data;\n         BOOST_CHECK_MESSAGE(script.IsPushOnly(), \"Length \" << i << \" is not pure push.\");\n-        BOOST_CHECK_MESSAGE(VerifyScript(script, CScript() << OP_1, NULL, SCRIPT_VERIFY_MINIMALDATA, BaseSignatureChecker(), &err), \"Length \" << i << \" push is not minimal data.\");\n+        BOOST_CHECK_MESSAGE(VerifyScript(script, CScript() << OP_1, nullptr, SCRIPT_VERIFY_MINIMALDATA, BaseSignatureChecker(), &err), \"Length \" << i << \" push is not minimal data.\");\n         BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n     }\n }"
      },
      {
        "sha": "e3654e67ad629a4ad82896b12a7e3d1ca5c7dacc",
        "filename": "src/test/skiplist_tests.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/test/skiplist_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/test/skiplist_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/skiplist_tests.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -20,7 +20,7 @@ BOOST_AUTO_TEST_CASE(skiplist_test)\n \n     for (int i=0; i<SKIPLIST_LENGTH; i++) {\n         vIndex[i].nHeight = i;\n-        vIndex[i].pprev = (i == 0) ? NULL : &vIndex[i - 1];\n+        vIndex[i].pprev = (i == 0) ? nullptr : &vIndex[i - 1];\n         vIndex[i].BuildSkip();\n     }\n \n@@ -29,7 +29,7 @@ BOOST_AUTO_TEST_CASE(skiplist_test)\n             BOOST_CHECK(vIndex[i].pskip == &vIndex[vIndex[i].pskip->nHeight]);\n             BOOST_CHECK(vIndex[i].pskip->nHeight < i);\n         } else {\n-            BOOST_CHECK(vIndex[i].pskip == NULL);\n+            BOOST_CHECK(vIndex[i].pskip == nullptr);\n         }\n     }\n \n@@ -51,11 +51,11 @@ BOOST_AUTO_TEST_CASE(getlocator_test)\n     for (unsigned int i=0; i<vBlocksMain.size(); i++) {\n         vHashMain[i] = ArithToUint256(i); // Set the hash equal to the height, so we can quickly check the distances.\n         vBlocksMain[i].nHeight = i;\n-        vBlocksMain[i].pprev = i ? &vBlocksMain[i - 1] : NULL;\n+        vBlocksMain[i].pprev = i ? &vBlocksMain[i - 1] : nullptr;\n         vBlocksMain[i].phashBlock = &vHashMain[i];\n         vBlocksMain[i].BuildSkip();\n         BOOST_CHECK_EQUAL((int)UintToArith256(vBlocksMain[i].GetBlockHash()).GetLow64(), vBlocksMain[i].nHeight);\n-        BOOST_CHECK(vBlocksMain[i].pprev == NULL || vBlocksMain[i].nHeight == vBlocksMain[i].pprev->nHeight + 1);\n+        BOOST_CHECK(vBlocksMain[i].pprev == nullptr || vBlocksMain[i].nHeight == vBlocksMain[i].pprev->nHeight + 1);\n     }\n \n     // Build a branch that splits off at block 49999, 50000 blocks long.\n@@ -68,7 +68,7 @@ BOOST_AUTO_TEST_CASE(getlocator_test)\n         vBlocksSide[i].phashBlock = &vHashSide[i];\n         vBlocksSide[i].BuildSkip();\n         BOOST_CHECK_EQUAL((int)UintToArith256(vBlocksSide[i].GetBlockHash()).GetLow64(), vBlocksSide[i].nHeight);\n-        BOOST_CHECK(vBlocksSide[i].pprev == NULL || vBlocksSide[i].nHeight == vBlocksSide[i].pprev->nHeight + 1);\n+        BOOST_CHECK(vBlocksSide[i].pprev == nullptr || vBlocksSide[i].nHeight == vBlocksSide[i].pprev->nHeight + 1);\n     }\n \n     // Build a CChain for the main branch.\n@@ -106,7 +106,7 @@ BOOST_AUTO_TEST_CASE(findearliestatleast_test)\n     for (unsigned int i=0; i<vBlocksMain.size(); i++) {\n         vHashMain[i] = ArithToUint256(i); // Set the hash equal to the height\n         vBlocksMain[i].nHeight = i;\n-        vBlocksMain[i].pprev = i ? &vBlocksMain[i - 1] : NULL;\n+        vBlocksMain[i].pprev = i ? &vBlocksMain[i - 1] : nullptr;\n         vBlocksMain[i].phashBlock = &vHashMain[i];\n         vBlocksMain[i].BuildSkip();\n         if (i < 10) {\n@@ -138,7 +138,7 @@ BOOST_AUTO_TEST_CASE(findearliestatleast_test)\n         int64_t test_time = vBlocksMain[r].nTime;\n         CBlockIndex *ret = chain.FindEarliestAtLeast(test_time);\n         BOOST_CHECK(ret->nTimeMax >= test_time);\n-        BOOST_CHECK((ret->pprev==NULL) || ret->pprev->nTimeMax < test_time);\n+        BOOST_CHECK((ret->pprev==nullptr) || ret->pprev->nTimeMax < test_time);\n         BOOST_CHECK(vBlocksMain[r].GetAncestor(ret->nHeight) == ret);\n     }\n }"
      },
      {
        "sha": "a64fb6903f834efc0f1ef684c2702cc3a8da6b1d",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -140,7 +140,7 @@ TestChain100Setup::CreateAndProcessBlock(const std::vector<CMutableTransaction>&\n     while (!CheckProofOfWork(block.GetHash(), block.nBits, chainparams.GetConsensus())) ++block.nNonce;\n \n     std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(block);\n-    ProcessNewBlock(chainparams, shared_pblock, true, NULL);\n+    ProcessNewBlock(chainparams, shared_pblock, true, nullptr);\n \n     CBlock result = block;\n     return result;"
      },
      {
        "sha": "2d25cb96c807cd7262a739603ac4cf65fca9e43d",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -29,7 +29,7 @@ ToMemPool(CMutableTransaction& tx)\n     LOCK(cs_main);\n \n     CValidationState state;\n-    return AcceptToMemoryPool(mempool, state, MakeTransactionRef(tx), false, NULL, NULL, true, 0);\n+    return AcceptToMemoryPool(mempool, state, MakeTransactionRef(tx), false, nullptr, nullptr, true, 0);\n }\n \n BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)"
      },
      {
        "sha": "567908696902f89195257c4f83ea74d936df952d",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 20,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -328,7 +328,7 @@ BOOST_AUTO_TEST_CASE(test_ParseInt32)\n {\n     int32_t n;\n     // Valid values\n-    BOOST_CHECK(ParseInt32(\"1234\", NULL));\n+    BOOST_CHECK(ParseInt32(\"1234\", nullptr));\n     BOOST_CHECK(ParseInt32(\"0\", &n) && n == 0);\n     BOOST_CHECK(ParseInt32(\"1234\", &n) && n == 1234);\n     BOOST_CHECK(ParseInt32(\"01234\", &n) && n == 1234); // no octal\n@@ -347,17 +347,17 @@ BOOST_AUTO_TEST_CASE(test_ParseInt32)\n     std::string teststr(test_bytes, sizeof(test_bytes));\n     BOOST_CHECK(!ParseInt32(teststr, &n)); // no embedded NULs\n     // Overflow and underflow\n-    BOOST_CHECK(!ParseInt32(\"-2147483649\", NULL));\n-    BOOST_CHECK(!ParseInt32(\"2147483648\", NULL));\n-    BOOST_CHECK(!ParseInt32(\"-32482348723847471234\", NULL));\n-    BOOST_CHECK(!ParseInt32(\"32482348723847471234\", NULL));\n+    BOOST_CHECK(!ParseInt32(\"-2147483649\", nullptr));\n+    BOOST_CHECK(!ParseInt32(\"2147483648\", nullptr));\n+    BOOST_CHECK(!ParseInt32(\"-32482348723847471234\", nullptr));\n+    BOOST_CHECK(!ParseInt32(\"32482348723847471234\", nullptr));\n }\n \n BOOST_AUTO_TEST_CASE(test_ParseInt64)\n {\n     int64_t n;\n     // Valid values\n-    BOOST_CHECK(ParseInt64(\"1234\", NULL));\n+    BOOST_CHECK(ParseInt64(\"1234\", nullptr));\n     BOOST_CHECK(ParseInt64(\"0\", &n) && n == 0LL);\n     BOOST_CHECK(ParseInt64(\"1234\", &n) && n == 1234LL);\n     BOOST_CHECK(ParseInt64(\"01234\", &n) && n == 1234LL); // no octal\n@@ -377,17 +377,17 @@ BOOST_AUTO_TEST_CASE(test_ParseInt64)\n     std::string teststr(test_bytes, sizeof(test_bytes));\n     BOOST_CHECK(!ParseInt64(teststr, &n)); // no embedded NULs\n     // Overflow and underflow\n-    BOOST_CHECK(!ParseInt64(\"-9223372036854775809\", NULL));\n-    BOOST_CHECK(!ParseInt64(\"9223372036854775808\", NULL));\n-    BOOST_CHECK(!ParseInt64(\"-32482348723847471234\", NULL));\n-    BOOST_CHECK(!ParseInt64(\"32482348723847471234\", NULL));\n+    BOOST_CHECK(!ParseInt64(\"-9223372036854775809\", nullptr));\n+    BOOST_CHECK(!ParseInt64(\"9223372036854775808\", nullptr));\n+    BOOST_CHECK(!ParseInt64(\"-32482348723847471234\", nullptr));\n+    BOOST_CHECK(!ParseInt64(\"32482348723847471234\", nullptr));\n }\n \n BOOST_AUTO_TEST_CASE(test_ParseUInt32)\n {\n     uint32_t n;\n     // Valid values\n-    BOOST_CHECK(ParseUInt32(\"1234\", NULL));\n+    BOOST_CHECK(ParseUInt32(\"1234\", nullptr));\n     BOOST_CHECK(ParseUInt32(\"0\", &n) && n == 0);\n     BOOST_CHECK(ParseUInt32(\"1234\", &n) && n == 1234);\n     BOOST_CHECK(ParseUInt32(\"01234\", &n) && n == 1234); // no octal\n@@ -410,15 +410,15 @@ BOOST_AUTO_TEST_CASE(test_ParseUInt32)\n     BOOST_CHECK(!ParseUInt32(\"-2147483648\", &n));\n     BOOST_CHECK(!ParseUInt32(\"4294967296\", &n));\n     BOOST_CHECK(!ParseUInt32(\"-1234\", &n));\n-    BOOST_CHECK(!ParseUInt32(\"-32482348723847471234\", NULL));\n-    BOOST_CHECK(!ParseUInt32(\"32482348723847471234\", NULL));\n+    BOOST_CHECK(!ParseUInt32(\"-32482348723847471234\", nullptr));\n+    BOOST_CHECK(!ParseUInt32(\"32482348723847471234\", nullptr));\n }\n \n BOOST_AUTO_TEST_CASE(test_ParseUInt64)\n {\n     uint64_t n;\n     // Valid values\n-    BOOST_CHECK(ParseUInt64(\"1234\", NULL));\n+    BOOST_CHECK(ParseUInt64(\"1234\", nullptr));\n     BOOST_CHECK(ParseUInt64(\"0\", &n) && n == 0LL);\n     BOOST_CHECK(ParseUInt64(\"1234\", &n) && n == 1234LL);\n     BOOST_CHECK(ParseUInt64(\"01234\", &n) && n == 1234LL); // no octal\n@@ -438,9 +438,9 @@ BOOST_AUTO_TEST_CASE(test_ParseUInt64)\n     std::string teststr(test_bytes, sizeof(test_bytes));\n     BOOST_CHECK(!ParseUInt64(teststr, &n)); // no embedded NULs\n     // Overflow and underflow\n-    BOOST_CHECK(!ParseUInt64(\"-9223372036854775809\", NULL));\n-    BOOST_CHECK(!ParseUInt64(\"18446744073709551616\", NULL));\n-    BOOST_CHECK(!ParseUInt64(\"-32482348723847471234\", NULL));\n+    BOOST_CHECK(!ParseUInt64(\"-9223372036854775809\", nullptr));\n+    BOOST_CHECK(!ParseUInt64(\"18446744073709551616\", nullptr));\n+    BOOST_CHECK(!ParseUInt64(\"-32482348723847471234\", nullptr));\n     BOOST_CHECK(!ParseUInt64(\"-2147483648\", &n));\n     BOOST_CHECK(!ParseUInt64(\"-9223372036854775808\", &n));\n     BOOST_CHECK(!ParseUInt64(\"-1234\", &n));\n@@ -450,7 +450,7 @@ BOOST_AUTO_TEST_CASE(test_ParseDouble)\n {\n     double n;\n     // Valid values\n-    BOOST_CHECK(ParseDouble(\"1234\", NULL));\n+    BOOST_CHECK(ParseDouble(\"1234\", nullptr));\n     BOOST_CHECK(ParseDouble(\"0\", &n) && n == 0.0);\n     BOOST_CHECK(ParseDouble(\"1234\", &n) && n == 1234.0);\n     BOOST_CHECK(ParseDouble(\"01234\", &n) && n == 1234.0); // no octal\n@@ -470,8 +470,8 @@ BOOST_AUTO_TEST_CASE(test_ParseDouble)\n     std::string teststr(test_bytes, sizeof(test_bytes));\n     BOOST_CHECK(!ParseDouble(teststr, &n)); // no embedded NULs\n     // Overflow and underflow\n-    BOOST_CHECK(!ParseDouble(\"-1e10000\", NULL));\n-    BOOST_CHECK(!ParseDouble(\"1e10000\", NULL));\n+    BOOST_CHECK(!ParseDouble(\"-1e10000\", nullptr));\n+    BOOST_CHECK(!ParseDouble(\"1e10000\", nullptr));\n }\n \n BOOST_AUTO_TEST_CASE(test_FormatParagraph)"
      },
      {
        "sha": "f433aad889c1926f3e7064adf4e65def4fbaf42a",
        "filename": "src/test/versionbits_tests.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/test/versionbits_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/test/versionbits_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/versionbits_tests.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -69,7 +69,7 @@ class VersionBitsTester\n         while (vpblock.size() < height) {\n             CBlockIndex* pindex = new CBlockIndex();\n             pindex->nHeight = vpblock.size();\n-            pindex->pprev = vpblock.size() > 0 ? vpblock.back() : NULL;\n+            pindex->pprev = vpblock.size() > 0 ? vpblock.back() : nullptr;\n             pindex->nTime = nTime;\n             pindex->nVersion = nVersion;\n             pindex->BuildSkip();\n@@ -81,7 +81,7 @@ class VersionBitsTester\n     VersionBitsTester& TestStateSinceHeight(int height) {\n         for (int i = 0; i < CHECKERS; i++) {\n             if (InsecureRandBits(i) == 0) {\n-                BOOST_CHECK_MESSAGE(checker[i].GetStateSinceHeightFor(vpblock.empty() ? NULL : vpblock.back()) == height, strprintf(\"Test %i for StateSinceHeight\", num));\n+                BOOST_CHECK_MESSAGE(checker[i].GetStateSinceHeightFor(vpblock.empty() ? nullptr : vpblock.back()) == height, strprintf(\"Test %i for StateSinceHeight\", num));\n             }\n         }\n         num++;\n@@ -91,7 +91,7 @@ class VersionBitsTester\n     VersionBitsTester& TestDefined() {\n         for (int i = 0; i < CHECKERS; i++) {\n             if (InsecureRandBits(i) == 0) {\n-                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? NULL : vpblock.back()) == THRESHOLD_DEFINED, strprintf(\"Test %i for DEFINED\", num));\n+                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_DEFINED, strprintf(\"Test %i for DEFINED\", num));\n             }\n         }\n         num++;\n@@ -101,7 +101,7 @@ class VersionBitsTester\n     VersionBitsTester& TestStarted() {\n         for (int i = 0; i < CHECKERS; i++) {\n             if (InsecureRandBits(i) == 0) {\n-                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? NULL : vpblock.back()) == THRESHOLD_STARTED, strprintf(\"Test %i for STARTED\", num));\n+                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_STARTED, strprintf(\"Test %i for STARTED\", num));\n             }\n         }\n         num++;\n@@ -111,7 +111,7 @@ class VersionBitsTester\n     VersionBitsTester& TestLockedIn() {\n         for (int i = 0; i < CHECKERS; i++) {\n             if (InsecureRandBits(i) == 0) {\n-                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? NULL : vpblock.back()) == THRESHOLD_LOCKED_IN, strprintf(\"Test %i for LOCKED_IN\", num));\n+                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_LOCKED_IN, strprintf(\"Test %i for LOCKED_IN\", num));\n             }\n         }\n         num++;\n@@ -121,7 +121,7 @@ class VersionBitsTester\n     VersionBitsTester& TestActive() {\n         for (int i = 0; i < CHECKERS; i++) {\n             if (InsecureRandBits(i) == 0) {\n-                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? NULL : vpblock.back()) == THRESHOLD_ACTIVE, strprintf(\"Test %i for ACTIVE\", num));\n+                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_ACTIVE, strprintf(\"Test %i for ACTIVE\", num));\n             }\n         }\n         num++;\n@@ -131,14 +131,14 @@ class VersionBitsTester\n     VersionBitsTester& TestFailed() {\n         for (int i = 0; i < CHECKERS; i++) {\n             if (InsecureRandBits(i) == 0) {\n-                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? NULL : vpblock.back()) == THRESHOLD_FAILED, strprintf(\"Test %i for FAILED\", num));\n+                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_FAILED, strprintf(\"Test %i for FAILED\", num));\n             }\n         }\n         num++;\n         return *this;\n     }\n \n-    CBlockIndex * Tip() { return vpblock.size() ? vpblock.back() : NULL; }\n+    CBlockIndex * Tip() { return vpblock.size() ? vpblock.back() : nullptr; }\n };\n \n BOOST_FIXTURE_TEST_SUITE(versionbits_tests, TestingSetup)\n@@ -255,7 +255,7 @@ BOOST_AUTO_TEST_CASE(versionbits_computeblockversion)\n \n     // Before MedianTimePast of the chain has crossed nStartTime, the bit\n     // should not be set.\n-    CBlockIndex *lastBlock = NULL;\n+    CBlockIndex *lastBlock = nullptr;\n     lastBlock = firstChain.Mine(2016, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();\n     BOOST_CHECK_EQUAL(ComputeBlockVersion(lastBlock, mainnetParams) & (1<<bit), 0);\n "
      },
      {
        "sha": "57c22537b268db8a91e6b82722ed83246c8d2524",
        "filename": "src/torcontrol.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/torcontrol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/torcontrol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/torcontrol.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -138,8 +138,8 @@ void TorControlConnection::readcb(struct bufferevent *bev, void *ctx)\n     size_t n_read_out = 0;\n     char *line;\n     assert(input);\n-    //  If there is not a whole line to read, evbuffer_readln returns NULL\n-    while((line = evbuffer_readln(input, &n_read_out, EVBUFFER_EOL_CRLF)) != NULL)\n+    //  If there is not a whole line to read, evbuffer_readln returns nullptr\n+    while((line = evbuffer_readln(input, &n_read_out, EVBUFFER_EOL_CRLF)) != nullptr)\n     {\n         std::string s(line, n_read_out);\n         free(line);\n@@ -210,7 +210,7 @@ bool TorControlConnection::Connect(const std::string &target, const ConnectionCB\n     b_conn = bufferevent_socket_new(base, -1, BEV_OPT_CLOSE_ON_FREE);\n     if (!b_conn)\n         return false;\n-    bufferevent_setcb(b_conn, TorControlConnection::readcb, NULL, TorControlConnection::eventcb, this);\n+    bufferevent_setcb(b_conn, TorControlConnection::readcb, nullptr, TorControlConnection::eventcb, this);\n     bufferevent_enable(b_conn, EV_READ|EV_WRITE);\n     this->connected = _connected;\n     this->disconnected = _disconnected;\n@@ -333,7 +333,7 @@ static std::map<std::string,std::string> ParseTorReplyMapping(const std::string\n                         if (j == 3 && value[i] > '3') {\n                             j--;\n                         }\n-                        escaped_value.push_back(strtol(value.substr(i, j).c_str(), NULL, 8));\n+                        escaped_value.push_back(strtol(value.substr(i, j).c_str(), nullptr, 8));\n                         // Account for automatic incrementing at loop end\n                         i += j - 1;\n                     } else {\n@@ -367,7 +367,7 @@ static std::map<std::string,std::string> ParseTorReplyMapping(const std::string\n static std::pair<bool,std::string> ReadBinaryFile(const fs::path &filename, size_t maxsize=std::numeric_limits<size_t>::max())\n {\n     FILE *f = fsbridge::fopen(filename, \"rb\");\n-    if (f == NULL)\n+    if (f == nullptr)\n         return std::make_pair(false,\"\");\n     std::string retval;\n     char buffer[128];\n@@ -393,7 +393,7 @@ static std::pair<bool,std::string> ReadBinaryFile(const fs::path &filename, size\n static bool WriteBinaryFile(const fs::path &filename, const std::string &data)\n {\n     FILE *f = fsbridge::fopen(filename, \"wb\");\n-    if (f == NULL)\n+    if (f == nullptr)\n         return false;\n     if (fwrite(data.data(), 1, data.size(), f) != data.size()) {\n         fclose(f);"
      },
      {
        "sha": "6723ea8e6cafc8fc0be03152f3e034b6759f4490",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -45,7 +45,7 @@ struct LockPoints\n     // values are still valid even after a reorg.\n     CBlockIndex* maxInputBlock;\n \n-    LockPoints() : height(0), time(0), maxInputBlock(NULL) { }\n+    LockPoints() : height(0), time(0), maxInputBlock(nullptr) { }\n };\n \n class CTxMemPool;\n@@ -592,7 +592,7 @@ class CTxMemPool\n       *  pvNoSpendsRemaining, if set, will be populated with the list of outpoints\n       *  which are not in mempool which no longer have any spends in this mempool.\n       */\n-    void TrimToSize(size_t sizelimit, std::vector<COutPoint>* pvNoSpendsRemaining=NULL);\n+    void TrimToSize(size_t sizelimit, std::vector<COutPoint>* pvNoSpendsRemaining=nullptr);\n \n     /** Expire all transaction (and their dependencies) in the mempool older than time. Return the number of removed transactions. */\n     int Expire(int64_t time);"
      },
      {
        "sha": "fc75b7ef85effdfb8ea863b5c24913c42a0cb257",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -144,7 +144,7 @@ class CInit\n         // Securely erase the memory used by the PRNG\n         RAND_cleanup();\n         // Shutdown OpenSSL library multithreading support\n-        CRYPTO_set_locking_callback(NULL);\n+        CRYPTO_set_locking_callback(nullptr);\n         // Clear the set of locks now to maintain symmetry with the constructor.\n         ppmutexOpenSSL.reset();\n     }\n@@ -173,8 +173,8 @@ static boost::once_flag debugPrintInitFlag = BOOST_ONCE_INIT;\n  * the OS/libc. When the shutdown sequence is fully audited and\n  * tested, explicit destruction of these objects can be implemented.\n  */\n-static FILE* fileout = NULL;\n-static boost::mutex* mutexDebugLog = NULL;\n+static FILE* fileout = nullptr;\n+static boost::mutex* mutexDebugLog = nullptr;\n static std::list<std::string>* vMsgsBeforeOpenLog;\n \n static int FileWriteStr(const std::string &str, FILE *fp)\n@@ -184,7 +184,7 @@ static int FileWriteStr(const std::string &str, FILE *fp)\n \n static void DebugPrintInit()\n {\n-    assert(mutexDebugLog == NULL);\n+    assert(mutexDebugLog == nullptr);\n     mutexDebugLog = new boost::mutex();\n     vMsgsBeforeOpenLog = new std::list<std::string>;\n }\n@@ -194,12 +194,12 @@ void OpenDebugLog()\n     boost::call_once(&DebugPrintInit, debugPrintInitFlag);\n     boost::mutex::scoped_lock scoped_lock(*mutexDebugLog);\n \n-    assert(fileout == NULL);\n+    assert(fileout == nullptr);\n     assert(vMsgsBeforeOpenLog);\n     fs::path pathDebug = GetDataDir() / \"debug.log\";\n     fileout = fsbridge::fopen(pathDebug, \"a\");\n     if (fileout) {\n-        setbuf(fileout, NULL); // unbuffered\n+        setbuf(fileout, nullptr); // unbuffered\n         // dump buffered messages from before we opened the log\n         while (!vMsgsBeforeOpenLog->empty()) {\n             FileWriteStr(vMsgsBeforeOpenLog->front(), fileout);\n@@ -208,7 +208,7 @@ void OpenDebugLog()\n     }\n \n     delete vMsgsBeforeOpenLog;\n-    vMsgsBeforeOpenLog = NULL;\n+    vMsgsBeforeOpenLog = nullptr;\n }\n \n struct CLogCategoryDesc\n@@ -344,7 +344,7 @@ int LogPrintStr(const std::string &str)\n         boost::mutex::scoped_lock scoped_lock(*mutexDebugLog);\n \n         // buffer if we haven't opened the log yet\n-        if (fileout == NULL) {\n+        if (fileout == nullptr) {\n             assert(vMsgsBeforeOpenLog);\n             ret = strTimestamped.length();\n             vMsgsBeforeOpenLog->push_back(strTimestamped);\n@@ -355,8 +355,8 @@ int LogPrintStr(const std::string &str)\n             if (fReopenDebugLog) {\n                 fReopenDebugLog = false;\n                 fs::path pathDebug = GetDataDir() / \"debug.log\";\n-                if (fsbridge::freopen(pathDebug,\"a\",fileout) != NULL)\n-                    setbuf(fileout, NULL); // unbuffered\n+                if (fsbridge::freopen(pathDebug,\"a\",fileout) != nullptr)\n+                    setbuf(fileout, nullptr); // unbuffered\n             }\n \n             ret = FileWriteStr(strTimestamped, fileout);\n@@ -503,7 +503,7 @@ static std::string FormatException(const std::exception* pex, const char* pszThr\n {\n #ifdef WIN32\n     char pszModule[MAX_PATH] = \"\";\n-    GetModuleFileNameA(NULL, pszModule, sizeof(pszModule));\n+    GetModuleFileNameA(nullptr, pszModule, sizeof(pszModule));\n #else\n     const char* pszModule = \"bitcoin\";\n #endif\n@@ -534,7 +534,7 @@ fs::path GetDefaultDataDir()\n #else\n     fs::path pathRet;\n     char* pszHome = getenv(\"HOME\");\n-    if (pszHome == NULL || strlen(pszHome) == 0)\n+    if (pszHome == nullptr || strlen(pszHome) == 0)\n         pathRet = fs::path(\"/\");\n     else\n         pathRet = fs::path(pszHome);\n@@ -791,7 +791,7 @@ void ShrinkDebugFile()\n             fclose(file);\n         }\n     }\n-    else if (file != NULL)\n+    else if (file != nullptr)\n         fclose(file);\n }\n \n@@ -800,7 +800,7 @@ fs::path GetSpecialFolderPath(int nFolder, bool fCreate)\n {\n     char pszPath[MAX_PATH] = \"\";\n \n-    if(SHGetSpecialFolderPathA(NULL, pszPath, nFolder, fCreate))\n+    if(SHGetSpecialFolderPathA(nullptr, pszPath, nFolder, fCreate))\n     {\n         return fs::path(pszPath);\n     }"
      },
      {
        "sha": "b01606cb8fa3a7b0910b69808b58097743c2d8f7",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -358,7 +358,7 @@ template <typename Callable> void TraceThread(const char* name,  Callable func)\n         throw;\n     }\n     catch (...) {\n-        PrintExceptionContinue(NULL, name);\n+        PrintExceptionContinue(nullptr, name);\n         throw;\n     }\n }"
      },
      {
        "sha": "fd233f67579ccea3a6c6a269376392955ad77ae9",
        "filename": "src/utilstrencodings.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/utilstrencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/utilstrencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utilstrencodings.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -452,7 +452,7 @@ bool ParseInt32(const std::string& str, int32_t *out)\n {\n     if (!ParsePrechecks(str))\n         return false;\n-    char *endp = NULL;\n+    char *endp = nullptr;\n     errno = 0; // strtol will not set errno if valid\n     long int n = strtol(str.c_str(), &endp, 10);\n     if(out) *out = (int32_t)n;\n@@ -468,7 +468,7 @@ bool ParseInt64(const std::string& str, int64_t *out)\n {\n     if (!ParsePrechecks(str))\n         return false;\n-    char *endp = NULL;\n+    char *endp = nullptr;\n     errno = 0; // strtoll will not set errno if valid\n     long long int n = strtoll(str.c_str(), &endp, 10);\n     if(out) *out = (int64_t)n;\n@@ -485,7 +485,7 @@ bool ParseUInt32(const std::string& str, uint32_t *out)\n         return false;\n     if (str.size() >= 1 && str[0] == '-') // Reject negative values, unfortunately strtoul accepts these by default if they fit in the range\n         return false;\n-    char *endp = NULL;\n+    char *endp = nullptr;\n     errno = 0; // strtoul will not set errno if valid\n     unsigned long int n = strtoul(str.c_str(), &endp, 10);\n     if(out) *out = (uint32_t)n;\n@@ -502,7 +502,7 @@ bool ParseUInt64(const std::string& str, uint64_t *out)\n         return false;\n     if (str.size() >= 1 && str[0] == '-') // Reject negative values, unfortunately strtoull accepts these by default if they fit in the range\n         return false;\n-    char *endp = NULL;\n+    char *endp = nullptr;\n     errno = 0; // strtoull will not set errno if valid\n     unsigned long long int n = strtoull(str.c_str(), &endp, 10);\n     if(out) *out = (uint64_t)n;\n@@ -583,7 +583,7 @@ int64_t atoi64(const char* psz)\n #ifdef _MSC_VER\n     return _atoi64(psz);\n #else\n-    return strtoll(psz, NULL, 10);\n+    return strtoll(psz, nullptr, 10);\n #endif\n }\n \n@@ -592,7 +592,7 @@ int64_t atoi64(const std::string& str)\n #ifdef _MSC_VER\n     return _atoi64(str.c_str());\n #else\n-    return strtoll(str.c_str(), NULL, 10);\n+    return strtoll(str.c_str(), nullptr, 10);\n #endif\n }\n "
      },
      {
        "sha": "53da60e8f13f57f5d03e1208146de63e0148c5be",
        "filename": "src/utilstrencodings.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/utilstrencodings.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/utilstrencodings.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utilstrencodings.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -39,11 +39,11 @@ std::vector<unsigned char> ParseHex(const char* psz);\n std::vector<unsigned char> ParseHex(const std::string& str);\n signed char HexDigit(char c);\n bool IsHex(const std::string& str);\n-std::vector<unsigned char> DecodeBase64(const char* p, bool* pfInvalid = NULL);\n+std::vector<unsigned char> DecodeBase64(const char* p, bool* pfInvalid = nullptr);\n std::string DecodeBase64(const std::string& str);\n std::string EncodeBase64(const unsigned char* pch, size_t len);\n std::string EncodeBase64(const std::string& str);\n-std::vector<unsigned char> DecodeBase32(const char* p, bool* pfInvalid = NULL);\n+std::vector<unsigned char> DecodeBase32(const char* p, bool* pfInvalid = nullptr);\n std::string DecodeBase32(const std::string& str);\n std::string EncodeBase32(const unsigned char* pch, size_t len);\n std::string EncodeBase32(const std::string& str);"
      },
      {
        "sha": "4cc77dbfeb3521432b5dd02ceb676b33a7ad230b",
        "filename": "src/utiltime.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/utiltime.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/utiltime.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utiltime.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -21,7 +21,7 @@ int64_t GetTime()\n     int64_t mocktime = nMockTime.load(std::memory_order_relaxed);\n     if (mocktime) return mocktime;\n \n-    time_t now = time(NULL);\n+    time_t now = time(nullptr);\n     assert(now > 0);\n     return now;\n }"
      },
      {
        "sha": "5e0c710de0178693ba56779a40747b61ab7c4748",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 109,
        "deletions": 109,
        "changes": 218,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -61,7 +61,7 @@ CCriticalSection cs_main;\n \n BlockMap mapBlockIndex;\n CChain chainActive;\n-CBlockIndex *pindexBestHeader = NULL;\n+CBlockIndex *pindexBestHeader = nullptr;\n CWaitableCriticalSection csBestBlock;\n CConditionVariable cvBlockChange;\n int nScriptCheckThreads = 0;\n@@ -177,9 +177,9 @@ CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& loc\n     return chain.Genesis();\n }\n \n-CCoinsViewDB *pcoinsdbview = NULL;\n-CCoinsViewCache *pcoinsTip = NULL;\n-CBlockTreeDB *pblocktree = NULL;\n+CCoinsViewDB *pcoinsdbview = nullptr;\n+CCoinsViewCache *pcoinsTip = nullptr;\n+CBlockTreeDB *pblocktree = nullptr;\n \n enum FlushStateMode {\n     FLUSH_STATE_NONE,\n@@ -378,7 +378,7 @@ void UpdateMempoolForReorg(DisconnectedBlockTransactions &disconnectpool, bool f\n     while (it != disconnectpool.queuedTx.get<insertion_order>().rend()) {\n         // ignore validation errors in resurrected transactions\n         CValidationState stateDummy;\n-        if (!fAddToMempool || (*it)->IsCoinBase() || !AcceptToMemoryPool(mempool, stateDummy, *it, false, NULL, NULL, true)) {\n+        if (!fAddToMempool || (*it)->IsCoinBase() || !AcceptToMemoryPool(mempool, stateDummy, *it, false, nullptr, nullptr, true)) {\n             // If the transaction doesn't make it in to the mempool, remove any\n             // transactions that depend on it (which would now be orphans).\n             mempool.removeRecursive(**it, MemPoolRemovalReason::REORG);\n@@ -899,7 +899,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n /** Return transaction in txOut, and if it was found inside a block, its hash is placed in hashBlock */\n bool GetTransaction(const uint256 &hash, CTransactionRef &txOut, const Consensus::Params& consensusParams, uint256 &hashBlock, bool fAllowSlow)\n {\n-    CBlockIndex *pindexSlow = NULL;\n+    CBlockIndex *pindexSlow = nullptr;\n \n     LOCK(cs_main);\n \n@@ -1045,7 +1045,7 @@ bool IsInitialBlockDownload()\n         return false;\n     if (fImporting || fReindex)\n         return true;\n-    if (chainActive.Tip() == NULL)\n+    if (chainActive.Tip() == nullptr)\n         return true;\n     if (chainActive.Tip()->nChainWork < UintToArith256(chainParams.GetConsensus().nMinimumChainWork))\n         return true;\n@@ -1056,7 +1056,7 @@ bool IsInitialBlockDownload()\n     return false;\n }\n \n-CBlockIndex *pindexBestForkTip = NULL, *pindexBestForkBase = NULL;\n+CBlockIndex *pindexBestForkTip = nullptr, *pindexBestForkBase = nullptr;\n \n static void AlertNotify(const std::string& strMessage)\n {\n@@ -1086,7 +1086,7 @@ static void CheckForkWarningConditions()\n     // If our best fork is no longer within 72 blocks (+/- 12 hours if no one mines it)\n     // of our head, drop it\n     if (pindexBestForkTip && chainActive.Height() - pindexBestForkTip->nHeight >= 72)\n-        pindexBestForkTip = NULL;\n+        pindexBestForkTip = nullptr;\n \n     if (pindexBestForkTip || (pindexBestInvalid && pindexBestInvalid->nChainWork > chainActive.Tip()->nChainWork + (GetBlockProof(*chainActive.Tip()) * 6)))\n     {\n@@ -1226,7 +1226,7 @@ void InitScriptExecutionCache() {\n  * Check whether all inputs of this transaction are valid (no double spends, scripts & sigs, amounts)\n  * This does not modify the UTXO set.\n  *\n- * If pvChecks is not NULL, script checks are pushed onto it instead of being performed inline. Any\n+ * If pvChecks is not nullptr, script checks are pushed onto it instead of being performed inline. Any\n  * script checks which are not necessary (eg due to script execution cache hits) are, obviously,\n  * not pushed onto pvChecks/run.\n  *\n@@ -1633,7 +1633,7 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n     AssertLockHeld(cs_main);\n     assert(pindex);\n     // pindex->phashBlock can be null if called by CreateNewBlock/TestBlockValidity\n-    assert((pindex->phashBlock == NULL) ||\n+    assert((pindex->phashBlock == nullptr) ||\n            (*pindex->phashBlock == block.GetHash()));\n     int64_t nTimeStart = GetTimeMicros();\n \n@@ -1642,7 +1642,7 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n         return error(\"%s: Consensus::CheckBlock: %s\", __func__, FormatStateMessage(state));\n \n     // verify that the view's current state corresponds to the previous block\n-    uint256 hashPrevBlock = pindex->pprev == NULL ? uint256() : pindex->pprev->GetBlockHash();\n+    uint256 hashPrevBlock = pindex->pprev == nullptr ? uint256() : pindex->pprev->GetBlockHash();\n     assert(hashPrevBlock == view.GetBestBlock());\n \n     // Special case for the genesis block, skipping connection of its transactions\n@@ -1733,7 +1733,7 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n \n     CBlockUndo blockundo;\n \n-    CCheckQueueControl<CScriptCheck> control(fScriptChecks && nScriptCheckThreads ? &scriptcheckqueue : NULL);\n+    CCheckQueueControl<CScriptCheck> control(fScriptChecks && nScriptCheckThreads ? &scriptcheckqueue : nullptr);\n \n     std::vector<int> prevheights;\n     CAmount nFees = 0;\n@@ -1787,7 +1787,7 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n \n             std::vector<CScriptCheck> vChecks;\n             bool fCacheResults = fJustCheck; /* Don't cache results if we're actually connecting blocks (still consult the cache, though) */\n-            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, fCacheResults, txdata[i], nScriptCheckThreads ? &vChecks : NULL))\n+            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, fCacheResults, txdata[i], nScriptCheckThreads ? &vChecks : nullptr))\n                 return error(\"ConnectBlock(): CheckInputs on %s failed with %s\",\n                     tx.GetHash().ToString(), FormatStateMessage(state));\n             control.Add(vChecks);\n@@ -2014,7 +2014,7 @@ void static UpdateTip(CBlockIndex *pindexNew, const CChainParams& chainParams) {\n             }\n         }\n         // Check the version of the last 100 blocks to see if we need to upgrade:\n-        for (int i = 0; i < 100 && pindex != NULL; i++)\n+        for (int i = 0; i < 100 && pindex != nullptr; i++)\n         {\n             int32_t nExpectedVersion = ComputeBlockVersion(pindex->pprev, chainParams.GetConsensus());\n             if (pindex->nVersion > VERSIONBITS_LAST_OLD_BLOCK_VERSION && (pindex->nVersion & ~nExpectedVersion) != 0)\n@@ -2047,7 +2047,7 @@ void static UpdateTip(CBlockIndex *pindexNew, const CChainParams& chainParams) {\n   * should make the mempool consistent again by calling UpdateMempoolForReorg.\n   * with cs_main held.\n   *\n-  * If disconnectpool is NULL, then no disconnected transactions are added to\n+  * If disconnectpool is nullptr, then no disconnected transactions are added to\n   * disconnectpool (note that the caller is responsible for mempool consistency\n   * in any case).\n   */\n@@ -2103,7 +2103,7 @@ static int64_t nTimeChainState = 0;\n static int64_t nTimePostConnect = 0;\n \n struct PerBlockConnectTrace {\n-    CBlockIndex* pindex = NULL;\n+    CBlockIndex* pindex = nullptr;\n     std::shared_ptr<const CBlock> pblock;\n     std::shared_ptr<std::vector<CTransactionRef>> conflictedTxs;\n     PerBlockConnectTrace() : conflictedTxs(std::make_shared<std::vector<CTransactionRef>>()) {}\n@@ -2168,7 +2168,7 @@ class ConnectTrace {\n };\n \n /**\n- * Connect a new block to chainActive. pblock is either NULL or a pointer to a CBlock\n+ * Connect a new block to chainActive. pblock is either nullptr or a pointer to a CBlock\n  * corresponding to pindexNew, to bypass loading it again from disk.\n  *\n  * The block is added to connectTrace if connection succeeds.\n@@ -2233,13 +2233,13 @@ bool static ConnectTip(CValidationState& state, const CChainParams& chainparams,\n  */\n static CBlockIndex* FindMostWorkChain() {\n     do {\n-        CBlockIndex *pindexNew = NULL;\n+        CBlockIndex *pindexNew = nullptr;\n \n         // Find the best candidate header.\n         {\n             std::set<CBlockIndex*, CBlockIndexWorkComparator>::reverse_iterator it = setBlockIndexCandidates.rbegin();\n             if (it == setBlockIndexCandidates.rend())\n-                return NULL;\n+                return nullptr;\n             pindexNew = *it;\n         }\n \n@@ -2258,7 +2258,7 @@ static CBlockIndex* FindMostWorkChain() {\n             bool fMissingData = !(pindexTest->nStatus & BLOCK_HAVE_DATA);\n             if (fFailedChain || fMissingData) {\n                 // Candidate chain is not usable (either invalid or missing data)\n-                if (fFailedChain && (pindexBestInvalid == NULL || pindexNew->nChainWork > pindexBestInvalid->nChainWork))\n+                if (fFailedChain && (pindexBestInvalid == nullptr || pindexNew->nChainWork > pindexBestInvalid->nChainWork))\n                     pindexBestInvalid = pindexNew;\n                 CBlockIndex *pindexFailed = pindexNew;\n                 // Remove the entire chain from the set.\n@@ -2299,7 +2299,7 @@ static void PruneBlockIndexCandidates() {\n \n /**\n  * Try to make some progress towards making pindexMostWork the active block.\n- * pblock is either NULL or a pointer to a CBlock corresponding to pindexMostWork.\n+ * pblock is either nullptr or a pointer to a CBlock corresponding to pindexMostWork.\n  */\n static bool ActivateBestChainStep(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace)\n {\n@@ -2385,8 +2385,8 @@ static bool ActivateBestChainStep(CValidationState& state, const CChainParams& c\n static void NotifyHeaderTip() {\n     bool fNotify = false;\n     bool fInitialBlockDownload = false;\n-    static CBlockIndex* pindexHeaderOld = NULL;\n-    CBlockIndex* pindexHeader = NULL;\n+    static CBlockIndex* pindexHeaderOld = nullptr;\n+    CBlockIndex* pindexHeader = nullptr;\n     {\n         LOCK(cs_main);\n         pindexHeader = pindexBestHeader;\n@@ -2405,7 +2405,7 @@ static void NotifyHeaderTip() {\n \n /**\n  * Make the best chain active, in multiple steps. The result is either failure\n- * or an activated best chain. pblock is either NULL or a pointer to a block\n+ * or an activated best chain. pblock is either nullptr or a pointer to a block\n  * that is already loaded (to avoid loading it again from disk).\n  */\n bool ActivateBestChain(CValidationState &state, const CChainParams& chainparams, std::shared_ptr<const CBlock> pblock) {\n@@ -2414,8 +2414,8 @@ bool ActivateBestChain(CValidationState &state, const CChainParams& chainparams,\n     // us in the middle of ProcessNewBlock - do not assume pblock is set\n     // sanely for performance or correctness!\n \n-    CBlockIndex *pindexMostWork = NULL;\n-    CBlockIndex *pindexNewTip = NULL;\n+    CBlockIndex *pindexMostWork = nullptr;\n+    CBlockIndex *pindexNewTip = nullptr;\n     int nStopAtHeight = GetArg(\"-stopatheight\", DEFAULT_STOPATHEIGHT);\n     do {\n         boost::this_thread::interruption_point();\n@@ -2429,12 +2429,12 @@ bool ActivateBestChain(CValidationState &state, const CChainParams& chainparams,\n             ConnectTrace connectTrace(mempool); // Destructed before cs_main is unlocked\n \n             CBlockIndex *pindexOldTip = chainActive.Tip();\n-            if (pindexMostWork == NULL) {\n+            if (pindexMostWork == nullptr) {\n                 pindexMostWork = FindMostWorkChain();\n             }\n \n             // Whether we have anything to do at all.\n-            if (pindexMostWork == NULL || pindexMostWork == chainActive.Tip())\n+            if (pindexMostWork == nullptr || pindexMostWork == chainActive.Tip())\n                 return true;\n \n             bool fInvalidFound = false;\n@@ -2444,7 +2444,7 @@ bool ActivateBestChain(CValidationState &state, const CChainParams& chainparams,\n \n             if (fInvalidFound) {\n                 // Wipe cache, we may need another branch now.\n-                pindexMostWork = NULL;\n+                pindexMostWork = nullptr;\n             }\n             pindexNewTip = chainActive.Tip();\n             pindexFork = chainActive.FindFork(pindexOldTip);\n@@ -2569,14 +2569,14 @@ bool ResetBlockFailureFlags(CBlockIndex *pindex) {\n             }\n             if (it->second == pindexBestInvalid) {\n                 // Reset invalid block marker if it was pointing to one of those.\n-                pindexBestInvalid = NULL;\n+                pindexBestInvalid = nullptr;\n             }\n         }\n         it++;\n     }\n \n     // Remove the invalidity flag from all ancestors too.\n-    while (pindex != NULL) {\n+    while (pindex != nullptr) {\n         if (pindex->nStatus & BLOCK_FAILED_MASK) {\n             pindex->nStatus &= ~BLOCK_FAILED_MASK;\n             setDirtyBlockIndex.insert(pindex);\n@@ -2613,7 +2613,7 @@ static CBlockIndex* AddToBlockIndex(const CBlockHeader& block)\n     pindexNew->nTimeMax = (pindexNew->pprev ? std::max(pindexNew->pprev->nTimeMax, pindexNew->nTime) : pindexNew->nTime);\n     pindexNew->nChainWork = (pindexNew->pprev ? pindexNew->pprev->nChainWork : 0) + GetBlockProof(*pindexNew);\n     pindexNew->RaiseValidity(BLOCK_VALID_TREE);\n-    if (pindexBestHeader == NULL || pindexBestHeader->nChainWork < pindexNew->nChainWork)\n+    if (pindexBestHeader == nullptr || pindexBestHeader->nChainWork < pindexNew->nChainWork)\n         pindexBestHeader = pindexNew;\n \n     setDirtyBlockIndex.insert(pindexNew);\n@@ -2636,7 +2636,7 @@ static bool ReceivedBlockTransactions(const CBlock &block, CValidationState& sta\n     pindexNew->RaiseValidity(BLOCK_VALID_TRANSACTIONS);\n     setDirtyBlockIndex.insert(pindexNew);\n \n-    if (pindexNew->pprev == NULL || pindexNew->pprev->nChainTx) {\n+    if (pindexNew->pprev == nullptr || pindexNew->pprev->nChainTx) {\n         // If pindexNew is the genesis block or all parents are BLOCK_VALID_TRANSACTIONS.\n         std::deque<CBlockIndex*> queue;\n         queue.push_back(pindexNew);\n@@ -2650,7 +2650,7 @@ static bool ReceivedBlockTransactions(const CBlock &block, CValidationState& sta\n                 LOCK(cs_nBlockSequenceId);\n                 pindex->nSequenceId = nBlockSequenceId++;\n             }\n-            if (chainActive.Tip() == NULL || !setBlockIndexCandidates.value_comp()(pindex, chainActive.Tip())) {\n+            if (chainActive.Tip() == nullptr || !setBlockIndexCandidates.value_comp()(pindex, chainActive.Tip())) {\n                 setBlockIndexCandidates.insert(pindex);\n             }\n             std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> range = mapBlocksUnlinked.equal_range(pindex);\n@@ -2886,7 +2886,7 @@ std::vector<unsigned char> GenerateCoinbaseCommitment(CBlock& block, const CBloc\n     std::vector<unsigned char> ret(32, 0x00);\n     if (consensusParams.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout != 0) {\n         if (commitpos == -1) {\n-            uint256 witnessroot = BlockWitnessMerkleRoot(block, NULL);\n+            uint256 witnessroot = BlockWitnessMerkleRoot(block, nullptr);\n             CHash256().Write(witnessroot.begin(), 32).Write(ret.data(), 32).Finalize(witnessroot.begin());\n             CTxOut out;\n             out.nValue = 0;\n@@ -2913,7 +2913,7 @@ std::vector<unsigned char> GenerateCoinbaseCommitment(CBlock& block, const CBloc\n  *  set; UTXO-related validity checks are done in ConnectBlock(). */\n static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& state, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev, int64_t nAdjustedTime)\n {\n-    assert(pindexPrev != NULL);\n+    assert(pindexPrev != nullptr);\n     const int nHeight = pindexPrev->nHeight + 1;\n     // Check proof of work\n     if (block.nBits != GetNextWorkRequired(pindexPrev, &block, consensusParams))\n@@ -2940,7 +2940,7 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n \n static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev)\n {\n-    const int nHeight = pindexPrev == NULL ? 0 : pindexPrev->nHeight + 1;\n+    const int nHeight = pindexPrev == nullptr ? 0 : pindexPrev->nHeight + 1;\n \n     // Start enforcing BIP113 (Median Time Past) using versionbits logic.\n     int nLockTimeFlags = 0;\n@@ -3025,7 +3025,7 @@ static bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state\n     // Check for duplicate\n     uint256 hash = block.GetHash();\n     BlockMap::iterator miSelf = mapBlockIndex.find(hash);\n-    CBlockIndex *pindex = NULL;\n+    CBlockIndex *pindex = nullptr;\n     if (hash != chainparams.GetConsensus().hashGenesisBlock) {\n \n         if (miSelf != mapBlockIndex.end()) {\n@@ -3042,7 +3042,7 @@ static bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state\n             return error(\"%s: Consensus::CheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));\n \n         // Get prev block index\n-        CBlockIndex* pindexPrev = NULL;\n+        CBlockIndex* pindexPrev = nullptr;\n         BlockMap::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\n         if (mi == mapBlockIndex.end())\n             return state.DoS(10, error(\"%s: prev block not found\", __func__), 0, \"prev-blk-not-found\");\n@@ -3057,7 +3057,7 @@ static bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state\n         if (!ContextualCheckBlockHeader(block, state, chainparams.GetConsensus(), pindexPrev, GetAdjustedTime()))\n             return error(\"%s: Consensus::ContextualCheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));\n     }\n-    if (pindex == NULL)\n+    if (pindex == nullptr)\n         pindex = AddToBlockIndex(block);\n \n     if (ppindex)\n@@ -3074,7 +3074,7 @@ bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& headers, CValidatio\n     {\n         LOCK(cs_main);\n         for (const CBlockHeader& header : headers) {\n-            CBlockIndex *pindex = NULL; // Use a temp pindex instead of ppindex to avoid a const_cast\n+            CBlockIndex *pindex = nullptr; // Use a temp pindex instead of ppindex to avoid a const_cast\n             if (!AcceptBlockHeader(header, state, chainparams, &pindex)) {\n                 return false;\n             }\n@@ -3087,15 +3087,15 @@ bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& headers, CValidatio\n     return true;\n }\n \n-/** Store block on disk. If dbp is non-NULL, the file is known to already reside on disk */\n+/** Store block on disk. If dbp is non-nullptr, the file is known to already reside on disk */\n static bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex, bool fRequested, const CDiskBlockPos* dbp, bool* fNewBlock)\n {\n     const CBlock& block = *pblock;\n \n     if (fNewBlock) *fNewBlock = false;\n     AssertLockHeld(cs_main);\n \n-    CBlockIndex *pindexDummy = NULL;\n+    CBlockIndex *pindexDummy = nullptr;\n     CBlockIndex *&pindex = ppindex ? *ppindex : pindexDummy;\n \n     if (!AcceptBlockHeader(block, state, chainparams, &pindex))\n@@ -3148,11 +3148,11 @@ static bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CValidation\n     try {\n         unsigned int nBlockSize = ::GetSerializeSize(block, SER_DISK, CLIENT_VERSION);\n         CDiskBlockPos blockPos;\n-        if (dbp != NULL)\n+        if (dbp != nullptr)\n             blockPos = *dbp;\n-        if (!FindBlockPos(state, blockPos, nBlockSize+8, nHeight, block.GetBlockTime(), dbp != NULL))\n+        if (!FindBlockPos(state, blockPos, nBlockSize+8, nHeight, block.GetBlockTime(), dbp != nullptr))\n             return error(\"AcceptBlock(): FindBlockPos failed\");\n-        if (dbp == NULL)\n+        if (dbp == nullptr)\n             if (!WriteBlockToDisk(block, blockPos, chainparams.MessageStart()))\n                 AbortNode(state, \"Failed to write block\");\n         if (!ReceivedBlockTransactions(block, state, pindex, blockPos, chainparams.GetConsensus()))\n@@ -3170,7 +3170,7 @@ static bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CValidation\n bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, bool fForceProcessing, bool *fNewBlock)\n {\n     {\n-        CBlockIndex *pindex = NULL;\n+        CBlockIndex *pindex = nullptr;\n         if (fNewBlock) *fNewBlock = false;\n         CValidationState state;\n         // Ensure that CheckBlock() passes before calling AcceptBlock, as\n@@ -3181,7 +3181,7 @@ bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<cons\n \n         if (ret) {\n             // Store to disk\n-            ret = AcceptBlock(pblock, state, chainparams, &pindex, fForceProcessing, NULL, fNewBlock);\n+            ret = AcceptBlock(pblock, state, chainparams, &pindex, fForceProcessing, nullptr, fNewBlock);\n         }\n         CheckBlockIndex(chainparams.GetConsensus());\n         if (!ret) {\n@@ -3288,7 +3288,7 @@ static void FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nManualPr\n     assert(fPruneMode && nManualPruneHeight > 0);\n \n     LOCK2(cs_main, cs_LastBlockFile);\n-    if (chainActive.Tip() == NULL)\n+    if (chainActive.Tip() == nullptr)\n         return;\n \n     // last block to prune is the lesser of (user-specified height, MIN_BLOCKS_TO_KEEP from the tip)\n@@ -3330,7 +3330,7 @@ void PruneBlockFilesManual(int nManualPruneHeight)\n static void FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPruneAfterHeight)\n {\n     LOCK2(cs_main, cs_LastBlockFile);\n-    if (chainActive.Tip() == NULL || nPruneTarget == 0) {\n+    if (chainActive.Tip() == nullptr || nPruneTarget == 0) {\n         return;\n     }\n     if ((uint64_t)chainActive.Tip()->nHeight <= nPruneAfterHeight) {\n@@ -3388,21 +3388,21 @@ bool CheckDiskSpace(uint64_t nAdditionalBytes)\n static FILE* OpenDiskFile(const CDiskBlockPos &pos, const char *prefix, bool fReadOnly)\n {\n     if (pos.IsNull())\n-        return NULL;\n+        return nullptr;\n     fs::path path = GetBlockPosFilename(pos, prefix);\n     fs::create_directories(path.parent_path());\n     FILE* file = fsbridge::fopen(path, \"rb+\");\n     if (!file && !fReadOnly)\n         file = fsbridge::fopen(path, \"wb+\");\n     if (!file) {\n         LogPrintf(\"Unable to open file %s\\n\", path.string());\n-        return NULL;\n+        return nullptr;\n     }\n     if (pos.nPos) {\n         if (fseek(file, pos.nPos, SEEK_SET)) {\n             LogPrintf(\"Unable to seek to position %u of %s\\n\", pos.nPos, path.string());\n             fclose(file);\n-            return NULL;\n+            return nullptr;\n         }\n     }\n     return file;\n@@ -3425,7 +3425,7 @@ fs::path GetBlockPosFilename(const CDiskBlockPos &pos, const char *prefix)\n CBlockIndex * InsertBlockIndex(uint256 hash)\n {\n     if (hash.IsNull())\n-        return NULL;\n+        return nullptr;\n \n     // Return existing\n     BlockMap::iterator mi = mapBlockIndex.find(hash);\n@@ -3477,13 +3477,13 @@ bool static LoadBlockIndexDB(const CChainParams& chainparams)\n                 pindex->nChainTx = pindex->nTx;\n             }\n         }\n-        if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) && (pindex->nChainTx || pindex->pprev == NULL))\n+        if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) && (pindex->nChainTx || pindex->pprev == nullptr))\n             setBlockIndexCandidates.insert(pindex);\n         if (pindex->nStatus & BLOCK_FAILED_MASK && (!pindexBestInvalid || pindex->nChainWork > pindexBestInvalid->nChainWork))\n             pindexBestInvalid = pindex;\n         if (pindex->pprev)\n             pindex->BuildSkip();\n-        if (pindex->IsValid(BLOCK_VALID_TREE) && (pindexBestHeader == NULL || CBlockIndexWorkComparator()(pindexBestHeader, pindex)))\n+        if (pindex->IsValid(BLOCK_VALID_TREE) && (pindexBestHeader == nullptr || CBlockIndexWorkComparator()(pindexBestHeader, pindex)))\n             pindexBestHeader = pindex;\n     }\n \n@@ -3581,7 +3581,7 @@ CVerifyDB::~CVerifyDB()\n bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview, int nCheckLevel, int nCheckDepth)\n {\n     LOCK(cs_main);\n-    if (chainActive.Tip() == NULL || chainActive.Tip()->pprev == NULL)\n+    if (chainActive.Tip() == nullptr || chainActive.Tip()->pprev == nullptr)\n         return true;\n \n     // Verify blocks in the best chain\n@@ -3591,7 +3591,7 @@ bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview,\n     LogPrintf(\"Verifying last %i blocks at level %i\\n\", nCheckDepth, nCheckLevel);\n     CCoinsViewCache coins(coinsview);\n     CBlockIndex* pindexState = chainActive.Tip();\n-    CBlockIndex* pindexFailure = NULL;\n+    CBlockIndex* pindexFailure = nullptr;\n     int nGoodTransactions = 0;\n     CValidationState state;\n     int reportDone = 0;\n@@ -3784,7 +3784,7 @@ bool RewindBlockIndex(const CChainParams& params)\n             // of the blockchain).\n             break;\n         }\n-        if (!DisconnectTip(state, params, NULL)) {\n+        if (!DisconnectTip(state, params, nullptr)) {\n             return error(\"RewindBlockIndex: unable to disconnect block at height %i\", pindex->nHeight);\n         }\n         // Occasionally flush state to disk.\n@@ -3833,7 +3833,7 @@ bool RewindBlockIndex(const CChainParams& params)\n         }\n     }\n \n-    if (chainActive.Tip() != NULL) {\n+    if (chainActive.Tip() != nullptr) {\n         // We can't prune block index candidates based on our tip if we have\n         // no tip due to chainActive being empty!\n         PruneBlockIndexCandidates();\n@@ -3858,9 +3858,9 @@ void UnloadBlockIndex()\n {\n     LOCK(cs_main);\n     setBlockIndexCandidates.clear();\n-    chainActive.SetTip(NULL);\n-    pindexBestInvalid = NULL;\n-    pindexBestHeader = NULL;\n+    chainActive.SetTip(nullptr);\n+    pindexBestInvalid = nullptr;\n+    pindexBestHeader = nullptr;\n     mempool.clear();\n     mapBlocksUnlinked.clear();\n     vinfoBlockFile.clear();\n@@ -3997,7 +3997,7 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, CDiskB\n                 if (mapBlockIndex.count(hash) == 0 || (mapBlockIndex[hash]->nStatus & BLOCK_HAVE_DATA) == 0) {\n                     LOCK(cs_main);\n                     CValidationState state;\n-                    if (AcceptBlock(pblock, state, chainparams, NULL, true, dbp, NULL))\n+                    if (AcceptBlock(pblock, state, chainparams, nullptr, true, dbp, nullptr))\n                         nLoaded++;\n                     if (state.IsError())\n                         break;\n@@ -4031,7 +4031,7 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, CDiskB\n                                     head.ToString());\n                             LOCK(cs_main);\n                             CValidationState dummy;\n-                            if (AcceptBlock(pblockrecursive, dummy, chainparams, NULL, true, &it->second, NULL))\n+                            if (AcceptBlock(pblockrecursive, dummy, chainparams, nullptr, true, &it->second, nullptr))\n                             {\n                                 nLoaded++;\n                                 queue.push_back(pblockrecursive->GetHash());\n@@ -4078,35 +4078,35 @@ void static CheckBlockIndex(const Consensus::Params& consensusParams)\n \n     assert(forward.size() == mapBlockIndex.size());\n \n-    std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> rangeGenesis = forward.equal_range(NULL);\n+    std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> rangeGenesis = forward.equal_range(nullptr);\n     CBlockIndex *pindex = rangeGenesis.first->second;\n     rangeGenesis.first++;\n-    assert(rangeGenesis.first == rangeGenesis.second); // There is only one index entry with parent NULL.\n+    assert(rangeGenesis.first == rangeGenesis.second); // There is only one index entry with parent nullptr.\n \n     // Iterate over the entire block tree, using depth-first search.\n     // Along the way, remember whether there are blocks on the path from genesis\n     // block being explored which are the first to have certain properties.\n     size_t nNodes = 0;\n     int nHeight = 0;\n-    CBlockIndex* pindexFirstInvalid = NULL; // Oldest ancestor of pindex which is invalid.\n-    CBlockIndex* pindexFirstMissing = NULL; // Oldest ancestor of pindex which does not have BLOCK_HAVE_DATA.\n-    CBlockIndex* pindexFirstNeverProcessed = NULL; // Oldest ancestor of pindex for which nTx == 0.\n-    CBlockIndex* pindexFirstNotTreeValid = NULL; // Oldest ancestor of pindex which does not have BLOCK_VALID_TREE (regardless of being valid or not).\n-    CBlockIndex* pindexFirstNotTransactionsValid = NULL; // Oldest ancestor of pindex which does not have BLOCK_VALID_TRANSACTIONS (regardless of being valid or not).\n-    CBlockIndex* pindexFirstNotChainValid = NULL; // Oldest ancestor of pindex which does not have BLOCK_VALID_CHAIN (regardless of being valid or not).\n-    CBlockIndex* pindexFirstNotScriptsValid = NULL; // Oldest ancestor of pindex which does not have BLOCK_VALID_SCRIPTS (regardless of being valid or not).\n-    while (pindex != NULL) {\n+    CBlockIndex* pindexFirstInvalid = nullptr; // Oldest ancestor of pindex which is invalid.\n+    CBlockIndex* pindexFirstMissing = nullptr; // Oldest ancestor of pindex which does not have BLOCK_HAVE_DATA.\n+    CBlockIndex* pindexFirstNeverProcessed = nullptr; // Oldest ancestor of pindex for which nTx == 0.\n+    CBlockIndex* pindexFirstNotTreeValid = nullptr; // Oldest ancestor of pindex which does not have BLOCK_VALID_TREE (regardless of being valid or not).\n+    CBlockIndex* pindexFirstNotTransactionsValid = nullptr; // Oldest ancestor of pindex which does not have BLOCK_VALID_TRANSACTIONS (regardless of being valid or not).\n+    CBlockIndex* pindexFirstNotChainValid = nullptr; // Oldest ancestor of pindex which does not have BLOCK_VALID_CHAIN (regardless of being valid or not).\n+    CBlockIndex* pindexFirstNotScriptsValid = nullptr; // Oldest ancestor of pindex which does not have BLOCK_VALID_SCRIPTS (regardless of being valid or not).\n+    while (pindex != nullptr) {\n         nNodes++;\n-        if (pindexFirstInvalid == NULL && pindex->nStatus & BLOCK_FAILED_VALID) pindexFirstInvalid = pindex;\n-        if (pindexFirstMissing == NULL && !(pindex->nStatus & BLOCK_HAVE_DATA)) pindexFirstMissing = pindex;\n-        if (pindexFirstNeverProcessed == NULL && pindex->nTx == 0) pindexFirstNeverProcessed = pindex;\n-        if (pindex->pprev != NULL && pindexFirstNotTreeValid == NULL && (pindex->nStatus & BLOCK_VALID_MASK) < BLOCK_VALID_TREE) pindexFirstNotTreeValid = pindex;\n-        if (pindex->pprev != NULL && pindexFirstNotTransactionsValid == NULL && (pindex->nStatus & BLOCK_VALID_MASK) < BLOCK_VALID_TRANSACTIONS) pindexFirstNotTransactionsValid = pindex;\n-        if (pindex->pprev != NULL && pindexFirstNotChainValid == NULL && (pindex->nStatus & BLOCK_VALID_MASK) < BLOCK_VALID_CHAIN) pindexFirstNotChainValid = pindex;\n-        if (pindex->pprev != NULL && pindexFirstNotScriptsValid == NULL && (pindex->nStatus & BLOCK_VALID_MASK) < BLOCK_VALID_SCRIPTS) pindexFirstNotScriptsValid = pindex;\n+        if (pindexFirstInvalid == nullptr && pindex->nStatus & BLOCK_FAILED_VALID) pindexFirstInvalid = pindex;\n+        if (pindexFirstMissing == nullptr && !(pindex->nStatus & BLOCK_HAVE_DATA)) pindexFirstMissing = pindex;\n+        if (pindexFirstNeverProcessed == nullptr && pindex->nTx == 0) pindexFirstNeverProcessed = pindex;\n+        if (pindex->pprev != nullptr && pindexFirstNotTreeValid == nullptr && (pindex->nStatus & BLOCK_VALID_MASK) < BLOCK_VALID_TREE) pindexFirstNotTreeValid = pindex;\n+        if (pindex->pprev != nullptr && pindexFirstNotTransactionsValid == nullptr && (pindex->nStatus & BLOCK_VALID_MASK) < BLOCK_VALID_TRANSACTIONS) pindexFirstNotTransactionsValid = pindex;\n+        if (pindex->pprev != nullptr && pindexFirstNotChainValid == nullptr && (pindex->nStatus & BLOCK_VALID_MASK) < BLOCK_VALID_CHAIN) pindexFirstNotChainValid = pindex;\n+        if (pindex->pprev != nullptr && pindexFirstNotScriptsValid == nullptr && (pindex->nStatus & BLOCK_VALID_MASK) < BLOCK_VALID_SCRIPTS) pindexFirstNotScriptsValid = pindex;\n \n         // Begin: actual consistency checks.\n-        if (pindex->pprev == NULL) {\n+        if (pindex->pprev == nullptr) {\n             // Genesis block checks.\n             assert(pindex->GetBlockHash() == consensusParams.hashGenesisBlock); // Genesis block's hash must match.\n             assert(pindex == chainActive.Genesis()); // The current active chain's genesis block must be this block.\n@@ -4125,26 +4125,26 @@ void static CheckBlockIndex(const Consensus::Params& consensusParams)\n         if (pindex->nStatus & BLOCK_HAVE_UNDO) assert(pindex->nStatus & BLOCK_HAVE_DATA);\n         assert(((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_TRANSACTIONS) == (pindex->nTx > 0)); // This is pruning-independent.\n         // All parents having had data (at some point) is equivalent to all parents being VALID_TRANSACTIONS, which is equivalent to nChainTx being set.\n-        assert((pindexFirstNeverProcessed != NULL) == (pindex->nChainTx == 0)); // nChainTx != 0 is used to signal that all parent blocks have been processed (but may have been pruned).\n-        assert((pindexFirstNotTransactionsValid != NULL) == (pindex->nChainTx == 0));\n+        assert((pindexFirstNeverProcessed != nullptr) == (pindex->nChainTx == 0)); // nChainTx != 0 is used to signal that all parent blocks have been processed (but may have been pruned).\n+        assert((pindexFirstNotTransactionsValid != nullptr) == (pindex->nChainTx == 0));\n         assert(pindex->nHeight == nHeight); // nHeight must be consistent.\n-        assert(pindex->pprev == NULL || pindex->nChainWork >= pindex->pprev->nChainWork); // For every block except the genesis block, the chainwork must be larger than the parent's.\n+        assert(pindex->pprev == nullptr || pindex->nChainWork >= pindex->pprev->nChainWork); // For every block except the genesis block, the chainwork must be larger than the parent's.\n         assert(nHeight < 2 || (pindex->pskip && (pindex->pskip->nHeight < nHeight))); // The pskip pointer must point back for all but the first 2 blocks.\n-        assert(pindexFirstNotTreeValid == NULL); // All mapBlockIndex entries must at least be TREE valid\n-        if ((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_TREE) assert(pindexFirstNotTreeValid == NULL); // TREE valid implies all parents are TREE valid\n-        if ((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_CHAIN) assert(pindexFirstNotChainValid == NULL); // CHAIN valid implies all parents are CHAIN valid\n-        if ((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_SCRIPTS) assert(pindexFirstNotScriptsValid == NULL); // SCRIPTS valid implies all parents are SCRIPTS valid\n-        if (pindexFirstInvalid == NULL) {\n+        assert(pindexFirstNotTreeValid == nullptr); // All mapBlockIndex entries must at least be TREE valid\n+        if ((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_TREE) assert(pindexFirstNotTreeValid == nullptr); // TREE valid implies all parents are TREE valid\n+        if ((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_CHAIN) assert(pindexFirstNotChainValid == nullptr); // CHAIN valid implies all parents are CHAIN valid\n+        if ((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_SCRIPTS) assert(pindexFirstNotScriptsValid == nullptr); // SCRIPTS valid implies all parents are SCRIPTS valid\n+        if (pindexFirstInvalid == nullptr) {\n             // Checks for not-invalid blocks.\n             assert((pindex->nStatus & BLOCK_FAILED_MASK) == 0); // The failed mask cannot be set for blocks without invalid parents.\n         }\n-        if (!CBlockIndexWorkComparator()(pindex, chainActive.Tip()) && pindexFirstNeverProcessed == NULL) {\n-            if (pindexFirstInvalid == NULL) {\n+        if (!CBlockIndexWorkComparator()(pindex, chainActive.Tip()) && pindexFirstNeverProcessed == nullptr) {\n+            if (pindexFirstInvalid == nullptr) {\n                 // If this block sorts at least as good as the current tip and\n                 // is valid and we have all data for its parents, it must be in\n                 // setBlockIndexCandidates.  chainActive.Tip() must also be there\n                 // even if some data has been pruned.\n-                if (pindexFirstMissing == NULL || pindex == chainActive.Tip()) {\n+                if (pindexFirstMissing == nullptr || pindex == chainActive.Tip()) {\n                     assert(setBlockIndexCandidates.count(pindex));\n                 }\n                 // If some parent is missing, then it could be that this block was in\n@@ -4165,13 +4165,13 @@ void static CheckBlockIndex(const Consensus::Params& consensusParams)\n             }\n             rangeUnlinked.first++;\n         }\n-        if (pindex->pprev && (pindex->nStatus & BLOCK_HAVE_DATA) && pindexFirstNeverProcessed != NULL && pindexFirstInvalid == NULL) {\n+        if (pindex->pprev && (pindex->nStatus & BLOCK_HAVE_DATA) && pindexFirstNeverProcessed != nullptr && pindexFirstInvalid == nullptr) {\n             // If this block has block data available, some parent was never received, and has no invalid parents, it must be in mapBlocksUnlinked.\n             assert(foundInUnlinked);\n         }\n         if (!(pindex->nStatus & BLOCK_HAVE_DATA)) assert(!foundInUnlinked); // Can't be in mapBlocksUnlinked if we don't HAVE_DATA\n-        if (pindexFirstMissing == NULL) assert(!foundInUnlinked); // We aren't missing data for any parent -- cannot be in mapBlocksUnlinked.\n-        if (pindex->pprev && (pindex->nStatus & BLOCK_HAVE_DATA) && pindexFirstNeverProcessed == NULL && pindexFirstMissing != NULL) {\n+        if (pindexFirstMissing == nullptr) assert(!foundInUnlinked); // We aren't missing data for any parent -- cannot be in mapBlocksUnlinked.\n+        if (pindex->pprev && (pindex->nStatus & BLOCK_HAVE_DATA) && pindexFirstNeverProcessed == nullptr && pindexFirstMissing != nullptr) {\n             // We HAVE_DATA for this block, have received data for all parents at some point, but we're currently missing data for some parent.\n             assert(fHavePruned); // We must have pruned.\n             // This block may have entered mapBlocksUnlinked if:\n@@ -4183,7 +4183,7 @@ void static CheckBlockIndex(const Consensus::Params& consensusParams)\n             // So if this block is itself better than chainActive.Tip() and it wasn't in\n             // setBlockIndexCandidates, then it must be in mapBlocksUnlinked.\n             if (!CBlockIndexWorkComparator()(pindex, chainActive.Tip()) && setBlockIndexCandidates.count(pindex) == 0) {\n-                if (pindexFirstInvalid == NULL) {\n+                if (pindexFirstInvalid == nullptr) {\n                     assert(foundInUnlinked);\n                 }\n             }\n@@ -4204,13 +4204,13 @@ void static CheckBlockIndex(const Consensus::Params& consensusParams)\n         while (pindex) {\n             // We are going to either move to a parent or a sibling of pindex.\n             // If pindex was the first with a certain property, unset the corresponding variable.\n-            if (pindex == pindexFirstInvalid) pindexFirstInvalid = NULL;\n-            if (pindex == pindexFirstMissing) pindexFirstMissing = NULL;\n-            if (pindex == pindexFirstNeverProcessed) pindexFirstNeverProcessed = NULL;\n-            if (pindex == pindexFirstNotTreeValid) pindexFirstNotTreeValid = NULL;\n-            if (pindex == pindexFirstNotTransactionsValid) pindexFirstNotTransactionsValid = NULL;\n-            if (pindex == pindexFirstNotChainValid) pindexFirstNotChainValid = NULL;\n-            if (pindex == pindexFirstNotScriptsValid) pindexFirstNotScriptsValid = NULL;\n+            if (pindex == pindexFirstInvalid) pindexFirstInvalid = nullptr;\n+            if (pindex == pindexFirstMissing) pindexFirstMissing = nullptr;\n+            if (pindex == pindexFirstNeverProcessed) pindexFirstNeverProcessed = nullptr;\n+            if (pindex == pindexFirstNotTreeValid) pindexFirstNotTreeValid = nullptr;\n+            if (pindex == pindexFirstNotTransactionsValid) pindexFirstNotTransactionsValid = nullptr;\n+            if (pindex == pindexFirstNotChainValid) pindexFirstNotChainValid = nullptr;\n+            if (pindex == pindexFirstNotScriptsValid) pindexFirstNotScriptsValid = nullptr;\n             // Find our parent.\n             CBlockIndex* pindexPar = pindex->pprev;\n             // Find which child we just visited.\n@@ -4307,7 +4307,7 @@ bool LoadMempool(void)\n             CValidationState state;\n             if (nTime + nExpiryTimeout > nNow) {\n                 LOCK(cs_main);\n-                AcceptToMemoryPoolWithTime(chainparams, mempool, state, tx, true, NULL, nTime, NULL, false, 0);\n+                AcceptToMemoryPoolWithTime(chainparams, mempool, state, tx, true, nullptr, nTime, nullptr, false, 0);\n                 if (state.IsValid()) {\n                     ++count;\n                 } else {\n@@ -4383,10 +4383,10 @@ void DumpMempool(void)\n \n //! Guess how far we are in the verification process at the given block index\n double GuessVerificationProgress(const ChainTxData& data, CBlockIndex *pindex) {\n-    if (pindex == NULL)\n+    if (pindex == nullptr)\n         return 0.0;\n \n-    int64_t nNow = time(NULL);\n+    int64_t nNow = time(nullptr);\n \n     double fTxTotal;\n "
      },
      {
        "sha": "edb8eab894b1915009cb0c6c1926869bafebaf02",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -246,7 +246,7 @@ bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<cons\n  * @param[in]  chainparams The params for the chain we want to connect to\n  * @param[out] ppindex If set, the pointer will be set to point to the last new block index object for the given headers\n  */\n-bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& block, CValidationState& state, const CChainParams& chainparams, const CBlockIndex** ppindex=NULL);\n+bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& block, CValidationState& state, const CChainParams& chainparams, const CBlockIndex** ppindex=nullptr);\n \n /** Check whether enough disk space is available for an incoming block */\n bool CheckDiskSpace(uint64_t nAdditionalBytes = 0);\n@@ -255,7 +255,7 @@ FILE* OpenBlockFile(const CDiskBlockPos &pos, bool fReadOnly = false);\n /** Translation to a filesystem path */\n fs::path GetBlockPosFilename(const CDiskBlockPos &pos, const char *prefix);\n /** Import blocks from an external file */\n-bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, CDiskBlockPos *dbp = NULL);\n+bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, CDiskBlockPos *dbp = nullptr);\n /** Ensures we have a genesis block in the block tree, possibly writing one to disk. */\n bool LoadGenesisBlock(const CChainParams& chainparams);\n /** Load the block tree and coins database from disk,\n@@ -300,7 +300,7 @@ void PruneBlockFilesManual(int nManualPruneHeight);\n /** (try to) add transaction to memory pool\n  * plTxnReplaced will be appended to with all transactions replaced from mempool **/\n bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransactionRef &tx, bool fLimitFree,\n-                        bool* pfMissingInputs, std::list<CTransactionRef>* plTxnReplaced = NULL,\n+                        bool* pfMissingInputs, std::list<CTransactionRef>* plTxnReplaced = nullptr,\n                         bool fOverrideMempoolLimit=false, const CAmount nAbsurdFee=0);\n \n /** Convert CValidationState to a human-readable message for logging */\n@@ -346,7 +346,7 @@ bool TestLockPointValidity(const LockPoints* lp);\n  *\n  * See consensus/consensus.h for flag definitions.\n  */\n-bool CheckSequenceLocks(const CTransaction &tx, int flags, LockPoints* lp = NULL, bool useExistingLockPoints = false);\n+bool CheckSequenceLocks(const CTransaction &tx, int flags, LockPoints* lp = nullptr, bool useExistingLockPoints = false);\n \n /**\n  * Closure representing one script verification"
      },
      {
        "sha": "04a692d82644d8e3dc9f39c18445853cefe3e511",
        "filename": "src/versionbits.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/versionbits.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/versionbits.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/versionbits.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -28,14 +28,14 @@ ThresholdState AbstractThresholdConditionChecker::GetStateFor(const CBlockIndex*\n     int64_t nTimeTimeout = EndTime(params);\n \n     // A block's state is always the same as that of the first of its period, so it is computed based on a pindexPrev whose height equals a multiple of nPeriod - 1.\n-    if (pindexPrev != NULL) {\n+    if (pindexPrev != nullptr) {\n         pindexPrev = pindexPrev->GetAncestor(pindexPrev->nHeight - ((pindexPrev->nHeight + 1) % nPeriod));\n     }\n \n     // Walk backwards in steps of nPeriod to find a pindexPrev whose information is known\n     std::vector<const CBlockIndex*> vToCompute;\n     while (cache.count(pindexPrev) == 0) {\n-        if (pindexPrev == NULL) {\n+        if (pindexPrev == nullptr) {\n             // The genesis block is by definition defined.\n             cache[pindexPrev] = THRESHOLD_DEFINED;\n             break;\n@@ -112,7 +112,7 @@ BIP9Stats AbstractThresholdConditionChecker::GetStateStatisticsFor(const CBlockI\n     stats.period = Period(params);\n     stats.threshold = Threshold(params);\n \n-    if (pindex == NULL)\n+    if (pindex == nullptr)\n         return stats;\n \n     // Find beginning of period\n@@ -150,12 +150,12 @@ int AbstractThresholdConditionChecker::GetStateSinceHeightFor(const CBlockIndex*\n     // right now pindexPrev points to the block prior to the block that we are computing for, thus:\n     // if we are computing for the last block of a period, then pindexPrev points to the second to last block of the period, and\n     // if we are computing for the first block of a period, then pindexPrev points to the last block of the previous period.\n-    // The parent of the genesis block is represented by NULL.\n+    // The parent of the genesis block is represented by nullptr.\n     pindexPrev = pindexPrev->GetAncestor(pindexPrev->nHeight - ((pindexPrev->nHeight + 1) % nPeriod));\n \n     const CBlockIndex* previousPeriodParent = pindexPrev->GetAncestor(pindexPrev->nHeight - nPeriod);\n \n-    while (previousPeriodParent != NULL && GetStateFor(previousPeriodParent, params, cache) == initialState) {\n+    while (previousPeriodParent != nullptr && GetStateFor(previousPeriodParent, params, cache) == initialState) {\n         pindexPrev = previousPeriodParent;\n         previousPeriodParent = pindexPrev->GetAncestor(pindexPrev->nHeight - nPeriod);\n     }"
      },
      {
        "sha": "71dc0c85009094567b1829b5d3fb3e7fcafe10bc",
        "filename": "src/versionbits.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/versionbits.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/versionbits.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/versionbits.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -27,7 +27,7 @@ enum ThresholdState {\n \n // A map that gives the state for blocks whose height is a multiple of Period().\n // The map is indexed by the block's parent, however, so all keys in the map\n-// will either be NULL or a block with (height + 1) % Period() == 0.\n+// will either be nullptr or a block with (height + 1) % Period() == 0.\n typedef std::map<const CBlockIndex*, ThresholdState> ThresholdConditionCache;\n \n struct VBDeploymentInfo {"
      },
      {
        "sha": "4c06c2c1f97742b3f3dd8ba07a9b2e060dba9b88",
        "filename": "src/wallet/db.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 22,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/wallet/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/wallet/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -47,7 +47,7 @@ void CDBEnv::Reset()\n     fMockDb = false;\n }\n \n-CDBEnv::CDBEnv() : dbenv(NULL)\n+CDBEnv::CDBEnv() : dbenv(nullptr)\n {\n     Reset();\n }\n@@ -56,7 +56,7 @@ CDBEnv::~CDBEnv()\n {\n     EnvShutdown();\n     delete dbenv;\n-    dbenv = NULL;\n+    dbenv = nullptr;\n }\n \n void CDBEnv::Close()\n@@ -125,7 +125,7 @@ void CDBEnv::MakeMock()\n     dbenv->set_lk_max_objects(10000);\n     dbenv->set_flags(DB_AUTO_COMMIT, 1);\n     dbenv->log_set_config(DB_LOG_IN_MEMORY, 1);\n-    int ret = dbenv->open(NULL,\n+    int ret = dbenv->open(nullptr,\n                          DB_CREATE |\n                              DB_INIT_LOCK |\n                              DB_INIT_LOG |\n@@ -147,10 +147,10 @@ CDBEnv::VerifyResult CDBEnv::Verify(const std::string& strFile, recoverFunc_type\n     assert(mapFileUseCount.count(strFile) == 0);\n \n     Db db(dbenv, 0);\n-    int result = db.verify(strFile.c_str(), NULL, NULL, 0);\n+    int result = db.verify(strFile.c_str(), nullptr, nullptr, 0);\n     if (result == 0)\n         return VERIFY_OK;\n-    else if (recoverFunc == NULL)\n+    else if (recoverFunc == nullptr)\n         return RECOVER_FAIL;\n \n     // Try to recover:\n@@ -170,7 +170,7 @@ bool CDB::Recover(const std::string& filename, void *callbackDataIn, bool (*reco\n     int64_t now = GetTime();\n     newFilename = strprintf(\"%s.%d.bak\", filename, now);\n \n-    int result = bitdb.dbenv->dbrename(NULL, filename.c_str(), NULL,\n+    int result = bitdb.dbenv->dbrename(nullptr, filename.c_str(), nullptr,\n                                        newFilename.c_str(), DB_AUTO_COMMIT);\n     if (result == 0)\n         LogPrintf(\"Renamed %s to %s\\n\", filename, newFilename);\n@@ -190,7 +190,7 @@ bool CDB::Recover(const std::string& filename, void *callbackDataIn, bool (*reco\n     LogPrintf(\"Salvage(aggressive) found %u records\\n\", salvagedData.size());\n \n     std::unique_ptr<Db> pdbCopy(new Db(bitdb.dbenv, 0));\n-    int ret = pdbCopy->open(NULL,               // Txn pointer\n+    int ret = pdbCopy->open(nullptr,               // Txn pointer\n                             filename.c_str(),   // Filename\n                             \"main\",             // Logical db name\n                             DB_BTREE,           // Database type\n@@ -299,7 +299,7 @@ bool CDBEnv::Salvage(const std::string& strFile, bool fAggressive, std::vector<C\n     std::stringstream strDump;\n \n     Db db(dbenv, 0);\n-    int result = db.verify(strFile.c_str(), NULL, &strDump, flags);\n+    int result = db.verify(strFile.c_str(), nullptr, &strDump, flags);\n     if (result == DB_VERIFY_BAD) {\n         LogPrintf(\"CDBEnv::Salvage: Database salvage found errors, all data may not be recoverable.\\n\");\n         if (!fAggressive) {\n@@ -357,7 +357,7 @@ void CDBEnv::CheckpointLSN(const std::string& strFile)\n }\n \n \n-CDB::CDB(CWalletDBWrapper& dbw, const char* pszMode, bool fFlushOnCloseIn) : pdb(NULL), activeTxn(NULL)\n+CDB::CDB(CWalletDBWrapper& dbw, const char* pszMode, bool fFlushOnCloseIn) : pdb(nullptr), activeTxn(nullptr)\n {\n     fReadOnly = (!strchr(pszMode, '+') && !strchr(pszMode, 'w'));\n     fFlushOnClose = fFlushOnCloseIn;\n@@ -367,7 +367,7 @@ CDB::CDB(CWalletDBWrapper& dbw, const char* pszMode, bool fFlushOnCloseIn) : pdb\n     }\n     const std::string &strFilename = dbw.strFile;\n \n-    bool fCreate = strchr(pszMode, 'c') != NULL;\n+    bool fCreate = strchr(pszMode, 'c') != nullptr;\n     unsigned int nFlags = DB_THREAD;\n     if (fCreate)\n         nFlags |= DB_CREATE;\n@@ -380,7 +380,7 @@ CDB::CDB(CWalletDBWrapper& dbw, const char* pszMode, bool fFlushOnCloseIn) : pdb\n         strFile = strFilename;\n         ++env->mapFileUseCount[strFile];\n         pdb = env->mapDb[strFile];\n-        if (pdb == NULL) {\n+        if (pdb == nullptr) {\n             int ret;\n             pdb = new Db(env->dbenv, 0);\n \n@@ -392,16 +392,16 @@ CDB::CDB(CWalletDBWrapper& dbw, const char* pszMode, bool fFlushOnCloseIn) : pdb\n                     throw std::runtime_error(strprintf(\"CDB: Failed to configure for no temp file backing for database %s\", strFile));\n             }\n \n-            ret = pdb->open(NULL,                               // Txn pointer\n-                            fMockDb ? NULL : strFile.c_str(),   // Filename\n+            ret = pdb->open(nullptr,                               // Txn pointer\n+                            fMockDb ? nullptr : strFile.c_str(),   // Filename\n                             fMockDb ? strFile.c_str() : \"main\", // Logical db name\n                             DB_BTREE,                           // Database type\n                             nFlags,                             // Flags\n                             0);\n \n             if (ret != 0) {\n                 delete pdb;\n-                pdb = NULL;\n+                pdb = nullptr;\n                 --env->mapFileUseCount[strFile];\n                 strFile = \"\";\n                 throw std::runtime_error(strprintf(\"CDB: Error %d, can't open database %s\", ret, strFilename));\n@@ -443,8 +443,8 @@ void CDB::Close()\n         return;\n     if (activeTxn)\n         activeTxn->abort();\n-    activeTxn = NULL;\n-    pdb = NULL;\n+    activeTxn = nullptr;\n+    pdb = nullptr;\n \n     if (fFlushOnClose)\n         Flush();\n@@ -459,12 +459,12 @@ void CDBEnv::CloseDb(const std::string& strFile)\n {\n     {\n         LOCK(cs_db);\n-        if (mapDb[strFile] != NULL) {\n+        if (mapDb[strFile] != nullptr) {\n             // Close the database handle\n             Db* pdb = mapDb[strFile];\n             pdb->close(0);\n             delete pdb;\n-            mapDb[strFile] = NULL;\n+            mapDb[strFile] = nullptr;\n         }\n     }\n }\n@@ -492,7 +492,7 @@ bool CDB::Rewrite(CWalletDBWrapper& dbw, const char* pszSkip)\n                     CDB db(dbw, \"r\");\n                     Db* pdbCopy = new Db(env->dbenv, 0);\n \n-                    int ret = pdbCopy->open(NULL,               // Txn pointer\n+                    int ret = pdbCopy->open(nullptr,               // Txn pointer\n                                             strFileRes.c_str(), // Filename\n                                             \"main\",             // Logical db name\n                                             DB_BTREE,           // Database type\n@@ -527,7 +527,7 @@ bool CDB::Rewrite(CWalletDBWrapper& dbw, const char* pszSkip)\n                             }\n                             Dbt datKey(ssKey.data(), ssKey.size());\n                             Dbt datValue(ssValue.data(), ssValue.size());\n-                            int ret2 = pdbCopy->put(NULL, &datKey, &datValue, DB_NOOVERWRITE);\n+                            int ret2 = pdbCopy->put(nullptr, &datKey, &datValue, DB_NOOVERWRITE);\n                             if (ret2 > 0)\n                                 fSuccess = false;\n                         }\n@@ -541,10 +541,10 @@ bool CDB::Rewrite(CWalletDBWrapper& dbw, const char* pszSkip)\n                 }\n                 if (fSuccess) {\n                     Db dbA(env->dbenv, 0);\n-                    if (dbA.remove(strFile.c_str(), NULL, 0))\n+                    if (dbA.remove(strFile.c_str(), nullptr, 0))\n                         fSuccess = false;\n                     Db dbB(env->dbenv, 0);\n-                    if (dbB.rename(strFileRes.c_str(), NULL, strFile.c_str(), 0))\n+                    if (dbB.rename(strFileRes.c_str(), nullptr, strFile.c_str(), 0))\n                         fSuccess = false;\n                 }\n                 if (!fSuccess)"
      },
      {
        "sha": "3614e34fbba858f2b256a29cbfa35f7e462eced8",
        "filename": "src/wallet/db.h",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/wallet/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/wallet/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -77,10 +77,10 @@ class CDBEnv\n \n     DbTxn* TxnBegin(int flags = DB_TXN_WRITE_NOSYNC)\n     {\n-        DbTxn* ptxn = NULL;\n-        int ret = dbenv->txn_begin(NULL, &ptxn, flags);\n+        DbTxn* ptxn = nullptr;\n+        int ret = dbenv->txn_begin(nullptr, &ptxn, flags);\n         if (!ptxn || ret != 0)\n-            return NULL;\n+            return nullptr;\n         return ptxn;\n     }\n };\n@@ -191,7 +191,7 @@ class CDB\n         int ret = pdb->get(activeTxn, &datKey, &datValue, 0);\n         memory_cleanse(datKey.get_data(), datKey.get_size());\n         bool success = false;\n-        if (datValue.get_data() != NULL) {\n+        if (datValue.get_data() != nullptr) {\n             // Unserialize value\n             try {\n                 CDataStream ssValue((char*)datValue.get_data(), (char*)datValue.get_data() + datValue.get_size(), SER_DISK, CLIENT_VERSION);\n@@ -282,11 +282,11 @@ class CDB\n     Dbc* GetCursor()\n     {\n         if (!pdb)\n-            return NULL;\n-        Dbc* pcursor = NULL;\n-        int ret = pdb->cursor(NULL, &pcursor, 0);\n+            return nullptr;\n+        Dbc* pcursor = nullptr;\n+        int ret = pdb->cursor(nullptr, &pcursor, 0);\n         if (ret != 0)\n-            return NULL;\n+            return nullptr;\n         return pcursor;\n     }\n \n@@ -306,7 +306,7 @@ class CDB\n         int ret = pcursor->get(&datKey, &datValue, fFlags);\n         if (ret != 0)\n             return ret;\n-        else if (datKey.get_data() == NULL || datValue.get_data() == NULL)\n+        else if (datKey.get_data() == nullptr || datValue.get_data() == nullptr)\n             return 99999;\n \n         // Convert to streams\n@@ -342,7 +342,7 @@ class CDB\n         if (!pdb || !activeTxn)\n             return false;\n         int ret = activeTxn->commit(0);\n-        activeTxn = NULL;\n+        activeTxn = nullptr;\n         return (ret == 0);\n     }\n \n@@ -351,7 +351,7 @@ class CDB\n         if (!pdb || !activeTxn)\n             return false;\n         int ret = activeTxn->abort();\n-        activeTxn = NULL;\n+        activeTxn = nullptr;\n         return (ret == 0);\n     }\n \n@@ -366,7 +366,7 @@ class CDB\n         return Write(std::string(\"version\"), nVersion);\n     }\n \n-    bool static Rewrite(CWalletDBWrapper& dbw, const char* pszSkip = NULL);\n+    bool static Rewrite(CWalletDBWrapper& dbw, const char* pszSkip = nullptr);\n };\n \n #endif // BITCOIN_WALLET_DB_H"
      },
      {
        "sha": "2c6d93e1ad18b121ea640084ae6ea3e7e1abede0",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -1818,8 +1818,8 @@ UniValue listsinceblock(const JSONRPCRequest& request)\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    const CBlockIndex* pindex = NULL;    // Block index of the specified block or the common ancestor, if the block provided was in a deactivated chain.\n-    const CBlockIndex* paltindex = NULL; // Block index of the specified block, even if it's in a deactivated chain.\n+    const CBlockIndex* pindex = nullptr;    // Block index of the specified block or the common ancestor, if the block provided was in a deactivated chain.\n+    const CBlockIndex* paltindex = nullptr; // Block index of the specified block, even if it's in a deactivated chain.\n     int target_confirms = 1;\n     isminefilter filter = ISMINE_SPENDABLE;\n \n@@ -2720,10 +2720,10 @@ UniValue listunspent(const JSONRPCRequest& request)\n \n     UniValue results(UniValue::VARR);\n     std::vector<COutput> vecOutputs;\n-    assert(pwallet != NULL);\n+    assert(pwallet != nullptr);\n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    pwallet->AvailableCoins(vecOutputs, !include_unsafe, NULL, nMinimumAmount, nMaximumAmount, nMinimumSumAmount, nMaximumCount, nMinDepth, nMaxDepth);\n+    pwallet->AvailableCoins(vecOutputs, !include_unsafe, nullptr, nMinimumAmount, nMaximumAmount, nMinimumSumAmount, nMaximumCount, nMinDepth, nMaxDepth);\n     for (const COutput& out : vecOutputs) {\n         CTxDestination address;\n         const CScript& scriptPubKey = out.tx->tx->vout[out.i].scriptPubKey;"
      },
      {
        "sha": "db0808b93bce2734b4f61901248b7cd96e568c14",
        "filename": "src/wallet/rpcwallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/wallet/rpcwallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/wallet/rpcwallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -14,7 +14,7 @@ void RegisterWalletRPCCommands(CRPCTable &t);\n  * Figures out what wallet, if any, to use for a JSONRPCRequest.\n  *\n  * @param[in] request JSONRPCRequest that wishes to access a wallet\n- * @return NULL if no wallet should be used, or a pointer to the CWallet\n+ * @return nullptr if no wallet should be used, or a pointer to the CWallet\n  */\n CWallet *GetWalletForJSONRPCRequest(const JSONRPCRequest& request);\n "
      },
      {
        "sha": "98d957b322020c1e8738ac65dc590e8bcd49d28e",
        "filename": "src/wallet/test/crypto_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/wallet/test/crypto_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/wallet/test/crypto_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/crypto_tests.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -48,7 +48,7 @@ bool OldEncrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned char>\n     bool fOk = true;\n \n     EVP_CIPHER_CTX_init(ctx);\n-    if (fOk) fOk = EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, chKey, chIV) != 0;\n+    if (fOk) fOk = EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), nullptr, chKey, chIV) != 0;\n     if (fOk) fOk = EVP_EncryptUpdate(ctx, &vchCiphertext[0], &nCLen, &vchPlaintext[0], nLen) != 0;\n     if (fOk) fOk = EVP_EncryptFinal_ex(ctx, (&vchCiphertext[0]) + nCLen, &nFLen) != 0;\n     EVP_CIPHER_CTX_cleanup(ctx);\n@@ -76,7 +76,7 @@ bool OldDecrypt(const std::vector<unsigned char>& vchCiphertext, CKeyingMaterial\n     bool fOk = true;\n \n     EVP_CIPHER_CTX_init(ctx);\n-    if (fOk) fOk = EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, chKey, chIV) != 0;\n+    if (fOk) fOk = EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), nullptr, chKey, chIV) != 0;\n     if (fOk) fOk = EVP_DecryptUpdate(ctx, &vchPlaintext[0], &nPLen, &vchCiphertext[0], nLen) != 0;\n     if (fOk) fOk = EVP_DecryptFinal_ex(ctx, (&vchPlaintext[0]) + nPLen, &nFLen) != 0;\n     EVP_CIPHER_CTX_cleanup(ctx);"
      },
      {
        "sha": "e2f48c45ab93361937d8b86cc9293f6572341089",
        "filename": "src/wallet/test/wallet_test_fixture.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/wallet/test/wallet_test_fixture.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/wallet/test/wallet_test_fixture.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_test_fixture.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -28,7 +28,7 @@ WalletTestingSetup::~WalletTestingSetup()\n {\n     UnregisterValidationInterface(pwalletMain);\n     delete pwalletMain;\n-    pwalletMain = NULL;\n+    pwalletMain = nullptr;\n \n     bitdb.Flush(true);\n     bitdb.Reset();"
      },
      {
        "sha": "17b101ffefddb134e7f7a213089e51b596d8baac",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 23,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -85,7 +85,7 @@ const CWalletTx* CWallet::GetWalletTx(const uint256& hash) const\n     LOCK(cs_wallet);\n     std::map<uint256, CWalletTx>::const_iterator it = mapWallet.find(hash);\n     if (it == mapWallet.end())\n-        return NULL;\n+        return nullptr;\n     return &(it->second);\n }\n \n@@ -182,10 +182,10 @@ bool CWallet::AddKeyPubKeyWithDB(CWalletDB &walletdb, const CKey& secret, const\n         pwalletdbEncryption = &walletdb;\n     }\n     if (!CCryptoKeyStore::AddKeyPubKey(secret, pubkey)) {\n-        if (needsDB) pwalletdbEncryption = NULL;\n+        if (needsDB) pwalletdbEncryption = nullptr;\n         return false;\n     }\n-    if (needsDB) pwalletdbEncryption = NULL;\n+    if (needsDB) pwalletdbEncryption = nullptr;\n \n     // check if we need to remove from watch-only\n     CScript script;\n@@ -525,7 +525,7 @@ void CWallet::SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator> ran\n     // So: find smallest nOrderPos:\n \n     int nMinOrderPos = std::numeric_limits<int>::max();\n-    const CWalletTx* copyFrom = NULL;\n+    const CWalletTx* copyFrom = nullptr;\n     for (TxSpends::iterator it = range.first; it != range.second; ++it)\n     {\n         const uint256& hash = it->second;\n@@ -640,7 +640,7 @@ bool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n         pwalletdbEncryption = new CWalletDB(*dbw);\n         if (!pwalletdbEncryption->TxnBegin()) {\n             delete pwalletdbEncryption;\n-            pwalletdbEncryption = NULL;\n+            pwalletdbEncryption = nullptr;\n             return false;\n         }\n         pwalletdbEncryption->WriteMasterKey(nMasterKeyMaxID, kMasterKey);\n@@ -665,7 +665,7 @@ bool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n         }\n \n         delete pwalletdbEncryption;\n-        pwalletdbEncryption = NULL;\n+        pwalletdbEncryption = nullptr;\n \n         Lock();\n         Unlock(strWalletPassphrase);\n@@ -988,7 +988,7 @@ bool CWallet::LoadToWallet(const CWalletTx& wtxIn)\n /**\n  * Add a transaction to the wallet, or update it.  pIndex and posInBlock should\n  * be set when the transaction was known to be included in a block.  When\n- * pIndex == NULL, then wallet state is not updated in AddToWallet, but\n+ * pIndex == nullptr, then wallet state is not updated in AddToWallet, but\n  * notifications happen and cached balances are marked dirty.\n  *\n  * If fUpdate is true, existing transactions will be updated.\n@@ -1004,7 +1004,7 @@ bool CWallet::AddToWalletIfInvolvingMe(const CTransactionRef& ptx, const CBlockI\n     {\n         AssertLockHeld(cs_wallet);\n \n-        if (pIndex != NULL) {\n+        if (pIndex != nullptr) {\n             for (const CTxIn& txin : tx.vin) {\n                 std::pair<TxSpends::const_iterator, TxSpends::const_iterator> range = mapTxSpends.equal_range(txin.prevout);\n                 while (range.first != range.second) {\n@@ -1024,7 +1024,7 @@ bool CWallet::AddToWalletIfInvolvingMe(const CTransactionRef& ptx, const CBlockI\n             CWalletTx wtx(this, ptx);\n \n             // Get merkle branch if transaction was found in a block\n-            if (pIndex != NULL)\n+            if (pIndex != nullptr)\n                 wtx.SetMerkleBranch(pIndex, posInBlock);\n \n             return AddToWallet(wtx, false);\n@@ -1648,7 +1648,7 @@ bool CWalletTx::RelayWalletTransaction(CConnman* connman)\n std::set<uint256> CWalletTx::GetConflicts() const\n {\n     std::set<uint256> result;\n-    if (pwallet != NULL)\n+    if (pwallet != nullptr)\n     {\n         uint256 myHash = GetHash();\n         result = pwallet->GetConflicts(myHash);\n@@ -1845,7 +1845,7 @@ bool CWalletTx::IsTrusted() const\n     {\n         // Transactions not sent by us: not trusted\n         const CWalletTx* parent = pwallet->GetWalletTx(txin.prevout.hash);\n-        if (parent == NULL)\n+        if (parent == nullptr)\n             return false;\n         const CTxOut& parentOut = parent->tx->vout[txin.prevout.n];\n         if (pwallet->IsMine(parentOut) != ISMINE_SPENDABLE)\n@@ -3889,11 +3889,11 @@ CWallet* CWallet::CreateWalletFromFile(const std::string walletFile)\n         DBErrors nZapWalletRet = tempWallet->ZapWalletTx(vWtx);\n         if (nZapWalletRet != DB_LOAD_OK) {\n             InitError(strprintf(_(\"Error loading %s: Wallet corrupted\"), walletFile));\n-            return NULL;\n+            return nullptr;\n         }\n \n         delete tempWallet;\n-        tempWallet = NULL;\n+        tempWallet = nullptr;\n     }\n \n     uiInterface.InitMessage(_(\"Loading wallet...\"));\n@@ -3907,7 +3907,7 @@ CWallet* CWallet::CreateWalletFromFile(const std::string walletFile)\n     {\n         if (nLoadWalletRet == DB_CORRUPT) {\n             InitError(strprintf(_(\"Error loading %s: Wallet corrupted\"), walletFile));\n-            return NULL;\n+            return nullptr;\n         }\n         else if (nLoadWalletRet == DB_NONCRITICAL_ERROR)\n         {\n@@ -3917,16 +3917,16 @@ CWallet* CWallet::CreateWalletFromFile(const std::string walletFile)\n         }\n         else if (nLoadWalletRet == DB_TOO_NEW) {\n             InitError(strprintf(_(\"Error loading %s: Wallet requires newer version of %s\"), walletFile, _(PACKAGE_NAME)));\n-            return NULL;\n+            return nullptr;\n         }\n         else if (nLoadWalletRet == DB_NEED_REWRITE)\n         {\n             InitError(strprintf(_(\"Wallet needed to be rewritten: restart %s to complete\"), _(PACKAGE_NAME)));\n-            return NULL;\n+            return nullptr;\n         }\n         else {\n             InitError(strprintf(_(\"Error loading %s\"), walletFile));\n-            return NULL;\n+            return nullptr;\n         }\n     }\n \n@@ -3944,7 +3944,7 @@ CWallet* CWallet::CreateWalletFromFile(const std::string walletFile)\n         if (nMaxVersion < walletInstance->GetVersion())\n         {\n             InitError(_(\"Cannot downgrade wallet\"));\n-            return NULL;\n+            return nullptr;\n         }\n         walletInstance->SetMaxVersion(nMaxVersion);\n     }\n@@ -3967,7 +3967,7 @@ CWallet* CWallet::CreateWalletFromFile(const std::string walletFile)\n             walletInstance->SetDefaultKey(newDefaultKey);\n             if (!walletInstance->SetAddressBook(walletInstance->vchDefaultKey.GetID(), \"\", \"receive\")) {\n                 InitError(_(\"Cannot write default address\") += \"\\n\");\n-                return NULL;\n+                return nullptr;\n             }\n         }\n \n@@ -3977,11 +3977,11 @@ CWallet* CWallet::CreateWalletFromFile(const std::string walletFile)\n         bool useHD = GetBoolArg(\"-usehd\", DEFAULT_USE_HD_WALLET);\n         if (walletInstance->IsHDEnabled() && !useHD) {\n             InitError(strprintf(_(\"Error loading %s: You can't disable HD on an already existing HD wallet\"), walletFile));\n-            return NULL;\n+            return nullptr;\n         }\n         if (!walletInstance->IsHDEnabled() && useHD) {\n             InitError(strprintf(_(\"Error loading %s: You can't enable HD on an already existing non-HD wallet\"), walletFile));\n-            return NULL;\n+            return nullptr;\n         }\n     }\n \n@@ -4010,7 +4010,7 @@ CWallet* CWallet::CreateWalletFromFile(const std::string walletFile)\n \n             if (pindexRescan != block) {\n                 InitError(_(\"Prune: last wallet synchronisation goes beyond pruned data. You need to -reindex (download the whole blockchain again in case of pruned node)\"));\n-                return NULL;\n+                return nullptr;\n             }\n         }\n \n@@ -4280,5 +4280,5 @@ int CMerkleTx::GetBlocksToMaturity() const\n \n bool CMerkleTx::AcceptToMemoryPool(const CAmount& nAbsurdFee, CValidationState& state)\n {\n-    return ::AcceptToMemoryPool(mempool, state, tx, true, NULL, NULL, false, nAbsurdFee);\n+    return ::AcceptToMemoryPool(mempool, state, tx, true, nullptr, nullptr, false, nAbsurdFee);\n }"
      },
      {
        "sha": "a75f1b3fe573bc6d863341a49faa395f1db4ac54",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -342,7 +342,7 @@ class CWalletTx : public CMerkleTx\n \n     CWalletTx()\n     {\n-        Init(NULL);\n+        Init(nullptr);\n     }\n \n     CWalletTx(const CWallet* pwalletIn, CTransactionRef arg) : CMerkleTx(std::move(arg))\n@@ -386,7 +386,7 @@ class CWalletTx : public CMerkleTx\n     template <typename Stream, typename Operation>\n     inline void SerializationOp(Stream& s, Operation ser_action) {\n         if (ser_action.ForRead())\n-            Init(NULL);\n+            Init(nullptr);\n         char fSpent = false;\n \n         if (!ser_action.ForRead())\n@@ -662,7 +662,7 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n      * all coins from coinControl are selected; Never select unconfirmed coins\n      * if they are not ours\n      */\n-    bool SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CCoinControl *coinControl = NULL) const;\n+    bool SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CCoinControl *coinControl = nullptr) const;\n \n     CWalletDB *pwalletdbEncryption;\n \n@@ -693,7 +693,7 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n \n     /* Used by TransactionAddedToMemorypool/BlockConnected/Disconnected.\n      * Should be called with pindexBlock and posInBlock if this is for a transaction that is included in a block. */\n-    void SyncTransaction(const CTransactionRef& tx, const CBlockIndex *pindex = NULL, int posInBlock = 0);\n+    void SyncTransaction(const CTransactionRef& tx, const CBlockIndex *pindex = nullptr, int posInBlock = 0);\n \n     /* the HD chain data model (external chain counters) */\n     CHDChain hdChain;\n@@ -786,15 +786,15 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     ~CWallet()\n     {\n         delete pwalletdbEncryption;\n-        pwalletdbEncryption = NULL;\n+        pwalletdbEncryption = nullptr;\n     }\n \n     void SetNull()\n     {\n         nWalletVersion = FEATURE_BASE;\n         nWalletMaxVersion = FEATURE_BASE;\n         nMasterKeyMaxID = 0;\n-        pwalletdbEncryption = NULL;\n+        pwalletdbEncryption = nullptr;\n         nOrderPosNext = 0;\n         nAccountingEntryNumber = 0;\n         nNextResend = 0;\n@@ -832,7 +832,7 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     /**\n      * populate vCoins with vector of available COutputs.\n      */\n-    void AvailableCoins(std::vector<COutput>& vCoins, bool fOnlySafe=true, const CCoinControl *coinControl = NULL, const CAmount& nMinimumAmount = 1, const CAmount& nMaximumAmount = MAX_MONEY, const CAmount& nMinimumSumAmount = MAX_MONEY, const uint64_t& nMaximumCount = 0, const int& nMinDepth = 0, const int& nMaxDepth = 9999999) const;\n+    void AvailableCoins(std::vector<COutput>& vCoins, bool fOnlySafe=true, const CCoinControl *coinControl = nullptr, const CAmount& nMinimumAmount = 1, const CAmount& nMaximumAmount = MAX_MONEY, const CAmount& nMinimumSumAmount = MAX_MONEY, const uint64_t& nMaximumCount = 0, const int& nMinDepth = 0, const int& nMaxDepth = 9999999) const;\n \n     /**\n      * Return list of available coins and locked coins grouped by non-change output address.\n@@ -921,7 +921,7 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n      * Increment the next transaction order id\n      * @return next transaction order id\n      */\n-    int64_t IncOrderPosNext(CWalletDB *pwalletdb = NULL);\n+    int64_t IncOrderPosNext(CWalletDB *pwalletdb = nullptr);\n     DBErrors ReorderTransactions();\n     bool AccountMove(std::string strFrom, std::string strTo, CAmount nAmount, std::string strComment = \"\");\n     bool GetAccountPubkey(CPubKey &pubKey, std::string strAccount, bool bForceNew = false);\n@@ -1049,7 +1049,7 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     bool SetDefaultKey(const CPubKey &vchPubKey);\n \n     //! signify that a particular wallet feature is now used. this may change nWalletVersion and nWalletMaxVersion if those are lower\n-    bool SetMinVersion(enum WalletFeature, CWalletDB* pwalletdbIn = NULL, bool fExplicit = false);\n+    bool SetMinVersion(enum WalletFeature, CWalletDB* pwalletdbIn = nullptr, bool fExplicit = false);\n \n     //! change which version we're allowed to upgrade to (note that this does not immediately imply upgrading to that format)\n     bool SetMaxVersion(int nVersion);"
      },
      {
        "sha": "c8dc526264f49a3a9a7e8c1869275645321edd8b",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -787,7 +787,7 @@ bool CWalletDB::Recover(const std::string& filename, std::string& out_backup_fil\n {\n     // recover without a key filter callback\n     // results in recovering all record types\n-    return CWalletDB::Recover(filename, NULL, NULL, out_backup_filename);\n+    return CWalletDB::Recover(filename, nullptr, nullptr, out_backup_filename);\n }\n \n bool CWalletDB::RecoverKeysOnlyFilter(void *callbackData, CDataStream ssKey, CDataStream ssValue)"
      },
      {
        "sha": "b637f26fb20d580b3dd9f5a9c4da4cf78cbd7cf7",
        "filename": "src/zmq/zmqnotificationinterface.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/90d4d89230434493c3b1e9174abed2609ba74cf1/src/zmq/zmqnotificationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/90d4d89230434493c3b1e9174abed2609ba74cf1/src/zmq/zmqnotificationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqnotificationinterface.cpp?ref=90d4d89230434493c3b1e9174abed2609ba74cf1",
        "patch": "@@ -15,7 +15,7 @@ void zmqError(const char *str)\n     LogPrint(BCLog::ZMQ, \"zmq: Error: %s, errno=%s\\n\", str, zmq_strerror(errno));\n }\n \n-CZMQNotificationInterface::CZMQNotificationInterface() : pcontext(NULL)\n+CZMQNotificationInterface::CZMQNotificationInterface() : pcontext(nullptr)\n {\n }\n \n@@ -31,7 +31,7 @@ CZMQNotificationInterface::~CZMQNotificationInterface()\n \n CZMQNotificationInterface* CZMQNotificationInterface::Create()\n {\n-    CZMQNotificationInterface* notificationInterface = NULL;\n+    CZMQNotificationInterface* notificationInterface = nullptr;\n     std::map<std::string, CZMQNotifierFactory> factories;\n     std::list<CZMQAbstractNotifier*> notifiers;\n \n@@ -62,7 +62,7 @@ CZMQNotificationInterface* CZMQNotificationInterface::Create()\n         if (!notificationInterface->Initialize())\n         {\n             delete notificationInterface;\n-            notificationInterface = NULL;\n+            notificationInterface = nullptr;\n         }\n     }\n "
      }
    ]
  }
]