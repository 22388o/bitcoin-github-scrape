luke-jr,2020-03-04 20:04:21,How does it react to diverse network policies?,https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-594803706,594803706,
Empact,2020-03-04 20:13:31,Concept ACK,https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-594810354,594810354,
naumenkogs,2020-03-07 19:23:20,"@luke-jr \n\nWhen it comes to network policies, I'm using the same code originally used by regular gossip (""Determine transactions to relay"" in net_processing.cpp). So nothing should be lost or sent wastefully as a result of policy discrepancies.",https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-596129273,596129273,
gmaxwell,2020-03-08 22:57:38,"@luke-jr  I'm understanding your question as being inspired by earlier 'mempool sync' ideas that would bleed bandwidth if there was a long lasting mempool discrepancy.\n\nErlay isn't a mempool sync. It's uses a way of communicating lists of things you want to relay which only takes bandwidth proportional to the difference rather than the total size.  So there is no on-going bandwidth usage due t",https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-596262994,596262994,
practicalswift,2020-03-09 19:57:19,"@naumenkogs When trying out this PR I ran in to two small testing issues:\n\n* The suffix of the functional test `p2p_erlay` is `.p2p` (`p2p_erlay.p2p`) instead of the expected `.py` (`p2p_erlay.py`) :)\n* It seems like `make check` runs the `minisketch` binaries `test-exhaust` and `test-exhaust-verify`. The running times of these are quite substantial - is there some way to do a quick sanity c",https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-596749292,596749292,
sipa,2020-03-09 20:48:48,@practicalswift The unit test minisketch binaries actually run forever. I need to fix that.,https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-596771889,596771889,
practicalswift,2020-03-09 22:10:51,"@naumenkogs \n\nI did some robustness testing of this code by pulling in PRs #17989 (`ProcessMessage(‚Ä¶)` fuzzer). and #18288 (MemorySanitizer) and found an use of uninitialized memory (UUM) that is remotely triggerable.\n\nYou can reproduce the issue by pulling in the commits from those PR:s and simply run:\n\n```\n$ src/test/fuzz/process_message\n‚Ä¶\n```\n\nThe issue will be hit within ",https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-596803815,596803815,
practicalswift,2020-03-11 16:45:53,Needs rebase :),https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-597743053,597743053,
naumenkogs,2020-03-11 19:26:21,"I made some latest changes to make sure it can be plugged into a real network.\nPlease help with testing this by running a couple inter-connected Erlay nodes, and observing bandwidth (and ideally tx relay latency).\n\n@practicalswift I was planning to rebase once #18044 is merged.",https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-597823928,597823928,
naumenkogs,2020-03-15 17:41:16,"I ran 2 non-reachable nodes for around 24 hours, one is regular [wtxid-node](https://github.com/bitcoin/bitcoin/pull/18044) connected to legacy nodes, one is Erlay node connected to reconciliation-supporting nodes on the same host.\n\nBandwidth breakdown (in megabytes):\n\n|  | Legacy (sent) | Erlay (sent) | Legacy (received) | Erlay (received) |\n|----------------------------------|---------",https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-599241490,599241490,
naumenkogs,2020-03-18 02:12:12,"More experiments: now I ran the same 2 nodes for 24 hours, but connected to 16 instead of 8 nodes (yeah, all 16 peers of Erlay node support reconciliation).\n\nLegacy wtxid-relay node spent 150 megabytes for announcements, while Erlay node spent 24 megabytes. Since these 2 days might have had different activity, it makes sense to compare the growth.. Legacy grew 2.23x (I guess due to more INVs i",https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-600388543,600388543,
DrahtBot,2020-03-20 01:01:20,"<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #21148 (Split orphan handling from net_processing into txorphanage by ajtowns)\n* #21015 (Make all of net_processing (and ",https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-601483568,601483568,
naumenkogs,2020-04-19 21:42:12,"@mzumsande thank you for taking a look! I'll do my best to find the cause.\n\nSome external eyes looking at the code would definitely help to both confirm the approach and troubleshoot issues like this :)",https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-616229738,616229738,
naumenkogs,2020-04-21 20:31:17,"Alright, all the tests should be passing now, also rebased.\n\nThere's one last test that fails consistently: p2p_segwit.py.\nI'll take a look at that, and upgrade the code for recent minisketch (with reconciliation capacity checksum thing) soon.\n\nOne good idea for the future: test that legacy nodes talk OK alright to erlay nodes (I checked it only manually).\n",https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-617398513,617398513,
sipa,2020-04-21 20:40:26,@naumenkogs Please have a look at this: https://github.com/sipa/minisketch/pull/23,https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-617402629,617402629,
naumenkogs,2020-05-07 14:15:34,"This should be in reviewable state now: I split commits more, fixed all the tests, made it more stable, addressed feedback by @mzumsande, updated with new helpers from minisketch.\n\nTravis failed last time because of the little issue with minisketch release build, but it should work just fine for local testing and experiments!\nWill rebase again when #18044 is rebased to not create much discre",https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-625282154,625282154,
naumenkogs,2020-07-28 07:35:47,"Rebased on #18044, but we will probably get #19184 before Erlay first, so please review that first.\nAlthough this PR is in a reviewable state right now!\n\nThis PR currently doesn't pass travis tests because of the minisketch build issue after the recent patch. Should work locally and shouldn't stop people from reviewing this work :)",https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-664831828,664831828,
practicalswift,2020-10-02 09:08:37,"It seems like the tests are failing and that a rebase is needed.\n\nI'm super excited about Erlay! :) What is the plan ahead?",https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-702616037,702616037,
naumenkogs,2020-10-02 11:26:33,"@practicalswift we kinda agreed that #19988 is a prerequisite, I hope Erlay becomes a priority right after :)",https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-702679529,702679529,
naumenkogs,2020-11-17 13:34:12,"Rebased, added a bunch of comments and restructured commits for better review.\n\nMarking it as reviewable now, although my fight with Travis builds is not over yet :)",https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-728930036,728930036,
naumenkogs,2020-11-19 17:49:00,"Me and @sipa decided to switch to ""extension sketches"": instead of requesting a bisection, someone who failed to decode the difference from the initial sketch, may ask for an extension of the initial sketch.\nA responder then have to send syndromes of higher order only.\n\nThe main motivation is it seems like bisection adds a lot of complexity (see b5c92a41e4cc0599504cf838d20212f1a403e573).\nE",https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-730536171,730536171,
naumenkogs,2020-11-21 21:39:09,"Okay, now the [BIP PR](https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-600388543) is up-to-date with this code, and this stuff is ready for full review again.",https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-731640683,731640683,
ariard,2020-12-01 13:41:48,"Starting the review by digging into the BIP :)\n\nFew remarks :\n1) ""improves privacy as a side-effect"", it would be great to explain and document this claim, maybe add a section in Rationale ?\n2) ""truncated transaction IDs"",  AFAIU, Erlay introduces new shortened transaction identifiers for regular tx-relay, maybe it could be better to call them ""truncated WTXID"" ? If BIP 330 implies BIP 339",https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-736558694,736558694,
DrahtBot,2021-01-11 21:34:07,"<!--cf906140f33d8803c4a75a2196329ecb-->\nüêô This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a ""draft"".</sub>",https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-758239282,758239282,
unseddd,2021-02-10 04:21:25,"Added a couple fuzz harnesses in my [erlay](https://github.com/unseddd/bitcoin/tree/erlay) branch, if you want them.\n\nAlso contains some other minor fixups, like a change for [src/test/fuzz/net.cpp](https://github.com/bitcoin/bitcoin/blob/master/src/test/fuzz/net.cpp#L89) (for the `flood` param):\n\n```diff\ndiff --git a/src/test/fuzz/net.cpp b/src/test/fuzz/net.cpp\nindex 31b99600e..7d48a",https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-776429091,776429091,
unseddd,2021-02-10 04:31:31,"Concept ACK\n\nI understand that the requestor being the one to compute the sketches protects public nodes against potential DoS. Are there any protections for requestor(s)?\n\nThinking about the scenario where one public node requests a sketch from a malicious public node who returns parameters for high diff sketches as a DoS.",https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-776431981,776431981,
jnewbery,2021-02-10 10:27:15,"I think the approach needs rethinking for the reasons stated here: https://github.com/bitcoin/bitcoin/pull/18261#pullrequestreview-570100861. The Erlay logic in this PR is spread across many functions in net_processing.cpp and reconcilliation.h, which means that it's impossible to test that logic in isolation. I suppose that's why there aren't any unit tests included in this PR.\n\nI think it wo",https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-776608307,776608307,
jonatack,2021-02-10 10:43:38,"Needs rebase.\n\nEdit: This has 166 hidden comments, so apologies if I missed something, but are there any special build steps or flags to pass? With gcc 10.2.1 I'm seeing 16 occurrences of the same build warning (see comment below) and the functional tests are all failing for me with `detected inconsistent lock order for 'peer->m_recon_state_mutex' in net_processing.cpp:4936 (in thread 'msghand",https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-776618414,776618414,
pinheadmz,2021-02-10 15:19:29,"Update: With a  `make clean`, branch compiled fine. Sorry Gleb!\n\nI had issues compiling this branch as well. Full error: https://pastebin.com/6mc9eRed\n\nMostly errors like this:\n```\n  CXXLD    libbitcoinconsensus.la\n\nUndefined symbols for architecture x86_64:\n  ""ChaCha20::ChaCha20(unsigned char const*, unsigned long)"", referenced from:\n```\n\nCommand: ` ./autogen.sh && ./confi",https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-776779899,776779899,
pinheadmz,2021-02-10 15:59:46,"@naumenkogs the new test I think has the wrong permissions:\n\n```\n-rwxr-xr-x    1 matthewzipkin  staff    5718 Feb  3 10:10 p2p_disconnect_ban.py\n-rwxr-xr-x    1 matthewzipkin  staff    3833 Dec  3 15:09 p2p_dos_header_tree.py\n-rw-r--r--    1 matthewzipkin  staff   28920 Feb 10 09:34 p2p_erlay.py\n-rwxr-xr-x    1 matthewzipkin  staff    5741 Feb  3 10:10 p2p_eviction.py\n-rwxr-xr-x    1",https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-776813912,776813912,
jonatack,2021-02-11 00:02:35,"> @naumenkogs the new test I think has the wrong permissions:\n> -bash: test/functional/p2p_erlay.py: Permission denied\n\nConfirming @pinheadmz' comment, I needed to run `chmod 755 test/functional/p2p_erlay.py` on the file. The test then fails with `Assertion failed: detected inconsistent lock order for 'cs_main' in net_processing.cpp:2933 (in thread 'msghand')`\n\n<details><summary>tracebac",https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-777122712,777122712,
pinheadmz,2021-02-11 14:20:17,@jonasnick I `chmod a+x` and the test ran and passed.,https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-777493335,777493335,
jonatack,2021-02-11 14:58:57,"> the test ran and passed.\n\nBuilding with `--enable-debug`? The lock order errors seem pertinent to these changes. I even rebuilt again a few hours later yesterday after updating my depends; same thing. It's odd if no one else is seeing them.",https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-777537174,777537174,
jonatack,2021-02-11 15:00:57,"I suppose if no one is seeing the issues, I'll wait until the next push here and look at what the CI says.",https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-777541288,777541288,
naumenkogs,2021-03-02 13:24:42,"An update here.\nBased on some suggestions, I moved reconciliation to a separate module.\nI suggest doing some initial review of that in [the PR in my repo](https://github.com/naumenkogs/bitcoin/pull/2). Could you folks help to evaluate my new approach? @jnewbery @amitiuttarwar @sipa @jonatack (everyone else is welcome too)\n\nThis way we could save the review efforts of those contributors who",https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-788906220,788906220,
amitiuttarwar,2021-03-08 19:42:15,@naumenkogs I took a first look and I see that most of the comments I've left here are still applicable. I'm happy to do a deeper dive on the branch one you've addressed the outstanding comments.,https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-793022594,793022594,
naumenkogs,2021-03-23 21:00:28,Closing in favor of #21515. I believe I addressed most of the comments from here.,https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-805256489,805256489,
naumenkogs,2021-03-28 08:08:45,#21515 is ready for review now,https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-808863278,808863278,
practicalswift,2020-03-04 20:49:13,"I'm afraid `std::to_string` is locale dependent.\n\n---\n\nFor those interested in permanently killing the locale dependency bug class, consider reviewing:\n* #18124 ‚Äì init: Clarify C and C++ locale assumptions. Add locale sanity checks to verify assumptions at run-time\n* #18126 ‚Äì tests: Add fuzzing harness testing the locale independence of the `strencodings.h` functions\n* #18147 ‚Äì qt: K",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r387925726,387925726,src/net_processing.cpp
mzumsande,2020-04-21 16:19:22,"I think that this is UB (if no wtxid for a shortid is found, there is a LogPrint, but the item is still dereferenced).\nWhile this should explain the strange wtxids with lots of 0s, it doesn't explain the why no mapping is found to begin with.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r412301986,412301986,src/net.cpp
naumenkogs,2020-04-21 17:17:13,"I found an issue, will commit the fix later today!\nBasically, sometimes reconcil. difference finding gives a false positive: it looks like a success, but some difference elements are missing.\nThis is just a natural property of math in minisketch. I'll submit a workaround.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r412342381,412342381,src/net.cpp
naumenkogs,2020-04-21 18:13:33,Still not sure why it would be UB here? It just accesses the existing array element..,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r412382710,412382710,src/net.cpp
sipa,2020-04-21 18:16:16,You can't dereference local_tx when it is .end().,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r412384640,412384640,src/net.cpp
mzumsande,2020-04-21 18:23:20,"I may be off, but if `local_tx == m_recon_state->local_short_id_mapping.end()`, `local_tx->second` is still accessed after the LogPrint - isn't that illegal? ",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r412389472,412389472,src/net.cpp
naumenkogs,2020-04-21 18:46:18,"Oh, i see you are definitely right, it's a bug!",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r412404625,412404625,src/net.cpp
mzumsande,2020-04-22 00:39:24,"One more potential issue: If I understand it correctly, `m_recon_state` is null if our peer does not signal Erlay support. So we should check if `m_recon_state` is non-null before accessing its members here.\n\nOtherwise an attacker could not signal Erlay but then send Erlay-specific messages to crash our node. Same applies for the other new messages `NetMsgType::SKETCH` etc. below.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r412586167,412586167,src/net_processing.cpp
naumenkogs,2020-04-22 00:50:10,"Definitely an issue, will address!\nI had asserts all over, and then was replacing them with returns, but this one requires 2 checks for m_recon_state and for sender :)",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r412589714,412589714,src/net_processing.cpp
ysangkok,2020-06-06 19:20:37,this could say BIP 330,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r436293837,436293837,src/protocol.h
ysangkok,2020-06-06 19:20:59,"also, could say BIP 330",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r436293867,436293867,src/protocol.h
ysangkok,2020-06-06 19:23:41,wouldn't it be better to have this guarded by an ifdef?,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r436294048,436294048,src/minisketch/src/test-exhaust.cpp
naumenkogs,2020-06-06 20:14:23,I think https://github.com/sipa/minisketch master branch is a better place for these comments :),https://github.com/bitcoin/bitcoin/pull/18261#discussion_r436297436,436297436,src/minisketch/src/test-exhaust.cpp
sdaftuar,2020-12-10 20:12:07,"We should probably not send a `sendrecon` message to block-relay only peers?  Here we should just check to see if it's an inbound peer, right?",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r540464964,540464964,src/net_processing.cpp
sdaftuar,2020-12-10 20:15:00,"I believe BIP 330 doesn't reference protocol version 80001, and the code in this commit seems to send it as long as the peer has version 70016 or higher.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r540466709,540466709,src/protocol.h
sdaftuar,2020-12-10 20:17:01,"Just a note, I think the BIP draft refers to a default value of q=0.1. Perhaps if we end up leaving our default at 0.02, then we could update the BIP to have the same default value suggestion.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r540467865,540467865,src/net_processing.cpp
sdaftuar,2020-12-10 20:19:25,"spelling nit: should say ""reconcile""",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r540469261,540469261,src/net_processing.cpp
sdaftuar,2020-12-10 20:21:01,"Should we only consider negotiation to have succeeded if we've already received a `wtxidrelay` message from this peer?  If so, I think we need to specify the order in which `wtxidrelay` and `sendrecon` get sent during handshaking in the BIP.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r540470196,540470196,src/net_processing.cpp
sdaftuar,2020-12-10 20:25:01,"A comment here explaining this setup for an inbound peer that sends us a SENDRECON with `sender=false` would be helpful.  Here, it seems that we don't set up any reconciliation to occur with an inbound peer that doesn't want to reconcile with us, because we only send reconciliations to our outbound peers, and require that inbounds who want to reconcile be the requestor.\n\nPerhaps a comment that",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r540472620,540472620,src/net_processing.cpp
sdaftuar,2020-12-10 20:40:43,"I think if an inbound peer advertised support for both requesting sketches and responding to sketch requests, that we would then add them to our recon queue, but the comment here says that we are only doing this for outbound peers. Can you clarify the correct behavior in that situation?",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r540481711,540481711,src/net_processing.cpp
sdaftuar,2020-12-10 20:51:43,"If I read correctly, even in the final version of this PR this function is only invoked with flooding=true.  Can we simplify this function a bit to reflect that?",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r540487984,540487984,src/net_processing.cpp
sdaftuar,2020-12-10 20:52:44,"Style comment: I've noticed in a few places that you have one-line `if` statements; our style guide requires that if the body of the `if` isn't on the same line, then we must use curly braces.  So that's something to fix up throughout the new code.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r540488569,540488569,src/net_processing.cpp
sdaftuar,2020-12-10 20:55:39,"I haven't quite thought through exactly how flooding works in Erlay, but I believe this logic is written so that if we configure a node to have 8 manual outbound peers in addition to the 8 full outbound relay peers, and the 8 manual peers are all assigned to be the flood peers, and then they all go offline, we would be left with 0 flood peers?  Is it a problem if we are using fewer than our 8 floo",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r540490244,540490244,src/net_processing.cpp
sdaftuar,2020-12-10 21:00:58,I assume you could pass this vector by (const) reference?  (And maybe all the other stuff can be passed by reference too...). ,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r540493276,540493276,src/net_processing.cpp
sdaftuar,2020-12-10 21:10:03,"nit: Here and in many of the loops in this PR, I think you could make these `const uint256& wtxid : ...`, to save a copy.  Won't point it out in every spot but probably could be cleaned up throughout the PR at some point.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r540498519,540498519,src/net_processing.cpp
naumenkogs,2020-12-11 08:29:36,"Haha, I was planning to bring this up later in the review cycle. I didn't expect someone to find it that fast :)\nYeah, what you describing is possible.\nPerhaps we should have a loop checking that we have enough (8) flood outbound peers, and then if not, switch some existing recon peers to flooding.\n\nWill add a commit for this.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r540772961,540772961,src/net_processing.cpp
sdaftuar,2020-12-11 13:18:30,I think a comment here explaining why we don't flood these transactions would be helpful.,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r540940436,540940436,src/net_processing.cpp
sdaftuar,2020-12-11 13:27:50,"Here, if a peer doesn't support reconciliation, then the `flood` bool doesn't matter, we'll always flood -- right?  If that's correct, perhaps we could either set flood=true for all non-reconciliation peers, or leave a comment that explains that the parameter doesn't matter in this case.\n",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r540945952,540945952,src/net_processing.cpp
sdaftuar,2020-12-11 13:29:49,We track where we got the orphan from; should we use that to determine whether to flood (rather than setting `flood=true` for all orphans)?,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r540947160,540947160,src/net_processing.cpp
sdaftuar,2020-12-11 13:37:13,Can we make this const and just always initialize it when a `Peer` object is created?  Then we could avoid having to worry about locking issues with this (right now it seems like there should be some kind of lock that guards it).,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r540951635,540951635,src/net_processing.cpp
sdaftuar,2020-12-11 13:40:10,I think this probably should have a lock that protects access to this object?,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r540953528,540953528,src/net_processing.cpp
sdaftuar,2020-12-11 13:42:26,"nit: perhaps the constructor can take initial values for all the members, so there's no risk that the members go uninitialized?  It looks like the way you are currently using this is to instantiate the object and immediately set everything, so I think this would be an easy change.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r540954946,540954946,src/net_processing.cpp
sdaftuar,2020-12-11 13:43:36,I think this probably needs a lock to synchronize access to this?,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r540955695,540955695,src/net_processing.h
sdaftuar,2020-12-11 15:14:13,"So inbound peers that are reconciling with us effectively get their own poisson timer -- can you explain why this is an ok change?  \n\nIt seems like an inbound peer that constantly tries to reconcile with us could be a more effective spy than before this change, but maybe I'm missing something.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r541017754,541017754,src/net_processing.cpp
sdaftuar,2020-12-11 15:17:04,"Also, it might be helpful for code readers if the way we check to see if we're reconciling with a peer is to call a function that explains that better (`peer->ReconEnabled()` or something), than checking to see if the `m_recon_state` object is a nullptr or not. But that's just a style nit, you can take it or leave it.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r541019792,541019792,src/net_processing.cpp
sdaftuar,2020-12-11 15:24:37,"If we're reconciling with a peer, does it make sense to limit this loop to `INVENTORY_BROADCAST_MAX` transactions?  That is primarily a bandwidth throttling behavior, not a privacy behavior -- and since reconciliation is already bandwidth reducing itself, it might be beneficial to throw more things into the sketch sooner? \n\nOn the other hand, maybe it works out just fine if both parties are th",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r541025191,541025191,src/net_processing.cpp
sdaftuar,2020-12-11 15:29:37,"Would it make more sense perhaps to announce the earliest transactions in the queue, rather than the most recent ones?  \n\nIt's possible this logic is fairly optimal, but here is what I was concerned about:\n- an inbound adversary could negotiate erlay support but then never send a reconciliation request, and so this queue fills up until we start just inv'ing them everything new anyway. Since ",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r541028803,541028803,src/net_processing.cpp
sdaftuar,2020-12-11 15:32:44,"FYI, I believe that because this number used to be odd, the ratio of announcement delay to inbound versus outbound peers will change from 2.5 in the old code to 2 in the new code.  Not sure if that is cause for any concern though.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r541031015,541031015,src/net_processing.cpp
sdaftuar,2020-12-11 15:34:34,"Can you explain why this needs to change, and how you arrived at multiplying by 4?",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r541032397,541032397,src/net_processing.cpp
sdaftuar,2020-12-11 15:46:24,"Ah, I didn't realize we respond to these asynchronously. If this isn't already in the BIP, perhaps it would be helpful to specify there that reconciliation responses are not guaranteed to be sent out in sync with other messages peers might send (such as pings, getdata, etc)?",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r541041135,541041135,src/net_processing.cpp
sdaftuar,2020-12-11 15:51:09,"Should we snapshot our reconciliation set as of when we receive this request?  If we have a fixed delay and no snapshot, then I'm not sure how much privacy we gain by the 2 second delay (other than from throttling reconciliation requests from a single peer).",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r541044473,541044473,src/net_processing.cpp
sdaftuar,2020-12-11 15:57:55,We should try to figure out a better way to organize all these constants and the complexity of the logic away from the rest of `net_processing` -- not sure yet what to suggest but wanted to flag that this is now quite a lot of esoteric stuff we're adding to the top of this file.,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r541049259,541049259,src/net_processing.cpp
sdaftuar,2020-12-11 16:14:00,spelling nit: possession ,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r541059908,541059908,src/net_processing.cpp
sdaftuar,2020-12-11 16:16:53,"Do we need to invoke `minisketch_destroy` on the `response_sketch` to avoid leaking memory?\n\nI'm also confused about why we need to serialize the sketch into a temporary array and then move it into another vector before sending our response.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r541061891,541061891,src/net_processing.cpp
sdaftuar,2020-12-11 16:20:03,"I thought we needed to hang on to a snapshot of this in order to respond to sketch-extension requests?\n\nEDIT: Ah, this happens in a later commit.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r541063971,541063971,src/net_processing.cpp
naumenkogs,2020-12-11 17:10:12,"Fixed this in the first batch of commits, will also fix for the rest.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r541097407,541097407,src/net_processing.cpp
naumenkogs,2020-12-11 17:19:36,Probably gonna be restrictive for now.,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r541103154,541103154,src/net_processing.cpp
naumenkogs,2020-12-11 17:20:29,Updating the code and the BIP,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r541103641,541103641,src/net_processing.cpp
sdaftuar,2020-12-11 17:42:01,"This assert worried me a bit, since I figured that the `FinalizeReconciliation` could be triggered by a peer with a `reconcildiff` message without having sent a previous `reqreconcil`.  It looks like there is a guard to prevent that from happening, but it's not clear to me that `assert()` is what we want here.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r541116815,541116815,src/net_processing.cpp
sdaftuar,2020-12-11 17:47:40,"So -- this logic means that we won't do any reconciliation with peers if their sender/responder settings don't match exactly what we expect inbound and outbound peers to do.  Should we add some sort of acknowledgement message so that both sides know whether reconciliation is enabled on the link?\n\nOur own logic seems to change based on whether we *think* we're reconciling with a peer; if some o",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r541120337,541120337,src/net_processing.cpp
sdaftuar,2020-12-11 18:11:19,"I'm wondering if this might be better as a poisson-timer, but I don't quite understand the implications of all this yet to reach a conclusion.  Intuition: with a fixed delay like this, an adversary with 2 inbound connections can use set reconciliation to measure the set difference between the node's transactions-to-announce in known and arbitrarily precise time slices.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r541134079,541134079,src/net_processing.cpp
sdaftuar,2020-12-11 18:16:09,Should the `m_local_short_id_mapping` be cleared out in this function?,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r541136948,541136948,src/net_processing.cpp
sdaftuar,2020-12-11 18:19:04,"I think this is a protocol violation and leaves the link in a permanently broken reconciliation state, since a reconcildiff would never be sent. Perhaps we should disconnect the peer if this happens?",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r541138509,541138509,src/net_processing.cpp
sdaftuar,2020-12-11 18:21:30,I think we need to call `minisketch_destroy` on these somewhere to avoid a memory leak right?,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r541139881,541139881,src/net_processing.cpp
sdaftuar,2020-12-11 18:37:33,Is it possible for the peer to send us a message that causes `remote_sketch` to be nullptr here?,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r541149185,541149185,src/net_processing.cpp
naumenkogs,2020-12-16 12:40:06,"I think you're right, although we should be extra careful to make sure no privacy leak is introduced w.r.t topology.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r544266303,544266303,src/net_processing.cpp
naumenkogs,2020-12-16 13:44:41,"Yeah, so I think the ratio matters most. It was 2.5 and now it's 2, so a bit different.\nBut I'm also not 100% if this difference matters, while preserving 2.5 would require operating with floats now, so I decided to not, at least yet.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r544308769,544308769,src/net_processing.cpp
naumenkogs,2020-12-16 13:59:58,Adding protection for this case.,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r544319767,544319767,src/net_processing.cpp
naumenkogs,2020-12-16 15:00:19,"Not really permanently broken, they still have a chance to send us a proper sketch. But yeah, either finalizing or disconnecting would work. Making it disconnect for now.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r544368199,544368199,src/net_processing.cpp
naumenkogs,2020-12-16 15:12:42,"Why so early? The point of it is to refer to it later, when we are requested something by short ID.\nThat's why it should be kept until `FinalizeReconciliation`. \n\nAlthough as currently implemented, I notice there's a bug, because we may lose short IDs of the transactions received during extension when calling this after the extension is over. I need to fix this part.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r544378109,544378109,src/net_processing.cpp
naumenkogs,2020-12-16 15:18:04,"I also don't have a good answer, but it's not that simple of an attack: we [have](https://github.com/bitcoin/bitcoin/pull/18261/files#r541017754) Poisson on adding to reconciliation sets.\n\nHaving another poison here, well, I don't think it makes anything worse. Maybe you're right.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r544382513,544382513,src/net_processing.cpp
naumenkogs,2020-12-16 15:22:39,"Right, this implementation prioritized simplicity here.\nPerhaps, I should add sending RECONACK, and also think whether at least some of the non-matching scenarios are compatible.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r544386261,544386261,src/net_processing.cpp
naumenkogs,2020-12-17 08:57:47,"`INVENTORY_BROADCAST_PER_SECOND` is probably derived from the block size, so it shouldn't be changed.\n`INVENTORY_BROADCAST_INTERVAL` is just how long we wait between reconciliations with different peers (say 2 seconds).\n\nNow, imagine, a non-reachable node (which only learns from reconciliations), reconciled with a dysfunctional peer. So the stack of what it should learn during the next succe",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r544917491,544917491,src/net_processing.cpp
naumenkogs,2020-12-17 09:20:01,"We gain privacy by not allowing 2 peers to monitor our mempool, because we respond to them at the same time (every 2 seconds).\n\nSnapshoting earlier would hide the transactions received during the last 2 seconds and disable this kind of monitoring, but then reconciliations would not be so ""fresh"" (txs received during last 2s go into the next one).\nNot sure this kind of monitoring is that dang",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r544932128,544932128,src/net_processing.cpp
naumenkogs,2020-12-17 09:22:12,"Yeah, definitely, I have the same feel. Perhaps it better belongs to ReconState{}.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r544933569,544933569,src/net_processing.cpp
sipa,2020-12-18 22:28:40,"BIP comment, and commit ""Handle reconciliation support announcement"":\n\nShould we use a BIP340 tagged hash here (see `TaggedHash()` in src/hash.h)?",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r546120863,546120863,src/net_processing.cpp
sipa,2020-12-18 22:32:37,"In commit ""Handle reconciliation support announcement"":\n\nThis comment isn't entirely clear to me. Flood transactions to the peer, as opposed to what (given that in the next line you say it's not in conflict with reconciliation, so it's not clear to me if this means instead of, or in addition to, reconciliation).",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r546122011,546122011,src/net_processing.cpp
sipa,2020-12-18 22:33:07,"In commit ""Handle reconciliation support announcement"":\n\nThe salt is only 128 bits, right? Why uint256? In the codebase we usually call SipHash salts k0 and k1.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r546122109,546122109,src/net_processing.cpp
sipa,2020-12-18 22:35:24,"In commit ""Handle reconciliation support announcement""\n\nIs it necessary to use a recursive mutex here? If you can avoid them, Mutex is more efficient and easier to reason about.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r546122819,546122819,src/net_processing.cpp
sipa,2020-12-18 22:44:13,"BIP comment:\n\nI think it's possible to specify the behavior exactly without the need for an ACK message, but perhaps this is a detail you don't actually want in the BIP:\n* We send (us_sender, us_responder, us_version)\n* We receive (they_sender, they_responder, they_version)\n* Define out_recon = us_sender && they_responder\n* Define in_recon = they_sender && us_responder\n* If !(out_rec",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r546125410,546125410,src/net_processing.cpp
sipa,2020-12-18 23:16:03,"In commit ""Handle reconciliation support announcement""\n\nThis conversion to decimal strings doesn't seem to match the BIP. I would think you'd do:\n\n```c++\nuint64_t salt1 = local_salt, salt2 = remote_salt;\nif (salt1 > salt2) std::swap(salt1, salt2);\nuint256 full_salt = (CHashWriter(SER_HASH, 0) << MakeSpan(RECON_STATIC_SALT) << salt1 << salt2).GetSHA256();\n```\n\nIf the BIP is chan",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r546141650,546141650,src/net_processing.cpp
sipa,2020-12-18 23:21:00,"In commit ""Handle reconciliation support announcement"":\n\nThe comment of m_recon_queue needing a lock doesn't seem resolved?",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r546142850,546142850,src/net_processing.h
sipa,2020-12-18 23:34:57,"Or even `const auto& wtxid : ...` to be sure no copy is created, regardless of the type of the container.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r546146253,546146253,src/net_processing.cpp
sipa,2020-12-18 23:42:50,"In commit ""Distinguish transactions to flood and to reconcile"":\n\nYou can use\n\n```c++\nm_tx_relay->setInventoryTxToSend.emplace(hash, flood);\n```\n\nhere instead.\n\n",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r546148014,546148014,src/net.h
sipa,2020-12-18 23:48:27,"In commit ""Distinguish transactions to flood and to reconcile""\n\nWould it make sense to reuse `MAX_PEER_TX_ANNOUNCEMENTS` here? It was reduced to 5000 in #19988.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r546151144,546151144,src/net_processing.cpp
sipa,2020-12-19 01:07:01,"In commit ""Handle reconciliation support announcement"" (and BIP)\n\nDo we want to ignore or disconnect if this message arrives after VERACK?",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r546167320,546167320,src/net_processing.cpp
sipa,2020-12-19 01:28:27,"In commit ""Distinguish transactions to flood and to reconcile"":\n\nNit: coding style (use { ... } for multi-line ifs).",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r546170672,546170672,src/net_processing.cpp
sipa,2020-12-20 00:36:28,"In commit ""Distinguish transactions to flood and to reconcile""\n\nPerhaps it's useful to comment on the exact semantics for the bool parameter here. IIRC it is:\n* false: use reconciliation if negotiated, flood otherwise\n* true: flood unless reconciliation negotiated and this is not a flooding peer\n",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r546301880,546301880,src/net.h
sipa,2020-12-20 01:39:59,BIP comment: why 12 bits? You could have 16 bits of accuracy with the 2 bytes that it takes.,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r546306680,546306680,src/net_processing.cpp
sipa,2020-12-20 01:41:17,"Why is this strictly needed? (apart from the BIP specifying that it is 32, so any other value is protocol breaking).",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r546306755,546306755,src/net_processing.cpp
sipa,2020-12-20 01:43:35,I've PR'ed https://github.com/sipa/minisketch/pull/28 that adds a safer C++ wrapper around the minisketch* type. You may want to use it instead of doing manual memory management for them. It also adds some convenience functions for dealing with fpbits (CreateFP and DecodeFP).,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r546306899,546306899,src/net_processing.cpp
sipa,2020-12-20 01:44:56,I've PR'ed https://github.com/sipa/minisketch/pull/26 which adds a pure Python (slow) full reimplementation of minisketch. You may want to use that instead (it also supports decoding).,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r546307036,546307036,test/functional/p2p_erlay.py
naumenkogs,2020-12-22 09:44:20,"I'm not 100% sure how to do it right, but simple Mutex doesn't seem to work when `GetFloodingOutboundsCount` is called in handling `NetMsgType::SENDRECON`. It just hangs.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r547174377,547174377,src/net_processing.cpp
naumenkogs,2020-12-24 18:23:07,"q is computed as `(total_missing - abs(local_missing - remote_missing)) / min_size`\n\nSo the bounds on q are [0...2] I think?\nif abs = 0, total_missing = 2 * min_size (at most) is an upper bound.\nIf abs !=0, well. Ideally, we need to solve this equation properly :)\n\nSo it should be (2 << 14) - 1 I think assuming [0..2] for now.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r548678244,548678244,src/net_processing.cpp
jnewbery,2021-01-17 22:24:38,This is no longer a set.,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r559247494,559247494,src/net.h
jnewbery,2021-01-17 22:25:32,"```suggestion\nstatic constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{16s};\n```\n\nSaves repeating the chrono type",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r559247594,559247594,src/net_processing.cpp
jnewbery,2021-01-17 22:26:15,Any reason not to use a bool here?,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r559247689,559247689,src/net_processing.cpp
jnewbery,2021-01-17 22:29:12,"It's easy enough to instantiate a new `CNetMsgMaker` from the CNode, rather than passing it as an argument. If you make this function a member of `PeerManagerImpl` you can also avoid passing the `CConnman&`.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r559248117,559248117,src/net_processing.cpp
jnewbery,2021-01-17 22:30:08,"Consider inverting this if condition to make this a guard clause and avoid deep indentations below.\n\n```suggestion\n    if (remote_missing_wtxids.size() == 0) return;\n```",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r559248234,559248234,src/net_processing.cpp
jnewbery,2021-01-17 22:31:27,"Perhaps reserve max(size of remote_missing_wtxids, MAX_INV_SIZE) to avoid reallocations.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r559248400,559248400,src/net_processing.cpp
jnewbery,2021-01-17 22:32:39,A bit of space/comments in this code block would make it easier to read.,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r559248515,559248515,src/net_processing.cpp
jnewbery,2021-01-17 22:33:24,"Again, spacing/comments would make this more legible.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r559248593,559248593,src/net_processing.cpp
jnewbery,2021-01-17 22:34:40,sort,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r559248746,559248746,src/net_processing.h
jnewbery,2021-01-17 22:35:32,"This doesn't need to be in the header, since it's only used inside net_processing.cpp.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r559248856,559248856,src/net_processing.h
jnewbery,2021-01-17 22:38:48,"Inside a structure inside `Peer` feels like the wrong place for a lot of this complex logic. I think ideally, `Peer` would continue to be a struct (i.e. data members only) and the logic would be contained in a separate module.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r559249350,559249350,src/net_processing.h
jnewbery,2021-01-17 22:39:50,"Don't use old cs nomenclature for mutexes:\n\n```suggestion\n    RecursiveMutex m_recon_state_mutex;\n```\n\nAlso prefer to use a `Mutex` over a `RecursiveMutex` in new code.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r559249519,559249519,src/net_processing.h
jnewbery,2021-01-17 22:40:44,"Again, prefer a non-reenrant mutex and don't use the cs nomenclature.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r559249641,559249641,src/net_processing.h
jnewbery,2021-01-17 22:41:45,Why this space?,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r559249766,559249766,test/functional/p2p_erlay.py
jnewbery,2021-01-17 22:42:06,"Please sort, with standard library imports first.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r559249818,559249818,test/functional/p2p_erlay.py
jnewbery,2021-01-17 22:42:40,Why not a bool?,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r559249883,559249883,test/functional/p2p_erlay.py
jnewbery,2021-01-17 22:43:27,I think that these are unneeded now that truncated txids aren't used,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r559249972,559249972,test/functional/test_framework/messages.py
jnewbery,2021-01-17 22:43:55,why two blank lines?,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r559250042,559250042,test/functional/test_framework/messages.py
jnewbery,2021-01-17 22:44:13,sort,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r559250087,559250087,test/functional/test_framework/p2p.py
jnewbery,2021-01-17 22:44:21,sort,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r559250109,559250109,test/functional/test_framework/p2p.py
jnewbery,2021-01-17 22:44:29,sort,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r559250122,559250122,test/functional/test_framework/p2p.py
jnewbery,2021-01-17 22:44:52,sort,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r559250156,559250156,test/functional/test_framework/p2p.py
naumenkogs,2021-01-19 11:25:54,"I think this should be min, because the vector never exceeds MAX_INV_SIZE.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r560107354,560107354,src/net_processing.cpp
jnewbery,2021-01-19 11:54:21,"yes, you're right. Should be min.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r560122958,560122958,src/net_processing.cpp
naumenkogs,2021-01-19 15:00:01,"I can switch to non-recursive if UpdateNextReconRequest() takes `m_recon_queue.size()` as an argument, instead of accessing it inside. Do you think that would be preferable?",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r560240227,560240227,src/net_processing.h
naumenkogs,2021-01-19 15:24:13,I think I can't make it non-recursive because of the call inside `GetFloodingOutboundsCount`. How would you suggest to overcome this issue?,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r560259462,560259462,src/net_processing.h
jnewbery,2021-01-19 16:30:37,"I haven't looked into your branch in great detail, but it looks like `UpdateNextReconRequest()` is only called in one place, which already holds `m_recon_queue_mutex`. Could you make the function `EXCLUSIVE_LOCKS_REQUIRED(m_recon_queue_mutex)` and not retake the mutex inside?",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r560311775,560311775,src/net_processing.h
jnewbery,2021-01-25 09:02:38,Please use doxygen style comments.,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r563557030,563557030,src/net_processing.cpp
jnewbery,2021-01-25 09:03:12,This isn't needed in the header.,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r563557359,563557359,src/net_processing.h
jnewbery,2021-01-25 09:04:56,Use a `WITH_LOCK()` macro or code block here to avoid holding the mutex for the rest of this block.,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r563558393,563558393,src/net_processing.cpp
jnewbery,2021-01-25 09:06:56,"Please place this inside the `REQRECON` message handling code block (we probably want to split each message handler into its own function in the future, so we should minimize the use of code outside those code blocks).",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r563559617,563559617,src/net_processing.cpp
jnewbery,2021-01-25 09:08:03,Not required. There is already a local `peer` in this function.,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r563560359,563560359,src/net_processing.cpp
jnewbery,2021-01-25 09:10:40,No need to mark pass-by-value arguments as const.,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r563561991,563561991,src/net.h
jnewbery,2021-01-25 09:13:18,"Consider making `flood=false` the default, so that call sites don't need to be updated for this change.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r563563608,563563608,src/net_processing.h
jnewbery,2021-01-25 09:14:53,Add copyright boilerplate,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r563564589,563564589,src/reconciliation.h
jnewbery,2021-01-25 09:15:37,Can you try to limit these lines to 80 or 100 chars to avoid wrapping.,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r563565058,563565058,src/reconciliation.h
jnewbery,2021-01-25 09:16:16,doxygen,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r563565500,563565500,src/reconciliation.h
jnewbery,2021-01-25 09:17:20,"This file should include all the standard library headers that it uses (eg chrono, set, etc)",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r563566154,563566154,src/reconciliation.h
jnewbery,2021-01-25 09:18:10,Add include guards,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r563566739,563566739,src/reconciliation.h
jnewbery,2021-01-25 09:21:37,This should really be a class since it has function members.,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r563568993,563568993,src/reconciliation.h
mzumsande,2021-02-05 20:37:29,"Does this work as intended in the intermediate stage where not all of our peers support Erlay? If we are a non-reachable node that supports Erlay but has just one older pre-Erlay outbound peer - wouldn't we flood all of its transactions also to our Erlay-supporting peers because `flood == true` here? (Considering the goal that ""only well-connected publicly reachable nodes flood transactions to oth",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r571236196,571236196,src/net_processing.cpp
mzumsande,2021-02-05 20:42:04,"This message is called ""reqrecon**cil**"" in the BIP.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r571238532,571238532,src/protocol.h
ariard,2021-02-09 16:12:56,"094c4ed\n\nThis comment is really unclear. What about :\n""Transactions ids and their associated announcement protocols :\n- true, use flooding\n- false, use reconciliation""\n\nI think it's easier to use this map if it stays blind w.r.t to protocol negotiations and flooding-peers selection.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r573021963,573021963,src/net.h
ariard,2021-02-09 16:44:17,"aff98fc\n\nMaybe precise ""Count how many outbound connections are already used for flooding, including the ones not supporting reconciliation at all"". Until I read `GetFloodingOutboundsCount` I did have a doubt on whether or not this limit was scoping outbound peers not-supporting reconciliation.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r573047513,573047513,src/net_processing.cpp
ariard,2021-02-09 16:55:08,"34a485e\n\n`m_recon_resp_queue` better ?",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r573056635,573056635,src/net_processing.cpp
ariard,2021-02-09 17:07:22,"f63ad15\n\nLooking on `UpdateNextReconRequest` implementation, I think this should mention the delay is decreasing linearly with the number of reconciliation responders available. \n\nIIUC, you assume that more we have reconciliation peers, better the propagation of our local transactions set is. Thus we should space our requests to save bandwidth ? If this is correct, maybe link the section o",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r573066725,573066725,src/net_processing.cpp
ariard,2021-02-09 17:44:14,"ce83d3fb\n\nThanks for the comment but I don't think the non-reachability is a source of leak for the present scenario. Non-reachable nodes may open connections to outbound not supporting reconciliations, thus relying on flooding for transaction announcements, at least until Erlay is well-deployed. \n\nI think the leak would be constituted by a differential tx-announcement protocol selection f",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r573094798,573094798,src/net_processing.cpp
ariard,2021-02-09 17:57:41,"ce83d3fb\n\nIs the tx-announcement protocol marker is really required `m_transactions_to_announce` given that ultimately you will check peer's `m_recon_state` and `m_flood` to fan out between `vInv`/`txs_to_reconcile` ? A non-wtxid peer should be `m_recon_state==null` anyway.\n\nI think it's better to remove this notion of announcement protocol selection attached to tx itself and instead only ",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r573107239,573107239,src/net_processing.cpp
dergoegge,2021-02-09 19:41:35,"Should we disconnect the peer instead of ignoring the message? In all three cases the peer ""misbehaved"" and sent an unsolicited `REQRECON` message.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r573184729,573184729,src/net_processing.cpp
unseddd,2021-02-10 01:23:08,"nit: since order is not important, maybe std::unordered_map for efficiency?",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r573373989,573373989,src/net.h
unseddd,2021-02-10 02:24:04,"nit: consider using smth like:\n\n```\nstatic constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{16000000};\n```\n\nusing the `"""" s` operator requires a `using namespace std::chrono_literals` or similar: [https://en.cppreference.com/w/cpp/chrono/operator%22%22s](https://en.cppreference.com/w/cpp/chrono/operator%22%22s).\n\nSame for `RECON_RESPONSE_INTERVAL`.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r573400775,573400775,src/reconciliation.h
jonatack,2021-02-10 10:49:02,"with gcc 10.2.1\n```\nIn file included from ./reconciliation.h:1,\n                 from ./net_processing.h:10,\n                 from rpc/net.cpp:13:\n./minisketch/include/minisketch.h: In member function ‚Äòstd::optional<std::vector<long unsigned int> > Minisketch::Decode(size_t) const‚Äô:\n./minisketch/include/minisketch.h:293:25: warning: redundant move in return statement [-Wredundant-move]",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r573627435,573627435,src/minisketch/include/minisketch.h
naumenkogs,2021-02-10 11:18:51,"""only well-connected publicly reachable nodes flood transactions to other publicly reachable nodes via outbound connections"" only is an end-goal when most of the network implement Erlay.\n\nIn the meanwhile, I think this behavior is better because it's most intuitive: for legacy peers, we support legacy behavior (flood).\nTechnically, changing this condition wouldn't break stuff, but I think it",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r573646650,573646650,src/net_processing.cpp
naumenkogs,2021-02-10 11:33:09,"How to reflect that if it's ""false, use reconciliation"", it still can be flooded, in case if reconciliation is not supported for a given peer?\n",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r573655499,573655499,src/net.h
jonatack,2021-02-10 11:54:37,"After building with both gcc 10.2.1 and clang 9, functional tests are failing with `AssertionError: Unexpected stderr Assertion failed: detected inconsistent lock order for 'peer->m_recon_state_mutex' in net_processing.cpp:4936 (in thread 'msghand')`",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r573668001,573668001,src/net_processing.cpp
ariard,2021-02-10 13:49:19,See this [comment](https://github.com/bitcoin/bitcoin/pull/18261#discussion_r573107239) which I believe is superseding this discussion. ,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r573739993,573739993,src/net.h
ariard,2021-02-10 13:54:30,"34a485e\n\nThis checks sounds to assume we may have in the future a new reconciliation protocol for which we would reuse `ReconState` but with a earlier signaling mechanism. Given `SENDRECON` is versioned, I would expect a version-bump to introduce this hypothetical reconciliation protocol instead of new message already spawning `ReconState` allocation.\n\nThus I think this check can be remove",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r573743726,573743726,src/net_processing.cpp
ariard,2021-02-10 14:56:49,"34a485e\n\nI don't find the section in the paper where you're detailing the purpose of reconciliation as a redundant tx-announcement for strategic peers ? Given `RECON_REQUEST_INTERVAL` is superior to `INVENTORY_BROADCAST_INTERVAL`, I guess the motivation isn't about improving latency of transactions discovered during floods round towards strategic peers. ",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r573794642,573794642,src/net_processing.cpp
ariard,2021-02-10 15:27:26,"ce83d3fb\n\nIIUC, this comment correctly, you mean that a transaction discovered through an accepted-reconciliation will be marked for reconciliation for its future announcements, no matter the peer type (strategic outbound/non-strategic outbound/inbound).\n\nI don't get the rational of such approach, propagation of such transactions could be accelerated if we were flooding them for our outbou",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r573824646,573824646,src/net_processing.cpp
ariard,2021-02-10 16:10:25,"ce83d3fb\n\nI think we should have this discussion about just throwing away transactions under some `SKETCH_MAX_SIZE`. Sort them by feerate, keep the ones above the mark, discard the others.\n\nWe're already doing the same assumptions if a a transaction is under mempool min fee, we won't relay it further. That can be the same with reconciliation, we don't allocate sketch resources for low-fee ",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r573861905,573861905,src/net_processing.cpp
naumenkogs,2021-02-11 10:27:56,"This particular line is less than 100 chars, so I assume you referred to the other ones which are longer than 100. I see a couple, gonna limit them.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r574391119,574391119,src/reconciliation.h
amitiuttarwar,2021-02-14 05:53:27,can you extract this into its own `CNode` function with a name that captures the intent & a case statement for all the connection types? you can see `ExpectServicesFromConn` as an example. ,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r575758305,575758305,src/net_processing.cpp
amitiuttarwar,2021-02-14 06:26:25,"this salt calculation (and probably also the flood_to logic) seems like an example of code that can be extracted into the reconciliation module rather than added to `ProcessMessage`.\n\nit would make sense to me for the flow to be something like: \n- `ProcessMessage` does internal state checks (`m_tx_relay` exists, wtxid is enabled)\n- extract the message from `vRecv`\n- pass it along into th",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r575761033,575761033,src/net_processing.cpp
amitiuttarwar,2021-02-14 06:31:09,"I find (!A && !B) to be very confusing. Again, would be good to extract into its own function with switch statement. ",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r575761493,575761493,src/net_processing.cpp
amitiuttarwar,2021-02-14 06:42:59,"instead of recalculating whenever we get a `SENDRECON` message, could this logic be significantly simplified by just storing a count that gets updated when nodes do something to change their state? the characteristics being checked are all established early in the connection (connection type, m_tx_relay struct, flood_to being set) \n\nI think this should remove the need for the ""skip node"" logic",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r575762526,575762526,src/net_processing.cpp
naumenkogs,2021-02-14 09:33:33,"Yeah, I'm planning to do something similar in the next couple days. That's why I marked the PR draft for now :)\n\nThank you for the design suggestion!",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r575781038,575781038,src/net_processing.cpp
mzumsande,2021-02-22 21:14:25,"But the legacy behavior also affects Erlay peers (because if a non-reachable node received transactions from legacy  peers, it would act as if it was a reachable hub and forward them via flooding to other outbound peers, including Erlay ones).\n\nApart from this specific spot that could easily be adjusted if needed, I think that when there are two relay mechanisms with different time scales exis",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r580595369,580595369,src/net_processing.cpp
fanquake,2021-03-12 00:39:58,Please [use `std::make_unique` in new code](https://github.com/bitcoin/bitcoin/blob/master/src/util/memory.h#L13).,https://github.com/bitcoin/bitcoin/pull/18261#discussion_r592830262,592830262,src/net_processing.cpp
naumenkogs,2021-03-15 13:49:08,"I know it's more complicated logic, but think it's necessary.\nm_flood inside peer's ReconState is one factor, but it's not sufficient, because we can't flood *all* transactions to them.\n\nIf we did so, there will be too much flooding. A non-reachable node always sets m_flood for its 8 outbound peers to true. In that case, it will flood all transactions it gets for them, too much bandwidth.\n",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r594350238,594350238,src/net_processing.cpp
naumenkogs,2021-03-15 14:11:41,"""strategic"" is not a bidirectional link property, it's decided on every peer locally.\nWe might flood stuff to them, but they won't flood to us (because they only flood outbound). \n\nIn that case, we will never get their transactions, if we don't reconcile.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r594369245,594369245,src/net_processing.cpp
naumenkogs,2021-03-15 14:14:51,">Non-reachable nodes may open connections to outbound not supporting reconciliations, thus relying on flooding for transaction announcements, at least until Erlay is well-deployed.\n\nSure. But for reconciliation conns, the current policy is to flood only what was received via inbound. So if we rebroadcast to a reconciling peer via flooding, they will know it's rebroadcast, because non-reachable",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r594371856,594371856,src/net_processing.cpp
naumenkogs,2021-03-15 14:25:12,">It seems like an inbound peer that constantly tries to reconcile with us could be a more effective spy than before this change, but maybe I'm missing something.\n\nWe don't respond to reconciliations right away, there is a shared timer for those responses. That's why I thought it's fine to reduce the delay here.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r594380974,594380974,src/net_processing.cpp
naumenkogs,2021-03-15 14:49:13,">IIUC, this comment correctly, you mean that a transaction discovered through an accepted-reconciliation will be marked for reconciliation for its future announcements, no matter the peer type (strategic outbound/non-strategic outbound/inbound).\n\nCorrect if you mean accepted=outbound (see confusion below)\n\n> I don't get the rational of such approach, propagation of such transactions could ",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r594402754,594402754,src/net_processing.cpp
naumenkogs,2021-03-15 14:54:04,"@mzumsande sorry I just saw this question. Yeah, that might be useful, once I'm done with big refactor for this...\nIntuitively, I think this shouldn't be the case legacy peers cannibalize efficiency I think.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r594407099,594407099,src/net_processing.cpp
naumenkogs,2021-03-16 11:19:24,"@sipa good idea, ack.",https://github.com/bitcoin/bitcoin/pull/18261#discussion_r595075917,595075917,src/net_processing.cpp
