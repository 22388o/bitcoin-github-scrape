[
  {
    "sha": "9be6666a4e648782b49a6fdc458372ea521b444d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YmU2NjY2YTRlNjQ4NzgyYjQ5YTZmZGM0NTgzNzJlYTUyMWI0NDRk",
    "commit": {
      "author": {
        "name": "Adam Jonas",
        "email": "jonas@chaincode.com",
        "date": "2019-10-10T16:10:15Z"
      },
      "committer": {
        "name": "Adam Jonas",
        "email": "jonas@chaincode.com",
        "date": "2019-10-10T16:10:15Z"
      },
      "message": "typo and unneccessary parentheses",
      "tree": {
        "sha": "0033ee7cda37edc9952afe3ad0b42614567b385b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0033ee7cda37edc9952afe3ad0b42614567b385b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9be6666a4e648782b49a6fdc458372ea521b444d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9be6666a4e648782b49a6fdc458372ea521b444d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9be6666a4e648782b49a6fdc458372ea521b444d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9be6666a4e648782b49a6fdc458372ea521b444d/comments",
    "author": {
      "login": "adamjonas",
      "id": 755825,
      "node_id": "MDQ6VXNlcjc1NTgyNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/755825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/adamjonas",
      "html_url": "https://github.com/adamjonas",
      "followers_url": "https://api.github.com/users/adamjonas/followers",
      "following_url": "https://api.github.com/users/adamjonas/following{/other_user}",
      "gists_url": "https://api.github.com/users/adamjonas/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/adamjonas/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/adamjonas/subscriptions",
      "organizations_url": "https://api.github.com/users/adamjonas/orgs",
      "repos_url": "https://api.github.com/users/adamjonas/repos",
      "events_url": "https://api.github.com/users/adamjonas/events{/privacy}",
      "received_events_url": "https://api.github.com/users/adamjonas/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "adamjonas",
      "id": 755825,
      "node_id": "MDQ6VXNlcjc1NTgyNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/755825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/adamjonas",
      "html_url": "https://github.com/adamjonas",
      "followers_url": "https://api.github.com/users/adamjonas/followers",
      "following_url": "https://api.github.com/users/adamjonas/following{/other_user}",
      "gists_url": "https://api.github.com/users/adamjonas/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/adamjonas/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/adamjonas/subscriptions",
      "organizations_url": "https://api.github.com/users/adamjonas/orgs",
      "repos_url": "https://api.github.com/users/adamjonas/repos",
      "events_url": "https://api.github.com/users/adamjonas/events{/privacy}",
      "received_events_url": "https://api.github.com/users/adamjonas/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2a0164085b001a79b8d37b28751b115322124cfc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2a0164085b001a79b8d37b28751b115322124cfc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2a0164085b001a79b8d37b28751b115322124cfc"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 2,
      "deletions": 2
    },
    "files": [
      {
        "sha": "d2fe5f407da3b740cec99406a25a99cf04f52b15",
        "filename": "src/wallet/feebumper.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9be6666a4e648782b49a6fdc458372ea521b444d/src/wallet/feebumper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9be6666a4e648782b49a6fdc458372ea521b444d/src/wallet/feebumper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.cpp?ref=9be6666a4e648782b49a6fdc458372ea521b444d",
        "patch": "@@ -123,7 +123,7 @@ static CFeeRate EstimateFeeRate(CWallet* wallet, const CWalletTx& wtx, CCoinCont\n     // the minimum of that and the wallet's conservative\n     // WALLET_INCREMENTAL_RELAY_FEE value to future proof against changes to\n     // network wide policy for incremental relay fee that our node may not be\n-    // aware of. This ensures we're over the over the required relay fee rate\n+    // aware of. This ensures we're over the required relay fee rate\n     // (BIP 125 rule 4).  The replacement tx will be at least as large as the\n     // original tx, so the total fee will be greater (BIP 125 rule 3)\n     CFeeRate node_incremental_relay_fee = wallet->chain().relayIncrementalFee();\n@@ -314,7 +314,7 @@ Result CreateRateBumpTransaction(CWallet* wallet, const uint256& txid, const CCo\n         // The user provided a feeRate argument.\n         // We calculate this here to avoid compiler warning on the cs_wallet lock\n         const int64_t maxTxSize = CalculateMaximumSignedTxSize(*wtx.tx, wallet);\n-        Result res = CheckFeeRate(wallet, wtx, *(new_coin_control.m_feerate), maxTxSize, errors);\n+        Result res = CheckFeeRate(wallet, wtx, *new_coin_control.m_feerate, maxTxSize, errors);\n         if (res != Result::OK) {\n             return res;\n         }"
      }
    ]
  },
  {
    "sha": "66b29848c71c4b3b4dc36ca6d94de829bd533797",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NmIyOTg0OGM3MWM0YjNiNGRjMzZjYTZkOTRkZTgyOWJkNTMzNzk3",
    "commit": {
      "author": {
        "name": "Adam Jonas",
        "email": "jonas@chaincode.com",
        "date": "2019-10-10T16:12:28Z"
      },
      "committer": {
        "name": "Adam Jonas",
        "email": "jonas@chaincode.com",
        "date": "2019-10-10T21:46:59Z"
      },
      "message": "change wallet pointers to references in feebumper",
      "tree": {
        "sha": "69d87597d28e82047b185411675c46e831dbb8bb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/69d87597d28e82047b185411675c46e831dbb8bb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/66b29848c71c4b3b4dc36ca6d94de829bd533797",
      "comment_count": 2,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/66b29848c71c4b3b4dc36ca6d94de829bd533797",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/66b29848c71c4b3b4dc36ca6d94de829bd533797",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/66b29848c71c4b3b4dc36ca6d94de829bd533797/comments",
    "author": {
      "login": "adamjonas",
      "id": 755825,
      "node_id": "MDQ6VXNlcjc1NTgyNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/755825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/adamjonas",
      "html_url": "https://github.com/adamjonas",
      "followers_url": "https://api.github.com/users/adamjonas/followers",
      "following_url": "https://api.github.com/users/adamjonas/following{/other_user}",
      "gists_url": "https://api.github.com/users/adamjonas/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/adamjonas/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/adamjonas/subscriptions",
      "organizations_url": "https://api.github.com/users/adamjonas/orgs",
      "repos_url": "https://api.github.com/users/adamjonas/repos",
      "events_url": "https://api.github.com/users/adamjonas/events{/privacy}",
      "received_events_url": "https://api.github.com/users/adamjonas/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "adamjonas",
      "id": 755825,
      "node_id": "MDQ6VXNlcjc1NTgyNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/755825?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/adamjonas",
      "html_url": "https://github.com/adamjonas",
      "followers_url": "https://api.github.com/users/adamjonas/followers",
      "following_url": "https://api.github.com/users/adamjonas/following{/other_user}",
      "gists_url": "https://api.github.com/users/adamjonas/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/adamjonas/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/adamjonas/subscriptions",
      "organizations_url": "https://api.github.com/users/adamjonas/orgs",
      "repos_url": "https://api.github.com/users/adamjonas/repos",
      "events_url": "https://api.github.com/users/adamjonas/events{/privacy}",
      "received_events_url": "https://api.github.com/users/adamjonas/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9be6666a4e648782b49a6fdc458372ea521b444d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9be6666a4e648782b49a6fdc458372ea521b444d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9be6666a4e648782b49a6fdc458372ea521b444d"
      }
    ],
    "stats": {
      "total": 96,
      "additions": 48,
      "deletions": 48
    },
    "files": [
      {
        "sha": "aff08bfbea1d763b8ee0fb879c41c14db2062a1b",
        "filename": "src/interfaces/wallet.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/66b29848c71c4b3b4dc36ca6d94de829bd533797/src/interfaces/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/66b29848c71c4b3b4dc36ca6d94de829bd533797/src/interfaces/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/wallet.cpp?ref=66b29848c71c4b3b4dc36ca6d94de829bd533797",
        "patch": "@@ -241,7 +241,7 @@ class WalletImpl : public Wallet\n     }\n     bool transactionCanBeBumped(const uint256& txid) override\n     {\n-        return feebumper::TransactionCanBeBumped(m_wallet.get(), txid);\n+        return feebumper::TransactionCanBeBumped(*m_wallet.get(), txid);\n     }\n     bool createBumpTransaction(const uint256& txid,\n         const CCoinControl& coin_control,\n@@ -255,17 +255,17 @@ class WalletImpl : public Wallet\n             return feebumper::CreateTotalBumpTransaction(m_wallet.get(), txid, coin_control, total_fee, errors, old_fee, new_fee, mtx) ==\n                 feebumper::Result::OK;\n         } else {\n-            return feebumper::CreateRateBumpTransaction(m_wallet.get(), txid, coin_control, errors, old_fee, new_fee, mtx) ==\n+            return feebumper::CreateRateBumpTransaction(*m_wallet.get(), txid, coin_control, errors, old_fee, new_fee, mtx) ==\n                 feebumper::Result::OK;\n         }\n     }\n-    bool signBumpTransaction(CMutableTransaction& mtx) override { return feebumper::SignTransaction(m_wallet.get(), mtx); }\n+    bool signBumpTransaction(CMutableTransaction& mtx) override { return feebumper::SignTransaction(*m_wallet.get(), mtx); }\n     bool commitBumpTransaction(const uint256& txid,\n         CMutableTransaction&& mtx,\n         std::vector<std::string>& errors,\n         uint256& bumped_txid) override\n     {\n-        return feebumper::CommitTransaction(m_wallet.get(), txid, std::move(mtx), errors, bumped_txid) ==\n+        return feebumper::CommitTransaction(*m_wallet.get(), txid, std::move(mtx), errors, bumped_txid) ==\n                feebumper::Result::OK;\n     }\n     CTransactionRef getTx(const uint256& txid) override"
      },
      {
        "sha": "fbcf8d4de7528f4536d6d853508d4feda2f77192",
        "filename": "src/wallet/feebumper.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 37,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/66b29848c71c4b3b4dc36ca6d94de829bd533797/src/wallet/feebumper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/66b29848c71c4b3b4dc36ca6d94de829bd533797/src/wallet/feebumper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.cpp?ref=66b29848c71c4b3b4dc36ca6d94de829bd533797",
        "patch": "@@ -17,15 +17,15 @@\n \n //! Check whether transaction has descendant in wallet or mempool, or has been\n //! mined, or conflicts with a mined transaction. Return a feebumper::Result.\n-static feebumper::Result PreconditionChecks(interfaces::Chain::Lock& locked_chain, const CWallet* wallet, const CWalletTx& wtx, std::vector<std::string>& errors) EXCLUSIVE_LOCKS_REQUIRED(wallet->cs_wallet)\n+static feebumper::Result PreconditionChecks(interfaces::Chain::Lock& locked_chain, const CWallet& wallet, const CWalletTx& wtx, std::vector<std::string>& errors) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet)\n {\n-    if (wallet->HasWalletSpend(wtx.GetHash())) {\n+    if (wallet.HasWalletSpend(wtx.GetHash())) {\n         errors.push_back(\"Transaction has descendants in the wallet\");\n         return feebumper::Result::INVALID_PARAMETER;\n     }\n \n     {\n-        if (wallet->chain().hasDescendantsInMempool(wtx.GetHash())) {\n+        if (wallet.chain().hasDescendantsInMempool(wtx.GetHash())) {\n             errors.push_back(\"Transaction has descendants in the mempool\");\n             return feebumper::Result::INVALID_PARAMETER;\n         }\n@@ -48,7 +48,7 @@ static feebumper::Result PreconditionChecks(interfaces::Chain::Lock& locked_chai\n \n     // check that original tx consists entirely of our inputs\n     // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n-    if (!wallet->IsAllFromMe(*wtx.tx, ISMINE_SPENDABLE)) {\n+    if (!wallet.IsAllFromMe(*wtx.tx, ISMINE_SPENDABLE)) {\n         errors.push_back(\"Transaction contains inputs that don't belong to this wallet\");\n         return feebumper::Result::WALLET_ERROR;\n     }\n@@ -58,13 +58,13 @@ static feebumper::Result PreconditionChecks(interfaces::Chain::Lock& locked_chai\n }\n \n //! Check if the user provided a valid feeRate\n-static feebumper::Result CheckFeeRate(const CWallet* wallet, const CWalletTx& wtx, const CFeeRate& newFeerate, const int64_t maxTxSize, std::vector<std::string>& errors) {\n+static feebumper::Result CheckFeeRate(const CWallet& wallet, const CWalletTx& wtx, const CFeeRate& newFeerate, const int64_t maxTxSize, std::vector<std::string>& errors) {\n     // check that fee rate is higher than mempool's minimum fee\n     // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n     // This may occur if the user set FeeRate, TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n     // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n     // moment earlier. In this case, we report an error to the user, who may adjust the fee.\n-    CFeeRate minMempoolFeeRate = wallet->chain().mempoolMinFee();\n+    CFeeRate minMempoolFeeRate = wallet.chain().mempoolMinFee();\n \n     if (newFeerate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n         errors.push_back(strprintf(\n@@ -76,7 +76,7 @@ static feebumper::Result CheckFeeRate(const CWallet* wallet, const CWalletTx& wt\n \n     CAmount new_total_fee = newFeerate.GetFee(maxTxSize);\n \n-    CFeeRate incrementalRelayFee = std::max(wallet->chain().relayIncrementalFee(), CFeeRate(WALLET_INCREMENTAL_RELAY_FEE));\n+    CFeeRate incrementalRelayFee = std::max(wallet.chain().relayIncrementalFee(), CFeeRate(WALLET_INCREMENTAL_RELAY_FEE));\n \n     // Given old total fee and transaction size, calculate the old feeRate\n     CAmount old_fee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n@@ -91,15 +91,15 @@ static feebumper::Result CheckFeeRate(const CWallet* wallet, const CWalletTx& wt\n         return feebumper::Result::INVALID_PARAMETER;\n     }\n \n-    CAmount requiredFee = GetRequiredFee(*wallet, maxTxSize);\n+    CAmount requiredFee = GetRequiredFee(wallet, maxTxSize);\n     if (new_total_fee < requiredFee) {\n         errors.push_back(strprintf(\"Insufficient total fee (cannot be less than required fee %s)\",\n             FormatMoney(requiredFee)));\n         return feebumper::Result::INVALID_PARAMETER;\n     }\n \n     // Check that in all cases the new fee doesn't violate maxTxFee\n-    const CAmount max_tx_fee = wallet->m_default_max_tx_fee;\n+    const CAmount max_tx_fee = wallet.m_default_max_tx_fee;\n     if (new_total_fee > max_tx_fee) {\n         errors.push_back(strprintf(\"Specified or calculated fee %s is too high (cannot be higher than -maxtxfee %s)\",\n                             FormatMoney(new_total_fee), FormatMoney(max_tx_fee)));\n@@ -109,7 +109,7 @@ static feebumper::Result CheckFeeRate(const CWallet* wallet, const CWalletTx& wt\n     return feebumper::Result::OK;\n }\n \n-static CFeeRate EstimateFeeRate(CWallet* wallet, const CWalletTx& wtx, CCoinControl& coin_control, CAmount& old_fee)\n+static CFeeRate EstimateFeeRate(const CWallet& wallet, const CWalletTx& wtx, CCoinControl& coin_control, CAmount& old_fee)\n {\n     // Get the fee rate of the original transaction. This is calculated from\n     // the tx fee/vsize, so it may have been rounded down. Add 1 satoshi to the\n@@ -126,24 +126,24 @@ static CFeeRate EstimateFeeRate(CWallet* wallet, const CWalletTx& wtx, CCoinCont\n     // aware of. This ensures we're over the required relay fee rate\n     // (BIP 125 rule 4).  The replacement tx will be at least as large as the\n     // original tx, so the total fee will be greater (BIP 125 rule 3)\n-    CFeeRate node_incremental_relay_fee = wallet->chain().relayIncrementalFee();\n+    CFeeRate node_incremental_relay_fee = wallet.chain().relayIncrementalFee();\n     CFeeRate wallet_incremental_relay_fee = CFeeRate(WALLET_INCREMENTAL_RELAY_FEE);\n     feerate += std::max(node_incremental_relay_fee, wallet_incremental_relay_fee);\n \n     // Fee rate must also be at least the wallet's GetMinimumFeeRate\n-    CFeeRate min_feerate(GetMinimumFeeRate(*wallet, coin_control, /* feeCalc */ nullptr));\n+    CFeeRate min_feerate(GetMinimumFeeRate(wallet, coin_control, /* feeCalc */ nullptr));\n \n     // Set the required fee rate for the replacement transaction in coin control.\n     return std::max(feerate, min_feerate);\n }\n \n namespace feebumper {\n \n-bool TransactionCanBeBumped(const CWallet* wallet, const uint256& txid)\n+bool TransactionCanBeBumped(const CWallet& wallet, const uint256& txid)\n {\n-    auto locked_chain = wallet->chain().lock();\n-    LOCK(wallet->cs_wallet);\n-    const CWalletTx* wtx = wallet->GetWalletTx(txid);\n+    auto locked_chain = wallet.chain().lock();\n+    LOCK(wallet.cs_wallet);\n+    const CWalletTx* wtx = wallet.GetWalletTx(txid);\n     if (wtx == nullptr) return false;\n \n     std::vector<std::string> errors_dummy;\n@@ -166,7 +166,7 @@ Result CreateTotalBumpTransaction(const CWallet* wallet, const uint256& txid, co\n     }\n     const CWalletTx& wtx = it->second;\n \n-    Result result = PreconditionChecks(*locked_chain, wallet, wtx, errors);\n+    Result result = PreconditionChecks(*locked_chain, *wallet, wtx, errors);\n     if (result != Result::OK) {\n         return result;\n     }\n@@ -276,17 +276,17 @@ Result CreateTotalBumpTransaction(const CWallet* wallet, const uint256& txid, co\n }\n \n \n-Result CreateRateBumpTransaction(CWallet* wallet, const uint256& txid, const CCoinControl& coin_control, std::vector<std::string>& errors,\n+Result CreateRateBumpTransaction(CWallet& wallet, const uint256& txid, const CCoinControl& coin_control, std::vector<std::string>& errors,\n                                  CAmount& old_fee, CAmount& new_fee, CMutableTransaction& mtx)\n {\n     // We are going to modify coin control later, copy to re-use\n     CCoinControl new_coin_control(coin_control);\n \n-    auto locked_chain = wallet->chain().lock();\n-    LOCK(wallet->cs_wallet);\n+    auto locked_chain = wallet.chain().lock();\n+    LOCK(wallet.cs_wallet);\n     errors.clear();\n-    auto it = wallet->mapWallet.find(txid);\n-    if (it == wallet->mapWallet.end()) {\n+    auto it = wallet.mapWallet.find(txid);\n+    if (it == wallet.mapWallet.end()) {\n         errors.push_back(\"Invalid or non-wallet transaction id\");\n         return Result::INVALID_ADDRESS_OR_KEY;\n     }\n@@ -300,7 +300,7 @@ Result CreateRateBumpTransaction(CWallet* wallet, const uint256& txid, const CCo\n     // Fill in recipients(and preserve a single change key if there is one)\n     std::vector<CRecipient> recipients;\n     for (const auto& output : wtx.tx->vout) {\n-        if (!wallet->IsChange(output)) {\n+        if (!wallet.IsChange(output)) {\n             CRecipient recipient = {output.scriptPubKey, output.nValue, false};\n             recipients.push_back(recipient);\n         } else {\n@@ -313,7 +313,7 @@ Result CreateRateBumpTransaction(CWallet* wallet, const uint256& txid, const CCo\n     if (coin_control.m_feerate) {\n         // The user provided a feeRate argument.\n         // We calculate this here to avoid compiler warning on the cs_wallet lock\n-        const int64_t maxTxSize = CalculateMaximumSignedTxSize(*wtx.tx, wallet);\n+        const int64_t maxTxSize = CalculateMaximumSignedTxSize(*wtx.tx, &wallet);\n         Result res = CheckFeeRate(wallet, wtx, *new_coin_control.m_feerate, maxTxSize, errors);\n         if (res != Result::OK) {\n             return res;\n@@ -342,7 +342,7 @@ Result CreateRateBumpTransaction(CWallet* wallet, const uint256& txid, const CCo\n     CAmount fee_ret;\n     int change_pos_in_out = -1; // No requested location for change\n     std::string fail_reason;\n-    if (!wallet->CreateTransaction(*locked_chain, recipients, tx_new, fee_ret, change_pos_in_out, fail_reason, new_coin_control, false)) {\n+    if (!wallet.CreateTransaction(*locked_chain, recipients, tx_new, fee_ret, change_pos_in_out, fail_reason, new_coin_control, false)) {\n         errors.push_back(\"Unable to create transaction: \" + fail_reason);\n         return Result::WALLET_ERROR;\n     }\n@@ -353,7 +353,7 @@ Result CreateRateBumpTransaction(CWallet* wallet, const uint256& txid, const CCo\n     // Write back transaction\n     mtx = CMutableTransaction(*tx_new);\n     // Mark new tx not replaceable, if requested.\n-    if (!coin_control.m_signal_bip125_rbf.get_value_or(wallet->m_signal_rbf)) {\n+    if (!coin_control.m_signal_bip125_rbf.get_value_or(wallet.m_signal_rbf)) {\n         for (auto& input : mtx.vin) {\n             if (input.nSequence < 0xfffffffe) input.nSequence = 0xfffffffe;\n         }\n@@ -362,21 +362,21 @@ Result CreateRateBumpTransaction(CWallet* wallet, const uint256& txid, const CCo\n     return Result::OK;\n }\n \n-bool SignTransaction(CWallet* wallet, CMutableTransaction& mtx) {\n-    auto locked_chain = wallet->chain().lock();\n-    LOCK(wallet->cs_wallet);\n-    return wallet->SignTransaction(mtx);\n+bool SignTransaction(CWallet& wallet, CMutableTransaction& mtx) {\n+    auto locked_chain = wallet.chain().lock();\n+    LOCK(wallet.cs_wallet);\n+    return wallet.SignTransaction(mtx);\n }\n \n-Result CommitTransaction(CWallet* wallet, const uint256& txid, CMutableTransaction&& mtx, std::vector<std::string>& errors, uint256& bumped_txid)\n+Result CommitTransaction(CWallet& wallet, const uint256& txid, CMutableTransaction&& mtx, std::vector<std::string>& errors, uint256& bumped_txid)\n {\n-    auto locked_chain = wallet->chain().lock();\n-    LOCK(wallet->cs_wallet);\n+    auto locked_chain = wallet.chain().lock();\n+    LOCK(wallet.cs_wallet);\n     if (!errors.empty()) {\n         return Result::MISC_ERROR;\n     }\n-    auto it = txid.IsNull() ? wallet->mapWallet.end() : wallet->mapWallet.find(txid);\n-    if (it == wallet->mapWallet.end()) {\n+    auto it = txid.IsNull() ? wallet.mapWallet.end() : wallet.mapWallet.find(txid);\n+    if (it == wallet.mapWallet.end()) {\n         errors.push_back(\"Invalid or non-wallet transaction id\");\n         return Result::MISC_ERROR;\n     }\n@@ -394,7 +394,7 @@ Result CommitTransaction(CWallet* wallet, const uint256& txid, CMutableTransacti\n     mapValue[\"replaces_txid\"] = oldWtx.GetHash().ToString();\n \n     CValidationState state;\n-    if (!wallet->CommitTransaction(tx, std::move(mapValue), oldWtx.vOrderForm, state)) {\n+    if (!wallet.CommitTransaction(tx, std::move(mapValue), oldWtx.vOrderForm, state)) {\n         // NOTE: CommitTransaction never returns false, so this should never happen.\n         errors.push_back(strprintf(\"The transaction was rejected: %s\", FormatStateMessage(state)));\n         return Result::WALLET_ERROR;\n@@ -408,7 +408,7 @@ Result CommitTransaction(CWallet* wallet, const uint256& txid, CMutableTransacti\n     }\n \n     // mark the original tx as bumped\n-    if (!wallet->MarkReplaced(oldWtx.GetHash(), bumped_txid)) {\n+    if (!wallet.MarkReplaced(oldWtx.GetHash(), bumped_txid)) {\n         // TODO: see if JSON-RPC has a standard way of returning a response\n         // along with an exception. It would be good to return information about\n         // wtxBumped to the caller even if marking the original transaction"
      },
      {
        "sha": "9357397606fa86dbf9b477fa8be6da9725d2cdfb",
        "filename": "src/wallet/feebumper.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/66b29848c71c4b3b4dc36ca6d94de829bd533797/src/wallet/feebumper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/66b29848c71c4b3b4dc36ca6d94de829bd533797/src/wallet/feebumper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.h?ref=66b29848c71c4b3b4dc36ca6d94de829bd533797",
        "patch": "@@ -26,7 +26,7 @@ enum class Result\n };\n \n //! Return whether transaction can be bumped.\n-bool TransactionCanBeBumped(const CWallet* wallet, const uint256& txid);\n+bool TransactionCanBeBumped(const CWallet& wallet, const uint256& txid);\n \n //! Create bumpfee transaction based on total amount.\n Result CreateTotalBumpTransaction(const CWallet* wallet,\n@@ -39,7 +39,7 @@ Result CreateTotalBumpTransaction(const CWallet* wallet,\n                          CMutableTransaction& mtx);\n \n //! Create bumpfee transaction based on feerate estimates.\n-Result CreateRateBumpTransaction(CWallet* wallet,\n+Result CreateRateBumpTransaction(CWallet& wallet,\n                          const uint256& txid,\n                          const CCoinControl& coin_control,\n                          std::vector<std::string>& errors,\n@@ -50,13 +50,13 @@ Result CreateRateBumpTransaction(CWallet* wallet,\n //! Sign the new transaction,\n //! @return false if the tx couldn't be found or if it was\n //! impossible to create the signature(s)\n-bool SignTransaction(CWallet* wallet, CMutableTransaction& mtx);\n+bool SignTransaction(CWallet& wallet, CMutableTransaction& mtx);\n \n //! Commit the bumpfee transaction.\n //! @return success in case of CWallet::CommitTransaction was successful,\n //! but sets errors if the tx could not be added to the mempool (will try later)\n //! or if the old transaction could not be marked as replaced.\n-Result CommitTransaction(CWallet* wallet,\n+Result CommitTransaction(CWallet& wallet,\n                          const uint256& txid,\n                          CMutableTransaction&& mtx,\n                          std::vector<std::string>& errors,"
      },
      {
        "sha": "debc3fecda4dc9247d890e6da55fd461333fa2ef",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/66b29848c71c4b3b4dc36ca6d94de829bd533797/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/66b29848c71c4b3b4dc36ca6d94de829bd533797/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=66b29848c71c4b3b4dc36ca6d94de829bd533797",
        "patch": "@@ -3417,7 +3417,7 @@ static UniValue bumpfee(const JSONRPCRequest& request)\n         res = feebumper::CreateTotalBumpTransaction(pwallet, hash, coin_control, totalFee, errors, old_fee, new_fee, mtx);\n     } else {\n         // Targeting feerate bump.\n-        res = feebumper::CreateRateBumpTransaction(pwallet, hash, coin_control, errors, old_fee, new_fee, mtx);\n+        res = feebumper::CreateRateBumpTransaction(*pwallet, hash, coin_control, errors, old_fee, new_fee, mtx);\n     }\n     if (res != feebumper::Result::OK) {\n         switch(res) {\n@@ -3440,12 +3440,12 @@ static UniValue bumpfee(const JSONRPCRequest& request)\n     }\n \n     // sign bumped transaction\n-    if (!feebumper::SignTransaction(pwallet, mtx)) {\n+    if (!feebumper::SignTransaction(*pwallet, mtx)) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Can't sign transaction.\");\n     }\n     // commit the bumped transaction\n     uint256 txid;\n-    if (feebumper::CommitTransaction(pwallet, hash, std::move(mtx), errors, txid) != feebumper::Result::OK) {\n+    if (feebumper::CommitTransaction(*pwallet, hash, std::move(mtx), errors, txid) != feebumper::Result::OK) {\n         throw JSONRPCError(RPC_WALLET_ERROR, errors[0]);\n     }\n     UniValue result(UniValue::VOBJ);"
      }
    ]
  }
]