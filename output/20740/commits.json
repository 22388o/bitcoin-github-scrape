[
  {
    "sha": "e3d2ba7c70b13a2165020e45abf02373a1e953f7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplM2QyYmE3YzcwYjEzYTIxNjUwMjBlNDVhYmYwMjM3M2ExZTk1M2Y3",
    "commit": {
      "author": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2020-12-21T23:19:33Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2020-12-21T23:19:33Z"
      },
      "message": "fuzz: Update FuzzedDataProvider.h from upstream (LLVM)\n\nUpstream revision: https://github.com/llvm/llvm-project/blob/6d0488f75bb2f37bcfe93fc8f59f6e78c9a0c939/compiler-rt/include/fuzzer/FuzzedDataProvider.h\n\nChanges:\n* [compiler-rt] FuzzedDataProvider: add ConsumeData and method.\n* [compiler-rt] Fix a typo in a comment in FuzzedDataProvider.h.\n* [compiler-rt] Add ConsumeRandomLengthString() version without arguments.\n* [compiler-rt] Refactor FuzzedDataProvider for better readability.\n* [compiler-rt] FuzzedDataProvider: make linter happy.\n* [compiler-rt] Mark FDP non-template methods inline to avoid ODR violations.",
      "tree": {
        "sha": "823aad7a718ac1994ec198ef8a65f1c8daf5c175",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/823aad7a718ac1994ec198ef8a65f1c8daf5c175"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e3d2ba7c70b13a2165020e45abf02373a1e953f7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3d2ba7c70b13a2165020e45abf02373a1e953f7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e3d2ba7c70b13a2165020e45abf02373a1e953f7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3d2ba7c70b13a2165020e45abf02373a1e953f7/comments",
    "author": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f4ac48d30a84906d648664c77bf839f012bebdbf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f4ac48d30a84906d648664c77bf839f012bebdbf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f4ac48d30a84906d648664c77bf839f012bebdbf"
      }
    ],
    "stats": {
      "total": 556,
      "additions": 319,
      "deletions": 237
    },
    "files": [
      {
        "sha": "83bcd0134a7d3a92c7d44c34db957886cc9f5579",
        "filename": "src/test/fuzz/FuzzedDataProvider.h",
        "status": "modified",
        "additions": 319,
        "deletions": 237,
        "changes": 556,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3d2ba7c70b13a2165020e45abf02373a1e953f7/src/test/fuzz/FuzzedDataProvider.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3d2ba7c70b13a2165020e45abf02373a1e953f7/src/test/fuzz/FuzzedDataProvider.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/FuzzedDataProvider.h?ref=e3d2ba7c70b13a2165020e45abf02373a1e953f7",
        "patch": "@@ -34,272 +34,354 @@ class FuzzedDataProvider {\n       : data_ptr_(data), remaining_bytes_(size) {}\n   ~FuzzedDataProvider() = default;\n \n-  // Returns a std::vector containing |num_bytes| of input data. If fewer than\n-  // |num_bytes| of data remain, returns a shorter std::vector containing all\n-  // of the data that's left. Can be used with any byte sized type, such as\n-  // char, unsigned char, uint8_t, etc.\n-  template <typename T> std::vector<T> ConsumeBytes(size_t num_bytes) {\n-    num_bytes = std::min(num_bytes, remaining_bytes_);\n-    return ConsumeBytes<T>(num_bytes, num_bytes);\n-  }\n-\n-  // Similar to |ConsumeBytes|, but also appends the terminator value at the end\n-  // of the resulting vector. Useful, when a mutable null-terminated C-string is\n-  // needed, for example. But that is a rare case. Better avoid it, if possible,\n-  // and prefer using |ConsumeBytes| or |ConsumeBytesAsString| methods.\n+  // See the implementation below (after the class definition) for more verbose\n+  // comments for each of the methods.\n+\n+  // Methods returning std::vector of bytes. These are the most popular choice\n+  // when splitting fuzzing input into pieces, as every piece is put into a\n+  // separate buffer (i.e. ASan would catch any under-/overflow) and the memory\n+  // will be released automatically.\n+  template <typename T> std::vector<T> ConsumeBytes(size_t num_bytes);\n   template <typename T>\n-  std::vector<T> ConsumeBytesWithTerminator(size_t num_bytes,\n-                                            T terminator = 0) {\n-    num_bytes = std::min(num_bytes, remaining_bytes_);\n-    std::vector<T> result = ConsumeBytes<T>(num_bytes + 1, num_bytes);\n-    result.back() = terminator;\n-    return result;\n-  }\n-\n-  // Returns a std::string containing |num_bytes| of input data. Using this and\n-  // |.c_str()| on the resulting string is the best way to get an immutable\n-  // null-terminated C string. If fewer than |num_bytes| of data remain, returns\n-  // a shorter std::string containing all of the data that's left.\n-  std::string ConsumeBytesAsString(size_t num_bytes) {\n-    static_assert(sizeof(std::string::value_type) == sizeof(uint8_t),\n-                  \"ConsumeBytesAsString cannot convert the data to a string.\");\n-\n-    num_bytes = std::min(num_bytes, remaining_bytes_);\n-    std::string result(\n-        reinterpret_cast<const std::string::value_type *>(data_ptr_),\n-        num_bytes);\n-    Advance(num_bytes);\n-    return result;\n-  }\n+  std::vector<T> ConsumeBytesWithTerminator(size_t num_bytes, T terminator = 0);\n+  template <typename T> std::vector<T> ConsumeRemainingBytes();\n \n-  // Returns a number in the range [min, max] by consuming bytes from the\n-  // input data. The value might not be uniformly distributed in the given\n-  // range. If there's no input data left, always returns |min|. |min| must\n-  // be less than or equal to |max|.\n-  template <typename T> T ConsumeIntegralInRange(T min, T max) {\n-    static_assert(std::is_integral<T>::value, \"An integral type is required.\");\n-    static_assert(sizeof(T) <= sizeof(uint64_t), \"Unsupported integral type.\");\n+  // Methods returning strings. Use only when you need a std::string or a null\n+  // terminated C-string. Otherwise, prefer the methods returning std::vector.\n+  std::string ConsumeBytesAsString(size_t num_bytes);\n+  std::string ConsumeRandomLengthString(size_t max_length);\n+  std::string ConsumeRandomLengthString();\n+  std::string ConsumeRemainingBytesAsString();\n \n-    if (min > max)\n-      abort();\n+  // Methods returning integer values.\n+  template <typename T> T ConsumeIntegral();\n+  template <typename T> T ConsumeIntegralInRange(T min, T max);\n \n-    // Use the biggest type possible to hold the range and the result.\n-    uint64_t range = static_cast<uint64_t>(max) - min;\n-    uint64_t result = 0;\n-    size_t offset = 0;\n-\n-    while (offset < sizeof(T) * CHAR_BIT && (range >> offset) > 0 &&\n-           remaining_bytes_ != 0) {\n-      // Pull bytes off the end of the seed data. Experimentally, this seems to\n-      // allow the fuzzer to more easily explore the input space. This makes\n-      // sense, since it works by modifying inputs that caused new code to run,\n-      // and this data is often used to encode length of data read by\n-      // |ConsumeBytes|. Separating out read lengths makes it easier modify the\n-      // contents of the data that is actually read.\n-      --remaining_bytes_;\n-      result = (result << CHAR_BIT) | data_ptr_[remaining_bytes_];\n-      offset += CHAR_BIT;\n-    }\n+  // Methods returning floating point values.\n+  template <typename T> T ConsumeFloatingPoint();\n+  template <typename T> T ConsumeFloatingPointInRange(T min, T max);\n \n-    // Avoid division by 0, in case |range + 1| results in overflow.\n-    if (range != std::numeric_limits<decltype(range)>::max())\n-      result = result % (range + 1);\n+  // 0 <= return value <= 1.\n+  template <typename T> T ConsumeProbability();\n \n-    return static_cast<T>(min + result);\n-  }\n+  bool ConsumeBool();\n \n-  // Returns a std::string of length from 0 to |max_length|. When it runs out of\n-  // input data, returns what remains of the input. Designed to be more stable\n-  // with respect to a fuzzer inserting characters than just picking a random\n-  // length and then consuming that many bytes with |ConsumeBytes|.\n-  std::string ConsumeRandomLengthString(size_t max_length) {\n-    // Reads bytes from the start of |data_ptr_|. Maps \"\\\\\" to \"\\\", and maps \"\\\"\n-    // followed by anything else to the end of the string. As a result of this\n-    // logic, a fuzzer can insert characters into the string, and the string\n-    // will be lengthened to include those new characters, resulting in a more\n-    // stable fuzzer than picking the length of a string independently from\n-    // picking its contents.\n-    std::string result;\n-\n-    // Reserve the anticipated capaticity to prevent several reallocations.\n-    result.reserve(std::min(max_length, remaining_bytes_));\n-    for (size_t i = 0; i < max_length && remaining_bytes_ != 0; ++i) {\n-      char next = ConvertUnsignedToSigned<char>(data_ptr_[0]);\n-      Advance(1);\n-      if (next == '\\\\' && remaining_bytes_ != 0) {\n-        next = ConvertUnsignedToSigned<char>(data_ptr_[0]);\n-        Advance(1);\n-        if (next != '\\\\')\n-          break;\n-      }\n-      result += next;\n-    }\n+  // Returns a value chosen from the given enum.\n+  template <typename T> T ConsumeEnum();\n \n-    result.shrink_to_fit();\n-    return result;\n-  }\n+  // Returns a value from the given array.\n+  template <typename T, size_t size> T PickValueInArray(const T (&array)[size]);\n+  template <typename T> T PickValueInArray(std::initializer_list<const T> list);\n \n-  // Returns a std::vector containing all remaining bytes of the input data.\n-  template <typename T> std::vector<T> ConsumeRemainingBytes() {\n-    return ConsumeBytes<T>(remaining_bytes_);\n-  }\n+  // Writes data to the given destination and returns number of bytes written.\n+  size_t ConsumeData(void *destination, size_t num_bytes);\n \n-  // Returns a std::string containing all remaining bytes of the input data.\n-  // Prefer using |ConsumeRemainingBytes| unless you actually need a std::string\n-  // object.\n-  std::string ConsumeRemainingBytesAsString() {\n-    return ConsumeBytesAsString(remaining_bytes_);\n-  }\n+  // Reports the remaining bytes available for fuzzed input.\n+  size_t remaining_bytes() { return remaining_bytes_; }\n \n-  // Returns a number in the range [Type's min, Type's max]. The value might\n-  // not be uniformly distributed in the given range. If there's no input data\n-  // left, always returns |min|.\n-  template <typename T> T ConsumeIntegral() {\n-    return ConsumeIntegralInRange(std::numeric_limits<T>::min(),\n-                                  std::numeric_limits<T>::max());\n-  }\n+ private:\n+  FuzzedDataProvider(const FuzzedDataProvider &) = delete;\n+  FuzzedDataProvider &operator=(const FuzzedDataProvider &) = delete;\n \n-  // Reads one byte and returns a bool, or false when no data remains.\n-  bool ConsumeBool() { return 1 & ConsumeIntegral<uint8_t>(); }\n+  void CopyAndAdvance(void *destination, size_t num_bytes);\n \n-  // Returns a copy of the value selected from the given fixed-size |array|.\n-  template <typename T, size_t size>\n-  T PickValueInArray(const T (&array)[size]) {\n-    static_assert(size > 0, \"The array must be non empty.\");\n-    return array[ConsumeIntegralInRange<size_t>(0, size - 1)];\n-  }\n+  void Advance(size_t num_bytes);\n \n   template <typename T>\n-  T PickValueInArray(std::initializer_list<const T> list) {\n-    // TODO(Dor1s): switch to static_assert once C++14 is allowed.\n-    if (!list.size())\n-      abort();\n-\n-    return *(list.begin() + ConsumeIntegralInRange<size_t>(0, list.size() - 1));\n-  }\n-\n-  // Returns an enum value. The enum must start at 0 and be contiguous. It must\n-  // also contain |kMaxValue| aliased to its largest (inclusive) value. Such as:\n-  // enum class Foo { SomeValue, OtherValue, kMaxValue = OtherValue };\n-  template <typename T> T ConsumeEnum() {\n-    static_assert(std::is_enum<T>::value, \"|T| must be an enum type.\");\n-    return static_cast<T>(ConsumeIntegralInRange<uint32_t>(\n-        0, static_cast<uint32_t>(T::kMaxValue)));\n-  }\n+  std::vector<T> ConsumeBytes(size_t size, size_t num_bytes);\n \n-  // Returns a floating point number in the range [0.0, 1.0]. If there's no\n-  // input data left, always returns 0.\n-  template <typename T> T ConsumeProbability() {\n-    static_assert(std::is_floating_point<T>::value,\n-                  \"A floating point type is required.\");\n+  template <typename TS, typename TU> TS ConvertUnsignedToSigned(TU value);\n \n-    // Use different integral types for different floating point types in order\n-    // to provide better density of the resulting values.\n-    using IntegralType =\n-        typename std::conditional<(sizeof(T) <= sizeof(uint32_t)), uint32_t,\n-                                  uint64_t>::type;\n+  const uint8_t *data_ptr_;\n+  size_t remaining_bytes_;\n+};\n \n-    T result = static_cast<T>(ConsumeIntegral<IntegralType>());\n-    result /= static_cast<T>(std::numeric_limits<IntegralType>::max());\n-    return result;\n+// Returns a std::vector containing |num_bytes| of input data. If fewer than\n+// |num_bytes| of data remain, returns a shorter std::vector containing all\n+// of the data that's left. Can be used with any byte sized type, such as\n+// char, unsigned char, uint8_t, etc.\n+template <typename T>\n+std::vector<T> FuzzedDataProvider::ConsumeBytes(size_t num_bytes) {\n+  num_bytes = std::min(num_bytes, remaining_bytes_);\n+  return ConsumeBytes<T>(num_bytes, num_bytes);\n+}\n+\n+// Similar to |ConsumeBytes|, but also appends the terminator value at the end\n+// of the resulting vector. Useful, when a mutable null-terminated C-string is\n+// needed, for example. But that is a rare case. Better avoid it, if possible,\n+// and prefer using |ConsumeBytes| or |ConsumeBytesAsString| methods.\n+template <typename T>\n+std::vector<T> FuzzedDataProvider::ConsumeBytesWithTerminator(size_t num_bytes,\n+                                                              T terminator) {\n+  num_bytes = std::min(num_bytes, remaining_bytes_);\n+  std::vector<T> result = ConsumeBytes<T>(num_bytes + 1, num_bytes);\n+  result.back() = terminator;\n+  return result;\n+}\n+\n+// Returns a std::vector containing all remaining bytes of the input data.\n+template <typename T>\n+std::vector<T> FuzzedDataProvider::ConsumeRemainingBytes() {\n+  return ConsumeBytes<T>(remaining_bytes_);\n+}\n+\n+// Returns a std::string containing |num_bytes| of input data. Using this and\n+// |.c_str()| on the resulting string is the best way to get an immutable\n+// null-terminated C string. If fewer than |num_bytes| of data remain, returns\n+// a shorter std::string containing all of the data that's left.\n+inline std::string FuzzedDataProvider::ConsumeBytesAsString(size_t num_bytes) {\n+  static_assert(sizeof(std::string::value_type) == sizeof(uint8_t),\n+                \"ConsumeBytesAsString cannot convert the data to a string.\");\n+\n+  num_bytes = std::min(num_bytes, remaining_bytes_);\n+  std::string result(\n+      reinterpret_cast<const std::string::value_type *>(data_ptr_), num_bytes);\n+  Advance(num_bytes);\n+  return result;\n+}\n+\n+// Returns a std::string of length from 0 to |max_length|. When it runs out of\n+// input data, returns what remains of the input. Designed to be more stable\n+// with respect to a fuzzer inserting characters than just picking a random\n+// length and then consuming that many bytes with |ConsumeBytes|.\n+inline std::string\n+FuzzedDataProvider::ConsumeRandomLengthString(size_t max_length) {\n+  // Reads bytes from the start of |data_ptr_|. Maps \"\\\\\" to \"\\\", and maps \"\\\"\n+  // followed by anything else to the end of the string. As a result of this\n+  // logic, a fuzzer can insert characters into the string, and the string\n+  // will be lengthened to include those new characters, resulting in a more\n+  // stable fuzzer than picking the length of a string independently from\n+  // picking its contents.\n+  std::string result;\n+\n+  // Reserve the anticipated capaticity to prevent several reallocations.\n+  result.reserve(std::min(max_length, remaining_bytes_));\n+  for (size_t i = 0; i < max_length && remaining_bytes_ != 0; ++i) {\n+    char next = ConvertUnsignedToSigned<char>(data_ptr_[0]);\n+    Advance(1);\n+    if (next == '\\\\' && remaining_bytes_ != 0) {\n+      next = ConvertUnsignedToSigned<char>(data_ptr_[0]);\n+      Advance(1);\n+      if (next != '\\\\')\n+        break;\n+    }\n+    result += next;\n   }\n \n-  // Returns a floating point value in the range [Type's lowest, Type's max] by\n-  // consuming bytes from the input data. If there's no input data left, always\n-  // returns approximately 0.\n-  template <typename T> T ConsumeFloatingPoint() {\n-    return ConsumeFloatingPointInRange<T>(std::numeric_limits<T>::lowest(),\n-                                          std::numeric_limits<T>::max());\n+  result.shrink_to_fit();\n+  return result;\n+}\n+\n+// Returns a std::string of length from 0 to |remaining_bytes_|.\n+inline std::string FuzzedDataProvider::ConsumeRandomLengthString() {\n+  return ConsumeRandomLengthString(remaining_bytes_);\n+}\n+\n+// Returns a std::string containing all remaining bytes of the input data.\n+// Prefer using |ConsumeRemainingBytes| unless you actually need a std::string\n+// object.\n+inline std::string FuzzedDataProvider::ConsumeRemainingBytesAsString() {\n+  return ConsumeBytesAsString(remaining_bytes_);\n+}\n+\n+// Returns a number in the range [Type's min, Type's max]. The value might\n+// not be uniformly distributed in the given range. If there's no input data\n+// left, always returns |min|.\n+template <typename T> T FuzzedDataProvider::ConsumeIntegral() {\n+  return ConsumeIntegralInRange(std::numeric_limits<T>::min(),\n+                                std::numeric_limits<T>::max());\n+}\n+\n+// Returns a number in the range [min, max] by consuming bytes from the\n+// input data. The value might not be uniformly distributed in the given\n+// range. If there's no input data left, always returns |min|. |min| must\n+// be less than or equal to |max|.\n+template <typename T>\n+T FuzzedDataProvider::ConsumeIntegralInRange(T min, T max) {\n+  static_assert(std::is_integral<T>::value, \"An integral type is required.\");\n+  static_assert(sizeof(T) <= sizeof(uint64_t), \"Unsupported integral type.\");\n+\n+  if (min > max)\n+    abort();\n+\n+  // Use the biggest type possible to hold the range and the result.\n+  uint64_t range = static_cast<uint64_t>(max) - min;\n+  uint64_t result = 0;\n+  size_t offset = 0;\n+\n+  while (offset < sizeof(T) * CHAR_BIT && (range >> offset) > 0 &&\n+         remaining_bytes_ != 0) {\n+    // Pull bytes off the end of the seed data. Experimentally, this seems to\n+    // allow the fuzzer to more easily explore the input space. This makes\n+    // sense, since it works by modifying inputs that caused new code to run,\n+    // and this data is often used to encode length of data read by\n+    // |ConsumeBytes|. Separating out read lengths makes it easier modify the\n+    // contents of the data that is actually read.\n+    --remaining_bytes_;\n+    result = (result << CHAR_BIT) | data_ptr_[remaining_bytes_];\n+    offset += CHAR_BIT;\n   }\n \n-  // Returns a floating point value in the given range by consuming bytes from\n-  // the input data. If there's no input data left, returns |min|. Note that\n-  // |min| must be less than or equal to |max|.\n-  template <typename T> T ConsumeFloatingPointInRange(T min, T max) {\n-    if (min > max)\n-      abort();\n-\n-    T range = .0;\n-    T result = min;\n-    constexpr T zero(.0);\n-    if (max > zero && min < zero && max > min + std::numeric_limits<T>::max()) {\n-      // The diff |max - min| would overflow the given floating point type. Use\n-      // the half of the diff as the range and consume a bool to decide whether\n-      // the result is in the first of the second part of the diff.\n-      range = (max / 2.0) - (min / 2.0);\n-      if (ConsumeBool()) {\n-        result += range;\n-      }\n-    } else {\n-      range = max - min;\n+  // Avoid division by 0, in case |range + 1| results in overflow.\n+  if (range != std::numeric_limits<decltype(range)>::max())\n+    result = result % (range + 1);\n+\n+  return static_cast<T>(min + result);\n+}\n+\n+// Returns a floating point value in the range [Type's lowest, Type's max] by\n+// consuming bytes from the input data. If there's no input data left, always\n+// returns approximately 0.\n+template <typename T> T FuzzedDataProvider::ConsumeFloatingPoint() {\n+  return ConsumeFloatingPointInRange<T>(std::numeric_limits<T>::lowest(),\n+                                        std::numeric_limits<T>::max());\n+}\n+\n+// Returns a floating point value in the given range by consuming bytes from\n+// the input data. If there's no input data left, returns |min|. Note that\n+// |min| must be less than or equal to |max|.\n+template <typename T>\n+T FuzzedDataProvider::ConsumeFloatingPointInRange(T min, T max) {\n+  if (min > max)\n+    abort();\n+\n+  T range = .0;\n+  T result = min;\n+  constexpr T zero(.0);\n+  if (max > zero && min < zero && max > min + std::numeric_limits<T>::max()) {\n+    // The diff |max - min| would overflow the given floating point type. Use\n+    // the half of the diff as the range and consume a bool to decide whether\n+    // the result is in the first of the second part of the diff.\n+    range = (max / 2.0) - (min / 2.0);\n+    if (ConsumeBool()) {\n+      result += range;\n     }\n-\n-    return result + range * ConsumeProbability<T>();\n+  } else {\n+    range = max - min;\n   }\n \n-  // Reports the remaining bytes available for fuzzed input.\n-  size_t remaining_bytes() { return remaining_bytes_; }\n-\n- private:\n-  FuzzedDataProvider(const FuzzedDataProvider &) = delete;\n-  FuzzedDataProvider &operator=(const FuzzedDataProvider &) = delete;\n-\n-  void Advance(size_t num_bytes) {\n-    if (num_bytes > remaining_bytes_)\n+  return result + range * ConsumeProbability<T>();\n+}\n+\n+// Returns a floating point number in the range [0.0, 1.0]. If there's no\n+// input data left, always returns 0.\n+template <typename T> T FuzzedDataProvider::ConsumeProbability() {\n+  static_assert(std::is_floating_point<T>::value,\n+                \"A floating point type is required.\");\n+\n+  // Use different integral types for different floating point types in order\n+  // to provide better density of the resulting values.\n+  using IntegralType =\n+      typename std::conditional<(sizeof(T) <= sizeof(uint32_t)), uint32_t,\n+                                uint64_t>::type;\n+\n+  T result = static_cast<T>(ConsumeIntegral<IntegralType>());\n+  result /= static_cast<T>(std::numeric_limits<IntegralType>::max());\n+  return result;\n+}\n+\n+// Reads one byte and returns a bool, or false when no data remains.\n+inline bool FuzzedDataProvider::ConsumeBool() {\n+  return 1 & ConsumeIntegral<uint8_t>();\n+}\n+\n+// Returns an enum value. The enum must start at 0 and be contiguous. It must\n+// also contain |kMaxValue| aliased to its largest (inclusive) value. Such as:\n+// enum class Foo { SomeValue, OtherValue, kMaxValue = OtherValue };\n+template <typename T> T FuzzedDataProvider::ConsumeEnum() {\n+  static_assert(std::is_enum<T>::value, \"|T| must be an enum type.\");\n+  return static_cast<T>(\n+      ConsumeIntegralInRange<uint32_t>(0, static_cast<uint32_t>(T::kMaxValue)));\n+}\n+\n+// Returns a copy of the value selected from the given fixed-size |array|.\n+template <typename T, size_t size>\n+T FuzzedDataProvider::PickValueInArray(const T (&array)[size]) {\n+  static_assert(size > 0, \"The array must be non empty.\");\n+  return array[ConsumeIntegralInRange<size_t>(0, size - 1)];\n+}\n+\n+template <typename T>\n+T FuzzedDataProvider::PickValueInArray(std::initializer_list<const T> list) {\n+  // TODO(Dor1s): switch to static_assert once C++14 is allowed.\n+  if (!list.size())\n+    abort();\n+\n+  return *(list.begin() + ConsumeIntegralInRange<size_t>(0, list.size() - 1));\n+}\n+\n+// Writes |num_bytes| of input data to the given destination pointer. If there\n+// is not enough data left, writes all remaining bytes. Return value is the\n+// number of bytes written.\n+// In general, it's better to avoid using this function, but it may be useful\n+// in cases when it's necessary to fill a certain buffer or object with\n+// fuzzing data.\n+inline size_t FuzzedDataProvider::ConsumeData(void *destination,\n+                                              size_t num_bytes) {\n+  num_bytes = std::min(num_bytes, remaining_bytes_);\n+  CopyAndAdvance(destination, num_bytes);\n+  return num_bytes;\n+}\n+\n+// Private methods.\n+inline void FuzzedDataProvider::CopyAndAdvance(void *destination,\n+                                               size_t num_bytes) {\n+  std::memcpy(destination, data_ptr_, num_bytes);\n+  Advance(num_bytes);\n+}\n+\n+inline void FuzzedDataProvider::Advance(size_t num_bytes) {\n+  if (num_bytes > remaining_bytes_)\n+    abort();\n+\n+  data_ptr_ += num_bytes;\n+  remaining_bytes_ -= num_bytes;\n+}\n+\n+template <typename T>\n+std::vector<T> FuzzedDataProvider::ConsumeBytes(size_t size, size_t num_bytes) {\n+  static_assert(sizeof(T) == sizeof(uint8_t), \"Incompatible data type.\");\n+\n+  // The point of using the size-based constructor below is to increase the\n+  // odds of having a vector object with capacity being equal to the length.\n+  // That part is always implementation specific, but at least both libc++ and\n+  // libstdc++ allocate the requested number of bytes in that constructor,\n+  // which seems to be a natural choice for other implementations as well.\n+  // To increase the odds even more, we also call |shrink_to_fit| below.\n+  std::vector<T> result(size);\n+  if (size == 0) {\n+    if (num_bytes != 0)\n       abort();\n-\n-    data_ptr_ += num_bytes;\n-    remaining_bytes_ -= num_bytes;\n-  }\n-\n-  template <typename T>\n-  std::vector<T> ConsumeBytes(size_t size, size_t num_bytes_to_consume) {\n-    static_assert(sizeof(T) == sizeof(uint8_t), \"Incompatible data type.\");\n-\n-    // The point of using the size-based constructor below is to increase the\n-    // odds of having a vector object with capacity being equal to the length.\n-    // That part is always implementation specific, but at least both libc++ and\n-    // libstdc++ allocate the requested number of bytes in that constructor,\n-    // which seems to be a natural choice for other implementations as well.\n-    // To increase the odds even more, we also call |shrink_to_fit| below.\n-    std::vector<T> result(size);\n-    if (size == 0) {\n-      if (num_bytes_to_consume != 0)\n-        abort();\n-      return result;\n-    }\n-\n-    std::memcpy(result.data(), data_ptr_, num_bytes_to_consume);\n-    Advance(num_bytes_to_consume);\n-\n-    // Even though |shrink_to_fit| is also implementation specific, we expect it\n-    // to provide an additional assurance in case vector's constructor allocated\n-    // a buffer which is larger than the actual amount of data we put inside it.\n-    result.shrink_to_fit();\n     return result;\n   }\n \n-  template <typename TS, typename TU> TS ConvertUnsignedToSigned(TU value) {\n-    static_assert(sizeof(TS) == sizeof(TU), \"Incompatible data types.\");\n-    static_assert(!std::numeric_limits<TU>::is_signed,\n-                  \"Source type must be unsigned.\");\n-\n-    // TODO(Dor1s): change to `if constexpr` once C++17 becomes mainstream.\n-    if (std::numeric_limits<TS>::is_modulo)\n-      return static_cast<TS>(value);\n-\n-    // Avoid using implementation-defined unsigned to signer conversions.\n-    // To learn more, see https://stackoverflow.com/questions/13150449.\n-    if (value <= std::numeric_limits<TS>::max()) {\n-      return static_cast<TS>(value);\n-    } else {\n-      constexpr auto TS_min = std::numeric_limits<TS>::min();\n-      return TS_min + static_cast<char>(value - TS_min);\n-    }\n+  CopyAndAdvance(result.data(), num_bytes);\n+\n+  // Even though |shrink_to_fit| is also implementation specific, we expect it\n+  // to provide an additional assurance in case vector's constructor allocated\n+  // a buffer which is larger than the actual amount of data we put inside it.\n+  result.shrink_to_fit();\n+  return result;\n+}\n+\n+template <typename TS, typename TU>\n+TS FuzzedDataProvider::ConvertUnsignedToSigned(TU value) {\n+  static_assert(sizeof(TS) == sizeof(TU), \"Incompatible data types.\");\n+  static_assert(!std::numeric_limits<TU>::is_signed,\n+                \"Source type must be unsigned.\");\n+\n+  // TODO(Dor1s): change to `if constexpr` once C++17 becomes mainstream.\n+  if (std::numeric_limits<TS>::is_modulo)\n+    return static_cast<TS>(value);\n+\n+  // Avoid using implementation-defined unsigned to signed conversions.\n+  // To learn more, see https://stackoverflow.com/questions/13150449.\n+  if (value <= std::numeric_limits<TS>::max()) {\n+    return static_cast<TS>(value);\n+  } else {\n+    constexpr auto TS_min = std::numeric_limits<TS>::min();\n+    return TS_min + static_cast<char>(value - TS_min);\n   }\n-\n-  const uint8_t *data_ptr_;\n-  size_t remaining_bytes_;\n-};\n+}\n \n #endif // LLVM_FUZZER_FUZZED_DATA_PROVIDER_H_"
      }
    ]
  }
]