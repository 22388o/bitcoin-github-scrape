[
  {
    "sha": "fa96efffea6f83ca8b66a337bb0c07dd6b951a8d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTk2ZWZmZmVhNmY4M2NhOGI2NmEzMzdiYjBjMDdkZDZiOTUxYThk",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-06-21T18:24:20Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-07-17T12:48:17Z"
      },
      "message": "test: Sync nodes in helper method (simplify feature_rbf test)",
      "tree": {
        "sha": "13d8b17587e68d3b23d461f77221e5b118ab56d9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/13d8b17587e68d3b23d461f77221e5b118ab56d9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa96efffea6f83ca8b66a337bb0c07dd6b951a8d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUjvDAv+I5Hu7z7RozXUAwvpGRknlCN3BsIrHmgUrDDfj8wSWshty/uhld+LHYtN\nAE5Jpu1kLC4zIa/TNeA/G956IM35DpghqcQzvYW8U6Iy9dSPRlZygdmMX9aaBA5N\nwUKqgxJem8rrECKfqMGCynnAukeJbm47LH6yVv7MIyyKPMmmof4wc+bHPOsbKddC\nqXsjX7KkY6RGUT2/BNs4gjXoAzB8PjpBwI6zw/72TSrQPZq5tbOjIpnVxiLUWr5i\nK1JDfDrf8OPJSf27kvDkzbAOlViDJLpG5AV+mFRWdv0uMNrbJPweWUucPm0Eh/NN\nQKEI8mcITQm/Tj4kJZywnFsUVKCl+CHa/wNHWGAwBSDbNtYWjayIdgubxyXpGYfx\n72EMGIafNcc90RlUlPHd7LkTdGW7+l5tZ5zon6isjeOPdWQwjHvk07DS5+iG1UYY\n9vGLrF73l0Gd0bOHG8Az5a+TomQNAkdZy8TsAk538XAInW+6jT2SGURPItihdqHu\nkiWkk3fO\n=lYua\n-----END PGP SIGNATURE-----",
        "payload": "tree 13d8b17587e68d3b23d461f77221e5b118ab56d9\nparent 24dbcf380844f326b6a4e59466dba892314d2843\nauthor MarcoFalke <falke.marco@gmail.com> 1561141460 -0400\ncommitter MarcoFalke <falke.marco@gmail.com> 1563367697 -0400\n\ntest: Sync nodes in helper method (simplify feature_rbf test)\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa96efffea6f83ca8b66a337bb0c07dd6b951a8d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa96efffea6f83ca8b66a337bb0c07dd6b951a8d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa96efffea6f83ca8b66a337bb0c07dd6b951a8d/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "24dbcf380844f326b6a4e59466dba892314d2843",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/24dbcf380844f326b6a4e59466dba892314d2843",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/24dbcf380844f326b6a4e59466dba892314d2843"
      }
    ],
    "stats": {
      "total": 48,
      "additions": 22,
      "deletions": 26
    },
    "files": [
      {
        "sha": "981973bbbcf56d1442a1c225bec120417abfa2d9",
        "filename": "test/functional/feature_rbf.py",
        "status": "modified",
        "additions": 22,
        "deletions": 26,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa96efffea6f83ca8b66a337bb0c07dd6b951a8d/test/functional/feature_rbf.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa96efffea6f83ca8b66a337bb0c07dd6b951a8d/test/functional/feature_rbf.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_rbf.py?ref=fa96efffea6f83ca8b66a337bb0c07dd6b951a8d",
        "patch": "@@ -16,7 +16,7 @@\n def txToHex(tx):\n     return tx.serialize().hex()\n \n-def make_utxo(node, amount, confirmed=True, scriptPubKey=CScript([1])):\n+def make_utxo_util(node, amount, confirmed=True, scriptPubKey=CScript([1])):\n     \"\"\"Create a txout with a given amount and scriptPubKey\n \n     Mines coins as needed.\n@@ -79,14 +79,15 @@ def set_test_params(self):\n     def skip_test_if_missing_module(self):\n         self.skip_if_no_wallet()\n \n-    def run_test(self):\n-        # Leave IBD\n-        self.nodes[0].generate(1)\n-\n-        make_utxo(self.nodes[0], 1*COIN)\n+    def make_utxo(self, *args):\n+        outpoint = make_utxo_util(self.nodes[0], *args)\n \n         # Ensure nodes are synced\n         self.sync_all()\n+        return outpoint\n+\n+    def run_test(self):\n+        self.make_utxo(1 * COIN)\n \n         self.log.info(\"Running test simple doublespend...\")\n         self.test_simple_doublespend()\n@@ -122,12 +123,7 @@ def run_test(self):\n \n     def test_simple_doublespend(self):\n         \"\"\"Simple doublespend\"\"\"\n-        tx0_outpoint = make_utxo(self.nodes[0], int(1.1*COIN))\n-\n-        # make_utxo may have generated a bunch of blocks, so we need to sync\n-        # before we can spend the coins generated, or else the resulting\n-        # transactions might not be accepted by our peers.\n-        self.sync_all()\n+        tx0_outpoint = self.make_utxo(int(1.1 * COIN))\n \n         tx1a = CTransaction()\n         tx1a.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n@@ -165,7 +161,7 @@ def test_doublespend_chain(self):\n         \"\"\"Doublespend of a long chain\"\"\"\n \n         initial_nValue = 50*COIN\n-        tx0_outpoint = make_utxo(self.nodes[0], initial_nValue)\n+        tx0_outpoint = self.make_utxo(initial_nValue)\n \n         prevout = tx0_outpoint\n         remaining_value = initial_nValue\n@@ -205,7 +201,7 @@ def test_doublespend_tree(self):\n         \"\"\"Doublespend of a big tree of transactions\"\"\"\n \n         initial_nValue = 50*COIN\n-        tx0_outpoint = make_utxo(self.nodes[0], initial_nValue)\n+        tx0_outpoint = self.make_utxo(initial_nValue)\n \n         def branch(prevout, initial_value, max_txs, tree_width=5, fee=0.0001*COIN, _total_txs=None):\n             if _total_txs is None:\n@@ -268,7 +264,7 @@ def branch(prevout, initial_value, max_txs, tree_width=5, fee=0.0001*COIN, _tota\n         # double-spent at once\" anti-DoS limit.\n         for n in (MAX_REPLACEMENT_LIMIT+1, MAX_REPLACEMENT_LIMIT*2):\n             fee = int(0.0001*COIN)\n-            tx0_outpoint = make_utxo(self.nodes[0], initial_nValue)\n+            tx0_outpoint = self.make_utxo(initial_nValue)\n             tree_txs = list(branch(tx0_outpoint, initial_nValue, n, fee=fee))\n             assert_equal(len(tree_txs), n)\n \n@@ -285,7 +281,7 @@ def branch(prevout, initial_value, max_txs, tree_width=5, fee=0.0001*COIN, _tota\n \n     def test_replacement_feeperkb(self):\n         \"\"\"Replacement requires fee-per-KB to be higher\"\"\"\n-        tx0_outpoint = make_utxo(self.nodes[0], int(1.1*COIN))\n+        tx0_outpoint = self.make_utxo(int(1.1 * COIN))\n \n         tx1a = CTransaction()\n         tx1a.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n@@ -305,8 +301,8 @@ def test_replacement_feeperkb(self):\n \n     def test_spends_of_conflicting_outputs(self):\n         \"\"\"Replacements that spend conflicting tx outputs are rejected\"\"\"\n-        utxo1 = make_utxo(self.nodes[0], int(1.2*COIN))\n-        utxo2 = make_utxo(self.nodes[0], 3*COIN)\n+        utxo1 = self.make_utxo(int(1.2 * COIN))\n+        utxo2 = self.make_utxo(3 * COIN)\n \n         tx1a = CTransaction()\n         tx1a.vin = [CTxIn(utxo1, nSequence=0)]\n@@ -345,8 +341,8 @@ def test_spends_of_conflicting_outputs(self):\n \n     def test_new_unconfirmed_inputs(self):\n         \"\"\"Replacements that add new unconfirmed inputs are rejected\"\"\"\n-        confirmed_utxo = make_utxo(self.nodes[0], int(1.1*COIN))\n-        unconfirmed_utxo = make_utxo(self.nodes[0], int(0.1*COIN), False)\n+        confirmed_utxo = self.make_utxo(int(1.1 * COIN))\n+        unconfirmed_utxo = self.make_utxo(int(0.1 * COIN), False)\n \n         tx1 = CTransaction()\n         tx1.vin = [CTxIn(confirmed_utxo)]\n@@ -369,7 +365,7 @@ def test_too_many_replacements(self):\n \n         # Start by creating a single transaction with many outputs\n         initial_nValue = 10*COIN\n-        utxo = make_utxo(self.nodes[0], initial_nValue)\n+        utxo = self.make_utxo(initial_nValue)\n         fee = int(0.0001*COIN)\n         split_value = int((initial_nValue-fee)/(MAX_REPLACEMENT_LIMIT+1))\n \n@@ -417,7 +413,7 @@ def test_too_many_replacements(self):\n \n     def test_opt_in(self):\n         \"\"\"Replacing should only work if orig tx opted in\"\"\"\n-        tx0_outpoint = make_utxo(self.nodes[0], int(1.1*COIN))\n+        tx0_outpoint = self.make_utxo(int(1.1 * COIN))\n \n         # Create a non-opting in transaction\n         tx1a = CTransaction()\n@@ -438,7 +434,7 @@ def test_opt_in(self):\n         # This will raise an exception\n         assert_raises_rpc_error(-26, \"txn-mempool-conflict\", self.nodes[0].sendrawtransaction, tx1b_hex, 0)\n \n-        tx1_outpoint = make_utxo(self.nodes[0], int(1.1*COIN))\n+        tx1_outpoint = self.make_utxo(int(1.1 * COIN))\n \n         # Create a different non-opting in transaction\n         tx2a = CTransaction()\n@@ -466,7 +462,7 @@ def test_opt_in(self):\n         tx3a = CTransaction()\n         tx3a.vin = [CTxIn(COutPoint(tx1a_txid, 0), nSequence=0xffffffff),\n                     CTxIn(COutPoint(tx2a_txid, 0), nSequence=0xfffffffd)]\n-        tx3a.vout = [CTxOut(int(0.9*COIN), CScript([b'c'])), CTxOut(int(0.9*COIN), CScript([b'd']))]\n+        tx3a.vout = [CTxOut(int(0.9 * COIN), CScript([b'c'])), CTxOut(int(0.9 * COIN), CScript([b'd']))]\n         tx3a_hex = txToHex(tx3a)\n \n         tx3a_txid = self.nodes[0].sendrawtransaction(tx3a_hex, 0)\n@@ -494,7 +490,7 @@ def test_prioritised_transactions(self):\n         # correctly used by replacement logic\n \n         # 1. Check that feeperkb uses modified fees\n-        tx0_outpoint = make_utxo(self.nodes[0], int(1.1*COIN))\n+        tx0_outpoint = self.make_utxo(int(1.1 * COIN))\n \n         tx1a = CTransaction()\n         tx1a.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n@@ -520,7 +516,7 @@ def test_prioritised_transactions(self):\n         assert tx1b_txid in self.nodes[0].getrawmempool()\n \n         # 2. Check that absolute fee checks use modified fee.\n-        tx1_outpoint = make_utxo(self.nodes[0], int(1.1*COIN))\n+        tx1_outpoint = self.make_utxo(int(1.1 * COIN))\n \n         tx2a = CTransaction()\n         tx2a.vin = [CTxIn(tx1_outpoint, nSequence=0)]"
      }
    ]
  },
  {
    "sha": "fa31764911324c65ca3a9b44de4bd26e1a5a3083",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTMxNzY0OTExMzI0YzY1Y2EzYTliNDRkZTRiZDI2ZTFhNWEzMDgz",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-06-21T12:20:45Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-07-17T12:48:47Z"
      },
      "message": "policy: Add experimental -mempoolreplacement=full (off by default)",
      "tree": {
        "sha": "ca3e7aef8c4219a9c912b27132f116b559013bbb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ca3e7aef8c4219a9c912b27132f116b559013bbb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa31764911324c65ca3a9b44de4bd26e1a5a3083",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUijTwv/WUi7SNM0r+xifT5rVO8Ie46/Yxw/tRRo7BEY9lw9GyF/AFdKHwERw39u\n3F7nTaH8S0ZYu1jQ59NgfhwTt2RuJKilAiBSibuBfz8CqtytkEKUtrzrkTOHIiwb\nZ24d/BAORj7f9YWqdpJkefGelsvGPTdLcQv4blPpen7i3pupu5nWwoLx6Ol63RaZ\n776WdP55CJoN5M2N5cc1vbkGexyrmD4hXnmKoSDBSpIfIkPxdvF4p+z1EhHRiDXG\ndxUUWqTO8MahlG+x64/Bl3sdkfRfNeSJEEMyZad+AHYfXHEDdpRzYIslZzXF1wCt\nKMzNeFusCCjRpXaExQYR9xkK2vLnd95kjPp5Zwdz2kkbN6h2jEpgMsG4bczqHHIU\nNvFo41SYiWEKUY2f7rqcbaEODRjZk4EA4cvCgNov9DQx7121kjGZOEQNUYAuhbs4\nmtN9bEzYmPYXrK77G3UpWghca/MgJP6x8w9RnnDYmiHjAmhaXjTeo+E00LQxxN16\no5dw+Z3v\n=P34E\n-----END PGP SIGNATURE-----",
        "payload": "tree ca3e7aef8c4219a9c912b27132f116b559013bbb\nparent fa96efffea6f83ca8b66a337bb0c07dd6b951a8d\nauthor MarcoFalke <falke.marco@gmail.com> 1561119645 -0400\ncommitter MarcoFalke <falke.marco@gmail.com> 1563367727 -0400\n\npolicy: Add experimental -mempoolreplacement=full (off by default)\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa31764911324c65ca3a9b44de4bd26e1a5a3083",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa31764911324c65ca3a9b44de4bd26e1a5a3083",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa31764911324c65ca3a9b44de4bd26e1a5a3083/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fa96efffea6f83ca8b66a337bb0c07dd6b951a8d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa96efffea6f83ca8b66a337bb0c07dd6b951a8d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fa96efffea6f83ca8b66a337bb0c07dd6b951a8d"
      }
    ],
    "stats": {
      "total": 209,
      "additions": 137,
      "deletions": 72
    },
    "files": [
      {
        "sha": "1124b554b9e599996125d9285722fda911d4ac52",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa31764911324c65ca3a9b44de4bd26e1a5a3083/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa31764911324c65ca3a9b44de4bd26e1a5a3083/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=fa31764911324c65ca3a9b44de4bd26e1a5a3083",
        "patch": "@@ -527,6 +527,7 @@ void SetupServerArgs()\n     gArgs.AddArg(\"-bytespersigop\", strprintf(\"Equivalent bytes per sigop in transactions for relay and mining (default: %u)\", DEFAULT_BYTES_PER_SIGOP), false, OptionsCategory::NODE_RELAY);\n     gArgs.AddArg(\"-datacarrier\", strprintf(\"Relay and mine data carrier transactions (default: %u)\", DEFAULT_ACCEPT_DATACARRIER), false, OptionsCategory::NODE_RELAY);\n     gArgs.AddArg(\"-datacarriersize\", strprintf(\"Maximum size of data in data carrier transactions we relay and mine (default: %u)\", MAX_OP_RETURN_RELAY), false, OptionsCategory::NODE_RELAY);\n+    gArgs.AddArg(\"-mempoolreplacement=<mode>\", \"A comma separated list of transaction replacement modes for the memory pool. Recognized modes are: 'full' (experimental). Unrecognized modes are ignored. (default: empty list)\", false, OptionsCategory::NODE_RELAY);\n     gArgs.AddArg(\"-minrelaytxfee=<amt>\", strprintf(\"Fees (in %s/kB) smaller than this are considered zero fee for relaying, mining and transaction creation (default: %s)\",\n         CURRENCY_UNIT, FormatMoney(DEFAULT_MIN_RELAY_TX_FEE)), false, OptionsCategory::NODE_RELAY);\n     gArgs.AddArg(\"-whitelistforcerelay\", strprintf(\"Force relay of transactions from whitelisted peers even if the transactions were already in the mempool or violate local relay policy (default: %d)\", DEFAULT_WHITELISTFORCERELAY), false, OptionsCategory::NODE_RELAY);\n@@ -1175,6 +1176,16 @@ bool AppInitParameterInteraction()\n \n     nMaxTipAge = gArgs.GetArg(\"-maxtipage\", DEFAULT_MAX_TIP_AGE);\n \n+    if (gArgs.IsArgSet(\"-mempoolreplacement\")) {\n+        std::string replacement_mode_list = gArgs.GetArg(\"-mempoolreplacement\", \"\"); // default is impossible\n+        std::vector<std::string> replacement_modes;\n+        boost::split(replacement_modes, replacement_mode_list, boost::is_any_of(\",\"));\n+        g_enable_full_rbf = (std::find(replacement_modes.begin(), replacement_modes.end(), \"full\") != replacement_modes.end());\n+    }\n+    if (g_enable_full_rbf) {\n+        nLocalServices = ServiceFlags(nLocalServices | NODE_FULL_RBF);\n+    }\n+\n     return true;\n }\n "
      },
      {
        "sha": "1596c9cdf85985de153d3ac9aa9238f645f707bc",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 5,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa31764911324c65ca3a9b44de4bd26e1a5a3083/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa31764911324c65ca3a9b44de4bd26e1a5a3083/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=fa31764911324c65ca3a9b44de4bd26e1a5a3083",
        "patch": "@@ -13,6 +13,7 @@\n #endif\n \n static std::atomic<bool> g_initial_block_download_completed(false);\n+extern bool g_enable_full_rbf;\n \n namespace NetMsgType {\n const char *VERSION=\"version\";\n@@ -128,12 +129,18 @@ bool CMessageHeader::IsValid(const MessageStartChars& pchMessageStartIn) const\n     return true;\n }\n \n-\n-ServiceFlags GetDesirableServiceFlags(ServiceFlags services) {\n-    if ((services & NODE_NETWORK_LIMITED) && g_initial_block_download_completed) {\n-        return ServiceFlags(NODE_NETWORK_LIMITED | NODE_WITNESS);\n+ServiceFlags GetDesirableServiceFlags(ServiceFlags services_them)\n+{\n+    ServiceFlags desired{NODE_WITNESS}; // Always desire NODE_WITNESS\n+    if (g_enable_full_rbf) {\n+        desired = ServiceFlags(desired | NODE_FULL_RBF);\n+    }\n+    if ((services_them & NODE_NETWORK_LIMITED) && g_initial_block_download_completed) {\n+        desired = ServiceFlags(desired | NODE_NETWORK_LIMITED); // NODE_NETWORK_LIMITED provided by them is sufficient\n+    } else {\n+        desired = ServiceFlags(desired | NODE_NETWORK);\n     }\n-    return ServiceFlags(NODE_NETWORK | NODE_WITNESS);\n+    return desired;\n }\n \n void SetServiceFlagsIBDCache(bool state) {"
      },
      {
        "sha": "3ab05f97b3ef83faeafbecb5d0f5c313b67f9051",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa31764911324c65ca3a9b44de4bd26e1a5a3083/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa31764911324c65ca3a9b44de4bd26e1a5a3083/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=fa31764911324c65ca3a9b44de4bd26e1a5a3083",
        "patch": "@@ -273,6 +273,8 @@ enum ServiceFlags : uint64_t {\n     // collisions and other cases where nodes may be advertising a service they\n     // do not actually support. Other service bits should be allocated via the\n     // BIP process.\n+\n+    NODE_FULL_RBF = (1 << 26),\n };\n \n /**\n@@ -299,7 +301,7 @@ enum ServiceFlags : uint64_t {\n  * If the NODE_NONE return value is changed, contrib/seeds/makeseeds.py\n  * should be updated appropriately to filter for the same nodes.\n  */\n-ServiceFlags GetDesirableServiceFlags(ServiceFlags services);\n+ServiceFlags GetDesirableServiceFlags(ServiceFlags services_them);\n \n /** Set the current IBD status in order to figure out the desirable service flags */\n void SetServiceFlagsIBDCache(bool status);"
      },
      {
        "sha": "bae4bb7598f74b35fd409329f5983e0da5ee3520",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa31764911324c65ca3a9b44de4bd26e1a5a3083/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa31764911324c65ca3a9b44de4bd26e1a5a3083/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=fa31764911324c65ca3a9b44de4bd26e1a5a3083",
        "patch": "@@ -114,6 +114,7 @@ bool fCheckpointsEnabled = DEFAULT_CHECKPOINTS_ENABLED;\n size_t nCoinCacheUsage = 5000 * 300;\n uint64_t nPruneTarget = 0;\n int64_t nMaxTipAge = DEFAULT_MAX_TIP_AGE;\n+bool g_enable_full_rbf{false};\n \n uint256 hashAssumeValid;\n arith_uint256 nMinimumChainWork;\n@@ -478,6 +479,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         if (ptxConflicting) {\n             if (!setConflicts.count(ptxConflicting->GetHash()))\n             {\n+                if (!g_enable_full_rbf) {\n                 // Allow opt-out of transaction replacement by setting\n                 // nSequence > MAX_BIP125_RBF_SEQUENCE (SEQUENCE_FINAL-2) on all inputs.\n                 //\n@@ -502,6 +504,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 if (fReplacementOptOut) {\n                     return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_DUPLICATE, \"txn-mempool-conflict\");\n                 }\n+                } // g_enable_full_rbf\n \n                 setConflicts.insert(ptxConflicting->GetHash());\n             }"
      },
      {
        "sha": "986b33f1ec43028c74ecdd328a1bc3a1c62ed59c",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa31764911324c65ca3a9b44de4bd26e1a5a3083/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa31764911324c65ca3a9b44de4bd26e1a5a3083/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=fa31764911324c65ca3a9b44de4bd26e1a5a3083",
        "patch": "@@ -156,6 +156,8 @@ extern bool fCheckpointsEnabled;\n extern size_t nCoinCacheUsage;\n /** A fee rate smaller than this is considered zero fee (for relaying, mining and transaction creation) */\n extern CFeeRate minRelayTxFee;\n+/** Experimental support for full rbf (off by default, can be enabled via -mempoolreplacement=full) */\n+extern bool g_enable_full_rbf;\n /** If the tip is older than this (in seconds), the node is considered to be in initial block download. */\n extern int64_t nMaxTipAge;\n "
      },
      {
        "sha": "bade1121055a6a84e45d664e1cfe536094e35b44",
        "filename": "test/functional/feature_rbf.py",
        "status": "modified",
        "additions": 106,
        "deletions": 66,
        "changes": 172,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa31764911324c65ca3a9b44de4bd26e1a5a3083/test/functional/feature_rbf.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa31764911324c65ca3a9b44de4bd26e1a5a3083/test/functional/feature_rbf.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_rbf.py?ref=fa31764911324c65ca3a9b44de4bd26e1a5a3083",
        "patch": "@@ -64,17 +64,16 @@ def make_utxo_util(node, amount, confirmed=True, scriptPubKey=CScript([1])):\n \n class ReplaceByFeeTest(BitcoinTestFramework):\n     def set_test_params(self):\n-        self.num_nodes = 1\n-        self.extra_args = [\n-            [\n+        self.num_nodes = 2\n+        self.extra_args = [[\n                 \"-acceptnonstdtxn=1\",\n                 \"-maxorphantx=1000\",\n                 \"-limitancestorcount=50\",\n                 \"-limitancestorsize=101\",\n                 \"-limitdescendantcount=200\",\n                 \"-limitdescendantsize=101\",\n-            ],\n-        ]\n+                \"-mempoolreplacement={}\".format(r),\n+        ] for r in ['0', 'full']]\n \n     def skip_test_if_missing_module(self):\n         self.skip_if_no_wallet()\n@@ -89,6 +88,8 @@ def make_utxo(self, *args):\n     def run_test(self):\n         self.make_utxo(1 * COIN)\n \n+        self.RBF_NODES = range(0, 2)\n+\n         self.log.info(\"Running test simple doublespend...\")\n         self.test_simple_doublespend()\n \n@@ -129,7 +130,8 @@ def test_simple_doublespend(self):\n         tx1a.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n         tx1a.vout = [CTxOut(1 * COIN, CScript([b'a' * 35]))]\n         tx1a_hex = txToHex(tx1a)\n-        tx1a_txid = self.nodes[0].sendrawtransaction(tx1a_hex, 0)\n+        for i in self.RBF_NODES:\n+            tx1a_txid = self.nodes[i].sendrawtransaction(tx1a_hex, 0)\n \n         self.sync_all()\n \n@@ -140,22 +142,24 @@ def test_simple_doublespend(self):\n         tx1b_hex = txToHex(tx1b)\n \n         # This will raise an exception due to insufficient fee\n-        assert_raises_rpc_error(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, tx1b_hex, 0)\n+        for i in self.RBF_NODES:\n+            assert_raises_rpc_error(-26, \"insufficient fee\", self.nodes[i].sendrawtransaction, tx1b_hex, 0)\n \n         # Extra 0.1 BTC fee\n         tx1b = CTransaction()\n         tx1b.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n         tx1b.vout = [CTxOut(int(0.9 * COIN), CScript([b'b' * 35]))]\n         tx1b_hex = txToHex(tx1b)\n         # Works when enabled\n-        tx1b_txid = self.nodes[0].sendrawtransaction(tx1b_hex, 0)\n+        for i in self.RBF_NODES:\n+            tx1b_txid = self.nodes[i].sendrawtransaction(tx1b_hex, 0)\n \n-        mempool = self.nodes[0].getrawmempool()\n+            mempool = self.nodes[i].getrawmempool()\n \n-        assert tx1a_txid not in mempool\n-        assert tx1b_txid in mempool\n+            assert tx1a_txid not in mempool\n+            assert tx1b_txid in mempool\n \n-        assert_equal(tx1b_hex, self.nodes[0].getrawtransaction(tx1b_txid))\n+            assert_equal(tx1b_hex, self.nodes[i].getrawtransaction(tx1b_txid))\n \n     def test_doublespend_chain(self):\n         \"\"\"Doublespend of a long chain\"\"\"\n@@ -172,7 +176,8 @@ def test_doublespend_chain(self):\n             tx.vin = [CTxIn(prevout, nSequence=0)]\n             tx.vout = [CTxOut(remaining_value, CScript([1, OP_DROP] * 15 + [1]))]\n             tx_hex = txToHex(tx)\n-            txid = self.nodes[0].sendrawtransaction(tx_hex, 0)\n+            for i in self.RBF_NODES:\n+                txid = self.nodes[i].sendrawtransaction(tx_hex, 0)\n             chain_txids.append(txid)\n             prevout = COutPoint(int(txid, 16), 0)\n \n@@ -184,18 +189,20 @@ def test_doublespend_chain(self):\n         dbl_tx_hex = txToHex(dbl_tx)\n \n         # This will raise an exception due to insufficient fee\n-        assert_raises_rpc_error(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, dbl_tx_hex, 0)\n+        for i in self.RBF_NODES:\n+            assert_raises_rpc_error(-26, \"insufficient fee\", self.nodes[i].sendrawtransaction, dbl_tx_hex, 0)\n \n         # Accepted with sufficient fee\n         dbl_tx = CTransaction()\n         dbl_tx.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n         dbl_tx.vout = [CTxOut(1 * COIN, CScript([1] * 35))]\n         dbl_tx_hex = txToHex(dbl_tx)\n-        self.nodes[0].sendrawtransaction(dbl_tx_hex, 0)\n+        for i in self.RBF_NODES:\n+            self.nodes[i].sendrawtransaction(dbl_tx_hex, 0)\n \n-        mempool = self.nodes[0].getrawmempool()\n-        for doublespent_txid in chain_txids:\n-            assert doublespent_txid not in mempool\n+            mempool = self.nodes[i].getrawmempool()\n+            for doublespent_txid in chain_txids:\n+                assert doublespent_txid not in mempool\n \n     def test_doublespend_tree(self):\n         \"\"\"Doublespend of a big tree of transactions\"\"\"\n@@ -221,7 +228,8 @@ def branch(prevout, initial_value, max_txs, tree_width=5, fee=0.0001*COIN, _tota\n             tx_hex = txToHex(tx)\n \n             assert len(tx.serialize()) < 100000\n-            txid = self.nodes[0].sendrawtransaction(tx_hex, 0)\n+            for i in self.RBF_NODES:\n+                txid = self.nodes[i].sendrawtransaction(tx_hex, 0)\n             yield tx\n             _total_txs[0] += 1\n \n@@ -245,20 +253,22 @@ def branch(prevout, initial_value, max_txs, tree_width=5, fee=0.0001*COIN, _tota\n         dbl_tx.vout = [CTxOut(initial_nValue - fee * n, CScript([1] * 35))]\n         dbl_tx_hex = txToHex(dbl_tx)\n         # This will raise an exception due to insufficient fee\n-        assert_raises_rpc_error(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, dbl_tx_hex, 0)\n+        for i in self.RBF_NODES:\n+            assert_raises_rpc_error(-26, \"insufficient fee\", self.nodes[i].sendrawtransaction, dbl_tx_hex, 0)\n \n         # 1 BTC fee is enough\n         dbl_tx = CTransaction()\n         dbl_tx.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n         dbl_tx.vout = [CTxOut(initial_nValue - fee * n - 1 * COIN, CScript([1] * 35))]\n         dbl_tx_hex = txToHex(dbl_tx)\n-        self.nodes[0].sendrawtransaction(dbl_tx_hex, 0)\n+        for i in self.RBF_NODES:\n+            self.nodes[i].sendrawtransaction(dbl_tx_hex, 0)\n \n-        mempool = self.nodes[0].getrawmempool()\n+            mempool = self.nodes[i].getrawmempool()\n \n-        for tx in tree_txs:\n-            tx.rehash()\n-            assert tx.hash not in mempool\n+            for tx in tree_txs:\n+                tx.rehash()\n+                assert tx.hash not in mempool\n \n         # Try again, but with more total transactions than the \"max txs\n         # double-spent at once\" anti-DoS limit.\n@@ -273,11 +283,13 @@ def branch(prevout, initial_value, max_txs, tree_width=5, fee=0.0001*COIN, _tota\n             dbl_tx.vout = [CTxOut(initial_nValue - 2 * fee * n, CScript([1] * 35))]\n             dbl_tx_hex = txToHex(dbl_tx)\n             # This will raise an exception\n-            assert_raises_rpc_error(-26, \"too many potential replacements\", self.nodes[0].sendrawtransaction, dbl_tx_hex, 0)\n+            for i in self.RBF_NODES:\n+                assert_raises_rpc_error(-26, \"too many potential replacements\", self.nodes[i].sendrawtransaction,\n+                                        dbl_tx_hex, 0)\n \n-            for tx in tree_txs:\n-                tx.rehash()\n-                self.nodes[0].getrawtransaction(tx.hash)\n+                for tx in tree_txs:\n+                    tx.rehash()\n+                    self.nodes[i].getrawtransaction(tx.hash)\n \n     def test_replacement_feeperkb(self):\n         \"\"\"Replacement requires fee-per-KB to be higher\"\"\"\n@@ -287,7 +299,8 @@ def test_replacement_feeperkb(self):\n         tx1a.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n         tx1a.vout = [CTxOut(1 * COIN, CScript([b'a' * 35]))]\n         tx1a_hex = txToHex(tx1a)\n-        self.nodes[0].sendrawtransaction(tx1a_hex, 0)\n+        for i in self.RBF_NODES:\n+            self.nodes[i].sendrawtransaction(tx1a_hex, 0)\n \n         # Higher fee, but the fee per KB is much lower, so the replacement is\n         # rejected.\n@@ -297,7 +310,8 @@ def test_replacement_feeperkb(self):\n         tx1b_hex = txToHex(tx1b)\n \n         # This will raise an exception due to insufficient fee\n-        assert_raises_rpc_error(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, tx1b_hex, 0)\n+        for i in self.RBF_NODES:\n+            assert_raises_rpc_error(-26, \"insufficient fee\", self.nodes[i].sendrawtransaction, tx1b_hex, 0)\n \n     def test_spends_of_conflicting_outputs(self):\n         \"\"\"Replacements that spend conflicting tx outputs are rejected\"\"\"\n@@ -308,7 +322,8 @@ def test_spends_of_conflicting_outputs(self):\n         tx1a.vin = [CTxIn(utxo1, nSequence=0)]\n         tx1a.vout = [CTxOut(int(1.1 * COIN), CScript([b'a' * 35]))]\n         tx1a_hex = txToHex(tx1a)\n-        tx1a_txid = self.nodes[0].sendrawtransaction(tx1a_hex, 0)\n+        for i in self.RBF_NODES:\n+            tx1a_txid = self.nodes[i].sendrawtransaction(tx1a_hex, 0)\n \n         tx1a_txid = int(tx1a_txid, 16)\n \n@@ -320,14 +335,16 @@ def test_spends_of_conflicting_outputs(self):\n         tx2_hex = txToHex(tx2)\n \n         # This will raise an exception\n-        assert_raises_rpc_error(-26, \"bad-txns-spends-conflicting-tx\", self.nodes[0].sendrawtransaction, tx2_hex, 0)\n+        for i in self.RBF_NODES:\n+            assert_raises_rpc_error(-26, \"bad-txns-spends-conflicting-tx\", self.nodes[i].sendrawtransaction, tx2_hex, 0)\n \n         # Spend tx1a's output to test the indirect case.\n         tx1b = CTransaction()\n         tx1b.vin = [CTxIn(COutPoint(tx1a_txid, 0), nSequence=0)]\n         tx1b.vout = [CTxOut(1 * COIN, CScript([b'a' * 35]))]\n         tx1b_hex = txToHex(tx1b)\n-        tx1b_txid = self.nodes[0].sendrawtransaction(tx1b_hex, 0)\n+        for i in self.RBF_NODES:\n+            tx1b_txid = self.nodes[i].sendrawtransaction(tx1b_hex, 0)\n         tx1b_txid = int(tx1b_txid, 16)\n \n         tx2 = CTransaction()\n@@ -337,7 +354,8 @@ def test_spends_of_conflicting_outputs(self):\n         tx2_hex = txToHex(tx2)\n \n         # This will raise an exception\n-        assert_raises_rpc_error(-26, \"bad-txns-spends-conflicting-tx\", self.nodes[0].sendrawtransaction, tx2_hex, 0)\n+        for i in self.RBF_NODES:\n+            assert_raises_rpc_error(-26, \"bad-txns-spends-conflicting-tx\", self.nodes[i].sendrawtransaction, tx2_hex, 0)\n \n     def test_new_unconfirmed_inputs(self):\n         \"\"\"Replacements that add new unconfirmed inputs are rejected\"\"\"\n@@ -348,15 +366,17 @@ def test_new_unconfirmed_inputs(self):\n         tx1.vin = [CTxIn(confirmed_utxo)]\n         tx1.vout = [CTxOut(1 * COIN, CScript([b'a' * 35]))]\n         tx1_hex = txToHex(tx1)\n-        self.nodes[0].sendrawtransaction(tx1_hex, 0)\n+        for i in self.RBF_NODES:\n+            self.nodes[i].sendrawtransaction(tx1_hex, 0)\n \n         tx2 = CTransaction()\n         tx2.vin = [CTxIn(confirmed_utxo), CTxIn(unconfirmed_utxo)]\n         tx2.vout = tx1.vout\n         tx2_hex = txToHex(tx2)\n \n         # This will raise an exception\n-        assert_raises_rpc_error(-26, \"replacement-adds-unconfirmed\", self.nodes[0].sendrawtransaction, tx2_hex, 0)\n+        for i in self.RBF_NODES:\n+            assert_raises_rpc_error(-26, \"replacement-adds-unconfirmed\", self.nodes[i].sendrawtransaction, tx2_hex, 0)\n \n     def test_too_many_replacements(self):\n         \"\"\"Replacements that evict too many transactions are rejected\"\"\"\n@@ -378,7 +398,8 @@ def test_too_many_replacements(self):\n         splitting_tx.vout = outputs\n         splitting_tx_hex = txToHex(splitting_tx)\n \n-        txid = self.nodes[0].sendrawtransaction(splitting_tx_hex, 0)\n+        for i in self.RBF_NODES:\n+            txid = self.nodes[i].sendrawtransaction(splitting_tx_hex, 0)\n         txid = int(txid, 16)\n \n         # Now spend each of those outputs individually\n@@ -387,7 +408,8 @@ def test_too_many_replacements(self):\n             tx_i.vin = [CTxIn(COutPoint(txid, i), nSequence=0)]\n             tx_i.vout = [CTxOut(split_value - fee, CScript([b'a' * 35]))]\n             tx_i_hex = txToHex(tx_i)\n-            self.nodes[0].sendrawtransaction(tx_i_hex, 0)\n+            for i in self.RBF_NODES:\n+                self.nodes[i].sendrawtransaction(tx_i_hex, 0)\n \n         # Now create doublespend of the whole lot; should fail.\n         # Need a big enough fee to cover all spending transactions and have\n@@ -402,14 +424,17 @@ def test_too_many_replacements(self):\n         double_tx_hex = txToHex(double_tx)\n \n         # This will raise an exception\n-        assert_raises_rpc_error(-26, \"too many potential replacements\", self.nodes[0].sendrawtransaction, double_tx_hex, 0)\n+        for i in self.RBF_NODES:\n+            assert_raises_rpc_error(-26, \"too many potential replacements\", self.nodes[i].sendrawtransaction,\n+                                    double_tx_hex, 0)\n \n         # If we remove an input, it should pass\n         double_tx = CTransaction()\n         double_tx.vin = inputs[0:-1]\n         double_tx.vout = [CTxOut(double_spend_value, CScript([b'a']))]\n         double_tx_hex = txToHex(double_tx)\n-        self.nodes[0].sendrawtransaction(double_tx_hex, 0)\n+        for i in self.RBF_NODES:\n+            self.nodes[i].sendrawtransaction(double_tx_hex, 0)\n \n     def test_opt_in(self):\n         \"\"\"Replacing should only work if orig tx opted in\"\"\"\n@@ -420,10 +445,11 @@ def test_opt_in(self):\n         tx1a.vin = [CTxIn(tx0_outpoint, nSequence=0xffffffff)]\n         tx1a.vout = [CTxOut(1 * COIN, CScript([b'a' * 35]))]\n         tx1a_hex = txToHex(tx1a)\n-        tx1a_txid = self.nodes[0].sendrawtransaction(tx1a_hex, 0)\n+        for i in self.RBF_NODES:\n+            tx1a_txid = self.nodes[i].sendrawtransaction(tx1a_hex, 0)\n \n-        # This transaction isn't shown as replaceable\n-        assert_equal(self.nodes[0].getmempoolentry(tx1a_txid)['bip125-replaceable'], False)\n+            # This transaction isn't shown as replaceable\n+            assert_equal(self.nodes[i].getmempoolentry(tx1a_txid)['bip125-replaceable'], False)\n \n         # Shouldn't be able to double-spend\n         tx1b = CTransaction()\n@@ -433,6 +459,8 @@ def test_opt_in(self):\n \n         # This will raise an exception\n         assert_raises_rpc_error(-26, \"txn-mempool-conflict\", self.nodes[0].sendrawtransaction, tx1b_hex, 0)\n+        # Other node will accept it\n+        self.nodes[1].sendrawtransaction(tx1b_hex, 0)\n \n         tx1_outpoint = self.make_utxo(int(1.1 * COIN))\n \n@@ -441,7 +469,8 @@ def test_opt_in(self):\n         tx2a.vin = [CTxIn(tx1_outpoint, nSequence=0xfffffffe)]\n         tx2a.vout = [CTxOut(1 * COIN, CScript([b'a' * 35]))]\n         tx2a_hex = txToHex(tx2a)\n-        tx2a_txid = self.nodes[0].sendrawtransaction(tx2a_hex, 0)\n+        for i in self.RBF_NODES:\n+            tx2a_txid = self.nodes[i].sendrawtransaction(tx2a_hex, 0)\n \n         # Still shouldn't be able to double-spend\n         tx2b = CTransaction()\n@@ -451,6 +480,11 @@ def test_opt_in(self):\n \n         # This will raise an exception\n         assert_raises_rpc_error(-26, \"txn-mempool-conflict\", self.nodes[0].sendrawtransaction, tx2b_hex, 0)\n+        # Other node will accept it\n+        self.nodes[1].sendrawtransaction(tx2b_hex, 0)\n+        # Sync both mempools to the same state\n+        self.nodes[1].prioritisetransaction(txid=tx2a_txid, fee_delta=int(0.2 * COIN))\n+        self.nodes[1].sendrawtransaction(tx2a_hex, 0)\n \n         # Now create a new transaction that spends from tx1a and tx2a\n         # opt-in on one of the inputs\n@@ -465,10 +499,11 @@ def test_opt_in(self):\n         tx3a.vout = [CTxOut(int(0.9 * COIN), CScript([b'c'])), CTxOut(int(0.9 * COIN), CScript([b'd']))]\n         tx3a_hex = txToHex(tx3a)\n \n-        tx3a_txid = self.nodes[0].sendrawtransaction(tx3a_hex, 0)\n+        for i in self.RBF_NODES:\n+            tx3a_txid = self.nodes[i].sendrawtransaction(tx3a_hex, 0)\n \n-        # This transaction is shown as replaceable\n-        assert_equal(self.nodes[0].getmempoolentry(tx3a_txid)['bip125-replaceable'], True)\n+            # This transaction is shown as replaceable\n+            assert_equal(self.nodes[i].getmempoolentry(tx3a_txid)['bip125-replaceable'], True)\n \n         tx3b = CTransaction()\n         tx3b.vin = [CTxIn(COutPoint(tx1a_txid, 0), nSequence=0)]\n@@ -480,10 +515,11 @@ def test_opt_in(self):\n         tx3c.vout = [CTxOut(int(0.5 * COIN), CScript([b'f' * 35]))]\n         tx3c_hex = txToHex(tx3c)\n \n-        self.nodes[0].sendrawtransaction(tx3b_hex, 0)\n-        # If tx3b was accepted, tx3c won't look like a replacement,\n-        # but make sure it is accepted anyway\n-        self.nodes[0].sendrawtransaction(tx3c_hex, 0)\n+        for i in self.RBF_NODES:\n+            self.nodes[i].sendrawtransaction(tx3b_hex, 0)\n+            # If tx3b was accepted, tx3c won't look like a replacement,\n+            # but make sure it is accepted anyway\n+            self.nodes[i].sendrawtransaction(tx3c_hex, 0)\n \n     def test_prioritised_transactions(self):\n         # Ensure that fee deltas used via prioritisetransaction are\n@@ -496,7 +532,8 @@ def test_prioritised_transactions(self):\n         tx1a.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n         tx1a.vout = [CTxOut(1 * COIN, CScript([b'a' * 35]))]\n         tx1a_hex = txToHex(tx1a)\n-        tx1a_txid = self.nodes[0].sendrawtransaction(tx1a_hex, 0)\n+        for i in self.RBF_NODES:\n+            tx1a_txid = self.nodes[i].sendrawtransaction(tx1a_hex, 0)\n \n         # Higher fee, but the actual fee per KB is much lower.\n         tx1b = CTransaction()\n@@ -505,15 +542,16 @@ def test_prioritised_transactions(self):\n         tx1b_hex = txToHex(tx1b)\n \n         # Verify tx1b cannot replace tx1a.\n-        assert_raises_rpc_error(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, tx1b_hex, 0)\n+        for i in self.RBF_NODES:\n+            assert_raises_rpc_error(-26, \"insufficient fee\", self.nodes[i].sendrawtransaction, tx1b_hex, 0)\n \n-        # Use prioritisetransaction to set tx1a's fee to 0.\n-        self.nodes[0].prioritisetransaction(txid=tx1a_txid, fee_delta=int(-0.1*COIN))\n+            # Use prioritisetransaction to set tx1a's fee to 0.\n+            self.nodes[i].prioritisetransaction(txid=tx1a_txid, fee_delta=int(-0.1 * COIN))\n \n-        # Now tx1b should be able to replace tx1a\n-        tx1b_txid = self.nodes[0].sendrawtransaction(tx1b_hex, 0)\n+            # Now tx1b should be able to replace tx1a\n+            tx1b_txid = self.nodes[i].sendrawtransaction(tx1b_hex, 0)\n \n-        assert tx1b_txid in self.nodes[0].getrawmempool()\n+            assert tx1b_txid in self.nodes[i].getrawmempool()\n \n         # 2. Check that absolute fee checks use modified fee.\n         tx1_outpoint = self.make_utxo(int(1.1 * COIN))\n@@ -522,7 +560,8 @@ def test_prioritised_transactions(self):\n         tx2a.vin = [CTxIn(tx1_outpoint, nSequence=0)]\n         tx2a.vout = [CTxOut(1 * COIN, CScript([b'a' * 35]))]\n         tx2a_hex = txToHex(tx2a)\n-        self.nodes[0].sendrawtransaction(tx2a_hex, 0)\n+        for i in self.RBF_NODES:\n+            self.nodes[i].sendrawtransaction(tx2a_hex, 0)\n \n         # Lower fee, but we'll prioritise it\n         tx2b = CTransaction()\n@@ -532,15 +571,16 @@ def test_prioritised_transactions(self):\n         tx2b_hex = txToHex(tx2b)\n \n         # Verify tx2b cannot replace tx2a.\n-        assert_raises_rpc_error(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, tx2b_hex, 0)\n+        for i in self.RBF_NODES:\n+            assert_raises_rpc_error(-26, \"insufficient fee\", self.nodes[i].sendrawtransaction, tx2b_hex, 0)\n \n-        # Now prioritise tx2b to have a higher modified fee\n-        self.nodes[0].prioritisetransaction(txid=tx2b.hash, fee_delta=int(0.1*COIN))\n+            # Now prioritise tx2b to have a higher modified fee\n+            self.nodes[i].prioritisetransaction(txid=tx2b.hash, fee_delta=int(0.1 * COIN))\n \n-        # tx2b should now be accepted\n-        tx2b_txid = self.nodes[0].sendrawtransaction(tx2b_hex, 0)\n+            # tx2b should now be accepted\n+            tx2b_txid = self.nodes[i].sendrawtransaction(tx2b_hex, 0)\n \n-        assert tx2b_txid in self.nodes[0].getrawmempool()\n+            assert tx2b_txid in self.nodes[i].getrawmempool()\n \n     def test_rpc(self):\n         us0 = self.nodes[0].listunspent()[0]"
      }
    ]
  }
]