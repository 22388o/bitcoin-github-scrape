[
  {
    "sha": "5ee9baec85bcc972853af954967ee6b24bdeff2c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ZWU5YmFlYzg1YmNjOTcyODUzYWY5NTQ5NjdlZTZiMjRiZGVmZjJj",
    "commit": {
      "author": {
        "name": "Philip Kaufmann",
        "email": "phil.kaufmann@t-online.de",
        "date": "2013-11-18T10:57:38Z"
      },
      "committer": {
        "name": "Philip Kaufmann",
        "email": "phil.kaufmann@t-online.de",
        "date": "2013-12-01T13:45:23Z"
      },
      "message": "implement CAutoFile via std::fstream\n\n- implement CAutoFile via std::fstream and use it in the code\n- unify log/error messages for serializing/deserializing exceptions\n- add debug and benchmark messages for writing/reading block/undo files\n- remove boost::path member from CAddrDB class\n- add new helper functions GetBlockFile() and GetUndoFile()",
      "tree": {
        "sha": "f532df39687f89c564012dbcd10d1dad6e149396",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f532df39687f89c564012dbcd10d1dad6e149396"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5ee9baec85bcc972853af954967ee6b24bdeff2c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5ee9baec85bcc972853af954967ee6b24bdeff2c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5ee9baec85bcc972853af954967ee6b24bdeff2c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5ee9baec85bcc972853af954967ee6b24bdeff2c/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "40ad6e7f35b539d06d328082b17878f18f0fc22e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/40ad6e7f35b539d06d328082b17878f18f0fc22e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/40ad6e7f35b539d06d328082b17878f18f0fc22e"
      }
    ],
    "stats": {
      "total": 370,
      "additions": 206,
      "deletions": 164
    },
    "files": [
      {
        "sha": "6fa4ee09e37d7af69ac1b9484b9094ed557540a3",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 33,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5ee9baec85bcc972853af954967ee6b24bdeff2c/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5ee9baec85bcc972853af954967ee6b24bdeff2c/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=5ee9baec85bcc972853af954967ee6b24bdeff2c",
        "patch": "@@ -436,8 +436,7 @@ bool CDB::Rewrite(const string& strFile, const char* pszSkip)\n void CDBEnv::Flush(bool fShutdown)\n {\n     int64_t nStart = GetTimeMillis();\n-    // Flush log data to the actual data file\n-    //  on all files that are not in use\n+    // Flush log data to the actual data file on all files that are not in use\n     LogPrint(\"db\", \"Flush(%s)%s\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" db not started\");\n     if (!fDbEnvInit)\n         return;\n@@ -493,82 +492,79 @@ void CDBEnv::Flush(bool fShutdown)\n // CAddrDB\n //\n \n-CAddrDB::CAddrDB()\n-{\n-    pathAddr = GetDataDir() / \"peers.dat\";\n-}\n-\n bool CAddrDB::Write(const CAddrMan& addr)\n {\n     // Generate random temporary filename\n     unsigned short randv = 0;\n     RAND_bytes((unsigned char *)&randv, sizeof(randv));\n     std::string tmpfn = strprintf(\"peers.dat.%04x\", randv);\n \n+    boost::filesystem::path pathAddr = GetDataDir() / \"peers.dat\";\n+    boost::filesystem::path pathTmp = GetDataDir() / tmpfn;\n+\n     // serialize addresses, checksum data up to that point, then append csum\n     CDataStream ssPeers(SER_DISK, CLIENT_VERSION);\n     ssPeers << FLATDATA(Params().MessageStart());\n     ssPeers << addr;\n     uint256 hash = Hash(ssPeers.begin(), ssPeers.end());\n     ssPeers << hash;\n \n-    // open temp output file, and associate with CAutoFile\n-    boost::filesystem::path pathTmp = GetDataDir() / tmpfn;\n-    FILE *file = fopen(pathTmp.string().c_str(), \"wb\");\n-    CAutoFile fileout = CAutoFile(file, SER_DISK, CLIENT_VERSION);\n-    if (!fileout)\n-        return error(\"CAddrman::Write() : open failed\");\n+    CAutoFile fileOut(SER_DISK, CLIENT_VERSION);\n+    // open temp output file\n+    if (!fileOut.open(pathTmp.string().c_str(), std::ios::binary | std::ios::out | std::ios::trunc))\n+        return error(\"CAddrDB::Write : Failed to open file %s\", pathTmp.string().c_str());\n \n     // Write and commit header, data\n     try {\n-        fileout << ssPeers;\n+        fileOut << ssPeers;\n     }\n     catch (std::exception &e) {\n-        return error(\"CAddrman::Write() : I/O error\");\n+        return error(\"%s : Serialize or I/O error - %s\", __PRETTY_FUNCTION__, e.what());\n     }\n-    FileCommit(fileout);\n-    fileout.fclose();\n+    fileOut.close();\n \n     // replace existing peers.dat, if any, with new peers.dat.XXXX\n     if (!RenameOver(pathTmp, pathAddr))\n-        return error(\"CAddrman::Write() : Rename-into-place failed\");\n+        return error(\"CAddrDB::Write : Rename-into-place failed\");\n \n     return true;\n }\n \n bool CAddrDB::Read(CAddrMan& addr)\n {\n-    // open input file, and associate with CAutoFile\n-    FILE *file = fopen(pathAddr.string().c_str(), \"rb\");\n-    CAutoFile filein = CAutoFile(file, SER_DISK, CLIENT_VERSION);\n-    if (!filein)\n-        return error(\"CAddrman::Read() : open failed\");\n+    boost::filesystem::path pathAddr = GetDataDir() / \"peers.dat\";\n+\n+    CAutoFile fileIn(SER_DISK, CLIENT_VERSION);\n+    // open input file\n+    if (!fileIn.open(pathAddr.string().c_str(), std::ios::binary | std::ios::in))\n+        return error(\"CAddrDB::Read : Failed to open file %s\", pathAddr.string().c_str());\n \n     // use file size to size memory buffer\n-    int fileSize = GetFilesize(filein);\n+    int fileSize = (int)boost::filesystem::file_size(pathAddr);\n     int dataSize = fileSize - sizeof(uint256);\n-    //Don't try to resize to a negative number if file is small\n-    if ( dataSize < 0 ) dataSize = 0;\n+    // Don't try to resize to a negative number if file is small\n+    if (dataSize < 0)\n+        dataSize = 0;\n     vector<unsigned char> vchData;\n     vchData.resize(dataSize);\n     uint256 hashIn;\n \n     // read data and checksum from file\n     try {\n-        filein.read((char *)&vchData[0], dataSize);\n-        filein >> hashIn;\n+        fileIn.read((char *)&vchData[0], dataSize);\n+        fileIn >> hashIn;\n     }\n     catch (std::exception &e) {\n-        return error(\"CAddrman::Read() 2 : I/O error or stream data corrupted\");\n+        return error(\"%s 1 : Deserialize or I/O error - %s\", __PRETTY_FUNCTION__, e.what());\n     }\n-    filein.fclose();\n+    fileIn.close();\n \n     CDataStream ssPeers(vchData, SER_DISK, CLIENT_VERSION);\n \n     // verify stored checksum matches input data\n     uint256 hashTmp = Hash(ssPeers.begin(), ssPeers.end());\n     if (hashIn != hashTmp)\n-        return error(\"CAddrman::Read() : checksum mismatch; data corrupted\");\n+        return error(\"CAddrDB::Read : checksum mismatch; data corrupted\");\n \n     unsigned char pchMsgTmp[4];\n     try {\n@@ -577,13 +573,13 @@ bool CAddrDB::Read(CAddrMan& addr)\n \n         // ... verify the network matches ours\n         if (memcmp(pchMsgTmp, Params().MessageStart(), sizeof(pchMsgTmp)))\n-            return error(\"CAddrman::Read() : invalid network magic number\");\n+            return error(\"CAddrDB::Read : invalid network magic number\");\n \n         // de-serialize address data into one CAddrMan object\n         ssPeers >> addr;\n     }\n     catch (std::exception &e) {\n-        return error(\"CAddrman::Read() : I/O error or stream data corrupted\");\n+        return error(\"%s 2 : Deserialize or I/O error - %s\", __PRETTY_FUNCTION__, e.what());\n     }\n \n     return true;"
      },
      {
        "sha": "92ce049d96b4261e17bd5a512cb0388f5b181da5",
        "filename": "src/db.h",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5ee9baec85bcc972853af954967ee6b24bdeff2c/src/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5ee9baec85bcc972853af954967ee6b24bdeff2c/src/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.h?ref=5ee9baec85bcc972853af954967ee6b24bdeff2c",
        "patch": "@@ -315,10 +315,7 @@ class CDB\n /** Access to the (IP) address database (peers.dat) */\n class CAddrDB\n {\n-private:\n-    boost::filesystem::path pathAddr;\n public:\n-    CAddrDB();\n     bool Write(const CAddrMan& addr);\n     bool Read(CAddrMan& addr);\n };"
      },
      {
        "sha": "d04a7c3cdc6aa7c68a388c8402633c50cfa33026",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 82,
        "deletions": 29,
        "changes": 111,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5ee9baec85bcc972853af954967ee6b24bdeff2c/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5ee9baec85bcc972853af954967ee6b24bdeff2c/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=5ee9baec85bcc972853af954967ee6b24bdeff2c",
        "patch": "@@ -819,18 +819,25 @@ bool GetTransaction(const uint256 &hash, CTransaction &txOut, uint256 &hashBlock\n         if (fTxIndex) {\n             CDiskTxPos postx;\n             if (pblocktree->ReadTxIndex(hash, postx)) {\n-                CAutoFile file(OpenBlockFile(postx, true), SER_DISK, CLIENT_VERSION);\n+                CAutoFile blockFileIn(SER_DISK, CLIENT_VERSION);\n+                // Open block file to read\n+                if (!blockFileIn.open(GetBlockFile(postx).c_str(), std::ios::binary | std::ios::in))\n+                    return error(\"GetTransaction : Failed to open block file %s\", GetBlockFile(postx).c_str());\n+                else\n+                    blockFileIn.seekg(postx.nPos);\n+\n+                // Read block\n                 CBlockHeader header;\n                 try {\n-                    file >> header;\n-                    fseek(file, postx.nTxOffset, SEEK_CUR);\n-                    file >> txOut;\n+                    blockFileIn >> header;\n+                    blockFileIn.seekg(postx.nTxOffset);\n+                    blockFileIn >> txOut;\n                 } catch (std::exception &e) {\n-                    return error(\"%s() : deserialize or I/O error\", __PRETTY_FUNCTION__);\n+                    return error(\"%s : Deserialize or I/O error - %s\", __PRETTY_FUNCTION__, e.what());\n                 }\n                 hashBlock = header.GetHash();\n                 if (txOut.GetHash() != hash)\n-                    return error(\"%s() : txid mismatch\", __PRETTY_FUNCTION__);\n+                    return error(\"%s : txid mismatch\", __PRETTY_FUNCTION__);\n                 return true;\n             }\n         }\n@@ -876,50 +883,61 @@ bool GetTransaction(const uint256 &hash, CTransaction &txOut, uint256 &hashBlock\n \n bool WriteBlockToDisk(CBlock& block, CDiskBlockPos& pos)\n {\n-    // Open history file to append\n-    CAutoFile fileout = CAutoFile(OpenBlockFile(pos), SER_DISK, CLIENT_VERSION);\n-    if (!fileout)\n-        return error(\"WriteBlockToDisk() : OpenBlockFile failed\");\n+    int64_t nStart = GetTimeMicros();\n+\n+    CAutoFile blockFileOut(SER_DISK, CLIENT_VERSION);\n+    // Open block file\n+    if (!blockFileOut.open(GetBlockFile(pos).c_str()))\n+        return error(\"WriteBlockToDisk : Failed to open block file %s\", GetBlockFile(pos).c_str());\n+    else\n+        blockFileOut.seekp(pos.nPos);\n \n     // Write index header\n-    unsigned int nSize = fileout.GetSerializeSize(block);\n-    fileout << FLATDATA(Params().MessageStart()) << nSize;\n+    blockFileOut << FLATDATA(Params().MessageStart()) << blockFileOut.GetSerializeSize(block);\n+\n+    // Save new block position (used in the block-index)\n+    pos.nPos = (unsigned int)blockFileOut.tellp();\n \n     // Write block\n-    long fileOutPos = ftell(fileout);\n-    if (fileOutPos < 0)\n-        return error(\"WriteBlockToDisk() : ftell failed\");\n-    pos.nPos = (unsigned int)fileOutPos;\n-    fileout << block;\n+    blockFileOut << block;\n \n-    // Flush stdio buffers and commit to disk before returning\n-    fflush(fileout);\n-    if (!IsInitialBlockDownload())\n-        FileCommit(fileout);\n+    if (fDebug)\n+        LogPrintf(\"WriteBlockToDisk : Current position in block file %s after writing block is %\"PRIu64\"\\n\", GetBlockFile(pos).c_str(), blockFileOut.tellp());\n+    if (fBenchmark)\n+        LogPrintf(\"WriteBlockToDisk : Function executed in %.2fms\\n\", (GetTimeMicros() - nStart) * 0.001);\n \n     return true;\n }\n \n bool ReadBlockFromDisk(CBlock& block, const CDiskBlockPos& pos)\n {\n+    int64_t nStart = GetTimeMicros();\n+\n     block.SetNull();\n \n-    // Open history file to read\n-    CAutoFile filein = CAutoFile(OpenBlockFile(pos, true), SER_DISK, CLIENT_VERSION);\n-    if (!filein)\n-        return error(\"ReadBlockFromDisk(CBlock&, CDiskBlockPos&) : OpenBlockFile failed\");\n+    CAutoFile blockFileIn(SER_DISK, CLIENT_VERSION);\n+    // Open block file to read\n+    if (!blockFileIn.open(GetBlockFile(pos).c_str(), std::ios::binary | std::ios::in))\n+        return error(\"ReadBlockFromDisk : Failed to open block file %s\", GetBlockFile(pos).c_str());\n+    else\n+        blockFileIn.seekg(pos.nPos);\n \n     // Read block\n     try {\n-        filein >> block;\n+        blockFileIn >> block;\n     }\n     catch (std::exception &e) {\n-        return error(\"%s() : deserialize or I/O error\", __PRETTY_FUNCTION__);\n+        return error(\"%s : Deserialize or I/O error - %s\", __PRETTY_FUNCTION__, e.what());\n     }\n \n     // Check the header\n     if (!CheckProofOfWork(block.GetHash(), block.nBits))\n-        return error(\"ReadBlockFromDisk(CBlock&, CDiskBlockPos&) : errors in block header\");\n+        return error(\"ReadBlockFromDisk : Errors in block header\");\n+\n+    if (fDebug)\n+        LogPrintf(\"ReadBlockFromDisk : Current position in block file %s after reading block is %\"PRIu64\"\\n\", GetBlockFile(pos).c_str(), blockFileIn.tellg());\n+    if (fBenchmark)\n+        LogPrintf(\"ReadBlockFromDisk : Function executed in %.2fms\\n\", (GetTimeMicros() - nStart) * 0.001);\n \n     return true;\n }\n@@ -2465,6 +2483,41 @@ FILE* OpenUndoFile(const CDiskBlockPos &pos, bool fReadOnly) {\n     return OpenDiskFile(pos, \"rev\", fReadOnly);\n }\n \n+const std::string& GetDiskFile(const CDiskBlockPos &pos, const char *prefix, bool fIsUndoFile)\n+{\n+    if (pos.IsNull())\n+        LogPrintf(\"GetDiskFile : Error, pos.IsNull() was true\\n\");\n+\n+    static std::string strPathCached[2];\n+    static int nFileCached[2] = {-1, -1};\n+    int nFileCur = pos.nFile;\n+\n+    if (nFileCached[fIsUndoFile] == nFileCur)\n+    {\n+        return strPathCached[fIsUndoFile];\n+    }\n+    else\n+    {\n+        boost::filesystem::path pathDiskFile = GetDataDir() / \"blocks\" / strprintf(\"%s%05u.dat\", prefix, nFileCur);\n+        boost::filesystem::create_directories(pathDiskFile.parent_path());\n+\n+        strPathCached[fIsUndoFile] = pathDiskFile.string();\n+        nFileCached[fIsUndoFile] = nFileCur;\n+    }\n+\n+    return strPathCached[fIsUndoFile];\n+}\n+\n+const std::string& GetBlockFile(const CDiskBlockPos &pos)\n+{\n+    return GetDiskFile(pos, \"blk\", false);\n+}\n+\n+const std::string& GetUndoFile(const CDiskBlockPos &pos)\n+{\n+    return GetDiskFile(pos, \"rev\", true);\n+}\n+\n CBlockIndex * InsertBlockIndex(uint256 hash)\n {\n     if (hash == 0)\n@@ -2791,7 +2844,7 @@ bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n                         break;\n                 }\n             } catch (std::exception &e) {\n-                LogPrintf(\"%s() : Deserialize or I/O error caught during load\\n\", __PRETTY_FUNCTION__);\n+                LogPrintf(\"%s : Deserialize or I/O error - %s\", __PRETTY_FUNCTION__, e.what());\n             }\n         }\n         fclose(fileIn);"
      },
      {
        "sha": "e0d74dad3c86fbd45b4b6e75785be4d3735487ff",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 39,
        "deletions": 24,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5ee9baec85bcc972853af954967ee6b24bdeff2c/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5ee9baec85bcc972853af954967ee6b24bdeff2c/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=5ee9baec85bcc972853af954967ee6b24bdeff2c",
        "patch": "@@ -137,6 +137,10 @@ bool CheckDiskSpace(uint64_t nAdditionalBytes = 0);\n FILE* OpenBlockFile(const CDiskBlockPos &pos, bool fReadOnly = false);\n /** Open an undo file (rev?????.dat) */\n FILE* OpenUndoFile(const CDiskBlockPos &pos, bool fReadOnly = false);\n+/** Get full path for the block file referenced by pos */\n+const std::string& GetBlockFile(const CDiskBlockPos &pos);\n+/** Get full path for the undo file referenced by pos */\n+const std::string& GetUndoFile(const CDiskBlockPos &pos);\n /** Import blocks from an external file */\n bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp = NULL);\n /** Initialize a new block tree database + block data on disk */\n@@ -329,59 +333,70 @@ class CBlockUndo\n \n     bool WriteToDisk(CDiskBlockPos &pos, const uint256 &hashBlock)\n     {\n-        // Open history file to append\n-        CAutoFile fileout = CAutoFile(OpenUndoFile(pos), SER_DISK, CLIENT_VERSION);\n-        if (!fileout)\n-            return error(\"CBlockUndo::WriteToDisk() : OpenUndoFile failed\");\n+        int64_t nStart = GetTimeMicros();\n+\n+        CAutoFile undoFileOut(SER_DISK, CLIENT_VERSION);\n+        // Open undo file\n+        if (!undoFileOut.open(GetUndoFile(pos).c_str()))\n+            return error(\"CBlockUndo::WriteToDisk : Failed to open undo file %s\", GetUndoFile(pos).c_str());\n+        else\n+            undoFileOut.seekp(pos.nPos);\n \n         // Write index header\n-        unsigned int nSize = fileout.GetSerializeSize(*this);\n-        fileout << FLATDATA(Params().MessageStart()) << nSize;\n+        undoFileOut << FLATDATA(Params().MessageStart()) << undoFileOut.GetSerializeSize(*this);\n+\n+        // Save new block position (used in the block-index)\n+        pos.nPos = (unsigned int)undoFileOut.tellp();\n \n         // Write undo data\n-        long fileOutPos = ftell(fileout);\n-        if (fileOutPos < 0)\n-            return error(\"CBlockUndo::WriteToDisk() : ftell failed\");\n-        pos.nPos = (unsigned int)fileOutPos;\n-        fileout << *this;\n+        undoFileOut << *this;\n \n         // calculate & write checksum\n         CHashWriter hasher(SER_GETHASH, PROTOCOL_VERSION);\n         hasher << hashBlock;\n         hasher << *this;\n-        fileout << hasher.GetHash();\n+        undoFileOut << hasher.GetHash();\n \n-        // Flush stdio buffers and commit to disk before returning\n-        fflush(fileout);\n-        if (!IsInitialBlockDownload())\n-            FileCommit(fileout);\n+        if (fDebug)\n+            LogPrintf(\"CBlockUndo::WriteToDisk : Current position in undo file %s after writing block is %\"PRIu64\"\\n\", GetUndoFile(pos).c_str(), undoFileOut.tellp());\n+        if (fBenchmark)\n+            LogPrintf(\"CBlockUndo::WriteToDisk : Function executed in %.2fms\\n\", (GetTimeMicros() - nStart) * 0.001);\n \n         return true;\n     }\n \n     bool ReadFromDisk(const CDiskBlockPos &pos, const uint256 &hashBlock)\n     {\n-        // Open history file to read\n-        CAutoFile filein = CAutoFile(OpenUndoFile(pos, true), SER_DISK, CLIENT_VERSION);\n-        if (!filein)\n-            return error(\"CBlockUndo::ReadFromDisk() : OpenBlockFile failed\");\n+        int64_t nStart = GetTimeMicros();\n+\n+        CAutoFile undoFileIn(SER_DISK, CLIENT_VERSION);\n+        // Open undo file to read\n+        if (!undoFileIn.open(GetUndoFile(pos).c_str(), std::ios::binary | std::ios::in))\n+            return error(\"CBlockUndo::ReadFromDisk : Failed to open undo file %s\", GetUndoFile(pos).c_str());\n+        else\n+            undoFileIn.seekg(pos.nPos);\n \n         // Read block\n         uint256 hashChecksum;\n         try {\n-            filein >> *this;\n-            filein >> hashChecksum;\n+            undoFileIn >> *this;\n+            undoFileIn >> hashChecksum;\n         }\n         catch (std::exception &e) {\n-            return error(\"%s() : deserialize or I/O error\", __PRETTY_FUNCTION__);\n+            return error(\"%s : Deserialize or I/O error - %s\", __PRETTY_FUNCTION__, e.what());\n         }\n \n         // Verify checksum\n         CHashWriter hasher(SER_GETHASH, PROTOCOL_VERSION);\n         hasher << hashBlock;\n         hasher << *this;\n         if (hashChecksum != hasher.GetHash())\n-            return error(\"CBlockUndo::ReadFromDisk() : checksum mismatch\");\n+            return error(\"CBlockUndo::ReadFromDisk : Checksum mismatch\");\n+\n+        if (fDebug)\n+            LogPrintf(\"CBlockUndo::ReadFromDisk : Current position in undo file %s after reading block is %\"PRIu64\"\\n\", GetUndoFile(pos).c_str(), undoFileIn.tellg());\n+        if (fBenchmark)\n+            LogPrintf(\"CBlockUndo::ReadFromDisk : Function executed in %.2fms\\n\", (GetTimeMicros() - nStart) * 0.001);\n \n         return true;\n     }"
      },
      {
        "sha": "cb45bf815ea80b3dd85f70440b645388a85a9fa3",
        "filename": "src/serialize.h",
        "status": "modified",
        "additions": 43,
        "deletions": 63,
        "changes": 106,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5ee9baec85bcc972853af954967ee6b24bdeff2c/src/serialize.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5ee9baec85bcc972853af954967ee6b24bdeff2c/src/serialize.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/serialize.h?ref=5ee9baec85bcc972853af954967ee6b24bdeff2c",
        "patch": "@@ -10,6 +10,7 @@\n \n #include <algorithm>\n #include <assert.h>\n+#include <fstream>\n #include <limits>\n #include <ios>\n #include <map>\n@@ -421,6 +422,7 @@ template<typename Stream, typename K, typename Pred, typename A> void Unserializ\n \n \n \n+\n //\n // If none of the specialized versions above matched, default to calling member function.\n // \"int nType\" is changed to \"long nType\" to keep from getting an ambiguous overload error.\n@@ -447,8 +449,6 @@ inline void Unserialize(Stream& is, T& a, long nType, int nVersion)\n \n \n \n-\n-\n //\n // string\n //\n@@ -789,11 +789,6 @@ struct ser_streamplaceholder\n \n \n \n-\n-\n-\n-\n-\n typedef std::vector<char, zero_after_free_allocator<char> > CSerializeData;\n \n /** Double ended buffer combining vector and stream-like interfaces.\n@@ -1100,71 +1095,50 @@ class CDataStream\n \n \n \n-\n-\n-\n-\n-/** RAII wrapper for FILE*.\n+/** RAII Wrapper for std::fstream.\n+ *\n+ * Also allows the underlying std::fstream to be used in spite of being wrapped by a\n+ * CAutoFile, if and only if it is referenced as a std::fstream and not a CAutoFile\n  *\n- * Will automatically close the file when it goes out of scope if not null.\n- * If you're returning the file pointer, return file.release().\n- * If you need to close the file early, use file.fclose() instead of fclose(file).\n+ * Will automatically close the file when it goes out of scope if opened.\n+ * If you need to close the file early, use file.close().\n  */\n-class CAutoFile\n+class CAutoFile : protected std::fstream\n {\n-protected:\n-    FILE* file;\n-    short state;\n-    short exceptmask;\n public:\n     int nType;\n     int nVersion;\n \n-    CAutoFile(FILE* filenew, int nTypeIn, int nVersionIn)\n+    CAutoFile(int nTypeIn, int nVersionIn)\n     {\n-        file = filenew;\n         nType = nTypeIn;\n         nVersion = nVersionIn;\n-        state = 0;\n-        exceptmask = std::ios::badbit | std::ios::failbit;\n     }\n \n     ~CAutoFile()\n     {\n-        fclose();\n+        // .close() would also be called by the std::fstream destructor if a file is still open\n+        if (std::fstream::is_open())\n+            std::fstream::close();\n     }\n \n-    void fclose()\n+    bool open(const char *pszFile, std::ios_base::openmode mode = std::ios::binary | std::ios::in | std::ios::out)\n     {\n-        if (file != NULL && file != stdin && file != stdout && file != stderr)\n-            ::fclose(file);\n-        file = NULL;\n+        std::fstream::open(pszFile, mode);\n+        return std::fstream::is_open();\n     }\n \n-    FILE* release()             { FILE* ret = file; file = NULL; return ret; }\n-    operator FILE*()            { return file; }\n-    FILE* operator->()          { return file; }\n-    FILE& operator*()           { return *file; }\n-    FILE** operator&()          { return &file; }\n-    FILE* operator=(FILE* pnew) { return file = pnew; }\n-    bool operator!()            { return (file == NULL); }\n+    void close() { std::fstream::close(); }\n \n+    // functions when reading from files\n+    void sync() { std::fstream::sync(); }\n+    void seekg(uint64_t nFPtrPosIn) { std::fstream::seekg(nFPtrPosIn, std::ios::beg); }\n+    uint64_t tellg() { return (uint64_t)std::fstream::tellg(); }\n \n-    //\n-    // Stream subset\n-    //\n-    void setstate(short bits, const char* psz)\n-    {\n-        state |= bits;\n-        if (state & exceptmask)\n-            throw std::ios_base::failure(psz);\n-    }\n-\n-    bool fail() const            { return state & (std::ios::badbit | std::ios::failbit); }\n-    bool good() const            { return state == 0; }\n-    void clear(short n = 0)      { state = n; }\n-    short exceptions()           { return exceptmask; }\n-    short exceptions(short mask) { short prev = exceptmask; exceptmask = mask; setstate(0, \"CAutoFile\"); return prev; }\n+    // functions when writing to files\n+    void flush() { std::fstream::flush(); } // write\n+    void seekp(uint64_t nFPtrPosIn) { std::fstream::seekp(nFPtrPosIn, std::ios::beg); }\n+    uint64_t tellp() { return (uint64_t)std::fstream::tellp(); } // write\n \n     void SetType(int n)          { nType = n; }\n     int GetType()                { return nType; }\n@@ -1175,19 +1149,25 @@ class CAutoFile\n \n     CAutoFile& read(char* pch, size_t nSize)\n     {\n-        if (!file)\n-            throw std::ios_base::failure(\"CAutoFile::read : file handle is NULL\");\n-        if (fread(pch, 1, nSize, file) != nSize)\n-            setstate(std::ios::failbit, feof(file) ? \"CAutoFile::read : end of file\" : \"CAutoFile::read : fread failed\");\n+        if (!std::fstream::is_open())\n+            throw std::ios_base::failure(\"CAutoFile::read : no file opened\");\n+\n+        std::fstream::read(pch, nSize);\n+        if (!std::fstream::good())\n+            throw std::ios_base::failure(\"CAutoFile::read : failed to read from file\");\n+\n         return (*this);\n     }\n \n     CAutoFile& write(const char* pch, size_t nSize)\n     {\n-        if (!file)\n-            throw std::ios_base::failure(\"CAutoFile::write : file handle is NULL\");\n-        if (fwrite(pch, 1, nSize, file) != nSize)\n-            setstate(std::ios::failbit, \"CAutoFile::write : write failed\");\n+        if (!std::fstream::is_open())\n+            throw std::ios_base::failure(\"CAutoFile::write : no file opened\");\n+\n+        std::fstream::write(pch, nSize);\n+        if (!std::fstream::good())\n+            throw std::ios_base::failure(\"CAutoFile::write : failed to write to file\");\n+\n         return (*this);\n     }\n \n@@ -1202,8 +1182,8 @@ class CAutoFile\n     CAutoFile& operator<<(const T& obj)\n     {\n         // Serialize to this stream\n-        if (!file)\n-            throw std::ios_base::failure(\"CAutoFile::operator<< : file handle is NULL\");\n+        if (!std::fstream::is_open())\n+            throw std::ios_base::failure(\"CAutoFile::operator<< : no file opened\");\n         ::Serialize(*this, obj, nType, nVersion);\n         return (*this);\n     }\n@@ -1212,8 +1192,8 @@ class CAutoFile\n     CAutoFile& operator>>(T& obj)\n     {\n         // Unserialize from this stream\n-        if (!file)\n-            throw std::ios_base::failure(\"CAutoFile::operator>> : file handle is NULL\");\n+        if (!std::fstream::is_open())\n+            throw std::ios_base::failure(\"CAutoFile::operator>> : no file opened\");\n         ::Unserialize(*this, obj, nType, nVersion);\n         return (*this);\n     }"
      },
      {
        "sha": "b02430639639c458a0dc1a231757d9bb6d4b8cf3",
        "filename": "src/test/checkblock_tests.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5ee9baec85bcc972853af954967ee6b24bdeff2c/src/test/checkblock_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5ee9baec85bcc972853af954967ee6b24bdeff2c/src/test/checkblock_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/checkblock_tests.cpp?ref=5ee9baec85bcc972853af954967ee6b24bdeff2c",
        "patch": "@@ -15,8 +15,7 @@\n \n BOOST_AUTO_TEST_SUITE(CheckBlock_tests)\n \n-bool\n-read_block(const std::string& filename, CBlock& block)\n+bool read_block(const std::string& filename, CBlock& block)\n {\n     namespace fs = boost::filesystem;\n     fs::path testFile = fs::current_path() / \"data\" / filename;\n@@ -26,15 +25,16 @@ read_block(const std::string& filename, CBlock& block)\n         testFile = fs::path(BOOST_PP_STRINGIZE(TEST_DATA_DIR)) / filename;\n     }\n #endif\n-    FILE* fp = fopen(testFile.string().c_str(), \"rb\");\n-    if (!fp) return false;\n \n-    fseek(fp, 8, SEEK_SET); // skip msgheader/size\n+    CAutoFile fileIn(SER_DISK, CLIENT_VERSION);\n+    // open input file\n+    if (!fileIn.open(testFile.string().c_str(), std::ios::binary | std::ios::in))\n+        return false;\n \n-    CAutoFile filein = CAutoFile(fp, SER_DISK, CLIENT_VERSION);\n-    if (!filein) return false;\n+    // skip msgheader/size\n+    fileIn.seekg(8);\n \n-    filein >> block;\n+    fileIn >> block;\n \n     return true;\n }"
      },
      {
        "sha": "0b1f2dc106d9a88705c5e97c84d70f3269e6de38",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5ee9baec85bcc972853af954967ee6b24bdeff2c/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5ee9baec85bcc972853af954967ee6b24bdeff2c/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=5ee9baec85bcc972853af954967ee6b24bdeff2c",
        "patch": "@@ -148,7 +148,7 @@ bool CCoinsViewDB::GetStats(CCoinsStats &stats) {\n             }\n             pcursor->Next();\n         } catch (std::exception &e) {\n-            return error(\"%s() : deserialize error\", __PRETTY_FUNCTION__);\n+            return error(\"%s : Deserialize or I/O error - %s\", __PRETTY_FUNCTION__, e.what());\n         }\n     }\n     delete pcursor;\n@@ -226,7 +226,7 @@ bool CBlockTreeDB::LoadBlockIndexGuts()\n                 break; // if shutdown requested or finished loading block index\n             }\n         } catch (std::exception &e) {\n-            return error(\"%s() : deserialize error\", __PRETTY_FUNCTION__);\n+            return error(\"%s : Deserialize or I/O error - %s\", __PRETTY_FUNCTION__, e.what());\n         }\n     }\n     delete pcursor;"
      },
      {
        "sha": "9dd4aa91709bec10a05b94cfc405dda4c507063b",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5ee9baec85bcc972853af954967ee6b24bdeff2c/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5ee9baec85bcc972853af954967ee6b24bdeff2c/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=5ee9baec85bcc972853af954967ee6b24bdeff2c",
        "patch": "@@ -1178,9 +1178,10 @@ bool RenameOver(boost::filesystem::path src, boost::filesystem::path dest)\n \n void FileCommit(FILE *fileout)\n {\n-    fflush(fileout);                // harmless if redundantly called\n+    fflush(fileout); // harmless if redundantly called\n #ifdef WIN32\n-    _commit(_fileno(fileout));\n+    HANDLE hFile = (HANDLE)_get_osfhandle(_fileno(fileout));\n+    FlushFileBuffers(hFile);\n #else\n     #if defined(__linux__) || defined(__NetBSD__)\n     fdatasync(fileno(fileout));"
      }
    ]
  }
]