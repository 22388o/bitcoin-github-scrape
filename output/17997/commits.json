[
  {
    "sha": "fa7fea3654203bf7e7bd504589dd564af7fc749d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTdmZWEzNjU0MjAzYmY3ZTdiZDUwNDU4OWRkNTY0YWY3ZmM3NDlk",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2020-01-24T19:00:57Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2020-03-12T13:23:56Z"
      },
      "message": "refactor: Remove mempool global from net\n\nThis refactor does two things:\n* Pass mempool in to PeerLogicValidation\n* Pass m_mempool around where needed",
      "tree": {
        "sha": "4e2987ec25b64618340af4afd61638038e96fb66",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4e2987ec25b64618340af4afd61638038e96fb66"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa7fea3654203bf7e7bd504589dd564af7fc749d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUiaXQv/Ra0ApbiTTFvI5cWEuHy5qopTxX/TKwvNq86smIYWaLJGsubbpz/PPGNl\nF0lSX8RQAx8PTWtgRTLOIrzyoVwyeN8R44Zg8Ns5xVAD31JTmc9AdNnNXTg63iRa\niO2mhlAEQydhnbOdP7JQxZiP+dDdtd9upSqxIa8ZqAaXNsJcgk0+RzSr7UQXHWH9\nPX3l6hfn9rjm7WRLrg3Ua8qCXDixFjhDKwyoisy657MRvofS4KYvWY40egbHa1WI\n4+hmZYfi+qESIsfz4fQV3J8PhRzoZGuD8o1ihqg1oyATiNg487LCUjal6lsd5ln4\nIThB9RWbFKyGiXg9NqEJ25RwDX0M+a6/UuHzBWa+rFf1wXYTgVKa6uAHFjbISuSE\nJJSE4vnCXC6lHpcoycXj2SNqBBLF/BMKAr4XQK5+Vv4KzsW7BIxLizRo4TnImHxD\nGIFl271B7FTht9dMU1JvM7FmkmVpM+2tKSkPoxRxta9kDtuAC5m3iELHkXcHAKuv\nIFUSFbQV\n=CWOl\n-----END PGP SIGNATURE-----",
        "payload": "tree 4e2987ec25b64618340af4afd61638038e96fb66\nparent 309b0c4c19319a8e0fd3fd7ff82ef9ebb2803072\nauthor MarcoFalke <falke.marco@gmail.com> 1579892457 -0500\ncommitter MarcoFalke <falke.marco@gmail.com> 1584019436 -0400\n\nrefactor: Remove mempool global from net\n\nThis refactor does two things:\n* Pass mempool in to PeerLogicValidation\n* Pass m_mempool around where needed\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa7fea3654203bf7e7bd504589dd564af7fc749d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa7fea3654203bf7e7bd504589dd564af7fc749d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa7fea3654203bf7e7bd504589dd564af7fc749d/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "309b0c4c19319a8e0fd3fd7ff82ef9ebb2803072",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/309b0c4c19319a8e0fd3fd7ff82ef9ebb2803072",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/309b0c4c19319a8e0fd3fd7ff82ef9ebb2803072"
      }
    ],
    "stats": {
      "total": 93,
      "additions": 49,
      "deletions": 44
    },
    "files": [
      {
        "sha": "97640b0658933fcaeb6165efba4f73593a02d8fc",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa7fea3654203bf7e7bd504589dd564af7fc749d/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa7fea3654203bf7e7bd504589dd564af7fc749d/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=fa7fea3654203bf7e7bd504589dd564af7fc749d",
        "patch": "@@ -1329,8 +1329,12 @@ bool AppInitMain(NodeContext& node)\n     node.banman = MakeUnique<BanMan>(GetDataDir() / \"banlist.dat\", &uiInterface, gArgs.GetArg(\"-bantime\", DEFAULT_MISBEHAVING_BANTIME));\n     assert(!node.connman);\n     node.connman = std::unique_ptr<CConnman>(new CConnman(GetRand(std::numeric_limits<uint64_t>::max()), GetRand(std::numeric_limits<uint64_t>::max())));\n+    // Make mempool generally available in the node context. For example the connection manager, wallet, or RPC threads,\n+    // which are all started after this, may use it from the node context.\n+    assert(!node.mempool);\n+    node.mempool = &::mempool;\n \n-    node.peer_logic.reset(new PeerLogicValidation(node.connman.get(), node.banman.get(), *node.scheduler));\n+    node.peer_logic.reset(new PeerLogicValidation(node.connman.get(), node.banman.get(), *node.scheduler, *node.mempool));\n     RegisterValidationInterface(node.peer_logic.get());\n \n     // sanitize comments per BIP-0014, format user agent and check total size\n@@ -1678,11 +1682,6 @@ bool AppInitMain(NodeContext& node)\n         return false;\n     }\n \n-    // Now that the chain state is loaded, make mempool generally available in the node context. For example the\n-    // connection manager, wallet, or RPC threads, which are all started after this, may use it from the node context.\n-    assert(!node.mempool);\n-    node.mempool = &::mempool;\n-\n     fs::path est_path = GetDataDir() / FEE_ESTIMATES_FILENAME;\n     CAutoFile est_filein(fsbridge::fopen(est_path, \"rb\"), SER_DISK, CLIENT_VERSION);\n     // Allowed to fail as this file IS missing on first startup."
      },
      {
        "sha": "d9b048fd6510a4aa9ac0a08a10c2f9ee64046715",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 27,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa7fea3654203bf7e7bd504589dd564af7fc749d/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa7fea3654203bf7e7bd504589dd564af7fc749d/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=fa7fea3654203bf7e7bd504589dd564af7fc749d",
        "patch": "@@ -465,7 +465,7 @@ static bool MarkBlockAsReceived(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs\n \n // returns false, still setting pit, if the block was already in flight from the same peer\n // pit will only be valid as long as the same cs_main lock is being held\n-static bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex* pindex = nullptr, std::list<QueuedBlock>::iterator** pit = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n+static bool MarkBlockAsInFlight(CTxMemPool& mempool, NodeId nodeid, const uint256& hash, const CBlockIndex* pindex = nullptr, std::list<QueuedBlock>::iterator** pit = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n     CNodeState *state = State(nodeid);\n     assert(state != nullptr);\n \n@@ -1102,8 +1102,11 @@ static bool BlockRequestAllowed(const CBlockIndex* pindex, const Consensus::Para\n         (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, consensusParams) < STALE_RELAY_AGE_LIMIT);\n }\n \n-PeerLogicValidation::PeerLogicValidation(CConnman* connmanIn, BanMan* banman, CScheduler& scheduler)\n-    : connman(connmanIn), m_banman(banman), m_stale_tip_check_time(0)\n+PeerLogicValidation::PeerLogicValidation(CConnman* connmanIn, BanMan* banman, CScheduler& scheduler, CTxMemPool& pool)\n+    : connman(connmanIn),\n+      m_banman(banman),\n+      m_mempool(pool),\n+      m_stale_tip_check_time(0)\n {\n     // Initialize global variables that cannot be constructed at startup.\n     recentRejects.reset(new CRollingBloomFilter(120000, 0.000001));\n@@ -1314,7 +1317,7 @@ void PeerLogicValidation::BlockChecked(const CBlock& block, const BlockValidatio\n //\n \n \n-bool static AlreadyHave(const CInv& inv) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+bool static AlreadyHave(const CInv& inv, const CTxMemPool& mempool) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     switch (inv.type)\n     {\n@@ -1553,7 +1556,7 @@ void static ProcessGetBlockData(CNode* pfrom, const CChainParams& chainparams, c\n     }\n }\n \n-void static ProcessGetData(CNode* pfrom, const CChainParams& chainparams, CConnman* connman, const std::atomic<bool>& interruptMsgProc) LOCKS_EXCLUDED(cs_main)\n+void static ProcessGetData(CNode* pfrom, const CChainParams& chainparams, CConnman* connman, const CTxMemPool& mempool, const std::atomic<bool>& interruptMsgProc) LOCKS_EXCLUDED(cs_main)\n {\n     AssertLockNotHeld(cs_main);\n \n@@ -1666,7 +1669,7 @@ inline void static SendBlockTransactions(const CBlock& block, const BlockTransac\n     connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));\n }\n \n-bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::vector<CBlockHeader>& headers, const CChainParams& chainparams, bool via_compact_block)\n+bool static ProcessHeadersMessage(CNode* pfrom, CConnman* connman, CTxMemPool& mempool, const std::vector<CBlockHeader>& headers, const CChainParams& chainparams, bool via_compact_block)\n {\n     const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n     size_t nCount = headers.size();\n@@ -1794,7 +1797,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n                     }\n                     uint32_t nFetchFlags = GetFetchFlags(pfrom);\n                     vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n-                    MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), pindex);\n+                    MarkBlockAsInFlight(mempool, pfrom->GetId(), pindex->GetBlockHash(), pindex);\n                     LogPrint(BCLog::NET, \"Requesting block %s from  peer=%d\\n\",\n                             pindex->GetBlockHash().ToString(), pfrom->GetId());\n                 }\n@@ -1848,7 +1851,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n     return true;\n }\n \n-void static ProcessOrphanTx(CConnman* connman, std::set<uint256>& orphan_work_set, std::list<CTransactionRef>& removed_txn) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans)\n+void static ProcessOrphanTx(CConnman* connman, CTxMemPool& mempool, std::set<uint256>& orphan_work_set, std::list<CTransactionRef>& removed_txn) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans)\n {\n     AssertLockHeld(cs_main);\n     AssertLockHeld(g_cs_orphans);\n@@ -1908,7 +1911,7 @@ void static ProcessOrphanTx(CConnman* connman, std::set<uint256>& orphan_work_se\n     }\n }\n \n-bool ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman* connman, BanMan* banman, const std::atomic<bool>& interruptMsgProc)\n+bool ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CTxMemPool& mempool, CConnman* connman, BanMan* banman, const std::atomic<bool>& interruptMsgProc)\n {\n     LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->GetId());\n     if (gArgs.IsArgSet(\"-dropmessagestest\") && GetRand(gArgs.GetArg(\"-dropmessagestest\", 0)) == 0)\n@@ -2260,7 +2263,7 @@ bool ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vR\n             if (interruptMsgProc)\n                 return true;\n \n-            bool fAlreadyHave = AlreadyHave(inv);\n+            bool fAlreadyHave = AlreadyHave(inv, mempool);\n             LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom->GetId());\n \n             if (inv.type == MSG_TX) {\n@@ -2311,7 +2314,7 @@ bool ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vR\n         }\n \n         pfrom->vRecvGetData.insert(pfrom->vRecvGetData.end(), vInv.begin(), vInv.end());\n-        ProcessGetData(pfrom, chainparams, connman, interruptMsgProc);\n+        ProcessGetData(pfrom, chainparams, connman, mempool, interruptMsgProc);\n         return true;\n     }\n \n@@ -2528,7 +2531,7 @@ bool ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vR\n \n         std::list<CTransactionRef> lRemovedTxn;\n \n-        if (!AlreadyHave(inv) &&\n+        if (!AlreadyHave(inv, mempool) &&\n             AcceptToMemoryPool(mempool, state, ptx, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n             mempool.check(&::ChainstateActive().CoinsTip());\n             RelayTransaction(tx.GetHash(), *connman);\n@@ -2549,7 +2552,7 @@ bool ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vR\n                 mempool.size(), mempool.DynamicMemoryUsage() / 1000);\n \n             // Recursively process any orphan transactions that depended on this one\n-            ProcessOrphanTx(connman, pfrom->orphan_work_set, lRemovedTxn);\n+            ProcessOrphanTx(connman, mempool, pfrom->orphan_work_set, lRemovedTxn);\n         }\n         else if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS)\n         {\n@@ -2567,7 +2570,7 @@ bool ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vR\n                 for (const CTxIn& txin : tx.vin) {\n                     CInv _inv(MSG_TX | nFetchFlags, txin.prevout.hash);\n                     pfrom->AddInventoryKnown(_inv);\n-                    if (!AlreadyHave(_inv)) RequestTx(State(pfrom->GetId()), _inv.hash, current_time);\n+                    if (!AlreadyHave(_inv, mempool)) RequestTx(State(pfrom->GetId()), _inv.hash, current_time);\n                 }\n                 AddOrphanTx(ptx, pfrom->GetId());\n \n@@ -2742,7 +2745,7 @@ bool ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vR\n             if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n                  (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {\n                 std::list<QueuedBlock>::iterator* queuedBlockIt = nullptr;\n-                if (!MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), pindex, &queuedBlockIt)) {\n+                if (!MarkBlockAsInFlight(mempool, pfrom->GetId(), pindex->GetBlockHash(), pindex, &queuedBlockIt)) {\n                     if (!(*queuedBlockIt)->partialBlock)\n                         (*queuedBlockIt)->partialBlock.reset(new PartiallyDownloadedBlock(&mempool));\n                     else {\n@@ -2815,15 +2818,15 @@ bool ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vR\n         } // cs_main\n \n         if (fProcessBLOCKTXN)\n-            return ProcessMessage(pfrom, NetMsgType::BLOCKTXN, blockTxnMsg, nTimeReceived, chainparams, connman, banman, interruptMsgProc);\n+            return ProcessMessage(pfrom, NetMsgType::BLOCKTXN, blockTxnMsg, nTimeReceived, chainparams, mempool, connman, banman, interruptMsgProc);\n \n         if (fRevertToHeaderProcessing) {\n             // Headers received from HB compact block peers are permitted to be\n             // relayed before full validation (see BIP 152), so we don't want to disconnect\n             // the peer if the header turns out to be for an invalid block.\n             // Note that if a peer tries to build on an invalid chain, that\n             // will be detected and the peer will be banned.\n-            return ProcessHeadersMessage(pfrom, connman, {cmpctblock.header}, chainparams, /*via_compact_block=*/true);\n+            return ProcessHeadersMessage(pfrom, connman, mempool, {cmpctblock.header}, chainparams, /*via_compact_block=*/true);\n         }\n \n         if (fBlockReconstructed) {\n@@ -2967,7 +2970,7 @@ bool ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vR\n             ReadCompactSize(vRecv); // ignore tx count; assume it is 0.\n         }\n \n-        return ProcessHeadersMessage(pfrom, connman, headers, chainparams, /*via_compact_block=*/false);\n+        return ProcessHeadersMessage(pfrom, connman, mempool, headers, chainparams, /*via_compact_block=*/false);\n     }\n \n     if (strCommand == NetMsgType::BLOCK)\n@@ -3285,12 +3288,12 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     bool fMoreWork = false;\n \n     if (!pfrom->vRecvGetData.empty())\n-        ProcessGetData(pfrom, chainparams, connman, interruptMsgProc);\n+        ProcessGetData(pfrom, chainparams, connman, m_mempool, interruptMsgProc);\n \n     if (!pfrom->orphan_work_set.empty()) {\n         std::list<CTransactionRef> removed_txn;\n         LOCK2(cs_main, g_cs_orphans);\n-        ProcessOrphanTx(connman, pfrom->orphan_work_set, removed_txn);\n+        ProcessOrphanTx(connman, m_mempool, pfrom->orphan_work_set, removed_txn);\n         for (const CTransactionRef& removedTx : removed_txn) {\n             AddToCompactExtraTransactions(removedTx);\n         }\n@@ -3353,7 +3356,7 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     bool fRet = false;\n     try\n     {\n-        fRet = ProcessMessage(pfrom, strCommand, vRecv, msg.m_time, chainparams, connman, m_banman, interruptMsgProc);\n+        fRet = ProcessMessage(pfrom, strCommand, vRecv, msg.m_time, chainparams, m_mempool, connman, m_banman, interruptMsgProc);\n         if (interruptMsgProc)\n             return false;\n         if (!pfrom->vRecvGetData.empty())\n@@ -3819,7 +3822,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n \n                 // Respond to BIP35 mempool requests\n                 if (fSendTrickle && pto->m_tx_relay->fSendMempool) {\n-                    auto vtxinfo = mempool.infoAll();\n+                    auto vtxinfo = m_mempool.infoAll();\n                     pto->m_tx_relay->fSendMempool = false;\n                     CFeeRate filterrate;\n                     {\n@@ -3865,7 +3868,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                     }\n                     // Topologically and fee-rate sort the inventory we send for privacy and priority reasons.\n                     // A heap is used so that not all items need sorting if only a few are being sent.\n-                    CompareInvMempoolOrder compareInvMempoolOrder(&mempool);\n+                    CompareInvMempoolOrder compareInvMempoolOrder(&m_mempool);\n                     std::make_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n                     // No reason to drain out at many times the network's capacity,\n                     // especially since we have many peers and some will draw much shorter delays.\n@@ -3884,7 +3887,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                             continue;\n                         }\n                         // Not in the mempool anymore? don't bother sending it.\n-                        auto txinfo = mempool.info(hash);\n+                        auto txinfo = m_mempool.info(hash);\n                         if (!txinfo.tx) {\n                             continue;\n                         }\n@@ -3996,7 +3999,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n             for (const CBlockIndex *pindex : vToDownload) {\n                 uint32_t nFetchFlags = GetFetchFlags(pto);\n                 vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n-                MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), pindex);\n+                MarkBlockAsInFlight(m_mempool, pto->GetId(), pindex->GetBlockHash(), pindex);\n                 LogPrint(BCLog::NET, \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n                     pindex->nHeight, pto->GetId());\n             }\n@@ -4039,7 +4042,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n             // processing at a later time, see below)\n             tx_process_time.erase(tx_process_time.begin());\n             CInv inv(MSG_TX | GetFetchFlags(pto), txid);\n-            if (!AlreadyHave(inv)) {\n+            if (!AlreadyHave(inv, m_mempool)) {\n                 // If this transaction was last requested more than 1 minute ago,\n                 // then request.\n                 const auto last_request_time = GetTxRequestTime(inv.hash);\n@@ -4077,7 +4080,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n         // We don't want white listed peers to filter txs to us if we have -whitelistforcerelay\n         if (pto->m_tx_relay != nullptr && pto->nVersion >= FEEFILTER_VERSION && gArgs.GetBoolArg(\"-feefilter\", DEFAULT_FEEFILTER) &&\n             !pto->HasPermission(PF_FORCERELAY)) {\n-            CAmount currentFilter = mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFeePerK();\n+            CAmount currentFilter = m_mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFeePerK();\n             int64_t timeNow = GetTimeMicros();\n             if (timeNow > pto->m_tx_relay->nextSendTimeFeeFilter) {\n                 static CFeeRate default_feerate(DEFAULT_MIN_RELAY_TX_FEE);"
      },
      {
        "sha": "b73037722c44f994839ef1ecf4bd953d0a41e0f8",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 6,
        "deletions": 3,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa7fea3654203bf7e7bd504589dd564af7fc749d/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa7fea3654203bf7e7bd504589dd564af7fc749d/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=fa7fea3654203bf7e7bd504589dd564af7fc749d",
        "patch": "@@ -6,10 +6,12 @@\n #ifndef BITCOIN_NET_PROCESSING_H\n #define BITCOIN_NET_PROCESSING_H\n \n-#include <net.h>\n-#include <validationinterface.h>\n #include <consensus/params.h>\n+#include <net.h>\n #include <sync.h>\n+#include <validationinterface.h>\n+\n+class CTxMemPool;\n \n extern RecursiveMutex cs_main;\n \n@@ -23,11 +25,12 @@ class PeerLogicValidation final : public CValidationInterface, public NetEventsI\n private:\n     CConnman* const connman;\n     BanMan* const m_banman;\n+    CTxMemPool& m_mempool;\n \n     bool CheckIfBanned(CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n public:\n-    PeerLogicValidation(CConnman* connman, BanMan* banman, CScheduler& scheduler);\n+    PeerLogicValidation(CConnman* connman, BanMan* banman, CScheduler& scheduler, CTxMemPool& pool);\n \n     /**\n      * Overridden from CValidationInterface."
      },
      {
        "sha": "73bce6f7897090437850958ec4d61255a2dc52a4",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa7fea3654203bf7e7bd504589dd564af7fc749d/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa7fea3654203bf7e7bd504589dd564af7fc749d/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=fa7fea3654203bf7e7bd504589dd564af7fc749d",
        "patch": "@@ -78,7 +78,7 @@ BOOST_FIXTURE_TEST_SUITE(denialofservice_tests, TestingSetup)\n BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n {\n     auto connman = MakeUnique<CConnman>(0x1337, 0x1337);\n-    auto peerLogic = MakeUnique<PeerLogicValidation>(connman.get(), nullptr, *m_node.scheduler);\n+    auto peerLogic = MakeUnique<PeerLogicValidation>(connman.get(), nullptr, *m_node.scheduler, *m_node.mempool);\n \n     // Mock an outbound peer\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n@@ -148,7 +148,7 @@ static void AddRandomOutboundPeer(std::vector<CNode *> &vNodes, PeerLogicValidat\n BOOST_AUTO_TEST_CASE(stale_tip_peer_management)\n {\n     auto connman = MakeUnique<CConnmanTest>(0x1337, 0x1337);\n-    auto peerLogic = MakeUnique<PeerLogicValidation>(connman.get(), nullptr, *m_node.scheduler);\n+    auto peerLogic = MakeUnique<PeerLogicValidation>(connman.get(), nullptr, *m_node.scheduler, *m_node.mempool);\n \n     const Consensus::Params& consensusParams = Params().GetConsensus();\n     constexpr int max_outbound_full_relay = 8;\n@@ -221,7 +221,7 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n {\n     auto banman = MakeUnique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     auto connman = MakeUnique<CConnman>(0x1337, 0x1337);\n-    auto peerLogic = MakeUnique<PeerLogicValidation>(connman.get(), banman.get(), *m_node.scheduler);\n+    auto peerLogic = MakeUnique<PeerLogicValidation>(connman.get(), banman.get(), *m_node.scheduler, *m_node.mempool);\n \n     banman->ClearBanned();\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n@@ -276,7 +276,7 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n {\n     auto banman = MakeUnique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     auto connman = MakeUnique<CConnman>(0x1337, 0x1337);\n-    auto peerLogic = MakeUnique<PeerLogicValidation>(connman.get(), banman.get(), *m_node.scheduler);\n+    auto peerLogic = MakeUnique<PeerLogicValidation>(connman.get(), banman.get(), *m_node.scheduler, *m_node.mempool);\n \n     banman->ClearBanned();\n     gArgs.ForceSetArg(\"-banscore\", \"111\"); // because 11 is my favorite number\n@@ -323,7 +323,7 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n {\n     auto banman = MakeUnique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     auto connman = MakeUnique<CConnman>(0x1337, 0x1337);\n-    auto peerLogic = MakeUnique<PeerLogicValidation>(connman.get(), banman.get(), *m_node.scheduler);\n+    auto peerLogic = MakeUnique<PeerLogicValidation>(connman.get(), banman.get(), *m_node.scheduler, *m_node.mempool);\n \n     banman->ClearBanned();\n     int64_t nStartTime = GetTime();"
      },
      {
        "sha": "dc49dd499a156b653786c6eb3d3e431135d5278f",
        "filename": "src/test/fuzz/process_message.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa7fea3654203bf7e7bd504589dd564af7fc749d/src/test/fuzz/process_message.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa7fea3654203bf7e7bd504589dd564af7fc749d/src/test/fuzz/process_message.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/process_message.cpp?ref=fa7fea3654203bf7e7bd504589dd564af7fc749d",
        "patch": "@@ -32,7 +32,7 @@\n #include <string>\n #include <vector>\n \n-bool ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman* connman, BanMan* banman, const std::atomic<bool>& interruptMsgProc);\n+bool ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CTxMemPool& mempool, CConnman* connman, BanMan* banman, const std::atomic<bool>& interruptMsgProc);\n \n namespace {\n \n@@ -85,7 +85,7 @@ void test_one_input(const std::vector<uint8_t>& buffer)\n     p2p_node.SetSendVersion(PROTOCOL_VERSION);\n     g_setup->m_node.peer_logic->InitializeNode(&p2p_node);\n     try {\n-        (void)ProcessMessage(&p2p_node, random_message_type, random_bytes_data_stream, GetTimeMillis(), Params(), g_setup->m_node.connman.get(), g_setup->m_node.banman.get(), std::atomic<bool>{false});\n+        (void)ProcessMessage(&p2p_node, random_message_type, random_bytes_data_stream, GetTimeMillis(), Params(), *g_setup->m_node.mempool, g_setup->m_node.connman.get(), g_setup->m_node.banman.get(), std::atomic<bool>{false});\n     } catch (const std::ios_base::failure& e) {\n         const std::string exception_message{e.what()};\n         const auto p = EXPECTED_DESERIALIZATION_EXCEPTIONS.find(exception_message);"
      },
      {
        "sha": "e19a96eafca1f6faaa13f77300d19cb8b5ad114c",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa7fea3654203bf7e7bd504589dd564af7fc749d/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa7fea3654203bf7e7bd504589dd564af7fc749d/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=fa7fea3654203bf7e7bd504589dd564af7fc749d",
        "patch": "@@ -137,7 +137,7 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n     m_node.mempool->setSanityCheck(1.0);\n     m_node.banman = MakeUnique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     m_node.connman = MakeUnique<CConnman>(0x1337, 0x1337); // Deterministic randomness for tests.\n-    m_node.peer_logic = MakeUnique<PeerLogicValidation>(m_node.connman.get(), m_node.banman.get(), *m_node.scheduler);\n+    m_node.peer_logic = MakeUnique<PeerLogicValidation>(m_node.connman.get(), m_node.banman.get(), *m_node.scheduler, *m_node.mempool);\n }\n \n TestingSetup::~TestingSetup()"
      }
    ]
  }
]