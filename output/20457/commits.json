[
  {
    "sha": "4747db876154ddd828c03d9eda10ecf8b25d8dc8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NzQ3ZGI4NzYxNTRkZGQ4MjhjMDNkOWVkYTEwZWNmOGIyNWQ4ZGM4",
    "commit": {
      "author": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2021-09-18T04:30:30Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2021-09-18T04:31:24Z"
      },
      "message": "util: Introduce ToIntegral<T>(const std::string&) for locale independent parsing using std::from_chars(\u2026) (C++17)\n\nutil: Avoid locale dependent functions strtol/strtoll/strtoul/strtoull in ParseInt32/ParseInt64/ParseUInt32/ParseUInt64\n\nfuzz: Assert equivalence between new and old Parse{Int,Uint}{8,32,64} functions\n\ntest: Add unit tests for ToIntegral<T>(const std::string&)",
      "tree": {
        "sha": "7b9b6ebad2043653c550fb1adc2be76742804711",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7b9b6ebad2043653c550fb1adc2be76742804711"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4747db876154ddd828c03d9eda10ecf8b25d8dc8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4747db876154ddd828c03d9eda10ecf8b25d8dc8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4747db876154ddd828c03d9eda10ecf8b25d8dc8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4747db876154ddd828c03d9eda10ecf8b25d8dc8/comments",
    "author": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e69cbac628bfdca4a8e4ead821190eaf5b6b3d07",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e69cbac628bfdca4a8e4ead821190eaf5b6b3d07",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e69cbac628bfdca4a8e4ead821190eaf5b6b3d07"
      }
    ],
    "stats": {
      "total": 344,
      "additions": 270,
      "deletions": 74
    },
    "files": [
      {
        "sha": "dc2bf7c860653191428c41cd2f4482095eaeded3",
        "filename": "src/test/fuzz/string.cpp",
        "status": "modified",
        "additions": 135,
        "deletions": 0,
        "changes": 135,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4747db876154ddd828c03d9eda10ecf8b25d8dc8/src/test/fuzz/string.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4747db876154ddd828c03d9eda10ecf8b25d8dc8/src/test/fuzz/string.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/string.cpp?ref=4747db876154ddd828c03d9eda10ecf8b25d8dc8",
        "patch": "@@ -31,9 +31,99 @@\n #include <version.h>\n \n #include <cstdint>\n+#include <cstdlib>\n #include <string>\n #include <vector>\n \n+namespace {\n+bool LegacyParsePrechecks(const std::string& str)\n+{\n+    if (str.empty()) // No empty string allowed\n+        return false;\n+    if (str.size() >= 1 && (IsSpace(str[0]) || IsSpace(str[str.size() - 1]))) // No padding allowed\n+        return false;\n+    if (!ValidAsCString(str)) // No embedded NUL characters allowed\n+        return false;\n+    return true;\n+}\n+\n+bool LegacyParseInt32(const std::string& str, int32_t* out)\n+{\n+    if (!LegacyParsePrechecks(str))\n+        return false;\n+    char* endp = nullptr;\n+    errno = 0; // strtol will not set errno if valid\n+    long int n = strtol(str.c_str(), &endp, 10);\n+    if (out) *out = (int32_t)n;\n+    // Note that strtol returns a *long int*, so even if strtol doesn't report an over/underflow\n+    // we still have to check that the returned value is within the range of an *int32_t*. On 64-bit\n+    // platforms the size of these types may be different.\n+    return endp && *endp == 0 && !errno &&\n+           n >= std::numeric_limits<int32_t>::min() &&\n+           n <= std::numeric_limits<int32_t>::max();\n+}\n+\n+bool LegacyParseInt64(const std::string& str, int64_t* out)\n+{\n+    if (!LegacyParsePrechecks(str))\n+        return false;\n+    char* endp = nullptr;\n+    errno = 0; // strtoll will not set errno if valid\n+    long long int n = strtoll(str.c_str(), &endp, 10);\n+    if (out) *out = (int64_t)n;\n+    // Note that strtoll returns a *long long int*, so even if strtol doesn't report an over/underflow\n+    // we still have to check that the returned value is within the range of an *int64_t*.\n+    return endp && *endp == 0 && !errno &&\n+           n >= std::numeric_limits<int64_t>::min() &&\n+           n <= std::numeric_limits<int64_t>::max();\n+}\n+\n+bool LegacyParseUInt32(const std::string& str, uint32_t* out)\n+{\n+    if (!LegacyParsePrechecks(str))\n+        return false;\n+    if (str.size() >= 1 && str[0] == '-') // Reject negative values, unfortunately strtoul accepts these by default if they fit in the range\n+        return false;\n+    char* endp = nullptr;\n+    errno = 0; // strtoul will not set errno if valid\n+    unsigned long int n = strtoul(str.c_str(), &endp, 10);\n+    if (out) *out = (uint32_t)n;\n+    // Note that strtoul returns a *unsigned long int*, so even if it doesn't report an over/underflow\n+    // we still have to check that the returned value is within the range of an *uint32_t*. On 64-bit\n+    // platforms the size of these types may be different.\n+    return endp && *endp == 0 && !errno &&\n+           n <= std::numeric_limits<uint32_t>::max();\n+}\n+\n+bool LegacyParseUInt8(const std::string& str, uint8_t* out)\n+{\n+    uint32_t u32;\n+    if (!LegacyParseUInt32(str, &u32) || u32 > std::numeric_limits<uint8_t>::max()) {\n+        return false;\n+    }\n+    if (out != nullptr) {\n+        *out = static_cast<uint8_t>(u32);\n+    }\n+    return true;\n+}\n+\n+bool LegacyParseUInt64(const std::string& str, uint64_t* out)\n+{\n+    if (!LegacyParsePrechecks(str))\n+        return false;\n+    if (str.size() >= 1 && str[0] == '-') // Reject negative values, unfortunately strtoull accepts these by default if they fit in the range\n+        return false;\n+    char* endp = nullptr;\n+    errno = 0; // strtoull will not set errno if valid\n+    unsigned long long int n = strtoull(str.c_str(), &endp, 10);\n+    if (out) *out = (uint64_t)n;\n+    // Note that strtoull returns a *unsigned long long int*, so even if it doesn't report an over/underflow\n+    // we still have to check that the returned value is within the range of an *uint64_t*.\n+    return endp && *endp == 0 && !errno &&\n+           n <= std::numeric_limits<uint64_t>::max();\n+}\n+}; // namespace\n+\n FUZZ_TARGET(string)\n {\n     FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n@@ -133,4 +223,49 @@ FUZZ_TARGET(string)\n         const bilingual_str bs2{random_string_2, random_string_1};\n         (void)(bs1 + bs2);\n     }\n+    {\n+        int32_t i32;\n+        int64_t i64;\n+        uint32_t u32;\n+        uint64_t u64;\n+        uint8_t u8;\n+        const bool ok_i32 = ParseInt32(random_string_1, &i32);\n+        const bool ok_i64 = ParseInt64(random_string_1, &i64);\n+        const bool ok_u32 = ParseUInt32(random_string_1, &u32);\n+        const bool ok_u64 = ParseUInt64(random_string_1, &u64);\n+        const bool ok_u8 = ParseUInt8(random_string_1, &u8);\n+\n+        int32_t i32_legacy;\n+        int64_t i64_legacy;\n+        uint32_t u32_legacy;\n+        uint64_t u64_legacy;\n+        uint8_t u8_legacy;\n+        const bool ok_i32_legacy = LegacyParseInt32(random_string_1, &i32_legacy);\n+        const bool ok_i64_legacy = LegacyParseInt64(random_string_1, &i64_legacy);\n+        const bool ok_u32_legacy = LegacyParseUInt32(random_string_1, &u32_legacy);\n+        const bool ok_u64_legacy = LegacyParseUInt64(random_string_1, &u64_legacy);\n+        const bool ok_u8_legacy = LegacyParseUInt8(random_string_1, &u8_legacy);\n+\n+        assert(ok_i32 == ok_i32_legacy);\n+        assert(ok_i64 == ok_i64_legacy);\n+        assert(ok_u32 == ok_u32_legacy);\n+        assert(ok_u64 == ok_u64_legacy);\n+        assert(ok_u8 == ok_u8_legacy);\n+\n+        if (ok_i32) {\n+            assert(i32 == i32_legacy);\n+        }\n+        if (ok_i64) {\n+            assert(i64 == i64_legacy);\n+        }\n+        if (ok_u32) {\n+            assert(u32 == u32_legacy);\n+        }\n+        if (ok_u64) {\n+            assert(u64 == u64_legacy);\n+        }\n+        if (ok_u8) {\n+            assert(u8 == u8_legacy);\n+        }\n+    }\n }"
      },
      {
        "sha": "5ee522ea0a35dd6c94683a9772b23ac414c1b10c",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 75,
        "deletions": 0,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4747db876154ddd828c03d9eda10ecf8b25d8dc8/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4747db876154ddd828c03d9eda10ecf8b25d8dc8/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=4747db876154ddd828c03d9eda10ecf8b25d8dc8",
        "patch": "@@ -1474,6 +1474,81 @@ BOOST_AUTO_TEST_CASE(test_ParseInt32)\n     BOOST_CHECK(!ParseInt32(\"32482348723847471234\", nullptr));\n }\n \n+BOOST_AUTO_TEST_CASE(test_ToIntegral)\n+{\n+    BOOST_CHECK_EQUAL(ToIntegral<int32_t>(\"1234\").value(), 1'234);\n+    BOOST_CHECK_EQUAL(ToIntegral<int32_t>(\"0\").value(), 0);\n+    BOOST_CHECK_EQUAL(ToIntegral<int32_t>(\"01234\").value(), 1'234);\n+    BOOST_CHECK_EQUAL(ToIntegral<int32_t>(\"00000000000000001234\").value(), 1'234);\n+    BOOST_CHECK_EQUAL(ToIntegral<int32_t>(\"-00000000000000001234\").value(), -1'234);\n+    BOOST_CHECK_EQUAL(ToIntegral<int32_t>(\"00000000000000000000\").value(), 0);\n+    BOOST_CHECK_EQUAL(ToIntegral<int32_t>(\"-00000000000000000000\").value(), 0);\n+    BOOST_CHECK_EQUAL(ToIntegral<int32_t>(\"-1234\").value(), -1'234);\n+    BOOST_CHECK_EQUAL(ToIntegral<int32_t>(\"-1\").value(), -1);\n+\n+    BOOST_CHECK(!ToIntegral<int32_t>(\" 1\"));\n+    BOOST_CHECK(!ToIntegral<int32_t>(\"1 \"));\n+    BOOST_CHECK(!ToIntegral<int32_t>(\"1a\"));\n+    BOOST_CHECK(!ToIntegral<int32_t>(\"1.1\"));\n+    BOOST_CHECK(!ToIntegral<int32_t>(\"1.9\"));\n+    BOOST_CHECK(!ToIntegral<int32_t>(\"+01.9\"));\n+    BOOST_CHECK(!ToIntegral<int32_t>(\" -1\"));\n+    BOOST_CHECK(!ToIntegral<int32_t>(\"-1 \"));\n+    BOOST_CHECK(!ToIntegral<int32_t>(\" -1 \"));\n+    BOOST_CHECK(!ToIntegral<int32_t>(\"+1\"));\n+    BOOST_CHECK(!ToIntegral<int32_t>(\" +1\"));\n+    BOOST_CHECK(!ToIntegral<int32_t>(\" +1 \"));\n+    BOOST_CHECK(!ToIntegral<int32_t>(\"+-1\"));\n+    BOOST_CHECK(!ToIntegral<int32_t>(\"-+1\"));\n+    BOOST_CHECK(!ToIntegral<int32_t>(\"++1\"));\n+    BOOST_CHECK(!ToIntegral<int32_t>(\"--1\"));\n+    BOOST_CHECK(!ToIntegral<int32_t>(\"\"));\n+    BOOST_CHECK(!ToIntegral<int32_t>(\"aap\"));\n+    BOOST_CHECK(!ToIntegral<int32_t>(\"0x1\"));\n+    BOOST_CHECK(!ToIntegral<int32_t>(\"-32482348723847471234\"));\n+    BOOST_CHECK(!ToIntegral<int32_t>(\"32482348723847471234\"));\n+\n+    BOOST_CHECK(!ToIntegral<int64_t>(\"-9223372036854775809\"));\n+    BOOST_CHECK_EQUAL(ToIntegral<int64_t>(\"-9223372036854775808\").value(), -9'223'372'036'854'775'807LL - 1LL);\n+    BOOST_CHECK_EQUAL(ToIntegral<int64_t>(\"9223372036854775807\").value(), 9'223'372'036'854'775'807);\n+    BOOST_CHECK(!ToIntegral<int64_t>(\"9223372036854775808\"));\n+\n+    BOOST_CHECK(!ToIntegral<uint64_t>(\"-1\"));\n+    BOOST_CHECK_EQUAL(ToIntegral<uint64_t>(\"0\").value(), 0U);\n+    BOOST_CHECK_EQUAL(ToIntegral<uint64_t>(\"18446744073709551615\").value(), 18'446'744'073'709'551'615ULL);\n+    BOOST_CHECK(!ToIntegral<uint64_t>(\"18446744073709551616\"));\n+\n+    BOOST_CHECK(!ToIntegral<int32_t>(\"-2147483649\"));\n+    BOOST_CHECK_EQUAL(ToIntegral<int32_t>(\"-2147483648\").value(), -2'147'483'648LL);\n+    BOOST_CHECK_EQUAL(ToIntegral<int32_t>(\"2147483647\").value(), 2'147'483'647);\n+    BOOST_CHECK(!ToIntegral<int32_t>(\"2147483648\"));\n+\n+    BOOST_CHECK(!ToIntegral<uint32_t>(\"-1\"));\n+    BOOST_CHECK_EQUAL(ToIntegral<uint32_t>(\"0\").value(), 0U);\n+    BOOST_CHECK_EQUAL(ToIntegral<uint32_t>(\"4294967295\").value(), 4'294'967'295U);\n+    BOOST_CHECK(!ToIntegral<uint32_t>(\"4294967296\"));\n+\n+    BOOST_CHECK(!ToIntegral<int16_t>(\"-32769\"));\n+    BOOST_CHECK_EQUAL(ToIntegral<int16_t>(\"-32768\").value(), -32'768);\n+    BOOST_CHECK_EQUAL(ToIntegral<int16_t>(\"32767\").value(), 32'767);\n+    BOOST_CHECK(!ToIntegral<int16_t>(\"32768\"));\n+\n+    BOOST_CHECK(!ToIntegral<uint16_t>(\"-1\"));\n+    BOOST_CHECK_EQUAL(ToIntegral<uint16_t>(\"0\").value(), 0U);\n+    BOOST_CHECK_EQUAL(ToIntegral<uint16_t>(\"65535\").value(), 65'535U);\n+    BOOST_CHECK(!ToIntegral<uint16_t>(\"65536\"));\n+\n+    BOOST_CHECK(!ToIntegral<int8_t>(\"-129\"));\n+    BOOST_CHECK_EQUAL(ToIntegral<int8_t>(\"-128\").value(), -128);\n+    BOOST_CHECK_EQUAL(ToIntegral<int8_t>(\"127\").value(), 127);\n+    BOOST_CHECK(!ToIntegral<int8_t>(\"128\"));\n+\n+    BOOST_CHECK(!ToIntegral<uint8_t>(\"-1\"));\n+    BOOST_CHECK_EQUAL(ToIntegral<uint8_t>(\"0\").value(), 0U);\n+    BOOST_CHECK_EQUAL(ToIntegral<uint8_t>(\"255\").value(), 255U);\n+    BOOST_CHECK(!ToIntegral<uint8_t>(\"256\"));\n+}\n+\n BOOST_AUTO_TEST_CASE(test_ParseInt64)\n {\n     int64_t n;"
      },
      {
        "sha": "0aa80ea0aeda2ef549be2a025386f28c9a19faec",
        "filename": "src/util/strencodings.cpp",
        "status": "modified",
        "additions": 38,
        "deletions": 72,
        "changes": 110,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4747db876154ddd828c03d9eda10ecf8b25d8dc8/src/util/strencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4747db876154ddd828c03d9eda10ecf8b25d8dc8/src/util/strencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/strencodings.cpp?ref=4747db876154ddd828c03d9eda10ecf8b25d8dc8",
        "patch": "@@ -11,8 +11,7 @@\n #include <algorithm>\n #include <cstdlib>\n #include <cstring>\n-#include <errno.h>\n-#include <limits>\n+#include <optional>\n \n static const std::string CHARS_ALPHA_NUM = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n \n@@ -282,6 +281,32 @@ std::string DecodeBase32(const std::string& str, bool* pf_invalid)\n     return std::string((const char*)vchRet.data(), vchRet.size());\n }\n \n+[[nodiscard]] static bool ParsePrechecks(const std::string&);\n+\n+namespace {\n+template <typename T>\n+bool ParseIntegral(const std::string& str, T* out)\n+{\n+    static_assert(std::is_integral<T>::value);\n+    if (!ParsePrechecks(str)) {\n+        return false;\n+    }\n+    // Replicate the exact behavior of strtol/strtoll/strtoul/strtoull when\n+    // handling leading +/- for backwards compatibility.\n+    if (str.length() >= 2 && str[0] == '+' && str[1] == '-') {\n+        return false;\n+    }\n+    const std::optional<T> opt_int = ToIntegral<T>((!str.empty() && str[0] == '+') ? str.substr(1) : str);\n+    if (!opt_int) {\n+        return false;\n+    }\n+    if (out != nullptr) {\n+        *out = *opt_int;\n+    }\n+    return true;\n+}\n+}; // namespace\n+\n [[nodiscard]] static bool ParsePrechecks(const std::string& str)\n {\n     if (str.empty()) // No empty string allowed\n@@ -293,95 +318,36 @@ std::string DecodeBase32(const std::string& str, bool* pf_invalid)\n     return true;\n }\n \n-bool ParseInt32(const std::string& str, int32_t *out)\n+bool ParseInt32(const std::string& str, int32_t* out)\n {\n-    if (!ParsePrechecks(str))\n-        return false;\n-    char *endp = nullptr;\n-    errno = 0; // strtol will not set errno if valid\n-    long int n = strtol(str.c_str(), &endp, 10);\n-    if(out) *out = (int32_t)n;\n-    // Note that strtol returns a *long int*, so even if strtol doesn't report an over/underflow\n-    // we still have to check that the returned value is within the range of an *int32_t*. On 64-bit\n-    // platforms the size of these types may be different.\n-    return endp && *endp == 0 && !errno &&\n-        n >= std::numeric_limits<int32_t>::min() &&\n-        n <= std::numeric_limits<int32_t>::max();\n+    return ParseIntegral<int32_t>(str, out);\n }\n \n-bool ParseInt64(const std::string& str, int64_t *out)\n+bool ParseInt64(const std::string& str, int64_t* out)\n {\n-    if (!ParsePrechecks(str))\n-        return false;\n-    char *endp = nullptr;\n-    errno = 0; // strtoll will not set errno if valid\n-    long long int n = strtoll(str.c_str(), &endp, 10);\n-    if(out) *out = (int64_t)n;\n-    // Note that strtoll returns a *long long int*, so even if strtol doesn't report an over/underflow\n-    // we still have to check that the returned value is within the range of an *int64_t*.\n-    return endp && *endp == 0 && !errno &&\n-        n >= std::numeric_limits<int64_t>::min() &&\n-        n <= std::numeric_limits<int64_t>::max();\n+    return ParseIntegral<int64_t>(str, out);\n }\n \n-bool ParseUInt8(const std::string& str, uint8_t *out)\n+bool ParseUInt8(const std::string& str, uint8_t* out)\n {\n-    uint32_t u32;\n-    if (!ParseUInt32(str, &u32) || u32 > std::numeric_limits<uint8_t>::max()) {\n-        return false;\n-    }\n-    if (out != nullptr) {\n-        *out = static_cast<uint8_t>(u32);\n-    }\n-    return true;\n+    return ParseIntegral<uint8_t>(str, out);\n }\n \n bool ParseUInt16(const std::string& str, uint16_t* out)\n {\n-    uint32_t u32;\n-    if (!ParseUInt32(str, &u32) || u32 > std::numeric_limits<uint16_t>::max()) {\n-        return false;\n-    }\n-    if (out != nullptr) {\n-        *out = static_cast<uint16_t>(u32);\n-    }\n-    return true;\n+    return ParseIntegral<uint16_t>(str, out);\n }\n \n-bool ParseUInt32(const std::string& str, uint32_t *out)\n+bool ParseUInt32(const std::string& str, uint32_t* out)\n {\n-    if (!ParsePrechecks(str))\n-        return false;\n-    if (str.size() >= 1 && str[0] == '-') // Reject negative values, unfortunately strtoul accepts these by default if they fit in the range\n-        return false;\n-    char *endp = nullptr;\n-    errno = 0; // strtoul will not set errno if valid\n-    unsigned long int n = strtoul(str.c_str(), &endp, 10);\n-    if(out) *out = (uint32_t)n;\n-    // Note that strtoul returns a *unsigned long int*, so even if it doesn't report an over/underflow\n-    // we still have to check that the returned value is within the range of an *uint32_t*. On 64-bit\n-    // platforms the size of these types may be different.\n-    return endp && *endp == 0 && !errno &&\n-        n <= std::numeric_limits<uint32_t>::max();\n+    return ParseIntegral<uint32_t>(str, out);\n }\n \n-bool ParseUInt64(const std::string& str, uint64_t *out)\n+bool ParseUInt64(const std::string& str, uint64_t* out)\n {\n-    if (!ParsePrechecks(str))\n-        return false;\n-    if (str.size() >= 1 && str[0] == '-') // Reject negative values, unfortunately strtoull accepts these by default if they fit in the range\n-        return false;\n-    char *endp = nullptr;\n-    errno = 0; // strtoull will not set errno if valid\n-    unsigned long long int n = strtoull(str.c_str(), &endp, 10);\n-    if(out) *out = (uint64_t)n;\n-    // Note that strtoull returns a *unsigned long long int*, so even if it doesn't report an over/underflow\n-    // we still have to check that the returned value is within the range of an *uint64_t*.\n-    return endp && *endp == 0 && !errno &&\n-        n <= std::numeric_limits<uint64_t>::max();\n+    return ParseIntegral<uint64_t>(str, out);\n }\n \n-\n bool ParseDouble(const std::string& str, double *out)\n {\n     if (!ParsePrechecks(str))"
      },
      {
        "sha": "1217572c45185ca071848b329821c4f0f555bb42",
        "filename": "src/util/strencodings.h",
        "status": "modified",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4747db876154ddd828c03d9eda10ecf8b25d8dc8/src/util/strencodings.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4747db876154ddd828c03d9eda10ecf8b25d8dc8/src/util/strencodings.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/strencodings.h?ref=4747db876154ddd828c03d9eda10ecf8b25d8dc8",
        "patch": "@@ -12,8 +12,10 @@\n #include <attributes.h>\n #include <span.h>\n \n+#include <charconv>\n #include <cstdint>\n #include <iterator>\n+#include <optional>\n #include <string>\n #include <vector>\n \n@@ -94,6 +96,24 @@ constexpr inline bool IsSpace(char c) noexcept {\n     return c == ' ' || c == '\\f' || c == '\\n' || c == '\\r' || c == '\\t' || c == '\\v';\n }\n \n+/**\n+ * Convert string to integral type T.\n+ *\n+ * @returns std::nullopt if the entire string could not be parsed, or if the\n+ *   parsed value is not in the range representable by the type T.\n+ */\n+template <typename T>\n+std::optional<T> ToIntegral(const std::string& str)\n+{\n+    static_assert(std::is_integral<T>::value);\n+    T result;\n+    const auto [first_nonmatching, error_condition] = std::from_chars(str.data(), str.data() + str.size(), result);\n+    if (first_nonmatching != str.data() + str.size() || error_condition != std::errc{}) {\n+        return std::nullopt;\n+    }\n+    return {result};\n+}\n+\n /**\n  * Convert string to signed 32-bit integer with strict parse error feedback.\n  * @returns true if the entire string could be parsed as valid integer,"
      },
      {
        "sha": "fcc4883d0b6c8ebeee01a7a3debbe7af2f91eb6e",
        "filename": "test/lint/lint-locale-dependence.sh",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4747db876154ddd828c03d9eda10ecf8b25d8dc8/test/lint/lint-locale-dependence.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4747db876154ddd828c03d9eda10ecf8b25d8dc8/test/lint/lint-locale-dependence.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-locale-dependence.sh?ref=4747db876154ddd828c03d9eda10ecf8b25d8dc8",
        "patch": "@@ -47,11 +47,11 @@ KNOWN_VIOLATIONS=(\n     \"src/test/dbwrapper_tests.cpp:.*snprintf\"\n     \"src/test/fuzz/locale.cpp\"\n     \"src/test/fuzz/parse_numbers.cpp:.*atoi\"\n+    \"src/test/fuzz/string.cpp\"\n     \"src/torcontrol.cpp:.*atoi\"\n     \"src/torcontrol.cpp:.*strtol\"\n     \"src/util/strencodings.cpp:.*atoi\"\n-    \"src/util/strencodings.cpp:.*strtol\"\n-    \"src/util/strencodings.cpp:.*strtoul\"\n+    \"src/util/strencodings.cpp:.*strtoll\"\n     \"src/util/strencodings.h:.*atoi\"\n     \"src/util/system.cpp:.*atoi\"\n )"
      }
    ]
  }
]