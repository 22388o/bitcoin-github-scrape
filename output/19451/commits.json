[
  {
    "sha": "0a78f225c79decb4a131a7001fbde215c6c60f31",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowYTc4ZjIyNWM3OWRlY2I0YTEzMWE3MDAxZmJkZTIxNWM2YzYwZjMx",
    "commit": {
      "author": {
        "name": "Lowogo",
        "email": "66907636+lowogo@users.noreply.github.com",
        "date": "2020-06-23T01:18:46Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2020-06-23T01:18:46Z"
      },
      "message": "Merge pull request #1 from bitcoin/master\n\nPull",
      "tree": {
        "sha": "c73b104d7fabea1d1de5fee1666ee63e643fab47",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c73b104d7fabea1d1de5fee1666ee63e643fab47"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0a78f225c79decb4a131a7001fbde215c6c60f31",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe8Vh2CRBK7hj4Ov3rIwAAdHIIAK/w5AKIJwbKxbNZc0LD/wTc\nTxZGJ7j3QbySw3BiusjVbpRoukXs3unhARLWSSDqx2POHeLCcJpWTnoYP0ksiOOR\nTRg3Id6bM/4YgTuXWN49b+zV1KXSjjvkOc1vhto5qSHc9sHEoX7TQT6ap66mFtDZ\nlIg2yn2VnOiA5F/FNzH5JXZAr0ogPo/MXT7phJvQBu/JTl1g4PGRSybmfA4aPEb+\nygKBjwkGL4XnE0k+SecPcslsHB3Bn879mj8RqhgvVcvMBI5Pe9bAy3fNzfJrcP4F\nzXY8LDR5zwFttB0fW0y23ujMwBwMRS2ky+RpEHLM5EpUyHOwHXU/eL+k2Oo5JYg=\n=roKj\n-----END PGP SIGNATURE-----\n",
        "payload": "tree c73b104d7fabea1d1de5fee1666ee63e643fab47\nparent d4f9ae00252ba44909a61db0f606be6fddf904c1\nparent e3fa3c7d671e34038a262bb2db16b30bee82153d\nauthor Lowogo <66907636+lowogo@users.noreply.github.com> 1592875126 +0700\ncommitter GitHub <noreply@github.com> 1592875126 +0700\n\nMerge pull request #1 from bitcoin/master\n\nPull"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0a78f225c79decb4a131a7001fbde215c6c60f31",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0a78f225c79decb4a131a7001fbde215c6c60f31",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0a78f225c79decb4a131a7001fbde215c6c60f31/comments",
    "author": {
      "login": "lowogo",
      "id": 66907636,
      "node_id": "MDQ6VXNlcjY2OTA3NjM2",
      "avatar_url": "https://avatars.githubusercontent.com/u/66907636?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lowogo",
      "html_url": "https://github.com/lowogo",
      "followers_url": "https://api.github.com/users/lowogo/followers",
      "following_url": "https://api.github.com/users/lowogo/following{/other_user}",
      "gists_url": "https://api.github.com/users/lowogo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lowogo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lowogo/subscriptions",
      "organizations_url": "https://api.github.com/users/lowogo/orgs",
      "repos_url": "https://api.github.com/users/lowogo/repos",
      "events_url": "https://api.github.com/users/lowogo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lowogo/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d4f9ae00252ba44909a61db0f606be6fddf904c1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d4f9ae00252ba44909a61db0f606be6fddf904c1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d4f9ae00252ba44909a61db0f606be6fddf904c1"
      },
      {
        "sha": "e3fa3c7d671e34038a262bb2db16b30bee82153d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3fa3c7d671e34038a262bb2db16b30bee82153d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e3fa3c7d671e34038a262bb2db16b30bee82153d"
      }
    ],
    "stats": {
      "total": 1622,
      "additions": 1165,
      "deletions": 457
    },
    "files": [
      {
        "sha": "6a3c9f1dc125b9e44fb27b11f4bdab81f12dd5fc",
        "filename": "build_msvc/libbitcoin_qt/libbitcoin_qt.vcxproj",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/build_msvc/libbitcoin_qt/libbitcoin_qt.vcxproj",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/build_msvc/libbitcoin_qt/libbitcoin_qt.vcxproj",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/libbitcoin_qt/libbitcoin_qt.vcxproj?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -35,6 +35,7 @@\n     <ClCompile Include=\"..\\..\\src\\qt\\paymentserver.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\qt\\peertablemodel.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\qt\\platformstyle.cpp\" />\n+    <ClCompile Include=\"..\\..\\src\\qt\\psbtoperationsdialog.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\qt\\qrimagewidget.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\qt\\qvalidatedlineedit.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\qt\\qvaluecombobox.cpp\" />\n@@ -87,6 +88,7 @@\n     <ClCompile Include=\"$(GeneratedFilesOutDir)\\moc\\moc_paymentserver.cpp\" />\n     <ClCompile Include=\"$(GeneratedFilesOutDir)\\moc\\moc_peertablemodel.cpp\" />\n     <ClCompile Include=\"$(GeneratedFilesOutDir)\\moc\\moc_platformstyle.cpp\" />\n+    <ClCompile Include=\"$(GeneratedFilesOutDir)\\moc\\moc_psbtoperationsdialog.cpp\" />\n     <ClCompile Include=\"$(GeneratedFilesOutDir)\\moc\\moc_qrimagewidget.cpp\" />\n     <ClCompile Include=\"$(GeneratedFilesOutDir)\\moc\\moc_qvalidatedlineedit.cpp\" />\n     <ClCompile Include=\"$(GeneratedFilesOutDir)\\moc\\moc_qvaluecombobox.cpp\" />"
      },
      {
        "sha": "3442fa451b3cf851f3cc78721820e1e8a7bb8b8e",
        "filename": "doc/release-notes-16377.md",
        "status": "added",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/doc/release-notes-16377.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/doc/release-notes-16377.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-16377.md?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -0,0 +1,9 @@\n+RPC changes\n+-----------\n+- The `walletcreatefundedpsbt` RPC call will now fail with\n+  `Insufficient funds` when inputs are manually selected but are not enough to cover\n+  the outputs and fee. Additional inputs can automatically be added through the\n+  new `add_inputs` option.\n+\n+- The `fundrawtransaction` RPC now supports `add_inputs` option that when `false`\n+  prevents adding more inputs if necessary and consequently the RPC fails."
      },
      {
        "sha": "4670cb2e75fe35534b76c65c732b2484ac588320",
        "filename": "doc/release-notes-19200.md",
        "status": "added",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/doc/release-notes-19200.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/doc/release-notes-19200.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-19200.md?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -0,0 +1,7 @@\n+## Wallet\n+\n+- Backwards compatibility has been dropped for two `getaddressinfo` RPC\n+  deprecations, as notified in the 0.20 release notes. The deprecated `label`\n+  field has been removed as well as the deprecated `labels` behavior of\n+  returning a JSON object containing `name` and `purpose` key-value pairs. Since\n+  0.20, the `labels` field returns a JSON array of label names. (#19200)"
      },
      {
        "sha": "e73bedfb10273a44119ffdec7d2ed8d59faed7c8",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -45,6 +45,11 @@ wallet versions of Bitcoin Core are generally supported.\n Compatibility\n ==============\n \n+During this release cycle, work has been done to ensure that the codebase is fully\n+compatible with C++17. The intention is to begin using C++17 features starting\n+with the 0.22.0 release. This means that a compiler that supports C++17 will be\n+required to compile 0.22.0.\n+\n Bitcoin Core is supported and extensively tested on operating systems\n using the Linux kernel, macOS 10.12+, and Windows 7 and newer.  Bitcoin\n Core should also work on most other Unix-like systems but is not as"
      },
      {
        "sha": "a8f8565f80638fb38b3052261c0012b712864802",
        "filename": "src/.clang-format",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/.clang-format",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/.clang-format",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/.clang-format?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -1,9 +1,10 @@\n Language:        Cpp\n AccessModifierOffset: -4\n-AlignAfterOpenBracket: false\n+AlignAfterOpenBracket: true\n AlignEscapedNewlinesLeft: true\n AlignTrailingComments: true\n-AllowAllParametersOfDeclarationOnNextLine: false\n+AllowAllArgumentsOnNextLine : true\n+AllowAllParametersOfDeclarationOnNextLine: true\n AllowShortBlocksOnASingleLine: false\n AllowShortCaseLabelsOnASingleLine: true\n AllowShortFunctionsOnASingleLine: All"
      },
      {
        "sha": "632ed3e31fac18c181523da76747ae07f0b75f99",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -184,6 +184,7 @@ BITCOIN_CORE_H = \\\n   reverse_iterator.h \\\n   rpc/blockchain.h \\\n   rpc/client.h \\\n+  rpc/mining.h \\\n   rpc/protocol.h \\\n   rpc/rawtransaction_util.h \\\n   rpc/register.h \\"
      },
      {
        "sha": "1f66516172c238a60062d9339b36ae4a164e7bb9",
        "filename": "src/Makefile.qt.include",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/Makefile.qt.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/Makefile.qt.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qt.include?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -25,6 +25,7 @@ QT_FORMS_UI = \\\n   qt/forms/openuridialog.ui \\\n   qt/forms/optionsdialog.ui \\\n   qt/forms/overviewpage.ui \\\n+  qt/forms/psbtoperationsdialog.ui \\\n   qt/forms/receivecoinsdialog.ui \\\n   qt/forms/receiverequestdialog.ui \\\n   qt/forms/debugwindow.ui \\\n@@ -61,6 +62,7 @@ QT_MOC_CPP = \\\n   qt/moc_overviewpage.cpp \\\n   qt/moc_peertablemodel.cpp \\\n   qt/moc_paymentserver.cpp \\\n+  qt/moc_psbtoperationsdialog.cpp \\\n   qt/moc_qrimagewidget.cpp \\\n   qt/moc_qvalidatedlineedit.cpp \\\n   qt/moc_qvaluecombobox.cpp \\\n@@ -132,6 +134,7 @@ BITCOIN_QT_H = \\\n   qt/paymentserver.h \\\n   qt/peertablemodel.h \\\n   qt/platformstyle.h \\\n+  qt/psbtoperationsdialog.h \\\n   qt/qrimagewidget.h \\\n   qt/qvalidatedlineedit.h \\\n   qt/qvaluecombobox.h \\\n@@ -245,6 +248,7 @@ BITCOIN_QT_WALLET_CPP = \\\n   qt/openuridialog.cpp \\\n   qt/overviewpage.cpp \\\n   qt/paymentserver.cpp \\\n+  qt/psbtoperationsdialog.cpp \\\n   qt/qrimagewidget.cpp \\\n   qt/receivecoinsdialog.cpp \\\n   qt/receiverequestdialog.cpp \\"
      },
      {
        "sha": "f5125f22db6615bcea70287511b4931c8813fc22",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 106,
        "deletions": 32,
        "changes": 138,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -11,6 +11,7 @@\n #include <clientversion.h>\n #include <optional.h>\n #include <rpc/client.h>\n+#include <rpc/mining.h>\n #include <rpc/protocol.h>\n #include <rpc/request.h>\n #include <util/strencodings.h>\n@@ -39,6 +40,9 @@ static const int DEFAULT_HTTP_CLIENT_TIMEOUT=900;\n static const bool DEFAULT_NAMED=false;\n static const int CONTINUE_EXECUTION=-1;\n \n+/** Default number of blocks to generate for RPC generatetoaddress. */\n+static const std::string DEFAULT_NBLOCKS = \"1\";\n+\n static void SetupCliArgs()\n {\n     SetupHelpOptions(gArgs);\n@@ -50,6 +54,7 @@ static void SetupCliArgs()\n     gArgs.AddArg(\"-version\", \"Print version and exit\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-conf=<file>\", strprintf(\"Specify configuration file. Relative paths will be prefixed by datadir location. (default: %s)\", BITCOIN_CONF_FILENAME), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-datadir=<dir>\", \"Specify data directory\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-generate\", strprintf(\"Generate blocks immediately, equivalent to RPC generatenewaddress followed by RPC generatetoaddress. Optional positional integer arguments are number of blocks to generate (default: %s) and maximum iterations to try (default: %s), equivalent to RPC generatetoaddress nblocks and maxtries arguments. Example: bitcoin-cli -generate 4 1000\", DEFAULT_NBLOCKS, DEFAULT_MAX_TRIES), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-getinfo\", \"Get general information from the remote server. Note that unlike server-side RPC calls, the results of -getinfo is the result of multiple non-atomic requests. Some entries in the result may represent results from different states (e.g. wallet balance may be as of a different block from the chain state reported)\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     SetupChainParamsBaseOptions();\n     gArgs.AddArg(\"-named\", strprintf(\"Pass named instead of positional arguments (default: %s)\", DEFAULT_NAMED), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n@@ -286,6 +291,28 @@ class GetinfoRequestHandler: public BaseRequestHandler\n     }\n };\n \n+/** Process RPC generatetoaddress request. */\n+class GenerateToAddressRequestHandler : public BaseRequestHandler\n+{\n+public:\n+    UniValue PrepareRequest(const std::string& method, const std::vector<std::string>& args) override\n+    {\n+        address_str = args.at(1);\n+        UniValue params{RPCConvertValues(\"generatetoaddress\", args)};\n+        return JSONRPCRequestObj(\"generatetoaddress\", params, 1);\n+    }\n+\n+    UniValue ProcessReply(const UniValue &reply) override\n+    {\n+        UniValue result(UniValue::VOBJ);\n+        result.pushKV(\"address\", address_str);\n+        result.pushKV(\"blocks\", reply.get_obj()[\"result\"]);\n+        return JSONRPCReplyObj(result, NullUniValue, 1);\n+    }\n+protected:\n+    std::string address_str;\n+};\n+\n /** Process default single requests */\n class DefaultRequestHandler: public BaseRequestHandler {\n public:\n@@ -453,6 +480,34 @@ static UniValue ConnectAndCallRPC(BaseRequestHandler* rh, const std::string& str\n     return response;\n }\n \n+/** Parse UniValue result to update the message to print to std::cout. */\n+static void ParseResult(const UniValue& result, std::string& strPrint)\n+{\n+    if (result.isNull()) return;\n+    strPrint = result.isStr() ? result.get_str() : result.write(2);\n+}\n+\n+/** Parse UniValue error to update the message to print to std::cerr and the code to return. */\n+static void ParseError(const UniValue& error, std::string& strPrint, int& nRet)\n+{\n+    if (error.isObject()) {\n+        const UniValue& err_code = find_value(error, \"code\");\n+        const UniValue& err_msg = find_value(error, \"message\");\n+        if (!err_code.isNull()) {\n+            strPrint = \"error code: \" + err_code.getValStr() + \"\\n\";\n+        }\n+        if (err_msg.isStr()) {\n+            strPrint += (\"error message:\\n\" + err_msg.get_str());\n+        }\n+        if (err_code.isNum() && err_code.get_int() == RPC_WALLET_NOT_SPECIFIED) {\n+            strPrint += \"\\nTry adding \\\"-rpcwallet=<filename>\\\" option to bitcoin-cli command line.\";\n+        }\n+    } else {\n+        strPrint = \"error: \" + error.write();\n+    }\n+    nRet = abs(error[\"code\"].get_int());\n+}\n+\n /**\n  * GetWalletBalances calls listwallets; if more than one wallet is loaded, it then\n  * fetches mine.trusted balances for each loaded wallet and pushes them to `result`.\n@@ -477,6 +532,34 @@ static void GetWalletBalances(UniValue& result)\n     result.pushKV(\"balances\", balances);\n }\n \n+/**\n+ * Call RPC getnewaddress.\n+ * @returns getnewaddress response as a UniValue object.\n+ */\n+static UniValue GetNewAddress()\n+{\n+    Optional<std::string> wallet_name{};\n+    if (gArgs.IsArgSet(\"-rpcwallet\")) wallet_name = gArgs.GetArg(\"-rpcwallet\", \"\");\n+    std::unique_ptr<BaseRequestHandler> rh{MakeUnique<DefaultRequestHandler>()};\n+    return ConnectAndCallRPC(rh.get(), \"getnewaddress\", /* args=*/{}, wallet_name);\n+}\n+\n+/**\n+ * Check bounds and set up args for RPC generatetoaddress params: nblocks, address, maxtries.\n+ * @param[in] address  Reference to const string address to insert into the args.\n+ * @param     args     Reference to vector of string args to modify.\n+ */\n+static void SetGenerateToAddressArgs(const std::string& address, std::vector<std::string>& args)\n+{\n+    if (args.size() > 2) throw std::runtime_error(\"too many arguments (maximum 2 for nblocks and maxtries)\");\n+    if (args.size() == 0) {\n+        args.emplace_back(DEFAULT_NBLOCKS);\n+    } else if (args.at(0) == \"0\") {\n+        throw std::runtime_error(\"the first argument (number of blocks to generate, default: \" + DEFAULT_NBLOCKS + \") must be an integer value greater than zero\");\n+    }\n+    args.emplace(args.begin() + 1, address);\n+}\n+\n static int CommandLineRPC(int argc, char *argv[])\n {\n     std::string strPrint;\n@@ -535,6 +618,15 @@ static int CommandLineRPC(int argc, char *argv[])\n         std::string method;\n         if (gArgs.IsArgSet(\"-getinfo\")) {\n             rh.reset(new GetinfoRequestHandler());\n+        } else if (gArgs.GetBoolArg(\"-generate\", false)) {\n+            const UniValue getnewaddress{GetNewAddress()};\n+            const UniValue& error{find_value(getnewaddress, \"error\")};\n+            if (error.isNull()) {\n+                SetGenerateToAddressArgs(find_value(getnewaddress, \"result\").get_str(), args);\n+                rh.reset(new GenerateToAddressRequestHandler());\n+            } else {\n+                ParseError(error, strPrint, nRet);\n+            }\n         } else {\n             rh.reset(new DefaultRequestHandler());\n             if (args.size() < 1) {\n@@ -543,40 +635,22 @@ static int CommandLineRPC(int argc, char *argv[])\n             method = args[0];\n             args.erase(args.begin()); // Remove trailing method name from arguments vector\n         }\n-        Optional<std::string> wallet_name{};\n-        if (gArgs.IsArgSet(\"-rpcwallet\")) wallet_name = gArgs.GetArg(\"-rpcwallet\", \"\");\n-        const UniValue reply = ConnectAndCallRPC(rh.get(), method, args, wallet_name);\n-\n-        // Parse reply\n-        UniValue result = find_value(reply, \"result\");\n-        const UniValue& error = find_value(reply, \"error\");\n-        if (!error.isNull()) {\n-            // Error\n-            strPrint = \"error: \" + error.write();\n-            nRet = abs(error[\"code\"].get_int());\n-            if (error.isObject()) {\n-                const UniValue& errCode = find_value(error, \"code\");\n-                const UniValue& errMsg = find_value(error, \"message\");\n-                strPrint = errCode.isNull() ? \"\" : (\"error code: \" + errCode.getValStr() + \"\\n\");\n-\n-                if (errMsg.isStr()) {\n-                    strPrint += (\"error message:\\n\" + errMsg.get_str());\n-                }\n-                if (errCode.isNum() && errCode.get_int() == RPC_WALLET_NOT_SPECIFIED) {\n-                    strPrint += \"\\nTry adding \\\"-rpcwallet=<filename>\\\" option to bitcoin-cli command line.\";\n+        if (nRet == 0) {\n+            // Perform RPC call\n+            Optional<std::string> wallet_name{};\n+            if (gArgs.IsArgSet(\"-rpcwallet\")) wallet_name = gArgs.GetArg(\"-rpcwallet\", \"\");\n+            const UniValue reply = ConnectAndCallRPC(rh.get(), method, args, wallet_name);\n+\n+            // Parse reply\n+            UniValue result = find_value(reply, \"result\");\n+            const UniValue& error = find_value(reply, \"error\");\n+            if (error.isNull()) {\n+                if (gArgs.IsArgSet(\"-getinfo\") && !gArgs.IsArgSet(\"-rpcwallet\")) {\n+                    GetWalletBalances(result); // fetch multiwallet balances and append to result\n                 }\n-            }\n-        } else {\n-            if (gArgs.IsArgSet(\"-getinfo\") && !gArgs.IsArgSet(\"-rpcwallet\")) {\n-                GetWalletBalances(result); // fetch multiwallet balances and append to result\n-            }\n-            // Result\n-            if (result.isNull()) {\n-                strPrint = \"\";\n-            } else if (result.isStr()) {\n-                strPrint = result.get_str();\n+                ParseResult(result, strPrint);\n             } else {\n-                strPrint = result.write(2);\n+                ParseError(error, strPrint, nRet);\n             }\n         }\n     } catch (const std::exception& e) {"
      },
      {
        "sha": "b65eb72b1ccf94d26091606d277f8fb258f12edf",
        "filename": "src/interfaces/wallet.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/interfaces/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/interfaces/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/wallet.cpp?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -335,9 +335,10 @@ class WalletImpl : public Wallet\n         bool sign,\n         bool bip32derivs,\n         PartiallySignedTransaction& psbtx,\n-        bool& complete) override\n+        bool& complete,\n+        size_t* n_signed) override\n     {\n-        return m_wallet->FillPSBT(psbtx, complete, sighash_type, sign, bip32derivs);\n+        return m_wallet->FillPSBT(psbtx, complete, sighash_type, sign, bip32derivs, n_signed);\n     }\n     WalletBalances getBalances() override\n     {"
      },
      {
        "sha": "e2161521f6662e015feef6a6d363ebd958ea5a56",
        "filename": "src/interfaces/wallet.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/interfaces/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/interfaces/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/wallet.h?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -197,7 +197,8 @@ class Wallet\n         bool sign,\n         bool bip32derivs,\n         PartiallySignedTransaction& psbtx,\n-        bool& complete) = 0;\n+        bool& complete,\n+        size_t* n_signed) = 0;\n \n     //! Get balances.\n     virtual WalletBalances getBalances() = 0;"
      },
      {
        "sha": "270e415e4205cb079af95b1c523f8a938abfbf0e",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -4387,9 +4387,9 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n         //\n         // Message: feefilter\n         //\n-        // We don't want white listed peers to filter txs to us if we have -whitelistforcerelay\n         if (pto->m_tx_relay != nullptr && pto->nVersion >= FEEFILTER_VERSION && gArgs.GetBoolArg(\"-feefilter\", DEFAULT_FEEFILTER) &&\n-            !pto->HasPermission(PF_FORCERELAY)) {\n+            !pto->HasPermission(PF_FORCERELAY) // peers with the forcerelay permission should not filter txs to us\n+        ) {\n             CAmount currentFilter = m_mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFeePerK();\n             int64_t timeNow = GetTimeMicros();\n             if (timeNow > pto->m_tx_relay->nextSendTimeFeeFilter) {"
      },
      {
        "sha": "871474d56e77436da0c47cb8f94b8332c5edadef",
        "filename": "src/outputtype.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/outputtype.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/outputtype.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/outputtype.cpp?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -53,7 +53,7 @@ CTxDestination GetDestinationForKey(const CPubKey& key, OutputType type)\n     case OutputType::P2SH_SEGWIT:\n     case OutputType::BECH32: {\n         if (!key.IsCompressed()) return PKHash(key);\n-        CTxDestination witdest = WitnessV0KeyHash(PKHash(key));\n+        CTxDestination witdest = WitnessV0KeyHash(key);\n         CScript witprog = GetScriptForDestination(witdest);\n         if (type == OutputType::P2SH_SEGWIT) {\n             return ScriptHash(witprog);"
      },
      {
        "sha": "10260740f0d202b172dd1c6bf98a34bc5011574f",
        "filename": "src/psbt.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/psbt.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/psbt.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/psbt.cpp?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -214,6 +214,17 @@ bool PSBTInputSigned(const PSBTInput& input)\n     return !input.final_script_sig.empty() || !input.final_script_witness.IsNull();\n }\n \n+size_t CountPSBTUnsignedInputs(const PartiallySignedTransaction& psbt) {\n+    size_t count = 0;\n+    for (const auto& input : psbt.inputs) {\n+        if (!PSBTInputSigned(input)) {\n+            count++;\n+        }\n+    }\n+\n+    return count;\n+}\n+\n void UpdatePSBTOutput(const SigningProvider& provider, PartiallySignedTransaction& psbt, int index)\n {\n     const CTxOut& out = psbt.tx->vout.at(index);"
      },
      {
        "sha": "0a8ea2ea0b144ea308982963aabf6e5adcbed5c7",
        "filename": "src/psbt.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/psbt.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/psbt.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/psbt.h?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -579,6 +579,9 @@ bool PSBTInputSigned(const PSBTInput& input);\n /** Signs a PSBTInput, verifying that all provided data matches what is being signed. */\n bool SignPSBTInput(const SigningProvider& provider, PartiallySignedTransaction& psbt, int index, int sighash = SIGHASH_ALL, SignatureData* out_sigdata = nullptr, bool use_dummy = false);\n \n+/** Counts the unsigned inputs of a PSBT. */\n+size_t CountPSBTUnsignedInputs(const PartiallySignedTransaction& psbt);\n+\n /** Updates a PSBTOutput with information from provider.\n  *\n  * This fills in the redeem_script, witness_script, and hd_keypaths where possible."
      },
      {
        "sha": "b4182e85242d44685e33ae5fafe41771db0da8c8",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 3,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -321,8 +321,10 @@ void BitcoinGUI::createActions()\n     signMessageAction->setStatusTip(tr(\"Sign messages with your Bitcoin addresses to prove you own them\"));\n     verifyMessageAction = new QAction(tr(\"&Verify message...\"), this);\n     verifyMessageAction->setStatusTip(tr(\"Verify messages to ensure they were signed with specified Bitcoin addresses\"));\n-    m_load_psbt_action = new QAction(tr(\"Load PSBT...\"), this);\n+    m_load_psbt_action = new QAction(tr(\"&Load PSBT from file...\"), this);\n     m_load_psbt_action->setStatusTip(tr(\"Load Partially Signed Bitcoin Transaction\"));\n+    m_load_psbt_clipboard_action = new QAction(tr(\"Load PSBT from clipboard...\"), this);\n+    m_load_psbt_clipboard_action->setStatusTip(tr(\"Load Partially Signed Bitcoin Transaction from clipboard\"));\n \n     openRPCConsoleAction = new QAction(tr(\"Node window\"), this);\n     openRPCConsoleAction->setStatusTip(tr(\"Open node debugging and diagnostic console\"));\n@@ -381,6 +383,7 @@ void BitcoinGUI::createActions()\n         connect(signMessageAction, &QAction::triggered, [this]{ showNormalIfMinimized(); });\n         connect(signMessageAction, &QAction::triggered, [this]{ gotoSignMessageTab(); });\n         connect(m_load_psbt_action, &QAction::triggered, [this]{ gotoLoadPSBT(); });\n+        connect(m_load_psbt_clipboard_action, &QAction::triggered, [this]{ gotoLoadPSBT(true); });\n         connect(verifyMessageAction, &QAction::triggered, [this]{ showNormalIfMinimized(); });\n         connect(verifyMessageAction, &QAction::triggered, [this]{ gotoVerifyMessageTab(); });\n         connect(usedSendingAddressesAction, &QAction::triggered, walletFrame, &WalletFrame::usedSendingAddresses);\n@@ -459,6 +462,7 @@ void BitcoinGUI::createMenuBar()\n         file->addAction(signMessageAction);\n         file->addAction(verifyMessageAction);\n         file->addAction(m_load_psbt_action);\n+        file->addAction(m_load_psbt_clipboard_action);\n         file->addSeparator();\n     }\n     file->addAction(quitAction);\n@@ -878,9 +882,9 @@ void BitcoinGUI::gotoVerifyMessageTab(QString addr)\n {\n     if (walletFrame) walletFrame->gotoVerifyMessageTab(addr);\n }\n-void BitcoinGUI::gotoLoadPSBT()\n+void BitcoinGUI::gotoLoadPSBT(bool from_clipboard)\n {\n-    if (walletFrame) walletFrame->gotoLoadPSBT();\n+    if (walletFrame) walletFrame->gotoLoadPSBT(from_clipboard);\n }\n #endif // ENABLE_WALLET\n "
      },
      {
        "sha": "697e83e77218d987cf077c8d51e028cd12fee81a",
        "filename": "src/qt/bitcoingui.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/qt/bitcoingui.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/qt/bitcoingui.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.h?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -139,6 +139,7 @@ class BitcoinGUI : public QMainWindow\n     QAction* signMessageAction = nullptr;\n     QAction* verifyMessageAction = nullptr;\n     QAction* m_load_psbt_action = nullptr;\n+    QAction* m_load_psbt_clipboard_action = nullptr;\n     QAction* aboutAction = nullptr;\n     QAction* receiveCoinsAction = nullptr;\n     QAction* receiveCoinsMenuAction = nullptr;\n@@ -278,8 +279,8 @@ public Q_SLOTS:\n     void gotoSignMessageTab(QString addr = \"\");\n     /** Show Sign/Verify Message dialog and switch to verify message tab */\n     void gotoVerifyMessageTab(QString addr = \"\");\n-    /** Show load Partially Signed Bitcoin Transaction dialog */\n-    void gotoLoadPSBT();\n+    /** Load Partially Signed Bitcoin Transaction from file or clipboard */\n+    void gotoLoadPSBT(bool from_clipboard = false);\n \n     /** Show open dialog */\n     void openClicked();"
      },
      {
        "sha": "7c72858501c59357ae980108b11fbd25aa4c139e",
        "filename": "src/qt/coincontroldialog.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/qt/coincontroldialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/qt/coincontroldialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroldialog.cpp?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -456,7 +456,7 @@ void CoinControlDialog::updateLabels(CCoinControl& m_coin_control, WalletModel *\n         {\n             CPubKey pubkey;\n             PKHash *pkhash = boost::get<PKHash>(&address);\n-            if (pkhash && model->wallet().getPubKey(out.txout.scriptPubKey, CKeyID(*pkhash), pubkey))\n+            if (pkhash && model->wallet().getPubKey(out.txout.scriptPubKey, ToKeyID(*pkhash), pubkey))\n             {\n                 nBytesInputs += (pubkey.IsCompressed() ? 148 : 180);\n             }"
      },
      {
        "sha": "c2e2f5035bde4de09d36c87eac76ba50b2be2c4e",
        "filename": "src/qt/forms/psbtoperationsdialog.ui",
        "status": "added",
        "additions": 148,
        "deletions": 0,
        "changes": 148,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/qt/forms/psbtoperationsdialog.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/qt/forms/psbtoperationsdialog.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/psbtoperationsdialog.ui?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -0,0 +1,148 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<ui version=\"4.0\">\n+ <class>PSBTOperationsDialog</class>\n+ <widget class=\"QDialog\" name=\"PSBTOperationsDialog\">\n+  <property name=\"geometry\">\n+   <rect>\n+    <x>0</x>\n+    <y>0</y>\n+    <width>585</width>\n+    <height>327</height>\n+   </rect>\n+  </property>\n+  <property name=\"windowTitle\">\n+   <string>Dialog</string>\n+  </property>\n+  <layout class=\"QVBoxLayout\" name=\"verticalLayout\">\n+   <property name=\"spacing\">\n+    <number>12</number>\n+   </property>\n+   <property name=\"sizeConstraint\">\n+    <enum>QLayout::SetDefaultConstraint</enum>\n+   </property>\n+   <property name=\"bottomMargin\">\n+    <number>12</number>\n+   </property>\n+   <item>\n+    <layout class=\"QVBoxLayout\" name=\"mainDialogLayout\">\n+     <property name=\"spacing\">\n+      <number>5</number>\n+     </property>\n+     <property name=\"topMargin\">\n+      <number>0</number>\n+     </property>\n+     <property name=\"bottomMargin\">\n+      <number>0</number>\n+     </property>\n+     <item>\n+      <widget class=\"QLabel\" name=\"statusBar\">\n+       <property name=\"font\">\n+        <font>\n+         <weight>75</weight>\n+         <bold>true</bold>\n+        </font>\n+       </property>\n+       <property name=\"autoFillBackground\">\n+        <bool>false</bool>\n+       </property>\n+       <property name=\"styleSheet\">\n+        <string notr=\"true\"/>\n+       </property>\n+       <property name=\"text\">\n+        <string/>\n+       </property>\n+      </widget>\n+     </item>\n+     <item>\n+      <widget class=\"QTextEdit\" name=\"transactionDescription\">\n+       <property name=\"undoRedoEnabled\">\n+        <bool>false</bool>\n+       </property>\n+       <property name=\"readOnly\">\n+        <bool>true</bool>\n+       </property>\n+      </widget>\n+     </item>\n+     <item>\n+      <layout class=\"QHBoxLayout\" name=\"buttonRowLayout\">\n+       <property name=\"spacing\">\n+        <number>5</number>\n+       </property>\n+       <item>\n+        <widget class=\"QPushButton\" name=\"signTransactionButton\">\n+         <property name=\"sizePolicy\">\n+          <sizepolicy hsizetype=\"Minimum\" vsizetype=\"Fixed\">\n+           <horstretch>0</horstretch>\n+           <verstretch>0</verstretch>\n+          </sizepolicy>\n+         </property>\n+         <property name=\"font\">\n+          <font>\n+           <weight>50</weight>\n+           <bold>false</bold>\n+          </font>\n+         </property>\n+         <property name=\"text\">\n+          <string>Sign Tx</string>\n+         </property>\n+         <property name=\"autoDefault\">\n+          <bool>true</bool>\n+         </property>\n+         <property name=\"default\">\n+          <bool>false</bool>\n+         </property>\n+         <property name=\"flat\">\n+          <bool>false</bool>\n+         </property>\n+        </widget>\n+       </item>\n+       <item>\n+        <widget class=\"QPushButton\" name=\"broadcastTransactionButton\">\n+         <property name=\"text\">\n+          <string>Broadcast Tx</string>\n+         </property>\n+        </widget>\n+       </item>\n+       <item>\n+        <spacer name=\"horizontalSpacer\">\n+         <property name=\"orientation\">\n+          <enum>Qt::Horizontal</enum>\n+         </property>\n+         <property name=\"sizeHint\" stdset=\"0\">\n+          <size>\n+           <width>40</width>\n+           <height>20</height>\n+          </size>\n+         </property>\n+        </spacer>\n+       </item>\n+       <item>\n+        <widget class=\"QPushButton\" name=\"copyToClipboardButton\">\n+         <property name=\"text\">\n+          <string>Copy to Clipboard</string>\n+         </property>\n+        </widget>\n+       </item>\n+       <item>\n+        <widget class=\"QPushButton\" name=\"saveButton\">\n+         <property name=\"text\">\n+          <string>Save...</string>\n+         </property>\n+        </widget>\n+       </item>\n+       <item>\n+        <widget class=\"QPushButton\" name=\"closeButton\">\n+         <property name=\"text\">\n+          <string>Close</string>\n+         </property>\n+        </widget>\n+       </item>\n+      </layout>\n+     </item>\n+    </layout>\n+   </item>\n+  </layout>\n+ </widget>\n+ <resources/>\n+ <connections/>\n+</ui>"
      },
      {
        "sha": "58167d4bb45941902fac3549a9cce6cb51cdc69e",
        "filename": "src/qt/psbtoperationsdialog.cpp",
        "status": "added",
        "additions": 268,
        "deletions": 0,
        "changes": 268,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/qt/psbtoperationsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/qt/psbtoperationsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/psbtoperationsdialog.cpp?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -0,0 +1,268 @@\n+// Copyright (c) 2011-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <qt/psbtoperationsdialog.h>\n+\n+#include <core_io.h>\n+#include <interfaces/node.h>\n+#include <key_io.h>\n+#include <node/psbt.h>\n+#include <policy/policy.h>\n+#include <qt/bitcoinunits.h>\n+#include <qt/forms/ui_psbtoperationsdialog.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <util/strencodings.h>\n+\n+#include <iostream>\n+\n+\n+PSBTOperationsDialog::PSBTOperationsDialog(\n+    QWidget* parent, WalletModel* wallet_model, ClientModel* client_model) : QDialog(parent),\n+                                                                             m_ui(new Ui::PSBTOperationsDialog),\n+                                                                             m_wallet_model(wallet_model),\n+                                                                             m_client_model(client_model)\n+{\n+    m_ui->setupUi(this);\n+    setWindowTitle(\"PSBT Operations\");\n+\n+    connect(m_ui->signTransactionButton, &QPushButton::clicked, this, &PSBTOperationsDialog::signTransaction);\n+    connect(m_ui->broadcastTransactionButton, &QPushButton::clicked, this, &PSBTOperationsDialog::broadcastTransaction);\n+    connect(m_ui->copyToClipboardButton, &QPushButton::clicked, this, &PSBTOperationsDialog::copyToClipboard);\n+    connect(m_ui->saveButton, &QPushButton::clicked, this, &PSBTOperationsDialog::saveTransaction);\n+\n+    connect(m_ui->closeButton, &QPushButton::clicked, this, &PSBTOperationsDialog::close);\n+\n+    m_ui->signTransactionButton->setEnabled(false);\n+    m_ui->broadcastTransactionButton->setEnabled(false);\n+}\n+\n+PSBTOperationsDialog::~PSBTOperationsDialog()\n+{\n+    delete m_ui;\n+}\n+\n+void PSBTOperationsDialog::openWithPSBT(PartiallySignedTransaction psbtx)\n+{\n+    m_transaction_data = psbtx;\n+\n+    bool complete;\n+    size_t n_could_sign;\n+    FinalizePSBT(psbtx);  // Make sure all existing signatures are fully combined before checking for completeness.\n+    TransactionError err = m_wallet_model->wallet().fillPSBT(SIGHASH_ALL, false /* sign */, true /* bip32derivs */,  m_transaction_data, complete, &n_could_sign);\n+    if (err != TransactionError::OK) {\n+        showStatus(tr(\"Failed to load transaction: %1\")\n+            .arg(QString::fromStdString(TransactionErrorString(err).translated)), StatusLevel::ERR);\n+        return;\n+    }\n+\n+    m_ui->broadcastTransactionButton->setEnabled(complete);\n+    m_ui->signTransactionButton->setEnabled(!complete && !m_wallet_model->wallet().privateKeysDisabled() && n_could_sign > 0);\n+\n+    updateTransactionDisplay();\n+}\n+\n+void PSBTOperationsDialog::signTransaction()\n+{\n+    bool complete;\n+    size_t n_signed;\n+    TransactionError err = m_wallet_model->wallet().fillPSBT(SIGHASH_ALL, true /* sign */, true /* bip32derivs */, m_transaction_data, complete, &n_signed);\n+\n+    if (err != TransactionError::OK) {\n+        showStatus(tr(\"Failed to sign transaction: %1\")\n+            .arg(QString::fromStdString(TransactionErrorString(err).translated)), StatusLevel::ERR);\n+        return;\n+    }\n+\n+    updateTransactionDisplay();\n+\n+    if (!complete && n_signed < 1) {\n+        showStatus(tr(\"Could not sign any more inputs.\"), StatusLevel::WARN);\n+    } else if (!complete) {\n+        showStatus(tr(\"Signed %1 inputs, but more signatures are still required.\").arg(n_signed),\n+            StatusLevel::INFO);\n+    } else {\n+        showStatus(tr(\"Signed transaction successfully. Transaction is ready to broadcast.\"),\n+            StatusLevel::INFO);\n+        m_ui->broadcastTransactionButton->setEnabled(true);\n+    }\n+}\n+\n+void PSBTOperationsDialog::broadcastTransaction()\n+{\n+    CMutableTransaction mtx;\n+    if (!FinalizeAndExtractPSBT(m_transaction_data, mtx)) {\n+        // This is never expected to fail unless we were given a malformed PSBT\n+        // (e.g. with an invalid signature.)\n+        showStatus(tr(\"Unknown error processing transaction.\"), StatusLevel::ERR);\n+        return;\n+    }\n+\n+    CTransactionRef tx = MakeTransactionRef(mtx);\n+    std::string err_string;\n+    TransactionError error = BroadcastTransaction(\n+        *m_client_model->node().context(), tx, err_string, DEFAULT_MAX_RAW_TX_FEE_RATE.GetFeePerK(), /* relay */ true, /* await_callback */ false);\n+\n+    if (error == TransactionError::OK) {\n+        showStatus(tr(\"Transaction broadcast successfully! Transaction ID: %1\")\n+            .arg(QString::fromStdString(tx->GetHash().GetHex())), StatusLevel::INFO);\n+    } else {\n+        showStatus(tr(\"Transaction broadcast failed: %1\")\n+            .arg(QString::fromStdString(TransactionErrorString(error).translated)), StatusLevel::ERR);\n+    }\n+}\n+\n+void PSBTOperationsDialog::copyToClipboard() {\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << m_transaction_data;\n+    GUIUtil::setClipboard(EncodeBase64(ssTx.str()).c_str());\n+    showStatus(tr(\"PSBT copied to clipboard.\"), StatusLevel::INFO);\n+}\n+\n+void PSBTOperationsDialog::saveTransaction() {\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << m_transaction_data;\n+\n+    QString selected_filter;\n+    QString filename_suggestion = \"\";\n+    bool first = true;\n+    for (const CTxOut& out : m_transaction_data.tx->vout) {\n+        if (!first) {\n+            filename_suggestion.append(\"-\");\n+        }\n+        CTxDestination address;\n+        ExtractDestination(out.scriptPubKey, address);\n+        QString amount = BitcoinUnits::format(m_wallet_model->getOptionsModel()->getDisplayUnit(), out.nValue);\n+        QString address_str = QString::fromStdString(EncodeDestination(address));\n+        filename_suggestion.append(address_str + \"-\" + amount);\n+        first = false;\n+    }\n+    filename_suggestion.append(\".psbt\");\n+    QString filename = GUIUtil::getSaveFileName(this,\n+        tr(\"Save Transaction Data\"), filename_suggestion,\n+        tr(\"Partially Signed Transaction (Binary) (*.psbt)\"), &selected_filter);\n+    if (filename.isEmpty()) {\n+        return;\n+    }\n+    std::ofstream out(filename.toLocal8Bit().data());\n+    out << ssTx.str();\n+    out.close();\n+    showStatus(tr(\"PSBT saved to disk.\"), StatusLevel::INFO);\n+}\n+\n+void PSBTOperationsDialog::updateTransactionDisplay() {\n+    m_ui->transactionDescription->setText(QString::fromStdString(renderTransaction(m_transaction_data)));\n+    showTransactionStatus(m_transaction_data);\n+}\n+\n+std::string PSBTOperationsDialog::renderTransaction(const PartiallySignedTransaction &psbtx)\n+{\n+    QString tx_description = \"\";\n+    CAmount totalAmount = 0;\n+    for (const CTxOut& out : psbtx.tx->vout) {\n+        CTxDestination address;\n+        ExtractDestination(out.scriptPubKey, address);\n+        totalAmount += out.nValue;\n+        tx_description.append(tr(\" * Sends %1 to %2\")\n+            .arg(BitcoinUnits::formatWithUnit(BitcoinUnits::BTC, out.nValue))\n+            .arg(QString::fromStdString(EncodeDestination(address))));\n+        tx_description.append(\"<br>\");\n+    }\n+\n+    PSBTAnalysis analysis = AnalyzePSBT(psbtx);\n+    tx_description.append(\" * \");\n+    if (!*analysis.fee) {\n+        // This happens if the transaction is missing input UTXO information.\n+        tx_description.append(tr(\"Unable to calculate transaction fee or total transaction amount.\"));\n+    } else {\n+        tx_description.append(tr(\"Pays transaction fee: \"));\n+        tx_description.append(BitcoinUnits::formatWithUnit(BitcoinUnits::BTC, *analysis.fee));\n+\n+        // add total amount in all subdivision units\n+        tx_description.append(\"<hr />\");\n+        QStringList alternativeUnits;\n+        for (const BitcoinUnits::Unit u : BitcoinUnits::availableUnits())\n+        {\n+            if(u != m_client_model->getOptionsModel()->getDisplayUnit()) {\n+                alternativeUnits.append(BitcoinUnits::formatHtmlWithUnit(u, totalAmount));\n+            }\n+        }\n+        tx_description.append(QString(\"<b>%1</b>: <b>%2</b>\").arg(tr(\"Total Amount\"))\n+            .arg(BitcoinUnits::formatHtmlWithUnit(m_client_model->getOptionsModel()->getDisplayUnit(), totalAmount)));\n+        tx_description.append(QString(\"<br /><span style='font-size:10pt; font-weight:normal;'>(=%1)</span>\")\n+            .arg(alternativeUnits.join(\" \" + tr(\"or\") + \" \")));\n+    }\n+\n+    size_t num_unsigned = CountPSBTUnsignedInputs(psbtx);\n+    if (num_unsigned > 0) {\n+        tx_description.append(\"<br><br>\");\n+        tx_description.append(tr(\"Transaction has %1 unsigned inputs.\").arg(QString::number(num_unsigned)));\n+    }\n+\n+    return tx_description.toStdString();\n+}\n+\n+void PSBTOperationsDialog::showStatus(const QString &msg, StatusLevel level) {\n+    m_ui->statusBar->setText(msg);\n+    switch (level) {\n+        case StatusLevel::INFO: {\n+            m_ui->statusBar->setStyleSheet(\"QLabel { background-color : lightgreen }\");\n+            break;\n+        }\n+        case StatusLevel::WARN: {\n+            m_ui->statusBar->setStyleSheet(\"QLabel { background-color : orange }\");\n+            break;\n+        }\n+        case StatusLevel::ERR: {\n+            m_ui->statusBar->setStyleSheet(\"QLabel { background-color : red }\");\n+            break;\n+        }\n+    }\n+    m_ui->statusBar->show();\n+}\n+\n+size_t PSBTOperationsDialog::couldSignInputs(const PartiallySignedTransaction &psbtx) {\n+    size_t n_signed;\n+    bool complete;\n+    TransactionError err = m_wallet_model->wallet().fillPSBT(SIGHASH_ALL, false /* sign */, false /* bip32derivs */, m_transaction_data, complete, &n_signed);\n+\n+    if (err != TransactionError::OK) {\n+        return 0;\n+    }\n+    return n_signed;\n+}\n+\n+void PSBTOperationsDialog::showTransactionStatus(const PartiallySignedTransaction &psbtx) {\n+    PSBTAnalysis analysis = AnalyzePSBT(psbtx);\n+    size_t n_could_sign = couldSignInputs(psbtx);\n+\n+    switch (analysis.next) {\n+        case PSBTRole::UPDATER: {\n+            showStatus(tr(\"Transaction is missing some information about inputs.\"), StatusLevel::WARN);\n+            break;\n+        }\n+        case PSBTRole::SIGNER: {\n+            QString need_sig_text = tr(\"Transaction still needs signature(s).\");\n+            StatusLevel level = StatusLevel::INFO;\n+            if (m_wallet_model->wallet().privateKeysDisabled()) {\n+                need_sig_text += \" \" + tr(\"(But this wallet cannot sign transactions.)\");\n+                level = StatusLevel::WARN;\n+            } else if (n_could_sign < 1) {\n+                need_sig_text += \" \" + tr(\"(But this wallet does not have the right keys.)\"); // XXX wording\n+                level = StatusLevel::WARN;\n+            }\n+            showStatus(need_sig_text, level);\n+            break;\n+        }\n+        case PSBTRole::FINALIZER:\n+        case PSBTRole::EXTRACTOR: {\n+            showStatus(tr(\"Transaction is fully signed and ready for broadcast.\"), StatusLevel::INFO);\n+            break;\n+        }\n+        default: {\n+            showStatus(tr(\"Transaction status is unknown.\"), StatusLevel::ERR);\n+            break;\n+        }\n+    }\n+}"
      },
      {
        "sha": "f37bdbe39a3cc13252045cc04df638d7d38c1b48",
        "filename": "src/qt/psbtoperationsdialog.h",
        "status": "added",
        "additions": 54,
        "deletions": 0,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/qt/psbtoperationsdialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/qt/psbtoperationsdialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/psbtoperationsdialog.h?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -0,0 +1,54 @@\n+// Copyright (c) 2011-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_QT_PSBTOPERATIONSDIALOG_H\n+#define BITCOIN_QT_PSBTOPERATIONSDIALOG_H\n+\n+#include <QDialog>\n+\n+#include <psbt.h>\n+#include <qt/clientmodel.h>\n+#include <qt/walletmodel.h>\n+\n+namespace Ui {\n+class PSBTOperationsDialog;\n+}\n+\n+/** Dialog showing transaction details. */\n+class PSBTOperationsDialog : public QDialog\n+{\n+    Q_OBJECT\n+\n+public:\n+    explicit PSBTOperationsDialog(QWidget* parent, WalletModel* walletModel, ClientModel* clientModel);\n+    ~PSBTOperationsDialog();\n+\n+    void openWithPSBT(PartiallySignedTransaction psbtx);\n+\n+public Q_SLOTS:\n+    void signTransaction();\n+    void broadcastTransaction();\n+    void copyToClipboard();\n+    void saveTransaction();\n+\n+private:\n+    Ui::PSBTOperationsDialog* m_ui;\n+    PartiallySignedTransaction m_transaction_data;\n+    WalletModel* m_wallet_model;\n+    ClientModel* m_client_model;\n+\n+    enum class StatusLevel {\n+        INFO,\n+        WARN,\n+        ERR\n+    };\n+\n+    size_t couldSignInputs(const PartiallySignedTransaction &psbtx);\n+    void updateTransactionDisplay();\n+    std::string renderTransaction(const PartiallySignedTransaction &psbtx);\n+    void showStatus(const QString &msg, StatusLevel level);\n+    void showTransactionStatus(const PartiallySignedTransaction &psbtx);\n+};\n+\n+#endif // BITCOIN_QT_PSBTOPERATIONSDIALOG_H"
      },
      {
        "sha": "0ac61f3adc02384121e81ebc4f99d91ee07b7525",
        "filename": "src/qt/sendcoinsdialog.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/qt/sendcoinsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/qt/sendcoinsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.cpp?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -392,7 +392,7 @@ void SendCoinsDialog::on_sendButton_clicked()\n         CMutableTransaction mtx = CMutableTransaction{*(m_current_transaction->getWtx())};\n         PartiallySignedTransaction psbtx(mtx);\n         bool complete = false;\n-        const TransactionError err = model->wallet().fillPSBT(SIGHASH_ALL, false /* sign */, true /* bip32derivs */, psbtx, complete);\n+        const TransactionError err = model->wallet().fillPSBT(SIGHASH_ALL, false /* sign */, true /* bip32derivs */, psbtx, complete, nullptr);\n         assert(!complete);\n         assert(err == TransactionError::OK);\n         // Serialize the PSBT"
      },
      {
        "sha": "ec56f2755fc3a16db50ed74945d48c90b5801a7e",
        "filename": "src/qt/walletframe.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/qt/walletframe.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/qt/walletframe.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletframe.cpp?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -165,11 +165,11 @@ void WalletFrame::gotoVerifyMessageTab(QString addr)\n         walletView->gotoVerifyMessageTab(addr);\n }\n \n-void WalletFrame::gotoLoadPSBT()\n+void WalletFrame::gotoLoadPSBT(bool from_clipboard)\n {\n     WalletView *walletView = currentWalletView();\n     if (walletView) {\n-        walletView->gotoLoadPSBT();\n+        walletView->gotoLoadPSBT(from_clipboard);\n     }\n }\n "
      },
      {
        "sha": "2b5f2634688a689aa3f376c8b7715a9745326240",
        "filename": "src/qt/walletframe.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/qt/walletframe.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/qt/walletframe.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletframe.h?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -79,7 +79,7 @@ public Q_SLOTS:\n     void gotoVerifyMessageTab(QString addr = \"\");\n \n     /** Load Partially Signed Bitcoin Transaction */\n-    void gotoLoadPSBT();\n+    void gotoLoadPSBT(bool from_clipboard = false);\n \n     /** Encrypt the wallet */\n     void encryptWallet(bool status);"
      },
      {
        "sha": "72c75f7be02b41f1eae00e803b4a3d356c32d8ce",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -536,7 +536,7 @@ bool WalletModel::bumpFee(uint256 hash, uint256& new_hash)\n     if (create_psbt) {\n         PartiallySignedTransaction psbtx(mtx);\n         bool complete = false;\n-        const TransactionError err = wallet().fillPSBT(SIGHASH_ALL, false /* sign */, true /* bip32derivs */, psbtx, complete);\n+        const TransactionError err = wallet().fillPSBT(SIGHASH_ALL, false /* sign */, true /* bip32derivs */, psbtx, complete, nullptr);\n         if (err != TransactionError::OK || complete) {\n             QMessageBox::critical(nullptr, tr(\"Fee bump error\"), tr(\"Can't draft transaction.\"));\n             return false;"
      },
      {
        "sha": "a3f303aea618402108b5125a17c0ef461e7c27dc",
        "filename": "src/qt/walletview.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 63,
        "changes": 93,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/qt/walletview.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/qt/walletview.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletview.cpp?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -11,6 +11,7 @@\n #include <qt/askpassphrasedialog.h>\n #include <qt/clientmodel.h>\n #include <qt/guiutil.h>\n+#include <qt/psbtoperationsdialog.h>\n #include <qt/optionsmodel.h>\n #include <qt/overviewpage.h>\n #include <qt/platformstyle.h>\n@@ -27,6 +28,8 @@\n \n #include <QAction>\n #include <QActionGroup>\n+#include <QApplication>\n+#include <QClipboard>\n #include <QFileDialog>\n #include <QHBoxLayout>\n #include <QProgressDialog>\n@@ -204,78 +207,42 @@ void WalletView::gotoVerifyMessageTab(QString addr)\n         signVerifyMessageDialog->setAddress_VM(addr);\n }\n \n-void WalletView::gotoLoadPSBT()\n+void WalletView::gotoLoadPSBT(bool from_clipboard)\n {\n-    QString filename = GUIUtil::getOpenFileName(this,\n-        tr(\"Load Transaction Data\"), QString(),\n-        tr(\"Partially Signed Transaction (*.psbt)\"), nullptr);\n-    if (filename.isEmpty()) return;\n-    if (GetFileSize(filename.toLocal8Bit().data(), MAX_FILE_SIZE_PSBT) == MAX_FILE_SIZE_PSBT) {\n-        Q_EMIT message(tr(\"Error\"), tr(\"PSBT file must be smaller than 100 MiB\"), CClientUIInterface::MSG_ERROR);\n-        return;\n+    std::string data;\n+\n+    if (from_clipboard) {\n+        std::string raw = QApplication::clipboard()->text().toStdString();\n+        bool invalid;\n+        data = DecodeBase64(raw, &invalid);\n+        if (invalid) {\n+            Q_EMIT message(tr(\"Error\"), tr(\"Unable to decode PSBT from clipboard (invalid base64)\"), CClientUIInterface::MSG_ERROR);\n+            return;\n+        }\n+    } else {\n+        QString filename = GUIUtil::getOpenFileName(this,\n+            tr(\"Load Transaction Data\"), QString(),\n+            tr(\"Partially Signed Transaction (*.psbt)\"), nullptr);\n+        if (filename.isEmpty()) return;\n+        if (GetFileSize(filename.toLocal8Bit().data(), MAX_FILE_SIZE_PSBT) == MAX_FILE_SIZE_PSBT) {\n+            Q_EMIT message(tr(\"Error\"), tr(\"PSBT file must be smaller than 100 MiB\"), CClientUIInterface::MSG_ERROR);\n+            return;\n+        }\n+        std::ifstream in(filename.toLocal8Bit().data(), std::ios::binary);\n+        data = std::string(std::istreambuf_iterator<char>{in}, {});\n     }\n-    std::ifstream in(filename.toLocal8Bit().data(), std::ios::binary);\n-    std::string data(std::istreambuf_iterator<char>{in}, {});\n \n     std::string error;\n     PartiallySignedTransaction psbtx;\n     if (!DecodeRawPSBT(psbtx, data, error)) {\n-        Q_EMIT message(tr(\"Error\"), tr(\"Unable to decode PSBT file\") + \"\\n\" + QString::fromStdString(error), CClientUIInterface::MSG_ERROR);\n+        Q_EMIT message(tr(\"Error\"), tr(\"Unable to decode PSBT\") + \"\\n\" + QString::fromStdString(error), CClientUIInterface::MSG_ERROR);\n         return;\n     }\n \n-    CMutableTransaction mtx;\n-    bool complete = false;\n-    PSBTAnalysis analysis = AnalyzePSBT(psbtx);\n-    QMessageBox msgBox;\n-    msgBox.setText(\"PSBT\");\n-    switch (analysis.next) {\n-    case PSBTRole::CREATOR:\n-    case PSBTRole::UPDATER:\n-        msgBox.setInformativeText(\"PSBT is incomplete. Copy to clipboard for manual inspection?\");\n-        break;\n-    case PSBTRole::SIGNER:\n-        msgBox.setInformativeText(\"Transaction needs more signatures. Copy to clipboard?\");\n-        break;\n-    case PSBTRole::FINALIZER:\n-    case PSBTRole::EXTRACTOR:\n-        complete = FinalizeAndExtractPSBT(psbtx, mtx);\n-        if (complete) {\n-            msgBox.setInformativeText(tr(\"Would you like to send this transaction?\"));\n-        } else {\n-            // The analyzer missed something, e.g. if there are final_scriptSig/final_scriptWitness\n-            // but with invalid signatures.\n-            msgBox.setInformativeText(tr(\"There was an unexpected problem processing the PSBT. Copy to clipboard for manual inspection?\"));\n-        }\n-    }\n-\n-    msgBox.setStandardButtons(QMessageBox::Yes | QMessageBox::Cancel);\n-    switch (msgBox.exec()) {\n-    case QMessageBox::Yes: {\n-        if (complete) {\n-            std::string err_string;\n-            CTransactionRef tx = MakeTransactionRef(mtx);\n-\n-            TransactionError result = BroadcastTransaction(*clientModel->node().context(), tx, err_string, DEFAULT_MAX_RAW_TX_FEE_RATE.GetFeePerK(), /* relay */ true, /* wait_callback */ false);\n-            if (result == TransactionError::OK) {\n-                Q_EMIT message(tr(\"Success\"), tr(\"Broadcasted transaction successfully.\"), CClientUIInterface::MSG_INFORMATION | CClientUIInterface::MODAL);\n-            } else {\n-                Q_EMIT message(tr(\"Error\"), QString::fromStdString(err_string), CClientUIInterface::MSG_ERROR);\n-            }\n-        } else {\n-            // Serialize the PSBT\n-            CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n-            ssTx << psbtx;\n-            GUIUtil::setClipboard(EncodeBase64(ssTx.str()).c_str());\n-            Q_EMIT message(tr(\"PSBT copied\"), \"Copied to clipboard\", CClientUIInterface::MSG_INFORMATION);\n-            return;\n-        }\n-    }\n-    case QMessageBox::Cancel:\n-        break;\n-    default:\n-        assert(false);\n-    }\n+    PSBTOperationsDialog* dlg = new PSBTOperationsDialog(this, walletModel, clientModel);\n+    dlg->openWithPSBT(psbtx);\n+    dlg->setAttribute(Qt::WA_DeleteOnClose);\n+    dlg->exec();\n }\n \n bool WalletView::handlePaymentRequest(const SendCoinsRecipient& recipient)"
      },
      {
        "sha": "f186554758fbbb2d4a3436eb289302e7d169880d",
        "filename": "src/qt/walletview.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/qt/walletview.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/qt/walletview.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletview.h?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -84,7 +84,7 @@ public Q_SLOTS:\n     /** Show Sign/Verify Message dialog and switch to verify message tab */\n     void gotoVerifyMessageTab(QString addr = \"\");\n     /** Load Partially Signed Bitcoin Transaction */\n-    void gotoLoadPSBT();\n+    void gotoLoadPSBT(bool from_clipboard = false);\n \n     /** Show incoming transaction notification for new transactions.\n "
      },
      {
        "sha": "66ace7263a7424234e6d4413639cfab131abf290",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -217,7 +217,7 @@ UniValue ParseNonRFCJSONValue(const std::string& strVal)\n     UniValue jVal;\n     if (!jVal.read(std::string(\"[\")+strVal+std::string(\"]\")) ||\n         !jVal.isArray() || jVal.size()!=1)\n-        throw std::runtime_error(std::string(\"Error parsing JSON:\")+strVal);\n+        throw std::runtime_error(std::string(\"Error parsing JSON: \") + strVal);\n     return jVal[0];\n }\n "
      },
      {
        "sha": "e8e0ab317931aca497b09a140e8af2545782da73",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 10,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -17,6 +17,7 @@\n #include <policy/fees.h>\n #include <pow.h>\n #include <rpc/blockchain.h>\n+#include <rpc/mining.h>\n #include <rpc/server.h>\n #include <rpc/util.h>\n #include <script/descriptor.h>\n@@ -207,7 +208,7 @@ static UniValue generatetodescriptor(const JSONRPCRequest& request)\n         {\n             {\"num_blocks\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"How many blocks are generated immediately.\"},\n             {\"descriptor\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The descriptor to send the newly generated bitcoin to.\"},\n-            {\"maxtries\", RPCArg::Type::NUM, /* default */ \"1000000\", \"How many iterations to try.\"},\n+            {\"maxtries\", RPCArg::Type::NUM, /* default */ ToString(DEFAULT_MAX_TRIES), \"How many iterations to try.\"},\n         },\n         RPCResult{\n             RPCResult::Type::ARR, \"\", \"hashes of blocks generated\",\n@@ -221,7 +222,7 @@ static UniValue generatetodescriptor(const JSONRPCRequest& request)\n         .Check(request);\n \n     const int num_blocks{request.params[0].get_int()};\n-    const int64_t max_tries{request.params[2].isNull() ? 1000000 : request.params[2].get_int()};\n+    const uint64_t max_tries{request.params[2].isNull() ? DEFAULT_MAX_TRIES : request.params[2].get_int()};\n \n     CScript coinbase_script;\n     std::string error;\n@@ -242,7 +243,7 @@ static UniValue generatetoaddress(const JSONRPCRequest& request)\n                 {\n                     {\"nblocks\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"How many blocks are generated immediately.\"},\n                     {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The address to send the newly generated bitcoin to.\"},\n-                    {\"maxtries\", RPCArg::Type::NUM, /* default */ \"1000000\", \"How many iterations to try.\"},\n+                    {\"maxtries\", RPCArg::Type::NUM, /* default */ ToString(DEFAULT_MAX_TRIES), \"How many iterations to try.\"},\n                 },\n                 RPCResult{\n                     RPCResult::Type::ARR, \"\", \"hashes of blocks generated\",\n@@ -257,11 +258,8 @@ static UniValue generatetoaddress(const JSONRPCRequest& request)\n                 },\n             }.Check(request);\n \n-    int nGenerate = request.params[0].get_int();\n-    uint64_t nMaxTries = 1000000;\n-    if (!request.params[2].isNull()) {\n-        nMaxTries = request.params[2].get_int();\n-    }\n+    const int num_blocks{request.params[0].get_int()};\n+    const uint64_t max_tries{request.params[2].isNull() ? DEFAULT_MAX_TRIES : request.params[2].get_int()};\n \n     CTxDestination destination = DecodeDestination(request.params[1].get_str());\n     if (!IsValidDestination(destination)) {\n@@ -273,7 +271,7 @@ static UniValue generatetoaddress(const JSONRPCRequest& request)\n \n     CScript coinbase_script = GetScriptForDestination(destination);\n \n-    return generateBlocks(chainman, mempool, coinbase_script, nGenerate, nMaxTries);\n+    return generateBlocks(chainman, mempool, coinbase_script, num_blocks, max_tries);\n }\n \n static UniValue generateblock(const JSONRPCRequest& request)\n@@ -371,7 +369,7 @@ static UniValue generateblock(const JSONRPCRequest& request)\n     }\n \n     uint256 block_hash;\n-    uint64_t max_tries{1000000};\n+    uint64_t max_tries{DEFAULT_MAX_TRIES};\n     unsigned int extra_nonce{0};\n \n     if (!GenerateBlock(EnsureChainman(request.context), block, max_tries, extra_nonce, block_hash) || block_hash.IsNull()) {"
      },
      {
        "sha": "acc74e1dcc8346aa836e34958323e24d11a17c3a",
        "filename": "src/rpc/mining.h",
        "status": "added",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/rpc/mining.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/rpc/mining.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.h?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -0,0 +1,11 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_RPC_MINING_H\n+#define BITCOIN_RPC_MINING_H\n+\n+/** Default max iterations to try in RPC generatetodescriptor, generatetoaddress, and generateblock. */\n+static const uint64_t DEFAULT_MAX_TRIES{1000000};\n+\n+#endif // BITCOIN_RPC_MINING_H"
      },
      {
        "sha": "814f8bddfedf62010d4af2f4a2506164f5bd26a1",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -595,7 +595,7 @@ static UniValue decodescript(const JSONRPCRequest& request)\n             if (which_type == TX_PUBKEY) {\n                 segwitScr = GetScriptForDestination(WitnessV0KeyHash(Hash160(solutions_data[0].begin(), solutions_data[0].end())));\n             } else if (which_type == TX_PUBKEYHASH) {\n-                segwitScr = GetScriptForDestination(WitnessV0KeyHash(solutions_data[0]));\n+                segwitScr = GetScriptForDestination(WitnessV0KeyHash(uint160{solutions_data[0]}));\n             } else {\n                 // Scripts that are not fit for P2WPKH are encoded as P2WSH.\n                 // Newer segwit program versions should be considered when then become available."
      },
      {
        "sha": "43988c4fd7d9d1d0e2a2fcf1a0924957d59686a5",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -131,7 +131,7 @@ static bool SignStep(const SigningProvider& provider, const BaseSignatureCreator\n     }\n     case TX_SCRIPTHASH:\n         h160 = uint160(vSolutions[0]);\n-        if (GetCScript(provider, sigdata, h160, scriptRet)) {\n+        if (GetCScript(provider, sigdata, CScriptID{h160}, scriptRet)) {\n             ret.push_back(std::vector<unsigned char>(scriptRet.begin(), scriptRet.end()));\n             return true;\n         }\n@@ -165,7 +165,7 @@ static bool SignStep(const SigningProvider& provider, const BaseSignatureCreator\n \n     case TX_WITNESS_V0_SCRIPTHASH:\n         CRIPEMD160().Write(&vSolutions[0][0], vSolutions[0].size()).Finalize(h160.begin());\n-        if (GetCScript(provider, sigdata, h160, scriptRet)) {\n+        if (GetCScript(provider, sigdata, CScriptID{h160}, scriptRet)) {\n             ret.push_back(std::vector<unsigned char>(scriptRet.begin(), scriptRet.end()));\n             return true;\n         }\n@@ -458,7 +458,7 @@ bool IsSegWitOutput(const SigningProvider& provider, const CScript& script)\n     if (whichtype == TX_SCRIPTHASH) {\n         auto h160 = uint160(solutions[0]);\n         CScript subscript;\n-        if (provider.GetCScript(h160, subscript)) {\n+        if (provider.GetCScript(CScriptID{h160}, subscript)) {\n             whichtype = Solver(subscript, solutions);\n             if (whichtype == TX_WITNESS_V0_SCRIPTHASH || whichtype == TX_WITNESS_V0_KEYHASH || whichtype == TX_WITNESS_UNKNOWN) return true;\n         }"
      },
      {
        "sha": "2d8dc7d4714fe39b643f55bb01560183df7bcac5",
        "filename": "src/script/signingprovider.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/script/signingprovider.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/script/signingprovider.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/signingprovider.cpp?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -180,18 +180,18 @@ CKeyID GetKeyForDestination(const SigningProvider& store, const CTxDestination&\n     // Only supports destinations which map to single public keys, i.e. P2PKH,\n     // P2WPKH, and P2SH-P2WPKH.\n     if (auto id = boost::get<PKHash>(&dest)) {\n-        return CKeyID(*id);\n+        return ToKeyID(*id);\n     }\n     if (auto witness_id = boost::get<WitnessV0KeyHash>(&dest)) {\n-        return CKeyID(*witness_id);\n+        return ToKeyID(*witness_id);\n     }\n     if (auto script_hash = boost::get<ScriptHash>(&dest)) {\n         CScript script;\n         CScriptID script_id(*script_hash);\n         CTxDestination inner_dest;\n         if (store.GetCScript(script_id, script) && ExtractDestination(script, inner_dest)) {\n             if (auto inner_witness_id = boost::get<WitnessV0KeyHash>(&inner_dest)) {\n-                return CKeyID(*inner_witness_id);\n+                return ToKeyID(*inner_witness_id);\n             }\n         }\n     }"
      },
      {
        "sha": "2adf6ce56d5938b45efbbacd88180773c08a5a44",
        "filename": "src/script/standard.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 4,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/script/standard.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/script/standard.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.cpp?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -16,11 +16,27 @@ typedef std::vector<unsigned char> valtype;\n bool fAcceptDatacarrier = DEFAULT_ACCEPT_DATACARRIER;\n unsigned nMaxDatacarrierBytes = MAX_OP_RETURN_RELAY;\n \n-CScriptID::CScriptID(const CScript& in) : uint160(Hash160(in.begin(), in.end())) {}\n+CScriptID::CScriptID(const CScript& in) : BaseHash(Hash160(in.begin(), in.end())) {}\n+CScriptID::CScriptID(const ScriptHash& in) : BaseHash(static_cast<uint160>(in)) {}\n \n-ScriptHash::ScriptHash(const CScript& in) : uint160(Hash160(in.begin(), in.end())) {}\n+ScriptHash::ScriptHash(const CScript& in) : BaseHash(Hash160(in.begin(), in.end())) {}\n+ScriptHash::ScriptHash(const CScriptID& in) : BaseHash(static_cast<uint160>(in)) {}\n \n-PKHash::PKHash(const CPubKey& pubkey) : uint160(pubkey.GetID()) {}\n+PKHash::PKHash(const CPubKey& pubkey) : BaseHash(pubkey.GetID()) {}\n+PKHash::PKHash(const CKeyID& pubkey_id) : BaseHash(pubkey_id) {}\n+\n+WitnessV0KeyHash::WitnessV0KeyHash(const CPubKey& pubkey) : BaseHash(pubkey.GetID()) {}\n+WitnessV0KeyHash::WitnessV0KeyHash(const PKHash& pubkey_hash) : BaseHash(static_cast<uint160>(pubkey_hash)) {}\n+\n+CKeyID ToKeyID(const PKHash& key_hash)\n+{\n+    return CKeyID{static_cast<uint160>(key_hash)};\n+}\n+\n+CKeyID ToKeyID(const WitnessV0KeyHash& key_hash)\n+{\n+    return CKeyID{static_cast<uint160>(key_hash)};\n+}\n \n WitnessV0ScriptHash::WitnessV0ScriptHash(const CScript& in)\n {\n@@ -307,7 +323,7 @@ CScript GetScriptForWitness(const CScript& redeemscript)\n     if (typ == TX_PUBKEY) {\n         return GetScriptForDestination(WitnessV0KeyHash(Hash160(vSolutions[0].begin(), vSolutions[0].end())));\n     } else if (typ == TX_PUBKEYHASH) {\n-        return GetScriptForDestination(WitnessV0KeyHash(vSolutions[0]));\n+        return GetScriptForDestination(WitnessV0KeyHash(uint160{vSolutions[0]}));\n     }\n     return GetScriptForDestination(WitnessV0ScriptHash(redeemscript));\n }"
      },
      {
        "sha": "4baed6da6e3889f8cf3c8fb2ded7d7991925687c",
        "filename": "src/script/standard.h",
        "status": "modified",
        "additions": 85,
        "deletions": 19,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/script/standard.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/script/standard.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.h?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -18,14 +18,77 @@ static const bool DEFAULT_ACCEPT_DATACARRIER = true;\n \n class CKeyID;\n class CScript;\n+struct ScriptHash;\n+\n+template<typename HashType>\n+class BaseHash\n+{\n+protected:\n+    HashType m_hash;\n+\n+public:\n+    BaseHash() : m_hash() {}\n+    BaseHash(const HashType& in) : m_hash(in) {}\n+\n+    unsigned char* begin()\n+    {\n+        return m_hash.begin();\n+    }\n+\n+    const unsigned char* begin() const\n+    {\n+        return m_hash.begin();\n+    }\n+\n+    unsigned char* end()\n+    {\n+        return m_hash.end();\n+    }\n+\n+    const unsigned char* end() const\n+    {\n+        return m_hash.end();\n+    }\n+\n+    operator std::vector<unsigned char>() const\n+    {\n+        return std::vector<unsigned char>{m_hash.begin(), m_hash.end()};\n+    }\n+\n+    std::string ToString() const\n+    {\n+        return m_hash.ToString();\n+    }\n+\n+    bool operator==(const BaseHash<HashType>& other) const noexcept\n+    {\n+        return m_hash == other.m_hash;\n+    }\n+\n+    bool operator!=(const BaseHash<HashType>& other) const noexcept\n+    {\n+        return !(m_hash == other.m_hash);\n+    }\n+\n+    bool operator<(const BaseHash<HashType>& other) const noexcept\n+    {\n+        return m_hash < other.m_hash;\n+    }\n+\n+    size_t size() const\n+    {\n+        return m_hash.size();\n+    }\n+};\n \n /** A reference to a CScript: the Hash160 of its serialization (see script.h) */\n-class CScriptID : public uint160\n+class CScriptID : public BaseHash<uint160>\n {\n public:\n-    CScriptID() : uint160() {}\n+    CScriptID() : BaseHash() {}\n     explicit CScriptID(const CScript& in);\n-    CScriptID(const uint160& in) : uint160(in) {}\n+    explicit CScriptID(const uint160& in) : BaseHash(in) {}\n+    explicit CScriptID(const ScriptHash& in);\n };\n \n /**\n@@ -73,41 +136,44 @@ class CNoDestination {\n     friend bool operator<(const CNoDestination &a, const CNoDestination &b) { return true; }\n };\n \n-struct PKHash : public uint160\n+struct PKHash : public BaseHash<uint160>\n {\n-    PKHash() : uint160() {}\n-    explicit PKHash(const uint160& hash) : uint160(hash) {}\n+    PKHash() : BaseHash() {}\n+    explicit PKHash(const uint160& hash) : BaseHash(hash) {}\n     explicit PKHash(const CPubKey& pubkey);\n-    using uint160::uint160;\n+    explicit PKHash(const CKeyID& pubkey_id);\n };\n+CKeyID ToKeyID(const PKHash& key_hash);\n \n struct WitnessV0KeyHash;\n-struct ScriptHash : public uint160\n+struct ScriptHash : public BaseHash<uint160>\n {\n-    ScriptHash() : uint160() {}\n+    ScriptHash() : BaseHash() {}\n     // These don't do what you'd expect.\n     // Use ScriptHash(GetScriptForDestination(...)) instead.\n     explicit ScriptHash(const WitnessV0KeyHash& hash) = delete;\n     explicit ScriptHash(const PKHash& hash) = delete;\n-    explicit ScriptHash(const uint160& hash) : uint160(hash) {}\n+\n+    explicit ScriptHash(const uint160& hash) : BaseHash(hash) {}\n     explicit ScriptHash(const CScript& script);\n-    using uint160::uint160;\n+    explicit ScriptHash(const CScriptID& script);\n };\n \n-struct WitnessV0ScriptHash : public uint256\n+struct WitnessV0ScriptHash : public BaseHash<uint256>\n {\n-    WitnessV0ScriptHash() : uint256() {}\n-    explicit WitnessV0ScriptHash(const uint256& hash) : uint256(hash) {}\n+    WitnessV0ScriptHash() : BaseHash() {}\n+    explicit WitnessV0ScriptHash(const uint256& hash) : BaseHash(hash) {}\n     explicit WitnessV0ScriptHash(const CScript& script);\n-    using uint256::uint256;\n };\n \n-struct WitnessV0KeyHash : public uint160\n+struct WitnessV0KeyHash : public BaseHash<uint160>\n {\n-    WitnessV0KeyHash() : uint160() {}\n-    explicit WitnessV0KeyHash(const uint160& hash) : uint160(hash) {}\n-    using uint160::uint160;\n+    WitnessV0KeyHash() : BaseHash() {}\n+    explicit WitnessV0KeyHash(const uint160& hash) : BaseHash(hash) {}\n+    explicit WitnessV0KeyHash(const CPubKey& pubkey);\n+    explicit WitnessV0KeyHash(const PKHash& pubkey_hash);\n };\n+CKeyID ToKeyID(const WitnessV0KeyHash& key_hash);\n \n //! CTxDestination subtype to encode any future Witness version\n struct WitnessUnknown"
      },
      {
        "sha": "0fbf257f0e292256afb5a53e63bcbfedb4f72c27",
        "filename": "src/test/netbase_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/test/netbase_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/test/netbase_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/netbase_tests.cpp?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -160,6 +160,9 @@ BOOST_AUTO_TEST_CASE(subnet_test)\n     BOOST_CHECK(ResolveSubNet(\"1.2.2.20/26\").Match(ResolveIP(\"1.2.2.63\")));\n     // All-Matching IPv6 Matches arbitrary IPv4 and IPv6\n     BOOST_CHECK(ResolveSubNet(\"::/0\").Match(ResolveIP(\"1:2:3:4:5:6:7:1234\")));\n+    // But not `::` or `0.0.0.0` because they are considered invalid addresses\n+    BOOST_CHECK(!ResolveSubNet(\"::/0\").Match(ResolveIP(\"::\")));\n+    BOOST_CHECK(!ResolveSubNet(\"::/0\").Match(ResolveIP(\"0.0.0.0\")));\n     BOOST_CHECK(ResolveSubNet(\"::/0\").Match(ResolveIP(\"1.2.3.4\")));\n     // All-Matching IPv4 does not Match IPv6\n     BOOST_CHECK(!ResolveSubNet(\"0.0.0.0/0\").Match(ResolveIP(\"1:2:3:4:5:6:7:1234\")));"
      },
      {
        "sha": "3e29083712eac13ca0fa73bd5eec8ac024e39de4",
        "filename": "src/util/error.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/util/error.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/util/error.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/error.cpp?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -14,7 +14,7 @@ bilingual_str TransactionErrorString(const TransactionError err)\n         case TransactionError::OK:\n             return Untranslated(\"No error\");\n         case TransactionError::MISSING_INPUTS:\n-            return Untranslated(\"Missing inputs\");\n+            return Untranslated(\"Inputs missing or spent\");\n         case TransactionError::ALREADY_IN_CHAIN:\n             return Untranslated(\"Transaction already in block chain\");\n         case TransactionError::P2P_DISABLED:\n@@ -24,11 +24,11 @@ bilingual_str TransactionErrorString(const TransactionError err)\n         case TransactionError::MEMPOOL_ERROR:\n             return Untranslated(\"AcceptToMemoryPool failed\");\n         case TransactionError::INVALID_PSBT:\n-            return Untranslated(\"PSBT is not sane\");\n+            return Untranslated(\"PSBT is not well-formed\");\n         case TransactionError::PSBT_MISMATCH:\n             return Untranslated(\"PSBTs not compatible (different transactions)\");\n         case TransactionError::SIGHASH_MISMATCH:\n-            return Untranslated(\"Specified sighash value does not match existing value\");\n+            return Untranslated(\"Specified sighash value does not match value stored in PSBT\");\n         case TransactionError::MAX_FEE_EXCEEDED:\n             return Untranslated(\"Fee exceeds maximum configured by -maxtxfee\");\n         // no default case, so the compiler can warn about missing cases"
      },
      {
        "sha": "720877ead08da8bb18f79247ae592904409d5607",
        "filename": "src/wallet/coincontrol.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/wallet/coincontrol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/wallet/coincontrol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coincontrol.cpp?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -10,6 +10,7 @@ void CCoinControl::SetNull()\n {\n     destChange = CNoDestination();\n     m_change_type.reset();\n+    m_add_inputs = true;\n     fAllowOtherInputs = false;\n     fAllowWatchOnly = false;\n     m_avoid_partial_spends = gArgs.GetBoolArg(\"-avoidpartialspends\", DEFAULT_AVOIDPARTIALSPENDS);\n@@ -23,4 +24,3 @@ void CCoinControl::SetNull()\n     m_min_depth = DEFAULT_MIN_DEPTH;\n     m_max_depth = DEFAULT_MAX_DEPTH;\n }\n-"
      },
      {
        "sha": "c499b0ff25e683f22b1c3824f91f5da7c70a3b15",
        "filename": "src/wallet/coincontrol.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/wallet/coincontrol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/wallet/coincontrol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coincontrol.h?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -26,6 +26,8 @@ class CCoinControl\n     CTxDestination destChange;\n     //! Override the default change type if set, ignored if destChange is set\n     Optional<OutputType> m_change_type;\n+    //! If false, only selected inputs are used\n+    bool m_add_inputs;\n     //! If false, allows unselected inputs, but requires all selected inputs be used\n     bool fAllowOtherInputs;\n     //! Includes watch only addresses which are solvable"
      },
      {
        "sha": "541675bcef44a2ee2663b23d60cacde6ccdbe19d",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -297,7 +297,7 @@ UniValue importaddress(const JSONRPCRequest& request)\n             pwallet->ImportScripts(scripts, 0 /* timestamp */);\n \n             if (fP2SH) {\n-                scripts.insert(GetScriptForDestination(ScriptHash(CScriptID(redeem_script))));\n+                scripts.insert(GetScriptForDestination(ScriptHash(redeem_script)));\n             }\n \n             pwallet->ImportScriptPubKeys(strLabel, scripts, false /* have_solving_data */, true /* apply_label */, 1 /* timestamp */);"
      },
      {
        "sha": "72998c30fd5cb336d137828add755611307ad986",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 36,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -2918,13 +2918,12 @@ static UniValue listunspent(const JSONRPCRequest& request)\n     return results;\n }\n \n-void FundTransaction(CWallet* const pwallet, CMutableTransaction& tx, CAmount& fee_out, int& change_position, UniValue options)\n+void FundTransaction(CWallet* const pwallet, CMutableTransaction& tx, CAmount& fee_out, int& change_position, UniValue options, CCoinControl& coinControl)\n {\n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n-    CCoinControl coinControl;\n     change_position = -1;\n     bool lockUnspents = false;\n     UniValue subtractFeeFromOutputs;\n@@ -2939,6 +2938,7 @@ void FundTransaction(CWallet* const pwallet, CMutableTransaction& tx, CAmount& f\n         RPCTypeCheckArgument(options, UniValue::VOBJ);\n         RPCTypeCheckObj(options,\n             {\n+                {\"add_inputs\", UniValueType(UniValue::VBOOL)},\n                 {\"changeAddress\", UniValueType(UniValue::VSTR)},\n                 {\"changePosition\", UniValueType(UniValue::VNUM)},\n                 {\"change_type\", UniValueType(UniValue::VSTR)},\n@@ -2952,6 +2952,10 @@ void FundTransaction(CWallet* const pwallet, CMutableTransaction& tx, CAmount& f\n             },\n             true, true);\n \n+        if (options.exists(\"add_inputs\") ) {\n+            coinControl.m_add_inputs = options[\"add_inputs\"].get_bool();\n+        }\n+\n         if (options.exists(\"changeAddress\")) {\n             CTxDestination dest = DecodeDestination(options[\"changeAddress\"].get_str());\n \n@@ -3039,8 +3043,8 @@ void FundTransaction(CWallet* const pwallet, CMutableTransaction& tx, CAmount& f\n static UniValue fundrawtransaction(const JSONRPCRequest& request)\n {\n     RPCHelpMan{\"fundrawtransaction\",\n-                \"\\nAdd inputs to a transaction until it has enough in value to meet its out value.\\n\"\n-                \"This will not modify existing inputs, and will add at most one change output to the outputs.\\n\"\n+                \"\\nIf the transaction has no inputs, they will be automatically selected to meet its out value.\\n\"\n+                \"It will add at most one change output to the outputs.\\n\"\n                 \"No existing outputs will be modified unless \\\"subtractFeeFromOutputs\\\" is specified.\\n\"\n                 \"Note that inputs which were signed may need to be resigned after completion since in/outputs have been added.\\n\"\n                 \"The inputs added will not be signed, use signrawtransactionwithkey\\n\"\n@@ -3054,6 +3058,7 @@ static UniValue fundrawtransaction(const JSONRPCRequest& request)\n                     {\"hexstring\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The hex string of the raw transaction\"},\n                     {\"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"for backward compatibility: passing in a true instead of an object will result in {\\\"includeWatching\\\":true}\",\n                         {\n+                            {\"add_inputs\", RPCArg::Type::BOOL, /* default */ \"true\", \"For a transaction with existing inputs, automatically include more if they are not enough.\"},\n                             {\"changeAddress\", RPCArg::Type::STR, /* default */ \"pool address\", \"The bitcoin address to receive the change\"},\n                             {\"changePosition\", RPCArg::Type::NUM, /* default */ \"random\", \"The index of the change output\"},\n                             {\"change_type\", RPCArg::Type::STR, /* default */ \"set by -changetype\", \"The output type to use. Only valid if changeAddress is not specified. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\".\"},\n@@ -3123,7 +3128,10 @@ static UniValue fundrawtransaction(const JSONRPCRequest& request)\n \n     CAmount fee;\n     int change_position;\n-    FundTransaction(pwallet, tx, fee, change_position, request.params[1]);\n+    CCoinControl coin_control;\n+    // Automatically select (additional) coins. Can be overriden by options.add_inputs.\n+    coin_control.m_add_inputs = true;\n+    FundTransaction(pwallet, tx, fee, change_position, request.params[1], coin_control);\n \n     UniValue result(UniValue::VOBJ);\n     result.pushKV(\"hex\", EncodeHexTx(CTransaction(tx)));\n@@ -3517,7 +3525,7 @@ class DescribeWalletAddressVisitor : public boost::static_visitor<UniValue>\n \n     UniValue operator()(const PKHash& pkhash) const\n     {\n-        CKeyID keyID(pkhash);\n+        CKeyID keyID{ToKeyID(pkhash)};\n         UniValue obj(UniValue::VOBJ);\n         CPubKey vchPubKey;\n         if (provider && provider->GetPubKey(keyID, vchPubKey)) {\n@@ -3542,7 +3550,7 @@ class DescribeWalletAddressVisitor : public boost::static_visitor<UniValue>\n     {\n         UniValue obj(UniValue::VOBJ);\n         CPubKey pubkey;\n-        if (provider && provider->GetPubKey(CKeyID(id), pubkey)) {\n+        if (provider && provider->GetPubKey(ToKeyID(id), pubkey)) {\n             obj.pushKV(\"pubkey\", HexStr(pubkey));\n         }\n         return obj;\n@@ -3623,25 +3631,18 @@ UniValue getaddressinfo(const JSONRPCRequest& request)\n                         {RPCResult::Type::STR_HEX, \"pubkey\", /* optional */ true, \"The hex value of the raw public key for single-key addresses (possibly embedded in P2SH or P2WSH).\"},\n                         {RPCResult::Type::OBJ, \"embedded\", /* optional */ true, \"Information about the address embedded in P2SH or P2WSH, if relevant and known.\",\n                         {\n-                            {RPCResult::Type::ELISION, \"\", \"Includes all\\n\"\n-            \"                                                         getaddressinfo output fields for the embedded address, excluding metadata (timestamp, hdkeypath,\\n\"\n-                            \"hdseedid) and relation to the wallet (ismine, iswatchonly).\"},\n+                            {RPCResult::Type::ELISION, \"\", \"Includes all getaddressinfo output fields for the embedded address, excluding metadata (timestamp, hdkeypath, hdseedid)\\n\"\n+                            \"and relation to the wallet (ismine, iswatchonly).\"},\n                         }},\n                         {RPCResult::Type::BOOL, \"iscompressed\", /* optional */ true, \"If the pubkey is compressed.\"},\n-                        {RPCResult::Type::STR, \"label\", \"DEPRECATED. The label associated with the address. Defaults to \\\"\\\". Replaced by the labels array below.\"},\n                         {RPCResult::Type::NUM_TIME, \"timestamp\", /* optional */ true, \"The creation time of the key, if available, expressed in \" + UNIX_EPOCH_TIME + \".\"},\n                         {RPCResult::Type::STR, \"hdkeypath\", /* optional */ true, \"The HD keypath, if the key is HD and available.\"},\n                         {RPCResult::Type::STR_HEX, \"hdseedid\", /* optional */ true, \"The Hash160 of the HD seed.\"},\n                         {RPCResult::Type::STR_HEX, \"hdmasterfingerprint\", /* optional */ true, \"The fingerprint of the master key.\"},\n                         {RPCResult::Type::ARR, \"labels\", \"Array of labels associated with the address. Currently limited to one label but returned\\n\"\n                             \"as an array to keep the API stable if multiple labels are enabled in the future.\",\n                         {\n-                            {RPCResult::Type::STR, \"label name\", \"The label name. Defaults to \\\"\\\".\"},\n-                            {RPCResult::Type::OBJ, \"\", \"label data, DEPRECATED, will be removed in 0.21. To re-enable, launch bitcoind with `-deprecatedrpc=labelspurpose`\",\n-                            {\n-                                {RPCResult::Type::STR, \"name\", \"The label name. Defaults to \\\"\\\".\"},\n-                                {RPCResult::Type::STR, \"purpose\", \"The purpose of the associated address (send or receive).\"},\n-                            }},\n+                            {RPCResult::Type::STR, \"label name\", \"Label name (defaults to \\\"\\\").\"},\n                         }},\n                     }\n                 },\n@@ -3687,14 +3688,6 @@ UniValue getaddressinfo(const JSONRPCRequest& request)\n     UniValue detail = DescribeWalletAddress(pwallet, dest);\n     ret.pushKVs(detail);\n \n-    // DEPRECATED: Return label field if existing. Currently only one label can\n-    // be associated with an address, so the label should be equivalent to the\n-    // value of the name key/value pair in the labels array below.\n-    const auto* address_book_entry = pwallet->FindAddressBookEntry(dest);\n-    if (pwallet->chain().rpcEnableDeprecated(\"label\") && address_book_entry) {\n-        ret.pushKV(\"label\", address_book_entry->GetLabel());\n-    }\n-\n     ret.pushKV(\"ischange\", pwallet->IsChange(scriptPubKey));\n \n     ScriptPubKeyMan* spk_man = pwallet->GetScriptPubKeyMan(scriptPubKey);\n@@ -3715,14 +3708,9 @@ UniValue getaddressinfo(const JSONRPCRequest& request)\n     // stable if we allow multiple labels to be associated with an address in\n     // the future.\n     UniValue labels(UniValue::VARR);\n+    const auto* address_book_entry = pwallet->FindAddressBookEntry(dest);\n     if (address_book_entry) {\n-        // DEPRECATED: The previous behavior of returning an array containing a\n-        // JSON object of `name` and `purpose` key/value pairs is deprecated.\n-        if (pwallet->chain().rpcEnableDeprecated(\"labelspurpose\")) {\n-            labels.push_back(AddressBookDataToJSON(*address_book_entry, true));\n-        } else {\n-            labels.push_back(address_book_entry->GetLabel());\n-        }\n+        labels.push_back(address_book_entry->GetLabel());\n     }\n     ret.pushKV(\"labels\", std::move(labels));\n \n@@ -3976,16 +3964,16 @@ UniValue walletprocesspsbt(const JSONRPCRequest& request)\n UniValue walletcreatefundedpsbt(const JSONRPCRequest& request)\n {\n             RPCHelpMan{\"walletcreatefundedpsbt\",\n-                \"\\nCreates and funds a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n+                \"\\nCreates and funds a transaction in the Partially Signed Transaction format.\\n\"\n                 \"Implements the Creator and Updater roles.\\n\",\n                 {\n-                    {\"inputs\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The inputs\",\n+                    {\"inputs\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The inputs. Leave empty to add inputs automatically. See add_inputs option.\",\n                         {\n                             {\"\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED, \"\",\n                                 {\n                                     {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n                                     {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n-                                    {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                                    {\"sequence\", RPCArg::Type::NUM, /* default */ \"depends on the value of the 'locktime' and 'options.replaceable' arguments\", \"The sequence number\"},\n                                 },\n                             },\n                         },\n@@ -4010,6 +3998,7 @@ UniValue walletcreatefundedpsbt(const JSONRPCRequest& request)\n                     {\"locktime\", RPCArg::Type::NUM, /* default */ \"0\", \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n                     {\"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n                         {\n+                            {\"add_inputs\", RPCArg::Type::BOOL, /* default */ \"false\", \"If inputs are specified, automatically include more if they are not enough.\"},\n                             {\"changeAddress\", RPCArg::Type::STR_HEX, /* default */ \"pool address\", \"The bitcoin address to receive the change\"},\n                             {\"changePosition\", RPCArg::Type::NUM, /* default */ \"random\", \"The index of the change output\"},\n                             {\"change_type\", RPCArg::Type::STR, /* default */ \"set by -changetype\", \"The output type to use. Only valid if changeAddress is not specified. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\".\"},\n@@ -4071,7 +4060,11 @@ UniValue walletcreatefundedpsbt(const JSONRPCRequest& request)\n         rbf = replaceable_arg.isTrue();\n     }\n     CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], rbf);\n-    FundTransaction(pwallet, rawTx, fee, change_position, request.params[3]);\n+    CCoinControl coin_control;\n+    // Automatically select coins, unless at least one is manually selected. Can\n+    // be overriden by options.add_inputs.\n+    coin_control.m_add_inputs = rawTx.vin.size() == 0;\n+    FundTransaction(pwallet, rawTx, fee, change_position, request.params[3], coin_control);\n \n     // Make a blank psbt\n     PartiallySignedTransaction psbtx(rawTx);"
      },
      {
        "sha": "d57f99a205fca692563c04fb680e91b81500b8cf",
        "filename": "src/wallet/scriptpubkeyman.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 6,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/wallet/scriptpubkeyman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/wallet/scriptpubkeyman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/scriptpubkeyman.cpp?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -573,9 +573,8 @@ bool LegacyScriptPubKeyMan::SignTransaction(CMutableTransaction& tx, const std::\n \n SigningResult LegacyScriptPubKeyMan::SignMessage(const std::string& message, const PKHash& pkhash, std::string& str_sig) const\n {\n-    CKeyID key_id(pkhash);\n     CKey key;\n-    if (!GetKey(key_id, key)) {\n+    if (!GetKey(ToKeyID(pkhash), key)) {\n         return SigningResult::PRIVATE_KEY_NOT_AVAILABLE;\n     }\n \n@@ -585,8 +584,11 @@ SigningResult LegacyScriptPubKeyMan::SignMessage(const std::string& message, con\n     return SigningResult::SIGNING_FAILED;\n }\n \n-TransactionError LegacyScriptPubKeyMan::FillPSBT(PartiallySignedTransaction& psbtx, int sighash_type, bool sign, bool bip32derivs) const\n+TransactionError LegacyScriptPubKeyMan::FillPSBT(PartiallySignedTransaction& psbtx, int sighash_type, bool sign, bool bip32derivs, int* n_signed) const\n {\n+    if (n_signed) {\n+        *n_signed = 0;\n+    }\n     for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n         const CTxIn& txin = psbtx.tx->vin[i];\n         PSBTInput& input = psbtx.inputs.at(i);\n@@ -617,6 +619,14 @@ TransactionError LegacyScriptPubKeyMan::FillPSBT(PartiallySignedTransaction& psb\n         SignatureData sigdata;\n         input.FillSignatureData(sigdata);\n         SignPSBTInput(HidingSigningProvider(this, !sign, !bip32derivs), psbtx, i, sighash_type);\n+\n+        bool signed_one = PSBTInputSigned(input);\n+        if (n_signed && (signed_one || !sign)) {\n+            // If sign is false, we assume that we _could_ sign if we get here. This\n+            // will never have false negatives; it is hard to tell under what i\n+            // circumstances it could have false positives.\n+            (*n_signed)++;\n+        }\n     }\n \n     // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n@@ -2052,9 +2062,8 @@ SigningResult DescriptorScriptPubKeyMan::SignMessage(const std::string& message,\n         return SigningResult::PRIVATE_KEY_NOT_AVAILABLE;\n     }\n \n-    CKeyID key_id(pkhash);\n     CKey key;\n-    if (!keys->GetKey(key_id, key)) {\n+    if (!keys->GetKey(ToKeyID(pkhash), key)) {\n         return SigningResult::PRIVATE_KEY_NOT_AVAILABLE;\n     }\n \n@@ -2064,8 +2073,11 @@ SigningResult DescriptorScriptPubKeyMan::SignMessage(const std::string& message,\n     return SigningResult::OK;\n }\n \n-TransactionError DescriptorScriptPubKeyMan::FillPSBT(PartiallySignedTransaction& psbtx, int sighash_type, bool sign, bool bip32derivs) const\n+TransactionError DescriptorScriptPubKeyMan::FillPSBT(PartiallySignedTransaction& psbtx, int sighash_type, bool sign, bool bip32derivs, int* n_signed) const\n {\n+    if (n_signed) {\n+        *n_signed = 0;\n+    }\n     for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n         const CTxIn& txin = psbtx.tx->vin[i];\n         PSBTInput& input = psbtx.inputs.at(i);\n@@ -2117,6 +2129,14 @@ TransactionError DescriptorScriptPubKeyMan::FillPSBT(PartiallySignedTransaction&\n         }\n \n         SignPSBTInput(HidingSigningProvider(keys.get(), !sign, !bip32derivs), psbtx, i, sighash_type);\n+\n+        bool signed_one = PSBTInputSigned(input);\n+        if (n_signed && (signed_one || !sign)) {\n+            // If sign is false, we assume that we _could_ sign if we get here. This\n+            // will never have false negatives; it is hard to tell under what i\n+            // circumstances it could have false positives.\n+            (*n_signed)++;\n+        }\n     }\n \n     // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change"
      },
      {
        "sha": "9fa2a68284c1d53302eea91fc3f4eb87201c4ede",
        "filename": "src/wallet/scriptpubkeyman.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/wallet/scriptpubkeyman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/wallet/scriptpubkeyman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/scriptpubkeyman.h?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -234,7 +234,7 @@ class ScriptPubKeyMan\n     /** Sign a message with the given script */\n     virtual SigningResult SignMessage(const std::string& message, const PKHash& pkhash, std::string& str_sig) const { return SigningResult::SIGNING_FAILED; };\n     /** Adds script and derivation path information to a PSBT, and optionally signs it. */\n-    virtual TransactionError FillPSBT(PartiallySignedTransaction& psbt, int sighash_type = 1 /* SIGHASH_ALL */, bool sign = true, bool bip32derivs = false) const { return TransactionError::INVALID_PSBT; }\n+    virtual TransactionError FillPSBT(PartiallySignedTransaction& psbt, int sighash_type = 1 /* SIGHASH_ALL */, bool sign = true, bool bip32derivs = false, int* n_signed = nullptr) const { return TransactionError::INVALID_PSBT; }\n \n     virtual uint256 GetID() const { return uint256(); }\n \n@@ -393,7 +393,7 @@ class LegacyScriptPubKeyMan : public ScriptPubKeyMan, public FillableSigningProv\n \n     bool SignTransaction(CMutableTransaction& tx, const std::map<COutPoint, Coin>& coins, int sighash, std::map<int, std::string>& input_errors) const override;\n     SigningResult SignMessage(const std::string& message, const PKHash& pkhash, std::string& str_sig) const override;\n-    TransactionError FillPSBT(PartiallySignedTransaction& psbt, int sighash_type = 1 /* SIGHASH_ALL */, bool sign = true, bool bip32derivs = false) const override;\n+    TransactionError FillPSBT(PartiallySignedTransaction& psbt, int sighash_type = 1 /* SIGHASH_ALL */, bool sign = true, bool bip32derivs = false, int* n_signed = nullptr) const override;\n \n     uint256 GetID() const override;\n \n@@ -596,7 +596,7 @@ class DescriptorScriptPubKeyMan : public ScriptPubKeyMan\n \n     bool SignTransaction(CMutableTransaction& tx, const std::map<COutPoint, Coin>& coins, int sighash, std::map<int, std::string>& input_errors) const override;\n     SigningResult SignMessage(const std::string& message, const PKHash& pkhash, std::string& str_sig) const override;\n-    TransactionError FillPSBT(PartiallySignedTransaction& psbt, int sighash_type = 1 /* SIGHASH_ALL */, bool sign = true, bool bip32derivs = false) const override;\n+    TransactionError FillPSBT(PartiallySignedTransaction& psbt, int sighash_type = 1 /* SIGHASH_ALL */, bool sign = true, bool bip32derivs = false, int* n_signed = nullptr) const override;\n \n     uint256 GetID() const override;\n "
      },
      {
        "sha": "e416f16044627e85a8f75bb9aac33667d29f013e",
        "filename": "src/wallet/test/ismine_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/wallet/test/ismine_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/wallet/test/ismine_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/ismine_tests.cpp?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -167,7 +167,7 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         keystore.SetupLegacyScriptPubKeyMan();\n         LOCK(keystore.GetLegacyScriptPubKeyMan()->cs_KeyStore);\n \n-        CScript witnessscript = GetScriptForDestination(WitnessV0KeyHash(PKHash(pubkeys[0])));\n+        CScript witnessscript = GetScriptForDestination(WitnessV0KeyHash(pubkeys[0]));\n         scriptPubKey = GetScriptForDestination(WitnessV0ScriptHash(witnessscript));\n \n         BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(witnessscript));\n@@ -202,7 +202,7 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         LOCK(keystore.GetLegacyScriptPubKeyMan()->cs_KeyStore);\n         BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(keys[0]));\n \n-        scriptPubKey = GetScriptForDestination(WitnessV0KeyHash(PKHash(pubkeys[0])));\n+        scriptPubKey = GetScriptForDestination(WitnessV0KeyHash(pubkeys[0]));\n \n         // Keystore implicitly has key and P2SH redeemScript\n         BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddCScript(scriptPubKey));\n@@ -217,7 +217,7 @@ BOOST_AUTO_TEST_CASE(ismine_standard)\n         LOCK(keystore.GetLegacyScriptPubKeyMan()->cs_KeyStore);\n         BOOST_CHECK(keystore.GetLegacyScriptPubKeyMan()->AddKey(uncompressedKey));\n \n-        scriptPubKey = GetScriptForDestination(WitnessV0KeyHash(PKHash(uncompressedPubkey)));\n+        scriptPubKey = GetScriptForDestination(WitnessV0KeyHash(uncompressedPubkey));\n \n         // Keystore has key, but no P2SH redeemScript\n         result = keystore.GetLegacyScriptPubKeyMan()->IsMine(scriptPubKey);"
      },
      {
        "sha": "57eec9baf901cc10d67ef15f7436e9bc30fb20ea",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 2,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -2160,6 +2160,11 @@ void CWallet::AvailableCoins(std::vector<COutput>& vCoins, bool fOnlySafe, const\n         }\n \n         for (unsigned int i = 0; i < wtx.tx->vout.size(); i++) {\n+            // Only consider selected coins if add_inputs is false\n+            if (coinControl && !coinControl->m_add_inputs && !coinControl->IsSelected(COutPoint(entry.first, i))) {\n+                continue;\n+            }\n+\n             if (wtx.tx->vout[i].nValue < nMinimumAmount || wtx.tx->vout[i].nValue > nMaximumAmount)\n                 continue;\n \n@@ -2471,8 +2476,11 @@ bool CWallet::SignTransaction(CMutableTransaction& tx, const std::map<COutPoint,\n     return false;\n }\n \n-TransactionError CWallet::FillPSBT(PartiallySignedTransaction& psbtx, bool& complete, int sighash_type, bool sign, bool bip32derivs) const\n+TransactionError CWallet::FillPSBT(PartiallySignedTransaction& psbtx, bool& complete, int sighash_type, bool sign, bool bip32derivs, size_t * n_signed) const\n {\n+    if (n_signed) {\n+        *n_signed = 0;\n+    }\n     LOCK(cs_wallet);\n     // Get all of the previous transactions\n     for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n@@ -2503,10 +2511,15 @@ TransactionError CWallet::FillPSBT(PartiallySignedTransaction& psbtx, bool& comp\n \n     // Fill in information from ScriptPubKeyMans\n     for (ScriptPubKeyMan* spk_man : GetAllScriptPubKeyMans()) {\n-        TransactionError res = spk_man->FillPSBT(psbtx, sighash_type, sign, bip32derivs);\n+        int n_signed_this_spkm = 0;\n+        TransactionError res = spk_man->FillPSBT(psbtx, sighash_type, sign, bip32derivs, &n_signed_this_spkm);\n         if (res != TransactionError::OK) {\n             return res;\n         }\n+\n+        if (n_signed) {\n+            (*n_signed) += n_signed_this_spkm;\n+        }\n     }\n \n     // Complete if every input is now signed"
      },
      {
        "sha": "9931671fb4afa7699afa9b55bc807c952a2adec6",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -964,7 +964,8 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n                   bool& complete,\n                   int sighash_type = 1 /* SIGHASH_ALL */,\n                   bool sign = true,\n-                  bool bip32derivs = true) const;\n+                  bool bip32derivs = true,\n+                  size_t* n_signed = nullptr) const;\n \n     /**\n      * Create a new transaction paying the recipients with a set of coins"
      },
      {
        "sha": "5cddd6527e7c158b9eabe4504b49eac644050041",
        "filename": "test/functional/feature_backwards_compatibility.py",
        "status": "modified",
        "additions": 7,
        "deletions": 11,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/feature_backwards_compatibility.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/feature_backwards_compatibility.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_backwards_compatibility.py?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -27,8 +27,6 @@\n \n from test_framework.util import (\n     assert_equal,\n-    sync_blocks,\n-    sync_mempools,\n )\n \n \n@@ -65,7 +63,7 @@ def setup_nodes(self):\n     def run_test(self):\n         self.nodes[0].generatetoaddress(101, self.nodes[0].getnewaddress())\n \n-        sync_blocks(self.nodes)\n+        self.sync_blocks()\n \n         # Sanity check the test framework:\n         res = self.nodes[self.num_nodes - 1].getblockchaininfo()\n@@ -90,17 +88,17 @@ def run_test(self):\n         # Create a confirmed transaction, receiving coins\n         address = wallet.getnewaddress()\n         self.nodes[0].sendtoaddress(address, 10)\n-        sync_mempools(self.nodes)\n+        self.sync_mempools()\n         self.nodes[0].generate(1)\n-        sync_blocks(self.nodes)\n+        self.sync_blocks()\n         # Create a conflicting transaction using RBF\n         return_address = self.nodes[0].getnewaddress()\n         tx1_id = self.nodes[1].sendtoaddress(return_address, 1)\n         tx2_id = self.nodes[1].bumpfee(tx1_id)[\"txid\"]\n         # Confirm the transaction\n-        sync_mempools(self.nodes)\n+        self.sync_mempools()\n         self.nodes[0].generate(1)\n-        sync_blocks(self.nodes)\n+        self.sync_blocks()\n         # Create another conflicting transaction using RBF\n         tx3_id = self.nodes[1].sendtoaddress(return_address, 1)\n         tx4_id = self.nodes[1].bumpfee(tx3_id)[\"txid\"]\n@@ -313,15 +311,13 @@ def run_test(self):\n         self.start_node(4)\n \n         # Open most recent wallet in v0.16 (no loadwallet RPC)\n-        self.stop_node(5)\n-        self.start_node(5, extra_args=[\"-wallet=w2\"])\n+        self.restart_node(5, extra_args=[\"-wallet=w2\"])\n         wallet = node_v16.get_wallet_rpc(\"w2\")\n         info = wallet.getwalletinfo()\n         assert info['keypoolsize'] == 1\n \n         # Create upgrade wallet in v0.16\n-        self.stop_node(-1)\n-        self.start_node(-1, extra_args=[\"-wallet=u1_v16\"])\n+        self.restart_node(-1, extra_args=[\"-wallet=u1_v16\"])\n         wallet = node_v16.get_wallet_rpc(\"u1_v16\")\n         v16_addr = wallet.getnewaddress('', \"bech32\")\n         v16_info = wallet.validateaddress(v16_addr)"
      },
      {
        "sha": "0a457ca17f749f75235d8c1ae724bcf7b42abb68",
        "filename": "test/functional/feature_loadblock.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/feature_loadblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/feature_loadblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_loadblock.py?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -71,8 +71,7 @@ def run_test(self):\n                        check=True)\n \n         self.log.info(\"Restart second, unsynced node with bootstrap file\")\n-        self.stop_node(1)\n-        self.start_node(1, [\"-loadblock=\" + bootstrap_file])\n+        self.restart_node(1, extra_args=[\"-loadblock=\" + bootstrap_file])\n         assert_equal(self.nodes[1].getblockcount(), 100)  # start_node is blocking on all block files being imported\n \n         assert_equal(self.nodes[1].getblockchaininfo()['blocks'], 100)"
      },
      {
        "sha": "afcbcf099ad33487c5e4b0c1bfd72734ee12a6b8",
        "filename": "test/functional/feature_logging.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/feature_logging.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/feature_logging.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_logging.py?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -67,8 +67,7 @@ def run_test(self):\n         assert not os.path.isfile(default_log_path)\n \n         # just sanity check no crash here\n-        self.stop_node(0)\n-        self.start_node(0, [\"-debuglogfile=%s\" % os.devnull])\n+        self.restart_node(0, [\"-debuglogfile=%s\" % os.devnull])\n \n \n if __name__ == '__main__':"
      },
      {
        "sha": "e46e5aacc8a6b137c1d70ed6e694fe15e86a1b48",
        "filename": "test/functional/feature_pruning.py",
        "status": "modified",
        "additions": 4,
        "deletions": 8,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/feature_pruning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/feature_pruning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_pruning.py?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -263,8 +263,7 @@ def manual_test(self, node_number, use_timestamp):\n         assert_raises_rpc_error(-1, \"not in prune mode\", node.pruneblockchain, 500)\n \n         # now re-start in manual pruning mode\n-        self.stop_node(node_number)\n-        self.start_node(node_number, extra_args=[\"-prune=1\"])\n+        self.restart_node(node_number, extra_args=[\"-prune=1\"])\n         node = self.nodes[node_number]\n         assert_equal(node.getblockcount(), 995)\n \n@@ -326,16 +325,14 @@ def has_block(index):\n         assert not has_block(3), \"blk00003.dat is still there, should be pruned by now\"\n \n         # stop node, start back up with auto-prune at 550 MiB, make sure still runs\n-        self.stop_node(node_number)\n-        self.start_node(node_number, extra_args=[\"-prune=550\"])\n+        self.restart_node(node_number, extra_args=[\"-prune=550\"])\n \n         self.log.info(\"Success\")\n \n     def wallet_test(self):\n         # check that the pruning node's wallet is still in good shape\n         self.log.info(\"Stop and start pruning node to trigger wallet rescan\")\n-        self.stop_node(2)\n-        self.start_node(2, extra_args=[\"-prune=550\"])\n+        self.restart_node(2, extra_args=[\"-prune=550\"])\n         self.log.info(\"Success\")\n \n         # check that wallet loads successfully when restarting a pruned node after IBD.\n@@ -344,8 +341,7 @@ def wallet_test(self):\n         connect_nodes(self.nodes[0], 5)\n         nds = [self.nodes[0], self.nodes[5]]\n         self.sync_blocks(nds, wait=5, timeout=300)\n-        self.stop_node(5)  # stop and start to trigger rescan\n-        self.start_node(5, extra_args=[\"-prune=550\"])\n+        self.restart_node(5, extra_args=[\"-prune=550\"]) # restart to trigger rescan\n         self.log.info(\"Success\")\n \n     def run_test(self):"
      },
      {
        "sha": "5195d20dcb8d0100691d7b95b58476161e1a3c81",
        "filename": "test/functional/feature_segwit.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/feature_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/feature_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_segwit.py?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -559,8 +559,7 @@ def run_test(self):\n             assert_equal(self.nodes[1].listtransactions(\"*\", 1, 0, True)[0][\"txid\"], txid)\n \n             # Assert it is properly saved\n-            self.stop_node(1)\n-            self.start_node(1)\n+            self.restart_node(1)\n             assert_equal(self.nodes[1].gettransaction(txid, True)[\"txid\"], txid)\n             assert_equal(self.nodes[1].listtransactions(\"*\", 1, 0, True)[0][\"txid\"], txid)\n "
      },
      {
        "sha": "80003aca0d11fc28beecf56a6b66887d8ace5647",
        "filename": "test/functional/interface_bitcoin_cli.py",
        "status": "modified",
        "additions": 96,
        "deletions": 6,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/interface_bitcoin_cli.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/interface_bitcoin_cli.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_bitcoin_cli.py?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -3,16 +3,28 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test bitcoin-cli\"\"\"\n+\n from decimal import Decimal\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, assert_raises_process_error, get_auth_cookie\n+from test_framework.util import (\n+    assert_equal,\n+    assert_raises_process_error,\n+    assert_raises_rpc_error,\n+    get_auth_cookie,\n+)\n \n # The block reward of coinbaseoutput.nValue (50) BTC/block matures after\n # COINBASE_MATURITY (100) blocks. Therefore, after mining 101 blocks we expect\n # node 0 to have a balance of (BLOCKS - COINBASE_MATURITY) * 50 BTC/block.\n BLOCKS = 101\n BALANCE = (BLOCKS - 100) * 50\n \n+JSON_PARSING_ERROR = 'error: Error parsing JSON: foo'\n+BLOCKS_VALUE_OF_ZERO = 'error: the first argument (number of blocks to generate, default: 1) must be an integer value greater than zero'\n+TOO_MANY_ARGS = 'error: too many arguments (maximum 2 for nblocks and maxtries)'\n+WALLET_NOT_LOADED = 'Requested wallet does not exist or is not loaded'\n+WALLET_NOT_SPECIFIED = 'Wallet file not specified'\n+\n class TestBitcoinCli(BitcoinTestFramework):\n     def set_test_params(self):\n         self.setup_clean_chain = True\n@@ -75,14 +87,16 @@ def run_test(self):\n             assert_equal(cli_get_info['relayfee'], network_info['relayfee'])\n             assert_equal(self.nodes[0].cli.getwalletinfo(), wallet_info)\n \n-            # Setup to test -getinfo and -rpcwallet= with multiple wallets.\n+            # Setup to test -getinfo, -generate, and -rpcwallet= with multiple wallets.\n             wallets = ['', 'Encrypted', 'secret']\n             amounts = [BALANCE + Decimal('9.999928'), Decimal(9), Decimal(31)]\n             self.nodes[0].createwallet(wallet_name=wallets[1])\n             self.nodes[0].createwallet(wallet_name=wallets[2])\n             w1 = self.nodes[0].get_wallet_rpc(wallets[0])\n             w2 = self.nodes[0].get_wallet_rpc(wallets[1])\n             w3 = self.nodes[0].get_wallet_rpc(wallets[2])\n+            rpcwallet2 = '-rpcwallet={}'.format(wallets[1])\n+            rpcwallet3 = '-rpcwallet={}'.format(wallets[2])\n             w1.walletpassphrase(password, self.rpc_timeout)\n             w2.encryptwallet(password)\n             w1.sendtoaddress(w2.getnewaddress(), amounts[1])\n@@ -123,17 +137,93 @@ def run_test(self):\n             assert_equal(cli_get_info['balance'], amounts[1])\n \n             self.log.info(\"Test -getinfo with -rpcwallet=remaining-non-default-wallet returns only its balance\")\n-            cli_get_info = self.nodes[0].cli('-getinfo', '-rpcwallet={}'.format(wallets[1])).send_cli()\n+            cli_get_info = self.nodes[0].cli('-getinfo', rpcwallet2).send_cli()\n             assert 'balances' not in cli_get_info.keys()\n             assert_equal(cli_get_info['balance'], amounts[1])\n \n             self.log.info(\"Test -getinfo with -rpcwallet=unloaded wallet returns no balances\")\n-            cli_get_info = self.nodes[0].cli('-getinfo', '-rpcwallet={}'.format(wallets[2])).send_cli()\n+            cli_get_info = self.nodes[0].cli('-getinfo', rpcwallet3).send_cli()\n             assert 'balance' not in cli_get_info_keys\n             assert 'balances' not in cli_get_info_keys\n+\n+            # Test bitcoin-cli -generate.\n+            n1 = 3\n+            n2 = 4\n+            w2.walletpassphrase(password, self.rpc_timeout)\n+            blocks = self.nodes[0].getblockcount()\n+\n+            self.log.info('Test -generate with no args')\n+            generate = self.nodes[0].cli('-generate').send_cli()\n+            assert_equal(set(generate.keys()), {'address', 'blocks'})\n+            assert_equal(len(generate[\"blocks\"]), 1)\n+            assert_equal(self.nodes[0].getblockcount(), blocks + 1)\n+\n+            self.log.info('Test -generate with bad args')\n+            assert_raises_process_error(1, JSON_PARSING_ERROR, self.nodes[0].cli('-generate', 'foo').echo)\n+            assert_raises_process_error(1, BLOCKS_VALUE_OF_ZERO, self.nodes[0].cli('-generate', 0).echo)\n+            assert_raises_process_error(1, TOO_MANY_ARGS, self.nodes[0].cli('-generate', 1, 2, 3).echo)\n+\n+            self.log.info('Test -generate with nblocks')\n+            generate = self.nodes[0].cli('-generate', n1).send_cli()\n+            assert_equal(set(generate.keys()), {'address', 'blocks'})\n+            assert_equal(len(generate[\"blocks\"]), n1)\n+            assert_equal(self.nodes[0].getblockcount(), blocks + 1 + n1)\n+\n+            self.log.info('Test -generate with nblocks and maxtries')\n+            generate = self.nodes[0].cli('-generate', n2, 1000000).send_cli()\n+            assert_equal(set(generate.keys()), {'address', 'blocks'})\n+            assert_equal(len(generate[\"blocks\"]), n2)\n+            assert_equal(self.nodes[0].getblockcount(), blocks + 1 + n1 + n2)\n+\n+            self.log.info('Test -generate -rpcwallet in single-wallet mode')\n+            generate = self.nodes[0].cli(rpcwallet2, '-generate').send_cli()\n+            assert_equal(set(generate.keys()), {'address', 'blocks'})\n+            assert_equal(len(generate[\"blocks\"]), 1)\n+            assert_equal(self.nodes[0].getblockcount(), blocks + 2 + n1 + n2)\n+\n+            self.log.info('Test -generate -rpcwallet=unloaded wallet raises RPC error')\n+            assert_raises_rpc_error(-18, WALLET_NOT_LOADED, self.nodes[0].cli(rpcwallet3, '-generate').echo)\n+            assert_raises_rpc_error(-18, WALLET_NOT_LOADED, self.nodes[0].cli(rpcwallet3, '-generate', 'foo').echo)\n+            assert_raises_rpc_error(-18, WALLET_NOT_LOADED, self.nodes[0].cli(rpcwallet3, '-generate', 0).echo)\n+            assert_raises_rpc_error(-18, WALLET_NOT_LOADED, self.nodes[0].cli(rpcwallet3, '-generate', 1, 2, 3).echo)\n+\n+            # Test bitcoin-cli -generate with -rpcwallet in multiwallet mode.\n+            self.nodes[0].loadwallet(wallets[2])\n+            n3 = 4\n+            n4 = 10\n+            blocks = self.nodes[0].getblockcount()\n+\n+            self.log.info('Test -generate -rpcwallet with no args')\n+            generate = self.nodes[0].cli(rpcwallet2, '-generate').send_cli()\n+            assert_equal(set(generate.keys()), {'address', 'blocks'})\n+            assert_equal(len(generate[\"blocks\"]), 1)\n+            assert_equal(self.nodes[0].getblockcount(), blocks + 1)\n+\n+            self.log.info('Test -generate -rpcwallet with bad args')\n+            assert_raises_process_error(1, JSON_PARSING_ERROR, self.nodes[0].cli(rpcwallet2, '-generate', 'foo').echo)\n+            assert_raises_process_error(1, BLOCKS_VALUE_OF_ZERO, self.nodes[0].cli(rpcwallet2, '-generate', 0).echo)\n+            assert_raises_process_error(1, TOO_MANY_ARGS, self.nodes[0].cli(rpcwallet2, '-generate', 1, 2, 3).echo)\n+\n+            self.log.info('Test -generate -rpcwallet with nblocks')\n+            generate = self.nodes[0].cli(rpcwallet2, '-generate', n3).send_cli()\n+            assert_equal(set(generate.keys()), {'address', 'blocks'})\n+            assert_equal(len(generate[\"blocks\"]), n3)\n+            assert_equal(self.nodes[0].getblockcount(), blocks + 1 + n3)\n+\n+            self.log.info('Test -generate -rpcwallet with nblocks and maxtries')\n+            generate = self.nodes[0].cli(rpcwallet2, '-generate', n4, 1000000).send_cli()\n+            assert_equal(set(generate.keys()), {'address', 'blocks'})\n+            assert_equal(len(generate[\"blocks\"]), n4)\n+            assert_equal(self.nodes[0].getblockcount(), blocks + 1 + n3 + n4)\n+\n+            self.log.info('Test -generate without -rpcwallet in multiwallet mode raises RPC error')\n+            assert_raises_rpc_error(-19, WALLET_NOT_SPECIFIED, self.nodes[0].cli('-generate').echo)\n+            assert_raises_rpc_error(-19, WALLET_NOT_SPECIFIED, self.nodes[0].cli('-generate', 'foo').echo)\n+            assert_raises_rpc_error(-19, WALLET_NOT_SPECIFIED, self.nodes[0].cli('-generate', 0).echo)\n+            assert_raises_rpc_error(-19, WALLET_NOT_SPECIFIED, self.nodes[0].cli('-generate', 1, 2, 3).echo)\n         else:\n             self.log.info(\"*** Wallet not compiled; cli getwalletinfo and -getinfo wallet tests skipped\")\n-            self.nodes[0].generate(1)  # maintain block parity with the wallet_compiled conditional branch\n+            self.nodes[0].generate(25)  # maintain block parity with the wallet_compiled conditional branch\n \n         self.log.info(\"Test -version with node stopped\")\n         self.stop_node(0)\n@@ -145,7 +235,7 @@ def run_test(self):\n         self.nodes[0].wait_for_cookie_credentials()  # ensure cookie file is available to avoid race condition\n         blocks = self.nodes[0].cli('-rpcwait').send_cli('getblockcount')\n         self.nodes[0].wait_for_rpc_connection()\n-        assert_equal(blocks, BLOCKS + 1)\n+        assert_equal(blocks, BLOCKS + 25)\n \n \n if __name__ == '__main__':"
      },
      {
        "sha": "09b9ebeb2d2a6972947a2ed11fb67e805a765a6e",
        "filename": "test/functional/p2p_disconnect_ban.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/p2p_disconnect_ban.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/p2p_disconnect_ban.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_disconnect_ban.py?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -69,8 +69,7 @@ def run_test(self):\n         self.nodes[1].setmocktime(old_time + 3)\n         assert_equal(len(self.nodes[1].listbanned()), 3)\n \n-        self.stop_node(1)\n-        self.start_node(1)\n+        self.restart_node(1)\n \n         listAfterShutdown = self.nodes[1].listbanned()\n         assert_equal(\"127.0.0.0/24\", listAfterShutdown[0]['address'])"
      },
      {
        "sha": "f939ea965cf62f8e6d15e3fccb980964f558bd4c",
        "filename": "test/functional/p2p_feefilter.py",
        "status": "modified",
        "additions": 45,
        "deletions": 16,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/p2p_feefilter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/p2p_feefilter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_feefilter.py?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -10,11 +10,13 @@\n from test_framework.messages import MSG_TX, msg_feefilter\n from test_framework.mininode import mininode_lock, P2PInterface\n from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal\n \n \n def hashToHex(hash):\n     return format(hash, '064x')\n \n+\n # Wait up to 60 secs to see if the testnode has received all the expected invs\n def allInvsMatch(invsExpected, testnode):\n     for x in range(60):\n@@ -24,6 +26,18 @@ def allInvsMatch(invsExpected, testnode):\n         time.sleep(1)\n     return False\n \n+\n+class FeefilterConn(P2PInterface):\n+    feefilter_received = False\n+\n+    def on_feefilter(self, message):\n+        self.feefilter_received = True\n+\n+    def assert_feefilter_received(self, recv: bool):\n+        with mininode_lock:\n+            assert_equal(self.feefilter_received, recv)\n+\n+\n class TestP2PConn(P2PInterface):\n     def __init__(self):\n         super().__init__()\n@@ -38,6 +52,7 @@ def clear_invs(self):\n         with mininode_lock:\n             self.txinvs = []\n \n+\n class FeeFilterTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 2\n@@ -46,41 +61,54 @@ def set_test_params(self):\n         # mempool and wallet feerate calculation based on GetFee\n         # rounding down 3 places, leading to stranded transactions.\n         # See issue #16499\n-        self.extra_args = [[\"-minrelaytxfee=0.00000100\", \"-mintxfee=0.00000100\"]]*self.num_nodes\n+        self.extra_args = [[\"-minrelaytxfee=0.00000100\", \"-mintxfee=0.00000100\"]] * self.num_nodes\n \n     def skip_test_if_missing_module(self):\n         self.skip_if_no_wallet()\n \n     def run_test(self):\n+        self.test_feefilter_forcerelay()\n+        self.test_feefilter()\n+\n+    def test_feefilter_forcerelay(self):\n+        self.log.info('Check that peers without forcerelay permission (default) get a feefilter message')\n+        self.nodes[0].add_p2p_connection(FeefilterConn()).assert_feefilter_received(True)\n+\n+        self.log.info('Check that peers with forcerelay permission do not get a feefilter message')\n+        self.restart_node(0, extra_args=['-whitelist=forcerelay@127.0.0.1'])\n+        self.nodes[0].add_p2p_connection(FeefilterConn()).assert_feefilter_received(False)\n+\n+        # Restart to disconnect peers and load default extra_args\n+        self.restart_node(0)\n+        self.connect_nodes(1, 0)\n+\n+    def test_feefilter(self):\n         node1 = self.nodes[1]\n         node0 = self.nodes[0]\n-        # Get out of IBD\n-        node1.generate(1)\n-        self.sync_blocks()\n \n-        self.nodes[0].add_p2p_connection(TestP2PConn())\n+        conn = self.nodes[0].add_p2p_connection(TestP2PConn())\n \n         # Test that invs are received by test connection for all txs at\n         # feerate of .2 sat/byte\n         node1.settxfee(Decimal(\"0.00000200\"))\n         txids = [node1.sendtoaddress(node1.getnewaddress(), 1) for x in range(3)]\n-        assert allInvsMatch(txids, self.nodes[0].p2p)\n-        self.nodes[0].p2p.clear_invs()\n+        assert allInvsMatch(txids, conn)\n+        conn.clear_invs()\n \n         # Set a filter of .15 sat/byte on test connection\n-        self.nodes[0].p2p.send_and_ping(msg_feefilter(150))\n+        conn.send_and_ping(msg_feefilter(150))\n \n         # Test that txs are still being received by test connection (paying .15 sat/byte)\n         node1.settxfee(Decimal(\"0.00000150\"))\n         txids = [node1.sendtoaddress(node1.getnewaddress(), 1) for x in range(3)]\n-        assert allInvsMatch(txids, self.nodes[0].p2p)\n-        self.nodes[0].p2p.clear_invs()\n+        assert allInvsMatch(txids, conn)\n+        conn.clear_invs()\n \n         # Change tx fee rate to .1 sat/byte and test they are no longer received\n         # by the test connection\n         node1.settxfee(Decimal(\"0.00000100\"))\n         [node1.sendtoaddress(node1.getnewaddress(), 1) for x in range(3)]\n-        self.sync_mempools() # must be sure node 0 has received all txs\n+        self.sync_mempools()  # must be sure node 0 has received all txs\n \n         # Send one transaction from node0 that should be received, so that we\n         # we can sync the test on receipt (if node1's txs were relayed, they'd\n@@ -91,14 +119,15 @@ def run_test(self):\n         # as well.\n         node0.settxfee(Decimal(\"0.00020000\"))\n         txids = [node0.sendtoaddress(node0.getnewaddress(), 1)]\n-        assert allInvsMatch(txids, self.nodes[0].p2p)\n-        self.nodes[0].p2p.clear_invs()\n+        assert allInvsMatch(txids, conn)\n+        conn.clear_invs()\n \n         # Remove fee filter and check that txs are received again\n-        self.nodes[0].p2p.send_and_ping(msg_feefilter(0))\n+        conn.send_and_ping(msg_feefilter(0))\n         txids = [node1.sendtoaddress(node1.getnewaddress(), 1) for x in range(3)]\n-        assert allInvsMatch(txids, self.nodes[0].p2p)\n-        self.nodes[0].p2p.clear_invs()\n+        assert allInvsMatch(txids, conn)\n+        conn.clear_invs()\n+\n \n if __name__ == '__main__':\n     FeeFilterTest().main()"
      },
      {
        "sha": "bea202855d1048445eeda6531844efc0910858cb",
        "filename": "test/functional/p2p_permissions.py",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/p2p_permissions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/p2p_permissions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_permissions.py?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -42,6 +42,12 @@ def run_test(self):\n             [\"relay\", \"noban\", \"mempool\"],\n             True)\n \n+        self.checkpermission(\n+            # no permission (even with forcerelay)\n+            [\"-whitelist=@127.0.0.1\", \"-whitelistforcerelay=1\"],\n+            [],\n+            False)\n+\n         self.checkpermission(\n             # relay permission removed (no specific permissions)\n             [\"-whitelist=127.0.0.1\", \"-whitelistrelay=0\"],"
      },
      {
        "sha": "25dd76544261e7a08b701caebee4f966cab9a850",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -1898,8 +1898,7 @@ def test_non_standard_witness(self):\n     def test_upgrade_after_activation(self):\n         \"\"\"Test the behavior of starting up a segwit-aware node after the softfork has activated.\"\"\"\n \n-        self.stop_node(2)\n-        self.start_node(2, extra_args=[\"-segwitheight={}\".format(SEGWIT_HEIGHT)])\n+        self.restart_node(2, extra_args=[\"-segwitheight={}\".format(SEGWIT_HEIGHT)])\n         connect_nodes(self.nodes[0], 2)\n \n         # We reconnect more than 100 blocks, give it plenty of time"
      },
      {
        "sha": "57c8f511acd1f2766296480680a42b4eaeacf95c",
        "filename": "test/functional/rpc_fundrawtransaction.py",
        "status": "modified",
        "additions": 12,
        "deletions": 2,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/rpc_fundrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/rpc_fundrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_fundrawtransaction.py?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -271,7 +271,11 @@ def test_coin_selection(self):\n         assert_equal(utx['txid'], dec_tx['vin'][0]['txid'])\n         assert_equal(\"00\", dec_tx['vin'][0]['scriptSig']['hex'])\n \n+        # Should fail without add_inputs:\n+        assert_raises_rpc_error(-4, \"Insufficient funds\", self.nodes[2].fundrawtransaction, rawtx, {\"add_inputs\": False})\n+        # add_inputs is enabled by default\n         rawtxfund = self.nodes[2].fundrawtransaction(rawtx)\n+\n         dec_tx  = self.nodes[2].decoderawtransaction(rawtxfund['hex'])\n         totalOut = 0\n         matchingOuts = 0\n@@ -299,7 +303,10 @@ def test_two_vin(self):\n         dec_tx  = self.nodes[2].decoderawtransaction(rawtx)\n         assert_equal(utx['txid'], dec_tx['vin'][0]['txid'])\n \n-        rawtxfund = self.nodes[2].fundrawtransaction(rawtx)\n+        # Should fail without add_inputs:\n+        assert_raises_rpc_error(-4, \"Insufficient funds\", self.nodes[2].fundrawtransaction, rawtx, {\"add_inputs\": False})\n+        rawtxfund = self.nodes[2].fundrawtransaction(rawtx, {\"add_inputs\": True})\n+\n         dec_tx  = self.nodes[2].decoderawtransaction(rawtxfund['hex'])\n         totalOut = 0\n         matchingOuts = 0\n@@ -330,7 +337,10 @@ def test_two_vin_two_vout(self):\n         dec_tx  = self.nodes[2].decoderawtransaction(rawtx)\n         assert_equal(utx['txid'], dec_tx['vin'][0]['txid'])\n \n-        rawtxfund = self.nodes[2].fundrawtransaction(rawtx)\n+        # Should fail without add_inputs:\n+        assert_raises_rpc_error(-4, \"Insufficient funds\", self.nodes[2].fundrawtransaction, rawtx, {\"add_inputs\": False})\n+        rawtxfund = self.nodes[2].fundrawtransaction(rawtx, {\"add_inputs\": True})\n+\n         dec_tx  = self.nodes[2].decoderawtransaction(rawtxfund['hex'])\n         totalOut = 0\n         matchingOuts = 0"
      },
      {
        "sha": "09545ebce7e56d620e9f587b5e5efc20ab13c7fe",
        "filename": "test/functional/rpc_getaddressinfo_label_deprecation.py",
        "status": "removed",
        "additions": 0,
        "deletions": 43,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d4f9ae00252ba44909a61db0f606be6fddf904c1/test/functional/rpc_getaddressinfo_label_deprecation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d4f9ae00252ba44909a61db0f606be6fddf904c1/test/functional/rpc_getaddressinfo_label_deprecation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_getaddressinfo_label_deprecation.py?ref=d4f9ae00252ba44909a61db0f606be6fddf904c1",
        "patch": "@@ -1,43 +0,0 @@\n-#!/usr/bin/env python3\n-# Copyright (c) 2020-2019 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"\n-Test deprecation of the RPC getaddressinfo `label` field. It has been\n-superseded by the `labels` field.\n-\n-\"\"\"\n-from test_framework.test_framework import BitcoinTestFramework\n-\n-class GetAddressInfoLabelDeprecationTest(BitcoinTestFramework):\n-    def set_test_params(self):\n-        self.num_nodes = 2\n-        self.setup_clean_chain = False\n-        # Start node[0] with -deprecatedrpc=label, and node[1] without.\n-        self.extra_args = [[\"-deprecatedrpc=label\"], []]\n-\n-    def skip_test_if_missing_module(self):\n-        self.skip_if_no_wallet()\n-\n-    def test_label_with_deprecatedrpc_flag(self):\n-        self.log.info(\"Test getaddressinfo label with -deprecatedrpc flag\")\n-        node = self.nodes[0]\n-        address = node.getnewaddress()\n-        info = node.getaddressinfo(address)\n-        assert \"label\" in info\n-\n-    def test_label_without_deprecatedrpc_flag(self):\n-        self.log.info(\"Test getaddressinfo label without -deprecatedrpc flag\")\n-        node = self.nodes[1]\n-        address = node.getnewaddress()\n-        info = node.getaddressinfo(address)\n-        assert \"label\" not in info\n-\n-    def run_test(self):\n-        \"\"\"Test getaddressinfo label with and without -deprecatedrpc flag.\"\"\"\n-        self.test_label_with_deprecatedrpc_flag()\n-        self.test_label_without_deprecatedrpc_flag()\n-\n-\n-if __name__ == '__main__':\n-    GetAddressInfoLabelDeprecationTest().main()"
      },
      {
        "sha": "903f5536b91cc31ce9c43bb5ac3e27cd9cdb0631",
        "filename": "test/functional/rpc_getaddressinfo_labels_purpose_deprecation.py",
        "status": "removed",
        "additions": 0,
        "deletions": 48,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d4f9ae00252ba44909a61db0f606be6fddf904c1/test/functional/rpc_getaddressinfo_labels_purpose_deprecation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d4f9ae00252ba44909a61db0f606be6fddf904c1/test/functional/rpc_getaddressinfo_labels_purpose_deprecation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_getaddressinfo_labels_purpose_deprecation.py?ref=d4f9ae00252ba44909a61db0f606be6fddf904c1",
        "patch": "@@ -1,48 +0,0 @@\n-#!/usr/bin/env python3\n-# Copyright (c) 2020 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"\n-Test deprecation of RPC getaddressinfo `labels` returning an array\n-containing a JSON object of `name` and purpose` key-value pairs. It now\n-returns an array containing only the label name.\n-\n-\"\"\"\n-from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal\n-\n-LABELS_TO_TEST = frozenset({\"\" , \"New \ud834\udd61 $<#>&!\u0440\u044b\u0431\u0430 Label\"})\n-\n-class GetAddressInfoLabelsPurposeDeprecationTest(BitcoinTestFramework):\n-    def set_test_params(self):\n-        self.num_nodes = 2\n-        self.setup_clean_chain = False\n-        # Start node[0] with -deprecatedrpc=labelspurpose and node[1] without.\n-        self.extra_args = [[\"-deprecatedrpc=labelspurpose\"], []]\n-\n-    def skip_test_if_missing_module(self):\n-        self.skip_if_no_wallet()\n-\n-    def test_labels(self, node_num, label_name, expected_value):\n-        node = self.nodes[node_num]\n-        address = node.getnewaddress()\n-        if label_name != \"\":\n-            node.setlabel(address, label_name)\n-            self.log.info(\"  set label to {}\".format(label_name))\n-        labels = node.getaddressinfo(address)[\"labels\"]\n-        self.log.info(\"  labels = {}\".format(labels))\n-        assert_equal(labels, expected_value)\n-\n-    def run_test(self):\n-        \"\"\"Test getaddressinfo labels with and without -deprecatedrpc flag.\"\"\"\n-        self.log.info(\"Test getaddressinfo labels with -deprecatedrpc flag\")\n-        for label in LABELS_TO_TEST:\n-            self.test_labels(node_num=0, label_name=label, expected_value=[{\"name\": label, \"purpose\": \"receive\"}])\n-\n-        self.log.info(\"Test getaddressinfo labels without -deprecatedrpc flag\")\n-        for label in LABELS_TO_TEST:\n-            self.test_labels(node_num=1, label_name=label, expected_value=[label])\n-\n-\n-if __name__ == '__main__':\n-    GetAddressInfoLabelsPurposeDeprecationTest().main()"
      },
      {
        "sha": "8fa36445cd845c4177800407ad5596cc8a4f1a72",
        "filename": "test/functional/rpc_getblockfilter.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/rpc_getblockfilter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/rpc_getblockfilter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_getblockfilter.py?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -7,7 +7,7 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal, assert_is_hex_string, assert_raises_rpc_error,\n-    connect_nodes, disconnect_nodes, sync_blocks\n+    connect_nodes, disconnect_nodes\n     )\n \n FILTER_TYPES = [\"basic\"]\n@@ -30,7 +30,7 @@ def run_test(self):\n \n         # Reorg node 0 to a new chain\n         connect_nodes(self.nodes[0], 1)\n-        sync_blocks(self.nodes)\n+        self.sync_blocks()\n \n         assert_equal(self.nodes[0].getblockcount(), 4)\n         chain1_hashes = [self.nodes[0].getblockhash(block_height) for block_height in range(4)]"
      },
      {
        "sha": "660953be9b3f0d4020d4854c688cd5deef1f87a6",
        "filename": "test/functional/rpc_psbt.py",
        "status": "modified",
        "additions": 18,
        "deletions": 10,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/rpc_psbt.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/rpc_psbt.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_psbt.py?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -8,6 +8,7 @@\n from decimal import Decimal\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n+    assert_approx,\n     assert_equal,\n     assert_greater_than,\n     assert_raises_rpc_error,\n@@ -85,6 +86,13 @@ def run_test(self):\n         # Create and fund a raw tx for sending 10 BTC\n         psbtx1 = self.nodes[0].walletcreatefundedpsbt([], {self.nodes[2].getnewaddress():10})['psbt']\n \n+        # If inputs are specified, do not automatically add more:\n+        utxo1 = self.nodes[0].listunspent()[0]\n+        assert_raises_rpc_error(-4, \"Insufficient funds\", self.nodes[0].walletcreatefundedpsbt, [{\"txid\": utxo1['txid'], \"vout\": utxo1['vout']}], {self.nodes[2].getnewaddress():90})\n+\n+        psbtx1 = self.nodes[0].walletcreatefundedpsbt([{\"txid\": utxo1['txid'], \"vout\": utxo1['vout']}], {self.nodes[2].getnewaddress():90}, 0, {\"add_inputs\": True})['psbt']\n+        assert_equal(len(self.nodes[0].decodepsbt(psbtx1)['tx']['vin']), 2)\n+\n         # Node 1 should not be able to add anything to it but still return the psbtx same as before\n         psbtx = self.nodes[1].walletprocesspsbt(psbtx1)['psbt']\n         assert_equal(psbtx1, psbtx)\n@@ -152,13 +160,13 @@ def run_test(self):\n         self.nodes[1].sendrawtransaction(self.nodes[1].finalizepsbt(walletprocesspsbt_out['psbt'])['hex'])\n \n         # feeRate of 0.1 BTC / KB produces a total fee slightly below -maxtxfee (~0.05280000):\n-        res = self.nodes[1].walletcreatefundedpsbt([{\"txid\":txid,\"vout\":p2wpkh_pos},{\"txid\":txid,\"vout\":p2sh_p2wpkh_pos},{\"txid\":txid,\"vout\":p2pkh_pos}], {self.nodes[1].getnewaddress():29.99}, 0, {\"feeRate\": 0.1})\n-        assert_greater_than(res[\"fee\"], 0.05)\n-        assert_greater_than(0.06, res[\"fee\"])\n+        res = self.nodes[1].walletcreatefundedpsbt([{\"txid\":txid,\"vout\":p2wpkh_pos},{\"txid\":txid,\"vout\":p2sh_p2wpkh_pos},{\"txid\":txid,\"vout\":p2pkh_pos}], {self.nodes[1].getnewaddress():29.99}, 0, {\"feeRate\": 0.1, \"add_inputs\": True})\n+        assert_approx(res[\"fee\"], 0.055, 0.005)\n \n         # feeRate of 10 BTC / KB produces a total fee well above -maxtxfee\n         # previously this was silently capped at -maxtxfee\n-        assert_raises_rpc_error(-4, \"Fee exceeds maximum configured by -maxtxfee\", self.nodes[1].walletcreatefundedpsbt, [{\"txid\":txid,\"vout\":p2wpkh_pos},{\"txid\":txid,\"vout\":p2sh_p2wpkh_pos},{\"txid\":txid,\"vout\":p2pkh_pos}], {self.nodes[1].getnewaddress():29.99}, 0, {\"feeRate\": 10})\n+        assert_raises_rpc_error(-4, \"Fee exceeds maximum configured by -maxtxfee\", self.nodes[1].walletcreatefundedpsbt, [{\"txid\":txid,\"vout\":p2wpkh_pos},{\"txid\":txid,\"vout\":p2sh_p2wpkh_pos},{\"txid\":txid,\"vout\":p2pkh_pos}], {self.nodes[1].getnewaddress():29.99}, 0, {\"feeRate\": 10, \"add_inputs\": True})\n+        assert_raises_rpc_error(-4, \"Fee exceeds maximum configured by -maxtxfee\", self.nodes[1].walletcreatefundedpsbt, [{\"txid\":txid,\"vout\":p2wpkh_pos},{\"txid\":txid,\"vout\":p2sh_p2wpkh_pos},{\"txid\":txid,\"vout\":p2pkh_pos}], {self.nodes[1].getnewaddress():1}, 0, {\"feeRate\": 10, \"add_inputs\": False})\n \n         # partially sign multisig things with node 1\n         psbtx = wmulti.walletcreatefundedpsbt(inputs=[{\"txid\":txid,\"vout\":p2wsh_pos},{\"txid\":txid,\"vout\":p2sh_pos},{\"txid\":txid,\"vout\":p2sh_p2wsh_pos}], outputs={self.nodes[1].getnewaddress():29.99}, options={'changeAddress': self.nodes[1].getrawchangeaddress()})['psbt']\n@@ -239,23 +247,23 @@ def run_test(self):\n         # replaceable arg\n         block_height = self.nodes[0].getblockcount()\n         unspent = self.nodes[0].listunspent()[0]\n-        psbtx_info = self.nodes[0].walletcreatefundedpsbt([{\"txid\":unspent[\"txid\"], \"vout\":unspent[\"vout\"]}], [{self.nodes[2].getnewaddress():unspent[\"amount\"]+1}], block_height+2, {\"replaceable\": False}, False)\n+        psbtx_info = self.nodes[0].walletcreatefundedpsbt([{\"txid\":unspent[\"txid\"], \"vout\":unspent[\"vout\"]}], [{self.nodes[2].getnewaddress():unspent[\"amount\"]+1}], block_height+2, {\"replaceable\": False, \"add_inputs\": True}, False)\n         decoded_psbt = self.nodes[0].decodepsbt(psbtx_info[\"psbt\"])\n         for tx_in, psbt_in in zip(decoded_psbt[\"tx\"][\"vin\"], decoded_psbt[\"inputs\"]):\n             assert_greater_than(tx_in[\"sequence\"], MAX_BIP125_RBF_SEQUENCE)\n             assert \"bip32_derivs\" not in psbt_in\n         assert_equal(decoded_psbt[\"tx\"][\"locktime\"], block_height+2)\n \n         # Same construction with only locktime set and RBF explicitly enabled\n-        psbtx_info = self.nodes[0].walletcreatefundedpsbt([{\"txid\":unspent[\"txid\"], \"vout\":unspent[\"vout\"]}], [{self.nodes[2].getnewaddress():unspent[\"amount\"]+1}], block_height, {\"replaceable\": True}, True)\n+        psbtx_info = self.nodes[0].walletcreatefundedpsbt([{\"txid\":unspent[\"txid\"], \"vout\":unspent[\"vout\"]}], [{self.nodes[2].getnewaddress():unspent[\"amount\"]+1}], block_height, {\"replaceable\": True, \"add_inputs\": True}, True)\n         decoded_psbt = self.nodes[0].decodepsbt(psbtx_info[\"psbt\"])\n         for tx_in, psbt_in in zip(decoded_psbt[\"tx\"][\"vin\"], decoded_psbt[\"inputs\"]):\n             assert_equal(tx_in[\"sequence\"], MAX_BIP125_RBF_SEQUENCE)\n             assert \"bip32_derivs\" in psbt_in\n         assert_equal(decoded_psbt[\"tx\"][\"locktime\"], block_height)\n \n         # Same construction without optional arguments\n-        psbtx_info = self.nodes[0].walletcreatefundedpsbt([{\"txid\":unspent[\"txid\"], \"vout\":unspent[\"vout\"]}], [{self.nodes[2].getnewaddress():unspent[\"amount\"]+1}])\n+        psbtx_info = self.nodes[0].walletcreatefundedpsbt([], [{self.nodes[2].getnewaddress():unspent[\"amount\"]+1}])\n         decoded_psbt = self.nodes[0].decodepsbt(psbtx_info[\"psbt\"])\n         for tx_in, psbt_in in zip(decoded_psbt[\"tx\"][\"vin\"], decoded_psbt[\"inputs\"]):\n             assert_equal(tx_in[\"sequence\"], MAX_BIP125_RBF_SEQUENCE)\n@@ -264,7 +272,7 @@ def run_test(self):\n \n         # Same construction without optional arguments, for a node with -walletrbf=0\n         unspent1 = self.nodes[1].listunspent()[0]\n-        psbtx_info = self.nodes[1].walletcreatefundedpsbt([{\"txid\":unspent1[\"txid\"], \"vout\":unspent1[\"vout\"]}], [{self.nodes[2].getnewaddress():unspent1[\"amount\"]+1}], block_height)\n+        psbtx_info = self.nodes[1].walletcreatefundedpsbt([{\"txid\":unspent1[\"txid\"], \"vout\":unspent1[\"vout\"]}], [{self.nodes[2].getnewaddress():unspent1[\"amount\"]+1}], block_height, {\"add_inputs\": True})\n         decoded_psbt = self.nodes[1].decodepsbt(psbtx_info[\"psbt\"])\n         for tx_in, psbt_in in zip(decoded_psbt[\"tx\"][\"vin\"], decoded_psbt[\"inputs\"]):\n             assert_greater_than(tx_in[\"sequence\"], MAX_BIP125_RBF_SEQUENCE)\n@@ -275,7 +283,7 @@ def run_test(self):\n         self.nodes[0].walletcreatefundedpsbt([], [{self.nodes[2].getnewaddress():unspent[\"amount\"]+1}], block_height+2, {\"changeAddress\":self.nodes[1].getnewaddress()}, False)\n \n         # Regression test for 14473 (mishandling of already-signed witness transaction):\n-        psbtx_info = self.nodes[0].walletcreatefundedpsbt([{\"txid\":unspent[\"txid\"], \"vout\":unspent[\"vout\"]}], [{self.nodes[2].getnewaddress():unspent[\"amount\"]+1}])\n+        psbtx_info = self.nodes[0].walletcreatefundedpsbt([{\"txid\":unspent[\"txid\"], \"vout\":unspent[\"vout\"]}], [{self.nodes[2].getnewaddress():unspent[\"amount\"]+1}], 0, {\"add_inputs\": True})\n         complete_psbt = self.nodes[0].walletprocesspsbt(psbtx_info[\"psbt\"])\n         double_processed_psbt = self.nodes[0].walletprocesspsbt(complete_psbt[\"psbt\"])\n         assert_equal(complete_psbt, double_processed_psbt)\n@@ -467,7 +475,7 @@ def test_psbt_input_keys(psbt_input, keys):\n         assert_equal(analysis['next'], 'creator')\n         assert_equal(analysis['error'], 'PSBT is not valid. Input 0 specifies invalid prevout')\n \n-        assert_raises_rpc_error(-25, 'Missing inputs', self.nodes[0].walletprocesspsbt, 'cHNidP8BAJoCAAAAAkvEW8NnDtdNtDpsmze+Ht2LH35IJcKv00jKAlUs21RrAwAAAAD/////S8Rbw2cO1020OmybN74e3Ysffkglwq/TSMoCVSzbVGsBAAAAAP7///8CwLYClQAAAAAWABSNJKzjaUb3uOxixsvh1GGE3fW7zQD5ApUAAAAAFgAUKNw0x8HRctAgmvoevm4u1SbN7XIAAAAAAAEAnQIAAAACczMa321tVHuN4GKWKRncycI22aX3uXgwSFUKM2orjRsBAAAAAP7///9zMxrfbW1Ue43gYpYpGdzJwjbZpfe5eDBIVQozaiuNGwAAAAAA/v///wIA+QKVAAAAABl2qRT9zXUVA8Ls5iVqynLHe5/vSe1XyYisQM0ClQAAAAAWABRmWQUcjSjghQ8/uH4Bn/zkakwLtAAAAAAAAQEfQM0ClQAAAAAWABRmWQUcjSjghQ8/uH4Bn/zkakwLtAAAAA==')\n+        assert_raises_rpc_error(-25, 'Inputs missing or spent', self.nodes[0].walletprocesspsbt, 'cHNidP8BAJoCAAAAAkvEW8NnDtdNtDpsmze+Ht2LH35IJcKv00jKAlUs21RrAwAAAAD/////S8Rbw2cO1020OmybN74e3Ysffkglwq/TSMoCVSzbVGsBAAAAAP7///8CwLYClQAAAAAWABSNJKzjaUb3uOxixsvh1GGE3fW7zQD5ApUAAAAAFgAUKNw0x8HRctAgmvoevm4u1SbN7XIAAAAAAAEAnQIAAAACczMa321tVHuN4GKWKRncycI22aX3uXgwSFUKM2orjRsBAAAAAP7///9zMxrfbW1Ue43gYpYpGdzJwjbZpfe5eDBIVQozaiuNGwAAAAAA/v///wIA+QKVAAAAABl2qRT9zXUVA8Ls5iVqynLHe5/vSe1XyYisQM0ClQAAAAAWABRmWQUcjSjghQ8/uH4Bn/zkakwLtAAAAAAAAQEfQM0ClQAAAAAWABRmWQUcjSjghQ8/uH4Bn/zkakwLtAAAAA==')\n \n if __name__ == '__main__':\n     PSBTTest().main()"
      },
      {
        "sha": "9d9e065158a4f91b64e49b39945c1a9c2d6d7f01",
        "filename": "test/functional/test_framework/test_framework.py",
        "status": "modified",
        "additions": 58,
        "deletions": 15,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/test_framework/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/test_framework/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_framework.py?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -31,8 +31,6 @@\n     disconnect_nodes,\n     get_datadir_path,\n     initialize_datadir,\n-    sync_blocks,\n-    sync_mempools,\n )\n \n \n@@ -355,9 +353,9 @@ def setup_network(self):\n         # See fPreferredDownload in net_processing.\n         #\n         # If further outbound connections are needed, they can be added at the beginning of the test with e.g.\n-        # connect_nodes(self.nodes[1], 2)\n+        # self.connect_nodes(1, 2)\n         for i in range(self.num_nodes - 1):\n-            connect_nodes(self.nodes[i + 1], i)\n+            self.connect_nodes(i + 1, i)\n         self.sync_all()\n \n     def setup_nodes(self):\n@@ -534,30 +532,75 @@ def restart_node(self, i, extra_args=None):\n     def wait_for_node_exit(self, i, timeout):\n         self.nodes[i].process.wait(timeout)\n \n+    def connect_nodes(self, a, b):\n+        connect_nodes(self.nodes[a], b)\n+\n+    def disconnect_nodes(self, a, b):\n+        disconnect_nodes(self.nodes[a], b)\n+\n     def split_network(self):\n         \"\"\"\n         Split the network of four nodes into nodes 0/1 and 2/3.\n         \"\"\"\n-        disconnect_nodes(self.nodes[1], 2)\n+        self.disconnect_nodes(1, 2)\n         self.sync_all(self.nodes[:2])\n         self.sync_all(self.nodes[2:])\n \n     def join_network(self):\n         \"\"\"\n         Join the (previously split) network halves together.\n         \"\"\"\n-        connect_nodes(self.nodes[1], 2)\n+        self.connect_nodes(1, 2)\n         self.sync_all()\n \n-    def sync_blocks(self, nodes=None, **kwargs):\n-        sync_blocks(nodes or self.nodes, **kwargs)\n-\n-    def sync_mempools(self, nodes=None, **kwargs):\n-        sync_mempools(nodes or self.nodes, **kwargs)\n-\n-    def sync_all(self, nodes=None, **kwargs):\n-        self.sync_blocks(nodes, **kwargs)\n-        self.sync_mempools(nodes, **kwargs)\n+    def sync_blocks(self, nodes=None, wait=1, timeout=60):\n+        \"\"\"\n+        Wait until everybody has the same tip.\n+        sync_blocks needs to be called with an rpc_connections set that has least\n+        one node already synced to the latest, stable tip, otherwise there's a\n+        chance it might return before all nodes are stably synced.\n+        \"\"\"\n+        rpc_connections = nodes or self.nodes\n+        timeout = int(timeout * self.options.timeout_factor)\n+        stop_time = time.time() + timeout\n+        while time.time() <= stop_time:\n+            best_hash = [x.getbestblockhash() for x in rpc_connections]\n+            if best_hash.count(best_hash[0]) == len(rpc_connections):\n+                return\n+            # Check that each peer has at least one connection\n+            assert (all([len(x.getpeerinfo()) for x in rpc_connections]))\n+            time.sleep(wait)\n+        raise AssertionError(\"Block sync timed out after {}s:{}\".format(\n+            timeout,\n+            \"\".join(\"\\n  {!r}\".format(b) for b in best_hash),\n+        ))\n+\n+    def sync_mempools(self, nodes=None, wait=1, timeout=60, flush_scheduler=True):\n+        \"\"\"\n+        Wait until everybody has the same transactions in their memory\n+        pools\n+        \"\"\"\n+        rpc_connections = nodes or self.nodes\n+        timeout = int(timeout * self.options.timeout_factor)\n+        stop_time = time.time() + timeout\n+        while time.time() <= stop_time:\n+            pool = [set(r.getrawmempool()) for r in rpc_connections]\n+            if pool.count(pool[0]) == len(rpc_connections):\n+                if flush_scheduler:\n+                    for r in rpc_connections:\n+                        r.syncwithvalidationinterfacequeue()\n+                return\n+            # Check that each peer has at least one connection\n+            assert (all([len(x.getpeerinfo()) for x in rpc_connections]))\n+            time.sleep(wait)\n+        raise AssertionError(\"Mempool sync timed out after {}s:{}\".format(\n+            timeout,\n+            \"\".join(\"\\n  {!r}\".format(m) for m in pool),\n+        ))\n+\n+    def sync_all(self, nodes=None):\n+        self.sync_blocks(nodes)\n+        self.sync_mempools(nodes)\n \n     # Private helper methods. These should not be accessed by the subclass test scripts.\n "
      },
      {
        "sha": "506057f1fafa2d28cea87818b093e67d3dcb5d0a",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 0,
        "deletions": 44,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -444,50 +444,6 @@ def connect_nodes(from_connection, node_num):\n     wait_until(lambda: all(peer['bytesrecv_per_msg'].pop('verack', 0) == 24 for peer in from_connection.getpeerinfo()))\n \n \n-def sync_blocks(rpc_connections, *, wait=1, timeout=60):\n-    \"\"\"\n-    Wait until everybody has the same tip.\n-\n-    sync_blocks needs to be called with an rpc_connections set that has least\n-    one node already synced to the latest, stable tip, otherwise there's a\n-    chance it might return before all nodes are stably synced.\n-    \"\"\"\n-    stop_time = time.time() + timeout\n-    while time.time() <= stop_time:\n-        best_hash = [x.getbestblockhash() for x in rpc_connections]\n-        if best_hash.count(best_hash[0]) == len(rpc_connections):\n-            return\n-        # Check that each peer has at least one connection\n-        assert (all([len(x.getpeerinfo()) for x in rpc_connections]))\n-        time.sleep(wait)\n-    raise AssertionError(\"Block sync timed out after {}s:{}\".format(\n-        timeout,\n-        \"\".join(\"\\n  {!r}\".format(b) for b in best_hash),\n-    ))\n-\n-\n-def sync_mempools(rpc_connections, *, wait=1, timeout=60, flush_scheduler=True):\n-    \"\"\"\n-    Wait until everybody has the same transactions in their memory\n-    pools\n-    \"\"\"\n-    stop_time = time.time() + timeout\n-    while time.time() <= stop_time:\n-        pool = [set(r.getrawmempool()) for r in rpc_connections]\n-        if pool.count(pool[0]) == len(rpc_connections):\n-            if flush_scheduler:\n-                for r in rpc_connections:\n-                    r.syncwithvalidationinterfacequeue()\n-            return\n-        # Check that each peer has at least one connection\n-        assert (all([len(x.getpeerinfo()) for x in rpc_connections]))\n-        time.sleep(wait)\n-    raise AssertionError(\"Mempool sync timed out after {}s:{}\".format(\n-        timeout,\n-        \"\".join(\"\\n  {!r}\".format(m) for m in pool),\n-    ))\n-\n-\n # Transaction/Block functions\n #############################\n "
      },
      {
        "sha": "41f9bde183e58c6c6907d851d0456be8a2fc0868",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -242,8 +242,6 @@\n     'p2p_permissions.py',\n     'feature_blocksdir.py',\n     'feature_config_args.py',\n-    'rpc_getaddressinfo_labels_purpose_deprecation.py',\n-    'rpc_getaddressinfo_label_deprecation.py',\n     'rpc_getdescriptorinfo.py',\n     'rpc_help.py',\n     'feature_help.py',"
      },
      {
        "sha": "8837e130052d6567a782765f15608ed6c8183851",
        "filename": "test/functional/wallet_abandonconflict.py",
        "status": "modified",
        "additions": 3,
        "deletions": 6,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/wallet_abandonconflict.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/wallet_abandonconflict.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_abandonconflict.py?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -95,8 +95,7 @@ def run_test(self):\n \n         # Restart the node with a higher min relay fee so the parent tx is no longer in mempool\n         # TODO: redo with eviction\n-        self.stop_node(0)\n-        self.start_node(0, extra_args=[\"-minrelaytxfee=0.0001\"])\n+        self.restart_node(0, extra_args=[\"-minrelaytxfee=0.0001\"])\n         assert self.nodes[0].getmempoolinfo()['loaded']\n \n         # Verify txs no longer in either node's mempool\n@@ -123,8 +122,7 @@ def run_test(self):\n         balance = newbalance\n \n         # Verify that even with a low min relay fee, the tx is not reaccepted from wallet on startup once abandoned\n-        self.stop_node(0)\n-        self.start_node(0, extra_args=[\"-minrelaytxfee=0.00001\"])\n+        self.restart_node(0, extra_args=[\"-minrelaytxfee=0.00001\"])\n         assert self.nodes[0].getmempoolinfo()['loaded']\n \n         assert_equal(len(self.nodes[0].getrawmempool()), 0)\n@@ -145,8 +143,7 @@ def run_test(self):\n         balance = newbalance\n \n         # Remove using high relay fee again\n-        self.stop_node(0)\n-        self.start_node(0, extra_args=[\"-minrelaytxfee=0.0001\"])\n+        self.restart_node(0, extra_args=[\"-minrelaytxfee=0.0001\"])\n         assert self.nodes[0].getmempoolinfo()['loaded']\n         assert_equal(len(self.nodes[0].getrawmempool()), 0)\n         newbalance = self.nodes[0].getbalance()"
      },
      {
        "sha": "eddd9388476ecd8452715a11699afacb20292fef",
        "filename": "test/functional/wallet_avoidreuse.py",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/wallet_avoidreuse.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/wallet_avoidreuse.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_avoidreuse.py?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -110,9 +110,7 @@ def test_persistence(self):\n         assert_equal(self.nodes[0].getwalletinfo()[\"avoid_reuse\"], False)\n         assert_equal(self.nodes[1].getwalletinfo()[\"avoid_reuse\"], True)\n \n-        # Stop and restart node 1\n-        self.stop_node(1)\n-        self.start_node(1)\n+        self.restart_node(1)\n         connect_nodes(self.nodes[0], 1)\n \n         # Flags should still be node1.avoid_reuse=false, node2.avoid_reuse=true"
      },
      {
        "sha": "31829a18b3ad96a8a53e2ae443a4e2797875cdf0",
        "filename": "test/functional/wallet_balance.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/wallet_balance.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/wallet_balance.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_balance.py?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -12,7 +12,6 @@\n     assert_equal,\n     assert_raises_rpc_error,\n     connect_nodes,\n-    sync_blocks,\n )\n \n \n@@ -264,7 +263,7 @@ def test_balances(*, fee_node_1=0):\n         # Now confirm tx_orig\n         self.restart_node(1, ['-persistmempool=0'])\n         connect_nodes(self.nodes[0], 1)\n-        sync_blocks(self.nodes)\n+        self.sync_blocks()\n         self.nodes[1].sendrawtransaction(tx_orig)\n         self.nodes[1].generatetoaddress(1, ADDRESS_WATCHONLY)\n         self.sync_all()"
      },
      {
        "sha": "ba1e494d9aca8ee3aa1b846d641f388609dfc944",
        "filename": "test/functional/wallet_dump.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/wallet_dump.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/wallet_dump.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_dump.py?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -190,8 +190,7 @@ def run_test(self):\n         assert_raises_rpc_error(-8, \"already exists\", lambda: self.nodes[0].dumpwallet(wallet_enc_dump))\n \n         # Restart node with new wallet, and test importwallet\n-        self.stop_node(0)\n-        self.start_node(0, ['-wallet=w2'])\n+        self.restart_node(0, ['-wallet=w2'])\n \n         # Make sure the address is not IsMine before import\n         result = self.nodes[0].getaddressinfo(multisig_addr)"
      },
      {
        "sha": "3c336623e29e584ef5ae7a0b42eb537c7ee2c7f0",
        "filename": "test/functional/wallet_hd.py",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/wallet_hd.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/wallet_hd.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_hd.py?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -103,8 +103,7 @@ def run_test(self):\n         self.sync_all()\n \n         # Needs rescan\n-        self.stop_node(1)\n-        self.start_node(1, extra_args=self.extra_args[1] + ['-rescan'])\n+        self.restart_node(1, extra_args=self.extra_args[1] + ['-rescan'])\n         assert_equal(self.nodes[1].getbalance(), NUM_HD_ADDS + 1)\n \n         # Try a RPC based rescan\n@@ -183,8 +182,7 @@ def run_test(self):\n             self.nodes[0].generate(10)\n             # Restart node 1 with keypool of 3 and a different wallet\n             self.nodes[1].createwallet(wallet_name='origin', blank=True)\n-            self.stop_node(1)\n-            self.start_node(1, extra_args=['-keypool=3', '-wallet=origin'])\n+            self.restart_node(1, extra_args=['-keypool=3', '-wallet=origin'])\n             connect_nodes(self.nodes[0], 1)\n \n             # sethdseed restoring and seeing txs to addresses out of the keypool"
      },
      {
        "sha": "455f1fc5e859c75a31cc4020505ff82964721ba4",
        "filename": "test/functional/wallet_reorgsrestore.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/wallet_reorgsrestore.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/wallet_reorgsrestore.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_reorgsrestore.py?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -77,8 +77,7 @@ def run_test(self):\n         assert_equal(conflicted[\"walletconflicts\"][0], conflicting[\"txid\"])\n \n         # Node0 wallet is shutdown\n-        self.stop_node(0)\n-        self.start_node(0)\n+        self.restart_node(0)\n \n         # The block chain re-orgs and the tx is included in a different block\n         self.nodes[1].generate(9)"
      },
      {
        "sha": "7f1cdbd20bbf23a2310b72dea98e05bdd4b8a54c",
        "filename": "test/functional/wallet_zapwallettxes.py",
        "status": "modified",
        "additions": 6,
        "deletions": 9,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/wallet_zapwallettxes.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/test/functional/wallet_zapwallettxes.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_zapwallettxes.py?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -49,28 +49,25 @@ def run_test(self):\n         assert_equal(self.nodes[0].gettransaction(txid1)['txid'], txid1)\n         assert_equal(self.nodes[0].gettransaction(txid2)['txid'], txid2)\n \n-        # Stop-start node0. Both confirmed and unconfirmed transactions remain in the wallet.\n-        self.stop_node(0)\n-        self.start_node(0)\n+        # Restart node0. Both confirmed and unconfirmed transactions remain in the wallet.\n+        self.restart_node(0)\n \n         assert_equal(self.nodes[0].gettransaction(txid1)['txid'], txid1)\n         assert_equal(self.nodes[0].gettransaction(txid2)['txid'], txid2)\n \n-        # Stop node0 and restart with zapwallettxes and persistmempool. The unconfirmed\n+        # Restart node0 with zapwallettxes and persistmempool. The unconfirmed\n         # transaction is zapped from the wallet, but is re-added when the mempool is reloaded.\n-        self.stop_node(0)\n-        self.start_node(0, [\"-persistmempool=1\", \"-zapwallettxes=2\"])\n+        self.restart_node(0, [\"-persistmempool=1\", \"-zapwallettxes=2\"])\n \n         wait_until(lambda: self.nodes[0].getmempoolinfo()['size'] == 1, timeout=3)\n         self.nodes[0].syncwithvalidationinterfacequeue()  # Flush mempool to wallet\n \n         assert_equal(self.nodes[0].gettransaction(txid1)['txid'], txid1)\n         assert_equal(self.nodes[0].gettransaction(txid2)['txid'], txid2)\n \n-        # Stop node0 and restart with zapwallettxes, but not persistmempool.\n+        # Restart node0 with zapwallettxes, but not persistmempool.\n         # The unconfirmed transaction is zapped and is no longer in the wallet.\n-        self.stop_node(0)\n-        self.start_node(0, [\"-zapwallettxes=2\"])\n+        self.restart_node(0, [\"-zapwallettxes=2\"])\n \n         # tx1 is still be available because it was confirmed\n         assert_equal(self.nodes[0].gettransaction(txid1)['txid'], txid1)"
      },
      {
        "sha": "34f54325b305a4830bc27c8ab7149d571718c816",
        "filename": "test/lint/lint-spelling.ignore-words.txt",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0a78f225c79decb4a131a7001fbde215c6c60f31/test/lint/lint-spelling.ignore-words.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0a78f225c79decb4a131a7001fbde215c6c60f31/test/lint/lint-spelling.ignore-words.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-spelling.ignore-words.txt?ref=0a78f225c79decb4a131a7001fbde215c6c60f31",
        "patch": "@@ -14,3 +14,4 @@ setban\n hist\n ser\n unselect\n+lowercased"
      }
    ]
  }
]