[
  {
    "sha": "86acc9646968213aaa4408635915b1bfd75a10c9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4NmFjYzk2NDY5NjgyMTNhYWE0NDA4NjM1OTE1YjFiZmQ3NWExMGM5",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2020-12-23T11:24:29Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-04-01T07:08:11Z"
      },
      "message": "[net processing] Take NodeId instead of CNode* as originator for RelayAddress()\n\nThis makes the following commit easier.",
      "tree": {
        "sha": "90ce1182c49e34e3e74570a3d5bdac3d65820e6e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/90ce1182c49e34e3e74570a3d5bdac3d65820e6e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/86acc9646968213aaa4408635915b1bfd75a10c9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/86acc9646968213aaa4408635915b1bfd75a10c9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/86acc9646968213aaa4408635915b1bfd75a10c9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/86acc9646968213aaa4408635915b1bfd75a10c9/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "539e4eec63fa5cbc525343c33c40c43f7b48cb6a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/539e4eec63fa5cbc525343c33c40c43f7b48cb6a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/539e4eec63fa5cbc525343c33c40c43f7b48cb6a"
      }
    ],
    "stats": {
      "total": 10,
      "additions": 5,
      "deletions": 5
    },
    "files": [
      {
        "sha": "b800dc67f25084c6fe17014b85aeefcffdda5049",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/86acc9646968213aaa4408635915b1bfd75a10c9/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/86acc9646968213aaa4408635915b1bfd75a10c9/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=86acc9646968213aaa4408635915b1bfd75a10c9",
        "patch": "@@ -1490,13 +1490,13 @@ void PeerManagerImpl::RelayTransaction(const uint256& txid, const uint256& wtxid\n  * address. So within 24h we will likely relay a given address once. This is to\n  * prevent a peer from unjustly giving their address better propagation by sending\n  * it to us repeatedly.\n- * @param[in] originator The peer that sent us the address. We don't want to relay it back.\n+ * @param[in] originator The id of the peer that sent us the address. We don't want to relay it back.\n  * @param[in] addr Address to relay.\n  * @param[in] fReachable Whether the address' network is reachable. We relay unreachable\n  * addresses less.\n  * @param[in] connman Connection manager to choose nodes to relay to.\n  */\n-static void RelayAddress(const CNode& originator,\n+static void RelayAddress(NodeId originator,\n                          const CAddress& addr,\n                          bool fReachable,\n                          const CConnman& connman)\n@@ -1516,8 +1516,8 @@ static void RelayAddress(const CNode& originator,\n     std::array<std::pair<uint64_t, CNode*>,2> best{{{0, nullptr}, {0, nullptr}}};\n     assert(nRelayNodes <= best.size());\n \n-    auto sortfunc = [&best, &hasher, nRelayNodes, &originator, &addr](CNode* pnode) {\n-        if (pnode->RelayAddrsWithConn() && pnode != &originator && pnode->IsAddrCompatible(addr)) {\n+    auto sortfunc = [&best, &hasher, nRelayNodes, originator, &addr](CNode* pnode) {\n+        if (pnode->RelayAddrsWithConn() && pnode->GetId() != originator && pnode->IsAddrCompatible(addr)) {\n             uint64_t hashKey = CSipHasher(hasher).Write(pnode->GetId()).Finalize();\n             for (unsigned int i = 0; i < nRelayNodes; i++) {\n                  if (hashKey > best[i].first) {\n@@ -2683,7 +2683,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             if (addr.nTime > nSince && !pfrom.fGetAddr && vAddr.size() <= 10 && addr.IsRoutable())\n             {\n                 // Relay to a limited number of other nodes\n-                RelayAddress(pfrom, addr, fReachable, m_connman);\n+                RelayAddress(pfrom.GetId(), addr, fReachable, m_connman);\n             }\n             // Do not store addresses outside our network\n             if (fReachable)"
      }
    ]
  },
  {
    "sha": "caba7ae8a505a4b4680a9d7618f65c4e8579a1e2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjYWJhN2FlOGE1MDVhNGI0NjgwYTlkNzYxOGY2NWM0ZTg1NzlhMWUy",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-02-15T11:50:01Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-04-01T07:08:11Z"
      },
      "message": "[net processing] Make RelayAddress() a member function of PeerManagerImpl",
      "tree": {
        "sha": "6b2964d0b919d0777f49ff43f2e372a08ebf7a75",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6b2964d0b919d0777f49ff43f2e372a08ebf7a75"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/caba7ae8a505a4b4680a9d7618f65c4e8579a1e2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/caba7ae8a505a4b4680a9d7618f65c4e8579a1e2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/caba7ae8a505a4b4680a9d7618f65c4e8579a1e2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/caba7ae8a505a4b4680a9d7618f65c4e8579a1e2/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "86acc9646968213aaa4408635915b1bfd75a10c9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/86acc9646968213aaa4408635915b1bfd75a10c9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/86acc9646968213aaa4408635915b1bfd75a10c9"
      }
    ],
    "stats": {
      "total": 41,
      "additions": 21,
      "deletions": 20
    },
    "files": [
      {
        "sha": "7ebd28b69621e8d28ee1237f3db8e2811d15337c",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 20,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/caba7ae8a505a4b4680a9d7618f65c4e8579a1e2/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/caba7ae8a505a4b4680a9d7618f65c4e8579a1e2/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=caba7ae8a505a4b4680a9d7618f65c4e8579a1e2",
        "patch": "@@ -326,6 +326,15 @@ class PeerManagerImpl final : public PeerManager\n     /** Send `addr` messages on a regular schedule. */\n     void MaybeSendAddr(CNode& node, std::chrono::microseconds current_time);\n \n+    /** Relay (gossip) an address to a few randomly chosen nodes.\n+     *\n+     * @param[in] originator   The id of the peer that sent us the address. We don't want to relay it back.\n+     * @param[in] addr         Address to relay.\n+     * @param[in] fReachable   Whether the address' network is reachable. We relay unreachable\n+     *                         addresses less.\n+     */\n+    void RelayAddress(NodeId originator, const CAddress& addr, bool fReachable);\n+\n     const CChainParams& m_chainparams;\n     CConnman& m_connman;\n     CAddrMan& m_addrman;\n@@ -1483,31 +1492,23 @@ void PeerManagerImpl::RelayTransaction(const uint256& txid, const uint256& wtxid\n     });\n }\n \n-/**\n- * Relay (gossip) an address to a few randomly chosen nodes.\n- * We choose the same nodes within a given 24h window (if the list of connected\n- * nodes does not change) and we don't relay to nodes that already know an\n- * address. So within 24h we will likely relay a given address once. This is to\n- * prevent a peer from unjustly giving their address better propagation by sending\n- * it to us repeatedly.\n- * @param[in] originator The id of the peer that sent us the address. We don't want to relay it back.\n- * @param[in] addr Address to relay.\n- * @param[in] fReachable Whether the address' network is reachable. We relay unreachable\n- * addresses less.\n- * @param[in] connman Connection manager to choose nodes to relay to.\n- */\n-static void RelayAddress(NodeId originator,\n-                         const CAddress& addr,\n-                         bool fReachable,\n-                         const CConnman& connman)\n+void PeerManagerImpl::RelayAddress(NodeId originator,\n+                                   const CAddress& addr,\n+                                   bool fReachable)\n {\n+    // We choose the same nodes within a given 24h window (if the list of connected\n+    // nodes does not change) and we don't relay to nodes that already know an\n+    // address. So within 24h we will likely relay a given address once. This is to\n+    // prevent a peer from unjustly giving their address better propagation by sending\n+    // it to us repeatedly.\n+\n     if (!fReachable && !addr.IsRelayable()) return;\n \n     // Relay to a limited number of other nodes\n     // Use deterministic randomness to send to the same nodes for 24 hours\n     // at a time so the m_addr_knowns of the chosen nodes prevent repeats\n     uint64_t hashAddr = addr.GetHash();\n-    const CSipHasher hasher = connman.GetDeterministicRandomizer(RANDOMIZER_ID_ADDRESS_RELAY).Write(hashAddr << 32).Write((GetTime() + hashAddr) / (24 * 60 * 60));\n+    const CSipHasher hasher = m_connman.GetDeterministicRandomizer(RANDOMIZER_ID_ADDRESS_RELAY).Write(hashAddr << 32).Write((GetTime() + hashAddr) / (24 * 60 * 60));\n     FastRandomContext insecure_rand;\n \n     // Relay reachable addresses to 2 peers. Unreachable addresses are relayed randomly to 1 or 2 peers.\n@@ -1535,7 +1536,7 @@ static void RelayAddress(NodeId originator,\n         }\n     };\n \n-    connman.ForEachNodeThen(std::move(sortfunc), std::move(pushfunc));\n+    m_connman.ForEachNodeThen(std::move(sortfunc), std::move(pushfunc));\n }\n \n void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CInv& inv)\n@@ -2683,7 +2684,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             if (addr.nTime > nSince && !pfrom.fGetAddr && vAddr.size() <= 10 && addr.IsRoutable())\n             {\n                 // Relay to a limited number of other nodes\n-                RelayAddress(pfrom.GetId(), addr, fReachable, m_connman);\n+                RelayAddress(pfrom.GetId(), addr, fReachable);\n             }\n             // Do not store addresses outside our network\n             if (fReachable)"
      }
    ]
  },
  {
    "sha": "76568a3351418c878d30ba0373cf76988f93f90e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3NjU2OGEzMzUxNDE4Yzg3OGQzMGJhMDM3M2NmNzY5ODhmOTNmOTBl",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2020-07-10T15:29:57Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-04-30T10:29:14Z"
      },
      "message": "[net processing] Move addr relay data and logic into net processing",
      "tree": {
        "sha": "f17f8cbdb83f7a48b662b32ac086347e582814bb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f17f8cbdb83f7a48b662b32ac086347e582814bb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/76568a3351418c878d30ba0373cf76988f93f90e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/76568a3351418c878d30ba0373cf76988f93f90e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/76568a3351418c878d30ba0373cf76988f93f90e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/76568a3351418c878d30ba0373cf76988f93f90e/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "caba7ae8a505a4b4680a9d7618f65c4e8579a1e2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/caba7ae8a505a4b4680a9d7618f65c4e8579a1e2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/caba7ae8a505a4b4680a9d7618f65c4e8579a1e2"
      }
    ],
    "stats": {
      "total": 250,
      "additions": 112,
      "deletions": 138
    },
    "files": [
      {
        "sha": "b0f426676569fde711d2a536df6dc5809ec7fa3c",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76568a3351418c878d30ba0373cf76988f93f90e/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76568a3351418c878d30ba0373cf76988f93f90e/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=76568a3351418c878d30ba0373cf76988f93f90e",
        "patch": "@@ -2926,10 +2926,6 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, SOCKET hSocketIn, const\n         m_tx_relay = std::make_unique<TxRelay>();\n     }\n \n-    if (RelayAddrsWithConn()) {\n-        m_addr_known = std::make_unique<CRollingBloomFilter>(5000, 0.001);\n-    }\n-\n     for (const std::string &msg : getAllNetMessageTypes())\n         mapRecvBytesPerMsgCmd[msg] = 0;\n     mapRecvBytesPerMsgCmd[NET_MESSAGE_COMMAND_OTHER] = 0;"
      },
      {
        "sha": "dc0d97372fd718cd73d5642c6434633c6530d300",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 0,
        "deletions": 56,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76568a3351418c878d30ba0373cf76988f93f90e/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76568a3351418c878d30ba0373cf76988f93f90e/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=76568a3351418c878d30ba0373cf76988f93f90e",
        "patch": "@@ -54,8 +54,6 @@ static const int TIMEOUT_INTERVAL = 20 * 60;\n static constexpr auto FEELER_INTERVAL = 2min;\n /** Run the extra block-relay-only connection loop once every 5 minutes. **/\n static constexpr auto EXTRA_BLOCK_RELAY_ONLY_PEER_INTERVAL = 5min;\n-/** The maximum number of addresses from our addrman to return in response to a getaddr message. */\n-static constexpr size_t MAX_ADDR_TO_SEND = 1000;\n /** Maximum length of incoming protocol messages (no message over 4 MB is currently acceptable). */\n static const unsigned int MAX_PROTOCOL_MESSAGE_LENGTH = 4 * 1000 * 1000;\n /** Maximum length of the user agent string in `version` message */\n@@ -447,17 +445,11 @@ class CNode\n     }\n     bool fClient{false}; // set by version message\n     bool m_limited_node{false}; //after BIP159, set by version message\n-    /**\n-     * Whether the peer has signaled support for receiving ADDRv2 (BIP155)\n-     * messages, implying a preference to receive ADDRv2 instead of ADDR ones.\n-     */\n-    std::atomic_bool m_wants_addrv2{false};\n     /** fSuccessfullyConnected is set to true on receiving VERACK from the peer. */\n     std::atomic_bool fSuccessfullyConnected{false};\n     // Setting fDisconnect to true will cause the node to be disconnected the\n     // next time DisconnectNodes() runs\n     std::atomic_bool fDisconnect{false};\n-    bool fSentAddr{false};\n     CSemaphoreGrant grantOutbound;\n     std::atomic<int> nRefCount{0};\n \n@@ -504,15 +496,6 @@ class CNode\n         return m_conn_type == ConnectionType::INBOUND;\n     }\n \n-    /* Whether we send addr messages over this connection */\n-    bool RelayAddrsWithConn() const\n-    {\n-        // Don't relay addr messages to peers that we connect to as block-relay-only\n-        // peers (to prevent adversaries from inferring these links from addr\n-        // traffic).\n-        return m_conn_type != ConnectionType::BLOCK_RELAY;\n-    }\n-\n     bool ExpectServicesFromConn() const {\n         switch (m_conn_type) {\n             case ConnectionType::INBOUND:\n@@ -545,14 +528,6 @@ class CNode\n     // Peer selected us as (compact blocks) high-bandwidth peer (BIP152)\n     std::atomic<bool> m_bip152_highbandwidth_from{false};\n \n-    // flood relay\n-    std::vector<CAddress> vAddrToSend;\n-    std::unique_ptr<CRollingBloomFilter> m_addr_known{nullptr};\n-    bool fGetAddr{false};\n-    Mutex m_addr_send_times_mutex;\n-    std::chrono::microseconds m_next_addr_send GUARDED_BY(m_addr_send_times_mutex){0};\n-    std::chrono::microseconds m_next_local_addr_send GUARDED_BY(m_addr_send_times_mutex){0};\n-\n     struct TxRelay {\n         mutable RecursiveMutex cs_filter;\n         // We use fRelayTxes for two purposes -\n@@ -657,37 +632,6 @@ class CNode\n         nRefCount--;\n     }\n \n-    void AddAddressKnown(const CAddress& _addr)\n-    {\n-        assert(m_addr_known);\n-        m_addr_known->insert(_addr.GetKey());\n-    }\n-\n-    /**\n-     * Whether the peer supports the address. For example, a peer that does not\n-     * implement BIP155 cannot receive Tor v3 addresses because it requires\n-     * ADDRv2 (BIP155) encoding.\n-     */\n-    bool IsAddrCompatible(const CAddress& addr) const\n-    {\n-        return m_wants_addrv2 || addr.IsAddrV1Compatible();\n-    }\n-\n-    void PushAddress(const CAddress& _addr, FastRandomContext &insecure_rand)\n-    {\n-        // Known checking here is only to save space from duplicates.\n-        // SendMessages will filter it again for knowns that were added\n-        // after addresses were pushed.\n-        assert(m_addr_known);\n-        if (_addr.IsValid() && !m_addr_known->contains(_addr.GetKey()) && IsAddrCompatible(_addr)) {\n-            if (vAddrToSend.size() >= MAX_ADDR_TO_SEND) {\n-                vAddrToSend[insecure_rand.randrange(vAddrToSend.size())] = _addr;\n-            } else {\n-                vAddrToSend.push_back(_addr);\n-            }\n-        }\n-    }\n-\n     void AddKnownTx(const uint256& hash)\n     {\n         if (m_tx_relay != nullptr) {"
      },
      {
        "sha": "543f58b5e507c6a26af2e29f203c728cf33d987a",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 112,
        "deletions": 56,
        "changes": 168,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76568a3351418c878d30ba0373cf76988f93f90e/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76568a3351418c878d30ba0373cf76988f93f90e/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=76568a3351418c878d30ba0373cf76988f93f90e",
        "patch": "@@ -150,6 +150,8 @@ static constexpr uint32_t MAX_GETCFILTERS_SIZE = 1000;\n static constexpr uint32_t MAX_GETCFHEADERS_SIZE = 2000;\n /** the maximum percentage of addresses from our addrman to return in response to a getaddr message. */\n static constexpr size_t MAX_PCT_ADDR_TO_SEND = 23;\n+/** The maximum number of address records permitted in an ADDR message. */\n+static constexpr size_t MAX_ADDR_TO_SEND{1000};\n \n // Internal stuff\n namespace {\n@@ -210,6 +212,25 @@ struct Peer {\n     /** Whether a ping has been requested by the user */\n     std::atomic<bool> m_ping_queued{false};\n \n+    /** A vector of addresses to send to the peer, limited to MAX_ADDR_TO_SEND. */\n+    std::vector<CAddress> vAddrToSend;\n+    /** Probabilistic filter of addresses that this peer already knows.\n+     *  Used to avoid relaying addresses to this peer more than once. */\n+    const std::unique_ptr<CRollingBloomFilter> m_addr_known;\n+    /** Whether a getaddr request to this peer is outstanding. */\n+    bool fGetAddr{false};\n+    /** Guards address sending timers. */\n+    mutable Mutex m_addr_send_times_mutex;\n+    /** Time point to send the next ADDR message to this peer. */\n+    std::chrono::microseconds m_next_addr_send GUARDED_BY(m_addr_send_times_mutex){0};\n+    /** Time point to possibly re-announce our local address to this peer. */\n+    std::chrono::microseconds m_next_local_addr_send GUARDED_BY(m_addr_send_times_mutex){0};\n+    /** Whether the peer has signaled support for receiving ADDRv2 (BIP155)\n+     *  messages, indicating a preference to receive ADDRv2 instead of ADDR ones. */\n+    std::atomic_bool m_wants_addrv2{false};\n+    /** Whether this peer has already sent us a getaddr message. */\n+    bool fSentAddr{false};\n+\n     /** Set of txids to reconsider once their parent transactions have been accepted **/\n     std::set<uint256> m_orphan_work_set GUARDED_BY(g_cs_orphans);\n \n@@ -218,7 +239,10 @@ struct Peer {\n     /** Work queue of items requested by this peer **/\n     std::deque<CInv> m_getdata_requests GUARDED_BY(m_getdata_requests_mutex);\n \n-    explicit Peer(NodeId id) : m_id(id) {}\n+    explicit Peer(NodeId id, bool addr_relay)\n+        : m_id(id)\n+        , m_addr_known{addr_relay ? std::make_unique<CRollingBloomFilter>(5000, 0.001) : nullptr}\n+    {}\n };\n \n using PeerRef = std::shared_ptr<Peer>;\n@@ -324,7 +348,7 @@ class PeerManagerImpl final : public PeerManager\n     void MaybeSendPing(CNode& node_to, Peer& peer, std::chrono::microseconds now);\n \n     /** Send `addr` messages on a regular schedule. */\n-    void MaybeSendAddr(CNode& node, std::chrono::microseconds current_time);\n+    void MaybeSendAddr(CNode& node, Peer& peer, std::chrono::microseconds current_time);\n \n     /** Relay (gossip) an address to a few randomly chosen nodes.\n      *\n@@ -626,6 +650,42 @@ static CNodeState *State(NodeId pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n     return &it->second;\n }\n \n+static bool RelayAddrsWithPeer(const Peer& peer)\n+{\n+    return peer.m_addr_known != nullptr;\n+}\n+\n+/**\n+ * Whether the peer supports the address. For example, a peer that does not\n+ * implement BIP155 cannot receive Tor v3 addresses because it requires\n+ * ADDRv2 (BIP155) encoding.\n+ */\n+static bool IsAddrCompatible(const Peer& peer, const CAddress& addr)\n+{\n+    return peer.m_wants_addrv2 || addr.IsAddrV1Compatible();\n+}\n+\n+static void AddAddressKnown(Peer& peer, const CAddress& addr)\n+{\n+    assert(peer.m_addr_known);\n+    peer.m_addr_known->insert(addr.GetKey());\n+}\n+\n+static void PushAddress(Peer& peer, const CAddress& addr, FastRandomContext& insecure_rand)\n+{\n+    // Known checking here is only to save space from duplicates.\n+    // Before sending, we'll filter it again for known addresses that were\n+    // added after addresses were pushed.\n+    assert(peer.m_addr_known);\n+    if (addr.IsValid() && !peer.m_addr_known->contains(addr.GetKey()) && IsAddrCompatible(peer, addr)) {\n+        if (peer.vAddrToSend.size() >= MAX_ADDR_TO_SEND) {\n+            peer.vAddrToSend[insecure_rand.randrange(peer.vAddrToSend.size())] = addr;\n+        } else {\n+            peer.vAddrToSend.push_back(addr);\n+        }\n+    }\n+}\n+\n static void UpdatePreferredDownload(const CNode& node, CNodeState* state) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     nPreferredDownload -= state->fPreferredDownload;\n@@ -954,7 +1014,9 @@ void PeerManagerImpl::InitializeNode(CNode *pnode)\n         assert(m_txrequest.Count(nodeid) == 0);\n     }\n     {\n-        PeerRef peer = std::make_shared<Peer>(nodeid);\n+        // Addr relay is disabled for outbound block-relay-only peers to\n+        // prevent adversaries from inferring these links from addr traffic.\n+        PeerRef peer = std::make_shared<Peer>(nodeid, /* addr_relay = */ !pnode->IsBlockOnlyConn());\n         LOCK(m_peer_mutex);\n         m_peer_map.emplace_hint(m_peer_map.end(), nodeid, std::move(peer));\n     }\n@@ -1514,29 +1576,27 @@ void PeerManagerImpl::RelayAddress(NodeId originator,\n     // Relay reachable addresses to 2 peers. Unreachable addresses are relayed randomly to 1 or 2 peers.\n     unsigned int nRelayNodes = (fReachable || (hasher.Finalize() & 1)) ? 2 : 1;\n \n-    std::array<std::pair<uint64_t, CNode*>,2> best{{{0, nullptr}, {0, nullptr}}};\n+    std::array<std::pair<uint64_t, Peer*>, 2> best{{{0, nullptr}, {0, nullptr}}};\n     assert(nRelayNodes <= best.size());\n \n-    auto sortfunc = [&best, &hasher, nRelayNodes, originator, &addr](CNode* pnode) {\n-        if (pnode->RelayAddrsWithConn() && pnode->GetId() != originator && pnode->IsAddrCompatible(addr)) {\n-            uint64_t hashKey = CSipHasher(hasher).Write(pnode->GetId()).Finalize();\n+    LOCK(m_peer_mutex);\n+\n+    for (auto& [id, peer] : m_peer_map) {\n+        if (RelayAddrsWithPeer(*peer) && id != originator && IsAddrCompatible(*peer, addr)) {\n+            uint64_t hashKey = CSipHasher(hasher).Write(id).Finalize();\n             for (unsigned int i = 0; i < nRelayNodes; i++) {\n                  if (hashKey > best[i].first) {\n                      std::copy(best.begin() + i, best.begin() + nRelayNodes - 1, best.begin() + i + 1);\n-                     best[i] = std::make_pair(hashKey, pnode);\n+                     best[i] = std::make_pair(hashKey, peer.get());\n                      break;\n                  }\n             }\n         }\n     };\n \n-    auto pushfunc = [&addr, &best, nRelayNodes, &insecure_rand] {\n-        for (unsigned int i = 0; i < nRelayNodes && best[i].first != 0; i++) {\n-            best[i].second->PushAddress(addr, insecure_rand);\n-        }\n-    };\n-\n-    m_connman.ForEachNodeThen(std::move(sortfunc), std::move(pushfunc));\n+    for (unsigned int i = 0; i < nRelayNodes && best[i].first != 0; i++) {\n+        PushAddress(*best[i].second, addr, insecure_rand);\n+    }\n }\n \n void PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CInv& inv)\n@@ -2457,17 +2517,17 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 if (addr.IsRoutable())\n                 {\n                     LogPrint(BCLog::NET, \"ProcessMessages: advertising address %s\\n\", addr.ToString());\n-                    pfrom.PushAddress(addr, insecure_rand);\n+                    PushAddress(*peer, addr, insecure_rand);\n                 } else if (IsPeerAddrLocalGood(&pfrom)) {\n                     addr.SetIP(addrMe);\n                     LogPrint(BCLog::NET, \"ProcessMessages: advertising address %s\\n\", addr.ToString());\n-                    pfrom.PushAddress(addr, insecure_rand);\n+                    PushAddress(*peer, addr, insecure_rand);\n                 }\n             }\n \n             // Get recent addresses\n             m_connman.PushMessage(&pfrom, CNetMsgMaker(greatest_common_version).Make(NetMsgType::GETADDR));\n-            pfrom.fGetAddr = true;\n+            peer->fGetAddr = true;\n         }\n \n         if (!pfrom.IsInboundConn()) {\n@@ -2626,7 +2686,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             pfrom.fDisconnect = true;\n             return;\n         }\n-        pfrom.m_wants_addrv2 = true;\n+        peer->m_wants_addrv2 = true;\n         return;\n     }\n \n@@ -2648,7 +2708,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n         s >> vAddr;\n \n-        if (!pfrom.RelayAddrsWithConn()) {\n+        if (!RelayAddrsWithPeer(*peer)) {\n             LogPrint(BCLog::NET, \"ignoring %s message from %s peer=%d\\n\", msg_type, pfrom.ConnectionTypeAsString(), pfrom.GetId());\n             return;\n         }\n@@ -2675,14 +2735,13 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n             if (addr.nTime <= 100000000 || addr.nTime > nNow + 10 * 60)\n                 addr.nTime = nNow - 5 * 24 * 60 * 60;\n-            pfrom.AddAddressKnown(addr);\n+            AddAddressKnown(*peer, addr);\n             if (m_banman && (m_banman->IsDiscouraged(addr) || m_banman->IsBanned(addr))) {\n                 // Do not process banned/discouraged addresses beyond remembering we received them\n                 continue;\n             }\n             bool fReachable = IsReachable(addr);\n-            if (addr.nTime > nSince && !pfrom.fGetAddr && vAddr.size() <= 10 && addr.IsRoutable())\n-            {\n+            if (addr.nTime > nSince && !peer->fGetAddr && vAddr.size() <= 10 && addr.IsRoutable()) {\n                 // Relay to a limited number of other nodes\n                 RelayAddress(pfrom.GetId(), addr, fReachable);\n             }\n@@ -2691,8 +2750,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 vAddrOk.push_back(addr);\n         }\n         m_addrman.Add(vAddrOk, pfrom.addr, 2 * 60 * 60);\n-        if (vAddr.size() < 1000)\n-            pfrom.fGetAddr = false;\n+        if (vAddr.size() < 1000) peer->fGetAddr = false;\n         if (pfrom.IsAddrFetchConn()) {\n             LogPrint(BCLog::NET, \"addrfetch connection completed peer=%d; disconnecting\\n\", pfrom.GetId());\n             pfrom.fDisconnect = true;\n@@ -3573,14 +3631,14 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         }\n \n         // Only send one GetAddr response per connection to reduce resource waste\n-        //  and discourage addr stamping of INV announcements.\n-        if (pfrom.fSentAddr) {\n+        // and discourage addr stamping of INV announcements.\n+        if (peer->fSentAddr) {\n             LogPrint(BCLog::NET, \"Ignoring repeated \\\"getaddr\\\". peer=%d\\n\", pfrom.GetId());\n             return;\n         }\n-        pfrom.fSentAddr = true;\n+        peer->fSentAddr = true;\n \n-        pfrom.vAddrToSend.clear();\n+        peer->vAddrToSend.clear();\n         std::vector<CAddress> vAddr;\n         if (pfrom.HasPermission(PF_ADDR)) {\n             vAddr = m_connman.GetAddresses(MAX_ADDR_TO_SEND, MAX_PCT_ADDR_TO_SEND);\n@@ -3589,7 +3647,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         }\n         FastRandomContext insecure_rand;\n         for (const CAddress &addr : vAddr) {\n-            pfrom.PushAddress(addr, insecure_rand);\n+            PushAddress(*peer, addr, insecure_rand);\n         }\n         return;\n     }\n@@ -4147,72 +4205,70 @@ void PeerManagerImpl::MaybeSendPing(CNode& node_to, Peer& peer, std::chrono::mic\n     }\n }\n \n-void PeerManagerImpl::MaybeSendAddr(CNode& node, std::chrono::microseconds current_time)\n+void PeerManagerImpl::MaybeSendAddr(CNode& node, Peer& peer, std::chrono::microseconds current_time)\n {\n     // Nothing to do for non-address-relay peers\n-    if (!node.RelayAddrsWithConn()) return;\n-\n-    assert(node.m_addr_known);\n+    if (!RelayAddrsWithPeer(peer)) return;\n \n-    LOCK(node.m_addr_send_times_mutex);\n+    LOCK(peer.m_addr_send_times_mutex);\n     // Periodically advertise our local address to the peer.\n     if (fListen && !m_chainman.ActiveChainstate().IsInitialBlockDownload() &&\n-        node.m_next_local_addr_send < current_time) {\n+        peer.m_next_local_addr_send < current_time) {\n         // If we've sent before, clear the bloom filter for the peer, so that our\n         // self-announcement will actually go out.\n         // This might be unnecessary if the bloom filter has already rolled\n         // over since our last self-announcement, but there is only a small\n         // bandwidth cost that we can incur by doing this (which happens\n         // once a day on average).\n-        if (node.m_next_local_addr_send != 0us) {\n-            node.m_addr_known->reset();\n+        if (peer.m_next_local_addr_send != 0us) {\n+            peer.m_addr_known->reset();\n         }\n         if (std::optional<CAddress> local_addr = GetLocalAddrForPeer(&node)) {\n             FastRandomContext insecure_rand;\n-            node.PushAddress(*local_addr, insecure_rand);\n+            PushAddress(peer, *local_addr, insecure_rand);\n         }\n-        node.m_next_local_addr_send = PoissonNextSend(current_time, AVG_LOCAL_ADDRESS_BROADCAST_INTERVAL);\n+        peer.m_next_local_addr_send = PoissonNextSend(current_time, AVG_LOCAL_ADDRESS_BROADCAST_INTERVAL);\n     }\n \n     // We sent an `addr` message to this peer recently. Nothing more to do.\n-    if (current_time <= node.m_next_addr_send) return;\n+    if (current_time <= peer.m_next_addr_send) return;\n \n-    node.m_next_addr_send = PoissonNextSend(current_time, AVG_ADDRESS_BROADCAST_INTERVAL);\n+    peer.m_next_addr_send = PoissonNextSend(current_time, AVG_ADDRESS_BROADCAST_INTERVAL);\n \n-    if (!Assume(node.vAddrToSend.size() <= MAX_ADDR_TO_SEND)) {\n+    if (!Assume(peer.vAddrToSend.size() <= MAX_ADDR_TO_SEND)) {\n         // Should be impossible since we always check size before adding to\n         // vAddrToSend. Recover by trimming the vector.\n-        node.vAddrToSend.resize(MAX_ADDR_TO_SEND);\n+        peer.vAddrToSend.resize(MAX_ADDR_TO_SEND);\n     }\n \n     // Remove addr records that the peer already knows about, and add new\n     // addrs to the m_addr_known filter on the same pass.\n-    auto addr_already_known = [&node](const CAddress& addr) {\n-        bool ret = node.m_addr_known->contains(addr.GetKey());\n-        if (!ret) node.m_addr_known->insert(addr.GetKey());\n+    auto addr_already_known = [&peer](const CAddress& addr) {\n+        bool ret = peer.m_addr_known->contains(addr.GetKey());\n+        if (!ret) peer.m_addr_known->insert(addr.GetKey());\n         return ret;\n     };\n-    node.vAddrToSend.erase(std::remove_if(node.vAddrToSend.begin(), node.vAddrToSend.end(), addr_already_known),\n-                           node.vAddrToSend.end());\n+    peer.vAddrToSend.erase(std::remove_if(peer.vAddrToSend.begin(), peer.vAddrToSend.end(), addr_already_known),\n+                           peer.vAddrToSend.end());\n \n     // No addr messages to send\n-    if (node.vAddrToSend.empty()) return;\n+    if (peer.vAddrToSend.empty()) return;\n \n     const char* msg_type;\n     int make_flags;\n-    if (node.m_wants_addrv2) {\n+    if (peer.m_wants_addrv2) {\n         msg_type = NetMsgType::ADDRV2;\n         make_flags = ADDRV2_FORMAT;\n     } else {\n         msg_type = NetMsgType::ADDR;\n         make_flags = 0;\n     }\n-    m_connman.PushMessage(&node, CNetMsgMaker(node.GetCommonVersion()).Make(make_flags, msg_type, node.vAddrToSend));\n-    node.vAddrToSend.clear();\n+    m_connman.PushMessage(&node, CNetMsgMaker(node.GetCommonVersion()).Make(make_flags, msg_type, peer.vAddrToSend));\n+    peer.vAddrToSend.clear();\n \n     // we only send the big addr message once\n-    if (node.vAddrToSend.capacity() > 40) {\n-        node.vAddrToSend.shrink_to_fit();\n+    if (peer.vAddrToSend.capacity() > 40) {\n+        peer.vAddrToSend.shrink_to_fit();\n     }\n }\n \n@@ -4261,7 +4317,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n     // MaybeSendPing may have marked peer for disconnection\n     if (pto->fDisconnect) return true;\n \n-    MaybeSendAddr(*pto, current_time);\n+    MaybeSendAddr(*pto, *peer, current_time);\n \n     {\n         LOCK(cs_main);"
      },
      {
        "sha": "20d858131281295c663779ef3a1397a0e3dd354c",
        "filename": "src/test/fuzz/net.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 22,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76568a3351418c878d30ba0373cf76988f93f90e/src/test/fuzz/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76568a3351418c878d30ba0373cf76988f93f90e/src/test/fuzz/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/net.cpp?ref=76568a3351418c878d30ba0373cf76988f93f90e",
        "patch": "@@ -57,27 +57,6 @@ FUZZ_TARGET_INIT(net, initialize_net)\n                     node.Release();\n                 }\n             },\n-            [&] {\n-                if (node.m_addr_known == nullptr) {\n-                    return;\n-                }\n-                const std::optional<CAddress> addr_opt = ConsumeDeserializable<CAddress>(fuzzed_data_provider);\n-                if (!addr_opt) {\n-                    return;\n-                }\n-                node.AddAddressKnown(*addr_opt);\n-            },\n-            [&] {\n-                if (node.m_addr_known == nullptr) {\n-                    return;\n-                }\n-                const std::optional<CAddress> addr_opt = ConsumeDeserializable<CAddress>(fuzzed_data_provider);\n-                if (!addr_opt) {\n-                    return;\n-                }\n-                FastRandomContext fast_random_context{ConsumeUInt256(fuzzed_data_provider)};\n-                node.PushAddress(*addr_opt, fast_random_context);\n-            },\n             [&] {\n                 const std::optional<CInv> inv_opt = ConsumeDeserializable<CInv>(fuzzed_data_provider);\n                 if (!inv_opt) {\n@@ -110,7 +89,6 @@ FUZZ_TARGET_INIT(net, initialize_net)\n     const int ref_count = node.GetRefCount();\n     assert(ref_count >= 0);\n     (void)node.GetCommonVersion();\n-    (void)node.RelayAddrsWithConn();\n \n     const NetPermissionFlags net_permission_flags = ConsumeWeakEnum(fuzzed_data_provider, ALL_NET_PERMISSION_FLAGS);\n     (void)node.HasPermission(net_permission_flags);"
      }
    ]
  },
  {
    "sha": "09cc66c00e1d5fabe11ffcc32cad060e6b483b20",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowOWNjNjZjMDBlMWQ1ZmFiZTExZmZjYzMyY2FkMDYwZTZiNDgzYjIw",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2020-06-16T20:27:34Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-04-30T10:29:16Z"
      },
      "message": "scripted-diff: rename address relay fields\n\n-BEGIN VERIFY SCRIPT-\nren() { sed -i \"s:\\<$1\\>:$2:g\" $(git grep -l \"\\<$1\\>\" ./src ./test); }\n\nren fGetAddr     m_getaddr_sent\nren fSentAddr    m_getaddr_recvd\nren vAddrToSend  m_addrs_to_send\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "ac6007f04168fa4ebfc2e21d68e68f49c08df2fc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ac6007f04168fa4ebfc2e21d68e68f49c08df2fc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/09cc66c00e1d5fabe11ffcc32cad060e6b483b20",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/09cc66c00e1d5fabe11ffcc32cad060e6b483b20",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/09cc66c00e1d5fabe11ffcc32cad060e6b483b20",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/09cc66c00e1d5fabe11ffcc32cad060e6b483b20/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "76568a3351418c878d30ba0373cf76988f93f90e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/76568a3351418c878d30ba0373cf76988f93f90e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/76568a3351418c878d30ba0373cf76988f93f90e"
      }
    ],
    "stats": {
      "total": 44,
      "additions": 22,
      "deletions": 22
    },
    "files": [
      {
        "sha": "f2e2a4dbe1fc01c87db0418f31099c634db680ad",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 22,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/09cc66c00e1d5fabe11ffcc32cad060e6b483b20/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/09cc66c00e1d5fabe11ffcc32cad060e6b483b20/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=09cc66c00e1d5fabe11ffcc32cad060e6b483b20",
        "patch": "@@ -213,12 +213,12 @@ struct Peer {\n     std::atomic<bool> m_ping_queued{false};\n \n     /** A vector of addresses to send to the peer, limited to MAX_ADDR_TO_SEND. */\n-    std::vector<CAddress> vAddrToSend;\n+    std::vector<CAddress> m_addrs_to_send;\n     /** Probabilistic filter of addresses that this peer already knows.\n      *  Used to avoid relaying addresses to this peer more than once. */\n     const std::unique_ptr<CRollingBloomFilter> m_addr_known;\n     /** Whether a getaddr request to this peer is outstanding. */\n-    bool fGetAddr{false};\n+    bool m_getaddr_sent{false};\n     /** Guards address sending timers. */\n     mutable Mutex m_addr_send_times_mutex;\n     /** Time point to send the next ADDR message to this peer. */\n@@ -229,7 +229,7 @@ struct Peer {\n      *  messages, indicating a preference to receive ADDRv2 instead of ADDR ones. */\n     std::atomic_bool m_wants_addrv2{false};\n     /** Whether this peer has already sent us a getaddr message. */\n-    bool fSentAddr{false};\n+    bool m_getaddr_recvd{false};\n \n     /** Set of txids to reconsider once their parent transactions have been accepted **/\n     std::set<uint256> m_orphan_work_set GUARDED_BY(g_cs_orphans);\n@@ -678,10 +678,10 @@ static void PushAddress(Peer& peer, const CAddress& addr, FastRandomContext& ins\n     // added after addresses were pushed.\n     assert(peer.m_addr_known);\n     if (addr.IsValid() && !peer.m_addr_known->contains(addr.GetKey()) && IsAddrCompatible(peer, addr)) {\n-        if (peer.vAddrToSend.size() >= MAX_ADDR_TO_SEND) {\n-            peer.vAddrToSend[insecure_rand.randrange(peer.vAddrToSend.size())] = addr;\n+        if (peer.m_addrs_to_send.size() >= MAX_ADDR_TO_SEND) {\n+            peer.m_addrs_to_send[insecure_rand.randrange(peer.m_addrs_to_send.size())] = addr;\n         } else {\n-            peer.vAddrToSend.push_back(addr);\n+            peer.m_addrs_to_send.push_back(addr);\n         }\n     }\n }\n@@ -2527,7 +2527,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n             // Get recent addresses\n             m_connman.PushMessage(&pfrom, CNetMsgMaker(greatest_common_version).Make(NetMsgType::GETADDR));\n-            peer->fGetAddr = true;\n+            peer->m_getaddr_sent = true;\n         }\n \n         if (!pfrom.IsInboundConn()) {\n@@ -2741,7 +2741,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 continue;\n             }\n             bool fReachable = IsReachable(addr);\n-            if (addr.nTime > nSince && !peer->fGetAddr && vAddr.size() <= 10 && addr.IsRoutable()) {\n+            if (addr.nTime > nSince && !peer->m_getaddr_sent && vAddr.size() <= 10 && addr.IsRoutable()) {\n                 // Relay to a limited number of other nodes\n                 RelayAddress(pfrom.GetId(), addr, fReachable);\n             }\n@@ -2750,7 +2750,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 vAddrOk.push_back(addr);\n         }\n         m_addrman.Add(vAddrOk, pfrom.addr, 2 * 60 * 60);\n-        if (vAddr.size() < 1000) peer->fGetAddr = false;\n+        if (vAddr.size() < 1000) peer->m_getaddr_sent = false;\n         if (pfrom.IsAddrFetchConn()) {\n             LogPrint(BCLog::NET, \"addrfetch connection completed peer=%d; disconnecting\\n\", pfrom.GetId());\n             pfrom.fDisconnect = true;\n@@ -3632,13 +3632,13 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n         // Only send one GetAddr response per connection to reduce resource waste\n         // and discourage addr stamping of INV announcements.\n-        if (peer->fSentAddr) {\n+        if (peer->m_getaddr_recvd) {\n             LogPrint(BCLog::NET, \"Ignoring repeated \\\"getaddr\\\". peer=%d\\n\", pfrom.GetId());\n             return;\n         }\n-        peer->fSentAddr = true;\n+        peer->m_getaddr_recvd = true;\n \n-        peer->vAddrToSend.clear();\n+        peer->m_addrs_to_send.clear();\n         std::vector<CAddress> vAddr;\n         if (pfrom.HasPermission(PF_ADDR)) {\n             vAddr = m_connman.GetAddresses(MAX_ADDR_TO_SEND, MAX_PCT_ADDR_TO_SEND);\n@@ -4235,10 +4235,10 @@ void PeerManagerImpl::MaybeSendAddr(CNode& node, Peer& peer, std::chrono::micros\n \n     peer.m_next_addr_send = PoissonNextSend(current_time, AVG_ADDRESS_BROADCAST_INTERVAL);\n \n-    if (!Assume(peer.vAddrToSend.size() <= MAX_ADDR_TO_SEND)) {\n+    if (!Assume(peer.m_addrs_to_send.size() <= MAX_ADDR_TO_SEND)) {\n         // Should be impossible since we always check size before adding to\n-        // vAddrToSend. Recover by trimming the vector.\n-        peer.vAddrToSend.resize(MAX_ADDR_TO_SEND);\n+        // m_addrs_to_send. Recover by trimming the vector.\n+        peer.m_addrs_to_send.resize(MAX_ADDR_TO_SEND);\n     }\n \n     // Remove addr records that the peer already knows about, and add new\n@@ -4248,11 +4248,11 @@ void PeerManagerImpl::MaybeSendAddr(CNode& node, Peer& peer, std::chrono::micros\n         if (!ret) peer.m_addr_known->insert(addr.GetKey());\n         return ret;\n     };\n-    peer.vAddrToSend.erase(std::remove_if(peer.vAddrToSend.begin(), peer.vAddrToSend.end(), addr_already_known),\n-                           peer.vAddrToSend.end());\n+    peer.m_addrs_to_send.erase(std::remove_if(peer.m_addrs_to_send.begin(), peer.m_addrs_to_send.end(), addr_already_known),\n+                           peer.m_addrs_to_send.end());\n \n     // No addr messages to send\n-    if (peer.vAddrToSend.empty()) return;\n+    if (peer.m_addrs_to_send.empty()) return;\n \n     const char* msg_type;\n     int make_flags;\n@@ -4263,12 +4263,12 @@ void PeerManagerImpl::MaybeSendAddr(CNode& node, Peer& peer, std::chrono::micros\n         msg_type = NetMsgType::ADDR;\n         make_flags = 0;\n     }\n-    m_connman.PushMessage(&node, CNetMsgMaker(node.GetCommonVersion()).Make(make_flags, msg_type, peer.vAddrToSend));\n-    peer.vAddrToSend.clear();\n+    m_connman.PushMessage(&node, CNetMsgMaker(node.GetCommonVersion()).Make(make_flags, msg_type, peer.m_addrs_to_send));\n+    peer.m_addrs_to_send.clear();\n \n     // we only send the big addr message once\n-    if (peer.vAddrToSend.capacity() > 40) {\n-        peer.vAddrToSend.shrink_to_fit();\n+    if (peer.m_addrs_to_send.capacity() > 40) {\n+        peer.m_addrs_to_send.shrink_to_fit();\n     }\n }\n "
      }
    ]
  },
  {
    "sha": "0829516d1f3868c1c2ba507feee718325d81e329",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowODI5NTE2ZDFmMzg2OGMxYzJiYTUwN2ZlZWU3MTgzMjVkODFlMzI5",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2020-12-23T11:58:57Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-04-30T10:29:17Z"
      },
      "message": "[refactor] Remove unused ForEachNodeThen() template",
      "tree": {
        "sha": "483863fbe439aff262a38c821b387952383ccfa4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/483863fbe439aff262a38c821b387952383ccfa4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0829516d1f3868c1c2ba507feee718325d81e329",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0829516d1f3868c1c2ba507feee718325d81e329",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0829516d1f3868c1c2ba507feee718325d81e329",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0829516d1f3868c1c2ba507feee718325d81e329/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "09cc66c00e1d5fabe11ffcc32cad060e6b483b20",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/09cc66c00e1d5fabe11ffcc32cad060e6b483b20",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/09cc66c00e1d5fabe11ffcc32cad060e6b483b20"
      }
    ],
    "stats": {
      "total": 25,
      "additions": 0,
      "deletions": 25
    },
    "files": [
      {
        "sha": "40b17e7020ea71c82c0ad72815f66d06a5d558aa",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 0,
        "deletions": 22,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0829516d1f3868c1c2ba507feee718325d81e329/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0829516d1f3868c1c2ba507feee718325d81e329/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=0829516d1f3868c1c2ba507feee718325d81e329",
        "patch": "@@ -844,28 +844,6 @@ class CConnman\n         }\n     };\n \n-    template<typename Callable, typename CallableAfter>\n-    void ForEachNodeThen(Callable&& pre, CallableAfter&& post)\n-    {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                pre(node);\n-        }\n-        post();\n-    };\n-\n-    template<typename Callable, typename CallableAfter>\n-    void ForEachNodeThen(Callable&& pre, CallableAfter&& post) const\n-    {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                pre(node);\n-        }\n-        post();\n-    };\n-\n     // Addrman functions\n     std::vector<CAddress> GetAddresses(size_t max_addresses, size_t max_pct);\n     /**"
      },
      {
        "sha": "acfd5f9797533a87bd54755aed74ea5cd9c6bb6d",
        "filename": "src/test/fuzz/connman.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0829516d1f3868c1c2ba507feee718325d81e329/src/test/fuzz/connman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0829516d1f3868c1c2ba507feee718325d81e329/src/test/fuzz/connman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/connman.cpp?ref=0829516d1f3868c1c2ba507feee718325d81e329",
        "patch": "@@ -64,9 +64,6 @@ FUZZ_TARGET_INIT(connman, initialize_connman)\n             [&] {\n                 connman.ForEachNode([](auto) {});\n             },\n-            [&] {\n-                connman.ForEachNodeThen([](auto) {}, []() {});\n-            },\n             [&] {\n                 (void)connman.ForNode(fuzzed_data_provider.ConsumeIntegral<NodeId>(), [&](auto) { return fuzzed_data_provider.ConsumeBool(); });\n             },"
      }
    ]
  }
]