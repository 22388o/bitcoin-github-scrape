[
  {
    "sha": "32008e82191f0a6952c5e96a90aa809a7024cb58",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozMjAwOGU4MjE5MWYwYTY5NTJjNWU5NmE5MGFhODA5YTcwMjRjYjU4",
    "commit": {
      "author": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2015-02-10T07:58:29Z"
      },
      "committer": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2015-06-29T01:08:11Z"
      },
      "message": "Add replace-by-fee logic to the mempool\n\nReplaces transactions already in the mempool if a new transaction is\nseen with a higher fee, specifically both a higher fee per KB and a\nhigher absolute fee. Children are evaluated for replacement as well,\nusing a fixed depth/breadth limit to prevent DoS attacks.\n\nIncludes stand-alone unittests for regtest in qa/replace-by-fee/",
      "tree": {
        "sha": "2f896c86a5fdd5fff68669ba839031a11cdaeb0c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2f896c86a5fdd5fff68669ba839031a11cdaeb0c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/32008e82191f0a6952c5e96a90aa809a7024cb58",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/32008e82191f0a6952c5e96a90aa809a7024cb58",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/32008e82191f0a6952c5e96a90aa809a7024cb58",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/32008e82191f0a6952c5e96a90aa809a7024cb58/comments",
    "author": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "247b91449ad7d041c6af5d2abf5660ab00be0fb4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/247b91449ad7d041c6af5d2abf5660ab00be0fb4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/247b91449ad7d041c6af5d2abf5660ab00be0fb4"
      }
    ],
    "stats": {
      "total": 492,
      "additions": 478,
      "deletions": 14
    },
    "files": [
      {
        "sha": "b2c4f4657aebb1a2bffcc5e7a7d1c3bcdefdd56f",
        "filename": "qa/replace-by-fee/.gitignore",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32008e82191f0a6952c5e96a90aa809a7024cb58/qa/replace-by-fee/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32008e82191f0a6952c5e96a90aa809a7024cb58/qa/replace-by-fee/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/replace-by-fee/.gitignore?ref=32008e82191f0a6952c5e96a90aa809a7024cb58",
        "patch": "@@ -0,0 +1 @@\n+python-bitcoinlib"
      },
      {
        "sha": "220b35aac4c63b1cd46fc64f3d8cbb0c10f1b41a",
        "filename": "qa/replace-by-fee/README.md",
        "status": "added",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32008e82191f0a6952c5e96a90aa809a7024cb58/qa/replace-by-fee/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32008e82191f0a6952c5e96a90aa809a7024cb58/qa/replace-by-fee/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/replace-by-fee/README.md?ref=32008e82191f0a6952c5e96a90aa809a7024cb58",
        "patch": "@@ -0,0 +1,13 @@\n+Replace-by-fee regression tests\n+===============================\n+\n+First get version v0.3.0 of the python-bitcoinlib library. In this directory\n+run:\n+\n+    git clone -n https://github.com/petertodd/python-bitcoinlib\n+    (cd python-bitcoinlib && git checkout c481254c623cc9a002187dc23263cce3e05f5754)\n+\n+Then run the tests themselves with a bitcoind available running in regtest\n+mode:\n+\n+    ./full-rbf-tests.py"
      },
      {
        "sha": "ead30fa098c79e985fce01adf61882dbae13e606",
        "filename": "qa/replace-by-fee/full-rbf-tests.py",
        "status": "added",
        "additions": 331,
        "deletions": 0,
        "changes": 331,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32008e82191f0a6952c5e96a90aa809a7024cb58/qa/replace-by-fee/full-rbf-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32008e82191f0a6952c5e96a90aa809a7024cb58/qa/replace-by-fee/full-rbf-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/replace-by-fee/full-rbf-tests.py?ref=32008e82191f0a6952c5e96a90aa809a7024cb58",
        "patch": "@@ -0,0 +1,331 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2015 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test replace-by-fee\n+#\n+\n+import os\n+import sys\n+\n+# Add python-bitcoinlib to module search path:\n+sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), \"python-bitcoinlib\"))\n+\n+import unittest\n+\n+import bitcoin\n+bitcoin.SelectParams('regtest')\n+\n+import bitcoin.rpc\n+\n+from bitcoin.core import *\n+from bitcoin.core.script import *\n+from bitcoin.wallet import *\n+\n+MAX_REPLACEMENT_LIMIT = 100\n+\n+class Test_ReplaceByFee(unittest.TestCase):\n+    proxy = None\n+\n+    @classmethod\n+    def setUpClass(cls):\n+        if cls.proxy is None:\n+            cls.proxy = bitcoin.rpc.Proxy()\n+\n+    @classmethod\n+    def tearDownClass(cls):\n+        # Make sure mining works\n+        mempool_size = 1\n+        while mempool_size:\n+            cls.proxy.generate(1)\n+            new_mempool_size = len(cls.proxy.getrawmempool())\n+\n+            # It's possible to get stuck in a loop here if the mempool has\n+            # transactions that can't be mined.\n+            assert(new_mempool_size != mempool_size)\n+            mempool_size = new_mempool_size\n+\n+    def make_txout(self, amount, scriptPubKey=CScript([1])):\n+        \"\"\"Create a txout with a given amount and scriptPubKey\n+\n+        Mines coins as needed.\n+        \"\"\"\n+        fee = 1*COIN\n+        while self.proxy.getbalance() < amount + fee:\n+            self.proxy.generate(100)\n+\n+        addr = P2SHBitcoinAddress.from_redeemScript(CScript([]))\n+        txid = self.proxy.sendtoaddress(addr, amount + fee)\n+\n+        tx1 = self.proxy.getrawtransaction(txid)\n+\n+        i = None\n+        for i, txout in enumerate(tx1.vout):\n+            if txout.scriptPubKey == addr.to_scriptPubKey():\n+                break\n+        assert i is not None\n+\n+        tx2 = CTransaction([CTxIn(COutPoint(txid, i), CScript([1, CScript([])]))],\n+                           [CTxOut(amount, scriptPubKey)])\n+\n+        tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+\n+        return COutPoint(tx2_txid, 0)\n+\n+    def test_simple_doublespend(self):\n+        \"\"\"Simple doublespend\"\"\"\n+        tx0_outpoint = self.make_txout(1.1*COIN)\n+\n+        tx1a = CTransaction([CTxIn(tx0_outpoint)],\n+                            [CTxOut(1*COIN, CScript([b'a']))])\n+        tx1a_txid = self.proxy.sendrawtransaction(tx1a, True)\n+\n+        # Should fail because we haven't changed the fee\n+        tx1b = CTransaction([CTxIn(tx0_outpoint)],\n+                            [CTxOut(1*COIN, CScript([b'b']))])\n+\n+        try:\n+            tx1b_txid = self.proxy.sendrawtransaction(tx1b, True)\n+        except bitcoin.rpc.JSONRPCException as exp:\n+            self.assertEqual(exp.error['code'], -26) # insufficient fee\n+        else:\n+            self.fail()\n+\n+        # Extra 0.1 BTC fee\n+        tx1b = CTransaction([CTxIn(tx0_outpoint)],\n+                            [CTxOut(0.9*COIN, CScript([b'b']))])\n+        tx1b_txid = self.proxy.sendrawtransaction(tx1b, True)\n+\n+        # tx1a is in fact replaced\n+        with self.assertRaises(IndexError):\n+            self.proxy.getrawtransaction(tx1a_txid)\n+\n+        self.assertEqual(tx1b, self.proxy.getrawtransaction(tx1b_txid))\n+\n+    def test_doublespend_chain(self):\n+        \"\"\"Doublespend of a long chain\"\"\"\n+\n+        initial_nValue = 50*COIN\n+        tx0_outpoint = self.make_txout(initial_nValue)\n+\n+        prevout = tx0_outpoint\n+        remaining_value = initial_nValue\n+        chain_txids = []\n+        while remaining_value > 10*COIN:\n+            remaining_value -= 1*COIN\n+            tx = CTransaction([CTxIn(prevout)],\n+                              [CTxOut(remaining_value, CScript([1]))])\n+            txid = self.proxy.sendrawtransaction(tx, True)\n+            chain_txids.append(txid)\n+            prevout = COutPoint(txid, 0)\n+\n+        # Whether the double-spend is allowed is evaluated by including all\n+        # child fees - 40 BTC - so this attempt is rejected.\n+        dbl_tx = CTransaction([CTxIn(tx0_outpoint)],\n+                              [CTxOut(initial_nValue - 30*COIN, CScript([1]))])\n+\n+        try:\n+            self.proxy.sendrawtransaction(dbl_tx, True)\n+        except bitcoin.rpc.JSONRPCException as exp:\n+            self.assertEqual(exp.error['code'], -26) # insufficient fee\n+        else:\n+            self.fail()\n+\n+        # Accepted with sufficient fee\n+        dbl_tx = CTransaction([CTxIn(tx0_outpoint)],\n+                              [CTxOut(1*COIN, CScript([1]))])\n+        self.proxy.sendrawtransaction(dbl_tx, True)\n+\n+        for doublespent_txid in chain_txids:\n+            with self.assertRaises(IndexError):\n+                self.proxy.getrawtransaction(doublespent_txid)\n+\n+    def test_doublespend_tree(self):\n+        \"\"\"Doublespend of a big tree of transactions\"\"\"\n+\n+        initial_nValue = 50*COIN\n+        tx0_outpoint = self.make_txout(initial_nValue)\n+\n+        def branch(prevout, initial_value, max_txs, *, tree_width=5, fee=0.0001*COIN, _total_txs=None):\n+            if _total_txs is None:\n+                _total_txs = [0]\n+            if _total_txs[0] >= max_txs:\n+                return\n+\n+            txout_value = (initial_value - fee) // tree_width\n+            if txout_value < fee:\n+                return\n+\n+            vout = [CTxOut(txout_value, CScript([i+1]))\n+                    for i in range(tree_width)]\n+            tx = CTransaction([CTxIn(prevout)],\n+                              vout)\n+\n+            self.assertTrue(len(tx.serialize()) < 100000)\n+            txid = self.proxy.sendrawtransaction(tx, True)\n+            yield tx\n+            _total_txs[0] += 1\n+\n+            for i, txout in enumerate(tx.vout):\n+                yield from branch(COutPoint(txid, i), txout_value,\n+                                  max_txs,\n+                                  tree_width=tree_width, fee=fee,\n+                                  _total_txs=_total_txs)\n+\n+        fee = 0.0001*COIN\n+        n = MAX_REPLACEMENT_LIMIT\n+        tree_txs = list(branch(tx0_outpoint, initial_nValue, n, fee=fee))\n+        self.assertEqual(len(tree_txs), n)\n+\n+        # Attempt double-spend, will fail because too little fee paid\n+        dbl_tx = CTransaction([CTxIn(tx0_outpoint)],\n+                              [CTxOut(initial_nValue - fee*n, CScript([1]))])\n+        try:\n+            self.proxy.sendrawtransaction(dbl_tx, True)\n+        except bitcoin.rpc.JSONRPCException as exp:\n+            self.assertEqual(exp.error['code'], -26) # insufficient fee\n+        else:\n+            self.fail()\n+\n+        # 1 BTC fee is enough\n+        dbl_tx = CTransaction([CTxIn(tx0_outpoint)],\n+                              [CTxOut(initial_nValue - fee*n - 1*COIN, CScript([1]))])\n+        self.proxy.sendrawtransaction(dbl_tx, True)\n+\n+        for tx in tree_txs:\n+            with self.assertRaises(IndexError):\n+                self.proxy.getrawtransaction(tx.GetHash())\n+\n+        # Try again, but with more total transactions than the \"max txs\n+        # double-spent at once\" anti-DoS limit.\n+        for n in (MAX_REPLACEMENT_LIMIT, MAX_REPLACEMENT_LIMIT*2):\n+            fee = 0.0001*COIN\n+            tx0_outpoint = self.make_txout(initial_nValue)\n+            tree_txs = list(branch(tx0_outpoint, initial_nValue, n, fee=fee))\n+            self.assertEqual(len(tree_txs), n)\n+\n+            dbl_tx = CTransaction([CTxIn(tx0_outpoint)],\n+                                  [CTxOut(initial_nValue - fee*n, CScript([1]))])\n+            try:\n+                self.proxy.sendrawtransaction(dbl_tx, True)\n+            except bitcoin.rpc.JSONRPCException as exp:\n+                self.assertEqual(exp.error['code'], -26)\n+            else:\n+                self.fail()\n+\n+            for tx in tree_txs:\n+                self.proxy.getrawtransaction(tx.GetHash())\n+\n+    def test_huge_chain(self):\n+        \"\"\"Doublespend of a huge (in size) transaction chain\"\"\"\n+\n+        def fat_chain(n, remaining_value):\n+            fee = 0.1*COIN\n+\n+            initial_nValue = (n * fee) + remaining_value\n+            tx0_outpoint = self.make_txout(initial_nValue)\n+\n+            yield tx0_outpoint\n+\n+            prevout = tx0_outpoint\n+            prevout_nValue = initial_nValue\n+\n+            fat_txout = CTxOut(1, CScript([b'\\xff'*999000]))\n+\n+            for i in range(n):\n+                tx = CTransaction([CTxIn(prevout)],\n+                                  [CTxOut(prevout_nValue - fee, CScript([1])),\n+                                   fat_txout])\n+\n+                txid = self.proxy.sendrawtransaction(tx, True)\n+\n+                prevout = COutPoint(txid, 0)\n+                prevout_nValue = tx.vout[0].nValue\n+\n+                yield tx\n+\n+        n = MAX_REPLACEMENT_LIMIT\n+        tx0_outpoint, *chain_txs = fat_chain(n, 1*COIN)\n+        self.assertEqual(len(chain_txs), n)\n+\n+        # Attempt double-spend, will fail because too little fee paid\n+        dbl_tx = CTransaction([CTxIn(tx0_outpoint)],\n+                              [CTxOut(2*COIN, CScript([1]))])\n+        try:\n+            self.proxy.sendrawtransaction(dbl_tx, True)\n+        except bitcoin.rpc.JSONRPCException as exp:\n+            self.assertEqual(exp.error['code'], -26) # insufficient fee\n+        else:\n+            self.fail()\n+\n+        # Fine with more fees\n+        dbl_tx = CTransaction([CTxIn(tx0_outpoint)],\n+                              [CTxOut(0.9*COIN, CScript([1]))])\n+        self.proxy.sendrawtransaction(dbl_tx, True)\n+\n+        for tx in chain_txs:\n+            with self.assertRaises(IndexError):\n+                self.proxy.getrawtransaction(tx.GetHash())\n+\n+    def test_replacement_feeperkb(self):\n+        \"\"\"Replacement requires overall fee-per-KB to be higher\"\"\"\n+        tx0_outpoint = self.make_txout(1.1*COIN)\n+\n+        tx1a = CTransaction([CTxIn(tx0_outpoint)],\n+                            [CTxOut(1*COIN, CScript([b'a']))])\n+        tx1a_txid = self.proxy.sendrawtransaction(tx1a, True)\n+\n+        # Higher fee, but the fee per KB is much lower, so the replacement is\n+        # rejected.\n+        tx1b = CTransaction([CTxIn(tx0_outpoint)],\n+                            [CTxOut(0.001*COIN,\n+                                    CScript([b'a'*999000]))])\n+\n+        try:\n+            tx1b_txid = self.proxy.sendrawtransaction(tx1b, True)\n+        except bitcoin.rpc.JSONRPCException as exp:\n+            self.assertEqual(exp.error['code'], -26) # insufficient fee\n+        else:\n+            self.fail()\n+\n+    def test_spends_of_conflicting_outputs(self):\n+        \"\"\"Replacements that spend conflicting tx outputs are rejected\"\"\"\n+        utxo1 = self.make_txout(1.2*COIN)\n+        utxo2 = self.make_txout(3.0*COIN)\n+\n+        tx1a = CTransaction([CTxIn(utxo1)],\n+                            [CTxOut(1.1*COIN, CScript([b'a']))])\n+        tx1a_txid = self.proxy.sendrawtransaction(tx1a, True)\n+\n+        # Direct spend an output of the transaction we're replacing.\n+        tx2 = CTransaction([CTxIn(utxo1), CTxIn(utxo2),\n+                            CTxIn(COutPoint(tx1a_txid, 0))],\n+                           tx1a.vout)\n+\n+        try:\n+            tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+        except bitcoin.rpc.JSONRPCException as exp:\n+            self.assertEqual(exp.error['code'], -26)\n+        else:\n+            self.fail()\n+\n+        # Spend tx1a's output to test the indirect case.\n+        tx1b = CTransaction([CTxIn(COutPoint(tx1a_txid, 0))],\n+                            [CTxOut(1.0*COIN, CScript([b'a']))])\n+        tx1b_txid = self.proxy.sendrawtransaction(tx1b, True)\n+\n+        tx2 = CTransaction([CTxIn(utxo1), CTxIn(utxo2),\n+                            CTxIn(COutPoint(tx1b_txid, 0))],\n+                           tx1a.vout)\n+\n+        try:\n+            tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+        except bitcoin.rpc.JSONRPCException as exp:\n+            self.assertEqual(exp.error['code'], -26)\n+        else:\n+            self.fail()\n+\n+if __name__ == '__main__':\n+    unittest.main()"
      },
      {
        "sha": "1a7888ab6e4290f343b93c05cc9715779d3cbfba",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 133,
        "deletions": 14,
        "changes": 147,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/32008e82191f0a6952c5e96a90aa809a7024cb58/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/32008e82191f0a6952c5e96a90aa809a7024cb58/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=32008e82191f0a6952c5e96a90aa809a7024cb58",
        "patch": "@@ -916,20 +916,6 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n     if (pool.exists(hash))\n         return false;\n \n-    // Check for conflicts with in-memory transactions\n-    {\n-    LOCK(pool.cs); // protect pool.mapNextTx\n-    for (unsigned int i = 0; i < tx.vin.size(); i++)\n-    {\n-        COutPoint outpoint = tx.vin[i].prevout;\n-        if (pool.mapNextTx.count(outpoint))\n-        {\n-            // Disable replacement feature for now\n-            return false;\n-        }\n-    }\n-    }\n-\n     {\n         CCoinsView dummy;\n         CCoinsViewCache view(&dummy);\n@@ -1055,8 +1041,141 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n             return error(\"AcceptToMemoryPool: BUG! PLEASE REPORT THIS! ConnectInputs failed against MANDATORY but not STANDARD flags %s\", hash.ToString());\n         }\n \n+        CAmount nConflictingFees = 0;\n+        size_t nConflictingSize = 0;\n+        {\n+\n+            // Now that we're (almost) sure we'd let the transaction into the\n+            // mempool if not for conflicts, check if it's economically\n+            // rational to mine it rather than the transactions it conflicts\n+            // with. (if any)\n+            //\n+            // Secondly, as this requires us to walk the graph of all\n+            // transactions that might be replaced, we have the opportunity to\n+            // make sure the replacement transaction doesn't spend outputs of\n+            // transactions that it replaces. If it did, once those\n+            // replacements were removed from the mempool the transaction would\n+            // be orphaned; such transactions are invalid and can't be mined.\n+            LOCK(pool.cs);\n+            set<uint256> sConflicts;\n+            set<uint256> sPrevTxs;\n+\n+            // Start with set of conflicting transactions we're directly\n+            // double-spending.\n+            BOOST_FOREACH(const CTxIn txin, tx.vin) {\n+                if (pool.mapNextTx.count(txin.prevout))\n+                {\n+                    sConflicts.insert(pool.mapNextTx[txin.prevout].ptx->GetHash());\n+                }\n+                sPrevTxs.insert(txin.prevout.hash);\n+            }\n+\n+            if (sConflicts.size())\n+            {\n+\n+                // Sum up conflicting size/fees for that set and all children.\n+                int nTxVisited = 0;\n+                while (sConflicts.size())\n+                {\n+                    // Limit DoS potential by simply rejecting double-spends of large\n+                    // numbers of transactions. This can be removed when the\n+                    // mempool itself is limited in size - as we're just following\n+                    // pointers and nFees and nSize are cached this operation is\n+                    // very fast even with extremely large amounts of transactions\n+                    // changed.\n+                    nTxVisited++;\n+                    if (nTxVisited > 100)\n+                    {\n+                        return state.DoS(0, error(\"AcceptToMemoryPool: too many conflicting txs for replacement; can't replace with %s\",\n+                                                   hash.ToString()),\n+                                             REJECT_DUPLICATE, \"bad-txns-inputs-spent\");\n+                    }\n+\n+                    std::set<uint256>::iterator it;\n+                    it = sConflicts.begin();\n+                    uint256 hashChildTx = *it;\n+                    sConflicts.erase(it);\n+\n+                    if (sPrevTxs.count(hashChildTx))\n+                    {\n+                        return state.DoS(0, error(\"AcceptToMemoryPool: %s spends conflicting transaction %s\",\n+                                                  hash.ToString(),\n+                                                  hashChildTx.ToString()),\n+                                         REJECT_INVALID, \"bad-txns-spends-conflicting-tx\");\n+                    }\n+\n+                    const CTxMemPoolEntry& entry = pool.mapTx.at(hashChildTx);\n+                    nConflictingFees += entry.GetFee();\n+                    nConflictingSize += entry.GetTxSize();\n+\n+                    // Add tx children to the set\n+                    for (unsigned int i = 0; i < entry.GetTx().vout.size(); i++)\n+                    {\n+                        COutPoint outpoint(hashChildTx, i);\n+                        if (pool.mapNextTx.count(outpoint))\n+                        {\n+                            sConflicts.insert(pool.mapNextTx[outpoint].ptx->GetHash());\n+                        }\n+                    }\n+                }\n+\n+                // Replace?\n+                //\n+                // First of all we can't allow a replacement unless it pays greater\n+                // fees than the transactions it conflicts with - if we did the\n+                // bandwidth used by those conflicting transactions would not be\n+                // paid for.\n+                if (nFees < nConflictingFees)\n+                {\n+                    return state.DoS(0, error(\"AcceptToMemoryPool: rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n+                                              hash.ToString(), FormatMoney(nFees), FormatMoney(nConflictingFees)),\n+                                     REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n+                }\n+\n+                // Secondly in addition to paying more fees than the conflicts the\n+                // new transaction must additionally pay for its own bandwidth.\n+                CAmount nDeltaFees = nFees - nConflictingFees;\n+                if (nDeltaFees < ::minRelayTxFee.GetFee(nSize))\n+                {\n+                    return state.DoS(0,\n+                            error(\"AcceptToMemoryPool: rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n+                                  hash.ToString(),\n+                                  FormatMoney(nDeltaFees),\n+                                  FormatMoney(::minRelayTxFee.GetFee(nSize))),\n+                            REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n+                }\n+\n+                // Finally replace only if we end up with a larger fees-per-kb than\n+                // the replacements.\n+                CFeeRate oldFeeRate(nConflictingFees, nConflictingSize);\n+                CFeeRate newFeeRate(nFees, nSize);\n+                if (newFeeRate <= oldFeeRate)\n+                {\n+                    return state.DoS(0,\n+                            error(\"AcceptToMemoryPool: rejecting replacement %s; new fee %s <= old fee %s\",\n+                                  hash.ToString(),\n+                                  newFeeRate.ToString(),\n+                                  oldFeeRate.ToString()),\n+                            REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n+                }\n+            }\n+        }\n+\n+        // Remove conflicting transactions from the mempool\n+        list<CTransaction> ltxConflicted;\n+        pool.removeConflicts(tx, ltxConflicted);\n+\n         // Store transaction in memory\n         pool.addUnchecked(hash, entry, !IsInitialBlockDownload());\n+\n+        BOOST_FOREACH(const CTransaction &txConflicted, ltxConflicted)\n+        {\n+            LogPrint(\"mempool\", \"replacing tx %s with %s for %s BTC additional fees, %d delta bytes\\n\",\n+                     txConflicted.GetHash().ToString(),\n+                     hash.ToString(),\n+                     FormatMoney(nFees - nConflictingFees),\n+                     (int)nSize - (int)nConflictingSize);\n+        }\n     }\n \n     SyncWithWallets(tx, NULL);"
      }
    ]
  },
  {
    "sha": "8821579b0885d6a49e770575e1c071b4430f4586",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4ODIxNTc5YjA4ODVkNmE0OWU3NzA1NzVlMWMwNzFiNDQzMGY0NTg2",
    "commit": {
      "author": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2015-06-29T00:25:01Z"
      },
      "committer": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2015-06-30T01:21:52Z"
      },
      "message": "Restrict RBF with first-seen-safe rules until switchover date\n\nCredit goes to Jeff Garzik for suggesting a scheduled switchover\ndeployment strategy.",
      "tree": {
        "sha": "93de5519d8e618878e76a62821c781b819606a56",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/93de5519d8e618878e76a62821c781b819606a56"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8821579b0885d6a49e770575e1c071b4430f4586",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGrBAABCACVBQJVke8xXhSAAAAAABUAQGJsb2NraGFzaEBiaXRjb2luLm9yZzAw\nMDAwMDAwMDAwMDAwMDAwYmZlOTMxODFhMTBlMmYxMmE0NWRhODc3YjUwMjZhZTI2\nOTg4ZTkzNmExMzIyYWUvFIAAAAAAFQARcGthLWFkZHJlc3NAZ251cGcub3JncGV0\nZUBwZXRlcnRvZC5vcmcACgkQJIFAPaXwkfvZ9wf9HEYvXAT7VVyMTOpSTUCfT58D\nkbsCkav8fEW1jpBhRX9kcs8wJG70raoW2gOgdGaarxryobRDGFIvSEzSunoRAp14\n5EOedKKjEVBqLB5aMEVM8C16V8P9eUGHESQ7NpNDzZ55nBKce6ApccGyfj0NMK1O\nfHgLd56LYS26SQHJuCji4wQaR+xVIspivr+XSPlL7t6UPeIKethEp3Cd8xiVWogZ\nb/H1EMvtCPKejSl8fDrbvpB8BOtL+ea/X7czhBUXq55V5bJXRdrD4oc4F3wNUG0m\nO1ej8uGdd4HWABNE0J1g4nMiNrxXophTvO12UrFVHiQ8gkSmHX6nCF7Xzc/SzA==\n=xNc2\n-----END PGP SIGNATURE-----",
        "payload": "tree 93de5519d8e618878e76a62821c781b819606a56\nparent 32008e82191f0a6952c5e96a90aa809a7024cb58\nauthor Peter Todd <pete@petertodd.org> 1435537501 -0400\ncommitter Peter Todd <pete@petertodd.org> 1435627312 -0400\n\nRestrict RBF with first-seen-safe rules until switchover date\n\nCredit goes to Jeff Garzik for suggesting a scheduled switchover\ndeployment strategy.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8821579b0885d6a49e770575e1c071b4430f4586",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8821579b0885d6a49e770575e1c071b4430f4586",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8821579b0885d6a49e770575e1c071b4430f4586/comments",
    "author": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "32008e82191f0a6952c5e96a90aa809a7024cb58",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/32008e82191f0a6952c5e96a90aa809a7024cb58",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/32008e82191f0a6952c5e96a90aa809a7024cb58"
      }
    ],
    "stats": {
      "total": 491,
      "additions": 490,
      "deletions": 1
    },
    "files": [
      {
        "sha": "72b57a0de0b2e3a84794f1b1eb396bffd08345eb",
        "filename": "qa/replace-by-fee/README.md",
        "status": "modified",
        "additions": 10,
        "deletions": 1,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8821579b0885d6a49e770575e1c071b4430f4586/qa/replace-by-fee/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8821579b0885d6a49e770575e1c071b4430f4586/qa/replace-by-fee/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/replace-by-fee/README.md?ref=8821579b0885d6a49e770575e1c071b4430f4586",
        "patch": "@@ -8,6 +8,15 @@ run:\n     (cd python-bitcoinlib && git checkout c481254c623cc9a002187dc23263cce3e05f5754)\n \n Then run the tests themselves with a bitcoind available running in regtest\n-mode:\n+mode. There's separate tests for full and first-seen-safe RBF. The former:\n \n     ./full-rbf-tests.py\n+\n+To run the latter you'll need to restart bitcoind using the\n+fullrbfactivationtime argument to disable full-RBF on regtest:\n+\n+    bitcoind -fullrbfactivationtime=0 -regtest\n+\n+Followed by:\n+\n+    ./fss-rbf-tests.py"
      },
      {
        "sha": "e95534dbdab8c90eb23a1f11f42bb238d1774773",
        "filename": "qa/replace-by-fee/fss-rbf-tests.py",
        "status": "added",
        "additions": 387,
        "deletions": 0,
        "changes": 387,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8821579b0885d6a49e770575e1c071b4430f4586/qa/replace-by-fee/fss-rbf-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8821579b0885d6a49e770575e1c071b4430f4586/qa/replace-by-fee/fss-rbf-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/replace-by-fee/fss-rbf-tests.py?ref=8821579b0885d6a49e770575e1c071b4430f4586",
        "patch": "@@ -0,0 +1,387 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2015 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test replace-by-fee\n+#\n+\n+import os\n+import sys\n+\n+# Add python-bitcoinlib to module search path:\n+sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), \"python-bitcoinlib\"))\n+\n+import unittest\n+\n+import bitcoin\n+bitcoin.SelectParams('regtest')\n+\n+import bitcoin.rpc\n+\n+from bitcoin.core import *\n+from bitcoin.core.script import *\n+from bitcoin.wallet import *\n+\n+class Test_ReplaceByFee(unittest.TestCase):\n+    proxy = None\n+\n+    @classmethod\n+    def setUpClass(cls):\n+        if cls.proxy is None:\n+            cls.proxy = bitcoin.rpc.Proxy()\n+\n+    @classmethod\n+    def mine_mempool(cls):\n+        \"\"\"Mine until mempool is empty\"\"\"\n+        mempool_size = 1\n+        while mempool_size:\n+            cls.proxy.generate(1)\n+            new_mempool_size = len(cls.proxy.getrawmempool())\n+\n+            # It's possible to get stuck in a loop here if the mempool has\n+            # transactions that can't be mined.\n+            assert(new_mempool_size != mempool_size)\n+            mempool_size = new_mempool_size\n+\n+    @classmethod\n+    def tearDownClass(cls):\n+        # Make sure mining works\n+        cls.mine_mempool()\n+\n+    def make_txouts(self, n, amount, confirmed=True, scriptPubKey=CScript([1])):\n+        \"\"\"Create n txouts with a given amount and scriptPubKey\n+\n+        Mines coins as needed.\n+\n+        confirmed - txouts created will be confirmed in the blockchain;\n+                    unconfirmed otherwise.\n+        \"\"\"\n+        if not n:\n+            return []\n+\n+        fee = 1*COIN\n+        while self.proxy.getbalance() < n*amount + fee:\n+            self.proxy.generate(100)\n+\n+        addr = P2SHBitcoinAddress.from_redeemScript(CScript([]))\n+        txid = self.proxy.sendtoaddress(addr, n*amount + fee)\n+\n+        tx1 = self.proxy.getrawtransaction(txid)\n+\n+        i = None\n+        for i, txout in enumerate(tx1.vout):\n+            if txout.scriptPubKey == addr.to_scriptPubKey():\n+                break\n+        assert i is not None\n+\n+        tx2 = CTransaction([CTxIn(COutPoint(txid, i), CScript([1, CScript([])]))],\n+                           [CTxOut(amount, scriptPubKey)]*n)\n+\n+        tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+\n+        # If requested, ensure txouts are confirmed.\n+        if confirmed:\n+            self.mine_mempool()\n+\n+        return [COutPoint(tx2_txid, i) for i in range(n)]\n+\n+    def make_txout(self, amount, confirmed=True, scriptPubKey=CScript([1])):\n+        \"\"\"Create a txout with a given amount and scriptPubKey\n+\n+        Mines coins as needed.\n+\n+        confirmed - txouts created will be confirmed in the blockchain;\n+                    unconfirmed otherwise.\n+        \"\"\"\n+        return self.make_txouts(1, amount, confirmed, scriptPubKey)[0]\n+\n+    def test_subset_prohibited(self):\n+        \"\"\"Replacement prohibited if any recipient will receive less funds from replacement\"\"\"\n+\n+        for n in range(1,4):\n+            utxo1 = self.make_txout(n*0.11*COIN)\n+            utxo2 = self.make_txout(1.0*COIN)\n+\n+            tx1 = CTransaction([CTxIn(utxo1)],\n+                                [CTxOut(0.10*COIN, CScript([i])) for i in range(n)])\n+            tx1_txid = self.proxy.sendrawtransaction(tx1, True)\n+\n+            # Double spend with too-few outputs\n+            for m in range(1,n):\n+                tx2 = CTransaction([CTxIn(utxo1), CTxIn(utxo2)],\n+                                   tx1.vout[0:m])\n+\n+                try:\n+                    tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+                except bitcoin.rpc.JSONRPCException as exp:\n+                    self.assertEqual(exp.error['code'], -26)\n+                else:\n+                    self.fail()\n+\n+            # Double spend with one of the outputs changed\n+            for m in range(0,n):\n+                vout = list(tx1.vout)\n+                vout[m] = CTxOut(0.10*COIN, CScript([b'a']))\n+                tx2 = CTransaction([CTxIn(utxo1), CTxIn(utxo2)], vout)\n+\n+                try:\n+                    tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+                except bitcoin.rpc.JSONRPCException as exp:\n+                    self.assertEqual(exp.error['code'], -26)\n+                else:\n+                    self.fail()\n+\n+            # Double spend with one of the outputs reduced in value by one satoshi\n+            for m in range(0,n):\n+                vout = list(tx1.vout)\n+                vout[m] = CTxOut(vout[m].nValue-1, vout[m].scriptPubKey)\n+                tx2 = CTransaction([CTxIn(utxo1), CTxIn(utxo2)], vout)\n+\n+                try:\n+                    tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+                except bitcoin.rpc.JSONRPCException as exp:\n+                    self.assertEqual(exp.error['code'], -26)\n+                else:\n+                    self.fail()\n+\n+            # With all the outputs the same, and an additional input, the\n+            # replacement will succeed.\n+            tx2 = CTransaction([CTxIn(utxo1), CTxIn(utxo2)], tx1.vout)\n+            tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+\n+            with self.assertRaises(IndexError):\n+                self.proxy.getrawtransaction(tx1_txid)\n+            self.proxy.getrawtransaction(tx2_txid)\n+\n+    def test_reorder_vout_prohibited(self):\n+        \"\"\"Changing the order of vout is prohibited\"\"\"\n+\n+        utxo1 = self.make_txout(2*1.1*COIN)\n+        utxo2 = self.make_txout(1.0*COIN)\n+\n+        tx1 = CTransaction([CTxIn(utxo1)],\n+                            [CTxOut(1.0*COIN, CScript([1])),\n+                             CTxOut(1.0*COIN, CScript([2]))])\n+        tx1_txid = self.proxy.sendrawtransaction(tx1, True)\n+\n+        tx2 = CTransaction([CTxIn(utxo1), CTxIn(utxo2)],\n+                           reversed(tx1.vout))\n+\n+        try:\n+            tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+        except bitcoin.rpc.JSONRPCException as exp:\n+            self.assertEqual(exp.error['code'], -26)\n+        else:\n+            self.fail()\n+\n+    def test_reorder_vin_allowed(self):\n+        \"\"\"Changing the order of vin is allowed\"\"\"\n+        utxo1 = self.make_txout(1.1*COIN)\n+        utxo2 = self.make_txout(1.0*COIN)\n+\n+        tx1 = CTransaction([CTxIn(utxo1)],\n+                            [CTxOut(1.0*COIN, CScript([1]))])\n+        tx1_txid = self.proxy.sendrawtransaction(tx1, True)\n+\n+        tx2 = CTransaction([CTxIn(utxo2), CTxIn(utxo1)],\n+                           tx1.vout)\n+\n+        tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+        with self.assertRaises(IndexError):\n+            self.proxy.getrawtransaction(tx1_txid)\n+        self.proxy.getrawtransaction(tx2_txid)\n+\n+    def test_one_to_one(self):\n+        \"\"\"Replacing multiple transactions at once is prohibited\"\"\"\n+        utxo1 = self.make_txout(1.1*COIN)\n+        utxo2 = self.make_txout(1.1*COIN)\n+        utxo3 = self.make_txout(1.0*COIN)\n+\n+        tx1a = CTransaction([CTxIn(utxo1)],\n+                            [CTxOut(1.0*COIN, CScript([b'a']))])\n+        tx1a_txid = self.proxy.sendrawtransaction(tx1a, True)\n+\n+        tx1b = CTransaction([CTxIn(utxo2)],\n+                            [CTxOut(1.0*COIN, CScript([b'b']))])\n+        tx1b_txid = self.proxy.sendrawtransaction(tx1b, True)\n+\n+        tx2 = CTransaction([CTxIn(utxo1), CTxIn(utxo2), CTxIn(utxo3)],\n+                           tx1a.vout + tx1b.vout)\n+\n+        try:\n+            tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+        except bitcoin.rpc.JSONRPCException as exp:\n+            self.assertEqual(exp.error['code'], -26)\n+        else:\n+            self.fail()\n+\n+    def test_replaced_outputs_unspent(self):\n+        \"\"\"Replaced transaction's outputs must be unspent\"\"\"\n+\n+        for i in range(2):\n+            utxo1 = self.make_txout(1.2*COIN)\n+            utxo2 = self.make_txout(3.0*COIN)\n+\n+            tx1a = CTransaction([CTxIn(utxo1)],\n+                                [CTxOut(0.5*COIN, CScript([b'a'])),\n+                                 CTxOut(0.5*COIN, CScript([b'b']))])\n+            tx1a_txid = self.proxy.sendrawtransaction(tx1a, True)\n+\n+            tx1b = CTransaction([CTxIn(COutPoint(tx1a_txid, i))],\n+                                [CTxOut(0.4*COIN, CScript([b'b']))])\n+            tx1b_txid = self.proxy.sendrawtransaction(tx1b, True)\n+\n+            tx2 = CTransaction([CTxIn(utxo1), CTxIn(utxo2)],\n+                               tx1a.vout + tx1b.vout)\n+\n+            try:\n+                tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+            except bitcoin.rpc.JSONRPCException as exp:\n+                self.assertEqual(exp.error['code'], -26)\n+            else:\n+                self.fail()\n+\n+    def test_additional_unconfirmed_inputs(self):\n+        \"\"\"Replacement fails if additional unconfirmed inputs added\"\"\"\n+        confirmed_utxo = self.make_txout(1.1*COIN)\n+        unconfirmed_utxo = self.make_txout(0.1*COIN, False)\n+\n+        tx1 = CTransaction([CTxIn(confirmed_utxo)],\n+                           [CTxOut(1.0*COIN, CScript([b'a']))])\n+        tx1_txid = self.proxy.sendrawtransaction(tx1, True)\n+\n+        tx2 = CTransaction([CTxIn(confirmed_utxo), CTxIn(unconfirmed_utxo)],\n+                           tx1.vout)\n+\n+        try:\n+            tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+        except bitcoin.rpc.JSONRPCException as exp:\n+            self.assertEqual(exp.error['code'], -26)\n+        else:\n+            self.fail()\n+\n+    def test_spends_of_conflicting_outputs(self):\n+        \"\"\"Replacements that spend conflicting tx outputs are rejected\"\"\"\n+        utxo1 = self.make_txout(1.2*COIN)\n+        utxo2 = self.make_txout(3.0*COIN)\n+\n+        tx1a = CTransaction([CTxIn(utxo1)],\n+                            [CTxOut(1.1*COIN, CScript([b'a']))])\n+        tx1a_txid = self.proxy.sendrawtransaction(tx1a, True)\n+\n+        # Direct spend an output of the transaction we're replacing.\n+        tx2 = CTransaction([CTxIn(utxo1), CTxIn(utxo2),\n+                            CTxIn(COutPoint(tx1a_txid, 0))],\n+                           tx1a.vout)\n+\n+        try:\n+            tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+        except bitcoin.rpc.JSONRPCException as exp:\n+            self.assertEqual(exp.error['code'], -26)\n+        else:\n+            self.fail()\n+\n+        # Spend tx1a's output to test the indirect case.\n+        tx1b = CTransaction([CTxIn(COutPoint(tx1a_txid, 0))],\n+                            [CTxOut(1.0*COIN, CScript([b'a']))])\n+        tx1b_txid = self.proxy.sendrawtransaction(tx1b, True)\n+\n+        tx2 = CTransaction([CTxIn(utxo1), CTxIn(utxo2),\n+                            CTxIn(COutPoint(tx1b_txid, 0))],\n+                           tx1a.vout)\n+\n+        try:\n+            tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+        except bitcoin.rpc.JSONRPCException as exp:\n+            self.assertEqual(exp.error['code'], -26)\n+        else:\n+            self.fail()\n+\n+\n+    def test_economics(self):\n+        \"\"\"Replacement prohibited if uneconomical\"\"\"\n+        utxo1 = self.make_txout(110000)\n+        utxo2 = self.make_txout(1)\n+        utxo3 = self.make_txout(1000000)\n+\n+        # By including utxo2 in tx1 but not tx2 lets us test the case where the\n+        # replacement pays less fees than the original while still respecting\n+        # the \"no-decreases\" rule.\n+        tx1 = CTransaction([CTxIn(utxo1), CTxIn(utxo2)],\n+                            [CTxOut(100000, CScript([b'a']))])\n+        tx1_txid = self.proxy.sendrawtransaction(tx1, True)\n+\n+        # FIXME: these constants should be derived somehow, but right now\n+        # there's no way to get min fee info from the mempool over RPC\n+        for fee_delta in [-1,   # less fees than original\n+                          0, 1, # not enough to pay for bandwidth\n+                          114, 1068,  # fee/KB of replacement less than original\n+                         ]:\n+            tx2 = CTransaction([CTxIn(utxo1), CTxIn(utxo3)],\n+                               [tx1.vout[0],\n+                                CTxOut(1000000-1-fee_delta, CScript([b'b']))])\n+\n+            try:\n+                tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+            except bitcoin.rpc.JSONRPCException as exp:\n+                self.assertEqual(exp.error['code'], -26)\n+            else:\n+                self.fail()\n+\n+\n+    def test_very_large_replacements(self):\n+        \"\"\"Very large replacements\"\"\"\n+        n = 5000\n+        for n_vin, n_new_vin, n_vout, n_new_vout in [(n,0,2,0),\n+                                                     (n,n,2,0),\n+                                                     (n,n,n,0),\n+                                                     (n,n,n,n),\n+                                                     (2,n,n,n),\n+                                                     (2,0,n,n),\n+                                                     (2,0,2,n),\n+                                                     ]:\n+            utxos = self.make_txouts(n_vin, 1000)\n+\n+            fee_utxo1 = self.make_txout(0.01*COIN)\n+            fee_utxo2 = self.make_txout(10*COIN)\n+            new_utxos = tuple(CTxIn(utxo) for utxo in self.make_txouts(n_new_vin, 1000))\n+\n+            tx1 = CTransaction([CTxIn(utxo) for utxo in utxos] + [CTxIn(fee_utxo1)],\n+                               [CTxOut(1, CScript([b'a'])) for i in range(n_vout)])\n+            tx1_txid = self.proxy.sendrawtransaction(tx1, True)\n+\n+            new_vout = tuple(CTxOut(1, CScript([b'b'])) for i in range(n_new_vout))\n+\n+            # Prohibited replacement, last vout omitted\n+            tx2 = CTransaction(tx1.vin + (CTxIn(fee_utxo2),) + new_utxos,\n+                               tx1.vout[0:-1] + new_vout)\n+            try:\n+                tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+            except bitcoin.rpc.JSONRPCException as exp:\n+                self.assertEqual(exp.error['code'], -26)\n+            else:\n+                self.fail()\n+\n+            # Prohibited replacement, last vout changed\n+            tx2 = CTransaction(tx1.vin + (CTxIn(fee_utxo2),) + new_utxos,\n+                               tx1.vout[0:-1] + (CTxOut(1, CScript([b'b'])),) + new_vout)\n+            try:\n+                tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+            except bitcoin.rpc.JSONRPCException as exp:\n+                self.assertEqual(exp.error['code'], -26)\n+            else:\n+                self.fail()\n+\n+            # Succesful replacement\n+            tx2 = CTransaction(tx1.vin + (CTxIn(fee_utxo2),) + new_utxos,\n+                               tx1.vout + new_vout)\n+\n+            tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+            with self.assertRaises(IndexError):\n+                self.proxy.getrawtransaction(tx1_txid)\n+            self.proxy.getrawtransaction(tx2_txid)\n+\n+if __name__ == '__main__':\n+    unittest.main()"
      },
      {
        "sha": "ee5da31a7cc4a696f3f3c1a23939111edee15800",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8821579b0885d6a49e770575e1c071b4430f4586/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8821579b0885d6a49e770575e1c071b4430f4586/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=8821579b0885d6a49e770575e1c071b4430f4586",
        "patch": "@@ -106,6 +106,9 @@ class CMainParams : public CChainParams {\n         fMineBlocksOnDemand = false;\n         fTestnetToBeDeprecatedFieldRPC = false;\n \n+        // Tuesday April 5th, 2016 at 3pm UTC\n+        nFullRbfActivationTime = 1459868400;\n+\n         checkpointData = (Checkpoints::CCheckpointData) {\n             boost::assign::map_list_of\n             ( 11111, uint256S(\"0x0000000069e244f73d78e8fd29ba2fd2ed618bd6fa2ee92559f542fdb26e7c1d\"))\n@@ -178,6 +181,9 @@ class CTestNetParams : public CMainParams {\n         fMineBlocksOnDemand = false;\n         fTestnetToBeDeprecatedFieldRPC = true;\n \n+        // Full-RBF always active on testnet/regtest\n+        nFullRbfActivationTime = 1;\n+\n         checkpointData = (Checkpoints::CCheckpointData) {\n             boost::assign::map_list_of\n             ( 546, uint256S(\"000000002a936ca763904c3c35fce2f3556c559c0214345d31b1bcebf76acb70\")),"
      },
      {
        "sha": "e6374b1690ee62af0c8e86fcb844bfcf2a0ac5e2",
        "filename": "src/chainparams.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8821579b0885d6a49e770575e1c071b4430f4586/src/chainparams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8821579b0885d6a49e770575e1c071b4430f4586/src/chainparams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.h?ref=8821579b0885d6a49e770575e1c071b4430f4586",
        "patch": "@@ -65,6 +65,8 @@ class CChainParams\n     bool MineBlocksOnDemand() const { return fMineBlocksOnDemand; }\n     /** In the future use NetworkIDString() for RPC fields */\n     bool TestnetToBeDeprecatedFieldRPC() const { return fTestnetToBeDeprecatedFieldRPC; }\n+    /** In the future use NetworkIDString() for RPC fields */\n+    int64_t FullRbfActivationTime() const { return nFullRbfActivationTime; }\n     /** Return the BIP70 network string (main, test or regtest) */\n     std::string NetworkIDString() const { return strNetworkID; }\n     const std::vector<CDNSSeedData>& DNSSeeds() const { return vSeeds; }\n@@ -92,6 +94,7 @@ class CChainParams\n     bool fRequireStandard;\n     bool fMineBlocksOnDemand;\n     bool fTestnetToBeDeprecatedFieldRPC;\n+    int64_t nFullRbfActivationTime;\n     Checkpoints::CCheckpointData checkpointData;\n };\n "
      },
      {
        "sha": "246fa1432b4980b33c43b822bdf033b3e353fe87",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8821579b0885d6a49e770575e1c071b4430f4586/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8821579b0885d6a49e770575e1c071b4430f4586/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=8821579b0885d6a49e770575e1c071b4430f4586",
        "patch": "@@ -398,6 +398,9 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageGroup(_(\"Node relay options:\"));\n     strUsage += HelpMessageOpt(\"-datacarrier\", strprintf(_(\"Relay and mine data carrier transactions (default: %u)\"), 1));\n     strUsage += HelpMessageOpt(\"-datacarriersize\", strprintf(_(\"Maximum size of data in data carrier transactions we relay and mine (default: %u)\"), MAX_OP_RETURN_RELAY));\n+    strUsage += HelpMessageOpt(\"-fullrbfactivationtime\", strprintf(_(\"Full-RBF activation time in seconds from the epoch. Set to 1 to enable now, or 0 to disable. (default: %u, or %u testnet/regtest)\"),\n+                                                                   Params(CBaseChainParams::MAIN).FullRbfActivationTime(),\n+                                                                   Params(CBaseChainParams::TESTNET).FullRbfActivationTime()));\n \n     strUsage += HelpMessageGroup(_(\"Block creation options:\"));\n     strUsage += HelpMessageOpt(\"-blockminsize=<n>\", strprintf(_(\"Set minimum block size in bytes (default: %u)\"), 0));\n@@ -863,6 +866,8 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n     std::string strWalletFile = GetArg(\"-wallet\", \"wallet.dat\");\n #endif // ENABLE_WALLET\n \n+    nFullRbfActivationTime = GetArg(\"-fullrbfactivationtime\", Params().FullRbfActivationTime());\n+\n     fIsBareMultisigStd = GetBoolArg(\"-permitbaremultisig\", true);\n     nMaxDatacarrierBytes = GetArg(\"-datacarriersize\", nMaxDatacarrierBytes);\n "
      },
      {
        "sha": "e7019ed597097fa201e7e3415cabab36c144081e",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 78,
        "deletions": 0,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8821579b0885d6a49e770575e1c071b4430f4586/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8821579b0885d6a49e770575e1c071b4430f4586/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=8821579b0885d6a49e770575e1c071b4430f4586",
        "patch": "@@ -62,6 +62,7 @@ bool fCheckpointsEnabled = true;\n size_t nCoinCacheUsage = 5000 * 300;\n uint64_t nPruneTarget = 0;\n bool fAlerts = DEFAULT_ALERTS;\n+int64_t nFullRbfActivationTime = -1;\n \n /** Fees smaller than this (in satoshi) are considered zero fee (for relaying and mining) */\n CFeeRate minRelayTxFee = CFeeRate(1000);\n@@ -1072,6 +1073,76 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n \n             if (sConflicts.size())\n             {\n+                const bool fFullRBF = nFullRbfActivationTime && GetAdjustedTime() >= nFullRbfActivationTime;\n+\n+                if (!fFullRBF)\n+                {\n+                    // Prior to the full-RBF activation time first-seen-safe\n+                    // rules are enforced.\n+\n+                    // For simplicity we only replace transactions on a 1-for-1\n+                    // basis; we don't, for instance, look at all outputs paid\n+                    // by the set of replaced transactions.\n+                    if (sConflicts.size() > 1)\n+                        return state.DoS(0, error(\"AcceptToMemoryPool: replacement %s conflicts with more than one other transaction\",\n+                                                  hash.ToString()),\n+                                         REJECT_DUPLICATE, \"bad-txns-inputs-spent\");\n+\n+                    const uint256 hashConflicting = *sConflicts.begin();\n+                    const CTransaction txConflicting = pool.mapTx[hashConflicting].GetTx();\n+\n+                    // The conflicting transaction's vout must be a subset of the\n+                    // replacement. Outputs can pay more than before, but not less.\n+                    // For simplicity we require that the order of outputs be\n+                    // unchanged.\n+                    if (tx.vout.size() < txConflicting.vout.size())\n+                    {\n+                        return state.DoS(0, error(\"AcceptToMemoryPool: replacement has %s fewer outputs than original %s\",\n+                                                  hash.ToString(),\n+                                                  hashConflicting.ToString()),\n+                                         REJECT_DUPLICATE, \"bad-txns-inputs-spent\");\n+                    }\n+                    for (unsigned int j = 0; j < txConflicting.vout.size(); j++)\n+                    {\n+                        if (txConflicting.vout[j].scriptPubKey != tx.vout[j].scriptPubKey ||\n+                            txConflicting.vout[j].nValue > tx.vout[j].nValue)\n+                        {\n+                            return state.DoS(0, error(\"AcceptToMemoryPool: replacement %s outputs not a subset of original %s\",\n+                                                      hash.ToString(),\n+                                                      hashConflicting.ToString()),\n+                                             REJECT_DUPLICATE, \"bad-txns-inputs-spent\");\n+                        }\n+                    }\n+\n+                    // Check that any new inputs spend only confirmed coins.\n+                    //\n+                    // Replacing a transaction with one that spends unconfirmed\n+                    // outputs could be used as a way of preventing a tx from\n+                    // being mined, increasing the chance of a zeroconf\n+                    // doublespend.\n+                    //\n+                    // It also might not be economically rational for the\n+                    // miner, however it's enough of an edge case that we'll\n+                    // ignore it for full-RBF mode; the mempool isn't really\n+                    // sophisticated enough yet to analyse this properly, and\n+                    // the potential downside for the miner is minimal.\n+                    set<COutPoint> setConflictsPrevouts;\n+                    BOOST_FOREACH(const CTxIn txin, txConflicting.vin)\n+                        setConflictsPrevouts.insert(txin.prevout);\n+                    for (unsigned int j = 0; j < tx.vin.size(); j++)\n+                    {\n+                        if (!setConflictsPrevouts.count(tx.vin[j].prevout))\n+                        {\n+                            // Rather than check the UTXO set - potentially\n+                            // expensive - it's cheaper to just check that the new\n+                            // input refers to a tx that is *not* in the mempool.\n+                            if (pool.exists(tx.vin[j].prevout.hash))\n+                                return state.DoS(0, error(\"AcceptToMemoryPool: replacement %s adds unconfirmed input, idx %d\",\n+                                                          hash.ToString(), j),\n+                                                 REJECT_DUPLICATE, \"bad-txns-inputs-spent\");\n+                        }\n+                    }\n+                }\n \n                 // Sum up conflicting size/fees for that set and all children.\n                 int nTxVisited = 0;\n@@ -1114,6 +1185,13 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n                         COutPoint outpoint(hashChildTx, i);\n                         if (pool.mapNextTx.count(outpoint))\n                         {\n+                            if (!fFullRBF)\n+                            {\n+                                return state.DoS(0, error(\"AcceptToMemoryPool: outpoint %s:%d already spent; can't replace with %s\",\n+                                                          hashChildTx.ToString(), i,\n+                                                          hash.ToString()),\n+                                                 REJECT_DUPLICATE, \"bad-txns-inputs-spent\");\n+                            }\n                             sConflicts.insert(pool.mapNextTx[outpoint].ptx->GetHash());\n                         }\n                     }"
      },
      {
        "sha": "aa924e24482560a1b0b229a03ccb59c84cabe656",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8821579b0885d6a49e770575e1c071b4430f4586/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8821579b0885d6a49e770575e1c071b4430f4586/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=8821579b0885d6a49e770575e1c071b4430f4586",
        "patch": "@@ -116,6 +116,7 @@ extern bool fCheckpointsEnabled;\n extern size_t nCoinCacheUsage;\n extern CFeeRate minRelayTxFee;\n extern bool fAlerts;\n+extern int64_t nFullRbfActivationTime;\n \n /** Best header we've seen so far (used for getheaders queries' starting points). */\n extern CBlockIndex *pindexBestHeader;"
      }
    ]
  }
]