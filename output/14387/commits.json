[
  {
    "sha": "e1ed29fd90a735fcb28df2897bcc24f9d5cdbc35",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMWVkMjlmZDkwYTczNWZjYjI4ZGYyODk3YmNjMjRmOWQ1Y2RiYzM1",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2018-10-04T06:09:19Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2018-10-05T08:22:01Z"
      },
      "message": "Add Benchmark to test input de-duplication worst case",
      "tree": {
        "sha": "33ba41d2684acb384edb0607f958288025085ea9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/33ba41d2684acb384edb0607f958288025085ea9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e1ed29fd90a735fcb28df2897bcc24f9d5cdbc35",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e1ed29fd90a735fcb28df2897bcc24f9d5cdbc35",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e1ed29fd90a735fcb28df2897bcc24f9d5cdbc35",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e1ed29fd90a735fcb28df2897bcc24f9d5cdbc35/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1f59c6f3eb6c2d5b8dcff04dc3334ee0f0de5b17",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1f59c6f3eb6c2d5b8dcff04dc3334ee0f0de5b17",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1f59c6f3eb6c2d5b8dcff04dc3334ee0f0de5b17"
      }
    ],
    "stats": {
      "total": 105,
      "additions": 105,
      "deletions": 0
    },
    "files": [
      {
        "sha": "5e787ca222a50d43ef4e16c7867b5a0ac0e5f1b8",
        "filename": "src/Makefile.bench.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e1ed29fd90a735fcb28df2897bcc24f9d5cdbc35/src/Makefile.bench.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e1ed29fd90a735fcb28df2897bcc24f9d5cdbc35/src/Makefile.bench.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.bench.include?ref=e1ed29fd90a735fcb28df2897bcc24f9d5cdbc35",
        "patch": "@@ -18,6 +18,7 @@ bench_bench_bitcoin_SOURCES = \\\n   bench/block_assemble.cpp \\\n   bench/checkblock.cpp \\\n   bench/checkqueue.cpp \\\n+  bench/duplicate_inputs.cpp \\\n   bench/examples.cpp \\\n   bench/rollingbloom.cpp \\\n   bench/crypto_hash.cpp \\"
      },
      {
        "sha": "85f862286df1261d98442d243a339de50dd845db",
        "filename": "src/bench/duplicate_inputs.cpp",
        "status": "added",
        "additions": 104,
        "deletions": 0,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e1ed29fd90a735fcb28df2897bcc24f9d5cdbc35/src/bench/duplicate_inputs.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e1ed29fd90a735fcb28df2897bcc24f9d5cdbc35/src/bench/duplicate_inputs.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/duplicate_inputs.cpp?ref=e1ed29fd90a735fcb28df2897bcc24f9d5cdbc35",
        "patch": "@@ -0,0 +1,104 @@\n+// Copyright (c) 2011-2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+#include <chainparams.h>\n+#include <coins.h>\n+#include <consensus/merkle.h>\n+#include <consensus/validation.h>\n+#include <miner.h>\n+#include <policy/policy.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <txdb.h>\n+#include <txmempool.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <boost/thread.hpp>\n+\n+#include <list>\n+#include <vector>\n+\n+\n+static void DuplicateInputs(benchmark::State& state)\n+{\n+    const std::vector<unsigned char> op_true{OP_TRUE};\n+\n+\n+    const CScript SCRIPT_PUB{CScript(OP_TRUE)};\n+\n+    // Switch to regtest so we can mine faster\n+    // Also segwit is active, so we can include witness transactions\n+    SelectParams(CBaseChainParams::REGTEST);\n+\n+    InitScriptExecutionCache();\n+\n+    boost::thread_group thread_group;\n+    CScheduler scheduler;\n+    const CChainParams& chainparams = Params();\n+    {\n+        ::pblocktree.reset(new CBlockTreeDB(1 << 20, true));\n+        ::pcoinsdbview.reset(new CCoinsViewDB(1 << 23, true));\n+        ::pcoinsTip.reset(new CCoinsViewCache(pcoinsdbview.get()));\n+\n+        thread_group.create_thread(boost::bind(&CScheduler::serviceQueue, &scheduler));\n+        GetMainSignals().RegisterBackgroundSignalScheduler(scheduler);\n+        LoadGenesisBlock(chainparams);\n+        CValidationState state;\n+        ActivateBestChain(state, chainparams);\n+        assert(::chainActive.Tip() != nullptr);\n+        const bool witness_enabled{IsWitnessEnabled(::chainActive.Tip(), chainparams.GetConsensus())};\n+        assert(witness_enabled);\n+    }\n+\n+    CBlock block{};\n+    CMutableTransaction coinbaseTx{};\n+    CMutableTransaction naughtyTx{};\n+\n+    CBlockIndex* pindexPrev = ::chainActive.Tip();\n+    assert(pindexPrev != nullptr);\n+    block.nBits = GetNextWorkRequired(pindexPrev, &block, chainparams.GetConsensus());\n+    block.nNonce = 0;\n+    auto nHeight = pindexPrev->nHeight + 1;\n+    block.nTime = ::chainActive.Tip()->GetMedianTimePast() + 1;\n+\n+    // Make a coinbase TX\n+    coinbaseTx.vin.resize(1);\n+    coinbaseTx.vin[0].prevout.SetNull();\n+    coinbaseTx.vout.resize(1);\n+    coinbaseTx.vout[0].scriptPubKey = SCRIPT_PUB;\n+    coinbaseTx.vout[0].nValue = GetBlockSubsidy(nHeight, chainparams.GetConsensus());\n+    coinbaseTx.vin[0].scriptSig = CScript() << nHeight << OP_0;\n+\n+\n+    naughtyTx.vout.resize(1);\n+    naughtyTx.vout[0].nValue = 0;\n+    naughtyTx.vout[0].scriptPubKey = SCRIPT_PUB;\n+\n+    int n_inputs = (((MAX_BLOCK_SERIALIZED_SIZE / WITNESS_SCALE_FACTOR) - (CTransaction(coinbaseTx).GetTotalSize() + CTransaction(naughtyTx).GetTotalSize())) / 41) - 100;\n+    for (int x = 0; x < (n_inputs - 1); ++x) {\n+        naughtyTx.vin.emplace_back(GetRandHash(), 0, CScript(), 0);\n+    }\n+    naughtyTx.vin.emplace_back(naughtyTx.vin.back());\n+\n+    block.vtx.push_back(MakeTransactionRef(std::move(coinbaseTx)));\n+    block.vtx.push_back(MakeTransactionRef(std::move(naughtyTx)));\n+\n+    block.hashMerkleRoot = BlockMerkleRoot(block);\n+\n+    while (state.KeepRunning()) {\n+        CValidationState state{};\n+        assert(!CheckBlock(block, state, chainparams.GetConsensus(), false, false));\n+        assert(state.GetRejectReason() == \"bad-txns-inputs-duplicate\");\n+    }\n+\n+    thread_group.interrupt_all();\n+    thread_group.join_all();\n+    GetMainSignals().FlushBackgroundCallbacks();\n+    GetMainSignals().UnregisterBackgroundSignalScheduler();\n+}\n+\n+BENCHMARK(DuplicateInputs, 10);"
      }
    ]
  },
  {
    "sha": "2871bc9a71443c074ef011b9cafce6d4a3d47e14",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyODcxYmM5YTcxNDQzYzA3NGVmMDExYjljYWZjZTZkNGEzZDQ3ZTE0",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2018-09-25T23:53:04Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2018-10-06T01:01:22Z"
      },
      "message": "Add Probabalistic Checker for Duplicate Inputs",
      "tree": {
        "sha": "ad2e055ad9a3b08b558c3d7fd202694b09b1ae3f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ad2e055ad9a3b08b558c3d7fd202694b09b1ae3f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2871bc9a71443c074ef011b9cafce6d4a3d47e14",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2871bc9a71443c074ef011b9cafce6d4a3d47e14",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2871bc9a71443c074ef011b9cafce6d4a3d47e14",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2871bc9a71443c074ef011b9cafce6d4a3d47e14/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e1ed29fd90a735fcb28df2897bcc24f9d5cdbc35",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e1ed29fd90a735fcb28df2897bcc24f9d5cdbc35",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e1ed29fd90a735fcb28df2897bcc24f9d5cdbc35"
      }
    ],
    "stats": {
      "total": 247,
      "additions": 228,
      "deletions": 19
    },
    "files": [
      {
        "sha": "40e3c9e7fad180769e955f64853230fbd3a3787f",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 163,
        "deletions": 17,
        "changes": 180,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2871bc9a71443c074ef011b9cafce6d4a3d47e14/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2871bc9a71443c074ef011b9cafce6d4a3d47e14/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=2871bc9a71443c074ef011b9cafce6d4a3d47e14",
        "patch": "@@ -13,6 +13,10 @@\n #include <chain.h>\n #include <coins.h>\n #include <utilmoneystr.h>\n+#include <utilmemory.h>\n+#include <random.h>\n+\n+#include <functional>\n \n bool IsFinalTx(const CTransaction &tx, int nBlockHeight, int64_t nBlockTime)\n {\n@@ -156,7 +160,7 @@ int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& i\n     return nSigOps;\n }\n \n-bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fCheckDuplicateInputs)\n+bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fCheckDuplicateInputs, uint64_t table[])\n {\n     // Basic checks that don't depend on any context\n     if (tx.vin.empty())\n@@ -181,25 +185,167 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n     }\n \n     // Check for duplicate inputs - note that this check is slow so we skip it in CheckBlock\n-    if (fCheckDuplicateInputs) {\n-        std::set<COutPoint> vInOutPoints;\n-        for (const auto& txin : tx.vin)\n-        {\n-            if (!vInOutPoints.insert(txin.prevout).second)\n-                return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n-        }\n-    }\n-\n-    if (tx.IsCoinBase())\n-    {\n+    if (tx.IsCoinBase() ) {\n         if (tx.vin[0].scriptSig.size() < 2 || tx.vin[0].scriptSig.size() > 100)\n             return state.DoS(100, false, REJECT_INVALID, \"bad-cb-length\");\n-    }\n-    else\n-    {\n-        for (const auto& txin : tx.vin)\n-            if (txin.prevout.IsNull())\n+    } else if (!fCheckDuplicateInputs || tx.vin.size() == 1){\n+        for (const auto& txin : tx.vin) {\n+            if (txin.prevout.IsNull()) {\n                 return state.DoS(10, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n+            }\n+        }\n+    } else{\n+        // This duplication checking algorithm uses a probabilistic filter\n+        // to check for collisions efficiently.\n+        //\n+        // This is faster than the naive construction, using a set, which\n+        // requires more allocation and comparison of uint256s.\n+        //\n+        // First we create a bitset table with 1<<21 elements. This\n+        // is around 300 KB, so we construct it on the heap.\n+        //\n+        // We also allow reusing a 'dirty' table because zeroing 300 KB\n+        // can be expensive, and the table will operate acceptably for all of the\n+        // transactions in a given block.\n+        //\n+        // Then, we iterate through the elements one by one, generated 8 salted\n+        // 21-bit hashes (which can be quickly generated using siphash) based on\n+        // each prevout.\n+        //\n+        // We then check if all 8 hashes are set in the table yet. If they are,\n+        // we do a linear scan through the inputs to see if it was a true\n+        // collision, and reject the txn.\n+        //\n+        // Otherwise, we set the 8 bits corresponding to the hashes and\n+        // continue.\n+        //\n+        // From the perspective of the N+1st prevout, assuming the transaction\n+        // does not double spend:\n+        //\n+        // Up to N*8 hashes have been set in the table already (potentially\n+        // fewer if collisions)\n+        //\n+        // For each of the 8 hashes h_1...h_8, P(bit set in table for h_i) =\n+        // (N*8)/1<<21\n+        //\n+        // Each of these probabilities is independent\n+        //\n+        // Therefore the total probability of a false collision on all bits is:\n+        // ((N*8)/2**21)**8\n+        //\n+        // The cost of a false collision is to do N comparisons.\n+        //\n+        // Therefore, the expression for the expected number of comparisons is:\n+        //\n+        // Sum from i = 0 to M [ i*( i*8 / 2**21)**8 ]\n+        //\n+        // Based on an input being at least 41 bytes, and a block being 1M bytes\n+        // max, there are a maximum of 24390 inputs, so M = 24390\n+        //\n+        // The total expected number of direct comparisons for M=24930 is\n+        // therefore 0.33 with this algorithm.\n+        //\n+        // As a bonus, we also get \"free\" null checking by manually inserting\n+        // the null element into the table so it always generates a conflict\n+        // check. We remove this null-check before terminating so that we avoid\n+        // doubling the bloat on the table.\n+        //\n+        // If a dirty table is used, the algorithms worst-case\n+        // runtime is still better because of three key reasons:\n+        //\n+        // 1) the linear searches complexity is limited to each transaction's\n+        // subset of inputs\n+        // 2) The total number of inputs in the block still does not exceed\n+        // 24930\n+        // 3) less initialization of the table\n+        //\n+        //\n+        // The worst case for this algorithm from a denial of service\n+        // perspective with an invalid transaction would be to do a transaction\n+        // where the last two elements are a collision. In this case, the scan\n+        // would require to scan all N elements.\n+        //\n+        //\n+        //\n+        // N.B. When the table is dirty, the bits set in the table\n+        // are meaningless because the hash was salted separately.\n+        //\n+        uint64_t k1 = GetRand(std::numeric_limits<uint64_t>::max());\n+        uint64_t k2 = GetRand(std::numeric_limits<uint64_t>::max());\n+        auto hasher = [k1, k2](const COutPoint& out){return SipHashUint256Extra192(k1, k2, out.hash, out.n);};\n+        // If we haven't been given a table, make one now.\n+        std::unique_ptr<uint64_t[]> upTable = table ? std::unique_ptr<uint64_t[]>(nullptr) :\n+                                                      std::unique_ptr<uint64_t[]>(new uint64_t[1<<15]());\n+        table = table ? table : upTable.get();\n+#define HASH(h, a) \\\n+uint64_t bit1 = 1<<(std::get<0>(h) & 63);\\\n+uint64_t bit2 = 1<<(std::get<0>(h)>>6 & 63);\\\n+uint64_t bit3 = 1<<(std::get<0>(h)>>12 & 63);\\\n+uint64_t bit4 = 1<<(std::get<0>(h)>>18 & 63);\\\n+uint64_t bit5 = 1<<(std::get<0>(h)>>24 & 63);\\\n+uint64_t bit6 = 1<<(std::get<0>(h)>>24 & 63);\\\n+uint64_t bit7 = 1<<(std::get<0>(h)>>24 & 63);\\\n+uint64_t bit8 = 1<<(std::get<0>(h)>>24 & 63);\\\n+uint64_t pos1 = (std::get<1>(h)     & 0x07FFF);\\\n+uint64_t pos2 = (std::get<1>(h)>>15 & 0x07FFF);\\\n+uint64_t pos3 = (std::get<1>(h)>>30 & 0x07FFF);\\\n+uint64_t pos4 = (std::get<1>(h)>>45 & 0x07FFF);\\\n+uint64_t pos5 = (std::get<2>(h)     & 0x07FFF);\\\n+uint64_t pos6 = (std::get<2>(h)>>15 & 0x07FFF);\\\n+uint64_t pos7 = (std::get<2>(h)>>30 & 0x07FFF);\\\n+uint64_t pos8 = (std::get<2>(h)>>45 & 0x07FFF);\\\n+        a;\n+#define SET_BITS \\\n+        table[pos1] |= bit1;\\\n+        table[pos2] |= bit2;\\\n+        table[pos3] |= bit3;\\\n+        table[pos4] |= bit4;\\\n+        table[pos5] |= bit5;\\\n+        table[pos6] |= bit6;\\\n+        table[pos7] |= bit7;\\\n+        table[pos8] |= bit8;\n+\n+#define TOGGLE_BITS \\\n+        table[pos1] ^= bit1;\\\n+        table[pos2] ^= bit2;\\\n+        table[pos3] ^= bit3;\\\n+        table[pos4] ^= bit4;\\\n+        table[pos5] ^= bit5;\\\n+        table[pos6] ^= bit6;\\\n+        table[pos7] ^= bit7;\\\n+        table[pos8] ^= bit8;\n+#define DONT_SET_BITS\n+\n+\n+        auto nil_hash = hasher(COutPoint{});\n+        HASH(nil_hash, SET_BITS);\n+        std::unique_ptr<void, std::function<void(void*)>>\n+            cleanupNilEntryGuard((void*)1, [&](void*) { TOGGLE_BITS; });\n+        for (auto txinit =  tx.vin.cbegin(); txinit != tx.vin.cend(); ++txinit) {\n+            auto hash = hasher(txinit->prevout);\n+            HASH(hash, DONT_SET_BITS)\n+            if (\n+            (table[pos1] & bit1) &&\n+            (table[pos2] & bit2) &&\n+            (table[pos3] & bit3) &&\n+            (table[pos4] & bit4) &&\n+            (table[pos5] & bit5) &&\n+            (table[pos6] & bit6) &&\n+            (table[pos7] & bit7) &&\n+            (table[pos8] & bit8)) {\n+                if (txinit->prevout.IsNull()) {\n+                    return state.DoS(10, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n+                }\n+                // If we have a potential collision, then scan through the set up to here for the colliding element\n+                auto elem = std::find_if(tx.vin.begin(), txinit, [txinit](CTxIn x){return x.prevout == txinit->prevout;});\n+                // If the iterator outputs anything except for txinit, then we have found a conflict\n+                if  (elem != txinit) {\n+                    return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n+                }\n+            } else {\n+                SET_BITS;\n+            }\n+        }\n     }\n \n     return true;"
      },
      {
        "sha": "6892418f3ec9a3b34c633e732b0c58bfecb8c6a6",
        "filename": "src/consensus/tx_verify.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2871bc9a71443c074ef011b9cafce6d4a3d47e14/src/consensus/tx_verify.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2871bc9a71443c074ef011b9cafce6d4a3d47e14/src/consensus/tx_verify.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.h?ref=2871bc9a71443c074ef011b9cafce6d4a3d47e14",
        "patch": "@@ -18,7 +18,7 @@ class CValidationState;\n /** Transaction validation functions */\n \n /** Context-independent validity checks */\n-bool CheckTransaction(const CTransaction& tx, CValidationState& state, bool fCheckDuplicateInputs=true);\n+bool CheckTransaction(const CTransaction& tx, CValidationState& state, bool fCheckDuplicateInputs=true, uint64_t table[]=nullptr);\n \n namespace Consensus {\n /**"
      },
      {
        "sha": "647cf55673f1d80f58caef317049f9b3569db00b",
        "filename": "src/hash.cpp",
        "status": "modified",
        "additions": 60,
        "deletions": 0,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2871bc9a71443c074ef011b9cafce6d4a3d47e14/src/hash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2871bc9a71443c074ef011b9cafce6d4a3d47e14/src/hash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.cpp?ref=2871bc9a71443c074ef011b9cafce6d4a3d47e14",
        "patch": "@@ -245,3 +245,63 @@ uint64_t SipHashUint256Extra(uint64_t k0, uint64_t k1, const uint256& val, uint3\n     SIPROUND;\n     return v0 ^ v1 ^ v2 ^ v3;\n }\n+\n+std::tuple<uint64_t, uint64_t, uint64_t> SipHashUint256Extra192(uint64_t k0, uint64_t k1, const uint256& val, uint32_t extra)\n+{\n+    /* Specialized implementation for efficiency */\n+    uint64_t d = val.GetUint64(0);\n+\n+    uint64_t v0 = 0x736f6d6570736575ULL ^ k0;\n+    uint64_t v1 = 0x646f72616e646f6dULL ^ k1;\n+    uint64_t v2 = 0x6c7967656e657261ULL ^ k0;\n+    uint64_t v3 = 0x7465646279746573ULL ^ k1 ^ d;\n+\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    d = val.GetUint64(1);\n+    v3 ^= d;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    d = val.GetUint64(2);\n+    v3 ^= d;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    d = val.GetUint64(3);\n+    v3 ^= d;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    d = (((uint64_t)36) << 56) | extra;\n+    v3 ^= d;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    v2 ^= 0xEE;\n+    SIPROUND;\n+    SIPROUND;\n+    SIPROUND;\n+    SIPROUND;\n+\n+    uint64_t res1 = v0 ^ v1 ^ v2 ^ v3;\n+\n+    v1 ^= 0xDD;\n+\n+    SIPROUND;\n+    SIPROUND;\n+    SIPROUND;\n+    SIPROUND;\n+\n+    uint64_t res2 = v0 ^ v1 ^ v2 ^ v3;\n+\n+    v1 ^= 0xAA;\n+\n+    SIPROUND;\n+    SIPROUND;\n+    SIPROUND;\n+    SIPROUND;\n+\n+    return std::make_tuple(res1, res2, v0 ^ v1 ^ v2 ^ v3);\n+}"
      },
      {
        "sha": "fe817707f575656d0c21b874e8eeb13016057b86",
        "filename": "src/hash.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2871bc9a71443c074ef011b9cafce6d4a3d47e14/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2871bc9a71443c074ef011b9cafce6d4a3d47e14/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.h?ref=2871bc9a71443c074ef011b9cafce6d4a3d47e14",
        "patch": "@@ -229,4 +229,5 @@ class CSipHasher\n uint64_t SipHashUint256(uint64_t k0, uint64_t k1, const uint256& val);\n uint64_t SipHashUint256Extra(uint64_t k0, uint64_t k1, const uint256& val, uint32_t extra);\n \n+std::tuple<uint64_t, uint64_t, uint64_t> SipHashUint256Extra192(uint64_t k0, uint64_t k1, const uint256& val, uint32_t extra);\n #endif // BITCOIN_HASH_H"
      },
      {
        "sha": "ed160f5ddf15960cebb73e4966af7160a2afd0d2",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2871bc9a71443c074ef011b9cafce6d4a3d47e14/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2871bc9a71443c074ef011b9cafce6d4a3d47e14/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=2871bc9a71443c074ef011b9cafce6d4a3d47e14",
        "patch": "@@ -3121,8 +3121,10 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n             return state.DoS(100, false, REJECT_INVALID, \"bad-cb-multiple\", false, \"more than one coinbase\");\n \n     // Check transactions\n+    //\n+    std::unique_ptr<uint64_t[]> table = std::unique_ptr<uint64_t[]>(new uint64_t[1<<15]());\n     for (const auto& tx : block.vtx)\n-        if (!CheckTransaction(*tx, state, true))\n+        if (!CheckTransaction(*tx, state, true, table.get()))\n             return state.Invalid(false, state.GetRejectCode(), state.GetRejectReason(),\n                                  strprintf(\"Transaction check failed (tx hash %s) %s\", tx->GetHash().ToString(), state.GetDebugMessage()));\n "
      }
    ]
  },
  {
    "sha": "d2b195b2017899b8fa5ffaa511045b2d0a642e46",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMmIxOTViMjAxNzg5OWI4ZmE1ZmZhYTUxMTA0NWIyZDBhNjQyZTQ2",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2018-10-05T07:53:25Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2018-10-06T01:01:22Z"
      },
      "message": "Fix hash computations to get unique bits",
      "tree": {
        "sha": "b700726bb0934f83912021d8bbdd856c410e3c8a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b700726bb0934f83912021d8bbdd856c410e3c8a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d2b195b2017899b8fa5ffaa511045b2d0a642e46",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d2b195b2017899b8fa5ffaa511045b2d0a642e46",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d2b195b2017899b8fa5ffaa511045b2d0a642e46",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d2b195b2017899b8fa5ffaa511045b2d0a642e46/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2871bc9a71443c074ef011b9cafce6d4a3d47e14",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2871bc9a71443c074ef011b9cafce6d4a3d47e14",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2871bc9a71443c074ef011b9cafce6d4a3d47e14"
      }
    ],
    "stats": {
      "total": 28,
      "additions": 14,
      "deletions": 14
    },
    "files": [
      {
        "sha": "93ad9a4ff117decd7aa6c1115c3b531f220fb77a",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d2b195b2017899b8fa5ffaa511045b2d0a642e46/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d2b195b2017899b8fa5ffaa511045b2d0a642e46/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=d2b195b2017899b8fa5ffaa511045b2d0a642e46",
        "patch": "@@ -278,22 +278,22 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n                                                       std::unique_ptr<uint64_t[]>(new uint64_t[1<<15]());\n         table = table ? table : upTable.get();\n #define HASH(h, a) \\\n-uint64_t bit1 = 1<<(std::get<0>(h) & 63);\\\n-uint64_t bit2 = 1<<(std::get<0>(h)>>6 & 63);\\\n-uint64_t bit3 = 1<<(std::get<0>(h)>>12 & 63);\\\n-uint64_t bit4 = 1<<(std::get<0>(h)>>18 & 63);\\\n-uint64_t bit5 = 1<<(std::get<0>(h)>>24 & 63);\\\n-uint64_t bit6 = 1<<(std::get<0>(h)>>24 & 63);\\\n-uint64_t bit7 = 1<<(std::get<0>(h)>>24 & 63);\\\n-uint64_t bit8 = 1<<(std::get<0>(h)>>24 & 63);\\\n+uint64_t bit1 = 1<<((std::get<0>(h)) & 63);\\\n+uint64_t bit2 = 1<<((std::get<0>(h)>>6) & 63);\\\n+uint64_t bit3 = 1<<((std::get<0>(h)>>12) & 63);\\\n+uint64_t bit4 = 1<<((std::get<0>(h)>>18) & 63);\\\n+uint64_t bit5 = 1<<((std::get<0>(h)>>24) & 63);\\\n+uint64_t bit6 = 1<<((std::get<0>(h)>>30) & 63);\\\n+uint64_t bit7 = 1<<((std::get<0>(h)>>36) & 63);\\\n+uint64_t bit8 = 1<<((std::get<0>(h)>>42) & 63);\\\n uint64_t pos1 = (std::get<1>(h)     & 0x07FFF);\\\n-uint64_t pos2 = (std::get<1>(h)>>15 & 0x07FFF);\\\n-uint64_t pos3 = (std::get<1>(h)>>30 & 0x07FFF);\\\n-uint64_t pos4 = (std::get<1>(h)>>45 & 0x07FFF);\\\n+uint64_t pos2 = ((std::get<1>(h)>>15) & 0x07FFF);\\\n+uint64_t pos3 = ((std::get<1>(h)>>30) & 0x07FFF);\\\n+uint64_t pos4 = ((std::get<1>(h)>>45) & 0x07FFF);\\\n uint64_t pos5 = (std::get<2>(h)     & 0x07FFF);\\\n-uint64_t pos6 = (std::get<2>(h)>>15 & 0x07FFF);\\\n-uint64_t pos7 = (std::get<2>(h)>>30 & 0x07FFF);\\\n-uint64_t pos8 = (std::get<2>(h)>>45 & 0x07FFF);\\\n+uint64_t pos6 = ((std::get<2>(h)>>15) & 0x07FFF);\\\n+uint64_t pos7 = ((std::get<2>(h)>>30) & 0x07FFF);\\\n+uint64_t pos8 = ((std::get<2>(h)>>45) & 0x07FFF);\\\n         a;\n #define SET_BITS \\\n         table[pos1] |= bit1;\\"
      }
    ]
  },
  {
    "sha": "5ff5f74f30b3d5bcfd92341e999fbe2454fa8563",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ZmY1Zjc0ZjMwYjNkNWJjZmQ5MjM0MWU5OTlmYmUyNDU0ZmE4NTYz",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2018-10-05T22:16:44Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2018-10-06T01:01:22Z"
      },
      "message": "Use less error-prone code for bitset",
      "tree": {
        "sha": "535cf4684bbec56fd33b73946889cd5048771579",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/535cf4684bbec56fd33b73946889cd5048771579"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5ff5f74f30b3d5bcfd92341e999fbe2454fa8563",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5ff5f74f30b3d5bcfd92341e999fbe2454fa8563",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5ff5f74f30b3d5bcfd92341e999fbe2454fa8563",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5ff5f74f30b3d5bcfd92341e999fbe2454fa8563/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d2b195b2017899b8fa5ffaa511045b2d0a642e46",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d2b195b2017899b8fa5ffaa511045b2d0a642e46",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d2b195b2017899b8fa5ffaa511045b2d0a642e46"
      }
    ],
    "stats": {
      "total": 122,
      "additions": 63,
      "deletions": 59
    },
    "files": [
      {
        "sha": "d32f3a347a8e6248cb5289491c273914d9a00d46",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 60,
        "deletions": 57,
        "changes": 117,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5ff5f74f30b3d5bcfd92341e999fbe2454fa8563/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5ff5f74f30b3d5bcfd92341e999fbe2454fa8563/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=5ff5f74f30b3d5bcfd92341e999fbe2454fa8563",
        "patch": "@@ -160,7 +160,7 @@ int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& i\n     return nSigOps;\n }\n \n-bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fCheckDuplicateInputs, uint64_t table[])\n+bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fCheckDuplicateInputs, std::bitset<1ull<<21>* table)\n {\n     // Basic checks that don't depend on any context\n     if (tx.vin.empty())\n@@ -272,67 +272,70 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n         //\n         uint64_t k1 = GetRand(std::numeric_limits<uint64_t>::max());\n         uint64_t k2 = GetRand(std::numeric_limits<uint64_t>::max());\n-        auto hasher = [k1, k2](const COutPoint& out){return SipHashUint256Extra192(k1, k2, out.hash, out.n);};\n         // If we haven't been given a table, make one now.\n-        std::unique_ptr<uint64_t[]> upTable = table ? std::unique_ptr<uint64_t[]>(nullptr) :\n-                                                      std::unique_ptr<uint64_t[]>(new uint64_t[1<<15]());\n+        std::unique_ptr<std::bitset<1<<21>> upTable = table ? std::unique_ptr<std::bitset<1<<21>>(nullptr) :\n+                                                      MakeUnique<std::bitset<1<<21>>();\n         table = table ? table : upTable.get();\n-#define HASH(h, a) \\\n-uint64_t bit1 = 1<<((std::get<0>(h)) & 63);\\\n-uint64_t bit2 = 1<<((std::get<0>(h)>>6) & 63);\\\n-uint64_t bit3 = 1<<((std::get<0>(h)>>12) & 63);\\\n-uint64_t bit4 = 1<<((std::get<0>(h)>>18) & 63);\\\n-uint64_t bit5 = 1<<((std::get<0>(h)>>24) & 63);\\\n-uint64_t bit6 = 1<<((std::get<0>(h)>>30) & 63);\\\n-uint64_t bit7 = 1<<((std::get<0>(h)>>36) & 63);\\\n-uint64_t bit8 = 1<<((std::get<0>(h)>>42) & 63);\\\n-uint64_t pos1 = (std::get<1>(h)     & 0x07FFF);\\\n-uint64_t pos2 = ((std::get<1>(h)>>15) & 0x07FFF);\\\n-uint64_t pos3 = ((std::get<1>(h)>>30) & 0x07FFF);\\\n-uint64_t pos4 = ((std::get<1>(h)>>45) & 0x07FFF);\\\n-uint64_t pos5 = (std::get<2>(h)     & 0x07FFF);\\\n-uint64_t pos6 = ((std::get<2>(h)>>15) & 0x07FFF);\\\n-uint64_t pos7 = ((std::get<2>(h)>>30) & 0x07FFF);\\\n-uint64_t pos8 = ((std::get<2>(h)>>45) & 0x07FFF);\\\n-        a;\n-#define SET_BITS \\\n-        table[pos1] |= bit1;\\\n-        table[pos2] |= bit2;\\\n-        table[pos3] |= bit3;\\\n-        table[pos4] |= bit4;\\\n-        table[pos5] |= bit5;\\\n-        table[pos6] |= bit6;\\\n-        table[pos7] |= bit7;\\\n-        table[pos8] |= bit8;\n-\n-#define TOGGLE_BITS \\\n-        table[pos1] ^= bit1;\\\n-        table[pos2] ^= bit2;\\\n-        table[pos3] ^= bit3;\\\n-        table[pos4] ^= bit4;\\\n-        table[pos5] ^= bit5;\\\n-        table[pos6] ^= bit6;\\\n-        table[pos7] ^= bit7;\\\n-        table[pos8] ^= bit8;\n-#define DONT_SET_BITS\n-\n-\n+        struct pos {\n+            uint64_t a : 21;\n+            uint64_t b : 21;\n+            uint64_t c : 21;\n+            bool empty_1 : 1;\n+            uint64_t d : 21;\n+            uint64_t e : 21;\n+            uint64_t f : 21;\n+            bool empty_2 : 1;\n+            uint64_t g : 21;\n+            uint64_t h : 21;\n+            uint64_t unused : 22;\n+            void set(std::bitset<1<<21>& t) {\n+                t.set(a);\n+                t.set(b); \n+                t.set(c); \n+                t.set(d); \n+                t.set(e); \n+                t.set(f); \n+                t.set(g); \n+                t.set(h);\n+            };\n+        };\n+        struct packed_hash {\n+            uint64_t a;\n+            uint64_t b;\n+            uint64_t c;\n+        };\n+        union convert {\n+            packed_hash ph;\n+            pos p;\n+        };\n+        auto hasher = [k1, k2](const COutPoint& out){\n+            auto h = SipHashUint256Extra192(k1, k2, out.hash, out.n);\n+            convert v = {std::get<0>(h), std::get<1>(h), std::get<2>(h)};\n+            return v.p;\n+        };\n         auto nil_hash = hasher(COutPoint{});\n-        HASH(nil_hash, SET_BITS);\n+        nil_hash.set(*table);\n         std::unique_ptr<void, std::function<void(void*)>>\n-            cleanupNilEntryGuard((void*)1, [&](void*) { TOGGLE_BITS; });\n+            cleanupNilEntryGuard((void*)1, [&](void*) { \n+                    table->flip(nil_hash.a);\n+                    table->flip(nil_hash.b);\n+                    table->flip(nil_hash.c);\n+                    table->flip(nil_hash.d);\n+                    table->flip(nil_hash.e);\n+                    table->flip(nil_hash.f);\n+                    table->flip(nil_hash.g);\n+                    table->flip(nil_hash.h);\n+                    });\n         for (auto txinit =  tx.vin.cbegin(); txinit != tx.vin.cend(); ++txinit) {\n             auto hash = hasher(txinit->prevout);\n-            HASH(hash, DONT_SET_BITS)\n-            if (\n-            (table[pos1] & bit1) &&\n-            (table[pos2] & bit2) &&\n-            (table[pos3] & bit3) &&\n-            (table[pos4] & bit4) &&\n-            (table[pos5] & bit5) &&\n-            (table[pos6] & bit6) &&\n-            (table[pos7] & bit7) &&\n-            (table[pos8] & bit8)) {\n+            if (table->test(hash.a) &&\n+                table->test(hash.b) &&\n+                table->test(hash.c) &&\n+                table->test(hash.d) &&\n+                table->test(hash.e) &&\n+                table->test(hash.f) &&\n+                table->test(hash.g) &&\n+                table->test(hash.h)) {\n                 if (txinit->prevout.IsNull()) {\n                     return state.DoS(10, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n                 }\n@@ -343,7 +346,7 @@ uint64_t pos8 = ((std::get<2>(h)>>45) & 0x07FFF);\\\n                     return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n                 }\n             } else {\n-                SET_BITS;\n+                hash.set(*table);\n             }\n         }\n     }"
      },
      {
        "sha": "f9e5a40b70844d1fc6517e232dc44e14ab102ab7",
        "filename": "src/consensus/tx_verify.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5ff5f74f30b3d5bcfd92341e999fbe2454fa8563/src/consensus/tx_verify.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5ff5f74f30b3d5bcfd92341e999fbe2454fa8563/src/consensus/tx_verify.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.h?ref=5ff5f74f30b3d5bcfd92341e999fbe2454fa8563",
        "patch": "@@ -9,6 +9,7 @@\n \n #include <stdint.h>\n #include <vector>\n+#include <bitset>\n \n class CBlockIndex;\n class CCoinsViewCache;\n@@ -18,7 +19,7 @@ class CValidationState;\n /** Transaction validation functions */\n \n /** Context-independent validity checks */\n-bool CheckTransaction(const CTransaction& tx, CValidationState& state, bool fCheckDuplicateInputs=true, uint64_t table[]=nullptr);\n+bool CheckTransaction(const CTransaction& tx, CValidationState& state, bool fCheckDuplicateInputs=true, std::bitset<1ull<<21>* table=nullptr);\n \n namespace Consensus {\n /**"
      },
      {
        "sha": "036abad2dac982db1e51d737fbc6fa4eec45f6d9",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5ff5f74f30b3d5bcfd92341e999fbe2454fa8563/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5ff5f74f30b3d5bcfd92341e999fbe2454fa8563/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=5ff5f74f30b3d5bcfd92341e999fbe2454fa8563",
        "patch": "@@ -3122,7 +3122,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n \n     // Check transactions\n     //\n-    std::unique_ptr<uint64_t[]> table = std::unique_ptr<uint64_t[]>(new uint64_t[1<<15]());\n+    std::unique_ptr<std::bitset<1<<21>> table = MakeUnique<std::bitset<1<<21>>();\n     for (const auto& tx : block.vtx)\n         if (!CheckTransaction(*tx, state, true, table.get()))\n             return state.Invalid(false, state.GetRejectCode(), state.GetRejectReason(),"
      }
    ]
  },
  {
    "sha": "752682d554c9d6ae9fd10a81500278df52025d7c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3NTI2ODJkNTU0YzlkNmFlOWZkMTBhODE1MDAyNzhkZjUyMDI1ZDdj",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2018-10-06T00:16:03Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2018-10-06T01:01:22Z"
      },
      "message": "revert tx_verify.* to master",
      "tree": {
        "sha": "1465cca2afdfde14315e3599260465e033a34d63",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1465cca2afdfde14315e3599260465e033a34d63"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/752682d554c9d6ae9fd10a81500278df52025d7c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/752682d554c9d6ae9fd10a81500278df52025d7c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/752682d554c9d6ae9fd10a81500278df52025d7c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/752682d554c9d6ae9fd10a81500278df52025d7c/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5ff5f74f30b3d5bcfd92341e999fbe2454fa8563",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5ff5f74f30b3d5bcfd92341e999fbe2454fa8563",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5ff5f74f30b3d5bcfd92341e999fbe2454fa8563"
      }
    ],
    "stats": {
      "total": 186,
      "additions": 18,
      "deletions": 168
    },
    "files": [
      {
        "sha": "0628ec1d475e273fc3536e31bd7404286182165e",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 166,
        "changes": 183,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/752682d554c9d6ae9fd10a81500278df52025d7c/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/752682d554c9d6ae9fd10a81500278df52025d7c/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=752682d554c9d6ae9fd10a81500278df52025d7c",
        "patch": "@@ -13,10 +13,6 @@\n #include <chain.h>\n #include <coins.h>\n #include <utilmoneystr.h>\n-#include <utilmemory.h>\n-#include <random.h>\n-\n-#include <functional>\n \n bool IsFinalTx(const CTransaction &tx, int nBlockHeight, int64_t nBlockTime)\n {\n@@ -160,7 +156,7 @@ int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& i\n     return nSigOps;\n }\n \n-bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fCheckDuplicateInputs, std::bitset<1ull<<21>* table)\n+bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fCheckDuplicateInputs)\n {\n     // Basic checks that don't depend on any context\n     if (tx.vin.empty())\n@@ -185,170 +181,25 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n     }\n \n     // Check for duplicate inputs - note that this check is slow so we skip it in CheckBlock\n-    if (tx.IsCoinBase() ) {\n+    if (fCheckDuplicateInputs) {\n+        std::set<COutPoint> vInOutPoints;\n+        for (const auto& txin : tx.vin)\n+        {\n+            if (!vInOutPoints.insert(txin.prevout).second)\n+                return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n+        }\n+    }\n+\n+    if (tx.IsCoinBase())\n+    {\n         if (tx.vin[0].scriptSig.size() < 2 || tx.vin[0].scriptSig.size() > 100)\n             return state.DoS(100, false, REJECT_INVALID, \"bad-cb-length\");\n-    } else if (!fCheckDuplicateInputs || tx.vin.size() == 1){\n-        for (const auto& txin : tx.vin) {\n-            if (txin.prevout.IsNull()) {\n+    }\n+    else\n+    {\n+        for (const auto& txin : tx.vin)\n+            if (txin.prevout.IsNull())\n                 return state.DoS(10, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n-            }\n-        }\n-    } else{\n-        // This duplication checking algorithm uses a probabilistic filter\n-        // to check for collisions efficiently.\n-        //\n-        // This is faster than the naive construction, using a set, which\n-        // requires more allocation and comparison of uint256s.\n-        //\n-        // First we create a bitset table with 1<<21 elements. This\n-        // is around 300 KB, so we construct it on the heap.\n-        //\n-        // We also allow reusing a 'dirty' table because zeroing 300 KB\n-        // can be expensive, and the table will operate acceptably for all of the\n-        // transactions in a given block.\n-        //\n-        // Then, we iterate through the elements one by one, generated 8 salted\n-        // 21-bit hashes (which can be quickly generated using siphash) based on\n-        // each prevout.\n-        //\n-        // We then check if all 8 hashes are set in the table yet. If they are,\n-        // we do a linear scan through the inputs to see if it was a true\n-        // collision, and reject the txn.\n-        //\n-        // Otherwise, we set the 8 bits corresponding to the hashes and\n-        // continue.\n-        //\n-        // From the perspective of the N+1st prevout, assuming the transaction\n-        // does not double spend:\n-        //\n-        // Up to N*8 hashes have been set in the table already (potentially\n-        // fewer if collisions)\n-        //\n-        // For each of the 8 hashes h_1...h_8, P(bit set in table for h_i) =\n-        // (N*8)/1<<21\n-        //\n-        // Each of these probabilities is independent\n-        //\n-        // Therefore the total probability of a false collision on all bits is:\n-        // ((N*8)/2**21)**8\n-        //\n-        // The cost of a false collision is to do N comparisons.\n-        //\n-        // Therefore, the expression for the expected number of comparisons is:\n-        //\n-        // Sum from i = 0 to M [ i*( i*8 / 2**21)**8 ]\n-        //\n-        // Based on an input being at least 41 bytes, and a block being 1M bytes\n-        // max, there are a maximum of 24390 inputs, so M = 24390\n-        //\n-        // The total expected number of direct comparisons for M=24930 is\n-        // therefore 0.33 with this algorithm.\n-        //\n-        // As a bonus, we also get \"free\" null checking by manually inserting\n-        // the null element into the table so it always generates a conflict\n-        // check. We remove this null-check before terminating so that we avoid\n-        // doubling the bloat on the table.\n-        //\n-        // If a dirty table is used, the algorithms worst-case\n-        // runtime is still better because of three key reasons:\n-        //\n-        // 1) the linear searches complexity is limited to each transaction's\n-        // subset of inputs\n-        // 2) The total number of inputs in the block still does not exceed\n-        // 24930\n-        // 3) less initialization of the table\n-        //\n-        //\n-        // The worst case for this algorithm from a denial of service\n-        // perspective with an invalid transaction would be to do a transaction\n-        // where the last two elements are a collision. In this case, the scan\n-        // would require to scan all N elements.\n-        //\n-        //\n-        //\n-        // N.B. When the table is dirty, the bits set in the table\n-        // are meaningless because the hash was salted separately.\n-        //\n-        uint64_t k1 = GetRand(std::numeric_limits<uint64_t>::max());\n-        uint64_t k2 = GetRand(std::numeric_limits<uint64_t>::max());\n-        // If we haven't been given a table, make one now.\n-        std::unique_ptr<std::bitset<1<<21>> upTable = table ? std::unique_ptr<std::bitset<1<<21>>(nullptr) :\n-                                                      MakeUnique<std::bitset<1<<21>>();\n-        table = table ? table : upTable.get();\n-        struct pos {\n-            uint64_t a : 21;\n-            uint64_t b : 21;\n-            uint64_t c : 21;\n-            bool empty_1 : 1;\n-            uint64_t d : 21;\n-            uint64_t e : 21;\n-            uint64_t f : 21;\n-            bool empty_2 : 1;\n-            uint64_t g : 21;\n-            uint64_t h : 21;\n-            uint64_t unused : 22;\n-            void set(std::bitset<1<<21>& t) {\n-                t.set(a);\n-                t.set(b); \n-                t.set(c); \n-                t.set(d); \n-                t.set(e); \n-                t.set(f); \n-                t.set(g); \n-                t.set(h);\n-            };\n-        };\n-        struct packed_hash {\n-            uint64_t a;\n-            uint64_t b;\n-            uint64_t c;\n-        };\n-        union convert {\n-            packed_hash ph;\n-            pos p;\n-        };\n-        auto hasher = [k1, k2](const COutPoint& out){\n-            auto h = SipHashUint256Extra192(k1, k2, out.hash, out.n);\n-            convert v = {std::get<0>(h), std::get<1>(h), std::get<2>(h)};\n-            return v.p;\n-        };\n-        auto nil_hash = hasher(COutPoint{});\n-        nil_hash.set(*table);\n-        std::unique_ptr<void, std::function<void(void*)>>\n-            cleanupNilEntryGuard((void*)1, [&](void*) { \n-                    table->flip(nil_hash.a);\n-                    table->flip(nil_hash.b);\n-                    table->flip(nil_hash.c);\n-                    table->flip(nil_hash.d);\n-                    table->flip(nil_hash.e);\n-                    table->flip(nil_hash.f);\n-                    table->flip(nil_hash.g);\n-                    table->flip(nil_hash.h);\n-                    });\n-        for (auto txinit =  tx.vin.cbegin(); txinit != tx.vin.cend(); ++txinit) {\n-            auto hash = hasher(txinit->prevout);\n-            if (table->test(hash.a) &&\n-                table->test(hash.b) &&\n-                table->test(hash.c) &&\n-                table->test(hash.d) &&\n-                table->test(hash.e) &&\n-                table->test(hash.f) &&\n-                table->test(hash.g) &&\n-                table->test(hash.h)) {\n-                if (txinit->prevout.IsNull()) {\n-                    return state.DoS(10, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n-                }\n-                // If we have a potential collision, then scan through the set up to here for the colliding element\n-                auto elem = std::find_if(tx.vin.begin(), txinit, [txinit](CTxIn x){return x.prevout == txinit->prevout;});\n-                // If the iterator outputs anything except for txinit, then we have found a conflict\n-                if  (elem != txinit) {\n-                    return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n-                }\n-            } else {\n-                hash.set(*table);\n-            }\n-        }\n     }\n \n     return true;"
      },
      {
        "sha": "0519cef8c090ac9b494adcad6898d361ec74f2d6",
        "filename": "src/consensus/tx_verify.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/752682d554c9d6ae9fd10a81500278df52025d7c/src/consensus/tx_verify.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/752682d554c9d6ae9fd10a81500278df52025d7c/src/consensus/tx_verify.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.h?ref=752682d554c9d6ae9fd10a81500278df52025d7c",
        "patch": "@@ -9,7 +9,6 @@\n \n #include <stdint.h>\n #include <vector>\n-#include <bitset>\n \n class CBlockIndex;\n class CCoinsViewCache;\n@@ -19,7 +18,7 @@ class CValidationState;\n /** Transaction validation functions */\n \n /** Context-independent validity checks */\n-bool CheckTransaction(const CTransaction& tx, CValidationState& state, bool fCheckDuplicateInputs=true, std::bitset<1ull<<21>* table=nullptr);\n+bool CheckTransaction(const CTransaction& tx, CValidationState& state, bool fCheckDuplicateInputs=true);\n \n namespace Consensus {\n /**"
      }
    ]
  },
  {
    "sha": "4ca0ed7ae8501135ab413a2961ffeaaa0df85e5a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0Y2EwZWQ3YWU4NTAxMTM1YWI0MTNhMjk2MWZmZWFhYTBkZjg1ZTVh",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2018-10-06T00:17:30Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2018-10-06T01:01:23Z"
      },
      "message": "Add probabalistic duplicate detector to CheckBlock",
      "tree": {
        "sha": "88219ee4303d11416235d16000096d4b10de8c45",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/88219ee4303d11416235d16000096d4b10de8c45"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4ca0ed7ae8501135ab413a2961ffeaaa0df85e5a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ca0ed7ae8501135ab413a2961ffeaaa0df85e5a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4ca0ed7ae8501135ab413a2961ffeaaa0df85e5a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ca0ed7ae8501135ab413a2961ffeaaa0df85e5a/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "752682d554c9d6ae9fd10a81500278df52025d7c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/752682d554c9d6ae9fd10a81500278df52025d7c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/752682d554c9d6ae9fd10a81500278df52025d7c"
      }
    ],
    "stats": {
      "total": 160,
      "additions": 155,
      "deletions": 5
    },
    "files": [
      {
        "sha": "edb9e106578460dd345fafffc25985022d5de065",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4ca0ed7ae8501135ab413a2961ffeaaa0df85e5a/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4ca0ed7ae8501135ab413a2961ffeaaa0df85e5a/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=4ca0ed7ae8501135ab413a2961ffeaaa0df85e5a",
        "patch": "@@ -156,7 +156,7 @@ int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& i\n     return nSigOps;\n }\n \n-bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fCheckDuplicateInputs)\n+bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fCheckDuplicateInputs, bool fCheckNullInputs)\n {\n     // Basic checks that don't depend on any context\n     if (tx.vin.empty())\n@@ -195,7 +195,7 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n         if (tx.vin[0].scriptSig.size() < 2 || tx.vin[0].scriptSig.size() > 100)\n             return state.DoS(100, false, REJECT_INVALID, \"bad-cb-length\");\n     }\n-    else\n+    else if (fCheckNullInputs)\n     {\n         for (const auto& txin : tx.vin)\n             if (txin.prevout.IsNull())"
      },
      {
        "sha": "e54920c116c6a14a43065b9e7d35719bb3058bc0",
        "filename": "src/consensus/tx_verify.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4ca0ed7ae8501135ab413a2961ffeaaa0df85e5a/src/consensus/tx_verify.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4ca0ed7ae8501135ab413a2961ffeaaa0df85e5a/src/consensus/tx_verify.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.h?ref=4ca0ed7ae8501135ab413a2961ffeaaa0df85e5a",
        "patch": "@@ -18,7 +18,7 @@ class CValidationState;\n /** Transaction validation functions */\n \n /** Context-independent validity checks */\n-bool CheckTransaction(const CTransaction& tx, CValidationState& state, bool fCheckDuplicateInputs=true);\n+bool CheckTransaction(const CTransaction& tx, CValidationState& state, bool fCheckDuplicateInputs=true, bool fCheckNullInputs=true);\n \n namespace Consensus {\n /**"
      },
      {
        "sha": "18bab90740610a406953c37e7f78a542aefd7609",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 152,
        "deletions": 2,
        "changes": 154,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4ca0ed7ae8501135ab413a2961ffeaaa0df85e5a/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4ca0ed7ae8501135ab413a2961ffeaaa0df85e5a/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=4ca0ed7ae8501135ab413a2961ffeaaa0df85e5a",
        "patch": "@@ -3120,11 +3120,161 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n         if (block.vtx[i]->IsCoinBase())\n             return state.DoS(100, false, REJECT_INVALID, \"bad-cb-multiple\", false, \"more than one coinbase\");\n \n-    // Check transactions\n+    // Check transactions for duplicate inputs\n+    //\n+\n+    // This duplication checking algorithm uses a probabilistic filter\n+    // to check for collisions efficiently.\n+    //\n+    // This is faster than the naive construction, using a set, which\n+    // requires more allocation and comparison of uint256s.\n+    //\n+    // First we create a bitset table with 1<<21 elements. This\n+    // is around 300 KB, so we construct it on the heap.\n+    //\n+    // We also allow reusing a 'dirty' table because zeroing 300 KB\n+    // can be expensive, and the table will operate acceptably for all of the\n+    // transactions in a given block.\n+    //\n+    // Then, we iterate through the elements one by one, generated 8 salted\n+    // 21-bit hashes (which can be quickly generated using siphash) based on\n+    // each prevout.\n+    //\n+    // We then check if all 8 hashes are set in the table yet. If they are,\n+    // we do a linear scan through the inputs to see if it was a true\n+    // collision, and reject the txn.\n+    //\n+    // Otherwise, we set the 8 bits corresponding to the hashes and\n+    // continue.\n+    //\n+    // From the perspective of the N+1st prevout, assuming the transaction\n+    // does not double spend:\n+    //\n+    // Up to N*8 hashes have been set in the table already (potentially\n+    // fewer if collisions)\n+    //\n+    // For each of the 8 hashes h_1...h_8, P(bit set in table for h_i) =\n+    // (N*8)/1<<21\n+    //\n+    // Each of these probabilities is independent\n+    //\n+    // Therefore the total probability of a false collision on all bits is:\n+    // ((N*8)/2**21)**8\n+    //\n+    // The cost of a false collision is to do N comparisons.\n+    //\n+    // Therefore, the expression for the expected number of comparisons is:\n+    //\n+    // Sum from i = 0 to M [ i*( i*8 / 2**21)**8 ]\n+    //\n+    // Based on an input being at least 41 bytes, and a block being 1M bytes\n+    // max, there are a maximum of 24390 inputs, so M = 24390\n+    //\n+    // The total expected number of direct comparisons for M=24930 is\n+    // therefore 0.33 with this algorithm.\n+    //\n+    // As a bonus, we also get \"free\" null checking by manually inserting\n+    // the null element into the table so it always generates a conflict\n+    // check. We remove this null-check before terminating so that we avoid\n+    // doubling the bloat on the table.\n+    //\n+    // If a dirty table is used, the algorithms worst-case\n+    // runtime is still better because of three key reasons:\n+    //\n+    // 1) the linear searches complexity is limited to each transaction's\n+    // subset of inputs\n+    // 2) The total number of inputs in the block still does not exceed\n+    // 24930\n+    // 3) less initialization of the table\n+    //\n     //\n+    // The worst case for this algorithm from a denial of service\n+    // perspective with an invalid transaction would be to do a transaction\n+    // where the last two elements are a collision. In this case, the scan\n+    // would require to scan all N elements.\n+    //\n+    //\n+    //\n+    // N.B. When the table is dirty, the bits set in the table\n+    // are meaningless because the hash was salted separately.\n+    //\n+    struct pos {\n+        uint64_t a : 21;\n+        uint64_t b : 21;\n+        uint64_t c : 21;\n+        bool empty_1 : 1;\n+        uint64_t d : 21;\n+        uint64_t e : 21;\n+        uint64_t f : 21;\n+        bool empty_2 : 1;\n+        uint64_t g : 21;\n+        uint64_t h : 21;\n+        uint64_t unused : 22;\n+        void set(std::bitset<1<<21>& t) {\n+            t.set(a);\n+            t.set(b);\n+            t.set(c);\n+            t.set(d);\n+            t.set(e);\n+            t.set(f);\n+            t.set(g);\n+            t.set(h);\n+        };\n+    };\n+    struct packed_hash {\n+        uint64_t a;\n+        uint64_t b;\n+        uint64_t c;\n+    };\n+    union convert {\n+        packed_hash ph;\n+        pos p;\n+    };\n+\n+    uint64_t k1 = GetRand(std::numeric_limits<uint64_t>::max());\n+    uint64_t k2 = GetRand(std::numeric_limits<uint64_t>::max());\n+    auto hasher = [k1, k2](const COutPoint& out){\n+        auto h = SipHashUint256Extra192(k1, k2, out.hash, out.n);\n+        convert v = {std::get<0>(h), std::get<1>(h), std::get<2>(h)};\n+        return v.p;\n+    };\n+\n     std::unique_ptr<std::bitset<1<<21>> table = MakeUnique<std::bitset<1<<21>>();\n+    // Note that the first one tested is the coinbase transaction, whose input\n+    // is null. Therefore, any subsequent null input would be a collision with \n+    // that null, enabling us to not null check\n+    for (const auto& tx : block.vtx) {\n+        for (auto txinit =  tx->vin.cbegin(); txinit != tx->vin.cend(); ++txinit) {\n+            auto hash = hasher(txinit->prevout);\n+            if (table->test(hash.a) &&\n+                    table->test(hash.b) &&\n+                    table->test(hash.c) &&\n+                    table->test(hash.d) &&\n+                    table->test(hash.e) &&\n+                    table->test(hash.f) &&\n+                    table->test(hash.g) &&\n+                table->test(hash.h)) {\n+                if (txinit->prevout.IsNull()) {\n+                    return state.DoS(10, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n+                }\n+                // If we have a potential collision, perform expensive check\n+                for (const auto& tx2 : block.vtx) {\n+                    for (auto txinit2 =  tx2->vin.cbegin(); txinit2 != tx2->vin.cend(); ++txinit2) {\n+                        if (txinit2 != txinit && txinit2->prevout == txinit->prevout)\n+                            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n+                    }\n+\n+                }\n+            } else {\n+                hash.set(*table);\n+            }\n+        }\n+    }\n+\n+    // Check transactions\n+    //\n     for (const auto& tx : block.vtx)\n-        if (!CheckTransaction(*tx, state, true, table.get()))\n+        if (!CheckTransaction(*tx, state, false, false))\n             return state.Invalid(false, state.GetRejectCode(), state.GetRejectReason(),\n                                  strprintf(\"Transaction check failed (tx hash %s) %s\", tx->GetHash().ToString(), state.GetDebugMessage()));\n "
      }
    ]
  },
  {
    "sha": "c176a9c2c5e686eadbfb64feddcc980c52dcf050",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjMTc2YTljMmM1ZTY4NmVhZGJmYjY0ZmVkZGNjOTgwYzUyZGNmMDUw",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2018-10-06T01:01:13Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2018-10-06T01:01:23Z"
      },
      "message": "Clean up the implementation of fast deduplication checking",
      "tree": {
        "sha": "cd40414bcb56d2e77be165282cd9523b40a56b60",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cd40414bcb56d2e77be165282cd9523b40a56b60"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c176a9c2c5e686eadbfb64feddcc980c52dcf050",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c176a9c2c5e686eadbfb64feddcc980c52dcf050",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c176a9c2c5e686eadbfb64feddcc980c52dcf050",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c176a9c2c5e686eadbfb64feddcc980c52dcf050/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4ca0ed7ae8501135ab413a2961ffeaaa0df85e5a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ca0ed7ae8501135ab413a2961ffeaaa0df85e5a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4ca0ed7ae8501135ab413a2961ffeaaa0df85e5a"
      }
    ],
    "stats": {
      "total": 79,
      "additions": 41,
      "deletions": 38
    },
    "files": [
      {
        "sha": "0e0f11978f8b4a1af95906ca1477e6fe0cbd164a",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 38,
        "changes": 79,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c176a9c2c5e686eadbfb64feddcc980c52dcf050/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c176a9c2c5e686eadbfb64feddcc980c52dcf050/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=c176a9c2c5e686eadbfb64feddcc980c52dcf050",
        "patch": "@@ -3210,24 +3210,9 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n         uint64_t g : 21;\n         uint64_t h : 21;\n         uint64_t unused : 22;\n-        void set(std::bitset<1<<21>& t) {\n-            t.set(a);\n-            t.set(b);\n-            t.set(c);\n-            t.set(d);\n-            t.set(e);\n-            t.set(f);\n-            t.set(g);\n-            t.set(h);\n-        };\n-    };\n-    struct packed_hash {\n-        uint64_t a;\n-        uint64_t b;\n-        uint64_t c;\n     };\n     union convert {\n-        packed_hash ph;\n+        uint64_t ph[3];\n         pos p;\n     };\n \n@@ -3239,34 +3224,52 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n         return v.p;\n     };\n \n-    std::unique_ptr<std::bitset<1<<21>> table = MakeUnique<std::bitset<1<<21>>();\n+    std::unique_ptr<std::bitset<1<<21>> pTable = MakeUnique<std::bitset<1<<21>>();\n+    auto& table = *pTable.get();\n     // Note that the first one tested is the coinbase transaction, whose input\n-    // is null. Therefore, any subsequent null input would be a collision with \n+    // is null. Therefore, any subsequent null input would be a collision with\n     // that null, enabling us to not null check\n-    for (const auto& tx : block.vtx) {\n-        for (auto txinit =  tx->vin.cbegin(); txinit != tx->vin.cend(); ++txinit) {\n-            auto hash = hasher(txinit->prevout);\n-            if (table->test(hash.a) &&\n-                    table->test(hash.b) &&\n-                    table->test(hash.c) &&\n-                    table->test(hash.d) &&\n-                    table->test(hash.e) &&\n-                    table->test(hash.f) &&\n-                    table->test(hash.g) &&\n-                table->test(hash.h)) {\n-                if (txinit->prevout.IsNull()) {\n+    for (auto txit =  block.vtx.cbegin(); txit != block.vtx.cend(); ++txit) {\n+        const auto& tx = **txit;\n+        for (auto txinit =  tx.vin.cbegin(); txinit != tx.vin.cend(); ++txinit) {\n+            const COutPoint& prevout = txinit->prevout;\n+            const auto hash = hasher(prevout);\n+            if (    !table[hash.a] || !table[hash.b] ||\n+                    !table[hash.c] || !table[hash.d] ||\n+                    !table[hash.e] || !table[hash.f] ||\n+                    !table[hash.g] || !table[hash.h]){\n+                table[hash.a] = true;\n+                table[hash.b] = true;\n+                table[hash.c] = true;\n+                table[hash.d] = true;\n+                table[hash.e] = true;\n+                table[hash.f] = true;\n+                table[hash.g] = true;\n+                table[hash.h] = true;\n+            } else {\n+                if (prevout.IsNull()) {\n                     return state.DoS(10, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n                 }\n-                // If we have a potential collision, perform expensive check\n-                for (const auto& tx2 : block.vtx) {\n-                    for (auto txinit2 =  tx2->vin.cbegin(); txinit2 != tx2->vin.cend(); ++txinit2) {\n-                        if (txinit2 != txinit && txinit2->prevout == txinit->prevout)\n-                            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n+                // If we have a potential collision, perform expensive check over\n+                // all prior transactions, starting with the current txn\n+                {\n+                    // Check current transaction up to the input txinit\n+                    auto elem = std::find_if(tx.vin.begin(), txinit,\n+                            [&](const CTxIn& x){return x.prevout == prevout;});\n+                    // If the iterator outputs anything except for txinit, then we have found a conflict\n+                    if  (elem != txinit) {\n+                        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n                     }\n-\n                 }\n-            } else {\n-                hash.set(*table);\n+                // Check prior transaction's inputs for conflict\n+                for (auto txit2 =  block.vtx.cbegin(); txit2 != txit; ++txit2) {\n+                    const auto& tx2 = **txit2;\n+                    auto elem = std::find_if(tx2.vin.cbegin(), tx2.vin.cend(),\n+                            [&](const CTxIn& x){return x.prevout == prevout;});\n+                    if (elem != tx2.vin.cend())\n+                        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n+                }\n+\n             }\n         }\n     }"
      }
    ]
  },
  {
    "sha": "1f2477364d20cce37249f06a99424169a2326780",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxZjI0NzczNjRkMjBjY2UzNzI0OWYwNmE5OTQyNDE2OWEyMzI2Nzgw",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2018-10-06T01:11:40Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2018-10-06T01:11:40Z"
      },
      "message": "Small clean up of comment & code layout for Duplicate Input checking",
      "tree": {
        "sha": "c3797d01a4867ce9599e65a6a10c36d458aa9b7f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c3797d01a4867ce9599e65a6a10c36d458aa9b7f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1f2477364d20cce37249f06a99424169a2326780",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1f2477364d20cce37249f06a99424169a2326780",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1f2477364d20cce37249f06a99424169a2326780",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1f2477364d20cce37249f06a99424169a2326780/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c176a9c2c5e686eadbfb64feddcc980c52dcf050",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c176a9c2c5e686eadbfb64feddcc980c52dcf050",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c176a9c2c5e686eadbfb64feddcc980c52dcf050"
      }
    ],
    "stats": {
      "total": 77,
      "additions": 36,
      "deletions": 41
    },
    "files": [
      {
        "sha": "1bc3d0d7280864bb0ff7ea96c2a6c6983f9323a2",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 41,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f2477364d20cce37249f06a99424169a2326780/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f2477364d20cce37249f06a99424169a2326780/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=1f2477364d20cce37249f06a99424169a2326780",
        "patch": "@@ -3123,35 +3123,34 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n     // Check transactions for duplicate inputs\n     //\n \n-    // This duplication checking algorithm uses a probabilistic filter\n-    // to check for collisions efficiently.\n+    // This duplication checking algorithm uses a probabilistic filter to check\n+    // for collisions efficiently.\n     //\n-    // This is faster than the naive construction, using a set, which\n-    // requires more allocation and comparison of uint256s.\n+    // This is faster than the naive construction, using a set, which requires\n+    // more allocation and comparison of uint256s.\n     //\n-    // First we create a bitset table with 1<<21 elements. This\n-    // is around 300 KB, so we construct it on the heap.\n+    // First we create a bitset table with 1<<21 elements. This is around 300\n+    // KB, so we construct it on the heap.\n     //\n-    // We also allow reusing a 'dirty' table because zeroing 300 KB\n-    // can be expensive, and the table will operate acceptably for all of the\n+    // We also allow reusing a 'dirty' table because zeroing 300 KB can be\n+    // expensive, and the table will operate acceptably for all of the\n     // transactions in a given block.\n     //\n     // Then, we iterate through the elements one by one, generated 8 salted\n     // 21-bit hashes (which can be quickly generated using siphash) based on\n     // each prevout.\n     //\n-    // We then check if all 8 hashes are set in the table yet. If they are,\n-    // we do a linear scan through the inputs to see if it was a true\n-    // collision, and reject the txn.\n+    // We then check if all 8 hashes are set in the table yet. If they are, we\n+    // do a linear scan through the inputs to see if it was a true collision,\n+    // and reject the txn.\n     //\n-    // Otherwise, we set the 8 bits corresponding to the hashes and\n-    // continue.\n+    // Otherwise, we set the 8 bits corresponding to the hashes and continue.\n     //\n-    // From the perspective of the N+1st prevout, assuming the transaction\n-    // does not double spend:\n+    // From the perspective of the N+1st prevout, assuming the transaction does\n+    // not double spend:\n     //\n-    // Up to N*8 hashes have been set in the table already (potentially\n-    // fewer if collisions)\n+    // Up to N*8 hashes have been set in the table already (potentially fewer if\n+    // collisions)\n     //\n     // For each of the 8 hashes h_1...h_8, P(bit set in table for h_i) =\n     // (N*8)/1<<21\n@@ -3170,16 +3169,15 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n     // Based on an input being at least 41 bytes, and a block being 1M bytes\n     // max, there are a maximum of 24390 inputs, so M = 24390\n     //\n-    // The total expected number of direct comparisons for M=24930 is\n-    // therefore 0.33 with this algorithm.\n+    // The total expected number of direct comparisons for M=24930 is therefore\n+    // 0.33 with this algorithm.\n     //\n-    // As a bonus, we also get \"free\" null checking by manually inserting\n-    // the null element into the table so it always generates a conflict\n-    // check. We remove this null-check before terminating so that we avoid\n-    // doubling the bloat on the table.\n+    // Note that the first element checked is the coinbase transaction, whose\n+    // input is null. Therefore, any subsequent null input would be a collision\n+    // with that null, enabling us to not null check every subsequent entry.\n     //\n-    // If a dirty table is used, the algorithms worst-case\n-    // runtime is still better because of three key reasons:\n+    // If a dirty table is used, the algorithms worst-case runtime is still\n+    // better because of three key reasons:\n     //\n     // 1) the linear searches complexity is limited to each transaction's\n     // subset of inputs\n@@ -3188,16 +3186,16 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n     // 3) less initialization of the table\n     //\n     //\n-    // The worst case for this algorithm from a denial of service\n-    // perspective with an invalid transaction would be to do a transaction\n-    // where the last two elements are a collision. In this case, the scan\n-    // would require to scan all N elements.\n+    // The worst case for this algorithm from a denial of service perspective\n+    // with an invalid transaction would be to do a transaction where the last\n+    // two elements are a collision. In this case, the scan would require to\n+    // scan all N elements.\n     //\n     //\n     //\n-    // N.B. When the table is dirty, the bits set in the table\n-    // are meaningless because the hash was salted separately.\n-    //\n+    // N.B. When the table is dirty, the bits set in the table are meaningless\n+    // because the hash was salted separately.\n+\n     struct pos {\n         uint64_t a : 21;\n         uint64_t b : 21;\n@@ -3211,24 +3209,21 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n         uint64_t h : 21;\n         uint64_t unused : 22;\n     };\n-    union convert {\n-        uint64_t ph[3];\n-        pos p;\n-    };\n \n     uint64_t k1 = GetRand(std::numeric_limits<uint64_t>::max());\n     uint64_t k2 = GetRand(std::numeric_limits<uint64_t>::max());\n     auto hasher = [k1, k2](const COutPoint& out){\n+        union convert {\n+            uint64_t ph[3];\n+            pos p;\n+        };\n         auto h = SipHashUint256Extra192(k1, k2, out.hash, out.n);\n         convert v = {std::get<0>(h), std::get<1>(h), std::get<2>(h)};\n         return v.p;\n     };\n \n     std::unique_ptr<std::bitset<1<<21>> pTable = MakeUnique<std::bitset<1<<21>>();\n     auto& table = *pTable.get();\n-    // Note that the first one tested is the coinbase transaction, whose input\n-    // is null. Therefore, any subsequent null input would be a collision with\n-    // that null, enabling us to not null check\n     for (auto txit =  block.vtx.cbegin(); txit != block.vtx.cend(); ++txit) {\n         const auto& tx = **txit;\n         for (auto txinit =  tx.vin.cbegin(); txinit != tx.vin.cend(); ++txinit) {\n@@ -3266,10 +3261,10 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n                     const auto& tx2 = **txit2;\n                     auto elem = std::find_if(tx2.vin.cbegin(), tx2.vin.cend(),\n                             [&](const CTxIn& x){return x.prevout == prevout;});\n-                    if (elem != tx2.vin.cend())\n+                    if (elem != tx2.vin.cend()) {\n                         return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n+                    }\n                 }\n-\n             }\n         }\n     }"
      }
    ]
  }
]