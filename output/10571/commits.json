[
  {
    "sha": "6b4f231f5f0f88690488c4da20ea1c180dbc4b19",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2YjRmMjMxZjVmMGY4ODY5MDQ4OGM0ZGEyMGVhMWMxODBkYmM0YjE5",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2017-06-10T05:38:06Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2017-07-18T17:59:06Z"
      },
      "message": "Move transaction combining from signrawtransaction to new RPC\n\nCreate a combinerawtransaction RPC which accepts a json array of hex raw\ntransactions to combine them into one transaction. Signrawtransaction is changed\nto no longer combine transactions and only accept one transaction at a time.",
      "tree": {
        "sha": "ed832262304d91d4c0c2941d53cf410a58d2da67",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ed832262304d91d4c0c2941d53cf410a58d2da67"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6b4f231f5f0f88690488c4da20ea1c180dbc4b19",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6b4f231f5f0f88690488c4da20ea1c180dbc4b19",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6b4f231f5f0f88690488c4da20ea1c180dbc4b19",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6b4f231f5f0f88690488c4da20ea1c180dbc4b19/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0b019357ff09e7a522307fc271d6b60562a7b890",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0b019357ff09e7a522307fc271d6b60562a7b890",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0b019357ff09e7a522307fc271d6b60562a7b890"
      }
    ],
    "stats": {
      "total": 209,
      "additions": 154,
      "deletions": 55
    },
    "files": [
      {
        "sha": "d82e85f825d75097a492b7da770a9cbbb3e1ed3b",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b4f231f5f0f88690488c4da20ea1c180dbc4b19/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b4f231f5f0f88690488c4da20ea1c180dbc4b19/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=6b4f231f5f0f88690488c4da20ea1c180dbc4b19",
        "patch": "@@ -95,6 +95,7 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"signrawtransaction\", 1, \"prevtxs\" },\n     { \"signrawtransaction\", 2, \"privkeys\" },\n     { \"sendrawtransaction\", 1, \"allowhighfees\" },\n+    { \"combinerawtransaction\", 0, \"txs\" },\n     { \"fundrawtransaction\", 1, \"options\" },\n     { \"gettxout\", 1, \"n\" },\n     { \"gettxout\", 2, \"include_mempool\" },"
      },
      {
        "sha": "10886fea9feaba52d6367051dc8ed9c33751301e",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 100,
        "deletions": 35,
        "changes": 135,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b4f231f5f0f88690488c4da20ea1c180dbc4b19/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b4f231f5f0f88690488c4da20ea1c180dbc4b19/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=6b4f231f5f0f88690488c4da20ea1c180dbc4b19",
        "patch": "@@ -554,6 +554,93 @@ static void TxInErrorToJSON(const CTxIn& txin, UniValue& vErrorsRet, const std::\n     vErrorsRet.push_back(entry);\n }\n \n+UniValue combinerawtransaction(const JSONRPCRequest& request)\n+{\n+\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinerawtransaction [\\\"hexstring\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed transactions into one transaction.\\n\"\n+            \"The combined transaction may be another partially signed transaction or a \\n\"\n+            \"fully signed transaction.\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"         (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"hexstring\\\"     (string) A transaction hash\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"\\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded raw transaction with signature(s)\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinerawtransaction\", \"[\\\"myhex1\\\", \\\"myhex2\\\", \\\"myhex3\\\"]\")\n+        );\n+\n+\n+    UniValue txs = request.params[0].get_array();\n+    std::vector<CMutableTransaction> txVariants(txs.size());\n+\n+    for (unsigned int idx = 0; idx < txs.size(); idx++) {\n+        if (!DecodeHexTx(txVariants[idx], txs[idx].get_str(), true)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed for tx %d\", idx));\n+        }\n+    }\n+\n+    if (txVariants.empty()) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Missing transactions\");\n+    }\n+\n+    // mergedTx will end up with all the signatures; it\n+    // starts as a clone of the rawtx:\n+    CMutableTransaction mergedTx(txVariants[0]);\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK(cs_main);\n+        LOCK(mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : mergedTx.vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Use CTransaction for the constant parts of the\n+    // transaction to avoid rehashing.\n+    const CTransaction txConst(mergedTx);\n+    // Sign what we can:\n+    for (unsigned int i = 0; i < mergedTx.vin.size(); i++) {\n+        CTxIn& txin = mergedTx.vin[i];\n+        const Coin& coin = view.AccessCoin(txin.prevout);\n+        if (coin.IsSpent()) {\n+            throw JSONRPCError(RPC_VERIFY_ERROR, \"Input not found or already spent\");\n+        }\n+        const CScript& prevPubKey = coin.out.scriptPubKey;\n+        const CAmount& amount = coin.out.nValue;\n+\n+        SignatureData sigdata;\n+\n+        // ... and merge in other signatures:\n+        for (const CMutableTransaction& txv : txVariants) {\n+            if (txv.vin.size() > i) {\n+                sigdata = CombineSignatures(prevPubKey, TransactionSignatureChecker(&txConst, i, amount), sigdata, DataFromTransaction(txv, i));\n+            }\n+        }\n+\n+        UpdateTransaction(mergedTx, i, sigdata);\n+    }\n+\n+    return EncodeHexTx(mergedTx);\n+}\n+\n UniValue signrawtransaction(const JSONRPCRequest& request)\n {\n #ifdef ENABLE_WALLET\n@@ -626,26 +713,9 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n #endif\n     RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR, UniValue::VARR, UniValue::VSTR}, true);\n \n-    std::vector<unsigned char> txData(ParseHexV(request.params[0], \"argument 1\"));\n-    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n-    std::vector<CMutableTransaction> txVariants;\n-    while (!ssData.empty()) {\n-        try {\n-            CMutableTransaction tx;\n-            ssData >> tx;\n-            txVariants.push_back(tx);\n-        }\n-        catch (const std::exception&) {\n-            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n-        }\n-    }\n-\n-    if (txVariants.empty())\n-        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Missing transaction\");\n-\n-    // mergedTx will end up with all the signatures; it\n-    // starts as a clone of the rawtx:\n-    CMutableTransaction mergedTx(txVariants[0]);\n+    CMutableTransaction mtx;\n+    if (!DecodeHexTx(mtx, request.params[0].get_str(), true))\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n \n     // Fetch previous transactions (inputs):\n     CCoinsView viewDummy;\n@@ -656,7 +726,7 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n         CCoinsViewMemPool viewMempool(&viewChain, mempool);\n         view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n \n-        for (const CTxIn& txin : mergedTx.vin) {\n+        for (const CTxIn& txin : mtx.vin) {\n             view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n         }\n \n@@ -781,10 +851,10 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n \n     // Use CTransaction for the constant parts of the\n     // transaction to avoid rehashing.\n-    const CTransaction txConst(mergedTx);\n+    const CTransaction txConst(mtx);\n     // Sign what we can:\n-    for (unsigned int i = 0; i < mergedTx.vin.size(); i++) {\n-        CTxIn& txin = mergedTx.vin[i];\n+    for (unsigned int i = 0; i < mtx.vin.size(); i++) {\n+        CTxIn& txin = mtx.vin[i];\n         const Coin& coin = view.AccessCoin(txin.prevout);\n         if (coin.IsSpent()) {\n             TxInErrorToJSON(txin, vErrors, \"Input not found or already spent\");\n@@ -795,17 +865,11 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n \n         SignatureData sigdata;\n         // Only sign SIGHASH_SINGLE if there's a corresponding output:\n-        if (!fHashSingle || (i < mergedTx.vout.size()))\n-            ProduceSignature(MutableTransactionSignatureCreator(&keystore, &mergedTx, i, amount, nHashType), prevPubKey, sigdata);\n+        if (!fHashSingle || (i < mtx.vout.size()))\n+            ProduceSignature(MutableTransactionSignatureCreator(&keystore, &mtx, i, amount, nHashType), prevPubKey, sigdata);\n+        sigdata = CombineSignatures(prevPubKey, TransactionSignatureChecker(&txConst, i, amount), sigdata, DataFromTransaction(mtx, i));\n \n-        // ... and merge in other signatures:\n-        for (const CMutableTransaction& txv : txVariants) {\n-            if (txv.vin.size() > i) {\n-                sigdata = CombineSignatures(prevPubKey, TransactionSignatureChecker(&txConst, i, amount), sigdata, DataFromTransaction(txv, i));\n-            }\n-        }\n-\n-        UpdateTransaction(mergedTx, i, sigdata);\n+        UpdateTransaction(mtx, i, sigdata);\n \n         ScriptError serror = SCRIPT_ERR_OK;\n         if (!VerifyScript(txin.scriptSig, prevPubKey, &txin.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, TransactionSignatureChecker(&txConst, i, amount), &serror)) {\n@@ -815,7 +879,7 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n     bool fComplete = vErrors.empty();\n \n     UniValue result(UniValue::VOBJ);\n-    result.push_back(Pair(\"hex\", EncodeHexTx(mergedTx)));\n+    result.push_back(Pair(\"hex\", EncodeHexTx(mtx)));\n     result.push_back(Pair(\"complete\", fComplete));\n     if (!vErrors.empty()) {\n         result.push_back(Pair(\"errors\", vErrors));\n@@ -905,6 +969,7 @@ static const CRPCCommand commands[] =\n     { \"rawtransactions\",    \"decoderawtransaction\",   &decoderawtransaction,   true,  {\"hexstring\"} },\n     { \"rawtransactions\",    \"decodescript\",           &decodescript,           true,  {\"hexstring\"} },\n     { \"rawtransactions\",    \"sendrawtransaction\",     &sendrawtransaction,     false, {\"hexstring\",\"allowhighfees\"} },\n+    { \"rawtransactions\",    \"combinerawtransaction\",  &combinerawtransaction,  true,  {\"txs\"} },\n     { \"rawtransactions\",    \"signrawtransaction\",     &signrawtransaction,     false, {\"hexstring\",\"prevtxs\",\"privkeys\",\"sighashtype\"} }, /* uses wallet if enabled */\n \n     { \"blockchain\",         \"gettxoutproof\",          &gettxoutproof,          true,  {\"txids\", \"blockhash\"} },"
      },
      {
        "sha": "6272fc69b783cdfda19e2b0b65bf56ea493260f3",
        "filename": "test/functional/rawtransactions.py",
        "status": "modified",
        "additions": 53,
        "deletions": 4,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b4f231f5f0f88690488c4da20ea1c180dbc4b19/test/functional/rawtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b4f231f5f0f88690488c4da20ea1c180dbc4b19/test/functional/rawtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rawtransactions.py?ref=6b4f231f5f0f88690488c4da20ea1c180dbc4b19",
        "patch": "@@ -114,7 +114,7 @@ def run_test(self):\n         rawTx = self.nodes[2].createrawtransaction(inputs, outputs)\n         rawTxPartialSigned = self.nodes[1].signrawtransaction(rawTx, inputs)\n         assert_equal(rawTxPartialSigned['complete'], False) #node1 only has one key, can't comp. sign the tx\n-        \n+\n         rawTxSigned = self.nodes[2].signrawtransaction(rawTx, inputs)\n         assert_equal(rawTxSigned['complete'], True) #node2 can sign the tx compl., own two of three keys\n         self.nodes[2].sendrawtransaction(rawTxSigned['hex'])\n@@ -124,6 +124,55 @@ def run_test(self):\n         self.sync_all()\n         assert_equal(self.nodes[0].getbalance(), bal+Decimal('50.00000000')+Decimal('2.19000000')) #block reward + tx\n \n+        # 2of2 test for combining transactions\n+        bal = self.nodes[2].getbalance()\n+        addr1 = self.nodes[1].getnewaddress()\n+        addr2 = self.nodes[2].getnewaddress()\n+\n+        addr1Obj = self.nodes[1].validateaddress(addr1)\n+        addr2Obj = self.nodes[2].validateaddress(addr2)\n+\n+        self.nodes[1].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey']])\n+        mSigObj = self.nodes[2].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey']])\n+        mSigObjValid = self.nodes[2].validateaddress(mSigObj)\n+\n+        txId = self.nodes[0].sendtoaddress(mSigObj, 2.2)\n+        decTx = self.nodes[0].gettransaction(txId)\n+        rawTx2 = self.nodes[0].decoderawtransaction(decTx['hex'])\n+        self.sync_all()\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        assert_equal(self.nodes[2].getbalance(), bal) # the funds of a 2of2 multisig tx should not be marked as spendable\n+\n+        txDetails = self.nodes[0].gettransaction(txId, True)\n+        rawTx2 = self.nodes[0].decoderawtransaction(txDetails['hex'])\n+        vout = False\n+        for outpoint in rawTx2['vout']:\n+            if outpoint['value'] == Decimal('2.20000000'):\n+                vout = outpoint\n+                break\n+\n+        bal = self.nodes[0].getbalance()\n+        inputs = [{ \"txid\" : txId, \"vout\" : vout['n'], \"scriptPubKey\" : vout['scriptPubKey']['hex'], \"redeemScript\" : mSigObjValid['hex']}]\n+        outputs = { self.nodes[0].getnewaddress() : 2.19 }\n+        rawTx2 = self.nodes[2].createrawtransaction(inputs, outputs)\n+        rawTxPartialSigned1 = self.nodes[1].signrawtransaction(rawTx2, inputs)\n+        self.log.info(rawTxPartialSigned1)\n+        assert_equal(rawTxPartialSigned['complete'], False) #node1 only has one key, can't comp. sign the tx\n+\n+        rawTxPartialSigned2 = self.nodes[2].signrawtransaction(rawTx2, inputs)\n+        self.log.info(rawTxPartialSigned2)\n+        assert_equal(rawTxPartialSigned2['complete'], False) #node2 only has one key, can't comp. sign the tx\n+        rawTxComb = self.nodes[2].combinerawtransaction([rawTxPartialSigned1['hex'], rawTxPartialSigned2['hex']])\n+        self.log.info(rawTxComb)\n+        self.nodes[2].sendrawtransaction(rawTxComb)\n+        rawTx2 = self.nodes[0].decoderawtransaction(rawTxComb)\n+        self.sync_all()\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+        assert_equal(self.nodes[0].getbalance(), bal+Decimal('50.00000000')+Decimal('2.19000000')) #block reward + tx\n+\n         # getrawtransaction tests\n         # 1. valid parameters - only supply txid\n         txHash = rawTx[\"hash\"]\n@@ -156,17 +205,17 @@ def run_test(self):\n         rawtx   = self.nodes[0].createrawtransaction(inputs, outputs)\n         decrawtx= self.nodes[0].decoderawtransaction(rawtx)\n         assert_equal(decrawtx['vin'][0]['sequence'], 1000)\n-        \n+\n         # 9. invalid parameters - sequence number out of range\n         inputs  = [ {'txid' : \"1d1d4e24ed99057e84c3f80fd8fbec79ed9e1acee37da269356ecea000000000\", 'vout' : 1, 'sequence' : -1}]\n         outputs = { self.nodes[0].getnewaddress() : 1 }\n         assert_raises_jsonrpc(-8, 'Invalid parameter, sequence number is out of range', self.nodes[0].createrawtransaction, inputs, outputs)\n-        \n+\n         # 10. invalid parameters - sequence number out of range\n         inputs  = [ {'txid' : \"1d1d4e24ed99057e84c3f80fd8fbec79ed9e1acee37da269356ecea000000000\", 'vout' : 1, 'sequence' : 4294967296}]\n         outputs = { self.nodes[0].getnewaddress() : 1 }\n         assert_raises_jsonrpc(-8, 'Invalid parameter, sequence number is out of range', self.nodes[0].createrawtransaction, inputs, outputs)\n-        \n+\n         inputs  = [ {'txid' : \"1d1d4e24ed99057e84c3f80fd8fbec79ed9e1acee37da269356ecea000000000\", 'vout' : 1, 'sequence' : 4294967294}]\n         outputs = { self.nodes[0].getnewaddress() : 1 }\n         rawtx   = self.nodes[0].createrawtransaction(inputs, outputs)"
      },
      {
        "sha": "415727268a30ab4b680ff90dba20c788ab556262",
        "filename": "test/functional/signrawtransactions.py",
        "status": "modified",
        "additions": 0,
        "deletions": 16,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b4f231f5f0f88690488c4da20ea1c180dbc4b19/test/functional/signrawtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b4f231f5f0f88690488c4da20ea1c180dbc4b19/test/functional/signrawtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/signrawtransactions.py?ref=6b4f231f5f0f88690488c4da20ea1c180dbc4b19",
        "patch": "@@ -43,22 +43,6 @@ def successful_signing_test(self):\n         # 2) No script verification error occurred\n         assert 'errors' not in rawTxSigned\n \n-        # Check that signrawtransaction doesn't blow up on garbage merge attempts\n-        dummyTxInconsistent = self.nodes[0].createrawtransaction([inputs[0]], outputs)\n-        rawTxUnsigned = self.nodes[0].signrawtransaction(rawTx + dummyTxInconsistent, inputs)\n-\n-        assert 'complete' in rawTxUnsigned\n-        assert_equal(rawTxUnsigned['complete'], False)\n-\n-        # Check that signrawtransaction properly merges unsigned and signed txn, even with garbage in the middle\n-        rawTxSigned2 = self.nodes[0].signrawtransaction(rawTxUnsigned[\"hex\"] + dummyTxInconsistent + rawTxSigned[\"hex\"], inputs)\n-\n-        assert 'complete' in rawTxSigned2\n-        assert_equal(rawTxSigned2['complete'], True)\n-\n-        assert 'errors' not in rawTxSigned2\n-\n-\n     def script_verification_error_test(self):\n         \"\"\"Create and sign a raw transaction with valid (vin 0), invalid (vin 1) and one missing (vin 2) input script.\n "
      }
    ]
  }
]