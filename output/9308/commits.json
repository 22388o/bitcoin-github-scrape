[
  {
    "sha": "07df40babb0231b2e8a2f42341805b4bbcc4e284",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowN2RmNDBiYWJiMDIzMWIyZThhMmY0MjM0MTgwNWI0YmJjYzRlMjg0",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2016-12-05T23:30:46Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2016-12-05T23:30:46Z"
      },
      "message": "[test] Add CCoinsViewCache Access/Modify/Write tests\n\nAdd more comprehensive unit tests for CCoinsViewCache. Right now it is hard to\nrefactor caching code or fix bugs in the caching logic because you have to try\nto mentally enumerate all the different states the cache might be in to make\nsure a change doesn't cause unintended consequences. The new tests explicitly\nenumerate relevant cache states, documenting and verifying the behavior in each\nstate, so it will be safer and easier to make changes to the caching code in\nthe future.",
      "tree": {
        "sha": "2d1afcf8a7eadc040c2728a6d11abc04883ca52c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2d1afcf8a7eadc040c2728a6d11abc04883ca52c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/07df40babb0231b2e8a2f42341805b4bbcc4e284",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/07df40babb0231b2e8a2f42341805b4bbcc4e284",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/07df40babb0231b2e8a2f42341805b4bbcc4e284",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/07df40babb0231b2e8a2f42341805b4bbcc4e284/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7f72568e6b15fc139323fb200591a50762f6df0b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7f72568e6b15fc139323fb200591a50762f6df0b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7f72568e6b15fc139323fb200591a50762f6df0b"
      }
    ],
    "stats": {
      "total": 364,
      "additions": 364,
      "deletions": 0
    },
    "files": [
      {
        "sha": "f0e74a55d24aab5f38756cae00365b94062ba122",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 364,
        "deletions": 0,
        "changes": 364,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/07df40babb0231b2e8a2f42341805b4bbcc4e284/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/07df40babb0231b2e8a2f42341805b4bbcc4e284/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=07df40babb0231b2e8a2f42341805b4bbcc4e284",
        "patch": "@@ -80,6 +80,8 @@ class CCoinsViewCacheTest : public CCoinsViewCache\n         BOOST_CHECK_EQUAL(DynamicMemoryUsage(), ret);\n     }\n \n+    CCoinsMap& map() { return cacheCoins; }\n+    size_t& usage() { return cachedCoinsUsage; }\n };\n \n }\n@@ -415,4 +417,366 @@ BOOST_AUTO_TEST_CASE(ccoins_serialization)\n     }\n }\n \n+const static uint256 TXID;\n+const static CAmount PRUNED = -1;\n+const static CAmount ABSENT = -2;\n+const static CAmount VALUE1 = 100;\n+const static CAmount VALUE2 = 200;\n+const static CAmount VALUE3 = 300;\n+const static char DIRTY = CCoinsCacheEntry::DIRTY;\n+const static char FRESH = CCoinsCacheEntry::FRESH;\n+const static char NO_ENTRY = -1;\n+\n+const static auto FLAGS = {char(0), FRESH, DIRTY, char(DIRTY | FRESH)};\n+const static auto CLEAN_FLAGS = {char(0), FRESH};\n+const static auto DIRTY_FLAGS = {DIRTY, char(DIRTY | FRESH)};\n+const static auto ABSENT_FLAGS = {NO_ENTRY};\n+\n+void SetCoinsValue(CAmount value, CCoins& coins)\n+{\n+    assert(value != ABSENT);\n+    coins.Clear();\n+    assert(coins.IsPruned());\n+    if (value != PRUNED) {\n+        coins.vout.emplace_back();\n+        coins.vout.back().nValue = value;\n+        assert(!coins.IsPruned());\n+    }\n+}\n+\n+size_t InsertCoinsMapEntry(CCoinsMap& map, CAmount value, char flags)\n+{\n+    if (value == ABSENT) {\n+        assert(flags == NO_ENTRY);\n+        return 0;\n+    }\n+    assert(flags != NO_ENTRY);\n+    CCoinsCacheEntry entry;\n+    entry.flags = flags;\n+    SetCoinsValue(value, entry.coins);\n+    auto inserted = map.emplace(TXID, std::move(entry));\n+    assert(inserted.second);\n+    return inserted.first->second.coins.DynamicMemoryUsage();\n+}\n+\n+void GetCoinsMapEntry(const CCoinsMap& map, CAmount& value, char& flags)\n+{\n+    auto it = map.find(TXID);\n+    if (it == map.end()) {\n+        value = ABSENT;\n+        flags = NO_ENTRY;\n+    } else {\n+        if (it->second.coins.IsPruned()) {\n+            assert(it->second.coins.vout.size() == 0);\n+            value = PRUNED;\n+        } else {\n+            assert(it->second.coins.vout.size() == 1);\n+            value = it->second.coins.vout[0].nValue;\n+        }\n+        flags = it->second.flags;\n+        assert(flags != NO_ENTRY);\n+    }\n+}\n+\n+void WriteCoinsViewEntry(CCoinsView& view, CAmount value, char flags)\n+{\n+    CCoinsMap map;\n+    InsertCoinsMapEntry(map, value, flags);\n+    view.BatchWrite(map, {});\n+}\n+\n+class SingleEntryCacheTest\n+{\n+public:\n+    SingleEntryCacheTest(CAmount base_value, CAmount cache_value, char cache_flags)\n+    {\n+        WriteCoinsViewEntry(base, base_value, base_value == ABSENT ? NO_ENTRY : DIRTY);\n+        cache.usage() += InsertCoinsMapEntry(cache.map(), cache_value, cache_flags);\n+    }\n+\n+    CCoinsView root;\n+    CCoinsViewCacheTest base{&root};\n+    CCoinsViewCacheTest cache{&base};\n+};\n+\n+void CheckAccessCoins(CAmount base_value, CAmount cache_value, CAmount expected_value, char cache_flags, char expected_flags)\n+{\n+    SingleEntryCacheTest test(base_value, cache_value, cache_flags);\n+    test.cache.AccessCoins(TXID);\n+    test.cache.SelfTest();\n+\n+    CAmount result_value;\n+    char result_flags;\n+    GetCoinsMapEntry(test.cache.map(), result_value, result_flags);\n+    BOOST_CHECK_EQUAL(result_value, expected_value);\n+    BOOST_CHECK_EQUAL(result_flags, expected_flags);\n+}\n+\n+BOOST_AUTO_TEST_CASE(ccoins_access)\n+{\n+    /* Check AccessCoin behavior, requesting a coin from a cache view layered on\n+     * top of a base view, and checking the resulting entry in the cache after\n+     * the access.\n+     *\n+     *               Base    Cache   Result  Cache        Result\n+     *               Value   Value   Value   Flags        Flags\n+     */\n+    CheckAccessCoins(ABSENT, ABSENT, ABSENT, NO_ENTRY   , NO_ENTRY   );\n+    CheckAccessCoins(ABSENT, PRUNED, PRUNED, 0          , 0          );\n+    CheckAccessCoins(ABSENT, PRUNED, PRUNED, FRESH      , FRESH      );\n+    CheckAccessCoins(ABSENT, PRUNED, PRUNED, DIRTY      , DIRTY      );\n+    CheckAccessCoins(ABSENT, PRUNED, PRUNED, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckAccessCoins(ABSENT, VALUE2, VALUE2, 0          , 0          );\n+    CheckAccessCoins(ABSENT, VALUE2, VALUE2, FRESH      , FRESH      );\n+    CheckAccessCoins(ABSENT, VALUE2, VALUE2, DIRTY      , DIRTY      );\n+    CheckAccessCoins(ABSENT, VALUE2, VALUE2, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckAccessCoins(PRUNED, ABSENT, PRUNED, NO_ENTRY   , FRESH      );\n+    CheckAccessCoins(PRUNED, PRUNED, PRUNED, 0          , 0          );\n+    CheckAccessCoins(PRUNED, PRUNED, PRUNED, FRESH      , FRESH      );\n+    CheckAccessCoins(PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      );\n+    CheckAccessCoins(PRUNED, PRUNED, PRUNED, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckAccessCoins(PRUNED, VALUE2, VALUE2, 0          , 0          );\n+    CheckAccessCoins(PRUNED, VALUE2, VALUE2, FRESH      , FRESH      );\n+    CheckAccessCoins(PRUNED, VALUE2, VALUE2, DIRTY      , DIRTY      );\n+    CheckAccessCoins(PRUNED, VALUE2, VALUE2, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckAccessCoins(VALUE1, ABSENT, VALUE1, NO_ENTRY   , 0          );\n+    CheckAccessCoins(VALUE1, PRUNED, PRUNED, 0          , 0          );\n+    CheckAccessCoins(VALUE1, PRUNED, PRUNED, FRESH      , FRESH      );\n+    CheckAccessCoins(VALUE1, PRUNED, PRUNED, DIRTY      , DIRTY      );\n+    CheckAccessCoins(VALUE1, PRUNED, PRUNED, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckAccessCoins(VALUE1, VALUE2, VALUE2, 0          , 0          );\n+    CheckAccessCoins(VALUE1, VALUE2, VALUE2, FRESH      , FRESH      );\n+    CheckAccessCoins(VALUE1, VALUE2, VALUE2, DIRTY      , DIRTY      );\n+    CheckAccessCoins(VALUE1, VALUE2, VALUE2, DIRTY|FRESH, DIRTY|FRESH);\n+}\n+\n+void CheckModifyCoins(CAmount base_value, CAmount cache_value, CAmount modify_value, CAmount expected_value, char cache_flags, char expected_flags)\n+{\n+    SingleEntryCacheTest test(base_value, cache_value, cache_flags);\n+    SetCoinsValue(modify_value, *test.cache.ModifyCoins(TXID));\n+    test.cache.SelfTest();\n+\n+    CAmount result_value;\n+    char result_flags;\n+    GetCoinsMapEntry(test.cache.map(), result_value, result_flags);\n+    BOOST_CHECK_EQUAL(result_value, expected_value);\n+    BOOST_CHECK_EQUAL(result_flags, expected_flags);\n+};\n+\n+BOOST_AUTO_TEST_CASE(ccoins_modify)\n+{\n+    /* Check ModifyCoin behavior, requesting a coin from a cache view layered on\n+     * top of a base view, writing a modification to the coin, and then checking\n+     * the resulting entry in the cache after the modification.\n+     *\n+     *               Base    Cache   Write   Result  Cache        Result\n+     *               Value   Value   Value   Value   Flags        Flags\n+     */\n+    CheckModifyCoins(ABSENT, ABSENT, PRUNED, ABSENT, NO_ENTRY   , NO_ENTRY   );\n+    CheckModifyCoins(ABSENT, ABSENT, VALUE3, VALUE3, NO_ENTRY   , DIRTY|FRESH);\n+    CheckModifyCoins(ABSENT, PRUNED, PRUNED, PRUNED, 0          , DIRTY      );\n+    CheckModifyCoins(ABSENT, PRUNED, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n+    CheckModifyCoins(ABSENT, PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      );\n+    CheckModifyCoins(ABSENT, PRUNED, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n+    CheckModifyCoins(ABSENT, PRUNED, VALUE3, VALUE3, 0          , DIRTY      );\n+    CheckModifyCoins(ABSENT, PRUNED, VALUE3, VALUE3, FRESH      , DIRTY|FRESH);\n+    CheckModifyCoins(ABSENT, PRUNED, VALUE3, VALUE3, DIRTY      , DIRTY      );\n+    CheckModifyCoins(ABSENT, PRUNED, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckModifyCoins(ABSENT, VALUE2, PRUNED, PRUNED, 0          , DIRTY      );\n+    CheckModifyCoins(ABSENT, VALUE2, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n+    CheckModifyCoins(ABSENT, VALUE2, PRUNED, PRUNED, DIRTY      , DIRTY      );\n+    CheckModifyCoins(ABSENT, VALUE2, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n+    CheckModifyCoins(ABSENT, VALUE2, VALUE3, VALUE3, 0          , DIRTY      );\n+    CheckModifyCoins(ABSENT, VALUE2, VALUE3, VALUE3, FRESH      , DIRTY|FRESH);\n+    CheckModifyCoins(ABSENT, VALUE2, VALUE3, VALUE3, DIRTY      , DIRTY      );\n+    CheckModifyCoins(ABSENT, VALUE2, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckModifyCoins(PRUNED, ABSENT, PRUNED, ABSENT, NO_ENTRY   , NO_ENTRY   );\n+    CheckModifyCoins(PRUNED, ABSENT, VALUE3, VALUE3, NO_ENTRY   , DIRTY|FRESH);\n+    CheckModifyCoins(PRUNED, PRUNED, PRUNED, PRUNED, 0          , DIRTY      );\n+    CheckModifyCoins(PRUNED, PRUNED, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n+    CheckModifyCoins(PRUNED, PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      );\n+    CheckModifyCoins(PRUNED, PRUNED, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n+    CheckModifyCoins(PRUNED, PRUNED, VALUE3, VALUE3, 0          , DIRTY      );\n+    CheckModifyCoins(PRUNED, PRUNED, VALUE3, VALUE3, FRESH      , DIRTY|FRESH);\n+    CheckModifyCoins(PRUNED, PRUNED, VALUE3, VALUE3, DIRTY      , DIRTY      );\n+    CheckModifyCoins(PRUNED, PRUNED, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckModifyCoins(PRUNED, VALUE2, PRUNED, PRUNED, 0          , DIRTY      );\n+    CheckModifyCoins(PRUNED, VALUE2, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n+    CheckModifyCoins(PRUNED, VALUE2, PRUNED, PRUNED, DIRTY      , DIRTY      );\n+    CheckModifyCoins(PRUNED, VALUE2, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n+    CheckModifyCoins(PRUNED, VALUE2, VALUE3, VALUE3, 0          , DIRTY      );\n+    CheckModifyCoins(PRUNED, VALUE2, VALUE3, VALUE3, FRESH      , DIRTY|FRESH);\n+    CheckModifyCoins(PRUNED, VALUE2, VALUE3, VALUE3, DIRTY      , DIRTY      );\n+    CheckModifyCoins(PRUNED, VALUE2, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckModifyCoins(VALUE1, ABSENT, PRUNED, PRUNED, NO_ENTRY   , DIRTY      );\n+    CheckModifyCoins(VALUE1, ABSENT, VALUE3, VALUE3, NO_ENTRY   , DIRTY      );\n+    CheckModifyCoins(VALUE1, PRUNED, PRUNED, PRUNED, 0          , DIRTY      );\n+    CheckModifyCoins(VALUE1, PRUNED, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n+    CheckModifyCoins(VALUE1, PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      );\n+    CheckModifyCoins(VALUE1, PRUNED, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n+    CheckModifyCoins(VALUE1, PRUNED, VALUE3, VALUE3, 0          , DIRTY      );\n+    CheckModifyCoins(VALUE1, PRUNED, VALUE3, VALUE3, FRESH      , DIRTY|FRESH);\n+    CheckModifyCoins(VALUE1, PRUNED, VALUE3, VALUE3, DIRTY      , DIRTY      );\n+    CheckModifyCoins(VALUE1, PRUNED, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckModifyCoins(VALUE1, VALUE2, PRUNED, PRUNED, 0          , DIRTY      );\n+    CheckModifyCoins(VALUE1, VALUE2, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n+    CheckModifyCoins(VALUE1, VALUE2, PRUNED, PRUNED, DIRTY      , DIRTY      );\n+    CheckModifyCoins(VALUE1, VALUE2, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n+    CheckModifyCoins(VALUE1, VALUE2, VALUE3, VALUE3, 0          , DIRTY      );\n+    CheckModifyCoins(VALUE1, VALUE2, VALUE3, VALUE3, FRESH      , DIRTY|FRESH);\n+    CheckModifyCoins(VALUE1, VALUE2, VALUE3, VALUE3, DIRTY      , DIRTY      );\n+    CheckModifyCoins(VALUE1, VALUE2, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH);\n+}\n+\n+void CheckModifyNewCoinsBase(CAmount base_value, CAmount cache_value, CAmount modify_value, CAmount expected_value, char cache_flags, char expected_flags, bool coinbase)\n+{\n+    SingleEntryCacheTest test(base_value, cache_value, cache_flags);\n+    SetCoinsValue(modify_value, *test.cache.ModifyNewCoins(TXID, coinbase));\n+\n+    CAmount result_value;\n+    char result_flags;\n+    GetCoinsMapEntry(test.cache.map(), result_value, result_flags);\n+    BOOST_CHECK_EQUAL(result_value, expected_value);\n+    BOOST_CHECK_EQUAL(result_flags, expected_flags);\n+}\n+\n+// Simple wrapper for CheckModifyNewCoinsBase function above that loops through\n+// different possible base_values, making sure each one gives the same results.\n+// This wrapper lets the modify_new test below be shorter and less repetitive,\n+// while still verifying that the CoinsViewCache::ModifyNewCoins implementation\n+// ignores base values.\n+template <typename... Args>\n+void CheckModifyNewCoins(Args&&... args)\n+{\n+    for (CAmount base_value : {ABSENT, PRUNED, VALUE1})\n+        CheckModifyNewCoinsBase(base_value, std::forward<Args>(args)...);\n+}\n+\n+BOOST_AUTO_TEST_CASE(ccoins_modify_new)\n+{\n+    /* Check ModifyNewCoin behavior, requesting a new coin from a cache view,\n+     * writing a modification to the coin, and then checking the resulting\n+     * entry in the cache after the modification. Verify behavior with the\n+     * with the ModifyNewCoin coinbase argument set to false, and to true.\n+     *\n+     *                  Cache   Write   Result  Cache        Result     Coinbase\n+     *                  Value   Value   Value   Flags        Flags\n+     */\n+    CheckModifyNewCoins(ABSENT, PRUNED, ABSENT, NO_ENTRY   , NO_ENTRY   , false);\n+    CheckModifyNewCoins(ABSENT, PRUNED, PRUNED, NO_ENTRY   , DIRTY      , true );\n+    CheckModifyNewCoins(ABSENT, VALUE3, VALUE3, NO_ENTRY   , DIRTY|FRESH, false);\n+    CheckModifyNewCoins(ABSENT, VALUE3, VALUE3, NO_ENTRY   , DIRTY      , true );\n+    CheckModifyNewCoins(PRUNED, PRUNED, ABSENT, 0          , NO_ENTRY   , false);\n+    CheckModifyNewCoins(PRUNED, PRUNED, PRUNED, 0          , DIRTY      , true );\n+    CheckModifyNewCoins(PRUNED, PRUNED, ABSENT, FRESH      , NO_ENTRY   , false);\n+    CheckModifyNewCoins(PRUNED, PRUNED, ABSENT, FRESH      , NO_ENTRY   , true );\n+    CheckModifyNewCoins(PRUNED, PRUNED, ABSENT, DIRTY      , NO_ENTRY   , false);\n+    CheckModifyNewCoins(PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      , true );\n+    CheckModifyNewCoins(PRUNED, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   , false);\n+    CheckModifyNewCoins(PRUNED, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   , true );\n+    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, 0          , DIRTY|FRESH, false);\n+    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, 0          , DIRTY      , true );\n+    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, FRESH      , DIRTY|FRESH, false);\n+    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, FRESH      , DIRTY|FRESH, true );\n+    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, DIRTY      , DIRTY|FRESH, false);\n+    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, DIRTY      , DIRTY      , true );\n+    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH, false);\n+    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH, true );\n+    CheckModifyNewCoins(VALUE2, PRUNED, ABSENT, 0          , NO_ENTRY   , false);\n+    CheckModifyNewCoins(VALUE2, PRUNED, PRUNED, 0          , DIRTY      , true );\n+    CheckModifyNewCoins(VALUE2, PRUNED, ABSENT, FRESH      , NO_ENTRY   , false);\n+    CheckModifyNewCoins(VALUE2, PRUNED, ABSENT, FRESH      , NO_ENTRY   , true );\n+    CheckModifyNewCoins(VALUE2, PRUNED, ABSENT, DIRTY      , NO_ENTRY   , false);\n+    CheckModifyNewCoins(VALUE2, PRUNED, PRUNED, DIRTY      , DIRTY      , true );\n+    CheckModifyNewCoins(VALUE2, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   , false);\n+    CheckModifyNewCoins(VALUE2, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   , true );\n+    CheckModifyNewCoins(VALUE2, VALUE3, VALUE3, 0          , DIRTY|FRESH, false);\n+    CheckModifyNewCoins(VALUE2, VALUE3, VALUE3, 0          , DIRTY      , true );\n+    CheckModifyNewCoins(VALUE2, VALUE3, VALUE3, FRESH      , DIRTY|FRESH, false);\n+    CheckModifyNewCoins(VALUE2, VALUE3, VALUE3, FRESH      , DIRTY|FRESH, true );\n+    CheckModifyNewCoins(VALUE2, VALUE3, VALUE3, DIRTY      , DIRTY|FRESH, false);\n+    CheckModifyNewCoins(VALUE2, VALUE3, VALUE3, DIRTY      , DIRTY      , true );\n+    CheckModifyNewCoins(VALUE2, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH, false);\n+    CheckModifyNewCoins(VALUE2, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH, true );\n+}\n+\n+void CheckWriteCoins(CAmount parent_value, CAmount child_value, CAmount expected_value, char parent_flags, char child_flags, char expected_flags)\n+{\n+    SingleEntryCacheTest test(ABSENT, parent_value, parent_flags);\n+    WriteCoinsViewEntry(test.cache, child_value, child_flags);\n+    test.cache.SelfTest();\n+\n+    CAmount result_value;\n+    char result_flags;\n+    GetCoinsMapEntry(test.cache.map(), result_value, result_flags);\n+    BOOST_CHECK_EQUAL(result_value, expected_value);\n+    BOOST_CHECK_EQUAL(result_flags, expected_flags);\n+}\n+\n+BOOST_AUTO_TEST_CASE(ccoins_write)\n+{\n+    /* Check BatchWrite behavior, flushing one entry from a child cache to a\n+     * parent cache, and checking the resulting entry in the parent cache\n+     * after the write.\n+     *\n+     *              Parent  Child   Result  Parent       Child        Result\n+     *              Value   Value   Value   Flags        Flags        Flags\n+     */\n+    CheckWriteCoins(ABSENT, ABSENT, ABSENT, NO_ENTRY   , NO_ENTRY   , NO_ENTRY   );\n+    CheckWriteCoins(ABSENT, PRUNED, PRUNED, NO_ENTRY   , DIRTY      , DIRTY      );\n+    CheckWriteCoins(ABSENT, PRUNED, ABSENT, NO_ENTRY   , DIRTY|FRESH, NO_ENTRY   );\n+    CheckWriteCoins(ABSENT, VALUE2, VALUE2, NO_ENTRY   , DIRTY      , DIRTY      );\n+    CheckWriteCoins(ABSENT, VALUE2, VALUE2, NO_ENTRY   , DIRTY|FRESH, DIRTY|FRESH);\n+    CheckWriteCoins(PRUNED, ABSENT, PRUNED, 0          , NO_ENTRY   , 0          );\n+    CheckWriteCoins(PRUNED, ABSENT, PRUNED, FRESH      , NO_ENTRY   , FRESH      );\n+    CheckWriteCoins(PRUNED, ABSENT, PRUNED, DIRTY      , NO_ENTRY   , DIRTY      );\n+    CheckWriteCoins(PRUNED, ABSENT, PRUNED, DIRTY|FRESH, NO_ENTRY   , DIRTY|FRESH);\n+    CheckWriteCoins(PRUNED, PRUNED, PRUNED, 0          , DIRTY      , DIRTY      );\n+    CheckWriteCoins(PRUNED, PRUNED, PRUNED, 0          , DIRTY|FRESH, DIRTY      );\n+    CheckWriteCoins(PRUNED, PRUNED, ABSENT, FRESH      , DIRTY      , NO_ENTRY   );\n+    CheckWriteCoins(PRUNED, PRUNED, ABSENT, FRESH      , DIRTY|FRESH, NO_ENTRY   );\n+    CheckWriteCoins(PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      , DIRTY      );\n+    CheckWriteCoins(PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY|FRESH, DIRTY      );\n+    CheckWriteCoins(PRUNED, PRUNED, ABSENT, DIRTY|FRESH, DIRTY      , NO_ENTRY   );\n+    CheckWriteCoins(PRUNED, PRUNED, ABSENT, DIRTY|FRESH, DIRTY|FRESH, NO_ENTRY   );\n+    CheckWriteCoins(PRUNED, VALUE2, VALUE2, 0          , DIRTY      , DIRTY      );\n+    CheckWriteCoins(PRUNED, VALUE2, VALUE2, 0          , DIRTY|FRESH, DIRTY      );\n+    CheckWriteCoins(PRUNED, VALUE2, VALUE2, FRESH      , DIRTY      , DIRTY|FRESH);\n+    CheckWriteCoins(PRUNED, VALUE2, VALUE2, FRESH      , DIRTY|FRESH, DIRTY|FRESH);\n+    CheckWriteCoins(PRUNED, VALUE2, VALUE2, DIRTY      , DIRTY      , DIRTY      );\n+    CheckWriteCoins(PRUNED, VALUE2, VALUE2, DIRTY      , DIRTY|FRESH, DIRTY      );\n+    CheckWriteCoins(PRUNED, VALUE2, VALUE2, DIRTY|FRESH, DIRTY      , DIRTY|FRESH);\n+    CheckWriteCoins(PRUNED, VALUE2, VALUE2, DIRTY|FRESH, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckWriteCoins(VALUE1, ABSENT, VALUE1, 0          , NO_ENTRY   , 0          );\n+    CheckWriteCoins(VALUE1, ABSENT, VALUE1, FRESH      , NO_ENTRY   , FRESH      );\n+    CheckWriteCoins(VALUE1, ABSENT, VALUE1, DIRTY      , NO_ENTRY   , DIRTY      );\n+    CheckWriteCoins(VALUE1, ABSENT, VALUE1, DIRTY|FRESH, NO_ENTRY   , DIRTY|FRESH);\n+    CheckWriteCoins(VALUE1, PRUNED, PRUNED, 0          , DIRTY      , DIRTY      );\n+    CheckWriteCoins(VALUE1, PRUNED, PRUNED, 0          , DIRTY|FRESH, DIRTY      );\n+    CheckWriteCoins(VALUE1, PRUNED, ABSENT, FRESH      , DIRTY      , NO_ENTRY   );\n+    CheckWriteCoins(VALUE1, PRUNED, ABSENT, FRESH      , DIRTY|FRESH, NO_ENTRY   );\n+    CheckWriteCoins(VALUE1, PRUNED, PRUNED, DIRTY      , DIRTY      , DIRTY      );\n+    CheckWriteCoins(VALUE1, PRUNED, PRUNED, DIRTY      , DIRTY|FRESH, DIRTY      );\n+    CheckWriteCoins(VALUE1, PRUNED, ABSENT, DIRTY|FRESH, DIRTY      , NO_ENTRY   );\n+    CheckWriteCoins(VALUE1, PRUNED, ABSENT, DIRTY|FRESH, DIRTY|FRESH, NO_ENTRY   );\n+    CheckWriteCoins(VALUE1, VALUE2, VALUE2, 0          , DIRTY      , DIRTY      );\n+    CheckWriteCoins(VALUE1, VALUE2, VALUE2, 0          , DIRTY|FRESH, DIRTY      );\n+    CheckWriteCoins(VALUE1, VALUE2, VALUE2, FRESH      , DIRTY      , DIRTY|FRESH);\n+    CheckWriteCoins(VALUE1, VALUE2, VALUE2, FRESH      , DIRTY|FRESH, DIRTY|FRESH);\n+    CheckWriteCoins(VALUE1, VALUE2, VALUE2, DIRTY      , DIRTY      , DIRTY      );\n+    CheckWriteCoins(VALUE1, VALUE2, VALUE2, DIRTY      , DIRTY|FRESH, DIRTY      );\n+    CheckWriteCoins(VALUE1, VALUE2, VALUE2, DIRTY|FRESH, DIRTY      , DIRTY|FRESH);\n+    CheckWriteCoins(VALUE1, VALUE2, VALUE2, DIRTY|FRESH, DIRTY|FRESH, DIRTY|FRESH);\n+\n+    // The checks above omit cases where the child flags are not DIRTY, since\n+    // they would be too repetitive (the parent cache is never updated in these\n+    // cases). The loop below covers these cases and makes sure the parent cache\n+    // is always left unchanged.\n+    for (CAmount parent_value : {ABSENT, PRUNED, VALUE1})\n+        for (CAmount child_value : {ABSENT, PRUNED, VALUE2})\n+            for (char parent_flags : parent_value == ABSENT ? ABSENT_FLAGS : FLAGS)\n+                for (char child_flags : child_value == ABSENT ? ABSENT_FLAGS : CLEAN_FLAGS)\n+                    CheckWriteCoins(parent_value, child_value, parent_value, parent_flags, child_flags, parent_flags);\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  }
]