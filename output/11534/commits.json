[
  {
    "sha": "e9d58023aef97d954b7a75da806ee4f22c9760c3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplOWQ1ODAyM2FlZjk3ZDk1NGI3YTc1ZGE4MDZlZTRmMjJjOTc2MGMz",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2017-10-11T12:55:14Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2017-10-20T00:29:53Z"
      },
      "message": "Disconnecting from bad outbound peers in IBD\n\nWhen in IBD, we'd like to use all our outbound peers to help us\nsync the chain.  Disconnect any outbound peers whose headers have\ninsufficient work.",
      "tree": {
        "sha": "91c692bf63f25132170a4f990848ed2ad0bb27f1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/91c692bf63f25132170a4f990848ed2ad0bb27f1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e9d58023aef97d954b7a75da806ee4f22c9760c3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e9d58023aef97d954b7a75da806ee4f22c9760c3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e9d58023aef97d954b7a75da806ee4f22c9760c3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e9d58023aef97d954b7a75da806ee4f22c9760c3/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "326a5652e0d25fdb60c337ef4f1c98a63e0748f0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/326a5652e0d25fdb60c337ef4f1c98a63e0748f0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/326a5652e0d25fdb60c337ef4f1c98a63e0748f0"
      }
    ],
    "stats": {
      "total": 22,
      "additions": 21,
      "deletions": 1
    },
    "files": [
      {
        "sha": "b9cd8637333deceea74fdada636282b784fb5433",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e9d58023aef97d954b7a75da806ee4f22c9760c3/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e9d58023aef97d954b7a75da806ee4f22c9760c3/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=e9d58023aef97d954b7a75da806ee4f22c9760c3",
        "patch": "@@ -2383,6 +2383,20 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 }\n             }\n         }\n+        // If we're in IBD, we want outbound peers that will serve us a useful\n+        // chain. Disconnect peers that are on chains with insufficient work.\n+        if (IsInitialBlockDownload() && nCount != MAX_HEADERS_RESULTS) {\n+            // When nCount < MAX_HEADERS_RESULTS, we know we have no more\n+            // headers to fetch from this peer.\n+            if (nodestate->pindexBestKnownBlock->nChainWork < nMinimumChainWork) {\n+                // This peer has too little work on their headers chain to help\n+                // us sync -- disconnect if using an outbound slot (unless\n+                // whitelisted or addnode).\n+                if (!(pfrom->fInbound || pfrom->fWhitelisted || pfrom->m_manual_connection)) {\n+                    pfrom->fDisconnect = true;\n+                }\n+            }\n+        }\n         }\n     }\n "
      },
      {
        "sha": "7e8e47f80fc4222b2f45f01f52272a7760f9da2a",
        "filename": "test/functional/minchainwork.py",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e9d58023aef97d954b7a75da806ee4f22c9760c3/test/functional/minchainwork.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e9d58023aef97d954b7a75da806ee4f22c9760c3/test/functional/minchainwork.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/minchainwork.py?ref=e9d58023aef97d954b7a75da806ee4f22c9760c3",
        "patch": "@@ -27,7 +27,7 @@ class MinimumChainWorkTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.setup_clean_chain = True\n         self.num_nodes = 3\n-        self.extra_args = [[], [\"-minimumchainwork=0x65\"], [\"-minimumchainwork=0x65\"]]\n+        self.extra_args = [['-whitelist=127.0.0.1'], [\"-minimumchainwork=0x65\", '-whitelist=127.0.0.1'], [\"-minimumchainwork=0x65\"]]\n         self.node_min_work = [0, 101, 101]\n \n     def setup_network(self):\n@@ -74,6 +74,12 @@ def run_test(self):\n         self.nodes[0].generate(1)\n \n         self.log.info(\"Verifying nodes are all synced\")\n+\n+        # May need to reconnect the nodes -- node1 may have abandoned node0 as a poor\n+        # outbound peer for having a low-work chain.\n+        if (len(self.nodes[0].getpeerinfo()) == 0):\n+            connect_nodes(self.nodes[1], 0)\n+\n         self.sync_all()\n         self.log.info(\"Blockcounts: %s\", [n.getblockcount() for n in self.nodes])\n "
      }
    ]
  },
  {
    "sha": "9a70054f65cd9b63b3e5540160f4eb91fc505f17",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YTcwMDU0ZjY1Y2Q5YjYzYjNlNTU0MDE2MGY0ZWI5MWZjNTA1ZjE3",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-10-12T17:55:43Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2017-10-20T00:29:53Z"
      },
      "message": "Permit disconnection of outbound peers on bad/slow chains\n\nCurrently we have no rotation of outbound peers.  If an outbound peer\nstops serving us blocks, or is on a consensus-incompatible chain with\nless work than our tip (but otherwise valid headers), then we will never\ndisconnect that peer, even though that peer is using one of our 8\noutbound connection slots.  Because we rely on our outbound peers to\nfind an honest node in order to reach consensus, allowing an\nincompatible peer to occupy one of those slots is undesirable,\nparticularly if it is possible for all such slots to be occupied by such\npeers.\n\nProtect against this by always checking to see if a peer's best known\nblock has less work than our tip, and if so, set a 20 minute timeout --\nif the peer is still not known to have caught up to a chain with as much\nwork as ours after 20 minutes, then send a single getheaders message,\nwait 2 more minutes, and if a better header hasn't been received by then,\ndisconnect that peer.\n\nNote:\n\n- we do not require that our peer sync to the same tip as ours, just an\nequal or greater work tip.  (Doing otherwise would risk partitioning the\nnetwork in the event of a chain split, and is also unnecessary.)\n\n- we pick 4 of our outbound peers and do not subject them to this logic,\nto be more conservative. We don't wish to permit temporary network\nissues (or an attacker) to excessively disrupt network topology.",
      "tree": {
        "sha": "02026e1fe99e88ef3d3d5c1465244b249137829a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/02026e1fe99e88ef3d3d5c1465244b249137829a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9a70054f65cd9b63b3e5540160f4eb91fc505f17",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9a70054f65cd9b63b3e5540160f4eb91fc505f17",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9a70054f65cd9b63b3e5540160f4eb91fc505f17",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9a70054f65cd9b63b3e5540160f4eb91fc505f17/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e9d58023aef97d954b7a75da806ee4f22c9760c3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e9d58023aef97d954b7a75da806ee4f22c9760c3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e9d58023aef97d954b7a75da806ee4f22c9760c3"
      }
    ],
    "stats": {
      "total": 80,
      "additions": 80,
      "deletions": 0
    },
    "files": [
      {
        "sha": "2be3208b51a467de894d6f24883ee0a918c1ce2e",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 74,
        "deletions": 0,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9a70054f65cd9b63b3e5540160f4eb91fc505f17/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9a70054f65cd9b63b3e5540160f4eb91fc505f17/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=9a70054f65cd9b63b3e5540160f4eb91fc505f17",
        "patch": "@@ -124,6 +124,9 @@ namespace {\n     /** Number of peers from which we're downloading blocks. */\n     int nPeersWithValidatedDownloads = 0;\n \n+    /** Number of outbound peers with m_protect_from_disconnect. */\n+    int g_outbound_peers_with_protect_from_disconnect = 0;\n+\n     /** Relay map, protected by cs_main. */\n     typedef std::map<uint256, CTransactionRef> MapRelay;\n     MapRelay mapRelay;\n@@ -200,6 +203,14 @@ struct CNodeState {\n      * otherwise: whether this peer sends non-witnesses in cmpctblocks/blocktxns.\n      */\n     bool fSupportsDesiredCmpctVersion;\n+    //! Whether this peer is protected from disconnection due to a bad/slow chain\n+    bool m_protect_from_disconnect;\n+    //! A timeout used for checking whether our peer has sufficiently synced\n+    int64_t m_headers_chain_timeout;\n+    //! A header with the work we require on our peer's chain\n+    const CBlockIndex * m_header_with_required_work;\n+    //! After timeout is reached, set to true after sending getheaders\n+    bool m_sent_getheaders_to_check_chain_sync;\n \n     CNodeState(CAddress addrIn, std::string addrNameIn) : address(addrIn), name(addrNameIn) {\n         fCurrentlyConnected = false;\n@@ -223,6 +234,10 @@ struct CNodeState {\n         fHaveWitness = false;\n         fWantsCmpctWitness = false;\n         fSupportsDesiredCmpctVersion = false;\n+        m_protect_from_disconnect = false;\n+        m_headers_chain_timeout = 0;\n+        m_header_with_required_work = nullptr;\n+        m_sent_getheaders_to_check_chain_sync = false;\n     }\n };\n \n@@ -534,6 +549,8 @@ void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTim\n     nPreferredDownload -= state->fPreferredDownload;\n     nPeersWithValidatedDownloads -= (state->nBlocksInFlightValidHeaders != 0);\n     assert(nPeersWithValidatedDownloads >= 0);\n+    g_outbound_peers_with_protect_from_disconnect -= state->m_protect_from_disconnect;\n+    assert(g_outbound_peers_with_protect_from_disconnect >= 0);\n \n     mapNodeState.erase(nodeid);\n \n@@ -542,6 +559,7 @@ void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTim\n         assert(mapBlocksInFlight.empty());\n         assert(nPreferredDownload == 0);\n         assert(nPeersWithValidatedDownloads == 0);\n+        assert(g_outbound_peers_with_protect_from_disconnect == 0);\n     }\n     LogPrint(BCLog::NET, \"Cleared nodestate for peer=%d\\n\", nodeid);\n }\n@@ -2393,10 +2411,20 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // us sync -- disconnect if using an outbound slot (unless\n                 // whitelisted or addnode).\n                 if (!(pfrom->fInbound || pfrom->fWhitelisted || pfrom->m_manual_connection)) {\n+                    LogPrintf(\"Disconnecting outbound peer %d -- headers chain has insufficient work\\n\", pfrom->GetId());\n                     pfrom->fDisconnect = true;\n                 }\n             }\n         }\n+\n+        if (!pfrom->fDisconnect && !pfrom->fInbound && !pfrom->fOneShot && !pfrom->fFeeler && !pfrom->m_manual_connection) {\n+            // If this is an outbound peer, check to see if we should protect\n+            // it from the bad/lagging chain logic.\n+            if (g_outbound_peers_with_protect_from_disconnect < MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT && nodestate->pindexBestKnownBlock->nChainWork >= chainActive.Tip()->nChainWork && !nodestate->m_protect_from_disconnect) {\n+                nodestate->m_protect_from_disconnect = true;\n+                ++g_outbound_peers_with_protect_from_disconnect;\n+            }\n+        }\n         }\n     }\n \n@@ -3261,6 +3289,52 @@ bool PeerLogicValidation::SendMessages(CNode* pto, std::atomic<bool>& interruptM\n             }\n         }\n \n+        // Check that outbound peers have reasonable chains\n+        // GetTime() is used by this anti-DoS logic so we can test this using mocktime\n+        int64_t time_in_seconds = GetTime();\n+        if (!(state.m_protect_from_disconnect || pto->fInbound || pto->m_manual_connection || pto->fFeeler || pto->fOneShot) && state.fSyncStarted) {\n+            // This is an outbound peer subject to disconnection if their chain\n+            // lags behind ours (note: if their chain has more work than ours,\n+            // we should sync to it, unless it's invalid, in which case we\n+            // should find that out and disconnect from them elsewhere).\n+            if (state.pindexBestKnownBlock != nullptr && state.pindexBestKnownBlock->nChainWork >= chainActive.Tip()->nChainWork) {\n+                if (state.m_headers_chain_timeout != 0) {\n+                    state.m_headers_chain_timeout = 0;\n+                    state.m_header_with_required_work = nullptr;\n+                    state.m_sent_getheaders_to_check_chain_sync = false;\n+                }\n+            } else if (state.m_headers_chain_timeout == 0 || (state.m_header_with_required_work != nullptr && state.pindexBestKnownBlock != nullptr && state.pindexBestKnownBlock->nChainWork >= state.m_header_with_required_work->nChainWork)) {\n+                // Our best block known by this peer is behind our tip, and we're either noticing\n+                // that for the first time, OR this peer was able to catch up to some earlier point\n+                // where we checked against our tip.\n+                // Either way, set a new timeout based on current tip.\n+                state.m_headers_chain_timeout = time_in_seconds + CHAIN_SYNC_TIMEOUT;\n+                state.m_header_with_required_work = chainActive.Tip();\n+                state.m_sent_getheaders_to_check_chain_sync = false;\n+            } else if (state.m_headers_chain_timeout > 0 && time_in_seconds > state.m_headers_chain_timeout) {\n+                // No evidence yet that our peer has synced to a chain with work equal to that\n+                // of our tip, when we first detected it was behind. Send a single getheaders\n+                // message to give the peer a chance to update us.\n+                if (state.m_sent_getheaders_to_check_chain_sync) {\n+                    // They've run out of time to catch up!\n+                    LogPrintf(\"Disconnecting outbound peer %d for old chain, best known block = %s\\n\", pto->GetId(), state.pindexBestKnownBlock != nullptr ? state.pindexBestKnownBlock->GetBlockHash().ToString() : \"<none>\");\n+                    pto->fDisconnect = true;\n+                } else {\n+                    LogPrint(BCLog::NET, \"sending getheaders to outbound peer=%d to verify chain work (current best known block:%s, benchmark blockhash: %s)\\n\", pto->GetId(), state.pindexBestKnownBlock != nullptr ? state.pindexBestKnownBlock->GetBlockHash().ToString() : \"<none>\", state.m_header_with_required_work->GetBlockHash().ToString());\n+                    connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(state.m_header_with_required_work->pprev), uint256()));\n+                    state.m_sent_getheaders_to_check_chain_sync = true;\n+                    constexpr int64_t HEADERS_RESPONSE_TIME = 120; // 2 minutes\n+                    // Bump the timeout to allow a response, which could clear the timeout\n+                    // (if the response shows the peer has synced), reset the timeout (if\n+                    // the peer syncs to the required work but not to our tip), or result\n+                    // in disconnect (if we advance to the timeout and pindexBestKnownBlock\n+                    // has not sufficiently progressed)\n+                    state.m_headers_chain_timeout = time_in_seconds + HEADERS_RESPONSE_TIME;\n+                }\n+            }\n+        }\n+\n+\n \n         //\n         // Message: getdata (blocks)"
      },
      {
        "sha": "e89e8a12ead53ea9bcd6a809cfd062ebd88a2c8d",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9a70054f65cd9b63b3e5540160f4eb91fc505f17/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9a70054f65cd9b63b3e5540160f4eb91fc505f17/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=9a70054f65cd9b63b3e5540160f4eb91fc505f17",
        "patch": "@@ -21,6 +21,12 @@ static const unsigned int DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN = 100;\n  *  Timeout = base + per_header * (expected number of headers) */\n static constexpr int64_t HEADERS_DOWNLOAD_TIMEOUT_BASE = 15 * 60 * 1000000; // 15 minutes\n static constexpr int64_t HEADERS_DOWNLOAD_TIMEOUT_PER_HEADER = 1000; // 1ms/header\n+/** Protect at least this many outbound peers from disconnection due to slow/\n+ * behind headers chain.\n+ */\n+static constexpr int32_t MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT = 4;\n+/** Timeout for (unprotected) outbound peers to sync to our chainwork, in seconds */\n+static constexpr int64_t CHAIN_SYNC_TIMEOUT = 20 * 60; // 20 minutes\n \n class PeerLogicValidation : public CValidationInterface, public NetEventsInterface {\n private:"
      }
    ]
  },
  {
    "sha": "39e0c8e1e7b5cdf57437aa0f957b41183fd0e197",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozOWUwYzhlMWU3YjVjZGY1NzQzN2FhMGY5NTdiNDExODNmZDBlMTk3",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-10-19T15:42:47Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2017-10-20T00:29:53Z"
      },
      "message": "Add unit test for outbound peer eviction",
      "tree": {
        "sha": "1238d5c1722cf182e883402772fb1552358f817b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1238d5c1722cf182e883402772fb1552358f817b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/39e0c8e1e7b5cdf57437aa0f957b41183fd0e197",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/39e0c8e1e7b5cdf57437aa0f957b41183fd0e197",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/39e0c8e1e7b5cdf57437aa0f957b41183fd0e197",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/39e0c8e1e7b5cdf57437aa0f957b41183fd0e197/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9a70054f65cd9b63b3e5540160f4eb91fc505f17",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9a70054f65cd9b63b3e5540160f4eb91fc505f17",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9a70054f65cd9b63b3e5540160f4eb91fc505f17"
      }
    ],
    "stats": {
      "total": 52,
      "additions": 52,
      "deletions": 0
    },
    "files": [
      {
        "sha": "d939320d7319069a98de92061d3a4dc61152cb73",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 0,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39e0c8e1e7b5cdf57437aa0f957b41183fd0e197/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39e0c8e1e7b5cdf57437aa0f957b41183fd0e197/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=39e0c8e1e7b5cdf57437aa0f957b41183fd0e197",
        "patch": "@@ -42,6 +42,48 @@ static NodeId id = 0;\n \n BOOST_FIXTURE_TEST_SUITE(DoS_tests, TestingSetup)\n \n+// Test eviction of an outbound peer whose chain never advances\n+// Mock a node connection, and use mocktime to simulate a peer\n+// which never sends any headers messages.  PeerLogic should\n+// decide to evict that outbound peer, after the appropriate timeouts.\n+// Note that we protect 4 outbound nodes from being subject to\n+// this logic; this test takes advantage of that protection only\n+// being applied to nodes which send headers with sufficient\n+// work.\n+BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n+{\n+    std::atomic<bool> interruptDummy(false);\n+\n+    // Mock an outbound peer\n+    CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n+    CNode dummyNode1(id++, ServiceFlags(NODE_NETWORK|NODE_WITNESS), 0, INVALID_SOCKET, addr1, 0, 0, CAddress(), \"\", /*fInboundIn=*/ false);\n+    dummyNode1.SetSendVersion(PROTOCOL_VERSION);\n+\n+    peerLogic->InitializeNode(&dummyNode1);\n+    dummyNode1.nVersion = 1;\n+    dummyNode1.fSuccessfullyConnected = true;\n+\n+    // This test requires that we have a chain with non-zero work.\n+    BOOST_CHECK(chainActive.Tip() != nullptr);\n+    BOOST_CHECK(chainActive.Tip()->nChainWork > 0);\n+\n+    // Test starts here\n+    peerLogic->SendMessages(&dummyNode1, interruptDummy); // should result in getheaders\n+\n+    int64_t nStartTime = GetTime();\n+    // Wait 21 minutes, to\n+    SetMockTime(nStartTime+21*60);\n+    peerLogic->SendMessages(&dummyNode1, interruptDummy); // should result in getheaders\n+    // Wait 3 more minutes\n+    SetMockTime(nStartTime+24*60);\n+    peerLogic->SendMessages(&dummyNode1, interruptDummy); // should result in disconnect\n+    BOOST_CHECK(dummyNode1.fDisconnect == true);\n+    SetMockTime(0);\n+\n+    bool dummy;\n+    peerLogic->FinalizeNode(dummyNode1.GetId(), dummy);\n+}\n+\n BOOST_AUTO_TEST_CASE(DoS_banning)\n {\n     std::atomic<bool> interruptDummy(false);\n@@ -71,6 +113,10 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n     Misbehaving(dummyNode2.GetId(), 50);\n     peerLogic->SendMessages(&dummyNode2, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr2));\n+\n+    bool dummy;\n+    peerLogic->FinalizeNode(dummyNode1.GetId(), dummy);\n+    peerLogic->FinalizeNode(dummyNode2.GetId(), dummy);\n }\n \n BOOST_AUTO_TEST_CASE(DoS_banscore)\n@@ -95,6 +141,9 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n     peerLogic->SendMessages(&dummyNode1, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr1));\n     gArgs.ForceSetArg(\"-banscore\", std::to_string(DEFAULT_BANSCORE_THRESHOLD));\n+\n+    bool dummy;\n+    peerLogic->FinalizeNode(dummyNode1.GetId(), dummy);\n }\n \n BOOST_AUTO_TEST_CASE(DoS_bantime)\n@@ -121,6 +170,9 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n \n     SetMockTime(nStartTime+60*60*24+1);\n     BOOST_CHECK(!connman->IsBanned(addr));\n+\n+    bool dummy;\n+    peerLogic->FinalizeNode(dummyNode.GetId(), dummy);\n }\n \n CTransactionRef RandomOrphan()"
      }
    ]
  },
  {
    "sha": "6cd3ff9731202868abae27fa8b226ead7c456945",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2Y2QzZmY5NzMxMjAyODY4YWJhZTI3ZmE4YjIyNmVhZDdjNDU2OTQ1",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-10-20T14:08:54Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-10-20T14:19:37Z"
      },
      "message": "Add hacky accessors for manipulating connman peers in tests",
      "tree": {
        "sha": "63977b0cb23fbb44d31831954d8cd45a22c3cd35",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/63977b0cb23fbb44d31831954d8cd45a22c3cd35"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6cd3ff9731202868abae27fa8b226ead7c456945",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6cd3ff9731202868abae27fa8b226ead7c456945",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6cd3ff9731202868abae27fa8b226ead7c456945",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6cd3ff9731202868abae27fa8b226ead7c456945/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "39e0c8e1e7b5cdf57437aa0f957b41183fd0e197",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/39e0c8e1e7b5cdf57437aa0f957b41183fd0e197",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/39e0c8e1e7b5cdf57437aa0f957b41183fd0e197"
      }
    ],
    "stats": {
      "total": 15,
      "additions": 15,
      "deletions": 0
    },
    "files": [
      {
        "sha": "94f130aa2aecabe51e35e2bd5914239f234005ae",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6cd3ff9731202868abae27fa8b226ead7c456945/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6cd3ff9731202868abae27fa8b226ead7c456945/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=6cd3ff9731202868abae27fa8b226ead7c456945",
        "patch": "@@ -2862,3 +2862,15 @@ uint64_t CConnman::CalculateKeyedNetGroup(const CAddress& ad) const\n \n     return GetDeterministicRandomizer(RANDOMIZER_ID_NETGROUP).Write(vchNetGroup.data(), vchNetGroup.size()).Finalize();\n }\n+\n+void CConnman::AddToVNodes(CNode &node)\n+{\n+    LOCK(cs_vNodes);\n+    vNodes.push_back(&node);\n+}\n+\n+void CConnman::ClearVNodes()\n+{\n+    LOCK(cs_vNodes);\n+    vNodes.clear();\n+}"
      },
      {
        "sha": "e92170d634f27b86e1bd49ef9e807a966f517246",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6cd3ff9731202868abae27fa8b226ead7c456945/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6cd3ff9731202868abae27fa8b226ead7c456945/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=6cd3ff9731202868abae27fa8b226ead7c456945",
        "patch": "@@ -295,6 +295,9 @@ class CConnman\n     unsigned int GetReceiveFloodSize() const;\n \n     void WakeMessageHandler();\n+\n+    void AddToVNodes(CNode &node);\n+    void ClearVNodes();\n private:\n     struct ListenSocket {\n         SOCKET socket;"
      }
    ]
  },
  {
    "sha": "c071f62e2138140c34be097bebec5f0debe9b269",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjMDcxZjYyZTIxMzgxNDBjMzRiZTA5N2JlYmVjNWYwZGViZTliMjY5",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2017-10-16T12:23:18Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-10-23T12:48:21Z"
      },
      "message": "Disconnect an outbound peer if tip is stale",
      "tree": {
        "sha": "6f256c84ad074df0cb5b63202d632d43720ba636",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6f256c84ad074df0cb5b63202d632d43720ba636"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c071f62e2138140c34be097bebec5f0debe9b269",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c071f62e2138140c34be097bebec5f0debe9b269",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c071f62e2138140c34be097bebec5f0debe9b269",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c071f62e2138140c34be097bebec5f0debe9b269/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6cd3ff9731202868abae27fa8b226ead7c456945",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6cd3ff9731202868abae27fa8b226ead7c456945",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6cd3ff9731202868abae27fa8b226ead7c456945"
      }
    ],
    "stats": {
      "total": 229,
      "additions": 229,
      "deletions": 0
    },
    "files": [
      {
        "sha": "4a144fc0e26275bd366ce4e30b122cae2ea660b0",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c071f62e2138140c34be097bebec5f0debe9b269/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c071f62e2138140c34be097bebec5f0debe9b269/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=c071f62e2138140c34be097bebec5f0debe9b269",
        "patch": "@@ -1768,6 +1768,28 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n             }\n         }\n \n+        // Disconnect outbound peers marked for eviction\n+        // Idea: if our outbound peers look bad (based on metrics designed\n+        // to ensure connectivity to consensus-compatible peers), then we\n+        // may wish to disconnect them if we have other peers we would try\n+        // instead.\n+        // If we're not yet using all our outbound peer slots, just clear the\n+        // eviction flag -- this prevents an unnecessary/undesired eviction\n+        // from happening later, if the flag was set before all our peer slots\n+        // were in use.\n+        {\n+            LOCK(cs_vNodes);\n+            for (CNode* pnode : vNodes) {\n+                if (nOutbound >= nMaxOutbound && !pnode->fInbound && !pnode->m_manual_connection && pnode->m_eviction_candidate) {\n+                    LogPrint(BCLog::NET, \"disconnecting outbound peer=%d (marked for eviction)\\n\", pnode->GetId());\n+                    pnode->fDisconnect = true;\n+                } else {\n+                    // If we can't evict for some reason, disable the flag\n+                    pnode->m_eviction_candidate = false;\n+                }\n+            }\n+        }\n+\n         // Feeler Connections\n         //\n         // Design goals:\n@@ -2706,6 +2728,7 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn\n     fWhitelisted = false;\n     fOneShot = false;\n     m_manual_connection = false;\n+    m_eviction_candidate = false;\n     fClient = false; // set by version message\n     fFeeler = false;\n     fSuccessfullyConnected = false;"
      },
      {
        "sha": "161645b5c49eb21a38a6a856a65a6b60c88189ad",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c071f62e2138140c34be097bebec5f0debe9b269/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c071f62e2138140c34be097bebec5f0debe9b269/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=c071f62e2138140c34be097bebec5f0debe9b269",
        "patch": "@@ -619,6 +619,14 @@ class CNode\n     bool fFeeler; // If true this node is being used as a short lived feeler.\n     bool fOneShot;\n     bool m_manual_connection;\n+\n+    // m_eviction_candidate should be set to true for outbound,\n+    // non-manual-connection peers that are suitable for eviction, if evicting\n+    // such a peer would make room for a new outbound peer\n+    // m_eviction_candidate will be set to false by CConnman if not all\n+    // outbound connections are up.\n+    bool m_eviction_candidate;\n+\n     bool fClient;\n     const bool fInbound;\n     std::atomic_bool fSuccessfullyConnected;"
      },
      {
        "sha": "2d82f5dc0978af7ca55f9aa95c78aa94b9b505fb",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 106,
        "deletions": 0,
        "changes": 106,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c071f62e2138140c34be097bebec5f0debe9b269/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c071f62e2138140c34be097bebec5f0debe9b269/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=c071f62e2138140c34be097bebec5f0debe9b269",
        "patch": "@@ -127,6 +127,12 @@ namespace {\n     /** Number of outbound peers with m_protect_from_disconnect. */\n     int g_outbound_peers_with_protect_from_disconnect = 0;\n \n+    /** When to next check whether our tip is stale. */\n+    int64_t g_tip_stale_check_time = 0;\n+\n+    /** When our tip was last updated. */\n+    int64_t g_last_tip_update = 0;\n+\n     /** Relay map, protected by cs_main. */\n     typedef std::map<uint256, CTransactionRef> MapRelay;\n     MapRelay mapRelay;\n@@ -211,6 +217,8 @@ struct CNodeState {\n     const CBlockIndex * m_header_with_required_work;\n     //! After timeout is reached, set to true after sending getheaders\n     bool m_sent_getheaders_to_check_chain_sync;\n+    //! Time of last new block announcement\n+    int64_t m_last_block_announcement;\n \n     CNodeState(CAddress addrIn, std::string addrNameIn) : address(addrIn), name(addrNameIn) {\n         fCurrentlyConnected = false;\n@@ -238,6 +246,7 @@ struct CNodeState {\n         m_headers_chain_timeout = 0;\n         m_header_with_required_work = nullptr;\n         m_sent_getheaders_to_check_chain_sync = false;\n+        m_last_block_announcement = 0;\n     }\n };\n \n@@ -252,6 +261,11 @@ CNodeState *State(NodeId pnode) {\n     return &it->second;\n }\n \n+void UpdateLastBlockAnnouncement(CNodeState *state)\n+{\n+    if (state != nullptr) state->m_last_block_announcement = GetTime();\n+}\n+\n void UpdatePreferredDownload(CNode* node, CNodeState* state)\n {\n     nPreferredDownload -= state->fPreferredDownload;\n@@ -417,6 +431,17 @@ bool CanDirectFetch(const Consensus::Params &consensusParams)\n     return chainActive.Tip()->GetBlockTime() > GetAdjustedTime() - consensusParams.nPowTargetSpacing * 20;\n }\n \n+// Requires cs_main\n+bool TipMayBeStale(const Consensus::Params &consensusParams)\n+{\n+    // Initialize the time of the last tip update to current time on startup.\n+    // We use GetTime() so that this logic can be tested using mocktime.\n+    if (g_last_tip_update == 0) {\n+        g_last_tip_update = GetTime();\n+    }\n+    return g_last_tip_update < GetTime() - consensusParams.nPowTargetSpacing * 12;\n+}\n+\n // Requires cs_main\n bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex)\n {\n@@ -517,6 +542,18 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n \n } // namespace\n \n+void PeerLogicValidation::UpdateLastAnnouncement(NodeId id)\n+{\n+    LOCK(cs_main);\n+    UpdateLastBlockAnnouncement(State(id));\n+}\n+\n+void PeerLogicValidation::ClearTipStaleCheckTime()\n+{\n+    LOCK(cs_main);\n+    g_tip_stale_check_time = 0;\n+}\n+\n void PeerLogicValidation::InitializeNode(CNode *pnode) {\n     CAddress addr = pnode->addr;\n     std::string addrName = pnode->GetAddrName();\n@@ -774,6 +811,10 @@ void PeerLogicValidation::BlockConnected(const std::shared_ptr<const CBlock>& pb\n         }\n         LogPrint(BCLog::MEMPOOL, \"Erased %d orphan tx included or conflicted by block\\n\", nErased);\n     }\n+\n+    // Track the most recent tip update time for stale-tip checks\n+    // We set this with GetTime() so that this can be tested using mocktime.\n+    g_last_tip_update = GetTime();\n }\n \n // All of the following cache a recent block, and are protected by cs_most_recent_block\n@@ -2277,6 +2318,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             return true;\n         }\n \n+        bool received_new_header = false;\n         const CBlockIndex *pindexLast = nullptr;\n         {\n         LOCK(cs_main);\n@@ -2317,6 +2359,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             }\n             hashLastBlock = header.GetHash();\n         }\n+\n+        // If we don't have the last header, then they'll have given us\n+        // something new (assuming these headers are valid).\n+        if (mapBlockIndex.find(hashLastBlock) == mapBlockIndex.end()) {\n+            received_new_header = true;\n+        }\n         }\n \n         CValidationState state;\n@@ -2342,6 +2390,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         assert(pindexLast);\n         UpdateBlockAvailability(pfrom->GetId(), pindexLast->GetBlockHash());\n \n+        // Update time of last block announcement from this peer (used in stale-\n+        // tip-based outbound peer eviction logic)\n+        if (received_new_header && pindexLast->nChainWork > chainActive.Tip()->nChainWork) {\n+            UpdateLastBlockAnnouncement(nodestate);\n+        }\n+\n         if (nCount == MAX_HEADERS_RESULTS) {\n             // Headers message had its maximum size; the peer may have more headers.\n             // TODO: optimize: if pindexLast is an ancestor of chainActive.Tip or pindexBestHeader, continue\n@@ -3334,6 +3388,58 @@ bool PeerLogicValidation::SendMessages(CNode* pto, std::atomic<bool>& interruptM\n             }\n         }\n \n+        // TODO: This logic is not peer-specific, so it doesn't really make\n+        // sense in SendMessages; move this somewhere more fitting.\n+        // Our goal here is to avoid being connected to a set of outbound peers\n+        // which are all refusing to relay valid blocks to us.\n+        // Strategy: if too much time has passed since we last updated our tip,\n+        // mark the outbound peer with the least recent block announcement as\n+        // evictable by our net.cpp code (which will only evict if we are at\n+        // our outbound peer limit).\n+        // If multiple peers are tied for least recently announcing a\n+        // block to us, prefer to evict the newest peer -- this prevents us\n+        // from cycling through all our peers in the event that blocks are just\n+        // slow to be found on our chain.\n+        if (time_in_seconds > g_tip_stale_check_time) {\n+            if (TipMayBeStale(consensusParams)) {\n+                // Mark our \"worst\" outbound peer for potential eviction, in\n+                // the hopes of finding an outbound peer who has a new block.\n+                NodeId worst_peer = -1;\n+                int64_t oldest_block_announcement = GetTime();\n+                int64_t worst_peer_connect_time = 0;\n+                for (auto it = mapNodeState.begin(); it != mapNodeState.end(); ++it) {\n+                    int64_t connect_time = 0;\n+                    if (connman->ForNode(it->first, [&](CNode *pnode){\n+                        // Figure out if this is an outbound peer we might try\n+                        // to evict\n+                        if (!(pnode->fInbound || pnode->m_manual_connection || pnode->fOneShot || pnode->fFeeler)) {\n+                            // unset eviction status\n+                            pnode->m_eviction_candidate = false;\n+                            connect_time = pnode->nTimeConnected;\n+                            return true;\n+                        }\n+                        return false;\n+                    })) {\n+                        // Mark the outbound peer that least recently served us\n+                        // a new block announcement; break ties by choosing the\n+                        // peer that most recently connected.\n+                        if (it->second.m_last_block_announcement < oldest_block_announcement ||\n+                                (it->second.m_last_block_announcement == oldest_block_announcement &&\n+                                 connect_time > worst_peer_connect_time)) {\n+                            worst_peer = it->first;\n+                            oldest_block_announcement = it->second.m_last_block_announcement;\n+                            worst_peer_connect_time = connect_time;\n+                        }\n+                    }\n+                }\n+                connman->ForNode(worst_peer, [&](CNode *pnode){\n+                    pnode->m_eviction_candidate = true;\n+                    return true;\n+                });\n+                LogPrint(BCLog::NET, \"Tip may be stale; marked peer=%d for potential eviction\\n\", worst_peer);\n+            }\n+            g_tip_stale_check_time = time_in_seconds + STALE_TIP_CHECK_INTERVAL;\n+        }\n \n \n         //"
      },
      {
        "sha": "da2b08fa1a7ce4dbfa25c5a6156b6638722682ae",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c071f62e2138140c34be097bebec5f0debe9b269/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c071f62e2138140c34be097bebec5f0debe9b269/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=c071f62e2138140c34be097bebec5f0debe9b269",
        "patch": "@@ -27,6 +27,8 @@ static constexpr int64_t HEADERS_DOWNLOAD_TIMEOUT_PER_HEADER = 1000; // 1ms/head\n static constexpr int32_t MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT = 4;\n /** Timeout for (unprotected) outbound peers to sync to our chainwork, in seconds */\n static constexpr int64_t CHAIN_SYNC_TIMEOUT = 20 * 60; // 20 minutes\n+/** Interval for checking whether our tip seems to be stale, in seconds */\n+static constexpr int64_t STALE_TIP_CHECK_INTERVAL = 10 * 60; // 10 minutes\n \n class PeerLogicValidation : public CValidationInterface, public NetEventsInterface {\n private:\n@@ -53,6 +55,10 @@ class PeerLogicValidation : public CValidationInterface, public NetEventsInterfa\n     * @return                      True if there is more work to be done\n     */\n     bool SendMessages(CNode* pto, std::atomic<bool>& interrupt) override;\n+\n+    // Accessors to clear/update net_processing state, for testing purposes.\n+    void UpdateLastAnnouncement(NodeId id);\n+    void ClearTipStaleCheckTime();\n };\n \n struct CNodeStateStats {"
      },
      {
        "sha": "508f81fdeae31dfc942f17a03e3a387546113599",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 86,
        "deletions": 0,
        "changes": 86,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c071f62e2138140c34be097bebec5f0debe9b269/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c071f62e2138140c34be097bebec5f0debe9b269/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=c071f62e2138140c34be097bebec5f0debe9b269",
        "patch": "@@ -84,6 +84,92 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n     peerLogic->FinalizeNode(dummyNode1.GetId(), dummy);\n }\n \n+// Test eviction of an outbound peer due to stale tip\n+BOOST_AUTO_TEST_CASE(outbound_stale_tip_eviction)\n+{\n+    std::atomic<bool> interruptDummy(false);\n+\n+    // Mock a few outbound peers\n+    CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n+    CNode dummyNode1(id++, ServiceFlags(NODE_NETWORK|NODE_WITNESS), 0, INVALID_SOCKET, addr1, 0, 0, CAddress(), \"\", /*fInboundIn=*/ false);\n+    dummyNode1.SetSendVersion(PROTOCOL_VERSION);\n+\n+    CAddress addr2(ip(0xaabbccdd), NODE_NONE);\n+    CNode dummyNode2(id++, ServiceFlags(NODE_NETWORK|NODE_WITNESS), 0, INVALID_SOCKET, addr2, 0, 0, CAddress(), \"\", /*fInboundIn=*/ false);\n+    dummyNode2.SetSendVersion(PROTOCOL_VERSION);\n+\n+    CAddress addr3(ip(0xbbccddaa), NODE_NONE);\n+    // Ensure that nTimeConnected for node3 is after node2\n+    // TODO: find a better way to do this than sleeping!\n+    MilliSleep(1000);\n+    CNode dummyNode3(id++, ServiceFlags(NODE_NETWORK|NODE_WITNESS), 0, INVALID_SOCKET, addr3, 0, 0, CAddress(), \"\", /*fInboundIn=*/ false);\n+    dummyNode3.SetSendVersion(PROTOCOL_VERSION);\n+\n+    connman->AddToVNodes(dummyNode1);\n+    connman->AddToVNodes(dummyNode2);\n+    connman->AddToVNodes(dummyNode3);\n+\n+    peerLogic->InitializeNode(&dummyNode1);\n+    peerLogic->InitializeNode(&dummyNode2);\n+    peerLogic->InitializeNode(&dummyNode3);\n+\n+    dummyNode1.nVersion = 1;\n+    dummyNode1.fSuccessfullyConnected = true;\n+\n+    dummyNode2.nVersion = 1;\n+    dummyNode2.fSuccessfullyConnected = true;\n+\n+    dummyNode3.nVersion = 1;\n+    dummyNode3.fSuccessfullyConnected = true;\n+\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time - 10*60);\n+    peerLogic->UpdateLastAnnouncement(dummyNode1.GetId());\n+    SetMockTime(start_time - 30*60);\n+    peerLogic->UpdateLastAnnouncement(dummyNode2.GetId());\n+    SetMockTime(start_time - 20*60);\n+    peerLogic->UpdateLastAnnouncement(dummyNode3.GetId());\n+    SetMockTime(start_time);\n+\n+    peerLogic->ClearTipStaleCheckTime();\n+\n+    peerLogic->SendMessages(&dummyNode1, interruptDummy); // should set stale tip check time\n+\n+    SetMockTime(start_time + 119*60);\n+\n+    // Nothing should happen yet -- timeout not yet reached\n+    peerLogic->SendMessages(&dummyNode2, interruptDummy);\n+    BOOST_CHECK(dummyNode1.m_eviction_candidate == false);\n+    BOOST_CHECK(dummyNode2.m_eviction_candidate == false);\n+    BOOST_CHECK(dummyNode3.m_eviction_candidate == false);\n+    BOOST_CHECK(dummyNode1.fDisconnect == false);\n+    BOOST_CHECK(dummyNode2.fDisconnect == false);\n+    BOOST_CHECK(dummyNode3.fDisconnect == false);\n+\n+    SetMockTime(start_time + 130*60);\n+    // Now we should choose a peer to evict\n+    peerLogic->SendMessages(&dummyNode3, interruptDummy);\n+    BOOST_CHECK(dummyNode1.m_eviction_candidate == false);\n+    BOOST_CHECK(dummyNode2.m_eviction_candidate == true);\n+    BOOST_CHECK(dummyNode3.m_eviction_candidate == false);\n+\n+    // Check the handling of ties\n+    SetMockTime(start_time - 20*60);\n+    peerLogic->UpdateLastAnnouncement(dummyNode2.GetId());\n+    SetMockTime(start_time + 260*60);\n+    peerLogic->SendMessages(&dummyNode2, interruptDummy);\n+    BOOST_CHECK(dummyNode1.m_eviction_candidate == false);\n+    BOOST_CHECK(dummyNode2.m_eviction_candidate == false);\n+    BOOST_CHECK(dummyNode3.m_eviction_candidate == true);\n+\n+    bool dummy;\n+    peerLogic->FinalizeNode(dummyNode1.GetId(), dummy);\n+    peerLogic->FinalizeNode(dummyNode2.GetId(), dummy);\n+    peerLogic->FinalizeNode(dummyNode3.GetId(), dummy);\n+\n+    connman->ClearVNodes();\n+}\n+\n BOOST_AUTO_TEST_CASE(DoS_banning)\n {\n     std::atomic<bool> interruptDummy(false);"
      }
    ]
  }
]