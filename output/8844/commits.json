[
  {
    "sha": "f119ec2700feb574315a04121aaa9632107ae627",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMTE5ZWMyNzAwZmViNTc0MzE1YTA0MTIxYWFhOTYzMjEwN2FlNjI3",
    "commit": {
      "author": {
        "name": "jnewbery",
        "email": "john@johnnewbery.com",
        "date": "2016-09-28T14:05:50Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2016-11-04T18:20:29Z"
      },
      "message": "change sigops cost to sigops weight",
      "tree": {
        "sha": "d1fc050951f854118a6f993008ded69151519cad",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d1fc050951f854118a6f993008ded69151519cad"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f119ec2700feb574315a04121aaa9632107ae627",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f119ec2700feb574315a04121aaa9632107ae627",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f119ec2700feb574315a04121aaa9632107ae627",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f119ec2700feb574315a04121aaa9632107ae627/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ed64bcec2dde1f4255f3bd5b0c2f01e4dfe260d3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ed64bcec2dde1f4255f3bd5b0c2f01e4dfe260d3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ed64bcec2dde1f4255f3bd5b0c2f01e4dfe260d3"
      }
    ],
    "stats": {
      "total": 189,
      "additions": 94,
      "deletions": 95
    },
    "files": [
      {
        "sha": "49c55b90ddd445f05b97024c6e66fa89aca9c9c2",
        "filename": "qa/rpc-tests/p2p-segwit.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f119ec2700feb574315a04121aaa9632107ae627/qa/rpc-tests/p2p-segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f119ec2700feb574315a04121aaa9632107ae627/qa/rpc-tests/p2p-segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-segwit.py?ref=f119ec2700feb574315a04121aaa9632107ae627",
        "patch": "@@ -19,7 +19,7 @@\n VB_ACTIVATION_THRESHOLD = 108\n VB_TOP_BITS = 0x20000000\n \n-MAX_SIGOP_COST = 80000\n+MAX_SIGOPS_WEIGHT = 80000\n \n '''\n SegWit p2p test.\n@@ -1606,14 +1606,14 @@ def test_witness_sigops(self):\n         # We'll produce 2 extra outputs, one with a program that would take us\n         # over max sig ops, and one with a program that would exactly reach max\n         # sig ops\n-        outputs = (MAX_SIGOP_COST // sigops_per_script) + 2\n-        extra_sigops_available = MAX_SIGOP_COST % sigops_per_script\n+        outputs = (MAX_SIGOPS_WEIGHT // sigops_per_script) + 2\n+        extra_sigops_available = MAX_SIGOPS_WEIGHT % sigops_per_script\n \n         # We chose the number of checkmultisigs/checksigs to make this work:\n         assert(extra_sigops_available < 100) # steer clear of MAX_OPS_PER_SCRIPT\n \n         # This script, when spent with the first\n-        # N(=MAX_SIGOP_COST//sigops_per_script) outputs of our transaction,\n+        # N(=MAX_SIGOPS_WEIGHT//sigops_per_script) outputs of our transaction,\n         # would push us just over the block sigop limit.\n         witness_program_toomany = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKSIG]*(extra_sigops_available + 1) + [OP_ENDIF])\n         witness_hash_toomany = sha256(witness_program_toomany)"
      },
      {
        "sha": "b0331809a5b8a9515dd487bcdfac50d8278ae765",
        "filename": "src/consensus/consensus.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f119ec2700feb574315a04121aaa9632107ae627/src/consensus/consensus.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f119ec2700feb574315a04121aaa9632107ae627/src/consensus/consensus.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/consensus.h?ref=f119ec2700feb574315a04121aaa9632107ae627",
        "patch": "@@ -14,8 +14,8 @@ static const unsigned int MAX_BLOCK_SERIALIZED_SIZE = 4000000;\n static const unsigned int MAX_BLOCK_WEIGHT = 4000000;\n /** The maximum allowed size for a block excluding witness data, in bytes (network rule) */\n static const unsigned int MAX_BLOCK_BASE_SIZE = 1000000;\n-/** The maximum allowed number of signature check operations in a block (network rule) */\n-static const int64_t MAX_BLOCK_SIGOPS_COST = 80000;\n+/** The maximum allowed number of signature check operations in a block, as defined by BIP 141 (network rule) */\n+static const int64_t MAX_BLOCK_SIGOPS_WEIGHT = 80000;\n /** Coinbase transaction outputs can only be spent after this number of new blocks (network rule) */\n static const int COINBASE_MATURITY = 100;\n "
      },
      {
        "sha": "93dd66067d6609a35a1e969491c9f4b81829ac55",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f119ec2700feb574315a04121aaa9632107ae627/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f119ec2700feb574315a04121aaa9632107ae627/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=f119ec2700feb574315a04121aaa9632107ae627",
        "patch": "@@ -1053,7 +1053,7 @@ unsigned int GetP2SHSigOpCount(const CTransaction& tx, const CCoinsViewCache& in\n     return nSigOps;\n }\n \n-int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& inputs, int flags)\n+int64_t GetTransactionSigOpsWeight(const CTransaction& tx, const CCoinsViewCache& inputs, int flags)\n {\n     int64_t nSigOps = GetLegacySigOpCount(tx) * WITNESS_SCALE_FACTOR;\n \n@@ -1295,7 +1295,7 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         if (!tx.wit.IsNull() && fRequireStandard && !IsWitnessStandard(tx, view))\n             return state.DoS(0, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\", true);\n \n-        int64_t nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);\n+        int64_t nSigOpsWeight = GetTransactionSigOpsWeight(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);\n \n         CAmount nValueOut = tx.GetValueOut();\n         CAmount nFees = nValueIn-nValueOut;\n@@ -1318,17 +1318,17 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n             }\n         }\n \n-        CTxMemPoolEntry entry(tx, nFees, nAcceptTime, dPriority, chainActive.Height(), pool.HasNoInputsOf(tx), inChainInputValue, fSpendsCoinbase, nSigOpsCost, lp);\n+        CTxMemPoolEntry entry(tx, nFees, nAcceptTime, dPriority, chainActive.Height(), pool.HasNoInputsOf(tx), inChainInputValue, fSpendsCoinbase, nSigOpsWeight, lp);\n         unsigned int nSize = entry.GetTxSize();\n \n         // Check that the transaction doesn't have an excessive number of\n         // sigops, making it impossible to mine. Since the coinbase transaction\n-        // itself can contain sigops MAX_STANDARD_TX_SIGOPS is less than\n-        // MAX_BLOCK_SIGOPS; we still consider this an invalid rather than\n+        // itself can contain sigops, MAX_STANDARD_TX_SIGOPS_WEIGHT is less than\n+        // MAX_BLOCK_SIGOPS_WEIGHT; we still consider this an invalid rather than\n         // merely non-standard transaction.\n-        if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)\n+        if (nSigOpsWeight > MAX_STANDARD_TX_SIGOPS_WEIGHT)\n             return state.DoS(0, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\", false,\n-                strprintf(\"%d\", nSigOpsCost));\n+                strprintf(\"%d\", nSigOpsWeight));\n \n         CAmount mempoolRejectFee = pool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(nSize);\n         if (mempoolRejectFee > 0 && nModifiedFees < mempoolRejectFee) {\n@@ -2436,7 +2436,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n     std::vector<int> prevheights;\n     CAmount nFees = 0;\n     int nInputs = 0;\n-    int64_t nSigOpsCost = 0;\n+    int64_t nSigOpsWeight = 0;\n     CDiskTxPos pos(pindex->GetBlockPos(), GetSizeOfCompactSize(block.vtx.size()));\n     std::vector<std::pair<uint256, CDiskTxPos> > vPos;\n     vPos.reserve(block.vtx.size());\n@@ -2480,12 +2480,12 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n             }\n         }\n \n-        // GetTransactionSigOpCost counts 3 types of sigops:\n+        // GetTransactionSigOpsWeight counts 3 types of sigops:\n         // * legacy (always)\n         // * p2sh (when P2SH enabled in flags and excludes coinbase)\n         // * witness (when witness enabled in flags and excludes coinbase)\n-        nSigOpsCost += GetTransactionSigOpCost(tx, view, flags);\n-        if (nSigOpsCost > MAX_BLOCK_SIGOPS_COST)\n+        nSigOpsWeight += GetTransactionSigOpsWeight(tx, view, flags);\n+        if (nSigOpsWeight > MAX_BLOCK_SIGOPS_WEIGHT)\n             return state.DoS(100, error(\"ConnectBlock(): too many sigops\"),\n                              REJECT_INVALID, \"bad-blk-sigops\");\n \n@@ -3442,7 +3442,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n     {\n         nSigOps += GetLegacySigOpCount(tx);\n     }\n-    if (nSigOps * WITNESS_SCALE_FACTOR > MAX_BLOCK_SIGOPS_COST)\n+    if (nSigOps * WITNESS_SCALE_FACTOR > MAX_BLOCK_SIGOPS_WEIGHT)\n         return state.DoS(100, false, REJECT_INVALID, \"bad-blk-sigops\", false, \"out-of-bounds SigOpCount\");\n \n     if (fCheckPOW && fCheckMerkleRoot)"
      },
      {
        "sha": "230edef06fafbecd3d94558a096d7b58893c3066",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f119ec2700feb574315a04121aaa9632107ae627/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f119ec2700feb574315a04121aaa9632107ae627/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=f119ec2700feb574315a04121aaa9632107ae627",
        "patch": "@@ -327,7 +327,7 @@ unsigned int GetP2SHSigOpCount(const CTransaction& tx, const CCoinsViewCache& ma\n  * @param[out] flags Script verification flags\n  * @return Total signature operation cost of tx\n  */\n-int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& inputs, int flags);\n+int64_t GetTransactionSigOpsWeight(const CTransaction& tx, const CCoinsViewCache& inputs, int flags);\n \n /**\n  * Check whether all inputs of this transaction are valid (no double spends, scripts & sigs, amounts)"
      },
      {
        "sha": "25d60547cf62f90adf890379a811c67d170d58a8",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f119ec2700feb574315a04121aaa9632107ae627/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f119ec2700feb574315a04121aaa9632107ae627/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=f119ec2700feb574315a04121aaa9632107ae627",
        "patch": "@@ -112,7 +112,7 @@ void BlockAssembler::resetBlock()\n     // Reserve space for coinbase tx\n     nBlockSize = 1000;\n     nBlockWeight = 4000;\n-    nBlockSigOpsCost = 400;\n+    nBlockSigOpsWeight = 400;\n     fIncludeWitness = false;\n \n     // These counters do not include coinbase tx\n@@ -136,7 +136,7 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc\n     // Add dummy coinbase tx as first transaction\n     pblock->vtx.push_back(CTransaction());\n     pblocktemplate->vTxFees.push_back(-1); // updated at end\n-    pblocktemplate->vTxSigOpsCost.push_back(-1); // updated at end\n+    pblocktemplate->vTxSigOpsWeight.push_back(-1); // updated at end\n \n     LOCK2(cs_main, mempool.cs);\n     CBlockIndex* pindexPrev = chainActive.Tip();\n@@ -169,7 +169,7 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc\n     nLastBlockTx = nBlockTx;\n     nLastBlockSize = nBlockSize;\n     nLastBlockWeight = nBlockWeight;\n-    LogPrintf(\"CreateNewBlock(): total size %u txs: %u fees: %ld sigops %d\\n\", nBlockSize, nBlockTx, nFees, nBlockSigOpsCost);\n+    LogPrintf(\"CreateNewBlock(): total size %u txs: %u fees: %ld sigops %d\\n\", nBlockSize, nBlockTx, nFees, nBlockSigOpsWeight);\n \n     // Create coinbase transaction.\n     CMutableTransaction coinbaseTx;\n@@ -188,7 +188,7 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc\n     UpdateTime(pblock, chainparams.GetConsensus(), pindexPrev);\n     pblock->nBits          = GetNextWorkRequired(pindexPrev, pblock, chainparams.GetConsensus());\n     pblock->nNonce         = 0;\n-    pblocktemplate->vTxSigOpsCost[0] = WITNESS_SCALE_FACTOR * GetLegacySigOpCount(pblock->vtx[0]);\n+    pblocktemplate->vTxSigOpsWeight[0] = WITNESS_SCALE_FACTOR * GetLegacySigOpCount(pblock->vtx[0]);\n \n     CValidationState state;\n     if (!TestBlockValidity(state, chainparams, *pblock, pindexPrev, false, false)) {\n@@ -222,12 +222,12 @@ void BlockAssembler::onlyUnconfirmed(CTxMemPool::setEntries& testSet)\n     }\n }\n \n-bool BlockAssembler::TestPackage(uint64_t packageSize, int64_t packageSigOpsCost)\n+bool BlockAssembler::TestPackage(uint64_t packageSize, int64_t packageSigOpsWeight)\n {\n     // TODO: switch to weight-based accounting for packages instead of vsize-based accounting.\n     if (nBlockWeight + WITNESS_SCALE_FACTOR * packageSize >= nBlockMaxWeight)\n         return false;\n-    if (nBlockSigOpsCost + packageSigOpsCost >= MAX_BLOCK_SIGOPS_COST)\n+    if (nBlockSigOpsWeight + packageSigOpsWeight >= MAX_BLOCK_SIGOPS_WEIGHT)\n         return false;\n     return true;\n }\n@@ -287,10 +287,10 @@ bool BlockAssembler::TestForBlock(CTxMemPool::txiter iter)\n         }\n     }\n \n-    if (nBlockSigOpsCost + iter->GetSigOpCost() >= MAX_BLOCK_SIGOPS_COST) {\n+    if (nBlockSigOpsWeight + iter->GetSigOpsWeight() >= MAX_BLOCK_SIGOPS_WEIGHT) {\n         // If the block has room for no more sig ops then\n         // flag that the block is finished\n-        if (nBlockSigOpsCost > MAX_BLOCK_SIGOPS_COST - 8) {\n+        if (nBlockSigOpsWeight > MAX_BLOCK_SIGOPS_WEIGHT - 8) {\n             blockFinished = true;\n             return false;\n         }\n@@ -312,13 +312,13 @@ void BlockAssembler::AddToBlock(CTxMemPool::txiter iter)\n {\n     pblock->vtx.push_back(iter->GetTx());\n     pblocktemplate->vTxFees.push_back(iter->GetFee());\n-    pblocktemplate->vTxSigOpsCost.push_back(iter->GetSigOpCost());\n+    pblocktemplate->vTxSigOpsWeight.push_back(iter->GetSigOpsWeight());\n     if (fNeedSizeAccounting) {\n         nBlockSize += ::GetSerializeSize(iter->GetTx(), SER_NETWORK, PROTOCOL_VERSION);\n     }\n     nBlockWeight += iter->GetTxWeight();\n     ++nBlockTx;\n-    nBlockSigOpsCost += iter->GetSigOpCost();\n+    nBlockSigOpsWeight += iter->GetSigOpsWeight();\n     nFees += iter->GetFee();\n     inBlock.insert(iter);\n \n@@ -349,7 +349,7 @@ void BlockAssembler::UpdatePackagesForAdded(const CTxMemPool::setEntries& alread\n                 CTxMemPoolModifiedEntry modEntry(desc);\n                 modEntry.nSizeWithAncestors -= it->GetTxSize();\n                 modEntry.nModFeesWithAncestors -= it->GetModifiedFee();\n-                modEntry.nSigOpCostWithAncestors -= it->GetSigOpCost();\n+                modEntry.nSigOpsWeightWithAncestors -= it->GetSigOpsWeight();\n                 mapModifiedTx.insert(modEntry);\n             } else {\n                 mapModifiedTx.modify(mit, update_for_parent_inclusion(it));\n@@ -451,19 +451,19 @@ void BlockAssembler::addPackageTxs()\n \n         uint64_t packageSize = iter->GetSizeWithAncestors();\n         CAmount packageFees = iter->GetModFeesWithAncestors();\n-        int64_t packageSigOpsCost = iter->GetSigOpCostWithAncestors();\n+        int64_t packageSigOpsWeight = iter->GetSigOpsWeightWithAncestors();\n         if (fUsingModified) {\n             packageSize = modit->nSizeWithAncestors;\n             packageFees = modit->nModFeesWithAncestors;\n-            packageSigOpsCost = modit->nSigOpCostWithAncestors;\n+            packageSigOpsWeight = modit->nSigOpsWeightWithAncestors;\n         }\n \n         if (packageFees < ::minRelayTxFee.GetFee(packageSize)) {\n             // Everything else we might consider has a lower fee rate\n             return;\n         }\n \n-        if (!TestPackage(packageSize, packageSigOpsCost)) {\n+        if (!TestPackage(packageSize, packageSigOpsWeight)) {\n             if (fUsingModified) {\n                 // Since we always look at the best entry in mapModifiedTx,\n                 // we must erase failed entries so that we can consider the"
      },
      {
        "sha": "b9947dba82ce90b6c768f122a2bb01446def2663",
        "filename": "src/miner.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f119ec2700feb574315a04121aaa9632107ae627/src/miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f119ec2700feb574315a04121aaa9632107ae627/src/miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.h?ref=f119ec2700feb574315a04121aaa9632107ae627",
        "patch": "@@ -28,7 +28,7 @@ struct CBlockTemplate\n {\n     CBlock block;\n     std::vector<CAmount> vTxFees;\n-    std::vector<int64_t> vTxSigOpsCost;\n+    std::vector<int64_t> vTxSigOpsWeight;\n     std::vector<unsigned char> vchCoinbaseCommitment;\n };\n \n@@ -40,13 +40,13 @@ struct CTxMemPoolModifiedEntry {\n         iter = entry;\n         nSizeWithAncestors = entry->GetSizeWithAncestors();\n         nModFeesWithAncestors = entry->GetModFeesWithAncestors();\n-        nSigOpCostWithAncestors = entry->GetSigOpCostWithAncestors();\n+        nSigOpsWeightWithAncestors = entry->GetSigOpsWeightWithAncestors();\n     }\n \n     CTxMemPool::txiter iter;\n     uint64_t nSizeWithAncestors;\n     CAmount nModFeesWithAncestors;\n-    int64_t nSigOpCostWithAncestors;\n+    int64_t nSigOpsWeightWithAncestors;\n };\n \n /** Comparator for CTxMemPool::txiter objects.\n@@ -124,7 +124,7 @@ struct update_for_parent_inclusion\n     {\n         e.nModFeesWithAncestors -= iter->GetFee();\n         e.nSizeWithAncestors -= iter->GetTxSize();\n-        e.nSigOpCostWithAncestors -= iter->GetSigOpCost();\n+        e.nSigOpsWeightWithAncestors -= iter->GetSigOpsWeight();\n     }\n \n     CTxMemPool::txiter iter;\n@@ -148,7 +148,7 @@ class BlockAssembler\n     uint64_t nBlockWeight;\n     uint64_t nBlockSize;\n     uint64_t nBlockTx;\n-    uint64_t nBlockSigOpsCost;\n+    uint64_t nBlockSigOpsWeight;\n     CAmount nFees;\n     CTxMemPool::setEntries inBlock;\n \n@@ -189,7 +189,7 @@ class BlockAssembler\n     /** Remove confirmed (inBlock) entries from given set */\n     void onlyUnconfirmed(CTxMemPool::setEntries& testSet);\n     /** Test if a new package would \"fit\" in the block */\n-    bool TestPackage(uint64_t packageSize, int64_t packageSigOpsCost);\n+    bool TestPackage(uint64_t packageSize, int64_t packageSigOpsWeight);\n     /** Perform checks on each transaction in a package:\n       * locktime, premature-witness, serialized size (if necessary)\n       * These checks should always succeed, and they're here"
      },
      {
        "sha": "279230d172d9ef1330045abdf5bc66774847253c",
        "filename": "src/policy/policy.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f119ec2700feb574315a04121aaa9632107ae627/src/policy/policy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f119ec2700feb574315a04121aaa9632107ae627/src/policy/policy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.cpp?ref=f119ec2700feb574315a04121aaa9632107ae627",
        "patch": "@@ -208,12 +208,12 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n \n unsigned int nBytesPerSigOp = DEFAULT_BYTES_PER_SIGOP;\n \n-int64_t GetVirtualTransactionSize(int64_t nWeight, int64_t nSigOpCost)\n+int64_t GetVirtualTransactionSize(int64_t nWeight, int64_t nSigOpsWeight)\n {\n-    return (std::max(nWeight, nSigOpCost * nBytesPerSigOp) + WITNESS_SCALE_FACTOR - 1) / WITNESS_SCALE_FACTOR;\n+    return (std::max(nWeight, nSigOpsWeight * nBytesPerSigOp) + WITNESS_SCALE_FACTOR - 1) / WITNESS_SCALE_FACTOR;\n }\n \n-int64_t GetVirtualTransactionSize(const CTransaction& tx, int64_t nSigOpCost)\n+int64_t GetVirtualTransactionSize(const CTransaction& tx, int64_t nSigOpsWeight)\n {\n-    return GetVirtualTransactionSize(GetTransactionWeight(tx), nSigOpCost);\n+    return GetVirtualTransactionSize(GetTransactionWeight(tx), nSigOpsWeight);\n }"
      },
      {
        "sha": "f6ca175ce4557022c8a34049c651bdd861683305",
        "filename": "src/policy/policy.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f119ec2700feb574315a04121aaa9632107ae627/src/policy/policy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f119ec2700feb574315a04121aaa9632107ae627/src/policy/policy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.h?ref=f119ec2700feb574315a04121aaa9632107ae627",
        "patch": "@@ -25,7 +25,7 @@ static const unsigned int MAX_STANDARD_TX_WEIGHT = 400000;\n /** Maximum number of signature check operations in an IsStandard() P2SH script */\n static const unsigned int MAX_P2SH_SIGOPS = 15;\n /** The maximum number of sigops we're willing to relay/mine in a single tx */\n-static const unsigned int MAX_STANDARD_TX_SIGOPS_COST = MAX_BLOCK_SIGOPS_COST/5;\n+static const unsigned int MAX_STANDARD_TX_SIGOPS_WEIGHT = MAX_BLOCK_SIGOPS_WEIGHT/5;\n /** Default for -maxmempool, maximum megabytes of mempool memory usage */\n static const unsigned int DEFAULT_MAX_MEMPOOL_SIZE = 300;\n /** Default for -bytespersigop */\n@@ -86,7 +86,7 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n extern unsigned int nBytesPerSigOp;\n \n /** Compute the virtual transaction size (weight reinterpreted as bytes). */\n-int64_t GetVirtualTransactionSize(int64_t nWeight, int64_t nSigOpCost);\n-int64_t GetVirtualTransactionSize(const CTransaction& tx, int64_t nSigOpCost = 0);\n+int64_t GetVirtualTransactionSize(int64_t nWeight, int64_t nSigOpsWeight);\n+int64_t GetVirtualTransactionSize(const CTransaction& tx, int64_t nSigOpsWeight = 0);\n \n #endif // BITCOIN_POLICY_POLICY_H"
      },
      {
        "sha": "28819f42eaa5fca78559dead42eccf6d4b38daf4",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f119ec2700feb574315a04121aaa9632107ae627/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f119ec2700feb574315a04121aaa9632107ae627/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=f119ec2700feb574315a04121aaa9632107ae627",
        "patch": "@@ -363,7 +363,7 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n             \"             ,...\\n\"\n             \"         ],\\n\"\n             \"         \\\"fee\\\": n,                    (numeric) difference in value between transaction inputs and outputs (in Satoshis); for coinbase transactions, this is a negative Number of the total collected block fees (ie, not including the block subsidy); if key is not present, fee is unknown and clients MUST NOT assume there isn't one\\n\"\n-            \"         \\\"sigops\\\" : n,                (numeric) total SigOps cost, as counted for purposes of block limits; if key is not present, sigop cost is unknown and clients MUST NOT assume it is zero\\n\"\n+            \"         \\\"sigops\\\" : n,                (numeric) total SigOps weight, as counted for purposes of block limits; if key is not present, sigop weight is unknown and clients MUST NOT assume it is zero\\n\"\n             \"         \\\"weight\\\" : n,                (numeric) total transaction weight, as counted for purposes of block limits\\n\"\n             \"         \\\"required\\\" : true|false      (boolean) if provided and true, this transaction must be in the final block\\n\"\n             \"      }\\n\"\n@@ -380,8 +380,7 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n             \"     \\\"value\\\"                          (string) A way the block template may be changed, e.g. 'time', 'transactions', 'prevblock'\\n\"\n             \"     ,...\\n\"\n             \"  ],\\n\"\n-            \"  \\\"noncerange\\\" : \\\"00000000ffffffff\\\",(string) A range of valid nonces\\n\"\n-            \"  \\\"sigoplimit\\\" : n,                 (numeric) limit of sigops in blocks\\n\"\n+            \"  \\\"sigoplimit\\\" : n,                 (numeric) weight limit of sigops in blocks\\n\"\n             \"  \\\"sizelimit\\\" : n,                  (numeric) limit of block size\\n\"\n             \"  \\\"weightlimit\\\" : n,                (numeric) limit of block weight\\n\"\n             \"  \\\"curtime\\\" : ttt,                  (numeric) current timestamp in seconds since epoch (Jan 1 1970 GMT)\\n\"\n@@ -581,7 +580,7 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n \n         int index_in_template = i - 1;\n         entry.push_back(Pair(\"fee\", pblocktemplate->vTxFees[index_in_template]));\n-        int64_t nTxSigOps = pblocktemplate->vTxSigOpsCost[index_in_template];\n+        int64_t nTxSigOps = pblocktemplate->vTxSigOpsWeight[index_in_template];\n         if (fPreSegWit) {\n             assert(nTxSigOps % WITNESS_SCALE_FACTOR == 0);\n             nTxSigOps /= WITNESS_SCALE_FACTOR;\n@@ -669,7 +668,7 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n     result.push_back(Pair(\"mintime\", (int64_t)pindexPrev->GetMedianTimePast()+1));\n     result.push_back(Pair(\"mutable\", aMutable));\n     result.push_back(Pair(\"noncerange\", \"00000000ffffffff\"));\n-    int64_t nSigOpLimit = MAX_BLOCK_SIGOPS_COST;\n+    int64_t nSigOpLimit = MAX_BLOCK_SIGOPS_WEIGHT;\n     if (fPreSegWit) {\n         assert(nSigOpLimit % WITNESS_SCALE_FACTOR == 0);\n         nSigOpLimit /= WITNESS_SCALE_FACTOR;"
      },
      {
        "sha": "f290701974baa08ab48b51ef68324679b777cc45",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f119ec2700feb574315a04121aaa9632107ae627/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f119ec2700feb574315a04121aaa9632107ae627/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=f119ec2700feb574315a04121aaa9632107ae627",
        "patch": "@@ -264,7 +264,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         hash = tx.GetHash();\n         bool spendsCoinbase = (i == 0) ? true : false; // only first tx spends coinbase\n         // If we do set the # of sig ops in the CTxMemPoolEntry, template creation passes\n-        mempool.addUnchecked(hash, entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).SigOpsCost(80).FromTx(tx));\n+        mempool.addUnchecked(hash, entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).SigOpsWeight(80).FromTx(tx));\n         tx.vin[0].prevout.hash = hash;\n     }\n     BOOST_CHECK(pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));"
      },
      {
        "sha": "e4e309e7f8e342a3a655a364a3217dfde19fa83a",
        "filename": "src/test/sigopcount_tests.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f119ec2700feb574315a04121aaa9632107ae627/src/test/sigopcount_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f119ec2700feb574315a04121aaa9632107ae627/src/test/sigopcount_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sigopcount_tests.cpp?ref=f119ec2700feb574315a04121aaa9632107ae627",
        "patch": "@@ -109,12 +109,12 @@ void BuildTxs(CMutableTransaction& spendingTx, CCoinsViewCache& coins, CMutableT\n     coins.ModifyCoins(creationTx.GetHash())->FromTx(creationTx, 0);\n }\n \n-BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n+BOOST_AUTO_TEST_CASE(GetTxSigOpsWeight)\n {\n     // Transaction creates outputs\n     CMutableTransaction creationTx;\n     // Transaction that spends outputs and whose\n-    // sig op cost is going to be tested\n+    // sig ops weight is going to be tested\n     CMutableTransaction spendingTx;\n \n     // Create utxo set\n@@ -137,10 +137,10 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n         // Legacy counting only includes signature operations in scriptSigs and scriptPubKeys\n         // of a transaction and does not take the actual executed sig operations into account.\n         // spendingTx in itself does not contain a signature operation.\n-        assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 0);\n+        assert(GetTransactionSigOpsWeight(CTransaction(spendingTx), coins, flags) == 0);\n         // creationTx contains two signature operations in its scriptPubKey, but legacy counting\n         // is not accurate.\n-        assert(GetTransactionSigOpCost(CTransaction(creationTx), coins, flags) == MAX_PUBKEYS_PER_MULTISIG * WITNESS_SCALE_FACTOR);\n+        assert(GetTransactionSigOpsWeight(CTransaction(creationTx), coins, flags) == MAX_PUBKEYS_PER_MULTISIG * WITNESS_SCALE_FACTOR);\n         // Sanity check: script verification fails because of an invalid signature.\n         assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n     }\n@@ -152,7 +152,7 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n         CScript scriptSig = CScript() << OP_0 << OP_0 << ToByteVector(redeemScript);\n \n         BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, CTxInWitness());\n-        assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 2 * WITNESS_SCALE_FACTOR);\n+        assert(GetTransactionSigOpsWeight(CTransaction(spendingTx), coins, flags) == 2 * WITNESS_SCALE_FACTOR);\n         assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n     }\n \n@@ -169,22 +169,22 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n \n \n         BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, witness);\n-        assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 1);\n+        assert(GetTransactionSigOpsWeight(CTransaction(spendingTx), coins, flags) == 1);\n         // No signature operations if we don't verify the witness.\n-        assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags & ~SCRIPT_VERIFY_WITNESS) == 0);\n+        assert(GetTransactionSigOpsWeight(CTransaction(spendingTx), coins, flags & ~SCRIPT_VERIFY_WITNESS) == 0);\n         assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_EQUALVERIFY);\n \n-        // The sig op cost for witness version != 0 is zero.\n+        // The sig ops weight for witness version != 0 is zero.\n         assert(scriptPubKey[0] == 0x00);\n         scriptPubKey[0] = 0x51;\n         BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, witness);\n-        assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 0);\n+        assert(GetTransactionSigOpsWeight(CTransaction(spendingTx), coins, flags) == 0);\n         scriptPubKey[0] = 0x00;\n         BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, witness);\n \n         // The witness of a coinbase transaction is not taken into account.\n         spendingTx.vin[0].prevout.SetNull();\n-        assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 0);\n+        assert(GetTransactionSigOpsWeight(CTransaction(spendingTx), coins, flags) == 0);\n     }\n \n     // P2WPKH nested in P2SH\n@@ -200,7 +200,7 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n         witness.scriptWitness = scriptWitness;\n \n         BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, witness);\n-        assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 1);\n+        assert(GetTransactionSigOpsWeight(CTransaction(spendingTx), coins, flags) == 1);\n         assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_EQUALVERIFY);\n     }\n \n@@ -217,8 +217,8 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n         witness.scriptWitness = scriptWitness;\n \n         BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, witness);\n-        assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 2);\n-        assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags & ~SCRIPT_VERIFY_WITNESS) == 0);\n+        assert(GetTransactionSigOpsWeight(CTransaction(spendingTx), coins, flags) == 2);\n+        assert(GetTransactionSigOpsWeight(CTransaction(spendingTx), coins, flags & ~SCRIPT_VERIFY_WITNESS) == 0);\n         assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n     }\n \n@@ -236,7 +236,7 @@ BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n         witness.scriptWitness = scriptWitness;\n \n         BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, witness);\n-        assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 2);\n+        assert(GetTransactionSigOpsWeight(CTransaction(spendingTx), coins, flags) == 2);\n         assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n     }\n }"
      },
      {
        "sha": "40fcdaecaa308f244d0dbbdf92a2b1e551b74f33",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f119ec2700feb574315a04121aaa9632107ae627/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f119ec2700feb574315a04121aaa9632107ae627/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=f119ec2700feb574315a04121aaa9632107ae627",
        "patch": "@@ -149,7 +149,7 @@ CTxMemPoolEntry TestMemPoolEntryHelper::FromTx(CTransaction &txn, CTxMemPool *po\n     CAmount inChainValue = hasNoDependencies ? txn.GetValueOut() : 0;\n \n     return CTxMemPoolEntry(txn, nFee, nTime, dPriority, nHeight,\n-                           hasNoDependencies, inChainValue, spendsCoinbase, sigOpCost, lp);\n+                           hasNoDependencies, inChainValue, spendsCoinbase, sigOpsWeight, lp);\n }\n \n void Shutdown(void* parg)"
      },
      {
        "sha": "591240a9f17fa0f9a64b9911afed6612510a1eb9",
        "filename": "src/test/test_bitcoin.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f119ec2700feb574315a04121aaa9632107ae627/src/test/test_bitcoin.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f119ec2700feb574315a04121aaa9632107ae627/src/test/test_bitcoin.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.h?ref=f119ec2700feb574315a04121aaa9632107ae627",
        "patch": "@@ -72,12 +72,12 @@ struct TestMemPoolEntryHelper\n     unsigned int nHeight;\n     bool hadNoDependencies;\n     bool spendsCoinbase;\n-    unsigned int sigOpCost;\n+    unsigned int sigOpsWeight;\n     LockPoints lp;\n \n     TestMemPoolEntryHelper() :\n         nFee(0), nTime(0), dPriority(0.0), nHeight(1),\n-        hadNoDependencies(false), spendsCoinbase(false), sigOpCost(4) { }\n+        hadNoDependencies(false), spendsCoinbase(false), sigOpsWeight(4) { }\n     \n     CTxMemPoolEntry FromTx(CMutableTransaction &tx, CTxMemPool *pool = NULL);\n     CTxMemPoolEntry FromTx(CTransaction &tx, CTxMemPool *pool = NULL);\n@@ -89,6 +89,6 @@ struct TestMemPoolEntryHelper\n     TestMemPoolEntryHelper &Height(unsigned int _height) { nHeight = _height; return *this; }\n     TestMemPoolEntryHelper &HadNoDependencies(bool _hnd) { hadNoDependencies = _hnd; return *this; }\n     TestMemPoolEntryHelper &SpendsCoinbase(bool _flag) { spendsCoinbase = _flag; return *this; }\n-    TestMemPoolEntryHelper &SigOpsCost(unsigned int _sigopsCost) { sigOpCost = _sigopsCost; return *this; }\n+    TestMemPoolEntryHelper &SigOpsWeight(unsigned int _sigOpsWeight) { sigOpsWeight = _sigOpsWeight; return *this; }\n };\n #endif"
      },
      {
        "sha": "e7eaee3d53927cf0afffea3531c54da238acb1f6",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f119ec2700feb574315a04121aaa9632107ae627/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f119ec2700feb574315a04121aaa9632107ae627/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=f119ec2700feb574315a04121aaa9632107ae627",
        "patch": "@@ -23,10 +23,10 @@ using namespace std;\n CTxMemPoolEntry::CTxMemPoolEntry(const CTransaction& _tx, const CAmount& _nFee,\n                                  int64_t _nTime, double _entryPriority, unsigned int _entryHeight,\n                                  bool poolHasNoInputsOf, CAmount _inChainInputValue,\n-                                 bool _spendsCoinbase, int64_t _sigOpsCost, LockPoints lp):\n+                                 bool _spendsCoinbase, int64_t _sigOpsWeight, LockPoints lp):\n     tx(std::make_shared<CTransaction>(_tx)), nFee(_nFee), nTime(_nTime), entryPriority(_entryPriority), entryHeight(_entryHeight),\n     hadNoDependencies(poolHasNoInputsOf), inChainInputValue(_inChainInputValue),\n-    spendsCoinbase(_spendsCoinbase), sigOpCost(_sigOpsCost), lockPoints(lp)\n+    spendsCoinbase(_spendsCoinbase), sigOpsWeight(_sigOpsWeight), lockPoints(lp)\n {\n     nTxWeight = GetTransactionWeight(_tx);\n     nModSize = _tx.CalculateModifiedSize(GetTxSize());\n@@ -43,7 +43,7 @@ CTxMemPoolEntry::CTxMemPoolEntry(const CTransaction& _tx, const CAmount& _nFee,\n     nCountWithAncestors = 1;\n     nSizeWithAncestors = GetTxSize();\n     nModFeesWithAncestors = nFee;\n-    nSigOpCostWithAncestors = sigOpCost;\n+    nSigOpsWeightWithAncestors = sigOpsWeight;\n }\n \n CTxMemPoolEntry::CTxMemPoolEntry(const CTxMemPoolEntry& other)\n@@ -75,7 +75,7 @@ void CTxMemPoolEntry::UpdateLockPoints(const LockPoints& lp)\n \n size_t CTxMemPoolEntry::GetTxSize() const\n {\n-    return GetVirtualTransactionSize(nTxWeight, sigOpCost);\n+    return GetVirtualTransactionSize(nTxWeight, sigOpsWeight);\n }\n \n // Update the given tx for any in-mempool descendants.\n@@ -117,7 +117,7 @@ void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendan\n             modifyCount++;\n             cachedDescendants[updateIt].insert(cit);\n             // Update ancestor state for each descendant\n-            mapTx.modify(cit, update_ancestor_state(updateIt->GetTxSize(), updateIt->GetModifiedFee(), 1, updateIt->GetSigOpCost()));\n+            mapTx.modify(cit, update_ancestor_state(updateIt->GetTxSize(), updateIt->GetModifiedFee(), 1, updateIt->GetSigOpsWeight()));\n         }\n     }\n     mapTx.modify(updateIt, update_descendant_state(modifySize, modifyFee, modifyCount));\n@@ -253,13 +253,13 @@ void CTxMemPool::UpdateEntryForAncestors(txiter it, const setEntries &setAncesto\n     int64_t updateCount = setAncestors.size();\n     int64_t updateSize = 0;\n     CAmount updateFee = 0;\n-    int64_t updateSigOpsCost = 0;\n+    int64_t updateSigOpsWeight = 0;\n     BOOST_FOREACH(txiter ancestorIt, setAncestors) {\n         updateSize += ancestorIt->GetTxSize();\n         updateFee += ancestorIt->GetModifiedFee();\n-        updateSigOpsCost += ancestorIt->GetSigOpCost();\n+        updateSigOpsWeight += ancestorIt->GetSigOpsWeight();\n     }\n-    mapTx.modify(it, update_ancestor_state(updateSize, updateFee, updateCount, updateSigOpsCost));\n+    mapTx.modify(it, update_ancestor_state(updateSize, updateFee, updateCount, updateSigOpsWeight));\n }\n \n void CTxMemPool::UpdateChildrenForRemoval(txiter it)\n@@ -288,7 +288,7 @@ void CTxMemPool::UpdateForRemoveFromMempool(const setEntries &entriesToRemove, b\n             setDescendants.erase(removeIt); // don't update state for self\n             int64_t modifySize = -((int64_t)removeIt->GetTxSize());\n             CAmount modifyFee = -removeIt->GetModifiedFee();\n-            int modifySigOps = -removeIt->GetSigOpCost();\n+            int modifySigOps = -removeIt->GetSigOpsWeight();\n             BOOST_FOREACH(txiter dit, setDescendants) {\n                 mapTx.modify(dit, update_ancestor_state(modifySize, modifyFee, -1, modifySigOps));\n             }\n@@ -344,8 +344,8 @@ void CTxMemPoolEntry::UpdateAncestorState(int64_t modifySize, CAmount modifyFee,\n     nModFeesWithAncestors += modifyFee;\n     nCountWithAncestors += modifyCount;\n     assert(int64_t(nCountWithAncestors) > 0);\n-    nSigOpCostWithAncestors += modifySigOps;\n-    assert(int(nSigOpCostWithAncestors) >= 0);\n+    nSigOpsWeightWithAncestors += modifySigOps;\n+    assert(int(nSigOpsWeightWithAncestors) >= 0);\n }\n \n CTxMemPool::CTxMemPool(const CFeeRate& _minReasonableRelayFee) :\n@@ -675,7 +675,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n         bool fDependsWait = false;\n         setEntries setParentCheck;\n         int64_t parentSizes = 0;\n-        int64_t parentSigOpCost = 0;\n+        int64_t parentSigOpsWeight = 0;\n         BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n             // Check that every mempool transaction's inputs refer to available coins, or other mempool tx's.\n             indexed_transaction_set::const_iterator it2 = mapTx.find(txin.prevout.hash);\n@@ -685,7 +685,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n                 fDependsWait = true;\n                 if (setParentCheck.insert(it2).second) {\n                     parentSizes += it2->GetTxSize();\n-                    parentSigOpCost += it2->GetSigOpCost();\n+                    parentSigOpsWeight += it2->GetSigOpsWeight();\n                 }\n             } else {\n                 const CCoins* coins = pcoins->AccessCoins(txin.prevout.hash);\n@@ -707,17 +707,17 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n         uint64_t nCountCheck = setAncestors.size() + 1;\n         uint64_t nSizeCheck = it->GetTxSize();\n         CAmount nFeesCheck = it->GetModifiedFee();\n-        int64_t nSigOpCheck = it->GetSigOpCost();\n+        int64_t nSigOpCheck = it->GetSigOpsWeight();\n \n         BOOST_FOREACH(txiter ancestorIt, setAncestors) {\n             nSizeCheck += ancestorIt->GetTxSize();\n             nFeesCheck += ancestorIt->GetModifiedFee();\n-            nSigOpCheck += ancestorIt->GetSigOpCost();\n+            nSigOpCheck += ancestorIt->GetSigOpsWeight();\n         }\n \n         assert(it->GetCountWithAncestors() == nCountCheck);\n         assert(it->GetSizeWithAncestors() == nSizeCheck);\n-        assert(it->GetSigOpCostWithAncestors() == nSigOpCheck);\n+        assert(it->GetSigOpsWeightWithAncestors() == nSigOpCheck);\n         assert(it->GetModFeesWithAncestors() == nFeesCheck);\n \n         // Check children against mapNextTx"
      },
      {
        "sha": "6683bcf91a9a6260d8c571bdca733d9cf5f8eeb2",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f119ec2700feb574315a04121aaa9632107ae627/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f119ec2700feb574315a04121aaa9632107ae627/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=f119ec2700feb574315a04121aaa9632107ae627",
        "patch": "@@ -91,7 +91,7 @@ class CTxMemPoolEntry\n     bool hadNoDependencies;    //!< Not dependent on any other txs when it entered the mempool\n     CAmount inChainInputValue; //!< Sum of all txin values that are already in blockchain\n     bool spendsCoinbase;       //!< keep track of transactions that spend a coinbase\n-    int64_t sigOpCost;         //!< Total sigop cost\n+    int64_t sigOpsWeight;      //!< Total sigops weight\n     int64_t feeDelta;          //!< Used for determining the priority of the transaction for mining in a block\n     LockPoints lockPoints;     //!< Track the height and time at which tx was final\n \n@@ -108,13 +108,13 @@ class CTxMemPoolEntry\n     uint64_t nCountWithAncestors;\n     uint64_t nSizeWithAncestors;\n     CAmount nModFeesWithAncestors;\n-    int64_t nSigOpCostWithAncestors;\n+    int64_t nSigOpsWeightWithAncestors;\n \n public:\n     CTxMemPoolEntry(const CTransaction& _tx, const CAmount& _nFee,\n                     int64_t _nTime, double _entryPriority, unsigned int _entryHeight,\n                     bool poolHasNoInputsOf, CAmount _inChainInputValue, bool spendsCoinbase,\n-                    int64_t nSigOpsCost, LockPoints lp);\n+                    int64_t nSigOpsWeight, LockPoints lp);\n     CTxMemPoolEntry(const CTxMemPoolEntry& other);\n \n     const CTransaction& GetTx() const { return *this->tx; }\n@@ -130,7 +130,7 @@ class CTxMemPoolEntry\n     int64_t GetTime() const { return nTime; }\n     unsigned int GetHeight() const { return entryHeight; }\n     bool WasClearAtEntry() const { return hadNoDependencies; }\n-    int64_t GetSigOpCost() const { return sigOpCost; }\n+    int64_t GetSigOpsWeight() const { return sigOpsWeight; }\n     int64_t GetModifiedFee() const { return nFee + feeDelta; }\n     size_t DynamicMemoryUsage() const { return nUsageSize; }\n     const LockPoints& GetLockPoints() const { return lockPoints; }\n@@ -154,7 +154,7 @@ class CTxMemPoolEntry\n     uint64_t GetCountWithAncestors() const { return nCountWithAncestors; }\n     uint64_t GetSizeWithAncestors() const { return nSizeWithAncestors; }\n     CAmount GetModFeesWithAncestors() const { return nModFeesWithAncestors; }\n-    int64_t GetSigOpCostWithAncestors() const { return nSigOpCostWithAncestors; }\n+    int64_t GetSigOpsWeightWithAncestors() const { return nSigOpsWeightWithAncestors; }\n \n     mutable size_t vTxHashesIdx; //!< Index in mempool's vTxHashes\n };\n@@ -177,18 +177,18 @@ struct update_descendant_state\n \n struct update_ancestor_state\n {\n-    update_ancestor_state(int64_t _modifySize, CAmount _modifyFee, int64_t _modifyCount, int64_t _modifySigOpsCost) :\n-        modifySize(_modifySize), modifyFee(_modifyFee), modifyCount(_modifyCount), modifySigOpsCost(_modifySigOpsCost)\n+    update_ancestor_state(int64_t _modifySize, CAmount _modifyFee, int64_t _modifyCount, int64_t _modifySigOpsWeight) :\n+        modifySize(_modifySize), modifyFee(_modifyFee), modifyCount(_modifyCount), modifySigOpsWeight(_modifySigOpsWeight)\n     {}\n \n     void operator() (CTxMemPoolEntry &e)\n-        { e.UpdateAncestorState(modifySize, modifyFee, modifyCount, modifySigOpsCost); }\n+        { e.UpdateAncestorState(modifySize, modifyFee, modifyCount, modifySigOpsWeight); }\n \n     private:\n         int64_t modifySize;\n         CAmount modifyFee;\n         int64_t modifyCount;\n-        int64_t modifySigOpsCost;\n+        int64_t modifySigOpsWeight;\n };\n \n struct update_fee_delta"
      }
    ]
  }
]