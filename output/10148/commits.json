[
  {
    "sha": "b3a279cd58d9ae0e107c7fee81f598635e53f9e1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiM2EyNzljZDU4ZDlhZTBlMTA3YzdmZWU4MWY1OTg2MzVlNTNmOWUx",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-04-16T13:57:11Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-26T17:45:48Z"
      },
      "message": "[MOVEONLY] Move LastCommonAncestor to chain",
      "tree": {
        "sha": "4ca31d34f211a7fb926e81c8fef27c5cd5f96ccc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4ca31d34f211a7fb926e81c8fef27c5cd5f96ccc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b3a279cd58d9ae0e107c7fee81f598635e53f9e1",
      "comment_count": 1,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b3a279cd58d9ae0e107c7fee81f598635e53f9e1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b3a279cd58d9ae0e107c7fee81f598635e53f9e1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b3a279cd58d9ae0e107c7fee81f598635e53f9e1/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "234ffc677ee58591b139695bf92bbd6f504ee91a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/234ffc677ee58591b139695bf92bbd6f504ee91a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/234ffc677ee58591b139695bf92bbd6f504ee91a"
      }
    ],
    "stats": {
      "total": 41,
      "additions": 22,
      "deletions": 19
    },
    "files": [
      {
        "sha": "ffd58d471d34b5f9926194446137f4e703742a82",
        "filename": "src/chain.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b3a279cd58d9ae0e107c7fee81f598635e53f9e1/src/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b3a279cd58d9ae0e107c7fee81f598635e53f9e1/src/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.cpp?ref=b3a279cd58d9ae0e107c7fee81f598635e53f9e1",
        "patch": "@@ -148,3 +148,22 @@ int64_t GetBlockProofEquivalentTime(const CBlockIndex& to, const CBlockIndex& fr\n     }\n     return sign * r.GetLow64();\n }\n+\n+/** Find the last common ancestor two blocks have.\n+ *  Both pa and pb must be non-NULL. */\n+const CBlockIndex* LastCommonAncestor(const CBlockIndex* pa, const CBlockIndex* pb) {\n+    if (pa->nHeight > pb->nHeight) {\n+        pa = pa->GetAncestor(pb->nHeight);\n+    } else if (pb->nHeight > pa->nHeight) {\n+        pb = pb->GetAncestor(pa->nHeight);\n+    }\n+\n+    while (pa != pb && pa && pb) {\n+        pa = pa->pprev;\n+        pb = pb->pprev;\n+    }\n+\n+    // Eventually all chain branches meet at the genesis block.\n+    assert(pa == pb);\n+    return pa;\n+}"
      },
      {
        "sha": "c5304b7d6f3e10bb32a1313d88d308ed14813d11",
        "filename": "src/chain.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b3a279cd58d9ae0e107c7fee81f598635e53f9e1/src/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b3a279cd58d9ae0e107c7fee81f598635e53f9e1/src/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.h?ref=b3a279cd58d9ae0e107c7fee81f598635e53f9e1",
        "patch": "@@ -362,6 +362,9 @@ class CBlockIndex\n arith_uint256 GetBlockProof(const CBlockIndex& block);\n /** Return the time it would take to redo the work difference between from and to, assuming the current hashrate corresponds to the difficulty at tip, in seconds. */\n int64_t GetBlockProofEquivalentTime(const CBlockIndex& to, const CBlockIndex& from, const CBlockIndex& tip, const Consensus::Params&);\n+/** Find the forking point between two chain tips. */\n+const CBlockIndex* LastCommonAncestor(const CBlockIndex* pa, const CBlockIndex* pb);\n+\n \n /** Used to marshal pointers into hashes for db storage. */\n class CDiskBlockIndex : public CBlockIndex"
      },
      {
        "sha": "4d832f37113ef1f78ad95d1c97d938745f77cb9d",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 19,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b3a279cd58d9ae0e107c7fee81f598635e53f9e1/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b3a279cd58d9ae0e107c7fee81f598635e53f9e1/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=b3a279cd58d9ae0e107c7fee81f598635e53f9e1",
        "patch": "@@ -452,25 +452,6 @@ bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex)\n     return false;\n }\n \n-/** Find the last common ancestor two blocks have.\n- *  Both pa and pb must be non-NULL. */\n-const CBlockIndex* LastCommonAncestor(const CBlockIndex* pa, const CBlockIndex* pb) {\n-    if (pa->nHeight > pb->nHeight) {\n-        pa = pa->GetAncestor(pb->nHeight);\n-    } else if (pb->nHeight > pa->nHeight) {\n-        pb = pb->GetAncestor(pa->nHeight);\n-    }\n-\n-    while (pa != pb && pa && pb) {\n-        pa = pa->pprev;\n-        pb = pb->pprev;\n-    }\n-\n-    // Eventually all chain branches meet at the genesis block.\n-    assert(pa == pb);\n-    return pa;\n-}\n-\n /** Update pindexLastCommonBlock and add not-in-flight missing successors to vBlocks, until it has\n  *  at most count entries. */\n void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams) {"
      }
    ]
  },
  {
    "sha": "013a56aa1af985894b3eaf7c325647b0b74e4456",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMTNhNTZhYTFhZjk4NTg5NGIzZWFmN2MzMjU2NDdiMGI3NGU0NDU2",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-04-19T16:34:30Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-26T17:45:48Z"
      },
      "message": "Non-atomic flushing using the blockchain as replay journal",
      "tree": {
        "sha": "e09581eda1ae2da213a85f699acc47e312c4e1e8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e09581eda1ae2da213a85f699acc47e312c4e1e8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/013a56aa1af985894b3eaf7c325647b0b74e4456",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/013a56aa1af985894b3eaf7c325647b0b74e4456",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/013a56aa1af985894b3eaf7c325647b0b74e4456",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/013a56aa1af985894b3eaf7c325647b0b74e4456/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b3a279cd58d9ae0e107c7fee81f598635e53f9e1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b3a279cd58d9ae0e107c7fee81f598635e53f9e1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b3a279cd58d9ae0e107c7fee81f598635e53f9e1"
      }
    ],
    "stats": {
      "total": 202,
      "additions": 186,
      "deletions": 16
    },
    "files": [
      {
        "sha": "4bcafcec8cba5d97fe7f98c154bd7eaf563e4a65",
        "filename": "src/coins.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 3,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/013a56aa1af985894b3eaf7c325647b0b74e4456/src/coins.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/013a56aa1af985894b3eaf7c325647b0b74e4456/src/coins.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.cpp?ref=013a56aa1af985894b3eaf7c325647b0b74e4456",
        "patch": "@@ -13,6 +13,7 @@\n bool CCoinsView::GetCoin(const COutPoint &outpoint, Coin &coin) const { return false; }\n bool CCoinsView::HaveCoin(const COutPoint &outpoint) const { return false; }\n uint256 CCoinsView::GetBestBlock() const { return uint256(); }\n+std::vector<uint256> CCoinsView::GetHeadBlocks() const { return std::vector<uint256>(); }\n bool CCoinsView::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) { return false; }\n CCoinsViewCursor *CCoinsView::Cursor() const { return 0; }\n \n@@ -21,6 +22,7 @@ CCoinsViewBacked::CCoinsViewBacked(CCoinsView *viewIn) : base(viewIn) { }\n bool CCoinsViewBacked::GetCoin(const COutPoint &outpoint, Coin &coin) const { return base->GetCoin(outpoint, coin); }\n bool CCoinsViewBacked::HaveCoin(const COutPoint &outpoint) const { return base->HaveCoin(outpoint); }\n uint256 CCoinsViewBacked::GetBestBlock() const { return base->GetBestBlock(); }\n+std::vector<uint256> CCoinsViewBacked::GetHeadBlocks() const { return base->GetHeadBlocks(); }\n void CCoinsViewBacked::SetBackend(CCoinsView &viewIn) { base = &viewIn; }\n bool CCoinsViewBacked::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) { return base->BatchWrite(mapCoins, hashBlock); }\n CCoinsViewCursor *CCoinsViewBacked::Cursor() const { return base->Cursor(); }\n@@ -81,13 +83,14 @@ void CCoinsViewCache::AddCoin(const COutPoint &outpoint, Coin&& coin, bool possi\n     cachedCoinsUsage += it->second.coin.DynamicMemoryUsage();\n }\n \n-void AddCoins(CCoinsViewCache& cache, const CTransaction &tx, int nHeight) {\n+void AddCoins(CCoinsViewCache& cache, const CTransaction &tx, int nHeight, bool check) {\n     bool fCoinbase = tx.IsCoinBase();\n     const uint256& txid = tx.GetHash();\n     for (size_t i = 0; i < tx.vout.size(); ++i) {\n-        // Pass fCoinbase as the possible_overwrite flag to AddCoin, in order to correctly\n+        bool overwrite = check ? cache.HaveCoin(COutPoint(txid, i)) : fCoinbase;\n+        // Always set the possible_overwrite flag to AddCoin for coinbase txn, in order to correctly\n         // deal with the pre-BIP30 occurrences of duplicate coinbase transactions.\n-        cache.AddCoin(COutPoint(txid, i), Coin(tx.vout[i], nHeight, fCoinbase), fCoinbase);\n+        cache.AddCoin(COutPoint(txid, i), Coin(tx.vout[i], nHeight, fCoinbase), overwrite);\n     }\n }\n "
      },
      {
        "sha": "de3264f46e0a9eda9acaf8c85b511d78a70a5cd0",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 11,
        "deletions": 2,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/013a56aa1af985894b3eaf7c325647b0b74e4456/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/013a56aa1af985894b3eaf7c325647b0b74e4456/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=013a56aa1af985894b3eaf7c325647b0b74e4456",
        "patch": "@@ -155,6 +155,12 @@ class CCoinsView\n     //! Retrieve the block hash whose state this CCoinsView currently represents\n     virtual uint256 GetBestBlock() const;\n \n+    //! Retrieve the range of blocks that may have been only partially written.\n+    //! If the database is in a consistent state, the result is the empty vector.\n+    //! Otherwise, a two-element vector is returned consisting of the new and\n+    //! the old block hash, in that order.\n+    virtual std::vector<uint256> GetHeadBlocks() const;\n+\n     //! Do a bulk modification (multiple Coin changes + BestBlock change).\n     //! The passed mapCoins can be modified.\n     virtual bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock);\n@@ -181,6 +187,7 @@ class CCoinsViewBacked : public CCoinsView\n     bool GetCoin(const COutPoint &outpoint, Coin &coin) const override;\n     bool HaveCoin(const COutPoint &outpoint) const override;\n     uint256 GetBestBlock() const override;\n+    std::vector<uint256> GetHeadBlocks() const override;\n     void SetBackend(CCoinsView &viewIn);\n     bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) override;\n     CCoinsViewCursor *Cursor() const override;\n@@ -289,10 +296,12 @@ class CCoinsViewCache : public CCoinsViewBacked\n };\n \n //! Utility function to add all of a transaction's outputs to a cache.\n-// It assumes that overwrites are only possible for coinbase transactions,\n+// When check is false, this assumes that overwrites are only possible for coinbase transactions.\n+// When check is true, the underlying view may be queried to determine whether an addition is\n+// an overwrite.\n // TODO: pass in a boolean to limit these possible overwrites to known\n // (pre-BIP34) cases.\n-void AddCoins(CCoinsViewCache& cache, const CTransaction& tx, int nHeight);\n+void AddCoins(CCoinsViewCache& cache, const CTransaction& tx, int nHeight, bool check = false);\n \n //! Utility function to find any unspent output with a given txid.\n const Coin& AccessByTxid(const CCoinsViewCache& cache, const uint256& txid);"
      },
      {
        "sha": "51f0d4003566b33f0221e1f56397e112a789f6ca",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/013a56aa1af985894b3eaf7c325647b0b74e4456/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/013a56aa1af985894b3eaf7c325647b0b74e4456/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=013a56aa1af985894b3eaf7c325647b0b74e4456",
        "patch": "@@ -336,6 +336,9 @@ std::string HelpMessage(HelpMessageMode mode)\n #endif\n     }\n     strUsage += HelpMessageOpt(\"-datadir=<dir>\", _(\"Specify data directory\"));\n+    if (showDebug) {\n+        strUsage += HelpMessageOpt(\"-dbbatchsize\", strprintf(\"Maximum database write batch size in bytes (default: %u)\", nDefaultDbBatchSize));\n+    }\n     strUsage += HelpMessageOpt(\"-dbcache=<n>\", strprintf(_(\"Set database cache size in megabytes (%d to %d, default: %d)\"), nMinDbCache, nMaxDbCache, nDefaultDbCache));\n     if (showDebug)\n         strUsage += HelpMessageOpt(\"-feefilter\", strprintf(\"Tell other nodes to filter invs to us by our mempool min fee (default: %u)\", DEFAULT_FEEFILTER));\n@@ -1426,6 +1429,13 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n                     break;\n                 }\n \n+                if (!ReplayBlocks(chainparams, pcoinsdbview)) {\n+                    strLoadError = _(\"Unable to replay blocks. You will need to rebuild the database using -reindex-chainstate.\");\n+                    break;\n+                }\n+                pcoinsTip->SetBestBlock(pcoinsdbview->GetBestBlock()); // TODO: only initialize pcoinsTip after ReplayBlocks\n+                LoadChainTip(chainparams);\n+\n                 if (!fReindex && chainActive.Tip() != NULL) {\n                     uiInterface.InitMessage(_(\"Rewinding blocks...\"));\n                     if (!RewindBlockIndex(chainparams)) {"
      },
      {
        "sha": "f0e5098b11e1fe79d578e3612618a17316dc89d0",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 46,
        "deletions": 2,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/013a56aa1af985894b3eaf7c325647b0b74e4456/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/013a56aa1af985894b3eaf7c325647b0b74e4456/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=013a56aa1af985894b3eaf7c325647b0b74e4456",
        "patch": "@@ -21,6 +21,7 @@ static const char DB_TXINDEX = 't';\n static const char DB_BLOCK_INDEX = 'b';\n \n static const char DB_BEST_BLOCK = 'B';\n+static const char DB_HEAD_BLOCKS = 'H';\n static const char DB_FLAG = 'F';\n static const char DB_REINDEX_FLAG = 'R';\n static const char DB_LAST_BLOCK = 'l';\n@@ -68,10 +69,45 @@ uint256 CCoinsViewDB::GetBestBlock() const {\n     return hashBestChain;\n }\n \n+std::vector<uint256> CCoinsViewDB::GetHeadBlocks() const {\n+    std::vector<uint256> vhashHeadBlocks;\n+    if (!db.Read(DB_HEAD_BLOCKS, vhashHeadBlocks)) {\n+        return std::vector<uint256>();\n+    }\n+    return vhashHeadBlocks;\n+}\n+\n bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n     CDBBatch batch(db);\n     size_t count = 0;\n     size_t changed = 0;\n+    size_t batch_size = (size_t)GetArg(\"-dbbatchsize\", nDefaultDbBatchSize);\n+\n+\n+    uint256 old_tip = GetBestBlock();\n+    if (old_tip.IsNull()) {\n+        // We may be in the middle of replaying.\n+        std::vector<uint256> old_heads = GetHeadBlocks();\n+        if (old_heads.size() == 2) {\n+            assert(old_heads[0] == hashBlock);\n+            old_tip = old_heads[1];\n+        }\n+    }\n+\n+    if (hashBlock.IsNull()) {\n+        // Initial flush, nothing to write.\n+        assert(mapCoins.empty());\n+        assert(old_tip.IsNull());\n+        return true;\n+    }\n+\n+    // In the first batch, mark the database as being in the middle of a\n+    // transition from old_tip to hashBlock.\n+    // A vector is used for future extensibility, as we may want to support\n+    // interrupting after partial writes from multiple independent reorgs.\n+    batch.Erase(DB_BEST_BLOCK);\n+    batch.Write(DB_HEAD_BLOCKS, std::vector<uint256>{hashBlock, old_tip});\n+\n     for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end();) {\n         if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n             CoinEntry entry(&it->first);\n@@ -84,10 +120,18 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n         count++;\n         CCoinsMap::iterator itOld = it++;\n         mapCoins.erase(itOld);\n+        if (batch.SizeEstimate() > batch_size) {\n+            LogPrint(BCLog::COINDB, \"Writing partial batch of %.2f MiB\\n\", batch.SizeEstimate() * (1.0 / 1048576.0));\n+            db.WriteBatch(batch);\n+            batch.Clear();\n+        }\n     }\n-    if (!hashBlock.IsNull())\n-        batch.Write(DB_BEST_BLOCK, hashBlock);\n \n+    // In the last batch, mark the database as consistent with hashBlock again.\n+    batch.Erase(DB_HEAD_BLOCKS);\n+    batch.Write(DB_BEST_BLOCK, hashBlock);\n+\n+    LogPrint(BCLog::COINDB, \"Writing final batch of %.2f MiB\\n\", batch.SizeEstimate() * (1.0 / 1048576.0));\n     bool ret = db.WriteBatch(batch);\n     LogPrint(BCLog::COINDB, \"Committed %u changed transaction outputs (out of %u) to coin database...\\n\", (unsigned int)changed, (unsigned int)count);\n     return ret;"
      },
      {
        "sha": "fa6bce214035ca75c3137c3d3f99cb74c0c51b05",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/013a56aa1af985894b3eaf7c325647b0b74e4456/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/013a56aa1af985894b3eaf7c325647b0b74e4456/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=013a56aa1af985894b3eaf7c325647b0b74e4456",
        "patch": "@@ -25,6 +25,8 @@ static constexpr int DB_PEAK_USAGE_FACTOR = 2;\n static constexpr int MAX_BLOCK_COINSDB_USAGE = 10 * DB_PEAK_USAGE_FACTOR;\n //! -dbcache default (MiB)\n static const int64_t nDefaultDbCache = 450;\n+//! -dbbatchsize default (bytes)\n+static const int64_t nDefaultDbBatchSize = 16 << 20;\n //! max. -dbcache (MiB)\n static const int64_t nMaxDbCache = sizeof(void*) > 4 ? 16384 : 1024;\n //! min. -dbcache (MiB)\n@@ -74,6 +76,7 @@ class CCoinsViewDB : public CCoinsView\n     bool GetCoin(const COutPoint &outpoint, Coin &coin) const override;\n     bool HaveCoin(const COutPoint &outpoint) const override;\n     uint256 GetBestBlock() const override;\n+    std::vector<uint256> GetHeadBlocks() const override;\n     bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) override;\n     CCoinsViewCursor *Cursor() const override;\n "
      },
      {
        "sha": "f5e31e0a0b454bb6b3e63c0636d7a992e4be0c44",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 105,
        "deletions": 9,
        "changes": 114,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/013a56aa1af985894b3eaf7c325647b0b74e4456/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/013a56aa1af985894b3eaf7c325647b0b74e4456/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=013a56aa1af985894b3eaf7c325647b0b74e4456",
        "patch": "@@ -96,7 +96,7 @@ namespace {\n \n     struct CBlockIndexWorkComparator\n     {\n-        bool operator()(CBlockIndex *pa, CBlockIndex *pb) const {\n+        bool operator()(const CBlockIndex *pa, const CBlockIndex *pb) const {\n             // First sort by most total work, ...\n             if (pa->nChainWork > pb->nChainWork) return false;\n             if (pa->nChainWork < pb->nChainWork) return true;\n@@ -1331,17 +1331,19 @@ int ApplyTxInUndo(Coin&& undo, CCoinsViewCache& view, const COutPoint& out)\n             return DISCONNECT_FAILED; // adding output for transaction without known metadata\n         }\n     }\n-    view.AddCoin(out, std::move(undo), undo.fCoinBase);\n+    // The potential_overwrite parameter to AddCoin is only allowed to be false if we know for\n+    // sure that the coin did not already exist in the cache. As we have queried for that above\n+    // using HaveCoin, we don't need to guess. When fClean is false, a coin already existed and\n+    // it is an overwrite.\n+    view.AddCoin(out, std::move(undo), !fClean);\n \n     return fClean ? DISCONNECT_OK : DISCONNECT_UNCLEAN;\n }\n \n /** Undo the effects of this block (with given index) on the UTXO set represented by coins.\n- *  When UNCLEAN or FAILED is returned, view is left in an indeterminate state. */\n+ *  When FAILED is returned, view is left in an indeterminate state. */\n static DisconnectResult DisconnectBlock(const CBlock& block, const CBlockIndex* pindex, CCoinsViewCache& view)\n {\n-    assert(pindex->GetBlockHash() == view.GetBestBlock());\n-\n     bool fClean = true;\n \n     CBlockUndo blockUndo;\n@@ -1946,6 +1948,7 @@ bool static DisconnectTip(CValidationState& state, const CChainParams& chainpara\n     int64_t nStart = GetTimeMicros();\n     {\n         CCoinsViewCache view(pcoinsTip);\n+        assert(view.GetBestBlock() == pindexDelete->GetBlockHash());\n         if (DisconnectBlock(block, pindexDelete, view) != DISCONNECT_OK)\n             return error(\"DisconnectTip(): DisconnectBlock %s failed\", pindexDelete->GetBlockHash().ToString());\n         bool flushed = view.Flush();\n@@ -3417,20 +3420,26 @@ bool static LoadBlockIndexDB(const CChainParams& chainparams)\n     pblocktree->ReadFlag(\"txindex\", fTxIndex);\n     LogPrintf(\"%s: transaction index %s\\n\", __func__, fTxIndex ? \"enabled\" : \"disabled\");\n \n+    LoadChainTip(chainparams);\n+    return true;\n+}\n+\n+void LoadChainTip(const CChainParams& chainparams)\n+{\n+    if (chainActive.Tip() && chainActive.Tip()->GetBlockHash() == pcoinsTip->GetBestBlock()) return;\n+\n     // Load pointer to end of best chain\n     BlockMap::iterator it = mapBlockIndex.find(pcoinsTip->GetBestBlock());\n     if (it == mapBlockIndex.end())\n-        return true;\n+        return;\n     chainActive.SetTip(it->second);\n \n     PruneBlockIndexCandidates();\n \n-    LogPrintf(\"%s: hashBestChain=%s height=%d date=%s progress=%f\\n\", __func__,\n+    LogPrintf(\"Loaded best chain: hashBestChain=%s height=%d date=%s progress=%f\\n\",\n         chainActive.Tip()->GetBlockHash().ToString(), chainActive.Height(),\n         DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()),\n         GuessVerificationProgress(chainparams.TxData(), chainActive.Tip()));\n-\n-    return true;\n }\n \n CVerifyDB::CVerifyDB()\n@@ -3499,6 +3508,7 @@ bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview,\n         }\n         // check level 3: check for inconsistencies during memory-only disconnect of tip blocks\n         if (nCheckLevel >= 3 && pindex == pindexState && (coins.DynamicMemoryUsage() + pcoinsTip->DynamicMemoryUsage()) <= nCoinCacheUsage) {\n+            assert(coins.GetBestBlock() == pindex->GetBlockHash());\n             DisconnectResult res = DisconnectBlock(block, pindex, coins);\n             if (res == DISCONNECT_FAILED) {\n                 return error(\"VerifyDB(): *** irrecoverable inconsistency in block data at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n@@ -3538,6 +3548,92 @@ bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview,\n     return true;\n }\n \n+/** Apply the effects of a block on the utxo cache, ignoring that it may already have been applied. */\n+static bool RollforwardBlock(const CBlockIndex* pindex, CCoinsViewCache& inputs, const CChainParams& params)\n+{\n+    // TODO: merge with ConnectBlock\n+    CBlock block;\n+    if (!ReadBlockFromDisk(block, pindex, params.GetConsensus())) {\n+        return error(\"ReplayBlock(): ReadBlockFromDisk failed at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n+    }\n+\n+    for (const CTransactionRef& tx : block.vtx) {\n+        if (!tx->IsCoinBase()) {\n+            for (const CTxIn &txin : tx->vin) {\n+                inputs.SpendCoin(txin.prevout);\n+            }\n+        }\n+        // Pass check = true as every addition may be an overwrite.\n+        AddCoins(inputs, *tx, pindex->nHeight, true);\n+    }\n+    return true;\n+}\n+\n+bool ReplayBlocks(const CChainParams& params, CCoinsView* view)\n+{\n+    LOCK(cs_main);\n+\n+    CCoinsViewCache cache(view);\n+\n+    std::vector<uint256> hashHeads = view->GetHeadBlocks();\n+    if (hashHeads.empty()) return true; // We're already in a consistent state.\n+    if (hashHeads.size() != 2) return error(\"ReplayBlocks(): unknown inconsistent state\");\n+\n+    uiInterface.ShowProgress(_(\"Replaying blocks...\"), 0);\n+    LogPrintf(\"Replaying blocks\\n\");\n+\n+    const CBlockIndex* pindexOld = nullptr;  // Old tip during the interrupted flush.\n+    const CBlockIndex* pindexNew;            // New tip during the interrupted flush.\n+    const CBlockIndex* pindexFork = nullptr; // Latest block common to both the old and the new tip.\n+\n+    if (mapBlockIndex.count(hashHeads[0]) == 0) {\n+        return error(\"ReplayBlocks(): reorganization to unknown block requested\");\n+    }\n+    pindexNew = mapBlockIndex[hashHeads[0]];\n+\n+    if (!hashHeads[1].IsNull()) { // The old tip is allowed to be 0, indicating it's the first flush.\n+        if (mapBlockIndex.count(hashHeads[1]) == 0) {\n+            return error(\"ReplayBlocks(): reorganization from unknown block requested\");\n+        }\n+        pindexOld = mapBlockIndex[hashHeads[1]];\n+        pindexFork = LastCommonAncestor(pindexOld, pindexNew);\n+        assert(pindexFork != nullptr);\n+    }\n+\n+    // Rollback along the old branch.\n+    while (pindexOld != pindexFork) {\n+        if (pindexOld->nHeight > 0) { // Never disconnect the genesis block.\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, pindexOld, params.GetConsensus())) {\n+                return error(\"RollbackBlock(): ReadBlockFromDisk() failed at %d, hash=%s\", pindexOld->nHeight, pindexOld->GetBlockHash().ToString());\n+            }\n+            LogPrintf(\"Rolling back %s (%i)\\n\", pindexOld->GetBlockHash().ToString(), pindexOld->nHeight);\n+            DisconnectResult res = DisconnectBlock(block, pindexOld, cache);\n+            if (res == DISCONNECT_FAILED) {\n+                return error(\"RollbackBlock(): DisconnectBlock failed at %d, hash=%s\", pindexOld->nHeight, pindexOld->GetBlockHash().ToString());\n+            }\n+            // If DISCONNECT_UNCLEAN is returned, it means a non-existing UTXO was deleted, or an existing UTXO was\n+            // overwritten. It corresponds to cases where the block-to-be-disconnect never had all its operations\n+            // applied to the UTXO set. However, as both writing a UTXO and deleting a UTXO are idempotent operations,\n+            // the result is still a version of the UTXO set with the effects of that block undone.\n+        }\n+        pindexOld = pindexOld->pprev;\n+    }\n+\n+    // Roll forward from the forking point to the new tip.\n+    int nForkHeight = pindexFork ? pindexFork->nHeight : 0;\n+    for (int nHeight = nForkHeight + 1; nHeight <= pindexNew->nHeight; ++nHeight) {\n+        const CBlockIndex* pindex = pindexNew->GetAncestor(nHeight);\n+        LogPrintf(\"Rolling forward %s (%i)\\n\", pindex->GetBlockHash().ToString(), nHeight);\n+        if (!RollforwardBlock(pindex, cache, params)) return false;\n+    }\n+\n+    cache.SetBestBlock(pindexNew->GetBlockHash());\n+    cache.Flush();\n+    uiInterface.ShowProgress(\"\", 100);\n+    return true;\n+}\n+\n bool RewindBlockIndex(const CChainParams& params)\n {\n     LOCK(cs_main);"
      },
      {
        "sha": "8a721dd7a256770e8645aef0666a2abdfd850cb7",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/013a56aa1af985894b3eaf7c325647b0b74e4456/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/013a56aa1af985894b3eaf7c325647b0b74e4456/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=013a56aa1af985894b3eaf7c325647b0b74e4456",
        "patch": "@@ -260,6 +260,8 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, CDiskB\n bool InitBlockIndex(const CChainParams& chainparams);\n /** Load the block tree and coins database from disk */\n bool LoadBlockIndex(const CChainParams& chainparams);\n+/** Update the chain tip based on database information. */\n+void LoadChainTip(const CChainParams& chainparams);\n /** Unload database information */\n void UnloadBlockIndex();\n /** Run an instance of the script checking thread */\n@@ -424,6 +426,9 @@ class CVerifyDB {\n     bool VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview, int nCheckLevel, int nCheckDepth);\n };\n \n+/** Replay blocks that aren't fully applied to the database. */\n+bool ReplayBlocks(const CChainParams& params, CCoinsView* view);\n+\n /** Find the last common block between the parameter chain and a locator. */\n CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator);\n "
      }
    ]
  },
  {
    "sha": "0580ee08ff413f729bd34e5a5ce0fb75894f0256",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNTgwZWUwOGZmNDEzZjcyOWJkMzRlNWE1Y2UwZmI3NTg5NGYwMjU2",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-04-19T16:34:48Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-26T17:45:48Z"
      },
      "message": "Adapt memory usage estimation for flushing",
      "tree": {
        "sha": "1aa759b02f0d8210a079a06b9535a3120f1f5238",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1aa759b02f0d8210a079a06b9535a3120f1f5238"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0580ee08ff413f729bd34e5a5ce0fb75894f0256",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0580ee08ff413f729bd34e5a5ce0fb75894f0256",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0580ee08ff413f729bd34e5a5ce0fb75894f0256",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0580ee08ff413f729bd34e5a5ce0fb75894f0256/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "013a56aa1af985894b3eaf7c325647b0b74e4456",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/013a56aa1af985894b3eaf7c325647b0b74e4456",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/013a56aa1af985894b3eaf7c325647b0b74e4456"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 2,
      "deletions": 4
    },
    "files": [
      {
        "sha": "e5c0516a3868dd96b895975558b621442452c86f",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0580ee08ff413f729bd34e5a5ce0fb75894f0256/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0580ee08ff413f729bd34e5a5ce0fb75894f0256/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=0580ee08ff413f729bd34e5a5ce0fb75894f0256",
        "patch": "@@ -19,10 +19,8 @@ class CBlockIndex;\n class CCoinsViewDBCursor;\n class uint256;\n \n-//! Compensate for extra memory peak (x1.5-x1.9) at flush time.\n-static constexpr int DB_PEAK_USAGE_FACTOR = 2;\n //! No need to periodic flush if at least this much space still available.\n-static constexpr int MAX_BLOCK_COINSDB_USAGE = 10 * DB_PEAK_USAGE_FACTOR;\n+static constexpr int MAX_BLOCK_COINSDB_USAGE = 10;\n //! -dbcache default (MiB)\n static const int64_t nDefaultDbCache = 450;\n //! -dbbatchsize default (bytes)"
      },
      {
        "sha": "77b96be1e514699bebdb2a6fe02f731013c672b4",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0580ee08ff413f729bd34e5a5ce0fb75894f0256/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0580ee08ff413f729bd34e5a5ce0fb75894f0256/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=0580ee08ff413f729bd34e5a5ce0fb75894f0256",
        "patch": "@@ -1781,7 +1781,7 @@ bool static FlushStateToDisk(const CChainParams& chainparams, CValidationState &\n         nLastSetChain = nNow;\n     }\n     int64_t nMempoolSizeMax = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n-    int64_t cacheSize = pcoinsTip->DynamicMemoryUsage() * DB_PEAK_USAGE_FACTOR;\n+    int64_t cacheSize = pcoinsTip->DynamicMemoryUsage();\n     int64_t nTotalSpace = nCoinCacheUsage + std::max<int64_t>(nMempoolSizeMax - nMempoolUsage, 0);\n     // The cache is large and we're within 10% and 10 MiB of the limit, but we have time now (not in the middle of a block processing).\n     bool fCacheLarge = mode == FLUSH_STATE_PERIODIC && cacheSize > std::max((9 * nTotalSpace) / 10, nTotalSpace - MAX_BLOCK_COINSDB_USAGE * 1024 * 1024);"
      }
    ]
  },
  {
    "sha": "eaca1b7b08b4911292d49efbce8471cbc9ca0e1c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplYWNhMWI3YjA4YjQ5MTEyOTJkNDllZmJjZTg0NzFjYmM5Y2EwZTFj",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-04-05T08:37:09Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-26T17:46:51Z"
      },
      "message": "Random db flush crash simulator",
      "tree": {
        "sha": "9b6bde7479dc3a0550a0d550f914cdebcbcdd0e2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9b6bde7479dc3a0550a0d550f914cdebcbcdd0e2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/eaca1b7b08b4911292d49efbce8471cbc9ca0e1c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eaca1b7b08b4911292d49efbce8471cbc9ca0e1c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/eaca1b7b08b4911292d49efbce8471cbc9ca0e1c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eaca1b7b08b4911292d49efbce8471cbc9ca0e1c/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0580ee08ff413f729bd34e5a5ce0fb75894f0256",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0580ee08ff413f729bd34e5a5ce0fb75894f0256",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0580ee08ff413f729bd34e5a5ce0fb75894f0256"
      }
    ],
    "stats": {
      "total": 13,
      "additions": 11,
      "deletions": 2
    },
    "files": [
      {
        "sha": "150f368513296525112f09d9732bc7c7a428b32f",
        "filename": "contrib/devtools/check-doc.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eaca1b7b08b4911292d49efbce8471cbc9ca0e1c/contrib/devtools/check-doc.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eaca1b7b08b4911292d49efbce8471cbc9ca0e1c/contrib/devtools/check-doc.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/check-doc.py?ref=eaca1b7b08b4911292d49efbce8471cbc9ca0e1c",
        "patch": "@@ -21,7 +21,7 @@\n REGEX_ARG = re.compile(r'(?:map(?:Multi)?Args(?:\\.count\\(|\\[)|Get(?:Bool)?Arg\\()\\\"(\\-[^\\\"]+?)\\\"')\n REGEX_DOC = re.compile(r'HelpMessageOpt\\(\\\"(\\-[^\\\"=]+?)(?:=|\\\")')\n # list unsupported, deprecated and duplicate args as they need no documentation\n-SET_DOC_OPTIONAL = set(['-rpcssl', '-benchmark', '-h', '-help', '-socks', '-tor', '-debugnet', '-whitelistalwaysrelay', '-prematurewitness', '-walletprematurewitness', '-promiscuousmempoolflags', '-blockminsize'])\n+SET_DOC_OPTIONAL = set(['-rpcssl', '-benchmark', '-h', '-help', '-socks', '-tor', '-debugnet', '-whitelistalwaysrelay', '-prematurewitness', '-walletprematurewitness', '-promiscuousmempoolflags', '-blockminsize', '-dbcrashratio'])\n \n def main():\n   used = check_output(CMD_GREP_ARGS, shell=True)"
      },
      {
        "sha": "7de11cc6172f60fc8dbcc6fe296affd25b87a3e0",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 1,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eaca1b7b08b4911292d49efbce8471cbc9ca0e1c/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eaca1b7b08b4911292d49efbce8471cbc9ca0e1c/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=eaca1b7b08b4911292d49efbce8471cbc9ca0e1c",
        "patch": "@@ -7,8 +7,10 @@\n \n #include \"chainparams.h\"\n #include \"hash.h\"\n+#include \"random.h\"\n #include \"pow.h\"\n #include \"uint256.h\"\n+#include \"util.h\"\n \n #include <stdint.h>\n \n@@ -82,7 +84,7 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n     size_t count = 0;\n     size_t changed = 0;\n     size_t batch_size = (size_t)GetArg(\"-dbbatchsize\", nDefaultDbBatchSize);\n-\n+    int crash_simulate = GetArg(\"-dbcrashratio\", 0);\n \n     uint256 old_tip = GetBestBlock();\n     if (old_tip.IsNull()) {\n@@ -124,6 +126,13 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n             LogPrint(BCLog::COINDB, \"Writing partial batch of %.2f MiB\\n\", batch.SizeEstimate() * (1.0 / 1048576.0));\n             db.WriteBatch(batch);\n             batch.Clear();\n+            if (crash_simulate) {\n+                static FastRandomContext rng;\n+                if (rng.randrange(crash_simulate) == 0) {\n+                    LogPrintf(\"Simulating a crash. Goodbye.\\n\");\n+                    exit(0);\n+                }\n+            }\n         }\n     }\n "
      }
    ]
  },
  {
    "sha": "d6af06d68aae985436cbc942f0d11078041d121b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNmFmMDZkNjhhYWU5ODU0MzZjYmM5NDJmMGQxMTA3ODA0MWQxMjFi",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-04-17T15:41:10Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-26T17:46:51Z"
      },
      "message": "Dont create pcoinsTip until after ReplayBlocks.\n\nThis requires that we not access pcoinsTip in InitBlockIndex's\nFlushStateToDisk (so we just skip it until later in AppInitMain)\nand the LoadChainTip in LoadBlockIndex (which there is already one\nlater in AppinitMain, after ReplayBlocks, so skipping it there is\nfine).\n\nIncludes some simplifications by Suhas Daftuar and Pieter Wuille.",
      "tree": {
        "sha": "a8af3452e747b038bc50957aae8b47a9e8585ee5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a8af3452e747b038bc50957aae8b47a9e8585ee5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d6af06d68aae985436cbc942f0d11078041d121b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d6af06d68aae985436cbc942f0d11078041d121b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d6af06d68aae985436cbc942f0d11078041d121b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d6af06d68aae985436cbc942f0d11078041d121b/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "eaca1b7b08b4911292d49efbce8471cbc9ca0e1c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eaca1b7b08b4911292d49efbce8471cbc9ca0e1c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/eaca1b7b08b4911292d49efbce8471cbc9ca0e1c"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 2,
      "deletions": 12
    },
    "files": [
      {
        "sha": "794c6bc45e3a659cf82dcee363a1f95440427c20",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6af06d68aae985436cbc942f0d11078041d121b/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6af06d68aae985436cbc942f0d11078041d121b/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=d6af06d68aae985436cbc942f0d11078041d121b",
        "patch": "@@ -1385,7 +1385,6 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n                 pblocktree = new CBlockTreeDB(nBlockTreeDBCache, false, fReindex);\n                 pcoinsdbview = new CCoinsViewDB(nCoinDBCache, false, fReindex || fReindexChainState);\n                 pcoinscatcher = new CCoinsViewErrorCatcher(pcoinsdbview);\n-                pcoinsTip = new CCoinsViewCache(pcoinscatcher);\n \n                 if (fReindex) {\n                     pblocktree->WriteReindexing(true);\n@@ -1433,7 +1432,7 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n                     strLoadError = _(\"Unable to replay blocks. You will need to rebuild the database using -reindex-chainstate.\");\n                     break;\n                 }\n-                pcoinsTip->SetBestBlock(pcoinsdbview->GetBestBlock()); // TODO: only initialize pcoinsTip after ReplayBlocks\n+                pcoinsTip = new CCoinsViewCache(pcoinscatcher);\n                 LoadChainTip(chainparams);\n \n                 if (!fReindex && chainActive.Tip() != NULL) {"
      },
      {
        "sha": "4cdfc7d6f5f4a35dcdd04cf8886cbef224780088",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 7,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6af06d68aae985436cbc942f0d11078041d121b/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6af06d68aae985436cbc942f0d11078041d121b/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=d6af06d68aae985436cbc942f0d11078041d121b",
        "patch": "@@ -85,6 +85,7 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n     size_t changed = 0;\n     size_t batch_size = (size_t)GetArg(\"-dbbatchsize\", nDefaultDbBatchSize);\n     int crash_simulate = GetArg(\"-dbcrashratio\", 0);\n+    assert(!hashBlock.IsNull());\n \n     uint256 old_tip = GetBestBlock();\n     if (old_tip.IsNull()) {\n@@ -96,13 +97,6 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n         }\n     }\n \n-    if (hashBlock.IsNull()) {\n-        // Initial flush, nothing to write.\n-        assert(mapCoins.empty());\n-        assert(old_tip.IsNull());\n-        return true;\n-    }\n-\n     // In the first batch, mark the database as being in the middle of a\n     // transition from old_tip to hashBlock.\n     // A vector is used for future extensibility, as we may want to support"
      },
      {
        "sha": "6100ccb33ddf15ed5a7a392e802701fe21440159",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6af06d68aae985436cbc942f0d11078041d121b/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6af06d68aae985436cbc942f0d11078041d121b/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=d6af06d68aae985436cbc942f0d11078041d121b",
        "patch": "@@ -3420,7 +3420,6 @@ bool static LoadBlockIndexDB(const CChainParams& chainparams)\n     pblocktree->ReadFlag(\"txindex\", fTxIndex);\n     LogPrintf(\"%s: transaction index %s\\n\", __func__, fTxIndex ? \"enabled\" : \"disabled\");\n \n-    LoadChainTip(chainparams);\n     return true;\n }\n \n@@ -3783,8 +3782,6 @@ bool InitBlockIndex(const CChainParams& chainparams)\n             CBlockIndex *pindex = AddToBlockIndex(block);\n             if (!ReceivedBlockTransactions(block, state, pindex, blockPos, chainparams.GetConsensus()))\n                 return error(\"LoadBlockIndex(): genesis block not accepted\");\n-            // Force a chainstate write so that when we VerifyDB in a moment, it doesn't check stale data\n-            return FlushStateToDisk(chainparams, state, FLUSH_STATE_ALWAYS);\n         } catch (const std::runtime_error& e) {\n             return error(\"LoadBlockIndex(): failed to initialize block database: %s\", e.what());\n         }"
      }
    ]
  },
  {
    "sha": "176c021d085f5a45bc9e038e760942aa648dd797",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxNzZjMDIxZDA4NWY1YTQ1YmM5ZTAzOGU3NjA5NDJhYTY0OGRkNzk3",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-06-15T21:08:48Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-26T21:48:42Z"
      },
      "message": "[qa] Test non-atomic chainstate writes\n\nAdds new functional test, dbcrash.py, which uses -dbcrashratio to exercise the\nlogic for recovering from a crash during chainstate flush.\n\ndbcrash.py is added to the extended tests, as it may take ~10 minutes to run\n\nUse _Exit() instead of exit() for crash simulation\n\nThis eliminates stderr output such as:\n    terminate called without an active exception\nor\n    Assertion failed: (!pthread_mutex_destroy(&m)), function ~recursive_mutex, file /usr/local/include/boost/thread/pthread/recursive_mutex.hpp, line 104.\n\nEliminating the stderr output on crash simulation allows testing with\ntest_runner.py, which reports a test as failed if stderr is produced.",
      "tree": {
        "sha": "cd057e23d8dedece53ffa4db73efa245c204b796",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cd057e23d8dedece53ffa4db73efa245c204b796"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/176c021d085f5a45bc9e038e760942aa648dd797",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/176c021d085f5a45bc9e038e760942aa648dd797",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/176c021d085f5a45bc9e038e760942aa648dd797",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/176c021d085f5a45bc9e038e760942aa648dd797/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d6af06d68aae985436cbc942f0d11078041d121b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d6af06d68aae985436cbc942f0d11078041d121b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d6af06d68aae985436cbc942f0d11078041d121b"
      }
    ],
    "stats": {
      "total": 273,
      "additions": 272,
      "deletions": 1
    },
    "files": [
      {
        "sha": "d24162ba2dc6d5c49f8dacf131af12127d22cd7c",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/176c021d085f5a45bc9e038e760942aa648dd797/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/176c021d085f5a45bc9e038e760942aa648dd797/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=176c021d085f5a45bc9e038e760942aa648dd797",
        "patch": "@@ -124,7 +124,7 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n                 static FastRandomContext rng;\n                 if (rng.randrange(crash_simulate) == 0) {\n                     LogPrintf(\"Simulating a crash. Goodbye.\\n\");\n-                    exit(0);\n+                    _Exit(0);\n                 }\n             }\n         }"
      },
      {
        "sha": "4a10743f04792f0566b5ac1812f6b28e98d68e68",
        "filename": "test/functional/dbcrash.py",
        "status": "added",
        "additions": 268,
        "deletions": 0,
        "changes": 268,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/176c021d085f5a45bc9e038e760942aa648dd797/test/functional/dbcrash.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/176c021d085f5a45bc9e038e760942aa648dd797/test/functional/dbcrash.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/dbcrash.py?ref=176c021d085f5a45bc9e038e760942aa648dd797",
        "patch": "@@ -0,0 +1,268 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test recovery from a crash during chainstate writing.\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.script import *\n+from test_framework.mininode import *\n+import random\n+try:\n+    import http.client as httplib\n+except ImportError:\n+    import httplib\n+import errno\n+\n+'''\n+Test structure:\n+\n+- 4 nodes\n+  * node0, node1, and node2 will have different dbcrash ratios, and different\n+    dbcache sizes\n+  * node3 will be a regular node, with no crashing.\n+  * The nodes will not connect to each other.\n+\n+- use default test framework starting chain. initialize starting_tip_height to\n+  tip height.\n+\n+- Main loop:\n+  * generate lots of transactions on node3, enough to fill up a block.\n+  * uniformly randomly pick a tip height from starting_tip_height to\n+    tip_height; with probability 1/(height_difference+4), invalidate this block.\n+  * mine enough blocks to overtake tip_height at start of loop.\n+  * for each node in [node0,node1,node2]:\n+     - for each mined block:\n+       * submit block to node\n+       * if node crashed on/after submitting:\n+         - restart until recovery succeeds\n+         - check that utxo matches node3 using gettxoutsetinfo\n+'''\n+\n+class ChainstateWriteCrashTest(BitcoinTestFramework):\n+\n+    def __init__(self):\n+        super().__init__()\n+        self.num_nodes = 4\n+        self.setup_clean_chain = False\n+\n+        # Set -maxmempool=0 to turn off mempool memory sharing with dbcache\n+        # Set -rpcservertimeout=900 to reduce socket disconnects in this\n+        # long-running test\n+        self.base_args = [\"-limitdescendantsize=0\", \"-maxmempool=0\", \"-rpcservertimeout=900\"]\n+\n+        # Set different crash ratios and cache sizes.  Note that not all of\n+        # -dbcache goes to pcoinsTip.\n+        self.node0_args = [\"-dbcrashratio=8\", \"-dbcache=4\", \"-dbbatchsize=200000\"] + self.base_args\n+        self.node1_args = [\"-dbcrashratio=16\", \"-dbcache=8\", \"-dbbatchsize=200000\"] + self.base_args\n+        self.node2_args = [\"-dbcrashratio=24\", \"-dbcache=16\", \"-dbbatchsize=200000\"] + self.base_args\n+\n+        # Node3 is a normal node with default args, except will mine full blocks\n+        self.node3_args = [\"-blockmaxweight=4000000\"]\n+        self.extra_args = [self.node0_args, self.node1_args, self.node2_args, self.node3_args]\n+\n+        # We'll track some test coverage statistics\n+        self.restart_counts = [0, 0, 0] # Track the restarts for nodes 0-2\n+        self.crashed_on_restart = 0     # Track count of crashes during recovery\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+        # Leave them unconnected, we'll use submitblock directly in this test\n+\n+    # Starts up a given node id, waits for the tip to reach the given block\n+    # hash, and calculates the utxo hash.  Exceptions on startup should\n+    # indicate node crash (due to -dbcrashratio), in which case we try again.\n+    # Give up after 60 seconds.\n+    # Returns the utxo hash of the given node.\n+    def restart_node(self, node_index, expected_tip):\n+        time_start = time.time()\n+        while time.time() - time_start < 60:\n+            try:\n+                # Any of these RPC calls could throw due to node crash\n+                self.nodes[node_index] = self.start_node(node_index, self.options.tmpdir, self.extra_args[node_index])\n+                self.nodes[node_index].waitforblock(expected_tip)\n+                utxo_hash = self.nodes[node_index].gettxoutsetinfo()['hash_serialized_2']\n+                return utxo_hash\n+            except:\n+                # An exception here should mean the node is about to crash.\n+                # If bitcoind exits, then try again.  wait_for_node_exit()\n+                # should raise an exception if bitcoind doesn't exit.\n+                wait_for_node_exit(node_index, timeout=10)\n+            self.crashed_on_restart += 1\n+            time.sleep(1)\n+\n+        # If we got here, bitcoind isn't coming back up on restart.  Could be a\n+        # bug in bitcoind, or we've gotten unlucky with our dbcrash ratio --\n+        # perhaps we generated a test case that blew up our cache?\n+        # TODO: If this happens a lot, we should try to restart without -dbcrashratio\n+        # and make sure that recovery happens.\n+        raise AssertionError(\"Unable to successfully restart node %d in allotted time\", node_index)\n+\n+    # Try submitting a block to the given node.\n+    # Catch any exceptions that indicate the node has crashed.\n+    # Returns true if the block was submitted successfully; false otherwise.\n+    def submit_block_catch_error(self, node_index, block):\n+        try:\n+            self.nodes[node_index].submitblock(block)\n+            return True\n+        except (httplib.CannotSendRequest, httplib.RemoteDisconnected) as e:\n+            self.log.debug(\"node %d submitblock raised exception: %s\", node_index, e)\n+            return False\n+        except OSError as e:\n+            self.log.debug(\"node %d submitblock raised OSError exception: errno=%s\", node_index, e.errno)\n+            if e.errno in [errno.EPIPE, errno.ECONNREFUSED, errno.ECONNRESET]:\n+                # The node has likely crashed\n+                return False\n+            else:\n+                # Unexpected exception, raise\n+                raise\n+\n+    # Use submitblock to sync node3's chain with the other nodes\n+    # If submitblock fails, restart the node and get the new utxo hash.\n+    def sync_node3blocks(self, block_hashes):\n+        # If any nodes crash while updating, we'll compare utxo hashes to\n+        # ensure recovery was successful.\n+        node3_utxo_hash = self.nodes[3].gettxoutsetinfo()['hash_serialized_2']\n+\n+        # Retrieve all the blocks from node3\n+        blocks = []\n+        for block_hash in block_hashes:\n+            blocks.append([block_hash, self.nodes[3].getblock(block_hash, 0)])\n+\n+        # Deliver each block to each other node\n+        for i in range(3):\n+            nodei_utxo_hash = None\n+            self.log.debug(\"Syncing blocks to node %d\", i)\n+            for (block_hash, block) in blocks:\n+                # Get the block from node3, and submit to node_i\n+                self.log.debug(\"submitting block %s\", block_hash)\n+                if not self.submit_block_catch_error(i, block):\n+                    # TODO: more carefully check that the crash is due to -dbcrashratio\n+                    # (change the exit code perhaps, and check that here?)\n+                    wait_for_node_exit(i, timeout=30)\n+                    self.log.debug(\"Restarting node %d after block hash %s\", i, block_hash)\n+                    nodei_utxo_hash = self.restart_node(i, block_hash)\n+                    assert nodei_utxo_hash is not None\n+                    self.restart_counts[i] += 1\n+                else:\n+                    # Clear it out after successful submitblock calls -- the cached\n+                    # utxo hash will no longer be correct\n+                    nodei_utxo_hash = None\n+\n+            # Check that the utxo hash matches node3's utxo set\n+            # NOTE: we only check the utxo set if we had to restart the node\n+            # after the last block submitted:\n+            # - checking the utxo hash causes a cache flush, which we don't\n+            # want to do every time; so\n+            # - we only update the utxo cache after a node restart, since flushing\n+            # the cache is a no-op at that point\n+            if nodei_utxo_hash is not None:\n+                self.log.debug(\"Checking txoutsetinfo matches for node %d\", i)\n+                assert_equal(nodei_utxo_hash, node3_utxo_hash)\n+\n+    # Verify that the utxo hash of each node matches node3.\n+    # Restart any nodes that crash while querying.\n+    def verify_utxo_hash(self):\n+        node3_utxo_hash = self.nodes[3].gettxoutsetinfo()['hash_serialized_2']\n+        self.log.info(\"Verifying utxo hash matches for all nodes\")\n+\n+        for i in range(3):\n+            try:\n+                nodei_utxo_hash = self.nodes[i].gettxoutsetinfo()['hash_serialized_2']\n+            except OSError:\n+                # probably a crash on db flushing\n+                nodei_utxo_hash = self.restart_node(i, self.nodes[3].getbestblockhash())\n+            assert_equal(nodei_utxo_hash, node3_utxo_hash)\n+\n+\n+    def generate_small_transactions(self, node, count, utxo_list):\n+        FEE = 1000 # TODO: replace this with node relay fee based calculation\n+        num_transactions = 0\n+        random.shuffle(utxo_list)\n+        while len(utxo_list) >= 2 and num_transactions < count:\n+            tx = CTransaction()\n+            input_amount = 0\n+            for i in range(2):\n+                utxo = utxo_list.pop()\n+                tx.vin.append(CTxIn(COutPoint(int(utxo['txid'], 16), utxo['vout'])))\n+                input_amount += int(utxo['amount']*COIN)\n+            output_amount = (input_amount - FEE)//3\n+\n+            if output_amount <= 0:\n+                # Sanity check -- if we chose inputs that are too small, skip\n+                continue\n+\n+            for i in range(3):\n+                tx.vout.append(CTxOut(output_amount, hex_str_to_bytes(utxo['scriptPubKey'])))\n+\n+            # Sign and send the transaction to get into the mempool\n+            tx_signed_hex = node.signrawtransaction(ToHex(tx))['hex']\n+            node.sendrawtransaction(tx_signed_hex)\n+            num_transactions += 1\n+\n+    def run_test(self):\n+\n+        # Start by creating a lot of utxos on node3\n+        initial_height = self.nodes[3].getblockcount()\n+        utxo_list = create_confirmed_utxos(self.nodes[3].getnetworkinfo()['relayfee'], self.nodes[3], 5000)\n+        self.log.info(\"Prepped %d utxo entries\", len(utxo_list))\n+\n+        # Sync these blocks with the other nodes\n+        block_hashes_to_sync = []\n+        for height in range(initial_height+1, self.nodes[3].getblockcount()+1):\n+            block_hashes_to_sync.append(self.nodes[3].getblockhash(height))\n+\n+        self.log.debug(\"Syncing %d blocks with other nodes\", len(block_hashes_to_sync))\n+        # Syncing the blocks could cause nodes to crash, so the test begins here.\n+        self.sync_node3blocks(block_hashes_to_sync)\n+\n+        starting_tip_height = self.nodes[3].getblockcount()\n+\n+        # Main test loop:\n+        # each time through the loop, generate a bunch of transactions,\n+        # and then either mine a single new block on the tip, or some-sized reorg.\n+        for i in range(40):\n+            self.log.info(\"Iteration %d, generating 2500 transactions %s\", i, self.restart_counts)\n+            # Generate a bunch of small-ish transactions\n+            self.generate_small_transactions(self.nodes[3], 2500, utxo_list)\n+            # Pick a random block between current tip, and starting tip\n+            current_height = self.nodes[3].getblockcount()\n+            random_height = random.randint(starting_tip_height, current_height)\n+            self.log.debug(\"At height %d, considering height %d\", current_height, random_height)\n+            if random_height > starting_tip_height:\n+                # Randomly reorg from this point with some probability (1/4 for\n+                # tip, 1/5 for tip-1, ...)\n+                if random.random() < 1.0/(current_height + 4 - random_height):\n+                    self.log.debug(\"Invalidating block at height %d\", random_height)\n+                    self.nodes[3].invalidateblock(self.nodes[3].getblockhash(random_height))\n+\n+            # Now generate new blocks until we pass the old tip height\n+            self.log.debug(\"Mining longer tip\")\n+            block_hashes = self.nodes[3].generate(current_height+1-self.nodes[3].getblockcount())\n+            self.log.debug(\"Syncing %d new blocks...\", len(block_hashes))\n+            self.sync_node3blocks(block_hashes)\n+            utxo_list = self.nodes[3].listunspent()\n+            self.log.debug(\"Node3 utxo count: %d\", len(utxo_list))\n+\n+        # Check that the utxo hashes agree with node3\n+        # Useful side effect: each utxo cache gets flushed here, so that we\n+        # won't get crashes on shutdown at the end of the test.\n+        self.verify_utxo_hash()\n+\n+        # Check the test coverage\n+        self.log.info(\"Restarted nodes: %s; crashes on restart: %d\", self.restart_counts, self.crashed_on_restart)\n+\n+        # If no nodes were restarted, we didn't test anything.\n+        assert self.restart_counts != [0, 0, 0]\n+\n+        # Make sure we tested the case of crash-during-recovery.\n+        assert self.crashed_on_restart > 0\n+\n+        # Warn if any of the nodes escaped restart.\n+        for i in range(3):\n+            if self.restart_counts[i] == 0:\n+                self.log.warn(\"Node %d never crashed during utxo flush!\", i)\n+\n+if __name__ == \"__main__\":\n+    ChainstateWriteCrashTest().main()"
      },
      {
        "sha": "2a4f3104aa0d1e656e1e1be6c8d132d702057696",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/176c021d085f5a45bc9e038e760942aa648dd797/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/176c021d085f5a45bc9e038e760942aa648dd797/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=176c021d085f5a45bc9e038e760942aa648dd797",
        "patch": "@@ -249,6 +249,8 @@ def wait_for_bitcoind_start(process, datadir, i, rpchost=None):\n                 raise\n         time.sleep(0.25)\n \n+def wait_for_node_exit(node_index, timeout):\n+    bitcoind_processes[node_index].wait(timeout)\n \n def _start_node(i, dirname, extra_args=None, rpchost=None, timewait=None, binary=None, stderr=None):\n     \"\"\"Start a bitcoind and return RPC connection to it"
      },
      {
        "sha": "70a7b2a1ffc70aa05bcb7c75b2ef7bb61575dd0b",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/176c021d085f5a45bc9e038e760942aa648dd797/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/176c021d085f5a45bc9e038e760942aa648dd797/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=176c021d085f5a45bc9e038e760942aa648dd797",
        "patch": "@@ -124,6 +124,7 @@\n     # vv Tests less than 5m vv\n     'maxuploadtarget.py',\n     'mempool_packages.py',\n+    'dbcrash.py',\n     # vv Tests less than 2m vv\n     'bip68-sequence.py',\n     'getblocktemplate_longpoll.py',"
      }
    ]
  }
]