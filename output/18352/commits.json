[
  {
    "sha": "4a7e92139bf8b7aefc11a5531eddc189431e03ff",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0YTdlOTIxMzliZjhiN2FlZmMxMWE1NTMxZWRkYzE4OTQzMWUwM2Zm",
    "commit": {
      "author": {
        "name": "Martin Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2019-10-29T18:53:54Z"
      },
      "committer": {
        "name": "Martin Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2020-03-28T07:31:29Z"
      },
      "message": "Replace current benchmarking framework with nanobench\n\nThis replaces the current benchmarking framework with nanobench [1], an\nMIT licensed single-header benchmarking library, of which I am the\nautor. This has in my opinion several advantages, especially on Linux:\n\n* fast: Running all benchmarks takes ~6 seconds instead of 4m13s on\n  an Intel i7-8700 CPU @ 3.20GHz.\n\n* accurate: I ran e.g. the benchmark for SipHash_32b 10 times and\n  calculate standard deviation / mean = coefficient of variation:\n\n  * 0.57% CV for old benchmarking framework\n  * 0.20% CV for nanobench\n\n  So the benchmark results with nanobench seem to vary less than with\n  the old framework.\n\n* It automatically determines runtime based on clock precision, no need\n  to specify number of evaluations.\n\n* measure instructions, cycles, branches, instructions per cycle,\n  branch misses (only Linux, when performance counters are available)\n\n* output in markdown table format.\n\n* Warn about unstable environment (frequency scaling, turbo, ...)\n\n* For better profiling, it is possible to set the environment variable\n  NANOBENCH_ENDLESS to force endless running of a particular benchmark\n  without the need to recompile. This makes it to e.g. run \"perf top\"\n  and look at hotspots.\n\nHere is an example copy & pasted from the terminal output:\n\n|             ns/byte |              byte/s |    err% |        ins/byte |        cyc/byte |    IPC |       bra/byte |   miss% |     total | benchmark\n|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|---------------:|--------:|----------:|:----------\n|                2.52 |      396,529,415.94 |    0.6% |           25.42 |            8.02 |  3.169 |           0.06 |    0.0% |      0.03 | `bench/crypto_hash.cpp RIPEMD160`\n|                1.87 |      535,161,444.83 |    0.3% |           21.36 |            5.95 |  3.589 |           0.06 |    0.0% |      0.02 | `bench/crypto_hash.cpp SHA1`\n|                3.22 |      310,344,174.79 |    1.1% |           36.80 |           10.22 |  3.601 |           0.09 |    0.0% |      0.04 | `bench/crypto_hash.cpp SHA256`\n|                2.01 |      496,375,796.23 |    0.0% |           18.72 |            6.43 |  2.911 |           0.01 |    1.0% |      0.00 | `bench/crypto_hash.cpp SHA256D64_1024`\n|                7.23 |      138,263,519.35 |    0.1% |           82.66 |           23.11 |  3.577 |           1.63 |    0.1% |      0.00 | `bench/crypto_hash.cpp SHA256_32b`\n|                3.04 |      328,780,166.40 |    0.3% |           35.82 |            9.69 |  3.696 |           0.03 |    0.0% |      0.03 | `bench/crypto_hash.cpp SHA512`\n\n[1] https://github.com/martinus/nanobench",
      "tree": {
        "sha": "571f1f66fd5b857a1761ed62d579a46ead4caa6a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/571f1f66fd5b857a1761ed62d579a46ead4caa6a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4a7e92139bf8b7aefc11a5531eddc189431e03ff",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4a7e92139bf8b7aefc11a5531eddc189431e03ff",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4a7e92139bf8b7aefc11a5531eddc189431e03ff",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4a7e92139bf8b7aefc11a5531eddc189431e03ff/comments",
    "author": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f2c416bcf5f898dd996106871dbbd7051851ccac",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f2c416bcf5f898dd996106871dbbd7051851ccac",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f2c416bcf5f898dd996106871dbbd7051851ccac"
      }
    ],
    "stats": {
      "total": 3406,
      "additions": 2845,
      "deletions": 561
    },
    "files": [
      {
        "sha": "9a6f27b98d67173ca25bb677d4c5482df4050c7f",
        "filename": ".appveyor.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/.appveyor.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/.appveyor.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.appveyor.yml?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -82,7 +82,7 @@ after_build:\n #- 7z a bitcoin-%APPVEYOR_BUILD_VERSION%.zip %APPVEYOR_BUILD_FOLDER%\\build_msvc\\%platform%\\%configuration%\\*.exe\n test_script:\n - cmd: src\\test_bitcoin.exe -k stdout -e stdout 2> NUL\n-- cmd: src\\bench_bitcoin.exe -evals=1 -scaling=0 > NUL\n+- cmd: src\\bench_bitcoin.exe > NUL\n - ps:  python test\\util\\bitcoin-util-test.py\n - cmd: python test\\util\\rpcauth-test.py\n # Fee estimation test failing on appveyor with: WinError 10048] Only one usage of each socket address (protocol/network address/port) is normally permitted."
      },
      {
        "sha": "3f6f915e5bed93677ae293e86a2fb74f0be5a4d5",
        "filename": "contrib/devtools/copyright_header.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/contrib/devtools/copyright_header.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/contrib/devtools/copyright_header.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/copyright_header.py?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -22,6 +22,7 @@\n     'src/reverse_iterator.h',\n     'src/test/fuzz/FuzzedDataProvider.h',\n     'src/tinyformat.h',\n+    'src/bench/nanobench.h',\n     'test/functional/test_framework/bignum.py',\n     # python init:\n     '*__init__.py',"
      },
      {
        "sha": "b6cd86eafe6e7df2f81da7e0835239a40c476a24",
        "filename": "doc/benchmarking.md",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/doc/benchmarking.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/doc/benchmarking.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/benchmarking.md?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -19,8 +19,10 @@ After compiling bitcoin-core, the benchmarks can be run with:\n \n The output will look similar to:\n ```\n-# Benchmark, evals, iterations, total, min, max, median\n-AssembleBlock, 5, 700, 1.79954, 0.000510913, 0.000517018, 0.000514497\n+|             ns/byte |              byte/s | error % | benchmark\n+|--------------------:|--------------------:|--------:|:----------------------------------------------\n+|               64.13 |       15,592,356.01 |    0.1% | `Base58CheckEncode`\n+|               24.56 |       40,722,672.68 |    0.2% | `Base58Decode`\n ...\n ```\n "
      },
      {
        "sha": "02c0d175873172f24f4cf65c4acc568b030bdb48",
        "filename": "src/Makefile.bench.include",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/Makefile.bench.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/Makefile.bench.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.bench.include?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -31,6 +31,8 @@ bench_bench_bitcoin_SOURCES = \\\n   bench/merkle_root.cpp \\\n   bench/mempool_eviction.cpp \\\n   bench/mempool_stress.cpp \\\n+  bench/nanobench.h \\\n+  bench/nanobench.cpp \\\n   bench/rpc_blockchain.cpp \\\n   bench/rpc_mempool.cpp \\\n   bench/util_time.cpp \\"
      },
      {
        "sha": "8fd809bbe7b049413ec6d1efe84f26627da470e4",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -972,8 +972,8 @@ endif\n if TARGET_WINDOWS\n else\n if ENABLE_BENCH\n-\t@echo \"Running bench/bench_bitcoin -evals=1 -scaling=0...\"\n-\t$(BENCH_BINARY) -evals=1 -scaling=0 > /dev/null\n+\t@echo \"Running bench/bench_bitcoin ...\"\n+\t$(BENCH_BINARY) > /dev/null\n endif\n endif\n \t$(AM_V_at)$(MAKE) $(AM_MAKEFLAGS) -C secp256k1 check"
      },
      {
        "sha": "00544cba315a3f6269e2851ec54845569caa0ea7",
        "filename": "src/bench/base58.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/base58.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/base58.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/base58.cpp?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -10,7 +10,7 @@\n #include <vector>\n \n \n-static void Base58Encode(benchmark::State& state)\n+static void Base58Encode(benchmark::Bench& bench)\n {\n     static const std::array<unsigned char, 32> buff = {\n         {\n@@ -19,13 +19,13 @@ static void Base58Encode(benchmark::State& state)\n             200, 24\n         }\n     };\n-    while (state.KeepRunning()) {\n+    bench.batch(buff.size()).unit(\"byte\").run([&] {\n         EncodeBase58(buff.data(), buff.data() + buff.size());\n-    }\n+    });\n }\n \n \n-static void Base58CheckEncode(benchmark::State& state)\n+static void Base58CheckEncode(benchmark::Bench& bench)\n {\n     static const std::array<unsigned char, 32> buff = {\n         {\n@@ -36,22 +36,22 @@ static void Base58CheckEncode(benchmark::State& state)\n     };\n     std::vector<unsigned char> vch;\n     vch.assign(buff.begin(), buff.end());\n-    while (state.KeepRunning()) {\n+    bench.batch(buff.size()).unit(\"byte\").run([&] {\n         EncodeBase58Check(vch);\n-    }\n+    });\n }\n \n \n-static void Base58Decode(benchmark::State& state)\n+static void Base58Decode(benchmark::Bench& bench)\n {\n     const char* addr = \"17VZNX1SN5NtKa8UQFxwQbFeFc3iqRYhem\";\n     std::vector<unsigned char> vch;\n-    while (state.KeepRunning()) {\n+    bench.batch(strlen(addr)).unit(\"byte\").run([&] {\n         (void) DecodeBase58(addr, vch, 64);\n-    }\n+    });\n }\n \n \n-BENCHMARK(Base58Encode, 470 * 1000);\n-BENCHMARK(Base58CheckEncode, 320 * 1000);\n-BENCHMARK(Base58Decode, 800 * 1000);\n+BENCHMARK(Base58Encode);\n+BENCHMARK(Base58CheckEncode);\n+BENCHMARK(Base58Decode);"
      },
      {
        "sha": "66dce7a0ba3474e22e7eb14e9503482395f0ec96",
        "filename": "src/bench/bech32.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 8,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/bech32.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/bech32.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bech32.cpp?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -3,6 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <bench/bench.h>\n+#include <bench/nanobench.h>\n \n #include <bech32.h>\n #include <util/strencodings.h>\n@@ -11,26 +12,26 @@\n #include <string>\n \n \n-static void Bech32Encode(benchmark::State& state)\n+static void Bech32Encode(benchmark::Bench& bench)\n {\n     std::vector<uint8_t> v = ParseHex(\"c97f5a67ec381b760aeaf67573bc164845ff39a3bb26a1cee401ac67243b48db\");\n     std::vector<unsigned char> tmp = {0};\n     tmp.reserve(1 + 32 * 8 / 5);\n     ConvertBits<8, 5, true>([&](unsigned char c) { tmp.push_back(c); }, v.begin(), v.end());\n-    while (state.KeepRunning()) {\n+    bench.batch(v.size()).unit(\"byte\").run([&] {\n         bech32::Encode(\"bc\", tmp);\n-    }\n+    });\n }\n \n \n-static void Bech32Decode(benchmark::State& state)\n+static void Bech32Decode(benchmark::Bench& bench)\n {\n     std::string addr = \"bc1qkallence7tjawwvy0dwt4twc62qjgaw8f4vlhyd006d99f09\";\n-    while (state.KeepRunning()) {\n+    bench.batch(addr.size()).unit(\"byte\").run([&] {\n         bech32::Decode(addr);\n-    }\n+    });\n }\n \n \n-BENCHMARK(Bech32Encode, 800 * 1000);\n-BENCHMARK(Bech32Decode, 800 * 1000);\n+BENCHMARK(Bech32Encode);\n+BENCHMARK(Bech32Decode);"
      },
      {
        "sha": "daaded86864b751b914b50282c9f5dfee1fb9e16",
        "filename": "src/bench/bench.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 117,
        "changes": 143,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/bench.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/bench.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench.cpp?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -8,113 +8,38 @@\n #include <test/util/setup_common.h>\n #include <validation.h>\n \n-#include <algorithm>\n-#include <assert.h>\n-#include <iomanip>\n-#include <iostream>\n-#include <numeric>\n #include <regex>\n \n const RegTestingSetup* g_testing_setup = nullptr;\n const std::function<void(const std::string&)> G_TEST_LOG_FUN{};\n \n-void benchmark::ConsolePrinter::header()\n-{\n-    std::cout << \"# Benchmark, evals, iterations, total, min, max, median\" << std::endl;\n-}\n-\n-void benchmark::ConsolePrinter::result(const State& state)\n-{\n-    auto results = state.m_elapsed_results;\n-    std::sort(results.begin(), results.end());\n-\n-    double total = state.m_num_iters * std::accumulate(results.begin(), results.end(), 0.0);\n-\n-    double front = 0;\n-    double back = 0;\n-    double median = 0;\n-\n-    if (!results.empty()) {\n-        front = results.front();\n-        back = results.back();\n-\n-        size_t mid = results.size() / 2;\n-        median = results[mid];\n-        if (0 == results.size() % 2) {\n-            median = (results[mid] + results[mid + 1]) / 2;\n-        }\n-    }\n-\n-    std::cout << std::setprecision(6);\n-    std::cout << state.m_name << \", \" << state.m_num_evals << \", \" << state.m_num_iters << \", \" << total << \", \" << front << \", \" << back << \", \" << median << std::endl;\n-}\n-\n-void benchmark::ConsolePrinter::footer() {}\n-benchmark::PlotlyPrinter::PlotlyPrinter(std::string plotly_url, int64_t width, int64_t height)\n-    : m_plotly_url(plotly_url), m_width(width), m_height(height)\n-{\n-}\n-\n-void benchmark::PlotlyPrinter::header()\n-{\n-    std::cout << \"<html><head>\"\n-              << \"<script src=\\\"\" << m_plotly_url << \"\\\"></script>\"\n-              << \"</head><body><div id=\\\"myDiv\\\" style=\\\"width:\" << m_width << \"px; height:\" << m_height << \"px\\\"></div>\"\n-              << \"<script> var data = [\"\n-              << std::endl;\n-}\n-\n-void benchmark::PlotlyPrinter::result(const State& state)\n-{\n-    std::cout << \"{ \" << std::endl\n-              << \"  name: '\" << state.m_name << \"', \" << std::endl\n-              << \"  y: [\";\n-\n-    const char* prefix = \"\";\n-    for (const auto& e : state.m_elapsed_results) {\n-        std::cout << prefix << std::setprecision(6) << e;\n-        prefix = \", \";\n-    }\n-    std::cout << \"],\" << std::endl\n-              << \"  boxpoints: 'all', jitter: 0.3, pointpos: 0, type: 'box',\"\n-              << std::endl\n-              << \"},\" << std::endl;\n-}\n-\n-void benchmark::PlotlyPrinter::footer()\n-{\n-    std::cout << \"]; var layout = { showlegend: false, yaxis: { rangemode: 'tozero', autorange: true } };\"\n-              << \"Plotly.newPlot('myDiv', data, layout);\"\n-              << \"</script></body></html>\";\n-}\n-\n-\n benchmark::BenchRunner::BenchmarkMap& benchmark::BenchRunner::benchmarks()\n {\n-    static std::map<std::string, Bench> benchmarks_map;\n+    static std::map<std::string, BenchFunction> benchmarks_map;\n     return benchmarks_map;\n }\n \n-benchmark::BenchRunner::BenchRunner(std::string name, benchmark::BenchFunction func, uint64_t num_iters_for_one_second)\n+benchmark::BenchRunner::BenchRunner(std::string name, benchmark::BenchFunction func)\n {\n-    benchmarks().insert(std::make_pair(name, Bench{func, num_iters_for_one_second}));\n+    benchmarks().insert(std::make_pair(name, func));\n }\n \n-void benchmark::BenchRunner::RunAll(Printer& printer, uint64_t num_evals, double scaling, const std::string& filter, bool is_list_only)\n+void benchmark::BenchRunner::RunAll(const std::string& filter, bool is_list_only)\n {\n-    if (!std::ratio_less_equal<benchmark::clock::period, std::micro>::value) {\n-        std::cerr << \"WARNING: Clock precision is worse than microsecond - benchmarks may be less accurate!\\n\";\n-    }\n-#ifdef DEBUG\n-    std::cerr << \"WARNING: This is a debug build - may result in slower benchmarks.\\n\";\n-#endif\n-\n     std::regex reFilter(filter);\n     std::smatch baseMatch;\n \n-    printer.header();\n-\n+    std::vector<Result> benchmarkResults;\n     for (const auto& p : benchmarks()) {\n+        if (!std::regex_match(p.first, baseMatch, reFilter)) {\n+            continue;\n+        }\n+\n+        if (is_list_only) {\n+            std::cout << p.first << std::endl;\n+            continue;\n+        }\n+\n         RegTestingSetup test{};\n         assert(g_testing_setup == nullptr);\n         g_testing_setup = &test;\n@@ -125,37 +50,21 @@ void benchmark::BenchRunner::RunAll(Printer& printer, uint64_t num_evals, double\n             assert(witness_enabled);\n         }\n \n-        if (!std::regex_match(p.first, baseMatch, reFilter)) {\n-             g_testing_setup = nullptr;\n-            continue;\n-        }\n-\n-        uint64_t num_iters = static_cast<uint64_t>(p.second.num_iters_for_one_second * scaling);\n-        if (0 == num_iters) {\n-            num_iters = 1;\n-        }\n-        State state(p.first, num_evals, num_iters, printer);\n-        if (!is_list_only) {\n-            p.second.func(state);\n-        }\n-        printer.result(state);\n+        Bench bench;\n+        bench.name(p.first);\n+        p.second(bench);\n+        benchmarkResults.push_back(bench.results().back());\n         g_testing_setup = nullptr;\n     }\n \n-    printer.footer();\n-}\n-\n-bool benchmark::State::UpdateTimer(const benchmark::time_point current_time)\n-{\n-    if (m_start_time != time_point()) {\n-        std::chrono::duration<double> diff = current_time - m_start_time;\n-        m_elapsed_results.push_back(diff.count() / m_num_iters);\n+    // Generate legacy CSV data to \"benchmarkresults.csv\"\n+    std::ofstream fout(\"benchmarkresults.csv\");\n \n-        if (m_elapsed_results.size() == m_num_evals) {\n-            return false;\n-        }\n+    // Base58CheckEncode, 5, 320000, 2.70232, 1.68246e-06, 1.69408e-06, 1.69268e-06\n+    if (fout.is_open()) {\n+        templates::generate(\"# Benchmark, evals, iterations, total, min, max, median\\n\"\n+                            \"{{#result}}{{name}}, {{epochs}}, {{average(iterations)}}, {{sumProduct(iterations, elapsed)}}, {{minimum(elapsed)}}, {{maximum(elapsed)}}, {{median(elapsed)}}\\n\"\n+                            \"{{/result}}\",\n+            benchmarkResults, fout);\n     }\n-\n-    m_num_iters_left = m_num_iters - 1;\n-    return true;\n }"
      },
      {
        "sha": "04c8d010facc29f9c30309e37a642f663e288334",
        "filename": "src/bench/bench.h",
        "status": "modified",
        "additions": 13,
        "deletions": 101,
        "changes": 114,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/bench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/bench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench.h?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -9,136 +9,48 @@\n #include <map>\n #include <string>\n #include <vector>\n-#include <chrono>\n \n+#include <bench/nanobench.h>\n #include <boost/preprocessor/cat.hpp>\n #include <boost/preprocessor/stringize.hpp>\n \n struct RegTestingSetup;\n extern const RegTestingSetup* g_testing_setup; //!< A pointer to the current testing setup\n-\n-// Simple micro-benchmarking framework; API mostly matches a subset of the Google Benchmark\n-// framework (see https://github.com/google/benchmark)\n-// Why not use the Google Benchmark framework? Because adding Yet Another Dependency\n-// (that uses cmake as its build system and has lots of features we don't need) isn't\n-// worth it.\n-\n /*\n  * Usage:\n \n-static void CODE_TO_TIME(benchmark::State& state)\n+static void CODE_TO_TIME(benchmark::Bench& bench)\n {\n     ... do any setup needed...\n-    while (state.KeepRunning()) {\n+    nanobench::Config().run([&] {\n        ... do stuff you want to time...\n-    }\n+    });\n     ... do any cleanup needed...\n }\n \n-// default to running benchmark for 5000 iterations\n-BENCHMARK(CODE_TO_TIME, 5000);\n+BENCHMARK(CODE_TO_TIME);\n \n  */\n \n namespace benchmark {\n-// In case high_resolution_clock is steady, prefer that, otherwise use steady_clock.\n-struct best_clock {\n-    using hi_res_clock = std::chrono::high_resolution_clock;\n-    using steady_clock = std::chrono::steady_clock;\n-    using type = std::conditional<hi_res_clock::is_steady, hi_res_clock, steady_clock>::type;\n-};\n-using clock = best_clock::type;\n-using time_point = clock::time_point;\n-using duration = clock::duration;\n-\n-class Printer;\n-\n-class State\n-{\n-public:\n-    std::string m_name;\n-    uint64_t m_num_iters_left;\n-    const uint64_t m_num_iters;\n-    const uint64_t m_num_evals;\n-    std::vector<double> m_elapsed_results;\n-    time_point m_start_time;\n \n-    bool UpdateTimer(time_point finish_time);\n+using namespace ankerl::nanobench;\n \n-    State(std::string name, uint64_t num_evals, double num_iters, Printer& printer) : m_name(name), m_num_iters_left(0), m_num_iters(num_iters), m_num_evals(num_evals)\n-    {\n-    }\n-\n-    inline bool KeepRunning()\n-    {\n-        if (m_num_iters_left--) {\n-            return true;\n-        }\n-\n-        bool result = UpdateTimer(clock::now());\n-        // measure again so runtime of UpdateTimer is not included\n-        m_start_time = clock::now();\n-        return result;\n-    }\n-};\n-\n-typedef std::function<void(State&)> BenchFunction;\n+typedef std::function<void(Bench&)> BenchFunction;\n \n class BenchRunner\n {\n-    struct Bench {\n-        BenchFunction func;\n-        uint64_t num_iters_for_one_second;\n-    };\n-    typedef std::map<std::string, Bench> BenchmarkMap;\n+    typedef std::map<std::string, BenchFunction> BenchmarkMap;\n     static BenchmarkMap& benchmarks();\n \n public:\n-    BenchRunner(std::string name, BenchFunction func, uint64_t num_iters_for_one_second);\n-\n-    static void RunAll(Printer& printer, uint64_t num_evals, double scaling, const std::string& filter, bool is_list_only);\n-};\n-\n-// interface to output benchmark results.\n-class Printer\n-{\n-public:\n-    virtual ~Printer() {}\n-    virtual void header() = 0;\n-    virtual void result(const State& state) = 0;\n-    virtual void footer() = 0;\n-};\n+    BenchRunner(std::string name, BenchFunction func);\n \n-// default printer to console, shows min, max, median.\n-class ConsolePrinter : public Printer\n-{\n-public:\n-    void header() override;\n-    void result(const State& state) override;\n-    void footer() override;\n-};\n-\n-// creates box plot with plotly.js\n-class PlotlyPrinter : public Printer\n-{\n-public:\n-    PlotlyPrinter(std::string plotly_url, int64_t width, int64_t height);\n-    void header() override;\n-    void result(const State& state) override;\n-    void footer() override;\n-\n-private:\n-    std::string m_plotly_url;\n-    int64_t m_width;\n-    int64_t m_height;\n+    static void RunAll(const std::string& filter, bool is_list_only);\n };\n }\n-\n-\n-// BENCHMARK(foo, num_iters_for_one_second) expands to:  benchmark::BenchRunner bench_11foo(\"foo\", num_iterations);\n-// Choose a num_iters_for_one_second that takes roughly 1 second. The goal is that all benchmarks should take approximately\n-// the same time, and scaling factor can be used that the total time is appropriate for your system.\n-#define BENCHMARK(n, num_iters_for_one_second) \\\n-    benchmark::BenchRunner BOOST_PP_CAT(bench_, BOOST_PP_CAT(__LINE__, n))(BOOST_PP_STRINGIZE(n), n, (num_iters_for_one_second));\n+// BENCHMARK(foo) expands to:  benchmark::BenchRunner bench_11foo(\"foo\");\n+#define BENCHMARK(n) \\\n+    benchmark::BenchRunner BOOST_PP_CAT(bench_, BOOST_PP_CAT(__LINE__, n))(BOOST_PP_STRINGIZE(n), n);\n \n #endif // BITCOIN_BENCH_BENCH_H"
      },
      {
        "sha": "4601cfb60cb4bf8519da43bdb6c4a6aa1b6532c8",
        "filename": "src/bench/bench_bitcoin.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 36,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/bench_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/bench_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench_bitcoin.cpp?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -9,26 +9,14 @@\n \n #include <memory>\n \n-static const int64_t DEFAULT_BENCH_EVALUATIONS = 5;\n static const char* DEFAULT_BENCH_FILTER = \".*\";\n-static const char* DEFAULT_BENCH_SCALING = \"1.0\";\n-static const char* DEFAULT_BENCH_PRINTER = \"console\";\n-static const char* DEFAULT_PLOT_PLOTLYURL = \"https://cdn.plot.ly/plotly-latest.min.js\";\n-static const int64_t DEFAULT_PLOT_WIDTH = 1024;\n-static const int64_t DEFAULT_PLOT_HEIGHT = 768;\n \n static void SetupBenchArgs()\n {\n     SetupHelpOptions(gArgs);\n \n     gArgs.AddArg(\"-list\", \"List benchmarks without executing them. Can be combined with -scaling and -filter\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-evals=<n>\", strprintf(\"Number of measurement evaluations to perform. (default: %u)\", DEFAULT_BENCH_EVALUATIONS), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-filter=<regex>\", strprintf(\"Regular expression filter to select benchmark by name (default: %s)\", DEFAULT_BENCH_FILTER), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-scaling=<n>\", strprintf(\"Scaling factor for benchmark's runtime (default: %u)\", DEFAULT_BENCH_SCALING), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-printer=(console|plot)\", strprintf(\"Choose printer format. console: print data to console. plot: Print results as HTML graph (default: %s)\", DEFAULT_BENCH_PRINTER), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-plot-plotlyurl=<uri>\", strprintf(\"URL to use for plotly.js (default: %s)\", DEFAULT_PLOT_PLOTLYURL), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-plot-width=<x>\", strprintf(\"Plot width in pixel (default: %u)\", DEFAULT_PLOT_WIDTH), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n-    gArgs.AddArg(\"-plot-height=<x>\", strprintf(\"Plot height in pixel (default: %u)\", DEFAULT_PLOT_HEIGHT), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n }\n \n int main(int argc, char** argv)\n@@ -46,34 +34,11 @@ int main(int argc, char** argv)\n         return EXIT_SUCCESS;\n     }\n \n-    int64_t evaluations = gArgs.GetArg(\"-evals\", DEFAULT_BENCH_EVALUATIONS);\n     std::string regex_filter = gArgs.GetArg(\"-filter\", DEFAULT_BENCH_FILTER);\n-    std::string scaling_str = gArgs.GetArg(\"-scaling\", DEFAULT_BENCH_SCALING);\n     bool is_list_only = gArgs.GetBoolArg(\"-list\", false);\n \n-    if (evaluations == 0) {\n-        return EXIT_SUCCESS;\n-    } else if (evaluations < 0) {\n-        tfm::format(std::cerr, \"Error parsing evaluations argument: %d\\n\", evaluations);\n-        return EXIT_FAILURE;\n-    }\n-\n-    double scaling_factor;\n-    if (!ParseDouble(scaling_str, &scaling_factor)) {\n-        tfm::format(std::cerr, \"Error parsing scaling factor as double: %s\\n\", scaling_str);\n-        return EXIT_FAILURE;\n-    }\n-\n-    std::unique_ptr<benchmark::Printer> printer = MakeUnique<benchmark::ConsolePrinter>();\n-    std::string printer_arg = gArgs.GetArg(\"-printer\", DEFAULT_BENCH_PRINTER);\n-    if (\"plot\" == printer_arg) {\n-        printer.reset(new benchmark::PlotlyPrinter(\n-            gArgs.GetArg(\"-plot-plotlyurl\", DEFAULT_PLOT_PLOTLYURL),\n-            gArgs.GetArg(\"-plot-width\", DEFAULT_PLOT_WIDTH),\n-            gArgs.GetArg(\"-plot-height\", DEFAULT_PLOT_HEIGHT)));\n-    }\n \n-    benchmark::BenchRunner::RunAll(*printer, evaluations, scaling_factor, regex_filter, is_list_only);\n+    benchmark::BenchRunner::RunAll(regex_filter, is_list_only);\n \n     return EXIT_SUCCESS;\n }"
      },
      {
        "sha": "7d578e301ee05e2db45316871bdf7b6453030211",
        "filename": "src/bench/block_assemble.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/block_assemble.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/block_assemble.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/block_assemble.cpp?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -14,7 +14,7 @@\n \n #include <vector>\n \n-static void AssembleBlock(benchmark::State& state)\n+static void AssembleBlock(benchmark::Bench& bench)\n {\n     const std::vector<unsigned char> op_true{OP_TRUE};\n     CScriptWitness witness;\n@@ -46,9 +46,9 @@ static void AssembleBlock(benchmark::State& state)\n         }\n     }\n \n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         PrepareBlock(g_testing_setup->m_node, SCRIPT_PUB);\n-    }\n+    });\n }\n \n-BENCHMARK(AssembleBlock, 700);\n+BENCHMARK(AssembleBlock);"
      },
      {
        "sha": "f9444c437a110cb0825c969e90b2e1e5104a308d",
        "filename": "src/bench/ccoins_caching.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/ccoins_caching.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/ccoins_caching.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/ccoins_caching.cpp?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -16,7 +16,7 @@\n // characteristics than e.g. reindex timings. But that's not a requirement of\n // every benchmark.\"\n // (https://github.com/bitcoin/bitcoin/issues/7883#issuecomment-224807484)\n-static void CCoinsCaching(benchmark::State& state)\n+static void CCoinsCaching(benchmark::Bench& bench)\n {\n     FillableSigningProvider keystore;\n     CCoinsView coinsDummy;\n@@ -41,12 +41,12 @@ static void CCoinsCaching(benchmark::State& state)\n \n     // Benchmark.\n     const CTransaction tx_1(t1);\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         bool success = AreInputsStandard(tx_1, coins);\n         assert(success);\n         CAmount value = coins.GetValueIn(tx_1);\n         assert(value == (50 + 21 + 22) * COIN);\n-    }\n+    });\n }\n \n-BENCHMARK(CCoinsCaching, 170 * 1000);\n+BENCHMARK(CCoinsCaching);"
      },
      {
        "sha": "913e0f8d575a96cb62b96596812141919bb7d2a2",
        "filename": "src/bench/chacha20.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/chacha20.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/chacha20.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/chacha20.cpp?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -11,34 +11,34 @@ static const uint64_t BUFFER_SIZE_TINY  = 64;\n static const uint64_t BUFFER_SIZE_SMALL = 256;\n static const uint64_t BUFFER_SIZE_LARGE = 1024*1024;\n \n-static void CHACHA20(benchmark::State& state, size_t buffersize)\n+static void CHACHA20(benchmark::Bench& bench, size_t buffersize)\n {\n     std::vector<uint8_t> key(32,0);\n     ChaCha20 ctx(key.data(), key.size());\n     ctx.SetIV(0);\n     ctx.Seek(0);\n     std::vector<uint8_t> in(buffersize,0);\n     std::vector<uint8_t> out(buffersize,0);\n-    while (state.KeepRunning()) {\n+    bench.batch(in.size()).unit(\"byte\").run([&] {\n         ctx.Crypt(in.data(), out.data(), in.size());\n-    }\n+    });\n }\n \n-static void CHACHA20_64BYTES(benchmark::State& state)\n+static void CHACHA20_64BYTES(benchmark::Bench& bench)\n {\n-    CHACHA20(state, BUFFER_SIZE_TINY);\n+    CHACHA20(bench, BUFFER_SIZE_TINY);\n }\n \n-static void CHACHA20_256BYTES(benchmark::State& state)\n+static void CHACHA20_256BYTES(benchmark::Bench& bench)\n {\n-    CHACHA20(state, BUFFER_SIZE_SMALL);\n+    CHACHA20(bench, BUFFER_SIZE_SMALL);\n }\n \n-static void CHACHA20_1MB(benchmark::State& state)\n+static void CHACHA20_1MB(benchmark::Bench& bench)\n {\n-    CHACHA20(state, BUFFER_SIZE_LARGE);\n+    CHACHA20(bench, BUFFER_SIZE_LARGE);\n }\n \n-BENCHMARK(CHACHA20_64BYTES, 500000);\n-BENCHMARK(CHACHA20_256BYTES, 250000);\n-BENCHMARK(CHACHA20_1MB, 340);\n+BENCHMARK(CHACHA20_64BYTES);\n+BENCHMARK(CHACHA20_256BYTES);\n+BENCHMARK(CHACHA20_1MB);"
      },
      {
        "sha": "f82b1632183ce7bdd41d64555b797a742287f42b",
        "filename": "src/bench/chacha_poly_aead.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 32,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/chacha_poly_aead.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/chacha_poly_aead.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/chacha_poly_aead.cpp?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -21,15 +21,15 @@ static const unsigned char k2[32] = {0};\n \n static ChaCha20Poly1305AEAD aead(k1, 32, k2, 32);\n \n-static void CHACHA20_POLY1305_AEAD(benchmark::State& state, size_t buffersize, bool include_decryption)\n+static void CHACHA20_POLY1305_AEAD(benchmark::Bench& bench, size_t buffersize, bool include_decryption)\n {\n     std::vector<unsigned char> in(buffersize + CHACHA20_POLY1305_AEAD_AAD_LEN + POLY1305_TAGLEN, 0);\n     std::vector<unsigned char> out(buffersize + CHACHA20_POLY1305_AEAD_AAD_LEN + POLY1305_TAGLEN, 0);\n     uint64_t seqnr_payload = 0;\n     uint64_t seqnr_aad = 0;\n     int aad_pos = 0;\n     uint32_t len = 0;\n-    while (state.KeepRunning()) {\n+    bench.batch(buffersize).unit(\"byte\").run([&] {\n         // encrypt or decrypt the buffer with a static key\n         assert(aead.Crypt(seqnr_payload, seqnr_aad, aad_pos, out.data(), out.size(), in.data(), buffersize, true));\n \n@@ -53,70 +53,71 @@ static void CHACHA20_POLY1305_AEAD(benchmark::State& state, size_t buffersize, b\n             seqnr_aad = 0;\n             aad_pos = 0;\n         }\n-    }\n+    });\n }\n \n-static void CHACHA20_POLY1305_AEAD_64BYTES_ONLY_ENCRYPT(benchmark::State& state)\n+static void CHACHA20_POLY1305_AEAD_64BYTES_ONLY_ENCRYPT(benchmark::Bench& bench)\n {\n-    CHACHA20_POLY1305_AEAD(state, BUFFER_SIZE_TINY, false);\n+    CHACHA20_POLY1305_AEAD(bench, BUFFER_SIZE_TINY, false);\n }\n \n-static void CHACHA20_POLY1305_AEAD_256BYTES_ONLY_ENCRYPT(benchmark::State& state)\n+static void CHACHA20_POLY1305_AEAD_256BYTES_ONLY_ENCRYPT(benchmark::Bench& bench)\n {\n-    CHACHA20_POLY1305_AEAD(state, BUFFER_SIZE_SMALL, false);\n+    CHACHA20_POLY1305_AEAD(bench, BUFFER_SIZE_SMALL, false);\n }\n \n-static void CHACHA20_POLY1305_AEAD_1MB_ONLY_ENCRYPT(benchmark::State& state)\n+static void CHACHA20_POLY1305_AEAD_1MB_ONLY_ENCRYPT(benchmark::Bench& bench)\n {\n-    CHACHA20_POLY1305_AEAD(state, BUFFER_SIZE_LARGE, false);\n+    CHACHA20_POLY1305_AEAD(bench, BUFFER_SIZE_LARGE, false);\n }\n \n-static void CHACHA20_POLY1305_AEAD_64BYTES_ENCRYPT_DECRYPT(benchmark::State& state)\n+static void CHACHA20_POLY1305_AEAD_64BYTES_ENCRYPT_DECRYPT(benchmark::Bench& bench)\n {\n-    CHACHA20_POLY1305_AEAD(state, BUFFER_SIZE_TINY, true);\n+    CHACHA20_POLY1305_AEAD(bench, BUFFER_SIZE_TINY, true);\n }\n \n-static void CHACHA20_POLY1305_AEAD_256BYTES_ENCRYPT_DECRYPT(benchmark::State& state)\n+static void CHACHA20_POLY1305_AEAD_256BYTES_ENCRYPT_DECRYPT(benchmark::Bench& bench)\n {\n-    CHACHA20_POLY1305_AEAD(state, BUFFER_SIZE_SMALL, true);\n+    CHACHA20_POLY1305_AEAD(bench, BUFFER_SIZE_SMALL, true);\n }\n \n-static void CHACHA20_POLY1305_AEAD_1MB_ENCRYPT_DECRYPT(benchmark::State& state)\n+static void CHACHA20_POLY1305_AEAD_1MB_ENCRYPT_DECRYPT(benchmark::Bench& bench)\n {\n-    CHACHA20_POLY1305_AEAD(state, BUFFER_SIZE_LARGE, true);\n+    CHACHA20_POLY1305_AEAD(bench, BUFFER_SIZE_LARGE, true);\n }\n \n // Add Hash() (dbl-sha256) bench for comparison\n \n-static void HASH(benchmark::State& state, size_t buffersize)\n+static void HASH(benchmark::Bench& bench, size_t buffersize)\n {\n     uint8_t hash[CHash256::OUTPUT_SIZE];\n     std::vector<uint8_t> in(buffersize,0);\n-    while (state.KeepRunning())\n+    bench.batch(in.size()).unit(\"byte\").run([&] {\n         CHash256().Write(in.data(), in.size()).Finalize(hash);\n+    });\n }\n \n-static void HASH_64BYTES(benchmark::State& state)\n+static void HASH_64BYTES(benchmark::Bench& bench)\n {\n-    HASH(state, BUFFER_SIZE_TINY);\n+    HASH(bench, BUFFER_SIZE_TINY);\n }\n \n-static void HASH_256BYTES(benchmark::State& state)\n+static void HASH_256BYTES(benchmark::Bench& bench)\n {\n-    HASH(state, BUFFER_SIZE_SMALL);\n+    HASH(bench, BUFFER_SIZE_SMALL);\n }\n \n-static void HASH_1MB(benchmark::State& state)\n+static void HASH_1MB(benchmark::Bench& bench)\n {\n-    HASH(state, BUFFER_SIZE_LARGE);\n+    HASH(bench, BUFFER_SIZE_LARGE);\n }\n \n-BENCHMARK(CHACHA20_POLY1305_AEAD_64BYTES_ONLY_ENCRYPT, 500000);\n-BENCHMARK(CHACHA20_POLY1305_AEAD_256BYTES_ONLY_ENCRYPT, 250000);\n-BENCHMARK(CHACHA20_POLY1305_AEAD_1MB_ONLY_ENCRYPT, 340);\n-BENCHMARK(CHACHA20_POLY1305_AEAD_64BYTES_ENCRYPT_DECRYPT, 500000);\n-BENCHMARK(CHACHA20_POLY1305_AEAD_256BYTES_ENCRYPT_DECRYPT, 250000);\n-BENCHMARK(CHACHA20_POLY1305_AEAD_1MB_ENCRYPT_DECRYPT, 340);\n-BENCHMARK(HASH_64BYTES, 500000);\n-BENCHMARK(HASH_256BYTES, 250000);\n-BENCHMARK(HASH_1MB, 340);\n+BENCHMARK(CHACHA20_POLY1305_AEAD_64BYTES_ONLY_ENCRYPT);\n+BENCHMARK(CHACHA20_POLY1305_AEAD_256BYTES_ONLY_ENCRYPT);\n+BENCHMARK(CHACHA20_POLY1305_AEAD_1MB_ONLY_ENCRYPT);\n+BENCHMARK(CHACHA20_POLY1305_AEAD_64BYTES_ENCRYPT_DECRYPT);\n+BENCHMARK(CHACHA20_POLY1305_AEAD_256BYTES_ENCRYPT_DECRYPT);\n+BENCHMARK(CHACHA20_POLY1305_AEAD_1MB_ENCRYPT_DECRYPT);\n+BENCHMARK(HASH_64BYTES);\n+BENCHMARK(HASH_256BYTES);\n+BENCHMARK(HASH_1MB);"
      },
      {
        "sha": "b93f8746dde545e12ee25d3ea4c938a9b8fabf48",
        "filename": "src/bench/checkblock.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/checkblock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/checkblock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkblock.cpp?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -14,29 +14,29 @@\n // a block off the wire, but before we can relay the block on to peers using\n // compact block relay.\n \n-static void DeserializeBlockTest(benchmark::State& state)\n+static void DeserializeBlockTest(benchmark::Bench& bench)\n {\n     CDataStream stream(benchmark::data::block413567, SER_NETWORK, PROTOCOL_VERSION);\n     char a = '\\0';\n     stream.write(&a, 1); // Prevent compaction\n \n-    while (state.KeepRunning()) {\n+    bench.unit(\"block\").run([&] {\n         CBlock block;\n         stream >> block;\n         bool rewound = stream.Rewind(benchmark::data::block413567.size());\n         assert(rewound);\n-    }\n+    });\n }\n \n-static void DeserializeAndCheckBlockTest(benchmark::State& state)\n+static void DeserializeAndCheckBlockTest(benchmark::Bench& bench)\n {\n     CDataStream stream(benchmark::data::block413567, SER_NETWORK, PROTOCOL_VERSION);\n     char a = '\\0';\n     stream.write(&a, 1); // Prevent compaction\n \n     const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n \n-    while (state.KeepRunning()) {\n+    bench.unit(\"block\").run([&] {\n         CBlock block; // Note that CBlock caches its checked state, so we need to recreate it here\n         stream >> block;\n         bool rewound = stream.Rewind(benchmark::data::block413567.size());\n@@ -45,8 +45,8 @@ static void DeserializeAndCheckBlockTest(benchmark::State& state)\n         BlockValidationState validationState;\n         bool checked = CheckBlock(block, validationState, chainParams->GetConsensus());\n         assert(checked);\n-    }\n+    });\n }\n \n-BENCHMARK(DeserializeBlockTest, 130);\n-BENCHMARK(DeserializeAndCheckBlockTest, 160);\n+BENCHMARK(DeserializeBlockTest);\n+BENCHMARK(DeserializeAndCheckBlockTest);"
      },
      {
        "sha": "d4eed945b9ee9e9b7d7449b3507a92938e9cb527",
        "filename": "src/bench/checkqueue.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 10,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/checkqueue.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/checkqueue.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkqueue.cpp?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -20,7 +20,7 @@ static const unsigned int QUEUE_BATCH_SIZE = 128;\n // This Benchmark tests the CheckQueue with a slightly realistic workload,\n // where checks all contain a prevector that is indirect 50% of the time\n // and there is a little bit of work done between calls to Add.\n-static void CCheckQueueSpeedPrevectorJob(benchmark::State& state)\n+static void CCheckQueueSpeedPrevectorJob(benchmark::Bench& bench)\n {\n     struct PrevectorJob {\n         prevector<PREVECTOR_SIZE, uint8_t> p;\n@@ -40,22 +40,27 @@ static void CCheckQueueSpeedPrevectorJob(benchmark::State& state)\n     for (auto x = 0; x < std::max(MIN_CORES, GetNumCores()); ++x) {\n        tg.create_thread([&]{queue.Thread();});\n     }\n-    while (state.KeepRunning()) {\n+\n+    // create all the data once, then submit copies in the benchmark.\n+    FastRandomContext insecure_rand(true);\n+    std::vector<std::vector<PrevectorJob>> vBatches(BATCHES);\n+    for (auto& vChecks : vBatches) {\n+        vChecks.reserve(BATCH_SIZE);\n+        for (size_t x = 0; x < BATCH_SIZE; ++x)\n+            vChecks.emplace_back(insecure_rand);\n+    }\n+\n+    bench.minEpochIterations(10).batch(BATCH_SIZE * BATCHES).unit(\"job\").run([&] {\n         // Make insecure_rand here so that each iteration is identical.\n-        FastRandomContext insecure_rand(true);\n         CCheckQueueControl<PrevectorJob> control(&queue);\n-        std::vector<std::vector<PrevectorJob>> vBatches(BATCHES);\n-        for (auto& vChecks : vBatches) {\n-            vChecks.reserve(BATCH_SIZE);\n-            for (size_t x = 0; x < BATCH_SIZE; ++x)\n-                vChecks.emplace_back(insecure_rand);\n+        for (auto vChecks : vBatches) {\n             control.Add(vChecks);\n         }\n         // control waits for completion by RAII, but\n         // it is done explicitly here for clarity\n         control.Wait();\n-    }\n+    });\n     tg.interrupt_all();\n     tg.join_all();\n }\n-BENCHMARK(CCheckQueueSpeedPrevectorJob, 1400);\n+BENCHMARK(CCheckQueueSpeedPrevectorJob);"
      },
      {
        "sha": "6106b7977cb26fe6ae9d5026c79d70eb920848da",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -27,7 +27,7 @@ static void addCoin(const CAmount& nValue, const CWallet& wallet, std::vector<st\n // same one over and over isn't too useful. Generating random isn't useful\n // either for measurements.\"\n // (https://github.com/bitcoin/bitcoin/issues/7883#issuecomment-224807484)\n-static void CoinSelection(benchmark::State& state)\n+static void CoinSelection(benchmark::Bench& bench)\n {\n     NodeContext node;\n     auto chain = interfaces::MakeChain(node);\n@@ -51,15 +51,15 @@ static void CoinSelection(benchmark::State& state)\n \n     const CoinEligibilityFilter filter_standard(1, 6, 0);\n     const CoinSelectionParams coin_selection_params(true, 34, 148, CFeeRate(0), 0);\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         std::set<CInputCoin> setCoinsRet;\n         CAmount nValueRet;\n         bool bnb_used;\n         bool success = wallet.SelectCoinsMinConf(1003 * COIN, filter_standard, groups, setCoinsRet, nValueRet, coin_selection_params, bnb_used);\n         assert(success);\n         assert(nValueRet == 1003 * COIN);\n         assert(setCoinsRet.size() == 2);\n-    }\n+    });\n }\n \n typedef std::set<CInputCoin> CoinSet;\n@@ -91,7 +91,7 @@ static CAmount make_hard_case(int utxos, std::vector<OutputGroup>& utxo_pool)\n     return target;\n }\n \n-static void BnBExhaustion(benchmark::State& state)\n+static void BnBExhaustion(benchmark::Bench& bench)\n {\n     // Setup\n     testWallet.SetupLegacyScriptPubKeyMan();\n@@ -100,16 +100,16 @@ static void BnBExhaustion(benchmark::State& state)\n     CAmount value_ret = 0;\n     CAmount not_input_fees = 0;\n \n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         // Benchmark\n         CAmount target = make_hard_case(17, utxo_pool);\n         SelectCoinsBnB(utxo_pool, target, 0, selection, value_ret, not_input_fees); // Should exhaust\n \n         // Cleanup\n         utxo_pool.clear();\n         selection.clear();\n-    }\n+    });\n }\n \n-BENCHMARK(CoinSelection, 650);\n-BENCHMARK(BnBExhaustion, 650);\n+BENCHMARK(CoinSelection);\n+BENCHMARK(BnBExhaustion);"
      },
      {
        "sha": "93392a490801cd4642e7aefd2980f4595c7dc16c",
        "filename": "src/bench/crypto_hash.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 32,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/crypto_hash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/crypto_hash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/crypto_hash.cpp?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -16,88 +16,92 @@\n /* Number of bytes to hash per iteration */\n static const uint64_t BUFFER_SIZE = 1000*1000;\n \n-static void RIPEMD160(benchmark::State& state)\n+static void RIPEMD160(benchmark::Bench& bench)\n {\n     uint8_t hash[CRIPEMD160::OUTPUT_SIZE];\n     std::vector<uint8_t> in(BUFFER_SIZE,0);\n-    while (state.KeepRunning())\n+    bench.batch(in.size()).unit(\"byte\").run([&] {\n         CRIPEMD160().Write(in.data(), in.size()).Finalize(hash);\n+    });\n }\n \n-static void SHA1(benchmark::State& state)\n+static void SHA1(benchmark::Bench& bench)\n {\n     uint8_t hash[CSHA1::OUTPUT_SIZE];\n     std::vector<uint8_t> in(BUFFER_SIZE,0);\n-    while (state.KeepRunning())\n+    bench.batch(in.size()).unit(\"byte\").run([&] {\n         CSHA1().Write(in.data(), in.size()).Finalize(hash);\n+    });\n }\n \n-static void SHA256(benchmark::State& state)\n+static void SHA256(benchmark::Bench& bench)\n {\n     uint8_t hash[CSHA256::OUTPUT_SIZE];\n     std::vector<uint8_t> in(BUFFER_SIZE,0);\n-    while (state.KeepRunning())\n+    bench.batch(in.size()).unit(\"byte\").run([&] {\n         CSHA256().Write(in.data(), in.size()).Finalize(hash);\n+    });\n }\n \n-static void SHA256_32b(benchmark::State& state)\n+static void SHA256_32b(benchmark::Bench& bench)\n {\n     std::vector<uint8_t> in(32,0);\n-    while (state.KeepRunning()) {\n+    bench.batch(in.size()).unit(\"byte\").run([&] {\n         CSHA256()\n             .Write(in.data(), in.size())\n             .Finalize(in.data());\n-    }\n+    });\n }\n \n-static void SHA256D64_1024(benchmark::State& state)\n+static void SHA256D64_1024(benchmark::Bench& bench)\n {\n     std::vector<uint8_t> in(64 * 1024, 0);\n-    while (state.KeepRunning()) {\n+    bench.batch(in.size()).unit(\"byte\").run([&] {\n         SHA256D64(in.data(), in.data(), 1024);\n-    }\n+    });\n }\n \n-static void SHA512(benchmark::State& state)\n+static void SHA512(benchmark::Bench& bench)\n {\n     uint8_t hash[CSHA512::OUTPUT_SIZE];\n     std::vector<uint8_t> in(BUFFER_SIZE,0);\n-    while (state.KeepRunning())\n+    bench.batch(in.size()).unit(\"byte\").run([&] {\n         CSHA512().Write(in.data(), in.size()).Finalize(hash);\n+    });\n }\n \n-static void SipHash_32b(benchmark::State& state)\n+static void SipHash_32b(benchmark::Bench& bench)\n {\n     uint256 x;\n     uint64_t k1 = 0;\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         *((uint64_t*)x.begin()) = SipHashUint256(0, ++k1, x);\n-    }\n+    });\n }\n \n-static void FastRandom_32bit(benchmark::State& state)\n+static void FastRandom_32bit(benchmark::Bench& bench)\n {\n     FastRandomContext rng(true);\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         rng.rand32();\n-    }\n+    });\n }\n \n-static void FastRandom_1bit(benchmark::State& state)\n+static void FastRandom_1bit(benchmark::Bench& bench)\n {\n     FastRandomContext rng(true);\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         rng.randbool();\n-    }\n+    });\n }\n \n-BENCHMARK(RIPEMD160, 440);\n-BENCHMARK(SHA1, 570);\n-BENCHMARK(SHA256, 340);\n-BENCHMARK(SHA512, 330);\n+BENCHMARK(RIPEMD160);\n+BENCHMARK(SHA1);\n+BENCHMARK(SHA256);\n+BENCHMARK(SHA512);\n \n-BENCHMARK(SHA256_32b, 4700 * 1000);\n-BENCHMARK(SipHash_32b, 40 * 1000 * 1000);\n-BENCHMARK(SHA256D64_1024, 7400);\n-BENCHMARK(FastRandom_32bit, 110 * 1000 * 1000);\n-BENCHMARK(FastRandom_1bit, 440 * 1000 * 1000);\n+BENCHMARK(SHA256_32b);\n+BENCHMARK(SipHash_32b);\n+BENCHMARK(SHA256D64_1024);\n+BENCHMARK(FastRandom_32bit);\n+BENCHMARK(FastRandom_1bit);"
      },
      {
        "sha": "00463fea811f94764392474197b8a03c467fb618",
        "filename": "src/bench/duplicate_inputs.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/duplicate_inputs.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/duplicate_inputs.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/duplicate_inputs.cpp?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -11,8 +11,7 @@\n #include <validation.h>\n \n \n-\n-static void DuplicateInputs(benchmark::State& state)\n+static void DuplicateInputs(benchmark::Bench& bench)\n {\n     const CScript SCRIPT_PUB{CScript(OP_TRUE)};\n \n@@ -53,11 +52,11 @@ static void DuplicateInputs(benchmark::State& state)\n \n     block.hashMerkleRoot = BlockMerkleRoot(block);\n \n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         BlockValidationState cvstate{};\n         assert(!CheckBlock(block, cvstate, chainparams.GetConsensus(), false, false));\n         assert(cvstate.GetRejectReason() == \"bad-txns-inputs-duplicate\");\n-    }\n+    });\n }\n \n-BENCHMARK(DuplicateInputs, 10);\n+BENCHMARK(DuplicateInputs);"
      },
      {
        "sha": "49ed8a7072d1b9b10baf64d0c79d41d7e1d96513",
        "filename": "src/bench/examples.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 15,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/examples.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/examples.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/examples.cpp?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -5,29 +5,18 @@\n #include <bench/bench.h>\n #include <util/time.h>\n \n-// Sanity test: this should loop ten times, and\n-// min/max/average should be close to 100ms.\n-static void Sleep100ms(benchmark::State& state)\n-{\n-    while (state.KeepRunning()) {\n-        UninterruptibleSleep(std::chrono::milliseconds{100});\n-    }\n-}\n-\n-BENCHMARK(Sleep100ms, 10);\n-\n // Extremely fast-running benchmark:\n #include <math.h>\n \n volatile double sum = 0.0; // volatile, global so not optimized away\n \n-static void Trig(benchmark::State& state)\n+static void Trig(benchmark::Bench& bench)\n {\n     double d = 0.01;\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         sum += sin(d);\n         d += 0.000001;\n-    }\n+    });\n }\n \n-BENCHMARK(Trig, 12 * 1000 * 1000);\n+BENCHMARK(Trig);"
      },
      {
        "sha": "ef83242e416694e0e2c6a2277ca4fef8948a3e63",
        "filename": "src/bench/gcs_filter.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/gcs_filter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/gcs_filter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/gcs_filter.cpp?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -5,7 +5,7 @@\n #include <bench/bench.h>\n #include <blockfilter.h>\n \n-static void ConstructGCSFilter(benchmark::State& state)\n+static void ConstructGCSFilter(benchmark::Bench& bench)\n {\n     GCSFilter::ElementSet elements;\n     for (int i = 0; i < 10000; ++i) {\n@@ -16,14 +16,14 @@ static void ConstructGCSFilter(benchmark::State& state)\n     }\n \n     uint64_t siphash_k0 = 0;\n-    while (state.KeepRunning()) {\n+    bench.batch(elements.size()).unit(\"elem\").run([&] {\n         GCSFilter filter({siphash_k0, 0, 20, 1 << 20}, elements);\n \n         siphash_k0++;\n-    }\n+    });\n }\n \n-static void MatchGCSFilter(benchmark::State& state)\n+static void MatchGCSFilter(benchmark::Bench& bench)\n {\n     GCSFilter::ElementSet elements;\n     for (int i = 0; i < 10000; ++i) {\n@@ -34,10 +34,10 @@ static void MatchGCSFilter(benchmark::State& state)\n     }\n     GCSFilter filter({0, 0, 20, 1 << 20}, elements);\n \n-    while (state.KeepRunning()) {\n+    bench.unit(\"elem\").run([&] {\n         filter.Match(GCSFilter::Element());\n-    }\n+    });\n }\n \n-BENCHMARK(ConstructGCSFilter, 1000);\n-BENCHMARK(MatchGCSFilter, 50 * 1000);\n+BENCHMARK(ConstructGCSFilter);\n+BENCHMARK(MatchGCSFilter);"
      },
      {
        "sha": "32b060a15a350fb814c7d87af4ca102e2259af08",
        "filename": "src/bench/lockedpool.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 17,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/lockedpool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/lockedpool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/lockedpool.cpp?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -9,10 +9,9 @@\n #include <vector>\n \n #define ASIZE 2048\n-#define BITER 5000\n #define MSIZE 2048\n \n-static void BenchLockedPool(benchmark::State& state)\n+static void BenchLockedPool(benchmark::Bench& bench)\n {\n     void *synth_base = reinterpret_cast<void*>(0x08000000);\n     const size_t synth_size = 1024*1024;\n@@ -22,24 +21,22 @@ static void BenchLockedPool(benchmark::State& state)\n     for (int x=0; x<ASIZE; ++x)\n         addr.push_back(nullptr);\n     uint32_t s = 0x12345678;\n-    while (state.KeepRunning()) {\n-        for (int x=0; x<BITER; ++x) {\n-            int idx = s & (addr.size()-1);\n-            if (s & 0x80000000) {\n-                b.free(addr[idx]);\n-                addr[idx] = nullptr;\n-            } else if(!addr[idx]) {\n-                addr[idx] = b.alloc((s >> 16) & (MSIZE-1));\n-            }\n-            bool lsb = s & 1;\n-            s >>= 1;\n-            if (lsb)\n-                s ^= 0xf00f00f0; // LFSR period 0xf7ffffe0\n+    bench.run([&] {\n+        int idx = s & (addr.size() - 1);\n+        if (s & 0x80000000) {\n+            b.free(addr[idx]);\n+            addr[idx] = nullptr;\n+        } else if (!addr[idx]) {\n+            addr[idx] = b.alloc((s >> 16) & (MSIZE - 1));\n         }\n-    }\n+        bool lsb = s & 1;\n+        s >>= 1;\n+        if (lsb)\n+            s ^= 0xf00f00f0; // LFSR period 0xf7ffffe0\n+    });\n     for (void *ptr: addr)\n         b.free(ptr);\n     addr.clear();\n }\n \n-BENCHMARK(BenchLockedPool, 1300);\n+BENCHMARK(BenchLockedPool);"
      },
      {
        "sha": "3204fd5e57d8161203fe08faa4404b61e10b91ad",
        "filename": "src/bench/mempool_eviction.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/mempool_eviction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/mempool_eviction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/mempool_eviction.cpp?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -15,14 +15,14 @@ static void AddTx(const CTransactionRef& tx, const CAmount& nFee, CTxMemPool& po\n     unsigned int sigOpCost = 4;\n     LockPoints lp;\n     pool.addUnchecked(CTxMemPoolEntry(\n-                                         tx, nFee, nTime, nHeight,\n-                                         spendsCoinbase, sigOpCost, lp));\n+        tx, nFee, nTime, nHeight,\n+        spendsCoinbase, sigOpCost, lp));\n }\n \n // Right now this is only testing eviction performance in an extremely small\n // mempool. Code needs to be written to generate a much wider variety of\n // unique transactions for a more meaningful performance measurement.\n-static void MempoolEviction(benchmark::State& state)\n+static void MempoolEviction(benchmark::Bench& bench)\n {\n     CMutableTransaction tx1 = CMutableTransaction();\n     tx1.vin.resize(1);\n@@ -116,7 +116,7 @@ static void MempoolEviction(benchmark::State& state)\n     const CTransactionRef tx6_r{MakeTransactionRef(tx6)};\n     const CTransactionRef tx7_r{MakeTransactionRef(tx7)};\n \n-    while (state.KeepRunning()) {\n+    bench.run([&]() NO_THREAD_SAFETY_ANALYSIS {\n         AddTx(tx1_r, 10000LL, pool);\n         AddTx(tx2_r, 5000LL, pool);\n         AddTx(tx3_r, 20000LL, pool);\n@@ -126,7 +126,7 @@ static void MempoolEviction(benchmark::State& state)\n         AddTx(tx7_r, 9000LL, pool);\n         pool.TrimToSize(pool.DynamicMemoryUsage() * 3 / 4);\n         pool.TrimToSize(GetVirtualTransactionSize(*tx1_r));\n-    }\n+    });\n }\n \n-BENCHMARK(MempoolEviction, 41000);\n+BENCHMARK(MempoolEviction);"
      },
      {
        "sha": "ed8a7387fb0129f81d9e73d8e00a3d6034eee6c7",
        "filename": "src/bench/mempool_stress.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/mempool_stress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/mempool_stress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/mempool_stress.cpp?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -25,7 +25,7 @@ struct Available {\n     Available(CTransactionRef& ref, size_t tx_count) : ref(ref), tx_count(tx_count){}\n };\n \n-static void ComplexMemPool(benchmark::State& state)\n+static void ComplexMemPool(benchmark::Bench& bench)\n {\n     FastRandomContext det_rand{true};\n     std::vector<Available> available_coins;\n@@ -75,13 +75,13 @@ static void ComplexMemPool(benchmark::State& state)\n     }\n     CTxMemPool pool;\n     LOCK2(cs_main, pool.cs);\n-    while (state.KeepRunning()) {\n+    bench.run([&]() NO_THREAD_SAFETY_ANALYSIS {\n         for (auto& tx : ordered_coins) {\n             AddTx(tx, pool);\n         }\n         pool.TrimToSize(pool.DynamicMemoryUsage() * 3 / 4);\n         pool.TrimToSize(GetVirtualTransactionSize(*ordered_coins.front()));\n-    }\n+    });\n }\n \n-BENCHMARK(ComplexMemPool, 1);\n+BENCHMARK(ComplexMemPool);"
      },
      {
        "sha": "66a69b06501bacf36af0740fefc532d11a94d862",
        "filename": "src/bench/merkle_root.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/merkle_root.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/merkle_root.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/merkle_root.cpp?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -8,19 +8,19 @@\n #include <random.h>\n #include <consensus/merkle.h>\n \n-static void MerkleRoot(benchmark::State& state)\n+static void MerkleRoot(benchmark::Bench& bench)\n {\n     FastRandomContext rng(true);\n     std::vector<uint256> leaves;\n     leaves.resize(9001);\n     for (auto& item : leaves) {\n         item = rng.rand256();\n     }\n-    while (state.KeepRunning()) {\n+    bench.batch(leaves.size()).unit(\"leaf\").run([&] {\n         bool mutation = false;\n         uint256 hash = ComputeMerkleRoot(std::vector<uint256>(leaves), &mutation);\n         leaves[mutation] = hash;\n-    }\n+    });\n }\n \n-BENCHMARK(MerkleRoot, 800);\n+BENCHMARK(MerkleRoot);"
      },
      {
        "sha": "fcdd86495a6a84d3cf4ccdd87fb8031d69460167",
        "filename": "src/bench/nanobench.cpp",
        "status": "added",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/nanobench.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/nanobench.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/nanobench.cpp?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -0,0 +1,6 @@\n+// Copyright (c) 2019-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define ANKERL_NANOBENCH_IMPLEMENT\n+#include <bench/nanobench.h>"
      },
      {
        "sha": "041c878bc4a14816bff1d4279419662e9630246f",
        "filename": "src/bench/nanobench.h",
        "status": "added",
        "additions": 2495,
        "deletions": 0,
        "changes": 2495,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/nanobench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/nanobench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/nanobench.h?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -0,0 +1,2495 @@\n+//  __   _ _______ __   _  _____  ______  _______ __   _ _______ _     _\n+//  | \\  | |_____| | \\  | |     | |_____] |______ | \\  | |       |_____|\n+//  |  \\_| |     | |  \\_| |_____| |_____] |______ |  \\_| |_____  |     |\n+//\n+// Microbenchmark framework for C++11/14/17/20\n+// https://github.com/martinus/nanobench\n+//\n+// Licensed under the MIT License <http://opensource.org/licenses/MIT>.\n+// SPDX-License-Identifier: MIT\n+// Copyright (c) 2019-2020 Martin Ankerl <http://martin.ankerl.com>\n+//\n+// Permission is hereby granted, free of charge, to any person obtaining a copy\n+// of this software and associated documentation files (the \"Software\"), to deal\n+// in the Software without restriction, including without limitation the rights\n+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+// copies of the Software, and to permit persons to whom the Software is\n+// furnished to do so, subject to the following conditions:\n+//\n+// The above copyright notice and this permission notice shall be included in all\n+// copies or substantial portions of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+// SOFTWARE.\n+\n+#ifndef ANKERL_NANOBENCH_H_INCLUDED\n+#define ANKERL_NANOBENCH_H_INCLUDED\n+\n+// see https://semver.org/\n+#define ANKERL_NANOBENCH_VERSION_MAJOR 4 // incompatible API changes\n+#define ANKERL_NANOBENCH_VERSION_MINOR 0 // backwards-compatible changes\n+#define ANKERL_NANOBENCH_VERSION_PATCH 0 // backwards-compatible bug fixes\n+\n+///////////////////////////////////////////////////////////////////////////////////////////////////\n+// public facing api - as minimal as possible\n+///////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+#include <chrono>        // high_resolution_clock\n+#include <cstring>       // memcpy\n+#include <iosfwd>        // for std::ostream* custom output target in Config\n+#include <string>        // all names\n+#include <unordered_map> // used by Result\n+#include <vector>        // holds all results\n+\n+#define ANKERL_NANOBENCH(x) ANKERL_NANOBENCH_PRIVATE_##x()\n+\n+#define ANKERL_NANOBENCH_PRIVATE_CXX() __cplusplus\n+#define ANKERL_NANOBENCH_PRIVATE_CXX98() 199711L\n+#define ANKERL_NANOBENCH_PRIVATE_CXX11() 201103L\n+#define ANKERL_NANOBENCH_PRIVATE_CXX14() 201402L\n+#define ANKERL_NANOBENCH_PRIVATE_CXX17() 201703L\n+\n+#if ANKERL_NANOBENCH(CXX) >= ANKERL_NANOBENCH(CXX17)\n+#    define ANKERL_NANOBENCH_PRIVATE_NODISCARD() [[nodiscard]]\n+#else\n+#    define ANKERL_NANOBENCH_PRIVATE_NODISCARD()\n+#endif\n+\n+#if defined(__clang__)\n+#    define ANKERL_NANOBENCH_PRIVATE_IGNORE_PADDED_PUSH() \\\n+        _Pragma(\"clang diagnostic push\") _Pragma(\"clang diagnostic ignored \\\"-Wpadded\\\"\")\n+#    define ANKERL_NANOBENCH_PRIVATE_IGNORE_PADDED_POP() _Pragma(\"clang diagnostic pop\")\n+#else\n+#    define ANKERL_NANOBENCH_PRIVATE_IGNORE_PADDED_PUSH()\n+#    define ANKERL_NANOBENCH_PRIVATE_IGNORE_PADDED_POP()\n+#endif\n+\n+#if defined(ANKERL_NANOBENCH_LOG_ENABLED)\n+#    include <iostream>\n+#    define ANKERL_NANOBENCH_LOG(x) std::cout << __FUNCTION__ << \"@\" << __LINE__ << \": \" << x << std::endl\n+#else\n+#    define ANKERL_NANOBENCH_LOG(x)\n+#endif\n+\n+#if defined(__linux__)\n+#    define ANKERL_NANOBENCH_PRIVATE_PERF_COUNTERS() 1\n+#else\n+#    define ANKERL_NANOBENCH_PRIVATE_PERF_COUNTERS() 0\n+#endif\n+\n+#if defined(__clang__)\n+#    define ANKERL_NANOBENCH_NO_SANITIZE(...) __attribute__((no_sanitize(__VA_ARGS__)))\n+#else\n+#    define ANKERL_NANOBENCH_NO_SANITIZE(...)\n+#endif\n+\n+#if defined(_MSC_VER)\n+#    define ANKERL_NANOBENCH_PRIVATE_NOINLINE() __declspec(noinline)\n+#else\n+#    define ANKERL_NANOBENCH_PRIVATE_NOINLINE() __attribute__((noinline))\n+#endif\n+\n+// workaround missing \"is_trivially_copyable\" in g++ < 5.0\n+// See https://stackoverflow.com/a/31798726/48181\n+#if defined(__GNUC__) && __GNUC__ < 5\n+#    define ANKERL_NANOBENCH_IS_TRIVIALLY_COPYABLE(...) __has_trivial_copy(__VA_ARGS__)\n+#else\n+#    define ANKERL_NANOBENCH_IS_TRIVIALLY_COPYABLE(...) std::is_trivially_copyable<__VA_ARGS__>::value\n+#endif\n+\n+// declarations ///////////////////////////////////////////////////////////////////////////////////\n+\n+namespace ankerl {\n+namespace nanobench {\n+\n+using Clock = std::chrono::high_resolution_clock;\n+class Bench;\n+struct Config;\n+class Result;\n+class Rng;\n+class BigO;\n+\n+// Contains mustache-like templates\n+namespace templates {\n+\n+// CSV file from the benchmark results.\n+char const* csv() noexcept;\n+\n+// HTML graphic using plotly.js\n+char const* htmlBoxplot() noexcept;\n+\n+// JSON that contains all result data\n+char const* json() noexcept;\n+\n+// Generates output from the template and results into the given stream\n+void generate(char const* mustacheTemplate, std::vector<Result> const& results, std::ostream& out);\n+\n+} // namespace templates\n+\n+namespace detail {\n+\n+template <typename T>\n+struct PerfCountSet;\n+\n+class IterationLogic;\n+class PerformanceCounters;\n+\n+#if ANKERL_NANOBENCH(PERF_COUNTERS)\n+class LinuxPerformanceCounters;\n+#endif\n+\n+} // namespace detail\n+} // namespace nanobench\n+} // namespace ankerl\n+\n+// definitions ////////////////////////////////////////////////////////////////////////////////////\n+\n+namespace ankerl {\n+namespace nanobench {\n+namespace detail {\n+\n+template <typename T>\n+struct PerfCountSet {\n+    T pageFaults{};\n+    T cpuCycles{};\n+    T contextSwitches{};\n+    T instructions{};\n+    T branchInstructions{};\n+    T branchMisses{};\n+};\n+\n+} // namespace detail\n+\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+struct Config {\n+    // actual benchmark config\n+    std::string mBenchmarkTitle = \"benchmark\";\n+    std::string mBenchmarkName = \"noname\";\n+    std::string mUnit = \"op\";\n+    double mBatch = 1.0;\n+    double mComplexityN = -1.0;\n+    size_t mNumEpochs = 11;\n+    size_t mClockResolutionMultiple = static_cast<size_t>(1000);\n+    std::chrono::nanoseconds mMaxEpochTime = std::chrono::milliseconds(100);\n+    std::chrono::nanoseconds mMinEpochTime{};\n+    uint64_t mMinEpochIterations{1};\n+    uint64_t mWarmup = 0;\n+    std::ostream* mOut = nullptr;\n+    bool mShowPerformanceCounters = true;\n+    bool mIsRelative = false;\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+// Result returned after a benchmark has finished. Can be used as a baseline for relative().\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+class Result {\n+public:\n+    explicit Result(Config const& benchmarkConfig);\n+\n+    // adds new measurement results\n+    // all values are scaled by iters (except iters...)\n+    void add(Clock::duration totalElapsed, uint64_t iters, detail::PerformanceCounters const& pc);\n+\n+    ANKERL_NANOBENCH(NODISCARD) Config const& config() const noexcept;\n+\n+    ANKERL_NANOBENCH(NODISCARD) double median(std::string const& query) const;\n+    ANKERL_NANOBENCH(NODISCARD) double medianAbsolutePercentError(std::string const& query) const;\n+    ANKERL_NANOBENCH(NODISCARD) double average(std::string const& query) const;\n+    ANKERL_NANOBENCH(NODISCARD) double sum(std::string const& query) const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double sumProduct(std::string const& query1, std::string const& query2) const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double minimum(std::string const& query) const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double maximum(std::string const& query) const noexcept;\n+\n+    ANKERL_NANOBENCH(NODISCARD) bool has(std::string const& query) const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double get(size_t idx, std::string const& query) const;\n+    ANKERL_NANOBENCH(NODISCARD) bool empty() const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) size_t size() const noexcept;\n+\n+private:\n+    Config mConfig{};\n+    std::unordered_map<std::string, std::vector<double>> mNameToMeasurements{};\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+// RomuTrio, Great for general purpose work, including huge jobs.\n+// Est. capacity = 2^75 bytes. Register pressure = 6. State size = 192 bits.\n+// By Mark Overton, Source: http://www.romu-random.org/\n+class Rng final {\n+public:\n+    using result_type = uint64_t;\n+\n+    static constexpr uint64_t(min)();\n+    static constexpr uint64_t(max)();\n+\n+    // don't allow copying, it's dangerous\n+    Rng(Rng const&) = delete;\n+    Rng& operator=(Rng const&) = delete;\n+\n+    // moving is ok\n+    Rng(Rng&&) noexcept = default;\n+    Rng& operator=(Rng&&) noexcept = default;\n+    ~Rng() noexcept = default;\n+\n+    Rng();\n+    explicit Rng(uint64_t seed) noexcept;\n+    Rng(uint64_t x, uint64_t y, uint64_t z) noexcept;\n+\n+    ANKERL_NANOBENCH(NODISCARD) Rng copy() const noexcept;\n+    void assign(Rng const& other) noexcept;\n+\n+    // that one's inline so it is fast\n+    inline uint64_t operator()() noexcept;\n+\n+    // random double in range [0, 1(\n+    inline double uniform01() noexcept;\n+\n+private:\n+    static constexpr uint64_t rotl(uint64_t x, unsigned k) noexcept;\n+\n+    uint64_t mX;\n+    uint64_t mY;\n+    uint64_t mZ;\n+};\n+\n+// Main entry class for the microbenchmark framework.\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+class Bench {\n+public:\n+    Bench();\n+\n+    Bench(Bench&& other);\n+    Bench& operator=(Bench&& other);\n+    Bench(Bench const& other);\n+    Bench& operator=(Bench const& other);\n+\n+    ~Bench() noexcept;\n+\n+    // Set the batch size, e.g. number of processed bytes, or some other metric for the size of the processed data in each iteration.\n+    // Best used in combination with `unit`. Any argument is cast to double.\n+    template <typename T>\n+    Bench& batch(T b) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double batch() const noexcept;\n+\n+    // Marks the next run as the baseline. The following runs will be compared to this run. 100% will mean it is exactly as fast as the\n+    // baseline, >100% means it is faster than the baseline. It is calculated by `100% * runtime_baseline / runtime`. So e.g. 200%\n+    // means the current run is twice as fast as the baseline.\n+    Bench& relative(bool isRelativeEnabled) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) bool relative() const noexcept;\n+\n+    Bench& performanceCounters(bool showPerformanceCounters) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) bool performanceCounters() const noexcept;\n+\n+    // Operation unit. Defaults to \"op\", could be e.g. \"byte\" for string processing. This is used for the table header, e.g. to show\n+    // `ns/byte`. Use singular (byte, not bytes). A change clears the currently collected results.\n+    Bench& unit(std::string unit);\n+    ANKERL_NANOBENCH(NODISCARD) std::string const& unit() const noexcept;\n+\n+    // Title of the benchmark, will be shown in the table header. A change clears the currently collected results.\n+    Bench& title(std::string benchmarkTitle);\n+    ANKERL_NANOBENCH(NODISCARD) std::string const& title() const noexcept;\n+\n+    // Name of the benchmark, will be shown in the table row.\n+    Bench& name(std::string benchmarkName);\n+    ANKERL_NANOBENCH(NODISCARD) std::string const& name() const noexcept;\n+\n+    // Set the output stream where the resulting markdown table will be printed to. The default is `&std::cout`. You can disable all\n+    // output by setting `nullptr`.\n+    Bench& output(std::ostream* outstream) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) std::ostream* output() const noexcept;\n+\n+    // Number of epochs to evaluate. The reported result will be the median of evaluation of each epoch. Defaults to 11. The higher you\n+    // choose this, the more deterministic will the result be and outliers will be more easily removed. The default is already quite\n+    // high to be able to filter most outliers.\n+    //\n+    // For slow benchmarks you might want to reduce this number.\n+    Bench& epochs(size_t numEpochs) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) size_t epochs() const noexcept;\n+\n+    // Modern processors have a very accurate clock, being able to measure as low as 20 nanoseconds. This allows nanobech to be so\n+    // fast: we only run the benchmark sufficiently often so that the clock's accuracy is good enough. The default is to run one epoch\n+    // for 2000 times the clock resolution. So for 20ns resolution and 11 epochs, this gives a total runtime of `20ns * 8000 * 11 ~\n+    // 2ms` for a benchmark to get accurate results.\n+    Bench& clockResolutionMultiple(size_t multiple) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) size_t clockResolutionMultiple() const noexcept;\n+\n+    // As a safety precausion if the clock is not very accurate, we can set an upper limit for the maximum evaluation time per epoch.\n+    // Default is 100ms.\n+    Bench& maxEpochTime(std::chrono::nanoseconds t) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) std::chrono::nanoseconds maxEpochTime() const noexcept;\n+\n+    // Sets the minimum time each epoch should take. Default is zero, so clockResolutionMultiple() can do it's best guess. You can\n+    // increase this if you have the time and results are not accurate enough.\n+    Bench& minEpochTime(std::chrono::nanoseconds t) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) std::chrono::nanoseconds minEpochTime() const noexcept;\n+\n+    // Sets the minimum number of iterations each epoch should take. Default is 1. For high median average percentage error (MdAPE),\n+    // which happens when your benchmark is unstable, you might want to increase the minimum number to get more accurate reslts.\n+    Bench& minEpochIterations(uint64_t numIters) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) uint64_t minEpochIterations() const noexcept;\n+\n+    // Set a number of iterations that are initially performed without any measurements, to warmup caches / database / whatever.\n+    // Normally this is not needed, since we show the median result so initial outliers will be filtered away automatically.\n+    Bench& warmup(uint64_t numWarmupIters) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) uint64_t warmup() const noexcept;\n+\n+    // Gets all benchmark results\n+    ANKERL_NANOBENCH(NODISCARD) std::vector<Result> const& results() const noexcept;\n+\n+    // Repeatedly calls op() based on the configuration, and performs measurements.\n+    // Make sure this is noinline to prevent the compiler to optimize beyond different benchmarks. This can have quite a big effect\n+    template <typename Op>\n+    ANKERL_NANOBENCH(NOINLINE)\n+    Bench& run(std::string const& benchmarkName, Op op);\n+\n+    // Repeatedly calls op() based on the configuration, and performs measurements. Uses previously set name.\n+    // Make sure this is noinline to prevent the compiler to optimize beyond different benchmarks. This can have quite a big effect\n+    template <typename Op>\n+    ANKERL_NANOBENCH(NOINLINE)\n+    Bench& run(Op op);\n+\n+    // Convenience: makes sure none of the given arguments are optimized away by the compiler.\n+    template <typename Arg>\n+    Bench& doNotOptimizeAway(Arg&& arg);\n+\n+    // Parses the mustache-like template and renders the output into os.\n+    Bench& render(char const* templateContent, std::ostream& os);\n+\n+    // Set the length of N for the next benchmark run, so it is possible to calculate bigO.\n+    template <typename T>\n+    Bench& complexityN(T b) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double complexityN() const noexcept;\n+\n+    // calculates bigO of the results with all preconfigured complexity functions\n+    std::vector<BigO> complexityBigO() const;\n+\n+    // calculates bigO for a custom function\n+    template <typename Op>\n+    BigO complexityBigO(std::string const& name, Op op) const;\n+\n+    // Set all the configuration.\n+    Bench& config(Config const& benchmarkConfig);\n+    ANKERL_NANOBENCH(NODISCARD) Config const& config() const noexcept;\n+\n+private:\n+    Config mConfig{};\n+    std::vector<Result> mResults{};\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+// Makes sure none of the given arguments are optimized away by the compiler.\n+template <typename Arg>\n+void doNotOptimizeAway(Arg&& arg);\n+\n+namespace detail {\n+\n+#if defined(_MSC_VER)\n+void doNotOptimizeAwaySink(void const*);\n+\n+template <typename T>\n+void doNotOptimizeAway(T const& val);\n+\n+#else\n+\n+// see folly's Benchmark.h\n+template <typename T>\n+constexpr bool doNotOptimizeNeedsIndirect() {\n+    using Decayed = typename std::decay<T>::type;\n+    return !ANKERL_NANOBENCH_IS_TRIVIALLY_COPYABLE(Decayed) || sizeof(Decayed) > sizeof(long) || std::is_pointer<Decayed>::value;\n+}\n+\n+template <typename T>\n+typename std::enable_if<!doNotOptimizeNeedsIndirect<T>()>::type doNotOptimizeAway(T const& val) {\n+    // NOLINTNEXTLINE(hicpp-no-assembler)\n+    asm volatile(\"\" ::\"r\"(val));\n+}\n+\n+template <typename T>\n+typename std::enable_if<doNotOptimizeNeedsIndirect<T>()>::type doNotOptimizeAway(T const& val) {\n+    // NOLINTNEXTLINE(hicpp-no-assembler)\n+    asm volatile(\"\" ::\"m\"(val) : \"memory\");\n+}\n+#endif\n+\n+// internally used, but visible because run() is templated\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+class IterationLogic {\n+public:\n+    explicit IterationLogic(Bench const& config) noexcept;\n+\n+    ANKERL_NANOBENCH(NODISCARD) uint64_t numIters() const noexcept;\n+    void add(std::chrono::nanoseconds elapsed, PerformanceCounters const& pc) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) Result& result();\n+\n+private:\n+    enum class State { warmup, upscaling_runtime, measuring, endless };\n+\n+    void showResult(std::string const& errorMessage) const;\n+    ANKERL_NANOBENCH(NODISCARD) bool isCloseEnoughForMeasurements(std::chrono::nanoseconds elapsed) const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) uint64_t calcBestNumIters(std::chrono::nanoseconds elapsed, uint64_t iters) noexcept;\n+    void upscale(std::chrono::nanoseconds elapsed);\n+\n+    uint64_t mNumIters = 1;\n+    Bench const& mBench;\n+    std::chrono::nanoseconds mTargetRuntimePerEpoch{};\n+    Result mResult;\n+    Rng mRng{123};\n+    std::chrono::nanoseconds mTotalElapsed{};\n+    uint64_t mTotalNumIters = 0;\n+\n+    State mState = State::upscaling_runtime;\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+class PerformanceCounters {\n+public:\n+    PerformanceCounters(PerformanceCounters const&) = delete;\n+    PerformanceCounters& operator=(PerformanceCounters const&) = delete;\n+\n+    PerformanceCounters();\n+    ~PerformanceCounters();\n+\n+    void beginMeasure();\n+    void endMeasure();\n+    void updateResults(uint64_t numIters);\n+\n+    ANKERL_NANOBENCH(NODISCARD) PerfCountSet<uint64_t> const& val() const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) PerfCountSet<bool> const& has() const noexcept;\n+\n+private:\n+#if ANKERL_NANOBENCH(PERF_COUNTERS)\n+    LinuxPerformanceCounters* mPc = nullptr;\n+#endif\n+    PerfCountSet<uint64_t> mVal;\n+    PerfCountSet<bool> mHas;\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+// Gets the singleton\n+PerformanceCounters& performanceCounters();\n+\n+} // namespace detail\n+\n+class BigO {\n+public:\n+    using RangeMeasure = std::vector<std::pair<double, double>>;\n+\n+    template <typename Op>\n+    static RangeMeasure mapRangeMeasure(RangeMeasure data, Op op) {\n+        for (auto& rangeMeasure : data) {\n+            rangeMeasure.first = op(rangeMeasure.first);\n+        }\n+        return data;\n+    }\n+\n+    static RangeMeasure collectRangeMeasure(std::vector<Result> const& results);\n+\n+    template <typename Op>\n+    BigO(std::string const& bigOName, RangeMeasure const& rangeMeasure, Op rangeToN)\n+        : BigO(bigOName, mapRangeMeasure(rangeMeasure, rangeToN)) {}\n+\n+    BigO(std::string const& bigOName, RangeMeasure const& scaledRangeMeasure);\n+    ANKERL_NANOBENCH(NODISCARD) std::string const& name() const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double constant() const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double normalizedRootMeanSquare() const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) bool operator<(BigO const& other) const noexcept;\n+\n+private:\n+    std::string mName{};\n+    double mConstant{};\n+    double mNormalizedRootMeanSquare{};\n+};\n+std::ostream& operator<<(std::ostream& os, BigO const& bigO);\n+std::ostream& operator<<(std::ostream& os, std::vector<ankerl::nanobench::BigO> const& bigOs);\n+\n+} // namespace nanobench\n+} // namespace ankerl\n+\n+// implementation /////////////////////////////////////////////////////////////////////////////////\n+\n+namespace ankerl {\n+namespace nanobench {\n+\n+constexpr uint64_t(Rng::min)() {\n+    return 0;\n+}\n+\n+constexpr uint64_t(Rng::max)() {\n+    return (std::numeric_limits<uint64_t>::max)();\n+}\n+\n+// Mark this as no_sanitize, otherwise UBSAN will say we got an unsigned integer overflow. Which is not a undefined behavior, but often\n+// a bug. Not here though.\n+ANKERL_NANOBENCH_NO_SANITIZE(\"integer\")\n+uint64_t Rng::operator()() noexcept {\n+    uint64_t x = mX;\n+    uint64_t y = mY;\n+    mX = UINT64_C(15241094284759029579) * mZ;\n+    mZ = rotl(mZ - y, 44U);\n+    mY = rotl(mY - x, 12U);\n+    return x;\n+}\n+\n+// see http://prng.di.unimi.it/\n+double Rng::uniform01() noexcept {\n+    auto i = (UINT64_C(0x3ff) << 52U) | (operator()() >> 12U);\n+    // can't use union in c++ here for type puning, it's undefined behavior.\n+    // std::memcpy is optimized anyways.\n+    double d;\n+    std::memcpy(&d, &i, sizeof(double));\n+    return d - 1.0;\n+}\n+\n+constexpr uint64_t Rng::rotl(uint64_t x, unsigned k) noexcept {\n+    return (x << k) | (x >> (64U - k));\n+}\n+\n+template <typename Op>\n+ANKERL_NANOBENCH_NO_SANITIZE(\"integer\")\n+Bench& Bench::run(Op op) {\n+    // It is important that this method is kept short so the compiler can do better optimizations/ inlining of op()\n+    detail::IterationLogic iterationLogic(*this);\n+    auto& pc = detail::performanceCounters();\n+\n+    while (auto n = iterationLogic.numIters()) {\n+        pc.beginMeasure();\n+        Clock::time_point before = Clock::now();\n+        while (n-- > 0) {\n+            op();\n+        }\n+        Clock::time_point after = Clock::now();\n+        pc.endMeasure();\n+        pc.updateResults(iterationLogic.numIters());\n+        iterationLogic.add(after - before, pc);\n+    }\n+    mResults.emplace_back(std::move(iterationLogic.result()));\n+    return *this;\n+}\n+\n+// Performs all evaluations.\n+template <typename Op>\n+Bench& Bench::run(std::string const& benchmarkName, Op op) {\n+    name(benchmarkName);\n+    return run(std::move(op));\n+}\n+\n+template <typename Op>\n+BigO Bench::complexityBigO(std::string const& benchmarkName, Op op) const {\n+    return BigO(benchmarkName, BigO::collectRangeMeasure(mResults), op);\n+}\n+\n+// Set the batch size, e.g. number of processed bytes, or some other metric for the size of the processed data in each iteration.\n+// Any argument is cast to double.\n+template <typename T>\n+Bench& Bench::batch(T b) noexcept {\n+    mConfig.mBatch = static_cast<double>(b);\n+    return *this;\n+}\n+\n+// Sets the computation complexity of the next run. Any argument is cast to double.\n+template <typename T>\n+Bench& Bench::complexityN(T n) noexcept {\n+    mConfig.mComplexityN = static_cast<double>(n);\n+    return *this;\n+}\n+\n+// Convenience: makes sure none of the given arguments are optimized away by the compiler.\n+template <typename Arg>\n+Bench& Bench::doNotOptimizeAway(Arg&& arg) {\n+    detail::doNotOptimizeAway(std::forward<Arg>(arg));\n+    return *this;\n+}\n+\n+// Makes sure none of the given arguments are optimized away by the compiler.\n+template <typename Arg>\n+void doNotOptimizeAway(Arg&& arg) {\n+    detail::doNotOptimizeAway(std::forward<Arg>(arg));\n+}\n+\n+namespace detail {\n+\n+#if defined(_MSC_VER)\n+template <typename T>\n+void doNotOptimizeAway(T const& val) {\n+    doNotOptimizeAwaySink(&val);\n+}\n+\n+#endif\n+\n+} // namespace detail\n+} // namespace nanobench\n+} // namespace ankerl\n+\n+#if defined(ANKERL_NANOBENCH_IMPLEMENT)\n+\n+///////////////////////////////////////////////////////////////////////////////////////////////////\n+// implementation part\n+///////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+#    include <algorithm> // sort, reverse\n+#    include <atomic>    // compare_exchange_strong in loop overhead\n+#    include <cstdlib>   // getenv\n+#    include <cstring>   // strstr, strncmp\n+#    include <fstream>   // ifstream to parse proc files\n+#    include <iomanip>   // setw, setprecision\n+#    include <iostream>  // cout\n+#    include <numeric>   // accumulate\n+#    include <random>    // random_device\n+#    include <sstream>   // to_s in Number\n+#    include <stdexcept> // throw for rendering templates\n+#    include <tuple>     // std::tie\n+#    if defined(__linux__)\n+#        include <unistd.h> //sysconf\n+#    endif\n+#    if ANKERL_NANOBENCH(PERF_COUNTERS)\n+#        include <map> // map\n+\n+#        include <linux/perf_event.h>\n+#        include <sys/ioctl.h>\n+#        include <sys/syscall.h>\n+#        include <unistd.h>\n+#    endif\n+\n+// declarations ///////////////////////////////////////////////////////////////////////////////////\n+\n+namespace ankerl {\n+namespace nanobench {\n+\n+// helper stuff that only intended to be used internally\n+namespace detail {\n+\n+struct TableInfo;\n+\n+// formatting utilities\n+namespace fmt {\n+\n+class NumSep;\n+class StreamStateRestorer;\n+class Number;\n+class MarkDownColumn;\n+class MarkDownCode;\n+\n+} // namespace fmt\n+} // namespace detail\n+} // namespace nanobench\n+} // namespace ankerl\n+\n+// definitions ////////////////////////////////////////////////////////////////////////////////////\n+\n+namespace ankerl {\n+namespace nanobench {\n+namespace detail {\n+\n+// helpers to get double values\n+template <typename T>\n+inline double d(T t) noexcept {\n+    return static_cast<double>(t);\n+}\n+inline double d(Clock::duration dur) noexcept {\n+    return std::chrono::duration_cast<std::chrono::duration<double>>(dur).count();\n+}\n+\n+} // namespace detail\n+\n+namespace templates {\n+\n+char const* csv() noexcept {\n+    return R\"DELIM(\"title\"; \"name\"; \"unit\"; \"batch\"; \"elapsed\"; \"error %\"; \"instructions\"; \"branches\"; \"branch misses\"; \"total\"\n+{{#result}}\"{{title}}\"; \"{{name}}\"; \"{{unit}}\"; {{batch}}; {{median(elapsed)}}; {{medianAbsolutePercentError(elapsed)}}; {{median(instructions)}}; {{median(branchinstructions)}}; {{median(branchmisses)}}; {{sumProduct(iterations, elapsed)}}\n+{{/result}}\n+)DELIM\";\n+}\n+//\n+char const* htmlBoxplot() noexcept {\n+    return R\"DELIM(<html>\n+\n+<head>\n+    <script src=\"https://cdn.plot.ly/plotly-latest.min.js\"></script>\n+</head>\n+\n+<body>\n+    <div id=\"myDiv\" style=\"width:1024px; height:768px\"></div>\n+    <script>\n+        var data = [\n+            {{#result}}{\n+                name: '{{name}}',\n+                y: [{{#measurement}}{{elapsed}}{{^-last}}, {{/last}}{{/measurement}}],\n+            },\n+            {{/result}}\n+        ];\n+        var title = 'benchmark';\n+\n+        data = data.map(a => Object.assign(a, { boxpoints: 'all', pointpos: 0, type: 'box' }));\n+        var layout = { title: { text: title }, showlegend: false, yaxis: { title: 'time per unit', rangemode: 'tozero', autorange: true } }; Plotly.newPlot('myDiv', data, layout, {responsive: true});\n+    </script>\n+</body>\n+\n+</html>)DELIM\";\n+}\n+\n+char const* json() noexcept {\n+    return R\"DELIM({\n+    \"results\": [\n+{{#result}}        {\n+            \"title\": \"{{title}}\",\n+            \"name\": \"{{name}}\",\n+            \"unit\": \"{{unit}}\",\n+            \"batch\": {{batch}},\n+            \"complexityN\": {{complexityN}},\n+            \"epochs\": {{epochs}},\n+            \"clockResolutionMultiple\": {{clockResolutionMultiple}},\n+            \"maxEpochTime\": {{maxEpochTime}},\n+            \"minEpochTime\": {{minEpochTime}},\n+            \"minEpochIterations\": {{minEpochIterations}},\n+            \"warmup\": {{warmup}},\n+            \"relative\": {{relative}},\n+            \"median(elapsed)\": {{median(elapsed)}},\n+            \"medianAbsolutePercentError(elapsed)\": {{medianAbsolutePercentError(elapsed)}},\n+            \"median(instructions)\": {{median(instructions)}},\n+            \"medianAbsolutePercentError(instructions)\": {{medianAbsolutePercentError(instructions)}},\n+            \"median(cpucycles)\": {{median(cpucycles)}},\n+            \"median(contextswitches)\": {{median(contextswitches)}},\n+            \"median(pagefaults)\": {{median(pagefaults)}},\n+            \"median(branchinstructions)\": {{median(branchinstructions)}},\n+            \"median(branchmisses)\": {{median(branchmisses)}},\n+            \"totalTime\": {{sumProduct(iterations, elapsed)}},\n+            \"measurements\": [\n+{{#measurement}}                {\n+                    \"iterations\": {{iterations}},\n+                    \"elapsed\": {{elapsed}},\n+                    \"pagefaults\": {{pagefaults}},\n+                    \"cpucycles\": {{cpucycles}},\n+                    \"contextswitches\": {{contextswitches}},\n+                    \"instructions\": {{instructions}},\n+                    \"branchinstructions\": {{branchinstructions}},\n+                    \"branchmisses\": {{branchmisses}}\n+                }{{^-last}},{{/-last}}\n+{{/measurement}}            ]\n+        }{{^-last}},{{/-last}}\n+{{/result}}    ]\n+})DELIM\";\n+}\n+\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+struct Node {\n+    enum class Type { tag, content, section, inverted_section };\n+\n+    char const* begin;\n+    char const* end;\n+    std::vector<Node> children;\n+    Type type;\n+\n+    template <size_t N>\n+    // NOLINTNEXTLINE(hicpp-avoid-c-arrays,modernize-avoid-c-arrays,cppcoreguidelines-avoid-c-arrays)\n+    bool operator==(char const (&str)[N]) const noexcept {\n+        return static_cast<size_t>(std::distance(begin, end) + 1) == N && 0 == strncmp(str, begin, N - 1);\n+    }\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+static std::vector<Node> parseMustacheTemplate(char const** tpl) {\n+    std::vector<Node> nodes;\n+\n+    while (true) {\n+        auto begin = std::strstr(*tpl, \"{{\");\n+        auto end = begin;\n+        if (begin != nullptr) {\n+            begin += 2;\n+            end = std::strstr(begin, \"}}\");\n+        }\n+\n+        if (begin == nullptr || end == nullptr) {\n+            // nothing found, finish node\n+            nodes.emplace_back(Node{*tpl, *tpl + std::strlen(*tpl), std::vector<Node>{}, Node::Type::content});\n+            return nodes;\n+        }\n+\n+        nodes.emplace_back(Node{*tpl, begin - 2, std::vector<Node>{}, Node::Type::content});\n+\n+        // we found a tag\n+        *tpl = end + 2;\n+        switch (*begin) {\n+        case '/':\n+            // finished! bail out\n+            return nodes;\n+\n+        case '#':\n+            nodes.emplace_back(Node{begin + 1, end, parseMustacheTemplate(tpl), Node::Type::section});\n+            break;\n+\n+        case '^':\n+            nodes.emplace_back(Node{begin + 1, end, parseMustacheTemplate(tpl), Node::Type::inverted_section});\n+            break;\n+\n+        default:\n+            nodes.emplace_back(Node{begin, end, std::vector<Node>{}, Node::Type::tag});\n+            break;\n+        }\n+    }\n+}\n+\n+static bool generateFirstLast(Node const& n, size_t idx, size_t size, std::ostream& out) {\n+    bool matchFirst = n == \"-first\";\n+    bool matchLast = n == \"-last\";\n+    if (!matchFirst && !matchLast) {\n+        return false;\n+    }\n+\n+    bool doWrite = false;\n+    if (n.type == Node::Type::section) {\n+        doWrite = (matchFirst && idx == 0) || (matchLast && idx == size - 1);\n+    } else if (n.type == Node::Type::inverted_section) {\n+        doWrite = (matchFirst && idx != 0) || (matchLast && idx != size - 1);\n+    }\n+\n+    if (doWrite) {\n+        for (auto const& child : n.children) {\n+            if (child.type == Node::Type::content) {\n+                out.write(child.begin, std::distance(child.begin, child.end));\n+            }\n+        }\n+    }\n+    return true;\n+}\n+\n+static bool matchCmdArgs(std::string const& str, std::vector<std::string>& matchResult) {\n+    matchResult.clear();\n+    auto idxOpen = str.find('(');\n+    auto idxClose = str.find(')', idxOpen);\n+    if (idxClose == std::string::npos) {\n+        return false;\n+    }\n+\n+    matchResult.emplace_back(str.substr(0, idxOpen));\n+\n+    // split by comma\n+    matchResult.emplace_back(std::string{});\n+    for (size_t i = idxOpen + 1; i != idxClose; ++i) {\n+        if (str[i] == ' ' || str[i] == '\\t') {\n+            // skip whitespace\n+            continue;\n+        }\n+        if (str[i] == ',') {\n+            // got a comma => new string\n+            matchResult.emplace_back(std::string{});\n+            continue;\n+        }\n+        // no whitespace no comma, append\n+        matchResult.back() += str[i];\n+    }\n+    return true;\n+}\n+\n+static std::ostream& generateResultTag(Node const& n, Result const& r, std::ostream& out) {\n+    using detail::d;\n+\n+    if (n == \"title\") {\n+        return out << r.config().mBenchmarkTitle;\n+    }\n+    if (n == \"name\") {\n+        return out << r.config().mBenchmarkName;\n+    }\n+    if (n == \"unit\") {\n+        return out << r.config().mUnit;\n+    }\n+    if (n == \"batch\") {\n+        return out << r.config().mBatch;\n+    }\n+    if (n == \"complexityN\") {\n+        return out << r.config().mComplexityN;\n+    }\n+    if (n == \"epochs\") {\n+        return out << r.config().mNumEpochs;\n+    }\n+    if (n == \"clockResolutionMultiple\") {\n+        return out << r.config().mClockResolutionMultiple;\n+    }\n+    if (n == \"maxEpochTime\") {\n+        return out << d(r.config().mMaxEpochTime);\n+    }\n+    if (n == \"minEpochTime\") {\n+        return out << d(r.config().mMinEpochTime);\n+    }\n+    if (n == \"minEpochIterations\") {\n+        return out << r.config().mMinEpochIterations;\n+    }\n+    if (n == \"warmup\") {\n+        return out << r.config().mWarmup;\n+    }\n+    if (n == \"relative\") {\n+        return out << r.config().mIsRelative;\n+    }\n+\n+    // match e.g. \"median(elapsed)\"\n+    // g++ 4.8 doesn't implement std::regex :(\n+    // static std::regex const regOpArg1(\"^([a-zA-Z]+)\\\\(([a-zA-Z]*)\\\\)$\");\n+    // std::cmatch matchResult;\n+    // if (std::regex_match(n.begin, n.end, matchResult, regOpArg1)) {\n+    std::vector<std::string> matchResult;\n+    if (matchCmdArgs(std::string(n.begin, n.end), matchResult)) {\n+        if (matchResult.size() == 2) {\n+            if (matchResult[0] == \"median\") {\n+                return out << r.median(matchResult[1]);\n+            }\n+            if (matchResult[0] == \"average\") {\n+                return out << r.average(matchResult[1]);\n+            }\n+            if (matchResult[0] == \"medianAbsolutePercentError\") {\n+                return out << r.medianAbsolutePercentError(matchResult[1]);\n+            }\n+            if (matchResult[0] == \"sum\") {\n+                return out << r.sum(matchResult[1]);\n+            }\n+            if (matchResult[0] == \"minimum\") {\n+                return out << r.minimum(matchResult[1]);\n+            }\n+            if (matchResult[0] == \"maximum\") {\n+                return out << r.maximum(matchResult[1]);\n+            }\n+        } else if (matchResult.size() == 3) {\n+            if (matchResult[0] == \"sumProduct\") {\n+                return out << r.sumProduct(matchResult[1], matchResult[2]);\n+            }\n+        }\n+    }\n+\n+    // match e.g. \"sumProduct(elapsed, iterations)\"\n+    // static std::regex const regOpArg2(\"^([a-zA-Z]+)\\\\(([a-zA-Z]*)\\\\s*,\\\\s+([a-zA-Z]*)\\\\)$\");\n+\n+    // nothing matches :(\n+    throw std::runtime_error(\"command '\" + std::string(n.begin, n.end) + \"' not understood\");\n+}\n+\n+static void generateResultMeasurement(std::vector<Node> const& nodes, size_t idx, Result const& r, std::ostream& out) {\n+    for (auto const& n : nodes) {\n+        if (!generateFirstLast(n, idx, r.size(), out)) {\n+            switch (n.type) {\n+            case Node::Type::content:\n+                out.write(n.begin, std::distance(n.begin, n.end));\n+                break;\n+\n+            case Node::Type::inverted_section:\n+                throw std::runtime_error(\"got a inverted section inside measurement\");\n+\n+            case Node::Type::section:\n+                throw std::runtime_error(\"got a section inside measurement\");\n+\n+            case Node::Type::tag: {\n+                out << r.get(idx, std::string(n.begin, n.end));\n+                break;\n+            }\n+            }\n+        }\n+    }\n+}\n+\n+static void generateResult(std::vector<Node> const& nodes, size_t idx, std::vector<Result> const& results, std::ostream& out) {\n+    auto const& r = results[idx];\n+    for (auto const& n : nodes) {\n+        if (!generateFirstLast(n, idx, results.size(), out)) {\n+            switch (n.type) {\n+            case Node::Type::content:\n+                out.write(n.begin, std::distance(n.begin, n.end));\n+                break;\n+\n+            case Node::Type::inverted_section:\n+                throw std::runtime_error(\"got a inverted section inside result\");\n+\n+            case Node::Type::section:\n+                if (n == \"measurement\") {\n+                    for (size_t i = 0; i < r.size(); ++i) {\n+                        generateResultMeasurement(n.children, i, r, out);\n+                    }\n+                } else {\n+                    throw std::runtime_error(\"got a section inside result\");\n+                }\n+                break;\n+\n+            case Node::Type::tag:\n+                generateResultTag(n, r, out);\n+                break;\n+            }\n+        }\n+    }\n+}\n+\n+void generate(char const* mustacheTemplate, std::vector<Result> const& results, std::ostream& out) {\n+    // TODO(martinus) save & restore stream status\n+    out.precision(std::numeric_limits<double>::digits10);\n+    auto nodes = parseMustacheTemplate(&mustacheTemplate);\n+\n+    for (auto const& n : nodes) {\n+        switch (n.type) {\n+        case Node::Type::content:\n+            out.write(n.begin, std::distance(n.begin, n.end));\n+            break;\n+\n+        case Node::Type::inverted_section:\n+            throw std::runtime_error(\"unknown list '\" + std::string(n.begin, n.end) + \"'\");\n+\n+        case Node::Type::section:\n+            if (n == \"result\") {\n+                for (size_t i = 0; i < results.size(); ++i) {\n+                    generateResult(n.children, i, results, out);\n+                }\n+            } else {\n+                throw std::runtime_error(\"unknown section '\" + std::string(n.begin, n.end) + \"'\");\n+            }\n+            break;\n+\n+        case Node::Type::tag:\n+            throw std::runtime_error(\"unknown tag '\" + std::string(n.begin, n.end) + \"'\");\n+            break;\n+        }\n+    }\n+}\n+\n+} // namespace templates\n+\n+// helper stuff that only intended to be used internally\n+namespace detail {\n+\n+char const* getEnv(char const* name);\n+bool isEndlessRunning(std::string const& name);\n+\n+template <typename T>\n+T parseFile(std::string const& filename);\n+\n+void gatherStabilityInformation(std::vector<std::string>& warnings, std::vector<std::string>& recommendations);\n+void printStabilityInformationOnce(std::ostream* os);\n+\n+// remembers the last table settings used. When it changes, a new table header is automatically written for the new entry.\n+uint64_t& singletonHeaderHash() noexcept;\n+\n+// determines resolution of the given clock. This is done by measuring multiple times and returning the minimum time difference.\n+Clock::duration calcClockResolution(size_t numEvaluations) noexcept;\n+\n+// Calculates clock resolution once, and remembers the result\n+inline Clock::duration clockResolution() noexcept;\n+\n+// formatting utilities\n+namespace fmt {\n+\n+// adds thousands separator to numbers\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+class NumSep : public std::numpunct<char> {\n+public:\n+    explicit NumSep(char sep);\n+    char do_thousands_sep() const override;\n+    std::string do_grouping() const override;\n+\n+private:\n+    char mSep;\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+// RAII to save & restore a stream's state\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+class StreamStateRestorer {\n+public:\n+    explicit StreamStateRestorer(std::ostream& s);\n+    ~StreamStateRestorer();\n+\n+    // sets back all stream info that we remembered at construction\n+    void restore();\n+\n+    // don't allow copying / moving\n+    StreamStateRestorer(StreamStateRestorer const&) = delete;\n+    StreamStateRestorer& operator=(StreamStateRestorer const&) = delete;\n+    StreamStateRestorer(StreamStateRestorer&&) = delete;\n+    StreamStateRestorer& operator=(StreamStateRestorer&&) = delete;\n+\n+private:\n+    std::ostream& mStream;\n+    std::locale mLocale;\n+    std::streamsize const mPrecision;\n+    std::streamsize const mWidth;\n+    std::ostream::char_type const mFill;\n+    std::ostream::fmtflags const mFmtFlags;\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+// Number formatter\n+class Number {\n+public:\n+    Number(int width, int precision, double value);\n+    Number(int width, int precision, int64_t value);\n+    std::string to_s() const;\n+\n+private:\n+    friend std::ostream& operator<<(std::ostream& os, Number const& n);\n+    std::ostream& write(std::ostream& os) const;\n+\n+    int mWidth;\n+    int mPrecision;\n+    double mValue;\n+};\n+\n+// helper replacement for std::to_string of signed/unsigned numbers so we are locale independent\n+std::string to_s(uint64_t s);\n+\n+std::ostream& operator<<(std::ostream& os, Number const& n);\n+\n+class MarkDownColumn {\n+public:\n+    MarkDownColumn(int w, int prec, std::string const& tit, std::string const& suff, double val);\n+    std::string title() const;\n+    std::string separator() const;\n+    std::string invalid() const;\n+    std::string value() const;\n+\n+private:\n+    int mWidth;\n+    int mPrecision;\n+    std::string mTitle;\n+    std::string mSuffix;\n+    double mValue;\n+};\n+\n+// Formats any text as markdown code, escaping backticks.\n+class MarkDownCode {\n+public:\n+    explicit MarkDownCode(std::string const& what);\n+\n+private:\n+    friend std::ostream& operator<<(std::ostream& os, MarkDownCode const& mdCode);\n+    std::ostream& write(std::ostream& os) const;\n+\n+    std::string mWhat{};\n+};\n+\n+std::ostream& operator<<(std::ostream& os, MarkDownCode const& mdCode);\n+\n+} // namespace fmt\n+} // namespace detail\n+} // namespace nanobench\n+} // namespace ankerl\n+\n+// implementation /////////////////////////////////////////////////////////////////////////////////\n+\n+namespace ankerl {\n+namespace nanobench {\n+namespace detail {\n+\n+PerformanceCounters& performanceCounters() {\n+#    if defined(__clang__)\n+#        pragma clang diagnostic push\n+#        pragma clang diagnostic ignored \"-Wexit-time-destructors\"\n+#    endif\n+    static PerformanceCounters pc;\n+#    if defined(__clang__)\n+#        pragma clang diagnostic pop\n+#    endif\n+    return pc;\n+}\n+\n+// Windows version of do not optimize away\n+// see https://github.com/google/benchmark/blob/master/include/benchmark/benchmark.h#L307\n+// see https://github.com/facebook/folly/blob/master/folly/Benchmark.h#L280\n+// see https://docs.microsoft.com/en-us/cpp/preprocessor/optimize\n+#    if defined(_MSC_VER)\n+#        pragma optimize(\"\", off)\n+void doNotOptimizeAwaySink(void const*) {}\n+#        pragma optimize(\"\", on)\n+#    endif\n+\n+template <typename T>\n+T parseFile(std::string const& filename) {\n+    std::ifstream fin(filename);\n+    T num{};\n+    fin >> num;\n+    return num;\n+}\n+\n+char const* getEnv(char const* name) {\n+#    if defined(_MSC_VER)\n+#        pragma warning(push)\n+#        pragma warning(disable : 4996) // getenv': This function or variable may be unsafe.\n+#    endif\n+    return std::getenv(name);\n+#    if defined(_MSC_VER)\n+#        pragma warning(pop)\n+#    endif\n+}\n+\n+bool isEndlessRunning(std::string const& name) {\n+    auto endless = getEnv(\"NANOBENCH_ENDLESS\");\n+    return nullptr != endless && endless == name;\n+}\n+\n+void gatherStabilityInformation(std::vector<std::string>& warnings, std::vector<std::string>& recommendations) {\n+    warnings.clear();\n+    recommendations.clear();\n+\n+    bool recommendCheckFlags = false;\n+#    if !defined(NDEBUG)\n+    warnings.emplace_back(\"NDEBUG not defined, assert() macros are evaluated\");\n+    recommendCheckFlags = true;\n+#    endif\n+\n+#    if defined(DEBUG)\n+    warnings.emplace_back(\"DEBUG defined\");\n+    recommendCheckFlags = true;\n+#    endif\n+\n+    bool recommendPyPerf = false;\n+#    if defined(__linux__)\n+    auto nprocs = sysconf(_SC_NPROCESSORS_CONF);\n+    if (nprocs <= 0) {\n+        warnings.emplace_back(\"couldn't figure out number of processors - no governor, turbo check possible\");\n+    } else {\n+\n+        // check frequency scaling\n+        for (long id = 0; id < nprocs; ++id) {\n+            auto idStr = detail::fmt::to_s(static_cast<uint64_t>(id));\n+            auto sysCpu = \"/sys/devices/system/cpu/cpu\" + idStr;\n+            auto minFreq = parseFile<int64_t>(sysCpu + \"/cpufreq/scaling_min_freq\");\n+            auto maxFreq = parseFile<int64_t>(sysCpu + \"/cpufreq/scaling_max_freq\");\n+            if (minFreq != maxFreq) {\n+                auto minMHz = static_cast<double>(minFreq) / 1000.0;\n+                auto maxMHz = static_cast<double>(maxFreq) / 1000.0;\n+                warnings.emplace_back(\"CPU frequency scaling enabled: CPU \" + idStr + \" between \" +\n+                                      detail::fmt::Number(1, 1, minMHz).to_s() + \" and \" + detail::fmt::Number(1, 1, maxMHz).to_s() +\n+                                      \" MHz\");\n+                recommendPyPerf = true;\n+                break;\n+            }\n+        }\n+\n+        auto currentGovernor = parseFile<std::string>(\"/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor\");\n+        if (\"performance\" != currentGovernor) {\n+            warnings.emplace_back(\"CPU governor is '\" + currentGovernor + \"' but should be 'performance'\");\n+            recommendPyPerf = true;\n+        }\n+\n+        if (0 == parseFile<int>(\"/sys/devices/system/cpu/intel_pstate/no_turbo\")) {\n+            warnings.emplace_back(\"Turbo is enabled, CPU frequency will fluctuate\");\n+            recommendPyPerf = true;\n+        }\n+    }\n+#    endif\n+\n+    if (recommendCheckFlags) {\n+        recommendations.emplace_back(\"Make sure you compile for Release\");\n+    }\n+    if (recommendPyPerf) {\n+        recommendations.emplace_back(\"Use 'pyperf system tune' before benchmarking. See https://github.com/vstinner/pyperf\");\n+    }\n+}\n+\n+void printStabilityInformationOnce(std::ostream* outStream) {\n+    static bool shouldPrint = true;\n+    if (shouldPrint && outStream) {\n+        auto& os = *outStream;\n+        shouldPrint = false;\n+        std::vector<std::string> warnings;\n+        std::vector<std::string> recommendations;\n+        gatherStabilityInformation(warnings, recommendations);\n+        if (warnings.empty()) {\n+            return;\n+        }\n+\n+        os << \"Warning, results might be unstable:\" << std::endl;\n+        for (auto const& w : warnings) {\n+            os << \"* \" << w << std::endl;\n+        }\n+\n+        os << std::endl << \"Recommendations\" << std::endl;\n+        for (auto const& r : recommendations) {\n+            os << \"* \" << r << std::endl;\n+        }\n+    }\n+}\n+\n+// remembers the last table settings used. When it changes, a new table header is automatically written for the new entry.\n+uint64_t& singletonHeaderHash() noexcept {\n+    static uint64_t sHeaderHash{};\n+    return sHeaderHash;\n+}\n+\n+ANKERL_NANOBENCH_NO_SANITIZE(\"integer\")\n+inline uint64_t fnv1a(std::string const& str) noexcept {\n+    auto val = UINT64_C(14695981039346656037);\n+    for (auto c : str) {\n+        val = (val ^ static_cast<uint8_t>(c)) * UINT64_C(1099511628211);\n+    }\n+    return val;\n+}\n+\n+ANKERL_NANOBENCH_NO_SANITIZE(\"integer\")\n+inline uint64_t hash_combine(uint64_t seed, uint64_t val) {\n+    return seed ^ (val + UINT64_C(0x9e3779b9) + (seed << 6U) + (seed >> 2U));\n+}\n+\n+// determines resolution of the given clock. This is done by measuring multiple times and returning the minimum time difference.\n+Clock::duration calcClockResolution(size_t numEvaluations) noexcept {\n+    auto bestDuration = Clock::duration::max();\n+    Clock::time_point tBegin;\n+    Clock::time_point tEnd;\n+    for (size_t i = 0; i < numEvaluations; ++i) {\n+        tBegin = Clock::now();\n+        do {\n+            tEnd = Clock::now();\n+        } while (tBegin == tEnd);\n+        bestDuration = (std::min)(bestDuration, tEnd - tBegin);\n+    }\n+    return bestDuration;\n+}\n+\n+// Calculates clock resolution once, and remembers the result\n+Clock::duration clockResolution() noexcept {\n+    static Clock::duration sResolution = calcClockResolution(20);\n+    return sResolution;\n+}\n+\n+IterationLogic::IterationLogic(Bench const& bench) noexcept\n+    : mBench(bench)\n+    , mResult(bench.config()) {\n+    printStabilityInformationOnce(mBench.output());\n+\n+    // determine target runtime per epoch\n+    mTargetRuntimePerEpoch = detail::clockResolution() * mBench.clockResolutionMultiple();\n+    if (mTargetRuntimePerEpoch > mBench.maxEpochTime()) {\n+        mTargetRuntimePerEpoch = mBench.maxEpochTime();\n+    }\n+    if (mTargetRuntimePerEpoch < mBench.minEpochTime()) {\n+        mTargetRuntimePerEpoch = mBench.minEpochTime();\n+    }\n+\n+    if (isEndlessRunning(mBench.name())) {\n+        std::cerr << \"NANOBENCH_ENDLESS set: running '\" << mBench.name() << \"' endlessly\" << std::endl;\n+        mNumIters = (std::numeric_limits<uint64_t>::max)();\n+        mState = State::endless;\n+    } else if (0 != mBench.warmup()) {\n+        mNumIters = mBench.warmup();\n+        mState = State::warmup;\n+    } else {\n+        mNumIters = mBench.minEpochIterations();\n+        mState = State::upscaling_runtime;\n+    }\n+}\n+\n+uint64_t IterationLogic::numIters() const noexcept {\n+    ANKERL_NANOBENCH_LOG(mBench.name() << \": mNumIters=\" << mNumIters);\n+    return mNumIters;\n+}\n+\n+bool IterationLogic::isCloseEnoughForMeasurements(std::chrono::nanoseconds elapsed) const noexcept {\n+    return elapsed * 3 >= mTargetRuntimePerEpoch * 2;\n+}\n+\n+// directly calculates new iters based on elapsed&iters, and adds a 10% noise. Makes sure we don't underflow.\n+uint64_t IterationLogic::calcBestNumIters(std::chrono::nanoseconds elapsed, uint64_t iters) noexcept {\n+    auto doubleElapsed = d(elapsed);\n+    auto doubleTargetRuntimePerEpoch = d(mTargetRuntimePerEpoch);\n+    auto doubleNewIters = doubleTargetRuntimePerEpoch / doubleElapsed * d(iters);\n+\n+    auto doubleMinEpochIters = d(mBench.minEpochIterations());\n+    if (doubleNewIters < doubleMinEpochIters) {\n+        doubleNewIters = doubleMinEpochIters;\n+    }\n+    doubleNewIters *= 1.0 + 0.2 * mRng.uniform01();\n+\n+    // +0.5 for correct rounding when casting\n+    // NOLINTNEXTLINE(bugprone-incorrect-roundings)\n+    return static_cast<uint64_t>(doubleNewIters + 0.5);\n+}\n+\n+ANKERL_NANOBENCH_NO_SANITIZE(\"integer\") void IterationLogic::upscale(std::chrono::nanoseconds elapsed) {\n+    if (elapsed * 10 < mTargetRuntimePerEpoch) {\n+        // we are far below the target runtime. Multiply iterations by 10 (with overflow check)\n+        if (mNumIters * 10 < mNumIters) {\n+            // overflow :-(\n+            showResult(\"iterations overflow. Maybe your code got optimized away?\");\n+            mNumIters = 0;\n+            return;\n+        }\n+        mNumIters *= 10;\n+    } else {\n+        mNumIters = calcBestNumIters(elapsed, mNumIters);\n+    }\n+}\n+\n+void IterationLogic::add(std::chrono::nanoseconds elapsed, PerformanceCounters const& pc) noexcept {\n+#    if defined(ANKERL_NANOBENCH_LOG_ENABLED)\n+    auto oldIters = mNumIters;\n+#    endif\n+\n+    switch (mState) {\n+    case State::warmup:\n+        if (isCloseEnoughForMeasurements(elapsed)) {\n+            // if elapsed is close enough, we can skip upscaling and go right to measurements\n+            // still, we don't add the result to the measurements.\n+            mState = State::measuring;\n+            mNumIters = calcBestNumIters(elapsed, mNumIters);\n+        } else {\n+            // not close enough: switch to upscaling\n+            mState = State::upscaling_runtime;\n+            upscale(elapsed);\n+        }\n+        break;\n+\n+    case State::upscaling_runtime:\n+        if (isCloseEnoughForMeasurements(elapsed)) {\n+            // if we are close enough, add measurement and switch to always measuring\n+            mState = State::measuring;\n+            mTotalElapsed += elapsed;\n+            mTotalNumIters += mNumIters;\n+            mResult.add(elapsed, mNumIters, pc);\n+            mNumIters = calcBestNumIters(mTotalElapsed, mTotalNumIters);\n+        } else {\n+            upscale(elapsed);\n+        }\n+        break;\n+\n+    case State::measuring:\n+        // just add measurements - no questions asked. Even when runtime is low. But we can't ignore\n+        // that fluctuation, or else we would bias the result\n+        mTotalElapsed += elapsed;\n+        mTotalNumIters += mNumIters;\n+        mResult.add(elapsed, mNumIters, pc);\n+        mNumIters = calcBestNumIters(mTotalElapsed, mTotalNumIters);\n+        break;\n+\n+    case State::endless:\n+        mNumIters = (std::numeric_limits<uint64_t>::max)();\n+        break;\n+    }\n+\n+    if (static_cast<uint64_t>(mResult.size()) == mBench.epochs()) {\n+        // we got all the results that we need, finish it\n+        showResult(\"\");\n+        mNumIters = 0;\n+    }\n+\n+    ANKERL_NANOBENCH_LOG(mName << \": \" << detail::fmt::Number(20, 3, static_cast<double>(elapsed.count())) << \" elapsed, \"\n+                               << detail::fmt::Number(20, 3, static_cast<double>(mTargetRuntimePerEpoch.count()))\n+                               << \" target. oldIters=\" << oldIters << \", mNumIters=\" << mNumIters\n+                               << \", mState=\" << static_cast<int>(mState));\n+}\n+\n+Result& IterationLogic::result() {\n+    return mResult;\n+}\n+\n+void IterationLogic::showResult(std::string const& errorMessage) const {\n+    ANKERL_NANOBENCH_LOG(\"mMeasurements.size()=\" << mMeasurements.size());\n+\n+    if (mBench.output() != nullptr) {\n+        // prepare column data ///////\n+        std::vector<fmt::MarkDownColumn> columns;\n+\n+        auto rMedian = mResult.median(\"elapsed\");\n+\n+        if (mBench.relative()) {\n+            double d = 100.0;\n+            if (!mBench.results().empty()) {\n+                d = rMedian <= 0.0 ? 0.0 : mBench.results().front().median(\"elapsed\") / rMedian * 100.0;\n+            }\n+            columns.emplace_back(11, 1, \"relative\", \"%\", d);\n+        }\n+\n+        columns.emplace_back(22, 2, \"ns/\" + mBench.unit(), \"\", 1e9 * rMedian / mBench.batch());\n+        columns.emplace_back(22, 2, mBench.unit() + \"/s\", \"\", rMedian <= 0.0 ? 0.0 : mBench.batch() / rMedian);\n+\n+        double rErrorMedian = mResult.medianAbsolutePercentError(\"elapsed\");\n+        columns.emplace_back(10, 1, \"err%\", \"%\", rErrorMedian * 100.0);\n+\n+        double rInsMedian = -1.0;\n+        if (mResult.has(\"instructions\")) {\n+            rInsMedian = mResult.median(\"instructions\");\n+            columns.emplace_back(18, 2, \"ins/\" + mBench.unit(), \"\", rInsMedian / mBench.batch());\n+        }\n+\n+        double rCycMedian = -1.0;\n+        if (mResult.has(\"cpucycles\")) {\n+            rCycMedian = mResult.median(\"cpucycles\");\n+            columns.emplace_back(18, 2, \"cyc/\" + mBench.unit(), \"\", rCycMedian / mBench.batch());\n+        }\n+        if (rInsMedian > 0.0 && rCycMedian > 0.0) {\n+            columns.emplace_back(9, 3, \"IPC\", \"\", rCycMedian <= 0.0 ? 0.0 : rInsMedian / rCycMedian);\n+        }\n+        if (mResult.has(\"branches\")) {\n+            double rBraMedian = mResult.median(\"branches\");\n+            columns.emplace_back(17, 2, \"bra/\" + mBench.unit(), \"\", rBraMedian / mBench.batch());\n+            if (mResult.has(\"branchmisses\")) {\n+                double p = 0.0;\n+                if (rBraMedian >= 1e-9) {\n+                    p = 100.0 * mResult.median(\"branchmisses\") / rBraMedian;\n+                }\n+                columns.emplace_back(10, 1, \"miss%\", \"%\", p);\n+            }\n+        }\n+\n+        columns.emplace_back(12, 2, \"total\", \"\", mResult.sum(\"elapsed\"));\n+\n+        // write everything\n+        auto& os = *mBench.output();\n+\n+        auto hash = hash_combine(fnv1a(mBench.unit()), fnv1a(mBench.title()));\n+        if (hash != singletonHeaderHash()) {\n+            singletonHeaderHash() = hash;\n+\n+            // no result yet, print header\n+            os << std::endl;\n+            for (auto const& col : columns) {\n+                os << col.title();\n+            }\n+            os << \"| \" << mBench.title() << std::endl;\n+\n+            for (auto const& col : columns) {\n+                os << col.separator();\n+            }\n+            os << \"|:\" << std::string(mBench.title().size() + 1U, '-') << std::endl;\n+        }\n+\n+        if (!errorMessage.empty()) {\n+            for (auto const& col : columns) {\n+                os << col.invalid();\n+            }\n+            os << \"| :boom: \" << fmt::MarkDownCode(mBench.name()) << \" (\" << errorMessage << ')' << std::endl;\n+        } else {\n+            for (auto const& col : columns) {\n+                os << col.value();\n+            }\n+            os << \"| \";\n+            auto showUnstable = rErrorMedian >= 0.05;\n+            if (showUnstable) {\n+                os << \":wavy_dash: \";\n+            }\n+            os << fmt::MarkDownCode(mBench.name());\n+            if (showUnstable) {\n+                auto avgIters = static_cast<double>(mTotalNumIters) / static_cast<double>(mBench.epochs());\n+                // NOLINTNEXTLINE(bugprone-incorrect-roundings)\n+                auto suggestedIters = static_cast<uint64_t>(avgIters * 10 + 0.5);\n+\n+                os << \" (Unstable with ~\" << detail::fmt::Number(1, 1, avgIters) << \" iters. Increase `minEpochIterations` to e.g. \"\n+                   << suggestedIters << \")\";\n+            }\n+            os << std::endl;\n+        }\n+    }\n+}\n+\n+#    if ANKERL_NANOBENCH(PERF_COUNTERS)\n+\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+class LinuxPerformanceCounters {\n+public:\n+    struct Target {\n+        Target(uint64_t* targetValue_, bool correctMeasuringOverhead_, bool correctLoopOverhead_)\n+            : targetValue(targetValue_)\n+            , correctMeasuringOverhead(correctMeasuringOverhead_)\n+            , correctLoopOverhead(correctLoopOverhead_) {}\n+\n+        uint64_t* targetValue{};\n+        bool correctMeasuringOverhead{};\n+        bool correctLoopOverhead{};\n+    };\n+\n+    ~LinuxPerformanceCounters();\n+\n+    // quick operation\n+    inline void start() {}\n+\n+    inline void stop() {}\n+\n+    bool monitor(perf_sw_ids swId, Target target);\n+    bool monitor(perf_hw_id hwId, Target target);\n+\n+    bool hasError() const noexcept {\n+        return mHasError;\n+    }\n+\n+    // Just reading data is faster than enable & disabling.\n+    // we subtract data ourselves.\n+    inline void beginMeasure() {\n+        if (mHasError) {\n+            return;\n+        }\n+\n+        // NOLINTNEXTLINE(hicpp-signed-bitwise)\n+        mHasError = -1 == ioctl(mFd, PERF_EVENT_IOC_RESET, PERF_IOC_FLAG_GROUP);\n+        if (mHasError) {\n+            return;\n+        }\n+\n+        // NOLINTNEXTLINE(hicpp-signed-bitwise)\n+        mHasError = -1 == ioctl(mFd, PERF_EVENT_IOC_ENABLE, PERF_IOC_FLAG_GROUP);\n+    }\n+\n+    inline void endMeasure() {\n+        if (mHasError) {\n+            return;\n+        }\n+\n+        // NOLINTNEXTLINE(hicpp-signed-bitwise)\n+        mHasError = (-1 == ioctl(mFd, PERF_EVENT_IOC_DISABLE, PERF_IOC_FLAG_GROUP));\n+        if (mHasError) {\n+            return;\n+        }\n+\n+        auto const numBytes = sizeof(uint64_t) * mCounters.size();\n+        auto ret = read(mFd, mCounters.data(), numBytes);\n+        mHasError = ret != static_cast<ssize_t>(numBytes);\n+    }\n+\n+    void updateResults(uint64_t numIters);\n+\n+    // rounded integer division\n+    template <typename T>\n+    static inline T divRounded(T a, T divisor) {\n+        return (a + divisor / 2) / divisor;\n+    }\n+\n+    template <typename Op>\n+    ANKERL_NANOBENCH_NO_SANITIZE(\"integer\")\n+    void calibrate(Op&& op) {\n+        // clear current calibration data,\n+        for (auto& v : mCalibratedOverhead) {\n+            v = UINT64_C(0);\n+        }\n+\n+        // create new calibration data\n+        auto newCalibration = mCalibratedOverhead;\n+        for (auto& v : newCalibration) {\n+            v = (std::numeric_limits<uint64_t>::max)();\n+        }\n+        for (size_t iter = 0; iter < 100; ++iter) {\n+            beginMeasure();\n+            op();\n+            endMeasure();\n+            if (mHasError) {\n+                return;\n+            }\n+\n+            for (size_t i = 0; i < newCalibration.size(); ++i) {\n+                auto diff = mCounters[i];\n+                if (newCalibration[i] > diff) {\n+                    newCalibration[i] = diff;\n+                }\n+            }\n+        }\n+\n+        mCalibratedOverhead = std::move(newCalibration);\n+\n+        {\n+            // calibrate loop overhead. For branches & instructions this makes sense, not so much for everything else like cycles.\n+            // marsaglia's xorshift: mov, sal/shr, xor. Times 3.\n+            // This has the nice property that the compiler doesn't seem to be able to optimize multiple calls any further.\n+            // see https://godbolt.org/z/49RVQ5\n+            uint64_t const numIters = 100000U + (std::random_device{}() & 3);\n+            uint64_t n = numIters;\n+            uint32_t x = 1234567;\n+            auto fn = [&]() {\n+                x ^= x << 13;\n+                x ^= x >> 17;\n+                x ^= x << 5;\n+            };\n+\n+            beginMeasure();\n+            while (n-- > 0) {\n+                fn();\n+            }\n+            endMeasure();\n+            detail::doNotOptimizeAway(x);\n+            auto measure1 = mCounters;\n+\n+            n = numIters;\n+            beginMeasure();\n+            while (n-- > 0) {\n+                // we now run *twice* so we can easily calculate the overhead\n+                fn();\n+                fn();\n+            }\n+            endMeasure();\n+            detail::doNotOptimizeAway(x);\n+            auto measure2 = mCounters;\n+\n+            for (size_t i = 0; i < mCounters.size(); ++i) {\n+                // factor 2 because we have two instructions per loop\n+                auto m1 = measure1[i] > mCalibratedOverhead[i] ? measure1[i] - mCalibratedOverhead[i] : 0;\n+                auto m2 = measure2[i] > mCalibratedOverhead[i] ? measure2[i] - mCalibratedOverhead[i] : 0;\n+                auto overhead = m1 * 2 > m2 ? m1 * 2 - m2 : 0;\n+\n+                mLoopOverhead[i] = divRounded(overhead, numIters);\n+            }\n+        }\n+    }\n+\n+private:\n+    bool monitor(uint32_t type, uint64_t eventid, Target target);\n+\n+    std::map<uint64_t, Target> mIdToTarget{};\n+\n+    // start with minimum size of 3 for read_format\n+    std::vector<uint64_t> mCounters{3};\n+    std::vector<uint64_t> mCalibratedOverhead{3};\n+    std::vector<uint64_t> mLoopOverhead{3};\n+\n+    uint64_t mTimeEnabledNanos = 0;\n+    uint64_t mTimeRunningNanos = 0;\n+    int mFd = -1;\n+    bool mHasError = false;\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+LinuxPerformanceCounters::~LinuxPerformanceCounters() {\n+    if (-1 != mFd) {\n+        close(mFd);\n+    }\n+}\n+\n+bool LinuxPerformanceCounters::monitor(perf_sw_ids swId, LinuxPerformanceCounters::Target target) {\n+    return monitor(PERF_TYPE_SOFTWARE, swId, target);\n+}\n+\n+bool LinuxPerformanceCounters::monitor(perf_hw_id hwId, LinuxPerformanceCounters::Target target) {\n+    return monitor(PERF_TYPE_HARDWARE, hwId, target);\n+}\n+\n+// overflow is ok, it's checked\n+ANKERL_NANOBENCH_NO_SANITIZE(\"integer\")\n+void LinuxPerformanceCounters::updateResults(uint64_t numIters) {\n+    // clear old data\n+    for (auto& id_value : mIdToTarget) {\n+        *id_value.second.targetValue = UINT64_C(0);\n+    }\n+\n+    if (mHasError) {\n+        return;\n+    }\n+\n+    mTimeEnabledNanos = mCounters[1] - mCalibratedOverhead[1];\n+    mTimeRunningNanos = mCounters[2] - mCalibratedOverhead[2];\n+\n+    for (uint64_t i = 0; i < mCounters[0]; ++i) {\n+        auto idx = static_cast<size_t>(3 + i * 2 + 0);\n+        auto id = mCounters[idx + 1U];\n+\n+        auto it = mIdToTarget.find(id);\n+        if (it != mIdToTarget.end()) {\n+\n+            auto& tgt = it->second;\n+            *tgt.targetValue = mCounters[idx];\n+            if (tgt.correctMeasuringOverhead) {\n+                if (*tgt.targetValue >= mCalibratedOverhead[idx]) {\n+                    *tgt.targetValue -= mCalibratedOverhead[idx];\n+                } else {\n+                    *tgt.targetValue = 0U;\n+                }\n+            }\n+            if (tgt.correctLoopOverhead) {\n+                auto correctionVal = mLoopOverhead[idx] * numIters;\n+                if (*tgt.targetValue >= correctionVal) {\n+                    *tgt.targetValue -= correctionVal;\n+                } else {\n+                    *tgt.targetValue = 0U;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+bool LinuxPerformanceCounters::monitor(uint32_t type, uint64_t eventid, Target target) {\n+    *target.targetValue = (std::numeric_limits<uint64_t>::max)();\n+    if (mHasError) {\n+        return false;\n+    }\n+\n+    auto pea = perf_event_attr();\n+    std::memset(&pea, 0, sizeof(perf_event_attr));\n+    pea.type = type;\n+    pea.size = sizeof(perf_event_attr);\n+    pea.config = eventid;\n+    pea.disabled = 1; // start counter as disabled\n+    pea.exclude_kernel = 1;\n+    pea.exclude_hv = 1;\n+\n+    // NOLINTNEXTLINE(hicpp-signed-bitwise)\n+    pea.read_format = PERF_FORMAT_GROUP | PERF_FORMAT_ID | PERF_FORMAT_TOTAL_TIME_ENABLED | PERF_FORMAT_TOTAL_TIME_RUNNING;\n+\n+    const int pid = 0;                    // the current process\n+    const int cpu = -1;                   // all CPUs\n+#        if defined(PERF_FLAG_FD_CLOEXEC) // since Linux 3.14\n+    const unsigned long flags = PERF_FLAG_FD_CLOEXEC;\n+#        else\n+    const unsigned long flags = 0;\n+#        endif\n+\n+    auto fd = static_cast<int>(syscall(__NR_perf_event_open, &pea, pid, cpu, mFd, flags));\n+    if (-1 == fd) {\n+        return false;\n+    }\n+    if (-1 == mFd) {\n+        // first call: set to fd, and use this from now on\n+        mFd = fd;\n+    }\n+    uint64_t id = 0;\n+    // NOLINTNEXTLINE(hicpp-signed-bitwise)\n+    if (-1 == ioctl(fd, PERF_EVENT_IOC_ID, &id)) {\n+        // couldn't get id\n+        return false;\n+    }\n+\n+    // insert into map, rely on the fact that map's references are constant.\n+    mIdToTarget.emplace(id, target);\n+\n+    // prepare readformat with the correct size (after the insert)\n+    auto size = 3 + 2 * mIdToTarget.size();\n+    mCounters.resize(size);\n+    mCalibratedOverhead.resize(size);\n+    mLoopOverhead.resize(size);\n+\n+    return true;\n+}\n+\n+PerformanceCounters::PerformanceCounters()\n+    : mPc(new LinuxPerformanceCounters())\n+    , mVal()\n+    , mHas() {\n+\n+    mHas.pageFaults = mPc->monitor(PERF_COUNT_SW_PAGE_FAULTS, LinuxPerformanceCounters::Target(&mVal.pageFaults, true, false));\n+    mHas.cpuCycles = mPc->monitor(PERF_COUNT_HW_REF_CPU_CYCLES, LinuxPerformanceCounters::Target(&mVal.cpuCycles, true, false));\n+    mHas.contextSwitches =\n+        mPc->monitor(PERF_COUNT_SW_CONTEXT_SWITCHES, LinuxPerformanceCounters::Target(&mVal.contextSwitches, true, false));\n+    mHas.instructions = mPc->monitor(PERF_COUNT_HW_INSTRUCTIONS, LinuxPerformanceCounters::Target(&mVal.instructions, true, true));\n+    mHas.branchInstructions =\n+        mPc->monitor(PERF_COUNT_HW_BRANCH_INSTRUCTIONS, LinuxPerformanceCounters::Target(&mVal.branchInstructions, true, false));\n+    mHas.branchMisses = mPc->monitor(PERF_COUNT_HW_BRANCH_MISSES, LinuxPerformanceCounters::Target(&mVal.branchMisses, true, false));\n+    // mHas.branchMisses = false;\n+\n+    mPc->start();\n+    mPc->calibrate([] {\n+        auto before = ankerl::nanobench::Clock::now();\n+        auto after = ankerl::nanobench::Clock::now();\n+        (void)before;\n+        (void)after;\n+    });\n+\n+    if (mPc->hasError()) {\n+        // something failed, don't monitor anything.\n+        mHas = PerfCountSet<bool>{};\n+    }\n+}\n+\n+PerformanceCounters::~PerformanceCounters() {\n+    if (nullptr != mPc) {\n+        delete mPc;\n+    }\n+}\n+\n+void PerformanceCounters::beginMeasure() {\n+    mPc->beginMeasure();\n+}\n+\n+void PerformanceCounters::endMeasure() {\n+    mPc->endMeasure();\n+}\n+\n+void PerformanceCounters::updateResults(uint64_t numIters) {\n+    mPc->updateResults(numIters);\n+}\n+\n+#    else\n+\n+PerformanceCounters::PerformanceCounters() = default;\n+PerformanceCounters::~PerformanceCounters() = default;\n+void PerformanceCounters::beginMeasure() {}\n+void PerformanceCounters::endMeasure() {}\n+void PerformanceCounters::updateResults(uint64_t) {}\n+\n+#    endif\n+\n+ANKERL_NANOBENCH(NODISCARD) PerfCountSet<uint64_t> const& PerformanceCounters::val() const noexcept {\n+    return mVal;\n+}\n+ANKERL_NANOBENCH(NODISCARD) PerfCountSet<bool> const& PerformanceCounters::has() const noexcept {\n+    return mHas;\n+}\n+\n+// formatting utilities\n+namespace fmt {\n+\n+// adds thousands separator to numbers\n+NumSep::NumSep(char sep)\n+    : mSep(sep) {}\n+\n+char NumSep::do_thousands_sep() const {\n+    return mSep;\n+}\n+\n+std::string NumSep::do_grouping() const {\n+    return \"\\003\";\n+}\n+\n+// RAII to save & restore a stream's state\n+StreamStateRestorer::StreamStateRestorer(std::ostream& s)\n+    : mStream(s)\n+    , mLocale(s.getloc())\n+    , mPrecision(s.precision())\n+    , mWidth(s.width())\n+    , mFill(s.fill())\n+    , mFmtFlags(s.flags()) {}\n+\n+StreamStateRestorer::~StreamStateRestorer() {\n+    restore();\n+}\n+\n+// sets back all stream info that we remembered at construction\n+void StreamStateRestorer::restore() {\n+    mStream.imbue(mLocale);\n+    mStream.precision(mPrecision);\n+    mStream.width(mWidth);\n+    mStream.fill(mFill);\n+    mStream.flags(mFmtFlags);\n+}\n+\n+Number::Number(int width, int precision, int64_t value)\n+    : mWidth(width)\n+    , mPrecision(precision)\n+    , mValue(static_cast<double>(value)) {}\n+\n+Number::Number(int width, int precision, double value)\n+    : mWidth(width)\n+    , mPrecision(precision)\n+    , mValue(value) {}\n+\n+std::ostream& Number::write(std::ostream& os) const {\n+    StreamStateRestorer restorer(os);\n+    os.imbue(std::locale(os.getloc(), new NumSep(',')));\n+    os << std::setw(mWidth) << std::setprecision(mPrecision) << std::fixed << mValue;\n+    return os;\n+}\n+\n+std::string Number::to_s() const {\n+    std::stringstream ss;\n+    write(ss);\n+    return ss.str();\n+}\n+\n+std::string to_s(uint64_t n) {\n+    std::string str;\n+    do {\n+        str += static_cast<char>('0' + static_cast<char>(n % 10));\n+        n /= 10;\n+    } while (n != 0);\n+    std::reverse(str.begin(), str.end());\n+    return str;\n+}\n+\n+std::ostream& operator<<(std::ostream& os, Number const& n) {\n+    return n.write(os);\n+}\n+\n+MarkDownColumn::MarkDownColumn(int w, int prec, std::string const& tit, std::string const& suff, double val)\n+    : mWidth(w)\n+    , mPrecision(prec)\n+    , mTitle(tit)\n+    , mSuffix(suff)\n+    , mValue(val) {}\n+\n+std::string MarkDownColumn::title() const {\n+    std::stringstream ss;\n+    ss << '|' << std::setw(mWidth - 2) << std::right << mTitle << ' ';\n+    return ss.str();\n+}\n+\n+std::string MarkDownColumn::separator() const {\n+    std::string sep(static_cast<size_t>(mWidth), '-');\n+    sep.front() = '|';\n+    sep.back() = ':';\n+    return sep;\n+}\n+\n+std::string MarkDownColumn::invalid() const {\n+    std::string sep(static_cast<size_t>(mWidth), ' ');\n+    sep.front() = '|';\n+    sep[sep.size() - 2] = '-';\n+    return sep;\n+}\n+\n+std::string MarkDownColumn::value() const {\n+    std::stringstream ss;\n+    auto width = mWidth - 2 - static_cast<int>(mSuffix.size());\n+    ss << '|' << Number(width, mPrecision, mValue) << mSuffix << ' ';\n+    return ss.str();\n+}\n+\n+// Formats any text as markdown code, escaping backticks.\n+MarkDownCode::MarkDownCode(std::string const& what) {\n+    mWhat.reserve(what.size() + 2);\n+    mWhat.push_back('`');\n+    for (char c : what) {\n+        mWhat.push_back(c);\n+        if ('`' == c) {\n+            mWhat.push_back('`');\n+        }\n+    }\n+    mWhat.push_back('`');\n+}\n+\n+std::ostream& MarkDownCode::write(std::ostream& os) const {\n+    return os << mWhat;\n+}\n+\n+std::ostream& operator<<(std::ostream& os, MarkDownCode const& mdCode) {\n+    return mdCode.write(os);\n+}\n+} // namespace fmt\n+} // namespace detail\n+\n+// Result returned after a benchmark has finished. Can be used as a baseline for relative().\n+Result::Result(Config const& benchmarkConfig)\n+    : mConfig(benchmarkConfig) {}\n+\n+void Result::add(Clock::duration totalElapsed, uint64_t iters, detail::PerformanceCounters const& pc) {\n+    using detail::d;\n+\n+    double dIters = d(iters);\n+    mNameToMeasurements[\"iterations\"].push_back(dIters);\n+\n+    mNameToMeasurements[\"elapsed\"].push_back(d(totalElapsed) / dIters);\n+    if (pc.has().pageFaults) {\n+        mNameToMeasurements[\"pagefaults\"].push_back(d(pc.val().pageFaults) / dIters);\n+    }\n+    if (pc.has().cpuCycles) {\n+        mNameToMeasurements[\"cpucycles\"].push_back(d(pc.val().cpuCycles) / dIters);\n+    }\n+    if (pc.has().contextSwitches) {\n+        mNameToMeasurements[\"contextswitches\"].push_back(d(pc.val().contextSwitches) / dIters);\n+    }\n+    if (pc.has().instructions) {\n+        mNameToMeasurements[\"instructions\"].push_back(d(pc.val().instructions) / dIters);\n+    }\n+    if (pc.has().branchInstructions) {\n+        double branchInstructions = 0.0;\n+        // correcting branches: remove branch introduced by the while (...) loop for each iteration.\n+        if (pc.val().branchInstructions > iters + 1U) {\n+            branchInstructions = d(pc.val().branchInstructions - (iters + 1U));\n+        }\n+        mNameToMeasurements[\"branchinstructions\"].push_back(branchInstructions / dIters);\n+\n+        if (pc.has().branchMisses) {\n+            // correcting branch misses\n+            double branchMisses = d(pc.val().branchMisses);\n+            if (branchMisses > branchInstructions) {\n+                // can't have branch misses when there were branches...\n+                branchMisses = branchInstructions;\n+            }\n+\n+            // assuming at least one missed branch for the loop\n+            branchMisses -= 1.0;\n+            if (branchMisses < 1.0) {\n+                branchMisses = 1.0;\n+            }\n+            mNameToMeasurements[\"branchmisses\"].push_back(branchMisses / dIters);\n+        }\n+    }\n+}\n+\n+Config const& Result::config() const noexcept {\n+    return mConfig;\n+}\n+\n+inline double calcMedian(std::vector<double>& data) {\n+    std::sort(data.begin(), data.end());\n+\n+    auto midIdx = data.size() / 2U;\n+    if (1U == (data.size() & 1U)) {\n+        return data[midIdx];\n+    }\n+    return (data[midIdx - 1U] + data[midIdx]) / 2U;\n+}\n+\n+double Result::median(std::string const& query) const {\n+    auto it = mNameToMeasurements.find(query);\n+    if (it == mNameToMeasurements.end()) {\n+        return 0.0;\n+    }\n+\n+    // create a copy so we can sort\n+    auto data = it->second;\n+    return calcMedian(data);\n+}\n+\n+double Result::average(std::string const& query) const {\n+    using detail::d;\n+    auto it = mNameToMeasurements.find(query);\n+    if (it == mNameToMeasurements.end() || it->second.empty()) {\n+        return 0.0;\n+    }\n+\n+    // create a copy so we can sort\n+    return sum(query) / d(it->second.size());\n+}\n+\n+double Result::medianAbsolutePercentError(std::string const& query) const {\n+    auto it = mNameToMeasurements.find(query);\n+    if (it == mNameToMeasurements.end()) {\n+        return 0.0;\n+    }\n+\n+    auto data = it->second;\n+\n+    // calculates MdAPE which is the median of percentage error\n+    // see https://www.spiderfinancial.com/support/documentation/numxl/reference-manual/forecasting-performance/mdape\n+    auto med = calcMedian(data);\n+\n+    // transform the data to absolute error\n+    for (auto& x : data) {\n+        x = (x - med) / x;\n+        if (x < 0) {\n+            x = -x;\n+        }\n+    }\n+    return calcMedian(data);\n+}\n+\n+double Result::sum(std::string const& query) const noexcept {\n+    auto it = mNameToMeasurements.find(query);\n+    if (it == mNameToMeasurements.end()) {\n+        return 0.0;\n+    }\n+    return std::accumulate(it->second.begin(), it->second.end(), 0.0);\n+}\n+\n+double Result::sumProduct(std::string const& query1, std::string const& query2) const noexcept {\n+    auto it1 = mNameToMeasurements.find(query1);\n+    auto it2 = mNameToMeasurements.find(query2);\n+\n+    if (it1 == mNameToMeasurements.end() || it2 == mNameToMeasurements.end() || it1->second.size() != it2->second.size()) {\n+        return 0.0;\n+    }\n+\n+    double result = 0.0;\n+    for (size_t i = 0, s = it1->second.size(); i != s; ++i) {\n+        result += it1->second[i] * it2->second[i];\n+    }\n+    return result;\n+}\n+\n+bool Result::has(std::string const& query) const noexcept {\n+    return mNameToMeasurements.end() != mNameToMeasurements.find(query);\n+}\n+\n+double Result::get(size_t idx, std::string const& query) const {\n+    auto it = mNameToMeasurements.find(query);\n+    if (it == mNameToMeasurements.end()) {\n+        return 0.0;\n+    }\n+    return it->second.at(idx);\n+}\n+\n+bool Result::empty() const noexcept {\n+    return 0U == size();\n+}\n+\n+size_t Result::size() const noexcept {\n+    auto it = mNameToMeasurements.find(\"elapsed\");\n+    if (it == mNameToMeasurements.end()) {\n+        return 0U;\n+    }\n+    return it->second.size();\n+}\n+\n+double Result::minimum(std::string const& query) const noexcept {\n+    auto it = mNameToMeasurements.find(query);\n+    if (it == mNameToMeasurements.end()) {\n+        return 0.0;\n+    }\n+\n+    // here its save to assume that at least one element is there\n+    return *std::min_element(it->second.begin(), it->second.end());\n+}\n+\n+double Result::maximum(std::string const& query) const noexcept {\n+    auto it = mNameToMeasurements.find(query);\n+    if (it == mNameToMeasurements.end()) {\n+        return 0.0;\n+    }\n+\n+    // here its save to assume that at least one element is there\n+    return *std::max_element(it->second.begin(), it->second.end());\n+}\n+\n+// Configuration of a microbenchmark.\n+Bench::Bench() {\n+    mConfig.mOut = &std::cout;\n+}\n+\n+Bench::Bench(Bench&&) = default;\n+Bench& Bench::operator=(Bench&&) = default;\n+Bench::Bench(Bench const&) = default;\n+Bench& Bench::operator=(Bench const&) = default;\n+Bench::~Bench() noexcept = default;\n+\n+double Bench::batch() const noexcept {\n+    return mConfig.mBatch;\n+}\n+\n+double Bench::complexityN() const noexcept {\n+    return mConfig.mComplexityN;\n+}\n+\n+// Set a baseline to compare it to. 100% it is exactly as fast as the baseline, >100% means it is faster than the baseline, <100%\n+// means it is slower than the baseline.\n+Bench& Bench::relative(bool isRelativeEnabled) noexcept {\n+    mConfig.mIsRelative = isRelativeEnabled;\n+    return *this;\n+}\n+bool Bench::relative() const noexcept {\n+    return mConfig.mIsRelative;\n+}\n+\n+Bench& Bench::performanceCounters(bool showPerformanceCounters) noexcept {\n+    mConfig.mShowPerformanceCounters = showPerformanceCounters;\n+    return *this;\n+}\n+bool Bench::performanceCounters() const noexcept {\n+    return mConfig.mShowPerformanceCounters;\n+}\n+\n+// Operation unit. Defaults to \"op\", could be e.g. \"byte\" for string processing.\n+// If u differs from currently set unit, the stored results will be cleared.\n+// Use singular (byte, not bytes).\n+Bench& Bench::unit(std::string u) {\n+    if (u != mConfig.mUnit) {\n+        mResults.clear();\n+    }\n+    mConfig.mUnit = std::move(u);\n+    return *this;\n+}\n+std::string const& Bench::unit() const noexcept {\n+    return mConfig.mUnit;\n+}\n+\n+// If benchmarkTitle differs from currently set title, the stored results will be cleared.\n+Bench& Bench::title(std::string benchmarkTitle) {\n+    if (benchmarkTitle != mConfig.mBenchmarkTitle) {\n+        mResults.clear();\n+    }\n+    mConfig.mBenchmarkTitle = std::move(benchmarkTitle);\n+    return *this;\n+}\n+std::string const& Bench::title() const noexcept {\n+    return mConfig.mBenchmarkTitle;\n+}\n+\n+Bench& Bench::name(std::string benchmarkName) {\n+    mConfig.mBenchmarkName = std::move(benchmarkName);\n+    return *this;\n+}\n+std::string const& Bench::name() const noexcept {\n+    return mConfig.mBenchmarkName;\n+}\n+\n+// Number of epochs to evaluate. The reported result will be the median of evaluation of each epoch.\n+Bench& Bench::epochs(size_t numEpochs) noexcept {\n+    mConfig.mNumEpochs = numEpochs;\n+    return *this;\n+}\n+size_t Bench::epochs() const noexcept {\n+    return mConfig.mNumEpochs;\n+}\n+\n+// Desired evaluation time is a multiple of clock resolution. Default is to be 1000 times above this measurement precision.\n+Bench& Bench::clockResolutionMultiple(size_t multiple) noexcept {\n+    mConfig.mClockResolutionMultiple = multiple;\n+    return *this;\n+}\n+size_t Bench::clockResolutionMultiple() const noexcept {\n+    return mConfig.mClockResolutionMultiple;\n+}\n+\n+// Sets the maximum time each epoch should take. Default is 100ms.\n+Bench& Bench::maxEpochTime(std::chrono::nanoseconds t) noexcept {\n+    mConfig.mMaxEpochTime = t;\n+    return *this;\n+}\n+std::chrono::nanoseconds Bench::maxEpochTime() const noexcept {\n+    return mConfig.mMaxEpochTime;\n+}\n+\n+// Sets the maximum time each epoch should take. Default is 100ms.\n+Bench& Bench::minEpochTime(std::chrono::nanoseconds t) noexcept {\n+    mConfig.mMinEpochTime = t;\n+    return *this;\n+}\n+std::chrono::nanoseconds Bench::minEpochTime() const noexcept {\n+    return mConfig.mMinEpochTime;\n+}\n+\n+Bench& Bench::minEpochIterations(uint64_t numIters) noexcept {\n+    mConfig.mMinEpochIterations = (numIters == 0) ? 1 : numIters;\n+    return *this;\n+}\n+uint64_t Bench::minEpochIterations() const noexcept {\n+    return mConfig.mMinEpochIterations;\n+}\n+\n+Bench& Bench::warmup(uint64_t numWarmupIters) noexcept {\n+    mConfig.mWarmup = numWarmupIters;\n+    return *this;\n+}\n+uint64_t Bench::warmup() const noexcept {\n+    return mConfig.mWarmup;\n+}\n+\n+Bench& Bench::config(Config const& benchmarkConfig) {\n+    mConfig = benchmarkConfig;\n+    return *this;\n+}\n+Config const& Bench::config() const noexcept {\n+    return mConfig;\n+}\n+\n+Bench& Bench::output(std::ostream* outstream) noexcept {\n+    mConfig.mOut = outstream;\n+    return *this;\n+}\n+\n+ANKERL_NANOBENCH(NODISCARD) std::ostream* Bench::output() const noexcept {\n+    return mConfig.mOut;\n+}\n+\n+std::vector<Result> const& Bench::results() const noexcept {\n+    return mResults;\n+}\n+\n+Bench& Bench::render(char const* templateContent, std::ostream& os) {\n+    templates::generate(templateContent, mResults, os);\n+    return *this;\n+}\n+\n+std::vector<BigO> Bench::complexityBigO() const {\n+    std::vector<BigO> bigOs;\n+    auto rangeMeasure = BigO::collectRangeMeasure(mResults);\n+    bigOs.emplace_back(\"O(1)\", rangeMeasure, [](double) { return 1.0; });\n+    bigOs.emplace_back(\"O(n)\", rangeMeasure, [](double n) { return n; });\n+    bigOs.emplace_back(\"O(log n)\", rangeMeasure, [](double n) { return std::log2(n); });\n+    bigOs.emplace_back(\"O(n log n)\", rangeMeasure, [](double n) { return n * std::log2(n); });\n+    bigOs.emplace_back(\"O(n^2)\", rangeMeasure, [](double n) { return n * n; });\n+    bigOs.emplace_back(\"O(n^3)\", rangeMeasure, [](double n) { return n * n * n; });\n+    std::sort(bigOs.begin(), bigOs.end());\n+    return bigOs;\n+}\n+\n+Rng::Rng()\n+    : mX(0)\n+    , mY(0)\n+    , mZ(0) {\n+    std::random_device rd;\n+    std::uniform_int_distribution<uint64_t> dist;\n+    do {\n+        mX = dist(rd);\n+        mY = dist(rd);\n+        mZ = dist(rd);\n+    } while (mX == 0 && mY == 0 && mZ == 0);\n+}\n+\n+// mY and mZ are set to random numbers. I don't set them to seed, because then the whole state could be zero if seed itself is zero.\n+// calling operator()() a few times to get some initial mixing.\n+Rng::Rng(uint64_t seed) noexcept\n+    : mX(seed)\n+    , mY(UINT64_C(0x31b69f9239739e03))\n+    , mZ(UINT64_C(0xb86f0df2ab5b2501)) {\n+    for (size_t i = 0; i < 12; ++i) {\n+        operator()();\n+    }\n+}\n+\n+Rng::Rng(uint64_t x, uint64_t y, uint64_t z) noexcept\n+    : mX(x)\n+    , mY(y)\n+    , mZ(z) {}\n+\n+Rng Rng::copy() const noexcept {\n+    return Rng{mX, mY, mZ};\n+}\n+\n+void Rng::assign(Rng const& other) noexcept {\n+    mX = other.mX;\n+    mY = other.mY;\n+    mZ = other.mZ;\n+}\n+\n+BigO::RangeMeasure BigO::collectRangeMeasure(std::vector<Result> const& results) {\n+    BigO::RangeMeasure rangeMeasure;\n+    for (auto const& result : results) {\n+        if (result.config().mComplexityN > 0.0) {\n+            rangeMeasure.emplace_back(result.config().mComplexityN, result.median(\"elapsed\"));\n+        }\n+    }\n+    return rangeMeasure;\n+}\n+\n+BigO::BigO(std::string const& bigOName, RangeMeasure const& rangeMeasure)\n+    : mName(bigOName) {\n+\n+    // estimate the constant factor\n+    double sumRangeMeasure = 0.0;\n+    double sumRangeRange = 0.0;\n+\n+    for (size_t i = 0; i < rangeMeasure.size(); ++i) {\n+        sumRangeMeasure += rangeMeasure[i].first * rangeMeasure[i].second;\n+        sumRangeRange += rangeMeasure[i].first * rangeMeasure[i].first;\n+    }\n+    mConstant = sumRangeMeasure / sumRangeRange;\n+\n+    // calculate root mean square\n+    double err = 0.0;\n+    double sumMeasure = 0.0;\n+    for (size_t i = 0; i < rangeMeasure.size(); ++i) {\n+        auto diff = mConstant * rangeMeasure[i].first - rangeMeasure[i].second;\n+        err += diff * diff;\n+\n+        sumMeasure += rangeMeasure[i].second;\n+    }\n+\n+    auto n = static_cast<double>(rangeMeasure.size());\n+    auto mean = sumMeasure / n;\n+    mNormalizedRootMeanSquare = std::sqrt(err / n) / mean;\n+}\n+\n+std::string const& BigO::name() const noexcept {\n+    return mName;\n+}\n+\n+double BigO::constant() const noexcept {\n+    return mConstant;\n+}\n+\n+double BigO::normalizedRootMeanSquare() const noexcept {\n+    return mNormalizedRootMeanSquare;\n+}\n+\n+bool BigO::operator<(BigO const& other) const noexcept {\n+    return std::tie(mNormalizedRootMeanSquare, mName) < std::tie(other.mNormalizedRootMeanSquare, other.mName);\n+}\n+\n+std::ostream& operator<<(std::ostream& os, BigO const& bigO) {\n+    return os << bigO.constant() << \" * \" << bigO.name() << \", rms=\" << bigO.normalizedRootMeanSquare();\n+}\n+\n+std::ostream& operator<<(std::ostream& os, std::vector<ankerl::nanobench::BigO> const& bigOs) {\n+    os << std::endl << \"|   coefficient |   err% | complexity\" << std::endl << \"|--------------:|-------:|------------\" << std::endl;\n+    for (auto const& bigO : bigOs) {\n+        os << \"|\" << std::setw(14) << bigO.constant() << \" \";\n+        os << \"|\" << detail::fmt::Number(6, 1, bigO.normalizedRootMeanSquare() * 100.0) << \"% \";\n+        os << \"| \" << bigO.name();\n+        os << std::endl;\n+    }\n+    return os;\n+}\n+\n+} // namespace nanobench\n+} // namespace ankerl\n+\n+#endif // ANKERL_NANOBENCH_IMPLEMENT\n+#endif // ANKERL_NANOBENCH_H_INCLUDED"
      },
      {
        "sha": "d8db99e7d4d7f1cd5b8c08310d839333e8115ae4",
        "filename": "src/bench/poly1305.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 11,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/poly1305.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/poly1305.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/poly1305.cpp?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -11,30 +11,31 @@ static constexpr uint64_t BUFFER_SIZE_TINY  = 64;\n static constexpr uint64_t BUFFER_SIZE_SMALL = 256;\n static constexpr uint64_t BUFFER_SIZE_LARGE = 1024*1024;\n \n-static void POLY1305(benchmark::State& state, size_t buffersize)\n+static void POLY1305(benchmark::Bench& bench, size_t buffersize)\n {\n     std::vector<unsigned char> tag(POLY1305_TAGLEN, 0);\n     std::vector<unsigned char> key(POLY1305_KEYLEN, 0);\n     std::vector<unsigned char> in(buffersize, 0);\n-    while (state.KeepRunning())\n+    bench.batch(in.size()).unit(\"byte\").run([&] {\n         poly1305_auth(tag.data(), in.data(), in.size(), key.data());\n+    });\n }\n \n-static void POLY1305_64BYTES(benchmark::State& state)\n+static void POLY1305_64BYTES(benchmark::Bench& bench)\n {\n-    POLY1305(state, BUFFER_SIZE_TINY);\n+    POLY1305(bench, BUFFER_SIZE_TINY);\n }\n \n-static void POLY1305_256BYTES(benchmark::State& state)\n+static void POLY1305_256BYTES(benchmark::Bench& bench)\n {\n-    POLY1305(state, BUFFER_SIZE_SMALL);\n+    POLY1305(bench, BUFFER_SIZE_SMALL);\n }\n \n-static void POLY1305_1MB(benchmark::State& state)\n+static void POLY1305_1MB(benchmark::Bench& bench)\n {\n-    POLY1305(state, BUFFER_SIZE_LARGE);\n+    POLY1305(bench, BUFFER_SIZE_LARGE);\n }\n \n-BENCHMARK(POLY1305_64BYTES, 500000);\n-BENCHMARK(POLY1305_256BYTES, 250000);\n-BENCHMARK(POLY1305_1MB, 340);\n+BENCHMARK(POLY1305_64BYTES);\n+BENCHMARK(POLY1305_256BYTES);\n+BENCHMARK(POLY1305_1MB);"
      },
      {
        "sha": "9b825b3754b516e906dee0b8ce87689134968b65",
        "filename": "src/bench/prevector.cpp",
        "status": "modified",
        "additions": 43,
        "deletions": 48,
        "changes": 91,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/prevector.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/prevector.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/prevector.cpp?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -32,51 +32,44 @@ static_assert(IS_TRIVIALLY_CONSTRUCTIBLE<trivial_t>::value,\n               \"expected trivial_t to be trivially constructible\");\n \n template <typename T>\n-static void PrevectorDestructor(benchmark::State& state)\n+static void PrevectorDestructor(benchmark::Bench& bench)\n {\n-    while (state.KeepRunning()) {\n-        for (auto x = 0; x < 1000; ++x) {\n-            prevector<28, T> t0;\n-            prevector<28, T> t1;\n-            t0.resize(28);\n-            t1.resize(29);\n-        }\n-    }\n+    bench.batch(2).run([&] {\n+        prevector<28, T> t0;\n+        prevector<28, T> t1;\n+        t0.resize(28);\n+        t1.resize(29);\n+    });\n }\n \n template <typename T>\n-static void PrevectorClear(benchmark::State& state)\n+static void PrevectorClear(benchmark::Bench& bench)\n {\n-\n-    while (state.KeepRunning()) {\n-        for (auto x = 0; x < 1000; ++x) {\n-            prevector<28, T> t0;\n-            prevector<28, T> t1;\n-            t0.resize(28);\n-            t0.clear();\n-            t1.resize(29);\n-            t1.clear();\n-        }\n-    }\n+    prevector<28, T> t0;\n+    prevector<28, T> t1;\n+    bench.batch(2).run([&] {\n+        t0.resize(28);\n+        t0.clear();\n+        t1.resize(29);\n+        t1.clear();\n+    });\n }\n \n template <typename T>\n-static void PrevectorResize(benchmark::State& state)\n+static void PrevectorResize(benchmark::Bench& bench)\n {\n-    while (state.KeepRunning()) {\n-        prevector<28, T> t0;\n-        prevector<28, T> t1;\n-        for (auto x = 0; x < 1000; ++x) {\n-            t0.resize(28);\n-            t0.resize(0);\n-            t1.resize(29);\n-            t1.resize(0);\n-        }\n-    }\n+    prevector<28, T> t0;\n+    prevector<28, T> t1;\n+    bench.batch(4).run([&] {\n+        t0.resize(28);\n+        t0.resize(0);\n+        t1.resize(29);\n+        t1.resize(0);\n+    });\n }\n \n template <typename T>\n-static void PrevectorDeserialize(benchmark::State& state)\n+static void PrevectorDeserialize(benchmark::Bench& bench)\n {\n     CDataStream s0(SER_NETWORK, 0);\n     prevector<28, T> t0;\n@@ -88,26 +81,28 @@ static void PrevectorDeserialize(benchmark::State& state)\n     for (auto x = 0; x < 101; ++x) {\n         s0 << t0;\n     }\n-    while (state.KeepRunning()) {\n+    bench.batch(1000).run([&] {\n         prevector<28, T> t1;\n         for (auto x = 0; x < 1000; ++x) {\n             s0 >> t1;\n         }\n         s0.Init(SER_NETWORK, 0);\n-    }\n+    });\n }\n \n-#define PREVECTOR_TEST(name, nontrivops, trivops)                       \\\n-    static void Prevector ## name ## Nontrivial(benchmark::State& state) { \\\n-        Prevector ## name<nontrivial_t>(state);                         \\\n-    }                                                                   \\\n-    BENCHMARK(Prevector ## name ## Nontrivial, nontrivops);             \\\n-    static void Prevector ## name ## Trivial(benchmark::State& state) { \\\n-        Prevector ## name<trivial_t>(state);                            \\\n-    }                                                                   \\\n-    BENCHMARK(Prevector ## name ## Trivial, trivops);\n+#define PREVECTOR_TEST(name)                                         \\\n+    static void Prevector##name##Nontrivial(benchmark::Bench& bench) \\\n+    {                                                                \\\n+        Prevector##name<nontrivial_t>(bench);                        \\\n+    }                                                                \\\n+    BENCHMARK(Prevector##name##Nontrivial);                          \\\n+    static void Prevector##name##Trivial(benchmark::Bench& bench)    \\\n+    {                                                                \\\n+        Prevector##name<trivial_t>(bench);                           \\\n+    }                                                                \\\n+    BENCHMARK(Prevector##name##Trivial);\n \n-PREVECTOR_TEST(Clear, 28300, 88600)\n-PREVECTOR_TEST(Destructor, 28800, 88900)\n-PREVECTOR_TEST(Resize, 28900, 90300)\n-PREVECTOR_TEST(Deserialize, 6800, 52000)\n+PREVECTOR_TEST(Clear)\n+PREVECTOR_TEST(Destructor)\n+PREVECTOR_TEST(Resize)\n+PREVECTOR_TEST(Deserialize)"
      },
      {
        "sha": "9b43951e6e2046737a2012475261ce1ce2cc057e",
        "filename": "src/bench/rollingbloom.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/rollingbloom.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/rollingbloom.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/rollingbloom.cpp?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -6,12 +6,12 @@\n #include <bench/bench.h>\n #include <bloom.h>\n \n-static void RollingBloom(benchmark::State& state)\n+static void RollingBloom(benchmark::Bench& bench)\n {\n     CRollingBloomFilter filter(120000, 0.000001);\n     std::vector<unsigned char> data(32);\n     uint32_t count = 0;\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         count++;\n         data[0] = count;\n         data[1] = count >> 8;\n@@ -24,16 +24,16 @@ static void RollingBloom(benchmark::State& state)\n         data[2] = count >> 8;\n         data[3] = count;\n         filter.contains(data);\n-    }\n+    });\n }\n \n-static void RollingBloomReset(benchmark::State& state)\n+static void RollingBloomReset(benchmark::Bench& bench)\n {\n     CRollingBloomFilter filter(120000, 0.000001);\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         filter.reset();\n-    }\n+    });\n }\n \n-BENCHMARK(RollingBloom, 1500 * 1000);\n-BENCHMARK(RollingBloomReset, 20000);\n+BENCHMARK(RollingBloom);\n+BENCHMARK(RollingBloomReset);"
      },
      {
        "sha": "7143a4f9dd58d95fbe01bd8a0e204fba36a7e176",
        "filename": "src/bench/rpc_blockchain.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/rpc_blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/rpc_blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/rpc_blockchain.cpp?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -11,7 +11,8 @@\n \n #include <univalue.h>\n \n-static void BlockToJsonVerbose(benchmark::State& state) {\n+static void BlockToJsonVerbose(benchmark::Bench& bench)\n+{\n     CDataStream stream(benchmark::data::block413567, SER_NETWORK, PROTOCOL_VERSION);\n     char a = '\\0';\n     stream.write(&a, 1); // Prevent compaction\n@@ -24,9 +25,9 @@ static void BlockToJsonVerbose(benchmark::State& state) {\n     blockindex.phashBlock = &blockHash;\n     blockindex.nBits = 403014710;\n \n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         (void)blockToJSON(block, &blockindex, &blockindex, /*verbose*/ true);\n-    }\n+    });\n }\n \n-BENCHMARK(BlockToJsonVerbose, 10);\n+BENCHMARK(BlockToJsonVerbose);"
      },
      {
        "sha": "1ff41765cfa0c4e1e30f3cbf834c6c40c091d92b",
        "filename": "src/bench/rpc_mempool.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/rpc_mempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/rpc_mempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/rpc_mempool.cpp?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -15,7 +15,7 @@ static void AddTx(const CTransactionRef& tx, const CAmount& fee, CTxMemPool& poo\n     pool.addUnchecked(CTxMemPoolEntry(tx, fee, /* time */ 0, /* height */ 1, /* spendsCoinbase */ false, /* sigOpCost */ 4, lp));\n }\n \n-static void RpcMempool(benchmark::State& state)\n+static void RpcMempool(benchmark::Bench& bench)\n {\n     CTxMemPool pool;\n     LOCK2(cs_main, pool.cs);\n@@ -32,9 +32,9 @@ static void RpcMempool(benchmark::State& state)\n         AddTx(tx_r, /* fee */ i, pool);\n     }\n \n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         (void)MempoolToJSON(pool, /*verbose*/ true);\n-    }\n+    });\n }\n \n-BENCHMARK(RpcMempool, 40);\n+BENCHMARK(RpcMempool);"
      },
      {
        "sha": "fad179eb8770bfcbaf4e4ac2ff70203d38ea4577",
        "filename": "src/bench/util_time.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/util_time.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/util_time.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/util_time.cpp?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -6,37 +6,37 @@\n \n #include <util/time.h>\n \n-static void BenchTimeDeprecated(benchmark::State& state)\n+static void BenchTimeDeprecated(benchmark::Bench& bench)\n {\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         (void)GetTime();\n-    }\n+    });\n }\n \n-static void BenchTimeMock(benchmark::State& state)\n+static void BenchTimeMock(benchmark::Bench& bench)\n {\n     SetMockTime(111);\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         (void)GetTime<std::chrono::seconds>();\n-    }\n+    });\n     SetMockTime(0);\n }\n \n-static void BenchTimeMillis(benchmark::State& state)\n+static void BenchTimeMillis(benchmark::Bench& bench)\n {\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         (void)GetTime<std::chrono::milliseconds>();\n-    }\n+    });\n }\n \n-static void BenchTimeMillisSys(benchmark::State& state)\n+static void BenchTimeMillisSys(benchmark::Bench& bench)\n {\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         (void)GetTimeMillis();\n-    }\n+    });\n }\n \n-BENCHMARK(BenchTimeDeprecated, 100000000);\n-BENCHMARK(BenchTimeMillis, 6000000);\n-BENCHMARK(BenchTimeMillisSys, 6000000);\n-BENCHMARK(BenchTimeMock, 300000000);\n+BENCHMARK(BenchTimeDeprecated);\n+BENCHMARK(BenchTimeMillis);\n+BENCHMARK(BenchTimeMillisSys);\n+BENCHMARK(BenchTimeMock);"
      },
      {
        "sha": "c6c2d442ab109b20f33705d58ac5f3aa709ec1cf",
        "filename": "src/bench/verify_script.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 10,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/verify_script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/verify_script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/verify_script.cpp?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -16,7 +16,7 @@\n \n // Microbenchmark for verification of a basic P2WPKH script. Can be easily\n // modified to measure performance of other types of scripts.\n-static void VerifyScriptBench(benchmark::State& state)\n+static void VerifyScriptBench(benchmark::Bench& bench)\n {\n     const int flags = SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH;\n     const int witnessversion = 0;\n@@ -46,7 +46,7 @@ static void VerifyScriptBench(benchmark::State& state)\n     witness.stack.push_back(ToByteVector(pubkey));\n \n     // Benchmark.\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         ScriptError err;\n         bool success = VerifyScript(\n             txSpend.vin[0].scriptSig,\n@@ -68,10 +68,11 @@ static void VerifyScriptBench(benchmark::State& state)\n             (const unsigned char*)stream.data(), stream.size(), 0, flags, nullptr);\n         assert(csuccess == 1);\n #endif\n-    }\n+    });\n }\n \n-static void VerifyNestedIfScript(benchmark::State& state) {\n+static void VerifyNestedIfScript(benchmark::Bench& bench)\n+{\n     std::vector<std::vector<unsigned char>> stack;\n     CScript script;\n     for (int i = 0; i < 100; ++i) {\n@@ -83,15 +84,13 @@ static void VerifyNestedIfScript(benchmark::State& state) {\n     for (int i = 0; i < 100; ++i) {\n         script << OP_ENDIF;\n     }\n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         auto stack_copy = stack;\n         ScriptError error;\n         bool ret = EvalScript(stack_copy, script, 0, BaseSignatureChecker(), SigVersion::BASE, &error);\n         assert(ret);\n-    }\n+    });\n }\n \n-\n-BENCHMARK(VerifyScriptBench, 6300);\n-\n-BENCHMARK(VerifyNestedIfScript, 100);\n+BENCHMARK(VerifyScriptBench);\n+BENCHMARK(VerifyNestedIfScript);"
      },
      {
        "sha": "a7b583fb7b19a4256e14c8ad85709961365fccdb",
        "filename": "src/bench/wallet_balance.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/wallet_balance.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/src/bench/wallet_balance.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/wallet_balance.cpp?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -12,7 +12,7 @@\n #include <validationinterface.h>\n #include <wallet/wallet.h>\n \n-static void WalletBalance(benchmark::State& state, const bool set_dirty, const bool add_watchonly, const bool add_mine)\n+static void WalletBalance(benchmark::Bench& bench, const bool set_dirty, const bool add_watchonly, const bool add_mine)\n {\n     const auto& ADDRESS_WATCHONLY = ADDRESS_BCRT1_UNSPENDABLE;\n \n@@ -38,20 +38,20 @@ static void WalletBalance(benchmark::State& state, const bool set_dirty, const b\n \n     auto bal = wallet.GetBalance(); // Cache\n \n-    while (state.KeepRunning()) {\n+    bench.run([&] {\n         if (set_dirty) wallet.MarkDirty();\n         bal = wallet.GetBalance();\n         if (add_mine) assert(bal.m_mine_trusted > 0);\n         if (add_watchonly) assert(bal.m_watchonly_trusted > 0);\n-    }\n+    });\n }\n \n-static void WalletBalanceDirty(benchmark::State& state) { WalletBalance(state, /* set_dirty */ true, /* add_watchonly */ true, /* add_mine */ true); }\n-static void WalletBalanceClean(benchmark::State& state) { WalletBalance(state, /* set_dirty */ false, /* add_watchonly */ true, /* add_mine */ true); }\n-static void WalletBalanceMine(benchmark::State& state) { WalletBalance(state, /* set_dirty */ false, /* add_watchonly */ false, /* add_mine */ true); }\n-static void WalletBalanceWatch(benchmark::State& state) { WalletBalance(state, /* set_dirty */ false, /* add_watchonly */ true, /* add_mine */ false); }\n+static void WalletBalanceDirty(benchmark::Bench& bench) { WalletBalance(bench, /* set_dirty */ true, /* add_watchonly */ true, /* add_mine */ true); }\n+static void WalletBalanceClean(benchmark::Bench& bench) { WalletBalance(bench, /* set_dirty */ false, /* add_watchonly */ true, /* add_mine */ true); }\n+static void WalletBalanceMine(benchmark::Bench& bench) { WalletBalance(bench, /* set_dirty */ false, /* add_watchonly */ false, /* add_mine */ true); }\n+static void WalletBalanceWatch(benchmark::Bench& bench) { WalletBalance(bench, /* set_dirty */ false, /* add_watchonly */ true, /* add_mine */ false); }\n \n-BENCHMARK(WalletBalanceDirty, 2500);\n-BENCHMARK(WalletBalanceClean, 8000);\n-BENCHMARK(WalletBalanceMine, 16000);\n-BENCHMARK(WalletBalanceWatch, 8000);\n+BENCHMARK(WalletBalanceDirty);\n+BENCHMARK(WalletBalanceClean);\n+BENCHMARK(WalletBalanceMine);\n+BENCHMARK(WalletBalanceWatch);"
      },
      {
        "sha": "5d5a150db877147a9aef858237d722de66d30877",
        "filename": "test/lint/lint-include-guards.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a7e92139bf8b7aefc11a5531eddc189431e03ff/test/lint/lint-include-guards.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a7e92139bf8b7aefc11a5531eddc189431e03ff/test/lint/lint-include-guards.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-include-guards.sh?ref=4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "patch": "@@ -10,7 +10,7 @@ export LC_ALL=C\n HEADER_ID_PREFIX=\"BITCOIN_\"\n HEADER_ID_SUFFIX=\"_H\"\n \n-REGEXP_EXCLUDE_FILES_WITH_PREFIX=\"src/(crypto/ctaes/|leveldb/|crc32c/|secp256k1/|test/fuzz/FuzzedDataProvider.h|tinyformat.h|univalue/)\"\n+REGEXP_EXCLUDE_FILES_WITH_PREFIX=\"src/(crypto/ctaes/|leveldb/|crc32c/|secp256k1/|test/fuzz/FuzzedDataProvider.h|tinyformat.h|bench/nanobench.h|univalue/)\"\n \n EXIT_CODE=0\n for HEADER_FILE in $(git ls-files -- \"*.h\" | grep -vE \"^${REGEXP_EXCLUDE_FILES_WITH_PREFIX}\")"
      }
    ]
  },
  {
    "sha": "e88e8a0d69435ac65ff38a65c00fa500bcefa343",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplODhlOGEwZDY5NDM1YWM2NWZmMzhhNjVjMDBmYTUwMGJjZWZhMzQz",
    "commit": {
      "author": {
        "name": "Martin Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2020-02-20T20:31:22Z"
      },
      "committer": {
        "name": "Martin Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2020-03-28T07:31:29Z"
      },
      "message": "Do not write benchmarkresults.csv when calling benchmark with -list",
      "tree": {
        "sha": "041aa36f4ec49e2bf758683e3017e088cc1d4e01",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/041aa36f4ec49e2bf758683e3017e088cc1d4e01"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e88e8a0d69435ac65ff38a65c00fa500bcefa343",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e88e8a0d69435ac65ff38a65c00fa500bcefa343",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e88e8a0d69435ac65ff38a65c00fa500bcefa343",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e88e8a0d69435ac65ff38a65c00fa500bcefa343/comments",
    "author": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4a7e92139bf8b7aefc11a5531eddc189431e03ff",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4a7e92139bf8b7aefc11a5531eddc189431e03ff"
      }
    ],
    "stats": {
      "total": 18,
      "additions": 9,
      "deletions": 9
    },
    "files": [
      {
        "sha": "8c975fe27d4ce46549178615c9b51b4914bd2bd6",
        "filename": "src/bench/bench.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e88e8a0d69435ac65ff38a65c00fa500bcefa343/src/bench/bench.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e88e8a0d69435ac65ff38a65c00fa500bcefa343/src/bench/bench.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench.cpp?ref=e88e8a0d69435ac65ff38a65c00fa500bcefa343",
        "patch": "@@ -57,14 +57,14 @@ void benchmark::BenchRunner::RunAll(const std::string& filter, bool is_list_only\n         g_testing_setup = nullptr;\n     }\n \n-    // Generate legacy CSV data to \"benchmarkresults.csv\"\n-    std::ofstream fout(\"benchmarkresults.csv\");\n-\n-    // Base58CheckEncode, 5, 320000, 2.70232, 1.68246e-06, 1.69408e-06, 1.69268e-06\n-    if (fout.is_open()) {\n-        templates::generate(\"# Benchmark, evals, iterations, total, min, max, median\\n\"\n-                            \"{{#result}}{{name}}, {{epochs}}, {{average(iterations)}}, {{sumProduct(iterations, elapsed)}}, {{minimum(elapsed)}}, {{maximum(elapsed)}}, {{median(elapsed)}}\\n\"\n-                            \"{{/result}}\",\n-            benchmarkResults, fout);\n+    if (!benchmarkResults.empty()) {\n+        // Generate legacy CSV data to \"benchmarkresults.csv\"\n+        std::ofstream fout(\"benchmarkresults.csv\");\n+        if (fout.is_open()) {\n+            templates::generate(\"# Benchmark, evals, iterations, total, min, max, median\\n\"\n+                                \"{{#result}}{{name}}, {{epochs}}, {{average(iterations)}}, {{sumProduct(iterations, elapsed)}}, {{minimum(elapsed)}}, {{maximum(elapsed)}}, {{median(elapsed)}}\\n\"\n+                                \"{{/result}}\",\n+                benchmarkResults, fout);\n+        }\n     }\n }"
      }
    ]
  },
  {
    "sha": "4c33547849a85158ca59807b00b033fbb2f1cb32",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0YzMzNTQ3ODQ5YTg1MTU4Y2E1OTgwN2IwMGIwMzNmYmIyZjFjYjMy",
    "commit": {
      "author": {
        "name": "Martin Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2020-02-20T21:34:46Z"
      },
      "committer": {
        "name": "Martin Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2020-03-28T07:31:29Z"
      },
      "message": "Adds support for asymptotes\n\nThis adds support to calculate asymptotic complexity of a benchmark.\nThis is similar to #17375, but currently only one asymptote is\nsupported, and I have added support in the benchmark `ComplexMemPool`\nas an example.\n\nUsage is e.g. like this:\n\n```\n./bench_bitcoin -filter=ComplexMemPool -asymptote=25,50,100,200,400,600,800\n```\n\nThis runs the benchmark `ComplexMemPool` several times but with\ndifferent complexityN settings. The benchmark can extract that number\nand use it accordingly. Here, it's used for `childTxs`. The output is\nthis:\n\n| complexityN |               ns/op |                op/s |    err% |          ins/op |          cyc/op |    IPC |     total | benchmark\n|------------:|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|----------:|:----------\n|          25 |        1,064,241.00 |              939.64 |    1.4% |    3,960,279.00 |    2,829,708.00 |  1.400 |      0.01 | `ComplexMemPool`\n|          50 |        1,579,530.00 |              633.10 |    1.0% |    6,231,810.00 |    4,412,674.00 |  1.412 |      0.02 | `ComplexMemPool`\n|         100 |        4,022,774.00 |              248.58 |    0.6% |   16,544,406.00 |   11,889,535.00 |  1.392 |      0.04 | `ComplexMemPool`\n|         200 |       15,390,986.00 |               64.97 |    0.2% |   63,904,254.00 |   47,731,705.00 |  1.339 |      0.17 | `ComplexMemPool`\n|         400 |       69,394,711.00 |               14.41 |    0.1% |  272,602,461.00 |  219,014,691.00 |  1.245 |      0.76 | `ComplexMemPool`\n|         600 |      168,977,165.00 |                5.92 |    0.1% |  639,108,082.00 |  535,316,887.00 |  1.194 |      1.86 | `ComplexMemPool`\n|         800 |      310,109,077.00 |                3.22 |    0.1% |1,149,134,246.00 |  984,620,812.00 |  1.167 |      3.41 | `ComplexMemPool`\n\n|   coefficient |   err% | complexity\n|--------------:|-------:|------------\n|   4.78486e-07 |   4.5% | O(n^2)\n|   6.38557e-10 |  21.7% | O(n^3)\n|   3.42338e-05 |  38.0% | O(n log n)\n|   0.000313914 |  46.9% | O(n)\n|     0.0129823 | 114.4% | O(log n)\n|     0.0815055 | 133.8% | O(1)\n\nThe best fitting curve is O(n^2), so the algorithm seems to scale\nquadratic with `childTxs` in the range 25 to 800.",
      "tree": {
        "sha": "60dea126d75ee5e7a38e0467cd2676461d8b98df",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/60dea126d75ee5e7a38e0467cd2676461d8b98df"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4c33547849a85158ca59807b00b033fbb2f1cb32",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4c33547849a85158ca59807b00b033fbb2f1cb32",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4c33547849a85158ca59807b00b033fbb2f1cb32",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4c33547849a85158ca59807b00b033fbb2f1cb32/comments",
    "author": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e88e8a0d69435ac65ff38a65c00fa500bcefa343",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e88e8a0d69435ac65ff38a65c00fa500bcefa343",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e88e8a0d69435ac65ff38a65c00fa500bcefa343"
      }
    ],
    "stats": {
      "total": 43,
      "additions": 37,
      "deletions": 6
    },
    "files": [
      {
        "sha": "7c6eb9ab1c08f64c1451ef8f94931b3755ae9965",
        "filename": "src/bench/bench.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 2,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c33547849a85158ca59807b00b033fbb2f1cb32/src/bench/bench.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c33547849a85158ca59807b00b033fbb2f1cb32/src/bench/bench.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench.cpp?ref=4c33547849a85158ca59807b00b033fbb2f1cb32",
        "patch": "@@ -24,7 +24,7 @@ benchmark::BenchRunner::BenchRunner(std::string name, benchmark::BenchFunction f\n     benchmarks().insert(std::make_pair(name, func));\n }\n \n-void benchmark::BenchRunner::RunAll(const std::string& filter, bool is_list_only)\n+void benchmark::BenchRunner::RunAll(const std::string& filter, bool is_list_only, const std::vector<double>& asymptote)\n {\n     std::regex reFilter(filter);\n     std::smatch baseMatch;\n@@ -52,7 +52,15 @@ void benchmark::BenchRunner::RunAll(const std::string& filter, bool is_list_only\n \n         Bench bench;\n         bench.name(p.first);\n-        p.second(bench);\n+        if (asymptote.empty()) {\n+            p.second(bench);\n+        } else {\n+            for (auto n : asymptote) {\n+                bench.complexityN(n);\n+                p.second(bench);\n+            }\n+            std::cout << bench.complexityBigO() << std::endl;\n+        }\n         benchmarkResults.push_back(bench.results().back());\n         g_testing_setup = nullptr;\n     }"
      },
      {
        "sha": "8f265d7cd89fac3159779102bd6abe6b187bd44c",
        "filename": "src/bench/bench.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c33547849a85158ca59807b00b033fbb2f1cb32/src/bench/bench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c33547849a85158ca59807b00b033fbb2f1cb32/src/bench/bench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench.h?ref=4c33547849a85158ca59807b00b033fbb2f1cb32",
        "patch": "@@ -46,7 +46,7 @@ class BenchRunner\n public:\n     BenchRunner(std::string name, BenchFunction func);\n \n-    static void RunAll(const std::string& filter, bool is_list_only);\n+    static void RunAll(const std::string& filter, bool is_list_only, const std::vector<double>& asymptote);\n };\n }\n // BENCHMARK(foo) expands to:  benchmark::BenchRunner bench_11foo(\"foo\");"
      },
      {
        "sha": "b29d4779d9361ea72b2b9fdf44ecd6028f4056ae",
        "filename": "src/bench/bench_bitcoin.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 2,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c33547849a85158ca59807b00b033fbb2f1cb32/src/bench/bench_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c33547849a85158ca59807b00b033fbb2f1cb32/src/bench/bench_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench_bitcoin.cpp?ref=4c33547849a85158ca59807b00b033fbb2f1cb32",
        "patch": "@@ -17,6 +17,20 @@ static void SetupBenchArgs()\n \n     gArgs.AddArg(\"-list\", \"List benchmarks without executing them. Can be combined with -scaling and -filter\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-filter=<regex>\", strprintf(\"Regular expression filter to select benchmark by name (default: %s)\", DEFAULT_BENCH_FILTER), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-asymptote=n1,n2,n3,...\", strprintf(\"Test asymptotic growth of the runtime of an algorithm, if supported by the benchmark\"), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n+}\n+\n+// parses a comma separated list like \"10,20,30,50\"\n+static std::vector<double> parseAsymptote(const std::string& str) {\n+    std::stringstream ss(str);\n+    std::vector<double> numbers;\n+    double d;\n+    char c;\n+    while (ss >> d) {\n+        numbers.push_back(d);\n+        ss >> c;\n+    }\n+    return numbers;\n }\n \n int main(int argc, char** argv)\n@@ -36,9 +50,9 @@ int main(int argc, char** argv)\n \n     std::string regex_filter = gArgs.GetArg(\"-filter\", DEFAULT_BENCH_FILTER);\n     bool is_list_only = gArgs.GetBoolArg(\"-list\", false);\n+    std::vector<double> asymptote = parseAsymptote(gArgs.GetArg(\"-asymptote\", \"\"));\n \n-\n-    benchmark::BenchRunner::RunAll(regex_filter, is_list_only);\n+    benchmark::BenchRunner::RunAll(regex_filter, is_list_only, asymptote);\n \n     return EXIT_SUCCESS;\n }"
      },
      {
        "sha": "3ce9380c5bc286d7214aed8d3e33fe3f42061f7f",
        "filename": "src/bench/mempool_stress.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c33547849a85158ca59807b00b033fbb2f1cb32/src/bench/mempool_stress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c33547849a85158ca59807b00b033fbb2f1cb32/src/bench/mempool_stress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/mempool_stress.cpp?ref=4c33547849a85158ca59807b00b033fbb2f1cb32",
        "patch": "@@ -27,6 +27,11 @@ struct Available {\n \n static void ComplexMemPool(benchmark::Bench& bench)\n {\n+    int childTxs = 800;\n+    if (bench.complexityN() > 1) {\n+        childTxs = static_cast<int>(bench.complexityN());\n+    }\n+\n     FastRandomContext det_rand{true};\n     std::vector<Available> available_coins;\n     std::vector<CTransactionRef> ordered_coins;\n@@ -45,7 +50,7 @@ static void ComplexMemPool(benchmark::Bench& bench)\n         ordered_coins.emplace_back(MakeTransactionRef(tx));\n         available_coins.emplace_back(ordered_coins.back(), tx_counter++);\n     }\n-    for (auto x = 0; x < 800 && !available_coins.empty(); ++x) {\n+    for (auto x = 0; x < childTxs && !available_coins.empty(); ++x) {\n         CMutableTransaction tx = CMutableTransaction();\n         size_t n_ancestors = det_rand.randrange(10)+1;\n         for (size_t ancestor = 0; ancestor < n_ancestors && !available_coins.empty(); ++ancestor){"
      },
      {
        "sha": "02f1588c675585b7e2c5705b222e1b1d67a66dc3",
        "filename": "src/bench/nanobench.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c33547849a85158ca59807b00b033fbb2f1cb32/src/bench/nanobench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c33547849a85158ca59807b00b033fbb2f1cb32/src/bench/nanobench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/nanobench.h?ref=4c33547849a85158ca59807b00b033fbb2f1cb32",
        "patch": "@@ -1494,6 +1494,10 @@ void IterationLogic::showResult(std::string const& errorMessage) const {\n             columns.emplace_back(11, 1, \"relative\", \"%\", d);\n         }\n \n+        if (mBench.complexityN() > 0) {\n+            columns.emplace_back(14, 0, \"complexityN\", \"\", mBench.complexityN());\n+        }\n+\n         columns.emplace_back(22, 2, \"ns/\" + mBench.unit(), \"\", 1e9 * rMedian / mBench.batch());\n         columns.emplace_back(22, 2, mBench.unit() + \"/s\", \"\", rMedian <= 0.0 ? 0.0 : mBench.batch() / rMedian);\n "
      }
    ]
  },
  {
    "sha": "4f82f05d8075cf242e9798d71cc4dcab21bbd4b4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ZjgyZjA1ZDgwNzVjZjI0MmU5Nzk4ZDcxY2M0ZGNhYjIxYmJkNGI0",
    "commit": {
      "author": {
        "name": "Martin Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2020-03-01T06:43:57Z"
      },
      "committer": {
        "name": "Martin Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2020-03-28T07:31:29Z"
      },
      "message": "Don't using namespace ankerl::nanobench\n\nInstead of `using namespace ankerl::nanobench`, just pull in ankerl::nanobench::Bench. This is the only class needed in the benchmarks anyways.",
      "tree": {
        "sha": "770b09dd78ee26ccda9adecc5530c6b5f3be3154",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/770b09dd78ee26ccda9adecc5530c6b5f3be3154"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4f82f05d8075cf242e9798d71cc4dcab21bbd4b4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4f82f05d8075cf242e9798d71cc4dcab21bbd4b4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4f82f05d8075cf242e9798d71cc4dcab21bbd4b4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4f82f05d8075cf242e9798d71cc4dcab21bbd4b4/comments",
    "author": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4c33547849a85158ca59807b00b033fbb2f1cb32",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4c33547849a85158ca59807b00b033fbb2f1cb32",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4c33547849a85158ca59807b00b033fbb2f1cb32"
      }
    ],
    "stats": {
      "total": 10,
      "additions": 5,
      "deletions": 5
    },
    "files": [
      {
        "sha": "d80e4f4cdc56da88695b2a12de95207fc66edfb9",
        "filename": "src/bench/bench.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4f82f05d8075cf242e9798d71cc4dcab21bbd4b4/src/bench/bench.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4f82f05d8075cf242e9798d71cc4dcab21bbd4b4/src/bench/bench.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench.cpp?ref=4f82f05d8075cf242e9798d71cc4dcab21bbd4b4",
        "patch": "@@ -29,7 +29,7 @@ void benchmark::BenchRunner::RunAll(const std::string& filter, bool is_list_only\n     std::regex reFilter(filter);\n     std::smatch baseMatch;\n \n-    std::vector<Result> benchmarkResults;\n+    std::vector<ankerl::nanobench::Result> benchmarkResults;\n     for (const auto& p : benchmarks()) {\n         if (!std::regex_match(p.first, baseMatch, reFilter)) {\n             continue;\n@@ -69,9 +69,9 @@ void benchmark::BenchRunner::RunAll(const std::string& filter, bool is_list_only\n         // Generate legacy CSV data to \"benchmarkresults.csv\"\n         std::ofstream fout(\"benchmarkresults.csv\");\n         if (fout.is_open()) {\n-            templates::generate(\"# Benchmark, evals, iterations, total, min, max, median\\n\"\n-                                \"{{#result}}{{name}}, {{epochs}}, {{average(iterations)}}, {{sumProduct(iterations, elapsed)}}, {{minimum(elapsed)}}, {{maximum(elapsed)}}, {{median(elapsed)}}\\n\"\n-                                \"{{/result}}\",\n+            ankerl::nanobench::templates::generate(\"# Benchmark, evals, iterations, total, min, max, median\\n\"\n+                                                   \"{{#result}}{{name}}, {{epochs}}, {{average(iterations)}}, {{sumProduct(iterations, elapsed)}}, {{minimum(elapsed)}}, {{maximum(elapsed)}}, {{median(elapsed)}}\\n\"\n+                                                   \"{{/result}}\",\n                 benchmarkResults, fout);\n         }\n     }"
      },
      {
        "sha": "1201512abb10c523216a9c6534f14665f5f7e1cc",
        "filename": "src/bench/bench.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4f82f05d8075cf242e9798d71cc4dcab21bbd4b4/src/bench/bench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4f82f05d8075cf242e9798d71cc4dcab21bbd4b4/src/bench/bench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench.h?ref=4f82f05d8075cf242e9798d71cc4dcab21bbd4b4",
        "patch": "@@ -34,7 +34,7 @@ BENCHMARK(CODE_TO_TIME);\n \n namespace benchmark {\n \n-using namespace ankerl::nanobench;\n+using ankerl::nanobench::Bench;\n \n typedef std::function<void(Bench&)> BenchFunction;\n "
      }
    ]
  },
  {
    "sha": "9eea19f82f783f80f91d938d0878370a77fd2e0c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZWVhMTlmODJmNzgzZjgwZjkxZDkzOGQwODc4MzcwYTc3ZmQyZTBj",
    "commit": {
      "author": {
        "name": "Martin Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2020-03-08T07:05:27Z"
      },
      "committer": {
        "name": "Martin Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2020-03-28T07:31:29Z"
      },
      "message": "Add option -output_csv and -output_json\n\n-output_cvs produces the (legacy) CSV format, and -output_json produces a big JSON file all the data that has been gathered.\n\nPut all args into a separate struct to prevent argument explosion of BenchRunner::RunAll.",
      "tree": {
        "sha": "f50b68d3fbeda6b32b315943bbe6352a2ededb4f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f50b68d3fbeda6b32b315943bbe6352a2ededb4f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9eea19f82f783f80f91d938d0878370a77fd2e0c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9eea19f82f783f80f91d938d0878370a77fd2e0c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9eea19f82f783f80f91d938d0878370a77fd2e0c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9eea19f82f783f80f91d938d0878370a77fd2e0c/comments",
    "author": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4f82f05d8075cf242e9798d71cc4dcab21bbd4b4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4f82f05d8075cf242e9798d71cc4dcab21bbd4b4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4f82f05d8075cf242e9798d71cc4dcab21bbd4b4"
      }
    ],
    "stats": {
      "total": 69,
      "additions": 48,
      "deletions": 21
    },
    "files": [
      {
        "sha": "48a08c014a37b99792fd79aa38c023a107100b86",
        "filename": "src/bench/bench.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 15,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9eea19f82f783f80f91d938d0878370a77fd2e0c/src/bench/bench.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9eea19f82f783f80f91d938d0878370a77fd2e0c/src/bench/bench.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench.cpp?ref=9eea19f82f783f80f91d938d0878370a77fd2e0c",
        "patch": "@@ -13,6 +13,26 @@\n const RegTestingSetup* g_testing_setup = nullptr;\n const std::function<void(const std::string&)> G_TEST_LOG_FUN{};\n \n+namespace {\n+\n+void GenerateTemplateResults(const std::vector<ankerl::nanobench::Result>& benchmarkResults, const std::string& filename, const char* tpl)\n+{\n+    if (benchmarkResults.empty() || filename.empty()) {\n+        // nothing to write, bail out\n+        return;\n+    }\n+    std::ofstream fout(filename);\n+    if (fout.is_open()) {\n+        ankerl::nanobench::templates::generate(tpl, benchmarkResults, fout);\n+    } else {\n+        std::cout << \"Could write to file '\" << filename << \"'\" << std::endl;\n+    }\n+\n+    std::cout << \"Created '\" << filename << \"'\" << std::endl;\n+}\n+\n+} // namespace\n+\n benchmark::BenchRunner::BenchmarkMap& benchmark::BenchRunner::benchmarks()\n {\n     static std::map<std::string, BenchFunction> benchmarks_map;\n@@ -24,9 +44,9 @@ benchmark::BenchRunner::BenchRunner(std::string name, benchmark::BenchFunction f\n     benchmarks().insert(std::make_pair(name, func));\n }\n \n-void benchmark::BenchRunner::RunAll(const std::string& filter, bool is_list_only, const std::vector<double>& asymptote)\n+void benchmark::BenchRunner::RunAll(const Args& args)\n {\n-    std::regex reFilter(filter);\n+    std::regex reFilter(args.regex_filter);\n     std::smatch baseMatch;\n \n     std::vector<ankerl::nanobench::Result> benchmarkResults;\n@@ -35,7 +55,7 @@ void benchmark::BenchRunner::RunAll(const std::string& filter, bool is_list_only\n             continue;\n         }\n \n-        if (is_list_only) {\n+        if (args.is_list_only) {\n             std::cout << p.first << std::endl;\n             continue;\n         }\n@@ -52,10 +72,10 @@ void benchmark::BenchRunner::RunAll(const std::string& filter, bool is_list_only\n \n         Bench bench;\n         bench.name(p.first);\n-        if (asymptote.empty()) {\n+        if (args.asymptote.empty()) {\n             p.second(bench);\n         } else {\n-            for (auto n : asymptote) {\n+            for (auto n : args.asymptote) {\n                 bench.complexityN(n);\n                 p.second(bench);\n             }\n@@ -65,14 +85,8 @@ void benchmark::BenchRunner::RunAll(const std::string& filter, bool is_list_only\n         g_testing_setup = nullptr;\n     }\n \n-    if (!benchmarkResults.empty()) {\n-        // Generate legacy CSV data to \"benchmarkresults.csv\"\n-        std::ofstream fout(\"benchmarkresults.csv\");\n-        if (fout.is_open()) {\n-            ankerl::nanobench::templates::generate(\"# Benchmark, evals, iterations, total, min, max, median\\n\"\n-                                                   \"{{#result}}{{name}}, {{epochs}}, {{average(iterations)}}, {{sumProduct(iterations, elapsed)}}, {{minimum(elapsed)}}, {{maximum(elapsed)}}, {{median(elapsed)}}\\n\"\n-                                                   \"{{/result}}\",\n-                benchmarkResults, fout);\n-        }\n-    }\n+    GenerateTemplateResults(benchmarkResults, args.output_csv, \"# Benchmark, evals, iterations, total, min, max, median\\n\"\n+                                                               \"{{#result}}{{name}}, {{epochs}}, {{average(iterations)}}, {{sumProduct(iterations, elapsed)}}, {{minimum(elapsed)}}, {{maximum(elapsed)}}, {{median(elapsed)}}\\n\"\n+                                                               \"{{/result}}\");\n+    GenerateTemplateResults(benchmarkResults, args.output_json, ankerl::nanobench::templates::json());\n }"
      },
      {
        "sha": "7cf85294c79e319a438653a2dc61ecad02e758b1",
        "filename": "src/bench/bench.h",
        "status": "modified",
        "additions": 9,
        "deletions": 1,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9eea19f82f783f80f91d938d0878370a77fd2e0c/src/bench/bench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9eea19f82f783f80f91d938d0878370a77fd2e0c/src/bench/bench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench.h?ref=9eea19f82f783f80f91d938d0878370a77fd2e0c",
        "patch": "@@ -38,6 +38,14 @@ using ankerl::nanobench::Bench;\n \n typedef std::function<void(Bench&)> BenchFunction;\n \n+struct Args {\n+    std::string regex_filter;\n+    bool is_list_only;\n+    std::vector<double> asymptote;\n+    std::string output_csv;\n+    std::string output_json;\n+};\n+\n class BenchRunner\n {\n     typedef std::map<std::string, BenchFunction> BenchmarkMap;\n@@ -46,7 +54,7 @@ class BenchRunner\n public:\n     BenchRunner(std::string name, BenchFunction func);\n \n-    static void RunAll(const std::string& filter, bool is_list_only, const std::vector<double>& asymptote);\n+    static void RunAll(const Args& args);\n };\n }\n // BENCHMARK(foo) expands to:  benchmark::BenchRunner bench_11foo(\"foo\");"
      },
      {
        "sha": "0866d2493d3e703844381572df40a049474a8eec",
        "filename": "src/bench/bench_bitcoin.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 5,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9eea19f82f783f80f91d938d0878370a77fd2e0c/src/bench/bench_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9eea19f82f783f80f91d938d0878370a77fd2e0c/src/bench/bench_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench_bitcoin.cpp?ref=9eea19f82f783f80f91d938d0878370a77fd2e0c",
        "patch": "@@ -15,9 +15,11 @@ static void SetupBenchArgs()\n {\n     SetupHelpOptions(gArgs);\n \n-    gArgs.AddArg(\"-list\", \"List benchmarks without executing them. Can be combined with -scaling and -filter\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-list\", \"List benchmarks without executing them\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-filter=<regex>\", strprintf(\"Regular expression filter to select benchmark by name (default: %s)\", DEFAULT_BENCH_FILTER), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-asymptote=n1,n2,n3,...\", strprintf(\"Test asymptotic growth of the runtime of an algorithm, if supported by the benchmark\"), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-output_csv=<output.csv>\", \"Generate CSV file with the most important benchmark results.\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-output_json=<output.json>\", \"Generate JSON file with all benchmark results.\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n }\n \n // parses a comma separated list like \"10,20,30,50\"\n@@ -48,11 +50,14 @@ int main(int argc, char** argv)\n         return EXIT_SUCCESS;\n     }\n \n-    std::string regex_filter = gArgs.GetArg(\"-filter\", DEFAULT_BENCH_FILTER);\n-    bool is_list_only = gArgs.GetBoolArg(\"-list\", false);\n-    std::vector<double> asymptote = parseAsymptote(gArgs.GetArg(\"-asymptote\", \"\"));\n+    benchmark::Args args;\n+    args.regex_filter = gArgs.GetArg(\"-filter\", DEFAULT_BENCH_FILTER);\n+    args.is_list_only = gArgs.GetBoolArg(\"-list\", false);\n+    args.asymptote = parseAsymptote(gArgs.GetArg(\"-asymptote\", \"\"));\n+    args.output_csv = gArgs.GetArg(\"-output_csv\", \"\");\n+    args.output_json = gArgs.GetArg(\"-output_json\", \"\");\n \n-    benchmark::BenchRunner::RunAll(regex_filter, is_list_only, asymptote);\n+    benchmark::BenchRunner::RunAll(args);\n \n     return EXIT_SUCCESS;\n }"
      }
    ]
  },
  {
    "sha": "17feb04349dd4f0387e0ee5105cb339b76b74608",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxN2ZlYjA0MzQ5ZGQ0ZjAzODdlMGVlNTEwNWNiMzM5Yjc2Yjc0NjA4",
    "commit": {
      "author": {
        "name": "Martin Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2020-03-08T07:24:43Z"
      },
      "committer": {
        "name": "Martin Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2020-03-28T07:31:29Z"
      },
      "message": "comment nits",
      "tree": {
        "sha": "8f542296e3e73d79e5578f3f12548e7ade2dbadc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8f542296e3e73d79e5578f3f12548e7ade2dbadc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/17feb04349dd4f0387e0ee5105cb339b76b74608",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/17feb04349dd4f0387e0ee5105cb339b76b74608",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/17feb04349dd4f0387e0ee5105cb339b76b74608",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/17feb04349dd4f0387e0ee5105cb339b76b74608/comments",
    "author": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9eea19f82f783f80f91d938d0878370a77fd2e0c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9eea19f82f783f80f91d938d0878370a77fd2e0c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9eea19f82f783f80f91d938d0878370a77fd2e0c"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 2,
      "deletions": 2
    },
    "files": [
      {
        "sha": "9947e04b2c5b7a45ff543a089502bf1477cbd424",
        "filename": "src/bench/nanobench.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/17feb04349dd4f0387e0ee5105cb339b76b74608/src/bench/nanobench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/17feb04349dd4f0387e0ee5105cb339b76b74608/src/bench/nanobench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/nanobench.h?ref=17feb04349dd4f0387e0ee5105cb339b76b74608",
        "patch": "@@ -660,7 +660,7 @@ void doNotOptimizeAway(T const& val) {\n namespace ankerl {\n namespace nanobench {\n \n-// helper stuff that only intended to be used internally\n+// helper stuff that is only intended to be used internally\n namespace detail {\n \n struct TableInfo;\n@@ -1188,7 +1188,7 @@ PerformanceCounters& performanceCounters() {\n     return pc;\n }\n \n-// Windows version of do not optimize away\n+// Windows version of doNotOptimizeAway\n // see https://github.com/google/benchmark/blob/master/include/benchmark/benchmark.h#L307\n // see https://github.com/facebook/folly/blob/master/folly/Benchmark.h#L280\n // see https://docs.microsoft.com/en-us/cpp/preprocessor/optimize"
      }
    ]
  },
  {
    "sha": "a841d1e25b1b26b6381f36e14307c2549a79edb4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphODQxZDFlMjViMWIyNmI2MzgxZjM2ZTE0MzA3YzI1NDlhNzllZGI0",
    "commit": {
      "author": {
        "name": "Martin Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2020-03-08T15:20:55Z"
      },
      "committer": {
        "name": "Martin Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2020-03-28T07:31:29Z"
      },
      "message": "remove unnecessary include util/time.h",
      "tree": {
        "sha": "d0b4bca97d09fd758652e45bcd52fe6f531046aa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d0b4bca97d09fd758652e45bcd52fe6f531046aa"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a841d1e25b1b26b6381f36e14307c2549a79edb4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a841d1e25b1b26b6381f36e14307c2549a79edb4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a841d1e25b1b26b6381f36e14307c2549a79edb4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a841d1e25b1b26b6381f36e14307c2549a79edb4/comments",
    "author": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "17feb04349dd4f0387e0ee5105cb339b76b74608",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/17feb04349dd4f0387e0ee5105cb339b76b74608",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/17feb04349dd4f0387e0ee5105cb339b76b74608"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 0,
      "deletions": 1
    },
    "files": [
      {
        "sha": "35a838903813fae24cad2e3b2ceaa18b4d1948c4",
        "filename": "src/bench/examples.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a841d1e25b1b26b6381f36e14307c2549a79edb4/src/bench/examples.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a841d1e25b1b26b6381f36e14307c2549a79edb4/src/bench/examples.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/examples.cpp?ref=a841d1e25b1b26b6381f36e14307c2549a79edb4",
        "patch": "@@ -3,7 +3,6 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <bench/bench.h>\n-#include <util/time.h>\n \n // Extremely fast-running benchmark:\n #include <math.h>"
      }
    ]
  },
  {
    "sha": "cf2eb9040f63099924c6fc9071997f725bde6545",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjZjJlYjkwNDBmNjMwOTk5MjRjNmZjOTA3MTk5N2Y3MjViZGU2NTQ1",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2020-03-14T21:07:05Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2020-03-28T16:43:42Z"
      },
      "message": "Revert \"Implement O(1) OP_IF/NOTIF/ELSE/ENDIF logic\"\n\nThis reverts commit e6e622e5a0e22c2ac1b50b96af818e412d67ac54.",
      "tree": {
        "sha": "e12ccd820d51a12478be8f3213a27f4ef80d90dd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e12ccd820d51a12478be8f3213a27f4ef80d90dd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cf2eb9040f63099924c6fc9071997f725bde6545",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cf2eb9040f63099924c6fc9071997f725bde6545",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cf2eb9040f63099924c6fc9071997f725bde6545",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cf2eb9040f63099924c6fc9071997f725bde6545/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a841d1e25b1b26b6381f36e14307c2549a79edb4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a841d1e25b1b26b6381f36e14307c2549a79edb4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a841d1e25b1b26b6381f36e14307c2549a79edb4"
      }
    ],
    "stats": {
      "total": 52,
      "additions": 6,
      "deletions": 46
    },
    "files": [
      {
        "sha": "d25dfc75ae06da27cca75bbd840dbe6cd42adf28",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 46,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cf2eb9040f63099924c6fc9071997f725bde6545/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cf2eb9040f63099924c6fc9071997f725bde6545/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=cf2eb9040f63099924c6fc9071997f725bde6545",
        "patch": "@@ -289,56 +289,16 @@ namespace {\n  * expose whether the stack is empty and whether or not any false values are\n  * present at all. To implement OP_ELSE, a toggle_top modifier is added, which\n  * flips the last value without returning it.\n- *\n- * This uses an optimized implementation that does not materialize the\n- * actual stack. Instead, it just stores the size of the would-be stack,\n- * and the position of the first false value in it.\n  */\n class ConditionStack {\n private:\n-    //! A constant for m_first_false_pos to indicate there are no falses.\n-    static constexpr uint32_t NO_FALSE = std::numeric_limits<uint32_t>::max();\n-\n-    //! The size of the implied stack.\n-    uint32_t m_stack_size = 0;\n-    //! The position of the first false value on the implied stack, or NO_FALSE if all true.\n-    uint32_t m_first_false_pos = NO_FALSE;\n-\n+    std::vector<bool> m_flags;\n public:\n-    bool empty() { return m_stack_size == 0; }\n-    bool all_true() { return m_first_false_pos == NO_FALSE; }\n-    void push_back(bool f)\n-    {\n-        if (m_first_false_pos == NO_FALSE && !f) {\n-            // The stack consists of all true values, and a false is added.\n-            // The first false value will appear at the current size.\n-            m_first_false_pos = m_stack_size;\n-        }\n-        ++m_stack_size;\n-    }\n-    void pop_back()\n-    {\n-        assert(m_stack_size > 0);\n-        --m_stack_size;\n-        if (m_first_false_pos == m_stack_size) {\n-            // When popping off the first false value, everything becomes true.\n-            m_first_false_pos = NO_FALSE;\n-        }\n-    }\n-    void toggle_top()\n-    {\n-        assert(m_stack_size > 0);\n-        if (m_first_false_pos == NO_FALSE) {\n-            // The current stack is all true values; the first false will be the top.\n-            m_first_false_pos = m_stack_size - 1;\n-        } else if (m_first_false_pos == m_stack_size - 1) {\n-            // The top is the first false value; toggling it will make everything true.\n-            m_first_false_pos = NO_FALSE;\n-        } else {\n-            // There is a false value, but not on top. No action is needed as toggling\n-            // anything but the first false value is unobservable.\n-        }\n-    }\n+    bool empty() { return m_flags.empty(); }\n+    bool all_true() { return !std::count(m_flags.begin(), m_flags.end(), false); }\n+    void push_back(bool f) { m_flags.push_back(f); }\n+    void pop_back() { m_flags.pop_back(); }\n+    void toggle_top() { m_flags.back() = !m_flags.back(); }\n };\n }\n "
      }
    ]
  },
  {
    "sha": "991966fa9b0d0e7dc1dd5d565fd027b822abc547",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5OTE5NjZmYTliMGQwZTdkYzFkZDVkNTY1ZmQwMjdiODIyYWJjNTQ3",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2020-03-14T21:07:09Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2020-03-28T16:43:42Z"
      },
      "message": "Revert \"[refactor] interpreter: define interface for vfExec\"\n\nThis reverts commit d0e8f4d5d8ddaccb37f98b7989fb944081e41ab8.",
      "tree": {
        "sha": "088d06a20cff0fc741f57888ae7b998687ee91d1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/088d06a20cff0fc741f57888ae7b998687ee91d1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/991966fa9b0d0e7dc1dd5d565fd027b822abc547",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/991966fa9b0d0e7dc1dd5d565fd027b822abc547",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/991966fa9b0d0e7dc1dd5d565fd027b822abc547",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/991966fa9b0d0e7dc1dd5d565fd027b822abc547/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cf2eb9040f63099924c6fc9071997f725bde6545",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cf2eb9040f63099924c6fc9071997f725bde6545",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cf2eb9040f63099924c6fc9071997f725bde6545"
      }
    ],
    "stats": {
      "total": 30,
      "additions": 3,
      "deletions": 27
    },
    "files": [
      {
        "sha": "5aa94d9ac6405fa828b5c3de309dbb967c9eeb79",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 27,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/991966fa9b0d0e7dc1dd5d565fd027b822abc547/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/991966fa9b0d0e7dc1dd5d565fd027b822abc547/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=991966fa9b0d0e7dc1dd5d565fd027b822abc547",
        "patch": "@@ -278,30 +278,6 @@ int FindAndDelete(CScript& script, const CScript& b)\n     return nFound;\n }\n \n-namespace {\n-/** A data type to abstract out the condition stack during script execution.\n- *\n- * Conceptually it acts like a vector of booleans, one for each level of nested\n- * IF/THEN/ELSE, indicating whether we're in the active or inactive branch of\n- * each.\n- *\n- * The elements on the stack cannot be observed individually; we only need to\n- * expose whether the stack is empty and whether or not any false values are\n- * present at all. To implement OP_ELSE, a toggle_top modifier is added, which\n- * flips the last value without returning it.\n- */\n-class ConditionStack {\n-private:\n-    std::vector<bool> m_flags;\n-public:\n-    bool empty() { return m_flags.empty(); }\n-    bool all_true() { return !std::count(m_flags.begin(), m_flags.end(), false); }\n-    void push_back(bool f) { m_flags.push_back(f); }\n-    void pop_back() { m_flags.pop_back(); }\n-    void toggle_top() { m_flags.back() = !m_flags.back(); }\n-};\n-}\n-\n bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)\n {\n     static const CScriptNum bnZero(0);\n@@ -317,7 +293,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n     CScript::const_iterator pbegincodehash = script.begin();\n     opcodetype opcode;\n     valtype vchPushValue;\n-    ConditionStack vfExec;\n+    std::vector<bool> vfExec;\n     std::vector<valtype> altstack;\n     set_error(serror, SCRIPT_ERR_UNKNOWN_ERROR);\n     if (script.size() > MAX_SCRIPT_SIZE)\n@@ -329,7 +305,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n     {\n         while (pc < pend)\n         {\n-            bool fExec = vfExec.all_true();\n+            bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n \n             //\n             // Read instruction\n@@ -518,7 +494,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                 {\n                     if (vfExec.empty())\n                         return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);\n-                    vfExec.toggle_top();\n+                    vfExec.back() = !vfExec.back();\n                 }\n                 break;\n "
      }
    ]
  }
]