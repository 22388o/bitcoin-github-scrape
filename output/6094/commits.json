[
  {
    "sha": "ef3281750d9698ed58e07e72232d1604652f5fff",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplZjMyODE3NTBkOTY5OGVkNThlMDdlNzIyMzJkMTYwNDY1MmY1ZmZm",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-04-30T20:40:22Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-04-30T20:40:22Z"
      },
      "message": "Fix mininode disconnections to work with select",
      "tree": {
        "sha": "87d64a474f2e2015b8e9004b34575cbd8724963d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/87d64a474f2e2015b8e9004b34575cbd8724963d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ef3281750d9698ed58e07e72232d1604652f5fff",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ef3281750d9698ed58e07e72232d1604652f5fff",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ef3281750d9698ed58e07e72232d1604652f5fff",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ef3281750d9698ed58e07e72232d1604652f5fff/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f026ab606d7bc317a725888296921df961d26208",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f026ab606d7bc317a725888296921df961d26208",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f026ab606d7bc317a725888296921df961d26208"
      }
    ],
    "stats": {
      "total": 31,
      "additions": 20,
      "deletions": 11
    },
    "files": [
      {
        "sha": "d1a57b54fa3d10817fdc1fbe247eb6d3528d94aa",
        "filename": "qa/rpc-tests/mininode.py",
        "status": "modified",
        "additions": 20,
        "deletions": 11,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ef3281750d9698ed58e07e72232d1604652f5fff/qa/rpc-tests/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ef3281750d9698ed58e07e72232d1604652f5fff/qa/rpc-tests/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/mininode.py?ref=ef3281750d9698ed58e07e72232d1604652f5fff",
        "patch": "@@ -37,6 +37,11 @@\n \n MAX_INV_SZ = 50000\n \n+# Keep our own socket map for asyncore, so that we can track disconnects\n+# ourselves (to workaround an issue with closing an asyncore socket when \n+# using select)\n+mininode_socket_map = dict()\n+\n # Serialization/deserialization tools\n def sha256(s):\n     return hashlib.new('sha256', s).digest()\n@@ -1076,7 +1081,7 @@ class NodeConn(asyncore.dispatcher):\n     }\n \n     def __init__(self, dstaddr, dstport, rpc, callback, net=\"regtest\"):\n-        asyncore.dispatcher.__init__(self)\n+        asyncore.dispatcher.__init__(self, map=mininode_socket_map)\n         self.log = logging.getLogger(\"NodeConn(%s:%d)\" % (dstaddr, dstport))\n         self.dstaddr = dstaddr\n         self.dstport = dstport\n@@ -1140,14 +1145,10 @@ def readable(self):\n         return True\n \n     def writable(self):\n-        if self.disconnect:\n-            self.handle_close()\n-            return False\n-        else:\n-            self.sendbufLock.acquire()\n-            length = len(self.sendbuf)\n-            self.sendbufLock.release()\n-            return (length > 0)\n+        self.sendbufLock.acquire()\n+        length = len(self.sendbuf)\n+        self.sendbufLock.release()\n+        return (length > 0)\n \n     def handle_write(self):\n         self.sendbufLock.acquire()\n@@ -1229,12 +1230,20 @@ def got_message(self, message):\n \n     def disconnect_node(self):\n         self.disconnect = True\n-        self.send_message(self.messagemap['ping']())\n \n \n class NetworkThread(Thread):\n     def run(self):\n-        asyncore.loop(0.1, True)\n+        while mininode_socket_map:\n+            # We check for whether to disconnect outside of the asyncore\n+            # loop to workaround the behavior of asyncore when using\n+            # select\n+            disconnected = []\n+            for fd, obj in mininode_socket_map.items():\n+                if obj.disconnect:\n+                    disconnected.append(obj)\n+            [ obj.handle_close() for obj in disconnected ]\n+            asyncore.loop(0.1, use_poll=True, map=mininode_socket_map, count=1)\n \n \n # An exception we can raise if we detect a potential disconnect"
      }
    ]
  },
  {
    "sha": "5487975ca3e26e959a815679ba326fb33d6baf8d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1NDg3OTc1Y2EzZTI2ZTk1OWE4MTU2NzliYTMyNmZiMzNkNmJhZjhk",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-04-30T20:40:36Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-04-30T20:40:36Z"
      },
      "message": "Don't run invalidblockrequest.py in travis until race condition is fixed",
      "tree": {
        "sha": "f741dc7606b49ca676ce628e34f8e6f865af0bc4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f741dc7606b49ca676ce628e34f8e6f865af0bc4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5487975ca3e26e959a815679ba326fb33d6baf8d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5487975ca3e26e959a815679ba326fb33d6baf8d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5487975ca3e26e959a815679ba326fb33d6baf8d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5487975ca3e26e959a815679ba326fb33d6baf8d/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ef3281750d9698ed58e07e72232d1604652f5fff",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ef3281750d9698ed58e07e72232d1604652f5fff",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ef3281750d9698ed58e07e72232d1604652f5fff"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "840addb251f27385a1dd51e3816f539494206132",
        "filename": "qa/pull-tester/rpc-tests.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5487975ca3e26e959a815679ba326fb33d6baf8d/qa/pull-tester/rpc-tests.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5487975ca3e26e959a815679ba326fb33d6baf8d/qa/pull-tester/rpc-tests.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.sh?ref=5487975ca3e26e959a815679ba326fb33d6baf8d",
        "patch": "@@ -31,7 +31,7 @@ testScripts=(\n     'merkle_blocks.py'\n #    'forknotify.py'\n     'maxblocksinflight.py'\n-    'invalidblockrequest.py'\n+#    'invalidblockrequest.py'\n );\n if [ \"x${ENABLE_BITCOIND}${ENABLE_UTILS}${ENABLE_WALLET}\" = \"x111\" ]; then\n     for (( i = 0; i < ${#testScripts[@]}; i++ ))"
      }
    ]
  },
  {
    "sha": "574db4816fd340b57970760ec30f4c8d6234187f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1NzRkYjQ4MTZmZDM0MGI1Nzk3MDc2MGVjMzBmNGM4ZDYyMzQxODdm",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-05-01T18:47:21Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-05-01T19:32:24Z"
      },
      "message": "Fix potential race conditions in p2p testing framework\n\nPreviously, each NodeConnCB had its own lock to synchronize data structures\nused by the testing thread and the networking thread, and NodeConn provided a\nseparate additional lock for synchronizing access to each send buffer.  This\ncommit replaces those locks with a single global lock (mininode_lock) that we\nuse to synchronize access to all data structures shared by the two threads.\n\nUpdates comptool and maxblocksinflight to use the new synchronization\nsemantics, eliminating previous race conditions within comptool, and re-enables\ninvalidblockrequest.py in travis.",
      "tree": {
        "sha": "205d7b6e4e39471b581e7e3f6533699a8d5c0c45",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/205d7b6e4e39471b581e7e3f6533699a8d5c0c45"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/574db4816fd340b57970760ec30f4c8d6234187f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/574db4816fd340b57970760ec30f4c8d6234187f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/574db4816fd340b57970760ec30f4c8d6234187f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/574db4816fd340b57970760ec30f4c8d6234187f/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5487975ca3e26e959a815679ba326fb33d6baf8d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5487975ca3e26e959a815679ba326fb33d6baf8d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5487975ca3e26e959a815679ba326fb33d6baf8d"
      }
    ],
    "stats": {
      "total": 138,
      "additions": 75,
      "deletions": 63
    },
    "files": [
      {
        "sha": "ae27a94b8dbe83989ecfa49e2f1e965434c49826",
        "filename": "qa/pull-tester/rpc-tests.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/574db4816fd340b57970760ec30f4c8d6234187f/qa/pull-tester/rpc-tests.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/574db4816fd340b57970760ec30f4c8d6234187f/qa/pull-tester/rpc-tests.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.sh?ref=574db4816fd340b57970760ec30f4c8d6234187f",
        "patch": "@@ -31,7 +31,7 @@ testScripts=(\n     'merkle_blocks.py'\n #    'forknotify.py'\n     'maxblocksinflight.py'\n-#    'invalidblockrequest.py'\n+    'invalidblockrequest.py'\n );\n if [ \"x${ENABLE_BITCOIND}${ENABLE_UTILS}${ENABLE_WALLET}\" = \"x111\" ]; then\n     for (( i = 0; i < ${#testScripts[@]}; i++ ))"
      },
      {
        "sha": "25cffe461f0c07cd136a73027f1d6dc5e222c058",
        "filename": "qa/rpc-tests/comptool.py",
        "status": "modified",
        "additions": 47,
        "deletions": 36,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/574db4816fd340b57970760ec30f4c8d6234187f/qa/rpc-tests/comptool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/574db4816fd340b57970760ec30f4c8d6234187f/qa/rpc-tests/comptool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/comptool.py?ref=574db4816fd340b57970760ec30f4c8d6234187f",
        "patch": "@@ -25,6 +25,8 @@\n # on_getheaders: provide headers via BlockStore\n # on_getdata: provide blocks via BlockStore\n \n+global mininode_lock\n+\n class TestNode(NodeConnCB):\n \n     def __init__(self, block_store, tx_store):\n@@ -148,10 +150,11 @@ def wait_for_verack(self):\n         max_tries = 10 / sleep_time  # Wait at most 10 seconds\n         while max_tries > 0:\n             done = True\n-            for c in self.connections:\n-                if c.cb.verack_received is False:\n-                    done = False\n-                    break\n+            with mininode_lock:\n+                for c in self.connections:\n+                    if c.cb.verack_received is False:\n+                        done = False\n+                        break\n             if done:\n                 break\n             time.sleep(sleep_time)\n@@ -161,10 +164,11 @@ def wait_for_pings(self, counter):\n         while received_pongs is not True:\n             time.sleep(0.05)\n             received_pongs = True\n-            for c in self.connections:\n-                if c.cb.received_ping_response(counter) is not True:\n-                    received_pongs = False\n-                    break\n+            with mininode_lock:\n+                for c in self.connections:\n+                    if c.cb.received_ping_response(counter) is not True:\n+                        received_pongs = False\n+                        break\n \n     # sync_blocks: Wait for all connections to request the blockhash given\n     # then send get_headers to find out the tip of each node, and synchronize\n@@ -173,8 +177,9 @@ def sync_blocks(self, blockhash, num_blocks):\n         # Wait for nodes to request block (50ms sleep * 20 tries * num_blocks)\n         max_tries = 20*num_blocks\n         while max_tries > 0:\n-            results = [ blockhash in c.cb.block_request_map and\n-                        c.cb.block_request_map[blockhash] for c in self.connections ]\n+            with mininode_lock:\n+                results = [ blockhash in c.cb.block_request_map and\n+                            c.cb.block_request_map[blockhash] for c in self.connections ]\n             if False not in results:\n                 break\n             time.sleep(0.05)\n@@ -199,8 +204,9 @@ def sync_transaction(self, txhash, num_events):\n         # Wait for nodes to request transaction (50ms sleep * 20 tries * num_events)\n         max_tries = 20*num_events\n         while max_tries > 0:\n-            results = [ txhash in c.cb.tx_request_map and\n-                        c.cb.tx_request_map[txhash] for c in self.connections ]\n+            with mininode_lock:\n+                results = [ txhash in c.cb.tx_request_map and\n+                            c.cb.tx_request_map[txhash] for c in self.connections ]\n             if False not in results:\n                 break\n             time.sleep(0.05)\n@@ -221,19 +227,21 @@ def sync_transaction(self, txhash, num_events):\n         self.ping_counter += 1\n \n         # Sort inv responses from each node\n-        [ c.cb.lastInv.sort() for c in self.connections ]\n+        with mininode_lock:\n+            [ c.cb.lastInv.sort() for c in self.connections ]\n \n     # Verify that the tip of each connection all agree with each other, and\n     # with the expected outcome (if given)\n     def check_results(self, blockhash, outcome):\n-        for c in self.connections:\n-            if outcome is None:\n-                if c.cb.bestblockhash != self.connections[0].cb.bestblockhash:\n+        with mininode_lock:\n+            for c in self.connections:\n+                if outcome is None:\n+                    if c.cb.bestblockhash != self.connections[0].cb.bestblockhash:\n+                        return False\n+                elif ((c.cb.bestblockhash == blockhash) != outcome):\n+                    # print c.cb.bestblockhash, blockhash, outcome\n                     return False\n-            elif ((c.cb.bestblockhash == blockhash) != outcome):\n-                # print c.cb.bestblockhash, blockhash, outcome\n-                return False\n-        return True\n+            return True\n \n     # Either check that the mempools all agree with each other, or that\n     # txhash's presence in the mempool matches the outcome specified.\n@@ -242,16 +250,17 @@ def check_results(self, blockhash, outcome):\n     # perhaps it would be useful to add the ability to check explicitly that\n     # a particular tx's existence in the mempool is the same across all nodes.\n     def check_mempool(self, txhash, outcome):\n-        for c in self.connections:\n-            if outcome is None:\n-                # Make sure the mempools agree with each other\n-                if c.cb.lastInv != self.connections[0].cb.lastInv:\n-                    # print c.rpc.getrawmempool()\n+        with mininode_lock:\n+            for c in self.connections:\n+                if outcome is None:\n+                    # Make sure the mempools agree with each other\n+                    if c.cb.lastInv != self.connections[0].cb.lastInv:\n+                        # print c.rpc.getrawmempool()\n+                        return False\n+                elif ((txhash in c.cb.lastInv) != outcome):\n+                    # print c.rpc.getrawmempool(), c.cb.lastInv\n                     return False\n-            elif ((txhash in c.cb.lastInv) != outcome):\n-                # print c.rpc.getrawmempool(), c.cb.lastInv\n-                return False\n-        return True\n+            return True\n \n     def run(self):\n         # Wait until verack is received\n@@ -272,9 +281,10 @@ def run(self):\n                     block = b_or_t\n                     block_outcome = outcome\n                     # Add to shared block_store, set as current block\n-                    self.block_store.add_block(block)\n-                    for c in self.connections:\n-                        c.cb.block_request_map[block.sha256] = False\n+                    with mininode_lock:\n+                        self.block_store.add_block(block)\n+                        for c in self.connections:\n+                            c.cb.block_request_map[block.sha256] = False\n                     # Either send inv's to each node and sync, or add\n                     # to invqueue for later inv'ing.\n                     if (test_instance.sync_every_block):\n@@ -288,10 +298,11 @@ def run(self):\n                     assert(isinstance(b_or_t, CTransaction))\n                     tx = b_or_t\n                     tx_outcome = outcome\n-                    # Add to shared tx store\n-                    self.tx_store.add_transaction(tx)\n-                    for c in self.connections:\n-                        c.cb.tx_request_map[tx.sha256] = False\n+                    # Add to shared tx store and clear map entry\n+                    with mininode_lock:\n+                        self.tx_store.add_transaction(tx)\n+                        for c in self.connections:\n+                            c.cb.tx_request_map[tx.sha256] = False\n                     # Again, either inv to all nodes or save for later\n                     if (test_instance.sync_every_tx):\n                         [ c.cb.send_inv(tx) for c in self.connections ]"
      },
      {
        "sha": "87c80cd97ec99e96579ce94ff951335395e464cf",
        "filename": "qa/rpc-tests/maxblocksinflight.py",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/574db4816fd340b57970760ec30f4c8d6234187f/qa/rpc-tests/maxblocksinflight.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/574db4816fd340b57970760ec30f4c8d6234187f/qa/rpc-tests/maxblocksinflight.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/maxblocksinflight.py?ref=574db4816fd340b57970760ec30f4c8d6234187f",
        "patch": "@@ -61,10 +61,11 @@ def run(self):\n                 time.sleep(2)\n \n                 total_requests = 0\n-                for key in self.blockReqCounts:\n-                    total_requests += self.blockReqCounts[key]\n-                    if self.blockReqCounts[key] > 1:\n-                        raise AssertionError(\"Error, test failed: block %064x requested more than once\" % key)\n+                with mininode_lock:\n+                    for key in self.blockReqCounts:\n+                        total_requests += self.blockReqCounts[key]\n+                        if self.blockReqCounts[key] > 1:\n+                            raise AssertionError(\"Error, test failed: block %064x requested more than once\" % key)\n                 if total_requests > MAX_REQUESTS:\n                     raise AssertionError(\"Error, too many blocks (%d) requested\" % total_requests)\n                 print \"Round %d: success (total requests: %d)\" % (count, total_requests)"
      },
      {
        "sha": "b7d78e74fa83d0b003d96a4f77421c8d13db1cba",
        "filename": "qa/rpc-tests/mininode.py",
        "status": "modified",
        "additions": 22,
        "deletions": 22,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/574db4816fd340b57970760ec30f4c8d6234187f/qa/rpc-tests/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/574db4816fd340b57970760ec30f4c8d6234187f/qa/rpc-tests/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/mininode.py?ref=574db4816fd340b57970760ec30f4c8d6234187f",
        "patch": "@@ -26,7 +26,7 @@\n import random\n import cStringIO\n import hashlib\n-from threading import Lock\n+from threading import RLock\n from threading import Thread\n import logging\n import copy\n@@ -42,6 +42,14 @@\n # using select)\n mininode_socket_map = dict()\n \n+# One lock for synchronizing all data access between the networking thread (see\n+# NetworkThread below) and the thread running the test logic.  For simplicity,\n+# NodeConn acquires this lock whenever delivering a message to to a NodeConnCB,\n+# and whenever adding anything to the send buffer (in send_message()).  This\n+# lock should be acquired in the thread running the test logic to synchronize\n+# access to any data shared with the NodeConnCB or NodeConn.\n+mininode_lock = RLock()\n+\n # Serialization/deserialization tools\n def sha256(s):\n     return hashlib.new('sha256', s).digest()\n@@ -980,10 +988,6 @@ def __repr__(self):\n # Reimplement the on_* functions to provide handling for events\n class NodeConnCB(object):\n     def __init__(self):\n-        # Acquire on all callbacks -- overkill for now since asyncore is\n-        # single-threaded, but may be useful for synchronizing access to\n-        # member variables in derived classes.\n-        self.cbLock = Lock()\n         self.verack_received = False\n \n     # Derived classes should call this function once to set the message map\n@@ -1009,7 +1013,7 @@ def create_callback_map(self):\n         }\n \n     def deliver(self, conn, message):\n-        with self.cbLock:\n+        with mininode_lock:\n             try:\n                 self.cbmap[message.command](conn, message)\n             except:\n@@ -1094,7 +1098,6 @@ def __init__(self, dstaddr, dstport, rpc, callback, net=\"regtest\"):\n         self.state = \"connecting\"\n         self.network = net\n         self.cb = callback\n-        self.sendbufLock = Lock()  # for protecting the sendbuffer\n         self.disconnect = False\n \n         # stuff version msg into sendbuf\n@@ -1145,20 +1148,18 @@ def readable(self):\n         return True\n \n     def writable(self):\n-        self.sendbufLock.acquire()\n-        length = len(self.sendbuf)\n-        self.sendbufLock.release()\n+        with mininode_lock:\n+            length = len(self.sendbuf)\n         return (length > 0)\n \n     def handle_write(self):\n-        self.sendbufLock.acquire()\n-        try:\n-            sent = self.send(self.sendbuf)\n-        except:\n-            self.handle_close()\n-            return\n-        self.sendbuf = self.sendbuf[sent:]\n-        self.sendbufLock.release()\n+        with mininode_lock:\n+            try:\n+                sent = self.send(self.sendbuf)\n+            except:\n+                self.handle_close()\n+                return\n+            self.sendbuf = self.sendbuf[sent:]\n \n     def got_data(self):\n         while True:\n@@ -1202,7 +1203,6 @@ def got_data(self):\n     def send_message(self, message, pushbuf=False):\n         if self.state != \"connected\" and not pushbuf:\n             return\n-        self.sendbufLock.acquire()\n         self.show_debug_msg(\"Send %s\" % repr(message))\n         command = message.command\n         data = message.serialize()\n@@ -1215,9 +1215,9 @@ def send_message(self, message, pushbuf=False):\n             h = sha256(th)\n             tmsg += h[:4]\n         tmsg += data\n-        self.sendbuf += tmsg\n-        self.last_sent = time.time()\n-        self.sendbufLock.release()\n+        with mininode_lock:\n+            self.sendbuf += tmsg\n+            self.last_sent = time.time()\n \n     def got_message(self, message):\n         if message.command == \"version\":"
      }
    ]
  },
  {
    "sha": "2a22d4be9b27c63afa7f1a425227e6637cda8750",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyYTIyZDRiZTliMjdjNjNhZmE3ZjFhNDI1MjI3ZTY2MzdjZGE4NzUw",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-05-01T18:47:44Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-05-01T19:32:24Z"
      },
      "message": "Fix comptool send_message call when MAX_INV_SZ reached",
      "tree": {
        "sha": "2b5936ca3d90d1d4a60a6815051374eaf2500f81",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2b5936ca3d90d1d4a60a6815051374eaf2500f81"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2a22d4be9b27c63afa7f1a425227e6637cda8750",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2a22d4be9b27c63afa7f1a425227e6637cda8750",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2a22d4be9b27c63afa7f1a425227e6637cda8750",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2a22d4be9b27c63afa7f1a425227e6637cda8750/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "574db4816fd340b57970760ec30f4c8d6234187f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/574db4816fd340b57970760ec30f4c8d6234187f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/574db4816fd340b57970760ec30f4c8d6234187f"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "23a979250cf17dfbbb28005cf8dd0dc36544c65f",
        "filename": "qa/rpc-tests/comptool.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a22d4be9b27c63afa7f1a425227e6637cda8750/qa/rpc-tests/comptool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a22d4be9b27c63afa7f1a425227e6637cda8750/qa/rpc-tests/comptool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/comptool.py?ref=2a22d4be9b27c63afa7f1a425227e6637cda8750",
        "patch": "@@ -313,7 +313,7 @@ def run(self):\n                         invqueue.append(CInv(1, tx.sha256))\n                 # Ensure we're not overflowing the inv queue\n                 if len(invqueue) == MAX_INV_SZ:\n-                    [ c.sb.send_message(msg_inv(invqueue)) for c in self.connections ]\n+                    [ c.send_message(msg_inv(invqueue)) for c in self.connections ]\n                     invqueue = []\n \n             # Do final sync if we weren't syncing on every block or every tx."
      }
    ]
  }
]