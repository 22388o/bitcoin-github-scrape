[
  {
    "sha": "0221b2cb47c902400ae3e4bbef3149b3d186b669",
    "node_id": "C_kwDOABII59oAKDAyMjFiMmNiNDdjOTAyNDAwYWUzZTRiYmVmMzE0OWIzZDE4NmI2Njk",
    "commit": {
      "author": {
        "name": "sstone",
        "email": "fabrice.drouin@acinq.fr",
        "date": "2021-11-29T14:48:36Z"
      },
      "committer": {
        "name": "sstone",
        "email": "fabrice.drouin@acinq.fr",
        "date": "2021-11-29T19:59:31Z"
      },
      "message": "Check descriptors returned by external signers\n\nCheck that descriptors returned by external signers have been parsed properly when creating a new wallet.",
      "tree": {
        "sha": "2c898ee93217b48b33b6fa6c273f288b851fd769",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2c898ee93217b48b33b6fa6c273f288b851fd769"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0221b2cb47c902400ae3e4bbef3149b3d186b669",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0221b2cb47c902400ae3e4bbef3149b3d186b669",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0221b2cb47c902400ae3e4bbef3149b3d186b669",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0221b2cb47c902400ae3e4bbef3149b3d186b669/comments",
    "author": {
      "login": "sstone",
      "id": 1573866,
      "node_id": "MDQ6VXNlcjE1NzM4NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1573866?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sstone",
      "html_url": "https://github.com/sstone",
      "followers_url": "https://api.github.com/users/sstone/followers",
      "following_url": "https://api.github.com/users/sstone/following{/other_user}",
      "gists_url": "https://api.github.com/users/sstone/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sstone/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sstone/subscriptions",
      "organizations_url": "https://api.github.com/users/sstone/orgs",
      "repos_url": "https://api.github.com/users/sstone/repos",
      "events_url": "https://api.github.com/users/sstone/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sstone/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sstone",
      "id": 1573866,
      "node_id": "MDQ6VXNlcjE1NzM4NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1573866?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sstone",
      "html_url": "https://github.com/sstone",
      "followers_url": "https://api.github.com/users/sstone/followers",
      "following_url": "https://api.github.com/users/sstone/following{/other_user}",
      "gists_url": "https://api.github.com/users/sstone/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sstone/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sstone/subscriptions",
      "organizations_url": "https://api.github.com/users/sstone/orgs",
      "repos_url": "https://api.github.com/users/sstone/repos",
      "events_url": "https://api.github.com/users/sstone/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sstone/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b4f647fa36a3336774ab616048bc6709bdc59fa1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4f647fa36a3336774ab616048bc6709bdc59fa1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b4f647fa36a3336774ab616048bc6709bdc59fa1"
      }
    ],
    "stats": {
      "total": 310,
      "additions": 196,
      "deletions": 114
    },
    "files": [
      {
        "sha": "2d9d1d7bea4471eae0633bd37ec5993de50576f2",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0221b2cb47c902400ae3e4bbef3149b3d186b669/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0221b2cb47c902400ae3e4bbef3149b3d186b669/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=0221b2cb47c902400ae3e4bbef3149b3d186b669",
        "patch": "@@ -3205,6 +3205,9 @@ void CWallet::SetupDescriptorScriptPubKeyMans()\n                 FlatSigningProvider keys;\n                 std::string dummy_error;\n                 std::unique_ptr<Descriptor> desc = Parse(desc_str, keys, dummy_error, false);\n+                if (desc == NULL) {\n+                    throw std::runtime_error(std::string(__func__) + \": Invalid descriptor\");\n+                }\n                 if (!desc->GetOutputType()) {\n                     continue;\n                 }"
      },
      {
        "sha": "e30cc9e20b053f566b895ff872b350044025a100",
        "filename": "test/functional/mocks/invalid_signer.py",
        "status": "added",
        "additions": 65,
        "deletions": 0,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0221b2cb47c902400ae3e4bbef3149b3d186b669/test/functional/mocks/invalid_signer.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0221b2cb47c902400ae3e4bbef3149b3d186b669/test/functional/mocks/invalid_signer.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mocks/invalid_signer.py?ref=0221b2cb47c902400ae3e4bbef3149b3d186b669",
        "patch": "@@ -0,0 +1,65 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2018-2021 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+import sys\n+import argparse\n+import json\n+\n+def perform_pre_checks():\n+    mock_result_path = os.path.join(os.getcwd(), \"mock_result\")\n+    if(os.path.isfile(mock_result_path)):\n+        with open(mock_result_path, \"r\", encoding=\"utf8\") as f:\n+            mock_result = f.read()\n+        if mock_result[0]:\n+            sys.stdout.write(mock_result[2:])\n+            sys.exit(int(mock_result[0]))\n+\n+def enumerate(args):\n+    sys.stdout.write(json.dumps([{\"fingerprint\": \"b3c19bfc\", \"type\": \"trezor\", \"model\": \"trezor_t\"}, {\"fingerprint\": \"00000002\"}]))\n+\n+def getdescriptors(args):\n+    xpub_pkh = \"xpub6CRhJvXV8x2AKWvqi1ZSMFU6cbxzQiYrv3dxSUXCawjMJ1JzpqVsveH4way1yCmJm29KzH1zrVZmVwes4Qo6oXVE1HFn4fdiKrYJngqFFc6\"\n+    xpub_sh = \"xpub6CoNoq3Tg4tGSpom2BSwL42gy864KHo3TXkHxLxBbhvCkgmdVXADQmiHbLZhX3Me1cYhRx7s25Lpm4LnT5zu395ANHsXB2QvT9tqJDAibTN\"\n+    xpub_wpkh = \"xpub6DUcLgY1DfgDy2RV6q4djwwsLitaoZDumbribqrR8mP78fEtgZa1XEsqT5MWQ7gwLwKsTQPT28XLoVE5A97rDNTwMXjmzPaNijoCApCbWvp\"\n+\n+    sys.stdout.write(json.dumps({\n+        \"receive\": [\n+            \"pkh([b3c19bfc/44'/1'/\" + args.account + \"']\" + xpub_pkh + \"/0/*)#h26nxtl9\",\n+            \"sh(wpkh([b3c19bfc/49'/1'/\" + args.account + \"']\" + xpub_sh + \"/0/*))#32ry02yp\",\n+            \"wpkh([b3c19bfc/84'/1'/\" + args.account + \"']\" + xpub_wpkh + \"/0/*)#jftn8ppv\"\n+        ],\n+        \"internal\": [\n+            \"pkh([b3c19bfc/44'/1'/\" + args.account + \"']\" + xpub_pkh + \"/1/*)#x7ljm70a\",\n+            \"sh(wpkh([b3c19bfc/49'/1'/\" + args.account + \"']\" + xpub_sh + \"/1/*))#ytdjh437\",\n+            \"wpkh([b3c19bfc/84'/1'/\" + args.account + \"']\" + xpub_wpkh + \"/1/*)#rawj6535\"\n+        ]\n+    }))\n+\n+parser = argparse.ArgumentParser(prog='./invalid_signer.py', description='External invalid signer mock')\n+parser.add_argument('--fingerprint')\n+parser.add_argument('--chain', default='main')\n+parser.add_argument('--stdin', action='store_true')\n+\n+subparsers = parser.add_subparsers(description='Commands', dest='command')\n+subparsers.required = True\n+\n+parser_enumerate = subparsers.add_parser('enumerate', help='list available signers')\n+parser_enumerate.set_defaults(func=enumerate)\n+\n+parser_getdescriptors = subparsers.add_parser('getdescriptors')\n+parser_getdescriptors.set_defaults(func=getdescriptors)\n+parser_getdescriptors.add_argument('--account', metavar='account')\n+\n+if not sys.stdin.isatty():\n+    buffer = sys.stdin.read()\n+    if buffer and buffer.rstrip() != \"\":\n+        sys.argv.extend(buffer.rstrip().split(\" \"))\n+\n+args = parser.parse_args()\n+\n+perform_pre_checks()\n+\n+args.func(args)"
      },
      {
        "sha": "5dabab932f57212ec0ebdcbde7f3780a8897af85",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0221b2cb47c902400ae3e4bbef3149b3d186b669/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0221b2cb47c902400ae3e4bbef3149b3d186b669/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=0221b2cb47c902400ae3e4bbef3149b3d186b669",
        "patch": "@@ -115,6 +115,7 @@\n     'feature_taproot.py',\n     'rpc_signer.py',\n     'wallet_signer.py --descriptors',\n+    'wallet_signer.py --descriptors --invalid',\n     # vv Tests less than 60s vv\n     'p2p_sendheaders.py',\n     'wallet_importmulti.py --legacy-wallet',"
      },
      {
        "sha": "67218145e07e58fa078cefe0be659d5a93ba1626",
        "filename": "test/functional/wallet_signer.py",
        "status": "modified",
        "additions": 127,
        "deletions": 114,
        "changes": 241,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0221b2cb47c902400ae3e4bbef3149b3d186b669/test/functional/wallet_signer.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0221b2cb47c902400ae3e4bbef3149b3d186b669/test/functional/wallet_signer.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_signer.py?ref=0221b2cb47c902400ae3e4bbef3149b3d186b669",
        "patch": "@@ -15,11 +15,16 @@\n     assert_equal,\n     assert_raises_rpc_error,\n )\n+from test_framework.authproxy import JSONRPCException\n \n \n class WalletSignerTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        parser.add_argument(\"--invalid\", dest=\"invalid\", default=False, action=\"store_true\",\n+                            help=\"Test invalid external signer\")\n+\n     def mock_signer_path(self):\n-        path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'mocks', 'signer.py')\n+        path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'mocks', 'invalid_signer.py' if self.options.invalid else 'signer.py')\n         if platform.system() == \"Windows\":\n             return \"py \" + path\n         else:\n@@ -58,8 +63,15 @@ def run_test(self):\n         else:\n             assert_raises_rpc_error(-4, \"Compiled without bdb support (required for legacy wallets)\", self.nodes[1].createwallet, wallet_name='not_hww', disable_private_keys=True, descriptors=False, external_signer=True)\n \n-        self.nodes[1].createwallet(wallet_name='hww', disable_private_keys=True, descriptors=True, external_signer=True)\n-        hww = self.nodes[1].get_wallet_rpc('hww')\n+        if self.options.invalid:\n+            self.log.info('Test invalid external signer')\n+            try:\n+                self.nodes[1].createwallet(wallet_name='hww', disable_private_keys=True, descriptors=True, external_signer=True)\n+            except JSONRPCException:\n+                pass\n+        else:\n+            self.nodes[1].createwallet(wallet_name='hww', disable_private_keys=True, descriptors=True, external_signer=True)\n+            hww = self.nodes[1].get_wallet_rpc('hww')\n \n         # Flag can't be set afterwards (could be added later for non-blank descriptor based watch-only wallets)\n         self.nodes[1].createwallet(wallet_name='not_hww', disable_private_keys=True, descriptors=True, external_signer=False)\n@@ -75,117 +87,118 @@ def run_test(self):\n         # )\n         # self.clear_mock_result(self.nodes[1])\n \n-        assert_equal(hww.getwalletinfo()[\"keypoolsize\"], 30)\n-\n-        address1 = hww.getnewaddress(address_type=\"bech32\")\n-        assert_equal(address1, \"bcrt1qm90ugl4d48jv8n6e5t9ln6t9zlpm5th68x4f8g\")\n-        address_info = hww.getaddressinfo(address1)\n-        assert_equal(address_info['solvable'], True)\n-        assert_equal(address_info['ismine'], True)\n-        assert_equal(address_info['hdkeypath'], \"m/84'/1'/0'/0/0\")\n-\n-        address2 = hww.getnewaddress(address_type=\"p2sh-segwit\")\n-        assert_equal(address2, \"2N2gQKzjUe47gM8p1JZxaAkTcoHPXV6YyVp\")\n-        address_info = hww.getaddressinfo(address2)\n-        assert_equal(address_info['solvable'], True)\n-        assert_equal(address_info['ismine'], True)\n-        assert_equal(address_info['hdkeypath'], \"m/49'/1'/0'/0/0\")\n-\n-        address3 = hww.getnewaddress(address_type=\"legacy\")\n-        assert_equal(address3, \"n1LKejAadN6hg2FrBXoU1KrwX4uK16mco9\")\n-        address_info = hww.getaddressinfo(address3)\n-        assert_equal(address_info['solvable'], True)\n-        assert_equal(address_info['ismine'], True)\n-        assert_equal(address_info['hdkeypath'], \"m/44'/1'/0'/0/0\")\n-\n-        self.log.info('Test walletdisplayaddress')\n-        result = hww.walletdisplayaddress(address1)\n-        assert_equal(result, {\"address\": address1})\n-\n-        # Handle error thrown by script\n-        self.set_mock_result(self.nodes[1], \"2\")\n-        assert_raises_rpc_error(-1, 'RunCommandParseJSON error',\n-            hww.walletdisplayaddress, address1\n-        )\n-        self.clear_mock_result(self.nodes[1])\n-\n-        self.log.info('Prepare mock PSBT')\n-        self.nodes[0].sendtoaddress(address1, 1)\n-        self.generate(self.nodes[0], 1)\n-\n-        # Load private key into wallet to generate a signed PSBT for the mock\n-        self.nodes[1].createwallet(wallet_name=\"mock\", disable_private_keys=False, blank=True, descriptors=True)\n-        mock_wallet = self.nodes[1].get_wallet_rpc(\"mock\")\n-        assert mock_wallet.getwalletinfo()['private_keys_enabled']\n-\n-        result = mock_wallet.importdescriptors([{\n-            \"desc\": \"wpkh([00000001/84'/1'/0']tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/0/*)#rweraev0\",\n-            \"timestamp\": 0,\n-            \"range\": [0,1],\n-            \"internal\": False,\n-            \"active\": True\n-        },\n-        {\n-            \"desc\": \"wpkh([00000001/84'/1'/0']tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/*)#j6uzqvuh\",\n-            \"timestamp\": 0,\n-            \"range\": [0, 0],\n-            \"internal\": True,\n-            \"active\": True\n-        }])\n-        assert_equal(result[0], {'success': True})\n-        assert_equal(result[1], {'success': True})\n-        assert_equal(mock_wallet.getwalletinfo()[\"txcount\"], 1)\n-        dest = self.nodes[0].getnewaddress(address_type='bech32')\n-        mock_psbt = mock_wallet.walletcreatefundedpsbt([], {dest:0.5}, 0, {}, True)['psbt']\n-        mock_psbt_signed = mock_wallet.walletprocesspsbt(psbt=mock_psbt, sign=True, sighashtype=\"ALL\", bip32derivs=True)\n-        mock_psbt_final = mock_wallet.finalizepsbt(mock_psbt_signed[\"psbt\"])\n-        mock_tx = mock_psbt_final[\"hex\"]\n-        assert(mock_wallet.testmempoolaccept([mock_tx])[0][\"allowed\"])\n-\n-        # # Create a new wallet and populate with specific public keys, in order\n-        # # to work with the mock signed PSBT.\n-        # self.nodes[1].createwallet(wallet_name=\"hww4\", disable_private_keys=True, descriptors=True, external_signer=True)\n-        # hww4 = self.nodes[1].get_wallet_rpc(\"hww4\")\n-        #\n-        # descriptors = [{\n-        #     \"desc\": \"wpkh([00000001/84'/1'/0']tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/0/*)#x30uthjs\",\n-        #     \"timestamp\": \"now\",\n-        #     \"range\": [0, 1],\n-        #     \"internal\": False,\n-        #     \"watchonly\": True,\n-        #     \"active\": True\n-        # },\n-        # {\n-        #     \"desc\": \"wpkh([00000001/84'/1'/0']tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/*)#h92akzzg\",\n-        #     \"timestamp\": \"now\",\n-        #     \"range\": [0, 0],\n-        #     \"internal\": True,\n-        #     \"watchonly\": True,\n-        #     \"active\": True\n-        # }]\n-\n-        # result = hww4.importdescriptors(descriptors)\n-        # assert_equal(result[0], {'success': True})\n-        # assert_equal(result[1], {'success': True})\n-        assert_equal(hww.getwalletinfo()[\"txcount\"], 1)\n-\n-        assert(hww.testmempoolaccept([mock_tx])[0][\"allowed\"])\n-\n-        with open(os.path.join(self.nodes[1].cwd, \"mock_psbt\"), \"w\", encoding=\"utf8\") as f:\n-            f.write(mock_psbt_signed[\"psbt\"])\n-\n-        self.log.info('Test send using hww1')\n-\n-        res = hww.send(outputs={dest:0.5},options={\"add_to_wallet\": False})\n-        assert(res[\"complete\"])\n-        assert_equal(res[\"hex\"], mock_tx)\n-\n-        # # Handle error thrown by script\n-        # self.set_mock_result(self.nodes[4], \"2\")\n-        # assert_raises_rpc_error(-1, 'Unable to parse JSON',\n-        #     hww4.signerprocesspsbt, psbt_orig, \"00000001\"\n-        # )\n-        # self.clear_mock_result(self.nodes[4])\n+        if not self.options.invalid:\n+            assert_equal(hww.getwalletinfo()[\"keypoolsize\"], 30)\n+\n+            address1 = hww.getnewaddress(address_type=\"bech32\")\n+            assert_equal(address1, \"bcrt1qm90ugl4d48jv8n6e5t9ln6t9zlpm5th68x4f8g\")\n+            address_info = hww.getaddressinfo(address1)\n+            assert_equal(address_info['solvable'], True)\n+            assert_equal(address_info['ismine'], True)\n+            assert_equal(address_info['hdkeypath'], \"m/84'/1'/0'/0/0\")\n+\n+            address2 = hww.getnewaddress(address_type=\"p2sh-segwit\")\n+            assert_equal(address2, \"2N2gQKzjUe47gM8p1JZxaAkTcoHPXV6YyVp\")\n+            address_info = hww.getaddressinfo(address2)\n+            assert_equal(address_info['solvable'], True)\n+            assert_equal(address_info['ismine'], True)\n+            assert_equal(address_info['hdkeypath'], \"m/49'/1'/0'/0/0\")\n+\n+            address3 = hww.getnewaddress(address_type=\"legacy\")\n+            assert_equal(address3, \"n1LKejAadN6hg2FrBXoU1KrwX4uK16mco9\")\n+            address_info = hww.getaddressinfo(address3)\n+            assert_equal(address_info['solvable'], True)\n+            assert_equal(address_info['ismine'], True)\n+            assert_equal(address_info['hdkeypath'], \"m/44'/1'/0'/0/0\")\n+\n+            self.log.info('Test walletdisplayaddress')\n+            result = hww.walletdisplayaddress(address1)\n+            assert_equal(result, {\"address\": address1})\n+\n+            # Handle error thrown by script\n+            self.set_mock_result(self.nodes[1], \"2\")\n+            assert_raises_rpc_error(-1, 'RunCommandParseJSON error',\n+                hww.walletdisplayaddress, address1\n+            )\n+            self.clear_mock_result(self.nodes[1])\n+\n+            self.log.info('Prepare mock PSBT')\n+            self.nodes[0].sendtoaddress(address1, 1)\n+            self.generate(self.nodes[0], 1)\n+\n+            # Load private key into wallet to generate a signed PSBT for the mock\n+            self.nodes[1].createwallet(wallet_name=\"mock\", disable_private_keys=False, blank=True, descriptors=True)\n+            mock_wallet = self.nodes[1].get_wallet_rpc(\"mock\")\n+            assert mock_wallet.getwalletinfo()['private_keys_enabled']\n+\n+            result = mock_wallet.importdescriptors([{\n+                \"desc\": \"wpkh([00000001/84'/1'/0']tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/0/*)#rweraev0\",\n+                \"timestamp\": 0,\n+                \"range\": [0,1],\n+                \"internal\": False,\n+                \"active\": True\n+            },\n+            {\n+                \"desc\": \"wpkh([00000001/84'/1'/0']tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/*)#j6uzqvuh\",\n+                \"timestamp\": 0,\n+                \"range\": [0, 0],\n+                \"internal\": True,\n+                \"active\": True\n+            }])\n+            assert_equal(result[0], {'success': True})\n+            assert_equal(result[1], {'success': True})\n+            assert_equal(mock_wallet.getwalletinfo()[\"txcount\"], 1)\n+            dest = self.nodes[0].getnewaddress(address_type='bech32')\n+            mock_psbt = mock_wallet.walletcreatefundedpsbt([], {dest:0.5}, 0, {}, True)['psbt']\n+            mock_psbt_signed = mock_wallet.walletprocesspsbt(psbt=mock_psbt, sign=True, sighashtype=\"ALL\", bip32derivs=True)\n+            mock_psbt_final = mock_wallet.finalizepsbt(mock_psbt_signed[\"psbt\"])\n+            mock_tx = mock_psbt_final[\"hex\"]\n+            assert(mock_wallet.testmempoolaccept([mock_tx])[0][\"allowed\"])\n+\n+            # # Create a new wallet and populate with specific public keys, in order\n+            # # to work with the mock signed PSBT.\n+            # self.nodes[1].createwallet(wallet_name=\"hww4\", disable_private_keys=True, descriptors=True, external_signer=True)\n+            # hww4 = self.nodes[1].get_wallet_rpc(\"hww4\")\n+            #\n+            # descriptors = [{\n+            #     \"desc\": \"wpkh([00000001/84'/1'/0']tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/0/*)#x30uthjs\",\n+            #     \"timestamp\": \"now\",\n+            #     \"range\": [0, 1],\n+            #     \"internal\": False,\n+            #     \"watchonly\": True,\n+            #     \"active\": True\n+            # },\n+            # {\n+            #     \"desc\": \"wpkh([00000001/84'/1'/0']tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/*)#h92akzzg\",\n+            #     \"timestamp\": \"now\",\n+            #     \"range\": [0, 0],\n+            #     \"internal\": True,\n+            #     \"watchonly\": True,\n+            #     \"active\": True\n+            # }]\n+\n+            # result = hww4.importdescriptors(descriptors)\n+            # assert_equal(result[0], {'success': True})\n+            # assert_equal(result[1], {'success': True})\n+            assert_equal(hww.getwalletinfo()[\"txcount\"], 1)\n+\n+            assert(hww.testmempoolaccept([mock_tx])[0][\"allowed\"])\n+\n+            with open(os.path.join(self.nodes[1].cwd, \"mock_psbt\"), \"w\", encoding=\"utf8\") as f:\n+                f.write(mock_psbt_signed[\"psbt\"])\n+\n+            self.log.info('Test send using hww1')\n+\n+            res = hww.send(outputs={dest:0.5},options={\"add_to_wallet\": False})\n+            assert(res[\"complete\"])\n+            assert_equal(res[\"hex\"], mock_tx)\n+\n+            # # Handle error thrown by script\n+            # self.set_mock_result(self.nodes[4], \"2\")\n+            # assert_raises_rpc_error(-1, 'Unable to parse JSON',\n+            #     hww4.signerprocesspsbt, psbt_orig, \"00000001\"\n+            # )\n+            # self.clear_mock_result(self.nodes[4])\n \n if __name__ == '__main__':\n     WalletSignerTest().main()"
      }
    ]
  }
]