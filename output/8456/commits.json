[
  {
    "sha": "766e8a40b478353a89622f42809ddb11e695a0c9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3NjZlOGE0MGI0NzgzNTNhODk2MjJmNDI4MDlkZGIxMWU2OTVhMGM5",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2016-12-09T20:31:06Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2017-01-10T13:14:50Z"
      },
      "message": "[wallet] Add IsAllFromMe: true if all inputs are from wallet",
      "tree": {
        "sha": "9684f52d1c11174b940e36e3f0ea5c209ef2d367",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9684f52d1c11174b940e36e3f0ea5c209ef2d367"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/766e8a40b478353a89622f42809ddb11e695a0c9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/766e8a40b478353a89622f42809ddb11e695a0c9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/766e8a40b478353a89622f42809ddb11e695a0c9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/766e8a40b478353a89622f42809ddb11e695a0c9/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5754e0341b7c033d4caf99534aca47e9981bd7ed",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5754e0341b7c033d4caf99534aca47e9981bd7ed",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5754e0341b7c033d4caf99534aca47e9981bd7ed"
      }
    ],
    "stats": {
      "total": 29,
      "additions": 29,
      "deletions": 0
    },
    "files": [
      {
        "sha": "be5d692c927e113d04430f52396ef296889df723",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/766e8a40b478353a89622f42809ddb11e695a0c9/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/766e8a40b478353a89622f42809ddb11e695a0c9/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=766e8a40b478353a89622f42809ddb11e695a0c9",
        "patch": "@@ -1154,6 +1154,8 @@ isminetype CWallet::IsMine(const CTxIn &txin) const\n     return ISMINE_NO;\n }\n \n+// Note that this function doesn't distinguish between a 0-valued input,\n+// and a not-\"is mine\" (according to the filter) input.\n CAmount CWallet::GetDebit(const CTxIn &txin, const isminefilter& filter) const\n {\n     {\n@@ -1236,6 +1238,27 @@ CAmount CWallet::GetDebit(const CTransaction& tx, const isminefilter& filter) co\n     return nDebit;\n }\n \n+bool CWallet::IsAllFromMe(const CTransaction& tx, const isminefilter& filter) const\n+{\n+    LOCK(cs_wallet);\n+\n+    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+    {\n+        auto mi = mapWallet.find(txin.prevout.hash);\n+        if (mi == mapWallet.end())\n+            return false; // any unknown inputs can't be from us\n+\n+        const CWalletTx& prev = (*mi).second;\n+\n+        if (txin.prevout.n >= prev.tx->vout.size())\n+            return false; // invalid input!\n+\n+        if (!(IsMine(prev.tx->vout[txin.prevout.n]) & filter))\n+            return false;\n+    }\n+    return true;\n+}\n+\n CAmount CWallet::GetCredit(const CTransaction& tx, const isminefilter& filter) const\n {\n     CAmount nCredit = 0;"
      },
      {
        "sha": "8a587f4ed0453384d399d0a2d239038cc3023b66",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/766e8a40b478353a89622f42809ddb11e695a0c9/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/766e8a40b478353a89622f42809ddb11e695a0c9/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=766e8a40b478353a89622f42809ddb11e695a0c9",
        "patch": "@@ -825,6 +825,10 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     std::set<CTxDestination> GetAccountAddresses(const std::string& strAccount) const;\n \n     isminetype IsMine(const CTxIn& txin) const;\n+    /**\n+     * Returns amount of debit if the input matches the\n+     * filter, otherwise returns 0\n+     */\n     CAmount GetDebit(const CTxIn& txin, const isminefilter& filter) const;\n     isminetype IsMine(const CTxOut& txout) const;\n     CAmount GetCredit(const CTxOut& txout, const isminefilter& filter) const;\n@@ -834,6 +838,8 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     /** should probably be renamed to IsRelevantToMe */\n     bool IsFromMe(const CTransaction& tx) const;\n     CAmount GetDebit(const CTransaction& tx, const isminefilter& filter) const;\n+    /** Returns whether all of the inputs match the filter */\n+    bool IsAllFromMe(const CTransaction& tx, const isminefilter& filter) const;\n     CAmount GetCredit(const CTransaction& tx, const isminefilter& filter) const;\n     CAmount GetChange(const CTransaction& tx) const;\n     void SetBestChain(const CBlockLocator& loc);"
      }
    ]
  },
  {
    "sha": "52dde66770d833ee5e42e7c5fee610453ae3852a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1MmRkZTY2NzcwZDgzM2VlNWU0MmU3YzVmZWU2MTA0NTNhZTM4NTJh",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2017-01-17T15:40:41Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2017-01-19T16:29:29Z"
      },
      "message": "[wallet] Add include_unsafe argument to listunspent RPC",
      "tree": {
        "sha": "1cb223500d2737ffe81a3578df430e27ffaca8e7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1cb223500d2737ffe81a3578df430e27ffaca8e7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/52dde66770d833ee5e42e7c5fee610453ae3852a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/52dde66770d833ee5e42e7c5fee610453ae3852a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/52dde66770d833ee5e42e7c5fee610453ae3852a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/52dde66770d833ee5e42e7c5fee610453ae3852a/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "766e8a40b478353a89622f42809ddb11e695a0c9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/766e8a40b478353a89622f42809ddb11e695a0c9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/766e8a40b478353a89622f42809ddb11e695a0c9"
      }
    ],
    "stats": {
      "total": 50,
      "additions": 36,
      "deletions": 14
    },
    "files": [
      {
        "sha": "283d458c8df90e486332a2b77fa7db759280aa9f",
        "filename": "src/rpc/server.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 5,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52dde66770d833ee5e42e7c5fee610453ae3852a/src/rpc/server.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52dde66770d833ee5e42e7c5fee610453ae3852a/src/rpc/server.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.cpp?ref=52dde66770d833ee5e42e7c5fee610453ae3852a",
        "patch": "@@ -79,16 +79,20 @@ void RPCTypeCheck(const UniValue& params,\n             break;\n \n         const UniValue& v = params[i];\n-        if (!((v.type() == t) || (fAllowNull && (v.isNull()))))\n-        {\n-            string err = strprintf(\"Expected type %s, got %s\",\n-                                   uvTypeName(t), uvTypeName(v.type()));\n-            throw JSONRPCError(RPC_TYPE_ERROR, err);\n+        if (!(fAllowNull && v.isNull())) {\n+            RPCTypeCheckArgument(v, t);\n         }\n         i++;\n     }\n }\n \n+void RPCTypeCheckArgument(const UniValue& value, UniValue::VType typeExpected)\n+{\n+    if (value.type() != typeExpected) {\n+        throw JSONRPCError(RPC_TYPE_ERROR, strprintf(\"Expected type %s, got %s\", uvTypeName(typeExpected), uvTypeName(value.type())));\n+    }\n+}\n+\n void RPCTypeCheckObj(const UniValue& o,\n     const map<string, UniValueType>& typesExpected,\n     bool fAllowNull,"
      },
      {
        "sha": "52f82866dc0c25967ac6039af62056847d355897",
        "filename": "src/rpc/server.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52dde66770d833ee5e42e7c5fee610453ae3852a/src/rpc/server.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52dde66770d833ee5e42e7c5fee610453ae3852a/src/rpc/server.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.h?ref=52dde66770d833ee5e42e7c5fee610453ae3852a",
        "patch": "@@ -78,6 +78,11 @@ bool RPCIsInWarmup(std::string *statusOut);\n void RPCTypeCheck(const UniValue& params,\n                   const std::list<UniValue::VType>& typesExpected, bool fAllowNull=false);\n \n+/**\n+ * Type-check one argument; throws JSONRPCError if wrong type given.\n+ */\n+void RPCTypeCheckArgument(const UniValue& value, UniValue::VType typeExpected);\n+\n /*\n   Check for expected keys/value types in an Object.\n */"
      },
      {
        "sha": "ffe0827befc2dfe24aa372c7983148f17f84c703",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 9,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/52dde66770d833ee5e42e7c5fee610453ae3852a/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/52dde66770d833ee5e42e7c5fee610453ae3852a/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=52dde66770d833ee5e42e7c5fee610453ae3852a",
        "patch": "@@ -2350,9 +2350,9 @@ UniValue listunspent(const JSONRPCRequest& request)\n     if (!EnsureWalletIsAvailable(request.fHelp))\n         return NullUniValue;\n \n-    if (request.fHelp || request.params.size() > 3)\n+    if (request.fHelp || request.params.size() > 4)\n         throw runtime_error(\n-            \"listunspent ( minconf maxconf  [\\\"addresses\\\",...] )\\n\"\n+            \"listunspent ( minconf maxconf  [\\\"addresses\\\",...] [include_unsafe] )\\n\"\n             \"\\nReturns array of unspent transaction outputs\\n\"\n             \"with between minconf and maxconf (inclusive) confirmations.\\n\"\n             \"Optionally filter to only include txouts paid to specified addresses.\\n\"\n@@ -2364,6 +2364,10 @@ UniValue listunspent(const JSONRPCRequest& request)\n             \"      \\\"address\\\"   (string) bitcoin address\\n\"\n             \"      ,...\\n\"\n             \"    ]\\n\"\n+            \"4. include_unsafe (bool, optional, default=true) Include outputs that are not safe to spend\\n\"\n+            \"                  because they come from unconfirmed untrusted transactions or unconfirmed\\n\"\n+            \"                  replacement transactions (cases where we are less sure that a conflicting\\n\"\n+            \"                  transaction won't be mined).\\n\"\n             \"\\nResult\\n\"\n             \"[                   (array of json object)\\n\"\n             \"  {\\n\"\n@@ -2387,18 +2391,21 @@ UniValue listunspent(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"listunspent\", \"6, 9999999 \\\"[\\\\\\\"1PGFqEzfmQch1gKD3ra4k18PNj3tTUUSqg\\\\\\\",\\\\\\\"1LtvqCaApEdUGFkpKMM4MstjcaL4dKg8SP\\\\\\\"]\\\"\")\n         );\n \n-    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VNUM)(UniValue::VNUM)(UniValue::VARR));\n-\n     int nMinDepth = 1;\n-    if (request.params.size() > 0)\n+    if (request.params.size() > 0 && !request.params[0].isNull()) {\n+        RPCTypeCheckArgument(request.params[0], UniValue::VNUM);\n         nMinDepth = request.params[0].get_int();\n+    }\n \n     int nMaxDepth = 9999999;\n-    if (request.params.size() > 1)\n+    if (request.params.size() > 1 && !request.params[1].isNull()) {\n+        RPCTypeCheckArgument(request.params[1], UniValue::VNUM);\n         nMaxDepth = request.params[1].get_int();\n+    }\n \n     set<CBitcoinAddress> setAddress;\n-    if (request.params.size() > 2) {\n+    if (request.params.size() > 2 && !request.params[2].isNull()) {\n+        RPCTypeCheckArgument(request.params[2], UniValue::VARR);\n         UniValue inputs = request.params[2].get_array();\n         for (unsigned int idx = 0; idx < inputs.size(); idx++) {\n             const UniValue& input = inputs[idx];\n@@ -2411,11 +2418,17 @@ UniValue listunspent(const JSONRPCRequest& request)\n         }\n     }\n \n+    bool include_unsafe = true;\n+    if (request.params.size() > 3 && !request.params[3].isNull()) {\n+        RPCTypeCheckArgument(request.params[3], UniValue::VBOOL);\n+        include_unsafe = request.params[3].get_bool();\n+    }\n+\n     UniValue results(UniValue::VARR);\n     vector<COutput> vecOutputs;\n     assert(pwalletMain != NULL);\n     LOCK2(cs_main, pwalletMain->cs_wallet);\n-    pwalletMain->AvailableCoins(vecOutputs, false, NULL, true);\n+    pwalletMain->AvailableCoins(vecOutputs, !include_unsafe, NULL, true);\n     BOOST_FOREACH(const COutput& out, vecOutputs) {\n         if (out.nDepth < nMinDepth || out.nDepth > nMaxDepth)\n             continue;\n@@ -2629,7 +2642,7 @@ static const CRPCCommand commands[] =\n     { \"wallet\",             \"listreceivedbyaddress\",    &listreceivedbyaddress,    false,  {\"minconf\",\"include_empty\",\"include_watchonly\"} },\n     { \"wallet\",             \"listsinceblock\",           &listsinceblock,           false,  {\"blockhash\",\"target_confirmations\",\"include_watchonly\"} },\n     { \"wallet\",             \"listtransactions\",         &listtransactions,         false,  {\"account\",\"count\",\"skip\",\"include_watchonly\"} },\n-    { \"wallet\",             \"listunspent\",              &listunspent,              false,  {\"minconf\",\"maxconf\",\"addresses\"} },\n+    { \"wallet\",             \"listunspent\",              &listunspent,              false,  {\"minconf\",\"maxconf\",\"addresses\",\"include_unsafe\"} },\n     { \"wallet\",             \"lockunspent\",              &lockunspent,              true,   {\"unlock\",\"transactions\"} },\n     { \"wallet\",             \"move\",                     &movecmd,                  false,  {\"fromaccount\",\"toaccount\",\"amount\",\"minconf\",\"comment\"} },\n     { \"wallet\",             \"sendfrom\",                 &sendfrom,                 false,  {\"fromaccount\",\"toaddress\",\"amount\",\"minconf\",\"comment\",\"comment_to\"} },"
      }
    ]
  },
  {
    "sha": "cc0243ad32cee1cc9faab317364b889beaf07647",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjYzAyNDNhZDMyY2VlMWNjOWZhYWIzMTczNjRiODg5YmVhZjA3NjQ3",
    "commit": {
      "author": {
        "name": "mrbandrews",
        "email": "bandrewsny@gmail.com",
        "date": "2016-12-09T18:45:27Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2017-01-19T16:29:29Z"
      },
      "message": "[RPC] bumpfee\n\nThis command allows a user to increase the fee on a wallet transaction T, creating a \"bumper\" transaction B.\nT must signal that it is BIP-125 replaceable.\nT's change output is decremented to pay the additional fee.  (B will not add inputs to T.)\nT cannot have any descendant transactions.\nOnce B bumps T, neither T nor B's outputs can be spent until either T or (more likely) B is mined.\n\nIncludes code by @jonasschnelli and @ryanofsky",
      "tree": {
        "sha": "4b2bf04e18d2900823c5c9d1d779410eb08d8f0b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4b2bf04e18d2900823c5c9d1d779410eb08d8f0b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cc0243ad32cee1cc9faab317364b889beaf07647",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cc0243ad32cee1cc9faab317364b889beaf07647",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cc0243ad32cee1cc9faab317364b889beaf07647",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cc0243ad32cee1cc9faab317364b889beaf07647/comments",
    "author": {
      "login": "mrbandrews",
      "id": 7504522,
      "node_id": "MDQ6VXNlcjc1MDQ1MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7504522?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mrbandrews",
      "html_url": "https://github.com/mrbandrews",
      "followers_url": "https://api.github.com/users/mrbandrews/followers",
      "following_url": "https://api.github.com/users/mrbandrews/following{/other_user}",
      "gists_url": "https://api.github.com/users/mrbandrews/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mrbandrews/subscriptions",
      "organizations_url": "https://api.github.com/users/mrbandrews/orgs",
      "repos_url": "https://api.github.com/users/mrbandrews/repos",
      "events_url": "https://api.github.com/users/mrbandrews/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mrbandrews/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "52dde66770d833ee5e42e7c5fee610453ae3852a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/52dde66770d833ee5e42e7c5fee610453ae3852a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/52dde66770d833ee5e42e7c5fee610453ae3852a"
      }
    ],
    "stats": {
      "total": 650,
      "additions": 650,
      "deletions": 0
    },
    "files": [
      {
        "sha": "c87d3c71278cd39b9f8cb8e292d3d9f9f52ed164",
        "filename": "qa/pull-tester/rpc-tests.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cc0243ad32cee1cc9faab317364b889beaf07647/qa/pull-tester/rpc-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cc0243ad32cee1cc9faab317364b889beaf07647/qa/pull-tester/rpc-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.py?ref=cc0243ad32cee1cc9faab317364b889beaf07647",
        "patch": "@@ -151,6 +151,7 @@\n     'signmessages.py',\n     'nulldummy.py',\n     'import-rescan.py',\n+    'bumpfee.py',\n     'rpcnamedargs.py',\n ]\n if ENABLE_ZMQ:"
      },
      {
        "sha": "0ebd79f7f32ef902106db0d8a0e957ed1e2dc2f3",
        "filename": "qa/rpc-tests/bumpfee.py",
        "status": "added",
        "additions": 317,
        "deletions": 0,
        "changes": 317,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cc0243ad32cee1cc9faab317364b889beaf07647/qa/rpc-tests/bumpfee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cc0243ad32cee1cc9faab317364b889beaf07647/qa/rpc-tests/bumpfee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bumpfee.py?ref=cc0243ad32cee1cc9faab317364b889beaf07647",
        "patch": "@@ -0,0 +1,317 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from segwit import send_to_witness\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework import blocktools\n+from test_framework.mininode import CTransaction\n+from test_framework.util import *\n+from test_framework.util import *\n+\n+import io\n+import time\n+\n+# Sequence number that is BIP 125 opt-in and BIP 68-compliant\n+BIP125_SEQUENCE_NUMBER = 0xfffffffd\n+\n+WALLET_PASSPHRASE = \"test\"\n+WALLET_PASSPHRASE_TIMEOUT = 3600\n+\n+\n+class BumpFeeTest(BitcoinTestFramework):\n+    def __init__(self):\n+        super().__init__()\n+        self.num_nodes = 2\n+        self.setup_clean_chain = True\n+\n+    def setup_network(self, split=False):\n+        extra_args = [[\"-debug\", \"-prematurewitness\", \"-walletprematurewitness\", \"-walletrbf={}\".format(i)]\n+                      for i in range(self.num_nodes)]\n+        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n+\n+        # Encrypt wallet for test_locked_wallet_fails test\n+        self.nodes[1].encryptwallet(WALLET_PASSPHRASE)\n+        bitcoind_processes[1].wait()\n+        self.nodes[1] = start_node(1, self.options.tmpdir, extra_args[1])\n+        self.nodes[1].walletpassphrase(WALLET_PASSPHRASE, WALLET_PASSPHRASE_TIMEOUT)\n+\n+        connect_nodes_bi(self.nodes, 0, 1)\n+        self.is_network_split = False\n+        self.sync_all()\n+\n+    def run_test(self):\n+        peer_node, rbf_node = self.nodes\n+        rbf_node_address = rbf_node.getnewaddress()\n+\n+        # fund rbf node with 10 coins of 0.001 btc (100,000 satoshis)\n+        print(\"Mining blocks...\")\n+        peer_node.generate(110)\n+        self.sync_all()\n+        for i in range(25):\n+            peer_node.sendtoaddress(rbf_node_address, 0.001)\n+        self.sync_all()\n+        peer_node.generate(1)\n+        self.sync_all()\n+        assert_equal(rbf_node.getbalance(), Decimal(\"0.025\"))\n+\n+        print(\"Running tests\")\n+        dest_address = peer_node.getnewaddress()\n+        test_small_output_fails(rbf_node, dest_address)\n+        test_dust_to_fee(rbf_node, dest_address)\n+        test_simple_bumpfee_succeeds(rbf_node, peer_node, dest_address)\n+        test_segwit_bumpfee_succeeds(rbf_node, dest_address)\n+        test_nonrbf_bumpfee_fails(peer_node, dest_address)\n+        test_notmine_bumpfee_fails(rbf_node, peer_node, dest_address)\n+        test_bumpfee_with_descendant_fails(rbf_node, rbf_node_address, dest_address)\n+        test_settxfee(rbf_node, dest_address)\n+        test_rebumping(rbf_node, dest_address)\n+        test_rebumping_not_replaceable(rbf_node, dest_address)\n+        test_unconfirmed_not_spendable(rbf_node, rbf_node_address)\n+        test_locked_wallet_fails(rbf_node, dest_address)\n+        print(\"Success\")\n+\n+\n+def test_simple_bumpfee_succeeds(rbf_node, peer_node, dest_address):\n+    rbfid = create_fund_sign_send(rbf_node, {dest_address: 0.00090000})\n+    rbftx = rbf_node.gettransaction(rbfid)\n+    sync_mempools((rbf_node, peer_node))\n+    assert rbfid in rbf_node.getrawmempool() and rbfid in peer_node.getrawmempool()\n+    bumped_tx = rbf_node.bumpfee(rbfid)\n+    assert bumped_tx[\"fee\"] - abs(rbftx[\"fee\"]) > 0\n+    # check that bumped_tx propogates, original tx was evicted and has a wallet conflict\n+    sync_mempools((rbf_node, peer_node))\n+    assert bumped_tx[\"txid\"] in rbf_node.getrawmempool()\n+    assert bumped_tx[\"txid\"] in peer_node.getrawmempool()\n+    assert rbfid not in rbf_node.getrawmempool()\n+    assert rbfid not in peer_node.getrawmempool()\n+    oldwtx = rbf_node.gettransaction(rbfid)\n+    assert len(oldwtx[\"walletconflicts\"]) > 0\n+    # check wallet transaction replaces and replaced_by values\n+    bumpedwtx = rbf_node.gettransaction(bumped_tx[\"txid\"])\n+    assert_equal(oldwtx[\"replaced_by_txid\"], bumped_tx[\"txid\"])\n+    assert_equal(bumpedwtx[\"replaces_txid\"], rbfid)\n+\n+\n+def test_segwit_bumpfee_succeeds(rbf_node, dest_address):\n+    # Create a transaction with segwit output, then create an RBF transaction\n+    # which spends it, and make sure bumpfee can be called on it.\n+\n+    segwit_in = next(u for u in rbf_node.listunspent() if u[\"amount\"] == Decimal(\"0.001\"))\n+    segwit_out = rbf_node.validateaddress(rbf_node.getnewaddress())\n+    rbf_node.addwitnessaddress(segwit_out[\"address\"])\n+    segwitid = send_to_witness(\n+        version=0,\n+        node=rbf_node,\n+        utxo=segwit_in,\n+        pubkey=segwit_out[\"pubkey\"],\n+        encode_p2sh=False,\n+        amount=Decimal(\"0.0009\"),\n+        sign=True)\n+\n+    rbfraw = rbf_node.createrawtransaction([{\n+        'txid': segwitid,\n+        'vout': 0,\n+        \"sequence\": BIP125_SEQUENCE_NUMBER\n+    }], {dest_address: Decimal(\"0.0005\"),\n+         get_change_address(rbf_node): Decimal(\"0.0003\")})\n+    rbfsigned = rbf_node.signrawtransaction(rbfraw)\n+    rbfid = rbf_node.sendrawtransaction(rbfsigned[\"hex\"])\n+    assert rbfid in rbf_node.getrawmempool()\n+\n+    bumped_tx = rbf_node.bumpfee(rbfid)\n+    assert bumped_tx[\"txid\"] in rbf_node.getrawmempool()\n+    assert rbfid not in rbf_node.getrawmempool()\n+\n+\n+def test_nonrbf_bumpfee_fails(peer_node, dest_address):\n+    # cannot replace a non RBF transaction (from node which did not enable RBF)\n+    not_rbfid = create_fund_sign_send(peer_node, {dest_address: 0.00090000})\n+    assert_raises_message(JSONRPCException, \"not BIP 125 replaceable\", peer_node.bumpfee, not_rbfid)\n+\n+\n+def test_notmine_bumpfee_fails(rbf_node, peer_node, dest_address):\n+    # cannot bump fee unless the tx has only inputs that we own.\n+    # here, the rbftx has a peer_node coin and then adds a rbf_node input\n+    # Note that this test depends upon the RPC code checking input ownership prior to change outputs\n+    # (since it can't use fundrawtransaction, it lacks a proper change output)\n+    utxos = [node.listunspent()[-1] for node in (rbf_node, peer_node)]\n+    inputs = [{\n+        \"txid\": utxo[\"txid\"],\n+        \"vout\": utxo[\"vout\"],\n+        \"address\": utxo[\"address\"],\n+        \"sequence\": BIP125_SEQUENCE_NUMBER\n+    } for utxo in utxos]\n+    output_val = sum(utxo[\"amount\"] for utxo in utxos) - Decimal(\"0.001\")\n+    rawtx = rbf_node.createrawtransaction(inputs, {dest_address: output_val})\n+    signedtx = rbf_node.signrawtransaction(rawtx)\n+    signedtx = peer_node.signrawtransaction(signedtx[\"hex\"])\n+    rbfid = rbf_node.sendrawtransaction(signedtx[\"hex\"])\n+    assert_raises_message(JSONRPCException, \"Transaction contains inputs that don't belong to this wallet\",\n+                          rbf_node.bumpfee, rbfid)\n+\n+\n+def test_bumpfee_with_descendant_fails(rbf_node, rbf_node_address, dest_address):\n+    # cannot bump fee if the transaction has a descendant\n+    # parent is send-to-self, so we don't have to check which output is change when creating the child tx\n+    parent_id = create_fund_sign_send(rbf_node, {rbf_node_address: 0.00050000})\n+    tx = rbf_node.createrawtransaction([{\"txid\": parent_id, \"vout\": 0}], {dest_address: 0.00020000})\n+    tx = rbf_node.signrawtransaction(tx)\n+    txid = rbf_node.sendrawtransaction(tx[\"hex\"])\n+    assert_raises_message(JSONRPCException, \"Transaction has descendants in the wallet\", rbf_node.bumpfee, parent_id)\n+\n+\n+def test_small_output_fails(rbf_node, dest_address):\n+    # cannot bump fee with a too-small output\n+    rbfid = spend_one_input(rbf_node,\n+                            Decimal(\"0.00100000\"),\n+                            {dest_address: 0.00080000,\n+                             get_change_address(rbf_node): Decimal(\"0.00010000\")})\n+    rbf_node.bumpfee(rbfid, {\"totalFee\": 20000})\n+\n+    rbfid = spend_one_input(rbf_node,\n+                            Decimal(\"0.00100000\"),\n+                            {dest_address: 0.00080000,\n+                             get_change_address(rbf_node): Decimal(\"0.00010000\")})\n+    assert_raises_message(JSONRPCException, \"Change output is too small\", rbf_node.bumpfee, rbfid, {\"totalFee\": 20001})\n+\n+\n+def test_dust_to_fee(rbf_node, dest_address):\n+    # check that if output is reduced to dust, it will be converted to fee\n+    # the bumped tx sets fee=9900, but it converts to 10,000\n+    rbfid = spend_one_input(rbf_node,\n+                            Decimal(\"0.00100000\"),\n+                            {dest_address: 0.00080000,\n+                             get_change_address(rbf_node): Decimal(\"0.00010000\")})\n+    fulltx = rbf_node.getrawtransaction(rbfid, 1)\n+    bumped_tx = rbf_node.bumpfee(rbfid, {\"totalFee\": 19900})\n+    full_bumped_tx = rbf_node.getrawtransaction(bumped_tx[\"txid\"], 1)\n+    assert_equal(bumped_tx[\"fee\"], Decimal(\"0.00020000\"))\n+    assert_equal(len(fulltx[\"vout\"]), 2)\n+    assert_equal(len(full_bumped_tx[\"vout\"]), 1)  #change output is eliminated\n+\n+\n+def test_settxfee(rbf_node, dest_address):\n+    # check that bumpfee reacts correctly to the use of settxfee (paytxfee)\n+    # increase feerate by 2.5x, test that fee increased at least 2x\n+    rbf_node.settxfee(Decimal(\"0.00001000\"))\n+    rbfid = create_fund_sign_send(rbf_node, {dest_address: 0.00090000})\n+    rbftx = rbf_node.gettransaction(rbfid)\n+    rbf_node.settxfee(Decimal(\"0.00002500\"))\n+    bumped_tx = rbf_node.bumpfee(rbfid)\n+    assert bumped_tx[\"fee\"] > 2 * abs(rbftx[\"fee\"])\n+    rbf_node.settxfee(Decimal(\"0.00000000\"))  # unset paytxfee\n+\n+\n+def test_rebumping(rbf_node, dest_address):\n+    # check that re-bumping the original tx fails, but bumping the bumper succeeds\n+    rbf_node.settxfee(Decimal(\"0.00001000\"))\n+    rbfid = create_fund_sign_send(rbf_node, {dest_address: 0.00090000})\n+    bumped = rbf_node.bumpfee(rbfid, {\"totalFee\": 1000})\n+    assert_raises_message(JSONRPCException, \"already bumped\", rbf_node.bumpfee, rbfid, {\"totalFee\": 2000})\n+    rbf_node.bumpfee(bumped[\"txid\"], {\"totalFee\": 2000})\n+\n+\n+def test_rebumping_not_replaceable(rbf_node, dest_address):\n+    # check that re-bumping a non-replaceable bump tx fails\n+    rbfid = create_fund_sign_send(rbf_node, {dest_address: 0.00090000})\n+    bumped = rbf_node.bumpfee(rbfid, {\"totalFee\": 10000, \"replaceable\": False})\n+    assert_raises_message(JSONRPCException, \"Transaction is not BIP 125 replaceable\", rbf_node.bumpfee, bumped[\"txid\"],\n+                          {\"totalFee\": 20000})\n+\n+\n+def test_unconfirmed_not_spendable(rbf_node, rbf_node_address):\n+    # check that unconfirmed outputs from bumped transactions are not spendable\n+    rbfid = create_fund_sign_send(rbf_node, {rbf_node_address: 0.00090000})\n+    rbftx = rbf_node.gettransaction(rbfid)[\"hex\"]\n+    assert rbfid in rbf_node.getrawmempool()\n+    bumpid = rbf_node.bumpfee(rbfid)[\"txid\"]\n+    assert bumpid in rbf_node.getrawmempool()\n+    assert rbfid not in rbf_node.getrawmempool()\n+\n+    # check that outputs from the bump transaction are not spendable\n+    # due to the replaces_txid check in CWallet::AvailableCoins\n+    assert_equal([t for t in rbf_node.listunspent(minconf=0, include_unsafe=False) if t[\"txid\"] == bumpid], [])\n+\n+    # submit a block with the rbf tx to clear the bump tx out of the mempool,\n+    # then call abandon to make sure the wallet doesn't attempt to resubmit the\n+    # bump tx, then invalidate the block so the rbf tx will be put back in the\n+    # mempool. this makes it possible to check whether the rbf tx outputs are\n+    # spendable before the rbf tx is confirmed.\n+    block = submit_block_with_tx(rbf_node, rbftx)\n+    rbf_node.abandontransaction(bumpid)\n+    rbf_node.invalidateblock(block.hash)\n+    assert bumpid not in rbf_node.getrawmempool()\n+    assert rbfid in rbf_node.getrawmempool()\n+\n+    # check that outputs from the rbf tx are not spendable before the\n+    # transaction is confirmed, due to the replaced_by_txid check in\n+    # CWallet::AvailableCoins\n+    assert_equal([t for t in rbf_node.listunspent(minconf=0, include_unsafe=False) if t[\"txid\"] == rbfid], [])\n+\n+    # check that the main output from the rbf tx is spendable after confirmed\n+    rbf_node.generate(1)\n+    assert_equal(\n+        sum(1 for t in rbf_node.listunspent(minconf=0, include_unsafe=False)\n+            if t[\"txid\"] == rbfid and t[\"address\"] == rbf_node_address and t[\"spendable\"]), 1)\n+\n+\n+def test_locked_wallet_fails(rbf_node, dest_address):\n+    rbfid = create_fund_sign_send(rbf_node, {dest_address: 0.00090000})\n+    rbf_node.walletlock()\n+    assert_raises_message(JSONRPCException, \"Please enter the wallet passphrase with walletpassphrase first.\",\n+                          rbf_node.bumpfee, rbfid)\n+\n+\n+def create_fund_sign_send(node, outputs):\n+    rawtx = node.createrawtransaction([], outputs)\n+    fundtx = node.fundrawtransaction(rawtx)\n+    signedtx = node.signrawtransaction(fundtx[\"hex\"])\n+    txid = node.sendrawtransaction(signedtx[\"hex\"])\n+    return txid\n+\n+\n+def spend_one_input(node, input_amount, outputs):\n+    input = dict(sequence=BIP125_SEQUENCE_NUMBER, **next(u for u in node.listunspent() if u[\"amount\"] == input_amount))\n+    rawtx = node.createrawtransaction([input], outputs)\n+    signedtx = node.signrawtransaction(rawtx)\n+    txid = node.sendrawtransaction(signedtx[\"hex\"])\n+    return txid\n+\n+\n+def get_change_address(node):\n+    \"\"\"Get a wallet change address.\n+\n+    There is no wallet RPC to access unused change addresses, so this creates a\n+    dummy transaction, calls fundrawtransaction to give add an input and change\n+    output, then returns the change address.\"\"\"\n+    dest_address = node.getnewaddress()\n+    dest_amount = Decimal(\"0.00012345\")\n+    rawtx = node.createrawtransaction([], {dest_address: dest_amount})\n+    fundtx = node.fundrawtransaction(rawtx)\n+    info = node.decoderawtransaction(fundtx[\"hex\"])\n+    return next(address for out in info[\"vout\"]\n+                if out[\"value\"] != dest_amount for address in out[\"scriptPubKey\"][\"addresses\"])\n+\n+\n+def submit_block_with_tx(node, tx):\n+    ctx = CTransaction()\n+    ctx.deserialize(io.BytesIO(hex_str_to_bytes(tx)))\n+\n+    tip = node.getbestblockhash()\n+    height = node.getblockcount() + 1\n+    block_time = node.getblockheader(tip)[\"mediantime\"] + 1\n+    block = blocktools.create_block(int(tip, 16), blocktools.create_coinbase(height), block_time)\n+    block.vtx.append(ctx)\n+    block.rehash()\n+    block.hashMerkleRoot = block.calc_merkle_root()\n+    block.solve()\n+    error = node.submitblock(bytes_to_hex_str(block.serialize(True)))\n+    if error is not None:\n+        raise Exception(error)\n+    return block\n+\n+\n+if __name__ == \"__main__\":\n+    BumpFeeTest().main()"
      },
      {
        "sha": "28d24b84fd76f793b916362f9d0c249b01f99e9a",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cc0243ad32cee1cc9faab317364b889beaf07647/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cc0243ad32cee1cc9faab317364b889beaf07647/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=cc0243ad32cee1cc9faab317364b889beaf07647",
        "patch": "@@ -116,6 +116,7 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"setnetworkactive\", 0, \"state\" },\n     { \"getmempoolancestors\", 1, \"verbose\" },\n     { \"getmempooldescendants\", 1, \"verbose\" },\n+    { \"bumpfee\", 1, \"options\" },\n     // Echo with conversion (For testing only)\n     { \"echojson\", 0, \"arg0\" },\n     { \"echojson\", 1, \"arg1\" },"
      },
      {
        "sha": "dc2c6d292e6845e5364e403bdb7d5cbda919e8f6",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 258,
        "deletions": 0,
        "changes": 258,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cc0243ad32cee1cc9faab317364b889beaf07647/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cc0243ad32cee1cc9faab317364b889beaf07647/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=cc0243ad32cee1cc9faab317364b889beaf07647",
        "patch": "@@ -11,8 +11,10 @@\n #include \"init.h\"\n #include \"validation.h\"\n #include \"net.h\"\n+#include \"policy/policy.h\"\n #include \"policy/rbf.h\"\n #include \"rpc/server.h\"\n+#include \"script/sign.h\"\n #include \"timedata.h\"\n #include \"util.h\"\n #include \"utilmoneystr.h\"\n@@ -2595,6 +2597,261 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2) {\n+        throw runtime_error(\n+            \"bumpfee \\\"txid\\\" ( options ) \\n\"\n+            \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n+            \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\"\n+            \"The command will pay the additional fee by decreasing (or perhaps removing) its change output.\\n\"\n+            \"If the change output is not big enough to cover the increased fee, the command will currently fail\\n\"\n+            \"instead of adding new inputs to compensate. (A future implementation could improve this.)\\n\"\n+            \"The command will fail if the wallet or mempool contains a transaction that spends one of T's outputs.\\n\"\n+            \"By default, the new fee will be calculated automatically using estimatefee.\\n\"\n+            \"The user can specify a confirmation target for estimatefee.\\n\"\n+            \"Alternatively, the user can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+            \"At a minimum, the new fee rate must be high enough to pay a new relay fee (relay fee amount returned\\n\"\n+            \"by getnetworkinfo RPC) and to enter the node's mempool.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. txid                  (string, required) The txid to be bumped\\n\"\n+            \"2. options               (object, optional)\\n\"\n+            \"   {\\n\"\n+            \"     \\\"confTarget\\\"        (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"     \\\"totalFee\\\"          (numeric, optional) Total fee (NOT feerate) to pay, in satoshis.\\n\"\n+            \"                         In rare cases, the actual fee paid might be slightly higher than the specified\\n\"\n+            \"                         totalFee if the tx change output has to be removed because it is too close to\\n\"\n+            \"                         the dust threshold.\\n\"\n+            \"     \\\"replaceable\\\"       (boolean, optional, default true) Whether the new transaction should still be\\n\"\n+            \"                         marked bip-125 replaceable. If true, the sequence numbers in the transaction will\\n\"\n+            \"                         be left unchanged from the original. If false, any input sequence numbers in the\\n\"\n+            \"                         original transaction that were less than 0xfffffffe will be increased to 0xfffffffe\\n\"\n+            \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n+            \"                         still be replacable in practice, for example if it has unconfirmed ancestors which\\n\"\n+            \"                         are replaceable).\\n\"\n+            \"   }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"txid\\\":    \\\"value\\\",   (string)  The id of the new transaction\\n\"\n+            \"  \\\"oldfee\\\":  n,         (numeric) Fee of the replaced transaction\\n\"\n+            \"  \\\"fee\\\":     n,         (numeric) Fee of the new transaction\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nBump the fee, get the new transaction\\'s txid\\n\" +\n+            HelpExampleCli(\"bumpfee\", \"<txid>\"));\n+    }\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VOBJ));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+\n+    // retrieve the original tx from the wallet\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    EnsureWalletIsUnlocked();\n+    if (!pwalletMain->mapWallet.count(hash)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    }\n+    CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    if (pwalletMain->HasWalletSpend(hash)) {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the wallet\");\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end() && it->GetCountWithDescendants() > 1) {\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has descendants in the mempool\");\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction has been mined, or is conflicted with a mined transaction\");\n+    }\n+\n+    if (!SignalsOptInRBF(wtx)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not BIP 125 replaceable\");\n+    }\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\")) {\n+        throw JSONRPCError(RPC_INVALID_REQUEST, strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", hash.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+    }\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pwalletMain->IsAllFromMe(wtx, ISMINE_SPENDABLE)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that don't belong to this wallet\");\n+    }\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pwalletMain->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1) {\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Transaction has multiple change outputs\");\n+            }\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1) {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Transaction does not have a change output\");\n+    }\n+\n+    // optional parameters\n+    bool specifiedConfirmTarget = false;\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    bool replaceable = true;\n+    if (request.params.size() > 1) {\n+        UniValue options = request.params[1];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"replaceable\", UniValueType(UniValue::VBOOL)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\") && options.exists(\"totalFee\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"confTarget and totalFee options should not both be set. Please provide either a confirmation target for fee estimation or an explicit total fee for the transaction.\");\n+        } else if (options.exists(\"confTarget\")) {\n+            specifiedConfirmTarget = true;\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) { // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+            }\n+        } else if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int64();\n+            if (totalFee <= 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            } else if (totalFee > maxTxFee) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than maxTxFee)\");\n+            }\n+        }\n+\n+        if (options.exists(\"replaceable\")) {\n+            replaceable = options[\"replaceable\"].get_bool();\n+        }\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = txSize + wtx.tx->vin.size();\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CAmount nNewFee;\n+    CFeeRate nNewFeeRate;\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + minRelayTxFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid totalFee, must be at least %s (oldFee %s + relayFee %s)\", FormatMoney(minTotalFee), nOldFeeRate.GetFee(maxNewTxSize), minRelayTxFee.GetFee(maxNewTxSize)));\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+        if (!specifiedConfirmTarget && payTxFee.GetFeePerK() != 0) {\n+            nNewFeeRate = payTxFee;\n+        } else {\n+            nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget);\n+        }\n+        if (nNewFeeRate.GetFeePerK() == 0) {\n+            nNewFeeRate = CWallet::fallbackFee;\n+        }\n+\n+        // new fee rate must be at least old rate + minimum relay rate\n+        if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+            nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+        }\n+\n+        nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        throw JSONRPCError(RPC_MISC_ERROR, strprintf(\"New fee rate (%s) is less than the minimum fee rate (%s) to get into the mempool. totalFee value should to be at least %s or settxfee value should be at least %s to add transaction.\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFee(maxNewTxSize)), FormatMoney(minMempoolFeeRate.GetFeePerK())));\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CAmount nDelta = nNewFee - nOldFee;\n+    assert(nDelta > 0);\n+    CMutableTransaction tx(*(wtx.tx));\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue < nDelta) {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Change output is too small to bump the fee\");\n+    }\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue -= nDelta;\n+    if (poutput->nValue <= poutput->GetDustThreshold(::minRelayTxFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee += poutput->nValue;\n+        tx.vout.erase(tx.vout.begin() + nOutput);\n+    }\n+\n+    // Mark new tx not replaceable, if requested.\n+    if (!replaceable) {\n+        for (auto& input : tx.vin) {\n+            if (input.nSequence < 0xfffffffe) input.nSequence = 0xfffffffe;\n+        }\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto& input : tx.vin) {\n+        std::map<uint256, CWalletTx>::const_iterator mi = pwalletMain->mapWallet.find(input.prevout.hash);\n+        assert(mi != pwalletMain->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        const CScript& scriptPubKey = mi->second.tx->vout[input.prevout.n].scriptPubKey;\n+        const CAmount& amount = mi->second.tx->vout[input.prevout.n].nValue;\n+        SignatureData sigdata;\n+        if (!ProduceSignature(TransactionSignatureCreator(pwalletMain, &txNewConst, nIn, amount, SIGHASH_ALL), scriptPubKey, sigdata)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Can't sign transaction.\");\n+        }\n+        UpdateTransaction(tx, nIn, sigdata);\n+        nIn++;\n+    }\n+\n+    // commit/broadcast the tx\n+    CReserveKey reservekey(pwalletMain);\n+    CWalletTx wtxBumped(pwalletMain, MakeTransactionRef(std::move(tx)));\n+    wtxBumped.mapValue[\"replaces_txid\"] = hash.ToString();\n+    CValidationState state;\n+    if (!pwalletMain->CommitTransaction(wtxBumped, reservekey, g_connman.get(), state) || !state.IsValid()) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, strprintf(\"Error: The transaction was rejected! Reason given: %s\", state.GetRejectReason()));\n+    }\n+\n+    // mark the original tx as bumped\n+    if (!pwalletMain->MarkReplaced(wtx.GetHash(), wtxBumped.GetHash())) {\n+        // TODO: see if JSON-RPC has a standard way of returning a response\n+        // along with an exception. It would be good to return information about\n+        // wtxBumped to the caller even if marking the original transaction\n+        // replaced does not succeed for some reason.\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error: Created new bumpfee transaction but could not mark the original transaction as replaced.\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    result.push_back(Pair(\"txid\", wtxBumped.GetHash().GetHex()));\n+    result.push_back(Pair(\"oldfee\", ValueFromAmount(nOldFee)));\n+    result.push_back(Pair(\"fee\", ValueFromAmount(nNewFee)));\n+\n+    return result;\n+}\n+\n extern UniValue dumpprivkey(const JSONRPCRequest& request); // in rpcdump.cpp\n extern UniValue importprivkey(const JSONRPCRequest& request);\n extern UniValue importaddress(const JSONRPCRequest& request);\n@@ -2614,6 +2871,7 @@ static const CRPCCommand commands[] =\n     { \"wallet\",             \"addmultisigaddress\",       &addmultisigaddress,       true,   {\"nrequired\",\"keys\",\"account\"} },\n     { \"wallet\",             \"addwitnessaddress\",        &addwitnessaddress,        true,   {\"address\"} },\n     { \"wallet\",             \"backupwallet\",             &backupwallet,             true,   {\"destination\"} },\n+    { \"wallet\",             \"bumpfee\",                  &bumpfee,                  true,   {\"txid\", \"options\"} },\n     { \"wallet\",             \"dumpprivkey\",              &dumpprivkey,              true,   {\"address\"}  },\n     { \"wallet\",             \"dumpwallet\",               &dumpwallet,               true,   {\"filename\"} },\n     { \"wallet\",             \"encryptwallet\",            &encryptwallet,            true,   {\"passphrase\"} },"
      },
      {
        "sha": "c1e1f2d7ea52efdc89504e86e635255c500eba4f",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 67,
        "deletions": 0,
        "changes": 67,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cc0243ad32cee1cc9faab317364b889beaf07647/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cc0243ad32cee1cc9faab317364b889beaf07647/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=cc0243ad32cee1cc9faab317364b889beaf07647",
        "patch": "@@ -411,6 +411,13 @@ set<uint256> CWallet::GetConflicts(const uint256& txid) const\n     return result;\n }\n \n+bool CWallet::HasWalletSpend(const uint256& txid) const\n+{\n+    AssertLockHeld(cs_wallet);\n+    auto iter = mapTxSpends.lower_bound(COutPoint(txid, 0));\n+    return (iter != mapTxSpends.end() && iter->first.hash == txid);\n+}\n+\n void CWallet::Flush(bool shutdown)\n {\n     bitdb.Flush(shutdown);\n@@ -826,6 +833,35 @@ void CWallet::MarkDirty()\n     }\n }\n \n+bool CWallet::MarkReplaced(const uint256& originalHash, const uint256& newHash)\n+{\n+    LOCK(cs_wallet);\n+\n+    auto mi = mapWallet.find(originalHash);\n+\n+    // There is a bug if MarkReplaced is not called on an existing wallet transaction.\n+    assert(mi != mapWallet.end());\n+\n+    CWalletTx& wtx = (*mi).second;\n+\n+    // Ensure for now that we're not overwriting data\n+    assert(wtx.mapValue.count(\"replaced_by_txid\") == 0);\n+\n+    wtx.mapValue[\"replaced_by_txid\"] = newHash.ToString();\n+\n+    CWalletDB walletdb(strWalletFile, \"r+\");\n+\n+    bool success = true;\n+    if (!walletdb.WriteTx(wtx)) {\n+        LogPrintf(\"%s: Updating walletdb tx %s failed\", __func__, wtx.GetHash().ToString());\n+        success = false;\n+    }\n+\n+    NotifyTransactionChanged(this, originalHash, CT_UPDATED);\n+\n+    return success;\n+}\n+\n bool CWallet::AddToWallet(const CWalletTx& wtxIn, bool fFlushOnClose)\n {\n     LOCK(cs_wallet);\n@@ -1981,6 +2017,37 @@ void CWallet::AvailableCoins(vector<COutput>& vCoins, bool fOnlyConfirmed, const\n             if (nDepth == 0 && !pcoin->InMempool())\n                 continue;\n \n+            // We should not consider coins from transactions that are replacing\n+            // other transactions.\n+            //\n+            // Example: There is a transaction A which is replaced by bumpfee\n+            // transaction B. In this case, we want to prevent creation of\n+            // a transaction B' which spends an output of B.\n+            //\n+            // Reason: If transaction A were initially confirmed, transactions B\n+            // and B' would no longer be valid, so the user would have to create\n+            // a new transaction C to replace B'. However, in the case of a\n+            // one-block reorg, transactions B' and C might BOTH be accepted,\n+            // when the user only wanted one of them. Specifically, there could\n+            // be a 1-block reorg away from the chain where transactions A and C\n+            // were accepted to another chain where B, B', and C were all\n+            // accepted.\n+            if (nDepth == 0 && fOnlyConfirmed && pcoin->mapValue.count(\"replaces_txid\")) {\n+                continue;\n+            }\n+\n+            // Similarly, we should not consider coins from transactions that\n+            // have been replaced. In the example above, we would want to prevent\n+            // creation of a transaction A' spending an output of A, because if\n+            // transaction B were initially confirmed, conflicting with A and\n+            // A', we wouldn't want to the user to create a transaction D\n+            // intending to replace A', but potentially resulting in a scenario\n+            // where A, A', and D could all be accepted (instead of just B and\n+            // D, or just A and A' like the user would want).\n+            if (nDepth == 0 && fOnlyConfirmed && pcoin->mapValue.count(\"replaced_by_txid\")) {\n+                continue;\n+            }\n+\n             for (unsigned int i = 0; i < pcoin->tx->vout.size(); i++) {\n                 isminetype mine = IsMine(pcoin->tx->vout[i]);\n                 if (!(IsSpent(wtxid, i)) && mine != ISMINE_NO &&"
      },
      {
        "sha": "50c5025c24a266c3e3c82a79c8698ae224948f0d",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cc0243ad32cee1cc9faab317364b889beaf07647/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cc0243ad32cee1cc9faab317364b889beaf07647/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=cc0243ad32cee1cc9faab317364b889beaf07647",
        "patch": "@@ -891,6 +891,9 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     //! Get wallet transactions that conflict with given transaction (spend same outputs)\n     std::set<uint256> GetConflicts(const uint256& txid) const;\n \n+    //! Check if a given transaction has any of its outputs spent by another transaction in the wallet\n+    bool HasWalletSpend(const uint256& txid) const;\n+\n     //! Flush wallet (bitdb flush)\n     void Flush(bool shutdown=false);\n \n@@ -927,6 +930,9 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     /* Mark a transaction (and it in-wallet descendants) as abandoned so its inputs may be respent. */\n     bool AbandonTransaction(const uint256& hashTx);\n \n+    /** Mark a transaction as replaced by another transaction (e.g., BIP 125). */\n+    bool MarkReplaced(const uint256& originalHash, const uint256& newHash);\n+\n     /* Returns the wallets help message */\n     static std::string GetWalletHelpString(bool showDebug);\n "
      }
    ]
  }
]