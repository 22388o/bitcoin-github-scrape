[
  {
    "sha": "c82a4e9a63a28fc8c482c7c8e5b7bfcc51a6805a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjODJhNGU5YTYzYTI4ZmM4YzQ4MmM3YzhlNWI3YmZjYzUxYTY4MDVh",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2016-02-21T02:02:44Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2016-06-16T16:35:37Z"
      },
      "message": "Use ancestor-feerate based transaction selection for mining\n\nIncludes changes by Pieter Wuille",
      "tree": {
        "sha": "3cd3545c0f596ece7043bf414e8f09143a97ca77",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3cd3545c0f596ece7043bf414e8f09143a97ca77"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c82a4e9a63a28fc8c482c7c8e5b7bfcc51a6805a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c82a4e9a63a28fc8c482c7c8e5b7bfcc51a6805a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c82a4e9a63a28fc8c482c7c8e5b7bfcc51a6805a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c82a4e9a63a28fc8c482c7c8e5b7bfcc51a6805a/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "44c1b1c9bb54082625c7ad76af25473abf79f866",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/44c1b1c9bb54082625c7ad76af25473abf79f866",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/44c1b1c9bb54082625c7ad76af25473abf79f866"
      }
    ],
    "stats": {
      "total": 324,
      "additions": 323,
      "deletions": 1
    },
    "files": [
      {
        "sha": "989ad11a2614d922786cb497aea7907ef1da8939",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 205,
        "deletions": 1,
        "changes": 206,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c82a4e9a63a28fc8c482c7c8e5b7bfcc51a6805a/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c82a4e9a63a28fc8c482c7c8e5b7bfcc51a6805a/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=c82a4e9a63a28fc8c482c7c8e5b7bfcc51a6805a",
        "patch": "@@ -25,6 +25,7 @@\n #include \"utilmoneystr.h\"\n #include \"validationinterface.h\"\n \n+#include <algorithm>\n #include <boost/thread.hpp>\n #include <boost/tuple/tuple.hpp>\n #include <queue>\n@@ -134,7 +135,7 @@ CBlockTemplate* BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn)\n                        : pblock->GetBlockTime();\n \n     addPriorityTxs();\n-    addScoreTxs();\n+    addPackageTxs();\n \n     nLastBlockTx = nBlockTx;\n     nLastBlockSize = nBlockSize;\n@@ -177,7 +178,38 @@ bool BlockAssembler::isStillDependent(CTxMemPool::txiter iter)\n     return false;\n }\n \n+void BlockAssembler::onlyUnconfirmed(CTxMemPool::setEntries& testSet)\n+{\n+    for (CTxMemPool::setEntries::iterator iit = testSet.begin(); iit != testSet.end(); ) {\n+        // Only test txs not already in the block\n+        if (inBlock.count(*iit)) {\n+            testSet.erase(iit++);\n+        }\n+        else {\n+            iit++;\n+        }\n+    }\n+}\n+\n+bool BlockAssembler::TestPackage(uint64_t packageSize, unsigned int packageSigOps)\n+{\n+    if (nBlockSize + packageSize >= nBlockMaxSize)\n+        return false;\n+    if (nBlockSigOps + packageSigOps >= MAX_BLOCK_SIGOPS)\n+        return false;\n+    return true;\n+}\n \n+// Block size and sigops have already been tested.  Check that all transactions\n+// are final.\n+bool BlockAssembler::TestPackageFinality(const CTxMemPool::setEntries& package)\n+{\n+    BOOST_FOREACH (const CTxMemPool::txiter it, package) {\n+        if (!IsFinalTx(it->GetTx(), nHeight, nLockTimeCutoff))\n+            return false;\n+    }\n+    return true;\n+}\n \n bool BlockAssembler::TestForBlock(CTxMemPool::txiter iter)\n {\n@@ -297,6 +329,178 @@ void BlockAssembler::addScoreTxs()\n     }\n }\n \n+void BlockAssembler::UpdatePackagesForAdded(const CTxMemPool::setEntries& alreadyAdded,\n+        indexed_modified_transaction_set &mapModifiedTx)\n+{\n+    BOOST_FOREACH(const CTxMemPool::txiter it, alreadyAdded) {\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(it, descendants);\n+        // Insert all descendants (not yet in block) into the modified set\n+        BOOST_FOREACH(CTxMemPool::txiter desc, descendants) {\n+            if (alreadyAdded.count(desc))\n+                continue;\n+            modtxiter mit = mapModifiedTx.find(desc);\n+            if (mit == mapModifiedTx.end()) {\n+                CTxMemPoolModifiedEntry modEntry(desc);\n+                modEntry.nSizeWithAncestors -= it->GetTxSize();\n+                modEntry.nModFeesWithAncestors -= it->GetModifiedFee();\n+                modEntry.nSigOpCountWithAncestors -= it->GetSigOpCount();\n+                mapModifiedTx.insert(modEntry);\n+            } else {\n+                mapModifiedTx.modify(mit, update_for_parent_inclusion(it));\n+            }\n+        }\n+    }\n+}\n+\n+// Skip entries in mapTx that are already in a block or are present\n+// in mapModifiedTx (which implies that the mapTx ancestor state is\n+// stale due to ancestor inclusion in the block)\n+// Also skip transactions that we've already failed to add. This can happen if\n+// we consider a transaction in mapModifiedTx and it fails: we can then\n+// potentially consider it again while walking mapTx.  It's currently\n+// guaranteed to fail again, but as a belt-and-suspenders check we put it in\n+// failedTx and avoid re-evaluation, since the re-evaluation would be using\n+// cached size/sigops/fee values that are not actually correct.\n+bool BlockAssembler::SkipMapTxEntry(CTxMemPool::txiter it, indexed_modified_transaction_set &mapModifiedTx, CTxMemPool::setEntries &failedTx)\n+{\n+    assert (it != mempool.mapTx.end());\n+    if (mapModifiedTx.count(it) || inBlock.count(it) || failedTx.count(it))\n+        return true;\n+    return false;\n+}\n+\n+void BlockAssembler::SortForBlock(const CTxMemPool::setEntries& package, CTxMemPool::txiter entry, std::vector<CTxMemPool::txiter>& sortedEntries)\n+{\n+    // Sort package by ancestor count\n+    // If a transaction A depends on transaction B, then A's ancestor count\n+    // must be greater than B's.  So this is sufficient to validly order the\n+    // transactions for block inclusion.\n+    sortedEntries.clear();\n+    sortedEntries.insert(sortedEntries.begin(), package.begin(), package.end());\n+    std::sort(sortedEntries.begin(), sortedEntries.end(), CompareTxIterByAncestorCount());\n+}\n+\n+// This transaction selection algorithm orders the mempool based\n+// on feerate of a transaction including all unconfirmed ancestors.\n+// Since we don't remove transactions from the mempool as we select them\n+// for block inclusion, we need an alternate method of updating the feerate\n+// of a transaction with its not-yet-selected ancestors as we go.\n+// This is accomplished by walking the in-mempool descendants of selected\n+// transactions and storing a temporary modified state in mapModifiedTxs.\n+// Each time through the loop, we compare the best transaction in\n+// mapModifiedTxs with the next transaction in the mempool to decide what\n+// transaction package to work on next.\n+void BlockAssembler::addPackageTxs()\n+{\n+    // mapModifiedTx will store sorted packages after they are modified\n+    // because some of their txs are already in the block\n+    indexed_modified_transaction_set mapModifiedTx;\n+    // Keep track of entries that failed inclusion, to avoid duplicate work\n+    CTxMemPool::setEntries failedTx;\n+\n+    // Start by adding all descendants of previously added txs to mapModifiedTx\n+    // and modifying them for their already included ancestors\n+    UpdatePackagesForAdded(inBlock, mapModifiedTx);\n+\n+    CTxMemPool::indexed_transaction_set::index<ancestor_score>::type::iterator mi = mempool.mapTx.get<ancestor_score>().begin();\n+    CTxMemPool::txiter iter;\n+    while (mi != mempool.mapTx.get<ancestor_score>().end() || !mapModifiedTx.empty())\n+    {\n+        // First try to find a new transaction in mapTx to evaluate.\n+        if (mi != mempool.mapTx.get<ancestor_score>().end() &&\n+                SkipMapTxEntry(mempool.mapTx.project<0>(mi), mapModifiedTx, failedTx)) {\n+            ++mi;\n+            continue;\n+        }\n+\n+        // Now that mi is not stale, determine which transaction to evaluate:\n+        // the next entry from mapTx, or the best from mapModifiedTx?\n+        bool fUsingModified = false;\n+\n+        modtxscoreiter modit = mapModifiedTx.get<ancestor_score>().begin();\n+        if (mi == mempool.mapTx.get<ancestor_score>().end()) {\n+            // We're out of entries in mapTx; use the entry from mapModifiedTx\n+            iter = modit->iter;\n+            fUsingModified = true;\n+        } else {\n+            // Try to compare the mapTx entry to the mapModifiedTx entry\n+            iter = mempool.mapTx.project<0>(mi);\n+            if (modit != mapModifiedTx.get<ancestor_score>().end() &&\n+                    CompareModifiedEntry()(*modit, CTxMemPoolModifiedEntry(iter))) {\n+                // The best entry in mapModifiedTx has higher score\n+                // than the one from mapTx.\n+                // Switch which transaction (package) to consider\n+                iter = modit->iter;\n+                fUsingModified = true;\n+            } else {\n+                // Either no entry in mapModifiedTx, or it's worse than mapTx.\n+                // Increment mi for the next loop iteration.\n+                ++mi;\n+            }\n+        }\n+\n+        // We skip mapTx entries that are inBlock, and mapModifiedTx shouldn't\n+        // contain anything that is inBlock.\n+        assert(!inBlock.count(iter));\n+\n+        uint64_t packageSize = iter->GetSizeWithAncestors();\n+        CAmount packageFees = iter->GetModFeesWithAncestors();\n+        unsigned int packageSigOps = iter->GetSigOpCountWithAncestors();\n+        if (fUsingModified) {\n+            packageSize = modit->nSizeWithAncestors;\n+            packageFees = modit->nModFeesWithAncestors;\n+            packageSigOps = modit->nSigOpCountWithAncestors;\n+        }\n+\n+        if (packageFees < ::minRelayTxFee.GetFee(packageSize) && nBlockSize >= nBlockMinSize) {\n+            // Everything else we might consider has a lower fee rate\n+            return;\n+        }\n+\n+        if (!TestPackage(packageSize, packageSigOps)) {\n+            if (fUsingModified) {\n+                // Since we always look at the best entry in mapModifiedTx,\n+                // we must erase failed entries so that we can consider the\n+                // next best entry on the next loop iteration\n+                mapModifiedTx.get<ancestor_score>().erase(modit);\n+                failedTx.insert(iter);\n+            }\n+            continue;\n+        }\n+\n+        CTxMemPool::setEntries ancestors;\n+        uint64_t nNoLimit = std::numeric_limits<uint64_t>::max();\n+        std::string dummy;\n+        mempool.CalculateMemPoolAncestors(*iter, ancestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy, false);\n+\n+        onlyUnconfirmed(ancestors);\n+        ancestors.insert(iter);\n+\n+        // Test if all tx's are Final\n+        if (!TestPackageFinality(ancestors)) {\n+            if (fUsingModified) {\n+                mapModifiedTx.get<ancestor_score>().erase(modit);\n+                failedTx.insert(iter);\n+            }\n+            continue;\n+        }\n+\n+        // Package can be added. Sort the entries in a valid order.\n+        vector<CTxMemPool::txiter> sortedEntries;\n+        SortForBlock(ancestors, iter, sortedEntries);\n+\n+        for (size_t i=0; i<sortedEntries.size(); ++i) {\n+            AddToBlock(sortedEntries[i]);\n+            // Erase from the modified set, if present\n+            mapModifiedTx.erase(sortedEntries[i]);\n+        }\n+\n+        // Update transactions that depend on each of these\n+        UpdatePackagesForAdded(ancestors, mapModifiedTx);\n+    }\n+}\n+\n void BlockAssembler::addPriorityTxs()\n {\n     // How much of the block should be dedicated to high-priority transactions,"
      },
      {
        "sha": "a9fea85304aa69a96172709b03a292e4b0ddb81d",
        "filename": "src/miner.h",
        "status": "modified",
        "additions": 118,
        "deletions": 0,
        "changes": 118,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c82a4e9a63a28fc8c482c7c8e5b7bfcc51a6805a/src/miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c82a4e9a63a28fc8c482c7c8e5b7bfcc51a6805a/src/miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.h?ref=c82a4e9a63a28fc8c482c7c8e5b7bfcc51a6805a",
        "patch": "@@ -11,6 +11,8 @@\n \n #include <stdint.h>\n #include <memory>\n+#include \"boost/multi_index_container.hpp\"\n+#include \"boost/multi_index/ordered_index.hpp\"\n \n class CBlockIndex;\n class CChainParams;\n@@ -29,6 +31,104 @@ struct CBlockTemplate\n     std::vector<int64_t> vTxSigOps;\n };\n \n+// Container for tracking updates to ancestor feerate as we include (parent)\n+// transactions in a block\n+struct CTxMemPoolModifiedEntry {\n+    CTxMemPoolModifiedEntry(CTxMemPool::txiter entry)\n+    {\n+        iter = entry;\n+        nSizeWithAncestors = entry->GetSizeWithAncestors();\n+        nModFeesWithAncestors = entry->GetModFeesWithAncestors();\n+        nSigOpCountWithAncestors = entry->GetSigOpCountWithAncestors();\n+    }\n+\n+    CTxMemPool::txiter iter;\n+    uint64_t nSizeWithAncestors;\n+    CAmount nModFeesWithAncestors;\n+    unsigned int nSigOpCountWithAncestors;\n+};\n+\n+/** Comparator for CTxMemPool::txiter objects.\n+ *  It simply compares the internal memory address of the CTxMemPoolEntry object\n+ *  pointed to. This means it has no meaning, and is only useful for using them\n+ *  as key in other indexes.\n+ */\n+struct CompareCTxMemPoolIter {\n+    bool operator()(const CTxMemPool::txiter& a, const CTxMemPool::txiter& b) const\n+    {\n+        return &(*a) < &(*b);\n+    }\n+};\n+\n+struct modifiedentry_iter {\n+    typedef CTxMemPool::txiter result_type;\n+    result_type operator() (const CTxMemPoolModifiedEntry &entry) const\n+    {\n+        return entry.iter;\n+    }\n+};\n+\n+// This matches the calculation in CompareTxMemPoolEntryByAncestorFee,\n+// except operating on CTxMemPoolModifiedEntry.\n+// TODO: refactor to avoid duplication of this logic.\n+struct CompareModifiedEntry {\n+    bool operator()(const CTxMemPoolModifiedEntry &a, const CTxMemPoolModifiedEntry &b)\n+    {\n+        double f1 = (double)a.nModFeesWithAncestors * b.nSizeWithAncestors;\n+        double f2 = (double)b.nModFeesWithAncestors * a.nSizeWithAncestors;\n+        if (f1 == f2) {\n+            return CTxMemPool::CompareIteratorByHash()(a.iter, b.iter);\n+        }\n+        return f1 > f2;\n+    }\n+};\n+\n+// A comparator that sorts transactions based on number of ancestors.\n+// This is sufficient to sort an ancestor package in an order that is valid\n+// to appear in a block.\n+struct CompareTxIterByAncestorCount {\n+    bool operator()(const CTxMemPool::txiter &a, const CTxMemPool::txiter &b)\n+    {\n+        if (a->GetCountWithAncestors() != b->GetCountWithAncestors())\n+            return a->GetCountWithAncestors() < b->GetCountWithAncestors();\n+        return CTxMemPool::CompareIteratorByHash()(a, b);\n+    }\n+};\n+\n+typedef boost::multi_index_container<\n+    CTxMemPoolModifiedEntry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<\n+            modifiedentry_iter,\n+            CompareCTxMemPoolIter\n+        >,\n+        // sorted by modified ancestor fee rate\n+        boost::multi_index::ordered_non_unique<\n+            // Reuse same tag from CTxMemPool's similar index\n+            boost::multi_index::tag<ancestor_score>,\n+            boost::multi_index::identity<CTxMemPoolModifiedEntry>,\n+            CompareModifiedEntry\n+        >\n+    >\n+> indexed_modified_transaction_set;\n+\n+typedef indexed_modified_transaction_set::nth_index<0>::type::iterator modtxiter;\n+typedef indexed_modified_transaction_set::index<ancestor_score>::type::iterator modtxscoreiter;\n+\n+struct update_for_parent_inclusion\n+{\n+    update_for_parent_inclusion(CTxMemPool::txiter it) : iter(it) {}\n+\n+    void operator() (CTxMemPoolModifiedEntry &e)\n+    {\n+        e.nModFeesWithAncestors -= iter->GetFee();\n+        e.nSizeWithAncestors -= iter->GetTxSize();\n+        e.nSigOpCountWithAncestors -= iter->GetSigOpCount();\n+    }\n+\n+    CTxMemPool::txiter iter;\n+};\n+\n /** Generate a new block, without valid proof-of-work */\n class BlockAssembler\n {\n@@ -74,12 +174,30 @@ class BlockAssembler\n     void addScoreTxs();\n     /** Add transactions based on tx \"priority\" */\n     void addPriorityTxs();\n+    /** Add transactions based on feerate including unconfirmed ancestors */\n+    void addPackageTxs();\n \n     // helper function for addScoreTxs and addPriorityTxs\n     /** Test if tx will still \"fit\" in the block */\n     bool TestForBlock(CTxMemPool::txiter iter);\n     /** Test if tx still has unconfirmed parents not yet in block */\n     bool isStillDependent(CTxMemPool::txiter iter);\n+\n+    // helper functions for addPackageTxs()\n+    /** Remove confirmed (inBlock) entries from given set */\n+    void onlyUnconfirmed(CTxMemPool::setEntries& testSet);\n+    /** Test if a new package would \"fit\" in the block */\n+    bool TestPackage(uint64_t packageSize, unsigned int packageSigOps);\n+    /** Test if a set of transactions are all final */\n+    bool TestPackageFinality(const CTxMemPool::setEntries& package);\n+    /** Return true if given transaction from mapTx has already been evaluated,\n+      * or if the transaction's cached data in mapTx is incorrect. */\n+    bool SkipMapTxEntry(CTxMemPool::txiter it, indexed_modified_transaction_set &mapModifiedTx, CTxMemPool::setEntries &failedTx);\n+    /** Sort the package in an order that is valid to appear in a block */\n+    void SortForBlock(const CTxMemPool::setEntries& package, CTxMemPool::txiter entry, std::vector<CTxMemPool::txiter>& sortedEntries);\n+    /** Add descendants of given transactions to mapModifiedTx with ancestor\n+      * state updated assuming given transactions are inBlock. */\n+    void UpdatePackagesForAdded(const CTxMemPool::setEntries& alreadyAdded, indexed_modified_transaction_set &mapModifiedTx);\n };\n \n /** Modify the extranonce in a block */"
      }
    ]
  },
  {
    "sha": "29fac19c93fabfed4163ee9ffa85f9188c9ee6ac",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyOWZhYzE5YzkzZmFiZmVkNDE2M2VlOWZmYTg1ZjkxODhjOWVlNmFj",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2016-02-21T01:58:23Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2016-06-16T16:35:37Z"
      },
      "message": "Add unit tests for ancestor feerate mining",
      "tree": {
        "sha": "2e6a8674a4e7179aea0041931d68076a442d0132",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2e6a8674a4e7179aea0041931d68076a442d0132"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/29fac19c93fabfed4163ee9ffa85f9188c9ee6ac",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/29fac19c93fabfed4163ee9ffa85f9188c9ee6ac",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/29fac19c93fabfed4163ee9ffa85f9188c9ee6ac",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/29fac19c93fabfed4163ee9ffa85f9188c9ee6ac/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c82a4e9a63a28fc8c482c7c8e5b7bfcc51a6805a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c82a4e9a63a28fc8c482c7c8e5b7bfcc51a6805a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c82a4e9a63a28fc8c482c7c8e5b7bfcc51a6805a"
      }
    ],
    "stats": {
      "total": 109,
      "additions": 109,
      "deletions": 0
    },
    "files": [
      {
        "sha": "ca8d6d2e05baa8b038f41bcd5dbe5260c4900b80",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 109,
        "deletions": 0,
        "changes": 109,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/29fac19c93fabfed4163ee9ffa85f9188c9ee6ac/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/29fac19c93fabfed4163ee9ffa85f9188c9ee6ac/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=29fac19c93fabfed4163ee9ffa85f9188c9ee6ac",
        "patch": "@@ -71,6 +71,113 @@ bool TestSequenceLocks(const CTransaction &tx, int flags)\n     return CheckSequenceLocks(tx, flags);\n }\n \n+// Test suite for ancestor feerate transaction selection.\n+// Implemented as an additional function, rather than a separate test case,\n+// to allow reusing the blockchain created in CreateNewBlock_validity.\n+// Note that this test assumes blockprioritysize is 0.\n+void TestPackageSelection(const CChainParams& chainparams, CScript scriptPubKey, std::vector<CTransaction *>& txFirst)\n+{\n+    // Test the ancestor feerate transaction selection.\n+    TestMemPoolEntryHelper entry;\n+\n+    // Test that a medium fee transaction will be selected after a higher fee\n+    // rate package with a low fee rate parent.\n+    CMutableTransaction tx;\n+    tx.vin.resize(1);\n+    tx.vin[0].scriptSig = CScript() << OP_1;\n+    tx.vin[0].prevout.hash = txFirst[0]->GetHash();\n+    tx.vin[0].prevout.n = 0;\n+    tx.vout.resize(1);\n+    tx.vout[0].nValue = 5000000000LL - 1000;\n+    // This tx has a low fee: 1000 satoshis\n+    uint256 hashParentTx = tx.GetHash(); // save this txid for later use\n+    mempool.addUnchecked(hashParentTx, entry.Fee(1000).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n+\n+    // This tx has a medium fee: 10000 satoshis\n+    tx.vin[0].prevout.hash = txFirst[1]->GetHash();\n+    tx.vout[0].nValue = 5000000000LL - 10000;\n+    uint256 hashMediumFeeTx = tx.GetHash();\n+    mempool.addUnchecked(hashMediumFeeTx, entry.Fee(10000).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n+\n+    // This tx has a high fee, but depends on the first transaction\n+    tx.vin[0].prevout.hash = hashParentTx;\n+    tx.vout[0].nValue = 5000000000LL - 1000 - 50000; // 50k satoshi fee\n+    uint256 hashHighFeeTx = tx.GetHash();\n+    mempool.addUnchecked(hashHighFeeTx, entry.Fee(50000).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));\n+\n+    CBlockTemplate *pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey);\n+    BOOST_CHECK(pblocktemplate->block.vtx[1].GetHash() == hashParentTx);\n+    BOOST_CHECK(pblocktemplate->block.vtx[2].GetHash() == hashHighFeeTx);\n+    BOOST_CHECK(pblocktemplate->block.vtx[3].GetHash() == hashMediumFeeTx);\n+\n+    // Test that a package below the min relay fee doesn't get included\n+    tx.vin[0].prevout.hash = hashHighFeeTx;\n+    tx.vout[0].nValue = 5000000000LL - 1000 - 50000; // 0 fee\n+    uint256 hashFreeTx = tx.GetHash();\n+    mempool.addUnchecked(hashFreeTx, entry.Fee(0).FromTx(tx));\n+    size_t freeTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n+\n+    // Calculate a fee on child transaction that will put the package just\n+    // below the min relay fee (assuming 1 child tx of the same size).\n+    CAmount feeToUse = minRelayTxFee.GetFee(2*freeTxSize) - 1;\n+\n+    tx.vin[0].prevout.hash = hashFreeTx;\n+    tx.vout[0].nValue = 5000000000LL - 1000 - 50000 - feeToUse;\n+    uint256 hashLowFeeTx = tx.GetHash();\n+    mempool.addUnchecked(hashLowFeeTx, entry.Fee(feeToUse).FromTx(tx));\n+    pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey);\n+    // Verify that the free tx and the low fee tx didn't get selected\n+    for (size_t i=0; i<pblocktemplate->block.vtx.size(); ++i) {\n+        BOOST_CHECK(pblocktemplate->block.vtx[i].GetHash() != hashFreeTx);\n+        BOOST_CHECK(pblocktemplate->block.vtx[i].GetHash() != hashLowFeeTx);\n+    }\n+\n+    // Test that packages above the min relay fee do get included, even if one\n+    // of the transactions is below the min relay fee\n+    // Remove the low fee transaction and replace with a higher fee transaction\n+    std::list<CTransaction> dummy;\n+    mempool.removeRecursive(tx, dummy);\n+    tx.vout[0].nValue -= 2; // Now we should be just over the min relay fee\n+    hashLowFeeTx = tx.GetHash();\n+    mempool.addUnchecked(hashLowFeeTx, entry.Fee(feeToUse+2).FromTx(tx));\n+    pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey);\n+    BOOST_CHECK(pblocktemplate->block.vtx[4].GetHash() == hashFreeTx);\n+    BOOST_CHECK(pblocktemplate->block.vtx[5].GetHash() == hashLowFeeTx);\n+\n+    // Test that transaction selection properly updates ancestor fee\n+    // calculations as ancestor transactions get included in a block.\n+    // Add a 0-fee transaction that has 2 outputs.\n+    tx.vin[0].prevout.hash = txFirst[2]->GetHash();\n+    tx.vout.resize(2);\n+    tx.vout[0].nValue = 5000000000LL - 100000000;\n+    tx.vout[1].nValue = 100000000; // 1BTC output\n+    uint256 hashFreeTx2 = tx.GetHash();\n+    mempool.addUnchecked(hashFreeTx2, entry.Fee(0).SpendsCoinbase(true).FromTx(tx));\n+\n+    // This tx can't be mined by itself\n+    tx.vin[0].prevout.hash = hashFreeTx2;\n+    tx.vout.resize(1);\n+    feeToUse = minRelayTxFee.GetFee(freeTxSize);\n+    tx.vout[0].nValue = 5000000000LL - 100000000 - feeToUse;\n+    uint256 hashLowFeeTx2 = tx.GetHash();\n+    mempool.addUnchecked(hashLowFeeTx2, entry.Fee(feeToUse).SpendsCoinbase(false).FromTx(tx));\n+    pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey);\n+\n+    // Verify that this tx isn't selected.\n+    for (size_t i=0; i<pblocktemplate->block.vtx.size(); ++i) {\n+        BOOST_CHECK(pblocktemplate->block.vtx[i].GetHash() != hashFreeTx2);\n+        BOOST_CHECK(pblocktemplate->block.vtx[i].GetHash() != hashLowFeeTx2);\n+    }\n+\n+    // This tx will be mineable, and should cause hashLowFeeTx2 to be selected\n+    // as well.\n+    tx.vin[0].prevout.n = 1;\n+    tx.vout[0].nValue = 100000000 - 10000; // 10k satoshi fee\n+    mempool.addUnchecked(tx.GetHash(), entry.Fee(10000).FromTx(tx));\n+    pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey);\n+    BOOST_CHECK(pblocktemplate->block.vtx[8].GetHash() == hashLowFeeTx2);\n+}\n+\n // NOTE: These tests rely on CreateNewBlock doing its own self-validation!\n BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n {\n@@ -385,6 +492,8 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     SetMockTime(0);\n     mempool.clear();\n \n+    TestPackageSelection(chainparams, scriptPubKey, txFirst);\n+\n     BOOST_FOREACH(CTransaction *_tx, txFirst)\n         delete _tx;\n "
      }
    ]
  }
]