[
  {
    "sha": "b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMzNhMGZiN2Y5ZTM3Y2I5YzUzOThiN2Q2NTFmNGU0MzczNDM0YWQz",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-07-27T13:32:40Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-07-13T14:23:03Z"
      },
      "message": "txpool: Avoid mapTx.iterator_to lookup in CalculateMemPoolAncestors",
      "tree": {
        "sha": "91b9df74469ac0716d24994ea97b83edc3c2e21f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/91b9df74469ac0716d24994ea97b83edc3c2e21f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3453cf26dbafabeccd6453d8a4703cdec35da805",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3453cf26dbafabeccd6453d8a4703cdec35da805",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3453cf26dbafabeccd6453d8a4703cdec35da805"
      }
    ],
    "stats": {
      "total": 48,
      "additions": 25,
      "deletions": 23
    },
    "files": [
      {
        "sha": "664b95a5a5f18cf802e63c5f9e5c94117b84b72b",
        "filename": "src/interfaces/chain.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3/src/interfaces/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3/src/interfaces/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.cpp?ref=b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3",
        "patch": "@@ -310,8 +310,8 @@ class ChainImpl : public Chain\n         auto limit_descendant_size = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT) * 1000;\n         std::string unused_error_string;\n         LOCK(::mempool.cs);\n-        return ::mempool.CalculateMemPoolAncestors(entry, ancestors, limit_ancestor_count, limit_ancestor_size,\n-            limit_descendant_count, limit_descendant_size, unused_error_string);\n+        return ::mempool.CalculateMemPoolAncestors(CTxMemPool::txiter{}, ancestors, limit_ancestor_count, limit_ancestor_size,\n+            limit_descendant_count, limit_descendant_size, unused_error_string, /* search_parents_for_entry */ &entry);\n     }\n     CFeeRate estimateSmartFee(int num_blocks, bool conservative, FeeCalculation* calc) override\n     {"
      },
      {
        "sha": "609be8ad1e045c318dc573036014e6ecd05fe04e",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3",
        "patch": "@@ -391,7 +391,7 @@ void BlockAssembler::addPackageTxs(int &nPackagesSelected, int &nDescendantsUpda\n         CTxMemPool::setEntries ancestors;\n         uint64_t nNoLimit = std::numeric_limits<uint64_t>::max();\n         std::string dummy;\n-        mempool.CalculateMemPoolAncestors(*iter, ancestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy, false);\n+        mempool.CalculateMemPoolAncestors(iter, ancestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy);\n \n         onlyUnconfirmed(ancestors);\n         ancestors.insert(iter);"
      },
      {
        "sha": "7981d09213cd64a16dbc60a4116d4d956d80cc16",
        "filename": "src/policy/rbf.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3/src/policy/rbf.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3/src/policy/rbf.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/rbf.cpp?ref=b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3",
        "patch": "@@ -26,8 +26,8 @@ RBFTransactionState IsRBFOptIn(const CTransaction& tx, const CTxMemPool& pool)\n     // signaled for RBF if any unconfirmed parents have signaled.\n     uint64_t noLimit = std::numeric_limits<uint64_t>::max();\n     std::string dummy;\n-    CTxMemPoolEntry entry = *pool.mapTx.find(tx.GetHash());\n-    pool.CalculateMemPoolAncestors(entry, setAncestors, noLimit, noLimit, noLimit, noLimit, dummy, false);\n+    auto it_tx = pool.mapTx.find(tx.GetHash());\n+    pool.CalculateMemPoolAncestors(it_tx, setAncestors, noLimit, noLimit, noLimit, noLimit, dummy);\n \n     for (CTxMemPool::txiter it : setAncestors) {\n         if (SignalsOptInRBF(it->GetTx())) {"
      },
      {
        "sha": "c93bc7b917b738cd750f1a5b6d0f1d4ffb2b8d99",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3",
        "patch": "@@ -566,7 +566,7 @@ static UniValue getmempoolancestors(const JSONRPCRequest& request)\n     CTxMemPool::setEntries setAncestors;\n     uint64_t noLimit = std::numeric_limits<uint64_t>::max();\n     std::string dummy;\n-    mempool.CalculateMemPoolAncestors(*it, setAncestors, noLimit, noLimit, noLimit, noLimit, dummy, false);\n+    mempool.CalculateMemPoolAncestors(it, setAncestors, noLimit, noLimit, noLimit, noLimit, dummy);\n \n     if (!fVerbose) {\n         UniValue o(UniValue::VARR);"
      },
      {
        "sha": "4178456a5010a1cb999652361a3d026373cd84c5",
        "filename": "src/test/mempool_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3/src/test/mempool_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3/src/test/mempool_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/mempool_tests.cpp?ref=b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3",
        "patch": "@@ -193,9 +193,10 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n     tx7.vout[1].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx7.vout[1].nValue = 1 * COIN;\n \n+    const CTxMemPoolEntry& search_parents_for_entry_1 = entry.Fee(2000000LL).FromTx(tx7);\n     CTxMemPool::setEntries setAncestorsCalculated;\n     std::string dummy;\n-    BOOST_CHECK_EQUAL(pool.CalculateMemPoolAncestors(entry.Fee(2000000LL).FromTx(tx7), setAncestorsCalculated, 100, 1000000, 1000, 1000000, dummy), true);\n+    BOOST_CHECK_EQUAL(pool.CalculateMemPoolAncestors(CTxMemPool::txiter{}, setAncestorsCalculated, 100, 1000000, 1000, 1000000, dummy, &search_parents_for_entry_1), true);\n     BOOST_CHECK(setAncestorsCalculated == setAncestors);\n \n     pool.addUnchecked(entry.FromTx(tx7), setAncestors);\n@@ -252,8 +253,9 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n     tx10.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx10.vout[0].nValue = 10 * COIN;\n \n+    const CTxMemPoolEntry& search_parents_for_entry_2 = entry.Fee(200000LL).Time(4).FromTx(tx10);\n     setAncestorsCalculated.clear();\n-    BOOST_CHECK_EQUAL(pool.CalculateMemPoolAncestors(entry.Fee(200000LL).Time(4).FromTx(tx10), setAncestorsCalculated, 100, 1000000, 1000, 1000000, dummy), true);\n+    BOOST_CHECK_EQUAL(pool.CalculateMemPoolAncestors(CTxMemPool::txiter{}, setAncestorsCalculated, 100, 1000000, 1000, 1000000, dummy, &search_parents_for_entry_2), true);\n     BOOST_CHECK(setAncestorsCalculated == setAncestors);\n \n     pool.addUnchecked(entry.FromTx(tx10), setAncestors);"
      },
      {
        "sha": "a4dcd2471725420f23154f65cd74eb0e90099fec",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 10,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3",
        "patch": "@@ -145,12 +145,13 @@ void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<uint256> &vHashes\n     }\n }\n \n-bool CTxMemPool::CalculateMemPoolAncestors(const CTxMemPoolEntry &entry, setEntries &setAncestors, uint64_t limitAncestorCount, uint64_t limitAncestorSize, uint64_t limitDescendantCount, uint64_t limitDescendantSize, std::string &errString, bool fSearchForParents /* = true */) const\n+bool CTxMemPool::CalculateMemPoolAncestors(txiter it, setEntries& setAncestors, uint64_t limitAncestorCount, uint64_t limitAncestorSize, uint64_t limitDescendantCount, uint64_t limitDescendantSize, std::string& errString, const CTxMemPoolEntry* search_parents_for_entry) const\n {\n     setEntries parentHashes;\n+    const CTxMemPoolEntry& entry = search_parents_for_entry ? *search_parents_for_entry : *it;\n     const CTransaction &tx = entry.GetTx();\n \n-    if (fSearchForParents) {\n+    if (search_parents_for_entry) {\n         // Get parents of this transaction that are in the mempool\n         // GetMemPoolParents() is only valid for entries in the mempool, so we\n         // iterate mapTx to find parents.\n@@ -165,9 +166,8 @@ bool CTxMemPool::CalculateMemPoolAncestors(const CTxMemPoolEntry &entry, setEntr\n             }\n         }\n     } else {\n-        // If we're not searching for parents, we require this to be an\n-        // entry in the mempool already.\n-        txiter it = mapTx.iterator_to(entry);\n+        // If we're not searching for parents, we were provided with an iterator\n+        // to an entry that is already in the mempool.\n         parentHashes = GetMemPoolParents(it);\n     }\n \n@@ -270,7 +270,6 @@ void CTxMemPool::UpdateForRemoveFromMempool(const setEntries &entriesToRemove, b\n     }\n     for (txiter removeIt : entriesToRemove) {\n         setEntries setAncestors;\n-        const CTxMemPoolEntry &entry = *removeIt;\n         std::string dummy;\n         // Since this is a tx that is already in the mempool, we can call CMPA\n         // with fSearchForParents = false.  If the mempool is in a consistent\n@@ -289,7 +288,7 @@ void CTxMemPool::UpdateForRemoveFromMempool(const setEntries &entriesToRemove, b\n         // differ from the set of mempool parents we'd calculate by searching,\n         // and it's important that we use the mapLinks[] notion of ancestor\n         // transactions as the set of things to update for removal.\n-        CalculateMemPoolAncestors(entry, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy, false);\n+        CalculateMemPoolAncestors(removeIt, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy);\n         // Note that UpdateAncestorsOf severs the child links that point to\n         // removeIt in the entries for the parents of removeIt.\n         UpdateAncestorsOf(false, removeIt, setAncestors);\n@@ -650,7 +649,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n         setEntries setAncestors;\n         uint64_t nNoLimit = std::numeric_limits<uint64_t>::max();\n         std::string dummy;\n-        CalculateMemPoolAncestors(*it, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy);\n+        CalculateMemPoolAncestors(txiter{}, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy, /* search_parents_for_entry */ &*it);\n         uint64_t nCountCheck = setAncestors.size() + 1;\n         uint64_t nSizeCheck = it->GetTxSize();\n         CAmount nFeesCheck = it->GetModifiedFee();\n@@ -821,7 +820,7 @@ void CTxMemPool::PrioritiseTransaction(const uint256& hash, const CAmount& nFeeD\n             setEntries setAncestors;\n             uint64_t nNoLimit = std::numeric_limits<uint64_t>::max();\n             std::string dummy;\n-            CalculateMemPoolAncestors(*it, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy, false);\n+            CalculateMemPoolAncestors(it, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy);\n             for (txiter ancestorIt : setAncestors) {\n                 mapTx.modify(ancestorIt, update_descendant_state(0, nFeeDelta, 0));\n             }\n@@ -938,7 +937,7 @@ void CTxMemPool::addUnchecked(const CTxMemPoolEntry &entry, bool validFeeEstimat\n     setEntries setAncestors;\n     uint64_t nNoLimit = std::numeric_limits<uint64_t>::max();\n     std::string dummy;\n-    CalculateMemPoolAncestors(entry, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy);\n+    CalculateMemPoolAncestors(txiter{}, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy, /* search_parents_for_entry */ &entry);\n     return addUnchecked(entry, setAncestors, validFeeEstimate);\n }\n "
      },
      {
        "sha": "f039900dd1fb407e0111602e4e6fd8226496e036",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3",
        "patch": "@@ -626,17 +626,18 @@ class CTxMemPool\n      */\n     void UpdateTransactionsFromBlock(const std::vector<uint256>& vHashesToUpdate) EXCLUSIVE_LOCKS_REQUIRED(cs, cs_main);\n \n-    /** Try to calculate all in-mempool ancestors of entry.\n+    /** Try to calculate all in-mempool ancestors of the passed iterator.\n      *  (these are all calculated including the tx itself)\n      *  limitAncestorCount = max number of ancestors\n      *  limitAncestorSize = max size of ancestors\n      *  limitDescendantCount = max number of descendants any ancestor can have\n      *  limitDescendantSize = max size of descendants any ancestor can have\n      *  errString = populated with error reason if any limits are hit\n-     *  fSearchForParents = whether to search a tx's vin for in-mempool parents, or\n-     *    look up parents from mapLinks. Must be true for entries not in the mempool\n+     *  search_parents_for_entry = Use this entry's tx's vin to search for in-mempool parents.\n+     *    Only needed when there is no mapTx iterator to this entry, which could be\n+     *    used to look up parents from mapLinks.\n      */\n-    bool CalculateMemPoolAncestors(const CTxMemPoolEntry& entry, setEntries& setAncestors, uint64_t limitAncestorCount, uint64_t limitAncestorSize, uint64_t limitDescendantCount, uint64_t limitDescendantSize, std::string& errString, bool fSearchForParents = true) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    bool CalculateMemPoolAncestors(txiter it, setEntries& setAncestors, uint64_t limitAncestorCount, uint64_t limitAncestorSize, uint64_t limitDescendantCount, uint64_t limitDescendantSize, std::string& errString, const CTxMemPoolEntry* search_parents_for_entry = nullptr) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     /** Populate setDescendants with all in-mempool descendants of hash.\n      *  Assumes that setDescendants includes all in-mempool descendants of anything"
      },
      {
        "sha": "a5dc0f1b8155606fe56d92a46f132addffb7e0c4",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3",
        "patch": "@@ -610,7 +610,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n         size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n         std::string errString;\n-        if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n+        if (!pool.CalculateMemPoolAncestors(CTxMemPool::txiter{}, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString, /* search_parents_for_entry */ &entry)) {\n             return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n         }\n "
      }
    ]
  },
  {
    "sha": "a6bf4f0588d96f24cb009c07aeea4bf733b5e860",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNmJmNGYwNTg4ZDk2ZjI0Y2IwMDljMDdhZWVhNGJmNzMzYjVlODYw",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-08-29T18:00:02Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-07-13T14:23:03Z"
      },
      "message": "tx pool: Make pool a template parameter of CoinsViewMemPool",
      "tree": {
        "sha": "f931412569123d566999cd2517bd058661a98ae1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f931412569123d566999cd2517bd058661a98ae1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a6bf4f0588d96f24cb009c07aeea4bf733b5e860",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a6bf4f0588d96f24cb009c07aeea4bf733b5e860",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a6bf4f0588d96f24cb009c07aeea4bf733b5e860",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a6bf4f0588d96f24cb009c07aeea4bf733b5e860/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b33a0fb7f9e37cb9c5398b7d651f4e4373434ad3"
      }
    ],
    "stats": {
      "total": 34,
      "additions": 19,
      "deletions": 15
    },
    "files": [
      {
        "sha": "76a128c0b304c56e4bd4e0e4bd4bcc868b606e37",
        "filename": "src/node/coin.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a6bf4f0588d96f24cb009c07aeea4bf733b5e860/src/node/coin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a6bf4f0588d96f24cb009c07aeea4bf733b5e860/src/node/coin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/coin.cpp?ref=a6bf4f0588d96f24cb009c07aeea4bf733b5e860",
        "patch": "@@ -12,7 +12,7 @@ void FindCoins(std::map<COutPoint, Coin>& coins)\n     LOCK2(cs_main, ::mempool.cs);\n     assert(pcoinsTip);\n     CCoinsViewCache& chain_view = *::pcoinsTip;\n-    CCoinsViewMemPool mempool_view(&chain_view, ::mempool);\n+    CoinsViewMemPool<CTxMemPool> mempool_view(&chain_view, ::mempool);\n     for (auto& coin : coins) {\n         if (!mempool_view.GetCoin(coin.first, coin.second)) {\n             // Either the coin is not in the CCoinsViewCache or is spent. Clear it."
      },
      {
        "sha": "eddd0269a3e1887eb6140278cced8e3fb68588f6",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a6bf4f0588d96f24cb009c07aeea4bf733b5e860/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a6bf4f0588d96f24cb009c07aeea4bf733b5e860/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=a6bf4f0588d96f24cb009c07aeea4bf733b5e860",
        "patch": "@@ -504,7 +504,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n             // use db+mempool as cache backend in case user likes to query mempool\n             LOCK2(cs_main, mempool.cs);\n             CCoinsViewCache& viewChain = *pcoinsTip;\n-            CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+            CoinsViewMemPool<CTxMemPool> viewMempool(&viewChain, mempool);\n             process_utxos(viewMempool, mempool);\n         } else {\n             LOCK(cs_main);  // no need to lock mempool!"
      },
      {
        "sha": "87415bbe83332d31d0ae11ed14f558905af37035",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a6bf4f0588d96f24cb009c07aeea4bf733b5e860/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a6bf4f0588d96f24cb009c07aeea4bf733b5e860/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=a6bf4f0588d96f24cb009c07aeea4bf733b5e860",
        "patch": "@@ -1128,7 +1128,7 @@ UniValue gettxout(const JSONRPCRequest& request)\n     Coin coin;\n     if (fMempool) {\n         LOCK(mempool.cs);\n-        CCoinsViewMemPool view(pcoinsTip.get(), mempool);\n+        CoinsViewMemPool<CTxMemPool> view(pcoinsTip.get(), mempool);\n         if (!view.GetCoin(out, coin) || mempool.isSpent(out)) {\n             return NullUniValue;\n         }"
      },
      {
        "sha": "e3bbfd33ac69e9164972a3c717579f6cab4217fd",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a6bf4f0588d96f24cb009c07aeea4bf733b5e860/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a6bf4f0588d96f24cb009c07aeea4bf733b5e860/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=a6bf4f0588d96f24cb009c07aeea4bf733b5e860",
        "patch": "@@ -633,7 +633,7 @@ static UniValue combinerawtransaction(const JSONRPCRequest& request)\n         LOCK(cs_main);\n         LOCK(mempool.cs);\n         CCoinsViewCache &viewChain = *pcoinsTip;\n-        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        CoinsViewMemPool<CTxMemPool> viewMempool(&viewChain, mempool);\n         view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n \n         for (const CTxIn& txin : mergedTx.vin) {\n@@ -1495,7 +1495,7 @@ UniValue utxoupdatepsbt(const JSONRPCRequest& request)\n     {\n         LOCK2(cs_main, mempool.cs);\n         CCoinsViewCache &viewChain = *pcoinsTip;\n-        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        CoinsViewMemPool<CTxMemPool> viewMempool(&viewChain, mempool);\n         view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n \n         for (const CTxIn& txin : psbtx.tx->vin) {"
      },
      {
        "sha": "6c8c8c725c300e1c110318c7a20ee8cd03f0383b",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a6bf4f0588d96f24cb009c07aeea4bf733b5e860/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a6bf4f0588d96f24cb009c07aeea4bf733b5e860/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=a6bf4f0588d96f24cb009c07aeea4bf733b5e860",
        "patch": "@@ -884,13 +884,13 @@ bool CTxMemPool::HasNoInputsOf(const CTransaction &tx) const\n     return true;\n }\n \n-CCoinsViewMemPool::CCoinsViewMemPool(CCoinsView* baseIn, const CTxMemPool& mempoolIn) : CCoinsViewBacked(baseIn), mempool(mempoolIn) { }\n-\n-bool CCoinsViewMemPool::GetCoin(const COutPoint &outpoint, Coin &coin) const {\n+template <typename P>\n+bool CoinsViewMemPool<P>::GetCoin(const COutPoint& outpoint, Coin& coin) const\n+{\n     // If an entry in the mempool exists, always return that one, as it's guaranteed to never\n     // conflict with the underlying cache, and it cannot have pruned entries (as it contains full)\n     // transactions. First checking the underlying cache risks returning a pruned entry instead.\n-    CTransactionRef ptx = mempool.get(outpoint.hash);\n+    CTransactionRef ptx = m_tx_pool.get(outpoint.hash);\n     if (ptx) {\n         if (outpoint.n < ptx->vout.size()) {\n             coin = Coin(ptx->vout[outpoint.n], MEMPOOL_HEIGHT, false);\n@@ -901,6 +901,7 @@ bool CCoinsViewMemPool::GetCoin(const COutPoint &outpoint, Coin &coin) const {\n     }\n     return base->GetCoin(outpoint, coin);\n }\n+template bool CoinsViewMemPool<CTxMemPool>::GetCoin(const COutPoint& outpoint, Coin& coin) const;\n \n size_t CTxMemPool::DynamicMemoryUsage() const {\n     LOCK(cs);"
      },
      {
        "sha": "23c0a2ac4776d341ff0873096866f0f626421b2b",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 7,
        "deletions": 4,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a6bf4f0588d96f24cb009c07aeea4bf733b5e860/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a6bf4f0588d96f24cb009c07aeea4bf733b5e860/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=a6bf4f0588d96f24cb009c07aeea4bf733b5e860",
        "patch": "@@ -751,14 +751,17 @@ class CTxMemPool\n  * signrawtransactionwithkey and signrawtransactionwithwallet,\n  * as long as the conflicting transaction is not yet confirmed.\n  */\n-class CCoinsViewMemPool : public CCoinsViewBacked\n+template <class P>\n+class CoinsViewMemPool : public CCoinsViewBacked\n {\n protected:\n-    const CTxMemPool& mempool;\n+    const P& m_tx_pool;\n \n public:\n-    CCoinsViewMemPool(CCoinsView* baseIn, const CTxMemPool& mempoolIn);\n-    bool GetCoin(const COutPoint &outpoint, Coin &coin) const override;\n+    CoinsViewMemPool(CCoinsView* baseIn, const P& mempoolIn)\n+        : CCoinsViewBacked(baseIn), m_tx_pool(mempoolIn) {}\n+\n+    bool GetCoin(const COutPoint& outpoint, Coin& coin) const override EXCLUSIVE_LOCKS_REQUIRED(m_tx_pool.cs);\n };\n \n /**"
      },
      {
        "sha": "ce0510774451e02f4b2bd82cc4b7c86563d7b227",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a6bf4f0588d96f24cb009c07aeea4bf733b5e860/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a6bf4f0588d96f24cb009c07aeea4bf733b5e860/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=a6bf4f0588d96f24cb009c07aeea4bf733b5e860",
        "patch": "@@ -255,7 +255,7 @@ bool CheckSequenceLocks(const CTxMemPool& pool, const CTransaction& tx, int flag\n     }\n     else {\n         // pcoinsTip contains the UTXO set for ::ChainActive().Tip()\n-        CCoinsViewMemPool viewMemPool(pcoinsTip.get(), pool);\n+        CoinsViewMemPool<CTxMemPool> viewMemPool(pcoinsTip.get(), pool);\n         std::vector<int> prevheights;\n         prevheights.resize(tx.vin.size());\n         for (size_t txinIndex = 0; txinIndex < tx.vin.size(); txinIndex++) {\n@@ -508,7 +508,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         CCoinsViewCache view(&dummy);\n \n         LockPoints lp;\n-        CCoinsViewMemPool viewMemPool(pcoinsTip.get(), pool);\n+        CoinsViewMemPool<CTxMemPool> viewMemPool(pcoinsTip.get(), pool);\n         view.SetBackend(viewMemPool);\n \n         // do all inputs exist?"
      }
    ]
  },
  {
    "sha": "980353a1869073ef3f67ae3c9548ce0d147f0ce2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ODAzNTNhMTg2OTA3M2VmM2Y2N2FlM2M5NTQ4Y2UwZDE0N2YwY2Uy",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-08-29T20:47:35Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-07-13T14:23:03Z"
      },
      "message": "tx pool: Move ATMP internal logic into static functions for template-reusability",
      "tree": {
        "sha": "9860c90ebb2eadb5f91a33e262c531687975003e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9860c90ebb2eadb5f91a33e262c531687975003e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/980353a1869073ef3f67ae3c9548ce0d147f0ce2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/980353a1869073ef3f67ae3c9548ce0d147f0ce2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/980353a1869073ef3f67ae3c9548ce0d147f0ce2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/980353a1869073ef3f67ae3c9548ce0d147f0ce2/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a6bf4f0588d96f24cb009c07aeea4bf733b5e860",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a6bf4f0588d96f24cb009c07aeea4bf733b5e860",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a6bf4f0588d96f24cb009c07aeea4bf733b5e860"
      }
    ],
    "stats": {
      "total": 239,
      "additions": 161,
      "deletions": 78
    },
    "files": [
      {
        "sha": "e1ed8432ba346ad6348bfb1c1098e2ba49eb9eac",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 143,
        "deletions": 70,
        "changes": 213,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/980353a1869073ef3f67ae3c9548ce0d147f0ce2/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/980353a1869073ef3f67ae3c9548ce0d147f0ce2/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=980353a1869073ef3f67ae3c9548ce0d147f0ce2",
        "patch": "@@ -145,9 +145,9 @@ void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<uint256> &vHashes\n     }\n }\n \n-bool CTxMemPool::CalculateMemPoolAncestors(txiter it, setEntries& setAncestors, uint64_t limitAncestorCount, uint64_t limitAncestorSize, uint64_t limitDescendantCount, uint64_t limitDescendantSize, std::string& errString, const CTxMemPoolEntry* search_parents_for_entry) const\n+static bool CalculateMemPoolAncestors(const CTxMemPool& pool, CTxMemPool::txiter it, CTxMemPool::setEntries& setAncestors, uint64_t limitAncestorCount, uint64_t limitAncestorSize, uint64_t limitDescendantCount, uint64_t limitDescendantSize, std::string& errString, const CTxMemPoolEntry* search_parents_for_entry) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n {\n-    setEntries parentHashes;\n+    CTxMemPool::setEntries parentHashes;\n     const CTxMemPoolEntry& entry = search_parents_for_entry ? *search_parents_for_entry : *it;\n     const CTransaction &tx = entry.GetTx();\n \n@@ -156,7 +156,7 @@ bool CTxMemPool::CalculateMemPoolAncestors(txiter it, setEntries& setAncestors,\n         // GetMemPoolParents() is only valid for entries in the mempool, so we\n         // iterate mapTx to find parents.\n         for (unsigned int i = 0; i < tx.vin.size(); i++) {\n-            boost::optional<txiter> piter = GetIter(tx.vin[i].prevout.hash);\n+            boost::optional<CTxMemPool::txiter> piter = pool.GetIter(tx.vin[i].prevout.hash);\n             if (piter) {\n                 parentHashes.insert(*piter);\n                 if (parentHashes.size() + 1 > limitAncestorCount) {\n@@ -168,13 +168,13 @@ bool CTxMemPool::CalculateMemPoolAncestors(txiter it, setEntries& setAncestors,\n     } else {\n         // If we're not searching for parents, we were provided with an iterator\n         // to an entry that is already in the mempool.\n-        parentHashes = GetMemPoolParents(it);\n+        parentHashes = pool.GetMemPoolParents(it);\n     }\n \n     size_t totalSizeWithAncestors = entry.GetTxSize();\n \n     while (!parentHashes.empty()) {\n-        txiter stageit = *parentHashes.begin();\n+        CTxMemPool::txiter stageit = *parentHashes.begin();\n \n         setAncestors.insert(stageit);\n         parentHashes.erase(stageit);\n@@ -191,8 +191,8 @@ bool CTxMemPool::CalculateMemPoolAncestors(txiter it, setEntries& setAncestors,\n             return false;\n         }\n \n-        const setEntries & setMemPoolParents = GetMemPoolParents(stageit);\n-        for (txiter phash : setMemPoolParents) {\n+        const auto& setMemPoolParents = pool.GetMemPoolParents(stageit);\n+        for (const auto& phash : setMemPoolParents) {\n             // If this is a new ancestor, add it.\n             if (setAncestors.count(phash) == 0) {\n                 parentHashes.insert(phash);\n@@ -207,44 +207,64 @@ bool CTxMemPool::CalculateMemPoolAncestors(txiter it, setEntries& setAncestors,\n     return true;\n }\n \n-void CTxMemPool::UpdateAncestorsOf(bool add, txiter it, setEntries &setAncestors)\n+bool CTxMemPool::CalculateMemPoolAncestors(txiter it, setEntries& setAncestors, uint64_t limitAncestorCount, uint64_t limitAncestorSize, uint64_t limitDescendantCount, uint64_t limitDescendantSize, std::string& errString, const CTxMemPoolEntry* search_parents_for_entry) const\n+{\n+    return ::CalculateMemPoolAncestors(*this, it, setAncestors, limitAncestorCount, limitAncestorSize, limitDescendantCount, limitDescendantSize, errString, search_parents_for_entry);\n+}\n+\n+static void UpdateAncestorsOf(CTxMemPool& pool, bool add, CTxMemPool::txiter it, const CTxMemPool::setEntries& setAncestors) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n {\n-    setEntries parentIters = GetMemPoolParents(it);\n+    auto parentIters = pool.GetMemPoolParents(it);\n     // add or remove this tx as a child of each parent\n-    for (txiter piter : parentIters) {\n-        UpdateChild(piter, it, add);\n+    for (const auto& piter : parentIters) {\n+        pool.UpdateChild(piter, it, add);\n     }\n     const int64_t updateCount = (add ? 1 : -1);\n     const int64_t updateSize = updateCount * it->GetTxSize();\n     const CAmount updateFee = updateCount * it->GetModifiedFee();\n-    for (txiter ancestorIt : setAncestors) {\n-        mapTx.modify(ancestorIt, update_descendant_state(updateSize, updateFee, updateCount));\n+    for (CTxMemPool::txiter ancestorIt : setAncestors) {\n+        pool.Modify(ancestorIt, update_descendant_state(updateSize, updateFee, updateCount));\n     }\n }\n \n-void CTxMemPool::UpdateEntryForAncestors(txiter it, const setEntries &setAncestors)\n+void CTxMemPool::UpdateAncestorsOf(bool add, txiter it, const setEntries& setAncestors)\n+{\n+    return ::UpdateAncestorsOf(*this, add, it, setAncestors);\n+}\n+\n+static void UpdateEntryForAncestors(CTxMemPool& pool, CTxMemPool::txiter it, const CTxMemPool::setEntries& setAncestors) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n {\n     int64_t updateCount = setAncestors.size();\n     int64_t updateSize = 0;\n     CAmount updateFee = 0;\n     int64_t updateSigOpsCost = 0;\n-    for (txiter ancestorIt : setAncestors) {\n+    for (CTxMemPool::txiter ancestorIt : setAncestors) {\n         updateSize += ancestorIt->GetTxSize();\n         updateFee += ancestorIt->GetModifiedFee();\n         updateSigOpsCost += ancestorIt->GetSigOpCost();\n     }\n-    mapTx.modify(it, update_ancestor_state(updateSize, updateFee, updateCount, updateSigOpsCost));\n+    pool.Modify(it, update_ancestor_state(updateSize, updateFee, updateCount, updateSigOpsCost));\n }\n \n-void CTxMemPool::UpdateChildrenForRemoval(txiter it)\n+void CTxMemPool::UpdateEntryForAncestors(txiter it, const setEntries& setAncestors)\n {\n-    const setEntries &setMemPoolChildren = GetMemPoolChildren(it);\n-    for (txiter updateIt : setMemPoolChildren) {\n-        UpdateParent(updateIt, it, false);\n+    return ::UpdateEntryForAncestors(*this, it, setAncestors);\n+}\n+\n+static void UpdateChildrenForRemoval(CTxMemPool& pool, CTxMemPool::txiter it) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n+{\n+    const auto& setMemPoolChildren = pool.GetMemPoolChildren(it);\n+    for (CTxMemPool::txiter updateIt : setMemPoolChildren) {\n+        pool.UpdateParent(updateIt, it, false);\n     }\n }\n \n-void CTxMemPool::UpdateForRemoveFromMempool(const setEntries &entriesToRemove, bool updateDescendants)\n+void CTxMemPool::UpdateChildrenForRemoval(txiter it)\n+{\n+    return ::UpdateChildrenForRemoval(*this, it);\n+}\n+\n+static void UpdateForRemoveFromMempool(CTxMemPool& pool, const CTxMemPool::setEntries& entriesToRemove, bool updateDescendants) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n {\n     // For each entry, walk back all ancestors and decrement size associated with this\n     // transaction\n@@ -256,20 +276,20 @@ void CTxMemPool::UpdateForRemoveFromMempool(const setEntries &entriesToRemove, b\n         // Here we only update statistics and not data in mapLinks (which\n         // we need to preserve until we're finished with all operations that\n         // need to traverse the mempool).\n-        for (txiter removeIt : entriesToRemove) {\n-            setEntries setDescendants;\n-            CalculateDescendants(removeIt, setDescendants);\n+        for (CTxMemPool::txiter removeIt : entriesToRemove) {\n+            CTxMemPool::setEntries setDescendants;\n+            pool.CalculateDescendants(removeIt, setDescendants);\n             setDescendants.erase(removeIt); // don't update state for self\n             int64_t modifySize = -((int64_t)removeIt->GetTxSize());\n             CAmount modifyFee = -removeIt->GetModifiedFee();\n             int modifySigOps = -removeIt->GetSigOpCost();\n-            for (txiter dit : setDescendants) {\n-                mapTx.modify(dit, update_ancestor_state(modifySize, modifyFee, -1, modifySigOps));\n+            for (CTxMemPool::txiter dit : setDescendants) {\n+                pool.Modify(dit, update_ancestor_state(modifySize, modifyFee, -1, modifySigOps));\n             }\n         }\n     }\n-    for (txiter removeIt : entriesToRemove) {\n-        setEntries setAncestors;\n+    for (CTxMemPool::txiter removeIt : entriesToRemove) {\n+        CTxMemPool::setEntries setAncestors;\n         std::string dummy;\n         // Since this is a tx that is already in the mempool, we can call CMPA\n         // with fSearchForParents = false.  If the mempool is in a consistent\n@@ -288,18 +308,22 @@ void CTxMemPool::UpdateForRemoveFromMempool(const setEntries &entriesToRemove, b\n         // differ from the set of mempool parents we'd calculate by searching,\n         // and it's important that we use the mapLinks[] notion of ancestor\n         // transactions as the set of things to update for removal.\n-        CalculateMemPoolAncestors(removeIt, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy);\n+        pool.CalculateMemPoolAncestors(removeIt, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy);\n         // Note that UpdateAncestorsOf severs the child links that point to\n         // removeIt in the entries for the parents of removeIt.\n-        UpdateAncestorsOf(false, removeIt, setAncestors);\n+        pool.UpdateAncestorsOf(false, removeIt, setAncestors);\n     }\n     // After updating all the ancestor sizes, we can now sever the link between each\n     // transaction being removed and any mempool children (ie, update setMemPoolParents\n     // for each direct child of a transaction being removed).\n-    for (txiter removeIt : entriesToRemove) {\n-        UpdateChildrenForRemoval(removeIt);\n+    for (CTxMemPool::txiter removeIt : entriesToRemove) {\n+        pool.UpdateChildrenForRemoval(removeIt);\n     }\n }\n+void CTxMemPool::UpdateForRemoveFromMempool(const setEntries& entriesToRemove, bool updateDescendants)\n+{\n+    return ::UpdateForRemoveFromMempool(*this, entriesToRemove, updateDescendants);\n+}\n \n void CTxMemPoolEntry::UpdateDescendantState(int64_t modifySize, CAmount modifyFee, int64_t modifyCount)\n {\n@@ -348,33 +372,29 @@ void CTxMemPool::AddTransactionsUpdated(unsigned int n)\n     nTransactionsUpdated += n;\n }\n \n-void CTxMemPool::addUnchecked(const CTxMemPoolEntry &entry, setEntries &setAncestors, bool validFeeEstimate)\n+static CTxMemPool::txiter addUnchecked(CTxMemPool& pool, const CTxMemPoolEntry& entry, const CTxMemPool::setEntries& setAncestors) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n {\n-    NotifyEntryAdded(entry.GetSharedTx());\n     // Add to memory pool without checking anything.\n     // Used by AcceptToMemoryPool(), which DOES do\n     // all the appropriate checks.\n-    indexed_transaction_set::iterator newit = mapTx.insert(entry).first;\n-    mapLinks.insert(make_pair(newit, TxLinks()));\n+    const auto& newit = pool.Insert(entry).first;\n+    pool.InsertLinks(newit);\n \n     // Update transaction for any feeDelta created by PrioritiseTransaction\n     // TODO: refactor so that the fee delta is calculated before inserting\n     // into mapTx.\n     CAmount delta{0};\n-    ApplyDelta(entry.GetTx().GetHash(), delta);\n-    if (delta) {\n-            mapTx.modify(newit, update_fee_delta(delta));\n-    }\n+    pool.ApplyDelta(entry.GetTx().GetHash(), delta);\n+    if (delta) pool.Modify(newit, update_fee_delta(delta));\n \n     // Update cachedInnerUsage to include contained transaction's usage.\n     // (When we update the entry for in-mempool parents, memory usage will be\n     // further updated.)\n-    cachedInnerUsage += entry.DynamicMemoryUsage();\n \n     const CTransaction& tx = newit->GetTx();\n     std::set<uint256> setParentTransactions;\n     for (unsigned int i = 0; i < tx.vin.size(); i++) {\n-        mapNextTx.insert(std::make_pair(&tx.vin[i].prevout, &tx));\n+        pool.InsertNextTx(std::make_pair(&tx.vin[i].prevout, &tx));\n         setParentTransactions.insert(tx.vin[i].prevout.hash);\n     }\n     // Don't bother worrying about child transactions of this one.\n@@ -385,26 +405,46 @@ void CTxMemPool::addUnchecked(const CTxMemPoolEntry &entry, setEntries &setAnces\n     // to clean up the mess we're leaving here.\n \n     // Update ancestors with information about this tx\n-    for (const auto& pit : GetIterSet(setParentTransactions)) {\n-            UpdateParent(newit, pit, true);\n+    for (const auto& pit : pool.GetIterSet(setParentTransactions)) {\n+        pool.UpdateParent(newit, pit, true);\n     }\n-    UpdateAncestorsOf(true, newit, setAncestors);\n-    UpdateEntryForAncestors(newit, setAncestors);\n+    pool.UpdateAncestorsOf(true, newit, setAncestors);\n+    pool.UpdateEntryForAncestors(newit, setAncestors);\n+\n+    return newit;\n+}\n+\n+void CTxMemPool::addUnchecked(const CTxMemPoolEntry& entry, const setEntries& setAncestors, bool validFeeEstimate)\n+{\n+    NotifyEntryAdded(entry.GetSharedTx());\n+\n+    cachedInnerUsage += entry.DynamicMemoryUsage();\n+\n+    txiter newit = ::addUnchecked(*this, entry, setAncestors);\n \n     nTransactionsUpdated++;\n     totalTxSize += entry.GetTxSize();\n-    if (minerPolicyEstimator) {minerPolicyEstimator->processTransaction(entry, validFeeEstimate);}\n+    if (minerPolicyEstimator) {\n+        minerPolicyEstimator->processTransaction(entry, validFeeEstimate);\n+    }\n \n-    vTxHashes.emplace_back(tx.GetWitnessHash(), newit);\n+    vTxHashes.emplace_back(entry.GetTx().GetWitnessHash(), newit);\n     newit->vTxHashesIdx = vTxHashes.size() - 1;\n }\n \n+static void removeUnchecked(CTxMemPool& pool, CTxMemPool::txiter it, MemPoolRemovalReason reason) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n+{\n+    for (const CTxIn& txin : it->GetTx().vin)\n+        pool.EraseNextTx(txin.prevout);\n+\n+    pool.EraseLinks(it);\n+    pool.EraseTx(it);\n+}\n+\n void CTxMemPool::removeUnchecked(txiter it, MemPoolRemovalReason reason)\n {\n     NotifyEntryRemoved(it->GetSharedTx(), reason);\n     const uint256 hash = it->GetTx().GetHash();\n-    for (const CTxIn& txin : it->GetTx().vin)\n-        mapNextTx.erase(txin.prevout);\n \n     if (vTxHashes.size() > 1) {\n         vTxHashes[it->vTxHashesIdx] = std::move(vTxHashes.back());\n@@ -418,8 +458,9 @@ void CTxMemPool::removeUnchecked(txiter it, MemPoolRemovalReason reason)\n     totalTxSize -= it->GetTxSize();\n     cachedInnerUsage -= it->DynamicMemoryUsage();\n     cachedInnerUsage -= memusage::DynamicUsage(mapLinks[it].parents) + memusage::DynamicUsage(mapLinks[it].children);\n-    mapLinks.erase(it);\n-    mapTx.erase(it);\n+\n+    ::removeUnchecked(*this, it, reason);\n+\n     nTransactionsUpdated++;\n     if (minerPolicyEstimator) {minerPolicyEstimator->removeTx(hash, false);}\n }\n@@ -430,29 +471,34 @@ void CTxMemPool::removeUnchecked(txiter it, MemPoolRemovalReason reason)\n // Also assumes that if an entry is in setDescendants already, then all\n // in-mempool descendants of it are already in setDescendants as well, so that we\n // can save time by not iterating over those entries.\n-void CTxMemPool::CalculateDescendants(txiter entryit, setEntries& setDescendants) const\n+static void CalculateDescendants(const CTxMemPool& pool, const CTxMemPool::txiter& entryit, CTxMemPool::setEntries& setDescendants) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n {\n-    setEntries stage;\n+    CTxMemPool::setEntries stage;\n     if (setDescendants.count(entryit) == 0) {\n         stage.insert(entryit);\n     }\n     // Traverse down the children of entry, only adding children that are not\n     // accounted for in setDescendants already (because those children have either\n     // already been walked, or will be walked in this iteration).\n     while (!stage.empty()) {\n-        txiter it = *stage.begin();\n+        CTxMemPool::txiter it = *stage.begin();\n         setDescendants.insert(it);\n         stage.erase(it);\n \n-        const setEntries &setChildren = GetMemPoolChildren(it);\n-        for (txiter childiter : setChildren) {\n+        const auto& setChildren = pool.GetMemPoolChildren(it);\n+        for (const auto& childiter : setChildren) {\n             if (!setDescendants.count(childiter)) {\n                 stage.insert(childiter);\n             }\n         }\n     }\n }\n \n+void CTxMemPool::CalculateDescendants(txiter entryit, setEntries& setDescendants) const\n+{\n+    return ::CalculateDescendants(*this, entryit, setDescendants);\n+}\n+\n void CTxMemPool::removeRecursive(const CTransaction &origTx, MemPoolRemovalReason reason)\n {\n     // Remove transaction from memory pool\n@@ -866,24 +912,40 @@ boost::optional<CTxMemPool::txiter> CTxMemPool::GetIter(const uint256& txid) con\n     return boost::optional<txiter>{};\n }\n \n-CTxMemPool::setEntries CTxMemPool::GetIterSet(const std::set<uint256>& hashes) const\n+static CTxMemPool::setEntries GetIterSet(const CTxMemPool& pool, const std::set<uint256>& hashes) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n {\n     CTxMemPool::setEntries ret;\n     for (const auto& h : hashes) {\n-        const auto mi = GetIter(h);\n+        const auto mi = pool.GetIter(h);\n         if (mi) ret.insert(*mi);\n     }\n     return ret;\n }\n \n-bool CTxMemPool::HasNoInputsOf(const CTransaction &tx) const\n+CTxMemPool::setEntries CTxMemPool::GetIterSet(const std::set<uint256>& hashes) const\n+{\n+    return ::GetIterSet(*this, hashes);\n+}\n+\n+template <typename UpdateStruct>\n+void CTxMemPool::Modify(txiter it, const UpdateStruct& update_object)\n+{\n+    mapTx.modify(it, update_object);\n+}\n+\n+static bool HasNoInputsOf(const CTxMemPool& pool, const CTransaction& tx) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n {\n     for (unsigned int i = 0; i < tx.vin.size(); i++)\n-        if (exists(tx.vin[i].prevout.hash))\n+        if (pool.exists(tx.vin[i].prevout.hash))\n             return false;\n     return true;\n }\n \n+bool CTxMemPool::HasNoInputsOf(const CTransaction& tx) const\n+{\n+    return ::HasNoInputsOf(*this, tx);\n+}\n+\n template <typename P>\n bool CoinsViewMemPool<P>::GetCoin(const COutPoint& outpoint, Coin& coin) const\n {\n@@ -909,14 +971,20 @@ size_t CTxMemPool::DynamicMemoryUsage() const {\n     return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 12 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + memusage::DynamicUsage(mapLinks) + memusage::DynamicUsage(vTxHashes) + cachedInnerUsage;\n }\n \n-void CTxMemPool::RemoveStaged(setEntries &stage, bool updateDescendants, MemPoolRemovalReason reason) {\n-    AssertLockHeld(cs);\n-    UpdateForRemoveFromMempool(stage, updateDescendants);\n-    for (txiter it : stage) {\n-        removeUnchecked(it, reason);\n+static void RemoveStaged(CTxMemPool& pool, CTxMemPool::setEntries& stage, bool updateDescendants, MemPoolRemovalReason reason) EXCLUSIVE_LOCKS_REQUIRED(pool.cs) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n+{\n+    AssertLockHeld(pool.cs);\n+    pool.UpdateForRemoveFromMempool(stage, updateDescendants);\n+    for (const auto& it : stage) {\n+        pool.removeUnchecked(it, reason);\n     }\n }\n \n+void CTxMemPool::RemoveStaged(setEntries& stage, bool updateDescendants, MemPoolRemovalReason reason)\n+{\n+    return ::RemoveStaged(*this, stage, updateDescendants, reason);\n+}\n+\n int CTxMemPool::Expire(int64_t time) {\n     AssertLockHeld(cs);\n     indexed_transaction_set::index<entry_time>::type::iterator it = mapTx.get<entry_time>().begin();\n@@ -933,13 +1001,18 @@ int CTxMemPool::Expire(int64_t time) {\n     return stage.size();\n }\n \n-void CTxMemPool::addUnchecked(const CTxMemPoolEntry &entry, bool validFeeEstimate)\n+static void addUnchecked(CTxMemPool& pool, const CTxMemPoolEntry& entry, bool validFeeEstimate) EXCLUSIVE_LOCKS_REQUIRED(pool.cs, cs_main)\n {\n-    setEntries setAncestors;\n+    CTxMemPool::setEntries setAncestors;\n     uint64_t nNoLimit = std::numeric_limits<uint64_t>::max();\n     std::string dummy;\n-    CalculateMemPoolAncestors(txiter{}, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy, /* search_parents_for_entry */ &entry);\n-    return addUnchecked(entry, setAncestors, validFeeEstimate);\n+    pool.CalculateMemPoolAncestors(CTxMemPool::txiter{}, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy, /* search_parents_for_entry */ &entry);\n+    return pool.addUnchecked(entry, setAncestors, validFeeEstimate);\n+}\n+\n+void CTxMemPool::addUnchecked(const CTxMemPoolEntry& entry, bool validFeeEstimate)\n+{\n+    return ::addUnchecked(*this, entry, validFeeEstimate);\n }\n \n void CTxMemPool::UpdateChild(txiter entry, txiter child, bool add)"
      },
      {
        "sha": "3588b08cb8c676847876d3d7627e84460099f803",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 18,
        "deletions": 8,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/980353a1869073ef3f67ae3c9548ce0d147f0ce2/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/980353a1869073ef3f67ae3c9548ce0d147f0ce2/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=980353a1869073ef3f67ae3c9548ce0d147f0ce2",
        "patch": "@@ -542,12 +542,12 @@ class CTxMemPool\n     typedef std::map<txiter, TxLinks, CompareIteratorByHash> txlinksMap;\n     txlinksMap mapLinks;\n \n-    void UpdateParent(txiter entry, txiter parent, bool add);\n-    void UpdateChild(txiter entry, txiter child, bool add);\n-\n     std::vector<indexed_transaction_set::const_iterator> GetSortedDepthAndScore() const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n public:\n+    void UpdateParent(txiter entry, txiter parent, bool add);\n+    void UpdateChild(txiter entry, txiter child, bool add);\n+\n     indirectmap<COutPoint, const CTransaction*> mapNextTx GUARDED_BY(cs);\n     std::map<uint256, CAmount> mapDeltas;\n \n@@ -572,7 +572,7 @@ class CTxMemPool\n     // and any other callers may break wallet's in-mempool tracking (due to\n     // lack of CValidationInterface::TransactionAddedToMempool callbacks).\n     void addUnchecked(const CTxMemPoolEntry& entry, bool validFeeEstimate = true) EXCLUSIVE_LOCKS_REQUIRED(cs, cs_main);\n-    void addUnchecked(const CTxMemPoolEntry& entry, setEntries& setAncestors, bool validFeeEstimate = true) EXCLUSIVE_LOCKS_REQUIRED(cs, cs_main);\n+    void addUnchecked(const CTxMemPoolEntry& entry, const setEntries& setAncestors, bool validFeeEstimate = true) EXCLUSIVE_LOCKS_REQUIRED(cs, cs_main);\n \n     void removeRecursive(const CTransaction& tx, MemPoolRemovalReason reason = MemPoolRemovalReason::UNKNOWN) EXCLUSIVE_LOCKS_REQUIRED(cs);\n     void removeForReorg(const CCoinsViewCache* pcoins, unsigned int nMemPoolHeight, int flags) EXCLUSIVE_LOCKS_REQUIRED(cs, cs_main);\n@@ -691,16 +691,26 @@ class CTxMemPool\n         return (mapTx.count(hash) != 0);\n     }\n \n+    template <typename UpdateStruct>\n+    void Modify(txiter it, const UpdateStruct& update_object) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    void InsertLinks(txiter newit) EXCLUSIVE_LOCKS_REQUIRED(cs) { mapLinks.emplace(newit, TxLinks{}); }\n+    void EraseLinks(txiter it) EXCLUSIVE_LOCKS_REQUIRED(cs) { mapLinks.erase(it); }\n+    void InsertNextTx(const std::pair<const COutPoint*, const CTransaction*>& next_tx) EXCLUSIVE_LOCKS_REQUIRED(cs) { mapNextTx.insert(next_tx); }\n+    void EraseNextTx(const COutPoint& out) EXCLUSIVE_LOCKS_REQUIRED(cs) { mapNextTx.erase(out); }\n+\n+    std::pair<txiter, bool> Insert(const CTxMemPoolEntry& entry) EXCLUSIVE_LOCKS_REQUIRED(cs) { return mapTx.insert(entry); }\n+    void EraseTx(txiter it) EXCLUSIVE_LOCKS_REQUIRED(cs) { mapTx.erase(it); }\n+\n     CTransactionRef get(const uint256& hash) const;\n     TxMempoolInfo info(const uint256& hash) const;\n     std::vector<TxMempoolInfo> infoAll() const;\n \n     size_t DynamicMemoryUsage() const;\n \n-    boost::signals2::signal<void (CTransactionRef)> NotifyEntryAdded;\n-    boost::signals2::signal<void (CTransactionRef, MemPoolRemovalReason)> NotifyEntryRemoved;\n+    boost::signals2::signal<void(CTransactionRef)> NotifyEntryAdded;\n+    boost::signals2::signal<void(CTransactionRef, MemPoolRemovalReason)> NotifyEntryRemoved;\n \n-private:\n     /** UpdateForDescendants is used by UpdateTransactionsFromBlock to update\n      *  the descendants for a single transaction that has been added to the\n      *  mempool but may have child transactions in the mempool, eg during a\n@@ -718,7 +728,7 @@ class CTxMemPool\n             cacheMap &cachedDescendants,\n             const std::set<uint256> &setExclude) EXCLUSIVE_LOCKS_REQUIRED(cs);\n     /** Update ancestors of hash to add/remove it as a descendant transaction. */\n-    void UpdateAncestorsOf(bool add, txiter hash, setEntries &setAncestors) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    void UpdateAncestorsOf(bool add, txiter hash, const setEntries& setAncestors) EXCLUSIVE_LOCKS_REQUIRED(cs);\n     /** Set ancestor state for an entry */\n     void UpdateEntryForAncestors(txiter it, const setEntries &setAncestors) EXCLUSIVE_LOCKS_REQUIRED(cs);\n     /** For each transaction being removed, update ancestors and any direct children."
      }
    ]
  },
  {
    "sha": "19c277055cfeac9aa817b42b476de44f51831865",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxOWMyNzcwNTVjZmVhYzlhYTgxN2I0MmI0NzZkZTQ0ZjUxODMxODY1",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-07-11T15:11:07Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-07-13T14:23:03Z"
      },
      "message": "txmempool: Use auto and GetEntry to hide txiter type",
      "tree": {
        "sha": "eb2d3cca869e9b7cf472d55f2bd69ff8797e9e61",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/eb2d3cca869e9b7cf472d55f2bd69ff8797e9e61"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/19c277055cfeac9aa817b42b476de44f51831865",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/19c277055cfeac9aa817b42b476de44f51831865",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/19c277055cfeac9aa817b42b476de44f51831865",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/19c277055cfeac9aa817b42b476de44f51831865/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "980353a1869073ef3f67ae3c9548ce0d147f0ce2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/980353a1869073ef3f67ae3c9548ce0d147f0ce2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/980353a1869073ef3f67ae3c9548ce0d147f0ce2"
      }
    ],
    "stats": {
      "total": 104,
      "additions": 52,
      "deletions": 52
    },
    "files": [
      {
        "sha": "f7a873397eb837635a4d6dbe2fbcc6368fb474d0",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 25,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/19c277055cfeac9aa817b42b476de44f51831865/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/19c277055cfeac9aa817b42b476de44f51831865/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=19c277055cfeac9aa817b42b476de44f51831865",
        "patch": "@@ -148,7 +148,7 @@ void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<uint256> &vHashes\n static bool CalculateMemPoolAncestors(const CTxMemPool& pool, CTxMemPool::txiter it, CTxMemPool::setEntries& setAncestors, uint64_t limitAncestorCount, uint64_t limitAncestorSize, uint64_t limitDescendantCount, uint64_t limitDescendantSize, std::string& errString, const CTxMemPoolEntry* search_parents_for_entry) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n {\n     CTxMemPool::setEntries parentHashes;\n-    const CTxMemPoolEntry& entry = search_parents_for_entry ? *search_parents_for_entry : *it;\n+    const CTxMemPoolEntry& entry = search_parents_for_entry ? *search_parents_for_entry : pool.GetEntry(it);\n     const CTransaction &tx = entry.GetTx();\n \n     if (search_parents_for_entry) {\n@@ -174,17 +174,17 @@ static bool CalculateMemPoolAncestors(const CTxMemPool& pool, CTxMemPool::txiter\n     size_t totalSizeWithAncestors = entry.GetTxSize();\n \n     while (!parentHashes.empty()) {\n-        CTxMemPool::txiter stageit = *parentHashes.begin();\n+        auto stageit = *parentHashes.begin();\n \n         setAncestors.insert(stageit);\n         parentHashes.erase(stageit);\n-        totalSizeWithAncestors += stageit->GetTxSize();\n+        totalSizeWithAncestors += pool.GetEntry(stageit).GetTxSize();\n \n-        if (stageit->GetSizeWithDescendants() + entry.GetTxSize() > limitDescendantSize) {\n-            errString = strprintf(\"exceeds descendant size limit for tx %s [limit: %u]\", stageit->GetTx().GetHash().ToString(), limitDescendantSize);\n+        if (pool.GetEntry(stageit).GetSizeWithDescendants() + entry.GetTxSize() > limitDescendantSize) {\n+            errString = strprintf(\"exceeds descendant size limit for tx %s [limit: %u]\", pool.GetEntry(stageit).GetTx().GetHash().ToString(), limitDescendantSize);\n             return false;\n-        } else if (stageit->GetCountWithDescendants() + 1 > limitDescendantCount) {\n-            errString = strprintf(\"too many descendants for tx %s [limit: %u]\", stageit->GetTx().GetHash().ToString(), limitDescendantCount);\n+        } else if (pool.GetEntry(stageit).GetCountWithDescendants() + 1 > limitDescendantCount) {\n+            errString = strprintf(\"too many descendants for tx %s [limit: %u]\", pool.GetEntry(stageit).GetTx().GetHash().ToString(), limitDescendantCount);\n             return false;\n         } else if (totalSizeWithAncestors > limitAncestorSize) {\n             errString = strprintf(\"exceeds ancestor size limit [limit: %u]\", limitAncestorSize);\n@@ -220,9 +220,9 @@ static void UpdateAncestorsOf(CTxMemPool& pool, bool add, CTxMemPool::txiter it,\n         pool.UpdateChild(piter, it, add);\n     }\n     const int64_t updateCount = (add ? 1 : -1);\n-    const int64_t updateSize = updateCount * it->GetTxSize();\n-    const CAmount updateFee = updateCount * it->GetModifiedFee();\n-    for (CTxMemPool::txiter ancestorIt : setAncestors) {\n+    const int64_t updateSize = updateCount * pool.GetEntry(it).GetTxSize();\n+    const CAmount updateFee = updateCount * pool.GetEntry(it).GetModifiedFee();\n+    for (const auto& ancestorIt : setAncestors) {\n         pool.Modify(ancestorIt, update_descendant_state(updateSize, updateFee, updateCount));\n     }\n }\n@@ -238,10 +238,10 @@ static void UpdateEntryForAncestors(CTxMemPool& pool, CTxMemPool::txiter it, con\n     int64_t updateSize = 0;\n     CAmount updateFee = 0;\n     int64_t updateSigOpsCost = 0;\n-    for (CTxMemPool::txiter ancestorIt : setAncestors) {\n-        updateSize += ancestorIt->GetTxSize();\n-        updateFee += ancestorIt->GetModifiedFee();\n-        updateSigOpsCost += ancestorIt->GetSigOpCost();\n+    for (const auto& ancestorIt : setAncestors) {\n+        updateSize += pool.GetEntry(ancestorIt).GetTxSize();\n+        updateFee += pool.GetEntry(ancestorIt).GetModifiedFee();\n+        updateSigOpsCost += pool.GetEntry(ancestorIt).GetSigOpCost();\n     }\n     pool.Modify(it, update_ancestor_state(updateSize, updateFee, updateCount, updateSigOpsCost));\n }\n@@ -254,7 +254,7 @@ void CTxMemPool::UpdateEntryForAncestors(txiter it, const setEntries& setAncesto\n static void UpdateChildrenForRemoval(CTxMemPool& pool, CTxMemPool::txiter it) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n {\n     const auto& setMemPoolChildren = pool.GetMemPoolChildren(it);\n-    for (CTxMemPool::txiter updateIt : setMemPoolChildren) {\n+    for (const auto& updateIt : setMemPoolChildren) {\n         pool.UpdateParent(updateIt, it, false);\n     }\n }\n@@ -276,19 +276,19 @@ static void UpdateForRemoveFromMempool(CTxMemPool& pool, const CTxMemPool::setEn\n         // Here we only update statistics and not data in mapLinks (which\n         // we need to preserve until we're finished with all operations that\n         // need to traverse the mempool).\n-        for (CTxMemPool::txiter removeIt : entriesToRemove) {\n+        for (const auto& removeIt : entriesToRemove) {\n             CTxMemPool::setEntries setDescendants;\n             pool.CalculateDescendants(removeIt, setDescendants);\n             setDescendants.erase(removeIt); // don't update state for self\n-            int64_t modifySize = -((int64_t)removeIt->GetTxSize());\n-            CAmount modifyFee = -removeIt->GetModifiedFee();\n-            int modifySigOps = -removeIt->GetSigOpCost();\n-            for (CTxMemPool::txiter dit : setDescendants) {\n+            int64_t modifySize = -((int64_t)pool.GetEntry(removeIt).GetTxSize());\n+            CAmount modifyFee = -pool.GetEntry(removeIt).GetModifiedFee();\n+            int modifySigOps = -pool.GetEntry(removeIt).GetSigOpCost();\n+            for (const auto& dit : setDescendants) {\n                 pool.Modify(dit, update_ancestor_state(modifySize, modifyFee, -1, modifySigOps));\n             }\n         }\n     }\n-    for (CTxMemPool::txiter removeIt : entriesToRemove) {\n+    for (const auto& removeIt : entriesToRemove) {\n         CTxMemPool::setEntries setAncestors;\n         std::string dummy;\n         // Since this is a tx that is already in the mempool, we can call CMPA\n@@ -316,7 +316,7 @@ static void UpdateForRemoveFromMempool(CTxMemPool& pool, const CTxMemPool::setEn\n     // After updating all the ancestor sizes, we can now sever the link between each\n     // transaction being removed and any mempool children (ie, update setMemPoolParents\n     // for each direct child of a transaction being removed).\n-    for (CTxMemPool::txiter removeIt : entriesToRemove) {\n+    for (const auto& removeIt : entriesToRemove) {\n         pool.UpdateChildrenForRemoval(removeIt);\n     }\n }\n@@ -391,7 +391,7 @@ static CTxMemPool::txiter addUnchecked(CTxMemPool& pool, const CTxMemPoolEntry&\n     // (When we update the entry for in-mempool parents, memory usage will be\n     // further updated.)\n \n-    const CTransaction& tx = newit->GetTx();\n+    const CTransaction& tx = pool.GetEntry(newit).GetTx();\n     std::set<uint256> setParentTransactions;\n     for (unsigned int i = 0; i < tx.vin.size(); i++) {\n         pool.InsertNextTx(std::make_pair(&tx.vin[i].prevout, &tx));\n@@ -434,7 +434,7 @@ void CTxMemPool::addUnchecked(const CTxMemPoolEntry& entry, const setEntries& se\n \n static void removeUnchecked(CTxMemPool& pool, CTxMemPool::txiter it, MemPoolRemovalReason reason) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n {\n-    for (const CTxIn& txin : it->GetTx().vin)\n+    for (const CTxIn& txin : pool.GetEntry(it).GetTx().vin)\n         pool.EraseNextTx(txin.prevout);\n \n     pool.EraseLinks(it);\n@@ -481,7 +481,7 @@ static void CalculateDescendants(const CTxMemPool& pool, const CTxMemPool::txite\n     // accounted for in setDescendants already (because those children have either\n     // already been walked, or will be walked in this iteration).\n     while (!stage.empty()) {\n-        CTxMemPool::txiter it = *stage.begin();\n+        const auto it = *stage.begin();\n         setDescendants.insert(it);\n         stage.erase(it);\n "
      },
      {
        "sha": "eb741813970ccf0a0f083967417df070e5a24308",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 8,
        "deletions": 5,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/19c277055cfeac9aa817b42b476de44f51831865/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/19c277055cfeac9aa817b42b476de44f51831865/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=19c277055cfeac9aa817b42b476de44f51831865",
        "patch": "@@ -445,7 +445,7 @@ class CTxMemPool\n private:\n     uint32_t nCheckFrequency GUARDED_BY(cs); //!< Value n means that n times in 2^32 we check.\n     std::atomic<unsigned int> nTransactionsUpdated; //!< Used by getblocktemplate to trigger CreateNewBlock() invocation\n-    CBlockPolicyEstimator* minerPolicyEstimator;\n+    CBlockPolicyEstimator* const minerPolicyEstimator;\n \n     uint64_t totalTxSize;      //!< sum of all mempool tx's virtual sizes. Differs from serialized tx size since witness data is discounted. Defined in BIP 141.\n     uint64_t cachedInnerUsage; //!< sum of dynamic memory usage of all the map elements (NOT the maps themselves)\n@@ -606,6 +606,9 @@ class CTxMemPool\n     /** Translate a set of hashes into a set of pool iterators to avoid repeated lookups */\n     setEntries GetIterSet(const std::set<uint256>& hashes) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n+    /** Dereference the txiter */\n+    static const CTxMemPoolEntry& GetEntry(txiter it) { return *it; }\n+\n     /** Remove a set of transactions from the mempool.\n      *  If a transaction is in this set, then all in-mempool descendants must\n      *  also be in the set, unless this transaction is being removed for being\n@@ -725,16 +728,16 @@ class CTxMemPool\n      *  same transaction again, if encountered in another transaction chain.\n      */\n     void UpdateForDescendants(txiter updateIt,\n-            cacheMap &cachedDescendants,\n-            const std::set<uint256> &setExclude) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+        cacheMap& cachedDescendants,\n+        const std::set<uint256>& setExclude) EXCLUSIVE_LOCKS_REQUIRED(cs);\n     /** Update ancestors of hash to add/remove it as a descendant transaction. */\n     void UpdateAncestorsOf(bool add, txiter hash, const setEntries& setAncestors) EXCLUSIVE_LOCKS_REQUIRED(cs);\n     /** Set ancestor state for an entry */\n-    void UpdateEntryForAncestors(txiter it, const setEntries &setAncestors) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    void UpdateEntryForAncestors(txiter it, const setEntries& setAncestors) EXCLUSIVE_LOCKS_REQUIRED(cs);\n     /** For each transaction being removed, update ancestors and any direct children.\n       * If updateDescendants is true, then also update in-mempool descendants'\n       * ancestor state. */\n-    void UpdateForRemoveFromMempool(const setEntries &entriesToRemove, bool updateDescendants) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    void UpdateForRemoveFromMempool(const setEntries& entriesToRemove, bool updateDescendants) EXCLUSIVE_LOCKS_REQUIRED(cs);\n     /** Sever link between specified transaction and direct children. */\n     void UpdateChildrenForRemoval(txiter entry) EXCLUSIVE_LOCKS_REQUIRED(cs);\n "
      },
      {
        "sha": "414d36100cda6397b5c9a78acc1429c6e8bf8981",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 22,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/19c277055cfeac9aa817b42b476de44f51831865/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/19c277055cfeac9aa817b42b476de44f51831865/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=19c277055cfeac9aa817b42b476de44f51831865",
        "patch": "@@ -357,12 +357,12 @@ static void UpdateMempoolForReorg(DisconnectedBlockTransactions& disconnectpool,\n         // ignore validation errors in resurrected transactions\n         CValidationState stateDummy;\n         if (!fAddToMempool || (*it)->IsCoinBase() ||\n-            !AcceptToMemoryPool(mempool, stateDummy, *it, nullptr /* pfMissingInputs */,\n-                                nullptr /* plTxnReplaced */, true /* bypass_limits */, 0 /* nAbsurdFee */)) {\n+            !AcceptToMemoryPool(::mempool, stateDummy, *it, nullptr /* pfMissingInputs */,\n+                nullptr /* plTxnReplaced */, true /* bypass_limits */, 0 /* nAbsurdFee */)) {\n             // If the transaction doesn't make it in to the mempool, remove any\n             // transactions that depend on it (which would now be orphans).\n-            mempool.removeRecursive(**it, MemPoolRemovalReason::REORG);\n-        } else if (mempool.exists((*it)->GetHash())) {\n+            ::mempool.removeRecursive(**it, MemPoolRemovalReason::REORG);\n+        } else if (::mempool.exists((*it)->GetHash())) {\n             vHashUpdate.push_back((*it)->GetHash());\n         }\n         ++it;\n@@ -373,12 +373,12 @@ static void UpdateMempoolForReorg(DisconnectedBlockTransactions& disconnectpool,\n     // previously-confirmed transactions back to the mempool.\n     // UpdateTransactionsFromBlock finds descendants of any transactions in\n     // the disconnectpool that were added back and cleans up the mempool state.\n-    mempool.UpdateTransactionsFromBlock(vHashUpdate);\n+    ::mempool.UpdateTransactionsFromBlock(vHashUpdate);\n \n     // We also need to remove any now-immature transactions\n-    mempool.removeForReorg(pcoinsTip.get(), ::ChainActive().Tip()->nHeight + 1, STANDARD_LOCKTIME_VERIFY_FLAGS);\n+    ::mempool.removeForReorg(pcoinsTip.get(), ::ChainActive().Tip()->nHeight + 1, STANDARD_LOCKTIME_VERIFY_FLAGS);\n     // Re-limit mempool size, in case we added any transactions\n-    LimitMempoolSize(mempool, gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, gArgs.GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n+    LimitMempoolSize(::mempool, gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, gArgs.GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n }\n \n // Used to avoid mempool polluting consensus critical paths if CCoinsViewMempool\n@@ -618,9 +618,8 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         // that we have the set of all ancestors we can detect this\n         // pathological case by making sure setConflicts and setAncestors don't\n         // intersect.\n-        for (CTxMemPool::txiter ancestorIt : setAncestors)\n-        {\n-            const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n+        for (const auto& ancestorIt : setAncestors) {\n+            const uint256 hashAncestor = pool.GetEntry(ancestorIt).GetTx().GetHash();\n             if (setConflicts.count(hashAncestor))\n             {\n                 return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-spends-conflicting-tx\",\n@@ -662,7 +661,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 // mean high feerate children are ignored when deciding whether\n                 // or not to replace, we do require the replacement to pay more\n                 // overall fees too, mitigating most cases.\n-                CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n+                CFeeRate oldFeeRate(pool.GetEntry(mi).GetModifiedFee(), pool.GetEntry(mi).GetTxSize());\n                 if (newFeeRate <= oldFeeRate)\n                 {\n                     return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n@@ -672,25 +671,24 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                                   oldFeeRate.ToString()));\n                 }\n \n-                for (const CTxIn &txin : mi->GetTx().vin)\n-                {\n+                for (const CTxIn& txin : pool.GetEntry(mi).GetTx().vin) {\n                     setConflictsParents.insert(txin.prevout.hash);\n                 }\n \n-                nConflictingCount += mi->GetCountWithDescendants();\n+                nConflictingCount += pool.GetEntry(mi).GetCountWithDescendants();\n             }\n             // This potentially overestimates the number of actual descendants\n             // but we just want to be conservative to avoid doing too much\n             // work.\n             if (nConflictingCount <= maxDescendantsToVisit) {\n                 // If not too many to replace, then calculate the set of\n                 // transactions that would have to be evicted\n-                for (CTxMemPool::txiter it : setIterConflicting) {\n+                for (const auto& it : setIterConflicting) {\n                     pool.CalculateDescendants(it, allConflicting);\n                 }\n-                for (CTxMemPool::txiter it : allConflicting) {\n-                    nConflictingFees += it->GetModifiedFee();\n-                    nConflictingSize += it->GetTxSize();\n+                for (const auto& it : allConflicting) {\n+                    nConflictingFees += pool.GetEntry(it).GetModifiedFee();\n+                    nConflictingSize += pool.GetEntry(it).GetTxSize();\n                 }\n             } else {\n                 return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too many potential replacements\",\n@@ -789,15 +787,14 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         }\n \n         // Remove conflicting transactions from the mempool\n-        for (CTxMemPool::txiter it : allConflicting)\n-        {\n+        for (const auto& it : allConflicting) {\n             LogPrint(BCLog::MEMPOOL, \"replacing tx %s with %s for %s BTC additional fees, %d delta bytes\\n\",\n-                    it->GetTx().GetHash().ToString(),\n+                    pool.GetEntry(it).GetTx().GetHash().ToString(),\n                     hash.ToString(),\n                     FormatMoney(nModifiedFees - nConflictingFees),\n                     (int)nSize - (int)nConflictingSize);\n             if (plTxnReplaced)\n-                plTxnReplaced->push_back(it->GetSharedTx());\n+                plTxnReplaced->push_back(pool.GetEntry(it).GetSharedTx());\n         }\n         pool.RemoveStaged(allConflicting, false, MemPoolRemovalReason::REPLACED);\n "
      }
    ]
  },
  {
    "sha": "f57817fca0115bb7c31daea57fab40093495bda9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNTc4MTdmY2EwMTE1YmI3YzMxZGFlYTU3ZmFiNDAwOTM0OTViZGE5",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-07-11T15:12:24Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-07-13T17:23:27Z"
      },
      "message": "Transaction Pool Layer",
      "tree": {
        "sha": "49c866f0363cf7aadbfedc9ae93d39fbe460b7df",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/49c866f0363cf7aadbfedc9ae93d39fbe460b7df"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f57817fca0115bb7c31daea57fab40093495bda9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f57817fca0115bb7c31daea57fab40093495bda9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f57817fca0115bb7c31daea57fab40093495bda9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f57817fca0115bb7c31daea57fab40093495bda9/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "19c277055cfeac9aa817b42b476de44f51831865",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/19c277055cfeac9aa817b42b476de44f51831865",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/19c277055cfeac9aa817b42b476de44f51831865"
      }
    ],
    "stats": {
      "total": 386,
      "additions": 352,
      "deletions": 34
    },
    "files": [
      {
        "sha": "4fc30f259640494363970f70507731ba23b35469",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 226,
        "deletions": 20,
        "changes": 246,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f57817fca0115bb7c31daea57fab40093495bda9/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f57817fca0115bb7c31daea57fab40093495bda9/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=f57817fca0115bb7c31daea57fab40093495bda9",
        "patch": "@@ -145,9 +145,10 @@ void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<uint256> &vHashes\n     }\n }\n \n-static bool CalculateMemPoolAncestors(const CTxMemPool& pool, CTxMemPool::txiter it, CTxMemPool::setEntries& setAncestors, uint64_t limitAncestorCount, uint64_t limitAncestorSize, uint64_t limitDescendantCount, uint64_t limitDescendantSize, std::string& errString, const CTxMemPoolEntry* search_parents_for_entry) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n+template <typename P>\n+static bool CalculateMemPoolAncestors(const P& pool, typename P::txiter it, typename P::setEntries& setAncestors, uint64_t limitAncestorCount, uint64_t limitAncestorSize, uint64_t limitDescendantCount, uint64_t limitDescendantSize, std::string& errString, const CTxMemPoolEntry* search_parents_for_entry) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n {\n-    CTxMemPool::setEntries parentHashes;\n+    typename P::setEntries parentHashes;\n     const CTxMemPoolEntry& entry = search_parents_for_entry ? *search_parents_for_entry : pool.GetEntry(it);\n     const CTransaction &tx = entry.GetTx();\n \n@@ -156,7 +157,7 @@ static bool CalculateMemPoolAncestors(const CTxMemPool& pool, CTxMemPool::txiter\n         // GetMemPoolParents() is only valid for entries in the mempool, so we\n         // iterate mapTx to find parents.\n         for (unsigned int i = 0; i < tx.vin.size(); i++) {\n-            boost::optional<CTxMemPool::txiter> piter = pool.GetIter(tx.vin[i].prevout.hash);\n+            boost::optional<typename P::txiter> piter = pool.GetIter(tx.vin[i].prevout.hash);\n             if (piter) {\n                 parentHashes.insert(*piter);\n                 if (parentHashes.size() + 1 > limitAncestorCount) {\n@@ -212,7 +213,13 @@ bool CTxMemPool::CalculateMemPoolAncestors(txiter it, setEntries& setAncestors,\n     return ::CalculateMemPoolAncestors(*this, it, setAncestors, limitAncestorCount, limitAncestorSize, limitDescendantCount, limitDescendantSize, errString, search_parents_for_entry);\n }\n \n-static void UpdateAncestorsOf(CTxMemPool& pool, bool add, CTxMemPool::txiter it, const CTxMemPool::setEntries& setAncestors) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n+bool TxPoolLayer::CalculateMemPoolAncestors(txiter it, setEntries& setAncestors, uint64_t limitAncestorCount, uint64_t limitAncestorSize, uint64_t limitDescendantCount, uint64_t limitDescendantSize, std::string& errString, const CTxMemPoolEntry* search_parents_for_entry)\n+{\n+    return ::CalculateMemPoolAncestors(*this, it, setAncestors, limitAncestorCount, limitAncestorSize, limitDescendantCount, limitDescendantSize, errString, search_parents_for_entry);\n+}\n+\n+template <typename P>\n+static void UpdateAncestorsOf(P& pool, bool add, typename P::txiter it, const typename P::setEntries& setAncestors) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n {\n     auto parentIters = pool.GetMemPoolParents(it);\n     // add or remove this tx as a child of each parent\n@@ -231,8 +238,13 @@ void CTxMemPool::UpdateAncestorsOf(bool add, txiter it, const setEntries& setAnc\n {\n     return ::UpdateAncestorsOf(*this, add, it, setAncestors);\n }\n+void TxPoolLayer::UpdateAncestorsOf(bool add, const TxPoolLayer::txiter& it, const setEntries& setAncestors)\n+{\n+    return ::UpdateAncestorsOf(*this, add, it, setAncestors);\n+}\n \n-static void UpdateEntryForAncestors(CTxMemPool& pool, CTxMemPool::txiter it, const CTxMemPool::setEntries& setAncestors) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n+template <typename P>\n+static void UpdateEntryForAncestors(P& pool, typename P::txiter it, const typename P::setEntries& setAncestors) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n {\n     int64_t updateCount = setAncestors.size();\n     int64_t updateSize = 0;\n@@ -250,8 +262,13 @@ void CTxMemPool::UpdateEntryForAncestors(txiter it, const setEntries& setAncesto\n {\n     return ::UpdateEntryForAncestors(*this, it, setAncestors);\n }\n+void TxPoolLayer::UpdateEntryForAncestors(const TxPoolLayer::txiter& it, const setEntries& setAncestors)\n+{\n+    return ::UpdateEntryForAncestors(*this, it, setAncestors);\n+}\n \n-static void UpdateChildrenForRemoval(CTxMemPool& pool, CTxMemPool::txiter it) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n+template <typename P>\n+static void UpdateChildrenForRemoval(P& pool, typename P::txiter it) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n {\n     const auto& setMemPoolChildren = pool.GetMemPoolChildren(it);\n     for (const auto& updateIt : setMemPoolChildren) {\n@@ -264,7 +281,13 @@ void CTxMemPool::UpdateChildrenForRemoval(txiter it)\n     return ::UpdateChildrenForRemoval(*this, it);\n }\n \n-static void UpdateForRemoveFromMempool(CTxMemPool& pool, const CTxMemPool::setEntries& entriesToRemove, bool updateDescendants) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n+void TxPoolLayer::UpdateChildrenForRemoval(txiter it)\n+{\n+    return ::UpdateChildrenForRemoval(*this, it);\n+}\n+\n+template <typename P>\n+static void UpdateForRemoveFromMempool(P& pool, const typename P::setEntries& entriesToRemove, bool updateDescendants) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n {\n     // For each entry, walk back all ancestors and decrement size associated with this\n     // transaction\n@@ -277,7 +300,7 @@ static void UpdateForRemoveFromMempool(CTxMemPool& pool, const CTxMemPool::setEn\n         // we need to preserve until we're finished with all operations that\n         // need to traverse the mempool).\n         for (const auto& removeIt : entriesToRemove) {\n-            CTxMemPool::setEntries setDescendants;\n+            typename P::setEntries setDescendants;\n             pool.CalculateDescendants(removeIt, setDescendants);\n             setDescendants.erase(removeIt); // don't update state for self\n             int64_t modifySize = -((int64_t)pool.GetEntry(removeIt).GetTxSize());\n@@ -289,7 +312,7 @@ static void UpdateForRemoveFromMempool(CTxMemPool& pool, const CTxMemPool::setEn\n         }\n     }\n     for (const auto& removeIt : entriesToRemove) {\n-        CTxMemPool::setEntries setAncestors;\n+        typename P::setEntries setAncestors;\n         std::string dummy;\n         // Since this is a tx that is already in the mempool, we can call CMPA\n         // with fSearchForParents = false.  If the mempool is in a consistent\n@@ -325,6 +348,10 @@ void CTxMemPool::UpdateForRemoveFromMempool(const setEntries& entriesToRemove, b\n     return ::UpdateForRemoveFromMempool(*this, entriesToRemove, updateDescendants);\n }\n \n+void TxPoolLayer::UpdateForRemoveFromMempool(const setEntries& entriesToRemove, bool updateDescendants)\n+{\n+    return ::UpdateForRemoveFromMempool(*this, entriesToRemove, updateDescendants);\n+}\n void CTxMemPoolEntry::UpdateDescendantState(int64_t modifySize, CAmount modifyFee, int64_t modifyCount)\n {\n     nSizeWithDescendants += modifySize;\n@@ -372,7 +399,8 @@ void CTxMemPool::AddTransactionsUpdated(unsigned int n)\n     nTransactionsUpdated += n;\n }\n \n-static CTxMemPool::txiter addUnchecked(CTxMemPool& pool, const CTxMemPoolEntry& entry, const CTxMemPool::setEntries& setAncestors) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n+template <typename P>\n+static typename P::txiter addUnchecked(P& pool, const CTxMemPoolEntry& entry, const typename P::setEntries& setAncestors) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n {\n     // Add to memory pool without checking anything.\n     // Used by AcceptToMemoryPool(), which DOES do\n@@ -432,7 +460,13 @@ void CTxMemPool::addUnchecked(const CTxMemPoolEntry& entry, const setEntries& se\n     newit->vTxHashesIdx = vTxHashes.size() - 1;\n }\n \n-static void removeUnchecked(CTxMemPool& pool, CTxMemPool::txiter it, MemPoolRemovalReason reason) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n+void TxPoolLayer::addUnchecked(const CTxMemPoolEntry& entry, const TxPoolLayer::setEntries& setAncestors, bool /* validFeeEstimate */)\n+{\n+    ::addUnchecked(*this, entry, setAncestors);\n+}\n+\n+template <typename P>\n+static void removeUnchecked(P& pool, typename P::txiter it, MemPoolRemovalReason) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n {\n     for (const CTxIn& txin : pool.GetEntry(it).GetTx().vin)\n         pool.EraseNextTx(txin.prevout);\n@@ -465,15 +499,22 @@ void CTxMemPool::removeUnchecked(txiter it, MemPoolRemovalReason reason)\n     if (minerPolicyEstimator) {minerPolicyEstimator->removeTx(hash, false);}\n }\n \n+void TxPoolLayer::removeUnchecked(txiter it, MemPoolRemovalReason reason)\n+{\n+    ::removeUnchecked(*this, it, reason);\n+}\n+\n+\n // Calculates descendants of entry that are not already in setDescendants, and adds to\n // setDescendants. Assumes entryit is already a tx in the mempool and setMemPoolChildren\n // is correct for tx and all descendants.\n // Also assumes that if an entry is in setDescendants already, then all\n // in-mempool descendants of it are already in setDescendants as well, so that we\n // can save time by not iterating over those entries.\n-static void CalculateDescendants(const CTxMemPool& pool, const CTxMemPool::txiter& entryit, CTxMemPool::setEntries& setDescendants) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n+template <typename P>\n+static void CalculateDescendants(const P& pool, const typename P::txiter& entryit, typename P::setEntries& setDescendants) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n {\n-    CTxMemPool::setEntries stage;\n+    typename P::setEntries stage;\n     if (setDescendants.count(entryit) == 0) {\n         stage.insert(entryit);\n     }\n@@ -499,6 +540,12 @@ void CTxMemPool::CalculateDescendants(txiter entryit, setEntries& setDescendants\n     return ::CalculateDescendants(*this, entryit, setDescendants);\n }\n \n+void TxPoolLayer::CalculateDescendants(const TxPoolLayer::txiter& entryit, TxPoolLayer::setEntries& setDescendants)\n+{\n+    return ::CalculateDescendants(*this, entryit, setDescendants);\n+}\n+\n+\n void CTxMemPool::removeRecursive(const CTransaction &origTx, MemPoolRemovalReason reason)\n {\n     // Remove transaction from memory pool\n@@ -844,6 +891,14 @@ CTransactionRef CTxMemPool::get(const uint256& hash) const\n     return i->GetSharedTx();\n }\n \n+CTransactionRef TxPoolLayer::get(const uint256& hash) const\n+{\n+    auto it = m_cache_added.find(hash);\n+    if (it != m_cache_added.end()) return it->GetSharedTx();\n+    if (m_cache_removed.find(hash) != m_cache_removed.end()) return nullptr;\n+    return m_tx_pool.get(hash);\n+}\n+\n TxMempoolInfo CTxMemPool::info(const uint256& hash) const\n {\n     LOCK(cs);\n@@ -853,6 +908,33 @@ TxMempoolInfo CTxMemPool::info(const uint256& hash) const\n     return GetInfo(i);\n }\n \n+bool TxPoolLayer::exists(const uint256& hash) const\n+{\n+    if (m_cache_added.find(hash) != m_cache_added.end()) return true;\n+    if (m_cache_removed.find(hash) != m_cache_removed.end()) return false;\n+    return m_tx_pool.exists(hash);\n+}\n+\n+const CTxMemPoolEntry& TxPoolLayer::GetEntry(const TxPoolLayer::txiter& it)\n+{\n+    if (it.which() == 0) return *boost::get<txiter_nested>(it)._i;\n+    return CTxMemPool::GetEntry(boost::get<CTxMemPool::txiter>(it));\n+}\n+\n+void TxPoolLayer::EraseTx(TxPoolLayer::txiter it)\n+{\n+    if (it.which() == 0) {\n+        const uint256& hash{GetEntry(it).GetTx().GetHash()};\n+        if (m_tx_pool.exists(hash)) {\n+            // likely the tx exists in both layers because of modified fees, so mark it erased in the outer layer\n+            m_cache_removed.emplace(hash);\n+        }\n+        m_cache_added.erase(boost::get<txiter_nested>(it)._i);\n+    } else {\n+        m_cache_removed.emplace(GetEntry(it).GetTx().GetHash());\n+    }\n+}\n+\n void CTxMemPool::PrioritiseTransaction(const uint256& hash, const CAmount& nFeeDelta)\n {\n     {\n@@ -892,6 +974,10 @@ void CTxMemPool::ApplyDelta(const uint256 hash, CAmount &nFeeDelta) const\n     const CAmount &delta = pos->second;\n     nFeeDelta += delta;\n }\n+void TxPoolLayer::ApplyDelta(const uint256& hash, CAmount& fee_delta) const\n+{\n+    return m_tx_pool.ApplyDelta(hash, fee_delta);\n+}\n \n void CTxMemPool::ClearPrioritisation(const uint256 hash)\n {\n@@ -905,16 +991,42 @@ const CTransaction* CTxMemPool::GetConflictTx(const COutPoint& prevout) const\n     return it == mapNextTx.end() ? nullptr : it->second;\n }\n \n+const CTransaction* TxPoolLayer::GetConflictTx(const COutPoint& prevout) const\n+{\n+    auto it_add = m_map_next_tx_added.find(prevout);\n+    if (it_add != m_map_next_tx_added.end()) return it_add->second;\n+    if (m_map_next_tx_removed.find(prevout) != m_map_next_tx_removed.end()) return nullptr;\n+\n+    return m_tx_pool.GetConflictTx(prevout);\n+}\n+\n boost::optional<CTxMemPool::txiter> CTxMemPool::GetIter(const uint256& txid) const\n {\n     auto it = mapTx.find(txid);\n     if (it != mapTx.end()) return it;\n     return boost::optional<txiter>{};\n }\n \n-static CTxMemPool::setEntries GetIterSet(const CTxMemPool& pool, const std::set<uint256>& hashes) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n+boost::optional<TxPoolLayer::txiter> TxPoolLayer::GetIter(const uint256& txid) const\n+{\n+    const auto& it_cache = m_cache_added.find(txid);\n+    if (it_cache != m_cache_added.end()) {\n+        return TxPoolLayer::txiter{it_cache};\n+    }\n+    if (m_cache_removed.find(txid) != m_cache_removed.end()) {\n+        return boost::optional<TxPoolLayer::txiter>{};\n+    }\n+\n+    // Nothing found in the cache, fall back to the inner layer:\n+    const auto it_inner = m_tx_pool.GetIter(txid);\n+    if (it_inner) return TxPoolLayer::txiter{*it_inner};\n+    return boost::optional<TxPoolLayer::txiter>{};\n+}\n+\n+template <typename P>\n+static typename P::setEntries GetIterSet(const P& pool, const std::set<uint256>& hashes) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n {\n-    CTxMemPool::setEntries ret;\n+    typename P::setEntries ret;\n     for (const auto& h : hashes) {\n         const auto mi = pool.GetIter(h);\n         if (mi) ret.insert(*mi);\n@@ -926,14 +1038,31 @@ CTxMemPool::setEntries CTxMemPool::GetIterSet(const std::set<uint256>& hashes) c\n {\n     return ::GetIterSet(*this, hashes);\n }\n+TxPoolLayer::setEntries TxPoolLayer::GetIterSet(const std::set<uint256>& hashes) const\n+{\n+    return ::GetIterSet(*this, hashes);\n+}\n \n template <typename UpdateStruct>\n void CTxMemPool::Modify(txiter it, const UpdateStruct& update_object)\n {\n     mapTx.modify(it, update_object);\n }\n \n-static bool HasNoInputsOf(const CTxMemPool& pool, const CTransaction& tx) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n+template <typename UpdateStruct>\n+void TxPoolLayer::Modify(txiter it, const UpdateStruct& update_object)\n+{\n+    if (it.which() == 0) {\n+        m_cache_added.modify(boost::get<txiter_nested>(it)._i, update_object);\n+    } else {\n+        const CTxMemPoolEntry& e{*boost::get<CTxMemPool::txiter>(it)};\n+        txiter it_added = Insert(e).first;\n+        m_cache_added.modify(boost::get<txiter_nested>(it_added)._i, update_object);\n+    }\n+}\n+\n+template <typename P>\n+static bool HasNoInputsOf(const P& pool, const CTransaction& tx) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n {\n     for (unsigned int i = 0; i < tx.vin.size(); i++)\n         if (pool.exists(tx.vin[i].prevout.hash))\n@@ -946,6 +1075,11 @@ bool CTxMemPool::HasNoInputsOf(const CTransaction& tx) const\n     return ::HasNoInputsOf(*this, tx);\n }\n \n+bool TxPoolLayer::HasNoInputsOf(const CTransaction& tx) const\n+{\n+    return ::HasNoInputsOf(*this, tx);\n+}\n+\n template <typename P>\n bool CoinsViewMemPool<P>::GetCoin(const COutPoint& outpoint, Coin& coin) const\n {\n@@ -964,14 +1098,16 @@ bool CoinsViewMemPool<P>::GetCoin(const COutPoint& outpoint, Coin& coin) const\n     return base->GetCoin(outpoint, coin);\n }\n template bool CoinsViewMemPool<CTxMemPool>::GetCoin(const COutPoint& outpoint, Coin& coin) const;\n+template bool CoinsViewMemPool<TxPoolLayer>::GetCoin(const COutPoint& outpoint, Coin& coin) const;\n \n size_t CTxMemPool::DynamicMemoryUsage() const {\n     LOCK(cs);\n     // Estimate the overhead of mapTx to be 12 pointers + an allocation, as no exact formula for boost::multi_index_contained is implemented.\n     return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 12 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + memusage::DynamicUsage(mapLinks) + memusage::DynamicUsage(vTxHashes) + cachedInnerUsage;\n }\n \n-static void RemoveStaged(CTxMemPool& pool, CTxMemPool::setEntries& stage, bool updateDescendants, MemPoolRemovalReason reason) EXCLUSIVE_LOCKS_REQUIRED(pool.cs) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n+template <typename P>\n+static void RemoveStaged(P& pool, typename P::setEntries& stage, bool updateDescendants, MemPoolRemovalReason reason) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n {\n     AssertLockHeld(pool.cs);\n     pool.UpdateForRemoveFromMempool(stage, updateDescendants);\n@@ -984,6 +1120,10 @@ void CTxMemPool::RemoveStaged(setEntries& stage, bool updateDescendants, MemPool\n {\n     return ::RemoveStaged(*this, stage, updateDescendants, reason);\n }\n+void TxPoolLayer::RemoveStaged(setEntries& stage, bool updateDescendants, MemPoolRemovalReason reason)\n+{\n+    return ::RemoveStaged(*this, stage, updateDescendants, reason);\n+}\n \n int CTxMemPool::Expire(int64_t time) {\n     AssertLockHeld(cs);\n@@ -1000,13 +1140,20 @@ int CTxMemPool::Expire(int64_t time) {\n     RemoveStaged(stage, false, MemPoolRemovalReason::EXPIRY);\n     return stage.size();\n }\n+int TxPoolLayer::Expire(int64_t /* time */)\n+{\n+    // The Layer is currently assumed to be very short lived (see comment on Layer::cs)\n+    // So assume this would very rarely have an effect and skip it\n+    return 0;\n+}\n \n-static void addUnchecked(CTxMemPool& pool, const CTxMemPoolEntry& entry, bool validFeeEstimate) EXCLUSIVE_LOCKS_REQUIRED(pool.cs, cs_main)\n+template <typename P>\n+static void addUnchecked(P& pool, const CTxMemPoolEntry& entry, bool validFeeEstimate) EXCLUSIVE_LOCKS_REQUIRED(pool.cs, cs_main)\n {\n-    CTxMemPool::setEntries setAncestors;\n+    typename P::setEntries setAncestors;\n     uint64_t nNoLimit = std::numeric_limits<uint64_t>::max();\n     std::string dummy;\n-    pool.CalculateMemPoolAncestors(CTxMemPool::txiter{}, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy, /* search_parents_for_entry */ &entry);\n+    pool.CalculateMemPoolAncestors(typename P::txiter{}, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy, /* search_parents_for_entry */ &entry);\n     return pool.addUnchecked(entry, setAncestors, validFeeEstimate);\n }\n \n@@ -1015,6 +1162,11 @@ void CTxMemPool::addUnchecked(const CTxMemPoolEntry& entry, bool validFeeEstimat\n     return ::addUnchecked(*this, entry, validFeeEstimate);\n }\n \n+void TxPoolLayer::addUnchecked(const CTxMemPoolEntry& entry, bool validFeeEstimate)\n+{\n+    return ::addUnchecked(*this, entry, validFeeEstimate);\n+}\n+\n void CTxMemPool::UpdateChild(txiter entry, txiter child, bool add)\n {\n     setEntries s;\n@@ -1025,6 +1177,15 @@ void CTxMemPool::UpdateChild(txiter entry, txiter child, bool add)\n     }\n }\n \n+void TxPoolLayer::UpdateChild(const TxPoolLayer::txiter& entry, const TxPoolLayer::txiter& child, bool add)\n+{\n+    if (add) {\n+        m_cache_map_links[entry].children.insert(child);\n+    } else {\n+        m_cache_map_links[entry].children.erase(child);\n+    }\n+}\n+\n void CTxMemPool::UpdateParent(txiter entry, txiter parent, bool add)\n {\n     setEntries s;\n@@ -1035,6 +1196,15 @@ void CTxMemPool::UpdateParent(txiter entry, txiter parent, bool add)\n     }\n }\n \n+void TxPoolLayer::UpdateParent(const TxPoolLayer::txiter& entry, const TxPoolLayer::txiter& parent, bool add)\n+{\n+    if (add) {\n+        m_cache_map_links[entry].parents.insert(parent);\n+    } else {\n+        m_cache_map_links[entry].parents.erase(parent);\n+    }\n+}\n+\n const CTxMemPool::setEntries & CTxMemPool::GetMemPoolParents(txiter entry) const\n {\n     assert (entry != mapTx.end());\n@@ -1043,6 +1213,18 @@ const CTxMemPool::setEntries & CTxMemPool::GetMemPoolParents(txiter entry) const\n     return it->second.parents;\n }\n \n+TxPoolLayer::setEntries TxPoolLayer::GetMemPoolParents(const TxPoolLayer::txiter& entry) const\n+{\n+    const auto it = m_cache_map_links.find(entry);\n+    if (it != m_cache_map_links.end()) return it->second.parents;\n+\n+    TxPoolLayer::setEntries ret;\n+    for (const auto& parent : m_tx_pool.GetMemPoolParents(boost::get<CTxMemPool::txiter>(entry))) {\n+        ret.emplace(parent);\n+    }\n+    return ret;\n+}\n+\n const CTxMemPool::setEntries & CTxMemPool::GetMemPoolChildren(txiter entry) const\n {\n     assert (entry != mapTx.end());\n@@ -1051,6 +1233,18 @@ const CTxMemPool::setEntries & CTxMemPool::GetMemPoolChildren(txiter entry) cons\n     return it->second.children;\n }\n \n+TxPoolLayer::setEntries TxPoolLayer::GetMemPoolChildren(const txiter& entry) const\n+{\n+    auto it = m_cache_map_links.find(entry);\n+    if (it != m_cache_map_links.end()) return it->second.children;\n+\n+    TxPoolLayer::setEntries ret;\n+    for (const auto& child: m_tx_pool.GetMemPoolChildren(boost::get<CTxMemPool::txiter>(entry))) {\n+        ret.emplace(child);\n+    }\n+    return ret;\n+}\n+\n CFeeRate CTxMemPool::GetMinFee(size_t sizelimit) const {\n     LOCK(cs);\n     if (!blockSinceLastRollingFeeBump || rollingMinimumFeeRate == 0)\n@@ -1075,6 +1269,11 @@ CFeeRate CTxMemPool::GetMinFee(size_t sizelimit) const {\n     return std::max(CFeeRate(llround(rollingMinimumFeeRate)), incrementalRelayFee);\n }\n \n+CFeeRate TxPoolLayer::GetMinFee(size_t sizelimit) const\n+{\n+    return m_tx_pool.GetMinFee(sizelimit);\n+}\n+\n void CTxMemPool::trackPackageRemoved(const CFeeRate& rate) {\n     AssertLockHeld(cs);\n     if (rate.GetFeePerK() > rollingMinimumFeeRate) {\n@@ -1126,6 +1325,13 @@ void CTxMemPool::TrimToSize(size_t sizelimit, std::vector<COutPoint>* pvNoSpends\n     }\n }\n \n+void TxPoolLayer::TrimToSize(size_t /* sizelimit */, std::vector<COutPoint>* /* pvNoSpendsRemaining */)\n+{\n+    // The Layer has no strict size limit for now, it is the responsibility of the caller to not exceed any limits\n+    return;\n+}\n+\n+\n uint64_t CTxMemPool::CalculateDescendantMaximum(txiter entry) const {\n     // find parent with highest descendant count\n     std::vector<txiter> candidates;"
      },
      {
        "sha": "fe707c39ff8c010770bef1edbd7806db21e0d4c9",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 102,
        "deletions": 0,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f57817fca0115bb7c31daea57fab40093495bda9/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f57817fca0115bb7c31daea57fab40093495bda9/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=f57817fca0115bb7c31daea57fab40093495bda9",
        "patch": "@@ -752,6 +752,108 @@ class CTxMemPool\n     void removeUnchecked(txiter entry, MemPoolRemovalReason reason = MemPoolRemovalReason::UNKNOWN) EXCLUSIVE_LOCKS_REQUIRED(cs);\n };\n \n+class TxPoolLayer\n+{\n+public:\n+    mutable RecursiveMutex cs; //!< Dummy mutex\n+    struct txiter_nested {\n+        CTxMemPool::txiter _i;\n+        explicit txiter_nested(CTxMemPool::txiter val) : _i(val) {}\n+        txiter_nested() : _i() {}\n+    };\n+    /**\n+     * The txiter of this layer is a pair.\n+     * The first element is a const iterator of this layer's m_cache_added,\n+     * the second element is a fallback to the underlying txiter (only present when first is missing)\n+     */\n+    using txiter = boost::variant<\n+        txiter_nested, // Can always use this one, since all entries might be created in the cache??\n+        CTxMemPool::txiter>;\n+\n+    struct CompareIteratorByHash {\n+        bool operator()(const txiter& a, const txiter& b) const\n+        {\n+            return GetEntry(a).GetTx().GetHash() < GetEntry(b).GetTx().GetHash();\n+        }\n+    };\n+\n+    using setEntries = std::set<TxPoolLayer::txiter, CompareIteratorByHash>;\n+\n+    struct TxLinks {\n+        TxPoolLayer::setEntries parents;\n+        TxPoolLayer::setEntries children;\n+    };\n+    using txlinksMap = std::map<TxPoolLayer::txiter, TxPoolLayer::TxLinks, CompareIteratorByHash>;\n+    /**\n+         * Construct a Layer based on an existing tx pool.\n+         * The caller must acquire the lock for the whole life-time of this layer.\n+         */\n+    explicit TxPoolLayer(const CTxMemPool& p) EXCLUSIVE_LOCKS_REQUIRED(p.cs)\n+        : m_tx_pool(p) { AssertLockHeld(p.cs); }\n+\n+    /// Methods that have identical signatures in the underlying tx pool:\n+    bool exists(const uint256& hash) const NO_THREAD_SAFETY_ANALYSIS;\n+    boost::optional<txiter> GetIter(const uint256& txid) const NO_THREAD_SAFETY_ANALYSIS;\n+    TxPoolLayer::setEntries GetIterSet(const std::set<uint256>& hashes) const NO_THREAD_SAFETY_ANALYSIS;\n+    template <typename UpdateStruct>\n+    void Modify(txiter it, const UpdateStruct& update_object) NO_THREAD_SAFETY_ANALYSIS;\n+    std::pair<txiter, bool> Insert(const CTxMemPoolEntry& entry) NO_THREAD_SAFETY_ANALYSIS\n+    {\n+        auto ins = m_cache_added.insert(entry);\n+        assert(ins.second);\n+        return {txiter_nested{ins.first}, ins.second};\n+    }\n+    void EraseTx(TxPoolLayer::txiter it) NO_THREAD_SAFETY_ANALYSIS;\n+    void InsertLinks(txiter newit) NO_THREAD_SAFETY_ANALYSIS { m_cache_map_links.emplace(newit, TxLinks{}); }\n+    void EraseLinks(txiter it) NO_THREAD_SAFETY_ANALYSIS { m_cache_map_links.erase(it); }\n+    void InsertNextTx(std::pair<const COutPoint*, const CTransaction*> next_tx) NO_THREAD_SAFETY_ANALYSIS { m_map_next_tx_added.insert(next_tx); }\n+    void EraseNextTx(const COutPoint& out) NO_THREAD_SAFETY_ANALYSIS\n+    {\n+        m_map_next_tx_added.erase(out);\n+        m_map_next_tx_removed.emplace(out);\n+    }\n+    static const CTxMemPoolEntry& GetEntry(const TxPoolLayer::txiter& it);\n+    const CTransaction* GetConflictTx(const COutPoint& prevout) const NO_THREAD_SAFETY_ANALYSIS;\n+    CTransactionRef get(const uint256& hash) const;\n+    void ApplyDelta(const uint256& hash, CAmount& fee_delta) const NO_THREAD_SAFETY_ANALYSIS;\n+    CFeeRate GetMinFee(size_t sizelimit) const NO_THREAD_SAFETY_ANALYSIS;\n+    bool CalculateMemPoolAncestors(txiter it, TxPoolLayer::setEntries& setAncestors, uint64_t limitAncestorCount, uint64_t limitAncestorSize, uint64_t limitDescendantCount, uint64_t limitDescendantSize, std::string& errString, const CTxMemPoolEntry* search_parents_for_entry = nullptr) NO_THREAD_SAFETY_ANALYSIS;\n+    void CalculateDescendants(const TxPoolLayer::txiter& it, TxPoolLayer::setEntries& setDescendants) NO_THREAD_SAFETY_ANALYSIS;\n+    void RemoveStaged(TxPoolLayer::setEntries& stage, bool updateDescendants, MemPoolRemovalReason reason = MemPoolRemovalReason::UNKNOWN) NO_THREAD_SAFETY_ANALYSIS;\n+    bool HasNoInputsOf(const CTransaction& tx) const NO_THREAD_SAFETY_ANALYSIS;\n+    void addUnchecked(const CTxMemPoolEntry& entry, bool /* validFeeEstimate */ ignore) NO_THREAD_SAFETY_ANALYSIS;\n+    TxPoolLayer::setEntries GetMemPoolParents(const TxPoolLayer::txiter& entry) const NO_THREAD_SAFETY_ANALYSIS;\n+    int Expire(int64_t time) NO_THREAD_SAFETY_ANALYSIS;\n+    void TrimToSize(size_t sizelimit, std::vector<COutPoint>* pvNoSpendsRemaining = nullptr) NO_THREAD_SAFETY_ANALYSIS;\n+\n+    void addUnchecked(const CTxMemPoolEntry& entry, const TxPoolLayer::setEntries& setAncestors, bool /* validFeeEstimate */ ignore) NO_THREAD_SAFETY_ANALYSIS;\n+    void UpdateAncestorsOf(bool add, const TxPoolLayer::txiter& it, const setEntries& setAncestors) NO_THREAD_SAFETY_ANALYSIS;\n+    void UpdateParent(const TxPoolLayer::txiter& entry, const TxPoolLayer::txiter& parent, bool add) NO_THREAD_SAFETY_ANALYSIS;\n+    void UpdateChild(const TxPoolLayer::txiter& entry, const TxPoolLayer::txiter& child, bool add) NO_THREAD_SAFETY_ANALYSIS;\n+    void UpdateEntryForAncestors(const TxPoolLayer::txiter& it, const setEntries& setAncestors) NO_THREAD_SAFETY_ANALYSIS;\n+    void UpdateForRemoveFromMempool(const setEntries& entriesToRemove, bool updateDescendants) NO_THREAD_SAFETY_ANALYSIS;\n+    void UpdateChildrenForRemoval(txiter it) NO_THREAD_SAFETY_ANALYSIS;\n+    setEntries GetMemPoolChildren(const txiter& entry) const NO_THREAD_SAFETY_ANALYSIS;\n+    void removeUnchecked(txiter it, MemPoolRemovalReason reason) NO_THREAD_SAFETY_ANALYSIS;\n+\n+private:\n+    /** The underlying tx pool */\n+    const CTxMemPool& m_tx_pool;\n+\n+    /* The txs this layer is adding */\n+    CTxMemPool::indexed_transaction_set m_cache_added;\n+    /* The txs this layer is removing */\n+    std::set<uint256> m_cache_removed;\n+\n+    /* Tx links for txs that got their links modified */\n+    TxPoolLayer::txlinksMap m_cache_map_links;\n+\n+    /* Next txs that were added */\n+    indirectmap<COutPoint, const CTransaction*> m_map_next_tx_added;\n+    /* Next txs that were removed */\n+    std::set<COutPoint> m_map_next_tx_removed;\n+};\n+\n /**\n  * CCoinsView that brings transactions from a mempool into view.\n  * It does not check for spendings by memory pool transactions."
      },
      {
        "sha": "38949196b9bfeebd31daf2ee8e559de4f4221e8d",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 12,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f57817fca0115bb7c31daea57fab40093495bda9/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f57817fca0115bb7c31daea57fab40093495bda9/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=f57817fca0115bb7c31daea57fab40093495bda9",
        "patch": "@@ -229,10 +229,11 @@ bool TestLockPointValidity(const LockPoints* lp)\n     return true;\n }\n \n-bool CheckSequenceLocks(const CTxMemPool& pool, const CTransaction& tx, int flags, LockPoints* lp, bool useExistingLockPoints)\n+template <typename P>\n+bool CheckSequenceLocks(const P& tx_pool, const CTransaction& tx, int flags, LockPoints* lp, bool useExistingLockPoints)\n {\n     AssertLockHeld(cs_main);\n-    AssertLockHeld(pool.cs);\n+    AssertLockHeld(tx_pool.cs);\n \n     CBlockIndex* tip = ::ChainActive().Tip();\n     assert(tip != nullptr);\n@@ -255,7 +256,7 @@ bool CheckSequenceLocks(const CTxMemPool& pool, const CTransaction& tx, int flag\n     }\n     else {\n         // pcoinsTip contains the UTXO set for ::ChainActive().Tip()\n-        CoinsViewMemPool<CTxMemPool> viewMemPool(pcoinsTip.get(), pool);\n+        CoinsViewMemPool<P> viewMemPool(pcoinsTip.get(), tx_pool);\n         std::vector<int> prevheights;\n         prevheights.resize(tx.vin.size());\n         for (size_t txinIndex = 0; txinIndex < tx.vin.size(); txinIndex++) {\n@@ -304,7 +305,8 @@ bool CheckSequenceLocks(const CTxMemPool& pool, const CTransaction& tx, int flag\n // Returns the script flags which should be checked for a given block\n static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consensus::Params& chainparams);\n \n-static void LimitMempoolSize(CTxMemPool& pool, size_t limit, unsigned long age) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n+template <typename P>\n+static void LimitMempoolSize(P& pool, size_t limit, unsigned long age) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n {\n     int expired = pool.Expire(GetTime() - age);\n     if (expired != 0) {\n@@ -383,7 +385,8 @@ static void UpdateMempoolForReorg(DisconnectedBlockTransactions& disconnectpool,\n \n // Used to avoid mempool polluting consensus critical paths if CCoinsViewMempool\n // were somehow broken and returning the wrong scriptPubKeys\n-static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationState& state, const CCoinsViewCache& view, const CTxMemPool& pool,\n+template <typename P>\n+static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationState& state, const CCoinsViewCache& view, const P& pool,\n                  unsigned int flags, bool cacheSigStore, PrecomputedTransactionData& txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n     AssertLockHeld(cs_main);\n \n@@ -424,7 +427,8 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n  *                                remove the cache additions if the associated transaction ends\n  *                                up being rejected by the mempool.\n  */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n+template<typename P>\n+static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, P& pool, CValidationState& state, const CTransactionRef& ptx,\n                               bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n                               bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n@@ -508,7 +512,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         CCoinsViewCache view(&dummy);\n \n         LockPoints lp;\n-        CoinsViewMemPool<CTxMemPool> viewMemPool(pcoinsTip.get(), pool);\n+        CoinsViewMemPool<P> viewMemPool(pcoinsTip.get(), pool);\n         view.SetBackend(viewMemPool);\n \n         // do all inputs exist?\n@@ -604,7 +608,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n         // Calculate in-mempool ancestors, up to a limit.\n-        CTxMemPool::setEntries setAncestors;\n+        typename P::setEntries setAncestors;\n         size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n         size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n         size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n@@ -634,7 +638,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         CAmount nConflictingFees = 0;\n         size_t nConflictingSize = 0;\n         uint64_t nConflictingCount = 0;\n-        CTxMemPool::setEntries allConflicting;\n+        typename P::setEntries allConflicting;\n \n         // If we don't hold the lock allConflicting might be incomplete; the\n         // subsequent RemoveStaged() and addUnchecked() calls don't guarantee\n@@ -645,7 +649,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             CFeeRate newFeeRate(nModifiedFees, nSize);\n             std::set<uint256> setConflictsParents;\n             const int maxDescendantsToVisit = 100;\n-            const CTxMemPool::setEntries setIterConflicting = pool.GetIterSet(setConflicts);\n+            const typename P::setEntries& setIterConflicting = pool.GetIterSet(setConflicts);\n             for (const auto& mi : setIterConflicting) {\n                 // Don't allow the replacement to reduce the feerate of the\n                 // mempool.\n@@ -822,7 +826,8 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n }\n \n /** (try to) add transaction to memory pool with a specified acceptance time **/\n-static bool AcceptToMemoryPoolWithTime(const CChainParams& chainparams, CTxMemPool& pool, CValidationState &state, const CTransactionRef &tx,\n+template<typename P>\n+static bool AcceptToMemoryPoolWithTime(const CChainParams& chainparams, P& pool, CValidationState &state, const CTransactionRef& tx,\n                         bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n                         bool bypass_limits, const CAmount nAbsurdFee, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n@@ -843,13 +848,16 @@ static bool AcceptToMemoryPoolWithTime(const CChainParams& chainparams, CTxMemPo\n     return res;\n }\n \n-bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransactionRef &tx,\n+template<typename P>\n+bool AcceptToMemoryPool(P& pool, CValidationState& state, const CTransactionRef& tx,\n                         bool* pfMissingInputs, std::list<CTransactionRef>* plTxnReplaced,\n                         bool bypass_limits, const CAmount nAbsurdFee, bool test_accept)\n {\n     const CChainParams& chainparams = Params();\n     return AcceptToMemoryPoolWithTime(chainparams, pool, state, tx, pfMissingInputs, GetTime(), plTxnReplaced, bypass_limits, nAbsurdFee, test_accept);\n }\n+template bool AcceptToMemoryPool(CTxMemPool&, CValidationState&, const CTransactionRef&, bool*, std::list<CTransactionRef>*, bool, const CAmount, bool);\n+template bool AcceptToMemoryPool(TxPoolLayer&, CValidationState&, const CTransactionRef&, bool*, std::list<CTransactionRef>*, bool, const CAmount, bool);\n \n /**\n  * Return transaction in txOut, and if it was found inside a block, its hash is placed in hashBlock."
      },
      {
        "sha": "d4993d0e53df0ab71db5a4f9db8a1e21b76bb609",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f57817fca0115bb7c31daea57fab40093495bda9/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f57817fca0115bb7c31daea57fab40093495bda9/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=f57817fca0115bb7c31daea57fab40093495bda9",
        "patch": "@@ -279,7 +279,8 @@ void PruneBlockFilesManual(int nManualPruneHeight);\n \n /** (try to) add transaction to memory pool\n  * plTxnReplaced will be appended to with all transactions replaced from mempool **/\n-bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransactionRef &tx,\n+template<typename P>\n+bool AcceptToMemoryPool(P& pool, CValidationState& state, const CTransactionRef& tx,\n                         bool* pfMissingInputs, std::list<CTransactionRef>* plTxnReplaced,\n                         bool bypass_limits, const CAmount nAbsurdFee, bool test_accept=false) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n@@ -323,7 +324,8 @@ bool TestLockPointValidity(const LockPoints* lp) EXCLUSIVE_LOCKS_REQUIRED(cs_mai\n  *\n  * See consensus/consensus.h for flag definitions.\n  */\n-bool CheckSequenceLocks(const CTxMemPool& pool, const CTransaction& tx, int flags, LockPoints* lp = nullptr, bool useExistingLockPoints = false) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+template <typename P>\n+bool CheckSequenceLocks(const P& pool, const CTransaction& tx, int flags, LockPoints* lp = nullptr, bool useExistingLockPoints = false) EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs);\n \n /**\n  * Closure representing one script verification"
      }
    ]
  },
  {
    "sha": "421de16e9ca017f5aa4fa600f15b156300ac0c75",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MjFkZTE2ZTljYTAxN2Y1YWE0ZmE2MDBmMTViMTU2MzAwYWMwYzc1",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-07-13T14:22:57Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-07-13T17:23:43Z"
      },
      "message": "rpc: Use TxPoolLayer in testmempoolaccept",
      "tree": {
        "sha": "33020f6cce2947a4a3e4601af51978e70ec5fed0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/33020f6cce2947a4a3e4601af51978e70ec5fed0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/421de16e9ca017f5aa4fa600f15b156300ac0c75",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/421de16e9ca017f5aa4fa600f15b156300ac0c75",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/421de16e9ca017f5aa4fa600f15b156300ac0c75",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/421de16e9ca017f5aa4fa600f15b156300ac0c75/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f57817fca0115bb7c31daea57fab40093495bda9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f57817fca0115bb7c31daea57fab40093495bda9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f57817fca0115bb7c31daea57fab40093495bda9"
      }
    ],
    "stats": {
      "total": 58,
      "additions": 32,
      "deletions": 26
    },
    "files": [
      {
        "sha": "2f98d5681926cd29fdb83746b6539874b57160f5",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 26,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/421de16e9ca017f5aa4fa600f15b156300ac0c75/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/421de16e9ca017f5aa4fa600f15b156300ac0c75/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=421de16e9ca017f5aa4fa600f15b156300ac0c75",
        "patch": "@@ -863,19 +863,21 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Array must contain exactly one raw transaction for now\");\n     }\n \n-    CMutableTransaction mtx;\n-    if (!DecodeHexTx(mtx, request.params[0].get_array()[0].get_str())) {\n-        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n+    std::vector<CTransactionRef> txs;\n+    for (const auto& tx : request.params[0].get_array().getValues()) {\n+        CMutableTransaction mtx;\n+        if (!DecodeHexTx(mtx, tx.get_str())) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n+        }\n+        txs.push_back(MakeTransactionRef(std::move(mtx)));\n     }\n-    CTransactionRef tx(MakeTransactionRef(std::move(mtx)));\n-    const uint256& tx_hash = tx->GetHash();\n \n     CAmount max_raw_tx_fee = DEFAULT_MAX_RAW_TX_FEE;\n     // TODO: temporary migration code for old clients. Remove in v0.20\n     if (request.params[1].isBool()) {\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Second argument must be numeric (maxfeerate) and no longer supports a boolean. To allow a transaction with high fees, set maxfeerate to 0.\");\n     } else if (!request.params[1].isNull()) {\n-        size_t weight = GetTransactionWeight(*tx);\n+        size_t weight = /* TODO fix */ 4000; //GetTransactionWeight(*tx);\n         CFeeRate fr(AmountFromValue(request.params[1]));\n         // the +3/4 part rounds the value up, and is the same formula used when\n         // calculating the fee for a transaction\n@@ -884,29 +886,33 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     }\n \n     UniValue result(UniValue::VARR);\n-    UniValue result_0(UniValue::VOBJ);\n-    result_0.pushKV(\"txid\", tx_hash.GetHex());\n \n-    CValidationState state;\n-    bool missing_inputs;\n-    bool test_accept_res;\n-    {\n-        LOCK(cs_main);\n-        test_accept_res = AcceptToMemoryPool(mempool, state, std::move(tx), &missing_inputs,\n-            nullptr /* plTxnReplaced */, false /* bypass_limits */, max_raw_tx_fee, /* test_accept */ true);\n-    }\n-    result_0.pushKV(\"allowed\", test_accept_res);\n-    if (!test_accept_res) {\n-        if (state.IsInvalid()) {\n-            result_0.pushKV(\"reject-reason\", strprintf(\"%i: %s\", state.GetRejectCode(), state.GetRejectReason()));\n-        } else if (missing_inputs) {\n-            result_0.pushKV(\"reject-reason\", \"missing-inputs\");\n-        } else {\n-            result_0.pushKV(\"reject-reason\", state.GetRejectReason());\n+    LOCK2(cs_main, ::mempool.cs);\n+    TxPoolLayer pool_layer{::mempool};\n+    for (const auto& tx : txs) {\n+        UniValue result_i(UniValue::VOBJ);\n+        result_i.pushKV(\"txid\", tx->GetHash().GetHex());\n+\n+        CValidationState state;\n+        bool missing_inputs;\n+        bool test_accept_res;\n+        {\n+            test_accept_res = AcceptToMemoryPool(pool_layer, state, tx, &missing_inputs,\n+                nullptr /* plTxnReplaced */, false /* bypass_limits */, max_raw_tx_fee, /* test_accept */ false);\n+        }\n+        result_i.pushKV(\"allowed\", test_accept_res);\n+        if (!test_accept_res) {\n+            if (state.IsInvalid()) {\n+                result_i.pushKV(\"reject-reason\", strprintf(\"%i: %s\", state.GetRejectCode(), state.GetRejectReason()));\n+            } else if (missing_inputs) {\n+                result_i.pushKV(\"reject-reason\", \"missing-inputs\");\n+            } else {\n+                result_i.pushKV(\"reject-reason\", state.GetRejectReason());\n+            }\n         }\n-    }\n \n-    result.push_back(std::move(result_0));\n+        result.push_back(std::move(result_i));\n+    }\n     return result;\n }\n "
      }
    ]
  }
]