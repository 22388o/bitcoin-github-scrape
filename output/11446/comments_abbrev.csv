theuni,2017-10-03T19:43:24Z,"Is it really necessary to request as many headers as possible on each bad chain?\n\nWhat about something like sending a request for non-deterministic headers from m to n, where```m = forkheight - rand(x), n = max(m + rand(2x), tip)``` from all chains (including the active one), that way we can also interpret ignored valid requests?",https://github.com/bitcoin/bitcoin/pull/11446#issuecomment-333955982,333955982,
achow101,2017-10-03T20:01:51Z,"> Is it really necessary to request as many headers as possible on each bad chain?\n\nNo.\n\n> that way we can also interpret ignored valid requests?\n\nI'm not sure if that is useful or necessary. How do you know the difference between a node not having a block, rejected the block, or is just slow to respond?",https://github.com/bitcoin/bitcoin/pull/11446#issuecomment-333961048,333961048,
theuni,2017-10-03T20:46:14Z,"Cautious concept ack on doing this once, sometimes, post-handshake, but I think this needs to be thought through a bit more.\n\n- Amplification bugs seem easy to introduce here. I'd be more comfortable if the testing was non-deterministic, and done more like ~50% of the time.\n- Nodes can just ignore any block locator containing different chains.\n- It seems unnecessary/wasteful to do this for",https://github.com/bitcoin/bitcoin/pull/11446#issuecomment-333973033,333973033,
gmaxwell,2017-10-03T20:46:15Z,"I don't understand why this is generating any headers requests at all, we already will synchronize all headers on the peers best chain (obviously not transferring any we already know about).  We just need to see that they connect to an invalid block and disconnect.",https://github.com/bitcoin/bitcoin/pull/11446#issuecomment-333973040,333973040,
JeremyRubin,2017-10-03T21:06:18Z," I don't really like this policy, I wouldn't go as far as a Concept NACK though because I think it can be adjusted to do what you want.\n\nI think returning an invalid block when requested is a weak indicator of peer correctness overall. Nodes to assuming ""you get what you ask for"" and feeding you invalid data -- if you ask for it and they have it -- seems like a semi-sane behavior. (e.g., the b",https://github.com/bitcoin/bitcoin/pull/11446#issuecomment-333978621,333978621,
JeremyRubin,2017-10-03T21:08:22Z,"Interleaving error (was taking my sweet time writing it up), but what @gmaxwell said should cover my suggestion as well.",https://github.com/bitcoin/bitcoin/pull/11446#issuecomment-333979198,333979198,
achow101,2017-10-03T21:52:09Z,"> It seems unnecessary/wasteful to do this for each block that comes in.\n\nI doesn't. It does this for each invalid block.\n\n> What does this offer over the request done after the handshake?\n\nI suppose it doesn't do that much after the handshake. The part that makes a difference with peers that have been connected to a while is the banning on duplicate invalid headers.\n\n> we already ",https://github.com/bitcoin/bitcoin/pull/11446#issuecomment-333989899,333989899,
gmaxwell,2017-10-03T22:43:32Z,"> I think returning an invalid block when requested is a weak indicator of peer correctness overall. Nodes to assuming ""you get what you ask for"" and feeding you invalid data -- if you ask for it and they have it -- seems like a semi-sane behavior. \n\nI don't agree that what you describe is a sane behavior and it is not a behavior of the Bitcoin protocol in the past.  It's prudent and important",https://github.com/bitcoin/bitcoin/pull/11446#issuecomment-334000406,334000406,
gmaxwell,2017-10-04T00:54:20Z,">  I think then it is harder to tell whether you are actually syncing the blockchain and whether you are testing the peer for correctness.\n\nYes, well and I think it can actually be done with basically no extra network traffic, just responding differently to messages we already get (punt a peer if they give you a header whos parent is something we've marked invalid). ",https://github.com/bitcoin/bitcoin/pull/11446#issuecomment-334020829,334020829,
achow101,2017-10-04T00:58:43Z,"> punt a peer if they give you a header whos parent is something we've marked invalid\n\nWe already do that. I'm more concerned about how you get a peer to tell you what blocks are in its best chain without having to wait for a new block to be found.",https://github.com/bitcoin/bitcoin/pull/11446#issuecomment-334021378,334021378,
achow101,2017-10-04T15:22:25Z,"After giving this some more thought and sleeping on it, I have a slightly different propsal:\n\n1. Ban all nodes who give us an invalid block even after we have already seen the block (Note: I'm not sure how this interacts with compact blocks).\n2. After the version handshake, send each node a `getheaders` request with the parent block of each invalid block that we have (i.e. a `getheaders` for",https://github.com/bitcoin/bitcoin/pull/11446#issuecomment-334192077,334192077,
gmaxwell,2017-10-05T17:08:28Z,For peers that are sending us HB mode compact blocks we can only kick things off for a subset of invalidity reasons. ,https://github.com/bitcoin/bitcoin/pull/11446#issuecomment-334530050,334530050,
achow101,2017-10-07T17:46:45Z,"I have updated this to be as we discussed in the IRC meeting. If we see a block header for a block we already know is invalid, we disconnect from the node that sent it. The only exception are our HB CB nodes.",https://github.com/bitcoin/bitcoin/pull/11446#issuecomment-334953583,334953583,
sipa,2017-10-13T00:33:23Z,Going to test this.,https://github.com/bitcoin/bitcoin/pull/11446#issuecomment-336317957,336317957,
meshcollider,2017-10-19T22:34:25Z,utACK https://github.com/bitcoin/bitcoin/pull/11446/commits/23b7af0ac484ce4a7f46060c06e3dca5a8c26d0d,https://github.com/bitcoin/bitcoin/pull/11446#issuecomment-338056762,338056762,
TheBlueMatt,2017-10-20T00:11:45Z,"I'm not sure how I feel about this - the current disconnection/ban logic on invalid headers is proabbly too conservative, but it helps in the case of soft forks where there are occasional invalid blocks relayed preventing us from banning all of our un-upgraded peers. Maybe we should ratchet up the agressiveness here, but only for outbound peers? I think just that change would be sufficient for 0.1",https://github.com/bitcoin/bitcoin/pull/11446#issuecomment-338071627,338071627,
sdaftuar,2017-10-20T01:41:58Z,"I think there's a small race condition in the CMPCTBLOCK handler -- there's a circumstance where we would revert to headers processing, and we release cs_main before doing so.  If the block header is learned to be invalid in between initial processing and re-processing, then I think this patch would disconnect an HB compact block peer inappropriately.\n\nI'm not really sure what the best remedy ",https://github.com/bitcoin/bitcoin/pull/11446#issuecomment-338082893,338082893,
achow101,2017-10-23T17:57:31Z,"> I think there's a small race condition in the CMPCTBLOCK handler -- there's a circumstance where we would revert to headers processing, and we release cs_main before doing so. If the block header is learned to be invalid in between initial processing and re-processing, then I think this patch would disconnect an HB compact block peer inappropriately.\n\nWhy would it revert to headers processin",https://github.com/bitcoin/bitcoin/pull/11446#issuecomment-338744044,338744044,
sdaftuar,2017-10-23T19:03:36Z,"@achow101 See https://github.com/bitcoin/bitcoin/blob/57ee73990f1ce29916adfd99f93eae1ccea1a43b/src/net_processing.cpp#L2130\n",https://github.com/bitcoin/bitcoin/pull/11446#issuecomment-338763477,338763477,
achow101,2017-10-27T15:41:18Z,superseded by #11568,https://github.com/bitcoin/bitcoin/pull/11446#issuecomment-340007655,340007655,
theuni,2017-10-03T19:04:08Z,"Should probably wait until VERACK for this.\n\nAlso, walking mapBlockIndex seems a little heavy here, no?",https://github.com/bitcoin/bitcoin/pull/11446#discussion_r142493120,142493120,src/net_processing.cpp
achow101,2017-10-03T19:13:46Z,"Besides walking `mapBlockIndex`, what do you suggest? I was considering making something to just store the hashes of the invalid blocks instead.",https://github.com/bitcoin/bitcoin/pull/11446#discussion_r142495438,142495438,src/net_processing.cpp
theuni,2017-10-03T19:47:07Z,"Yea, I'd say the fork-points need to be cached. Unsure if it'd be best to just do it here and be done with it, or maintain something in validation.cpp that (for ex) getchaintips could also use.",https://github.com/bitcoin/bitcoin/pull/11446#discussion_r142503177,142503177,src/net_processing.cpp
achow101,2017-10-03T19:56:04Z,Well it would have to be something that is loaded/generated on startup too.,https://github.com/bitcoin/bitcoin/pull/11446#discussion_r142505375,142505375,src/net_processing.cpp
theuni,2017-10-03T19:56:06Z,Feedback loop here.,https://github.com/bitcoin/bitcoin/pull/11446#discussion_r142505404,142505404,src/net_processing.cpp
theuni,2017-10-03T19:56:48Z,feedback loop here too :),https://github.com/bitcoin/bitcoin/pull/11446#discussion_r142505576,142505576,src/net_processing.cpp
achow101,2017-10-03T19:57:58Z,how so?,https://github.com/bitcoin/bitcoin/pull/11446#discussion_r142505845,142505845,src/net_processing.cpp
theuni,2017-10-03T20:05:46Z,"Node sends you bad header, you request that header from all nodes (including the one that just sent it). Same node replies with same header, you request it again from all nodes... repeat until they get banned.",https://github.com/bitcoin/bitcoin/pull/11446#discussion_r142507824,142507824,src/net_processing.cpp
achow101,2017-10-03T20:07:56Z,Isn't the node that sent it to you in the first place already banned by the time this runs?,https://github.com/bitcoin/bitcoin/pull/11446#discussion_r142508339,142508339,src/net_processing.cpp
theuni,2017-10-03T20:42:30Z,"No, not necessarily. See ""high-hash"" for example. But even still, the ban/disconnect should not be assumed. What if they're whitelisted?",https://github.com/bitcoin/bitcoin/pull/11446#discussion_r142517016,142517016,src/net_processing.cpp
theuni,2017-10-13T20:50:08Z,Do we not want to disconnect if ban points were assigned?,https://github.com/bitcoin/bitcoin/pull/11446#discussion_r144654182,144654182,src/net_processing.cpp
theuni,2017-10-13T20:52:45Z,Same here.,https://github.com/bitcoin/bitcoin/pull/11446#discussion_r144654688,144654688,src/net_processing.cpp
achow101,2017-10-13T21:12:26Z,"Most of the time when ban points are assigned, 100 points are assigned and the peer is banned and disconnected. However there are a few cases (e.g. https://github.com/bitcoin/bitcoin/blob/master/src/validation.cpp#L3060) where ban points are assigned but not 100 of them, and we don't necessarily want to disconnect on those.",https://github.com/bitcoin/bitcoin/pull/11446#discussion_r144658071,144658071,src/net_processing.cpp
theuni,2017-10-13T21:39:19Z,"Mmm, that's not at all obvious. For now at least, ban points are rather arbitrary. Not completely, of course, but I don't think their values can be relied on to convey any particular meaning. ~~Besides that, they could've already gotten some ban points for some other message.~~\n\nAnyway, Misbehaving() already does what you've described. So this actually seems backwards. Now, they're disconnecte",https://github.com/bitcoin/bitcoin/pull/11446#discussion_r144662407,144662407,src/net_processing.cpp
achow101,2017-10-13T21:44:18Z,Do you think we should just disconnect always when something is invalid?,https://github.com/bitcoin/bitcoin/pull/11446#discussion_r144663206,144663206,src/net_processing.cpp
TheBlueMatt,2017-10-17T21:28:08Z,This is racy. There is no way to check if a peer might have been in compact-fast-relay mode when you receive a compact block header.,https://github.com/bitcoin/bitcoin/pull/11446#discussion_r145261255,145261255,src/net_processing.cpp
achow101,2017-10-18T19:38:52Z,"Would it be better to just always disconnect on an invalid block, regardless?",https://github.com/bitcoin/bitcoin/pull/11446#discussion_r145519932,145519932,src/net_processing.cpp
TheBlueMatt,2017-10-18T22:03:43Z,"I think we should just ignore this case. My first reaction was to suggest you do a getheaders request, but then I went down a rabbit hole trying to decide whether the peer is required to respond with the header if they decided the block was valid (it turns out BIP 152 explicitly answers this question with a no). Per BIP 152, I believe the way to ""correctly"" handle this would be to reply with a get",https://github.com/bitcoin/bitcoin/pull/11446#discussion_r145555589,145555589,src/net_processing.cpp
achow101,2017-10-19T19:07:20Z,"@TheBlueMatt \n\n> I think we should just ignore this case.\n\nDo you mean just disconnect regardless or just don't do anything here and let invalid blocks through here?",https://github.com/bitcoin/bitcoin/pull/11446#discussion_r145795318,145795318,src/net_processing.cpp
achow101,2017-10-19T20:31:39Z,"Ok, I just removed this check and disconnect. After reviewing BIP 152 again, the low bandwidth peers should already be disconnected by the disconnection in handling the `headers` message so our high bandwidth peers are still unaffected.",https://github.com/bitcoin/bitcoin/pull/11446#discussion_r145815241,145815241,src/net_processing.cpp
achow101,2017-10-19T20:32:00Z,Removed the `else` statement so it will always disconnect on an invalid block header.,https://github.com/bitcoin/bitcoin/pull/11446#discussion_r145815330,145815330,src/net_processing.cpp
