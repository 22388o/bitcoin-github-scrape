[
  {
    "sha": "27e5e5e3d84919271a4d544d6ac8a756008e6995",
    "node_id": "C_kwDOABII59oAKDI3ZTVlNWUzZDg0OTE5MjcxYTRkNTQ0ZDZhYzhhNzU2MDA4ZTY5OTU",
    "commit": {
      "author": {
        "name": "Samuel Dobson",
        "email": "dobsonsa68@gmail.com",
        "date": "2021-11-30T01:49:00Z"
      },
      "committer": {
        "name": "Samuel Dobson",
        "email": "dobsonsa68@gmail.com",
        "date": "2021-12-02T07:58:12Z"
      },
      "message": "MOVEONLY: Move rpcdump.cpp to wallet/rpc/backup.cpp",
      "tree": {
        "sha": "aab49529df2d4c979eab913cbe8c83e8dfb93f39",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/aab49529df2d4c979eab913cbe8c83e8dfb93f39"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/27e5e5e3d84919271a4d544d6ac8a756008e6995",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/27e5e5e3d84919271a4d544d6ac8a756008e6995",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/27e5e5e3d84919271a4d544d6ac8a756008e6995",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/27e5e5e3d84919271a4d544d6ac8a756008e6995/comments",
    "author": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "af1067c4b73297f4db30e1b3989767cc16fd147f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af1067c4b73297f4db30e1b3989767cc16fd147f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/af1067c4b73297f4db30e1b3989767cc16fd147f"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "9cd5ca31efbb2e3e868fd575edc9967c447572eb",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27e5e5e3d84919271a4d544d6ac8a756008e6995/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27e5e5e3d84919271a4d544d6ac8a756008e6995/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=27e5e5e3d84919271a4d544d6ac8a756008e6995",
        "patch": "@@ -410,9 +410,9 @@ libbitcoin_wallet_a_SOURCES = \\\n   wallet/interfaces.cpp \\\n   wallet/load.cpp \\\n   wallet/receive.cpp \\\n+  wallet/rpc/backup.cpp \\\n   wallet/rpc/signmessage.cpp \\\n   wallet/rpc/util.cpp \\\n-  wallet/rpcdump.cpp \\\n   wallet/rpcwallet.cpp \\\n   wallet/scriptpubkeyman.cpp \\\n   wallet/spend.cpp \\"
      },
      {
        "sha": "db22a19a6301b0407a16e49b3fe65c6e7d5a24ae",
        "filename": "src/wallet/rpc/backup.cpp",
        "status": "renamed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/27e5e5e3d84919271a4d544d6ac8a756008e6995/src/wallet/rpc/backup.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/27e5e5e3d84919271a4d544d6ac8a756008e6995/src/wallet/rpc/backup.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpc/backup.cpp?ref=27e5e5e3d84919271a4d544d6ac8a756008e6995",
        "previous_filename": "src/wallet/rpcdump.cpp"
      }
    ]
  },
  {
    "sha": "0892bea0143079957f8579cbe724660d12b152d6",
    "node_id": "C_kwDOABII59oAKDA4OTJiZWEwMTQzMDc5OTU3Zjg1NzljYmU3MjQ2NjBkMTJiMTUyZDY",
    "commit": {
      "author": {
        "name": "Samuel Dobson",
        "email": "dobsonsa68@gmail.com",
        "date": "2021-11-30T02:19:02Z"
      },
      "committer": {
        "name": "Samuel Dobson",
        "email": "dobsonsa68@gmail.com",
        "date": "2021-12-02T07:58:12Z"
      },
      "message": "MOVEONLY: Move backupwallet and restorewallet to rpc/backup.cpp",
      "tree": {
        "sha": "a354eee015c45f96ea1edf85c1b4419c02b8fbb1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a354eee015c45f96ea1edf85c1b4419c02b8fbb1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0892bea0143079957f8579cbe724660d12b152d6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0892bea0143079957f8579cbe724660d12b152d6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0892bea0143079957f8579cbe724660d12b152d6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0892bea0143079957f8579cbe724660d12b152d6/comments",
    "author": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "27e5e5e3d84919271a4d544d6ac8a756008e6995",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/27e5e5e3d84919271a4d544d6ac8a756008e6995",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/27e5e5e3d84919271a4d544d6ac8a756008e6995"
      }
    ],
    "stats": {
      "total": 206,
      "additions": 108,
      "deletions": 98
    },
    "files": [
      {
        "sha": "03511574e72299967c354691ee8cad1ba44203d3",
        "filename": "src/wallet/rpc/backup.cpp",
        "status": "modified",
        "additions": 97,
        "deletions": 0,
        "changes": 97,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0892bea0143079957f8579cbe724660d12b152d6/src/wallet/rpc/backup.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0892bea0143079957f8579cbe724660d12b152d6/src/wallet/rpc/backup.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpc/backup.cpp?ref=0892bea0143079957f8579cbe724660d12b152d6",
        "patch": "@@ -17,6 +17,7 @@\n #include <util/system.h>\n #include <util/time.h>\n #include <util/translation.h>\n+#include <wallet/rpcwallet.h>\n #include <wallet/rpc/util.h>\n #include <wallet/wallet.h>\n \n@@ -1832,3 +1833,99 @@ RPCHelpMan listdescriptors()\n },\n     };\n }\n+\n+RPCHelpMan backupwallet()\n+{\n+    return RPCHelpMan{\"backupwallet\",\n+                \"\\nSafely copies current wallet file to destination, which can be a directory or a path with filename.\\n\",\n+                {\n+                    {\"destination\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The destination directory or file\"},\n+                },\n+                RPCResult{RPCResult::Type::NONE, \"\", \"\"},\n+                RPCExamples{\n+                    HelpExampleCli(\"backupwallet\", \"\\\"backup.dat\\\"\")\n+            + HelpExampleRpc(\"backupwallet\", \"\\\"backup.dat\\\"\")\n+                },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+{\n+    const std::shared_ptr<const CWallet> pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n+\n+    // Make sure the results are valid at least up to the most recent block\n+    // the user could have gotten from another RPC command prior to now\n+    pwallet->BlockUntilSyncedToCurrentChain();\n+\n+    LOCK(pwallet->cs_wallet);\n+\n+    std::string strDest = request.params[0].get_str();\n+    if (!pwallet->BackupWallet(strDest)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error: Wallet backup failed!\");\n+    }\n+\n+    return NullUniValue;\n+},\n+    };\n+}\n+\n+\n+RPCHelpMan restorewallet()\n+{\n+    return RPCHelpMan{\n+        \"restorewallet\",\n+        \"\\nRestore and loads a wallet from backup.\\n\",\n+        {\n+            {\"wallet_name\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The name that will be applied to the restored wallet\"},\n+            {\"backup_file\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The backup file that will be used to restore the wallet.\"},\n+            {\"load_on_startup\", RPCArg::Type::BOOL, RPCArg::Optional::OMITTED_NAMED_ARG, \"Save wallet name to persistent settings and load on startup. True to add wallet to startup list, false to remove, null to leave unchanged.\"},\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+            {\n+                {RPCResult::Type::STR, \"name\", \"The wallet name if restored successfully.\"},\n+                {RPCResult::Type::STR, \"warning\", \"Warning message if wallet was not loaded cleanly.\"},\n+            }\n+        },\n+        RPCExamples{\n+            HelpExampleCli(\"restorewallet\", \"\\\"testwallet\\\" \\\"home\\\\backups\\\\backup-file.bak\\\"\")\n+            + HelpExampleRpc(\"restorewallet\", \"\\\"testwallet\\\" \\\"home\\\\backups\\\\backup-file.bak\\\"\")\n+            + HelpExampleCliNamed(\"restorewallet\", {{\"wallet_name\", \"testwallet\"}, {\"backup_file\", \"home\\\\backups\\\\backup-file.bak\\\"\"}, {\"load_on_startup\", true}})\n+            + HelpExampleRpcNamed(\"restorewallet\", {{\"wallet_name\", \"testwallet\"}, {\"backup_file\", \"home\\\\backups\\\\backup-file.bak\\\"\"}, {\"load_on_startup\", true}})\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+{\n+\n+    WalletContext& context = EnsureWalletContext(request.context);\n+\n+    auto backup_file = fs::u8path(request.params[1].get_str());\n+\n+    if (!fs::exists(backup_file)) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Backup file does not exist\");\n+    }\n+\n+    std::string wallet_name = request.params[0].get_str();\n+\n+    const fs::path wallet_path = fsbridge::AbsPathJoin(GetWalletDir(), fs::u8path(wallet_name));\n+\n+    if (fs::exists(wallet_path)) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Wallet name already exists.\");\n+    }\n+\n+    if (!TryCreateDirectories(wallet_path)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, strprintf(\"Failed to create database path '%s'. Database already exists.\", wallet_path.u8string()));\n+    }\n+\n+    auto wallet_file = wallet_path / \"wallet.dat\";\n+\n+    fs::copy_file(backup_file, wallet_file, fs::copy_option::fail_if_exists);\n+\n+    auto [wallet, warnings] = LoadWalletHelper(context, request.params[2], wallet_name);\n+\n+    UniValue obj(UniValue::VOBJ);\n+    obj.pushKV(\"name\", wallet->GetName());\n+    obj.pushKV(\"warning\", Join(warnings, Untranslated(\"\\n\")).original);\n+\n+    return obj;\n+\n+},\n+    };\n+}"
      },
      {
        "sha": "16680fc250196c54a341aec9d4b883f04d852cb2",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 98,
        "changes": 101,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0892bea0143079957f8579cbe724660d12b152d6/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0892bea0143079957f8579cbe724660d12b152d6/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=0892bea0143079957f8579cbe724660d12b152d6",
        "patch": "@@ -1656,41 +1656,6 @@ static RPCHelpMan abandontransaction()\n     };\n }\n \n-\n-static RPCHelpMan backupwallet()\n-{\n-    return RPCHelpMan{\"backupwallet\",\n-                \"\\nSafely copies current wallet file to destination, which can be a directory or a path with filename.\\n\",\n-                {\n-                    {\"destination\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The destination directory or file\"},\n-                },\n-                RPCResult{RPCResult::Type::NONE, \"\", \"\"},\n-                RPCExamples{\n-                    HelpExampleCli(\"backupwallet\", \"\\\"backup.dat\\\"\")\n-            + HelpExampleRpc(\"backupwallet\", \"\\\"backup.dat\\\"\")\n-                },\n-        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n-{\n-    const std::shared_ptr<const CWallet> pwallet = GetWalletForJSONRPCRequest(request);\n-    if (!pwallet) return NullUniValue;\n-\n-    // Make sure the results are valid at least up to the most recent block\n-    // the user could have gotten from another RPC command prior to now\n-    pwallet->BlockUntilSyncedToCurrentChain();\n-\n-    LOCK(pwallet->cs_wallet);\n-\n-    std::string strDest = request.params[0].get_str();\n-    if (!pwallet->BackupWallet(strDest)) {\n-        throw JSONRPCError(RPC_WALLET_ERROR, \"Error: Wallet backup failed!\");\n-    }\n-\n-    return NullUniValue;\n-},\n-    };\n-}\n-\n-\n static RPCHelpMan keypoolrefill()\n {\n     return RPCHelpMan{\"keypoolrefill\",\n@@ -2467,7 +2432,7 @@ static RPCHelpMan listwallets()\n     };\n }\n \n-static std::tuple<std::shared_ptr<CWallet>, std::vector<bilingual_str>> LoadWalletHelper(WalletContext& context, UniValue load_on_start_param, const std::string wallet_name)\n+std::tuple<std::shared_ptr<CWallet>, std::vector<bilingual_str>> LoadWalletHelper(WalletContext& context, UniValue load_on_start_param, const std::string wallet_name)\n {\n     DatabaseOptions options;\n     DatabaseStatus status;\n@@ -2697,68 +2662,6 @@ static RPCHelpMan createwallet()\n     };\n }\n \n-static RPCHelpMan restorewallet()\n-{\n-    return RPCHelpMan{\n-        \"restorewallet\",\n-        \"\\nRestore and loads a wallet from backup.\\n\",\n-        {\n-            {\"wallet_name\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The name that will be applied to the restored wallet\"},\n-            {\"backup_file\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The backup file that will be used to restore the wallet.\"},\n-            {\"load_on_startup\", RPCArg::Type::BOOL, RPCArg::Optional::OMITTED_NAMED_ARG, \"Save wallet name to persistent settings and load on startup. True to add wallet to startup list, false to remove, null to leave unchanged.\"},\n-        },\n-        RPCResult{\n-            RPCResult::Type::OBJ, \"\", \"\",\n-            {\n-                {RPCResult::Type::STR, \"name\", \"The wallet name if restored successfully.\"},\n-                {RPCResult::Type::STR, \"warning\", \"Warning message if wallet was not loaded cleanly.\"},\n-            }\n-        },\n-        RPCExamples{\n-            HelpExampleCli(\"restorewallet\", \"\\\"testwallet\\\" \\\"home\\\\backups\\\\backup-file.bak\\\"\")\n-            + HelpExampleRpc(\"restorewallet\", \"\\\"testwallet\\\" \\\"home\\\\backups\\\\backup-file.bak\\\"\")\n-            + HelpExampleCliNamed(\"restorewallet\", {{\"wallet_name\", \"testwallet\"}, {\"backup_file\", \"home\\\\backups\\\\backup-file.bak\\\"\"}, {\"load_on_startup\", true}})\n-            + HelpExampleRpcNamed(\"restorewallet\", {{\"wallet_name\", \"testwallet\"}, {\"backup_file\", \"home\\\\backups\\\\backup-file.bak\\\"\"}, {\"load_on_startup\", true}})\n-        },\n-        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n-{\n-\n-    WalletContext& context = EnsureWalletContext(request.context);\n-\n-    auto backup_file = fs::u8path(request.params[1].get_str());\n-\n-    if (!fs::exists(backup_file)) {\n-        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Backup file does not exist\");\n-    }\n-\n-    std::string wallet_name = request.params[0].get_str();\n-\n-    const fs::path wallet_path = fsbridge::AbsPathJoin(GetWalletDir(), fs::u8path(wallet_name));\n-\n-    if (fs::exists(wallet_path)) {\n-        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Wallet name already exists.\");\n-    }\n-\n-    if (!TryCreateDirectories(wallet_path)) {\n-        throw JSONRPCError(RPC_WALLET_ERROR, strprintf(\"Failed to create database path '%s'. Database already exists.\", wallet_path.u8string()));\n-    }\n-\n-    auto wallet_file = wallet_path / \"wallet.dat\";\n-\n-    fs::copy_file(backup_file, wallet_file, fs::copy_option::fail_if_exists);\n-\n-    auto [wallet, warnings] = LoadWalletHelper(context, request.params[2], wallet_name);\n-\n-    UniValue obj(UniValue::VOBJ);\n-    obj.pushKV(\"name\", wallet->GetName());\n-    obj.pushKV(\"warning\", Join(warnings, Untranslated(\"\\n\")).original);\n-\n-    return obj;\n-\n-},\n-    };\n-}\n-\n static RPCHelpMan unloadwallet()\n {\n     return RPCHelpMan{\"unloadwallet\",\n@@ -4696,6 +4599,8 @@ RPCHelpMan importmulti();\n RPCHelpMan importdescriptors();\n RPCHelpMan listdescriptors();\n RPCHelpMan signmessage();\n+RPCHelpMan backupwallet();\n+RPCHelpMan restorewallet();\n \n Span<const CRPCCommand> GetWalletRPCCommands()\n {"
      },
      {
        "sha": "1c222df7b62a87b1cfd11ba4be3dcebd25e98876",
        "filename": "src/wallet/rpcwallet.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0892bea0143079957f8579cbe724660d12b152d6/src/wallet/rpcwallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0892bea0143079957f8579cbe724660d12b152d6/src/wallet/rpcwallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.h?ref=0892bea0143079957f8579cbe724660d12b152d6",
        "patch": "@@ -7,10 +7,18 @@\n \n #include <span.h>\n \n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n class CRPCCommand;\n+class CWallet;\n+struct WalletContext;\n \n Span<const CRPCCommand> GetWalletRPCCommands();\n \n+std::tuple<std::shared_ptr<CWallet>, std::vector<bilingual_str>> LoadWalletHelper(WalletContext& context, UniValue load_on_start_param, const std::string wallet_name);\n+\n RPCHelpMan getaddressinfo();\n RPCHelpMan signrawtransactionwithwallet();\n #endif // BITCOIN_WALLET_RPCWALLET_H"
      }
    ]
  },
  {
    "sha": "acc8d3286b823c4c7117ed0a96955473e9531231",
    "node_id": "C_kwDOABII59oAKGFjYzhkMzI4NmI4MjNjNGM3MTE3ZWQwYTk2OTU1NDczZTk1MzEyMzE",
    "commit": {
      "author": {
        "name": "Samuel Dobson",
        "email": "dobsonsa68@gmail.com",
        "date": "2021-12-01T01:50:19Z"
      },
      "committer": {
        "name": "Samuel Dobson",
        "email": "dobsonsa68@gmail.com",
        "date": "2021-12-02T07:58:12Z"
      },
      "message": "MOVEONLY: Move wallet encryption RPCs to encrypt.cpp",
      "tree": {
        "sha": "da776f51bdd2a7a88c9933bda26b76df9e775a06",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/da776f51bdd2a7a88c9933bda26b76df9e775a06"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/acc8d3286b823c4c7117ed0a96955473e9531231",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/acc8d3286b823c4c7117ed0a96955473e9531231",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/acc8d3286b823c4c7117ed0a96955473e9531231",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/acc8d3286b823c4c7117ed0a96955473e9531231/comments",
    "author": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0892bea0143079957f8579cbe724660d12b152d6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0892bea0143079957f8579cbe724660d12b152d6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0892bea0143079957f8579cbe724660d12b152d6"
      }
    ],
    "stats": {
      "total": 497,
      "additions": 256,
      "deletions": 241
    },
    "files": [
      {
        "sha": "72f548c19210d3e715946e48a5d1eeea50513477",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/acc8d3286b823c4c7117ed0a96955473e9531231/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/acc8d3286b823c4c7117ed0a96955473e9531231/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=acc8d3286b823c4c7117ed0a96955473e9531231",
        "patch": "@@ -411,6 +411,7 @@ libbitcoin_wallet_a_SOURCES = \\\n   wallet/load.cpp \\\n   wallet/receive.cpp \\\n   wallet/rpc/backup.cpp \\\n+  wallet/rpc/encrypt.cpp \\\n   wallet/rpc/signmessage.cpp \\\n   wallet/rpc/util.cpp \\\n   wallet/rpcwallet.cpp \\"
      },
      {
        "sha": "bd145624b7eb926f8cc7ce28a02354cafbeb7e2b",
        "filename": "src/wallet/rpc/encrypt.cpp",
        "status": "added",
        "additions": 249,
        "deletions": 0,
        "changes": 249,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/acc8d3286b823c4c7117ed0a96955473e9531231/src/wallet/rpc/encrypt.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/acc8d3286b823c4c7117ed0a96955473e9531231/src/wallet/rpc/encrypt.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpc/encrypt.cpp?ref=acc8d3286b823c4c7117ed0a96955473e9531231",
        "patch": "@@ -0,0 +1,249 @@\n+// Copyright (c) 2011-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <rpc/util.h>\n+#include <util/translation.h>\n+#include <wallet/rpc/util.h>\n+#include <wallet/wallet.h>\n+\n+\n+RPCHelpMan walletpassphrase()\n+{\n+    return RPCHelpMan{\"walletpassphrase\",\n+                \"\\nStores the wallet decryption key in memory for 'timeout' seconds.\\n\"\n+                \"This is needed prior to performing transactions related to private keys such as sending bitcoins\\n\"\n+            \"\\nNote:\\n\"\n+            \"Issuing the walletpassphrase command while the wallet is already unlocked will set a new unlock\\n\"\n+            \"time that overrides the old one.\\n\",\n+                {\n+                    {\"passphrase\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The wallet passphrase\"},\n+                    {\"timeout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The time to keep the decryption key in seconds; capped at 100000000 (~3 years).\"},\n+                },\n+                RPCResult{RPCResult::Type::NONE, \"\", \"\"},\n+                RPCExamples{\n+            \"\\nUnlock the wallet for 60 seconds\\n\"\n+            + HelpExampleCli(\"walletpassphrase\", \"\\\"my pass phrase\\\" 60\") +\n+            \"\\nLock the wallet again (before 60 seconds)\\n\"\n+            + HelpExampleCli(\"walletlock\", \"\") +\n+            \"\\nAs a JSON-RPC call\\n\"\n+            + HelpExampleRpc(\"walletpassphrase\", \"\\\"my pass phrase\\\", 60\")\n+                },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    if (!wallet) return NullUniValue;\n+    CWallet* const pwallet = wallet.get();\n+\n+    int64_t nSleepTime;\n+    int64_t relock_time;\n+    // Prevent concurrent calls to walletpassphrase with the same wallet.\n+    LOCK(pwallet->m_unlock_mutex);\n+    {\n+        LOCK(pwallet->cs_wallet);\n+\n+        if (!pwallet->IsCrypted()) {\n+            throw JSONRPCError(RPC_WALLET_WRONG_ENC_STATE, \"Error: running with an unencrypted wallet, but walletpassphrase was called.\");\n+        }\n+\n+        // Note that the walletpassphrase is stored in request.params[0] which is not mlock()ed\n+        SecureString strWalletPass;\n+        strWalletPass.reserve(100);\n+        // TODO: get rid of this .c_str() by implementing SecureString::operator=(std::string)\n+        // Alternately, find a way to make request.params[0] mlock()'d to begin with.\n+        strWalletPass = request.params[0].get_str().c_str();\n+\n+        // Get the timeout\n+        nSleepTime = request.params[1].get_int64();\n+        // Timeout cannot be negative, otherwise it will relock immediately\n+        if (nSleepTime < 0) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Timeout cannot be negative.\");\n+        }\n+        // Clamp timeout\n+        constexpr int64_t MAX_SLEEP_TIME = 100000000; // larger values trigger a macos/libevent bug?\n+        if (nSleepTime > MAX_SLEEP_TIME) {\n+            nSleepTime = MAX_SLEEP_TIME;\n+        }\n+\n+        if (strWalletPass.empty()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"passphrase can not be empty\");\n+        }\n+\n+        if (!pwallet->Unlock(strWalletPass)) {\n+            throw JSONRPCError(RPC_WALLET_PASSPHRASE_INCORRECT, \"Error: The wallet passphrase entered was incorrect.\");\n+        }\n+\n+        pwallet->TopUpKeyPool();\n+\n+        pwallet->nRelockTime = GetTime() + nSleepTime;\n+        relock_time = pwallet->nRelockTime;\n+    }\n+\n+    // rpcRunLater must be called without cs_wallet held otherwise a deadlock\n+    // can occur. The deadlock would happen when RPCRunLater removes the\n+    // previous timer (and waits for the callback to finish if already running)\n+    // and the callback locks cs_wallet.\n+    AssertLockNotHeld(wallet->cs_wallet);\n+    // Keep a weak pointer to the wallet so that it is possible to unload the\n+    // wallet before the following callback is called. If a valid shared pointer\n+    // is acquired in the callback then the wallet is still loaded.\n+    std::weak_ptr<CWallet> weak_wallet = wallet;\n+    pwallet->chain().rpcRunLater(strprintf(\"lockwallet(%s)\", pwallet->GetName()), [weak_wallet, relock_time] {\n+        if (auto shared_wallet = weak_wallet.lock()) {\n+            LOCK(shared_wallet->cs_wallet);\n+            // Skip if this is not the most recent rpcRunLater callback.\n+            if (shared_wallet->nRelockTime != relock_time) return;\n+            shared_wallet->Lock();\n+            shared_wallet->nRelockTime = 0;\n+        }\n+    }, nSleepTime);\n+\n+    return NullUniValue;\n+},\n+    };\n+}\n+\n+\n+RPCHelpMan walletpassphrasechange()\n+{\n+    return RPCHelpMan{\"walletpassphrasechange\",\n+                \"\\nChanges the wallet passphrase from 'oldpassphrase' to 'newpassphrase'.\\n\",\n+                {\n+                    {\"oldpassphrase\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The current passphrase\"},\n+                    {\"newpassphrase\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The new passphrase\"},\n+                },\n+                RPCResult{RPCResult::Type::NONE, \"\", \"\"},\n+                RPCExamples{\n+                    HelpExampleCli(\"walletpassphrasechange\", \"\\\"old one\\\" \\\"new one\\\"\")\n+            + HelpExampleRpc(\"walletpassphrasechange\", \"\\\"old one\\\", \\\"new one\\\"\")\n+                },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+{\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n+\n+    LOCK(pwallet->cs_wallet);\n+\n+    if (!pwallet->IsCrypted()) {\n+        throw JSONRPCError(RPC_WALLET_WRONG_ENC_STATE, \"Error: running with an unencrypted wallet, but walletpassphrasechange was called.\");\n+    }\n+\n+    // TODO: get rid of these .c_str() calls by implementing SecureString::operator=(std::string)\n+    // Alternately, find a way to make request.params[0] mlock()'d to begin with.\n+    SecureString strOldWalletPass;\n+    strOldWalletPass.reserve(100);\n+    strOldWalletPass = request.params[0].get_str().c_str();\n+\n+    SecureString strNewWalletPass;\n+    strNewWalletPass.reserve(100);\n+    strNewWalletPass = request.params[1].get_str().c_str();\n+\n+    if (strOldWalletPass.empty() || strNewWalletPass.empty()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"passphrase can not be empty\");\n+    }\n+\n+    if (!pwallet->ChangeWalletPassphrase(strOldWalletPass, strNewWalletPass)) {\n+        throw JSONRPCError(RPC_WALLET_PASSPHRASE_INCORRECT, \"Error: The wallet passphrase entered was incorrect.\");\n+    }\n+\n+    return NullUniValue;\n+},\n+    };\n+}\n+\n+\n+RPCHelpMan walletlock()\n+{\n+    return RPCHelpMan{\"walletlock\",\n+                \"\\nRemoves the wallet encryption key from memory, locking the wallet.\\n\"\n+                \"After calling this method, you will need to call walletpassphrase again\\n\"\n+                \"before being able to call any methods which require the wallet to be unlocked.\\n\",\n+                {},\n+                RPCResult{RPCResult::Type::NONE, \"\", \"\"},\n+                RPCExamples{\n+            \"\\nSet the passphrase for 2 minutes to perform a transaction\\n\"\n+            + HelpExampleCli(\"walletpassphrase\", \"\\\"my pass phrase\\\" 120\") +\n+            \"\\nPerform a send (requires passphrase set)\\n\"\n+            + HelpExampleCli(\"sendtoaddress\", \"\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\" 1.0\") +\n+            \"\\nClear the passphrase since we are done before 2 minutes is up\\n\"\n+            + HelpExampleCli(\"walletlock\", \"\") +\n+            \"\\nAs a JSON-RPC call\\n\"\n+            + HelpExampleRpc(\"walletlock\", \"\")\n+                },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+{\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n+\n+    LOCK(pwallet->cs_wallet);\n+\n+    if (!pwallet->IsCrypted()) {\n+        throw JSONRPCError(RPC_WALLET_WRONG_ENC_STATE, \"Error: running with an unencrypted wallet, but walletlock was called.\");\n+    }\n+\n+    pwallet->Lock();\n+    pwallet->nRelockTime = 0;\n+\n+    return NullUniValue;\n+},\n+    };\n+}\n+\n+\n+RPCHelpMan encryptwallet()\n+{\n+    return RPCHelpMan{\"encryptwallet\",\n+                \"\\nEncrypts the wallet with 'passphrase'. This is for first time encryption.\\n\"\n+                \"After this, any calls that interact with private keys such as sending or signing \\n\"\n+                \"will require the passphrase to be set prior the making these calls.\\n\"\n+                \"Use the walletpassphrase call for this, and then walletlock call.\\n\"\n+                \"If the wallet is already encrypted, use the walletpassphrasechange call.\\n\",\n+                {\n+                    {\"passphrase\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The pass phrase to encrypt the wallet with. It must be at least 1 character, but should be long.\"},\n+                },\n+                RPCResult{RPCResult::Type::STR, \"\", \"A string with further instructions\"},\n+                RPCExamples{\n+            \"\\nEncrypt your wallet\\n\"\n+            + HelpExampleCli(\"encryptwallet\", \"\\\"my pass phrase\\\"\") +\n+            \"\\nNow set the passphrase to use the wallet, such as for signing or sending bitcoin\\n\"\n+            + HelpExampleCli(\"walletpassphrase\", \"\\\"my pass phrase\\\"\") +\n+            \"\\nNow we can do something like sign\\n\"\n+            + HelpExampleCli(\"signmessage\", \"\\\"address\\\" \\\"test message\\\"\") +\n+            \"\\nNow lock the wallet again by removing the passphrase\\n\"\n+            + HelpExampleCli(\"walletlock\", \"\") +\n+            \"\\nAs a JSON-RPC call\\n\"\n+            + HelpExampleRpc(\"encryptwallet\", \"\\\"my pass phrase\\\"\")\n+                },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+{\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n+\n+    LOCK(pwallet->cs_wallet);\n+\n+    if (pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n+        throw JSONRPCError(RPC_WALLET_ENCRYPTION_FAILED, \"Error: wallet does not contain private keys, nothing to encrypt.\");\n+    }\n+\n+    if (pwallet->IsCrypted()) {\n+        throw JSONRPCError(RPC_WALLET_WRONG_ENC_STATE, \"Error: running with an encrypted wallet, but encryptwallet was called.\");\n+    }\n+\n+    // TODO: get rid of this .c_str() by implementing SecureString::operator=(std::string)\n+    // Alternately, find a way to make request.params[0] mlock()'d to begin with.\n+    SecureString strWalletPass;\n+    strWalletPass.reserve(100);\n+    strWalletPass = request.params[0].get_str().c_str();\n+\n+    if (strWalletPass.empty()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"passphrase can not be empty\");\n+    }\n+\n+    if (!pwallet->EncryptWallet(strWalletPass)) {\n+        throw JSONRPCError(RPC_WALLET_ENCRYPTION_FAILED, \"Error: Failed to encrypt the wallet.\");\n+    }\n+\n+    return \"wallet encrypted; The keypool has been flushed and a new HD seed was generated (if you are using HD). You need to make a new backup.\";\n+},\n+    };\n+}"
      },
      {
        "sha": "abfef6829462cde1d11dcc084dd38ae187b76fb0",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 241,
        "changes": 247,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/acc8d3286b823c4c7117ed0a96955473e9531231/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/acc8d3286b823c4c7117ed0a96955473e9531231/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=acc8d3286b823c4c7117ed0a96955473e9531231",
        "patch": "@@ -1727,247 +1727,6 @@ static RPCHelpMan newkeypool()\n     };\n }\n \n-\n-static RPCHelpMan walletpassphrase()\n-{\n-    return RPCHelpMan{\"walletpassphrase\",\n-                \"\\nStores the wallet decryption key in memory for 'timeout' seconds.\\n\"\n-                \"This is needed prior to performing transactions related to private keys such as sending bitcoins\\n\"\n-            \"\\nNote:\\n\"\n-            \"Issuing the walletpassphrase command while the wallet is already unlocked will set a new unlock\\n\"\n-            \"time that overrides the old one.\\n\",\n-                {\n-                    {\"passphrase\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The wallet passphrase\"},\n-                    {\"timeout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The time to keep the decryption key in seconds; capped at 100000000 (~3 years).\"},\n-                },\n-                RPCResult{RPCResult::Type::NONE, \"\", \"\"},\n-                RPCExamples{\n-            \"\\nUnlock the wallet for 60 seconds\\n\"\n-            + HelpExampleCli(\"walletpassphrase\", \"\\\"my pass phrase\\\" 60\") +\n-            \"\\nLock the wallet again (before 60 seconds)\\n\"\n-            + HelpExampleCli(\"walletlock\", \"\") +\n-            \"\\nAs a JSON-RPC call\\n\"\n-            + HelpExampleRpc(\"walletpassphrase\", \"\\\"my pass phrase\\\", 60\")\n-                },\n-        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n-{\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n-\n-    int64_t nSleepTime;\n-    int64_t relock_time;\n-    // Prevent concurrent calls to walletpassphrase with the same wallet.\n-    LOCK(pwallet->m_unlock_mutex);\n-    {\n-        LOCK(pwallet->cs_wallet);\n-\n-        if (!pwallet->IsCrypted()) {\n-            throw JSONRPCError(RPC_WALLET_WRONG_ENC_STATE, \"Error: running with an unencrypted wallet, but walletpassphrase was called.\");\n-        }\n-\n-        // Note that the walletpassphrase is stored in request.params[0] which is not mlock()ed\n-        SecureString strWalletPass;\n-        strWalletPass.reserve(100);\n-        // TODO: get rid of this .c_str() by implementing SecureString::operator=(std::string)\n-        // Alternately, find a way to make request.params[0] mlock()'d to begin with.\n-        strWalletPass = request.params[0].get_str().c_str();\n-\n-        // Get the timeout\n-        nSleepTime = request.params[1].get_int64();\n-        // Timeout cannot be negative, otherwise it will relock immediately\n-        if (nSleepTime < 0) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Timeout cannot be negative.\");\n-        }\n-        // Clamp timeout\n-        constexpr int64_t MAX_SLEEP_TIME = 100000000; // larger values trigger a macos/libevent bug?\n-        if (nSleepTime > MAX_SLEEP_TIME) {\n-            nSleepTime = MAX_SLEEP_TIME;\n-        }\n-\n-        if (strWalletPass.empty()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"passphrase can not be empty\");\n-        }\n-\n-        if (!pwallet->Unlock(strWalletPass)) {\n-            throw JSONRPCError(RPC_WALLET_PASSPHRASE_INCORRECT, \"Error: The wallet passphrase entered was incorrect.\");\n-        }\n-\n-        pwallet->TopUpKeyPool();\n-\n-        pwallet->nRelockTime = GetTime() + nSleepTime;\n-        relock_time = pwallet->nRelockTime;\n-    }\n-\n-    // rpcRunLater must be called without cs_wallet held otherwise a deadlock\n-    // can occur. The deadlock would happen when RPCRunLater removes the\n-    // previous timer (and waits for the callback to finish if already running)\n-    // and the callback locks cs_wallet.\n-    AssertLockNotHeld(wallet->cs_wallet);\n-    // Keep a weak pointer to the wallet so that it is possible to unload the\n-    // wallet before the following callback is called. If a valid shared pointer\n-    // is acquired in the callback then the wallet is still loaded.\n-    std::weak_ptr<CWallet> weak_wallet = wallet;\n-    pwallet->chain().rpcRunLater(strprintf(\"lockwallet(%s)\", pwallet->GetName()), [weak_wallet, relock_time] {\n-        if (auto shared_wallet = weak_wallet.lock()) {\n-            LOCK(shared_wallet->cs_wallet);\n-            // Skip if this is not the most recent rpcRunLater callback.\n-            if (shared_wallet->nRelockTime != relock_time) return;\n-            shared_wallet->Lock();\n-            shared_wallet->nRelockTime = 0;\n-        }\n-    }, nSleepTime);\n-\n-    return NullUniValue;\n-},\n-    };\n-}\n-\n-\n-static RPCHelpMan walletpassphrasechange()\n-{\n-    return RPCHelpMan{\"walletpassphrasechange\",\n-                \"\\nChanges the wallet passphrase from 'oldpassphrase' to 'newpassphrase'.\\n\",\n-                {\n-                    {\"oldpassphrase\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The current passphrase\"},\n-                    {\"newpassphrase\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The new passphrase\"},\n-                },\n-                RPCResult{RPCResult::Type::NONE, \"\", \"\"},\n-                RPCExamples{\n-                    HelpExampleCli(\"walletpassphrasechange\", \"\\\"old one\\\" \\\"new one\\\"\")\n-            + HelpExampleRpc(\"walletpassphrasechange\", \"\\\"old one\\\", \\\"new one\\\"\")\n-                },\n-        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n-{\n-    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n-    if (!pwallet) return NullUniValue;\n-\n-    LOCK(pwallet->cs_wallet);\n-\n-    if (!pwallet->IsCrypted()) {\n-        throw JSONRPCError(RPC_WALLET_WRONG_ENC_STATE, \"Error: running with an unencrypted wallet, but walletpassphrasechange was called.\");\n-    }\n-\n-    // TODO: get rid of these .c_str() calls by implementing SecureString::operator=(std::string)\n-    // Alternately, find a way to make request.params[0] mlock()'d to begin with.\n-    SecureString strOldWalletPass;\n-    strOldWalletPass.reserve(100);\n-    strOldWalletPass = request.params[0].get_str().c_str();\n-\n-    SecureString strNewWalletPass;\n-    strNewWalletPass.reserve(100);\n-    strNewWalletPass = request.params[1].get_str().c_str();\n-\n-    if (strOldWalletPass.empty() || strNewWalletPass.empty()) {\n-        throw JSONRPCError(RPC_INVALID_PARAMETER, \"passphrase can not be empty\");\n-    }\n-\n-    if (!pwallet->ChangeWalletPassphrase(strOldWalletPass, strNewWalletPass)) {\n-        throw JSONRPCError(RPC_WALLET_PASSPHRASE_INCORRECT, \"Error: The wallet passphrase entered was incorrect.\");\n-    }\n-\n-    return NullUniValue;\n-},\n-    };\n-}\n-\n-\n-static RPCHelpMan walletlock()\n-{\n-    return RPCHelpMan{\"walletlock\",\n-                \"\\nRemoves the wallet encryption key from memory, locking the wallet.\\n\"\n-                \"After calling this method, you will need to call walletpassphrase again\\n\"\n-                \"before being able to call any methods which require the wallet to be unlocked.\\n\",\n-                {},\n-                RPCResult{RPCResult::Type::NONE, \"\", \"\"},\n-                RPCExamples{\n-            \"\\nSet the passphrase for 2 minutes to perform a transaction\\n\"\n-            + HelpExampleCli(\"walletpassphrase\", \"\\\"my pass phrase\\\" 120\") +\n-            \"\\nPerform a send (requires passphrase set)\\n\"\n-            + HelpExampleCli(\"sendtoaddress\", \"\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\" 1.0\") +\n-            \"\\nClear the passphrase since we are done before 2 minutes is up\\n\"\n-            + HelpExampleCli(\"walletlock\", \"\") +\n-            \"\\nAs a JSON-RPC call\\n\"\n-            + HelpExampleRpc(\"walletlock\", \"\")\n-                },\n-        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n-{\n-    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n-    if (!pwallet) return NullUniValue;\n-\n-    LOCK(pwallet->cs_wallet);\n-\n-    if (!pwallet->IsCrypted()) {\n-        throw JSONRPCError(RPC_WALLET_WRONG_ENC_STATE, \"Error: running with an unencrypted wallet, but walletlock was called.\");\n-    }\n-\n-    pwallet->Lock();\n-    pwallet->nRelockTime = 0;\n-\n-    return NullUniValue;\n-},\n-    };\n-}\n-\n-\n-static RPCHelpMan encryptwallet()\n-{\n-    return RPCHelpMan{\"encryptwallet\",\n-                \"\\nEncrypts the wallet with 'passphrase'. This is for first time encryption.\\n\"\n-                \"After this, any calls that interact with private keys such as sending or signing \\n\"\n-                \"will require the passphrase to be set prior the making these calls.\\n\"\n-                \"Use the walletpassphrase call for this, and then walletlock call.\\n\"\n-                \"If the wallet is already encrypted, use the walletpassphrasechange call.\\n\",\n-                {\n-                    {\"passphrase\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The pass phrase to encrypt the wallet with. It must be at least 1 character, but should be long.\"},\n-                },\n-                RPCResult{RPCResult::Type::STR, \"\", \"A string with further instructions\"},\n-                RPCExamples{\n-            \"\\nEncrypt your wallet\\n\"\n-            + HelpExampleCli(\"encryptwallet\", \"\\\"my pass phrase\\\"\") +\n-            \"\\nNow set the passphrase to use the wallet, such as for signing or sending bitcoin\\n\"\n-            + HelpExampleCli(\"walletpassphrase\", \"\\\"my pass phrase\\\"\") +\n-            \"\\nNow we can do something like sign\\n\"\n-            + HelpExampleCli(\"signmessage\", \"\\\"address\\\" \\\"test message\\\"\") +\n-            \"\\nNow lock the wallet again by removing the passphrase\\n\"\n-            + HelpExampleCli(\"walletlock\", \"\") +\n-            \"\\nAs a JSON-RPC call\\n\"\n-            + HelpExampleRpc(\"encryptwallet\", \"\\\"my pass phrase\\\"\")\n-                },\n-        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n-{\n-    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n-    if (!pwallet) return NullUniValue;\n-\n-    LOCK(pwallet->cs_wallet);\n-\n-    if (pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n-        throw JSONRPCError(RPC_WALLET_ENCRYPTION_FAILED, \"Error: wallet does not contain private keys, nothing to encrypt.\");\n-    }\n-\n-    if (pwallet->IsCrypted()) {\n-        throw JSONRPCError(RPC_WALLET_WRONG_ENC_STATE, \"Error: running with an encrypted wallet, but encryptwallet was called.\");\n-    }\n-\n-    // TODO: get rid of this .c_str() by implementing SecureString::operator=(std::string)\n-    // Alternately, find a way to make request.params[0] mlock()'d to begin with.\n-    SecureString strWalletPass;\n-    strWalletPass.reserve(100);\n-    strWalletPass = request.params[0].get_str().c_str();\n-\n-    if (strWalletPass.empty()) {\n-        throw JSONRPCError(RPC_INVALID_PARAMETER, \"passphrase can not be empty\");\n-    }\n-\n-    if (!pwallet->EncryptWallet(strWalletPass)) {\n-        throw JSONRPCError(RPC_WALLET_ENCRYPTION_FAILED, \"Error: Failed to encrypt the wallet.\");\n-    }\n-\n-    return \"wallet encrypted; The keypool has been flushed and a new HD seed was generated (if you are using HD). You need to make a new backup.\";\n-},\n-    };\n-}\n-\n static RPCHelpMan lockunspent()\n {\n     return RPCHelpMan{\"lockunspent\",\n@@ -4602,6 +4361,12 @@ RPCHelpMan signmessage();\n RPCHelpMan backupwallet();\n RPCHelpMan restorewallet();\n \n+// encryption\n+RPCHelpMan walletpassphrase();\n+RPCHelpMan walletpassphrasechange();\n+RPCHelpMan walletlock();\n+RPCHelpMan encryptwallet();\n+\n Span<const CRPCCommand> GetWalletRPCCommands()\n {\n // clang-format off"
      }
    ]
  }
]