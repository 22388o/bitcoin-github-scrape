[
  {
    "sha": "fa0572d0f3b083b4c8e2e883a66e2b198c6779f1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTA1NzJkMGYzYjA4M2I0YzhlMmU4ODNhNjZlMmIxOThjNjc3OWYx",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2020-07-28T05:40:49Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2020-08-28T08:42:04Z"
      },
      "message": "Pass mempool reference to chainstate constructor",
      "tree": {
        "sha": "7a2e75b21eb48418728fb704ec2e620eb194f671",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7a2e75b21eb48418728fb704ec2e620eb194f671"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa0572d0f3b083b4c8e2e883a66e2b198c6779f1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUgDBAv+M+dDpa93+/hG0c/fpl3w5c3q0pnUagfgMUH6YZA+68q27az7taNxlSPN\noMrOazZoExpkjX4A+1WPLOTiN9dbhP3G4arsLBKpsPv2PJeGKfF5oahDQT7TicB1\njy9+OEJehQYSeBCoqwDu4m4g4hOMesVoYTEY0m+UbCWH+Ngbcdj5ROcCWEdjZazB\nJjMOgi0qYMsLKEIVMFRKU8HWymTGKZKByrgT2W30newXw+j6EuxAZtAaN1zgY5IY\nICzN7OipSw3o5wWyNt0QmxHcNPH8aK1ZQB0dj0NJN587t9W6qF7XWWVwyWGa6AZ0\nC2n1SwFg2keHG4A/rkrW/dcJsW8nBGPM9zSgVkDZ8rD8C0XgdcqGOLUJBMXCtJdM\n/y0Edt/c8vSqaNk98gc23BqSg+zU1jM4GV3v4jQdF9oYtDklBAxkcmrbXT6IPWlC\n+XXf9IgKiaAkCik+/1yTMU+LpCDazya54tgyWMgRfDMb0PBrhMGEa6VYyo9shpEQ\n1oBxGJsv\n=/7Xo\n-----END PGP SIGNATURE-----",
        "payload": "tree 7a2e75b21eb48418728fb704ec2e620eb194f671\nparent 862fde88be706adb20a211178253636442c3ae00\nauthor MarcoFalke <falke.marco@gmail.com> 1595914849 +0200\ncommitter MarcoFalke <falke.marco@gmail.com> 1598604124 +0200\n\nPass mempool reference to chainstate constructor\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa0572d0f3b083b4c8e2e883a66e2b198c6779f1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa0572d0f3b083b4c8e2e883a66e2b198c6779f1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa0572d0f3b083b4c8e2e883a66e2b198c6779f1/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "862fde88be706adb20a211178253636442c3ae00",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/862fde88be706adb20a211178253636442c3ae00",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/862fde88be706adb20a211178253636442c3ae00"
      }
    ],
    "stats": {
      "total": 92,
      "additions": 55,
      "deletions": 37
    },
    "files": [
      {
        "sha": "80edc604aad2766c52e416215558166afd944a3a",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0572d0f3b083b4c8e2e883a66e2b198c6779f1/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0572d0f3b083b4c8e2e883a66e2b198c6779f1/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=fa0572d0f3b083b4c8e2e883a66e2b198c6779f1",
        "patch": "@@ -1550,7 +1550,7 @@ bool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA\n             const int64_t load_block_index_start_time = GetTimeMillis();\n             try {\n                 LOCK(cs_main);\n-                chainman.InitializeChainstate();\n+                chainman.InitializeChainstate(*Assert(node.mempool));\n                 chainman.m_total_coinstip_cache = nCoinCacheUsage;\n                 chainman.m_total_coinsdb_cache = nCoinDBCache;\n "
      },
      {
        "sha": "8a88e75892d9f9e2a13d55c5467adc1e3a64d63b",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0572d0f3b083b4c8e2e883a66e2b198c6779f1/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0572d0f3b083b4c8e2e883a66e2b198c6779f1/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=fa0572d0f3b083b4c8e2e883a66e2b198c6779f1",
        "patch": "@@ -141,8 +141,11 @@ TestingSetup::TestingSetup(const std::string& chainName, const std::vector<const\n \n     pblocktree.reset(new CBlockTreeDB(1 << 20, true));\n \n+    m_node.mempool = &::mempool;\n+    m_node.mempool->setSanityCheck(1.0);\n+\n     m_node.chainman = &::g_chainman;\n-    m_node.chainman->InitializeChainstate();\n+    m_node.chainman->InitializeChainstate(*m_node.mempool);\n     ::ChainstateActive().InitCoinsDB(\n         /* cache_size_bytes */ 1 << 23, /* in_memory */ true, /* should_wipe */ false);\n     assert(!::ChainstateActive().CanFlushToDisk());\n@@ -164,8 +167,6 @@ TestingSetup::TestingSetup(const std::string& chainName, const std::vector<const\n     }\n     g_parallel_script_checks = true;\n \n-    m_node.mempool = &::mempool;\n-    m_node.mempool->setSanityCheck(1.0);\n     m_node.banman = MakeUnique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     m_node.connman = MakeUnique<CConnman>(0x1337, 0x1337); // Deterministic randomness for tests.\n     m_node.peer_logic = MakeUnique<PeerLogicValidation>(*m_node.connman, m_node.banman.get(), *m_node.scheduler, *m_node.chainman, *m_node.mempool);"
      },
      {
        "sha": "c8a375275f902456ce56c0b32d26ff339bf8e806",
        "filename": "src/test/validation_chainstate_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0572d0f3b083b4c8e2e883a66e2b198c6779f1/src/test/validation_chainstate_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0572d0f3b083b4c8e2e883a66e2b198c6779f1/src/test/validation_chainstate_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_chainstate_tests.cpp?ref=fa0572d0f3b083b4c8e2e883a66e2b198c6779f1",
        "patch": "@@ -20,6 +20,7 @@ BOOST_FIXTURE_TEST_SUITE(validation_chainstate_tests, TestingSetup)\n BOOST_AUTO_TEST_CASE(validation_chainstate_resize_caches)\n {\n     ChainstateManager manager;\n+    CTxMemPool mempool;\n \n     //! Create and add a Coin with DynamicMemoryUsage of 80 bytes to the given view.\n     auto add_coin = [](CCoinsViewCache& coins_view) -> COutPoint {\n@@ -34,7 +35,7 @@ BOOST_AUTO_TEST_CASE(validation_chainstate_resize_caches)\n         return outp;\n     };\n \n-    CChainState& c1 = *WITH_LOCK(cs_main, return &manager.InitializeChainstate());\n+    CChainState& c1 = *WITH_LOCK(cs_main, return &manager.InitializeChainstate(mempool));\n     c1.InitCoinsDB(\n         /* cache_size_bytes */ 1 << 23, /* in_memory */ true, /* should_wipe */ false);\n     WITH_LOCK(::cs_main, c1.InitCoinsCache(1 << 23));"
      },
      {
        "sha": "36badafc4e27315302848726fc60d595c45709ff",
        "filename": "src/test/validation_chainstatemanager_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0572d0f3b083b4c8e2e883a66e2b198c6779f1/src/test/validation_chainstatemanager_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0572d0f3b083b4c8e2e883a66e2b198c6779f1/src/test/validation_chainstatemanager_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_chainstatemanager_tests.cpp?ref=fa0572d0f3b083b4c8e2e883a66e2b198c6779f1",
        "patch": "@@ -23,12 +23,13 @@ BOOST_FIXTURE_TEST_SUITE(validation_chainstatemanager_tests, TestingSetup)\n BOOST_AUTO_TEST_CASE(chainstatemanager)\n {\n     ChainstateManager manager;\n+    CTxMemPool mempool;\n     std::vector<CChainState*> chainstates;\n     const CChainParams& chainparams = Params();\n \n     // Create a legacy (IBD) chainstate.\n     //\n-    CChainState& c1 = *WITH_LOCK(::cs_main, return &manager.InitializeChainstate());\n+    CChainState& c1 = *WITH_LOCK(::cs_main, return &manager.InitializeChainstate(mempool));\n     chainstates.push_back(&c1);\n     c1.InitCoinsDB(\n         /* cache_size_bytes */ 1 << 23, /* in_memory */ true, /* should_wipe */ false);\n@@ -54,7 +55,7 @@ BOOST_AUTO_TEST_CASE(chainstatemanager)\n \n     // Create a snapshot-based chainstate.\n     //\n-    CChainState& c2 = *WITH_LOCK(::cs_main, return &manager.InitializeChainstate(GetRandHash()));\n+    CChainState& c2 = *WITH_LOCK(::cs_main, return &manager.InitializeChainstate(mempool, GetRandHash()));\n     chainstates.push_back(&c2);\n     c2.InitCoinsDB(\n         /* cache_size_bytes */ 1 << 23, /* in_memory */ true, /* should_wipe */ false);\n@@ -104,6 +105,7 @@ BOOST_AUTO_TEST_CASE(chainstatemanager)\n BOOST_AUTO_TEST_CASE(chainstatemanager_rebalance_caches)\n {\n     ChainstateManager manager;\n+    CTxMemPool mempool;\n     size_t max_cache = 10000;\n     manager.m_total_coinsdb_cache = max_cache;\n     manager.m_total_coinstip_cache = max_cache;\n@@ -112,7 +114,7 @@ BOOST_AUTO_TEST_CASE(chainstatemanager_rebalance_caches)\n \n     // Create a legacy (IBD) chainstate.\n     //\n-    CChainState& c1 = *WITH_LOCK(cs_main, return &manager.InitializeChainstate());\n+    CChainState& c1 = *WITH_LOCK(cs_main, return &manager.InitializeChainstate(mempool));\n     chainstates.push_back(&c1);\n     c1.InitCoinsDB(\n         /* cache_size_bytes */ 1 << 23, /* in_memory */ true, /* should_wipe */ false);\n@@ -129,7 +131,7 @@ BOOST_AUTO_TEST_CASE(chainstatemanager_rebalance_caches)\n \n     // Create a snapshot-based chainstate.\n     //\n-    CChainState& c2 = *WITH_LOCK(cs_main, return &manager.InitializeChainstate(GetRandHash()));\n+    CChainState& c2 = *WITH_LOCK(cs_main, return &manager.InitializeChainstate(mempool, GetRandHash()));\n     chainstates.push_back(&c2);\n     c2.InitCoinsDB(\n         /* cache_size_bytes */ 1 << 23, /* in_memory */ true, /* should_wipe */ false);\n@@ -147,7 +149,6 @@ BOOST_AUTO_TEST_CASE(chainstatemanager_rebalance_caches)\n     BOOST_CHECK_CLOSE(c1.m_coinsdb_cache_size_bytes, max_cache * 0.05, 1);\n     BOOST_CHECK_CLOSE(c2.m_coinstip_cache_size_bytes, max_cache * 0.95, 1);\n     BOOST_CHECK_CLOSE(c2.m_coinsdb_cache_size_bytes, max_cache * 0.95, 1);\n-\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "a3b344d2c9b3fe034153bee0dcb8620dbe7d2f26",
        "filename": "src/test/validation_flush_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0572d0f3b083b4c8e2e883a66e2b198c6779f1/src/test/validation_flush_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0572d0f3b083b4c8e2e883a66e2b198c6779f1/src/test/validation_flush_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_flush_tests.cpp?ref=fa0572d0f3b083b4c8e2e883a66e2b198c6779f1",
        "patch": "@@ -18,8 +18,9 @@ BOOST_FIXTURE_TEST_SUITE(validation_flush_tests, BasicTestingSetup)\n //!\n BOOST_AUTO_TEST_CASE(getcoinscachesizestate)\n {\n+    CTxMemPool mempool;\n     BlockManager blockman{};\n-    CChainState chainstate{blockman};\n+    CChainState chainstate{mempool, blockman};\n     chainstate.InitCoinsDB(/*cache_size_bytes*/ 1 << 10, /*in_memory*/ true, /*should_wipe*/ false);\n     WITH_LOCK(::cs_main, chainstate.InitCoinsCache(1 << 10));\n     CTxMemPool tx_pool{};"
      },
      {
        "sha": "58af8744d90256b96250df172fd7504849e3ba81",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 21,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0572d0f3b083b4c8e2e883a66e2b198c6779f1/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0572d0f3b083b4c8e2e883a66e2b198c6779f1/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=fa0572d0f3b083b4c8e2e883a66e2b198c6779f1",
        "patch": "@@ -370,9 +370,10 @@ static bool IsCurrentForFeeEstimation() EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n  * and instead just erase from the mempool as needed.\n  */\n \n-static void UpdateMempoolForReorg(DisconnectedBlockTransactions& disconnectpool, bool fAddToMempool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, ::mempool.cs)\n+static void UpdateMempoolForReorg(CTxMemPool& mempool, DisconnectedBlockTransactions& disconnectpool, bool fAddToMempool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, mempool.cs)\n {\n     AssertLockHeld(cs_main);\n+    AssertLockHeld(mempool.cs);\n     std::vector<uint256> vHashUpdate;\n     // disconnectpool's insertion_order index sorts the entries from\n     // oldest to newest, but the oldest entry will be the last tx from the\n@@ -1254,8 +1255,9 @@ void CoinsViews::InitCache()\n     m_cacheview = MakeUnique<CCoinsViewCache>(&m_catcherview);\n }\n \n-CChainState::CChainState(BlockManager& blockman, uint256 from_snapshot_blockhash)\n+CChainState::CChainState(CTxMemPool& mempool, BlockManager& blockman, uint256 from_snapshot_blockhash)\n     : m_blockman(blockman),\n+      m_mempool(mempool),\n       m_from_snapshot_blockhash(from_snapshot_blockhash) {}\n \n void CChainState::InitCoinsDB(\n@@ -2280,7 +2282,7 @@ bool CChainState::FlushStateToDisk(\n     {\n         bool fFlushForPrune = false;\n         bool fDoFullFlush = false;\n-        CoinsCacheSizeState cache_state = GetCoinsCacheSizeState(&::mempool);\n+        CoinsCacheSizeState cache_state = GetCoinsCacheSizeState(&m_mempool);\n         LOCK(cs_LastBlockFile);\n         if (fPruneMode && (fCheckForPruning || nManualPruneHeight > 0) && !fReindex) {\n             if (nManualPruneHeight > 0) {\n@@ -2426,7 +2428,7 @@ static void AppendWarning(bilingual_str& res, const bilingual_str& warn)\n }\n \n /** Check warning conditions and do some notifications on new chain tip set. */\n-void static UpdateTip(const CBlockIndex* pindexNew, const CChainParams& chainParams)\n+static void UpdateTip(CTxMemPool& mempool, const CBlockIndex* pindexNew, const CChainParams& chainParams)\n     EXCLUSIVE_LOCKS_REQUIRED(::cs_main)\n {\n     // New best block\n@@ -2472,7 +2474,6 @@ void static UpdateTip(const CBlockIndex* pindexNew, const CChainParams& chainPar\n       FormatISO8601DateTime(pindexNew->GetBlockTime()),\n       GuessVerificationProgress(chainParams.TxData(), pindexNew), ::ChainstateActive().CoinsTip().DynamicMemoryUsage() * (1.0 / (1<<20)), ::ChainstateActive().CoinsTip().GetCacheSize(),\n       !warning_messages.empty() ? strprintf(\" warning='%s'\", warning_messages.original) : \"\");\n-\n }\n \n /** Disconnect m_chain's tip.\n@@ -2485,8 +2486,11 @@ void static UpdateTip(const CBlockIndex* pindexNew, const CChainParams& chainPar\n   * disconnectpool (note that the caller is responsible for mempool consistency\n   * in any case).\n   */\n-bool CChainState::DisconnectTip(BlockValidationState& state, const CChainParams& chainparams, DisconnectedBlockTransactions *disconnectpool)\n+bool CChainState::DisconnectTip(BlockValidationState& state, const CChainParams& chainparams, DisconnectedBlockTransactions* disconnectpool)\n {\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(m_mempool.cs);\n+\n     CBlockIndex *pindexDelete = m_chain.Tip();\n     assert(pindexDelete);\n     // Read block from disk.\n@@ -2517,14 +2521,14 @@ bool CChainState::DisconnectTip(BlockValidationState& state, const CChainParams&\n         while (disconnectpool->DynamicMemoryUsage() > MAX_DISCONNECTED_TX_POOL_SIZE * 1000) {\n             // Drop the earliest entry, and remove its children from the mempool.\n             auto it = disconnectpool->queuedTx.get<insertion_order>().begin();\n-            mempool.removeRecursive(**it, MemPoolRemovalReason::REORG);\n+            m_mempool.removeRecursive(**it, MemPoolRemovalReason::REORG);\n             disconnectpool->removeEntry(it);\n         }\n     }\n \n     m_chain.SetTip(pindexDelete->pprev);\n \n-    UpdateTip(pindexDelete->pprev, chainparams);\n+    UpdateTip(m_mempool, pindexDelete->pprev, chainparams);\n     // Let wallets know transactions went from 1-confirmed to\n     // 0-confirmed or conflicted:\n     GetMainSignals().BlockDisconnected(pblock, pindexDelete);\n@@ -2585,6 +2589,9 @@ class ConnectTrace {\n  */\n bool CChainState::ConnectTip(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions &disconnectpool)\n {\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(m_mempool.cs);\n+\n     assert(pindexNew->pprev == m_chain.Tip());\n     // Read block from disk.\n     int64_t nTime1 = GetTimeMicros();\n@@ -2625,11 +2632,11 @@ bool CChainState::ConnectTip(BlockValidationState& state, const CChainParams& ch\n     int64_t nTime5 = GetTimeMicros(); nTimeChainState += nTime5 - nTime4;\n     LogPrint(BCLog::BENCH, \"  - Writing chainstate: %.2fms [%.2fs (%.2fms/blk)]\\n\", (nTime5 - nTime4) * MILLI, nTimeChainState * MICRO, nTimeChainState * MILLI / nBlocksTotal);\n     // Remove conflicting transactions from the mempool.;\n-    mempool.removeForBlock(blockConnecting.vtx, pindexNew->nHeight);\n+    m_mempool.removeForBlock(blockConnecting.vtx, pindexNew->nHeight);\n     disconnectpool.removeForBlock(blockConnecting.vtx);\n     // Update m_chain & related variables.\n     m_chain.SetTip(pindexNew);\n-    UpdateTip(pindexNew, chainparams);\n+    UpdateTip(m_mempool, pindexNew, chainparams);\n \n     int64_t nTime6 = GetTimeMicros(); nTimePostConnect += nTime6 - nTime5; nTimeTotal += nTime6 - nTime1;\n     LogPrint(BCLog::BENCH, \"  - Connect postprocess: %.2fms [%.2fs (%.2fms/blk)]\\n\", (nTime6 - nTime5) * MILLI, nTimePostConnect * MICRO, nTimePostConnect * MILLI / nBlocksTotal);\n@@ -2719,6 +2726,7 @@ void CChainState::PruneBlockIndexCandidates() {\n bool CChainState::ActivateBestChainStep(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace)\n {\n     AssertLockHeld(cs_main);\n+    AssertLockHeld(m_mempool.cs);\n \n     const CBlockIndex *pindexOldTip = m_chain.Tip();\n     const CBlockIndex *pindexFork = m_chain.FindFork(pindexMostWork);\n@@ -2730,7 +2738,7 @@ bool CChainState::ActivateBestChainStep(BlockValidationState& state, const CChai\n         if (!DisconnectTip(state, chainparams, &disconnectpool)) {\n             // This is likely a fatal error, but keep the mempool consistent,\n             // just in case. Only remove from the mempool in this case.\n-            UpdateMempoolForReorg(disconnectpool, false);\n+            UpdateMempoolForReorg(m_mempool, disconnectpool, false);\n \n             // If we're unable to disconnect a block during normal operation,\n             // then that is a failure of our local system -- we should abort\n@@ -2774,7 +2782,7 @@ bool CChainState::ActivateBestChainStep(BlockValidationState& state, const CChai\n                     // A system error occurred (disk space, database error, ...).\n                     // Make the mempool consistent with the current tip, just in case\n                     // any observers try to use it before shutdown.\n-                    UpdateMempoolForReorg(disconnectpool, false);\n+                    UpdateMempoolForReorg(m_mempool, disconnectpool, false);\n                     return false;\n                 }\n             } else {\n@@ -2791,9 +2799,9 @@ bool CChainState::ActivateBestChainStep(BlockValidationState& state, const CChai\n     if (fBlocksDisconnected) {\n         // If any blocks were disconnected, disconnectpool may be non empty.  Add\n         // any disconnected transactions back to the mempool.\n-        UpdateMempoolForReorg(disconnectpool, true);\n+        UpdateMempoolForReorg(m_mempool, disconnectpool, true);\n     }\n-    mempool.check(&CoinsTip());\n+    m_mempool.check(&CoinsTip());\n \n     // Callbacks/notifications for a new best chain.\n     if (fInvalidFound)\n@@ -2867,7 +2875,8 @@ bool CChainState::ActivateBestChain(BlockValidationState &state, const CChainPar\n         LimitValidationInterfaceQueue();\n \n         {\n-            LOCK2(cs_main, ::mempool.cs); // Lock transaction pool for at least as long as it takes for connectTrace to be consumed\n+            LOCK(cs_main);\n+            LOCK(m_mempool.cs); // Lock transaction pool for at least as long as it takes for connectTrace to be consumed\n             CBlockIndex* starting_tip = m_chain.Tip();\n             bool blocks_connected = false;\n             do {\n@@ -3020,7 +3029,7 @@ bool CChainState::InvalidateBlock(BlockValidationState& state, const CChainParam\n         LimitValidationInterfaceQueue();\n \n         LOCK(cs_main);\n-        LOCK(::mempool.cs); // Lock for as long as disconnectpool is in scope to make sure UpdateMempoolForReorg is called after DisconnectTip without unlocking in between\n+        LOCK(m_mempool.cs); // Lock for as long as disconnectpool is in scope to make sure UpdateMempoolForReorg is called after DisconnectTip without unlocking in between\n         if (!m_chain.Contains(pindex)) break;\n         pindex_was_in_chain = true;\n         CBlockIndex *invalid_walk_tip = m_chain.Tip();\n@@ -3034,7 +3043,7 @@ bool CChainState::InvalidateBlock(BlockValidationState& state, const CChainParam\n         // transactions back to the mempool if disconnecting was successful,\n         // and we're not doing a very deep invalidation (in which case\n         // keeping the mempool up to date is probably futile anyway).\n-        UpdateMempoolForReorg(disconnectpool, /* fAddToMempool = */ (++disconnected <= 10) && ret);\n+        UpdateMempoolForReorg(m_mempool, disconnectpool, /* fAddToMempool = */ (++disconnected <= 10) && ret);\n         if (!ret) return false;\n         assert(invalid_walk_tip->pprev == m_chain.Tip());\n \n@@ -4517,7 +4526,8 @@ bool CChainState::RewindBlockIndex(const CChainParams& params)\n     // Loop until the tip is below nHeight, or we reach a pruned block.\n     while (!ShutdownRequested()) {\n         {\n-            LOCK2(cs_main, ::mempool.cs);\n+            LOCK(cs_main);\n+            LOCK(m_mempool.cs);\n             // Make sure nothing changed from under us (this won't happen because RewindBlockIndex runs before importing/network are active)\n             assert(tip == m_chain.Tip());\n             if (tip == nullptr || tip->nHeight < nHeight) break;\n@@ -5246,7 +5256,7 @@ std::vector<CChainState*> ChainstateManager::GetAll()\n     return out;\n }\n \n-CChainState& ChainstateManager::InitializeChainstate(const uint256& snapshot_blockhash)\n+CChainState& ChainstateManager::InitializeChainstate(CTxMemPool& mempool, const uint256& snapshot_blockhash)\n {\n     bool is_snapshot = !snapshot_blockhash.IsNull();\n     std::unique_ptr<CChainState>& to_modify =\n@@ -5255,8 +5265,7 @@ CChainState& ChainstateManager::InitializeChainstate(const uint256& snapshot_blo\n     if (to_modify) {\n         throw std::logic_error(\"should not be overwriting a chainstate\");\n     }\n-\n-    to_modify.reset(new CChainState(m_blockman, snapshot_blockhash));\n+    to_modify.reset(new CChainState(mempool, m_blockman, snapshot_blockhash));\n \n     // Snapshot chainstates and initial IBD chaintates always become active.\n     if (is_snapshot || (!is_snapshot && !m_active_chainstate)) {"
      },
      {
        "sha": "bb59b57f6b16b19f66b9da8818e010414a9b4989",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 10,
        "deletions": 5,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa0572d0f3b083b4c8e2e883a66e2b198c6779f1/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa0572d0f3b083b4c8e2e883a66e2b198c6779f1/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=fa0572d0f3b083b4c8e2e883a66e2b198c6779f1",
        "patch": "@@ -511,11 +511,14 @@ class CChainState {\n     //! easily as opposed to referencing a global.\n     BlockManager& m_blockman;\n \n+    //! mempool that is kept in sync with the chain\n+    CTxMemPool& m_mempool;\n+\n     //! Manages the UTXO set, which is a reflection of the contents of `m_chain`.\n     std::unique_ptr<CoinsViews> m_coins_views;\n \n public:\n-    explicit CChainState(BlockManager& blockman, uint256 from_snapshot_blockhash = uint256());\n+    explicit CChainState(CTxMemPool& mempool, BlockManager& blockman, uint256 from_snapshot_blockhash = uint256());\n \n     /**\n      * Initialize the CoinsViews UTXO set database management data structures. The in-memory\n@@ -642,7 +645,7 @@ class CChainState {\n                       CCoinsViewCache& view, const CChainParams& chainparams, bool fJustCheck = false) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     // Apply the effects of a block disconnection on the UTXO set.\n-    bool DisconnectTip(BlockValidationState& state, const CChainParams& chainparams, DisconnectedBlockTransactions* disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, ::mempool.cs);\n+    bool DisconnectTip(BlockValidationState& state, const CChainParams& chainparams, DisconnectedBlockTransactions* disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_mempool.cs);\n \n     // Manual block validity manipulation:\n     bool PreciousBlock(BlockValidationState& state, const CChainParams& params, CBlockIndex* pindex) LOCKS_EXCLUDED(cs_main);\n@@ -685,8 +688,8 @@ class CChainState {\n     std::string ToString() EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n \n private:\n-    bool ActivateBestChainStep(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace) EXCLUSIVE_LOCKS_REQUIRED(cs_main, ::mempool.cs);\n-    bool ConnectTip(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions& disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, ::mempool.cs);\n+    bool ActivateBestChainStep(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_mempool.cs);\n+    bool ConnectTip(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions& disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_mempool.cs);\n \n     void InvalidBlockFound(CBlockIndex *pindex, const BlockValidationState &state) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     CBlockIndex* FindMostWorkChain() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n@@ -818,9 +821,11 @@ class ChainstateManager\n     //! Instantiate a new chainstate and assign it based upon whether it is\n     //! from a snapshot.\n     //!\n+    //! @param[in] mempool              The mempool to pass to the chainstate\n+    //                                  constructor\n     //! @param[in] snapshot_blockhash   If given, signify that this chainstate\n     //!                                 is based on a snapshot.\n-    CChainState& InitializeChainstate(const uint256& snapshot_blockhash = uint256())\n+    CChainState& InitializeChainstate(CTxMemPool& mempool, const uint256& snapshot_blockhash = uint256())\n         EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n \n     //! Get all chainstates currently being used."
      }
    ]
  }
]