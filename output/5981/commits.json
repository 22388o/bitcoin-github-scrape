[
  {
    "sha": "6c1d1ba6fccd76e3690bac8341687c0921758e30",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2YzFkMWJhNmZjY2Q3NmUzNjkwYmFjODM0MTY4N2MwOTIxNzU4ZTMw",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-04-28T16:36:15Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-04-28T16:38:29Z"
      },
      "message": "Python p2p testing framework\n\nmininode.py provides a framework for connecting to a bitcoin node over the p2p\nnetwork. NodeConn is the main object that manages connectivity to a node and\nprovides callbacks; the interface for those callbacks is defined by NodeConnCB.\nDefined also are all data structures from bitcoin core that pass on the network\n(CBlock, CTransaction, etc), along with de-/serialization functions.\n\nmaxblocksinflight.py is an example test using this framework that tests whether\na node is limiting the maximum number of in-flight block requests.\n\nThis also adds support to util.py for specifying the binary to use when\nstarting nodes (for tests that compare the behavior of different bitcoind\nversions), and adds maxblocksinflight.py to the pull tester.",
      "tree": {
        "sha": "1b4edb379b9c83c52c0b888dd3f460c73420826f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1b4edb379b9c83c52c0b888dd3f460c73420826f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6c1d1ba6fccd76e3690bac8341687c0921758e30",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6c1d1ba6fccd76e3690bac8341687c0921758e30",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6c1d1ba6fccd76e3690bac8341687c0921758e30",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6c1d1ba6fccd76e3690bac8341687c0921758e30/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7bf5d5efa60c89c0e0c353dddc2a76fe4f243808",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7bf5d5efa60c89c0e0c353dddc2a76fe4f243808",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7bf5d5efa60c89c0e0c353dddc2a76fe4f243808"
      }
    ],
    "stats": {
      "total": 1358,
      "additions": 1354,
      "deletions": 4
    },
    "files": [
      {
        "sha": "6d57d58755bc695156b58ae6c8a3280fcfddb289",
        "filename": "qa/pull-tester/rpc-tests.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6c1d1ba6fccd76e3690bac8341687c0921758e30/qa/pull-tester/rpc-tests.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6c1d1ba6fccd76e3690bac8341687c0921758e30/qa/pull-tester/rpc-tests.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.sh?ref=6c1d1ba6fccd76e3690bac8341687c0921758e30",
        "patch": "@@ -30,6 +30,7 @@ testScripts=(\n     'proxy_test.py'\n     'merkle_blocks.py'\n #    'forknotify.py'\n+    'maxblocksinflight.py'\n );\n if [ \"x${ENABLE_BITCOIND}${ENABLE_UTILS}${ENABLE_WALLET}\" = \"x111\" ]; then\n     for (( i = 0; i < ${#testScripts[@]}; i++ ))"
      },
      {
        "sha": "4bfe2039908f201d9835f1e406173a068a9377b4",
        "filename": "qa/rpc-tests/maxblocksinflight.py",
        "status": "added",
        "additions": 99,
        "deletions": 0,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6c1d1ba6fccd76e3690bac8341687c0921758e30/qa/rpc-tests/maxblocksinflight.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6c1d1ba6fccd76e3690bac8341687c0921758e30/qa/rpc-tests/maxblocksinflight.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/maxblocksinflight.py?ref=6c1d1ba6fccd76e3690bac8341687c0921758e30",
        "patch": "@@ -0,0 +1,99 @@\n+#!/usr/bin/env python2\n+#\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+from mininode import *\n+from test_framework import BitcoinTestFramework\n+from util import *\n+import logging\n+\n+'''\n+In this test we connect to one node over p2p, send it numerous inv's, and\n+compare the resulting number of getdata requests to a max allowed value.  We\n+test for exceeding 128 blocks in flight, which was the limit an 0.9 client will\n+reach. [0.10 clients shouldn't request more than 16 from a single peer.]\n+'''\n+MAX_REQUESTS = 128\n+\n+class TestManager(NodeConnCB):\n+    # set up NodeConnCB callbacks, overriding base class\n+    def on_getdata(self, conn, message):\n+        self.log.debug(\"got getdata %s\" % repr(message))\n+        # Log the requests\n+        for inv in message.inv:\n+            if inv.hash not in self.blockReqCounts:\n+                self.blockReqCounts[inv.hash] = 0\n+            self.blockReqCounts[inv.hash] += 1\n+\n+    def on_close(self, conn):\n+        if not self.disconnectOkay:\n+            raise EarlyDisconnectError(0)\n+\n+    def __init__(self):\n+        NodeConnCB.__init__(self)\n+        self.log = logging.getLogger(\"BlockRelayTest\")\n+        self.create_callback_map()\n+\n+    def add_new_connection(self, connection):\n+        self.connection = connection\n+        self.blockReqCounts = {}\n+        self.disconnectOkay = False\n+\n+    def run(self):\n+        try:\n+            fail = False\n+            self.connection.rpc.generate(1) # Leave IBD\n+\n+            numBlocksToGenerate = [ 8, 16, 128, 1024 ]\n+            for count in range(len(numBlocksToGenerate)):\n+                current_invs = []\n+                for i in range(numBlocksToGenerate[count]):\n+                    current_invs.append(CInv(2, random.randrange(0, 1<<256)))\n+                    if len(current_invs) >= 50000:\n+                        self.connection.send_message(msg_inv(current_invs))\n+                        current_invs = []\n+                if len(current_invs) > 0:\n+                    self.connection.send_message(msg_inv(current_invs))\n+                \n+                # Wait and see how many blocks were requested\n+                time.sleep(2)\n+\n+                total_requests = 0\n+                for key in self.blockReqCounts:\n+                    total_requests += self.blockReqCounts[key]\n+                    if self.blockReqCounts[key] > 1:\n+                        raise AssertionError(\"Error, test failed: block %064x requested more than once\" % key)\n+                if total_requests > MAX_REQUESTS:\n+                    raise AssertionError(\"Error, too many blocks (%d) requested\" % total_requests)\n+                print \"Round %d: success (total requests: %d)\" % (count, total_requests)\n+        except AssertionError as e:\n+            print \"TEST FAILED: \", e.args\n+\n+        self.disconnectOkay = True\n+        self.connection.disconnect_node()\n+\n+        \n+class MaxBlocksInFlightTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        parser.add_option(\"--testbinary\", dest=\"testbinary\", default=\"bitcoind\",\n+                          help=\"Binary to test max block requests behavior\")\n+\n+    def setup_chain(self):\n+        print \"Initializing test directory \"+self.options.tmpdir\n+        initialize_chain_clean(self.options.tmpdir, 1)\n+\n+    def setup_network(self):\n+        self.nodes = start_nodes(1, self.options.tmpdir, \n+                                 extra_args=[['-debug', '-whitelist=127.0.0.1']],\n+                                 binary=[self.options.testbinary])\n+\n+    def run_test(self):\n+        test = TestManager()\n+        test.add_new_connection(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], test))\n+        NetworkThread().start()  # Start up network handling in another thread\n+        test.run()\n+\n+if __name__ == '__main__':\n+    MaxBlocksInFlightTest().main()"
      },
      {
        "sha": "c5c1bcfbbef1324d7178bf49d9bfc2c0b3cbfd86",
        "filename": "qa/rpc-tests/mininode.py",
        "status": "added",
        "additions": 1247,
        "deletions": 0,
        "changes": 1247,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6c1d1ba6fccd76e3690bac8341687c0921758e30/qa/rpc-tests/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6c1d1ba6fccd76e3690bac8341687c0921758e30/qa/rpc-tests/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/mininode.py?ref=6c1d1ba6fccd76e3690bac8341687c0921758e30",
        "patch": "@@ -0,0 +1,1247 @@\n+# mininode.py - Bitcoin P2P network half-a-node\n+#\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+# This python code was modified from ArtForz' public domain  half-a-node, as\n+# found in the mini-node branch of http://github.com/jgarzik/pynode.\n+#\n+# NodeConn: an object which manages p2p connectivity to a bitcoin node\n+# NodeConnCB: a base class that describes the interface for receiving\n+#             callbacks with network messages from a NodeConn\n+# CBlock, CTransaction, CBlockHeader, CTxIn, CTxOut, etc....:\n+#     data structures that should map to corresponding structures in\n+#     bitcoin/primitives\n+# msg_block, msg_tx, msg_headers, etc.:\n+#     data structures that represent network messages\n+# ser_*, deser_*: functions that handle serialization/deserialization\n+\n+\n+import struct\n+import socket\n+import asyncore\n+import binascii\n+import time\n+import sys\n+import random\n+import cStringIO\n+import hashlib\n+from threading import Lock\n+from threading import Thread\n+import logging\n+import copy\n+\n+BIP0031_VERSION = 60000\n+MY_VERSION = 60001  # past bip-31 for ping/pong\n+MY_SUBVERSION = \"/python-mininode-tester:0.0.1/\"\n+\n+MAX_INV_SZ = 50000\n+\n+# Serialization/deserialization tools\n+def sha256(s):\n+    return hashlib.new('sha256', s).digest()\n+\n+\n+def hash256(s):\n+    return sha256(sha256(s))\n+\n+\n+def deser_string(f):\n+    nit = struct.unpack(\"<B\", f.read(1))[0]\n+    if nit == 253:\n+        nit = struct.unpack(\"<H\", f.read(2))[0]\n+    elif nit == 254:\n+        nit = struct.unpack(\"<I\", f.read(4))[0]\n+    elif nit == 255:\n+        nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    return f.read(nit)\n+\n+\n+def ser_string(s):\n+    if len(s) < 253:\n+        return chr(len(s)) + s\n+    elif len(s) < 0x10000:\n+        return chr(253) + struct.pack(\"<H\", len(s)) + s\n+    elif len(s) < 0x100000000L:\n+        return chr(254) + struct.pack(\"<I\", len(s)) + s\n+    return chr(255) + struct.pack(\"<Q\", len(s)) + s\n+\n+\n+def deser_uint256(f):\n+    r = 0L\n+    for i in xrange(8):\n+        t = struct.unpack(\"<I\", f.read(4))[0]\n+        r += t << (i * 32)\n+    return r\n+\n+\n+def ser_uint256(u):\n+    rs = \"\"\n+    for i in xrange(8):\n+        rs += struct.pack(\"<I\", u & 0xFFFFFFFFL)\n+        u >>= 32\n+    return rs\n+\n+\n+def uint256_from_str(s):\n+    r = 0L\n+    t = struct.unpack(\"<IIIIIIII\", s[:32])\n+    for i in xrange(8):\n+        r += t[i] << (i * 32)\n+    return r\n+\n+\n+def uint256_from_compact(c):\n+    nbytes = (c >> 24) & 0xFF\n+    v = (c & 0xFFFFFFL) << (8 * (nbytes - 3))\n+    return v\n+\n+\n+def deser_vector(f, c):\n+    nit = struct.unpack(\"<B\", f.read(1))[0]\n+    if nit == 253:\n+        nit = struct.unpack(\"<H\", f.read(2))[0]\n+    elif nit == 254:\n+        nit = struct.unpack(\"<I\", f.read(4))[0]\n+    elif nit == 255:\n+        nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    r = []\n+    for i in xrange(nit):\n+        t = c()\n+        t.deserialize(f)\n+        r.append(t)\n+    return r\n+\n+\n+def ser_vector(l):\n+    r = \"\"\n+    if len(l) < 253:\n+        r = chr(len(l))\n+    elif len(l) < 0x10000:\n+        r = chr(253) + struct.pack(\"<H\", len(l))\n+    elif len(l) < 0x100000000L:\n+        r = chr(254) + struct.pack(\"<I\", len(l))\n+    else:\n+        r = chr(255) + struct.pack(\"<Q\", len(l))\n+    for i in l:\n+        r += i.serialize()\n+    return r\n+\n+\n+def deser_uint256_vector(f):\n+    nit = struct.unpack(\"<B\", f.read(1))[0]\n+    if nit == 253:\n+        nit = struct.unpack(\"<H\", f.read(2))[0]\n+    elif nit == 254:\n+        nit = struct.unpack(\"<I\", f.read(4))[0]\n+    elif nit == 255:\n+        nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    r = []\n+    for i in xrange(nit):\n+        t = deser_uint256(f)\n+        r.append(t)\n+    return r\n+\n+\n+def ser_uint256_vector(l):\n+    r = \"\"\n+    if len(l) < 253:\n+        r = chr(len(l))\n+    elif len(l) < 0x10000:\n+        r = chr(253) + struct.pack(\"<H\", len(l))\n+    elif len(l) < 0x100000000L:\n+        r = chr(254) + struct.pack(\"<I\", len(l))\n+    else:\n+        r = chr(255) + struct.pack(\"<Q\", len(l))\n+    for i in l:\n+        r += ser_uint256(i)\n+    return r\n+\n+\n+def deser_string_vector(f):\n+    nit = struct.unpack(\"<B\", f.read(1))[0]\n+    if nit == 253:\n+        nit = struct.unpack(\"<H\", f.read(2))[0]\n+    elif nit == 254:\n+        nit = struct.unpack(\"<I\", f.read(4))[0]\n+    elif nit == 255:\n+        nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    r = []\n+    for i in xrange(nit):\n+        t = deser_string(f)\n+        r.append(t)\n+    return r\n+\n+\n+def ser_string_vector(l):\n+    r = \"\"\n+    if len(l) < 253:\n+        r = chr(len(l))\n+    elif len(l) < 0x10000:\n+        r = chr(253) + struct.pack(\"<H\", len(l))\n+    elif len(l) < 0x100000000L:\n+        r = chr(254) + struct.pack(\"<I\", len(l))\n+    else:\n+        r = chr(255) + struct.pack(\"<Q\", len(l))\n+    for sv in l:\n+        r += ser_string(sv)\n+    return r\n+\n+\n+def deser_int_vector(f):\n+    nit = struct.unpack(\"<B\", f.read(1))[0]\n+    if nit == 253:\n+        nit = struct.unpack(\"<H\", f.read(2))[0]\n+    elif nit == 254:\n+        nit = struct.unpack(\"<I\", f.read(4))[0]\n+    elif nit == 255:\n+        nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    r = []\n+    for i in xrange(nit):\n+        t = struct.unpack(\"<i\", f.read(4))[0]\n+        r.append(t)\n+    return r\n+\n+\n+def ser_int_vector(l):\n+    r = \"\"\n+    if len(l) < 253:\n+        r = chr(len(l))\n+    elif len(l) < 0x10000:\n+        r = chr(253) + struct.pack(\"<H\", len(l))\n+    elif len(l) < 0x100000000L:\n+        r = chr(254) + struct.pack(\"<I\", len(l))\n+    else:\n+        r = chr(255) + struct.pack(\"<Q\", len(l))\n+    for i in l:\n+        r += struct.pack(\"<i\", i)\n+    return r\n+\n+\n+# Objects that map to bitcoind objects, which can be serialized/deserialized\n+\n+class CAddress(object):\n+    def __init__(self):\n+        self.nServices = 1\n+        self.pchReserved = \"\\x00\" * 10 + \"\\xff\" * 2\n+        self.ip = \"0.0.0.0\"\n+        self.port = 0\n+\n+    def deserialize(self, f):\n+        self.nServices = struct.unpack(\"<Q\", f.read(8))[0]\n+        self.pchReserved = f.read(12)\n+        self.ip = socket.inet_ntoa(f.read(4))\n+        self.port = struct.unpack(\">H\", f.read(2))[0]\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<Q\", self.nServices)\n+        r += self.pchReserved\n+        r += socket.inet_aton(self.ip)\n+        r += struct.pack(\">H\", self.port)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CAddress(nServices=%i ip=%s port=%i)\" % (self.nServices,\n+                                                         self.ip, self.port)\n+\n+\n+class CInv(object):\n+    typemap = {\n+        0: \"Error\",\n+        1: \"TX\",\n+        2: \"Block\"}\n+\n+    def __init__(self, t=0, h=0L):\n+        self.type = t\n+        self.hash = h\n+\n+    def deserialize(self, f):\n+        self.type = struct.unpack(\"<i\", f.read(4))[0]\n+        self.hash = deser_uint256(f)\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<i\", self.type)\n+        r += ser_uint256(self.hash)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CInv(type=%s hash=%064x)\" \\\n+            % (self.typemap[self.type], self.hash)\n+\n+\n+class CBlockLocator(object):\n+    def __init__(self):\n+        self.nVersion = MY_VERSION\n+        self.vHave = []\n+\n+    def deserialize(self, f):\n+        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n+        self.vHave = deser_uint256_vector(f)\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<i\", self.nVersion)\n+        r += ser_uint256_vector(self.vHave)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CBlockLocator(nVersion=%i vHave=%s)\" \\\n+            % (self.nVersion, repr(self.vHave))\n+\n+\n+class COutPoint(object):\n+    def __init__(self, hash=0, n=0):\n+        self.hash = hash\n+        self.n = n\n+\n+    def deserialize(self, f):\n+        self.hash = deser_uint256(f)\n+        self.n = struct.unpack(\"<I\", f.read(4))[0]\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += ser_uint256(self.hash)\n+        r += struct.pack(\"<I\", self.n)\n+        return r\n+\n+    def __repr__(self):\n+        return \"COutPoint(hash=%064x n=%i)\" % (self.hash, self.n)\n+\n+\n+class CTxIn(object):\n+    def __init__(self, outpoint=None, scriptSig=\"\", nSequence=0):\n+        if outpoint is None:\n+            self.prevout = COutPoint()\n+        else:\n+            self.prevout = outpoint\n+        self.scriptSig = scriptSig\n+        self.nSequence = nSequence\n+\n+    def deserialize(self, f):\n+        self.prevout = COutPoint()\n+        self.prevout.deserialize(f)\n+        self.scriptSig = deser_string(f)\n+        self.nSequence = struct.unpack(\"<I\", f.read(4))[0]\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += self.prevout.serialize()\n+        r += ser_string(self.scriptSig)\n+        r += struct.pack(\"<I\", self.nSequence)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CTxIn(prevout=%s scriptSig=%s nSequence=%i)\" \\\n+            % (repr(self.prevout), binascii.hexlify(self.scriptSig),\n+               self.nSequence)\n+\n+\n+class CTxOut(object):\n+    def __init__(self, nValue=0, scriptPubKey=\"\"):\n+        self.nValue = nValue\n+        self.scriptPubKey = scriptPubKey\n+\n+    def deserialize(self, f):\n+        self.nValue = struct.unpack(\"<q\", f.read(8))[0]\n+        self.scriptPubKey = deser_string(f)\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<q\", self.nValue)\n+        r += ser_string(self.scriptPubKey)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CTxOut(nValue=%i.%08i scriptPubKey=%s)\" \\\n+            % (self.nValue // 100000000, self.nValue % 100000000,\n+               binascii.hexlify(self.scriptPubKey))\n+\n+\n+class CTransaction(object):\n+    def __init__(self, tx=None):\n+        if tx is None:\n+            self.nVersion = 1\n+            self.vin = []\n+            self.vout = []\n+            self.nLockTime = 0\n+            self.sha256 = None\n+            self.hash = None\n+        else:\n+            self.nVersion = tx.nVersion\n+            self.vin = copy.deepcopy(tx.vin)\n+            self.vout = copy.deepcopy(tx.vout)\n+            self.nLockTime = tx.nLockTime\n+            self.sha256 = None\n+            self.hash = None\n+\n+    def deserialize(self, f):\n+        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n+        self.vin = deser_vector(f, CTxIn)\n+        self.vout = deser_vector(f, CTxOut)\n+        self.nLockTime = struct.unpack(\"<I\", f.read(4))[0]\n+        self.sha256 = None\n+        self.hash = None\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<i\", self.nVersion)\n+        r += ser_vector(self.vin)\n+        r += ser_vector(self.vout)\n+        r += struct.pack(\"<I\", self.nLockTime)\n+        return r\n+\n+    def rehash(self):\n+        self.sha256 = None\n+        self.calc_sha256()\n+\n+    def calc_sha256(self):\n+        if self.sha256 is None:\n+            self.sha256 = uint256_from_str(hash256(self.serialize()))\n+        self.hash = hash256(self.serialize())[::-1].encode('hex_codec')\n+\n+    def is_valid(self):\n+        self.calc_sha256()\n+        for tout in self.vout:\n+            if tout.nValue < 0 or tout.nValue > 21000000L * 100000000L:\n+                return False\n+        return True\n+\n+    def __repr__(self):\n+        return \"CTransaction(nVersion=%i vin=%s vout=%s nLockTime=%i)\" \\\n+            % (self.nVersion, repr(self.vin), repr(self.vout), self.nLockTime)\n+\n+\n+class CBlockHeader(object):\n+    def __init__(self, header=None):\n+        if header is None:\n+            self.set_null()\n+        else:\n+            self.nVersion = header.nVersion\n+            self.hashPrevBlock = header.hashPrevBlock\n+            self.hashMerkleRoot = header.hashMerkleRoot\n+            self.nTime = header.nTime\n+            self.nBits = header.nBits\n+            self.nNonce = header.nNonce\n+            self.sha256 = header.sha256\n+            self.hash = header.hash\n+            self.calc_sha256()\n+\n+    def set_null(self):\n+        self.nVersion = 1\n+        self.hashPrevBlock = 0\n+        self.hashMerkleRoot = 0\n+        self.nTime = 0\n+        self.nBits = 0\n+        self.nNonce = 0\n+        self.sha256 = None\n+        self.hash = None\n+\n+    def deserialize(self, f):\n+        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n+        self.hashPrevBlock = deser_uint256(f)\n+        self.hashMerkleRoot = deser_uint256(f)\n+        self.nTime = struct.unpack(\"<I\", f.read(4))[0]\n+        self.nBits = struct.unpack(\"<I\", f.read(4))[0]\n+        self.nNonce = struct.unpack(\"<I\", f.read(4))[0]\n+        self.sha256 = None\n+        self.hash = None\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<i\", self.nVersion)\n+        r += ser_uint256(self.hashPrevBlock)\n+        r += ser_uint256(self.hashMerkleRoot)\n+        r += struct.pack(\"<I\", self.nTime)\n+        r += struct.pack(\"<I\", self.nBits)\n+        r += struct.pack(\"<I\", self.nNonce)\n+        return r\n+\n+    def calc_sha256(self):\n+        if self.sha256 is None:\n+            r = \"\"\n+            r += struct.pack(\"<i\", self.nVersion)\n+            r += ser_uint256(self.hashPrevBlock)\n+            r += ser_uint256(self.hashMerkleRoot)\n+            r += struct.pack(\"<I\", self.nTime)\n+            r += struct.pack(\"<I\", self.nBits)\n+            r += struct.pack(\"<I\", self.nNonce)\n+            self.sha256 = uint256_from_str(hash256(r))\n+            self.hash = hash256(r)[::-1].encode('hex_codec')\n+\n+    def rehash(self):\n+        self.sha256 = None\n+        self.calc_sha256()\n+        return self.sha256\n+\n+    def __repr__(self):\n+        return \"CBlockHeader(nVersion=%i hashPrevBlock=%064x hashMerkleRoot=%064x nTime=%s nBits=%08x nNonce=%08x)\" \\\n+            % (self.nVersion, self.hashPrevBlock, self.hashMerkleRoot,\n+               time.ctime(self.nTime), self.nBits, self.nNonce)\n+\n+\n+class CBlock(CBlockHeader):\n+    def __init__(self, header=None):\n+        super(CBlock, self).__init__(header)\n+        self.vtx = []\n+\n+    def deserialize(self, f):\n+        super(CBlock, self).deserialize(f)\n+        self.vtx = deser_vector(f, CTransaction)\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += super(CBlock, self).serialize()\n+        r += ser_vector(self.vtx)\n+        return r\n+\n+    def calc_merkle_root(self):\n+        hashes = []\n+        for tx in self.vtx:\n+            tx.calc_sha256()\n+            hashes.append(ser_uint256(tx.sha256))\n+        while len(hashes) > 1:\n+            newhashes = []\n+            for i in xrange(0, len(hashes), 2):\n+                i2 = min(i+1, len(hashes)-1)\n+                newhashes.append(hash256(hashes[i] + hashes[i2]))\n+            hashes = newhashes\n+        return uint256_from_str(hashes[0])\n+\n+    def is_valid(self):\n+        self.calc_sha256()\n+        target = uint256_from_compact(self.nBits)\n+        if self.sha256 > target:\n+            return False\n+        for tx in self.vtx:\n+            if not tx.is_valid():\n+                return False\n+        if self.calc_merkle_root() != self.hashMerkleRoot:\n+            return False\n+        return True\n+\n+    def solve(self):\n+        self.calc_sha256()\n+        target = uint256_from_compact(self.nBits)\n+        while self.sha256 > target:\n+            self.nNonce += 1\n+            self.rehash()\n+\n+    def __repr__(self):\n+        return \"CBlock(nVersion=%i hashPrevBlock=%064x hashMerkleRoot=%064x nTime=%s nBits=%08x nNonce=%08x vtx=%s)\" \\\n+            % (self.nVersion, self.hashPrevBlock, self.hashMerkleRoot,\n+               time.ctime(self.nTime), self.nBits, self.nNonce, repr(self.vtx))\n+\n+\n+class CUnsignedAlert(object):\n+    def __init__(self):\n+        self.nVersion = 1\n+        self.nRelayUntil = 0\n+        self.nExpiration = 0\n+        self.nID = 0\n+        self.nCancel = 0\n+        self.setCancel = []\n+        self.nMinVer = 0\n+        self.nMaxVer = 0\n+        self.setSubVer = []\n+        self.nPriority = 0\n+        self.strComment = \"\"\n+        self.strStatusBar = \"\"\n+        self.strReserved = \"\"\n+\n+    def deserialize(self, f):\n+        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n+        self.nRelayUntil = struct.unpack(\"<q\", f.read(8))[0]\n+        self.nExpiration = struct.unpack(\"<q\", f.read(8))[0]\n+        self.nID = struct.unpack(\"<i\", f.read(4))[0]\n+        self.nCancel = struct.unpack(\"<i\", f.read(4))[0]\n+        self.setCancel = deser_int_vector(f)\n+        self.nMinVer = struct.unpack(\"<i\", f.read(4))[0]\n+        self.nMaxVer = struct.unpack(\"<i\", f.read(4))[0]\n+        self.setSubVer = deser_string_vector(f)\n+        self.nPriority = struct.unpack(\"<i\", f.read(4))[0]\n+        self.strComment = deser_string(f)\n+        self.strStatusBar = deser_string(f)\n+        self.strReserved = deser_string(f)\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<i\", self.nVersion)\n+        r += struct.pack(\"<q\", self.nRelayUntil)\n+        r += struct.pack(\"<q\", self.nExpiration)\n+        r += struct.pack(\"<i\", self.nID)\n+        r += struct.pack(\"<i\", self.nCancel)\n+        r += ser_int_vector(self.setCancel)\n+        r += struct.pack(\"<i\", self.nMinVer)\n+        r += struct.pack(\"<i\", self.nMaxVer)\n+        r += ser_string_vector(self.setSubVer)\n+        r += struct.pack(\"<i\", self.nPriority)\n+        r += ser_string(self.strComment)\n+        r += ser_string(self.strStatusBar)\n+        r += ser_string(self.strReserved)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CUnsignedAlert(nVersion %d, nRelayUntil %d, nExpiration %d, nID %d, nCancel %d, nMinVer %d, nMaxVer %d, nPriority %d, strComment %s, strStatusBar %s, strReserved %s)\" \\\n+            % (self.nVersion, self.nRelayUntil, self.nExpiration, self.nID,\n+               self.nCancel, self.nMinVer, self.nMaxVer, self.nPriority,\n+               self.strComment, self.strStatusBar, self.strReserved)\n+\n+\n+class CAlert(object):\n+    def __init__(self):\n+        self.vchMsg = \"\"\n+        self.vchSig = \"\"\n+\n+    def deserialize(self, f):\n+        self.vchMsg = deser_string(f)\n+        self.vchSig = deser_string(f)\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += ser_string(self.vchMsg)\n+        r += ser_string(self.vchSig)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CAlert(vchMsg.sz %d, vchSig.sz %d)\" \\\n+            % (len(self.vchMsg), len(self.vchSig))\n+\n+\n+# Objects that correspond to messages on the wire\n+class msg_version(object):\n+    command = \"version\"\n+\n+    def __init__(self):\n+        self.nVersion = MY_VERSION\n+        self.nServices = 1\n+        self.nTime = time.time()\n+        self.addrTo = CAddress()\n+        self.addrFrom = CAddress()\n+        self.nNonce = random.getrandbits(64)\n+        self.strSubVer = MY_SUBVERSION\n+        self.nStartingHeight = -1\n+\n+    def deserialize(self, f):\n+        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n+        if self.nVersion == 10300:\n+            self.nVersion = 300\n+        self.nServices = struct.unpack(\"<Q\", f.read(8))[0]\n+        self.nTime = struct.unpack(\"<q\", f.read(8))[0]\n+        self.addrTo = CAddress()\n+        self.addrTo.deserialize(f)\n+        if self.nVersion >= 106:\n+            self.addrFrom = CAddress()\n+            self.addrFrom.deserialize(f)\n+            self.nNonce = struct.unpack(\"<Q\", f.read(8))[0]\n+            self.strSubVer = deser_string(f)\n+            if self.nVersion >= 209:\n+                self.nStartingHeight = struct.unpack(\"<i\", f.read(4))[0]\n+            else:\n+                self.nStartingHeight = None\n+        else:\n+            self.addrFrom = None\n+            self.nNonce = None\n+            self.strSubVer = None\n+            self.nStartingHeight = None\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<i\", self.nVersion)\n+        r += struct.pack(\"<Q\", self.nServices)\n+        r += struct.pack(\"<q\", self.nTime)\n+        r += self.addrTo.serialize()\n+        r += self.addrFrom.serialize()\n+        r += struct.pack(\"<Q\", self.nNonce)\n+        r += ser_string(self.strSubVer)\n+        r += struct.pack(\"<i\", self.nStartingHeight)\n+        return r\n+\n+    def __repr__(self):\n+        return 'msg_version(nVersion=%i nServices=%i nTime=%s addrTo=%s addrFrom=%s nNonce=0x%016X strSubVer=%s nStartingHeight=%i)' \\\n+            % (self.nVersion, self.nServices, time.ctime(self.nTime),\n+               repr(self.addrTo), repr(self.addrFrom), self.nNonce,\n+               self.strSubVer, self.nStartingHeight)\n+\n+\n+class msg_verack(object):\n+    command = \"verack\"\n+\n+    def __init__(self):\n+        pass\n+\n+    def deserialize(self, f):\n+        pass\n+\n+    def serialize(self):\n+        return \"\"\n+\n+    def __repr__(self):\n+        return \"msg_verack()\"\n+\n+\n+class msg_addr(object):\n+    command = \"addr\"\n+\n+    def __init__(self):\n+        self.addrs = []\n+\n+    def deserialize(self, f):\n+        self.addrs = deser_vector(f, CAddress)\n+\n+    def serialize(self):\n+        return ser_vector(self.addrs)\n+\n+    def __repr__(self):\n+        return \"msg_addr(addrs=%s)\" % (repr(self.addrs))\n+\n+\n+class msg_alert(object):\n+    command = \"alert\"\n+\n+    def __init__(self):\n+        self.alert = CAlert()\n+\n+    def deserialize(self, f):\n+        self.alert = CAlert()\n+        self.alert.deserialize(f)\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += self.alert.serialize()\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_alert(alert=%s)\" % (repr(self.alert), )\n+\n+\n+class msg_inv(object):\n+    command = \"inv\"\n+\n+    def __init__(self, inv=None):\n+        if inv is None:\n+            self.inv = []\n+        else:\n+            self.inv = inv\n+\n+    def deserialize(self, f):\n+        self.inv = deser_vector(f, CInv)\n+\n+    def serialize(self):\n+        return ser_vector(self.inv)\n+\n+    def __repr__(self):\n+        return \"msg_inv(inv=%s)\" % (repr(self.inv))\n+\n+\n+class msg_getdata(object):\n+    command = \"getdata\"\n+\n+    def __init__(self):\n+        self.inv = []\n+\n+    def deserialize(self, f):\n+        self.inv = deser_vector(f, CInv)\n+\n+    def serialize(self):\n+        return ser_vector(self.inv)\n+\n+    def __repr__(self):\n+        return \"msg_getdata(inv=%s)\" % (repr(self.inv))\n+\n+\n+class msg_getblocks(object):\n+    command = \"getblocks\"\n+\n+    def __init__(self):\n+        self.locator = CBlockLocator()\n+        self.hashstop = 0L\n+\n+    def deserialize(self, f):\n+        self.locator = CBlockLocator()\n+        self.locator.deserialize(f)\n+        self.hashstop = deser_uint256(f)\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += self.locator.serialize()\n+        r += ser_uint256(self.hashstop)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_getblocks(locator=%s hashstop=%064x)\" \\\n+            % (repr(self.locator), self.hashstop)\n+\n+\n+class msg_tx(object):\n+    command = \"tx\"\n+\n+    def __init__(self, tx=CTransaction()):\n+        self.tx = tx\n+\n+    def deserialize(self, f):\n+        self.tx.deserialize(f)\n+\n+    def serialize(self):\n+        return self.tx.serialize()\n+\n+    def __repr__(self):\n+        return \"msg_tx(tx=%s)\" % (repr(self.tx))\n+\n+\n+class msg_block(object):\n+    command = \"block\"\n+\n+    def __init__(self, block=None):\n+        if block is None:\n+            self.block = CBlock()\n+        else:\n+            self.block = block\n+\n+    def deserialize(self, f):\n+        self.block.deserialize(f)\n+\n+    def serialize(self):\n+        return self.block.serialize()\n+\n+    def __repr__(self):\n+        return \"msg_block(block=%s)\" % (repr(self.block))\n+\n+\n+class msg_getaddr(object):\n+    command = \"getaddr\"\n+\n+    def __init__(self):\n+        pass\n+\n+    def deserialize(self, f):\n+        pass\n+\n+    def serialize(self):\n+        return \"\"\n+\n+    def __repr__(self):\n+        return \"msg_getaddr()\"\n+\n+\n+class msg_ping_prebip31(object):\n+    command = \"ping\"\n+\n+    def __init__(self):\n+        pass\n+\n+    def deserialize(self, f):\n+        pass\n+\n+    def serialize(self):\n+        return \"\"\n+\n+    def __repr__(self):\n+        return \"msg_ping() (pre-bip31)\"\n+\n+\n+class msg_ping(object):\n+    command = \"ping\"\n+\n+    def __init__(self, nonce=0L):\n+        self.nonce = nonce\n+\n+    def deserialize(self, f):\n+        self.nonce = struct.unpack(\"<Q\", f.read(8))[0]\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<Q\", self.nonce)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_ping(nonce=%08x)\" % self.nonce\n+\n+\n+class msg_pong(object):\n+    command = \"pong\"\n+\n+    def __init__(self, nonce=0L):\n+        self.nonce = nonce\n+\n+    def deserialize(self, f):\n+        self.nonce = struct.unpack(\"<Q\", f.read(8))[0]\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<Q\", self.nonce)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_pong(nonce=%08x)\" % self.nonce\n+\n+\n+class msg_mempool(object):\n+    command = \"mempool\"\n+\n+    def __init__(self):\n+        pass\n+\n+    def deserialize(self, f):\n+        pass\n+\n+    def serialize(self):\n+        return \"\"\n+\n+    def __repr__(self):\n+        return \"msg_mempool()\"\n+\n+\n+# getheaders message has\n+# number of entries\n+# vector of hashes\n+# hash_stop (hash of last desired block header, 0 to get as many as possible)\n+class msg_getheaders(object):\n+    command = \"getheaders\"\n+\n+    def __init__(self):\n+        self.locator = CBlockLocator()\n+        self.hashstop = 0L\n+\n+    def deserialize(self, f):\n+        self.locator = CBlockLocator()\n+        self.locator.deserialize(f)\n+        self.hashstop = deser_uint256(f)\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += self.locator.serialize()\n+        r += ser_uint256(self.hashstop)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_getheaders(locator=%s, stop=%064x)\" \\\n+            % (repr(self.locator), self.hashstop)\n+\n+\n+# headers message has\n+# <count> <vector of block headers>\n+class msg_headers(object):\n+    command = \"headers\"\n+\n+    def __init__(self):\n+        self.headers = []\n+\n+    def deserialize(self, f):\n+        # comment in bitcoind indicates these should be deserialized as blocks\n+        blocks = deser_vector(f, CBlock)\n+        for x in blocks:\n+            self.headers.append(CBlockHeader(x))\n+\n+    def serialize(self):\n+        blocks = [CBlock(x) for x in self.headers]\n+        return ser_vector(blocks)\n+\n+    def __repr__(self):\n+        return \"msg_headers(headers=%s)\" % repr(self.headers)\n+\n+\n+class msg_reject(object):\n+    command = \"reject\"\n+\n+    def __init__(self):\n+        self.message = \"\"\n+        self.code = \"\"\n+        self.reason = \"\"\n+        self.data = 0L\n+\n+    def deserialize(self, f):\n+        self.message = deser_string(f)\n+        self.code = struct.unpack(\"<B\", f.read(1))[0]\n+        self.reason = deser_string(f)\n+        if (self.message == \"block\" or self.message == \"tx\"):\n+            self.data = deser_uint256(f)\n+\n+    def serialize(self):\n+        r = ser_string(self.message)\n+        r += struct.pack(\"<B\", self.code)\n+        r += ser_string(self.reason)\n+        if (self.message == \"block\" or self.message == \"tx\"):\n+            r += ser_uint256(self.data)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_reject: %s %d %s [%064x]\" \\\n+            % (self.message, self.code, self.reason, self.data)\n+\n+\n+# This is what a callback should look like for NodeConn\n+# Reimplement the on_* functions to provide handling for events\n+class NodeConnCB(object):\n+    def __init__(self):\n+        # Acquire on all callbacks -- overkill for now since asyncore is\n+        # single-threaded, but may be useful for synchronizing access to\n+        # member variables in derived classes.\n+        self.cbLock = Lock()\n+        self.verack_received = False\n+\n+    # Derived classes should call this function once to set the message map\n+    # which associates the derived classes' functions to incoming messages\n+    def create_callback_map(self):\n+        self.cbmap = {\n+            \"version\": self.on_version,\n+            \"verack\": self.on_verack,\n+            \"addr\": self.on_addr,\n+            \"alert\": self.on_alert,\n+            \"inv\": self.on_inv,\n+            \"getdata\": self.on_getdata,\n+            \"getblocks\": self.on_getblocks,\n+            \"tx\": self.on_tx,\n+            \"block\": self.on_block,\n+            \"getaddr\": self.on_getaddr,\n+            \"ping\": self.on_ping,\n+            \"pong\": self.on_pong,\n+            \"headers\": self.on_headers,\n+            \"getheaders\": self.on_getheaders,\n+            \"reject\": self.on_reject,\n+            \"mempool\": self.on_mempool\n+        }\n+\n+    def deliver(self, conn, message):\n+        with self.cbLock:\n+            try:\n+                self.cbmap[message.command](conn, message)\n+            except:\n+                print \"ERROR delivering %s (%s)\" % (repr(message),\n+                                                    sys.exc_info()[0])\n+\n+    def on_version(self, conn, message):\n+        if message.nVersion >= 209:\n+            conn.send_message(msg_verack())\n+        conn.ver_send = min(MY_VERSION, message.nVersion)\n+        if message.nVersion < 209:\n+            conn.ver_recv = conn.ver_send\n+\n+    def on_verack(self, conn, message):\n+        conn.ver_recv = conn.ver_send\n+        self.verack_received = True\n+\n+    def on_inv(self, conn, message):\n+        want = msg_getdata()\n+        for i in message.inv:\n+            if i.type != 0:\n+                want.inv.append(i)\n+        if len(want.inv):\n+            conn.send_message(want)\n+\n+    def on_addr(self, conn, message): pass\n+    def on_alert(self, conn, message): pass\n+    def on_getdata(self, conn, message): pass\n+    def on_getblocks(self, conn, message): pass\n+    def on_tx(self, conn, message): pass\n+    def on_block(self, conn, message): pass\n+    def on_getaddr(self, conn, message): pass\n+    def on_headers(self, conn, message): pass\n+    def on_getheaders(self, conn, message): pass\n+    def on_ping(self, conn, message):\n+        if conn.ver_send > BIP0031_VERSION:\n+            conn.send_message(msg_pong(message.nonce))\n+    def on_reject(self, conn, message): pass\n+    def on_close(self, conn): pass\n+    def on_mempool(self, conn): pass\n+    def on_pong(self, conn, message): pass\n+\n+\n+# The actual NodeConn class\n+# This class provides an interface for a p2p connection to a specified node\n+class NodeConn(asyncore.dispatcher):\n+    messagemap = {\n+        \"version\": msg_version,\n+        \"verack\": msg_verack,\n+        \"addr\": msg_addr,\n+        \"alert\": msg_alert,\n+        \"inv\": msg_inv,\n+        \"getdata\": msg_getdata,\n+        \"getblocks\": msg_getblocks,\n+        \"tx\": msg_tx,\n+        \"block\": msg_block,\n+        \"getaddr\": msg_getaddr,\n+        \"ping\": msg_ping,\n+        \"pong\": msg_pong,\n+        \"headers\": msg_headers,\n+        \"getheaders\": msg_getheaders,\n+        \"reject\": msg_reject,\n+        \"mempool\": msg_mempool\n+    }\n+    MAGIC_BYTES = {\n+        \"mainnet\": \"\\xf9\\xbe\\xb4\\xd9\",   # mainnet\n+        \"testnet3\": \"\\x0b\\x11\\x09\\x07\",  # testnet3\n+        \"regtest\": \"\\xfa\\xbf\\xb5\\xda\"    # regtest\n+    }\n+\n+    def __init__(self, dstaddr, dstport, rpc, callback, net=\"regtest\"):\n+        asyncore.dispatcher.__init__(self)\n+        self.log = logging.getLogger(\"NodeConn(%s:%d)\" % (dstaddr, dstport))\n+        self.dstaddr = dstaddr\n+        self.dstport = dstport\n+        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)\n+        self.sendbuf = \"\"\n+        self.recvbuf = \"\"\n+        self.ver_send = 209\n+        self.ver_recv = 209\n+        self.last_sent = 0\n+        self.state = \"connecting\"\n+        self.network = net\n+        self.cb = callback\n+        self.sendbufLock = Lock()  # for protecting the sendbuffer\n+        self.disconnect = False\n+\n+        # stuff version msg into sendbuf\n+        vt = msg_version()\n+        vt.addrTo.ip = self.dstaddr\n+        vt.addrTo.port = self.dstport\n+        vt.addrFrom.ip = \"0.0.0.0\"\n+        vt.addrFrom.port = 0\n+        self.send_message(vt, True)\n+        print 'MiniNode: Connecting to Bitcoin Node IP # ' + dstaddr + ':' \\\n+            + str(dstport)\n+\n+        try:\n+            self.connect((dstaddr, dstport))\n+        except:\n+            self.handle_close()\n+        self.rpc = rpc\n+\n+    def show_debug_msg(self, msg):\n+        self.log.debug(msg)\n+\n+    def handle_connect(self):\n+        self.show_debug_msg(\"MiniNode: Connected & Listening: \\n\")\n+        self.state = \"connected\"\n+\n+    def handle_close(self):\n+        self.show_debug_msg(\"MiniNode: Closing Connection to %s:%d... \"\n+                            % (self.dstaddr, self.dstport))\n+        self.state = \"closed\"\n+        self.recvbuf = \"\"\n+        self.sendbuf = \"\"\n+        try:\n+            self.close()\n+        except:\n+            pass\n+        self.cb.on_close(self)\n+\n+    def handle_read(self):\n+        try:\n+            t = self.recv(8192)\n+            if len(t) > 0:\n+                self.recvbuf += t\n+                self.got_data()\n+        except:\n+            pass\n+\n+    def readable(self):\n+        return True\n+\n+    def writable(self):\n+        if self.disconnect:\n+            self.handle_close()\n+            return False\n+        else:\n+            self.sendbufLock.acquire()\n+            length = len(self.sendbuf)\n+            self.sendbufLock.release()\n+            return (length > 0)\n+\n+    def handle_write(self):\n+        self.sendbufLock.acquire()\n+        try:\n+            sent = self.send(self.sendbuf)\n+        except:\n+            self.handle_close()\n+            return\n+        self.sendbuf = self.sendbuf[sent:]\n+        self.sendbufLock.release()\n+\n+    def got_data(self):\n+        while True:\n+            if len(self.recvbuf) < 4:\n+                return\n+            if self.recvbuf[:4] != self.MAGIC_BYTES[self.network]:\n+                raise ValueError(\"got garbage %s\" % repr(self.recvbuf))\n+            if self.ver_recv < 209:\n+                if len(self.recvbuf) < 4 + 12 + 4:\n+                    return\n+                command = self.recvbuf[4:4+12].split(\"\\x00\", 1)[0]\n+                msglen = struct.unpack(\"<i\", self.recvbuf[4+12:4+12+4])[0]\n+                checksum = None\n+                if len(self.recvbuf) < 4 + 12 + 4 + msglen:\n+                    return\n+                msg = self.recvbuf[4+12+4:4+12+4+msglen]\n+                self.recvbuf = self.recvbuf[4+12+4+msglen:]\n+            else:\n+                if len(self.recvbuf) < 4 + 12 + 4 + 4:\n+                    return\n+                command = self.recvbuf[4:4+12].split(\"\\x00\", 1)[0]\n+                msglen = struct.unpack(\"<i\", self.recvbuf[4+12:4+12+4])[0]\n+                checksum = self.recvbuf[4+12+4:4+12+4+4]\n+                if len(self.recvbuf) < 4 + 12 + 4 + 4 + msglen:\n+                    return\n+                msg = self.recvbuf[4+12+4+4:4+12+4+4+msglen]\n+                th = sha256(msg)\n+                h = sha256(th)\n+                if checksum != h[:4]:\n+                    raise ValueError(\"got bad checksum \" + repr(self.recvbuf))\n+                self.recvbuf = self.recvbuf[4+12+4+4+msglen:]\n+            if command in self.messagemap:\n+                f = cStringIO.StringIO(msg)\n+                t = self.messagemap[command]()\n+                t.deserialize(f)\n+                self.got_message(t)\n+            else:\n+                self.show_debug_msg(\"Unknown command: '\" + command + \"' \" +\n+                                    repr(msg))\n+\n+    def send_message(self, message, pushbuf=False):\n+        if self.state != \"connected\" and not pushbuf:\n+            return\n+        self.sendbufLock.acquire()\n+        self.show_debug_msg(\"Send %s\" % repr(message))\n+        command = message.command\n+        data = message.serialize()\n+        tmsg = self.MAGIC_BYTES[self.network]\n+        tmsg += command\n+        tmsg += \"\\x00\" * (12 - len(command))\n+        tmsg += struct.pack(\"<I\", len(data))\n+        if self.ver_send >= 209:\n+            th = sha256(data)\n+            h = sha256(th)\n+            tmsg += h[:4]\n+        tmsg += data\n+        self.sendbuf += tmsg\n+        self.last_sent = time.time()\n+        self.sendbufLock.release()\n+\n+    def got_message(self, message):\n+        if message.command == \"version\":\n+            if message.nVersion <= BIP0031_VERSION:\n+                self.messagemap['ping'] = msg_ping_prebip31\n+        if self.last_sent + 30 * 60 < time.time():\n+            self.send_message(self.messagemap['ping']())\n+        self.show_debug_msg(\"Recv %s\" % repr(message))\n+        self.cb.deliver(self, message)\n+\n+    def disconnect_node(self):\n+        self.disconnect = True\n+        self.send_message(self.messagemap['ping']())\n+\n+\n+class NetworkThread(Thread):\n+    def run(self):\n+        asyncore.loop(0.1, True)\n+\n+\n+# An exception we can raise if we detect a potential disconnect\n+# (p2p or rpc) before the test is complete\n+class EarlyDisconnectError(Exception):\n+    def __init__(self, value):\n+        self.value = value\n+\n+    def __str__(self):\n+        return repr(self.value)"
      },
      {
        "sha": "385215a088661e5b0d7556d4b8215a9d0cbb3d8b",
        "filename": "qa/rpc-tests/util.py",
        "status": "modified",
        "additions": 7,
        "deletions": 4,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6c1d1ba6fccd76e3690bac8341687c0921758e30/qa/rpc-tests/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6c1d1ba6fccd76e3690bac8341687c0921758e30/qa/rpc-tests/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/util.py?ref=6c1d1ba6fccd76e3690bac8341687c0921758e30",
        "patch": "@@ -158,12 +158,14 @@ def _rpchost_to_args(rpchost):\n         rv += ['-rpcport=' + rpcport]\n     return rv\n \n-def start_node(i, dirname, extra_args=None, rpchost=None, timewait=None):\n+def start_node(i, dirname, extra_args=None, rpchost=None, timewait=None, binary=None):\n     \"\"\"\n     Start a bitcoind and return RPC connection to it\n     \"\"\"\n     datadir = os.path.join(dirname, \"node\"+str(i))\n-    args = [ os.getenv(\"BITCOIND\", \"bitcoind\"), \"-datadir=\"+datadir, \"-keypool=1\", \"-discover=0\", \"-rest\" ]\n+    if binary is None:\n+        binary = os.getenv(\"BITCOIND\", \"bitcoind\")\n+    args = [ binary, \"-datadir=\"+datadir, \"-keypool=1\", \"-discover=0\", \"-rest\" ]\n     if extra_args is not None: args.extend(extra_args)\n     bitcoind_processes[i] = subprocess.Popen(args)\n     devnull = open(\"/dev/null\", \"w+\")\n@@ -179,12 +181,13 @@ def start_node(i, dirname, extra_args=None, rpchost=None, timewait=None):\n     proxy.url = url # store URL on proxy for info\n     return proxy\n \n-def start_nodes(num_nodes, dirname, extra_args=None, rpchost=None):\n+def start_nodes(num_nodes, dirname, extra_args=None, rpchost=None, binary=None):\n     \"\"\"\n     Start multiple bitcoinds, return RPC connections to them\n     \"\"\"\n     if extra_args is None: extra_args = [ None for i in range(num_nodes) ]\n-    return [ start_node(i, dirname, extra_args[i], rpchost) for i in range(num_nodes) ]\n+    if binary is None: binary = [ None for i in range(num_nodes) ]\n+    return [ start_node(i, dirname, extra_args[i], rpchost, binary=binary[i]) for i in range(num_nodes) ]\n \n def log_filename(dirname, n_node, logname):\n     return os.path.join(dirname, \"node\"+str(n_node), \"regtest\", logname)"
      }
    ]
  },
  {
    "sha": "b93974c3f32a5398a94db275cd23b7ff78f269bf",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiOTM5NzRjM2YzMmE1Mzk4YTk0ZGIyNzVjZDIzYjdmZjc4ZjI2OWJm",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-04-28T16:39:47Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-04-28T16:40:56Z"
      },
      "message": "Add comparison tool test runner, built on mininode\n\ncomptool.py creates a tool for running a test suite on top of the mininode p2p\nframework.  It supports two types of tests: those for which we expect certain\nbehavior (acceptance or rejection of a block or transaction) and those for\nwhich we are just comparing that the behavior of 2 or more nodes is the same.\n\nblockstore.py defines BlockStore and TxStore, which provide db-backed maps\nbetween block/tx hashes and the corresponding block or tx.\n\nblocktools.py defines utility functions for creating and manipulating blocks\nand transactions.\n\ninvalidblockrequest.py is an example test in the comptool framework, which\ntests the behavior of a single node when sent two different types of invalid\nblocks (a block with a duplicated transaction and a block with a bad coinbase\nvalue).",
      "tree": {
        "sha": "315905c0afd9b8f8d4bec71f71b9d2f9b29d4f95",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/315905c0afd9b8f8d4bec71f71b9d2f9b29d4f95"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b93974c3f32a5398a94db275cd23b7ff78f269bf",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b93974c3f32a5398a94db275cd23b7ff78f269bf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b93974c3f32a5398a94db275cd23b7ff78f269bf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b93974c3f32a5398a94db275cd23b7ff78f269bf/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6c1d1ba6fccd76e3690bac8341687c0921758e30",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6c1d1ba6fccd76e3690bac8341687c0921758e30",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6c1d1ba6fccd76e3690bac8341687c0921758e30"
      }
    ],
    "stats": {
      "total": 667,
      "additions": 667,
      "deletions": 0
    },
    "files": [
      {
        "sha": "ae27a94b8dbe83989ecfa49e2f1e965434c49826",
        "filename": "qa/pull-tester/rpc-tests.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b93974c3f32a5398a94db275cd23b7ff78f269bf/qa/pull-tester/rpc-tests.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b93974c3f32a5398a94db275cd23b7ff78f269bf/qa/pull-tester/rpc-tests.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.sh?ref=b93974c3f32a5398a94db275cd23b7ff78f269bf",
        "patch": "@@ -31,6 +31,7 @@ testScripts=(\n     'merkle_blocks.py'\n #    'forknotify.py'\n     'maxblocksinflight.py'\n+    'invalidblockrequest.py'\n );\n if [ \"x${ENABLE_BITCOIND}${ENABLE_UTILS}${ENABLE_WALLET}\" = \"x111\" ]; then\n     for (( i = 0; i < ${#testScripts[@]}; i++ ))"
      },
      {
        "sha": "c57b6df81bbb03b3182d15f29b1b0dc424648453",
        "filename": "qa/rpc-tests/blockstore.py",
        "status": "added",
        "additions": 127,
        "deletions": 0,
        "changes": 127,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b93974c3f32a5398a94db275cd23b7ff78f269bf/qa/rpc-tests/blockstore.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b93974c3f32a5398a94db275cd23b7ff78f269bf/qa/rpc-tests/blockstore.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/blockstore.py?ref=b93974c3f32a5398a94db275cd23b7ff78f269bf",
        "patch": "@@ -0,0 +1,127 @@\n+# BlockStore: a helper class that keeps a map of blocks and implements\n+#             helper functions for responding to getheaders and getdata,\n+#             and for constructing a getheaders message\n+#\n+\n+from mininode import *\n+import dbm\n+\n+class BlockStore(object):\n+    def __init__(self, datadir):\n+        self.blockDB = dbm.open(datadir + \"/blocks\", 'c')\n+        self.currentBlock = 0L\n+    \n+    def close(self):\n+        self.blockDB.close()\n+\n+    def get(self, blockhash):\n+        serialized_block = None\n+        try:\n+            serialized_block = self.blockDB[repr(blockhash)]\n+        except KeyError:\n+            return None\n+        f = cStringIO.StringIO(serialized_block)\n+        ret = CBlock()\n+        ret.deserialize(f)\n+        ret.calc_sha256()\n+        return ret\n+\n+    # Note: this pulls full blocks out of the database just to retrieve\n+    # the headers -- perhaps we could keep a separate data structure\n+    # to avoid this overhead.\n+    def headers_for(self, locator, hash_stop, current_tip=None):\n+        if current_tip is None:\n+            current_tip = self.currentBlock\n+        current_block = self.get(current_tip)\n+        if current_block is None:\n+            return None\n+\n+        response = msg_headers()\n+        headersList = [ CBlockHeader(current_block) ]\n+        maxheaders = 2000\n+        while (headersList[0].sha256 not in locator.vHave):\n+            prevBlockHash = headersList[0].hashPrevBlock\n+            prevBlock = self.get(prevBlockHash)\n+            if prevBlock is not None:\n+                headersList.insert(0, CBlockHeader(prevBlock))\n+            else:\n+                break\n+        headersList = headersList[:maxheaders] # truncate if we have too many\n+        hashList = [x.sha256 for x in headersList]\n+        index = len(headersList)\n+        if (hash_stop in hashList):\n+            index = hashList.index(hash_stop)+1\n+        response.headers = headersList[:index]\n+        return response\n+\n+    def add_block(self, block):\n+        block.calc_sha256()\n+        try:\n+            self.blockDB[repr(block.sha256)] = bytes(block.serialize())\n+        except TypeError as e:\n+            print \"Unexpected error: \", sys.exc_info()[0], e.args\n+        self.currentBlock = block.sha256\n+\n+    def get_blocks(self, inv):\n+        responses = []\n+        for i in inv:\n+            if (i.type == 2): # MSG_BLOCK\n+                block = self.get(i.hash)\n+                if block is not None:\n+                    responses.append(msg_block(block))\n+        return responses\n+\n+    def get_locator(self, current_tip=None):\n+        if current_tip is None:\n+            current_tip = self.currentBlock\n+        r = []\n+        counter = 0\n+        step = 1\n+        lastBlock = self.get(current_tip)\n+        while lastBlock is not None:\n+            r.append(lastBlock.hashPrevBlock)\n+            for i in range(step):\n+                lastBlock = self.get(lastBlock.hashPrevBlock)\n+                if lastBlock is None:\n+                    break\n+            counter += 1\n+            if counter > 10:\n+                step *= 2\n+        locator = CBlockLocator()\n+        locator.vHave = r\n+        return locator\n+\n+class TxStore(object):\n+    def __init__(self, datadir):\n+        self.txDB = dbm.open(datadir + \"/transactions\", 'c')\n+\n+    def close(self):\n+        self.txDB.close()\n+\n+    def get(self, txhash):\n+        serialized_tx = None\n+        try:\n+            serialized_tx = self.txDB[repr(txhash)]\n+        except KeyError:\n+            return None\n+        f = cStringIO.StringIO(serialized_tx)\n+        ret = CTransaction()\n+        ret.deserialize(f)\n+        ret.calc_sha256()\n+        return ret\n+\n+    def add_transaction(self, tx):\n+        tx.calc_sha256()\n+        try:\n+            self.txDB[repr(tx.sha256)] = bytes(tx.serialize())\n+        except TypeError as e:\n+            print \"Unexpected error: \", sys.exc_info()[0], e.args\n+\n+    def get_transactions(self, inv):\n+        responses = []\n+        for i in inv:\n+            if (i.type == 1): # MSG_TX\n+                tx = self.get(i.hash)\n+                if tx is not None:\n+                    responses.append(msg_tx(tx))\n+        return responses"
      },
      {
        "sha": "f397fe7cd6ebbc56344b460048f0529b59e0bdc2",
        "filename": "qa/rpc-tests/blocktools.py",
        "status": "added",
        "additions": 65,
        "deletions": 0,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b93974c3f32a5398a94db275cd23b7ff78f269bf/qa/rpc-tests/blocktools.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b93974c3f32a5398a94db275cd23b7ff78f269bf/qa/rpc-tests/blocktools.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/blocktools.py?ref=b93974c3f32a5398a94db275cd23b7ff78f269bf",
        "patch": "@@ -0,0 +1,65 @@\n+# blocktools.py - utilities for manipulating blocks and transactions\n+#\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+from mininode import *\n+from script import CScript, CScriptOp\n+\n+# Create a block (with regtest difficulty)\n+def create_block(hashprev, coinbase, nTime=None):\n+    block = CBlock()\n+    if nTime is None:\n+        import time\n+        block.nTime = int(time.time()+600)\n+    else:\n+        block.nTime = nTime\n+    block.hashPrevBlock = hashprev\n+    block.nBits = 0x207fffff # Will break after a difficulty adjustment...\n+    block.vtx.append(coinbase)\n+    block.hashMerkleRoot = block.calc_merkle_root()\n+    block.calc_sha256()\n+    return block\n+\n+def serialize_script_num(value):\n+    r = bytearray(0)\n+    if value == 0:\n+        return r\n+    neg = value < 0\n+    absvalue = -value if neg else value\n+    while (absvalue):\n+        r.append(chr(absvalue & 0xff))\n+        absvalue >>= 8\n+    if r[-1] & 0x80:\n+        r.append(0x80 if neg else 0)\n+    elif neg:\n+        r[-1] |= 0x80\n+    return r\n+\n+counter=1\n+# Create an anyone-can-spend coinbase transaction, assuming no miner fees\n+def create_coinbase(heightAdjust = 0):\n+    global counter\n+    coinbase = CTransaction()\n+    coinbase.vin.append(CTxIn(COutPoint(0, 0xffffffff), \n+                ser_string(serialize_script_num(counter+heightAdjust)), 0xffffffff))\n+    counter += 1\n+    coinbaseoutput = CTxOut()\n+    coinbaseoutput.nValue = 50*100000000\n+    halvings = int((counter+heightAdjust)/150) # regtest\n+    coinbaseoutput.nValue >>= halvings\n+    coinbaseoutput.scriptPubKey = \"\"\n+    coinbase.vout = [ coinbaseoutput ]\n+    coinbase.calc_sha256()\n+    return coinbase\n+\n+# Create a transaction with an anyone-can-spend output, that spends the\n+# nth output of prevtx.\n+def create_transaction(prevtx, n, sig, value):\n+    tx = CTransaction()\n+    assert(n < len(prevtx.vout))\n+    tx.vin.append(CTxIn(COutPoint(prevtx.sha256, n), sig, 0xffffffff))\n+    tx.vout.append(CTxOut(value, \"\"))\n+    tx.calc_sha256()\n+    return tx"
      },
      {
        "sha": "6125bae51e4d922fc6be31ff34c5005fd1be140f",
        "filename": "qa/rpc-tests/comptool.py",
        "status": "added",
        "additions": 330,
        "deletions": 0,
        "changes": 330,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b93974c3f32a5398a94db275cd23b7ff78f269bf/qa/rpc-tests/comptool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b93974c3f32a5398a94db275cd23b7ff78f269bf/qa/rpc-tests/comptool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/comptool.py?ref=b93974c3f32a5398a94db275cd23b7ff78f269bf",
        "patch": "@@ -0,0 +1,330 @@\n+#!/usr/bin/env python2\n+#\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+from mininode import *\n+from blockstore import BlockStore, TxStore\n+from util import p2p_port\n+\n+'''\n+This is a tool for comparing two or more bitcoinds to each other\n+using a script provided.\n+\n+To use, create a class that implements get_tests(), and pass it in\n+as the test generator to TestManager.  get_tests() should be a python\n+generator that returns TestInstance objects.  See below for definition.\n+'''\n+\n+# TestNode behaves as follows:\n+# Configure with a BlockStore and TxStore\n+# on_inv: log the message but don't request\n+# on_headers: log the chain tip\n+# on_pong: update ping response map (for synchronization)\n+# on_getheaders: provide headers via BlockStore\n+# on_getdata: provide blocks via BlockStore\n+\n+class TestNode(NodeConnCB):\n+\n+    def __init__(self, block_store, tx_store):\n+        NodeConnCB.__init__(self)\n+        self.create_callback_map()\n+        self.conn = None\n+        self.bestblockhash = None\n+        self.block_store = block_store\n+        self.block_request_map = {}\n+        self.tx_store = tx_store\n+        self.tx_request_map = {}\n+\n+        # When the pingmap is non-empty we're waiting for \n+        # a response\n+        self.pingMap = {} \n+        self.lastInv = []\n+\n+    def add_connection(self, conn):\n+        self.conn = conn\n+\n+    def on_headers(self, conn, message):\n+        if len(message.headers) > 0:\n+            best_header = message.headers[-1]\n+            best_header.calc_sha256()\n+            self.bestblockhash = best_header.sha256\n+\n+    def on_getheaders(self, conn, message):\n+        response = self.block_store.headers_for(message.locator, message.hashstop)\n+        if response is not None:\n+            conn.send_message(response)\n+\n+    def on_getdata(self, conn, message):\n+        [conn.send_message(r) for r in self.block_store.get_blocks(message.inv)]\n+        [conn.send_message(r) for r in self.tx_store.get_transactions(message.inv)]\n+\n+        for i in message.inv:\n+            if i.type == 1:\n+                self.tx_request_map[i.hash] = True\n+            elif i.type == 2:\n+                self.block_request_map[i.hash] = True\n+\n+    def on_inv(self, conn, message):\n+        self.lastInv = [x.hash for x in message.inv]\n+\n+    def on_pong(self, conn, message):\n+        try:\n+            del self.pingMap[message.nonce]\n+        except KeyError:\n+            raise AssertionError(\"Got pong for unknown ping [%s]\" % repr(message))\n+\n+    def send_inv(self, obj):\n+        mtype = 2 if isinstance(obj, CBlock) else 1\n+        self.conn.send_message(msg_inv([CInv(mtype, obj.sha256)]))\n+\n+    def send_getheaders(self):\n+        # We ask for headers from their last tip.\n+        m = msg_getheaders()\n+        m.locator = self.block_store.get_locator(self.bestblockhash)\n+        self.conn.send_message(m)\n+\n+    # This assumes BIP31\n+    def send_ping(self, nonce):\n+        self.pingMap[nonce] = True\n+        self.conn.send_message(msg_ping(nonce))\n+\n+    def received_ping_response(self, nonce):\n+        return nonce not in self.pingMap\n+\n+    def send_mempool(self):\n+        self.lastInv = []\n+        self.conn.send_message(msg_mempool())\n+\n+# TestInstance:\n+#\n+# Instances of these are generated by the test generator, and fed into the\n+# comptool.\n+#\n+# \"blocks_and_transactions\" should be an array of [obj, True/False/None]:\n+#  - obj is either a CBlock or a CTransaction, and \n+#  - the second value indicates whether the object should be accepted\n+#    into the blockchain or mempool (for tests where we expect a certain\n+#    answer), or \"None\" if we don't expect a certain answer and are just\n+#    comparing the behavior of the nodes being tested.\n+# sync_every_block: if True, then each block will be inv'ed, synced, and\n+#    nodes will be tested based on the outcome for the block.  If False,\n+#    then inv's accumulate until all blocks are processed (or max inv size\n+#    is reached) and then sent out in one inv message.  Then the final block\n+#    will be synced across all connections, and the outcome of the final \n+#    block will be tested.\n+# sync_every_tx: analagous to behavior for sync_every_block, except if outcome\n+#    on the final tx is None, then contents of entire mempool are compared\n+#    across all connections.  (If outcome of final tx is specified as true\n+#    or false, then only the last tx is tested against outcome.)\n+\n+class TestInstance(object):\n+    def __init__(self, objects=[], sync_every_block=True, sync_every_tx=False):\n+        self.blocks_and_transactions = objects\n+        self.sync_every_block = sync_every_block\n+        self.sync_every_tx = sync_every_tx\n+\n+class TestManager(object):\n+\n+    def __init__(self, testgen, datadir):\n+        self.test_generator = testgen\n+        self.connections    = []\n+        self.block_store    = BlockStore(datadir)\n+        self.tx_store       = TxStore(datadir)\n+        self.ping_counter   = 1\n+\n+    def add_all_connections(self, nodes):\n+        for i in range(len(nodes)):\n+            # Create a p2p connection to each node\n+            self.connections.append(NodeConn('127.0.0.1', p2p_port(i), \n+                        nodes[i], TestNode(self.block_store, self.tx_store)))\n+            # Make sure the TestNode (callback class) has a reference to its\n+            # associated NodeConn\n+            self.connections[-1].cb.add_connection(self.connections[-1])\n+\n+    def wait_for_verack(self):\n+        sleep_time = 0.05\n+        max_tries = 10 / sleep_time  # Wait at most 10 seconds\n+        while max_tries > 0:\n+            done = True\n+            for c in self.connections:\n+                if c.cb.verack_received is False:\n+                    done = False\n+                    break\n+            if done:\n+                break\n+            time.sleep(sleep_time)\n+\n+    def wait_for_pings(self, counter):\n+        received_pongs = False\n+        while received_pongs is not True:\n+            time.sleep(0.05)\n+            received_pongs = True\n+            for c in self.connections:\n+                if c.cb.received_ping_response(counter) is not True:\n+                    received_pongs = False\n+                    break\n+\n+    # sync_blocks: Wait for all connections to request the blockhash given\n+    # then send get_headers to find out the tip of each node, and synchronize\n+    # the response by using a ping (and waiting for pong with same nonce).\n+    def sync_blocks(self, blockhash, num_blocks):\n+        # Wait for nodes to request block (50ms sleep * 20 tries * num_blocks)\n+        max_tries = 20*num_blocks\n+        while max_tries > 0:\n+            results = [ blockhash in c.cb.block_request_map and\n+                        c.cb.block_request_map[blockhash] for c in self.connections ]\n+            if False not in results:\n+                break\n+            time.sleep(0.05)\n+            max_tries -= 1\n+\n+        # --> error if not requested\n+        if max_tries == 0:\n+            # print [ c.cb.block_request_map for c in self.connections ]\n+            raise AssertionError(\"Not all nodes requested block\")\n+        # --> Answer request (we did this inline!)\n+\n+        # Send getheaders message\n+        [ c.cb.send_getheaders() for c in self.connections ]\n+\n+        # Send ping and wait for response -- synchronization hack\n+        [ c.cb.send_ping(self.ping_counter) for c in self.connections ]\n+        self.wait_for_pings(self.ping_counter)\n+        self.ping_counter += 1\n+\n+    # Analogous to sync_block (see above)\n+    def sync_transaction(self, txhash, num_events):\n+        # Wait for nodes to request transaction (50ms sleep * 20 tries * num_events)\n+        max_tries = 20*num_events\n+        while max_tries > 0:\n+            results = [ txhash in c.cb.tx_request_map and\n+                        c.cb.tx_request_map[txhash] for c in self.connections ]\n+            if False not in results:\n+                break\n+            time.sleep(0.05)\n+            max_tries -= 1\n+\n+        # --> error if not requested\n+        if max_tries == 0:\n+            # print [ c.cb.tx_request_map for c in self.connections ]\n+            raise AssertionError(\"Not all nodes requested transaction\")\n+        # --> Answer request (we did this inline!)\n+\n+        # Get the mempool\n+        [ c.cb.send_mempool() for c in self.connections ]\n+\n+        # Send ping and wait for response -- synchronization hack\n+        [ c.cb.send_ping(self.ping_counter) for c in self.connections ]\n+        self.wait_for_pings(self.ping_counter)\n+        self.ping_counter += 1\n+\n+        # Sort inv responses from each node\n+        [ c.cb.lastInv.sort() for c in self.connections ]\n+\n+    # Verify that the tip of each connection all agree with each other, and\n+    # with the expected outcome (if given)\n+    def check_results(self, blockhash, outcome):\n+        for c in self.connections:\n+            if outcome is None:\n+                if c.cb.bestblockhash != self.connections[0].cb.bestblockhash:\n+                    return False\n+            elif ((c.cb.bestblockhash == blockhash) != outcome):\n+                # print c.cb.bestblockhash, blockhash, outcome\n+                return False\n+        return True\n+\n+    # Either check that the mempools all agree with each other, or that\n+    # txhash's presence in the mempool matches the outcome specified.\n+    # This is somewhat of a strange comparison, in that we're either comparing\n+    # a particular tx to an outcome, or the entire mempools altogether;\n+    # perhaps it would be useful to add the ability to check explicitly that\n+    # a particular tx's existence in the mempool is the same across all nodes.\n+    def check_mempool(self, txhash, outcome):\n+        for c in self.connections:\n+            if outcome is None:\n+                # Make sure the mempools agree with each other\n+                if c.cb.lastInv != self.connections[0].cb.lastInv:\n+                    # print c.rpc.getrawmempool()\n+                    return False\n+            elif ((txhash in c.cb.lastInv) != outcome):\n+                # print c.rpc.getrawmempool(), c.cb.lastInv\n+                return False\n+        return True\n+\n+    def run(self):\n+        # Wait until verack is received\n+        self.wait_for_verack()\n+\n+        test_number = 1\n+        for test_instance in self.test_generator.get_tests():\n+            # We use these variables to keep track of the last block\n+            # and last transaction in the tests, which are used\n+            # if we're not syncing on every block or every tx.\n+            [ block, block_outcome ] = [ None, None ]\n+            [ tx, tx_outcome ] = [ None, None ]\n+            invqueue = []\n+\n+            for b_or_t, outcome in test_instance.blocks_and_transactions:\n+                # Determine if we're dealing with a block or tx\n+                if isinstance(b_or_t, CBlock):  # Block test runner\n+                    block = b_or_t\n+                    block_outcome = outcome\n+                    # Add to shared block_store, set as current block\n+                    self.block_store.add_block(block)\n+                    for c in self.connections:\n+                        c.cb.block_request_map[block.sha256] = False\n+                    # Either send inv's to each node and sync, or add\n+                    # to invqueue for later inv'ing.\n+                    if (test_instance.sync_every_block):\n+                        [ c.cb.send_inv(block) for c in self.connections ]\n+                        self.sync_blocks(block.sha256, 1)\n+                        if (not self.check_results(block.sha256, outcome)):\n+                            raise AssertionError(\"Test failed at test %d\" % test_number)\n+                    else:\n+                        invqueue.append(CInv(2, block.sha256))\n+                else:  # Tx test runner\n+                    assert(isinstance(b_or_t, CTransaction))\n+                    tx = b_or_t\n+                    tx_outcome = outcome\n+                    # Add to shared tx store\n+                    self.tx_store.add_transaction(tx)\n+                    for c in self.connections:\n+                        c.cb.tx_request_map[tx.sha256] = False\n+                    # Again, either inv to all nodes or save for later\n+                    if (test_instance.sync_every_tx):\n+                        [ c.cb.send_inv(tx) for c in self.connections ]\n+                        self.sync_transaction(tx.sha256, 1)\n+                        if (not self.check_mempool(tx.sha256, outcome)):\n+                            raise AssertionError(\"Test failed at test %d\" % test_number)\n+                    else:\n+                        invqueue.append(CInv(1, tx.sha256))\n+                # Ensure we're not overflowing the inv queue\n+                if len(invqueue) == MAX_INV_SZ:\n+                    [ c.sb.send_message(msg_inv(invqueue)) for c in self.connections ]\n+                    invqueue = []\n+\n+            # Do final sync if we weren't syncing on every block or every tx.\n+            if (not test_instance.sync_every_block and block is not None):\n+                if len(invqueue) > 0:\n+                    [ c.send_message(msg_inv(invqueue)) for c in self.connections ]\n+                    invqueue = []\n+                self.sync_blocks(block.sha256,\n+                                 len(test_instance.blocks_and_transactions))\n+                if (not self.check_results(block.sha256, block_outcome)):\n+                    raise AssertionError(\"Block test failed at test %d\" % test_number)\n+            if (not test_instance.sync_every_tx and tx is not None):\n+                if len(invqueue) > 0:\n+                    [ c.send_message(msg_inv(invqueue)) for c in self.connections ]\n+                    invqueue = []\n+                self.sync_transaction(tx.sha256, len(test_instance.blocks_and_transactions))\n+                if (not self.check_mempool(tx.sha256, tx_outcome)):\n+                    raise AssertionError(\"Mempool test failed at test %d\" % test_number)\n+\n+            print \"Test %d: PASS\" % test_number, [ c.rpc.getblockcount() for c in self.connections ]\n+            test_number += 1\n+\n+        self.block_store.close()\n+        self.tx_store.close()\n+        [ c.disconnect_node() for c in self.connections ]"
      },
      {
        "sha": "8b685ed9b23de7e62c74d25e2650ea70c94cc042",
        "filename": "qa/rpc-tests/invalidblockrequest.py",
        "status": "added",
        "additions": 115,
        "deletions": 0,
        "changes": 115,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b93974c3f32a5398a94db275cd23b7ff78f269bf/qa/rpc-tests/invalidblockrequest.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b93974c3f32a5398a94db275cd23b7ff78f269bf/qa/rpc-tests/invalidblockrequest.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/invalidblockrequest.py?ref=b93974c3f32a5398a94db275cd23b7ff78f269bf",
        "patch": "@@ -0,0 +1,115 @@\n+#!/usr/bin/env python2\n+#\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+from test_framework import ComparisonTestFramework\n+from util import *\n+from comptool import TestManager, TestInstance\n+from mininode import *\n+from blocktools import *\n+import logging\n+import copy\n+import time\n+\n+\n+'''\n+In this test we connect to one node over p2p, and test block requests:\n+1) Valid blocks should be requested and become chain tip.\n+2) Invalid block with duplicated transaction should be re-requested.\n+3) Invalid block with bad coinbase value should be rejected and not\n+re-requested.\n+'''\n+\n+# Use the ComparisonTestFramework with 1 node: only use --testbinary.\n+class InvalidBlockRequestTest(ComparisonTestFramework):\n+\n+    ''' Can either run this test as 1 node with expected answers, or two and compare them. \n+        Change the \"outcome\" variable from each TestInstance object to only do the comparison. '''\n+    def __init__(self):\n+        self.num_nodes = 1\n+\n+    def run_test(self):\n+        test = TestManager(self, self.options.tmpdir)\n+        test.add_all_connections(self.nodes)\n+        self.tip = None\n+        self.block_time = None\n+        NetworkThread().start() # Start up network handling in another thread\n+        test.run()\n+\n+    def get_tests(self):\n+        if self.tip is None:\n+            self.tip = int (\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n+        self.block_time = int(time.time())+1\n+\n+        '''\n+        Create a new block with an anyone-can-spend coinbase\n+        '''\n+        block = create_block(self.tip, create_coinbase(), self.block_time)\n+        self.block_time += 1\n+        block.solve()\n+        # Save the coinbase for later\n+        self.block1 = block\n+        self.tip = block.sha256\n+        yield TestInstance([[block, True]])\n+\n+        '''\n+        Now we need that block to mature so we can spend the coinbase.\n+        '''\n+        test = TestInstance(sync_every_block=False)\n+        for i in xrange(100):\n+            block = create_block(self.tip, create_coinbase(), self.block_time)\n+            block.solve()\n+            self.tip = block.sha256\n+            self.block_time += 1\n+            test.blocks_and_transactions.append([block, True])\n+        yield test\n+\n+        '''\n+        Now we use merkle-root malleability to generate an invalid block with\n+        same blockheader.\n+        Manufacture a block with 3 transactions (coinbase, spend of prior\n+        coinbase, spend of that spend).  Duplicate the 3rd transaction to \n+        leave merkle root and blockheader unchanged but invalidate the block.\n+        '''\n+        block2 = create_block(self.tip, create_coinbase(), self.block_time)\n+        self.block_time += 1\n+\n+        # chr(81) is OP_TRUE\n+        tx1 = create_transaction(self.block1.vtx[0], 0, chr(81), 50*100000000)\n+        tx2 = create_transaction(tx1, 0, chr(81), 50*100000000)\n+\n+        block2.vtx.extend([tx1, tx2])\n+        block2.hashMerkleRoot = block2.calc_merkle_root()\n+        block2.rehash()\n+        block2.solve()\n+        orig_hash = block2.sha256\n+        block2_orig = copy.deepcopy(block2)\n+\n+        # Mutate block 2\n+        block2.vtx.append(tx2)\n+        assert_equal(block2.hashMerkleRoot, block2.calc_merkle_root())\n+        assert_equal(orig_hash, block2.rehash())\n+        assert(block2_orig.vtx != block2.vtx)\n+\n+        self.tip = block2.sha256\n+        yield TestInstance([[block2, False], [block2_orig, True]])\n+\n+        '''\n+        Make sure that a totally screwed up block is not valid.\n+        '''\n+        block3 = create_block(self.tip, create_coinbase(), self.block_time)\n+        self.block_time += 1\n+        block3.vtx[0].vout[0].nValue = 100*100000000 # Too high!\n+        block3.vtx[0].sha256=None\n+        block3.vtx[0].calc_sha256()\n+        block3.hashMerkleRoot = block3.calc_merkle_root()\n+        block3.rehash()\n+        block3.solve()\n+\n+        yield TestInstance([[block3, False]])\n+\n+\n+if __name__ == '__main__':\n+    InvalidBlockRequestTest().main()"
      },
      {
        "sha": "f61b13dfe673bc0663e21865248c124936489e36",
        "filename": "qa/rpc-tests/test_framework.py",
        "status": "modified",
        "additions": 29,
        "deletions": 0,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b93974c3f32a5398a94db275cd23b7ff78f269bf/qa/rpc-tests/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b93974c3f32a5398a94db275cd23b7ff78f269bf/qa/rpc-tests/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework.py?ref=b93974c3f32a5398a94db275cd23b7ff78f269bf",
        "patch": "@@ -140,3 +140,32 @@ def main(self):\n         else:\n             print(\"Failed\")\n             sys.exit(1)\n+\n+\n+# Test framework for doing p2p comparison testing, which sets up some bitcoind\n+# binaries:\n+# 1 binary: test binary\n+# 2 binaries: 1 test binary, 1 ref binary\n+# n>2 binaries: 1 test binary, n-1 ref binaries\n+\n+class ComparisonTestFramework(BitcoinTestFramework):\n+\n+    # Can override the num_nodes variable to indicate how many nodes to run.\n+    def __init__(self):\n+        self.num_nodes = 2\n+\n+    def add_options(self, parser):\n+        parser.add_option(\"--testbinary\", dest=\"testbinary\", default=\"bitcoind\",\n+                          help=\"bitcoind binary to test\")\n+        parser.add_option(\"--refbinary\", dest=\"refbinary\", default=\"bitcoind\",\n+                          help=\"bitcoind binary to use for reference nodes (if any)\")\n+\n+    def setup_chain(self):\n+        print \"Initializing test directory \"+self.options.tmpdir\n+        initialize_chain_clean(self.options.tmpdir, self.num_nodes)\n+\n+    def setup_network(self):\n+        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir,\n+                                    extra_args=[['-debug', '-whitelist=127.0.0.1']] * self.num_nodes,\n+                                    binary=[self.options.testbinary] +\n+                                           [self.options.refbinary]*(self.num_nodes-1))"
      }
    ]
  },
  {
    "sha": "d76412b068d95454732aa3def95decf35251759a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNzY0MTJiMDY4ZDk1NDU0NzMyYWEzZGVmOTVkZWNmMzUyNTE3NTlh",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-04-28T16:41:54Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-04-28T19:09:29Z"
      },
      "message": "Add script manipulation tools for use in mininode testing framework\n\nscript.py is modified from the code in python-bitcoinlib, and provides tools\nfor manipulating and creating CScript objects.\n\nbignum.py is a dependency for script.py\n\nscript_test.py is an example test that uses the script tools for running a test\nthat compares the behavior of two nodes, in a comptool- style test, for each of\nthe test cases in the bitcoin unit test script files, script_valid.json and\nscript_invalid.json.  (This test is very slow to run, but is a proof of concept\nfor how we can write tests to compare consensus-critical behavior between\ndifferent versions of bitcoind.)\n\nbipdersig-p2p.py is another example test in the comptool framework, which tests\ndeployment of BIP DERSIG for a single node.  It uses the script.py tools for\nmanipulating signatures to be non-DER compliant.",
      "tree": {
        "sha": "a9b5888f34257cbd8c2a7bd03f9bb213f5fe07c8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a9b5888f34257cbd8c2a7bd03f9bb213f5fe07c8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d76412b068d95454732aa3def95decf35251759a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d76412b068d95454732aa3def95decf35251759a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d76412b068d95454732aa3def95decf35251759a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d76412b068d95454732aa3def95decf35251759a/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b93974c3f32a5398a94db275cd23b7ff78f269bf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b93974c3f32a5398a94db275cd23b7ff78f269bf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b93974c3f32a5398a94db275cd23b7ff78f269bf"
      }
    ],
    "stats": {
      "total": 1434,
      "additions": 1434,
      "deletions": 0
    },
    "files": [
      {
        "sha": "b0c58ccd474474cd9507add8fe49255b14a5ea9b",
        "filename": "qa/rpc-tests/bignum.py",
        "status": "added",
        "additions": 102,
        "deletions": 0,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d76412b068d95454732aa3def95decf35251759a/qa/rpc-tests/bignum.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d76412b068d95454732aa3def95decf35251759a/qa/rpc-tests/bignum.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bignum.py?ref=d76412b068d95454732aa3def95decf35251759a",
        "patch": "@@ -0,0 +1,102 @@\n+#\n+#\n+# bignum.py\n+#\n+# This file is copied from python-bitcoinlib.\n+#\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+\"\"\"Bignum routines\"\"\"\n+\n+from __future__ import absolute_import, division, print_function, unicode_literals\n+\n+import struct\n+\n+\n+# generic big endian MPI format\n+\n+def bn_bytes(v, have_ext=False):\n+    ext = 0\n+    if have_ext:\n+        ext = 1\n+    return ((v.bit_length()+7)//8) + ext\n+\n+def bn2bin(v):\n+    s = bytearray()\n+    i = bn_bytes(v)\n+    while i > 0:\n+        s.append((v >> ((i-1) * 8)) & 0xff)\n+        i -= 1\n+    return s\n+\n+def bin2bn(s):\n+    l = 0\n+    for ch in s:\n+        l = (l << 8) | ch\n+    return l\n+\n+def bn2mpi(v):\n+    have_ext = False\n+    if v.bit_length() > 0:\n+        have_ext = (v.bit_length() & 0x07) == 0\n+\n+    neg = False\n+    if v < 0:\n+        neg = True\n+        v = -v\n+\n+    s = struct.pack(b\">I\", bn_bytes(v, have_ext))\n+    ext = bytearray()\n+    if have_ext:\n+        ext.append(0)\n+    v_bin = bn2bin(v)\n+    if neg:\n+        if have_ext:\n+            ext[0] |= 0x80\n+        else:\n+            v_bin[0] |= 0x80\n+    return s + ext + v_bin\n+\n+def mpi2bn(s):\n+    if len(s) < 4:\n+        return None\n+    s_size = bytes(s[:4])\n+    v_len = struct.unpack(b\">I\", s_size)[0]\n+    if len(s) != (v_len + 4):\n+        return None\n+    if v_len == 0:\n+        return 0\n+\n+    v_str = bytearray(s[4:])\n+    neg = False\n+    i = v_str[0]\n+    if i & 0x80:\n+        neg = True\n+        i &= ~0x80\n+        v_str[0] = i\n+\n+    v = bin2bn(v_str)\n+\n+    if neg:\n+        return -v\n+    return v\n+\n+# bitcoin-specific little endian format, with implicit size\n+def mpi2vch(s):\n+    r = s[4:]           # strip size\n+    r = r[::-1]         # reverse string, converting BE->LE\n+    return r\n+\n+def bn2vch(v):\n+    return bytes(mpi2vch(bn2mpi(v)))\n+\n+def vch2mpi(s):\n+    r = struct.pack(b\">I\", len(s))   # size\n+    r += s[::-1]            # reverse string, converting LE->BE\n+    return r\n+\n+def vch2bn(s):\n+    return mpi2bn(vch2mpi(s))\n+"
      },
      {
        "sha": "ff0c87889898546059ebb510a97b45f7bb5834f8",
        "filename": "qa/rpc-tests/bipdersig-p2p.py",
        "status": "added",
        "additions": 183,
        "deletions": 0,
        "changes": 183,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d76412b068d95454732aa3def95decf35251759a/qa/rpc-tests/bipdersig-p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d76412b068d95454732aa3def95decf35251759a/qa/rpc-tests/bipdersig-p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bipdersig-p2p.py?ref=d76412b068d95454732aa3def95decf35251759a",
        "patch": "@@ -0,0 +1,183 @@\n+#!/usr/bin/env python2\n+#\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+from test_framework import ComparisonTestFramework\n+from util import *\n+from mininode import CTransaction, NetworkThread\n+from blocktools import create_coinbase, create_block\n+from binascii import hexlify, unhexlify\n+import cStringIO\n+from comptool import TestInstance, TestManager\n+from script import CScript\n+import time\n+\n+# A canonical signature consists of: \n+# <30> <total len> <02> <len R> <R> <02> <len S> <S> <hashtype>\n+def unDERify(tx):\n+    '''\n+    Make the signature in vin 0 of a tx non-DER-compliant,\n+    by adding padding after the S-value.\n+    '''\n+    scriptSig = CScript(tx.vin[0].scriptSig)\n+    newscript = []\n+    for i in scriptSig:\n+        if (len(newscript) == 0):\n+            newscript.append(i[0:-1] + '\\0' + i[-1])\n+        else:\n+            newscript.append(i)\n+    tx.vin[0].scriptSig = CScript(newscript)\n+    \n+'''\n+This test is meant to exercise BIP66 (DER SIG).\n+Connect to a single node.\n+Mine 2 (version 2) blocks (save the coinbases for later).\n+Generate 98 more version 2 blocks, verify the node accepts.\n+Mine 749 version 3 blocks, verify the node accepts.\n+Check that the new DERSIG rules are not enforced on the 750th version 3 block.\n+Check that the new DERSIG rules are enforced on the 751st version 3 block.\n+Mine 199 new version blocks.\n+Mine 1 old-version block.\n+Mine 1 new version block.\n+Mine 1 old version block, see that the node rejects.\n+'''\n+            \n+class BIP66Test(ComparisonTestFramework):\n+\n+    def __init__(self):\n+        self.num_nodes = 1\n+\n+    def setup_network(self):\n+        # Must set the blockversion for this test\n+        self.nodes = start_nodes(1, self.options.tmpdir, \n+                                 extra_args=[['-debug', '-whitelist=127.0.0.1', '-blockversion=2']],\n+                                 binary=[self.options.testbinary])\n+\n+    def run_test(self):\n+        test = TestManager(self, self.options.tmpdir)\n+        test.add_all_connections(self.nodes)\n+        NetworkThread().start() # Start up network handling in another thread\n+        test.run()\n+\n+    def create_transaction(self, node, coinbase, to_address, amount):\n+        from_txid = node.getblock(coinbase)['tx'][0]\n+        inputs = [{ \"txid\" : from_txid, \"vout\" : 0}]\n+        outputs = { to_address : amount }\n+        rawtx = node.createrawtransaction(inputs, outputs)\n+        signresult = node.signrawtransaction(rawtx)\n+        tx = CTransaction()\n+        f = cStringIO.StringIO(unhexlify(signresult['hex']))\n+        tx.deserialize(f)\n+        return tx\n+\n+    def get_tests(self):\n+\n+        self.coinbase_blocks = self.nodes[0].generate(2)\n+        self.tip = int (\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n+        self.nodeaddress = self.nodes[0].getnewaddress()\n+        self.last_block_time = time.time()\n+\n+        ''' 98 more version 2 blocks '''\n+        test_blocks = []\n+        for i in xrange(98):\n+            block = create_block(self.tip, create_coinbase(2), self.last_block_time + 1)\n+            block.nVersion = 2\n+            block.rehash()\n+            block.solve()\n+            test_blocks.append([block, True])\n+            self.last_block_time += 1\n+            self.tip = block.sha256\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+\n+        ''' Mine 749 version 3 blocks '''\n+        test_blocks = []\n+        for i in xrange(749):\n+            block = create_block(self.tip, create_coinbase(2), self.last_block_time + 1)\n+            block.nVersion = 3\n+            block.rehash()\n+            block.solve()\n+            test_blocks.append([block, True])\n+            self.last_block_time += 1\n+            self.tip = block.sha256\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+\n+        ''' \n+        Check that the new DERSIG rules are not enforced in the 750th\n+        version 3 block.\n+        '''\n+        spendtx = self.create_transaction(self.nodes[0],\n+                self.coinbase_blocks[0], self.nodeaddress, 1.0)\n+        unDERify(spendtx)\n+        spendtx.rehash()\n+\n+        block = create_block(self.tip, create_coinbase(2), self.last_block_time + 1)\n+        block.nVersion = 3\n+        block.vtx.append(spendtx)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        block.rehash()\n+        block.solve()\n+\n+        self.last_block_time += 1\n+        self.tip = block.sha256\n+        yield TestInstance([[block, True]])\n+\n+        ''' \n+        Check that the new DERSIG rules are enforced in the 751st version 3\n+        block.\n+        '''\n+        spendtx = self.create_transaction(self.nodes[0],\n+                self.coinbase_blocks[1], self.nodeaddress, 1.0)\n+        unDERify(spendtx)\n+        spendtx.rehash()\n+\n+        block = create_block(self.tip, create_coinbase(1), self.last_block_time + 1)\n+        block.nVersion = 3\n+        block.vtx.append(spendtx)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        block.rehash()\n+        block.solve()\n+        self.last_block_time += 1\n+        yield TestInstance([[block, False]])\n+\n+        ''' Mine 199 new version blocks on last valid tip '''\n+        test_blocks = []\n+        for i in xrange(199):\n+            block = create_block(self.tip, create_coinbase(1), self.last_block_time + 1)\n+            block.nVersion = 3\n+            block.rehash()\n+            block.solve()\n+            test_blocks.append([block, True])\n+            self.last_block_time += 1\n+            self.tip = block.sha256\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+\n+        ''' Mine 1 old version block '''\n+        block = create_block(self.tip, create_coinbase(1), self.last_block_time + 1)\n+        block.nVersion = 2\n+        block.rehash()\n+        block.solve()\n+        self.last_block_time += 1\n+        self.tip = block.sha256\n+        yield TestInstance([[block, True]])\n+\n+        ''' Mine 1 new version block '''\n+        block = create_block(self.tip, create_coinbase(1), self.last_block_time + 1)\n+        block.nVersion = 3\n+        block.rehash()\n+        block.solve()\n+        self.last_block_time += 1\n+        self.tip = block.sha256\n+        yield TestInstance([[block, True]])\n+\n+        ''' Mine 1 old version block, should be invalid '''\n+        block = create_block(self.tip, create_coinbase(1), self.last_block_time + 1)\n+        block.nVersion = 2\n+        block.rehash()\n+        block.solve()\n+        self.last_block_time += 1\n+        yield TestInstance([[block, False]])\n+\n+if __name__ == '__main__':\n+    BIP66Test().main()"
      },
      {
        "sha": "03695b86354ca30d699b3aaee9f63ab590ca9140",
        "filename": "qa/rpc-tests/script.py",
        "status": "added",
        "additions": 896,
        "deletions": 0,
        "changes": 896,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d76412b068d95454732aa3def95decf35251759a/qa/rpc-tests/script.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d76412b068d95454732aa3def95decf35251759a/qa/rpc-tests/script.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/script.py?ref=d76412b068d95454732aa3def95decf35251759a",
        "patch": "@@ -0,0 +1,896 @@\n+#\n+# script.py\n+#\n+# This file is modified from python-bitcoinlib.\n+#\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+\"\"\"Scripts\n+\n+Functionality to build scripts, as well as SignatureHash().\n+\"\"\"\n+\n+from __future__ import absolute_import, division, print_function, unicode_literals\n+\n+from mininode import CTransaction, CTxOut, hash256\n+\n+import sys\n+bchr = chr\n+bord = ord\n+if sys.version > '3':\n+    long = int\n+    bchr = lambda x: bytes([x])\n+    bord = lambda x: x\n+\n+import copy\n+import struct\n+\n+import bignum\n+\n+MAX_SCRIPT_SIZE = 10000\n+MAX_SCRIPT_ELEMENT_SIZE = 520\n+MAX_SCRIPT_OPCODES = 201\n+\n+OPCODE_NAMES = {}\n+\n+_opcode_instances = []\n+class CScriptOp(int):\n+    \"\"\"A single script opcode\"\"\"\n+    __slots__ = []\n+\n+    @staticmethod\n+    def encode_op_pushdata(d):\n+        \"\"\"Encode a PUSHDATA op, returning bytes\"\"\"\n+        if len(d) < 0x4c:\n+            return b'' + bchr(len(d)) + d # OP_PUSHDATA\n+        elif len(d) <= 0xff:\n+            return b'\\x4c' + bchr(len(d)) + d # OP_PUSHDATA1\n+        elif len(d) <= 0xffff:\n+            return b'\\x4d' + struct.pack(b'<H', len(d)) + d # OP_PUSHDATA2\n+        elif len(d) <= 0xffffffff:\n+            return b'\\x4e' + struct.pack(b'<I', len(d)) + d # OP_PUSHDATA4\n+        else:\n+            raise ValueError(\"Data too long to encode in a PUSHDATA op\")\n+\n+    @staticmethod\n+    def encode_op_n(n):\n+        \"\"\"Encode a small integer op, returning an opcode\"\"\"\n+        if not (0 <= n <= 16):\n+            raise ValueError('Integer must be in range 0 <= n <= 16, got %d' % n)\n+\n+        if n == 0:\n+            return OP_0\n+        else:\n+            return CScriptOp(OP_1 + n-1)\n+\n+    def decode_op_n(self):\n+        \"\"\"Decode a small integer opcode, returning an integer\"\"\"\n+        if self == OP_0:\n+            return 0\n+\n+        if not (self == OP_0 or OP_1 <= self <= OP_16):\n+            raise ValueError('op %r is not an OP_N' % self)\n+\n+        return int(self - OP_1+1)\n+\n+    def is_small_int(self):\n+        \"\"\"Return true if the op pushes a small integer to the stack\"\"\"\n+        if 0x51 <= self <= 0x60 or self == 0:\n+            return True\n+        else:\n+            return False\n+\n+    def __str__(self):\n+        return repr(self)\n+\n+    def __repr__(self):\n+        if self in OPCODE_NAMES:\n+            return OPCODE_NAMES[self]\n+        else:\n+            return 'CScriptOp(0x%x)' % self\n+\n+    def __new__(cls, n):\n+        try:\n+            return _opcode_instances[n]\n+        except IndexError:\n+            assert len(_opcode_instances) == n\n+            _opcode_instances.append(super(CScriptOp, cls).__new__(cls, n))\n+            return _opcode_instances[n]\n+\n+# Populate opcode instance table\n+for n in range(0xff+1):\n+    CScriptOp(n)\n+\n+\n+# push value\n+OP_0 = CScriptOp(0x00)\n+OP_FALSE = OP_0\n+OP_PUSHDATA1 = CScriptOp(0x4c)\n+OP_PUSHDATA2 = CScriptOp(0x4d)\n+OP_PUSHDATA4 = CScriptOp(0x4e)\n+OP_1NEGATE = CScriptOp(0x4f)\n+OP_RESERVED = CScriptOp(0x50)\n+OP_1 = CScriptOp(0x51)\n+OP_TRUE=OP_1\n+OP_2 = CScriptOp(0x52)\n+OP_3 = CScriptOp(0x53)\n+OP_4 = CScriptOp(0x54)\n+OP_5 = CScriptOp(0x55)\n+OP_6 = CScriptOp(0x56)\n+OP_7 = CScriptOp(0x57)\n+OP_8 = CScriptOp(0x58)\n+OP_9 = CScriptOp(0x59)\n+OP_10 = CScriptOp(0x5a)\n+OP_11 = CScriptOp(0x5b)\n+OP_12 = CScriptOp(0x5c)\n+OP_13 = CScriptOp(0x5d)\n+OP_14 = CScriptOp(0x5e)\n+OP_15 = CScriptOp(0x5f)\n+OP_16 = CScriptOp(0x60)\n+\n+# control\n+OP_NOP = CScriptOp(0x61)\n+OP_VER = CScriptOp(0x62)\n+OP_IF = CScriptOp(0x63)\n+OP_NOTIF = CScriptOp(0x64)\n+OP_VERIF = CScriptOp(0x65)\n+OP_VERNOTIF = CScriptOp(0x66)\n+OP_ELSE = CScriptOp(0x67)\n+OP_ENDIF = CScriptOp(0x68)\n+OP_VERIFY = CScriptOp(0x69)\n+OP_RETURN = CScriptOp(0x6a)\n+\n+# stack ops\n+OP_TOALTSTACK = CScriptOp(0x6b)\n+OP_FROMALTSTACK = CScriptOp(0x6c)\n+OP_2DROP = CScriptOp(0x6d)\n+OP_2DUP = CScriptOp(0x6e)\n+OP_3DUP = CScriptOp(0x6f)\n+OP_2OVER = CScriptOp(0x70)\n+OP_2ROT = CScriptOp(0x71)\n+OP_2SWAP = CScriptOp(0x72)\n+OP_IFDUP = CScriptOp(0x73)\n+OP_DEPTH = CScriptOp(0x74)\n+OP_DROP = CScriptOp(0x75)\n+OP_DUP = CScriptOp(0x76)\n+OP_NIP = CScriptOp(0x77)\n+OP_OVER = CScriptOp(0x78)\n+OP_PICK = CScriptOp(0x79)\n+OP_ROLL = CScriptOp(0x7a)\n+OP_ROT = CScriptOp(0x7b)\n+OP_SWAP = CScriptOp(0x7c)\n+OP_TUCK = CScriptOp(0x7d)\n+\n+# splice ops\n+OP_CAT = CScriptOp(0x7e)\n+OP_SUBSTR = CScriptOp(0x7f)\n+OP_LEFT = CScriptOp(0x80)\n+OP_RIGHT = CScriptOp(0x81)\n+OP_SIZE = CScriptOp(0x82)\n+\n+# bit logic\n+OP_INVERT = CScriptOp(0x83)\n+OP_AND = CScriptOp(0x84)\n+OP_OR = CScriptOp(0x85)\n+OP_XOR = CScriptOp(0x86)\n+OP_EQUAL = CScriptOp(0x87)\n+OP_EQUALVERIFY = CScriptOp(0x88)\n+OP_RESERVED1 = CScriptOp(0x89)\n+OP_RESERVED2 = CScriptOp(0x8a)\n+\n+# numeric\n+OP_1ADD = CScriptOp(0x8b)\n+OP_1SUB = CScriptOp(0x8c)\n+OP_2MUL = CScriptOp(0x8d)\n+OP_2DIV = CScriptOp(0x8e)\n+OP_NEGATE = CScriptOp(0x8f)\n+OP_ABS = CScriptOp(0x90)\n+OP_NOT = CScriptOp(0x91)\n+OP_0NOTEQUAL = CScriptOp(0x92)\n+\n+OP_ADD = CScriptOp(0x93)\n+OP_SUB = CScriptOp(0x94)\n+OP_MUL = CScriptOp(0x95)\n+OP_DIV = CScriptOp(0x96)\n+OP_MOD = CScriptOp(0x97)\n+OP_LSHIFT = CScriptOp(0x98)\n+OP_RSHIFT = CScriptOp(0x99)\n+\n+OP_BOOLAND = CScriptOp(0x9a)\n+OP_BOOLOR = CScriptOp(0x9b)\n+OP_NUMEQUAL = CScriptOp(0x9c)\n+OP_NUMEQUALVERIFY = CScriptOp(0x9d)\n+OP_NUMNOTEQUAL = CScriptOp(0x9e)\n+OP_LESSTHAN = CScriptOp(0x9f)\n+OP_GREATERTHAN = CScriptOp(0xa0)\n+OP_LESSTHANOREQUAL = CScriptOp(0xa1)\n+OP_GREATERTHANOREQUAL = CScriptOp(0xa2)\n+OP_MIN = CScriptOp(0xa3)\n+OP_MAX = CScriptOp(0xa4)\n+\n+OP_WITHIN = CScriptOp(0xa5)\n+\n+# crypto\n+OP_RIPEMD160 = CScriptOp(0xa6)\n+OP_SHA1 = CScriptOp(0xa7)\n+OP_SHA256 = CScriptOp(0xa8)\n+OP_HASH160 = CScriptOp(0xa9)\n+OP_HASH256 = CScriptOp(0xaa)\n+OP_CODESEPARATOR = CScriptOp(0xab)\n+OP_CHECKSIG = CScriptOp(0xac)\n+OP_CHECKSIGVERIFY = CScriptOp(0xad)\n+OP_CHECKMULTISIG = CScriptOp(0xae)\n+OP_CHECKMULTISIGVERIFY = CScriptOp(0xaf)\n+\n+# expansion\n+OP_NOP1 = CScriptOp(0xb0)\n+OP_NOP2 = CScriptOp(0xb1)\n+OP_NOP3 = CScriptOp(0xb2)\n+OP_NOP4 = CScriptOp(0xb3)\n+OP_NOP5 = CScriptOp(0xb4)\n+OP_NOP6 = CScriptOp(0xb5)\n+OP_NOP7 = CScriptOp(0xb6)\n+OP_NOP8 = CScriptOp(0xb7)\n+OP_NOP9 = CScriptOp(0xb8)\n+OP_NOP10 = CScriptOp(0xb9)\n+\n+# template matching params\n+OP_SMALLINTEGER = CScriptOp(0xfa)\n+OP_PUBKEYS = CScriptOp(0xfb)\n+OP_PUBKEYHASH = CScriptOp(0xfd)\n+OP_PUBKEY = CScriptOp(0xfe)\n+\n+OP_INVALIDOPCODE = CScriptOp(0xff)\n+\n+VALID_OPCODES = {\n+    OP_1NEGATE,\n+    OP_RESERVED,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_13,\n+    OP_14,\n+    OP_15,\n+    OP_16,\n+\n+    OP_NOP,\n+    OP_VER,\n+    OP_IF,\n+    OP_NOTIF,\n+    OP_VERIF,\n+    OP_VERNOTIF,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_VERIFY,\n+    OP_RETURN,\n+\n+    OP_TOALTSTACK,\n+    OP_FROMALTSTACK,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_3DUP,\n+    OP_2OVER,\n+    OP_2ROT,\n+    OP_2SWAP,\n+    OP_IFDUP,\n+    OP_DEPTH,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_NIP,\n+    OP_OVER,\n+    OP_PICK,\n+    OP_ROLL,\n+    OP_ROT,\n+    OP_SWAP,\n+    OP_TUCK,\n+\n+    OP_CAT,\n+    OP_SUBSTR,\n+    OP_LEFT,\n+    OP_RIGHT,\n+    OP_SIZE,\n+\n+    OP_INVERT,\n+    OP_AND,\n+    OP_OR,\n+    OP_XOR,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_RESERVED1,\n+    OP_RESERVED2,\n+\n+    OP_1ADD,\n+    OP_1SUB,\n+    OP_2MUL,\n+    OP_2DIV,\n+    OP_NEGATE,\n+    OP_ABS,\n+    OP_NOT,\n+    OP_0NOTEQUAL,\n+\n+    OP_ADD,\n+    OP_SUB,\n+    OP_MUL,\n+    OP_DIV,\n+    OP_MOD,\n+    OP_LSHIFT,\n+    OP_RSHIFT,\n+\n+    OP_BOOLAND,\n+    OP_BOOLOR,\n+    OP_NUMEQUAL,\n+    OP_NUMEQUALVERIFY,\n+    OP_NUMNOTEQUAL,\n+    OP_LESSTHAN,\n+    OP_GREATERTHAN,\n+    OP_LESSTHANOREQUAL,\n+    OP_GREATERTHANOREQUAL,\n+    OP_MIN,\n+    OP_MAX,\n+\n+    OP_WITHIN,\n+\n+    OP_RIPEMD160,\n+    OP_SHA1,\n+    OP_SHA256,\n+    OP_HASH160,\n+    OP_HASH256,\n+    OP_CODESEPARATOR,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGVERIFY,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+\n+    OP_NOP1,\n+    OP_NOP2,\n+    OP_NOP3,\n+    OP_NOP4,\n+    OP_NOP5,\n+    OP_NOP6,\n+    OP_NOP7,\n+    OP_NOP8,\n+    OP_NOP9,\n+    OP_NOP10,\n+\n+    OP_SMALLINTEGER,\n+    OP_PUBKEYS,\n+    OP_PUBKEYHASH,\n+    OP_PUBKEY,\n+}\n+\n+OPCODE_NAMES.update({\n+    OP_0 : 'OP_0',\n+    OP_PUSHDATA1 : 'OP_PUSHDATA1',\n+    OP_PUSHDATA2 : 'OP_PUSHDATA2',\n+    OP_PUSHDATA4 : 'OP_PUSHDATA4',\n+    OP_1NEGATE : 'OP_1NEGATE',\n+    OP_RESERVED : 'OP_RESERVED',\n+    OP_1 : 'OP_1',\n+    OP_2 : 'OP_2',\n+    OP_3 : 'OP_3',\n+    OP_4 : 'OP_4',\n+    OP_5 : 'OP_5',\n+    OP_6 : 'OP_6',\n+    OP_7 : 'OP_7',\n+    OP_8 : 'OP_8',\n+    OP_9 : 'OP_9',\n+    OP_10 : 'OP_10',\n+    OP_11 : 'OP_11',\n+    OP_12 : 'OP_12',\n+    OP_13 : 'OP_13',\n+    OP_14 : 'OP_14',\n+    OP_15 : 'OP_15',\n+    OP_16 : 'OP_16',\n+    OP_NOP : 'OP_NOP',\n+    OP_VER : 'OP_VER',\n+    OP_IF : 'OP_IF',\n+    OP_NOTIF : 'OP_NOTIF',\n+    OP_VERIF : 'OP_VERIF',\n+    OP_VERNOTIF : 'OP_VERNOTIF',\n+    OP_ELSE : 'OP_ELSE',\n+    OP_ENDIF : 'OP_ENDIF',\n+    OP_VERIFY : 'OP_VERIFY',\n+    OP_RETURN : 'OP_RETURN',\n+    OP_TOALTSTACK : 'OP_TOALTSTACK',\n+    OP_FROMALTSTACK : 'OP_FROMALTSTACK',\n+    OP_2DROP : 'OP_2DROP',\n+    OP_2DUP : 'OP_2DUP',\n+    OP_3DUP : 'OP_3DUP',\n+    OP_2OVER : 'OP_2OVER',\n+    OP_2ROT : 'OP_2ROT',\n+    OP_2SWAP : 'OP_2SWAP',\n+    OP_IFDUP : 'OP_IFDUP',\n+    OP_DEPTH : 'OP_DEPTH',\n+    OP_DROP : 'OP_DROP',\n+    OP_DUP : 'OP_DUP',\n+    OP_NIP : 'OP_NIP',\n+    OP_OVER : 'OP_OVER',\n+    OP_PICK : 'OP_PICK',\n+    OP_ROLL : 'OP_ROLL',\n+    OP_ROT : 'OP_ROT',\n+    OP_SWAP : 'OP_SWAP',\n+    OP_TUCK : 'OP_TUCK',\n+    OP_CAT : 'OP_CAT',\n+    OP_SUBSTR : 'OP_SUBSTR',\n+    OP_LEFT : 'OP_LEFT',\n+    OP_RIGHT : 'OP_RIGHT',\n+    OP_SIZE : 'OP_SIZE',\n+    OP_INVERT : 'OP_INVERT',\n+    OP_AND : 'OP_AND',\n+    OP_OR : 'OP_OR',\n+    OP_XOR : 'OP_XOR',\n+    OP_EQUAL : 'OP_EQUAL',\n+    OP_EQUALVERIFY : 'OP_EQUALVERIFY',\n+    OP_RESERVED1 : 'OP_RESERVED1',\n+    OP_RESERVED2 : 'OP_RESERVED2',\n+    OP_1ADD : 'OP_1ADD',\n+    OP_1SUB : 'OP_1SUB',\n+    OP_2MUL : 'OP_2MUL',\n+    OP_2DIV : 'OP_2DIV',\n+    OP_NEGATE : 'OP_NEGATE',\n+    OP_ABS : 'OP_ABS',\n+    OP_NOT : 'OP_NOT',\n+    OP_0NOTEQUAL : 'OP_0NOTEQUAL',\n+    OP_ADD : 'OP_ADD',\n+    OP_SUB : 'OP_SUB',\n+    OP_MUL : 'OP_MUL',\n+    OP_DIV : 'OP_DIV',\n+    OP_MOD : 'OP_MOD',\n+    OP_LSHIFT : 'OP_LSHIFT',\n+    OP_RSHIFT : 'OP_RSHIFT',\n+    OP_BOOLAND : 'OP_BOOLAND',\n+    OP_BOOLOR : 'OP_BOOLOR',\n+    OP_NUMEQUAL : 'OP_NUMEQUAL',\n+    OP_NUMEQUALVERIFY : 'OP_NUMEQUALVERIFY',\n+    OP_NUMNOTEQUAL : 'OP_NUMNOTEQUAL',\n+    OP_LESSTHAN : 'OP_LESSTHAN',\n+    OP_GREATERTHAN : 'OP_GREATERTHAN',\n+    OP_LESSTHANOREQUAL : 'OP_LESSTHANOREQUAL',\n+    OP_GREATERTHANOREQUAL : 'OP_GREATERTHANOREQUAL',\n+    OP_MIN : 'OP_MIN',\n+    OP_MAX : 'OP_MAX',\n+    OP_WITHIN : 'OP_WITHIN',\n+    OP_RIPEMD160 : 'OP_RIPEMD160',\n+    OP_SHA1 : 'OP_SHA1',\n+    OP_SHA256 : 'OP_SHA256',\n+    OP_HASH160 : 'OP_HASH160',\n+    OP_HASH256 : 'OP_HASH256',\n+    OP_CODESEPARATOR : 'OP_CODESEPARATOR',\n+    OP_CHECKSIG : 'OP_CHECKSIG',\n+    OP_CHECKSIGVERIFY : 'OP_CHECKSIGVERIFY',\n+    OP_CHECKMULTISIG : 'OP_CHECKMULTISIG',\n+    OP_CHECKMULTISIGVERIFY : 'OP_CHECKMULTISIGVERIFY',\n+    OP_NOP1 : 'OP_NOP1',\n+    OP_NOP2 : 'OP_NOP2',\n+    OP_NOP3 : 'OP_NOP3',\n+    OP_NOP4 : 'OP_NOP4',\n+    OP_NOP5 : 'OP_NOP5',\n+    OP_NOP6 : 'OP_NOP6',\n+    OP_NOP7 : 'OP_NOP7',\n+    OP_NOP8 : 'OP_NOP8',\n+    OP_NOP9 : 'OP_NOP9',\n+    OP_NOP10 : 'OP_NOP10',\n+    OP_SMALLINTEGER : 'OP_SMALLINTEGER',\n+    OP_PUBKEYS : 'OP_PUBKEYS',\n+    OP_PUBKEYHASH : 'OP_PUBKEYHASH',\n+    OP_PUBKEY : 'OP_PUBKEY',\n+    OP_INVALIDOPCODE : 'OP_INVALIDOPCODE',\n+})\n+\n+OPCODES_BY_NAME = {\n+    'OP_0' : OP_0,\n+    'OP_PUSHDATA1' : OP_PUSHDATA1,\n+    'OP_PUSHDATA2' : OP_PUSHDATA2,\n+    'OP_PUSHDATA4' : OP_PUSHDATA4,\n+    'OP_1NEGATE' : OP_1NEGATE,\n+    'OP_RESERVED' : OP_RESERVED,\n+    'OP_1' : OP_1,\n+    'OP_2' : OP_2,\n+    'OP_3' : OP_3,\n+    'OP_4' : OP_4,\n+    'OP_5' : OP_5,\n+    'OP_6' : OP_6,\n+    'OP_7' : OP_7,\n+    'OP_8' : OP_8,\n+    'OP_9' : OP_9,\n+    'OP_10' : OP_10,\n+    'OP_11' : OP_11,\n+    'OP_12' : OP_12,\n+    'OP_13' : OP_13,\n+    'OP_14' : OP_14,\n+    'OP_15' : OP_15,\n+    'OP_16' : OP_16,\n+    'OP_NOP' : OP_NOP,\n+    'OP_VER' : OP_VER,\n+    'OP_IF' : OP_IF,\n+    'OP_NOTIF' : OP_NOTIF,\n+    'OP_VERIF' : OP_VERIF,\n+    'OP_VERNOTIF' : OP_VERNOTIF,\n+    'OP_ELSE' : OP_ELSE,\n+    'OP_ENDIF' : OP_ENDIF,\n+    'OP_VERIFY' : OP_VERIFY,\n+    'OP_RETURN' : OP_RETURN,\n+    'OP_TOALTSTACK' : OP_TOALTSTACK,\n+    'OP_FROMALTSTACK' : OP_FROMALTSTACK,\n+    'OP_2DROP' : OP_2DROP,\n+    'OP_2DUP' : OP_2DUP,\n+    'OP_3DUP' : OP_3DUP,\n+    'OP_2OVER' : OP_2OVER,\n+    'OP_2ROT' : OP_2ROT,\n+    'OP_2SWAP' : OP_2SWAP,\n+    'OP_IFDUP' : OP_IFDUP,\n+    'OP_DEPTH' : OP_DEPTH,\n+    'OP_DROP' : OP_DROP,\n+    'OP_DUP' : OP_DUP,\n+    'OP_NIP' : OP_NIP,\n+    'OP_OVER' : OP_OVER,\n+    'OP_PICK' : OP_PICK,\n+    'OP_ROLL' : OP_ROLL,\n+    'OP_ROT' : OP_ROT,\n+    'OP_SWAP' : OP_SWAP,\n+    'OP_TUCK' : OP_TUCK,\n+    'OP_CAT' : OP_CAT,\n+    'OP_SUBSTR' : OP_SUBSTR,\n+    'OP_LEFT' : OP_LEFT,\n+    'OP_RIGHT' : OP_RIGHT,\n+    'OP_SIZE' : OP_SIZE,\n+    'OP_INVERT' : OP_INVERT,\n+    'OP_AND' : OP_AND,\n+    'OP_OR' : OP_OR,\n+    'OP_XOR' : OP_XOR,\n+    'OP_EQUAL' : OP_EQUAL,\n+    'OP_EQUALVERIFY' : OP_EQUALVERIFY,\n+    'OP_RESERVED1' : OP_RESERVED1,\n+    'OP_RESERVED2' : OP_RESERVED2,\n+    'OP_1ADD' : OP_1ADD,\n+    'OP_1SUB' : OP_1SUB,\n+    'OP_2MUL' : OP_2MUL,\n+    'OP_2DIV' : OP_2DIV,\n+    'OP_NEGATE' : OP_NEGATE,\n+    'OP_ABS' : OP_ABS,\n+    'OP_NOT' : OP_NOT,\n+    'OP_0NOTEQUAL' : OP_0NOTEQUAL,\n+    'OP_ADD' : OP_ADD,\n+    'OP_SUB' : OP_SUB,\n+    'OP_MUL' : OP_MUL,\n+    'OP_DIV' : OP_DIV,\n+    'OP_MOD' : OP_MOD,\n+    'OP_LSHIFT' : OP_LSHIFT,\n+    'OP_RSHIFT' : OP_RSHIFT,\n+    'OP_BOOLAND' : OP_BOOLAND,\n+    'OP_BOOLOR' : OP_BOOLOR,\n+    'OP_NUMEQUAL' : OP_NUMEQUAL,\n+    'OP_NUMEQUALVERIFY' : OP_NUMEQUALVERIFY,\n+    'OP_NUMNOTEQUAL' : OP_NUMNOTEQUAL,\n+    'OP_LESSTHAN' : OP_LESSTHAN,\n+    'OP_GREATERTHAN' : OP_GREATERTHAN,\n+    'OP_LESSTHANOREQUAL' : OP_LESSTHANOREQUAL,\n+    'OP_GREATERTHANOREQUAL' : OP_GREATERTHANOREQUAL,\n+    'OP_MIN' : OP_MIN,\n+    'OP_MAX' : OP_MAX,\n+    'OP_WITHIN' : OP_WITHIN,\n+    'OP_RIPEMD160' : OP_RIPEMD160,\n+    'OP_SHA1' : OP_SHA1,\n+    'OP_SHA256' : OP_SHA256,\n+    'OP_HASH160' : OP_HASH160,\n+    'OP_HASH256' : OP_HASH256,\n+    'OP_CODESEPARATOR' : OP_CODESEPARATOR,\n+    'OP_CHECKSIG' : OP_CHECKSIG,\n+    'OP_CHECKSIGVERIFY' : OP_CHECKSIGVERIFY,\n+    'OP_CHECKMULTISIG' : OP_CHECKMULTISIG,\n+    'OP_CHECKMULTISIGVERIFY' : OP_CHECKMULTISIGVERIFY,\n+    'OP_NOP1' : OP_NOP1,\n+    'OP_NOP2' : OP_NOP2,\n+    'OP_NOP3' : OP_NOP3,\n+    'OP_NOP4' : OP_NOP4,\n+    'OP_NOP5' : OP_NOP5,\n+    'OP_NOP6' : OP_NOP6,\n+    'OP_NOP7' : OP_NOP7,\n+    'OP_NOP8' : OP_NOP8,\n+    'OP_NOP9' : OP_NOP9,\n+    'OP_NOP10' : OP_NOP10,\n+    'OP_SMALLINTEGER' : OP_SMALLINTEGER,\n+    'OP_PUBKEYS' : OP_PUBKEYS,\n+    'OP_PUBKEYHASH' : OP_PUBKEYHASH,\n+    'OP_PUBKEY' : OP_PUBKEY,\n+}\n+\n+class CScriptInvalidError(Exception):\n+    \"\"\"Base class for CScript exceptions\"\"\"\n+    pass\n+\n+class CScriptTruncatedPushDataError(CScriptInvalidError):\n+    \"\"\"Invalid pushdata due to truncation\"\"\"\n+    def __init__(self, msg, data):\n+        self.data = data\n+        super(CScriptTruncatedPushDataError, self).__init__(msg)\n+\n+# This is used, eg, for blockchain heights in coinbase scripts (bip34)\n+class CScriptNum(object):\n+    def __init__(self, d=0):\n+        self.value = d\n+\n+    @staticmethod\n+    def encode(obj):\n+        r = bytearray(0)\n+        if obj.value == 0:\n+            return bytes(r)\n+        neg = obj.value < 0\n+        absvalue = -obj.value if neg else obj.value\n+        while (absvalue):\n+            r.append(chr(absvalue & 0xff))\n+            absvalue >>= 8\n+        if r[-1] & 0x80:\n+            r.append(0x80 if neg else 0)\n+        elif neg:\n+            r[-1] |= 0x80\n+        return bytes(bchr(len(r)) + r)\n+\n+\n+class CScript(bytes):\n+    \"\"\"Serialized script\n+\n+    A bytes subclass, so you can use this directly whenever bytes are accepted.\n+    Note that this means that indexing does *not* work - you'll get an index by\n+    byte rather than opcode. This format was chosen for efficiency so that the\n+    general case would not require creating a lot of little CScriptOP objects.\n+\n+    iter(script) however does iterate by opcode.\n+    \"\"\"\n+    @classmethod\n+    def __coerce_instance(cls, other):\n+        # Coerce other into bytes\n+        if isinstance(other, CScriptOp):\n+            other = bchr(other)\n+        elif isinstance(other, CScriptNum):\n+            if (other.value == 0):\n+                other = bchr(CScriptOp(OP_0))\n+            else:\n+                other = CScriptNum.encode(other)\n+        elif isinstance(other, (int, long)):\n+            if 0 <= other <= 16:\n+                other = bytes(bchr(CScriptOp.encode_op_n(other)))\n+            elif other == -1:\n+                other = bytes(bchr(OP_1NEGATE))\n+            else:\n+                other = CScriptOp.encode_op_pushdata(bignum.bn2vch(other))\n+        elif isinstance(other, (bytes, bytearray)):\n+            other = CScriptOp.encode_op_pushdata(other)\n+        return other\n+\n+    def __add__(self, other):\n+        # Do the coercion outside of the try block so that errors in it are\n+        # noticed.\n+        other = self.__coerce_instance(other)\n+\n+        try:\n+            # bytes.__add__ always returns bytes instances unfortunately\n+            return CScript(super(CScript, self).__add__(other))\n+        except TypeError:\n+            raise TypeError('Can not add a %r instance to a CScript' % other.__class__)\n+\n+    def join(self, iterable):\n+        # join makes no sense for a CScript()\n+        raise NotImplementedError\n+\n+    def __new__(cls, value=b''):\n+        if isinstance(value, bytes) or isinstance(value, bytearray):\n+            return super(CScript, cls).__new__(cls, value)\n+        else:\n+            def coerce_iterable(iterable):\n+                for instance in iterable:\n+                    yield cls.__coerce_instance(instance)\n+            # Annoyingly on both python2 and python3 bytes.join() always\n+            # returns a bytes instance even when subclassed.\n+            return super(CScript, cls).__new__(cls, b''.join(coerce_iterable(value)))\n+\n+    def raw_iter(self):\n+        \"\"\"Raw iteration\n+\n+        Yields tuples of (opcode, data, sop_idx) so that the different possible\n+        PUSHDATA encodings can be accurately distinguished, as well as\n+        determining the exact opcode byte indexes. (sop_idx)\n+        \"\"\"\n+        i = 0\n+        while i < len(self):\n+            sop_idx = i\n+            opcode = bord(self[i])\n+            i += 1\n+\n+            if opcode > OP_PUSHDATA4:\n+                yield (opcode, None, sop_idx)\n+            else:\n+                datasize = None\n+                pushdata_type = None\n+                if opcode < OP_PUSHDATA1:\n+                    pushdata_type = 'PUSHDATA(%d)' % opcode\n+                    datasize = opcode\n+\n+                elif opcode == OP_PUSHDATA1:\n+                    pushdata_type = 'PUSHDATA1'\n+                    if i >= len(self):\n+                        raise CScriptInvalidError('PUSHDATA1: missing data length')\n+                    datasize = bord(self[i])\n+                    i += 1\n+\n+                elif opcode == OP_PUSHDATA2:\n+                    pushdata_type = 'PUSHDATA2'\n+                    if i + 1 >= len(self):\n+                        raise CScriptInvalidError('PUSHDATA2: missing data length')\n+                    datasize = bord(self[i]) + (bord(self[i+1]) << 8)\n+                    i += 2\n+\n+                elif opcode == OP_PUSHDATA4:\n+                    pushdata_type = 'PUSHDATA4'\n+                    if i + 3 >= len(self):\n+                        raise CScriptInvalidError('PUSHDATA4: missing data length')\n+                    datasize = bord(self[i]) + (bord(self[i+1]) << 8) + (bord(self[i+2]) << 16) + (bord(self[i+3]) << 24)\n+                    i += 4\n+\n+                else:\n+                    assert False # shouldn't happen\n+\n+\n+                data = bytes(self[i:i+datasize])\n+\n+                # Check for truncation\n+                if len(data) < datasize:\n+                    raise CScriptTruncatedPushDataError('%s: truncated data' % pushdata_type, data)\n+\n+                i += datasize\n+\n+                yield (opcode, data, sop_idx)\n+\n+    def __iter__(self):\n+        \"\"\"'Cooked' iteration\n+\n+        Returns either a CScriptOP instance, an integer, or bytes, as\n+        appropriate.\n+\n+        See raw_iter() if you need to distinguish the different possible\n+        PUSHDATA encodings.\n+        \"\"\"\n+        for (opcode, data, sop_idx) in self.raw_iter():\n+            if data is not None:\n+                yield data\n+            else:\n+                opcode = CScriptOp(opcode)\n+\n+                if opcode.is_small_int():\n+                    yield opcode.decode_op_n()\n+                else:\n+                    yield CScriptOp(opcode)\n+\n+    def __repr__(self):\n+        # For Python3 compatibility add b before strings so testcases don't\n+        # need to change\n+        def _repr(o):\n+            if isinstance(o, bytes):\n+                return \"x('%s')\" % binascii.hexlify(o).decode('utf8')\n+            else:\n+                return repr(o)\n+\n+        ops = []\n+        i = iter(self)\n+        while True:\n+            op = None\n+            try:\n+                op = _repr(next(i))\n+            except CScriptTruncatedPushDataError as err:\n+                op = '%s...<ERROR: %s>' % (_repr(err.data), err)\n+                break\n+            except CScriptInvalidError as err:\n+                op = '<ERROR: %s>' % err\n+                break\n+            except StopIteration:\n+                break\n+            finally:\n+                if op is not None:\n+                    ops.append(op)\n+\n+        return \"CScript([%s])\" % ', '.join(ops)\n+\n+    def GetSigOpCount(self, fAccurate):\n+        \"\"\"Get the SigOp count.\n+\n+        fAccurate - Accurately count CHECKMULTISIG, see BIP16 for details.\n+\n+        Note that this is consensus-critical.\n+        \"\"\"\n+        n = 0\n+        lastOpcode = OP_INVALIDOPCODE\n+        for (opcode, data, sop_idx) in self.raw_iter():\n+            if opcode in (OP_CHECKSIG, OP_CHECKSIGVERIFY):\n+                n += 1\n+            elif opcode in (OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY):\n+                if fAccurate and (OP_1 <= lastOpcode <= OP_16):\n+                    n += opcode.decode_op_n()\n+                else:\n+                    n += 20\n+            lastOpcode = opcode\n+        return n\n+\n+\n+SIGHASH_ALL = 1\n+SIGHASH_NONE = 2\n+SIGHASH_SINGLE = 3\n+SIGHASH_ANYONECANPAY = 0x80\n+\n+def FindAndDelete(script, sig):\n+    \"\"\"Consensus critical, see FindAndDelete() in Satoshi codebase\"\"\"\n+    r = b''\n+    last_sop_idx = sop_idx = 0\n+    skip = True\n+    for (opcode, data, sop_idx) in script.raw_iter():\n+        if not skip:\n+            r += script[last_sop_idx:sop_idx]\n+        last_sop_idx = sop_idx\n+        if script[sop_idx:sop_idx + len(sig)] == sig:\n+            skip = True\n+        else:\n+            skip = False\n+    if not skip:\n+        r += script[last_sop_idx:]\n+    return CScript(r)\n+\n+\n+def SignatureHash(script, txTo, inIdx, hashtype):\n+    \"\"\"Consensus-correct SignatureHash\n+\n+    Returns (hash, err) to precisely match the consensus-critical behavior of\n+    the SIGHASH_SINGLE bug. (inIdx is *not* checked for validity)\n+    \"\"\"\n+    HASH_ONE = b'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n+\n+    if inIdx >= len(txTo.vin):\n+        return (HASH_ONE, \"inIdx %d out of range (%d)\" % (inIdx, len(txTo.vin)))\n+    txtmp = CTransaction(txTo)\n+\n+    for txin in txtmp.vin:\n+        txin.scriptSig = b''\n+    txtmp.vin[inIdx].scriptSig = FindAndDelete(script, CScript([OP_CODESEPARATOR]))\n+\n+    if (hashtype & 0x1f) == SIGHASH_NONE:\n+        txtmp.vout = []\n+\n+        for i in range(len(txtmp.vin)):\n+            if i != inIdx:\n+                txtmp.vin[i].nSequence = 0\n+\n+    elif (hashtype & 0x1f) == SIGHASH_SINGLE:\n+        outIdx = inIdx\n+        if outIdx >= len(txtmp.vout):\n+            return (HASH_ONE, \"outIdx %d out of range (%d)\" % (outIdx, len(txtmp.vout)))\n+\n+        tmp = txtmp.vout[outIdx]\n+        txtmp.vout = []\n+        for i in range(outIdx):\n+            txtmp.vout.append(CTxOut())\n+        txtmp.vout.append(tmp)\n+\n+        for i in range(len(txtmp.vin)):\n+            if i != inIdx:\n+                txtmp.vin[i].nSequence = 0\n+\n+    if hashtype & SIGHASH_ANYONECANPAY:\n+        tmp = txtmp.vin[inIdx]\n+        txtmp.vin = []\n+        txtmp.vin.append(tmp)\n+\n+    s = txtmp.serialize()\n+    s += struct.pack(b\"<I\", hashtype)\n+\n+    hash = hash256(s)\n+\n+    return (hash, None)"
      },
      {
        "sha": "1ba3a478a8ce9aae526d6fc65ef981f9cdb6a3a3",
        "filename": "qa/rpc-tests/script_test.py",
        "status": "added",
        "additions": 253,
        "deletions": 0,
        "changes": 253,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d76412b068d95454732aa3def95decf35251759a/qa/rpc-tests/script_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d76412b068d95454732aa3def95decf35251759a/qa/rpc-tests/script_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/script_test.py?ref=d76412b068d95454732aa3def95decf35251759a",
        "patch": "@@ -0,0 +1,253 @@\n+#!/usr/bin/env python2\n+#\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+'''\n+Test notes:\n+This test uses the script_valid and script_invalid tests from the unittest\n+framework to do end-to-end testing where we compare that two nodes agree on\n+whether blocks containing a given test script are valid.\n+\n+We generally ignore the script flags associated with each test (since we lack\n+the precision to test each script using those flags in this framework), but\n+for tests with SCRIPT_VERIFY_P2SH, we can use a block time after the BIP16 \n+switchover date to try to test with that flag enabled (and for tests without\n+that flag, we use a block time before the switchover date).\n+\n+NOTE: This test is very slow and may take more than 40 minutes to run.\n+'''\n+\n+from test_framework import ComparisonTestFramework\n+from util import *\n+from comptool import TestInstance, TestManager\n+from mininode import *\n+from blocktools import *\n+from script import *\n+import logging\n+import copy\n+import json\n+\n+script_valid_file   = \"../../src/test/data/script_valid.json\"\n+script_invalid_file = \"../../src/test/data/script_invalid.json\"\n+\n+# Pass in a set of json files to open. \n+class ScriptTestFile(object):\n+\n+    def __init__(self, files):\n+        self.files = files\n+        self.index = -1\n+        self.data = []\n+\n+    def load_files(self):\n+        for f in self.files:\n+            self.data.extend(json.loads(open(f).read()))\n+\n+    # Skip over records that are not long enough to be tests\n+    def get_records(self):\n+        while (self.index < len(self.data)):\n+            if len(self.data[self.index]) >= 3:\n+                yield self.data[self.index]\n+            self.index += 1\n+\n+\n+# Helper for parsing the flags specified in the .json files\n+SCRIPT_VERIFY_NONE = 0\n+SCRIPT_VERIFY_P2SH = 1 \n+SCRIPT_VERIFY_STRICTENC = 1 << 1\n+SCRIPT_VERIFY_DERSIG = 1 << 2\n+SCRIPT_VERIFY_LOW_S = 1 << 3\n+SCRIPT_VERIFY_NULLDUMMY = 1 << 4\n+SCRIPT_VERIFY_SIGPUSHONLY = 1 << 5\n+SCRIPT_VERIFY_MINIMALDATA = 1 << 6\n+SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = 1 << 7\n+SCRIPT_VERIFY_CLEANSTACK = 1 << 8\n+\n+flag_map = { \n+    \"\": SCRIPT_VERIFY_NONE,\n+    \"NONE\": SCRIPT_VERIFY_NONE, \n+    \"P2SH\": SCRIPT_VERIFY_P2SH,\n+    \"STRICTENC\": SCRIPT_VERIFY_STRICTENC,\n+    \"DERSIG\": SCRIPT_VERIFY_DERSIG,\n+    \"LOW_S\": SCRIPT_VERIFY_LOW_S,\n+    \"NULLDUMMY\": SCRIPT_VERIFY_NULLDUMMY,\n+    \"SIGPUSHONLY\": SCRIPT_VERIFY_SIGPUSHONLY,\n+    \"MINIMALDATA\": SCRIPT_VERIFY_MINIMALDATA,\n+    \"DISCOURAGE_UPGRADABLE_NOPS\": SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS,\n+    \"CLEANSTACK\": SCRIPT_VERIFY_CLEANSTACK,\n+}\n+\n+def ParseScriptFlags(flag_string):\n+    flags = 0\n+    for x in flag_string.split(\",\"):\n+        if x in flag_map:\n+            flags |= flag_map[x]\n+        else:\n+            print \"Error: unrecognized script flag: \", x\n+    return flags\n+\n+'''\n+Given a string that is a scriptsig or scriptpubkey from the .json files above,\n+convert it to a CScript()\n+'''\n+# Replicates behavior from core_read.cpp\n+def ParseScript(json_script):\n+    script = json_script.split(\" \")\n+    parsed_script = CScript()\n+    for x in script:\n+        if len(x) == 0:\n+            # Empty string, ignore.\n+            pass\n+        elif x.isdigit() or (len(x) >= 1 and x[0] == \"-\" and x[1:].isdigit()):\n+            # Number\n+            n = int(x, 0)\n+            if (n == -1) or (n >= 1 and n <= 16):\n+                parsed_script = CScript(bytes(parsed_script) + bytes(CScript([n])))\n+            else:\n+                parsed_script += CScriptNum(int(x, 0))\n+        elif x.startswith(\"0x\"):\n+            # Raw hex data, inserted NOT pushed onto stack:\n+            for i in xrange(2, len(x), 2):\n+                parsed_script = CScript(bytes(parsed_script) + bytes(chr(int(x[i:i+2],16))))\n+        elif x.startswith(\"'\") and x.endswith(\"'\") and len(x) >= 2:\n+            # Single-quoted string, pushed as data.\n+            parsed_script += CScript([x[1:-1]])\n+        else:\n+            # opcode, e.g. OP_ADD or ADD:\n+            tryopname = \"OP_\" + x\n+            if tryopname in OPCODES_BY_NAME:\n+                parsed_script += CScriptOp(OPCODES_BY_NAME[\"OP_\" + x])\n+            else:\n+                print \"ParseScript: error parsing '%s'\" % x\n+                return \"\"\n+    return parsed_script\n+            \n+class TestBuilder(object):\n+    def create_credit_tx(self, scriptPubKey):\n+        # self.tx1 is a coinbase transaction, modeled after the one created by script_tests.cpp\n+        # This allows us to reuse signatures created in the unit test framework.\n+        self.tx1 = create_coinbase()                 # this has a bip34 scriptsig,\n+        self.tx1.vin[0].scriptSig = CScript([0, 0])  # but this matches the unit tests\n+        self.tx1.vout[0].nValue = 0\n+        self.tx1.vout[0].scriptPubKey = scriptPubKey\n+        self.tx1.rehash()\n+    def create_spend_tx(self, scriptSig):\n+        self.tx2 = create_transaction(self.tx1, 0, CScript(), 0)\n+        self.tx2.vin[0].scriptSig = scriptSig\n+        self.tx2.vout[0].scriptPubKey = CScript()\n+        self.tx2.rehash()\n+    def rehash(self):\n+        self.tx1.rehash()\n+        self.tx2.rehash()\n+\n+# This test uses the (default) two nodes provided by ComparisonTestFramework,\n+# specified on the command line with --testbinary and --refbinary.\n+# See comptool.py\n+class ScriptTest(ComparisonTestFramework):\n+\n+    def run_test(self):\n+        # Set up the comparison tool TestManager\n+        test = TestManager(self, self.options.tmpdir)\n+        test.add_all_connections(self.nodes)\n+\n+        # Load scripts\n+        self.scripts = ScriptTestFile([script_valid_file, script_invalid_file])\n+        self.scripts.load_files()\n+\n+        # Some variables we re-use between test instances (to build blocks)\n+        self.tip = None\n+        self.block_time = None\n+\n+        NetworkThread().start()  # Start up network handling in another thread\n+        test.run()\n+\n+    def generate_test_instance(self, pubkeystring, scriptsigstring):\n+        scriptpubkey = ParseScript(pubkeystring)\n+        scriptsig = ParseScript(scriptsigstring)\n+\n+        test = TestInstance(sync_every_block=False)\n+        test_build = TestBuilder()\n+        test_build.create_credit_tx(scriptpubkey)\n+        test_build.create_spend_tx(scriptsig)\n+        test_build.rehash()\n+\n+        block = create_block(self.tip, test_build.tx1, self.block_time)\n+        self.block_time += 1\n+        block.solve()\n+        self.tip = block.sha256\n+        test.blocks_and_transactions = [[block, True]]\n+\n+        for i in xrange(100):\n+            block = create_block(self.tip, create_coinbase(), self.block_time)\n+            self.block_time += 1\n+            block.solve()\n+            self.tip = block.sha256\n+            test.blocks_and_transactions.append([block, True])\n+\n+        block = create_block(self.tip, create_coinbase(), self.block_time)\n+        self.block_time += 1\n+        block.vtx.append(test_build.tx2)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        block.rehash()\n+        block.solve()\n+        test.blocks_and_transactions.append([block, None])\n+        return test   \n+\n+    # This generates the tests for TestManager.\n+    def get_tests(self):\n+        self.tip = int (\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n+        self.block_time = 1333230000  # before the BIP16 switchover\n+\n+        '''\n+        Create a new block with an anyone-can-spend coinbase\n+        '''\n+        block = create_block(self.tip, create_coinbase(), self.block_time)\n+        self.block_time += 1\n+        block.solve()\n+        self.tip = block.sha256\n+        yield TestInstance(objects=[[block, True]])\n+\n+        '''\n+        Build out to 100 blocks total, maturing the coinbase.\n+        '''\n+        test = TestInstance(objects=[], sync_every_block=False, sync_every_tx=False)\n+        for i in xrange(100):\n+            b = create_block(self.tip, create_coinbase(), self.block_time)\n+            b.solve()\n+            test.blocks_and_transactions.append([b, True])\n+            self.tip = b.sha256\n+            self.block_time += 1\n+        yield test\n+ \n+        ''' Iterate through script tests. '''\n+        counter = 0\n+        for script_test in self.scripts.get_records():\n+            ''' Reset the blockchain to genesis block + 100 blocks. '''\n+            if self.nodes[0].getblockcount() > 101:\n+                self.nodes[0].invalidateblock(self.nodes[0].getblockhash(102))\n+                self.nodes[1].invalidateblock(self.nodes[1].getblockhash(102))\n+\n+            self.tip = int (\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n+\n+            [scriptsig, scriptpubkey, flags] = script_test[0:3]\n+            flags = ParseScriptFlags(flags)\n+\n+            # We can use block time to determine whether the nodes should be\n+            # enforcing BIP16.\n+            #\n+            # We intentionally let the block time grow by 1 each time.\n+            # This forces the block hashes to differ between tests, so that\n+            # a call to invalidateblock doesn't interfere with a later test.\n+            if (flags & SCRIPT_VERIFY_P2SH):\n+                self.block_time = 1333238400 + counter # Advance to enforcing BIP16\n+            else:\n+                self.block_time = 1333230000 + counter # Before the BIP16 switchover\n+\n+            print \"Script test: [%s]\" % script_test\n+\n+            yield self.generate_test_instance(scriptpubkey, scriptsig)\n+            counter += 1\n+\n+if __name__ == '__main__':\n+    ScriptTest().main()"
      }
    ]
  },
  {
    "sha": "29bff0e684c3ec0121a0695861b6701c5443707c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyOWJmZjBlNjg0YzNlYzAxMjFhMDY5NTg2MWI2NzAxYzU0NDM3MDdj",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-04-28T20:51:46Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-04-28T20:51:46Z"
      },
      "message": "Add some travis debugging for python scripts\n\nAdds printing to the console before/after calls to bitcoin-cli -rpcwait,\nif the PYTHON_DEBUG environment variable is initialized.",
      "tree": {
        "sha": "6cf1c8d0e26916b7c2040cc5785e2bc2b2e1415c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6cf1c8d0e26916b7c2040cc5785e2bc2b2e1415c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/29bff0e684c3ec0121a0695861b6701c5443707c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/29bff0e684c3ec0121a0695861b6701c5443707c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/29bff0e684c3ec0121a0695861b6701c5443707c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/29bff0e684c3ec0121a0695861b6701c5443707c/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d76412b068d95454732aa3def95decf35251759a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d76412b068d95454732aa3def95decf35251759a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d76412b068d95454732aa3def95decf35251759a"
      }
    ],
    "stats": {
      "total": 9,
      "additions": 9,
      "deletions": 0
    },
    "files": [
      {
        "sha": "e6578ee07861c2c9606d5e2287e90220575a7ff9",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/29bff0e684c3ec0121a0695861b6701c5443707c/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/29bff0e684c3ec0121a0695861b6701c5443707c/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=29bff0e684c3ec0121a0695861b6701c5443707c",
        "patch": "@@ -16,6 +16,7 @@ env:\n     - CCACHE_COMPRESS=1\n     - BASE_OUTDIR=$TRAVIS_BUILD_DIR/out\n     - SDK_URL=https://bitcoincore.org/depends-sources/sdks\n+    - PYTHON_DEBUG=1\n cache:\n   apt: true\n   directories:"
      },
      {
        "sha": "1cf96b314a19045d64a35ae6d8e968ab49c64c93",
        "filename": "qa/rpc-tests/util.py",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/29bff0e684c3ec0121a0695861b6701c5443707c/qa/rpc-tests/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/29bff0e684c3ec0121a0695861b6701c5443707c/qa/rpc-tests/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/util.py?ref=29bff0e684c3ec0121a0695861b6701c5443707c",
        "patch": "@@ -88,8 +88,12 @@ def initialize_chain(test_dir):\n             if i > 0:\n                 args.append(\"-connect=127.0.0.1:\"+str(p2p_port(0)))\n             bitcoind_processes[i] = subprocess.Popen(args)\n+            if os.getenv(\"PYTHON_DEBUG\", \"\"):\n+                print \"initialize_chain: bitcoind started, calling bitcoin-cli -rpcwait getblockcount\"\n             subprocess.check_call([ os.getenv(\"BITCOINCLI\", \"bitcoin-cli\"), \"-datadir=\"+datadir,\n                                     \"-rpcwait\", \"getblockcount\"], stdout=devnull)\n+            if os.getenv(\"PYTHON_DEBUG\", \"\"):\n+                print \"initialize_chain: bitcoin-cli -rpcwait getblockcount completed\"\n         devnull.close()\n         rpcs = []\n         for i in range(4):\n@@ -169,9 +173,13 @@ def start_node(i, dirname, extra_args=None, rpchost=None, timewait=None, binary=\n     if extra_args is not None: args.extend(extra_args)\n     bitcoind_processes[i] = subprocess.Popen(args)\n     devnull = open(\"/dev/null\", \"w+\")\n+    if os.getenv(\"PYTHON_DEBUG\", \"\"):\n+        print \"start_node: bitcoind started, calling bitcoin-cli -rpcwait getblockcount\"\n     subprocess.check_call([ os.getenv(\"BITCOINCLI\", \"bitcoin-cli\"), \"-datadir=\"+datadir] +\n                           _rpchost_to_args(rpchost)  +\n                           [\"-rpcwait\", \"getblockcount\"], stdout=devnull)\n+    if os.getenv(\"PYTHON_DEBUG\", \"\"):\n+        print \"start_node: calling bitcoin-cli -rpcwait getblockcount returned\"\n     devnull.close()\n     url = \"http://rt:rt@%s:%d\" % (rpchost or '127.0.0.1', rpc_port(i))\n     if timewait is not None:"
      }
    ]
  },
  {
    "sha": "2703412a39c95c811a40c3fff6929e4ce59c3c62",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNzAzNDEyYTM5Yzk1YzgxMWE0MGMzZmZmNjkyOWU0Y2U1OWMzYzYy",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-04-29T13:18:33Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-04-29T13:18:33Z"
      },
      "message": "Fix default binary in p2p tests to use environment variable",
      "tree": {
        "sha": "97585c3010cafead7e89bc885c47e9eeda250dd7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/97585c3010cafead7e89bc885c47e9eeda250dd7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2703412a39c95c811a40c3fff6929e4ce59c3c62",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2703412a39c95c811a40c3fff6929e4ce59c3c62",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2703412a39c95c811a40c3fff6929e4ce59c3c62",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2703412a39c95c811a40c3fff6929e4ce59c3c62/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "29bff0e684c3ec0121a0695861b6701c5443707c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/29bff0e684c3ec0121a0695861b6701c5443707c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/29bff0e684c3ec0121a0695861b6701c5443707c"
      }
    ],
    "stats": {
      "total": 9,
      "additions": 6,
      "deletions": 3
    },
    "files": [
      {
        "sha": "94535822d847732b346062b379985e04ef942f06",
        "filename": "qa/rpc-tests/maxblocksinflight.py",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2703412a39c95c811a40c3fff6929e4ce59c3c62/qa/rpc-tests/maxblocksinflight.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2703412a39c95c811a40c3fff6929e4ce59c3c62/qa/rpc-tests/maxblocksinflight.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/maxblocksinflight.py?ref=2703412a39c95c811a40c3fff6929e4ce59c3c62",
        "patch": "@@ -77,7 +77,8 @@ def run(self):\n         \n class MaxBlocksInFlightTest(BitcoinTestFramework):\n     def add_options(self, parser):\n-        parser.add_option(\"--testbinary\", dest=\"testbinary\", default=\"bitcoind\",\n+        parser.add_option(\"--testbinary\", dest=\"testbinary\",\n+                          default=os.getenv(\"BITCOIND\", \"bitcoind\"),\n                           help=\"Binary to test max block requests behavior\")\n \n     def setup_chain(self):"
      },
      {
        "sha": "9579db995ca8bed5e25d2d5299d5691000618e2c",
        "filename": "qa/rpc-tests/test_framework.py",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2703412a39c95c811a40c3fff6929e4ce59c3c62/qa/rpc-tests/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2703412a39c95c811a40c3fff6929e4ce59c3c62/qa/rpc-tests/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework.py?ref=2703412a39c95c811a40c3fff6929e4ce59c3c62",
        "patch": "@@ -155,9 +155,11 @@ def __init__(self):\n         self.num_nodes = 2\n \n     def add_options(self, parser):\n-        parser.add_option(\"--testbinary\", dest=\"testbinary\", default=\"bitcoind\",\n+        parser.add_option(\"--testbinary\", dest=\"testbinary\",\n+                          default=os.getenv(\"BITCOIND\", \"bitcoind\"),\n                           help=\"bitcoind binary to test\")\n-        parser.add_option(\"--refbinary\", dest=\"refbinary\", default=\"bitcoind\",\n+        parser.add_option(\"--refbinary\", dest=\"refbinary\",\n+                          default=os.getenv(\"BITCOIND\", \"bitcoind\"),\n                           help=\"bitcoind binary to use for reference nodes (if any)\")\n \n     def setup_chain(self):"
      }
    ]
  }
]