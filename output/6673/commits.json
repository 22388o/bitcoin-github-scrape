[
  {
    "sha": "bb93e2cb5dfbcfa5e20c9771f9638364775d8357",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiYjkzZTJjYjVkZmJjZmE1ZTIwYzk3NzFmOTYzODM2NDc3NWQ4MzU3",
    "commit": {
      "author": {
        "name": "Ashley Holman",
        "email": "dscvlt@gmail.com",
        "date": "2015-06-24T08:32:20Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-08-11T16:23:39Z"
      },
      "message": "TxMemPool: Change mapTx to a boost::multi_index_container\n\nIndexes on:\n- Tx Hash\n- Fee Rate (fee-per-kb)",
      "tree": {
        "sha": "6a01e4529b2208a068e7002f6089c480611183da",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6a01e4529b2208a068e7002f6089c480611183da"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bb93e2cb5dfbcfa5e20c9771f9638364775d8357",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bb93e2cb5dfbcfa5e20c9771f9638364775d8357",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bb93e2cb5dfbcfa5e20c9771f9638364775d8357",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bb93e2cb5dfbcfa5e20c9771f9638364775d8357/comments",
    "author": {
      "login": "ashleyholman",
      "id": 549484,
      "node_id": "MDQ6VXNlcjU0OTQ4NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/549484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ashleyholman",
      "html_url": "https://github.com/ashleyholman",
      "followers_url": "https://api.github.com/users/ashleyholman/followers",
      "following_url": "https://api.github.com/users/ashleyholman/following{/other_user}",
      "gists_url": "https://api.github.com/users/ashleyholman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ashleyholman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ashleyholman/subscriptions",
      "organizations_url": "https://api.github.com/users/ashleyholman/orgs",
      "repos_url": "https://api.github.com/users/ashleyholman/repos",
      "events_url": "https://api.github.com/users/ashleyholman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ashleyholman/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "87f37e259d6deb52ee464edde7aece687eea97a5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/87f37e259d6deb52ee464edde7aece687eea97a5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/87f37e259d6deb52ee464edde7aece687eea97a5"
      }
    ],
    "stats": {
      "total": 159,
      "additions": 127,
      "deletions": 32
    },
    "files": [
      {
        "sha": "64c1a93239b390ebf178f5b19864160dd9e6da57",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bb93e2cb5dfbcfa5e20c9771f9638364775d8357/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bb93e2cb5dfbcfa5e20c9771f9638364775d8357/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=bb93e2cb5dfbcfa5e20c9771f9638364775d8357",
        "patch": "@@ -158,10 +158,10 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n         // This vector will be sorted into a priority queue:\n         vector<TxPriority> vecPriority;\n         vecPriority.reserve(mempool.mapTx.size());\n-        for (map<uint256, CTxMemPoolEntry>::iterator mi = mempool.mapTx.begin();\n+        for (CTxMemPool::indexed_transaction_set::iterator mi = mempool.mapTx.begin();\n              mi != mempool.mapTx.end(); ++mi)\n         {\n-            const CTransaction& tx = mi->second.GetTx();\n+            const CTransaction& tx = mi->GetTx();\n             if (tx.IsCoinBase() || !IsFinalTx(tx, nHeight, pblock->nTime))\n                 continue;\n \n@@ -196,7 +196,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n                     }\n                     mapDependers[txin.prevout.hash].push_back(porphan);\n                     porphan->setDependsOn.insert(txin.prevout.hash);\n-                    nTotalIn += mempool.mapTx[txin.prevout.hash].GetTx().vout[txin.prevout.n].nValue;\n+                    nTotalIn += mempool.mapTx.find(txin.prevout.hash)->GetTx().vout[txin.prevout.n].nValue;\n                     continue;\n                 }\n                 const CCoins* coins = view.AccessCoins(txin.prevout.hash);\n@@ -226,7 +226,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n                 porphan->feeRate = feeRate;\n             }\n             else\n-                vecPriority.push_back(TxPriority(dPriority, feeRate, &mi->second.GetTx()));\n+                vecPriority.push_back(TxPriority(dPriority, feeRate, &(mi->GetTx())));\n         }\n \n         // Collect transactions into block"
      },
      {
        "sha": "76eae6d434b136219abd818f339ec819aff97247",
        "filename": "src/rpcblockchain.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bb93e2cb5dfbcfa5e20c9771f9638364775d8357/src/rpcblockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bb93e2cb5dfbcfa5e20c9771f9638364775d8357/src/rpcblockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcblockchain.cpp?ref=bb93e2cb5dfbcfa5e20c9771f9638364775d8357",
        "patch": "@@ -218,10 +218,9 @@ UniValue getrawmempool(const UniValue& params, bool fHelp)\n     {\n         LOCK(mempool.cs);\n         UniValue o(UniValue::VOBJ);\n-        BOOST_FOREACH(const PAIRTYPE(uint256, CTxMemPoolEntry)& entry, mempool.mapTx)\n+        BOOST_FOREACH(const CTxMemPoolEntry& e, mempool.mapTx)\n         {\n-            const uint256& hash = entry.first;\n-            const CTxMemPoolEntry& e = entry.second;\n+            const uint256& hash = e.GetTx().GetHash();\n             UniValue info(UniValue::VOBJ);\n             info.push_back(Pair(\"size\", (int)e.GetTxSize()));\n             info.push_back(Pair(\"fee\", ValueFromAmount(e.GetFee())));"
      },
      {
        "sha": "7f82a61bf30cf91bc78db3c26e4598996991a65e",
        "filename": "src/test/mempool_tests.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 0,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bb93e2cb5dfbcfa5e20c9771f9638364775d8357/src/test/mempool_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bb93e2cb5dfbcfa5e20c9771f9638364775d8357/src/test/mempool_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/mempool_tests.cpp?ref=bb93e2cb5dfbcfa5e20c9771f9638364775d8357",
        "patch": "@@ -100,4 +100,56 @@ BOOST_AUTO_TEST_CASE(MempoolRemoveTest)\n     removed.clear();\n }\n \n+BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n+{\n+    CTxMemPool pool(CFeeRate(0));\n+\n+    /* 3rd highest fee */\n+    CMutableTransaction tx1 = CMutableTransaction();\n+    tx1.vout.resize(1);\n+    tx1.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx1.vout[0].nValue = 10 * COIN;\n+    pool.addUnchecked(tx1.GetHash(), CTxMemPoolEntry(tx1, 10000LL, 0, 10.0, 1, true));\n+\n+    /* highest fee */\n+    CMutableTransaction tx2 = CMutableTransaction();\n+    tx2.vout.resize(1);\n+    tx2.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx2.vout[0].nValue = 2 * COIN;\n+    pool.addUnchecked(tx2.GetHash(), CTxMemPoolEntry(tx2, 20000LL, 0, 9.0, 1, true));\n+\n+    /* lowest fee */\n+    CMutableTransaction tx3 = CMutableTransaction();\n+    tx3.vout.resize(1);\n+    tx3.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx3.vout[0].nValue = 5 * COIN;\n+    pool.addUnchecked(tx3.GetHash(), CTxMemPoolEntry(tx3, 0LL, 0, 100.0, 1, true));\n+\n+    /* 2nd highest fee */\n+    CMutableTransaction tx4 = CMutableTransaction();\n+    tx4.vout.resize(1);\n+    tx4.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx4.vout[0].nValue = 6 * COIN;\n+    pool.addUnchecked(tx4.GetHash(), CTxMemPoolEntry(tx4, 15000LL, 0, 1.0, 1, true));\n+\n+    /* equal fee rate to tx1, but newer */\n+    CMutableTransaction tx5 = CMutableTransaction();\n+    tx5.vout.resize(1);\n+    tx5.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx5.vout[0].nValue = 11 * COIN;\n+    pool.addUnchecked(tx5.GetHash(), CTxMemPoolEntry(tx5, 10000LL, 1, 10.0, 1, true));\n+\n+    // there should be 4 transactions in the mempool\n+    BOOST_CHECK_EQUAL(pool.size(), 5);\n+\n+    // Check the fee-rate index is in order, should be tx2, tx4, tx1, tx5, tx3\n+    CTxMemPool::indexed_transaction_set::nth_index<1>::type::iterator it = pool.mapTx.get<1>().begin();\n+    BOOST_CHECK_EQUAL(it++->GetTx().GetHash().ToString(), tx2.GetHash().ToString());\n+    BOOST_CHECK_EQUAL(it++->GetTx().GetHash().ToString(), tx4.GetHash().ToString());\n+    BOOST_CHECK_EQUAL(it++->GetTx().GetHash().ToString(), tx1.GetHash().ToString());\n+    BOOST_CHECK_EQUAL(it++->GetTx().GetHash().ToString(), tx5.GetHash().ToString());\n+    BOOST_CHECK_EQUAL(it++->GetTx().GetHash().ToString(), tx3.GetHash().ToString());\n+    BOOST_CHECK(it == pool.mapTx.get<1>().end());\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "c410cd08323b2b28b7cc7b4c159af37896eebc19",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 24,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bb93e2cb5dfbcfa5e20c9771f9638364775d8357/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bb93e2cb5dfbcfa5e20c9771f9638364775d8357/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=bb93e2cb5dfbcfa5e20c9771f9638364775d8357",
        "patch": "@@ -32,6 +32,7 @@ CTxMemPoolEntry::CTxMemPoolEntry(const CTransaction& _tx, const CAmount& _nFee,\n     nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n     nModSize = tx.CalculateModifiedSize(nTxSize);\n     nUsageSize = RecursiveDynamicUsage(tx);\n+    feeRate = CFeeRate(nFee, nTxSize);\n }\n \n CTxMemPoolEntry::CTxMemPoolEntry(const CTxMemPoolEntry& other)\n@@ -96,8 +97,8 @@ bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry,\n     // Used by main.cpp AcceptToMemoryPool(), which DOES do\n     // all the appropriate checks.\n     LOCK(cs);\n-    mapTx[hash] = entry;\n-    const CTransaction& tx = mapTx[hash].GetTx();\n+    mapTx.insert(entry);\n+    const CTransaction& tx = mapTx.find(hash)->GetTx();\n     for (unsigned int i = 0; i < tx.vin.size(); i++)\n         mapNextTx[tx.vin[i].prevout] = CInPoint(&tx, i);\n     nTransactionsUpdated++;\n@@ -134,7 +135,7 @@ void CTxMemPool::remove(const CTransaction &origTx, std::list<CTransaction>& rem\n             txToRemove.pop_front();\n             if (!mapTx.count(hash))\n                 continue;\n-            const CTransaction& tx = mapTx[hash].GetTx();\n+            const CTransaction& tx = mapTx.find(hash)->GetTx();\n             if (fRecursive) {\n                 for (unsigned int i = 0; i < tx.vout.size(); i++) {\n                     std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(COutPoint(hash, i));\n@@ -147,8 +148,8 @@ void CTxMemPool::remove(const CTransaction &origTx, std::list<CTransaction>& rem\n                 mapNextTx.erase(txin.prevout);\n \n             removed.push_back(tx);\n-            totalTxSize -= mapTx[hash].GetTxSize();\n-            cachedInnerUsage -= mapTx[hash].DynamicMemoryUsage();\n+            totalTxSize -= mapTx.find(hash)->GetTxSize();\n+            cachedInnerUsage -= mapTx.find(hash)->DynamicMemoryUsage();\n             mapTx.erase(hash);\n             nTransactionsUpdated++;\n             minerPolicyEstimator->removeTx(hash);\n@@ -161,10 +162,10 @@ void CTxMemPool::removeCoinbaseSpends(const CCoinsViewCache *pcoins, unsigned in\n     // Remove transactions spending a coinbase which are now immature\n     LOCK(cs);\n     list<CTransaction> transactionsToRemove;\n-    for (std::map<uint256, CTxMemPoolEntry>::const_iterator it = mapTx.begin(); it != mapTx.end(); it++) {\n-        const CTransaction& tx = it->second.GetTx();\n+    for (indexed_transaction_set::const_iterator it = mapTx.begin(); it != mapTx.end(); it++) {\n+        const CTransaction& tx = it->GetTx();\n         BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n-            std::map<uint256, CTxMemPoolEntry>::const_iterator it2 = mapTx.find(txin.prevout.hash);\n+            indexed_transaction_set::const_iterator it2 = mapTx.find(txin.prevout.hash);\n             if (it2 != mapTx.end())\n                 continue;\n             const CCoins *coins = pcoins->AccessCoins(txin.prevout.hash);\n@@ -209,8 +210,10 @@ void CTxMemPool::removeForBlock(const std::vector<CTransaction>& vtx, unsigned i\n     BOOST_FOREACH(const CTransaction& tx, vtx)\n     {\n         uint256 hash = tx.GetHash();\n-        if (mapTx.count(hash))\n-            entries.push_back(mapTx[hash]);\n+\n+        indexed_transaction_set::iterator i = mapTx.find(hash);\n+        if (i != mapTx.end())\n+            entries.push_back(*i);\n     }\n     BOOST_FOREACH(const CTransaction& tx, vtx)\n     {\n@@ -247,17 +250,17 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n \n     LOCK(cs);\n     list<const CTxMemPoolEntry*> waitingOnDependants;\n-    for (std::map<uint256, CTxMemPoolEntry>::const_iterator it = mapTx.begin(); it != mapTx.end(); it++) {\n+    for (indexed_transaction_set::const_iterator it = mapTx.begin(); it != mapTx.end(); it++) {\n         unsigned int i = 0;\n-        checkTotal += it->second.GetTxSize();\n-        innerUsage += it->second.DynamicMemoryUsage();\n-        const CTransaction& tx = it->second.GetTx();\n+        checkTotal += it->GetTxSize();\n+        innerUsage += it->DynamicMemoryUsage();\n+        const CTransaction& tx = it->GetTx();\n         bool fDependsWait = false;\n         BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n             // Check that every mempool transaction's inputs refer to available coins, or other mempool tx's.\n-            std::map<uint256, CTxMemPoolEntry>::const_iterator it2 = mapTx.find(txin.prevout.hash);\n+            indexed_transaction_set::const_iterator it2 = mapTx.find(txin.prevout.hash);\n             if (it2 != mapTx.end()) {\n-                const CTransaction& tx2 = it2->second.GetTx();\n+                const CTransaction& tx2 = it2->GetTx();\n                 assert(tx2.vout.size() > txin.prevout.n && !tx2.vout[txin.prevout.n].IsNull());\n                 fDependsWait = true;\n             } else {\n@@ -272,7 +275,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n             i++;\n         }\n         if (fDependsWait)\n-            waitingOnDependants.push_back(&it->second);\n+            waitingOnDependants.push_back(&(*it));\n         else {\n             CValidationState state;\n             assert(CheckInputs(tx, state, mempoolDuplicate, false, 0, false, NULL));\n@@ -296,8 +299,8 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n     }\n     for (std::map<COutPoint, CInPoint>::const_iterator it = mapNextTx.begin(); it != mapNextTx.end(); it++) {\n         uint256 hash = it->second.ptx->GetHash();\n-        map<uint256, CTxMemPoolEntry>::const_iterator it2 = mapTx.find(hash);\n-        const CTransaction& tx = it2->second.GetTx();\n+        indexed_transaction_set::const_iterator it2 = mapTx.find(hash);\n+        const CTransaction& tx = it2->GetTx();\n         assert(it2 != mapTx.end());\n         assert(&tx == it->second.ptx);\n         assert(tx.vin.size() > it->second.n);\n@@ -314,16 +317,16 @@ void CTxMemPool::queryHashes(vector<uint256>& vtxid)\n \n     LOCK(cs);\n     vtxid.reserve(mapTx.size());\n-    for (map<uint256, CTxMemPoolEntry>::iterator mi = mapTx.begin(); mi != mapTx.end(); ++mi)\n-        vtxid.push_back((*mi).first);\n+    for (indexed_transaction_set::iterator mi = mapTx.begin(); mi != mapTx.end(); ++mi)\n+        vtxid.push_back(mi->GetTx().GetHash());\n }\n \n bool CTxMemPool::lookup(uint256 hash, CTransaction& result) const\n {\n     LOCK(cs);\n-    map<uint256, CTxMemPoolEntry>::const_iterator i = mapTx.find(hash);\n+    indexed_transaction_set::const_iterator i = mapTx.find(hash);\n     if (i == mapTx.end()) return false;\n-    result = i->second.GetTx();\n+    result = i->GetTx();\n     return true;\n }\n \n@@ -429,5 +432,6 @@ bool CCoinsViewMemPool::HaveCoins(const uint256 &txid) const {\n \n size_t CTxMemPool::DynamicMemoryUsage() const {\n     LOCK(cs);\n-    return memusage::DynamicUsage(mapTx) + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + cachedInnerUsage;\n+    // Estimate the overhead of mapTx to be 6 pointers + an allocation, as no exact formula for boost::multi_index_contained is implemented.\n+    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 6 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + cachedInnerUsage;\n }"
      },
      {
        "sha": "6b6b05454a4eee3fd1dda5bc13993c5f3a2578bc",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 41,
        "deletions": 1,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bb93e2cb5dfbcfa5e20c9771f9638364775d8357/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bb93e2cb5dfbcfa5e20c9771f9638364775d8357/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=bb93e2cb5dfbcfa5e20c9771f9638364775d8357",
        "patch": "@@ -13,6 +13,10 @@\n #include \"primitives/transaction.h\"\n #include \"sync.h\"\n \n+#undef foreach\n+#include \"boost/multi_index_container.hpp\"\n+#include \"boost/multi_index/ordered_index.hpp\"\n+\n class CAutoFile;\n \n inline double AllowFreeThreshold()\n@@ -41,6 +45,7 @@ class CTxMemPoolEntry\n     size_t nTxSize; //! ... and avoid recomputing tx size\n     size_t nModSize; //! ... and modified size for priority\n     size_t nUsageSize; //! ... and total memory usage\n+    CFeeRate feeRate; //! ... and fee per kB\n     int64_t nTime; //! Local time when entering the mempool\n     double dPriority; //! Priority when entering the mempool\n     unsigned int nHeight; //! Chain height when entering the mempool\n@@ -55,13 +60,35 @@ class CTxMemPoolEntry\n     const CTransaction& GetTx() const { return this->tx; }\n     double GetPriority(unsigned int currentHeight) const;\n     CAmount GetFee() const { return nFee; }\n+    CFeeRate GetFeeRate() const { return feeRate; }\n     size_t GetTxSize() const { return nTxSize; }\n     int64_t GetTime() const { return nTime; }\n     unsigned int GetHeight() const { return nHeight; }\n     bool WasClearAtEntry() const { return hadNoDependencies; }\n     size_t DynamicMemoryUsage() const { return nUsageSize; }\n };\n \n+// extracts a TxMemPoolEntry's transaction hash\n+struct mempoolentry_txid\n+{\n+    typedef uint256 result_type;\n+    result_type operator() (const CTxMemPoolEntry &entry) const\n+    {\n+        return entry.GetTx().GetHash();\n+    }\n+};\n+\n+class CompareTxMemPoolEntryByFee\n+{\n+public:\n+    bool operator()(const CTxMemPoolEntry& a, const CTxMemPoolEntry& b)\n+    {\n+        if (a.GetFeeRate() == b.GetFeeRate())\n+            return a.GetTime() < b.GetTime();\n+        return a.GetFeeRate() > b.GetFeeRate();\n+    }\n+};\n+\n class CBlockPolicyEstimator;\n \n /** An inpoint - a combination of a transaction and an index n into its vin */\n@@ -99,8 +126,21 @@ class CTxMemPool\n     uint64_t cachedInnerUsage; //! sum of dynamic memory usage of all the map elements (NOT the maps themselves)\n \n public:\n+    typedef boost::multi_index_container<\n+        CTxMemPoolEntry,\n+        boost::multi_index::indexed_by<\n+            // sorted by txid\n+            boost::multi_index::ordered_unique<mempoolentry_txid>,\n+            // sorted by fee rate\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::identity<CTxMemPoolEntry>,\n+                CompareTxMemPoolEntryByFee\n+            >\n+        >\n+    > indexed_transaction_set;\n+\n     mutable CCriticalSection cs;\n-    std::map<uint256, CTxMemPoolEntry> mapTx;\n+    indexed_transaction_set mapTx;\n     std::map<COutPoint, CInPoint> mapNextTx;\n     std::map<uint256, std::pair<double, CAmount> > mapDeltas;\n "
      }
    ]
  },
  {
    "sha": "5b6c1c25a56ca9211b13de0e09144765821c7545",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1YjZjMWMyNWE1NmNhOTIxMWIxM2RlMGUwOTE0NDc2NTgyMWM3NTQ1",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-07-15T18:47:45Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-09-09T12:41:03Z"
      },
      "message": "Track transaction packages in CTxMemPoolEntry\n\nAssociate with each CTxMemPoolEntry all the size/fees of descendant\nmempool transactions.  Sort mempool by max(feerate of entry, feerate\nof descendants).  Update statistics on-the-fly as transactions enter\nor leave the mempool.\n\nAlso add ancestor and descendant limiting, so that transactions can\nbe rejected if the number or size of unconfirmed ancestors exceeds\na target, or if adding a transaction would cause some other mempool\nentry to have too many (or too large) a set of unconfirmed in-\nmempool descendants.",
      "tree": {
        "sha": "77d47c839a1a8c0b8df14bbb70d0cd479bec32e5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/77d47c839a1a8c0b8df14bbb70d0cd479bec32e5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5b6c1c25a56ca9211b13de0e09144765821c7545",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5b6c1c25a56ca9211b13de0e09144765821c7545",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5b6c1c25a56ca9211b13de0e09144765821c7545",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5b6c1c25a56ca9211b13de0e09144765821c7545/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bb93e2cb5dfbcfa5e20c9771f9638364775d8357",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bb93e2cb5dfbcfa5e20c9771f9638364775d8357",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bb93e2cb5dfbcfa5e20c9771f9638364775d8357"
      }
    ],
    "stats": {
      "total": 855,
      "additions": 800,
      "deletions": 55
    },
    "files": [
      {
        "sha": "f5c9e9dff049ddc633015ca3b339e3c090b61dba",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5b6c1c25a56ca9211b13de0e09144765821c7545/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5b6c1c25a56ca9211b13de0e09144765821c7545/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=5b6c1c25a56ca9211b13de0e09144765821c7545",
        "patch": "@@ -288,6 +288,10 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-dbcache=<n>\", strprintf(_(\"Set database cache size in megabytes (%d to %d, default: %d)\"), nMinDbCache, nMaxDbCache, nDefaultDbCache));\n     strUsage += HelpMessageOpt(\"-loadblock=<file>\", _(\"Imports blocks from external blk000??.dat file\") + \" \" + _(\"on startup\"));\n     strUsage += HelpMessageOpt(\"-maxorphantx=<n>\", strprintf(_(\"Keep at most <n> unconnectable transactions in memory (default: %u)\"), DEFAULT_MAX_ORPHAN_TRANSACTIONS));\n+    strUsage += HelpMessageOpt(\"-limitancestorcount=<n>\", strprintf(_(\"Do not accept transactions if number of in-mempool ancestors is <n> or more (default: %u)\"), DEFAULT_ANCESTOR_LIMIT));\n+    strUsage += HelpMessageOpt(\"-limitancestorsize=<n>\", strprintf(_(\"Do not accept transactions whose size with all in-mempool ancestors exceeds <n> kilobytes (default: %u)\"), DEFAULT_ANCESTOR_SIZE_LIMIT));\n+    strUsage += HelpMessageOpt(\"-limitdescendantcount=<n>\", strprintf(_(\"Do not accept transactions if any ancestor would have <n> or more in-mempool descendants (default: %u)\"), DEFAULT_DESCENDANT_LIMIT));\n+    strUsage += HelpMessageOpt(\"-limitdescendantsize=<n>\", strprintf(\"Do not accept transactions if any ancestor would have more than <n> kilobytes of in-mempool descendants (default: %u).\", DEFAULT_DESCENDANT_SIZE_LIMIT));\n     strUsage += HelpMessageOpt(\"-par=<n>\", strprintf(_(\"Set the number of script verification threads (%u to %d, 0 = auto, <0 = leave that many cores free, default: %d)\"),\n         -GetNumCores(), MAX_SCRIPTCHECK_THREADS, DEFAULT_SCRIPTCHECK_THREADS));\n #ifndef WIN32"
      },
      {
        "sha": "c8b3f3b9f7f02eabd8263f51268ed38d60113f3b",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 2,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5b6c1c25a56ca9211b13de0e09144765821c7545/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5b6c1c25a56ca9211b13de0e09144765821c7545/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=5b6c1c25a56ca9211b13de0e09144765821c7545",
        "patch": "@@ -921,6 +921,17 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n                 REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, ::minRelayTxFee.GetFee(nSize) * 10000));\n \n+        // Calculate in-mempool ancestors, up to a limit.\n+        CTxMemPool::setEntries setAncestors;\n+        size_t nLimitAncestors = GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        size_t nLimitAncestorSize = GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n+        size_t nLimitDescendants = GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        size_t nLimitDescendantSize = GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n+        std::string errString;\n+        if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n+            return state.DoS(0, false, REJECT_LONGCHAIN, \"too-long-mempool-chain\", false, errString);\n+        }\n+\n         // Check against previous transactions\n         // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n         if (!CheckInputs(tx, state, view, true, STANDARD_SCRIPT_VERIFY_FLAGS, true))\n@@ -942,7 +953,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         }\n \n         // Store transaction in memory\n-        pool.addUnchecked(hash, entry, !IsInitialBlockDownload());\n+        pool.addUnchecked(hash, entry, setAncestors, !IsInitialBlockDownload());\n     }\n \n     SyncWithWallets(tx, NULL);\n@@ -2033,13 +2044,23 @@ bool static DisconnectTip(CValidationState &state) {\n     if (!FlushStateToDisk(state, FLUSH_STATE_IF_NEEDED))\n         return false;\n     // Resurrect mempool transactions from the disconnected block.\n+    std::vector<uint256> vHashUpdate;\n     BOOST_FOREACH(const CTransaction &tx, block.vtx) {\n         // ignore validation errors in resurrected transactions\n         list<CTransaction> removed;\n         CValidationState stateDummy;\n-        if (tx.IsCoinBase() || !AcceptToMemoryPool(mempool, stateDummy, tx, false, NULL))\n+        if (tx.IsCoinBase() || !AcceptToMemoryPool(mempool, stateDummy, tx, false, NULL)) {\n             mempool.remove(tx, removed, true);\n+        } else if (mempool.mapTx.count(tx.GetHash())) {\n+            vHashUpdate.push_back(tx.GetHash());\n+        }\n     }\n+    // AcceptToMemoryPool/addUnchecked all assume that new mempool entries have\n+    // no in-mempool children, which is generally not true when adding\n+    // previously-confirmed transactions back to the mempool.\n+    // UpdateTransactionsFromBlock finds descendants of any transactions in this\n+    // block that were added back and cleans up the mempool state.\n+    mempool.UpdateTransactionsFromBlock(vHashUpdate);\n     mempool.removeCoinbaseSpends(pcoinsTip, pindexDelete->nHeight);\n     mempool.check(pcoinsTip);\n     // Update chainActive and related variables."
      },
      {
        "sha": "d8914963b4e49f5309e4101f20c049c5e4201f9c",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5b6c1c25a56ca9211b13de0e09144765821c7545/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5b6c1c25a56ca9211b13de0e09144765821c7545/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=5b6c1c25a56ca9211b13de0e09144765821c7545",
        "patch": "@@ -43,6 +43,14 @@ struct CNodeStateStats;\n static const bool DEFAULT_ALERTS = true;\n /** Default for -maxorphantx, maximum number of orphan transactions kept in memory */\n static const unsigned int DEFAULT_MAX_ORPHAN_TRANSACTIONS = 100;\n+/** Default for -limitancestorcount, max number of in-mempool ancestors */\n+static const unsigned int DEFAULT_ANCESTOR_LIMIT = 100;\n+/** Default for -limitancestorsize, maximum kilobytes of tx + all in-mempool ancestors */\n+static const unsigned int DEFAULT_ANCESTOR_SIZE_LIMIT = 1000;\n+/** Default for -limitdescendantcount, max number of in-mempool descendants */\n+static const unsigned int DEFAULT_DESCENDANT_LIMIT = 1000;\n+/** Default for -limitdescendantsize, maximum kilobytes of in-mempool descendants */\n+static const unsigned int DEFAULT_DESCENDANT_SIZE_LIMIT = 2500;\n /** The maximum size of a blk?????.dat file (since 0.8) */\n static const unsigned int MAX_BLOCKFILE_SIZE = 0x8000000; // 128 MiB\n /** The pre-allocation chunk size for blk?????.dat files (since 0.8) */\n@@ -466,5 +474,7 @@ static const unsigned int REJECT_HIGHFEE = 0x100;\n static const unsigned int REJECT_ALREADY_KNOWN = 0x101;\n /** Transaction conflicts with a transaction already known */\n static const unsigned int REJECT_CONFLICT = 0x102;\n+/** Transaction would result in too long in-mempool chain */\n+static const unsigned int REJECT_LONGCHAIN = 0x103;\n \n #endif // BITCOIN_MAIN_H"
      },
      {
        "sha": "b475c3313b20004b4403604b58d77caec3e1c1fb",
        "filename": "src/memusage.h",
        "status": "modified",
        "additions": 15,
        "deletions": 3,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5b6c1c25a56ca9211b13de0e09144765821c7545/src/memusage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5b6c1c25a56ca9211b13de0e09144765821c7545/src/memusage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/memusage.h?ref=5b6c1c25a56ca9211b13de0e09144765821c7545",
        "patch": "@@ -74,18 +74,30 @@ static inline size_t DynamicUsage(const std::vector<X>& v)\n     return MallocUsage(v.capacity() * sizeof(X));\n }\n \n-template<typename X>\n-static inline size_t DynamicUsage(const std::set<X>& s)\n+template<typename X, typename Y>\n+static inline size_t DynamicUsage(const std::set<X, Y>& s)\n {\n     return MallocUsage(sizeof(stl_tree_node<X>)) * s.size();\n }\n \n template<typename X, typename Y>\n-static inline size_t DynamicUsage(const std::map<X, Y>& m)\n+static inline size_t IncrementalDynamicUsage(const std::set<X, Y>& s)\n+{\n+    return MallocUsage(sizeof(stl_tree_node<X>));\n+}\n+\n+template<typename X, typename Y, typename Z>\n+static inline size_t DynamicUsage(const std::map<X, Y, Z>& m)\n {\n     return MallocUsage(sizeof(stl_tree_node<std::pair<const X, Y> >)) * m.size();\n }\n \n+template<typename X, typename Y, typename Z>\n+static inline size_t IncrementalDynamicUsage(const std::map<X, Y, Z>& m)\n+{\n+    return MallocUsage(sizeof(stl_tree_node<std::pair<const X, Y> >));\n+}\n+\n // Boost data structures\n \n template<typename X>"
      },
      {
        "sha": "fee9e2ecbddbb1d328ac110767ca99b18bc6fe10",
        "filename": "src/test/mempool_tests.cpp",
        "status": "modified",
        "additions": 154,
        "deletions": 10,
        "changes": 164,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5b6c1c25a56ca9211b13de0e09144765821c7545/src/test/mempool_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5b6c1c25a56ca9211b13de0e09144765821c7545/src/test/mempool_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/mempool_tests.cpp?ref=5b6c1c25a56ca9211b13de0e09144765821c7545",
        "patch": "@@ -9,6 +9,7 @@\n \n #include <boost/test/unit_test.hpp>\n #include <list>\n+#include <vector>\n \n BOOST_FIXTURE_TEST_SUITE(mempool_tests, TestingSetup)\n \n@@ -100,6 +101,31 @@ BOOST_AUTO_TEST_CASE(MempoolRemoveTest)\n     removed.clear();\n }\n \n+void CheckSort(CTxMemPool &pool, std::vector<std::string> &sortedOrder)\n+{\n+    BOOST_CHECK_EQUAL(pool.size(), sortedOrder.size());\n+    CTxMemPool::indexed_transaction_set::nth_index<1>::type::iterator it = pool.mapTx.get<1>().begin();\n+    int count=0;\n+    for (; it != pool.mapTx.get<1>().end(); ++it, ++count) {\n+        BOOST_CHECK_EQUAL(it->GetTx().GetHash().ToString(), sortedOrder[count]);\n+    }\n+}\n+\n+template<typename X, typename Y>\n+bool CompareSet(const std::set<X, Y> &a, const std::set<X, Y> &b)\n+{\n+    if (a.size() != b.size()) {\n+        return false;\n+    }\n+    typename std::set<X, Y>::const_iterator ait = a.begin(), bit = b.begin();\n+    while (ait != a.end() && bit != b.end()) {\n+        if (*ait != *bit) return false;\n+        ait++;\n+        bit++;\n+    }\n+    return true;\n+}\n+\n BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n {\n     CTxMemPool pool(CFeeRate(0));\n@@ -138,18 +164,136 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n     tx5.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx5.vout[0].nValue = 11 * COIN;\n     pool.addUnchecked(tx5.GetHash(), CTxMemPoolEntry(tx5, 10000LL, 1, 10.0, 1, true));\n-\n-    // there should be 4 transactions in the mempool\n     BOOST_CHECK_EQUAL(pool.size(), 5);\n \n-    // Check the fee-rate index is in order, should be tx2, tx4, tx1, tx5, tx3\n-    CTxMemPool::indexed_transaction_set::nth_index<1>::type::iterator it = pool.mapTx.get<1>().begin();\n-    BOOST_CHECK_EQUAL(it++->GetTx().GetHash().ToString(), tx2.GetHash().ToString());\n-    BOOST_CHECK_EQUAL(it++->GetTx().GetHash().ToString(), tx4.GetHash().ToString());\n-    BOOST_CHECK_EQUAL(it++->GetTx().GetHash().ToString(), tx1.GetHash().ToString());\n-    BOOST_CHECK_EQUAL(it++->GetTx().GetHash().ToString(), tx5.GetHash().ToString());\n-    BOOST_CHECK_EQUAL(it++->GetTx().GetHash().ToString(), tx3.GetHash().ToString());\n-    BOOST_CHECK(it == pool.mapTx.get<1>().end());\n+    std::vector<std::string> sortedOrder;\n+    sortedOrder.resize(5);\n+    sortedOrder[0] = tx2.GetHash().ToString(); // 20000\n+    sortedOrder[1] = tx4.GetHash().ToString(); // 15000\n+    sortedOrder[2] = tx1.GetHash().ToString(); // 10000\n+    sortedOrder[3] = tx5.GetHash().ToString(); // 10000\n+    sortedOrder[4] = tx3.GetHash().ToString(); // 0\n+    CheckSort(pool, sortedOrder);\n+\n+    /* low fee but with high fee child */\n+    /* tx6 -> tx7 -> tx8, tx9 -> tx10 */\n+    CMutableTransaction tx6 = CMutableTransaction();\n+    tx6.vout.resize(1);\n+    tx6.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx6.vout[0].nValue = 20 * COIN;\n+    pool.addUnchecked(tx6.GetHash(), CTxMemPoolEntry(tx6, 0LL, 1, 10.0, 1, true));\n+    BOOST_CHECK_EQUAL(pool.size(), 6);\n+    // Check that at this point, tx6 is sorted low\n+    sortedOrder.push_back(tx6.GetHash().ToString());\n+    CheckSort(pool, sortedOrder);\n+\n+    CTxMemPool::setEntries setAncestors;\n+    setAncestors.insert(pool.mapTx.find(tx6.GetHash()));\n+    CMutableTransaction tx7 = CMutableTransaction();\n+    tx7.vin.resize(1);\n+    tx7.vin[0].prevout = COutPoint(tx6.GetHash(), 0);\n+    tx7.vin[0].scriptSig = CScript() << OP_11;\n+    tx7.vout.resize(2);\n+    tx7.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx7.vout[0].nValue = 10 * COIN;\n+    tx7.vout[1].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx7.vout[1].nValue = 1 * COIN;\n+\n+    CTxMemPool::setEntries setAncestorsCalculated;\n+    std::string dummy;\n+    CTxMemPoolEntry entry7(tx7, 2000000LL, 1, 10.0, 1, true);\n+    BOOST_CHECK_EQUAL(pool.CalculateMemPoolAncestors(entry7, setAncestorsCalculated, 100, 1000000, 1000, 1000000, dummy), true);\n+    BOOST_CHECK(CompareSet(setAncestorsCalculated, setAncestors));\n+\n+    pool.addUnchecked(tx7.GetHash(), CTxMemPoolEntry(tx7, 2000000LL, 1, 10.0, 1, true), setAncestors);\n+    BOOST_CHECK_EQUAL(pool.size(), 7);\n+\n+    // Now tx6 should be sorted higher (high fee child): tx7, tx6, tx2, ...\n+    sortedOrder.erase(sortedOrder.end()-1);\n+    sortedOrder.insert(sortedOrder.begin(), tx6.GetHash().ToString());\n+    sortedOrder.insert(sortedOrder.begin(), tx7.GetHash().ToString());\n+    CheckSort(pool, sortedOrder);\n+\n+    /* low fee child of tx7 */\n+    CMutableTransaction tx8 = CMutableTransaction();\n+    tx8.vin.resize(1);\n+    tx8.vin[0].prevout = COutPoint(tx7.GetHash(), 0);\n+    tx8.vin[0].scriptSig = CScript() << OP_11;\n+    tx8.vout.resize(1);\n+    tx8.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx8.vout[0].nValue = 10 * COIN;\n+    setAncestors.insert(pool.mapTx.find(tx7.GetHash()));\n+    pool.addUnchecked(tx8.GetHash(), CTxMemPoolEntry(tx8, 0LL, 2, 10.0, 1, true), setAncestors);\n+\n+    // Now tx8 should be sorted low, but tx6/tx both high\n+    sortedOrder.push_back(tx8.GetHash().ToString());\n+    CheckSort(pool, sortedOrder);\n+\n+    /* low fee child of tx7 */\n+    CMutableTransaction tx9 = CMutableTransaction();\n+    tx9.vin.resize(1);\n+    tx9.vin[0].prevout = COutPoint(tx7.GetHash(), 1);\n+    tx9.vin[0].scriptSig = CScript() << OP_11;\n+    tx9.vout.resize(1);\n+    tx9.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx9.vout[0].nValue = 1 * COIN;\n+    pool.addUnchecked(tx9.GetHash(), CTxMemPoolEntry(tx9, 0LL, 3, 10.0, 1, true), setAncestors);\n+\n+    // tx9 should be sorted low\n+    BOOST_CHECK_EQUAL(pool.size(), 9);\n+    sortedOrder.push_back(tx9.GetHash().ToString());\n+    CheckSort(pool, sortedOrder);\n+\n+    std::vector<std::string> snapshotOrder = sortedOrder;\n+\n+    setAncestors.insert(pool.mapTx.find(tx8.GetHash()));\n+    setAncestors.insert(pool.mapTx.find(tx9.GetHash()));\n+    /* tx10 depends on tx8 and tx9 and has a high fee*/\n+    CMutableTransaction tx10 = CMutableTransaction();\n+    tx10.vin.resize(2);\n+    tx10.vin[0].prevout = COutPoint(tx8.GetHash(), 0);\n+    tx10.vin[0].scriptSig = CScript() << OP_11;\n+    tx10.vin[1].prevout = COutPoint(tx9.GetHash(), 0);\n+    tx10.vin[1].scriptSig = CScript() << OP_11;\n+    tx10.vout.resize(1);\n+    tx10.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+    tx10.vout[0].nValue = 10 * COIN;\n+\n+    setAncestorsCalculated.clear();\n+    CTxMemPoolEntry entry10(tx10, 200000LL, 4, 10.0, 1, true);\n+    BOOST_CHECK_EQUAL(pool.CalculateMemPoolAncestors(entry10, setAncestorsCalculated, 100, 1000000, 1000, 1000000, dummy), true);\n+    BOOST_CHECK(CompareSet(setAncestorsCalculated, setAncestors));\n+\n+    pool.addUnchecked(tx10.GetHash(), CTxMemPoolEntry(tx10, 200000LL, 4, 10.0, 1, true), setAncestors);\n+\n+    /**\n+     *  tx8 and tx9 should both now be sorted higher\n+     *  Final order after tx10 is added:\n+     *\n+     *  tx7 = 2.2M (4 txs)\n+     *  tx6 = 2.2M (5 txs)\n+     *  tx10 = 200k (1 tx)\n+     *  tx8 = 200k (2 txs)\n+     *  tx9 = 200k (2 txs)\n+     *  tx2 = 20000 (1)\n+     *  tx4 = 15000 (1)\n+     *  tx1 = 10000 (1)\n+     *  tx5 = 10000 (1)\n+     *  tx3 = 0 (1)\n+     */\n+    sortedOrder.erase(sortedOrder.end()-2, sortedOrder.end()); // take out tx8, tx9 from the end\n+    sortedOrder.insert(sortedOrder.begin()+2, tx10.GetHash().ToString()); // tx10 is after tx6\n+    sortedOrder.insert(sortedOrder.begin()+3, tx9.GetHash().ToString());\n+    sortedOrder.insert(sortedOrder.begin()+3, tx8.GetHash().ToString());\n+    CheckSort(pool, sortedOrder);\n+\n+    // there should be 10 transactions in the mempool\n+    BOOST_CHECK_EQUAL(pool.size(), 10);\n+\n+    // Now try removing tx10 and verify the sort order returns to normal\n+    std::list<CTransaction> removed;\n+    pool.remove(pool.mapTx.find(tx10.GetHash())->GetTx(), removed, true);\n+    CheckSort(pool, snapshotOrder);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "2a36ecdc3aa1a6e32c120e4ff62e3d371b3d930c",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 420,
        "deletions": 38,
        "changes": 458,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5b6c1c25a56ca9211b13de0e09144765821c7545/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5b6c1c25a56ca9211b13de0e09144765821c7545/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=5b6c1c25a56ca9211b13de0e09144765821c7545",
        "patch": "@@ -18,7 +18,8 @@\n using namespace std;\n \n CTxMemPoolEntry::CTxMemPoolEntry():\n-    nFee(0), nTxSize(0), nModSize(0), nUsageSize(0), nTime(0), dPriority(0.0), hadNoDependencies(false)\n+    nFee(0), nTxSize(0), nModSize(0), nUsageSize(0), nTime(0), dPriority(0.0), hadNoDependencies(false),\n+    nCountWithDescendants(0), nSizeWithDescendants(0), nFeesWithDescendants(0)\n {\n     nHeight = MEMPOOL_HEIGHT;\n }\n@@ -32,7 +33,10 @@ CTxMemPoolEntry::CTxMemPoolEntry(const CTransaction& _tx, const CAmount& _nFee,\n     nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n     nModSize = tx.CalculateModifiedSize(nTxSize);\n     nUsageSize = RecursiveDynamicUsage(tx);\n-    feeRate = CFeeRate(nFee, nTxSize);\n+\n+    nCountWithDescendants = 1;\n+    nSizeWithDescendants = nTxSize;\n+    nFeesWithDescendants = nFee;\n }\n \n CTxMemPoolEntry::CTxMemPoolEntry(const CTxMemPoolEntry& other)\n@@ -49,6 +53,246 @@ CTxMemPoolEntry::GetPriority(unsigned int currentHeight) const\n     return dResult;\n }\n \n+// Update the given tx for any in-mempool descendants.\n+// Assumes that setMemPoolChildren is correct for the given tx and all\n+// descendants.\n+bool CTxMemPool::UpdateForDescendants(txiter updateIt, int maxDescendantsToVisit, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+{\n+    // Track the number of entries (outside setExclude) that we'd need to visit\n+    // (will bail out if it exceeds maxDescendantsToVisit)\n+    int nChildrenToVisit = 0; \n+\n+    setEntries stageEntries, setAllDescendants;\n+    stageEntries = GetMemPoolChildren(updateIt);\n+\n+    while (!stageEntries.empty()) {\n+        setAllDescendants.insert(stageEntries.begin(), stageEntries.end());\n+\n+        setEntries entriesToAdd;\n+        BOOST_FOREACH(const txiter cit, stageEntries) {\n+            if (cit->IsDirty()) {\n+                // Don't consider any more children if any descendant is dirty\n+                return false;\n+            }\n+            const setEntries &setChildren = GetMemPoolChildren(cit);\n+            BOOST_FOREACH(const txiter childEntry, setChildren) {\n+                cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n+                if (cacheIt != cachedDescendants.end()) {\n+                    // We've already calculated this one, just add the entries for this set\n+                    // but don't traverse again.\n+                    BOOST_FOREACH(const txiter cacheEntry, cacheIt->second) {\n+                        // update visit count only for new child transactions\n+                        // (outside of setExclude and entriesToAdd)\n+                        if (setAllDescendants.insert(cacheEntry).second &&\n+                                !setExclude.count(cacheEntry->GetTx().GetHash()) &&\n+                                !entriesToAdd.count(cacheEntry)) {\n+                            nChildrenToVisit++;\n+                        }\n+                    }\n+                } else if (!setAllDescendants.count(childEntry)) {\n+                    // Try adding to entriesToAdd, and update our visit count\n+                    if (entriesToAdd.insert(childEntry).second && !setExclude.count(childEntry->GetTx().GetHash())) {\n+                        nChildrenToVisit++;\n+                    }\n+                }\n+                if (nChildrenToVisit > maxDescendantsToVisit) {\n+                    return false;\n+                }\n+            }\n+        }\n+        stageEntries = entriesToAdd;\n+    }\n+    // setAllDescendants now contains all in-mempool descendants of updateIt.\n+    // Update and add to cached descendant map\n+    int64_t modifySize = 0;\n+    CAmount modifyFee = 0;\n+    int64_t modifyCount = 0;\n+    BOOST_FOREACH(txiter cit, setAllDescendants) {\n+        if (!setExclude.count(cit->GetTx().GetHash())) {\n+            modifySize += cit->GetTxSize();\n+            modifyFee += cit->GetFee();\n+            modifyCount++;\n+            cachedDescendants[updateIt].insert(cit);\n+        }\n+    }\n+    mapTx.modify(updateIt, update_descendant_state(modifySize, modifyFee, modifyCount));\n+    return true;\n+}\n+\n+// vHashesToUpdate is the set of transaction hashes from a disconnected block\n+// which has been re-added to the mempool.\n+// for each entry, look for descendants that are outside hashesToUpdate, and\n+// add fee/size information for such descendants to the parent.\n+void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<uint256> &vHashesToUpdate)\n+{\n+    // For each entry in vHashesToUpdate, store the set of in-mempool, but not\n+    // in-vHashesToUpdate transactions, so that we don't have to recalculate\n+    // descendants when we come across a previously seen entry.\n+    cacheMap mapMemPoolDescendantsToUpdate;\n+\n+    // Use a set for lookups into vHashesToUpdate (these entries are already\n+    // accounted for in the state of their ancestors)\n+    std::set<uint256> setAlreadyIncluded(vHashesToUpdate.begin(), vHashesToUpdate.end());\n+\n+    // Iterate in reverse, so that whenever we are looking at at a transaction\n+    // we are sure that all in-mempool descendants have already been processed.\n+    // This maximizes the benefit of the descendant cache and guarantees that\n+    // setMemPoolChildren will be updated, an assumption made in\n+    // UpdateForDescendants.\n+    BOOST_REVERSE_FOREACH(const uint256 &hash, vHashesToUpdate) {\n+        // we cache the in-mempool children to avoid duplicate updates\n+        setEntries setChildren;\n+        // calculate children from mapNextTx\n+        txiter it = mapTx.find(hash);\n+        if (it == mapTx.end()) {\n+            continue;\n+        }\n+        std::map<COutPoint, CInPoint>::iterator iter = mapNextTx.lower_bound(COutPoint(hash, 0));\n+        // First calculate the children, and update setMemPoolChildren to\n+        // include them, and update their setMemPoolParents to include this tx.\n+        for (; iter != mapNextTx.end() && iter->first.hash == hash; ++iter) {\n+            const uint256 &childHash = iter->second.ptx->GetHash();\n+            txiter childIter = mapTx.find(childHash);\n+            // We can skip updating entries we've encountered before or that\n+            // are in the block (which are already accounted for).\n+            if (setChildren.insert(childIter).second && !setAlreadyIncluded.count(childHash)) {\n+                UpdateChild(it, childIter, true);\n+                UpdateParent(childIter, it, true);\n+            }\n+        }\n+        if (!UpdateForDescendants(it, 100, mapMemPoolDescendantsToUpdate, setAlreadyIncluded)) {\n+            // Mark as dirty if we can't do the calculation.\n+            mapTx.modify(it, set_dirty());\n+        }\n+    }\n+}\n+\n+bool CTxMemPool::CalculateMemPoolAncestors(const CTxMemPoolEntry &entry, setEntries &setAncestors, uint64_t limitAncestorCount, uint64_t limitAncestorSize, uint64_t limitDescendantCount, uint64_t limitDescendantSize, std::string &errString)\n+{\n+    setEntries parentHashes;\n+    const CTransaction &tx = entry.GetTx();\n+\n+    // Get parents of this transaction that are in the mempool\n+    // entry may or may not already be in the mempool, so we iterate mapTx\n+    // to find parents, rather than try GetMemPoolParents(entry)\n+    // TODO: optimize this so that we only check limits and walk\n+    // tx.vin when called on entries not already in the mempool.\n+    for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+        txiter piter = mapTx.find(tx.vin[i].prevout.hash);\n+        if (piter != mapTx.end()) {\n+            parentHashes.insert(piter);\n+            if (parentHashes.size() + 1 > limitAncestorCount) {\n+                errString = strprintf(\"too many unconfirmed parents [limit: %u]\", limitAncestorCount);\n+                return false;\n+            }\n+        }\n+    }\n+\n+    size_t totalSizeWithAncestors = entry.GetTxSize();\n+\n+    while (!parentHashes.empty()) {\n+        setAncestors.insert(parentHashes.begin(), parentHashes.end());\n+        setEntries stageParentSet; \n+        BOOST_FOREACH(const txiter &stageit, parentHashes) {\n+            assert(stageit != mapTx.end());\n+\n+            totalSizeWithAncestors += stageit->GetTxSize();\n+            if (stageit->GetSizeWithDescendants() + entry.GetTxSize() > limitDescendantSize) {\n+                errString = strprintf(\"exceeds descendant size limit for tx %s [limit: %u]\", stageit->GetTx().GetHash().ToString().substr(0,10), limitDescendantSize);\n+                return false;\n+            } else if (uint64_t(stageit->GetCountWithDescendants() + 1) > limitDescendantCount) {\n+                errString = strprintf(\"too many descendants for tx %s [limit: %u]\", stageit->GetTx().GetHash().ToString().substr(0,10), limitDescendantCount);\n+                return false;\n+            } else if (totalSizeWithAncestors > limitAncestorSize) {\n+                errString = strprintf(\"exceeds ancestor size limit [limit: %u]\", limitAncestorSize);\n+                return false;\n+            }\n+\n+            const setEntries & setMemPoolParents = GetMemPoolParents(stageit);\n+            BOOST_FOREACH(const txiter &phash, setMemPoolParents) {\n+                // If this is a new ancestor, add it.\n+                if (setAncestors.count(phash) == 0) {\n+                    stageParentSet.insert(phash);\n+                }\n+                if (stageParentSet.size() + setAncestors.size() + 1 > limitAncestorCount) {\n+                    errString = strprintf(\"too many unconfirmed ancestors [limit: %u]\", limitAncestorCount);\n+                    return false;\n+                }\n+            }    \n+        }\n+        parentHashes = stageParentSet;\n+    }\n+\n+    return true;\n+}\n+\n+void CTxMemPool::UpdateAncestorsOf(bool add, const uint256 &hash, setEntries &setAncestors)\n+{\n+    indexed_transaction_set::iterator it = mapTx.find(hash);\n+    setEntries parentIters = GetMemPoolParents(it);\n+    // add or remove this tx as a child of each parent\n+    BOOST_FOREACH(txiter piter, parentIters) {\n+        UpdateChild(piter, it, add);\n+    }\n+    int64_t updateCount = (add ? 1 : -1);\n+    int64_t updateSize = updateCount * it->GetTxSize();\n+    CAmount updateFee = updateCount * it->GetFee();\n+    BOOST_FOREACH(txiter ancestorIt, setAncestors) {\n+        mapTx.modify(ancestorIt, update_descendant_state(updateSize, updateFee, updateCount));\n+    }\n+}\n+\n+// TODO: pass a txiter instead?\n+void CTxMemPool::UpdateChildrenForRemoval(const uint256 &hash)\n+{\n+    txiter it = mapTx.find(hash);\n+    const setEntries &setMemPoolChildren = GetMemPoolChildren(it);\n+    BOOST_FOREACH(txiter updateIt, setMemPoolChildren) {\n+        UpdateParent(updateIt, it, false);\n+    }\n+}\n+\n+void CTxMemPool::UpdateForRemoveFromMempool(const std::set<uint256> &hashesToRemove)\n+{\n+    // For each entry, walk back all ancestors and decrement size associated with this\n+    // transaction\n+    uint64_t nNoLimit = std::numeric_limits<uint64_t>::max();\n+    BOOST_FOREACH(const uint256& removeHash, hashesToRemove) {\n+        setEntries setAncestors;\n+        const CTxMemPoolEntry &entry = *mapTx.find(removeHash);\n+        std::string dummy;\n+        CalculateMemPoolAncestors(entry, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy);\n+        // Note that UpdateAncestorsOf severs the child links that point to\n+        // removeHash in the entries for the parents of removeHash.  This is\n+        // fine since we don't need to use the mempool children of any entries\n+        // to walk back over our ancestors (but we do need the mempool\n+        // parents!)\n+        UpdateAncestorsOf(false, removeHash, setAncestors);\n+    }\n+    // After updating all the ancestor sizes, we can now sever the link between each\n+    // transaction being removed and any mempool children (ie, update setMemPoolParents\n+    // for each direct child of a transaction being removed).\n+    BOOST_FOREACH(const uint256& removeHash, hashesToRemove) {\n+        UpdateChildrenForRemoval(removeHash);\n+    }\n+}\n+\n+void CTxMemPoolEntry::SetDirty()\n+{\n+    nCountWithDescendants=0;\n+    nSizeWithDescendants=nTxSize;\n+    nFeesWithDescendants=nFee;\n+}\n+\n+void CTxMemPoolEntry::UpdateState(int64_t modifySize, CAmount modifyFee, int64_t modifyCount)\n+{\n+    if (!IsDirty()) {\n+        nSizeWithDescendants += modifySize;\n+        nFeesWithDescendants += modifyFee;\n+        nCountWithDescendants += modifyCount;\n+    }\n+}\n+\n CTxMemPool::CTxMemPool(const CFeeRate& _minRelayFee) :\n     nTransactionsUpdated(0)\n {\n@@ -90,34 +334,106 @@ void CTxMemPool::AddTransactionsUpdated(unsigned int n)\n     nTransactionsUpdated += n;\n }\n \n-\n-bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, bool fCurrentEstimate)\n+bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, setEntries &setAncestors, bool fCurrentEstimate)\n {\n     // Add to memory pool without checking anything.\n     // Used by main.cpp AcceptToMemoryPool(), which DOES do\n     // all the appropriate checks.\n     LOCK(cs);\n-    mapTx.insert(entry);\n-    const CTransaction& tx = mapTx.find(hash)->GetTx();\n-    for (unsigned int i = 0; i < tx.vin.size(); i++)\n+    indexed_transaction_set::iterator newit = mapTx.insert(entry).first;\n+    mapLinks.insert(make_pair(newit, TxLinks()));\n+\n+    // Update cachedInnerUsage to include contained transaction's usage.\n+    // (When we update the entry for in-mempool parents, memory usage will be\n+    // further updated.)\n+    cachedInnerUsage += entry.DynamicMemoryUsage();\n+\n+    const CTransaction& tx = newit->GetTx();\n+    std::set<uint256> setParentTransactions;\n+    for (unsigned int i = 0; i < tx.vin.size(); i++) {\n         mapNextTx[tx.vin[i].prevout] = CInPoint(&tx, i);\n+        setParentTransactions.insert(tx.vin[i].prevout.hash);\n+    }\n+    // Don't bother worrying about child transactions of this one.\n+    // Normal case of a new transaction arriving is that there can't be any\n+    // children, because such children would be orphans.\n+    // An exception to that is if a transaction enters that used to be in a block.\n+    // In that case, our disconnect block logic will call UpdateTransactionsFromBlock\n+    // to clean up the mess we're leaving here.\n+\n+    // Update ancestors with information about this tx\n+    BOOST_FOREACH (const uint256 &phash, setParentTransactions) {\n+        txiter pit = mapTx.find(phash);\n+        if (pit != mapTx.end()) {\n+            UpdateParent(newit, pit, true);\n+        }\n+    }\n+    UpdateAncestorsOf(true, hash, setAncestors);\n+\n     nTransactionsUpdated++;\n     totalTxSize += entry.GetTxSize();\n-    cachedInnerUsage += entry.DynamicMemoryUsage();\n     minerPolicyEstimator->processTransaction(entry, fCurrentEstimate);\n \n     return true;\n }\n \n+// TODO: replace this hash with an iterator?\n+void CTxMemPool::removeUnchecked(const uint256& hash)\n+{\n+    indexed_transaction_set::iterator it = mapTx.find(hash);\n+\n+    BOOST_FOREACH(const CTxIn& txin, it->GetTx().vin)\n+        mapNextTx.erase(txin.prevout);\n+\n+    totalTxSize -= it->GetTxSize();\n+    cachedInnerUsage -= it->DynamicMemoryUsage();\n+    cachedInnerUsage -= memusage::DynamicUsage(mapLinks[it].parents) + memusage::DynamicUsage(mapLinks[it].children);\n+    mapLinks.erase(it);\n+    mapTx.erase(it);\n+    nTransactionsUpdated++;\n+    minerPolicyEstimator->removeTx(hash);\n+}\n+\n+// Calculates descendants of hash that are not already in setDescendants, and adds to \n+// setDescendants. Assumes hash is already a tx in the mempool and setMemPoolChildren\n+// is correct for tx and all descendants.\n+// Also assumes that if an entry is in setDescendants already, then all\n+// in-mempool descendants of it are already in setDescendants as well, so that we\n+// can save time by not iterating over those entries.\n+void CTxMemPool::CalculateDescendants(const uint256 &hash, std::set<uint256> &setDescendants)\n+{\n+    std::set<uint256> stage;\n+    if (setDescendants.count(hash) == 0) {\n+        stage.insert(hash);\n+    }\n+    // Traverse down the children of each hash, only adding children that are not\n+    // accounted for in setDescendants already (because those children have either\n+    // already been walked, or will be walked in this iteration).\n+    while (!stage.empty()) {\n+        setDescendants.insert(stage.begin(), stage.end());\n+        std::set<uint256> setNext;\n+        BOOST_FOREACH(const uint256 &stagehash, stage) {\n+            indexed_transaction_set::iterator it = mapTx.find(stagehash);\n+            const setEntries &setChildren = GetMemPoolChildren(it);\n+            BOOST_FOREACH(const txiter &childiter, setChildren) {\n+                if (!setDescendants.count(childiter->GetTx().GetHash())) {\n+                    setNext.insert(childiter->GetTx().GetHash());\n+                }\n+            }\n+        }\n+        stage = setNext;\n+    }\n+}\n \n void CTxMemPool::remove(const CTransaction &origTx, std::list<CTransaction>& removed, bool fRecursive)\n {\n     // Remove transaction from memory pool\n     {\n         LOCK(cs);\n-        std::deque<uint256> txToRemove;\n-        txToRemove.push_back(origTx.GetHash());\n-        if (fRecursive && !mapTx.count(origTx.GetHash())) {\n+        std::set<uint256> txToRemove;\n+        if (mapTx.count(origTx.GetHash())) {\n+            txToRemove.insert(origTx.GetHash());\n+        } else if (fRecursive) {\n             // If recursively removing but origTx isn't in the mempool\n             // be sure to remove any children that are in the pool. This can\n             // happen during chain re-orgs if origTx isn't re-accepted into\n@@ -126,34 +442,21 @@ void CTxMemPool::remove(const CTransaction &origTx, std::list<CTransaction>& rem\n                 std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(COutPoint(origTx.GetHash(), i));\n                 if (it == mapNextTx.end())\n                     continue;\n-                txToRemove.push_back(it->second.ptx->GetHash());\n+                txToRemove.insert(it->second.ptx->GetHash());\n             }\n         }\n-        while (!txToRemove.empty())\n-        {\n-            uint256 hash = txToRemove.front();\n-            txToRemove.pop_front();\n-            if (!mapTx.count(hash))\n-                continue;\n-            const CTransaction& tx = mapTx.find(hash)->GetTx();\n-            if (fRecursive) {\n-                for (unsigned int i = 0; i < tx.vout.size(); i++) {\n-                    std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(COutPoint(hash, i));\n-                    if (it == mapNextTx.end())\n-                        continue;\n-                    txToRemove.push_back(it->second.ptx->GetHash());\n-                }\n+        std::set<uint256> setAllRemoves;\n+        if (fRecursive) {\n+            BOOST_FOREACH(const uint256 &hash, txToRemove) {\n+                CalculateDescendants(hash, setAllRemoves);\n             }\n-            BOOST_FOREACH(const CTxIn& txin, tx.vin)\n-                mapNextTx.erase(txin.prevout);\n-\n-            removed.push_back(tx);\n-            totalTxSize -= mapTx.find(hash)->GetTxSize();\n-            cachedInnerUsage -= mapTx.find(hash)->DynamicMemoryUsage();\n-            mapTx.erase(hash);\n-            nTransactionsUpdated++;\n-            minerPolicyEstimator->removeTx(hash);\n+        } else {\n+            setAllRemoves = txToRemove;\n         }\n+        BOOST_FOREACH(const uint256& hash, setAllRemoves) {\n+            removed.push_back(mapTx.find(hash)->GetTx());\n+        }\n+        RemoveStaged(setAllRemoves);\n     }\n }\n \n@@ -229,6 +532,7 @@ void CTxMemPool::removeForBlock(const std::vector<CTransaction>& vtx, unsigned i\n void CTxMemPool::clear()\n {\n     LOCK(cs);\n+    mapLinks.clear();\n     mapTx.clear();\n     mapNextTx.clear();\n     totalTxSize = 0;\n@@ -253,16 +557,20 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n     for (indexed_transaction_set::const_iterator it = mapTx.begin(); it != mapTx.end(); it++) {\n         unsigned int i = 0;\n         checkTotal += it->GetTxSize();\n-        innerUsage += it->DynamicMemoryUsage();\n+        innerUsage += it->DynamicMemoryUsage(); \n         const CTransaction& tx = it->GetTx();\n+        const TxLinks &links = mapLinks.find(it)->second;\n+        innerUsage += memusage::DynamicUsage(links.parents) + memusage::DynamicUsage(links.children);\n         bool fDependsWait = false;\n+        setEntries setParentCheck;\n         BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n             // Check that every mempool transaction's inputs refer to available coins, or other mempool tx's.\n             indexed_transaction_set::const_iterator it2 = mapTx.find(txin.prevout.hash);\n             if (it2 != mapTx.end()) {\n                 const CTransaction& tx2 = it2->GetTx();\n                 assert(tx2.vout.size() > txin.prevout.n && !tx2.vout[txin.prevout.n].IsNull());\n                 fDependsWait = true;\n+                setParentCheck.insert(it2);\n             } else {\n                 const CCoins* coins = pcoins->AccessCoins(txin.prevout.hash);\n                 assert(coins && coins->IsAvailable(txin.prevout.n));\n@@ -274,6 +582,32 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n             assert(it3->second.n == i);\n             i++;\n         }\n+        assert(setParentCheck == GetMemPoolParents(it));\n+        // Check children against mapNextTx\n+        CTxMemPool::setEntries setChildrenCheck;\n+        std::map<COutPoint, CInPoint>::const_iterator iter = mapNextTx.lower_bound(COutPoint(it->GetTx().GetHash(), 0));\n+        int64_t childSizes = 0;\n+        CAmount childFees = 0;\n+        for (; iter != mapNextTx.end() && iter->first.hash == it->GetTx().GetHash(); ++iter) {\n+            txiter childit = mapTx.find(iter->second.ptx->GetHash());\n+            if (setChildrenCheck.insert(childit).second) {\n+                childSizes += childit->GetTxSize();\n+                childFees += childit->GetFee();\n+            }\n+        }\n+        assert(setChildrenCheck == GetMemPoolChildren(it));\n+        // Also check to make sure size/fees is greater than sum with immediate children.\n+        // just a sanity check, not definitive that this calc is correct...\n+        // also check that the size is less than the size of the entire mempool.\n+        if (!it->IsDirty()) {\n+            assert(it->GetSizeWithDescendants() >= childSizes + int64_t(it->GetTxSize()));\n+            assert(it->GetFeesWithDescendants() >= childFees + it->GetFee());\n+        } else {\n+            assert(it->GetSizeWithDescendants() == int64_t(it->GetTxSize()));\n+            assert(it->GetFeesWithDescendants() == it->GetFee());\n+        }\n+        assert(it->GetFeesWithDescendants() >= 0);\n+\n         if (fDependsWait)\n             waitingOnDependants.push_back(&(*it));\n         else {\n@@ -432,6 +766,54 @@ bool CCoinsViewMemPool::HaveCoins(const uint256 &txid) const {\n \n size_t CTxMemPool::DynamicMemoryUsage() const {\n     LOCK(cs);\n-    // Estimate the overhead of mapTx to be 6 pointers + an allocation, as no exact formula for boost::multi_index_contained is implemented.\n-    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 6 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + cachedInnerUsage;\n+    // Estimate the overhead of mapTx to be 9 pointers + an allocation, as no exact formula for boost::multi_index_contained is implemented.\n+    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 9 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + memusage::DynamicUsage(mapLinks) + cachedInnerUsage;\n+}\n+\n+void CTxMemPool::RemoveStaged(std::set<uint256>& stage) {\n+    UpdateForRemoveFromMempool(stage);\n+    BOOST_FOREACH(const uint256& hash, stage) {\n+        removeUnchecked(hash);\n+    }\n+}\n+\n+bool CTxMemPool::addUnchecked(const uint256&hash, const CTxMemPoolEntry &entry, bool fCurrentEstimate)\n+{\n+    setEntries setAncestors;\n+    uint64_t nNoLimit = std::numeric_limits<uint64_t>::max();\n+    std::string dummy;\n+    CalculateMemPoolAncestors(entry, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy);\n+    return addUnchecked(hash, entry, setAncestors, fCurrentEstimate);\n+}\n+\n+void CTxMemPool::UpdateChild(txiter entry, txiter child, bool add)\n+{\n+    setEntries s;\n+    if (add && mapLinks[entry].children.insert(child).second) {\n+        cachedInnerUsage += memusage::IncrementalDynamicUsage(s);\n+    } else if (!add && mapLinks[entry].children.erase(child)) {\n+        cachedInnerUsage -= memusage::IncrementalDynamicUsage(s);\n+    }\n+}\n+\n+void CTxMemPool::UpdateParent(txiter entry, txiter parent, bool add)\n+{\n+    setEntries s;\n+    if (add && mapLinks[entry].parents.insert(parent).second) {\n+        cachedInnerUsage += memusage::IncrementalDynamicUsage(s);\n+    } else if (!add && mapLinks[entry].parents.erase(parent)) {\n+        cachedInnerUsage -= memusage::IncrementalDynamicUsage(s);\n+    }\n+}\n+\n+const CTxMemPool::setEntries & CTxMemPool::GetMemPoolParents(txiter entry) const\n+{\n+    assert (entry != mapTx.end());\n+    return mapLinks.find(entry)->second.parents;\n+}\n+\n+const CTxMemPool::setEntries & CTxMemPool::GetMemPoolChildren(txiter entry) const\n+{\n+    assert (entry != mapTx.end());\n+    return mapLinks.find(entry)->second.children;\n }"
      },
      {
        "sha": "27cbfa021d4631b59224613b68c957605716e852",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 174,
        "deletions": 2,
        "changes": 176,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5b6c1c25a56ca9211b13de0e09144765821c7545/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5b6c1c25a56ca9211b13de0e09144765821c7545/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=5b6c1c25a56ca9211b13de0e09144765821c7545",
        "patch": "@@ -7,6 +7,7 @@\n #define BITCOIN_TXMEMPOOL_H\n \n #include <list>\n+#include <set>\n \n #include \"amount.h\"\n #include \"coins.h\"\n@@ -34,6 +35,8 @@ inline bool AllowFree(double dPriority)\n /** Fake height value used in CCoins to signify they are only in the memory pool (since 0.8) */\n static const unsigned int MEMPOOL_HEIGHT = 0x7FFFFFFF;\n \n+class CTxMemPool;\n+\n /**\n  * CTxMemPool stores these:\n  */\n@@ -51,6 +54,15 @@ class CTxMemPoolEntry\n     unsigned int nHeight; //! Chain height when entering the mempool\n     bool hadNoDependencies; //! Not dependent on any other txs when it entered the mempool\n \n+    // Information about descendants of this transaction that are in the\n+    // mempool; if we remove this transaction we must remove all of these\n+    // descendants as well.  if nCountWithDescendants is 0, treat this entry as\n+    // dirty, and nSizeWithDescendants and nFeesWithDescendants will not be\n+    // correct.\n+    int64_t nCountWithDescendants; //! number of descendant transactions\n+    int64_t nSizeWithDescendants;  //! ... and size\n+    CAmount nFeesWithDescendants;  //! ... and total fees (all including us)\n+\n public:\n     CTxMemPoolEntry(const CTransaction& _tx, const CAmount& _nFee,\n                     int64_t _nTime, double _dPriority, unsigned int _nHeight, bool poolHasNoInputsOf = false);\n@@ -66,6 +78,42 @@ class CTxMemPoolEntry\n     unsigned int GetHeight() const { return nHeight; }\n     bool WasClearAtEntry() const { return hadNoDependencies; }\n     size_t DynamicMemoryUsage() const { return nUsageSize; }\n+\n+    // Adjusts the descendant state, if this entry is not dirty.\n+    void UpdateState(int64_t modifySize, CAmount modifyFee, int64_t modifyCount);\n+\n+    /** We can set the entry to be dirty if doing the full calculation of in-\n+     *  mempool descendants will be too expensive, which can potentially happen\n+     *  when re-adding transactions from a block back to the mempool.\n+     */\n+    void SetDirty();\n+    bool IsDirty() const { return nCountWithDescendants == 0; }\n+\n+    int64_t GetCountWithDescendants() const { return nCountWithDescendants; }\n+    int64_t GetSizeWithDescendants() const { return nSizeWithDescendants; }\n+    CAmount GetFeesWithDescendants() const { return nFeesWithDescendants; }\n+};\n+\n+// Helpers for modifying CTxMemPool::mapTx, which is a boost multi_index.\n+struct update_descendant_state\n+{\n+    update_descendant_state(int64_t _modifySize, CAmount _modifyFee, int64_t _modifyCount) :\n+        modifySize(_modifySize), modifyFee(_modifyFee), modifyCount(_modifyCount)\n+    {}\n+\n+    void operator() (CTxMemPoolEntry &e)\n+        { e.UpdateState(modifySize, modifyFee, modifyCount); }\n+\n+    private:\n+        int64_t modifySize;\n+        CAmount modifyFee;\n+        int64_t modifyCount;\n+};\n+\n+struct set_dirty\n+{\n+    void operator() (CTxMemPoolEntry &e)\n+        { e.SetDirty(); }\n };\n \n // extracts a TxMemPoolEntry's transaction hash\n@@ -83,9 +131,41 @@ class CompareTxMemPoolEntryByFee\n public:\n     bool operator()(const CTxMemPoolEntry& a, const CTxMemPoolEntry& b)\n     {\n-        if (a.GetFeeRate() == b.GetFeeRate())\n+        bool fUseADescendants = UseDescendantFeeRate(a);\n+        bool fUseBDescendants = UseDescendantFeeRate(b);\n+\n+        double aFees = fUseADescendants ? a.GetFeesWithDescendants() : a.GetFee();\n+        double aSize = fUseADescendants ? a.GetSizeWithDescendants() : a.GetTxSize();\n+\n+        double bFees = fUseBDescendants ? b.GetFeesWithDescendants() : b.GetFee();\n+        double bSize = fUseBDescendants ? b.GetSizeWithDescendants() : b.GetTxSize();\n+\n+        // Avoid division by rewriting (a/b > c/d) as (a*d > c*b).\n+        double f1 = aFees * bSize;\n+        double f2 = aSize * bFees;\n+\n+        if (f1 == f2) {\n             return a.GetTime() < b.GetTime();\n-        return a.GetFeeRate() > b.GetFeeRate();\n+        }\n+        return f1 > f2;\n+    }\n+\n+    // Sort an entry based on max(fee_rate by itself, fee_rate with all\n+    // descendants).  Avoid division as above.\n+    bool UseDescendantFeeRate(const CTxMemPoolEntry &a)\n+    {\n+        double f1 = (double)a.GetFee() * a.GetSizeWithDescendants();\n+        double f2 = (double)a.GetFeesWithDescendants() * a.GetTxSize();\n+        return f2 > f1;\n+    }\n+};\n+\n+class CompareTxMemPoolEntryByEntryTime\n+{\n+public:\n+    bool operator()(const CTxMemPoolEntry& a, const CTxMemPoolEntry& b)\n+    {\n+        return a.GetTime() < b.GetTime();\n     }\n };\n \n@@ -141,6 +221,27 @@ class CTxMemPool\n \n     mutable CCriticalSection cs;\n     indexed_transaction_set mapTx;\n+    typedef indexed_transaction_set::iterator txiter;\n+    struct CompareIteratorByHash {\n+        bool operator()(const txiter &a, const txiter &b) const {\n+            return a->GetTx().GetHash() < b->GetTx().GetHash();\n+        }\n+    };\n+    typedef std::set<txiter, CompareIteratorByHash> setEntries;\n+    typedef std::map<txiter, setEntries, CompareIteratorByHash> cacheMap;\n+\n+    struct TxLinks {\n+        setEntries parents;\n+        setEntries children;\n+    };\n+\n+    std::map<txiter, TxLinks, CompareIteratorByHash> mapLinks;\n+\n+    const setEntries & GetMemPoolParents(txiter entry) const;\n+    const setEntries & GetMemPoolChildren(txiter entry) const;\n+    void UpdateParent(txiter entry, txiter parent, bool add);\n+    void UpdateChild(txiter entry, txiter child, bool add);\n+\n     std::map<COutPoint, CInPoint> mapNextTx;\n     std::map<uint256, std::pair<double, CAmount> > mapDeltas;\n \n@@ -156,7 +257,13 @@ class CTxMemPool\n     void check(const CCoinsViewCache *pcoins) const;\n     void setSanityCheck(bool _fSanityCheck) { fSanityCheck = _fSanityCheck; }\n \n+    // addUnchecked must updated state for all ancestors of a given transaction,\n+    // to track size/count of descendant transactions.  First version of\n+    // addUnchecked can be used to have it call CalculateMemPoolAncestors, and\n+    // then invoke the second version.\n     bool addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, bool fCurrentEstimate = true);\n+    bool addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, setEntries &setAncestors, bool fCurrentEstimate = true);\n+\n     void remove(const CTransaction &tx, std::list<CTransaction>& removed, bool fRecursive = false);\n     void removeCoinbaseSpends(const CCoinsViewCache *pcoins, unsigned int nMemPoolHeight);\n     void removeConflicts(const CTransaction &tx, std::list<CTransaction>& removed);\n@@ -178,6 +285,29 @@ class CTxMemPool\n     void ApplyDeltas(const uint256 hash, double &dPriorityDelta, CAmount &nFeeDelta);\n     void ClearPrioritisation(const uint256 hash);\n \n+public:\n+    void RemoveStaged(std::set<uint256>& stage);\n+\n+    /** When adding transactions from a disconnected block back to the mempool,\n+     *  new mempool entries may have children in the mempool (which is generally\n+     *  not the case when otherwise adding transactions).\n+     *  UpdateTransactionsFromBlock will find child transactions and update the\n+     *  descendant state for each transaction in hashesToUpdate (excluding any\n+     *  child transactions present in hashesToUpdate, which are already accounted\n+     *  for).\n+     */\n+    void UpdateTransactionsFromBlock(const std::vector<uint256> &hashesToUpdate);\n+\n+    /** Try to calculate all in-mempool ancestors of entry.\n+     *  (these are all calculated including the tx itself)\n+     *  limitAncestorCount = max number of ancestors\n+     *  limitAncestorSize = max size of ancestors\n+     *  limitDescendantCount = max number of descendants any ancestor can have\n+     *  limitDescendantSize = max size of descendants any ancestor can have\n+     *  errString = populated with error reason if any limits are hit\n+     */\n+    bool CalculateMemPoolAncestors(const CTxMemPoolEntry &entry, setEntries &setAncestors, uint64_t limitAncestorCount, uint64_t limitAncestorSize, uint64_t limitDescendantCount, uint64_t limitDescendantSize, std::string &errString);\n+\n     unsigned long size()\n     {\n         LOCK(cs);\n@@ -209,6 +339,48 @@ class CTxMemPool\n     bool ReadFeeEstimates(CAutoFile& filein);\n \n     size_t DynamicMemoryUsage() const;\n+\n+private:\n+    /** UpdateForDescendants is used by UpdateTransactionsFromBlock to update\n+     *  the descendants for a single transaction that has been added to the\n+     *  mempool but may have child transactions in the mempool, eg during a\n+     *  chain reorg.  setExclude is the set of descendant transactions in the\n+     *  mempool that must not be accounted for (because any descendants in\n+     *  setExclude were added to the mempool after the transaction being\n+     *  updated and hence their state is already reflected in the parent\n+     *  state).\n+     *\n+     *  If updating an entry requires looking at more than maxDescendantsToVisit\n+     *  transactions, outside of the ones in setExclude, then give up.\n+     *\n+     *  cachedDescendants will be updated with the descendants of the transaction\n+     *  being updated, so that future invocations don't need to walk the\n+     *  same transaction again, if encountered in another transaction chain.\n+     */\n+    bool UpdateForDescendants(txiter updateIt,\n+            int maxDescendantsToVisit,\n+            cacheMap &cachedDescendants,\n+            const std::set<uint256> &setExclude);\n+    /** Update ancestors of hash to add/remove it as a descendant transaction. */\n+    void UpdateAncestorsOf(bool add, const uint256 &hash, setEntries &setAncestors);\n+    /** For each transaction being removed, update ancestors and any direct children. */\n+    void UpdateForRemoveFromMempool(const std::set<uint256> &hashesToRemove);\n+    /** Sever link between specified transaction and direct children. */\n+    void UpdateChildrenForRemoval(const uint256 &hash);\n+    /** Populate setDescendants with all in-mempool descendants of hash.\n+     *  Assumes that setDescendants includes all in-mempool descendants of anything\n+     *  already in it.  */\n+    void CalculateDescendants(const uint256 &hash, std::set<uint256> &setDescendants);\n+\n+    /** Before calling removeUnchecked for a given transaction,\n+     *  UpdateForRemoveFromMempool must be called on the entire (dependent) set\n+     *  of transactions being removed at the same time.  We use each\n+     *  CTxMemPoolEntry's setMemPoolParents in order to walk ancestors of a\n+     *  given transaction that is removed, so we can't remove intermediate\n+     *  transactions in a chain before we've updated all the state for the\n+     *  removal.\n+     */\n+    void removeUnchecked(const uint256& hash);\n };\n \n /** "
      }
    ]
  },
  {
    "sha": "d6401c1547cbc39e55e71328e809e54a8bef4442",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNjQwMWMxNTQ3Y2JjMzllNTVlNzEzMjhlODA5ZTU0YThiZWY0NDQy",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-08-14T14:58:52Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-09-09T12:41:03Z"
      },
      "message": "Add documentation for mempool package tracking",
      "tree": {
        "sha": "3997d4ab20f4ed433116796beb559d95c3de53c0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3997d4ab20f4ed433116796beb559d95c3de53c0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d6401c1547cbc39e55e71328e809e54a8bef4442",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d6401c1547cbc39e55e71328e809e54a8bef4442",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d6401c1547cbc39e55e71328e809e54a8bef4442",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d6401c1547cbc39e55e71328e809e54a8bef4442/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5b6c1c25a56ca9211b13de0e09144765821c7545",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5b6c1c25a56ca9211b13de0e09144765821c7545",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5b6c1c25a56ca9211b13de0e09144765821c7545"
      }
    ],
    "stats": {
      "total": 86,
      "additions": 82,
      "deletions": 4
    },
    "files": [
      {
        "sha": "5627bf3f7d6c44555d5a52cbbb4a140b9059a050",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 82,
        "deletions": 4,
        "changes": 86,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6401c1547cbc39e55e71328e809e54a8bef4442/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6401c1547cbc39e55e71328e809e54a8bef4442/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=d6401c1547cbc39e55e71328e809e54a8bef4442",
        "patch": "@@ -37,9 +37,23 @@ static const unsigned int MEMPOOL_HEIGHT = 0x7FFFFFFF;\n \n class CTxMemPool;\n \n-/**\n- * CTxMemPool stores these:\n+/** \\class CTxMemPoolEntry\n+ *\n+ * CTxMemPoolEntry stores data about the correponding transaction, as well\n+ * as data about all in-mempool transactions that depend on the transaction\n+ * (\"descendant\" transactions).\n+ *\n+ * When a new entry is added to the mempool, we update the descendant state\n+ * (nCountWithDescendants, nSizeWithDescendants, and nFeesWithDescendants) for\n+ * all ancestors of the newly added transaction.\n+ *\n+ * If updating the descendant state is skipped, we can mark the entry as\n+ * \"dirty\", and set nSizeWithDescendants/nFeesWithDescendants to equal nTxSize/\n+ * nTxFee. (This can potentially happen during a reorg, where we limit the\n+ * amount of work we're willing to do to avoid consuming too much CPU.)\n+ *\n  */\n+\n class CTxMemPoolEntry\n {\n private:\n@@ -126,6 +140,10 @@ struct mempoolentry_txid\n     }\n };\n \n+/** \\class CompareTxMemPoolEntryByFee\n+ *\n+ *  Sort an entry by max(feerate of entry's tx, feerate with all descendants).\n+ */\n class CompareTxMemPoolEntryByFee\n {\n public:\n@@ -150,8 +168,7 @@ class CompareTxMemPoolEntryByFee\n         return f1 > f2;\n     }\n \n-    // Sort an entry based on max(fee_rate by itself, fee_rate with all\n-    // descendants).  Avoid division as above.\n+    // Calculate which feerate to use for an entry (avoiding division).\n     bool UseDescendantFeeRate(const CTxMemPoolEntry &a)\n     {\n         double f1 = (double)a.GetFee() * a.GetSizeWithDescendants();\n@@ -194,6 +211,67 @@ class CInPoint\n  * are added to the pool: if a new transaction double-spends\n  * an input of a transaction in the pool, it is dropped,\n  * as are non-standard transactions.\n+ *\n+ * CTxMemPool::mapTx, and CTxMemPoolEntry bookkeeping:\n+ *\n+ * mapTx is a boost::multi_index that sorts the mempool on 2 criteria:\n+ * - transaction hash\n+ * - feerate [we use max(feerate of tx, feerate of tx with all descendants)]\n+ *\n+ * In order for the feerate sort to remain correct, we must update transactions\n+ * in the mempool when new descendants arrive.  To facilitate this, we track\n+ * the set of in-mempool direct parents and direct children in mapLinks.  Within\n+ * each CTxMemPoolEntry, we track the size and fees of all descendants.\n+ *\n+ * Usually when a new transaction is added to the mempool, it has no in-mempool\n+ * children (because any such children would be an orphan).  So in addUnchecked,\n+ * we:\n+ * - update a new entry's setMemPoolParents to include all in-mempool parents\n+ * - update the new entry's direct parents to include the new tx as a child\n+ * - update all ancestors of the transaction to include the new tx's size/fee\n+ *\n+ * When a transaction is removed from the mempool, we must:\n+ * - update all in-mempool parents to not track the tx in setMemPoolChildren\n+ * - update all ancestors to not include the tx's size/fees in descendant state\n+ * - update all in-mempool children to not include it as a parent\n+ *\n+ * These happen in UpdateForRemoveFromMempool.  (Note that when removing a\n+ * transaction along with its descendants, we must calculate that set of\n+ * transactions to be removed before doing the removal, or else the mempool can\n+ * be in an inconsistent state where it's impossible to walk the ancestors of\n+ * a transaction.)\n+ *\n+ * In the event of a reorg, the assumption that a newly added tx has no\n+ * in-mempool children is false.  In particular, the mempool is in an\n+ * inconsistent state while new transactions are being added, because there may\n+ * be descendant transactions of a tx coming from a disconnected block that are\n+ * unreachable from just looking at transactions in the mempool (the linking\n+ * transactions may also be in the disconnected block, waiting to be added).\n+ * Because of this, there's not much benefit in trying to search for in-mempool\n+ * children in addUnchecked.  Instead, in the special case of transactions\n+ * being added from a disconnected block, we require the caller to clean up the\n+ * state, to account for in-mempool, out-of-block descendants for all the\n+ * in-block transactions by calling UpdateTransactionsFromBlock.  Note that\n+ * until this is called, the mempool state is not consistent, and in particular\n+ * mapLinks may not be correct (and therefore functions like\n+ * CalculateMemPoolAncestors and CalculateDescendants that rely\n+ * on them to walk the mempool are not generally safe to use).\n+ *\n+ * Computational limits:\n+ *\n+ * Updating all in-mempool ancestors of a newly added transaction can be slow,\n+ * if no bound exists on how many in-mempool ancestors there may be.\n+ * CalculateMemPoolAncestors() takes configurable limits that are designed to\n+ * prevent these calculations from being too CPU intensive.\n+ *\n+ * Adding transactions from a disconnected block can be very time consuming,\n+ * because we don't have a way to limit the number of in-mempool descendants.\n+ * To bound CPU processing, we limit the amount of work we're willing to do\n+ * to properly update the descendant information for a tx being added from\n+ * a disconnected block.  If we would exceed the limit, then we instead mark\n+ * the entry as \"dirty\", and set the feerate for sorting purposes to be equal\n+ * the feerate of the transaction without any descendants.\n+ *\n  */\n class CTxMemPool\n {"
      }
    ]
  },
  {
    "sha": "990143dfd6bf98be11f9f8167c41bc9151f38b97",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5OTAxNDNkZmQ2YmY5OGJlMTFmOWY4MTY3YzQxYmM5MTUxZjM4Yjk3",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-09-09T16:12:40Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-09-09T16:12:40Z"
      },
      "message": "Implement GuessDynamicMemoryUsage",
      "tree": {
        "sha": "f9bad1809e73e369364aaaffef64d2e95396666b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f9bad1809e73e369364aaaffef64d2e95396666b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/990143dfd6bf98be11f9f8167c41bc9151f38b97",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/990143dfd6bf98be11f9f8167c41bc9151f38b97",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/990143dfd6bf98be11f9f8167c41bc9151f38b97",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/990143dfd6bf98be11f9f8167c41bc9151f38b97/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d6401c1547cbc39e55e71328e809e54a8bef4442",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d6401c1547cbc39e55e71328e809e54a8bef4442",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d6401c1547cbc39e55e71328e809e54a8bef4442"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 6,
      "deletions": 0
    },
    "files": [
      {
        "sha": "f140f5255710c03e76f6b8dc15c893130ac90009",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/990143dfd6bf98be11f9f8167c41bc9151f38b97/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/990143dfd6bf98be11f9f8167c41bc9151f38b97/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=990143dfd6bf98be11f9f8167c41bc9151f38b97",
        "patch": "@@ -770,6 +770,11 @@ size_t CTxMemPool::DynamicMemoryUsage() const {\n     return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 9 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + memusage::DynamicUsage(mapLinks) + cachedInnerUsage;\n }\n \n+size_t CTxMemPool::GuessDynamicMemoryUsage(const CTxMemPoolEntry& entry) const {\n+    setEntries s;\n+    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 9 * sizeof(void*)) + entry.DynamicMemoryUsage() + (memusage::IncrementalDynamicUsage(mapNextTx) + memusage::IncrementalDynamicUsage(s)) * entry.GetTx().vin.size() + memusage::IncrementalDynamicUsage(mapLinks);\n+}\n+\n void CTxMemPool::RemoveStaged(std::set<uint256>& stage) {\n     UpdateForRemoveFromMempool(stage);\n     BOOST_FOREACH(const uint256& hash, stage) {"
      },
      {
        "sha": "886aebeab3b6a859f1d118f4359bfd884440dffe",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/990143dfd6bf98be11f9f8167c41bc9151f38b97/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/990143dfd6bf98be11f9f8167c41bc9151f38b97/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=990143dfd6bf98be11f9f8167c41bc9151f38b97",
        "patch": "@@ -417,6 +417,7 @@ class CTxMemPool\n     bool ReadFeeEstimates(CAutoFile& filein);\n \n     size_t DynamicMemoryUsage() const;\n+    size_t GuessDynamicMemoryUsage(const CTxMemPoolEntry& entry) const;\n \n private:\n     /** UpdateForDescendants is used by UpdateTransactionsFromBlock to update"
      }
    ]
  },
  {
    "sha": "495dd9be352c4de9a21b51e8b9ca31323191b25e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0OTVkZDliZTM1MmM0ZGU5YTIxYjUxZThiOWNhMzEzMjMxOTFiMjVl",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-09-09T16:37:44Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-09-15T21:41:02Z"
      },
      "message": "Exponentially increasing minimum relay fee rate.\n\nIntroduce a maximum mempool size and a mininmum relay fee rate multiplier that increases by 10% for every 2% of the maximimum mempool size.  Free transactions are disallowed after the first 2% band.",
      "tree": {
        "sha": "01d9770984265e6bf8f14f264afc39bed8e000e6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/01d9770984265e6bf8f14f264afc39bed8e000e6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/495dd9be352c4de9a21b51e8b9ca31323191b25e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/495dd9be352c4de9a21b51e8b9ca31323191b25e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/495dd9be352c4de9a21b51e8b9ca31323191b25e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/495dd9be352c4de9a21b51e8b9ca31323191b25e/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "990143dfd6bf98be11f9f8167c41bc9151f38b97",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/990143dfd6bf98be11f9f8167c41bc9151f38b97",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/990143dfd6bf98be11f9f8167c41bc9151f38b97"
      }
    ],
    "stats": {
      "total": 37,
      "additions": 30,
      "deletions": 7
    },
    "files": [
      {
        "sha": "ea772d43efe49251161fa6dfdf14d056f578d512",
        "filename": "qa/pull-tester/rpc-tests.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/495dd9be352c4de9a21b51e8b9ca31323191b25e/qa/pull-tester/rpc-tests.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/495dd9be352c4de9a21b51e8b9ca31323191b25e/qa/pull-tester/rpc-tests.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.sh?ref=495dd9be352c4de9a21b51e8b9ca31323191b25e",
        "patch": "@@ -49,7 +49,7 @@ testScriptsExt=(\n     'invalidateblock.py'\n     'keypool.py'\n     'receivedby.py'\n-    'rpcbind_test.py'\n+#    'rpcbind_test.py'\n #   'script_test.py'\n     'smartfees.py'\n     'maxblocksinflight.py'"
      },
      {
        "sha": "be6ffd450a62f93c545d0ec50ca05f0845f1a720",
        "filename": "qa/rpc-tests/test_framework/util.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/495dd9be352c4de9a21b51e8b9ca31323191b25e/qa/rpc-tests/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/495dd9be352c4de9a21b51e8b9ca31323191b25e/qa/rpc-tests/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/util.py?ref=495dd9be352c4de9a21b51e8b9ca31323191b25e",
        "patch": "@@ -168,7 +168,7 @@ def start_node(i, dirname, extra_args=None, rpchost=None, timewait=None, binary=\n     datadir = os.path.join(dirname, \"node\"+str(i))\n     if binary is None:\n         binary = os.getenv(\"BITCOIND\", \"bitcoind\")\n-    args = [ binary, \"-datadir=\"+datadir, \"-keypool=1\", \"-discover=0\", \"-rest\" ]\n+    args = [ binary, \"-datadir=\"+datadir, \"-keypool=1\", \"-discover=0\", \"-rest\", \"-rpctimeout=1500\" ]\n     if extra_args is not None: args.extend(extra_args)\n     bitcoind_processes[i] = subprocess.Popen(args)\n     devnull = open(\"/dev/null\", \"w+\")"
      },
      {
        "sha": "ec8f8d0bb6cd3d5b0dcfbdbb49e6dc51988f8df2",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/495dd9be352c4de9a21b51e8b9ca31323191b25e/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/495dd9be352c4de9a21b51e8b9ca31323191b25e/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=495dd9be352c4de9a21b51e8b9ca31323191b25e",
        "patch": "@@ -287,6 +287,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-datadir=<dir>\", _(\"Specify data directory\"));\n     strUsage += HelpMessageOpt(\"-dbcache=<n>\", strprintf(_(\"Set database cache size in megabytes (%d to %d, default: %d)\"), nMinDbCache, nMaxDbCache, nDefaultDbCache));\n     strUsage += HelpMessageOpt(\"-loadblock=<file>\", _(\"Imports blocks from external blk000??.dat file\") + \" \" + _(\"on startup\"));\n+    strUsage += HelpMessageOpt(\"-maxmempool=<n>\", strprintf(_(\"Keep the transaction memory pool below <n> megabytes. n <= 0 disables mempool limiting. (default: %u)\"), DEFAULT_MAX_MEMPOOL_SIZE));\n     strUsage += HelpMessageOpt(\"-maxorphantx=<n>\", strprintf(_(\"Keep at most <n> unconnectable transactions in memory (default: %u)\"), DEFAULT_MAX_ORPHAN_TRANSACTIONS));\n     strUsage += HelpMessageOpt(\"-limitancestorcount=<n>\", strprintf(_(\"Do not accept transactions if number of in-mempool ancestors is <n> or more (default: %u)\"), DEFAULT_ANCESTOR_LIMIT));\n     strUsage += HelpMessageOpt(\"-limitancestorsize=<n>\", strprintf(_(\"Do not accept transactions whose size with all in-mempool ancestors exceeds <n> kilobytes (default: %u)\"), DEFAULT_ANCESTOR_SIZE_LIMIT));"
      },
      {
        "sha": "57d72b5cb513547e3a72c0da40908af1bbdc1626",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 5,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/495dd9be352c4de9a21b51e8b9ca31323191b25e/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/495dd9be352c4de9a21b51e8b9ca31323191b25e/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=495dd9be352c4de9a21b51e8b9ca31323191b25e",
        "patch": "@@ -886,7 +886,27 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         CAmount txMinFee = GetMinRelayFee(tx, nSize, true);\n         if (fLimitFree && nFees < txMinFee)\n             return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n-                strprintf(\"%d < %d\", nFees, txMinFee));\n+                strprintf(\"%ld < %ld\", nFees, txMinFee));\n+\n+        // Divide mempool into 50 bands of increasing required minimum fee\n+        static const int numBands = 50;\n+        size_t mempoolBand = std::max((int64_t)0, GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000/numBands);\n+        size_t expsize = pool.DynamicMemoryUsage() + pool.GuessDynamicMemoryUsage(entry);\n+        // Once mempool size is above first band, free transactions are no longer accepted\n+        // and a higher minimum fee is required.\n+        if (mempoolBand && expsize > mempoolBand) {\n+            int bandNumber = expsize/mempoolBand;\n+            // Enforce the hard cap\n+            if (bandNumber >= numBands) {\n+                return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full hard cap\", false,\n+                                 strprintf(\"%u\", mempoolBand * numBands));\n+            }\n+            double feeMultiplier = pow(1.1, bandNumber); // Fee requirement increases by 10% every band\n+            if (nFees < feeMultiplier * ::minRelayTxFee.GetFee(nSize)) {\n+                return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient fee for mempool size\", false,\n+                                 strprintf(\"Mult: %.1f Fees: %ld < %ld\", feeMultiplier, nFees, feeMultiplier * ::minRelayTxFee.GetFee(nSize)));\n+            }\n+        }\n \n         // Require that free transactions have sufficient priority to be mined in the next block.\n         if (GetBoolArg(\"-relaypriority\", true) && nFees < ::minRelayTxFee.GetFee(nSize) && !AllowFree(view.GetPriority(tx, chainActive.Height() + 1))) {\n@@ -4275,10 +4295,10 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             RelayTransaction(tx);\n             vWorkQueue.push_back(inv.hash);\n \n-            LogPrint(\"mempool\", \"AcceptToMemoryPool: peer=%d %s: accepted %s (poolsz %u)\\n\",\n-                pfrom->id, pfrom->cleanSubVer,\n-                tx.GetHash().ToString(),\n-                mempool.mapTx.size());\n+            LogPrint(\"mempool\", \"AcceptToMemoryPool: peer=%d %s: accepted %s (poolsz %u txs %.2f M usage)\\n\",\n+                     pfrom->id, pfrom->cleanSubVer,\n+                     tx.GetHash().ToString(),\n+                     mempool.mapTx.size(), (double)mempool.DynamicMemoryUsage()/1000000);\n \n             // Recursively process any orphan transactions that depended on this one\n             set<NodeId> setMisbehaving;"
      },
      {
        "sha": "f379e46e246a8251b324cf240f1b2628d9cd8508",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/495dd9be352c4de9a21b51e8b9ca31323191b25e/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/495dd9be352c4de9a21b51e8b9ca31323191b25e/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=495dd9be352c4de9a21b51e8b9ca31323191b25e",
        "patch": "@@ -43,6 +43,8 @@ struct CNodeStateStats;\n static const bool DEFAULT_ALERTS = true;\n /** Default for -maxorphantx, maximum number of orphan transactions kept in memory */\n static const unsigned int DEFAULT_MAX_ORPHAN_TRANSACTIONS = 100;\n+/** Default for -maxmempool, maximum megabytes of mempool memory usage */\n+static const unsigned int DEFAULT_MAX_MEMPOOL_SIZE = 500;\n /** Default for -limitancestorcount, max number of in-mempool ancestors */\n static const unsigned int DEFAULT_ANCESTOR_LIMIT = 100;\n /** Default for -limitancestorsize, maximum kilobytes of tx + all in-mempool ancestors */"
      }
    ]
  }
]