[
  {
    "sha": "f8b3058992b507f3a6aac9d4e2db00102ae1b197",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmOGIzMDU4OTkyYjUwN2YzYTZhYWM5ZDRlMmRiMDAxMDJhZTFiMTk3",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-02-12T11:22:16Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-02-15T16:02:43Z"
      },
      "message": "[net processing] Add Peer& arg to MaybeDiscourageAndDisconnect()\n\nRefactor only. No change in behaviour.",
      "tree": {
        "sha": "52e9097f7d919ded1085ccb691db9fef54d832c2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/52e9097f7d919ded1085ccb691db9fef54d832c2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f8b3058992b507f3a6aac9d4e2db00102ae1b197",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f8b3058992b507f3a6aac9d4e2db00102ae1b197",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f8b3058992b507f3a6aac9d4e2db00102ae1b197",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f8b3058992b507f3a6aac9d4e2db00102ae1b197/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "489030f2a8f89e7ae5031351fc3d0db83e3911ea",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/489030f2a8f89e7ae5031351fc3d0db83e3911ea",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/489030f2a8f89e7ae5031351fc3d0db83e3911ea"
      }
    ],
    "stats": {
      "total": 26,
      "additions": 12,
      "deletions": 14
    },
    "files": [
      {
        "sha": "1140eabe4cd2c670d0d3b396f25a4484f1ae4112",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 14,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8b3058992b507f3a6aac9d4e2db00102ae1b197/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8b3058992b507f3a6aac9d4e2db00102ae1b197/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=f8b3058992b507f3a6aac9d4e2db00102ae1b197",
        "patch": "@@ -302,9 +302,10 @@ class PeerManagerImpl final : public PeerManager\n     /** Maybe disconnect a peer and discourage future connections from its address.\n      *\n      * @param[in]   pnode     The node to check.\n+     * @param[in]   peer      The peer object to check.\n      * @return                True if the peer was marked for disconnection in this function\n      */\n-    bool MaybeDiscourageAndDisconnect(CNode& pnode);\n+    bool MaybeDiscourageAndDisconnect(CNode& pnode, Peer& peer);\n \n     void ProcessOrphanTx(std::set<uint256>& orphan_work_set) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans);\n     /** Process a single headers message from a peer. */\n@@ -3996,43 +3997,39 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n     return;\n }\n \n-bool PeerManagerImpl::MaybeDiscourageAndDisconnect(CNode& pnode)\n+bool PeerManagerImpl::MaybeDiscourageAndDisconnect(CNode& pnode, Peer& peer)\n {\n-    const NodeId peer_id{pnode.GetId()};\n-    PeerRef peer = GetPeerRef(peer_id);\n-    if (peer == nullptr) return false;\n-\n     {\n-        LOCK(peer->m_misbehavior_mutex);\n+        LOCK(peer.m_misbehavior_mutex);\n \n         // There's nothing to do if the m_should_discourage flag isn't set\n-        if (!peer->m_should_discourage) return false;\n+        if (!peer.m_should_discourage) return false;\n \n-        peer->m_should_discourage = false;\n+        peer.m_should_discourage = false;\n     } // peer.m_misbehavior_mutex\n \n     if (pnode.HasPermission(PF_NOBAN)) {\n         // We never disconnect or discourage peers for bad behavior if they have the NOBAN permission flag\n-        LogPrintf(\"Warning: not punishing noban peer %d!\\n\", peer_id);\n+        LogPrintf(\"Warning: not punishing noban peer %d!\\n\", peer.m_id);\n         return false;\n     }\n \n     if (pnode.IsManualConn()) {\n         // We never disconnect or discourage manual peers for bad behavior\n-        LogPrintf(\"Warning: not punishing manually connected peer %d!\\n\", peer_id);\n+        LogPrintf(\"Warning: not punishing manually connected peer %d!\\n\", peer.m_id);\n         return false;\n     }\n \n     if (pnode.addr.IsLocal()) {\n         // We disconnect local peers for bad behavior but don't discourage (since that would discourage\n         // all peers on the same local address)\n-        LogPrintf(\"Warning: disconnecting but not discouraging local peer %d!\\n\", peer_id);\n+        LogPrintf(\"Warning: disconnecting but not discouraging local peer %d!\\n\", peer.m_id);\n         pnode.fDisconnect = true;\n         return true;\n     }\n \n     // Normal case: Disconnect the peer and discourage all nodes sharing the address\n-    LogPrint(BCLog::NET, \"Disconnecting and discouraging peer %d!\\n\", peer_id);\n+    LogPrint(BCLog::NET, \"Disconnecting and discouraging peer %d!\\n\", peer.m_id);\n     if (m_banman) m_banman->Discourage(pnode.addr);\n     m_connman.DisconnectNode(pnode.addr);\n     return true;\n@@ -4319,11 +4316,12 @@ class CompareInvMempoolOrder\n bool PeerManagerImpl::SendMessages(CNode* pto)\n {\n     PeerRef peer = GetPeerRef(pto->GetId());\n+    if (!peer) return false;\n     const Consensus::Params& consensusParams = m_chainparams.GetConsensus();\n \n     // We must call MaybeDiscourageAndDisconnect first, to ensure that we'll\n     // disconnect misbehaving peers even before the version handshake is complete.\n-    if (MaybeDiscourageAndDisconnect(*pto)) return true;\n+    if (MaybeDiscourageAndDisconnect(*pto, *peer)) return true;\n \n     // Don't send anything until the version handshake is complete\n     if (!pto->fSuccessfullyConnected || pto->fDisconnect)"
      }
    ]
  },
  {
    "sha": "1a07600b4b0d08cffc7cd5c58af33fcd1ede558e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxYTA3NjAwYjRiMGQwOGNmZmM3Y2Q1YzU4YWYzM2ZjZDFlZGU1NThl",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-02-12T10:01:55Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-02-15T16:02:43Z"
      },
      "message": "[net] Add RunInactivityChecks()\n\nMoves the logic to prevent running inactivity checks until\nthe peer has been connected for -peertimeout time into its\nown function. This will be reused by net_processing later.",
      "tree": {
        "sha": "d709d6d3dd0a8dd792ae78650d498a7f860b8b9e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d709d6d3dd0a8dd792ae78650d498a7f860b8b9e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1a07600b4b0d08cffc7cd5c58af33fcd1ede558e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1a07600b4b0d08cffc7cd5c58af33fcd1ede558e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1a07600b4b0d08cffc7cd5c58af33fcd1ede558e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1a07600b4b0d08cffc7cd5c58af33fcd1ede558e/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f8b3058992b507f3a6aac9d4e2db00102ae1b197",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f8b3058992b507f3a6aac9d4e2db00102ae1b197",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f8b3058992b507f3a6aac9d4e2db00102ae1b197"
      }
    ],
    "stats": {
      "total": 16,
      "additions": 9,
      "deletions": 7
    },
    "files": [
      {
        "sha": "a02b66bd74687e53f2277e3ee83c6afaafba7e3f",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 7,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a07600b4b0d08cffc7cd5c58af33fcd1ede558e/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a07600b4b0d08cffc7cd5c58af33fcd1ede558e/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=1a07600b4b0d08cffc7cd5c58af33fcd1ede558e",
        "patch": "@@ -1221,18 +1221,17 @@ void CConnman::NotifyNumConnectionsChanged()\n     }\n }\n \n+bool CConnman::RunInactivityChecks(const CNode& node) const\n+{\n+    return GetSystemTimeInSeconds() > node.nTimeConnected + m_peer_connect_timeout;\n+}\n+\n bool CConnman::InactivityCheck(const CNode& node) const\n {\n     // Use non-mockable system time (otherwise these timers will pop when we\n     // use setmocktime in the tests).\n     int64_t now = GetSystemTimeInSeconds();\n \n-    if (now <= node.nTimeConnected + m_peer_connect_timeout) {\n-        // Only run inactivity checks if the peer has been connected longer\n-        // than m_peer_connect_timeout.\n-        return false;\n-    }\n-\n     if (node.nLastRecv == 0 || node.nLastSend == 0) {\n         LogPrint(BCLog::NET, \"socket no message in first %i seconds, %d %d peer=%d\\n\", m_peer_connect_timeout, node.nLastRecv != 0, node.nLastSend != 0, node.GetId());\n         return true;\n@@ -1537,7 +1536,7 @@ void CConnman::SocketHandler()\n             if (bytes_sent) RecordBytesSent(bytes_sent);\n         }\n \n-        if (InactivityCheck(*pnode)) pnode->fDisconnect = true;\n+        if (RunInactivityChecks(*pnode) && InactivityCheck(*pnode)) pnode->fDisconnect = true;\n     }\n     {\n         LOCK(cs_vNodes);"
      },
      {
        "sha": "425371f3d5b87c0ed1e1078eb08c29a6bae87c37",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1a07600b4b0d08cffc7cd5c58af33fcd1ede558e/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1a07600b4b0d08cffc7cd5c58af33fcd1ede558e/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=1a07600b4b0d08cffc7cd5c58af33fcd1ede558e",
        "patch": "@@ -1022,6 +1022,9 @@ class CConnman\n \n     void SetAsmap(std::vector<bool> asmap) { addrman.m_asmap = std::move(asmap); }\n \n+    /** Return true if the peer has been connected for long enough to do inactivity checks. */\n+    bool RunInactivityChecks(const CNode& node) const;\n+\n private:\n     struct ListenSocket {\n     public:"
      }
    ]
  },
  {
    "sha": "0b43b81f69ff13dbc1e893a80950f186690b4f62",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowYjQzYjgxZjY5ZmYxM2RiYzFlODkzYTgwOTUwZjE4NjY5MGI0ZjYy",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2020-06-21T21:23:58Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-02-15T16:02:43Z"
      },
      "message": "[net processing] Move send ping message logic into function",
      "tree": {
        "sha": "72e51fb8087e770abe28d862fed5bda54566ab19",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/72e51fb8087e770abe28d862fed5bda54566ab19"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0b43b81f69ff13dbc1e893a80950f186690b4f62",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0b43b81f69ff13dbc1e893a80950f186690b4f62",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0b43b81f69ff13dbc1e893a80950f186690b4f62",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0b43b81f69ff13dbc1e893a80950f186690b4f62/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1a07600b4b0d08cffc7cd5c58af33fcd1ede558e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1a07600b4b0d08cffc7cd5c58af33fcd1ede558e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1a07600b4b0d08cffc7cd5c58af33fcd1ede558e"
      }
    ],
    "stats": {
      "total": 65,
      "additions": 37,
      "deletions": 28
    },
    "files": [
      {
        "sha": "94d9be6a9b4805ebabbad5f43632c275055471fd",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 28,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0b43b81f69ff13dbc1e893a80950f186690b4f62/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0b43b81f69ff13dbc1e893a80950f186690b4f62/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=0b43b81f69ff13dbc1e893a80950f186690b4f62",
        "patch": "@@ -324,6 +324,9 @@ class PeerManagerImpl final : public PeerManager\n     /** Send a version message to a peer */\n     void PushNodeVersion(CNode& pnode, int64_t nTime);\n \n+    /** Send a ping message every PING_INTERVAL or if requested via RPC. */\n+    void MaybeSendPing(CNode& node_to);\n+\n     const CChainParams& m_chainparams;\n     CConnman& m_connman;\n     /** Pointer to this node's banman. May be nullptr - check existence before dereferencing. */\n@@ -4292,6 +4295,39 @@ void PeerManagerImpl::CheckForStaleTipAndEvictPeers()\n     }\n }\n \n+void PeerManagerImpl::MaybeSendPing(CNode& node_to)\n+{\n+    const CNetMsgMaker msgMaker(node_to.GetCommonVersion());\n+    bool pingSend = false;\n+\n+    if (node_to.fPingQueued) {\n+        // RPC ping request by user\n+        pingSend = true;\n+    }\n+\n+    if (node_to.nPingNonceSent == 0 && node_to.m_ping_start.load() + PING_INTERVAL < GetTime<std::chrono::microseconds>()) {\n+        // Ping automatically sent as a latency probe & keepalive.\n+        pingSend = true;\n+    }\n+\n+    if (pingSend) {\n+        uint64_t nonce = 0;\n+        while (nonce == 0) {\n+            GetRandBytes((unsigned char*)&nonce, sizeof(nonce));\n+        }\n+        node_to.fPingQueued = false;\n+        node_to.m_ping_start = GetTime<std::chrono::microseconds>();\n+        if (node_to.GetCommonVersion() > BIP0031_VERSION) {\n+            node_to.nPingNonceSent = nonce;\n+            m_connman.PushMessage(&node_to, msgMaker.Make(NetMsgType::PING, nonce));\n+        } else {\n+            // Peer is too old to support ping command with nonce, pong will never arrive.\n+            node_to.nPingNonceSent = 0;\n+            m_connman.PushMessage(&node_to, msgMaker.Make(NetMsgType::PING));\n+        }\n+    }\n+}\n+\n namespace {\n class CompareInvMempoolOrder\n {\n@@ -4330,34 +4366,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n     // If we get here, the outgoing message serialization version is set and can't change.\n     const CNetMsgMaker msgMaker(pto->GetCommonVersion());\n \n-    //\n-    // Message: ping\n-    //\n-    bool pingSend = false;\n-    if (pto->fPingQueued) {\n-        // RPC ping request by user\n-        pingSend = true;\n-    }\n-    if (pto->nPingNonceSent == 0 && pto->m_ping_start.load() + PING_INTERVAL < GetTime<std::chrono::microseconds>()) {\n-        // Ping automatically sent as a latency probe & keepalive.\n-        pingSend = true;\n-    }\n-    if (pingSend) {\n-        uint64_t nonce = 0;\n-        while (nonce == 0) {\n-            GetRandBytes((unsigned char*)&nonce, sizeof(nonce));\n-        }\n-        pto->fPingQueued = false;\n-        pto->m_ping_start = GetTime<std::chrono::microseconds>();\n-        if (pto->GetCommonVersion() > BIP0031_VERSION) {\n-            pto->nPingNonceSent = nonce;\n-            m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::PING, nonce));\n-        } else {\n-            // Peer is too old to support ping command with nonce, pong will never arrive.\n-            pto->nPingNonceSent = 0;\n-            m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::PING));\n-        }\n-    }\n+    MaybeSendPing(*pto);\n \n     {\n         LOCK(cs_main);"
      }
    ]
  },
  {
    "sha": "dd2646d12c172cb8899669af717c590483a17404",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkZDI2NDZkMTJjMTcyY2I4ODk5NjY5YWY3MTdjNTkwNDgzYTE3NDA0",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2020-06-21T22:15:56Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-02-15T16:02:43Z"
      },
      "message": "[net processing] Move ping timeout logic to net processing\n\nPing messages are an application-level mechanism. Move timeout\nlogic from net to net processing.",
      "tree": {
        "sha": "61d8e6619a2f8e56fe88d7097b2dec1776f5bf93",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/61d8e6619a2f8e56fe88d7097b2dec1776f5bf93"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dd2646d12c172cb8899669af717c590483a17404",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dd2646d12c172cb8899669af717c590483a17404",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dd2646d12c172cb8899669af717c590483a17404",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dd2646d12c172cb8899669af717c590483a17404/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0b43b81f69ff13dbc1e893a80950f186690b4f62",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0b43b81f69ff13dbc1e893a80950f186690b4f62",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0b43b81f69ff13dbc1e893a80950f186690b4f62"
      }
    ],
    "stats": {
      "total": 29,
      "additions": 18,
      "deletions": 11
    },
    "files": [
      {
        "sha": "f8a417ddd1b9658e8395bdea4a5d39004052aea6",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 8,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd2646d12c172cb8899669af717c590483a17404/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd2646d12c172cb8899669af717c590483a17404/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=dd2646d12c172cb8899669af717c590483a17404",
        "patch": "@@ -1247,14 +1247,6 @@ bool CConnman::InactivityCheck(const CNode& node) const\n         return true;\n     }\n \n-    if (node.nPingNonceSent && node.m_ping_start.load() + std::chrono::seconds{TIMEOUT_INTERVAL} < GetTime<std::chrono::microseconds>()) {\n-        // We use mockable time for ping timeouts. This means that setmocktime\n-        // may cause pings to time out for peers that have been connected for\n-        // longer than m_peer_connect_timeout.\n-        LogPrint(BCLog::NET, \"ping timeout: %fs peer=%d\\n\", 0.000001 * count_microseconds(GetTime<std::chrono::microseconds>() - node.m_ping_start.load()), node.GetId());\n-        return true;\n-    }\n-\n     if (!node.fSuccessfullyConnected) {\n         LogPrint(BCLog::NET, \"version handshake timeout peer=%d\\n\", node.GetId());\n         return true;"
      },
      {
        "sha": "ac3e6d0343ae15524fae69f6606bd0b63ea66ae8",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 3,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd2646d12c172cb8899669af717c590483a17404/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd2646d12c172cb8899669af717c590483a17404/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=dd2646d12c172cb8899669af717c590483a17404",
        "patch": "@@ -324,7 +324,8 @@ class PeerManagerImpl final : public PeerManager\n     /** Send a version message to a peer */\n     void PushNodeVersion(CNode& pnode, int64_t nTime);\n \n-    /** Send a ping message every PING_INTERVAL or if requested via RPC. */\n+    /** Send a ping message every PING_INTERVAL or if requested via RPC. May\n+     *  mark the peer to be disconnected if a ping has timed out. */\n     void MaybeSendPing(CNode& node_to);\n \n     const CChainParams& m_chainparams;\n@@ -4297,6 +4298,17 @@ void PeerManagerImpl::CheckForStaleTipAndEvictPeers()\n \n void PeerManagerImpl::MaybeSendPing(CNode& node_to)\n {\n+    // Use mockable time for ping timeouts.\n+    // This means that setmocktime may cause pings to time out.\n+    auto now = GetTime<std::chrono::microseconds>();\n+\n+    if (m_connman.RunInactivityChecks(node_to) && node_to.nPingNonceSent &&\n+        now > node_to.m_ping_start.load() + std::chrono::seconds{TIMEOUT_INTERVAL}) {\n+        LogPrint(BCLog::NET, \"ping timeout: %fs peer=%d\\n\", 0.000001 * count_microseconds(now - node_to.m_ping_start.load()), node_to.GetId());\n+        node_to.fDisconnect = true;\n+        return;\n+    }\n+\n     const CNetMsgMaker msgMaker(node_to.GetCommonVersion());\n     bool pingSend = false;\n \n@@ -4305,7 +4317,7 @@ void PeerManagerImpl::MaybeSendPing(CNode& node_to)\n         pingSend = true;\n     }\n \n-    if (node_to.nPingNonceSent == 0 && node_to.m_ping_start.load() + PING_INTERVAL < GetTime<std::chrono::microseconds>()) {\n+    if (node_to.nPingNonceSent == 0 && now > node_to.m_ping_start.load() + PING_INTERVAL) {\n         // Ping automatically sent as a latency probe & keepalive.\n         pingSend = true;\n     }\n@@ -4316,7 +4328,7 @@ void PeerManagerImpl::MaybeSendPing(CNode& node_to)\n             GetRandBytes((unsigned char*)&nonce, sizeof(nonce));\n         }\n         node_to.fPingQueued = false;\n-        node_to.m_ping_start = GetTime<std::chrono::microseconds>();\n+        node_to.m_ping_start = now;\n         if (node_to.GetCommonVersion() > BIP0031_VERSION) {\n             node_to.nPingNonceSent = nonce;\n             m_connman.PushMessage(&node_to, msgMaker.Make(NetMsgType::PING, nonce));\n@@ -4368,6 +4380,9 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n \n     MaybeSendPing(*pto);\n \n+    // MaybeSendPing may have marked peer for disconnection\n+    if (pto->fDisconnect) return true;\n+\n     {\n         LOCK(cs_main);\n "
      }
    ]
  },
  {
    "sha": "45dcf2266125c65d7f546bdb211a278bd090a284",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NWRjZjIyNjYxMjVjNjVkN2Y1NDZiZGIyMTFhMjc4YmQwOTBhMjg0",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2020-06-21T22:56:19Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-02-15T16:15:51Z"
      },
      "message": "[net processing] Move ping data fields to net processing",
      "tree": {
        "sha": "384028a852c66190b8f8b1cd5773b90e15880049",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/384028a852c66190b8f8b1cd5773b90e15880049"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/45dcf2266125c65d7f546bdb211a278bd090a284",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/45dcf2266125c65d7f546bdb211a278bd090a284",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/45dcf2266125c65d7f546bdb211a278bd090a284",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/45dcf2266125c65d7f546bdb211a278bd090a284/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "dd2646d12c172cb8899669af717c590483a17404",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dd2646d12c172cb8899669af717c590483a17404",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/dd2646d12c172cb8899669af717c590483a17404"
      }
    ],
    "stats": {
      "total": 117,
      "additions": 66,
      "deletions": 51
    },
    "files": [
      {
        "sha": "cc2ddbf84fc5b518a503381a4fcb9a1501d14c57",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 14,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/45dcf2266125c65d7f546bdb211a278bd090a284/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/45dcf2266125c65d7f546bdb211a278bd090a284/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=45dcf2266125c65d7f546bdb211a278bd090a284",
        "patch": "@@ -601,21 +601,8 @@ void CNode::copyStats(CNodeStats &stats, const std::vector<bool> &m_asmap)\n         stats.minFeeFilter = 0;\n     }\n \n-    // It is common for nodes with good ping times to suddenly become lagged,\n-    // due to a new block arriving or other large transfer.\n-    // Merely reporting pingtime might fool the caller into thinking the node was still responsive,\n-    // since pingtime does not update until the ping is complete, which might take a while.\n-    // So, if a ping is taking an unusually long time in flight,\n-    // the caller can immediately detect that this is happening.\n-    std::chrono::microseconds ping_wait{0};\n-    if ((0 != nPingNonceSent) && (0 != m_ping_start.load().count())) {\n-        ping_wait = GetTime<std::chrono::microseconds>() - m_ping_start.load();\n-    }\n-\n-    // Raw ping time is in microseconds, but show it to user as whole seconds (Bitcoin users should be well used to small numbers with many decimal places by now :)\n     stats.m_ping_usec = nPingUsecTime;\n-    stats.m_min_ping_usec  = nMinPingUsecTime;\n-    stats.m_ping_wait_usec = count_microseconds(ping_wait);\n+    stats.m_min_ping_usec = nMinPingUsecTime;\n \n     // Leave string empty if addrLocal invalid (not filled in yet)\n     CService addrLocalUnlocked = GetAddrLocal();"
      },
      {
        "sha": "c6c62c29e70a17e8bed101f621459eae7b80bdc4",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/45dcf2266125c65d7f546bdb211a278bd090a284/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/45dcf2266125c65d7f546bdb211a278bd090a284/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=45dcf2266125c65d7f546bdb211a278bd090a284",
        "patch": "@@ -260,7 +260,6 @@ class CNodeStats\n     mapMsgCmdSize mapRecvBytesPerMsgCmd;\n     NetPermissionFlags m_permissionFlags;\n     int64_t m_ping_usec;\n-    int64_t m_ping_wait_usec;\n     int64_t m_min_ping_usec;\n     CAmount minFeeFilter;\n     // Our address, as reported by the peer\n@@ -591,17 +590,12 @@ class CNode\n      * in CConnman::AttemptToEvictConnection. */\n     std::atomic<int64_t> nLastTXTime{0};\n \n-    // Ping time measurement:\n-    // The pong reply we're expecting, or 0 if no pong expected.\n-    std::atomic<uint64_t> nPingNonceSent{0};\n-    /** When the last ping was sent, or 0 if no ping was ever sent */\n-    std::atomic<std::chrono::microseconds> m_ping_start{0us};\n-    // Last measured round-trip time.\n+    /** Last measured round-trip time. Used only for RPC/GUI stats/debugging.*/\n     std::atomic<int64_t> nPingUsecTime{0};\n-    // Best measured round-trip time.\n+\n+    /** Lowest measured round-trip time. Used as an inbound peer eviction\n+     * criterium in CConnman::AttemptToEvictConnection. */\n     std::atomic<int64_t> nMinPingUsecTime{std::numeric_limits<int64_t>::max()};\n-    // Whether a ping is requested.\n-    std::atomic<bool> fPingQueued{false};\n \n     CNode(NodeId id, ServiceFlags nLocalServicesIn, SOCKET hSocketIn, const CAddress& addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const CAddress& addrBindIn, const std::string& addrNameIn, ConnectionType conn_type_in, bool inbound_onion);\n     ~CNode();\n@@ -721,6 +715,12 @@ class CNode\n \n     std::string ConnectionTypeAsString() const { return ::ConnectionTypeAsString(m_conn_type); }\n \n+    /** A ping-pong round trip has completed successfully. Update latest and minimum ping times. */\n+    void PongReceived(std::chrono::microseconds ping_time) {\n+        nPingUsecTime = count_microseconds(ping_time);\n+        nMinPingUsecTime = std::min(nMinPingUsecTime.load(), count_microseconds(ping_time));\n+    }\n+\n private:\n     const NodeId id;\n     const uint64_t nLocalHostNonce;"
      },
      {
        "sha": "5ac9cbdcb5a025979eba0e9913ad421d9e1d8ef3",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 45,
        "deletions": 20,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/45dcf2266125c65d7f546bdb211a278bd090a284/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/45dcf2266125c65d7f546bdb211a278bd090a284/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=45dcf2266125c65d7f546bdb211a278bd090a284",
        "patch": "@@ -219,6 +219,13 @@ struct Peer {\n     /** This peer's reported block height when we connected */\n     std::atomic<int> m_starting_height{-1};\n \n+    /** The pong reply we're expecting, or 0 if no pong expected. */\n+    std::atomic<uint64_t> nPingNonceSent{0};\n+    /** When the last ping was sent, or 0 if no ping was ever sent */\n+    std::atomic<std::chrono::microseconds> m_ping_start{0us};\n+    /** Whether a ping has been requested by the user */\n+    std::atomic<bool> fPingQueued{false};\n+\n     /** Set of txids to reconsider once their parent transactions have been accepted **/\n     std::set<uint256> m_orphan_work_set GUARDED_BY(g_cs_orphans);\n \n@@ -256,6 +263,7 @@ class PeerManagerImpl final : public PeerManager\n     void CheckForStaleTipAndEvictPeers() override;\n     bool GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) override;\n     bool IgnoresIncomingTxs() override { return m_ignore_incoming_txs; }\n+    void SendPings() override;\n     void SetBestHeight(int height) override { m_best_height = height; };\n     void Misbehaving(const NodeId pnode, const int howmuch, const std::string& message) override;\n     void ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRecv,\n@@ -326,7 +334,7 @@ class PeerManagerImpl final : public PeerManager\n \n     /** Send a ping message every PING_INTERVAL or if requested via RPC. May\n      *  mark the peer to be disconnected if a ping has timed out. */\n-    void MaybeSendPing(CNode& node_to);\n+    void MaybeSendPing(CNode& node_to, Peer& peer);\n \n     const CChainParams& m_chainparams;\n     CConnman& m_connman;\n@@ -1093,6 +1101,18 @@ bool PeerManagerImpl::GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats)\n     PeerRef peer = GetPeerRef(nodeid);\n     if (peer == nullptr) return false;\n     stats.m_starting_height = peer->m_starting_height;\n+    // It is common for nodes with good ping times to suddenly become lagged,\n+    // due to a new block arriving or other large transfer.\n+    // Merely reporting pingtime might fool the caller into thinking the node was still responsive,\n+    // since pingtime does not update until the ping is complete, which might take a while.\n+    // So, if a ping is taking an unusually long time in flight,\n+    // the caller can immediately detect that this is happening.\n+    std::chrono::microseconds ping_wait{0};\n+    if ((0 != peer->nPingNonceSent) && (0 != peer->m_ping_start.load().count())) {\n+        ping_wait = GetTime<std::chrono::microseconds>() - peer->m_ping_start.load();\n+    }\n+\n+    stats.m_ping_wait_usec = count_microseconds(ping_wait);\n \n     return true;\n }\n@@ -1632,6 +1652,12 @@ bool static AlreadyHaveBlock(const uint256& block_hash) EXCLUSIVE_LOCKS_REQUIRED\n     return g_chainman.m_blockman.LookupBlockIndex(block_hash) != nullptr;\n }\n \n+void PeerManagerImpl::SendPings()\n+{\n+    LOCK(m_peer_mutex);\n+    for(auto& it : m_peer_map) it.second->fPingQueued = true;\n+}\n+\n void RelayTransaction(const uint256& txid, const uint256& wtxid, const CConnman& connman)\n {\n     connman.ForEachNode([&txid, &wtxid](CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {\n@@ -3842,15 +3868,14 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             vRecv >> nonce;\n \n             // Only process pong message if there is an outstanding ping (old ping without nonce should never pong)\n-            if (pfrom.nPingNonceSent != 0) {\n-                if (nonce == pfrom.nPingNonceSent) {\n+            if (peer->nPingNonceSent != 0) {\n+                if (nonce == peer->nPingNonceSent) {\n                     // Matching pong received, this ping is no longer outstanding\n                     bPingFinished = true;\n-                    const auto ping_time = ping_end - pfrom.m_ping_start.load();\n+                    const auto ping_time = ping_end - peer->m_ping_start.load();\n                     if (ping_time.count() >= 0) {\n-                        // Successful ping time measurement, replace previous\n-                        pfrom.nPingUsecTime = count_microseconds(ping_time);\n-                        pfrom.nMinPingUsecTime = std::min(pfrom.nMinPingUsecTime.load(), count_microseconds(ping_time));\n+                        // Let connman know about this successful ping-pong\n+                        pfrom.PongReceived(ping_time);\n                     } else {\n                         // This should never happen\n                         sProblem = \"Timing mishap\";\n@@ -3877,12 +3902,12 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             LogPrint(BCLog::NET, \"pong peer=%d: %s, %x expected, %x received, %u bytes\\n\",\n                 pfrom.GetId(),\n                 sProblem,\n-                pfrom.nPingNonceSent,\n+                peer->nPingNonceSent,\n                 nonce,\n                 nAvail);\n         }\n         if (bPingFinished) {\n-            pfrom.nPingNonceSent = 0;\n+            peer->nPingNonceSent = 0;\n         }\n         return;\n     }\n@@ -4296,28 +4321,28 @@ void PeerManagerImpl::CheckForStaleTipAndEvictPeers()\n     }\n }\n \n-void PeerManagerImpl::MaybeSendPing(CNode& node_to)\n+void PeerManagerImpl::MaybeSendPing(CNode& node_to, Peer& peer)\n {\n     // Use mockable time for ping timeouts.\n     // This means that setmocktime may cause pings to time out.\n     auto now = GetTime<std::chrono::microseconds>();\n \n-    if (m_connman.RunInactivityChecks(node_to) && node_to.nPingNonceSent &&\n-        now > node_to.m_ping_start.load() + std::chrono::seconds{TIMEOUT_INTERVAL}) {\n-        LogPrint(BCLog::NET, \"ping timeout: %fs peer=%d\\n\", 0.000001 * count_microseconds(now - node_to.m_ping_start.load()), node_to.GetId());\n+    if (m_connman.RunInactivityChecks(node_to) && peer.nPingNonceSent &&\n+        now > peer.m_ping_start.load() + std::chrono::seconds{TIMEOUT_INTERVAL}) {\n+        LogPrint(BCLog::NET, \"ping timeout: %fs peer=%d\\n\", 0.000001 * count_microseconds(now - peer.m_ping_start.load()), peer.m_id);\n         node_to.fDisconnect = true;\n         return;\n     }\n \n     const CNetMsgMaker msgMaker(node_to.GetCommonVersion());\n     bool pingSend = false;\n \n-    if (node_to.fPingQueued) {\n+    if (peer.fPingQueued) {\n         // RPC ping request by user\n         pingSend = true;\n     }\n \n-    if (node_to.nPingNonceSent == 0 && now > node_to.m_ping_start.load() + PING_INTERVAL) {\n+    if (peer.nPingNonceSent == 0 && now > peer.m_ping_start.load() + PING_INTERVAL) {\n         // Ping automatically sent as a latency probe & keepalive.\n         pingSend = true;\n     }\n@@ -4327,14 +4352,14 @@ void PeerManagerImpl::MaybeSendPing(CNode& node_to)\n         while (nonce == 0) {\n             GetRandBytes((unsigned char*)&nonce, sizeof(nonce));\n         }\n-        node_to.fPingQueued = false;\n-        node_to.m_ping_start = now;\n+        peer.fPingQueued = false;\n+        peer.m_ping_start = now;\n         if (node_to.GetCommonVersion() > BIP0031_VERSION) {\n-            node_to.nPingNonceSent = nonce;\n+            peer.nPingNonceSent = nonce;\n             m_connman.PushMessage(&node_to, msgMaker.Make(NetMsgType::PING, nonce));\n         } else {\n             // Peer is too old to support ping command with nonce, pong will never arrive.\n-            node_to.nPingNonceSent = 0;\n+            peer.nPingNonceSent = 0;\n             m_connman.PushMessage(&node_to, msgMaker.Make(NetMsgType::PING));\n         }\n     }\n@@ -4378,7 +4403,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n     // If we get here, the outgoing message serialization version is set and can't change.\n     const CNetMsgMaker msgMaker(pto->GetCommonVersion());\n \n-    MaybeSendPing(*pto);\n+    MaybeSendPing(*pto, *peer);\n \n     // MaybeSendPing may have marked peer for disconnection\n     if (pto->fDisconnect) return true;"
      },
      {
        "sha": "d7be453df5a1df3fc6a30b75aa4756df4063c088",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/45dcf2266125c65d7f546bdb211a278bd090a284/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/45dcf2266125c65d7f546bdb211a278bd090a284/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=45dcf2266125c65d7f546bdb211a278bd090a284",
        "patch": "@@ -30,6 +30,7 @@ struct CNodeStateStats {\n     int nSyncHeight = -1;\n     int nCommonHeight = -1;\n     int m_starting_height = -1;\n+    int64_t m_ping_wait_usec;\n     std::vector<int> vHeightInFlight;\n };\n \n@@ -47,6 +48,9 @@ class PeerManager : public CValidationInterface, public NetEventsInterface\n     /** Whether this node ignores txs received over p2p. */\n     virtual bool IgnoresIncomingTxs() = 0;\n \n+    /** Send ping message to all peers */\n+    virtual void SendPings() = 0;\n+\n     /** Set the best height */\n     virtual void SetBestHeight(int height) = 0;\n "
      },
      {
        "sha": "ea12ce1583cc6d62c6a8e582885e89d746053e2b",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/45dcf2266125c65d7f546bdb211a278bd090a284/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/45dcf2266125c65d7f546bdb211a278bd090a284/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=45dcf2266125c65d7f546bdb211a278bd090a284",
        "patch": "@@ -1115,7 +1115,6 @@ void RPCConsole::updateDetailWidget()\n     ui->peerBytesRecv->setText(GUIUtil::formatBytes(stats->nodeStats.nRecvBytes));\n     ui->peerConnTime->setText(GUIUtil::formatDurationStr(GetSystemTimeInSeconds() - stats->nodeStats.nTimeConnected));\n     ui->peerPingTime->setText(GUIUtil::formatPingTime(stats->nodeStats.m_ping_usec));\n-    ui->peerPingWait->setText(GUIUtil::formatPingTime(stats->nodeStats.m_ping_wait_usec));\n     ui->peerMinPing->setText(GUIUtil::formatPingTime(stats->nodeStats.m_min_ping_usec));\n     ui->timeoffset->setText(GUIUtil::formatTimeOffset(stats->nodeStats.nTimeOffset));\n     ui->peerVersion->setText(QString::number(stats->nodeStats.nVersion));\n@@ -1149,6 +1148,7 @@ void RPCConsole::updateDetailWidget()\n             ui->peerCommonHeight->setText(tr(\"Unknown\"));\n \n         ui->peerHeight->setText(QString::number(stats->nodeStateStats.m_starting_height));\n+        ui->peerPingWait->setText(GUIUtil::formatPingTime(stats->nodeStateStats.m_ping_wait_usec));\n     }\n \n     ui->detailWidget->show();"
      },
      {
        "sha": "0224ee697aaf73c556cf4291e06dce6bf8bc42fd",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/45dcf2266125c65d7f546bdb211a278bd090a284/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/45dcf2266125c65d7f546bdb211a278bd090a284/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=45dcf2266125c65d7f546bdb211a278bd090a284",
        "patch": "@@ -77,13 +77,12 @@ static RPCHelpMan ping()\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n     NodeContext& node = EnsureNodeContext(request.context);\n-    if(!node.connman)\n+    if (!node.peerman) {\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n+    }\n \n     // Request that each node send a ping during next message processing pass\n-    node.connman->ForEachNode([](CNode* pnode) {\n-        pnode->fPingQueued = true;\n-    });\n+    node.peerman->SendPings();\n     return NullUniValue;\n },\n     };\n@@ -209,8 +208,8 @@ static RPCHelpMan getpeerinfo()\n         if (stats.m_min_ping_usec < std::numeric_limits<int64_t>::max()) {\n             obj.pushKV(\"minping\", ((double)stats.m_min_ping_usec) / 1e6);\n         }\n-        if (stats.m_ping_wait_usec > 0) {\n-            obj.pushKV(\"pingwait\", ((double)stats.m_ping_wait_usec) / 1e6);\n+        if (fStateStats && statestats.m_ping_wait_usec > 0) {\n+            obj.pushKV(\"pingwait\", ((double)statestats.m_ping_wait_usec) / 1e6);\n         }\n         obj.pushKV(\"version\", stats.nVersion);\n         // Use the sanitized form of subver here, to avoid tricksy remote peers from"
      }
    ]
  },
  {
    "sha": "a5e15ae45ccae7948a6c5b95e6621f01afb88d55",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNWUxNWFlNDVjY2FlNzk0OGE2YzViOTVlNjYyMWYwMWFmYjg4ZDU1",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2020-07-11T17:20:10Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-02-15T16:15:51Z"
      },
      "message": "scripted-diff: rename ping members\n\n-BEGIN VERIFY SCRIPT-\nsed -i 's/fPingQueued/m_ping_queued/g' src/net_processing.cpp\nsed -i 's/nMinPingUsecTime/m_min_ping_time/g' src/net.* src/net_processing.cpp src/test/net_tests.cpp\nsed -i 's/nPingNonceSent/m_ping_nonce_sent/g' src/net_processing.cpp\nsed -i 's/nPingUsecTime/m_last_ping_time/g' src/net.*\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "40ccdb40060c6eb76f8bb1a55f396f85842d3cd7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/40ccdb40060c6eb76f8bb1a55f396f85842d3cd7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a5e15ae45ccae7948a6c5b95e6621f01afb88d55",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a5e15ae45ccae7948a6c5b95e6621f01afb88d55",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a5e15ae45ccae7948a6c5b95e6621f01afb88d55",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a5e15ae45ccae7948a6c5b95e6621f01afb88d55/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "45dcf2266125c65d7f546bdb211a278bd090a284",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/45dcf2266125c65d7f546bdb211a278bd090a284",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/45dcf2266125c65d7f546bdb211a278bd090a284"
      }
    ],
    "stats": {
      "total": 52,
      "additions": 26,
      "deletions": 26
    },
    "files": [
      {
        "sha": "81176785a27e34d4dadc563599dd77fb916f3ade",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5e15ae45ccae7948a6c5b95e6621f01afb88d55/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5e15ae45ccae7948a6c5b95e6621f01afb88d55/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=a5e15ae45ccae7948a6c5b95e6621f01afb88d55",
        "patch": "@@ -601,8 +601,8 @@ void CNode::copyStats(CNodeStats &stats, const std::vector<bool> &m_asmap)\n         stats.minFeeFilter = 0;\n     }\n \n-    stats.m_ping_usec = nPingUsecTime;\n-    stats.m_min_ping_usec = nMinPingUsecTime;\n+    stats.m_ping_usec = m_last_ping_time;\n+    stats.m_min_ping_usec = m_min_ping_time;\n \n     // Leave string empty if addrLocal invalid (not filled in yet)\n     CService addrLocalUnlocked = GetAddrLocal();\n@@ -824,7 +824,7 @@ size_t CConnman::SocketSendData(CNode& node) const\n \n static bool ReverseCompareNodeMinPingTime(const NodeEvictionCandidate &a, const NodeEvictionCandidate &b)\n {\n-    return a.nMinPingUsecTime > b.nMinPingUsecTime;\n+    return a.m_min_ping_time > b.m_min_ping_time;\n }\n \n static bool ReverseCompareNodeTimeConnected(const NodeEvictionCandidate &a, const NodeEvictionCandidate &b)\n@@ -979,7 +979,7 @@ bool CConnman::AttemptToEvictConnection()\n                 peer_relay_txes = node->m_tx_relay->fRelayTxes;\n                 peer_filter_not_null = node->m_tx_relay->pfilter != nullptr;\n             }\n-            NodeEvictionCandidate candidate = {node->GetId(), node->nTimeConnected, node->nMinPingUsecTime,\n+            NodeEvictionCandidate candidate = {node->GetId(), node->nTimeConnected, node->m_min_ping_time,\n                                                node->nLastBlockTime, node->nLastTXTime,\n                                                HasAllDesirableServiceFlags(node->nServices),\n                                                peer_relay_txes, peer_filter_not_null, node->nKeyedNetGroup,"
      },
      {
        "sha": "682150d65aa4cf1f8f7f7187db293a5028a84575",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5e15ae45ccae7948a6c5b95e6621f01afb88d55/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5e15ae45ccae7948a6c5b95e6621f01afb88d55/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=a5e15ae45ccae7948a6c5b95e6621f01afb88d55",
        "patch": "@@ -591,11 +591,11 @@ class CNode\n     std::atomic<int64_t> nLastTXTime{0};\n \n     /** Last measured round-trip time. Used only for RPC/GUI stats/debugging.*/\n-    std::atomic<int64_t> nPingUsecTime{0};\n+    std::atomic<int64_t> m_last_ping_time{0};\n \n     /** Lowest measured round-trip time. Used as an inbound peer eviction\n      * criterium in CConnman::AttemptToEvictConnection. */\n-    std::atomic<int64_t> nMinPingUsecTime{std::numeric_limits<int64_t>::max()};\n+    std::atomic<int64_t> m_min_ping_time{std::numeric_limits<int64_t>::max()};\n \n     CNode(NodeId id, ServiceFlags nLocalServicesIn, SOCKET hSocketIn, const CAddress& addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const CAddress& addrBindIn, const std::string& addrNameIn, ConnectionType conn_type_in, bool inbound_onion);\n     ~CNode();\n@@ -717,8 +717,8 @@ class CNode\n \n     /** A ping-pong round trip has completed successfully. Update latest and minimum ping times. */\n     void PongReceived(std::chrono::microseconds ping_time) {\n-        nPingUsecTime = count_microseconds(ping_time);\n-        nMinPingUsecTime = std::min(nMinPingUsecTime.load(), count_microseconds(ping_time));\n+        m_last_ping_time = count_microseconds(ping_time);\n+        m_min_ping_time = std::min(m_min_ping_time.load(), count_microseconds(ping_time));\n     }\n \n private:\n@@ -1253,7 +1253,7 @@ struct NodeEvictionCandidate\n {\n     NodeId id;\n     int64_t nTimeConnected;\n-    int64_t nMinPingUsecTime;\n+    int64_t m_min_ping_time;\n     int64_t nLastBlockTime;\n     int64_t nLastTXTime;\n     bool fRelevantServices;"
      },
      {
        "sha": "881f5d7297628a04754655e5792094f134ce2676",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5e15ae45ccae7948a6c5b95e6621f01afb88d55/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5e15ae45ccae7948a6c5b95e6621f01afb88d55/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=a5e15ae45ccae7948a6c5b95e6621f01afb88d55",
        "patch": "@@ -220,11 +220,11 @@ struct Peer {\n     std::atomic<int> m_starting_height{-1};\n \n     /** The pong reply we're expecting, or 0 if no pong expected. */\n-    std::atomic<uint64_t> nPingNonceSent{0};\n+    std::atomic<uint64_t> m_ping_nonce_sent{0};\n     /** When the last ping was sent, or 0 if no ping was ever sent */\n     std::atomic<std::chrono::microseconds> m_ping_start{0us};\n     /** Whether a ping has been requested by the user */\n-    std::atomic<bool> fPingQueued{false};\n+    std::atomic<bool> m_ping_queued{false};\n \n     /** Set of txids to reconsider once their parent transactions have been accepted **/\n     std::set<uint256> m_orphan_work_set GUARDED_BY(g_cs_orphans);\n@@ -1108,7 +1108,7 @@ bool PeerManagerImpl::GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats)\n     // So, if a ping is taking an unusually long time in flight,\n     // the caller can immediately detect that this is happening.\n     std::chrono::microseconds ping_wait{0};\n-    if ((0 != peer->nPingNonceSent) && (0 != peer->m_ping_start.load().count())) {\n+    if ((0 != peer->m_ping_nonce_sent) && (0 != peer->m_ping_start.load().count())) {\n         ping_wait = GetTime<std::chrono::microseconds>() - peer->m_ping_start.load();\n     }\n \n@@ -1655,7 +1655,7 @@ bool static AlreadyHaveBlock(const uint256& block_hash) EXCLUSIVE_LOCKS_REQUIRED\n void PeerManagerImpl::SendPings()\n {\n     LOCK(m_peer_mutex);\n-    for(auto& it : m_peer_map) it.second->fPingQueued = true;\n+    for(auto& it : m_peer_map) it.second->m_ping_queued = true;\n }\n \n void RelayTransaction(const uint256& txid, const uint256& wtxid, const CConnman& connman)\n@@ -3868,8 +3868,8 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             vRecv >> nonce;\n \n             // Only process pong message if there is an outstanding ping (old ping without nonce should never pong)\n-            if (peer->nPingNonceSent != 0) {\n-                if (nonce == peer->nPingNonceSent) {\n+            if (peer->m_ping_nonce_sent != 0) {\n+                if (nonce == peer->m_ping_nonce_sent) {\n                     // Matching pong received, this ping is no longer outstanding\n                     bPingFinished = true;\n                     const auto ping_time = ping_end - peer->m_ping_start.load();\n@@ -3902,12 +3902,12 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             LogPrint(BCLog::NET, \"pong peer=%d: %s, %x expected, %x received, %u bytes\\n\",\n                 pfrom.GetId(),\n                 sProblem,\n-                peer->nPingNonceSent,\n+                peer->m_ping_nonce_sent,\n                 nonce,\n                 nAvail);\n         }\n         if (bPingFinished) {\n-            peer->nPingNonceSent = 0;\n+            peer->m_ping_nonce_sent = 0;\n         }\n         return;\n     }\n@@ -4327,7 +4327,7 @@ void PeerManagerImpl::MaybeSendPing(CNode& node_to, Peer& peer)\n     // This means that setmocktime may cause pings to time out.\n     auto now = GetTime<std::chrono::microseconds>();\n \n-    if (m_connman.RunInactivityChecks(node_to) && peer.nPingNonceSent &&\n+    if (m_connman.RunInactivityChecks(node_to) && peer.m_ping_nonce_sent &&\n         now > peer.m_ping_start.load() + std::chrono::seconds{TIMEOUT_INTERVAL}) {\n         LogPrint(BCLog::NET, \"ping timeout: %fs peer=%d\\n\", 0.000001 * count_microseconds(now - peer.m_ping_start.load()), peer.m_id);\n         node_to.fDisconnect = true;\n@@ -4337,12 +4337,12 @@ void PeerManagerImpl::MaybeSendPing(CNode& node_to, Peer& peer)\n     const CNetMsgMaker msgMaker(node_to.GetCommonVersion());\n     bool pingSend = false;\n \n-    if (peer.fPingQueued) {\n+    if (peer.m_ping_queued) {\n         // RPC ping request by user\n         pingSend = true;\n     }\n \n-    if (peer.nPingNonceSent == 0 && now > peer.m_ping_start.load() + PING_INTERVAL) {\n+    if (peer.m_ping_nonce_sent == 0 && now > peer.m_ping_start.load() + PING_INTERVAL) {\n         // Ping automatically sent as a latency probe & keepalive.\n         pingSend = true;\n     }\n@@ -4352,14 +4352,14 @@ void PeerManagerImpl::MaybeSendPing(CNode& node_to, Peer& peer)\n         while (nonce == 0) {\n             GetRandBytes((unsigned char*)&nonce, sizeof(nonce));\n         }\n-        peer.fPingQueued = false;\n+        peer.m_ping_queued = false;\n         peer.m_ping_start = now;\n         if (node_to.GetCommonVersion() > BIP0031_VERSION) {\n-            peer.nPingNonceSent = nonce;\n+            peer.m_ping_nonce_sent = nonce;\n             m_connman.PushMessage(&node_to, msgMaker.Make(NetMsgType::PING, nonce));\n         } else {\n             // Peer is too old to support ping command with nonce, pong will never arrive.\n-            peer.nPingNonceSent = 0;\n+            peer.m_ping_nonce_sent = 0;\n             m_connman.PushMessage(&node_to, msgMaker.Make(NetMsgType::PING));\n         }\n     }"
      },
      {
        "sha": "f52905e1ef3955267f865f9ac1819975a9ad22b0",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5e15ae45ccae7948a6c5b95e6621f01afb88d55/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5e15ae45ccae7948a6c5b95e6621f01afb88d55/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=a5e15ae45ccae7948a6c5b95e6621f01afb88d55",
        "patch": "@@ -794,7 +794,7 @@ std::vector<NodeEvictionCandidate> GetRandomNodeEvictionCandidates(const int n_c\n         candidates.push_back({\n             /* id */ id,\n             /* nTimeConnected */ static_cast<int64_t>(random_context.randrange(100)),\n-            /* nMinPingUsecTime */ static_cast<int64_t>(random_context.randrange(100)),\n+            /* m_min_ping_time */ static_cast<int64_t>(random_context.randrange(100)),\n             /* nLastBlockTime */ static_cast<int64_t>(random_context.randrange(100)),\n             /* nLastTXTime */ static_cast<int64_t>(random_context.randrange(100)),\n             /* fRelevantServices */ random_context.randbool(),\n@@ -854,7 +854,7 @@ BOOST_AUTO_TEST_CASE(node_eviction_test)\n             // from eviction.\n             BOOST_CHECK(!IsEvicted(\n                 number_of_nodes, [](NodeEvictionCandidate& candidate) {\n-                    candidate.nMinPingUsecTime = candidate.id;\n+                    candidate.m_min_ping_time = candidate.id;\n                 },\n                 {0, 1, 2, 3, 4, 5, 6, 7}, random_context));\n \n@@ -901,7 +901,7 @@ BOOST_AUTO_TEST_CASE(node_eviction_test)\n             BOOST_CHECK(!IsEvicted(\n                 number_of_nodes, [number_of_nodes](NodeEvictionCandidate& candidate) {\n                     candidate.nKeyedNetGroup = number_of_nodes - candidate.id; // 4 protected\n-                    candidate.nMinPingUsecTime = candidate.id;                 // 8 protected\n+                    candidate.m_min_ping_time = candidate.id;                 // 8 protected\n                     candidate.nLastTXTime = number_of_nodes - candidate.id;    // 4 protected\n                     candidate.nLastBlockTime = number_of_nodes - candidate.id; // 4 protected\n                 },"
      }
    ]
  }
]