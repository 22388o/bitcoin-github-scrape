[
  {
    "sha": "700c42b85d20e624bef4228eef062c93084efab5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3MDBjNDJiODVkMjBlNjI0YmVmNDIyOGVlZjA2MmM5MzA4NGVmYWI1",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2017-07-27T14:08:31Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2019-01-15T16:42:00Z"
      },
      "message": "Add height, depth, and hash methods to the Chain interface\n\nAnd use them to remove uses of chainActive and mapBlockIndex in wallet code\n\nThis commit does not change behavior.\n\nCo-authored-by: Ben Woosley <ben.woosley@gmail.com>",
      "tree": {
        "sha": "60f0213d9b6671995ae6e7d2015d57ffdda89f4b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/60f0213d9b6671995ae6e7d2015d57ffdda89f4b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/700c42b85d20e624bef4228eef062c93084efab5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/700c42b85d20e624bef4228eef062c93084efab5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/700c42b85d20e624bef4228eef062c93084efab5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/700c42b85d20e624bef4228eef062c93084efab5/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "eb2aecfb80662a91c649ea1455d9812ced05c323",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eb2aecfb80662a91c649ea1455d9812ced05c323",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/eb2aecfb80662a91c649ea1455d9812ced05c323"
      }
    ],
    "stats": {
      "total": 131,
      "additions": 96,
      "deletions": 35
    },
    "files": [
      {
        "sha": "4a98a2c1d8cb90d6b804bcf187eb401bf09a5930",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/700c42b85d20e624bef4228eef062c93084efab5/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/700c42b85d20e624bef4228eef062c93084efab5/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=700c42b85d20e624bef4228eef062c93084efab5",
        "patch": "@@ -145,6 +145,7 @@ BITCOIN_CORE_H = \\\n   netbase.h \\\n   netmessagemaker.h \\\n   noui.h \\\n+  optional.h \\\n   outputtype.h \\\n   policy/feerate.h \\\n   policy/fees.h \\"
      },
      {
        "sha": "138d1bfd5fc31a3c595297b222f65f4cfba1d261",
        "filename": "src/interfaces/chain.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 0,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/700c42b85d20e624bef4228eef062c93084efab5/src/interfaces/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/700c42b85d20e624bef4228eef062c93084efab5/src/interfaces/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.cpp?ref=700c42b85d20e624bef4228eef062c93084efab5",
        "patch": "@@ -4,7 +4,9 @@\n \n #include <interfaces/chain.h>\n \n+#include <chain.h>\n #include <sync.h>\n+#include <uint256.h>\n #include <util/system.h>\n #include <validation.h>\n \n@@ -16,6 +18,34 @@ namespace {\n \n class LockImpl : public Chain::Lock\n {\n+    Optional<int> getHeight() override\n+    {\n+        int height = ::chainActive.Height();\n+        if (height >= 0) {\n+            return height;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> getBlockHeight(const uint256& hash) override\n+    {\n+        CBlockIndex* block = LookupBlockIndex(hash);\n+        if (block && ::chainActive.Contains(block)) {\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    int getBlockDepth(const uint256& hash) override\n+    {\n+        const Optional<int> tip_height = getHeight();\n+        const Optional<int> height = getBlockHeight(hash);\n+        return tip_height && height ? *tip_height - *height + 1 : 0;\n+    }\n+    uint256 getBlockHash(int height) override\n+    {\n+        CBlockIndex* block = ::chainActive[height];\n+        assert(block != nullptr);\n+        return block->GetBlockHash();\n+    }\n };\n \n class LockingStateImpl : public LockImpl, public UniqueLock<CCriticalSection>"
      },
      {
        "sha": "928b8af1f4506ef823238931698d94216991924d",
        "filename": "src/interfaces/chain.h",
        "status": "modified",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/700c42b85d20e624bef4228eef062c93084efab5/src/interfaces/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/700c42b85d20e624bef4228eef062c93084efab5/src/interfaces/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.h?ref=700c42b85d20e624bef4228eef062c93084efab5",
        "patch": "@@ -5,11 +5,14 @@\n #ifndef BITCOIN_INTERFACES_CHAIN_H\n #define BITCOIN_INTERFACES_CHAIN_H\n \n+#include <optional.h>\n+\n #include <memory>\n #include <string>\n #include <vector>\n \n class CScheduler;\n+class uint256;\n \n namespace interfaces {\n \n@@ -28,6 +31,23 @@ class Chain\n     {\n     public:\n         virtual ~Lock() {}\n+\n+        //! Get current chain height, not including genesis block (returns 0 if\n+        //! chain only contains genesis block, nullopt if chain does not contain\n+        //! any blocks).\n+        virtual Optional<int> getHeight() = 0;\n+\n+        //! Get block height above genesis block. Returns 0 for genesis block,\n+        //! 1 for following block, and so on. Returns nullopt for a block not\n+        //! included in the current chain.\n+        virtual Optional<int> getBlockHeight(const uint256& hash) = 0;\n+\n+        //! Get block depth. Returns 1 for chain tip, 2 for preceding block, and\n+        //! so on. Returns 0 for a block not included in the current chain.\n+        virtual int getBlockDepth(const uint256& hash) = 0;\n+\n+        //! Get block hash. Height must be valid or this function will abort.\n+        virtual uint256 getBlockHash(int height) = 0;\n     };\n \n     //! Return Lock interface. Chain is locked when this is called, and"
      },
      {
        "sha": "489cf0981c2490f5fc7777a58e992cfe3d1702f2",
        "filename": "src/interfaces/wallet.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/700c42b85d20e624bef4228eef062c93084efab5/src/interfaces/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/700c42b85d20e624bef4228eef062c93084efab5/src/interfaces/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/wallet.cpp?ref=700c42b85d20e624bef4228eef062c93084efab5",
        "patch": "@@ -333,7 +333,7 @@ class WalletImpl : public Wallet\n         if (mi == m_wallet.mapWallet.end()) {\n             return false;\n         }\n-        num_blocks = ::chainActive.Height();\n+        num_blocks = locked_chain->getHeight().value_or(-1);\n         block_time = ::chainActive.Tip()->GetBlockTime();\n         tx_status = MakeWalletTxStatus(*locked_chain, mi->second);\n         return true;\n@@ -348,7 +348,7 @@ class WalletImpl : public Wallet\n         LOCK(m_wallet.cs_wallet);\n         auto mi = m_wallet.mapWallet.find(txid);\n         if (mi != m_wallet.mapWallet.end()) {\n-            num_blocks = ::chainActive.Height();\n+            num_blocks = locked_chain->getHeight().value_or(-1);\n             in_mempool = mi->second.InMempool();\n             order_form = mi->second.vOrderForm;\n             tx_status = MakeWalletTxStatus(*locked_chain, mi->second);\n@@ -379,7 +379,7 @@ class WalletImpl : public Wallet\n             return false;\n         }\n         balances = getBalances();\n-        num_blocks = ::chainActive.Height();\n+        num_blocks = locked_chain->getHeight().value_or(-1);\n         return true;\n     }\n     CAmount getBalance() override { return m_wallet.GetBalance(); }"
      },
      {
        "sha": "1614c8971836dab928db45c3d39a0d34a5cdcc27",
        "filename": "src/optional.h",
        "status": "added",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/700c42b85d20e624bef4228eef062c93084efab5/src/optional.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/700c42b85d20e624bef4228eef062c93084efab5/src/optional.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/optional.h?ref=700c42b85d20e624bef4228eef062c93084efab5",
        "patch": "@@ -0,0 +1,17 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_OPTIONAL_H\n+#define BITCOIN_OPTIONAL_H\n+\n+#include <boost/optional.hpp>\n+\n+//! Substitute for C++17 std::optional\n+template <typename T>\n+using Optional = boost::optional<T>;\n+\n+//! Substitute for C++17 std::nullopt\n+static auto& nullopt = boost::none;\n+\n+#endif // BITCOIN_OPTIONAL_H"
      },
      {
        "sha": "f2b91e7c3d9ba7c083bc96669316a0e3d046309a",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/700c42b85d20e624bef4228eef062c93084efab5/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/700c42b85d20e624bef4228eef062c93084efab5/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=700c42b85d20e624bef4228eef062c93084efab5",
        "patch": "@@ -379,8 +379,7 @@ UniValue importprunedfunds(const JSONRPCRequest& request)\n     if (merkleBlock.txn.ExtractMatches(vMatch, vIndex) == merkleBlock.header.hashMerkleRoot) {\n \n         auto locked_chain = pwallet->chain().lock();\n-        const CBlockIndex* pindex = LookupBlockIndex(merkleBlock.header.GetHash());\n-        if (!pindex || !chainActive.Contains(pindex)) {\n+        if (locked_chain->getBlockHeight(merkleBlock.header.GetHash()) == nullopt) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found in chain\");\n         }\n \n@@ -773,7 +772,8 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     // produce output\n     file << strprintf(\"# Wallet dump created by Bitcoin %s\\n\", CLIENT_BUILD);\n     file << strprintf(\"# * Created on %s\\n\", FormatISO8601DateTime(GetTime()));\n-    file << strprintf(\"# * Best block at time of backup was %i (%s),\\n\", chainActive.Height(), chainActive.Tip()->GetBlockHash().ToString());\n+    const Optional<int> tip_height = locked_chain->getHeight();\n+    file << strprintf(\"# * Best block at time of backup was %i (%s),\\n\", tip_height.value_or(-1), tip_height ? locked_chain->getBlockHash(*tip_height).ToString() : \"(missing block hash)\");\n     file << strprintf(\"#   mined on %s\\n\", FormatISO8601DateTime(chainActive.Tip()->GetBlockTime()));\n     file << \"\\n\";\n "
      },
      {
        "sha": "c835d2928d40ff71e8d7accc98d858298148b465",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/700c42b85d20e624bef4228eef062c93084efab5/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/700c42b85d20e624bef4228eef062c93084efab5/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=700c42b85d20e624bef4228eef062c93084efab5",
        "patch": "@@ -1607,7 +1607,8 @@ static UniValue listsinceblock(const JSONRPCRequest& request)\n \n     bool include_removed = (request.params[3].isNull() || request.params[3].get_bool());\n \n-    int depth = pindex ? (1 + chainActive.Height() - pindex->nHeight) : -1;\n+    const Optional<int> tip_height = locked_chain->getHeight();\n+    int depth = tip_height && pindex ? (1 + *tip_height - pindex->nHeight) : -1;\n \n     UniValue transactions(UniValue::VARR);\n \n@@ -1638,8 +1639,8 @@ static UniValue listsinceblock(const JSONRPCRequest& request)\n         paltindex = paltindex->pprev;\n     }\n \n-    CBlockIndex *pblockLast = chainActive[chainActive.Height() + 1 - target_confirms];\n-    uint256 lastblock = pblockLast ? pblockLast->GetBlockHash() : uint256();\n+    int last_height = tip_height ? *tip_height + 1 - target_confirms : -1;\n+    uint256 lastblock = last_height >= 0 ? locked_chain->getBlockHash(last_height) : uint256();\n \n     UniValue ret(UniValue::VOBJ);\n     ret.pushKV(\"transactions\", transactions);"
      },
      {
        "sha": "4377e9f29da7ef905bbfca60f4202577e331a8de",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/700c42b85d20e624bef4228eef062c93084efab5/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/700c42b85d20e624bef4228eef062c93084efab5/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=700c42b85d20e624bef4228eef062c93084efab5",
        "patch": "@@ -276,7 +276,7 @@ static int64_t AddTx(CWallet& wallet, uint32_t lockTime, int64_t mockTime, int64\n \n     CWalletTx wtx(&wallet, MakeTransactionRef(tx));\n     if (block) {\n-        wtx.SetMerkleBranch(block, 0);\n+        wtx.SetMerkleBranch(block->GetBlockHash(), 0);\n     }\n     {\n         LOCK(cs_main);\n@@ -372,7 +372,7 @@ class ListCoinsTestingSetup : public TestChain100Setup\n         LOCK(wallet->cs_wallet);\n         auto it = wallet->mapWallet.find(tx->GetHash());\n         BOOST_CHECK(it != wallet->mapWallet.end());\n-        it->second.SetMerkleBranch(chainActive.Tip(), 1);\n+        it->second.SetMerkleBranch(chainActive.Tip()->GetBlockHash(), 1);\n         return it->second;\n     }\n "
      },
      {
        "sha": "c34295a11af95307d563ba0c367ccf099aae4f3a",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 22,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/700c42b85d20e624bef4228eef062c93084efab5/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/700c42b85d20e624bef4228eef062c93084efab5/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=700c42b85d20e624bef4228eef062c93084efab5",
        "patch": "@@ -935,19 +935,19 @@ void CWallet::LoadToWallet(const CWalletTx& wtxIn)\n     }\n }\n \n-bool CWallet::AddToWalletIfInvolvingMe(const CTransactionRef& ptx, const CBlockIndex* pIndex, int posInBlock, bool fUpdate)\n+bool CWallet::AddToWalletIfInvolvingMe(const CTransactionRef& ptx, const uint256& block_hash, int posInBlock, bool fUpdate)\n {\n     const CTransaction& tx = *ptx;\n     {\n         AssertLockHeld(cs_wallet);\n \n-        if (pIndex != nullptr) {\n+        if (!block_hash.IsNull()) {\n             for (const CTxIn& txin : tx.vin) {\n                 std::pair<TxSpends::const_iterator, TxSpends::const_iterator> range = mapTxSpends.equal_range(txin.prevout);\n                 while (range.first != range.second) {\n                     if (range.first->second != tx.GetHash()) {\n-                        WalletLogPrintf(\"Transaction %s (in block %s) conflicts with wallet transaction %s (both spend %s:%i)\\n\", tx.GetHash().ToString(), pIndex->GetBlockHash().ToString(), range.first->second.ToString(), range.first->first.hash.ToString(), range.first->first.n);\n-                        MarkConflicted(pIndex->GetBlockHash(), range.first->second);\n+                        WalletLogPrintf(\"Transaction %s (in block %s) conflicts with wallet transaction %s (both spend %s:%i)\\n\", tx.GetHash().ToString(), block_hash.ToString(), range.first->second.ToString(), range.first->first.hash.ToString(), range.first->first.n);\n+                        MarkConflicted(block_hash, range.first->second);\n                     }\n                     range.first++;\n                 }\n@@ -983,8 +983,8 @@ bool CWallet::AddToWalletIfInvolvingMe(const CTransactionRef& ptx, const CBlockI\n             CWalletTx wtx(this, ptx);\n \n             // Get merkle branch if transaction was found in a block\n-            if (pIndex != nullptr)\n-                wtx.SetMerkleBranch(pIndex, posInBlock);\n+            if (!block_hash.IsNull())\n+                wtx.SetMerkleBranch(block_hash, posInBlock);\n \n             return AddToWallet(wtx, false);\n         }\n@@ -1071,11 +1071,7 @@ void CWallet::MarkConflicted(const uint256& hashBlock, const uint256& hashTx)\n     auto locked_chain = chain().lock();\n     LOCK(cs_wallet);\n \n-    int conflictconfirms = 0;\n-    CBlockIndex* pindex = LookupBlockIndex(hashBlock);\n-    if (pindex && chainActive.Contains(pindex)) {\n-        conflictconfirms = -(chainActive.Height() - pindex->nHeight + 1);\n-    }\n+    int conflictconfirms = -locked_chain->getBlockDepth(hashBlock);\n     // If number of conflict confirms cannot be determined, this means\n     // that the block is still unknown or not yet part of the main chain,\n     // for example when loading the wallet during a reindex. Do nothing in that\n@@ -1122,7 +1118,7 @@ void CWallet::MarkConflicted(const uint256& hashBlock, const uint256& hashTx)\n }\n \n void CWallet::SyncTransaction(const CTransactionRef& ptx, const CBlockIndex *pindex, int posInBlock, bool update_tx) {\n-    if (!AddToWalletIfInvolvingMe(ptx, pindex, posInBlock, update_tx))\n+    if (!AddToWalletIfInvolvingMe(ptx, pindex->GetBlockHash(), posInBlock, update_tx))\n         return; // Not one of ours\n \n     // If a transaction changes 'conflicted' state, that changes the balance\n@@ -2573,6 +2569,7 @@ static bool IsCurrentForAntiFeeSniping(interfaces::Chain::Lock& locked_chain)\n  */\n static uint32_t GetLocktimeForNewTransaction(interfaces::Chain::Lock& locked_chain)\n {\n+    uint32_t const height = locked_chain.getHeight().value_or(-1);\n     uint32_t locktime;\n     // Discourage fee sniping.\n     //\n@@ -2595,7 +2592,7 @@ static uint32_t GetLocktimeForNewTransaction(interfaces::Chain::Lock& locked_cha\n     // now we ensure code won't be written that makes assumptions about\n     // nLockTime that preclude a fix later.\n     if (IsCurrentForAntiFeeSniping(locked_chain)) {\n-        locktime = chainActive.Height();\n+        locktime = height;\n \n         // Secondly occasionally randomly pick a nLockTime even further back, so\n         // that transactions that are delayed after signing for whatever reason,\n@@ -2609,7 +2606,7 @@ static uint32_t GetLocktimeForNewTransaction(interfaces::Chain::Lock& locked_cha\n         // unique \"nLockTime fingerprint\", set nLockTime to a constant.\n         locktime = 0;\n     }\n-    assert(locktime <= (unsigned int)chainActive.Height());\n+    assert(locktime <= height);\n     assert(locktime < LOCKTIME_THRESHOLD);\n     return locktime;\n }\n@@ -4282,10 +4279,10 @@ CWalletKey::CWalletKey(int64_t nExpires)\n     nTimeExpires = nExpires;\n }\n \n-void CMerkleTx::SetMerkleBranch(const CBlockIndex* pindex, int posInBlock)\n+void CMerkleTx::SetMerkleBranch(const uint256& block_hash, int posInBlock)\n {\n     // Update the tx's hashBlock\n-    hashBlock = pindex->GetBlockHash();\n+    hashBlock = block_hash;\n \n     // set the position of the transaction in the block\n     nIndex = posInBlock;\n@@ -4298,12 +4295,7 @@ int CMerkleTx::GetDepthInMainChain(interfaces::Chain::Lock& locked_chain) const\n \n     AssertLockHeld(cs_main);\n \n-    // Find the block it claims to be in\n-    CBlockIndex* pindex = LookupBlockIndex(hashBlock);\n-    if (!pindex || !chainActive.Contains(pindex))\n-        return 0;\n-\n-    return ((nIndex == -1) ? (-1) : 1) * (chainActive.Height() - pindex->nHeight + 1);\n+    return locked_chain.getBlockDepth(hashBlock) * (nIndex == -1 ? -1 : 1);\n }\n \n int CMerkleTx::GetBlocksToMaturity(interfaces::Chain::Lock& locked_chain) const"
      },
      {
        "sha": "d8981f7385d76c885d16cdaaa24ac8180777658a",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/700c42b85d20e624bef4228eef062c93084efab5/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/700c42b85d20e624bef4228eef062c93084efab5/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=700c42b85d20e624bef4228eef062c93084efab5",
        "patch": "@@ -287,7 +287,7 @@ class CMerkleTx\n         READWRITE(nIndex);\n     }\n \n-    void SetMerkleBranch(const CBlockIndex* pIndex, int posInBlock);\n+    void SetMerkleBranch(const uint256& block_hash, int posInBlock);\n \n     /**\n      * Return depth of transaction in blockchain:\n@@ -667,7 +667,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n      * Abandoned state should probably be more carefully tracked via different\n      * posInBlock signals or by checking mempool presence when necessary.\n      */\n-    bool AddToWalletIfInvolvingMe(const CTransactionRef& tx, const CBlockIndex* pIndex, int posInBlock, bool fUpdate) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    bool AddToWalletIfInvolvingMe(const CTransactionRef& tx, const uint256& block_hash, int posInBlock, bool fUpdate) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n     /* Mark a transaction (and its in-wallet descendants) as conflicting with a particular block. */\n     void MarkConflicted(const uint256& hashBlock, const uint256& hashTx);"
      }
    ]
  },
  {
    "sha": "d93c4c1d6e0aab5f32306ecd7c1237257b26940d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkOTNjNGMxZDZlMGFhYjVmMzIzMDZlY2Q3YzEyMzcyNTdiMjY5NDBk",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2019-01-08T06:35:47Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2019-01-15T16:42:00Z"
      },
      "message": "Add time methods to the Chain interface\n\nAnd use them to remove uses of chainActive and mapBlockIndex in wallet code\n\nThis commit does not change behavior.\n\nCo-authored-by: Ben Woosley <ben.woosley@gmail.com>",
      "tree": {
        "sha": "e11259962b2fdb58049057658bf924b4266ba892",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e11259962b2fdb58049057658bf924b4266ba892"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d93c4c1d6e0aab5f32306ecd7c1237257b26940d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d93c4c1d6e0aab5f32306ecd7c1237257b26940d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d93c4c1d6e0aab5f32306ecd7c1237257b26940d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d93c4c1d6e0aab5f32306ecd7c1237257b26940d/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "700c42b85d20e624bef4228eef062c93084efab5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/700c42b85d20e624bef4228eef062c93084efab5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/700c42b85d20e624bef4228eef062c93084efab5"
      }
    ],
    "stats": {
      "total": 60,
      "additions": 43,
      "deletions": 17
    },
    "files": [
      {
        "sha": "ca2533bb1dc77495a08ec817ec81e7cd7f52096e",
        "filename": "src/interfaces/chain.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d93c4c1d6e0aab5f32306ecd7c1237257b26940d/src/interfaces/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d93c4c1d6e0aab5f32306ecd7c1237257b26940d/src/interfaces/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.cpp?ref=d93c4c1d6e0aab5f32306ecd7c1237257b26940d",
        "patch": "@@ -46,6 +46,18 @@ class LockImpl : public Chain::Lock\n         assert(block != nullptr);\n         return block->GetBlockHash();\n     }\n+    int64_t getBlockTime(int height) override\n+    {\n+        CBlockIndex* block = ::chainActive[height];\n+        assert(block != nullptr);\n+        return block->GetBlockTime();\n+    }\n+    int64_t getBlockMedianTimePast(int height) override\n+    {\n+        CBlockIndex* block = ::chainActive[height];\n+        assert(block != nullptr);\n+        return block->GetMedianTimePast();\n+    }\n };\n \n class LockingStateImpl : public LockImpl, public UniqueLock<CCriticalSection>"
      },
      {
        "sha": "1db9d3861d3c2bb90ff36f7bd0722aa54e1813f3",
        "filename": "src/interfaces/chain.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d93c4c1d6e0aab5f32306ecd7c1237257b26940d/src/interfaces/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d93c4c1d6e0aab5f32306ecd7c1237257b26940d/src/interfaces/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.h?ref=d93c4c1d6e0aab5f32306ecd7c1237257b26940d",
        "patch": "@@ -8,6 +8,7 @@\n #include <optional.h>\n \n #include <memory>\n+#include <stdint.h>\n #include <string>\n #include <vector>\n \n@@ -48,6 +49,13 @@ class Chain\n \n         //! Get block hash. Height must be valid or this function will abort.\n         virtual uint256 getBlockHash(int height) = 0;\n+\n+        //! Get block time. Height must be valid or this function will abort.\n+        virtual int64_t getBlockTime(int height) = 0;\n+\n+        //! Get block median time past. Height must be valid or this function\n+        //! will abort.\n+        virtual int64_t getBlockMedianTimePast(int height) = 0;\n     };\n \n     //! Return Lock interface. Chain is locked when this is called, and"
      },
      {
        "sha": "88c5db73a17e4681d890a35004860d7c6d8613b8",
        "filename": "src/interfaces/wallet.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 2,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d93c4c1d6e0aab5f32306ecd7c1237257b26940d/src/interfaces/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d93c4c1d6e0aab5f32306ecd7c1237257b26940d/src/interfaces/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/wallet.cpp?ref=d93c4c1d6e0aab5f32306ecd7c1237257b26940d",
        "patch": "@@ -333,8 +333,13 @@ class WalletImpl : public Wallet\n         if (mi == m_wallet.mapWallet.end()) {\n             return false;\n         }\n-        num_blocks = locked_chain->getHeight().value_or(-1);\n-        block_time = ::chainActive.Tip()->GetBlockTime();\n+        if (Optional<int> height = locked_chain->getHeight()) {\n+            num_blocks = *height;\n+            block_time = locked_chain->getBlockTime(*height);\n+        } else {\n+            num_blocks = -1;\n+            block_time = -1;\n+        }\n         tx_status = MakeWalletTxStatus(*locked_chain, mi->second);\n         return true;\n     }"
      },
      {
        "sha": "c24703968d1ce3f5742562ec95590e6f89f9b79f",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 5,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d93c4c1d6e0aab5f32306ecd7c1237257b26940d/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d93c4c1d6e0aab5f32306ecd7c1237257b26940d/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=d93c4c1d6e0aab5f32306ecd7c1237257b26940d",
        "patch": "@@ -569,7 +569,8 @@ UniValue importwallet(const JSONRPCRequest& request)\n         if (!file.is_open()) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot open wallet dump file\");\n         }\n-        nTimeBegin = chainActive.Tip()->GetBlockTime();\n+        Optional<int> tip_height = locked_chain->getHeight();\n+        nTimeBegin = tip_height ? locked_chain->getBlockTime(*tip_height) : 0;\n \n         int64_t nFilesize = std::max((int64_t)1, (int64_t)file.tellg());\n         file.seekg(0, file.beg);\n@@ -774,7 +775,7 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     file << strprintf(\"# * Created on %s\\n\", FormatISO8601DateTime(GetTime()));\n     const Optional<int> tip_height = locked_chain->getHeight();\n     file << strprintf(\"# * Best block at time of backup was %i (%s),\\n\", tip_height.value_or(-1), tip_height ? locked_chain->getBlockHash(*tip_height).ToString() : \"(missing block hash)\");\n-    file << strprintf(\"#   mined on %s\\n\", FormatISO8601DateTime(chainActive.Tip()->GetBlockTime()));\n+    file << strprintf(\"#   mined on %s\\n\", tip_height ? FormatISO8601DateTime(locked_chain->getBlockTime(*tip_height)) : \"(missing block time)\");\n     file << \"\\n\";\n \n     // add the base58check encoded extended master if the wallet uses HD\n@@ -1232,15 +1233,16 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n         EnsureWalletIsUnlocked(pwallet);\n \n         // Verify all timestamps are present before importing any keys.\n-        now = chainActive.Tip() ? chainActive.Tip()->GetMedianTimePast() : 0;\n+        const Optional<int> tip_height = locked_chain->getHeight();\n+        now = tip_height ? locked_chain->getBlockMedianTimePast(*tip_height) : 0;\n         for (const UniValue& data : requests.getValues()) {\n             GetImportTimestamp(data, now);\n         }\n \n         const int64_t minimumTimestamp = 1;\n \n-        if (fRescan && chainActive.Tip()) {\n-            nLowestTimestamp = chainActive.Tip()->GetBlockTime();\n+        if (fRescan && tip_height) {\n+            nLowestTimestamp = locked_chain->getBlockTime(*tip_height);\n         } else {\n             fRescan = false;\n         }"
      },
      {
        "sha": "35660372cf5615fc8d0e8d10275527060ae6a6a0",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 10,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d93c4c1d6e0aab5f32306ecd7c1237257b26940d/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d93c4c1d6e0aab5f32306ecd7c1237257b26940d/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=d93c4c1d6e0aab5f32306ecd7c1237257b26940d",
        "patch": "@@ -3715,11 +3715,12 @@ void CWallet::GetKeyBirthTimes(interfaces::Chain::Lock& locked_chain, std::map<C\n     }\n \n     // map in which we'll infer heights of other keys\n-    CBlockIndex *pindexMax = chainActive[std::max(0, chainActive.Height() - 144)]; // the tip can be reorganized; use a 144-block safety margin\n-    std::map<CKeyID, CBlockIndex*> mapKeyFirstBlock;\n+    const Optional<int> tip_height = locked_chain.getHeight();\n+    const int max_height = tip_height && *tip_height > 144 ? *tip_height - 144 : 0; // the tip can be reorganized; use a 144-block safety margin\n+    std::map<CKeyID, int> mapKeyFirstBlock;\n     for (const CKeyID &keyid : GetKeys()) {\n         if (mapKeyBirth.count(keyid) == 0)\n-            mapKeyFirstBlock[keyid] = pindexMax;\n+            mapKeyFirstBlock[keyid] = max_height;\n     }\n \n     // if there are no such keys, we're done\n@@ -3730,25 +3731,23 @@ void CWallet::GetKeyBirthTimes(interfaces::Chain::Lock& locked_chain, std::map<C\n     for (const auto& entry : mapWallet) {\n         // iterate over all wallet transactions...\n         const CWalletTx &wtx = entry.second;\n-        CBlockIndex* pindex = LookupBlockIndex(wtx.hashBlock);\n-        if (pindex && chainActive.Contains(pindex)) {\n+        if (Optional<int> height = locked_chain.getBlockHeight(wtx.hashBlock)) {\n             // ... which are already in a block\n-            int nHeight = pindex->nHeight;\n             for (const CTxOut &txout : wtx.tx->vout) {\n                 // iterate over all their outputs\n                 for (const auto &keyid : GetAffectedKeys(txout.scriptPubKey, *this)) {\n                     // ... and all their affected keys\n-                    std::map<CKeyID, CBlockIndex*>::iterator rit = mapKeyFirstBlock.find(keyid);\n-                    if (rit != mapKeyFirstBlock.end() && nHeight < rit->second->nHeight)\n-                        rit->second = pindex;\n+                    std::map<CKeyID, int>::iterator rit = mapKeyFirstBlock.find(keyid);\n+                    if (rit != mapKeyFirstBlock.end() && *height < rit->second)\n+                        rit->second = *height;\n                 }\n             }\n         }\n     }\n \n     // Extract block timestamps for those keys\n     for (const auto& entry : mapKeyFirstBlock)\n-        mapKeyBirth[entry.first] = entry.second->GetBlockTime() - TIMESTAMP_WINDOW; // block times can be 2h off\n+        mapKeyBirth[entry.first] = locked_chain.getBlockTime(entry.second) - TIMESTAMP_WINDOW; // block times can be 2h off\n }\n \n /**"
      }
    ]
  },
  {
    "sha": "2ffb07929ef480bd114defdc10b6a84463f222be",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyZmZiMDc5MjllZjQ4MGJkMTE0ZGVmZGMxMGI2YTg0NDYzZjIyMmJl",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2019-01-08T06:56:46Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2019-01-15T16:42:00Z"
      },
      "message": "Add findFork and findBlock to the Chain interface\n\nAnd use them to remove uses of chainActive and mapBlockIndex in wallet code\n\nThis commit does not change behavior.\n\nCo-authored-by: Ben Woosley <ben.woosley@gmail.com>",
      "tree": {
        "sha": "49199da132e8043f486a6d9702b2b22bdda9a9fc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/49199da132e8043f486a6d9702b2b22bdda9a9fc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2ffb07929ef480bd114defdc10b6a84463f222be",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2ffb07929ef480bd114defdc10b6a84463f222be",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2ffb07929ef480bd114defdc10b6a84463f222be",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2ffb07929ef480bd114defdc10b6a84463f222be/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d93c4c1d6e0aab5f32306ecd7c1237257b26940d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d93c4c1d6e0aab5f32306ecd7c1237257b26940d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d93c4c1d6e0aab5f32306ecd7c1237257b26940d"
      }
    ],
    "stats": {
      "total": 94,
      "additions": 75,
      "deletions": 19
    },
    "files": [
      {
        "sha": "6e2224bc3e03115e029f947227cdda826018f212",
        "filename": "src/interfaces/chain.cpp",
        "status": "modified",
        "additions": 39,
        "deletions": 0,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ffb07929ef480bd114defdc10b6a84463f222be/src/interfaces/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ffb07929ef480bd114defdc10b6a84463f222be/src/interfaces/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.cpp?ref=2ffb07929ef480bd114defdc10b6a84463f222be",
        "patch": "@@ -5,6 +5,8 @@\n #include <interfaces/chain.h>\n \n #include <chain.h>\n+#include <chainparams.h>\n+#include <primitives/block.h>\n #include <sync.h>\n #include <uint256.h>\n #include <util/system.h>\n@@ -58,6 +60,22 @@ class LockImpl : public Chain::Lock\n         assert(block != nullptr);\n         return block->GetMedianTimePast();\n     }\n+    Optional<int> findFork(const uint256& hash, Optional<int>* height) override\n+    {\n+        const CBlockIndex* block = LookupBlockIndex(hash);\n+        const CBlockIndex* fork = block ? ::chainActive.FindFork(block) : nullptr;\n+        if (height) {\n+            if (block) {\n+                *height = block->nHeight;\n+            } else {\n+                height->reset();\n+            }\n+        }\n+        if (fork) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n };\n \n class LockingStateImpl : public LockImpl, public UniqueLock<CCriticalSection>\n@@ -77,6 +95,27 @@ class ChainImpl : public Chain\n         return std::move(result);\n     }\n     std::unique_ptr<Chain::Lock> assumeLocked() override { return MakeUnique<LockImpl>(); }\n+    bool findBlock(const uint256& hash, CBlock* block, int64_t* time, int64_t* time_max) override\n+    {\n+        CBlockIndex* index;\n+        {\n+            LOCK(cs_main);\n+            index = LookupBlockIndex(hash);\n+            if (!index) {\n+                return false;\n+            }\n+            if (time) {\n+                *time = index->GetBlockTime();\n+            }\n+            if (time_max) {\n+                *time_max = index->GetBlockTimeMax();\n+            }\n+        }\n+        if (block && !ReadBlockFromDisk(*block, index, Params().GetConsensus())) {\n+            block->SetNull();\n+        }\n+        return true;\n+    }\n };\n \n } // namespace"
      },
      {
        "sha": "8c7bd8c6ea42c6a197abad11cb683e0cd5023721",
        "filename": "src/interfaces/chain.h",
        "status": "modified",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ffb07929ef480bd114defdc10b6a84463f222be/src/interfaces/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ffb07929ef480bd114defdc10b6a84463f222be/src/interfaces/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.h?ref=2ffb07929ef480bd114defdc10b6a84463f222be",
        "patch": "@@ -12,6 +12,7 @@\n #include <string>\n #include <vector>\n \n+class CBlock;\n class CScheduler;\n class uint256;\n \n@@ -56,6 +57,13 @@ class Chain\n         //! Get block median time past. Height must be valid or this function\n         //! will abort.\n         virtual int64_t getBlockMedianTimePast(int height) = 0;\n+\n+        //! Return height of the highest block on the chain that is an ancestor\n+        //! of the specified block, or nullopt if no common ancestor is found.\n+        //! Also return the height of the specified block as an optional output\n+        //! parameter (to avoid the cost of a second hash lookup in case this\n+        //! information is desired).\n+        virtual Optional<int> findFork(const uint256& hash, Optional<int>* height) = 0;\n     };\n \n     //! Return Lock interface. Chain is locked when this is called, and\n@@ -66,6 +74,17 @@ class Chain\n     //! method is temporary and is only used in a few places to avoid changing\n     //! behavior while code is transitioned to use the Chain::Lock interface.\n     virtual std::unique_ptr<Lock> assumeLocked() = 0;\n+\n+    //! Return whether node has the block and optionally return block metadata\n+    //! or contents.\n+    //!\n+    //! If a block pointer is provided to retrieve the block contents, and the\n+    //! block exists but doesn't have data (for example due to pruning), the\n+    //! block will be empty and all fields set to null.\n+    virtual bool findBlock(const uint256& hash,\n+        CBlock* block = nullptr,\n+        int64_t* time = nullptr,\n+        int64_t* max_time = nullptr) = 0;\n };\n \n //! Interface to let node manage chain clients (wallets, or maybe tools for"
      },
      {
        "sha": "298a674b073a2d073d0fe1107373477a3c668b98",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 17,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ffb07929ef480bd114defdc10b6a84463f222be/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ffb07929ef480bd114defdc10b6a84463f222be/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=2ffb07929ef480bd114defdc10b6a84463f222be",
        "patch": "@@ -102,7 +102,10 @@ static void WalletTxToJSON(interfaces::Chain& chain, interfaces::Chain::Lock& lo\n     {\n         entry.pushKV(\"blockhash\", wtx.hashBlock.GetHex());\n         entry.pushKV(\"blockindex\", wtx.nIndex);\n-        entry.pushKV(\"blocktime\", LookupBlockIndex(wtx.hashBlock)->GetBlockTime());\n+        int64_t block_time;\n+        bool found_block = chain.findBlock(wtx.hashBlock, nullptr /* block */, &block_time);\n+        assert(found_block);\n+        entry.pushKV(\"blocktime\", block_time);\n     } else {\n         entry.pushKV(\"trusted\", wtx.IsTrusted(locked_chain));\n     }\n@@ -1573,24 +1576,18 @@ static UniValue listsinceblock(const JSONRPCRequest& request)\n     auto locked_chain = pwallet->chain().lock();\n     LOCK(pwallet->cs_wallet);\n \n-    const CBlockIndex* pindex = nullptr;    // Block index of the specified block or the common ancestor, if the block provided was in a deactivated chain.\n-    const CBlockIndex* paltindex = nullptr; // Block index of the specified block, even if it's in a deactivated chain.\n+    Optional<int> height;    // Height of the specified block or the common ancestor, if the block provided was in a deactivated chain.\n+    Optional<int> altheight; // Height of the specified block, even if it's in a deactivated chain.\n     int target_confirms = 1;\n     isminefilter filter = ISMINE_SPENDABLE;\n \n+    uint256 blockId;\n     if (!request.params[0].isNull() && !request.params[0].get_str().empty()) {\n-        uint256 blockId(ParseHashV(request.params[0], \"blockhash\"));\n-\n-        paltindex = pindex = LookupBlockIndex(blockId);\n-        if (!pindex) {\n+        blockId = ParseHashV(request.params[0], \"blockhash\");\n+        height = locked_chain->findFork(blockId, &altheight);\n+        if (!height) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n         }\n-        if (chainActive[pindex->nHeight] != pindex) {\n-            // the block being asked for is a part of a deactivated chain;\n-            // we don't want to depend on its perceived height in the block\n-            // chain, we want to instead use the last common ancestor\n-            pindex = chainActive.FindFork(pindex);\n-        }\n     }\n \n     if (!request.params[1].isNull()) {\n@@ -1608,7 +1605,7 @@ static UniValue listsinceblock(const JSONRPCRequest& request)\n     bool include_removed = (request.params[3].isNull() || request.params[3].get_bool());\n \n     const Optional<int> tip_height = locked_chain->getHeight();\n-    int depth = tip_height && pindex ? (1 + *tip_height - pindex->nHeight) : -1;\n+    int depth = tip_height && height ? (1 + *tip_height - *height) : -1;\n \n     UniValue transactions(UniValue::VARR);\n \n@@ -1623,9 +1620,9 @@ static UniValue listsinceblock(const JSONRPCRequest& request)\n     // when a reorg'd block is requested, we also list any relevant transactions\n     // in the blocks of the chain that was detached\n     UniValue removed(UniValue::VARR);\n-    while (include_removed && paltindex && paltindex != pindex) {\n+    while (include_removed && altheight && *altheight > *height) {\n         CBlock block;\n-        if (!ReadBlockFromDisk(block, paltindex, Params().GetConsensus())) {\n+        if (!pwallet->chain().findBlock(blockId, &block) || block.IsNull()) {\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"Can't read block from disk\");\n         }\n         for (const CTransactionRef& tx : block.vtx) {\n@@ -1636,7 +1633,8 @@ static UniValue listsinceblock(const JSONRPCRequest& request)\n                 ListTransactions(*locked_chain, pwallet, it->second, -100000000, true, removed, filter, nullptr /* filter_label */);\n             }\n         }\n-        paltindex = paltindex->pprev;\n+        blockId = block.hashPrevBlock;\n+        --*altheight;\n     }\n \n     int last_height = tip_height ? *tip_height + 1 - target_confirms : -1;"
      },
      {
        "sha": "32275c618058540a72c802fda044e8e6b7626900",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ffb07929ef480bd114defdc10b6a84463f222be/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ffb07929ef480bd114defdc10b6a84463f222be/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=2ffb07929ef480bd114defdc10b6a84463f222be",
        "patch": "@@ -3775,7 +3775,8 @@ unsigned int CWallet::ComputeTimeSmart(const CWalletTx& wtx) const\n {\n     unsigned int nTimeSmart = wtx.nTimeReceived;\n     if (!wtx.hashUnset()) {\n-        if (const CBlockIndex* pindex = LookupBlockIndex(wtx.hashBlock)) {\n+        int64_t blocktime;\n+        if (chain().findBlock(wtx.hashBlock, nullptr /* block */, &blocktime)) {\n             int64_t latestNow = wtx.nTimeReceived;\n             int64_t latestEntry = 0;\n \n@@ -3801,7 +3802,6 @@ unsigned int CWallet::ComputeTimeSmart(const CWalletTx& wtx) const\n                 }\n             }\n \n-            int64_t blocktime = pindex->GetBlockTime();\n             nTimeSmart = std::max(latestEntry, std::min(blocktime, latestNow));\n         } else {\n             WalletLogPrintf(\"%s: found %s in block %s not in index\\n\", __func__, wtx.GetHash().ToString(), wtx.hashBlock.ToString());"
      }
    ]
  },
  {
    "sha": "db21f0264855406c9b6ec4c084a15988c5c71b32",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkYjIxZjAyNjQ4NTU0MDZjOWI2ZWM0YzA4NGExNTk4OGM1YzcxYjMy",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2019-01-08T07:38:53Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2019-01-15T16:42:00Z"
      },
      "message": "Convert CWallet::ScanForWalletTransactions and SyncTransaction to the new Chain apis\n\nOnly change in behavior is \"Rescan started from block <height>\" message\nreplaced by \"Rescan started from block <hash>\" message in\nScanForWalletTransactions.\n\nCo-authored-by: Ben Woosley <ben.woosley@gmail.com>",
      "tree": {
        "sha": "453f8541449673867736c10f9fd1edd8b53b5476",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/453f8541449673867736c10f9fd1edd8b53b5476"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/db21f0264855406c9b6ec4c084a15988c5c71b32",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/db21f0264855406c9b6ec4c084a15988c5c71b32",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/db21f0264855406c9b6ec4c084a15988c5c71b32",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/db21f0264855406c9b6ec4c084a15988c5c71b32/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2ffb07929ef480bd114defdc10b6a84463f222be",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2ffb07929ef480bd114defdc10b6a84463f222be",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2ffb07929ef480bd114defdc10b6a84463f222be"
      }
    ],
    "stats": {
      "total": 334,
      "additions": 209,
      "deletions": 125
    },
    "files": [
      {
        "sha": "1f39e650dcfef16b53e653b42affe447e637390b",
        "filename": "src/interfaces/chain.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 0,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/db21f0264855406c9b6ec4c084a15988c5c71b32/src/interfaces/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/db21f0264855406c9b6ec4c084a15988c5c71b32/src/interfaces/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.cpp?ref=db21f0264855406c9b6ec4c084a15988c5c71b32",
        "patch": "@@ -60,6 +60,42 @@ class LockImpl : public Chain::Lock\n         assert(block != nullptr);\n         return block->GetMedianTimePast();\n     }\n+    Optional<int> findFirstBlockWithTime(int64_t time, uint256* hash) override\n+    {\n+        CBlockIndex* block = ::chainActive.FindEarliestAtLeast(time);\n+        if (block) {\n+            if (hash) *hash = block->GetBlockHash();\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height) override\n+    {\n+        // TODO: Could update CChain::FindEarliestAtLeast() to take a height\n+        // parameter and use it with std::lower_bound() to make this\n+        // implementation more efficient and allow combining\n+        // findFirstBlockWithTime and findFirstBlockWithTimeAndHeight into one\n+        // method.\n+        for (CBlockIndex* block = ::chainActive[height]; block; block = ::chainActive.Next(block)) {\n+            if (block->GetBlockTime() >= time) {\n+                return block->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findPruned(int start_height, Optional<int> stop_height) override\n+    {\n+        if (::fPruneMode) {\n+            CBlockIndex* block = stop_height ? ::chainActive[*stop_height] : ::chainActive.Tip();\n+            while (block && block->nHeight >= start_height) {\n+                if ((block->nStatus & BLOCK_HAVE_DATA) == 0) {\n+                    return block->nHeight;\n+                }\n+                block = block->pprev;\n+            }\n+        }\n+        return nullopt;\n+    }\n     Optional<int> findFork(const uint256& hash, Optional<int>* height) override\n     {\n         const CBlockIndex* block = LookupBlockIndex(hash);\n@@ -116,6 +152,11 @@ class ChainImpl : public Chain\n         }\n         return true;\n     }\n+    double guessVerificationProgress(const uint256& block_hash) override\n+    {\n+        LOCK(cs_main);\n+        return GuessVerificationProgress(Params().TxData(), LookupBlockIndex(block_hash));\n+    }\n };\n \n } // namespace"
      },
      {
        "sha": "aef81675e0fa1831578661898da198aad5ca7adc",
        "filename": "src/interfaces/chain.h",
        "status": "modified",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/db21f0264855406c9b6ec4c084a15988c5c71b32/src/interfaces/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/db21f0264855406c9b6ec4c084a15988c5c71b32/src/interfaces/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.h?ref=db21f0264855406c9b6ec4c084a15988c5c71b32",
        "patch": "@@ -58,6 +58,26 @@ class Chain\n         //! will abort.\n         virtual int64_t getBlockMedianTimePast(int height) = 0;\n \n+        //! Return height of the first block in the chain with timestamp equal\n+        //! or greater than the given time, or nullopt if there is no block with\n+        //! a high enough timestamp. Also return the block hash as an optional\n+        //! output parameter (to avoid the cost of a second lookup in case this\n+        //! information is needed.)\n+        virtual Optional<int> findFirstBlockWithTime(int64_t time, uint256* hash) = 0;\n+\n+        //! Return height of the first block in the chain with timestamp equal\n+        //! or greater than the given time and height equal or greater than the\n+        //! given height, or nullopt if there is no such block.\n+        //!\n+        //! Calling this with height 0 is equivalent to calling\n+        //! findFirstBlockWithTime, but less efficient because it requires a\n+        //! linear instead of a binary search.\n+        virtual Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height) = 0;\n+\n+        //! Return height of last block in the specified range which is pruned, or\n+        //! nullopt if no block in the range is pruned. Range is inclusive.\n+        virtual Optional<int> findPruned(int start_height = 0, Optional<int> stop_height = nullopt) = 0;\n+\n         //! Return height of the highest block on the chain that is an ancestor\n         //! of the specified block, or nullopt if no common ancestor is found.\n         //! Also return the height of the specified block as an optional output\n@@ -85,6 +105,10 @@ class Chain\n         CBlock* block = nullptr,\n         int64_t* time = nullptr,\n         int64_t* max_time = nullptr) = 0;\n+\n+    //! Estimate fraction of total transactions verified if blocks up to\n+    //! the specified block hash are verified.\n+    virtual double guessVerificationProgress(const uint256& block_hash) = 0;\n };\n \n //! Interface to let node manage chain clients (wallets, or maybe tools for"
      },
      {
        "sha": "ee84da0cdf99b7d713dee42fde577a2fb6f8c118",
        "filename": "src/qt/test/wallettests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 7,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/db21f0264855406c9b6ec4c084a15988c5c71b32/src/qt/test/wallettests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/db21f0264855406c9b6ec4c084a15988c5c71b32/src/qt/test/wallettests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/wallettests.cpp?ref=db21f0264855406c9b6ec4c084a15988c5c71b32",
        "patch": "@@ -1,6 +1,7 @@\n #include <qt/test/wallettests.h>\n #include <qt/test/util.h>\n \n+#include <init.h>\n #include <interfaces/chain.h>\n #include <interfaces/node.h>\n #include <base58.h>\n@@ -146,13 +147,10 @@ void TestGUI()\n         auto locked_chain = wallet->chain().lock();\n         WalletRescanReserver reserver(wallet.get());\n         reserver.reserve();\n-        const CBlockIndex* const null_block = nullptr;\n-        const CBlockIndex *stop_block, *failed_block;\n-        QCOMPARE(\n-            wallet->ScanForWalletTransactions(chainActive.Genesis(), nullptr, reserver, failed_block, stop_block, true /* fUpdate */),\n-            CWallet::ScanResult::SUCCESS);\n-        QCOMPARE(stop_block, chainActive.Tip());\n-        QCOMPARE(failed_block, null_block);\n+        CWallet::ScanResult result = wallet->ScanForWalletTransactions(locked_chain->getBlockHash(0), {} /* stop_block */, reserver, true /* fUpdate */);\n+        QCOMPARE(result.status, CWallet::ScanResult::SUCCESS);\n+        QCOMPARE(result.stop_block, chainActive.Tip()->GetBlockHash());\n+        QVERIFY(result.failed_block.IsNull());\n     }\n     wallet->SetBroadcastTransactions(true);\n "
      },
      {
        "sha": "32173a92d00edb23f551db973c17c071da76ae8e",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 25,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/db21f0264855406c9b6ec4c084a15988c5c71b32/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/db21f0264855406c9b6ec4c084a15988c5c71b32/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=db21f0264855406c9b6ec4c084a15988c5c71b32",
        "patch": "@@ -3387,59 +3387,57 @@ UniValue rescanblockchain(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Wallet is currently rescanning. Abort existing rescan or wait.\");\n     }\n \n-    CBlockIndex *pindexStart = nullptr;\n-    CBlockIndex *pindexStop = nullptr;\n-    CBlockIndex *pChainTip = nullptr;\n+    int start_height = 0;\n+    uint256 start_block, stop_block;\n     {\n         auto locked_chain = pwallet->chain().lock();\n-        pindexStart = chainActive.Genesis();\n-        pChainTip = chainActive.Tip();\n+        Optional<int> tip_height = locked_chain->getHeight();\n \n         if (!request.params[0].isNull()) {\n-            pindexStart = chainActive[request.params[0].get_int()];\n-            if (!pindexStart) {\n+            start_height = request.params[0].get_int();\n+            if (start_height < 0 || !tip_height || start_height > *tip_height) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid start_height\");\n             }\n         }\n \n+        Optional<int> stop_height;\n         if (!request.params[1].isNull()) {\n-            pindexStop = chainActive[request.params[1].get_int()];\n-            if (!pindexStop) {\n+            stop_height = request.params[1].get_int();\n+            if (*stop_height < 0 || !tip_height || *stop_height > *tip_height) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid stop_height\");\n             }\n-            else if (pindexStop->nHeight < pindexStart->nHeight) {\n+            else if (*stop_height < start_height) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"stop_height must be greater than start_height\");\n             }\n         }\n-    }\n \n-    // We can't rescan beyond non-pruned blocks, stop and throw an error\n-    if (fPruneMode) {\n-        auto locked_chain = pwallet->chain().lock();\n-        CBlockIndex *block = pindexStop ? pindexStop : pChainTip;\n-        while (block && block->nHeight >= pindexStart->nHeight) {\n-            if (!(block->nStatus & BLOCK_HAVE_DATA)) {\n-                throw JSONRPCError(RPC_MISC_ERROR, \"Can't rescan beyond pruned data. Use RPC call getblockchaininfo to determine your pruned height.\");\n+        // We can't rescan beyond non-pruned blocks, stop and throw an error\n+        if (locked_chain->findPruned(start_height, stop_height)) {\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Can't rescan beyond pruned data. Use RPC call getblockchaininfo to determine your pruned height.\");\n+        }\n+\n+        if (tip_height) {\n+            start_block = locked_chain->getBlockHash(start_height);\n+            if (stop_height) {\n+                stop_block = locked_chain->getBlockHash(*stop_height);\n             }\n-            block = block->pprev;\n         }\n     }\n \n-    const CBlockIndex *failed_block, *stopBlock;\n     CWallet::ScanResult result =\n-        pwallet->ScanForWalletTransactions(pindexStart, pindexStop, reserver, failed_block, stopBlock, true);\n-    switch (result) {\n+        pwallet->ScanForWalletTransactions(start_block, stop_block, reserver, true /* fUpdate */);\n+    switch (result.status) {\n     case CWallet::ScanResult::SUCCESS:\n-        break; // stopBlock set by ScanForWalletTransactions\n+        break;\n     case CWallet::ScanResult::FAILURE:\n         throw JSONRPCError(RPC_MISC_ERROR, \"Rescan failed. Potentially corrupted data files.\");\n     case CWallet::ScanResult::USER_ABORT:\n         throw JSONRPCError(RPC_MISC_ERROR, \"Rescan aborted.\");\n         // no default case, so the compiler can warn about missing cases\n     }\n     UniValue response(UniValue::VOBJ);\n-    response.pushKV(\"start_height\", pindexStart->nHeight);\n-    response.pushKV(\"stop_height\", stopBlock->nHeight);\n+    response.pushKV(\"start_height\", start_height);\n+    response.pushKV(\"stop_height\", result.stop_height ? *result.stop_height : UniValue());\n     return response;\n }\n "
      },
      {
        "sha": "8c380f1257ce0169ad98f1bb191a4163a52579f3",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 22,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/db21f0264855406c9b6ec4c084a15988c5c71b32/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/db21f0264855406c9b6ec4c084a15988c5c71b32/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=db21f0264855406c9b6ec4c084a15988c5c71b32",
        "patch": "@@ -39,7 +39,6 @@ BOOST_FIXTURE_TEST_CASE(scan_for_wallet_transactions, TestChain100Setup)\n     auto chain = interfaces::MakeChain();\n \n     // Cap last block file size, and mine new block in a new block file.\n-    const CBlockIndex* const null_block = nullptr;\n     CBlockIndex* oldTip = chainActive.Tip();\n     GetBlockFileInfo(oldTip->GetBlockPos().nFile)->nSize = MAX_BLOCKFILE_SIZE;\n     CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey()));\n@@ -53,10 +52,11 @@ BOOST_FIXTURE_TEST_CASE(scan_for_wallet_transactions, TestChain100Setup)\n         AddKey(wallet, coinbaseKey);\n         WalletRescanReserver reserver(&wallet);\n         reserver.reserve();\n-        const CBlockIndex *stop_block = null_block + 1, *failed_block = null_block + 1;\n-        BOOST_CHECK_EQUAL(wallet.ScanForWalletTransactions(nullptr, nullptr, reserver, failed_block, stop_block), CWallet::ScanResult::SUCCESS);\n-        BOOST_CHECK_EQUAL(failed_block, null_block);\n-        BOOST_CHECK_EQUAL(stop_block, null_block);\n+        CWallet::ScanResult result = wallet.ScanForWalletTransactions({} /* start_block */, {} /* stop_block */, reserver, false /* update */);\n+        BOOST_CHECK_EQUAL(result.status, CWallet::ScanResult::SUCCESS);\n+        BOOST_CHECK(result.failed_block.IsNull());\n+        BOOST_CHECK(result.stop_block.IsNull());\n+        BOOST_CHECK(!result.stop_height);\n         BOOST_CHECK_EQUAL(wallet.GetImmatureBalance(), 0);\n     }\n \n@@ -67,10 +67,11 @@ BOOST_FIXTURE_TEST_CASE(scan_for_wallet_transactions, TestChain100Setup)\n         AddKey(wallet, coinbaseKey);\n         WalletRescanReserver reserver(&wallet);\n         reserver.reserve();\n-        const CBlockIndex *stop_block = null_block + 1, *failed_block = null_block + 1;\n-        BOOST_CHECK_EQUAL(wallet.ScanForWalletTransactions(oldTip, nullptr, reserver, failed_block, stop_block), CWallet::ScanResult::SUCCESS);\n-        BOOST_CHECK_EQUAL(failed_block, null_block);\n-        BOOST_CHECK_EQUAL(stop_block, newTip);\n+        CWallet::ScanResult result = wallet.ScanForWalletTransactions(oldTip->GetBlockHash(), {} /* stop_block */, reserver, false /* update */);\n+        BOOST_CHECK_EQUAL(result.status, CWallet::ScanResult::SUCCESS);\n+        BOOST_CHECK(result.failed_block.IsNull());\n+        BOOST_CHECK_EQUAL(result.stop_block, newTip->GetBlockHash());\n+        BOOST_CHECK_EQUAL(*result.stop_height, newTip->nHeight);\n         BOOST_CHECK_EQUAL(wallet.GetImmatureBalance(), 100 * COIN);\n     }\n \n@@ -85,10 +86,11 @@ BOOST_FIXTURE_TEST_CASE(scan_for_wallet_transactions, TestChain100Setup)\n         AddKey(wallet, coinbaseKey);\n         WalletRescanReserver reserver(&wallet);\n         reserver.reserve();\n-        const CBlockIndex *stop_block = null_block + 1, *failed_block = null_block + 1;\n-        BOOST_CHECK_EQUAL(wallet.ScanForWalletTransactions(oldTip, nullptr, reserver, failed_block, stop_block), CWallet::ScanResult::FAILURE);\n-        BOOST_CHECK_EQUAL(failed_block, oldTip);\n-        BOOST_CHECK_EQUAL(stop_block, newTip);\n+        CWallet::ScanResult result = wallet.ScanForWalletTransactions(oldTip->GetBlockHash(), {} /* stop_block */, reserver, false /* update */);\n+        BOOST_CHECK_EQUAL(result.status, CWallet::ScanResult::FAILURE);\n+        BOOST_CHECK_EQUAL(result.failed_block, oldTip->GetBlockHash());\n+        BOOST_CHECK_EQUAL(result.stop_block, newTip->GetBlockHash());\n+        BOOST_CHECK_EQUAL(*result.stop_height, newTip->nHeight);\n         BOOST_CHECK_EQUAL(wallet.GetImmatureBalance(), 50 * COIN);\n     }\n \n@@ -102,10 +104,11 @@ BOOST_FIXTURE_TEST_CASE(scan_for_wallet_transactions, TestChain100Setup)\n         AddKey(wallet, coinbaseKey);\n         WalletRescanReserver reserver(&wallet);\n         reserver.reserve();\n-        const CBlockIndex *stop_block = null_block + 1, *failed_block = null_block + 1;\n-        BOOST_CHECK_EQUAL(wallet.ScanForWalletTransactions(oldTip, nullptr, reserver, failed_block, stop_block), CWallet::ScanResult::FAILURE);\n-        BOOST_CHECK_EQUAL(failed_block, newTip);\n-        BOOST_CHECK_EQUAL(stop_block, null_block);\n+        CWallet::ScanResult result = wallet.ScanForWalletTransactions(oldTip->GetBlockHash(), {} /* stop_block */, reserver, false /* update */);\n+        BOOST_CHECK_EQUAL(result.status, CWallet::ScanResult::FAILURE);\n+        BOOST_CHECK_EQUAL(result.failed_block, newTip->GetBlockHash());\n+        BOOST_CHECK(result.stop_block.IsNull());\n+        BOOST_CHECK(!result.stop_height);\n         BOOST_CHECK_EQUAL(wallet.GetImmatureBalance(), 0);\n     }\n }\n@@ -340,11 +343,11 @@ class ListCoinsTestingSetup : public TestChain100Setup\n         AddKey(*wallet, coinbaseKey);\n         WalletRescanReserver reserver(wallet.get());\n         reserver.reserve();\n-        const CBlockIndex* const null_block = nullptr;\n-        const CBlockIndex *stop_block = null_block + 1, *failed_block = null_block + 1;\n-        BOOST_CHECK_EQUAL(wallet->ScanForWalletTransactions(chainActive.Genesis(), nullptr, reserver, failed_block, stop_block), CWallet::ScanResult::SUCCESS);\n-        BOOST_CHECK_EQUAL(stop_block, chainActive.Tip());\n-        BOOST_CHECK_EQUAL(failed_block, null_block);\n+        CWallet::ScanResult result = wallet->ScanForWalletTransactions(chainActive.Genesis()->GetBlockHash(), {} /* stop_block */, reserver, false /* update */);\n+        BOOST_CHECK_EQUAL(result.status, CWallet::ScanResult::SUCCESS);\n+        BOOST_CHECK_EQUAL(result.stop_block, chainActive.Tip()->GetBlockHash());\n+        BOOST_CHECK_EQUAL(*result.stop_height, chainActive.Height());\n+        BOOST_CHECK(result.failed_block.IsNull());\n     }\n \n     ~ListCoinsTestingSetup()"
      },
      {
        "sha": "4b1d010fed069c447e0442780986838fcea34796",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 74,
        "deletions": 64,
        "changes": 138,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/db21f0264855406c9b6ec4c084a15988c5c71b32/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/db21f0264855406c9b6ec4c084a15988c5c71b32/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=db21f0264855406c9b6ec4c084a15988c5c71b32",
        "patch": "@@ -1117,8 +1117,8 @@ void CWallet::MarkConflicted(const uint256& hashBlock, const uint256& hashTx)\n     }\n }\n \n-void CWallet::SyncTransaction(const CTransactionRef& ptx, const CBlockIndex *pindex, int posInBlock, bool update_tx) {\n-    if (!AddToWalletIfInvolvingMe(ptx, pindex->GetBlockHash(), posInBlock, update_tx))\n+void CWallet::SyncTransaction(const CTransactionRef& ptx, const uint256& block_hash, int posInBlock, bool update_tx) {\n+    if (!AddToWalletIfInvolvingMe(ptx, block_hash, posInBlock, update_tx))\n         return; // Not one of ours\n \n     // If a transaction changes 'conflicted' state, that changes the balance\n@@ -1130,7 +1130,7 @@ void CWallet::SyncTransaction(const CTransactionRef& ptx, const CBlockIndex *pin\n void CWallet::TransactionAddedToMempool(const CTransactionRef& ptx) {\n     auto locked_chain = chain().lock();\n     LOCK(cs_wallet);\n-    SyncTransaction(ptx);\n+    SyncTransaction(ptx, {} /* block hash */, 0 /* position in block */);\n \n     auto it = mapWallet.find(ptx->GetHash());\n     if (it != mapWallet.end()) {\n@@ -1158,11 +1158,11 @@ void CWallet::BlockConnected(const std::shared_ptr<const CBlock>& pblock, const\n     // the notification that the conflicted transaction was evicted.\n \n     for (const CTransactionRef& ptx : vtxConflicted) {\n-        SyncTransaction(ptx);\n+        SyncTransaction(ptx, {} /* block hash */, 0 /* position in block */);\n         TransactionRemovedFromMempool(ptx);\n     }\n     for (size_t i = 0; i < pblock->vtx.size(); i++) {\n-        SyncTransaction(pblock->vtx[i], pindex, i);\n+        SyncTransaction(pblock->vtx[i], pindex->GetBlockHash(), i);\n         TransactionRemovedFromMempool(pblock->vtx[i]);\n     }\n \n@@ -1174,7 +1174,7 @@ void CWallet::BlockDisconnected(const std::shared_ptr<const CBlock>& pblock) {\n     LOCK(cs_wallet);\n \n     for (const CTransactionRef& ptx : pblock->vtx) {\n-        SyncTransaction(ptx);\n+        SyncTransaction(ptx, {} /* block hash */, 0 /* position in block */);\n     }\n }\n \n@@ -1587,132 +1587,143 @@ int64_t CWallet::RescanFromTime(int64_t startTime, const WalletRescanReserver& r\n     // Find starting block. May be null if nCreateTime is greater than the\n     // highest blockchain timestamp, in which case there is nothing that needs\n     // to be scanned.\n-    CBlockIndex* startBlock = nullptr;\n+    uint256 start_block;\n     {\n         auto locked_chain = chain().lock();\n-        startBlock = chainActive.FindEarliestAtLeast(startTime - TIMESTAMP_WINDOW);\n-        WalletLogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, startBlock ? chainActive.Height() - startBlock->nHeight + 1 : 0);\n+        const Optional<int> start_height = locked_chain->findFirstBlockWithTime(startTime - TIMESTAMP_WINDOW, &start_block);\n+        const Optional<int> tip_height = locked_chain->getHeight();\n+        WalletLogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, tip_height && start_height ? *tip_height - *start_height + 1 : 0);\n     }\n \n-    if (startBlock) {\n-        const CBlockIndex *failedBlock, *stop_block;\n+    if (!start_block.IsNull()) {\n         // TODO: this should take into account failure by ScanResult::USER_ABORT\n-        if (ScanResult::FAILURE == ScanForWalletTransactions(startBlock, nullptr, reserver, failedBlock, stop_block, update)) {\n-            return failedBlock->GetBlockTimeMax() + TIMESTAMP_WINDOW + 1;\n+        ScanResult result = ScanForWalletTransactions(start_block, {} /* stop_block */, reserver, update);\n+        if (result.status == ScanResult::FAILURE) {\n+            int64_t time_max;\n+            if (!chain().findBlock(result.failed_block, nullptr /* block */, nullptr /* time */, &time_max)) {\n+                throw std::logic_error(\"ScanForWalletTransactions returned invalid block hash\");\n+            }\n+            return time_max + TIMESTAMP_WINDOW + 1;\n         }\n     }\n     return startTime;\n }\n \n /**\n- * Scan the block chain (starting in pindexStart) for transactions\n+ * Scan the block chain (starting in start_block) for transactions\n  * from or to us. If fUpdate is true, found transactions that already\n  * exist in the wallet will be updated.\n  *\n- * @param[in] pindexStop if not a nullptr, the scan will stop at this block-index\n- * @param[out] failed_block if FAILURE is returned, the most recent block\n- *     that could not be scanned, otherwise nullptr\n- * @param[out] stop_block the most recent block that could be scanned,\n- *     otherwise nullptr if no block could be scanned\n+ * @param[in] start_block if not null, the scan will start at this block instead\n+ *            of the genesis block\n+ * @param[in] stop_block if not null, the scan will stop at this block instead\n+ *            of the chain tip\n  *\n  * @return ScanResult indicating success or failure of the scan. SUCCESS if\n  * scan was successful. FAILURE if a complete rescan was not possible (due to\n  * pruning or corruption). USER_ABORT if the rescan was aborted before it\n  * could complete.\n  *\n- * @pre Caller needs to make sure pindexStop (and the optional pindexStart) are on\n+ * @pre Caller needs to make sure start_block (and the optional stop_block) are on\n  * the main chain after to the addition of any new keys you want to detect\n  * transactions for.\n  */\n-CWallet::ScanResult CWallet::ScanForWalletTransactions(const CBlockIndex* const pindexStart, const CBlockIndex* const pindexStop, const WalletRescanReserver& reserver, const CBlockIndex*& failed_block, const CBlockIndex*& stop_block, bool fUpdate)\n+CWallet::ScanResult CWallet::ScanForWalletTransactions(const uint256& start_block, const uint256& stop_block, const WalletRescanReserver& reserver, bool fUpdate)\n {\n     int64_t nNow = GetTime();\n-    const CChainParams& chainParams = Params();\n \n     assert(reserver.isReserved());\n-    if (pindexStop) {\n-        assert(pindexStop->nHeight >= pindexStart->nHeight);\n-    }\n \n-    const CBlockIndex* pindex = pindexStart;\n-    failed_block = nullptr;\n-    stop_block = nullptr;\n+    uint256 block_hash = start_block;\n+    ScanResult result;\n \n-    if (pindex) WalletLogPrintf(\"Rescan started from block %d...\\n\", pindex->nHeight);\n+    WalletLogPrintf(\"Rescan started from block %s...\\n\", start_block.ToString());\n \n     {\n         fAbortRescan = false;\n         ShowProgress(strprintf(\"%s \" + _(\"Rescanning...\"), GetDisplayName()), 0); // show rescan progress in GUI as dialog or on splashscreen, if -rescan on startup\n-        CBlockIndex* tip = nullptr;\n+        uint256 tip_hash;\n+        Optional<int> block_height;\n         double progress_begin;\n         double progress_end;\n         {\n             auto locked_chain = chain().lock();\n-            progress_begin = GuessVerificationProgress(chainParams.TxData(), pindex);\n-            if (pindexStop == nullptr) {\n-                tip = chainActive.Tip();\n-                progress_end = GuessVerificationProgress(chainParams.TxData(), tip);\n-            } else {\n-                progress_end = GuessVerificationProgress(chainParams.TxData(), pindexStop);\n+            if (Optional<int> tip_height = locked_chain->getHeight()) {\n+                tip_hash = locked_chain->getBlockHash(*tip_height);\n             }\n+            block_height = locked_chain->getBlockHeight(block_hash);\n+            progress_begin = chain().guessVerificationProgress(block_hash);\n+            progress_end = chain().guessVerificationProgress(stop_block.IsNull() ? tip_hash : stop_block);\n         }\n         double progress_current = progress_begin;\n-        while (pindex && !fAbortRescan && !ShutdownRequested()) {\n-            if (pindex->nHeight % 100 == 0 && progress_end - progress_begin > 0.0) {\n+        while (block_height && !fAbortRescan && !ShutdownRequested()) {\n+            if (*block_height % 100 == 0 && progress_end - progress_begin > 0.0) {\n                 ShowProgress(strprintf(\"%s \" + _(\"Rescanning...\"), GetDisplayName()), std::max(1, std::min(99, (int)((progress_current - progress_begin) / (progress_end - progress_begin) * 100))));\n             }\n             if (GetTime() >= nNow + 60) {\n                 nNow = GetTime();\n-                WalletLogPrintf(\"Still rescanning. At block %d. Progress=%f\\n\", pindex->nHeight, progress_current);\n+                WalletLogPrintf(\"Still rescanning. At block %d. Progress=%f\\n\", *block_height, progress_current);\n             }\n \n             CBlock block;\n-            if (ReadBlockFromDisk(block, pindex, Params().GetConsensus())) {\n+            if (chain().findBlock(block_hash, &block) && !block.IsNull()) {\n                 auto locked_chain = chain().lock();\n                 LOCK(cs_wallet);\n-                if (pindex && !chainActive.Contains(pindex)) {\n+                if (!locked_chain->getBlockHeight(block_hash)) {\n                     // Abort scan if current block is no longer active, to prevent\n                     // marking transactions as coming from the wrong block.\n-                    failed_block = pindex;\n+                    // TODO: This should return success instead of failure, see\n+                    // https://github.com/bitcoin/bitcoin/pull/14711#issuecomment-458342518\n+                    result.failed_block = block_hash;\n+                    result.status = ScanResult::FAILURE;\n                     break;\n                 }\n                 for (size_t posInBlock = 0; posInBlock < block.vtx.size(); ++posInBlock) {\n-                    SyncTransaction(block.vtx[posInBlock], pindex, posInBlock, fUpdate);\n+                    SyncTransaction(block.vtx[posInBlock], block_hash, posInBlock, fUpdate);\n                 }\n                 // scan succeeded, record block as most recent successfully scanned\n-                stop_block = pindex;\n+                result.stop_block = block_hash;\n+                result.stop_height = *block_height;\n             } else {\n                 // could not scan block, keep scanning but record this block as the most recent failure\n-                failed_block = pindex;\n+                result.failed_block = block_hash;\n+                result.status = ScanResult::FAILURE;\n             }\n-            if (pindex == pindexStop) {\n+            if (block_hash == stop_block) {\n                 break;\n             }\n             {\n                 auto locked_chain = chain().lock();\n-                pindex = chainActive.Next(pindex);\n-                progress_current = GuessVerificationProgress(chainParams.TxData(), pindex);\n-                if (pindexStop == nullptr && tip != chainActive.Tip()) {\n-                    tip = chainActive.Tip();\n+                Optional<int> tip_height = locked_chain->getHeight();\n+                if (!tip_height || *tip_height <= block_height || !locked_chain->getBlockHeight(block_hash)) {\n+                    // break successfully when rescan has reached the tip, or\n+                    // previous block is no longer on the chain due to a reorg\n+                    break;\n+                }\n+\n+                // increment block and verification progress\n+                block_hash = locked_chain->getBlockHash(++*block_height);\n+                progress_current = chain().guessVerificationProgress(block_hash);\n+\n+                // handle updated tip hash\n+                const uint256 prev_tip_hash = tip_hash;\n+                tip_hash = locked_chain->getBlockHash(*tip_height);\n+                if (stop_block.IsNull() && prev_tip_hash != tip_hash) {\n                     // in case the tip has changed, update progress max\n-                    progress_end = GuessVerificationProgress(chainParams.TxData(), tip);\n+                    progress_end = chain().guessVerificationProgress(tip_hash);\n                 }\n             }\n         }\n         ShowProgress(strprintf(\"%s \" + _(\"Rescanning...\"), GetDisplayName()), 100); // hide progress dialog in GUI\n-        if (pindex && fAbortRescan) {\n-            WalletLogPrintf(\"Rescan aborted at block %d. Progress=%f\\n\", pindex->nHeight, progress_current);\n-            return ScanResult::USER_ABORT;\n-        } else if (pindex && ShutdownRequested()) {\n-            WalletLogPrintf(\"Rescan interrupted by shutdown request at block %d. Progress=%f\\n\", pindex->nHeight, progress_current);\n-            return ScanResult::USER_ABORT;\n+        if (block_height && fAbortRescan) {\n+            WalletLogPrintf(\"Rescan aborted at block %d. Progress=%f\\n\", block_height.value_or(0), progress_current);\n+            result.status = ScanResult::USER_ABORT;\n+        } else if (block_height && ShutdownRequested()) {\n+            WalletLogPrintf(\"Rescan interrupted by shutdown request at block %d. Progress=%f\\n\", block_height.value_or(0), progress_current);\n+            result.status = ScanResult::USER_ABORT;\n         }\n     }\n-    if (failed_block) {\n-        return ScanResult::FAILURE;\n-    } else {\n-        return ScanResult::SUCCESS;\n-    }\n+    return result;\n }\n \n void CWallet::ReacceptWalletTransactions()\n@@ -4194,8 +4205,7 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,\n         nStart = GetTimeMillis();\n         {\n             WalletRescanReserver reserver(walletInstance.get());\n-            const CBlockIndex *stop_block, *failed_block;\n-            if (!reserver.reserve() || (ScanResult::SUCCESS != walletInstance->ScanForWalletTransactions(pindexRescan, nullptr, reserver, failed_block, stop_block, true))) {\n+            if (!reserver.reserve() || (ScanResult::SUCCESS != walletInstance->ScanForWalletTransactions(pindexRescan->GetBlockHash(), {} /* stop block */, reserver, true /* update */).status)) {\n                 InitError(_(\"Failed to rescan the wallet during initialization\"));\n                 return nullptr;\n             }"
      },
      {
        "sha": "7a541db778b73714696b2d7fe2aa8bb262922097",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 17,
        "deletions": 7,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/db21f0264855406c9b6ec4c084a15988c5c71b32/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/db21f0264855406c9b6ec4c084a15988c5c71b32/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=db21f0264855406c9b6ec4c084a15988c5c71b32",
        "patch": "@@ -678,8 +678,8 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     void SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator>) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n     /* Used by TransactionAddedToMemorypool/BlockConnected/Disconnected/ScanForWalletTransactions.\n-     * Should be called with pindexBlock and posInBlock if this is for a transaction that is included in a block. */\n-    void SyncTransaction(const CTransactionRef& tx, const CBlockIndex *pindex = nullptr, int posInBlock = 0, bool update_tx = true) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+     * Should be called with non-zero block_hash and posInBlock if this is for a transaction that is included in a block. */\n+    void SyncTransaction(const CTransactionRef& tx, const uint256& block_hash, int posInBlock = 0, bool update_tx = true) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n     /* the HD chain data model (external chain counters) */\n     CHDChain hdChain;\n@@ -909,12 +909,22 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     void BlockDisconnected(const std::shared_ptr<const CBlock>& pblock) override;\n     int64_t RescanFromTime(int64_t startTime, const WalletRescanReserver& reserver, bool update);\n \n-    enum class ScanResult {\n-        SUCCESS,\n-        FAILURE,\n-        USER_ABORT\n+    struct ScanResult {\n+        enum { SUCCESS, FAILURE, USER_ABORT } status = SUCCESS;\n+\n+        //! Hash and height of most recent block that was successfully scanned.\n+        //! Unset if no blocks were scanned due to read errors or the chain\n+        //! being empty.\n+        uint256 stop_block;\n+        Optional<int> stop_height;\n+\n+        //! Height of the most recent block that could not be scanned due to\n+        //! read errors or pruning. Will be set if status is FAILURE, unset if\n+        //! status is SUCCESS, and may or may not be set if status is\n+        //! USER_ABORT.\n+        uint256 failed_block;\n     };\n-    ScanResult ScanForWalletTransactions(const CBlockIndex* const pindexStart, const CBlockIndex* const pindexStop, const WalletRescanReserver& reserver, const CBlockIndex*& failed_block, const CBlockIndex*& stop_block, bool fUpdate = false);\n+    ScanResult ScanForWalletTransactions(const uint256& first_block, const uint256& last_block, const WalletRescanReserver& reserver, bool fUpdate);\n     void TransactionRemovedFromMempool(const CTransactionRef &ptx) override;\n     void ReacceptWalletTransactions();\n     void ResendWalletTransactions(int64_t nBestBlockTime, CConnman* connman) override EXCLUSIVE_LOCKS_REQUIRED(cs_main);"
      }
    ]
  },
  {
    "sha": "44de1561aaf7556bb8ae8b582c233742ff76767d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NGRlMTU2MWFhZjc1NTZiYjhhZThiNTgyYzIzMzc0MmZmNzY3Njdk",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2019-01-08T08:06:24Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2019-01-15T16:42:00Z"
      },
      "message": "Remove remaining chainActive references from CWallet\n\nThis commit does not change behavior.\n\nCo-authored-by: Ben Woosley <ben.woosley@gmail.com>",
      "tree": {
        "sha": "9b4497111bdfb87a5b37516283ee21a37f852440",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9b4497111bdfb87a5b37516283ee21a37f852440"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/44de1561aaf7556bb8ae8b582c233742ff76767d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/44de1561aaf7556bb8ae8b582c233742ff76767d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/44de1561aaf7556bb8ae8b582c233742ff76767d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/44de1561aaf7556bb8ae8b582c233742ff76767d/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "db21f0264855406c9b6ec4c084a15988c5c71b32",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/db21f0264855406c9b6ec4c084a15988c5c71b32",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/db21f0264855406c9b6ec4c084a15988c5c71b32"
      }
    ],
    "stats": {
      "total": 90,
      "additions": 67,
      "deletions": 23
    },
    "files": [
      {
        "sha": "38888be8a3b77def12cda7e022719a6d1f01b85b",
        "filename": "src/interfaces/chain.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/44de1561aaf7556bb8ae8b582c233742ff76767d/src/interfaces/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/44de1561aaf7556bb8ae8b582c233742ff76767d/src/interfaces/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.cpp?ref=44de1561aaf7556bb8ae8b582c233742ff76767d",
        "patch": "@@ -60,6 +60,11 @@ class LockImpl : public Chain::Lock\n         assert(block != nullptr);\n         return block->GetMedianTimePast();\n     }\n+    bool haveBlockOnDisk(int height) override\n+    {\n+        CBlockIndex* block = ::chainActive[height];\n+        return block && ((block->nStatus & BLOCK_HAVE_DATA) != 0) && block->nTx > 0;\n+    }\n     Optional<int> findFirstBlockWithTime(int64_t time, uint256* hash) override\n     {\n         CBlockIndex* block = ::chainActive.FindEarliestAtLeast(time);\n@@ -112,6 +117,21 @@ class LockImpl : public Chain::Lock\n         }\n         return nullopt;\n     }\n+    bool isPotentialTip(const uint256& hash) override\n+    {\n+        if (::chainActive.Tip()->GetBlockHash() == hash) return true;\n+        CBlockIndex* block = LookupBlockIndex(hash);\n+        return block && block->GetAncestor(::chainActive.Height()) == ::chainActive.Tip();\n+    }\n+    CBlockLocator getLocator() override { return ::chainActive.GetLocator(); }\n+    Optional<int> findLocatorFork(const CBlockLocator& locator) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        if (CBlockIndex* fork = FindForkInGlobalIndex(::chainActive, locator)) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n };\n \n class LockingStateImpl : public LockImpl, public UniqueLock<CCriticalSection>"
      },
      {
        "sha": "735d5b60dfb4c3f7f4c4f66db3107031d925dc0f",
        "filename": "src/interfaces/chain.h",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/44de1561aaf7556bb8ae8b582c233742ff76767d/src/interfaces/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/44de1561aaf7556bb8ae8b582c233742ff76767d/src/interfaces/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.h?ref=44de1561aaf7556bb8ae8b582c233742ff76767d",
        "patch": "@@ -15,6 +15,7 @@\n class CBlock;\n class CScheduler;\n class uint256;\n+struct CBlockLocator;\n \n namespace interfaces {\n \n@@ -58,6 +59,10 @@ class Chain\n         //! will abort.\n         virtual int64_t getBlockMedianTimePast(int height) = 0;\n \n+        //! Check that the block is available on disk (i.e. has not been\n+        //! pruned), and contains transactions.\n+        virtual bool haveBlockOnDisk(int height) = 0;\n+\n         //! Return height of the first block in the chain with timestamp equal\n         //! or greater than the given time, or nullopt if there is no block with\n         //! a high enough timestamp. Also return the block hash as an optional\n@@ -84,6 +89,19 @@ class Chain\n         //! parameter (to avoid the cost of a second hash lookup in case this\n         //! information is desired).\n         virtual Optional<int> findFork(const uint256& hash, Optional<int>* height) = 0;\n+\n+        //! Return true if block hash points to the current chain tip, or to a\n+        //! possible descendant of the current chain tip that isn't currently\n+        //! connected.\n+        virtual bool isPotentialTip(const uint256& hash) = 0;\n+\n+        //! Get locator for the current chain tip.\n+        virtual CBlockLocator getLocator() = 0;\n+\n+        //! Return height of the latest block common to locator and chain, which\n+        //! is guaranteed to be an ancestor of the block used to create the\n+        //! locator.\n+        virtual Optional<int> findLocatorFork(const CBlockLocator& locator) = 0;\n     };\n \n     //! Return Lock interface. Chain is locked when this is called, and"
      },
      {
        "sha": "bea9ebefa30d2cb10e8f39d7481cc33612cdefd9",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 19,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/44de1561aaf7556bb8ae8b582c233742ff76767d/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/44de1561aaf7556bb8ae8b582c233742ff76767d/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=44de1561aaf7556bb8ae8b582c233742ff76767d",
        "patch": "@@ -1166,7 +1166,7 @@ void CWallet::BlockConnected(const std::shared_ptr<const CBlock>& pblock, const\n         TransactionRemovedFromMempool(pblock->vtx[i]);\n     }\n \n-    m_last_block_processed = pindex;\n+    m_last_block_processed = pindex->GetBlockHash();\n }\n \n void CWallet::BlockDisconnected(const std::shared_ptr<const CBlock>& pblock) {\n@@ -1191,9 +1191,8 @@ void CWallet::BlockUntilSyncedToCurrentChain() {\n         // protected by cs_wallet instead of cs_main, but as long as we need\n         // cs_main here anyway, it's easier to just call it cs_main-protected.\n         auto locked_chain = chain().lock();\n-        const CBlockIndex* initialChainTip = chainActive.Tip();\n \n-        if (m_last_block_processed && m_last_block_processed->GetAncestor(initialChainTip->nHeight) == initialChainTip) {\n+        if (!m_last_block_processed.IsNull() && locked_chain->isPotentialTip(m_last_block_processed)) {\n             return;\n         }\n     }\n@@ -4074,7 +4073,7 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,\n         }\n \n         auto locked_chain = chain.assumeLocked();  // Temporary. Removed in upcoming lock cleanup\n-        walletInstance->ChainStateFlushed(chainActive.GetLocator());\n+        walletInstance->ChainStateFlushed(locked_chain->getLocator());\n     } else if (wallet_creation_flags & WALLET_FLAG_DISABLE_PRIVATE_KEYS) {\n         // Make it impossible to disable private keys after creation\n         InitError(strprintf(_(\"Error loading %s: Private keys can only be disabled during creation\"), walletFile));\n@@ -4161,57 +4160,67 @@ std::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,\n     // Try to top up keypool. No-op if the wallet is locked.\n     walletInstance->TopUpKeyPool();\n \n-    LockAnnotation lock(::cs_main); // Temporary, for FindForkInGlobalIndex below. Removed in upcoming commit.\n     auto locked_chain = chain.lock();\n     LOCK(walletInstance->cs_wallet);\n \n-    CBlockIndex *pindexRescan = chainActive.Genesis();\n+    int rescan_height = 0;\n     if (!gArgs.GetBoolArg(\"-rescan\", false))\n     {\n         WalletBatch batch(*walletInstance->database);\n         CBlockLocator locator;\n-        if (batch.ReadBestBlock(locator))\n-            pindexRescan = FindForkInGlobalIndex(chainActive, locator);\n+        if (batch.ReadBestBlock(locator)) {\n+            if (const Optional<int> fork_height = locked_chain->findLocatorFork(locator)) {\n+                rescan_height = *fork_height;\n+            }\n+        }\n     }\n \n-    walletInstance->m_last_block_processed = chainActive.Tip();\n+    const Optional<int> tip_height = locked_chain->getHeight();\n+    if (tip_height) {\n+        walletInstance->m_last_block_processed = locked_chain->getBlockHash(*tip_height);\n+    } else {\n+        walletInstance->m_last_block_processed.SetNull();\n+    }\n \n-    if (chainActive.Tip() && chainActive.Tip() != pindexRescan)\n+    if (tip_height && *tip_height != rescan_height)\n     {\n         //We can't rescan beyond non-pruned blocks, stop and throw an error\n         //this might happen if a user uses an old wallet within a pruned node\n         // or if he ran -disablewallet for a longer time, then decided to re-enable\n         if (fPruneMode)\n         {\n-            CBlockIndex *block = chainActive.Tip();\n-            while (block && block->pprev && (block->pprev->nStatus & BLOCK_HAVE_DATA) && block->pprev->nTx > 0 && pindexRescan != block)\n-                block = block->pprev;\n+            int block_height = *tip_height;\n+            while (block_height > 0 && locked_chain->haveBlockOnDisk(block_height - 1) && rescan_height != block_height) {\n+                --block_height;\n+            }\n \n-            if (pindexRescan != block) {\n+            if (rescan_height != block_height) {\n                 InitError(_(\"Prune: last wallet synchronisation goes beyond pruned data. You need to -reindex (download the whole blockchain again in case of pruned node)\"));\n                 return nullptr;\n             }\n         }\n \n         uiInterface.InitMessage(_(\"Rescanning...\"));\n-        walletInstance->WalletLogPrintf(\"Rescanning last %i blocks (from block %i)...\\n\", chainActive.Height() - pindexRescan->nHeight, pindexRescan->nHeight);\n+        walletInstance->WalletLogPrintf(\"Rescanning last %i blocks (from block %i)...\\n\", *tip_height - rescan_height, rescan_height);\n \n         // No need to read and scan block if block was created before\n         // our wallet birthday (as adjusted for block time variability)\n-        while (pindexRescan && walletInstance->nTimeFirstKey && (pindexRescan->GetBlockTime() < (walletInstance->nTimeFirstKey - TIMESTAMP_WINDOW))) {\n-            pindexRescan = chainActive.Next(pindexRescan);\n+        if (walletInstance->nTimeFirstKey) {\n+            if (Optional<int> first_block = locked_chain->findFirstBlockWithTimeAndHeight(walletInstance->nTimeFirstKey - TIMESTAMP_WINDOW, rescan_height)) {\n+                rescan_height = *first_block;\n+            }\n         }\n \n         nStart = GetTimeMillis();\n         {\n             WalletRescanReserver reserver(walletInstance.get());\n-            if (!reserver.reserve() || (ScanResult::SUCCESS != walletInstance->ScanForWalletTransactions(pindexRescan->GetBlockHash(), {} /* stop block */, reserver, true /* update */).status)) {\n+            if (!reserver.reserve() || (ScanResult::SUCCESS != walletInstance->ScanForWalletTransactions(locked_chain->getBlockHash(rescan_height), {} /* stop block */, reserver, true /* update */).status)) {\n                 InitError(_(\"Failed to rescan the wallet during initialization\"));\n                 return nullptr;\n             }\n         }\n         walletInstance->WalletLogPrintf(\"Rescan completed in %15dms\\n\", GetTimeMillis() - nStart);\n-        walletInstance->ChainStateFlushed(chainActive.GetLocator());\n+        walletInstance->ChainStateFlushed(locked_chain->getLocator());\n         walletInstance->database->IncrementUpdateCounter();\n \n         // Restore wallet transaction metadata after -zapwallettxes=1"
      },
      {
        "sha": "fa18e3a6fa555b17350a6363d5a435ab7f3aa800",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/44de1561aaf7556bb8ae8b582c233742ff76767d/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/44de1561aaf7556bb8ae8b582c233742ff76767d/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=44de1561aaf7556bb8ae8b582c233742ff76767d",
        "patch": "@@ -95,7 +95,6 @@ static const bool DEFAULT_DISABLE_WALLET = false;\n //! Pre-calculated constants for input size estimation in *virtual size*\n static constexpr size_t DUMMY_NESTED_P2WPKH_INPUT_SIZE = 91;\n \n-class CBlockIndex;\n class CCoinControl;\n class COutput;\n class CReserveKey;\n@@ -723,10 +722,8 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n      * Note that this is *not* how far we've processed, we may need some rescan\n      * to have seen all transactions in the chain, but is only used to track\n      * live BlockConnected callbacks.\n-     *\n-     * Protected by cs_main (see BlockUntilSyncedToCurrentChain)\n      */\n-    const CBlockIndex* m_last_block_processed = nullptr;\n+    uint256 m_last_block_processed;\n \n public:\n     /*"
      }
    ]
  }
]