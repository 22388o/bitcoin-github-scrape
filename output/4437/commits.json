[
  {
    "sha": "de79aaa7a9ad07664461ee8735299aa68c630969",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkZTc5YWFhN2E5YWQwNzY2NDQ2MWVlODczNTI5OWFhNjhjNjMwOTY5",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-06-28T15:35:22Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-06-28T16:02:42Z"
      },
      "message": "Move non-trivial uint256.h methods to uint256.cpp",
      "tree": {
        "sha": "8c5f88f95403ab6c3c5a23374f93e8ab686dc6c9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8c5f88f95403ab6c3c5a23374f93e8ab686dc6c9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/de79aaa7a9ad07664461ee8735299aa68c630969",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/de79aaa7a9ad07664461ee8735299aa68c630969",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/de79aaa7a9ad07664461ee8735299aa68c630969",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/de79aaa7a9ad07664461ee8735299aa68c630969/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "236ae8665efadf7b4456c0a9fbf204a5cb4ce9f4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/236ae8665efadf7b4456c0a9fbf204a5cb4ce9f4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/236ae8665efadf7b4456c0a9fbf204a5cb4ce9f4"
      }
    ],
    "stats": {
      "total": 561,
      "additions": 316,
      "deletions": 245
    },
    "files": [
      {
        "sha": "9c7b294d35446d1985529b512361ff1afd802314",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de79aaa7a9ad07664461ee8735299aa68c630969/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de79aaa7a9ad07664461ee8735299aa68c630969/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=de79aaa7a9ad07664461ee8735299aa68c630969",
        "patch": "@@ -192,6 +192,7 @@ libbitcoin_util_a_SOURCES = \\\n   chainparamsbase.cpp \\\n   rpcprotocol.cpp \\\n   sync.cpp \\\n+  uint256.cpp \\\n   util.cpp \\\n   version.cpp \\\n   compat/glibc_sanity.cpp \\"
      },
      {
        "sha": "3392f1e9bcc06afbd7b9188f559a12140c2ddf1d",
        "filename": "src/uint256.cpp",
        "status": "added",
        "additions": 292,
        "deletions": 0,
        "changes": 292,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de79aaa7a9ad07664461ee8735299aa68c630969/src/uint256.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de79aaa7a9ad07664461ee8735299aa68c630969/src/uint256.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/uint256.cpp?ref=de79aaa7a9ad07664461ee8735299aa68c630969",
        "patch": "@@ -0,0 +1,292 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2014 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"uint256.h\"\n+#include \"util.h\"\n+\n+#include <stdio.h>\n+#include <string.h>\n+\n+template<unsigned int BITS>\n+base_uint<BITS>::base_uint(const std::string& str)\n+{\n+    SetHex(str);\n+}\n+\n+template<unsigned int BITS>\n+base_uint<BITS>::base_uint(const std::vector<unsigned char>& vch)\n+{\n+    if (vch.size() != sizeof(pn))\n+        throw uint_error(\"Converting vector of wrong size to base_uint\");\n+    memcpy(pn, &vch[0], sizeof(pn));\n+}\n+\n+template<unsigned int BITS>\n+base_uint<BITS>& base_uint<BITS>::operator<<=(unsigned int shift)\n+{\n+    base_uint<BITS> a(*this);\n+    for (int i = 0; i < WIDTH; i++)\n+        pn[i] = 0;\n+    int k = shift / 32;\n+    shift = shift % 32;\n+    for (int i = 0; i < WIDTH; i++) {\n+        if (i+k+1 < WIDTH && shift != 0)\n+            pn[i+k+1] |= (a.pn[i] >> (32-shift));\n+        if (i+k < WIDTH)\n+            pn[i+k] |= (a.pn[i] << shift);\n+    }\n+    return *this;\n+}\n+\n+template<unsigned int BITS>\n+base_uint<BITS>& base_uint<BITS>::operator>>=(unsigned int shift)\n+{\n+    base_uint<BITS> a(*this);\n+    for (int i = 0; i < WIDTH; i++)\n+        pn[i] = 0;\n+    int k = shift / 32;\n+    shift = shift % 32;\n+    for (int i = 0; i < WIDTH; i++) {\n+        if (i-k-1 >= 0 && shift != 0)\n+            pn[i-k-1] |= (a.pn[i] << (32-shift));\n+        if (i-k >= 0)\n+            pn[i-k] |= (a.pn[i] >> shift);\n+    }\n+    return *this;\n+}\n+\n+template<unsigned int BITS>\n+base_uint<BITS>& base_uint<BITS>::operator*=(uint32_t b32)\n+{\n+    uint64_t carry = 0;\n+    for (int i = 0; i < WIDTH; i++) {\n+        uint64_t n = carry + (uint64_t)b32 * pn[i];\n+        pn[i] = n & 0xffffffff;\n+        carry = n >> 32;\n+    }\n+    return *this;\n+}\n+\n+template<unsigned int BITS>\n+base_uint<BITS>& base_uint<BITS>::operator*=(const base_uint& b)\n+{\n+    base_uint<BITS> a = *this;\n+    *this = 0;\n+    for (int j = 0; j < WIDTH; j++) {\n+        uint64_t carry = 0;\n+        for (int i = 0; i + j < WIDTH; i++) {\n+            uint64_t n = carry + pn[i + j] + (uint64_t)a.pn[j] * b.pn[i];\n+            pn[i + j] = n & 0xffffffff;\n+            carry = n >> 32;\n+        }\n+    }\n+    return *this;\n+}\n+\n+template<unsigned int BITS>\n+base_uint<BITS>& base_uint<BITS>::operator/=(const base_uint& b)\n+{\n+    base_uint<BITS> div = b; // make a copy, so we can shift.\n+    base_uint<BITS> num = *this; // make a copy, so we can subtract.\n+    *this = 0; // the quotient.\n+    int num_bits = num.bits();\n+    int div_bits = div.bits();\n+    if (div_bits == 0)\n+        throw uint_error(\"Division by zero\");\n+    if (div_bits > num_bits) // the result is certainly 0.\n+        return *this;\n+    int shift = num_bits - div_bits;\n+    div <<= shift; // shift so that div and nun align.\n+    while (shift >= 0) {\n+        if (num >= div) {\n+            num -= div;\n+            pn[shift / 32] |= (1 << (shift & 31)); // set a bit of the result.\n+        }\n+        div >>= 1; // shift back.\n+        shift--;\n+    }\n+    // num now contains the remainder of the division.\n+    return *this;\n+}\n+\n+template<unsigned int BITS>\n+int base_uint<BITS>::CompareTo(const base_uint<BITS>& b) const {\n+    for (int i = WIDTH-1; i >= 0; i--) {\n+        if (pn[i] < b.pn[i])\n+            return -1;\n+        if (pn[i] > b.pn[i])\n+            return 1;\n+    }\n+    return 0;\n+}\n+\n+template<unsigned int BITS>\n+bool base_uint<BITS>::EqualTo(uint64_t b) const {\n+    for (int i = WIDTH-1; i >= 2; i--) {\n+        if (pn[i])\n+            return false;\n+    }\n+    if (pn[1] != (b >> 32))\n+        return false;\n+    if (pn[0] != (b & 0xfffffffful))\n+        return false;\n+    return true;\n+}\n+\n+template<unsigned int BITS>\n+double base_uint<BITS>::getdouble() const\n+{\n+    double ret = 0.0;\n+    double fact = 1.0;\n+    for (int i = 0; i < WIDTH; i++) {\n+        ret += fact * pn[i];\n+        fact *= 4294967296.0;\n+    }\n+    return ret;\n+}\n+\n+template<unsigned int BITS>\n+std::string base_uint<BITS>::GetHex() const\n+{\n+    char psz[sizeof(pn)*2 + 1];\n+    for (unsigned int i = 0; i < sizeof(pn); i++)\n+        sprintf(psz + i*2, \"%02x\", ((unsigned char*)pn)[sizeof(pn) - i - 1]);\n+    return std::string(psz, psz + sizeof(pn)*2);\n+}\n+\n+template<unsigned int BITS>\n+void base_uint<BITS>::SetHex(const char* psz)\n+{\n+    memset(pn,0,sizeof(pn));\n+\n+    // skip leading spaces\n+    while (isspace(*psz))\n+        psz++;\n+\n+    // skip 0x\n+    if (psz[0] == '0' && tolower(psz[1]) == 'x')\n+        psz += 2;\n+\n+    // hex string to uint\n+    const char* pbegin = psz;\n+    while (::HexDigit(*psz) != -1)\n+        psz++;\n+    psz--;\n+    unsigned char* p1 = (unsigned char*)pn;\n+    unsigned char* pend = p1 + WIDTH * 4;\n+    while (psz >= pbegin && p1 < pend) {\n+        *p1 = ::HexDigit(*psz--);\n+        if (psz >= pbegin) {\n+            *p1 |= ((unsigned char)::HexDigit(*psz--) << 4);\n+            p1++;\n+        }\n+    }\n+}\n+\n+template<unsigned int BITS>\n+void base_uint<BITS>::SetHex(const std::string& str)\n+{\n+    SetHex(str.c_str());\n+}\n+\n+template<unsigned int BITS>\n+std::string base_uint<BITS>::ToString() const\n+{\n+    return (GetHex());\n+}\n+\n+template<unsigned int BITS>\n+unsigned int base_uint<BITS>::bits() const\n+{\n+    for (int pos = WIDTH-1; pos >= 0; pos--) {\n+        if (pn[pos]) {\n+            for (int bits = 31; bits > 0; bits--) {\n+                if (pn[pos] & 1<<bits)\n+                    return 32*pos + bits + 1;\n+            }\n+            return 32*pos + 1;\n+        }\n+    }\n+    return 0;\n+}\n+\n+// Explicit instantiations for base_uint<160>\n+template base_uint<160>::base_uint(const std::string&);\n+template base_uint<160>::base_uint(const std::vector<unsigned char>&);\n+template base_uint<160>& base_uint<160>::operator<<=(unsigned int);\n+template base_uint<160>& base_uint<160>::operator>>=(unsigned int);\n+template base_uint<160>& base_uint<160>::operator*=(uint32_t b32);\n+template base_uint<160>& base_uint<160>::operator*=(const base_uint<160>& b);\n+template base_uint<160>& base_uint<160>::operator/=(const base_uint<160>& b);\n+template int base_uint<160>::CompareTo(const base_uint<160>&) const;\n+template bool base_uint<160>::EqualTo(uint64_t) const;\n+template double base_uint<160>::getdouble() const;\n+template std::string base_uint<160>::GetHex() const;\n+template std::string base_uint<160>::ToString() const;\n+template void base_uint<160>::SetHex(const char*);\n+template void base_uint<160>::SetHex(const std::string&);\n+template unsigned int base_uint<160>::bits() const;\n+\n+// Explicit instantiations for base_uint<256>\n+template base_uint<256>::base_uint(const std::string&);\n+template base_uint<256>::base_uint(const std::vector<unsigned char>&);\n+template base_uint<256>& base_uint<256>::operator<<=(unsigned int);\n+template base_uint<256>& base_uint<256>::operator>>=(unsigned int);\n+template base_uint<256>& base_uint<256>::operator*=(uint32_t b32);\n+template base_uint<256>& base_uint<256>::operator*=(const base_uint<256>& b);\n+template base_uint<256>& base_uint<256>::operator/=(const base_uint<256>& b);\n+template int base_uint<256>::CompareTo(const base_uint<256>&) const;\n+template bool base_uint<256>::EqualTo(uint64_t) const;\n+template double base_uint<256>::getdouble() const;\n+template std::string base_uint<256>::GetHex() const;\n+template std::string base_uint<256>::ToString() const;\n+template void base_uint<256>::SetHex(const char*);\n+template void base_uint<256>::SetHex(const std::string&);\n+template unsigned int base_uint<256>::bits() const;\n+\n+// This implementation directly uses shifts instead of going\n+// through an intermediate MPI representation.\n+uint256& uint256::SetCompact(uint32_t nCompact, bool *pfNegative, bool *pfOverflow)\n+{\n+    int nSize = nCompact >> 24;\n+    uint32_t nWord = nCompact & 0x007fffff;\n+    if (nSize <= 3) {\n+        nWord >>= 8*(3-nSize);\n+        *this = nWord;\n+    } else {\n+        *this = nWord;\n+        *this <<= 8*(nSize-3);\n+    }\n+    if (pfNegative)\n+        *pfNegative = nWord != 0 && (nCompact & 0x00800000) != 0;\n+    if (pfOverflow)\n+        *pfOverflow = nWord != 0 && ((nSize > 34) ||\n+                                     (nWord > 0xff && nSize > 33) ||\n+                                     (nWord > 0xffff && nSize > 32));\n+    return *this;\n+}\n+\n+uint32_t uint256::GetCompact(bool fNegative) const\n+{\n+    int nSize = (bits() + 7) / 8;\n+    uint32_t nCompact = 0;\n+    if (nSize <= 3) {\n+        nCompact = GetLow64() << 8*(3-nSize);\n+    } else {\n+        uint256 bn = *this >> 8*(nSize-3);\n+        nCompact = bn.GetLow64();\n+    }\n+    // The 0x00800000 bit denotes the sign.\n+    // Thus, if it is already set, divide the mantissa by 256 and increase the exponent.\n+    if (nCompact & 0x00800000) {\n+        nCompact >>= 8;\n+        nSize++;\n+    }\n+    assert((nCompact & ~0x007fffff) == 0);\n+    assert(nSize < 256);\n+    nCompact |= nSize << 24;\n+    nCompact |= (fNegative && (nCompact & 0x007fffff) ? 0x00800000 : 0);\n+    return nCompact;\n+}"
      },
      {
        "sha": "82db7758c936bd56604929ffd0a63f236a07105f",
        "filename": "src/uint256.h",
        "status": "modified",
        "additions": 17,
        "deletions": 245,
        "changes": 262,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de79aaa7a9ad07664461ee8735299aa68c630969/src/uint256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de79aaa7a9ad07664461ee8735299aa68c630969/src/uint256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/uint256.h?ref=de79aaa7a9ad07664461ee8735299aa68c630969",
        "patch": "@@ -9,18 +9,9 @@\n #include <assert.h>\n #include <stdexcept>\n #include <stdint.h>\n-#include <stdio.h>\n #include <string>\n-#include <string.h>\n #include <vector>\n \n-extern const signed char p_util_hexdigit[256]; // defined in util.cpp\n-\n-inline signed char HexDigit(char c)\n-{\n-    return p_util_hexdigit[(unsigned char)c];\n-}\n-\n class uint_error : public std::runtime_error {\n public:\n     explicit uint_error(const std::string& str) : std::runtime_error(str) {}\n@@ -62,17 +53,8 @@ class base_uint\n             pn[i] = 0;\n     }\n \n-    explicit base_uint(const std::string& str)\n-    {\n-        SetHex(str);\n-    }\n-\n-    explicit base_uint(const std::vector<unsigned char>& vch)\n-    {\n-        if (vch.size() != sizeof(pn))\n-            throw uint_error(\"Converting vector of wrong size to base_uint\");\n-        memcpy(pn, &vch[0], sizeof(pn));\n-    }\n+    explicit base_uint(const std::string& str);\n+    explicit base_uint(const std::vector<unsigned char>& vch);\n \n     bool operator!() const\n     {\n@@ -99,16 +81,7 @@ class base_uint\n         return ret;\n     }\n \n-    double getdouble() const\n-    {\n-        double ret = 0.0;\n-        double fact = 1.0;\n-        for (int i = 0; i < WIDTH; i++) {\n-            ret += fact * pn[i];\n-            fact *= 4294967296.0;\n-        }\n-        return ret;\n-    }\n+    double getdouble() const;\n \n     base_uint& operator=(uint64_t b)\n     {\n@@ -154,39 +127,8 @@ class base_uint\n         return *this;\n     }\n \n-    base_uint& operator<<=(unsigned int shift)\n-    {\n-        base_uint a(*this);\n-        for (int i = 0; i < WIDTH; i++)\n-            pn[i] = 0;\n-        int k = shift / 32;\n-        shift = shift % 32;\n-        for (int i = 0; i < WIDTH; i++)\n-        {\n-            if (i+k+1 < WIDTH && shift != 0)\n-                pn[i+k+1] |= (a.pn[i] >> (32-shift));\n-            if (i+k < WIDTH)\n-                pn[i+k] |= (a.pn[i] << shift);\n-        }\n-        return *this;\n-    }\n-\n-    base_uint& operator>>=(unsigned int shift)\n-    {\n-        base_uint a(*this);\n-        for (int i = 0; i < WIDTH; i++)\n-            pn[i] = 0;\n-        int k = shift / 32;\n-        shift = shift % 32;\n-        for (int i = 0; i < WIDTH; i++)\n-        {\n-            if (i-k-1 >= 0 && shift != 0)\n-                pn[i-k-1] |= (a.pn[i] << (32-shift));\n-            if (i-k >= 0)\n-                pn[i-k] |= (a.pn[i] >> shift);\n-        }\n-        return *this;\n-    }\n+    base_uint& operator<<=(unsigned int shift);\n+    base_uint& operator>>=(unsigned int shift);\n \n     base_uint& operator+=(const base_uint& b)\n     {\n@@ -222,57 +164,9 @@ class base_uint\n         return *this;\n     }\n \n-    base_uint& operator*=(uint32_t b32)\n-    {\n-        uint64_t carry = 0;\n-        for (int i = 0; i < WIDTH; i++)\n-        {\n-            uint64_t n = carry + (uint64_t)b32 * pn[i];\n-            pn[i] = n & 0xffffffff;\n-            carry = n >> 32;\n-        }\n-        return *this;\n-    }\n-\n-    base_uint& operator*=(const base_uint& b)\n-    {\n-        base_uint a = *this;\n-        *this = 0;\n-        for (int j = 0; j < WIDTH; j++) {\n-            uint64_t carry = 0;\n-            for (int i = 0; i + j < WIDTH; i++) {\n-                uint64_t n = carry + pn[i + j] + (uint64_t)a.pn[j] * b.pn[i];\n-                pn[i + j] = n & 0xffffffff;\n-                carry = n >> 32;\n-            }\n-        }\n-        return *this;\n-    }\n-\n-    base_uint& operator/=(const base_uint& b)\n-    {\n-        base_uint div = b; // make a copy, so we can shift.\n-        base_uint num = *this; // make a copy, so we can subtract.\n-        *this = 0; // the quotient.\n-        int num_bits = num.bits();\n-        int div_bits = div.bits();\n-        if (div_bits == 0)\n-            throw uint_error(\"Division by zero\");\n-        if (div_bits > num_bits) // the result is certainly 0.\n-            return *this;\n-        int shift = num_bits - div_bits;\n-        div <<= shift; // shift so that div and nun align.\n-        while (shift >= 0) {\n-            if (num >= div) {\n-                num -= div;\n-                pn[shift / 32] |= (1 << (shift & 31)); // set a bit of the result.\n-            }\n-            div >>= 1; // shift back.\n-            shift--;\n-        }\n-        // num now contains the remainder of the division.\n-        return *this;\n-    }\n+    base_uint& operator*=(uint32_t b32);\n+    base_uint& operator*=(const base_uint& b);\n+    base_uint& operator/=(const base_uint& b);\n \n     base_uint& operator++()\n     {\n@@ -308,27 +202,8 @@ class base_uint\n         return ret;\n     }\n \n-    int CompareTo(const base_uint& b) const {\n-        for (int i = base_uint::WIDTH-1; i >= 0; i--) {\n-            if (pn[i] < b.pn[i])\n-                return -1;\n-            if (pn[i] > b.pn[i])\n-                return 1;\n-        }\n-        return 0;\n-    }\n-\n-    bool EqualTo(uint64_t b) const {\n-        for (int i = base_uint::WIDTH-1; i >= 2; i--) {\n-            if (pn[i])\n-                return false;\n-        }\n-        if (pn[1] != (b >> 32))\n-            return false;\n-        if (pn[0] != (b & 0xfffffffful))\n-            return false;\n-        return true;\n-    }\n+    int CompareTo(const base_uint& b) const;\n+    bool EqualTo(uint64_t b) const;\n \n     friend inline const base_uint operator+(const base_uint& a, const base_uint& b) { return base_uint(a) += b; }\n     friend inline const base_uint operator-(const base_uint& a, const base_uint& b) { return base_uint(a) -= b; }\n@@ -349,53 +224,10 @@ class base_uint\n     friend inline bool operator==(const base_uint& a, uint64_t b) { return a.EqualTo(b); }\n     friend inline bool operator!=(const base_uint& a, uint64_t b) { return !a.EqualTo(b); }\n \n-    std::string GetHex() const\n-    {\n-        char psz[sizeof(pn)*2 + 1];\n-        for (unsigned int i = 0; i < sizeof(pn); i++)\n-            sprintf(psz + i*2, \"%02x\", ((unsigned char*)pn)[sizeof(pn) - i - 1]);\n-        return std::string(psz, psz + sizeof(pn)*2);\n-    }\n-\n-    void SetHex(const char* psz)\n-    {\n-        memset(pn,0,sizeof(pn));\n-\n-        // skip leading spaces\n-        while (isspace(*psz))\n-            psz++;\n-\n-        // skip 0x\n-        if (psz[0] == '0' && tolower(psz[1]) == 'x')\n-            psz += 2;\n-\n-        // hex string to uint\n-        const char* pbegin = psz;\n-        while (::HexDigit(*psz) != -1)\n-            psz++;\n-        psz--;\n-        unsigned char* p1 = (unsigned char*)pn;\n-        unsigned char* pend = p1 + WIDTH * 4;\n-        while (psz >= pbegin && p1 < pend)\n-        {\n-            *p1 = ::HexDigit(*psz--);\n-            if (psz >= pbegin)\n-            {\n-                *p1 |= ((unsigned char)::HexDigit(*psz--) << 4);\n-                p1++;\n-            }\n-        }\n-    }\n-\n-    void SetHex(const std::string& str)\n-    {\n-        SetHex(str.c_str());\n-    }\n-\n-    std::string ToString() const\n-    {\n-        return (GetHex());\n-    }\n+    std::string GetHex() const;\n+    void SetHex(const char* psz);\n+    void SetHex(const std::string& str);\n+    std::string ToString() const;\n \n     unsigned char* begin()\n     {\n@@ -424,19 +256,7 @@ class base_uint\n \n     // Returns the position of the highest bit set plus one, or zero if the\n     // value is zero.\n-    unsigned int bits() const\n-    {\n-        for (int pos = WIDTH-1; pos >= 0; pos--) {\n-            if (pn[pos]) {\n-                for (int bits = 31; bits > 0; bits--) {\n-                    if (pn[pos] & 1<<bits)\n-                        return 32*pos + bits + 1;\n-                }\n-                return 32*pos + 1;\n-            }\n-        }\n-        return 0;\n-    }\n+    unsigned int bits() const;\n \n     uint64_t GetLow64() const\n     {\n@@ -500,56 +320,8 @@ class uint256 : public base_uint<256> {\n     // targets, which are unsigned 256bit quantities.  Thus, all the\n     // complexities of the sign bit and using base 256 are probably an\n     // implementation accident.\n-    //\n-    // This implementation directly uses shifts instead of going\n-    // through an intermediate MPI representation.\n-    uint256& SetCompact(uint32_t nCompact, bool *pfNegative = NULL, bool *pfOverflow = NULL)\n-    {\n-        int nSize = nCompact >> 24;\n-        uint32_t nWord = nCompact & 0x007fffff;\n-        if (nSize <= 3)\n-        {\n-            nWord >>= 8*(3-nSize);\n-            *this = nWord;\n-        }\n-        else\n-        {\n-            *this = nWord;\n-            *this <<= 8*(nSize-3);\n-        }\n-        if (pfNegative)\n-            *pfNegative = nWord != 0 && (nCompact & 0x00800000) != 0;\n-        if (pfOverflow)\n-            *pfOverflow = nWord != 0 && ((nSize > 34) ||\n-                                         (nWord > 0xff && nSize > 33) ||\n-                                         (nWord > 0xffff && nSize > 32));\n-        return *this;\n-    }\n-\n-    uint32_t GetCompact(bool fNegative = false) const\n-    {\n-        int nSize = (bits() + 7) / 8;\n-        uint32_t nCompact = 0;\n-        if (nSize <= 3)\n-            nCompact = GetLow64() << 8*(3-nSize);\n-        else\n-        {\n-            uint256 bn = *this >> 8*(nSize-3);\n-            nCompact = bn.GetLow64();\n-        }\n-        // The 0x00800000 bit denotes the sign.\n-        // Thus, if it is already set, divide the mantissa by 256 and increase the exponent.\n-        if (nCompact & 0x00800000)\n-        {\n-            nCompact >>= 8;\n-            nSize++;\n-        }\n-        assert((nCompact & ~0x007fffff) == 0);\n-        assert(nSize < 256);\n-        nCompact |= nSize << 24;\n-        nCompact |= (fNegative && (nCompact & 0x007fffff) ? 0x00800000 : 0);\n-        return nCompact;\n-    }\n+    uint256& SetCompact(uint32_t nCompact, bool *pfNegative = NULL, bool *pfOverflow = NULL);\n+    uint32_t GetCompact(bool fNegative = false) const;\n };\n \n #endif"
      },
      {
        "sha": "e67c0dfd8ac2e55fcf3cf6938d63c389bbb27a32",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de79aaa7a9ad07664461ee8735299aa68c630969/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de79aaa7a9ad07664461ee8735299aa68c630969/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=de79aaa7a9ad07664461ee8735299aa68c630969",
        "patch": "@@ -419,6 +419,11 @@ const signed char p_util_hexdigit[256] =\n   -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n   -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, };\n \n+signed char HexDigit(char c)\n+{\n+    return p_util_hexdigit[(unsigned char)c];\n+}\n+\n bool IsHex(const string& str)\n {\n     BOOST_FOREACH(char c, str)"
      },
      {
        "sha": "707b8f2d7604a67b66b2a545769b50f508cd9bf1",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de79aaa7a9ad07664461ee8735299aa68c630969/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de79aaa7a9ad07664461ee8735299aa68c630969/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=de79aaa7a9ad07664461ee8735299aa68c630969",
        "patch": "@@ -156,6 +156,7 @@ bool ParseMoney(const char* pszIn, int64_t& nRet);\n std::string SanitizeString(const std::string& str);\n std::vector<unsigned char> ParseHex(const char* psz);\n std::vector<unsigned char> ParseHex(const std::string& str);\n+signed char HexDigit(char c);\n bool IsHex(const std::string& str);\n std::vector<unsigned char> DecodeBase64(const char* p, bool* pfInvalid = NULL);\n std::string DecodeBase64(const std::string& str);"
      }
    ]
  }
]