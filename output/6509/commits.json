[
  {
    "sha": "45a6cce971a96ebec6cc5d72921adbdde5ae4f18",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NWE2Y2NlOTcxYTk2ZWJlYzZjYzVkNzI5MjFhZGJkZGU1YWU0ZjE4",
    "commit": {
      "author": {
        "name": "Casey Rodarmor",
        "email": "casey@rodarmor.com",
        "date": "2015-08-03T18:51:12Z"
      },
      "committer": {
        "name": "Casey Rodarmor",
        "email": "casey@rodarmor.com",
        "date": "2015-08-12T15:02:43Z"
      },
      "message": "Fix race condition on test node shutdown",
      "tree": {
        "sha": "4de84a2f588d7eba2c8758a39d654ee00dd7ebd9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4de84a2f588d7eba2c8758a39d654ee00dd7ebd9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/45a6cce971a96ebec6cc5d72921adbdde5ae4f18",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/45a6cce971a96ebec6cc5d72921adbdde5ae4f18",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/45a6cce971a96ebec6cc5d72921adbdde5ae4f18",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/45a6cce971a96ebec6cc5d72921adbdde5ae4f18/comments",
    "author": {
      "login": "casey",
      "id": 1945,
      "node_id": "MDQ6VXNlcjE5NDU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1945?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/casey",
      "html_url": "https://github.com/casey",
      "followers_url": "https://api.github.com/users/casey/followers",
      "following_url": "https://api.github.com/users/casey/following{/other_user}",
      "gists_url": "https://api.github.com/users/casey/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/casey/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/casey/subscriptions",
      "organizations_url": "https://api.github.com/users/casey/orgs",
      "repos_url": "https://api.github.com/users/casey/repos",
      "events_url": "https://api.github.com/users/casey/events{/privacy}",
      "received_events_url": "https://api.github.com/users/casey/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "casey",
      "id": 1945,
      "node_id": "MDQ6VXNlcjE5NDU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1945?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/casey",
      "html_url": "https://github.com/casey",
      "followers_url": "https://api.github.com/users/casey/followers",
      "following_url": "https://api.github.com/users/casey/following{/other_user}",
      "gists_url": "https://api.github.com/users/casey/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/casey/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/casey/subscriptions",
      "organizations_url": "https://api.github.com/users/casey/orgs",
      "repos_url": "https://api.github.com/users/casey/repos",
      "events_url": "https://api.github.com/users/casey/events{/privacy}",
      "received_events_url": "https://api.github.com/users/casey/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a2bf40dde7465292a29234c6d32d9df7e386617e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a2bf40dde7465292a29234c6d32d9df7e386617e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a2bf40dde7465292a29234c6d32d9df7e386617e"
      }
    ],
    "stats": {
      "total": 94,
      "additions": 48,
      "deletions": 46
    },
    "files": [
      {
        "sha": "ffa9226a32f249c5bd0166503d3cc873c4d21698",
        "filename": "qa/rpc-tests/test_framework/comptool.py",
        "status": "modified",
        "additions": 48,
        "deletions": 46,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/45a6cce971a96ebec6cc5d72921adbdde5ae4f18/qa/rpc-tests/test_framework/comptool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/45a6cce971a96ebec6cc5d72921adbdde5ae4f18/qa/rpc-tests/test_framework/comptool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/comptool.py?ref=45a6cce971a96ebec6cc5d72921adbdde5ae4f18",
        "patch": "@@ -27,6 +27,20 @@\n \n global mininode_lock\n \n+def wait_until(predicate, attempts=float('inf'), timeout=float('inf')):\n+    attempt = 0\n+    elapsed = 0\n+\n+    while attempt < attempts and elapsed < timeout:\n+        with mininode_lock:\n+            if predicate():\n+                return True\n+        attempt += 1\n+        elapsed += 0.05\n+        time.sleep(0.05)\n+\n+    return False\n+\n class TestNode(NodeConnCB):\n \n     def __init__(self, block_store, tx_store):\n@@ -43,6 +57,10 @@ def __init__(self, block_store, tx_store):\n         # a response\n         self.pingMap = {} \n         self.lastInv = []\n+        self.closed = False\n+\n+    def on_close(self, conn):\n+        self.closed = True\n \n     def add_connection(self, conn):\n         self.conn = conn\n@@ -132,61 +150,48 @@ class TestManager(object):\n     def __init__(self, testgen, datadir):\n         self.test_generator = testgen\n         self.connections    = []\n+        self.test_nodes     = []\n         self.block_store    = BlockStore(datadir)\n         self.tx_store       = TxStore(datadir)\n         self.ping_counter   = 1\n \n     def add_all_connections(self, nodes):\n         for i in range(len(nodes)):\n             # Create a p2p connection to each node\n-            self.connections.append(NodeConn('127.0.0.1', p2p_port(i), \n-                        nodes[i], TestNode(self.block_store, self.tx_store)))\n+            test_node = TestNode(self.block_store, self.tx_store)\n+            self.test_nodes.append(test_node)\n+            self.connections.append(NodeConn('127.0.0.1', p2p_port(i), nodes[i], test_node))\n             # Make sure the TestNode (callback class) has a reference to its\n             # associated NodeConn\n-            self.connections[-1].cb.add_connection(self.connections[-1])\n+            test_node.add_connection(self.connections[-1])\n+\n+    def wait_for_disconnections(self):\n+        def disconnected():\n+            return all(node.closed for node in self.test_nodes)\n+        return wait_until(disconnected, timeout=10)\n \n     def wait_for_verack(self):\n-        sleep_time = 0.05\n-        max_tries = 10 / sleep_time  # Wait at most 10 seconds\n-        while max_tries > 0:\n-            done = True\n-            with mininode_lock:\n-                for c in self.connections:\n-                    if c.cb.verack_received is False:\n-                        done = False\n-                        break\n-            if done:\n-                break\n-            time.sleep(sleep_time)\n+        def veracked():\n+            return all(node.verack_received for node in self.test_nodes)\n+        return wait_until(veracked, timeout=10)\n \n     def wait_for_pings(self, counter):\n-        received_pongs = False\n-        while received_pongs is not True:\n-            time.sleep(0.05)\n-            received_pongs = True\n-            with mininode_lock:\n-                for c in self.connections:\n-                    if c.cb.received_ping_response(counter) is not True:\n-                        received_pongs = False\n-                        break\n+        def received_pongs():\n+            return all(node.received_ping_response(counter) for node in self.test_nodes)\n+        return wait_until(received_pongs)\n \n     # sync_blocks: Wait for all connections to request the blockhash given\n     # then send get_headers to find out the tip of each node, and synchronize\n     # the response by using a ping (and waiting for pong with same nonce).\n     def sync_blocks(self, blockhash, num_blocks):\n-        # Wait for nodes to request block (50ms sleep * 20 tries * num_blocks)\n-        max_tries = 20*num_blocks\n-        while max_tries > 0:\n-            with mininode_lock:\n-                results = [ blockhash in c.cb.block_request_map and\n-                            c.cb.block_request_map[blockhash] for c in self.connections ]\n-            if False not in results:\n-                break\n-            time.sleep(0.05)\n-            max_tries -= 1\n+        def blocks_requested():\n+            return all(\n+                blockhash in node.block_request_map and node.block_request_map[blockhash]\n+                for node in self.test_nodes\n+            )\n \n         # --> error if not requested\n-        if max_tries == 0:\n+        if not wait_until(blocks_requested, attempts=20*num_blocks):\n             # print [ c.cb.block_request_map for c in self.connections ]\n             raise AssertionError(\"Not all nodes requested block\")\n         # --> Answer request (we did this inline!)\n@@ -202,18 +207,14 @@ def sync_blocks(self, blockhash, num_blocks):\n     # Analogous to sync_block (see above)\n     def sync_transaction(self, txhash, num_events):\n         # Wait for nodes to request transaction (50ms sleep * 20 tries * num_events)\n-        max_tries = 20*num_events\n-        while max_tries > 0:\n-            with mininode_lock:\n-                results = [ txhash in c.cb.tx_request_map and\n-                            c.cb.tx_request_map[txhash] for c in self.connections ]\n-            if False not in results:\n-                break\n-            time.sleep(0.05)\n-            max_tries -= 1\n+        def transaction_requested():\n+            return all(\n+                txhash in node.tx_request_map and node.tx_request_map[txhash]\n+                for node in self.test_nodes\n+            )\n \n         # --> error if not requested\n-        if max_tries == 0:\n+        if not wait_until(transaction_requested, attempts=20*num_events):\n             # print [ c.cb.tx_request_map for c in self.connections ]\n             raise AssertionError(\"Not all nodes requested transaction\")\n         # --> Answer request (we did this inline!)\n@@ -336,6 +337,7 @@ def run(self):\n             print \"Test %d: PASS\" % test_number, [ c.rpc.getblockcount() for c in self.connections ]\n             test_number += 1\n \n+        [ c.disconnect_node() for c in self.connections ]\n+        self.wait_for_disconnections()\n         self.block_store.close()\n         self.tx_store.close()\n-        [ c.disconnect_node() for c in self.connections ]"
      }
    ]
  }
]