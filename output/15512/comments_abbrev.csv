DrahtBot,2019-03-05T10:36:13Z,"<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#15649](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/15649.html) (Add ChaCha20Poly1305@Bitcoin AEAD by jonass",https://github.com/bitcoin/bitcoin/pull/15512#issuecomment-469630268,469630268,
jnewbery,2019-05-03T21:01:44Z,"Looks good. utACK 2dfe2751713c814aea53b5a7563eb74ad1baea00.\n\nIn general, it's better to have less code duplication, so I'd like to hear from @sipa his reasoning for https://github.com/bitcoin/bitcoin/pull/15512#discussion_r269692281",https://github.com/bitcoin/bitcoin/pull/15512#issuecomment-489238698,489238698,
sipa,2019-05-03T21:09:20Z,"@jnewbery I just thought that it'd be preferable not to burden the RNG code with branches that are only used for encryption. In cryptographic code like this, I don't care too much about duplication, as it isn't code that subject to many possible future changes.",https://github.com/bitcoin/bitcoin/pull/15512#issuecomment-489240638,489240638,
jnewbery,2019-05-06T14:36:26Z,"ok, my aesthetic preference is for less duplication, either by having a single Keystream/Crypt function, or by calling Keystream() from Crypt() with a zero'ed message. As sipa points out though, this code is unlikely to be modified much in future, so it's not a big deal either way.\n\nutACK 2dfe2751713c814aea53b5a7563eb74ad1baea00",https://github.com/bitcoin/bitcoin/pull/15512#issuecomment-489644210,489644210,
sipa,2019-05-10T00:33:07Z,utACK 2dfe2751713c814aea53b5a7563eb74ad1baea00,https://github.com/bitcoin/bitcoin/pull/15512#issuecomment-491113087,491113087,
ryanofsky,2019-03-22T18:17:37Z,"A comment would be helpful here: ""If m has fewer than 64 bytes available, copy m to tmp and read from tmp instead""",https://github.com/bitcoin/bitcoin/pull/15512#discussion_r268286916,268286916,src/crypto/chacha20.cpp
ryanofsky,2019-03-22T18:18:51Z,"Just `memcpy(tmp, m, bytes)` might be simpler and easy to read than this for loop.",https://github.com/bitcoin/bitcoin/pull/15512#discussion_r268287371,268287371,src/crypto/chacha20.cpp
ryanofsky,2019-03-22T18:20:25Z,"Not sure what the benefit of defining XOR macro is. Isn't `x0 ^= ReadLE32(m + 0)` more readable and less error-prone than `x0 = XOR(x0, ReadLE32(m + 0))`?",https://github.com/bitcoin/bitcoin/pull/15512#discussion_r268287967,268287967,src/crypto/chacha20.cpp
ryanofsky,2019-03-22T18:25:42Z,"This comment seems imply that output is not written if input is null. Maybe rephrase: ""If \<input> is non-null, the specified number of \<bytes> from \<input> will encrypted and written to \<output>, otherwise just the keystream will be written to \<output\> (which may be useful for random number generation). Either way, the number of bytes written to \<output> will be \<bytes>.""",https://github.com/bitcoin/bitcoin/pull/15512#discussion_r268289944,268289944,src/crypto/chacha20.h
ryanofsky,2019-03-22T18:36:40Z,Maybe `assert(hex_message.empty() || m.size() == out.size())`,https://github.com/bitcoin/bitcoin/pull/15512#discussion_r268293664,268293664,src/test/crypto_tests.cpp
ryanofsky,2019-03-22T18:50:31Z,"It seems like a useful additional test would be call `rng.Output` twice if `hex_message` is nonempty, once with input and once without, and confirm that xoring the two outputs yields the input again.",https://github.com/bitcoin/bitcoin/pull/15512#discussion_r268298310,268298310,src/test/crypto_tests.cpp
jonasschnelli,2019-03-25T20:07:20Z,I'm not to familiar with compiler optimisations and stuff but I just checked the reference implementation by DJB and some other C based ChaCha implementations and all of them seems to use the byte per byte assignment. I prefer to leave it as it is.,https://github.com/bitcoin/bitcoin/pull/15512#discussion_r268828344,268828344,src/crypto/chacha20.cpp
jonasschnelli,2019-03-25T20:43:11Z,Good point. Added.,https://github.com/bitcoin/bitcoin/pull/15512#discussion_r268842266,268842266,src/test/crypto_tests.cpp
jonasschnelli,2019-03-25T20:43:18Z,Added.,https://github.com/bitcoin/bitcoin/pull/15512#discussion_r268842309,268842309,src/test/crypto_tests.cpp
jonasschnelli,2019-03-25T20:43:32Z,Valid point. Fixed.,https://github.com/bitcoin/bitcoin/pull/15512#discussion_r268842397,268842397,src/crypto/chacha20.h
jonasschnelli,2019-03-25T20:43:55Z,Added.,https://github.com/bitcoin/bitcoin/pull/15512#discussion_r268842508,268842508,src/crypto/chacha20.cpp
jonasschnelli,2019-03-25T20:44:14Z,Thanks for the review! Your right. Changed.,https://github.com/bitcoin/bitcoin/pull/15512#discussion_r268842649,268842649,src/crypto/chacha20.cpp
sipa,2019-03-27T17:48:22Z,"I think it would be better to duplicate the logic here and turn the stream cipher version into a separate function.\n\nAs is, it introduces an unnecessary branch in the output version.",https://github.com/bitcoin/bitcoin/pull/15512#discussion_r269692281,269692281,src/crypto/chacha20.cpp
jonasschnelli,2019-03-28T20:12:49Z,Good point. Adapted the duplication approach.,https://github.com/bitcoin/bitcoin/pull/15512#discussion_r270180420,270180420,src/crypto/chacha20.cpp
sipa,2019-03-28T21:28:46Z,No need for this `if`.,https://github.com/bitcoin/bitcoin/pull/15512#discussion_r270206310,270206310,src/crypto/chacha20.cpp
jonasschnelli,2019-03-29T08:58:14Z,Yes. Fixed.,https://github.com/bitcoin/bitcoin/pull/15512#discussion_r270323780,270323780,src/crypto/chacha20.cpp
jnewbery,2019-05-03T15:58:14Z,"What's the reasoning here? Performance?\n\nHow does the version in the refrence implementation compare?\n\n```c\nvoid ECRYPT_keystream_bytes(ECRYPT_ctx *x,u8 *stream,u32 bytes)\n{\n  u32 i;\n  for (i = 0;i < bytes;++i) stream[i] = 0;\n  ECRYPT_encrypt_bytes(x,stream,stream,bytes);\n}\n```\n\nie setting `Output(c, bytes)` to call `Crypt(c, c, bytes)`?",https://github.com/bitcoin/bitcoin/pull/15512#discussion_r280833386,280833386,src/crypto/chacha20.cpp
jnewbery,2019-05-03T15:59:08Z,nit: why the extra newline?,https://github.com/bitcoin/bitcoin/pull/15512#discussion_r280833698,280833698,src/crypto/chacha20.h
jnewbery,2019-05-03T16:02:53Z,"Now that this class can encrypt plaintext, the class comment should be updated from ""A PRNG class for ChaCha20.""\n\nReally, I'd like to see more commenting for this class in general (ie note that `SetIV` sets the nonce, `Seek` sets the counter, that the counter is 64 bytes and the nonce is 64 bytes as in the original ChaCha20 spec instead of 32 byte counter/96 byte nonce as in the IETF spec).\n",https://github.com/bitcoin/bitcoin/pull/15512#discussion_r280834907,280834907,src/crypto/chacha20.h
jnewbery,2019-05-03T16:06:32Z,nit: This function should be renamed `Keystream` now that the class is not just used for PRNG,https://github.com/bitcoin/bitcoin/pull/15512#discussion_r280836054,280836054,src/crypto/chacha20.h
jnewbery,2019-05-03T16:08:56Z,This test seems redundant to me. How could it ever fail if the test above succeeds?,https://github.com/bitcoin/bitcoin/pull/15512#discussion_r280836767,280836767,src/test/crypto_tests.cpp
ryanofsky,2019-05-03T17:03:02Z,"re: https://github.com/bitcoin/bitcoin/pull/15512#discussion_r280836767\n\nNot sure exactly what you want to get rid of, but if you're talking about the `out == outres` check below, I suggested it and think it'd be better to keep, because it means if the test passes you can be reassured that Crypt() and Output() results are consistent without manually verifying `4c616 ^ 6e2e3 == 224f5`... in the",https://github.com/bitcoin/bitcoin/pull/15512#discussion_r280853494,280853494,src/test/crypto_tests.cpp
jonasschnelli,2019-05-03T18:27:22Z,Renamed to `Keystream`,https://github.com/bitcoin/bitcoin/pull/15512#discussion_r280881759,280881759,src/crypto/chacha20.h
jonasschnelli,2019-05-03T18:32:33Z,"The IETF has a slightly modified recommendation AFAIK.\nWe use Bernstein-Vanilly 64bit nonce and 64bit block counter.\n\n* Changed the class comment\n* Added some function comments",https://github.com/bitcoin/bitcoin/pull/15512#discussion_r280883499,280883499,src/crypto/chacha20.h
jnewbery,2019-05-03T19:17:26Z,micronit: same line or braces for while code block please! Same for while block in `HASH()` below.,https://github.com/bitcoin/bitcoin/pull/15512#discussion_r280897800,280897800,src/bench/chacha20.cpp
jnewbery,2019-05-03T19:18:10Z,Is a reason you've added these `CHash256` benchmarks to chacha20.cpp?,https://github.com/bitcoin/bitcoin/pull/15512#discussion_r280897984,280897984,src/bench/chacha20.cpp
jonasschnelli,2019-05-03T20:43:27Z,"I added if for comparison and the impact on the networking... though I think it belong to an extra commit in https://github.com/bitcoin/bitcoin/pull/15649\nWill remove it from here.",https://github.com/bitcoin/bitcoin/pull/15512#discussion_r280922853,280922853,src/bench/chacha20.cpp
jonasschnelli,2019-05-03T20:45:30Z,"I had it in the initial version like @jnewbery just proposed.\nAfter @sipa recommended to separate it, I thought that a strict separation may be beneficial for verification and later optimizations. But maybe @sipa can clarify...",https://github.com/bitcoin/bitcoin/pull/15512#discussion_r280923476,280923476,src/crypto/chacha20.cpp
jonasschnelli,2019-05-03T20:53:04Z,Fixed,https://github.com/bitcoin/bitcoin/pull/15512#discussion_r280925547,280925547,src/bench/chacha20.cpp
Kixunil,2019-07-02T13:01:04Z,"Isn't this no-op? When `bytes < 64` line 215 get's executed which makes ctarget and c equal pointers, therefore it's copying a value to itself.",https://github.com/bitcoin/bitcoin/pull/15512#discussion_r299470103,299470103,src/crypto/chacha20.cpp
Kixunil,2019-07-02T13:04:30Z,"I like the renaming. Would be nice if the comments included information about pointers (e.g. ""key must be non-null, pointer isn't stored"").",https://github.com/bitcoin/bitcoin/pull/15512#discussion_r299471703,299471703,src/crypto/chacha20.h
jonasschnelli,2019-07-03T09:39:36Z,"I don't think so.\nIf we do less then 64 bytes, we execute the round on `tmp` (because we do 64bytes always, see line 216, `c` points to `tmp` if <64 bytes). So in the case of <64 bytes, `c` points to the temporary 64byte buffer and `ctarget` points to the function provided `c` argument.",https://github.com/bitcoin/bitcoin/pull/15512#discussion_r299867339,299867339,src/crypto/chacha20.cpp
jonasschnelli,2019-07-03T09:39:58Z,Yes. That would have been useful. Feel free to PR.,https://github.com/bitcoin/bitcoin/pull/15512#discussion_r299867520,299867520,src/crypto/chacha20.h
Kixunil,2019-07-04T11:05:00Z,"Ah, yes, missed that. Thanks and sorry for bothering.",https://github.com/bitcoin/bitcoin/pull/15512#discussion_r300349240,300349240,src/crypto/chacha20.cpp
