[
  {
    "sha": "c6396d9ac2d01c43fca7f7730b710de4ba86229c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNjM5NmQ5YWMyZDAxYzQzZmNhN2Y3NzMwYjcxMGRlNGJhODYyMjlj",
    "commit": {
      "author": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-03-29T18:26:09Z"
      },
      "committer": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-07-25T15:30:27Z"
      },
      "message": "Implement a thread-safe FIFO (producer/consumer style) queue",
      "tree": {
        "sha": "517d3e3e8686f412ac59c4e88610f3345d7ea845",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/517d3e3e8686f412ac59c4e88610f3345d7ea845"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c6396d9ac2d01c43fca7f7730b710de4ba86229c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c6396d9ac2d01c43fca7f7730b710de4ba86229c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c6396d9ac2d01c43fca7f7730b710de4ba86229c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c6396d9ac2d01c43fca7f7730b710de4ba86229c/comments",
    "author": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "29b4ee64695f79511912ae127e66e0fe82f7a0d1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/29b4ee64695f79511912ae127e66e0fe82f7a0d1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/29b4ee64695f79511912ae127e66e0fe82f7a0d1"
      }
    ],
    "stats": {
      "total": 157,
      "additions": 157,
      "deletions": 0
    },
    "files": [
      {
        "sha": "0fd3fd81f93af0ba9b5a591189bcb9725cbdeb43",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6396d9ac2d01c43fca7f7730b710de4ba86229c/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6396d9ac2d01c43fca7f7730b710de4ba86229c/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=c6396d9ac2d01c43fca7f7730b710de4ba86229c",
        "patch": "@@ -145,6 +145,7 @@ BITCOIN_CORE_H = \\\n   policy/policy.h \\\n   policy/rbf.h \\\n   pow.h \\\n+  core/producerconsumerqueue.h \\\n   protocol.h \\\n   random.h \\\n   reverse_iterator.h \\"
      },
      {
        "sha": "534b5145f6aa265072d3624bcec2d267ee5d936c",
        "filename": "src/core/producerconsumerqueue.h",
        "status": "added",
        "additions": 156,
        "deletions": 0,
        "changes": 156,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6396d9ac2d01c43fca7f7730b710de4ba86229c/src/core/producerconsumerqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6396d9ac2d01c43fca7f7730b710de4ba86229c/src/core/producerconsumerqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core/producerconsumerqueue.h?ref=c6396d9ac2d01c43fca7f7730b710de4ba86229c",
        "patch": "@@ -0,0 +1,156 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+#define BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+\n+#include <assert.h>\n+#include <deque>\n+#include <sync.h>\n+#include <type_traits>\n+\n+/**\n+ * The mode in which the queue operates\n+ * Modes may be specified for both producers and consumers\n+ */\n+enum class WorkerMode {\n+    BLOCKING,   //!< cv_wait until the action may proceed\n+    NONBLOCKING //!< do not block, immediately return failure if the action is not possible\n+};\n+\n+/**\n+ * A FIFO thread safe producer consumer queue with two operations Push() and Pop()\n+ * Producers Push() and Consumers Pop()\n+ *\n+ * @param T the type of the data contained\n+ * @param m_producer_mode queue behavior when calling Push() on a full queue (block till space becomes available, or immediately fail)\n+ * @param m_consumer_mode queue behavior when calling Pop() on an empty queue (block until there is data, or immediately fail)\n+ *\n+ * @see WorkerMode\n+ */\n+template <typename T, WorkerMode m_producer_mode = WorkerMode::BLOCKING, WorkerMode m_consumer_mode = WorkerMode::BLOCKING>\n+class ProducerConsumerQueue\n+{\n+public:\n+    /**\n+     * Constructs a ProducerConsumerQueue()\n+     * @param[in] capacity the maximum size of this queue\n+     */\n+    ProducerConsumerQueue(int capacity)\n+        : m_capacity(capacity)\n+    {\n+        assert(m_capacity > 0);\n+    };\n+\n+    /**\n+     * Constructs an empty ProducerConsumerQueue with capacity 0\n+     * In nonblocking mode all operations will immediately fail\n+     * In blocking mode all operations will fail an assertion to avoid blocking forever\n+     */\n+    ProducerConsumerQueue()\n+        : m_capacity(0){};\n+    ~ProducerConsumerQueue(){};\n+\n+    /**\n+     * Push an element to the back of the queue\n+     * Blocking producer mode: will always eventually succeed\n+     * Non-blocking producer mode: Push() returns failure when the queue is at capacity\n+     * @param[in] data the data to be pushed\n+     * @return the success of the operation\n+     * @see WorkerMode\n+     */\n+    template <typename TT>\n+    bool Push(TT&& data, WorkerMode mode = m_producer_mode)\n+    {\n+        // TT needed for perfect forwarding to vector::push_back\n+\n+        // attempting a push to a queue of capacity 0 is likely unintended\n+        assert(m_capacity > 0);\n+\n+        {\n+            std::unique_lock<std::mutex> l(m_queue_lock);\n+            if (m_data.size() >= m_capacity) {\n+                if (mode == WorkerMode::NONBLOCKING) {\n+                    return false;\n+                }\n+\n+                m_producer_cv.wait(l, [&]() { return m_data.size() < m_capacity; });\n+            }\n+\n+            m_data.push_back(std::forward<TT>(data));\n+        }\n+        m_consumer_cv.notify_one();\n+        return true;\n+    };\n+\n+    /**\n+     * Try to pop the oldest element from the front of the queue, if present\n+     * Blocking consumer mode: will always eventually succeed\n+     * Nonblocking consumer mode: Pop() returns failure when the queue is empty\n+     * @param[out] the data popped, if the operation was successful\n+     * @return the success of the operation\n+     * @see WorkerMode\n+     */\n+    bool Pop(T& data, WorkerMode mode = m_consumer_mode)\n+    {\n+        // attempting a pop from a queue of capacity 0 is likely unintended\n+        assert(m_capacity > 0);\n+\n+        {\n+            std::unique_lock<std::mutex> l(m_queue_lock);\n+            if (m_data.size() <= 0) {\n+                if (mode == WorkerMode::NONBLOCKING) {\n+                    return false;\n+                }\n+\n+                m_consumer_cv.wait(l, [&]() { return m_data.size() > 0; });\n+            }\n+\n+            data = std::move(m_data.front());\n+            m_data.pop_front();\n+        }\n+        m_producer_cv.notify_one();\n+        return true;\n+    }\n+\n+    /**\n+     * Shortcut for bool Pop(T&) when consumer mode is blocking\n+     * This must always succeed and thus may only be called in producer blocking mode\n+     * @return the element popped\n+     */\n+    T Pop()\n+    {\n+        static_assert(m_consumer_mode == WorkerMode::BLOCKING, \"\");\n+\n+        T ret;\n+\n+        // use a temporary so theres no side effecting code inside an assert which could be disabled\n+        bool success = Pop(ret);\n+        assert(success);\n+\n+        return ret;\n+    }\n+\n+    typename std::deque<T>::size_type size()\n+    {\n+        std::unique_lock<std::mutex> l(m_queue_lock);\n+        return m_data.size();\n+    }\n+    unsigned int GetCapacity() const { return m_capacity; }\n+    static constexpr WorkerMode GetProducerMode() { return m_producer_mode; }\n+    static constexpr WorkerMode GetConsumerMode() { return m_consumer_mode; }\n+\n+private:\n+    unsigned int m_capacity; //!< maximum capacity the queue can hold above which pushes will block or fail\n+    std::deque<T> m_data;    //!< the data currently in the queue\n+\n+    std::mutex m_queue_lock;          //!< synchronizes access to m_data\n+    CConditionVariable m_consumer_cv; //!< consumers waiting for m_data to become non-empty\n+    CConditionVariable m_producer_cv; //!< producers waiting for available space in m_data\n+};\n+\n+template <typename T, WorkerMode consumer_mode>\n+using BlockingConsumerQueue = ProducerConsumerQueue<T, WorkerMode::BLOCKING, consumer_mode>;\n+\n+#endif // BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H"
      }
    ]
  },
  {
    "sha": "3f09adf2ab63b813727b5b8e22f8a8129c43ed49",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozZjA5YWRmMmFiNjNiODEzNzI3YjViOGUyMmY4YTgxMjljNDNlZDQ5",
    "commit": {
      "author": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-03-29T18:45:14Z"
      },
      "committer": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-07-25T15:30:27Z"
      },
      "message": "Unit tests for ProducerConsumerQueue",
      "tree": {
        "sha": "de56451287c16062503de4557834875205cd9248",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/de56451287c16062503de4557834875205cd9248"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3f09adf2ab63b813727b5b8e22f8a8129c43ed49",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3f09adf2ab63b813727b5b8e22f8a8129c43ed49",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3f09adf2ab63b813727b5b8e22f8a8129c43ed49",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3f09adf2ab63b813727b5b8e22f8a8129c43ed49/comments",
    "author": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c6396d9ac2d01c43fca7f7730b710de4ba86229c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c6396d9ac2d01c43fca7f7730b710de4ba86229c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c6396d9ac2d01c43fca7f7730b710de4ba86229c"
      }
    ],
    "stats": {
      "total": 179,
      "additions": 179,
      "deletions": 0
    },
    "files": [
      {
        "sha": "ec2c518f25373d1b8610972ae348e8453d8ec20f",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3f09adf2ab63b813727b5b8e22f8a8129c43ed49/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3f09adf2ab63b813727b5b8e22f8a8129c43ed49/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=3f09adf2ab63b813727b5b8e22f8a8129c43ed49",
        "patch": "@@ -65,6 +65,7 @@ BITCOIN_TESTS =\\\n   test/policyestimator_tests.cpp \\\n   test/pow_tests.cpp \\\n   test/prevector_tests.cpp \\\n+  test/producerconsumerqueue_tests.cpp \\\n   test/raii_event_tests.cpp \\\n   test/random_tests.cpp \\\n   test/reverselock_tests.cpp \\"
      },
      {
        "sha": "9fa49654360e592a4a85e7e3bd75bffe72ac6997",
        "filename": "src/test/producerconsumerqueue_tests.cpp",
        "status": "added",
        "additions": 178,
        "deletions": 0,
        "changes": 178,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3f09adf2ab63b813727b5b8e22f8a8129c43ed49/src/test/producerconsumerqueue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3f09adf2ab63b813727b5b8e22f8a8129c43ed49/src/test/producerconsumerqueue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/producerconsumerqueue_tests.cpp?ref=3f09adf2ab63b813727b5b8e22f8a8129c43ed49",
        "patch": "@@ -0,0 +1,178 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <boost/test/unit_test.hpp>\n+#include <iostream>\n+#include <test/test_bitcoin.h>\n+\n+#include <core/producerconsumerqueue.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(producerconsumerqueue_tests, BasicTestingSetup)\n+\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::BLOCKING> QueueBB;\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::NONBLOCKING> QueueBN;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::BLOCKING> QueueNB;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::NONBLOCKING> QueueNN;\n+\n+typedef boost::mpl::list<QueueBB, QueueBN, QueueNB, QueueNN> queue_types;\n+\n+template <typename Q>\n+void Producer(Q& push, Q& recv, int id, int elements_to_push)\n+{\n+    // push all of these elements to one queue\n+    int elements_pushed = 0;\n+    while (elements_pushed < elements_to_push) {\n+        if (push.Push(id * elements_to_push + elements_pushed)) {\n+            elements_pushed++;\n+        } else if (push.GetProducerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking push should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    std::set<int> received;\n+    while (received.size() < (unsigned)elements_to_push) {\n+        int e;\n+        if (recv.Pop(e)) {\n+            assert(!received.count(e));\n+            received.insert(e);\n+        } else if (recv.GetConsumerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking pop should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    for (int i = 0; i < elements_to_push; i++) {\n+        assert(received.count(-i));\n+    }\n+}\n+\n+template <typename Q>\n+void Consumer(Q& work, std::vector<Q*> push, int id, int n_producers, int bucket_size, int elements_to_receive)\n+{\n+    int elements_received = 0;\n+    std::vector<int> latest(n_producers, -1);\n+\n+    while (elements_received != elements_to_receive) {\n+        int w;\n+        if (work.Pop(w)) {\n+            int producer_id = w / bucket_size;\n+            int i = w % bucket_size;\n+\n+            assert(producer_id < n_producers);\n+            assert(i > latest[producer_id]);\n+            latest[producer_id] = i;\n+\n+            while (!push[producer_id]->Push(-i)) {\n+                if (push[producer_id]->GetProducerMode() == WorkerMode::BLOCKING) {\n+                    BOOST_FAIL(\"a blocking push should always succeed\");\n+                }\n+                std::this_thread::yield();\n+            }\n+            elements_received++;\n+        } else if (work.GetConsumerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking pop should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+}\n+\n+template <typename Q>\n+void QueueTest(int capacity, int n_elements, int n_producers, int n_consumers)\n+{\n+    int bucket_size = n_elements / n_producers;\n+\n+    Q push(capacity);\n+    std::vector<Q*> pull;\n+    for (int i = 0; i < n_producers; i++)\n+        pull.push_back(new Q(bucket_size));\n+\n+    boost::thread_group test_threads;\n+\n+    for (int i = 0; i < n_producers; i++) {\n+        test_threads.create_thread([&, i] { Producer(push, *(pull[i]), i, bucket_size); });\n+    }\n+\n+    for (int i = 0; i < n_consumers; i++) {\n+        test_threads.create_thread([&, i] { Consumer(push, pull, i, n_producers, bucket_size, n_elements / n_consumers); });\n+    }\n+\n+    test_threads.join_all();\n+\n+    // queue should be empty\n+    BOOST_CHECK_EQUAL(push.size(), 0);\n+    for (int i = 0; i < n_producers; i++) {\n+        BOOST_CHECK_EQUAL(pull[i]->size(), 0);\n+        delete pull[i];\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE_TEMPLATE(invalid_queue, Q, queue_types)\n+{\n+    Q q;\n+    BOOST_CHECK(q.GetCapacity() == 0);\n+}\n+\n+BOOST_AUTO_TEST_CASE(basic_operation)\n+{\n+    int n = 10;\n+    QueueBB qBB(n);\n+    QueueBN qBN(n);\n+    QueueNB qNB(n);\n+    QueueNN qNN(n);\n+\n+    BOOST_CHECK((int)qBB.GetCapacity() == n);\n+    for (int i = 0; i < n; i++) {\n+        BOOST_CHECK(qBB.Push(i));\n+        BOOST_CHECK(qBN.Push(i));\n+        BOOST_CHECK(qNB.Push(i));\n+        BOOST_CHECK(qNN.Push(i));\n+    }\n+\n+    BOOST_CHECK(!qNB.Push(0));\n+    BOOST_CHECK(!qNN.Push(0));\n+\n+    int t;\n+    for (int i = 0; i < n; i++) {\n+        BOOST_CHECK_EQUAL(qBB.Pop(), i);\n+\n+        BOOST_CHECK(qBN.Pop(t));\n+        BOOST_CHECK_EQUAL(t, i);\n+\n+        BOOST_CHECK_EQUAL(qNB.Pop(), i);\n+\n+        BOOST_CHECK(qNN.Pop(t));\n+        BOOST_CHECK_EQUAL(t, i);\n+    }\n+\n+    int ret;\n+    BOOST_CHECK(!qBN.Pop(ret));\n+    BOOST_CHECK(!qNN.Pop(ret));\n+}\n+\n+BOOST_AUTO_TEST_CASE_TEMPLATE(multithreaded_operation, Q, queue_types)\n+{\n+    QueueTest<Q>(1000, 100, 1, 1);\n+    QueueTest<Q>(100, 1000, 1, 1);\n+\n+    QueueTest<Q>(1000, 100, 1, 10);\n+    QueueTest<Q>(100, 1000, 1, 10);\n+\n+    QueueTest<Q>(1000, 100, 10, 1);\n+    QueueTest<Q>(100, 1000, 10, 1);\n+\n+    QueueTest<Q>(1000, 100, 10, 10);\n+    QueueTest<Q>(100, 1000, 10, 10);\n+\n+    QueueTest<Q>(1000, 100, 10, 5);\n+    QueueTest<Q>(100, 1000, 10, 5);\n+\n+    QueueTest<Q>(1000, 100, 5, 10);\n+    QueueTest<Q>(100, 1000, 5, 10);\n+};\n+\n+BOOST_AUTO_TEST_SUITE_END();"
      }
    ]
  },
  {
    "sha": "7f8a8889564b6509285fbab64825fecb983fca6d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZjhhODg4OTU2NGI2NTA5Mjg1ZmJhYjY0ODI1ZmVjYjk4M2ZjYTZk",
    "commit": {
      "author": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-04-03T15:45:38Z"
      },
      "committer": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-07-25T15:30:27Z"
      },
      "message": "Add ConsumerThread: to consumer and operate on work from a ProducerConsumerQueue",
      "tree": {
        "sha": "e132479e8e11545182ba7d165c464a2c7a42b057",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e132479e8e11545182ba7d165c464a2c7a42b057"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7f8a8889564b6509285fbab64825fecb983fca6d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7f8a8889564b6509285fbab64825fecb983fca6d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7f8a8889564b6509285fbab64825fecb983fca6d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7f8a8889564b6509285fbab64825fecb983fca6d/comments",
    "author": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3f09adf2ab63b813727b5b8e22f8a8129c43ed49",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3f09adf2ab63b813727b5b8e22f8a8129c43ed49",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3f09adf2ab63b813727b5b8e22f8a8129c43ed49"
      }
    ],
    "stats": {
      "total": 200,
      "additions": 199,
      "deletions": 1
    },
    "files": [
      {
        "sha": "a915e6355b0c4b4115f426e0725b8f22b8937b5d",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f8a8889564b6509285fbab64825fecb983fca6d/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f8a8889564b6509285fbab64825fecb983fca6d/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=7f8a8889564b6509285fbab64825fecb983fca6d",
        "patch": "@@ -111,6 +111,8 @@ BITCOIN_CORE_H = \\\n   compressor.h \\\n   consensus/consensus.h \\\n   consensus/tx_verify.h \\\n+  core/consumerthread.h \\\n+  core/producerconsumerqueue.h \\\n   core_io.h \\\n   core_memusage.h \\\n   cuckoocache.h \\\n@@ -145,7 +147,6 @@ BITCOIN_CORE_H = \\\n   policy/policy.h \\\n   policy/rbf.h \\\n   pow.h \\\n-  core/producerconsumerqueue.h \\\n   protocol.h \\\n   random.h \\\n   reverse_iterator.h \\"
      },
      {
        "sha": "cbb37037fe5b5bcc619e82f0f8695753fb01abaa",
        "filename": "src/core/consumerthread.h",
        "status": "added",
        "additions": 197,
        "deletions": 0,
        "changes": 197,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f8a8889564b6509285fbab64825fecb983fca6d/src/core/consumerthread.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f8a8889564b6509285fbab64825fecb983fca6d/src/core/consumerthread.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core/consumerthread.h?ref=7f8a8889564b6509285fbab64825fecb983fca6d",
        "patch": "@@ -0,0 +1,197 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_CONSUMERTHREAD_H\n+#define BITCOIN_CORE_CONSUMERTHREAD_H\n+\n+#include <future>\n+#include <thread>\n+\n+#include <core/producerconsumerqueue.h>\n+#include <util.h>\n+\n+template <WorkerMode MODE>\n+class ConsumerThread;\n+\n+//! A WorkItem() encapsulates a task that can be processed by a ConsumerThread()\n+//! @see ConsumerThread()\n+template <WorkerMode MODE>\n+class WorkItem\n+{\n+    friend ConsumerThread<MODE>; //<! only a consumer thread can execute a WorkItem\n+\n+protected:\n+    WorkItem(){};\n+    virtual void operator()(){};\n+};\n+\n+template <WorkerMode MODE>\n+class GenericWorkItem : public WorkItem<MODE>\n+{\n+    friend ConsumerThread<MODE>;\n+\n+public:\n+    GenericWorkItem(std::function<void()> f) : m_f(f) {}\n+\n+protected:\n+    void operator()() override\n+    {\n+        m_f();\n+    }\n+\n+    std::function<void()> m_f;\n+};\n+\n+//! A special WorkItem() that is used to interrupt a blocked ConsumerThread() so that it can terminate\n+template <WorkerMode MODE>\n+class ShutdownPill : public WorkItem<MODE>\n+{\n+    friend ConsumerThread<MODE>;\n+\n+private:\n+    ShutdownPill(ConsumerThread<MODE>& consumer) : m_consumer(consumer){};\n+    void operator()()\n+    {\n+        std::thread::id id = m_consumer.m_thread.get_id();\n+        if (std::this_thread::get_id() != id) {\n+            // this ShutdownPill was intended for another thread\n+\n+            // we haven't seen this pill before\n+            if (!m_threads_observed.count(id)) {\n+                m_threads_observed.insert(std::this_thread::get_id());\n+\n+                // resubmit it so that it gets a chance to get to the right thread\n+                // when resubmitting, do not block and do not care about failures\n+                // theres a potential deadlock where we try to push this to a queue thats\n+                // full and there are no other threads still consuming\n+                // since the only purpose of reinjecting this is to terminate threads that\n+                // may be blocking on an empty queue when the queue is full we do not need to do this\n+                m_consumer.m_queue->Push(MakeUnique<ShutdownPill<MODE>>(std::move(*this)), WorkerMode::NONBLOCKING);\n+            }\n+\n+            // if the same pill has been seen by the same thread previously then it can safely be discarded\n+            // the intended thread has either terminated or is currently processing a work item and will terminate\n+            // after completing that item and before blocking on the queue\n+        }\n+    };\n+\n+    ConsumerThread<MODE>& m_consumer;\n+    std::set<std::thread::id> m_threads_observed;\n+};\n+\n+template <WorkerMode PRODUCER_MODE>\n+class WorkQueue : public BlockingConsumerQueue<std::unique_ptr<WorkItem<PRODUCER_MODE>>, PRODUCER_MODE>\n+{\n+public:\n+    WorkQueue(int capacity) :BlockingConsumerQueue<std::unique_ptr<WorkItem<PRODUCER_MODE>>, PRODUCER_MODE>(capacity) {}\n+\n+    //! Blocks until everything pushed to the queue prior to this call has been dequeued by a worker\n+    void Sync()\n+    {\n+        std::promise<void> barrier;\n+        this->Push(MakeUnique<GenericWorkItem<PRODUCER_MODE>>([&barrier](){ barrier.set_value(); }), WorkerMode::BLOCKING);\n+        barrier.get_future().wait();\n+    }\n+};\n+\n+/**\n+ * A worker thread that interoperates with a BlockingConsumerQueue\n+ *\n+ * Blocks on the queue, pulls WorkItem() tasks and executes them\n+ * No assumptions are made about number of threads operating on this queue\n+ *\n+ * @see WorkItem\n+ * @see WorkQueue\n+ * @see BlockingConsumerQueue\n+ * @see ProducerConsumerQueue\n+ */\n+template <WorkerMode PRODUCER_POLICY>\n+class ConsumerThread\n+{\n+    friend ShutdownPill<PRODUCER_POLICY>; //<! needs to introspect in order to cleanly terminate this thread\n+\n+public:\n+    //! Default constructor: not a valid thread\n+    ConsumerThread() : m_active(false){};\n+\n+    //! Constructs a ConsumerThread: RAII\n+    //! @param queue the queue from which this thread will pull work\n+    ConsumerThread(std::shared_ptr<WorkQueue<PRODUCER_POLICY>> queue, const std::string id = \"worker\")\n+        : m_id(id), m_queue(queue), m_active(true)\n+    {\n+        m_thread = std::thread(&TraceThread<std::function<void()>>, id.c_str(), std::function<void()>(std::bind(&ConsumerThread<PRODUCER_POLICY>::Loop, this)));\n+    };\n+\n+    //! Terminates a running consumer thread\n+    //! Blocks until the thread joins\n+    //! Repeated calls are no-ops\n+    void Terminate()\n+    {\n+        RequestTermination();\n+        Join();\n+    }\n+\n+    //! Requests termination of a running consumer thread\n+    //! Does not wait for the thread to terminate\n+    //! Repeated calls are no-ops\n+    void RequestTermination()\n+    {\n+        // locked only so that repeated calls do not push extra ShutdownPills\n+        std::unique_lock<CWaitableCriticalSection> l(m_cs_shutdown);\n+        if (m_active) {\n+            m_active = false;\n+\n+            // push an empty WorkItem so that we wake the thread up if it is blocking on an empty queue\n+            // there is no easy way to determine if this consumer is blocked on the queue without introducing\n+            // additional synchronization, but there is little downside to pushing this unnecessarily:\n+            // either this is the last active thread on the queue in which case this will be destroyed if/when\n+            // the queue (and any other work that may remain is destroyed)\n+            // or there are other threads on the queue - in which case this pill will be discarded after any\n+            // of the other threads observe it more than once\n+            m_queue->Push(std::unique_ptr<ShutdownPill<PRODUCER_POLICY>>(new ShutdownPill<PRODUCER_POLICY>(*this)), WorkerMode::NONBLOCKING);\n+        }\n+    }\n+\n+    //! Waits until this thread terminates\n+    //! RequestTerminate() must have been previously called or be called by a different thread\n+    void Join()\n+    {\n+        m_thread.join();\n+    }\n+\n+    bool IsActive() const { std::unique_lock<CWaitableCriticalSection> l(m_cs_shutdown); return m_active; }\n+\n+    const std::string m_id;\n+\n+private:\n+    //! the queue of work that this thread should consume from\n+    const std::shared_ptr<WorkQueue<PRODUCER_POLICY>> m_queue;\n+\n+    //! the thread that this class wraps\n+    std::thread m_thread;\n+\n+    //! whether this thread should continue running: behaves like a latch\n+    //! initialized to true in the constructor\n+    //! can be set to false by calling Terminate()\n+    volatile bool m_active;\n+\n+    //! protects Terminate()\n+    mutable CWaitableCriticalSection m_cs_shutdown;\n+\n+    //! the body of this thread\n+    //! Receives WorkItem() elements from m_queue and executes them until Terminate() is called\n+    void Loop()\n+    {\n+        while (m_active) {\n+            Process(m_queue->Pop());\n+        }\n+    }\n+\n+    void Process(const std::unique_ptr<WorkItem<PRODUCER_POLICY>> work) const\n+    {\n+        (*work)();\n+    }\n+};\n+\n+#endif // BITCOIN_CORE_CONSUMERTHREAD_H"
      }
    ]
  },
  {
    "sha": "134d47a263620afae26f9966a74465bf896ff530",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMzRkNDdhMjYzNjIwYWZhZTI2Zjk5NjZhNzQ0NjViZjg5NmZmNTMw",
    "commit": {
      "author": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-04-03T15:46:00Z"
      },
      "committer": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-07-25T15:30:27Z"
      },
      "message": "ConsumerThread unit tests",
      "tree": {
        "sha": "a5cdc7947cfe31912e177dd43b63de3c9edb99ad",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a5cdc7947cfe31912e177dd43b63de3c9edb99ad"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/134d47a263620afae26f9966a74465bf896ff530",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/134d47a263620afae26f9966a74465bf896ff530",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/134d47a263620afae26f9966a74465bf896ff530",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/134d47a263620afae26f9966a74465bf896ff530/comments",
    "author": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7f8a8889564b6509285fbab64825fecb983fca6d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7f8a8889564b6509285fbab64825fecb983fca6d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7f8a8889564b6509285fbab64825fecb983fca6d"
      }
    ],
    "stats": {
      "total": 89,
      "additions": 89,
      "deletions": 0
    },
    "files": [
      {
        "sha": "80b3529041b5f93ed7932be0c2f6190f1325ddba",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/134d47a263620afae26f9966a74465bf896ff530/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/134d47a263620afae26f9966a74465bf896ff530/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=134d47a263620afae26f9966a74465bf896ff530",
        "patch": "@@ -44,6 +44,7 @@ BITCOIN_TESTS =\\\n   test/checkqueue_tests.cpp \\\n   test/coins_tests.cpp \\\n   test/compress_tests.cpp \\\n+  test/consumerthread_tests.cpp \\\n   test/crypto_tests.cpp \\\n   test/cuckoocache_tests.cpp \\\n   test/denialofservice_tests.cpp \\"
      },
      {
        "sha": "65ff3e8c7eb5653f1e8204cad40aadbab53c76cc",
        "filename": "src/test/consumerthread_tests.cpp",
        "status": "added",
        "additions": 88,
        "deletions": 0,
        "changes": 88,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/134d47a263620afae26f9966a74465bf896ff530/src/test/consumerthread_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/134d47a263620afae26f9966a74465bf896ff530/src/test/consumerthread_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/consumerthread_tests.cpp?ref=134d47a263620afae26f9966a74465bf896ff530",
        "patch": "@@ -0,0 +1,88 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <atomic>\n+#include <boost/test/unit_test.hpp>\n+#include <iostream>\n+#include <test/test_bitcoin.h>\n+\n+#include <core/consumerthread.h>\n+#include <core/producerconsumerqueue.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(consumerthread_tests, BasicTestingSetup)\n+\n+class TestWorkItem : public WorkItem<WorkerMode::BLOCKING>\n+{\n+public:\n+    TestWorkItem(int& i) : m_i(i){};\n+    void operator()()\n+    {\n+        // yield to make unit tests somewhat more unpredictable\n+        std::this_thread::yield();\n+        ++m_i;\n+        std::this_thread::yield();\n+        ++m_i;\n+    }\n+\n+private:\n+    int& m_i;\n+};\n+\n+void ConsumerThreadTest(int n_elements, int n_threads)\n+{\n+    std::vector<int> work(n_elements);\n+    auto queue = std::shared_ptr<WorkQueue<WorkerMode::BLOCKING>>(new WorkQueue<WorkerMode::BLOCKING>(n_elements + 1));\n+\n+    std::vector<std::unique_ptr<ConsumerThread<WorkerMode::BLOCKING>>> threads;\n+    for (int i = 0; i < n_threads; i++) {\n+        threads.emplace_back(std::unique_ptr<ConsumerThread<WorkerMode::BLOCKING>>(new ConsumerThread<WorkerMode::BLOCKING>(queue, std::to_string(i))));\n+    }\n+\n+    for (int i = 0; i < n_elements; i++) {\n+        work[i] = i;\n+        queue->Push(std::unique_ptr<TestWorkItem>(new TestWorkItem(work[i])));\n+    }\n+\n+    while (queue->size() > 0) {\n+        std::this_thread::yield();\n+    }\n+    queue->Sync();\n+\n+    for (int i = 0; i < n_threads / 2; i++) {\n+        threads[i]->Terminate();\n+    }\n+\n+    BOOST_CHECK_LT(queue->size(), n_threads + 1);\n+    for (int i = 0; i < n_elements; i++) {\n+        BOOST_CHECK_EQUAL(work[i], i + 2);\n+    }\n+\n+    for (int i = 0; i < n_elements; i++) {\n+        queue->Push(std::unique_ptr<TestWorkItem>(new TestWorkItem(work[i])));\n+    }\n+\n+    while (queue->size() > 0) {\n+        std::this_thread::yield();\n+    }\n+    queue->Sync();\n+\n+    for (int i = n_threads / 2; i < n_threads; i++) {\n+        threads[i]->Terminate();\n+    }\n+\n+    BOOST_CHECK_LT(queue->size(), n_threads + 1);\n+    for (int i = 0; i < n_elements; i++) {\n+        BOOST_CHECK_EQUAL(work[i], i + 4);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(foo)\n+{\n+    ConsumerThreadTest(100, 1);\n+    ConsumerThreadTest(100, 10);\n+    ConsumerThreadTest(0, 10);\n+    ConsumerThreadTest(3, 10);\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END();"
      }
    ]
  },
  {
    "sha": "b4717281d43b1e0ff9e52d979a3899220ad11eea",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNDcxNzI4MWQ0M2IxZTBmZjllNTJkOTc5YTM4OTkyMjBhZDExZWVh",
    "commit": {
      "author": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-04-10T18:28:05Z"
      },
      "committer": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-07-25T15:30:27Z"
      },
      "message": "ValidationLayer() - interface for calls into block validation",
      "tree": {
        "sha": "60ecb0dc0ee385f0cac89912aacd1af995601ae3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/60ecb0dc0ee385f0cac89912aacd1af995601ae3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b4717281d43b1e0ff9e52d979a3899220ad11eea",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4717281d43b1e0ff9e52d979a3899220ad11eea",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b4717281d43b1e0ff9e52d979a3899220ad11eea",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4717281d43b1e0ff9e52d979a3899220ad11eea/comments",
    "author": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "134d47a263620afae26f9966a74465bf896ff530",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/134d47a263620afae26f9966a74465bf896ff530",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/134d47a263620afae26f9966a74465bf896ff530"
      }
    ],
    "stats": {
      "total": 202,
      "additions": 202,
      "deletions": 0
    },
    "files": [
      {
        "sha": "839b67c7dd2fd7630804764ae9006c0b0bae1ca2",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b4717281d43b1e0ff9e52d979a3899220ad11eea/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b4717281d43b1e0ff9e52d979a3899220ad11eea/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=b4717281d43b1e0ff9e52d979a3899220ad11eea",
        "patch": "@@ -185,6 +185,7 @@ BITCOIN_CORE_H = \\\n   utilmoneystr.h \\\n   utiltime.h \\\n   validation.h \\\n+  validation_layer.h \\\n   validationinterface.h \\\n   versionbits.h \\\n   walletinitinterface.h \\\n@@ -255,6 +256,7 @@ libbitcoin_server_a_SOURCES = \\\n   txmempool.cpp \\\n   ui_interface.cpp \\\n   validation.cpp \\\n+  validation_layer.cpp \\\n   validationinterface.cpp \\\n   versionbits.cpp \\\n   $(BITCOIN_CORE_H)"
      },
      {
        "sha": "5fe236beab4e1d8a670932f2da01f4d937294eac",
        "filename": "src/logging.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b4717281d43b1e0ff9e52d979a3899220ad11eea/src/logging.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b4717281d43b1e0ff9e52d979a3899220ad11eea/src/logging.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.cpp?ref=b4717281d43b1e0ff9e52d979a3899220ad11eea",
        "patch": "@@ -119,6 +119,7 @@ const CLogCategoryDesc LogCategories[] =\n     {BCLog::COINDB, \"coindb\"},\n     {BCLog::QT, \"qt\"},\n     {BCLog::LEVELDB, \"leveldb\"},\n+    {BCLog::VALIDATION, \"validation\"},\n     {BCLog::ALL, \"1\"},\n     {BCLog::ALL, \"all\"},\n };"
      },
      {
        "sha": "edeaccd3efb88e25e268200d86bdcb33f90e1183",
        "filename": "src/logging.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b4717281d43b1e0ff9e52d979a3899220ad11eea/src/logging.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b4717281d43b1e0ff9e52d979a3899220ad11eea/src/logging.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.h?ref=b4717281d43b1e0ff9e52d979a3899220ad11eea",
        "patch": "@@ -53,6 +53,7 @@ namespace BCLog {\n         COINDB      = (1 << 18),\n         QT          = (1 << 19),\n         LEVELDB     = (1 << 20),\n+        VALIDATION  = (1 << 21),\n         ALL         = ~(uint32_t)0,\n     };\n "
      },
      {
        "sha": "2dc54b5b738b0f6c1691839e8448343045742839",
        "filename": "src/validation_layer.cpp",
        "status": "added",
        "additions": 54,
        "deletions": 0,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b4717281d43b1e0ff9e52d979a3899220ad11eea/src/validation_layer.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b4717281d43b1e0ff9e52d979a3899220ad11eea/src/validation_layer.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation_layer.cpp?ref=b4717281d43b1e0ff9e52d979a3899220ad11eea",
        "patch": "@@ -0,0 +1,54 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <validation_layer.h>\n+#include <validation.h>\n+\n+void BlockValidationRequest::operator()()\n+{\n+    LogPrint(BCLog::VALIDATION, \"%s: validating request=%s\\n\", __func__, GetId());\n+    auto res = m_validation_layer.ValidateInternal(m_block, m_force_processing);\n+    LogPrint(BCLog::VALIDATION, \"%s: validation result request=%s block_valid=%d is_new=%d\\n\",\n+        __func__, GetId(), res.block_valid, res.is_new);\n+\n+    m_promise.set_value(res);\n+    if (m_on_ready) {\n+        m_on_ready();\n+    }\n+}\n+\n+std::string BlockValidationRequest::GetId() const\n+{\n+    return strprintf(\"BlockValidationRequest[%s]\", m_block->GetHash().ToString());\n+}\n+\n+void ValidationLayer::Start()\n+{\n+    assert(!m_thread || !m_thread->IsActive());\n+    m_thread = std::unique_ptr<ValidationThread>(new ValidationThread(m_validation_queue));\n+}\n+\n+void ValidationLayer::Stop()\n+{\n+    assert(m_thread && m_thread->IsActive());\n+    m_thread->Terminate();\n+}\n+\n+std::future<BlockValidationResponse> ValidationLayer::SubmitForValidation(const std::shared_ptr<const CBlock> block, bool force_processing, std::function<void()> on_ready)\n+{\n+    BlockValidationRequest* req = new BlockValidationRequest(*this, block, force_processing, on_ready);\n+    return SubmitForValidation<BlockValidationResponse>(req);\n+}\n+\n+BlockValidationResponse ValidationLayer::Validate(const std::shared_ptr<const CBlock> block, bool force_processing)\n+{\n+    return SubmitForValidation(block, force_processing).get();\n+}\n+\n+BlockValidationResponse ValidationLayer::ValidateInternal(const std::shared_ptr<const CBlock> block, bool force_processing) const\n+{\n+    bool is_new = false;\n+    bool block_valid = ProcessNewBlock(m_chainparams, block, force_processing, &is_new);\n+    return BlockValidationResponse(block_valid, is_new);\n+};"
      },
      {
        "sha": "c580a3fe6b2d92df0cf1afcd6309858526022175",
        "filename": "src/validation_layer.h",
        "status": "added",
        "additions": 144,
        "deletions": 0,
        "changes": 144,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b4717281d43b1e0ff9e52d979a3899220ad11eea/src/validation_layer.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b4717281d43b1e0ff9e52d979a3899220ad11eea/src/validation_layer.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation_layer.h?ref=b4717281d43b1e0ff9e52d979a3899220ad11eea",
        "patch": "@@ -0,0 +1,144 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_VALIDATION_LAYER_H\n+#define BITCOIN_VALIDATION_LAYER_H\n+\n+#include <future>\n+\n+#include <chainparams.h>\n+#include <core/consumerthread.h>\n+#include <core/producerconsumerqueue.h>\n+#include <util.h>\n+\n+class ValidationLayer;\n+extern std::unique_ptr<ValidationLayer> g_validation_layer;\n+\n+/**\n+ * Encapsulates a request to validate an object (currently only a block)\n+ * Submitted to ValidationLayer for asynchronous validation\n+ *\n+ * @see ValidationLayer\n+ */\n+template <typename RESPONSE>\n+class ValidationRequest : public WorkItem<WorkerMode::BLOCKING>\n+{\n+    friend ValidationLayer;\n+\n+private:\n+    //! Guts of the validation\n+    virtual void operator()() = 0;\n+\n+    //! Returns a string identifier (for logging)\n+    virtual std::string GetId() const = 0;\n+\n+protected:\n+    //! Promise that will deliver the validation result to the caller who generated this request\n+    std::promise<RESPONSE> m_promise;\n+};\n+\n+/**\n+ * Holds the results of asynchronous block validation\n+ */\n+struct BlockValidationResponse {\n+    //! Is this the first time this block has been validated\n+    const bool is_new;\n+\n+    //! Did initial validation pass (a block can still pass initial validation but then later fail to connect to an active chain)\n+    const bool block_valid;\n+\n+    BlockValidationResponse(bool _block_valid, bool _is_new)\n+        : is_new(_is_new), block_valid(_block_valid){};\n+};\n+\n+/**\n+ * Encapsulates a request to validate a block\n+ */\n+class BlockValidationRequest : public ValidationRequest<BlockValidationResponse>\n+{\n+    friend ValidationLayer;\n+\n+private:\n+    BlockValidationRequest(ValidationLayer& validation_layer, const std::shared_ptr<const CBlock> block, bool force_processing, const std::function<void()> on_ready)\n+        : m_validation_layer(validation_layer), m_block(block), m_force_processing(force_processing), m_on_ready(on_ready){};\n+\n+    //! Does the validation\n+    void operator()() override;\n+\n+    //! Returns a block hash\n+    std::string GetId() const override;\n+\n+    const ValidationLayer& m_validation_layer;\n+\n+    //! The block to be validated\n+    const std::shared_ptr<const CBlock> m_block;\n+\n+    //! Was this block explicitly requested (currently required by ProcessNewBlock)\n+    const bool m_force_processing;\n+\n+    //! A callback to invoke when ready\n+    //! This is a workaround because c++11 does not support multiplexed waiting on futures\n+    //! In a move to subsequent standards when this behavior is supported this can probably be removed\n+    const std::function<void()> m_on_ready;\n+};\n+\n+/**\n+ * Public interface to block validation\n+ *\n+ * Two apis:\n+ *  - asynchronous: SubmitForValidation(object) -> future<Response>\n+ *  - synchronous:  Validate(object) -> Response (just calls SubmitForValidation and blocks on the response)\n+ *\n+ * Internally, a validation thread pulls validations requests from a queue, processes them and satisfies the promise\n+ * with the result of validation.\n+ */\n+class ValidationLayer\n+{\n+    friend BlockValidationRequest;\n+\n+    typedef WorkQueue<WorkerMode::BLOCKING> ValidationQueue;\n+    typedef ConsumerThread<WorkerMode::BLOCKING> ValidationThread;\n+\n+public:\n+    ValidationLayer(const CChainParams& chainparams)\n+        : m_chainparams(chainparams), m_validation_queue(std::make_shared<ValidationQueue>(100)) {}\n+    ~ValidationLayer(){};\n+\n+    //! Starts the validation layer (creating the validation thread)\n+    void Start();\n+\n+    //! Stops the validation layer (stopping the validation thread)\n+    void Stop();\n+\n+    //! Submit a block for asynchronous validation\n+    std::future<BlockValidationResponse> SubmitForValidation(const std::shared_ptr<const CBlock> block, bool force_processing, std::function<void()> on_ready = []() {});\n+\n+    //! Submit a block for validation and block on the response\n+    BlockValidationResponse Validate(const std::shared_ptr<const CBlock> block, bool force_processing);\n+\n+private:\n+    //! Internal utility method - sets up and calls ProcessNewBlock\n+    BlockValidationResponse ValidateInternal(const std::shared_ptr<const CBlock> block, bool force_processing) const;\n+\n+    //! Internal utility method that wraps a request in a unique pointer and deposits it on the validation queue\n+    template <typename RESPONSE>\n+    std::future<RESPONSE> SubmitForValidation(ValidationRequest<RESPONSE>* request)\n+    {\n+        LogPrint(BCLog::VALIDATION, \"%s<%s>: submitting request=%s\\n\", __func__, typeid(RESPONSE).name(), request->GetId());\n+\n+        auto ret = request->m_promise.get_future();\n+        m_validation_queue->Push(std::unique_ptr<ValidationRequest<RESPONSE>>(request));\n+        return ret;\n+    };\n+\n+    const CChainParams& m_chainparams;\n+\n+    //! a queue that holds validation requests that are sequentially processed by m_thread\n+    const std::shared_ptr<ValidationQueue> m_validation_queue;\n+\n+    //! the validation thread - sequentially processes validation requests from m_validation_queue\n+    std::unique_ptr<ValidationThread> m_thread;\n+};\n+\n+#endif"
      }
    ]
  },
  {
    "sha": "1c9f74170f9c35d7bc5ba3e9e079b70aafae4094",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxYzlmNzQxNzBmOWMzNWQ3YmM1YmEzZTllMDc5YjcwYWFmYWU0MDk0",
    "commit": {
      "author": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-04-10T21:20:47Z"
      },
      "committer": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-07-25T17:27:01Z"
      },
      "message": "Call ProcessNewBlock() asynchronously in a separate thread from p2p layer",
      "tree": {
        "sha": "e8fff2608fadd83343aa693b74eb5336670ce1bd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e8fff2608fadd83343aa693b74eb5336670ce1bd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1c9f74170f9c35d7bc5ba3e9e079b70aafae4094",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1c9f74170f9c35d7bc5ba3e9e079b70aafae4094",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1c9f74170f9c35d7bc5ba3e9e079b70aafae4094",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1c9f74170f9c35d7bc5ba3e9e079b70aafae4094/comments",
    "author": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b4717281d43b1e0ff9e52d979a3899220ad11eea",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4717281d43b1e0ff9e52d979a3899220ad11eea",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b4717281d43b1e0ff9e52d979a3899220ad11eea"
      }
    ],
    "stats": {
      "total": 202,
      "additions": 148,
      "deletions": 54
    },
    "files": [
      {
        "sha": "aab5866fb6b2254683a8d50de154f8c4f3a0ddc4",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1c9f74170f9c35d7bc5ba3e9e079b70aafae4094/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1c9f74170f9c35d7bc5ba3e9e079b70aafae4094/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=1c9f74170f9c35d7bc5ba3e9e079b70aafae4094",
        "patch": "@@ -48,6 +48,7 @@\n #include <walletinitinterface.h>\n #include <stdint.h>\n #include <stdio.h>\n+#include <validation_layer.h>\n \n #ifndef WIN32\n #include <signal.h>\n@@ -73,6 +74,7 @@ static const bool DEFAULT_STOPAFTERBLOCKIMPORT = false;\n \n std::unique_ptr<CConnman> g_connman;\n std::unique_ptr<PeerLogicValidation> peerLogic;\n+std::unique_ptr<ValidationLayer> g_validation_layer;\n \n #if !(ENABLE_WALLET)\n class DummyWalletInit : public WalletInitInterface {\n@@ -209,6 +211,7 @@ void Shutdown()\n     // using the other before destroying them.\n     if (peerLogic) UnregisterValidationInterface(peerLogic.get());\n     if (g_connman) g_connman->Stop();\n+    if (g_validation_layer) g_validation_layer->Stop();\n     peerLogic.reset();\n     g_connman.reset();\n     if (g_txindex) {\n@@ -1306,7 +1309,10 @@ bool AppInitMain()\n     g_connman = std::unique_ptr<CConnman>(new CConnman(GetRand(std::numeric_limits<uint64_t>::max()), GetRand(std::numeric_limits<uint64_t>::max())));\n     CConnman& connman = *g_connman;\n \n-    peerLogic.reset(new PeerLogicValidation(&connman, scheduler, gArgs.GetBoolArg(\"-enablebip61\", DEFAULT_ENABLE_BIP61)));\n+    g_validation_layer.reset(new ValidationLayer(chainparams));\n+    g_validation_layer->Start();\n+\n+    peerLogic.reset(new PeerLogicValidation(&connman, *g_validation_layer, scheduler, gArgs.GetBoolArg(\"-enablebip61\", DEFAULT_ENABLE_BIP61)));\n     RegisterValidationInterface(peerLogic.get());\n \n     // sanitize comments per BIP-0014, format user agent and check total size"
      },
      {
        "sha": "cd202c3cd68fcfc8246bcd95f6dbcc6f3eacc338",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 53,
        "deletions": 4,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1c9f74170f9c35d7bc5ba3e9e079b70aafae4094/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1c9f74170f9c35d7bc5ba3e9e079b70aafae4094/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=1c9f74170f9c35d7bc5ba3e9e079b70aafae4094",
        "patch": "@@ -14,11 +14,12 @@\n #include <consensus/consensus.h>\n #include <crypto/common.h>\n #include <crypto/sha256.h>\n-#include <primitives/transaction.h>\n #include <netbase.h>\n+#include <primitives/transaction.h>\n #include <scheduler.h>\n #include <ui_interface.h>\n #include <utilstrencodings.h>\n+#include <validation_layer.h>\n \n #ifdef WIN32\n #include <string.h>\n@@ -2045,11 +2046,28 @@ void CConnman::ThreadMessageHandler()\n             if (pnode->fDisconnect)\n                 continue;\n \n-            // Receive messages\n-            bool fMoreNodeWork = m_msgproc->ProcessMessages(pnode, flagInterruptMsgProc);\n-            fMoreWork |= (fMoreNodeWork && !pnode->fPauseSend);\n+            bool request_was_queued = pnode->IsAwaitingInternalRequest();\n+\n+            // If an internal request was queued and it's not done yet, skip this node\n+            if (request_was_queued && !pnode->ProcessInternalRequestResults(m_msgproc))\n+                continue;\n+\n+            // If no internal request was queued receive messages\n+            if (!request_was_queued) {\n+                bool fMoreNodeWork = m_msgproc->ProcessMessages(pnode, flagInterruptMsgProc);\n+                request_was_queued = pnode->IsAwaitingInternalRequest();\n+\n+                fMoreWork |= (fMoreNodeWork && !pnode->fPauseSend && !request_was_queued);\n+            } else {\n+                request_was_queued = false;\n+            }\n+\n             if (flagInterruptMsgProc)\n                 return;\n+\n+            if (request_was_queued)\n+                continue;\n+\n             // Send messages\n             {\n                 LOCK(pnode->cs_sendProcessing);\n@@ -2813,6 +2831,37 @@ void CNode::AskFor(const CInv& inv)\n     mapAskFor.insert(std::make_pair(nRequestTime, inv));\n }\n \n+bool CNode::IsAwaitingInternalRequest()\n+{\n+    return m_block_validation_response.valid();\n+}\n+\n+bool CNode::ProcessInternalRequestResults(NetEventsInterface* peerlogic)\n+{\n+    bool all_cleared = true;\n+\n+    if (m_block_validation_response.valid()) {\n+        if (m_block_validation_response.wait_for(std::chrono::milliseconds::zero()) == std::future_status::ready) {\n+            peerlogic->ProcessBlockValidationResponse(this, m_block_validating, m_block_validating_index, m_block_validation_response.get());\n+\n+            m_block_validating = nullptr;\n+            m_block_validating_index = nullptr;\n+            m_block_validation_response = std::future<BlockValidationResponse>();\n+        } else {\n+            all_cleared = false;\n+        }\n+    }\n+\n+    return all_cleared;\n+}\n+\n+void CNode::SetPendingInternalRequest(const std::shared_ptr<const CBlock> block, std::future<BlockValidationResponse>&& pending_response, const CBlockIndex* pindex)\n+{\n+    m_block_validating = block;\n+    m_block_validating_index = pindex;\n+    m_block_validation_response = std::move(pending_response);\n+}\n+\n bool CConnman::NodeFullyConnected(const CNode* pnode)\n {\n     return pnode && pnode->fSuccessfullyConnected && !pnode->fDisconnect;"
      },
      {
        "sha": "279e6217620a2eb1b06ae08d4ce375f37d17bd86",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 25,
        "deletions": 3,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1c9f74170f9c35d7bc5ba3e9e079b70aafae4094/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1c9f74170f9c35d7bc5ba3e9e079b70aafae4094/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=1c9f74170f9c35d7bc5ba3e9e079b70aafae4094",
        "patch": "@@ -23,19 +23,23 @@\n #include <threadinterrupt.h>\n \n #include <atomic>\n+#include <chrono>\n+#include <condition_variable>\n #include <deque>\n+#include <future>\n+#include <memory>\n #include <stdint.h>\n #include <thread>\n-#include <memory>\n-#include <condition_variable>\n \n #ifndef WIN32\n #include <arpa/inet.h>\n #endif\n \n-\n+struct BlockValidationResponse;\n class CScheduler;\n class CNode;\n+class CBlock;\n+class CBlockIndex;\n \n /** Time between pings automatically sent out for latency probing and keepalive (in seconds). */\n static const int PING_INTERVAL = 2 * 60;\n@@ -478,6 +482,7 @@ class NetEventsInterface\n     virtual bool SendMessages(CNode* pnode) = 0;\n     virtual void InitializeNode(CNode* pnode) = 0;\n     virtual void FinalizeNode(NodeId id, bool& update_connection_time) = 0;\n+    virtual void ProcessBlockValidationResponse(CNode* pfrom, const std::shared_ptr<const CBlock> pblock, const CBlockIndex* pindex, const BlockValidationResponse& validation_response) = 0;\n \n protected:\n     /**\n@@ -755,6 +760,13 @@ class CNode\n     // Our address, as reported by the peer\n     CService addrLocal;\n     mutable CCriticalSection cs_addrLocal;\n+\n+    // If an asynchronous request to validate a block received over the network is pending\n+    // these members hold details of that request\n+    std::future<BlockValidationResponse> m_block_validation_response;\n+    std::shared_ptr<const CBlock> m_block_validating;\n+    const CBlockIndex* m_block_validating_index;\n+\n public:\n \n     NodeId GetId() const {\n@@ -865,6 +877,16 @@ class CNode\n     std::string GetAddrName() const;\n     //! Sets the addrName only if it was not previously set\n     void MaybeSetAddrName(const std::string& addrNameIn);\n+\n+    //! Is an asynchronous internal request pending\n+    bool IsAwaitingInternalRequest();\n+\n+    //! If a result from an asynchronous internal request is ready, process the results\n+    bool ProcessInternalRequestResults(NetEventsInterface*);\n+\n+    //! Mark this node as waiting for an asynchronous internal request to complete\n+    //! before any further processing of this node may occurb\n+    void SetPendingInternalRequest(const std::shared_ptr<const CBlock> block, std::future<BlockValidationResponse>&& pending_response, const CBlockIndex* pindex = nullptr);\n };\n \n "
      },
      {
        "sha": "1bdeecef48344a3e966626c96d1890d7c30bb827",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 42,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1c9f74170f9c35d7bc5ba3e9e079b70aafae4094/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1c9f74170f9c35d7bc5ba3e9e079b70aafae4094/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=1c9f74170f9c35d7bc5ba3e9e079b70aafae4094",
        "patch": "@@ -11,10 +11,9 @@\n #include <chainparams.h>\n #include <consensus/validation.h>\n #include <hash.h>\n-#include <validation.h>\n #include <merkleblock.h>\n-#include <netmessagemaker.h>\n #include <netbase.h>\n+#include <netmessagemaker.h>\n #include <policy/fees.h>\n #include <policy/policy.h>\n #include <primitives/block.h>\n@@ -28,6 +27,8 @@\n #include <util.h>\n #include <utilmoneystr.h>\n #include <utilstrencodings.h>\n+#include <validation.h>\n+#include <validation_layer.h>\n \n #include <memory>\n \n@@ -845,9 +846,9 @@ static bool BlockRequestAllowed(const CBlockIndex* pindex, const Consensus::Para\n         (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, consensusParams) < STALE_RELAY_AGE_LIMIT);\n }\n \n-PeerLogicValidation::PeerLogicValidation(CConnman* connmanIn, CScheduler &scheduler, bool enable_bip61)\n-    : connman(connmanIn), m_stale_tip_check_time(0), m_enable_bip61(enable_bip61) {\n-\n+PeerLogicValidation::PeerLogicValidation(CConnman* connmanIn, ValidationLayer& validation_layer, CScheduler& scheduler, bool enable_bip61)\n+    : connman(connmanIn), m_validation_layer(validation_layer), m_stale_tip_check_time(0), m_enable_bip61(enable_bip61)\n+{\n     // Initialize global variables that cannot be constructed at startup.\n     recentRejects.reset(new CRollingBloomFilter(120000, 0.000001));\n \n@@ -1263,6 +1264,12 @@ void static ProcessGetBlockData(CNode* pfrom, const CChainParams& chainparams, c\n     }\n }\n \n+void SubmitBlock(CConnman* connman, ValidationLayer& validation_layer, CNode* pfrom, const std::shared_ptr<const CBlock> pblock, bool force_processing, const CBlockIndex* pindex = nullptr)\n+{\n+    std::future<BlockValidationResponse> result = validation_layer.SubmitForValidation(pblock, force_processing, std::bind(&CConnman::WakeMessageHandler, connman));\n+    pfrom->SetPendingInternalRequest(pblock, std::move(result), pindex);\n+}\n+\n void static ProcessGetData(CNode* pfrom, const CChainParams& chainparams, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n {\n     AssertLockNotHeld(cs_main);\n@@ -1572,7 +1579,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n     return true;\n }\n \n-bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman* connman, const std::atomic<bool>& interruptMsgProc, bool enable_bip61)\n+    bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman* connman, ValidationLayer& validation_layer, const std::atomic<bool>& interruptMsgProc, bool enable_bip61)\n {\n     LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->GetId());\n     if (gArgs.IsArgSet(\"-dropmessagestest\") && GetRand(gArgs.GetArg(\"-dropmessagestest\", 0)) == 0)\n@@ -2552,7 +2559,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         } // cs_main\n \n         if (fProcessBLOCKTXN)\n-            return ProcessMessage(pfrom, NetMsgType::BLOCKTXN, blockTxnMsg, nTimeReceived, chainparams, connman, interruptMsgProc, enable_bip61);\n+            return ProcessMessage(pfrom, NetMsgType::BLOCKTXN, blockTxnMsg, nTimeReceived, chainparams, connman, validation_layer, interruptMsgProc, enable_bip61);\n \n         if (fRevertToHeaderProcessing) {\n             // Headers received from HB compact block peers are permitted to be\n@@ -2570,7 +2577,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 LOCK(cs_main);\n                 mapBlockSource.emplace(pblock->GetHash(), std::make_pair(pfrom->GetId(), false));\n             }\n-            bool fNewBlock = false;\n+\n             // Setting fForceProcessing to true means that we bypass some of\n             // our anti-DoS protections in AcceptBlock, which filters\n             // unrequested blocks that might be trying to waste our resources\n@@ -2580,21 +2587,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // we have a chain with at least nMinimumChainWork), and we ignore\n             // compact blocks with less work than our tip, it is safe to treat\n             // reconstructed compact blocks as having been requested.\n-            ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true, &fNewBlock);\n-            if (fNewBlock) {\n-                pfrom->nLastBlockTime = GetTime();\n-            } else {\n-                LOCK(cs_main);\n-                mapBlockSource.erase(pblock->GetHash());\n-            }\n-            LOCK(cs_main); // hold cs_main for CBlockIndex::IsValid()\n-            if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS)) {\n-                // Clear download state for this block, which is in\n-                // process from some other peer.  We do this after calling\n-                // ProcessNewBlock so that a malleated cmpctblock announcement\n-                // can't be used to interfere with block relay.\n-                MarkBlockAsReceived(pblock->GetHash());\n-            }\n+            SubmitBlock(connman, validation_layer, pfrom, pblock, /*fForceProcessing*/ true, pindex);\n         }\n \n     }\n@@ -2645,7 +2638,6 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // though the block was successfully read, and rely on the\n                 // handling in ProcessNewBlock to ensure the block index is\n                 // updated, reject messages go out, etc.\n-                MarkBlockAsReceived(resp.blockhash); // it is now an empty pointer\n                 fBlockRead = true;\n                 // mapBlockSource is only used for sending reject messages and DoS scores,\n                 // so the race between here and cs_main in ProcessNewBlock is fine.\n@@ -2656,20 +2648,13 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             }\n         } // Don't hold cs_main when we call into ProcessNewBlock\n         if (fBlockRead) {\n-            bool fNewBlock = false;\n             // Since we requested this block (it was in mapBlocksInFlight), force it to be processed,\n             // even if it would not be a candidate for new tip (missing previous block, chain not long enough, etc)\n             // This bypasses some anti-DoS logic in AcceptBlock (eg to prevent\n             // disk-space attacks), but this should be safe due to the\n             // protections in the compact block handler -- see related comment\n             // in compact block optimistic reconstruction handling.\n-            ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true, &fNewBlock);\n-            if (fNewBlock) {\n-                pfrom->nLastBlockTime = GetTime();\n-            } else {\n-                LOCK(cs_main);\n-                mapBlockSource.erase(pblock->GetHash());\n-            }\n+            SubmitBlock(connman, validation_layer, pfrom, pblock, /*fForceProcessing*/ true);\n         }\n     }\n \n@@ -2712,19 +2697,13 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             LOCK(cs_main);\n             // Also always process if we requested the block explicitly, as we may\n             // need it even though it is not a candidate for a new best tip.\n-            forceProcessing |= MarkBlockAsReceived(hash);\n+            forceProcessing = mapBlocksInFlight.count(hash);\n+\n             // mapBlockSource is only used for sending reject messages and DoS scores,\n             // so the race between here and cs_main in ProcessNewBlock is fine.\n             mapBlockSource.emplace(hash, std::make_pair(pfrom->GetId(), true));\n         }\n-        bool fNewBlock = false;\n-        ProcessNewBlock(chainparams, pblock, forceProcessing, &fNewBlock);\n-        if (fNewBlock) {\n-            pfrom->nLastBlockTime = GetTime();\n-        } else {\n-            LOCK(cs_main);\n-            mapBlockSource.erase(pblock->GetHash());\n-        }\n+        SubmitBlock(connman, validation_layer, pfrom, pblock, forceProcessing);\n     }\n \n \n@@ -3045,7 +3024,7 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     bool fRet = false;\n     try\n     {\n-        fRet = ProcessMessage(pfrom, strCommand, vRecv, msg.nTime, chainparams, connman, interruptMsgProc, m_enable_bip61);\n+        fRet = ProcessMessage(pfrom, strCommand, vRecv, msg.nTime, chainparams, connman, m_validation_layer, interruptMsgProc, m_enable_bip61);\n         if (interruptMsgProc)\n             return false;\n         if (!pfrom->vRecvGetData.empty())\n@@ -3092,6 +3071,26 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     return fMoreWork;\n }\n \n+void PeerLogicValidation::ProcessBlockValidationResponse(CNode* pfrom, const std::shared_ptr<const CBlock> pblock, const CBlockIndex* pindex, const BlockValidationResponse& validation_response)\n+{\n+    LOCK(cs_main);\n+\n+    // If we've reconstructed this block via compactblocks then\n+    // Clear download state for this block, which is in\n+    // process from some other peer.  We do this after calling\n+    // ProcessNewBlock so that a malleated cmpctblock announcement\n+    // can't be used to interfere with block relay.\n+    if (!pindex || pindex->IsValid(BLOCK_VALID_TRANSACTIONS)) {\n+        MarkBlockAsReceived(pblock->GetHash());\n+    }\n+\n+    if (validation_response.is_new) {\n+        pfrom->nLastBlockTime = GetTime();\n+    } else {\n+        mapBlockSource.erase(pblock->GetHash());\n+    }\n+}\n+\n void PeerLogicValidation::ConsiderEviction(CNode *pto, int64_t time_in_seconds)\n {\n     AssertLockHeld(cs_main);"
      },
      {
        "sha": "aa85a066f29fd200140b19b5cc3e2e90077b8433",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1c9f74170f9c35d7bc5ba3e9e079b70aafae4094/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1c9f74170f9c35d7bc5ba3e9e079b70aafae4094/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=1c9f74170f9c35d7bc5ba3e9e079b70aafae4094",
        "patch": "@@ -10,6 +10,9 @@\n #include <validationinterface.h>\n #include <consensus/params.h>\n \n+struct BlockValidationResponse;\n+class ValidationLayer;\n+\n /** Default for -maxorphantx, maximum number of orphan transactions kept in memory */\n static const unsigned int DEFAULT_MAX_ORPHAN_TRANSACTIONS = 100;\n /** Default number of orphan+recently-replaced txn to keep around for block reconstruction */\n@@ -20,9 +23,10 @@ static constexpr bool DEFAULT_ENABLE_BIP61 = true;\n class PeerLogicValidation final : public CValidationInterface, public NetEventsInterface {\n private:\n     CConnman* const connman;\n+    ValidationLayer& m_validation_layer;\n \n public:\n-    explicit PeerLogicValidation(CConnman* connman, CScheduler &scheduler, bool enable_bip61);\n+    explicit PeerLogicValidation(CConnman* connman, ValidationLayer& validation_layer, CScheduler& scheduler, bool enable_bip61);\n \n     /**\n      * Overridden from CValidationInterface.\n@@ -67,6 +71,8 @@ class PeerLogicValidation final : public CValidationInterface, public NetEventsI\n     /** If we have extra outbound peers, try to disconnect the one with the oldest block announcement */\n     void EvictExtraOutboundPeers(int64_t time_in_seconds);\n \n+    void ProcessBlockValidationResponse(CNode*, std::shared_ptr<const CBlock>, const CBlockIndex*, const BlockValidationResponse&) override;\n+\n private:\n     int64_t m_stale_tip_check_time; //! Next time to check for stale tip\n "
      },
      {
        "sha": "a0c1b10a4dfff7067cdd99d261f7bd75525c2d0a",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 2,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1c9f74170f9c35d7bc5ba3e9e079b70aafae4094/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1c9f74170f9c35d7bc5ba3e9e079b70aafae4094/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=1c9f74170f9c35d7bc5ba3e9e079b70aafae4094",
        "patch": "@@ -17,6 +17,7 @@\n #include <rpc/server.h>\n #include <rpc/register.h>\n #include <script/sigcache.h>\n+#include <validation_layer.h>\n \n void CConnmanTest::AddNode(CNode& node)\n {\n@@ -107,7 +108,11 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n             threadGroup.create_thread(&ThreadScriptCheck);\n         g_connman = std::unique_ptr<CConnman>(new CConnman(0x1337, 0x1337)); // Deterministic randomness for tests.\n         connman = g_connman.get();\n-        peerLogic.reset(new PeerLogicValidation(connman, scheduler, /*enable_bip61=*/true));\n+\n+        g_validation_layer.reset(new ValidationLayer(Params()));\n+        g_validation_layer->Start();\n+\n+        peerLogic.reset(new PeerLogicValidation(connman, *g_validation_layer, scheduler, /*enable_bip61=*/true));\n }\n \n TestingSetup::~TestingSetup()\n@@ -118,6 +123,8 @@ TestingSetup::~TestingSetup()\n         GetMainSignals().UnregisterBackgroundSignalScheduler();\n         g_connman.reset();\n         peerLogic.reset();\n+        if (g_validation_layer) g_validation_layer->Stop();\n+        g_validation_layer.reset();\n         UnloadBlockIndex();\n         pcoinsTip.reset();\n         pcoinsdbview.reset();\n@@ -126,6 +133,7 @@ TestingSetup::~TestingSetup()\n \n TestChain100Setup::TestChain100Setup() : TestingSetup(CBaseChainParams::REGTEST)\n {\n+\n     // CreateAndProcessBlock() does not support building SegWit blocks, so don't activate in these tests.\n     // TODO: fix the code to support SegWit blocks.\n     UpdateVersionBitsParameters(Consensus::DEPLOYMENT_SEGWIT, 0, Consensus::BIP9Deployment::NO_TIMEOUT);\n@@ -165,7 +173,7 @@ TestChain100Setup::CreateAndProcessBlock(const std::vector<CMutableTransaction>&\n     while (!CheckProofOfWork(block.GetHash(), block.nBits, chainparams.GetConsensus())) ++block.nNonce;\n \n     std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(block);\n-    ProcessNewBlock(chainparams, shared_pblock, true, nullptr);\n+    g_validation_layer->Validate(shared_pblock, true);\n \n     CBlock result = block;\n     return result;"
      },
      {
        "sha": "e06a2bf47d37d9abfdaadc89aa68390d79786961",
        "filename": "src/test/test_bitcoin.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1c9f74170f9c35d7bc5ba3e9e079b70aafae4094/src/test/test_bitcoin.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1c9f74170f9c35d7bc5ba3e9e079b70aafae4094/src/test/test_bitcoin.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.h?ref=1c9f74170f9c35d7bc5ba3e9e079b70aafae4094",
        "patch": "@@ -18,6 +18,8 @@\n \n #include <boost/thread.hpp>\n \n+class ValidationLayer;\n+\n extern uint256 insecure_rand_seed;\n extern FastRandomContext insecure_rand_ctx;\n "
      },
      {
        "sha": "f28a6620afa6521ff9c06c87d5e7f5e1cb868ab0",
        "filename": "src/test/test_bitcoin_main.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1c9f74170f9c35d7bc5ba3e9e079b70aafae4094/src/test/test_bitcoin_main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1c9f74170f9c35d7bc5ba3e9e079b70aafae4094/src/test/test_bitcoin_main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin_main.cpp?ref=1c9f74170f9c35d7bc5ba3e9e079b70aafae4094",
        "patch": "@@ -5,12 +5,14 @@\n #define BOOST_TEST_MODULE Bitcoin Test Suite\n \n #include <net.h>\n+#include <validation_layer.h>\n \n #include <memory>\n \n #include <boost/test/unit_test.hpp>\n \n std::unique_ptr<CConnman> g_connman;\n+std::unique_ptr<ValidationLayer> g_validation_layer;\n \n [[noreturn]] void Shutdown(void* parg)\n {"
      },
      {
        "sha": "6e51bd783119457eb7d4e7253a547309812d5bab",
        "filename": "src/validation_layer.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1c9f74170f9c35d7bc5ba3e9e079b70aafae4094/src/validation_layer.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1c9f74170f9c35d7bc5ba3e9e079b70aafae4094/src/validation_layer.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation_layer.cpp?ref=1c9f74170f9c35d7bc5ba3e9e079b70aafae4094",
        "patch": "@@ -10,7 +10,7 @@ void BlockValidationRequest::operator()()\n     LogPrint(BCLog::VALIDATION, \"%s: validating request=%s\\n\", __func__, GetId());\n     auto res = m_validation_layer.ValidateInternal(m_block, m_force_processing);\n     LogPrint(BCLog::VALIDATION, \"%s: validation result request=%s block_valid=%d is_new=%d\\n\",\n-        __func__, GetId(), res.block_valid, res.is_new);\n+             __func__, GetId(), res.block_valid, res.is_new);\n \n     m_promise.set_value(res);\n     if (m_on_ready) {"
      }
    ]
  },
  {
    "sha": "ce1d845a975d11b3f4e439dfd3ab2823895cf419",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjZTFkODQ1YTk3NWQxMWIzZjRlNDM5ZGZkM2FiMjgyMzg5NWNmNDE5",
    "commit": {
      "author": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-05-08T20:21:51Z"
      },
      "committer": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-07-25T17:27:01Z"
      },
      "message": "Replace all instances of ProcessNewBlock() with ValidationLayer.Validate()",
      "tree": {
        "sha": "df5afa0574f0bc3dde116ca2a2be88c2d3ca59d3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/df5afa0574f0bc3dde116ca2a2be88c2d3ca59d3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ce1d845a975d11b3f4e439dfd3ab2823895cf419",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ce1d845a975d11b3f4e439dfd3ab2823895cf419",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ce1d845a975d11b3f4e439dfd3ab2823895cf419",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ce1d845a975d11b3f4e439dfd3ab2823895cf419/comments",
    "author": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1c9f74170f9c35d7bc5ba3e9e079b70aafae4094",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1c9f74170f9c35d7bc5ba3e9e079b70aafae4094",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1c9f74170f9c35d7bc5ba3e9e079b70aafae4094"
      }
    ],
    "stats": {
      "total": 36,
      "additions": 21,
      "deletions": 15
    },
    "files": [
      {
        "sha": "66228d3b7198d52bd43ba58c2da62be1ad4cde51",
        "filename": "src/bench/bench_bitcoin.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ce1d845a975d11b3f4e439dfd3ab2823895cf419/src/bench/bench_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ce1d845a975d11b3f4e439dfd3ab2823895cf419/src/bench/bench_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench_bitcoin.cpp?ref=ce1d845a975d11b3f4e439dfd3ab2823895cf419",
        "patch": "@@ -9,7 +9,7 @@\n #include <random.h>\n #include <util.h>\n #include <utilstrencodings.h>\n-#include <validation.h>\n+#include <validation_layer.h>\n \n #include <memory>\n \n@@ -21,6 +21,8 @@ static const char* DEFAULT_PLOT_PLOTLYURL = \"https://cdn.plot.ly/plotly-latest.m\n static const int64_t DEFAULT_PLOT_WIDTH = 1024;\n static const int64_t DEFAULT_PLOT_HEIGHT = 768;\n \n+std::unique_ptr<ValidationLayer> g_validation_layer;\n+\n static void SetupBenchArgs()\n {\n     gArgs.AddArg(\"-?\", \"Print this help message and exit\", false, OptionsCategory::OPTIONS);\n@@ -69,6 +71,9 @@ int main(int argc, char** argv)\n     ECC_Start();\n     SetupEnvironment();\n \n+    g_validation_layer.reset(new ValidationLayer(Params()));\n+    g_validation_layer->Start();\n+\n     int64_t evaluations = gArgs.GetArg(\"-evals\", DEFAULT_BENCH_EVALUATIONS);\n     std::string regex_filter = gArgs.GetArg(\"-filter\", DEFAULT_BENCH_FILTER);\n     std::string scaling_str = gArgs.GetArg(\"-scaling\", DEFAULT_BENCH_SCALING);"
      },
      {
        "sha": "35669e2ce1a3c2dbf6b1cba2c1d3d88d17849888",
        "filename": "src/bench/block_assemble.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ce1d845a975d11b3f4e439dfd3ab2823895cf419/src/bench/block_assemble.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ce1d845a975d11b3f4e439dfd3ab2823895cf419/src/bench/block_assemble.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/block_assemble.cpp?ref=ce1d845a975d11b3f4e439dfd3ab2823895cf419",
        "patch": "@@ -14,7 +14,7 @@\n #include <txdb.h>\n #include <txmempool.h>\n #include <utiltime.h>\n-#include <validation.h>\n+#include <validation_layer.h>\n #include <validationinterface.h>\n \n #include <boost/thread.hpp>\n@@ -44,7 +44,7 @@ static CTxIn MineBlock(const CScript& coinbase_scriptPubKey)\n         assert(++block->nNonce);\n     }\n \n-    bool processed{ProcessNewBlock(Params(), block, true, nullptr)};\n+    bool processed{g_validation_layer->Validate(block, true).block_valid};\n     assert(processed);\n \n     return CTxIn{block->vtx[0]->GetHash(), 0};"
      },
      {
        "sha": "e324000f7c3bf3a25903a922fe829e873849aea6",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ce1d845a975d11b3f4e439dfd3ab2823895cf419/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ce1d845a975d11b3f4e439dfd3ab2823895cf419/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=ce1d845a975d11b3f4e439dfd3ab2823895cf419",
        "patch": "@@ -23,6 +23,7 @@\n #include <txmempool.h>\n #include <util.h>\n #include <utilstrencodings.h>\n+#include <validation_layer.h>\n #include <validationinterface.h>\n #include <warnings.h>\n \n@@ -137,7 +138,7 @@ UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbaseScript, int nGen\n             continue;\n         }\n         std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(*pblock);\n-        if (!ProcessNewBlock(Params(), shared_pblock, true, nullptr))\n+        if (!g_validation_layer->Validate(shared_pblock, true).block_valid)\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"ProcessNewBlock, block not accepted\");\n         ++nHeight;\n         blockHashes.push_back(pblock->GetHash().GetHex());\n@@ -748,10 +749,10 @@ static UniValue submitblock(const JSONRPCRequest& request)\n     bool new_block;\n     submitblock_StateCatcher sc(block.GetHash());\n     RegisterValidationInterface(&sc);\n-    bool accepted = ProcessNewBlock(Params(), blockptr, /* fForceProcessing */ true, /* fNewBlock */ &new_block);\n+    BlockValidationResponse resp = g_validation_layer->Validate(blockptr, true);\n     UnregisterValidationInterface(&sc);\n-    if (!new_block) {\n-        if (!accepted) {\n+    if (!resp.is_new) {\n+        if (!resp.block_valid) {\n             // TODO Maybe pass down fNewBlock to AcceptBlockHeader, so it is properly set to true in this case?\n             return \"invalid\";\n         }"
      },
      {
        "sha": "4a44841c562c82e7c798e8a94d3d457e966ef5fc",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ce1d845a975d11b3f4e439dfd3ab2823895cf419/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ce1d845a975d11b3f4e439dfd3ab2823895cf419/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=ce1d845a975d11b3f4e439dfd3ab2823895cf419",
        "patch": "@@ -17,6 +17,7 @@\n #include <uint256.h>\n #include <util.h>\n #include <utilstrencodings.h>\n+#include <validation_layer.h>\n \n #include <test/test_bitcoin.h>\n \n@@ -207,6 +208,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     // Note that by default, these tests run with size accounting enabled.\n     const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n     const CChainParams& chainparams = *chainParams;\n+\n     CScript scriptPubKey = CScript() << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\") << OP_CHECKSIG;\n     std::unique_ptr<CBlockTemplate> pblocktemplate;\n     CMutableTransaction tx;\n@@ -248,7 +250,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n             pblock->nNonce = blockinfo[i].nonce;\n         }\n         std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(*pblock);\n-        BOOST_CHECK(ProcessNewBlock(chainparams, shared_pblock, true, nullptr));\n+        BOOST_CHECK(g_validation_layer->Validate(shared_pblock, true).block_valid);\n         pblock->hashPrevBlock = pblock->GetHash();\n     }\n "
      },
      {
        "sha": "3803bbc63bbf51c7d84c39ca54a6c54f2bd8ecb8",
        "filename": "src/test/validation_block_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 7,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ce1d845a975d11b3f4e439dfd3ab2823895cf419/src/test/validation_block_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ce1d845a975d11b3f4e439dfd3ab2823895cf419/src/test/validation_block_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_block_tests.cpp?ref=ce1d845a975d11b3f4e439dfd3ab2823895cf419",
        "patch": "@@ -11,7 +11,7 @@\n #include <pow.h>\n #include <random.h>\n #include <test/test_bitcoin.h>\n-#include <validation.h>\n+#include <validation_layer.h>\n #include <validationinterface.h>\n \n struct RegtestingSetup : public TestingSetup {\n@@ -128,7 +128,6 @@ BOOST_AUTO_TEST_CASE(processnewblock_signals_ordering)\n         BuildChain(Params().GenesisBlock().GetHash(), 100, 15, 10, 500, blocks);\n     }\n \n-    bool ignored;\n     CValidationState state;\n     std::vector<CBlockHeader> headers;\n     std::transform(blocks.begin(), blocks.end(), std::back_inserter(headers), [](std::shared_ptr<const CBlock> b) { return b->GetBlockHeader(); });\n@@ -137,7 +136,7 @@ BOOST_AUTO_TEST_CASE(processnewblock_signals_ordering)\n     BOOST_CHECK(ProcessNewBlockHeaders(headers, state, Params()));\n \n     // Connect the genesis block and drain any outstanding events\n-    ProcessNewBlock(Params(), std::make_shared<CBlock>(Params().GenesisBlock()), true, &ignored);\n+    g_validation_layer->Validate(std::make_shared<CBlock>(Params().GenesisBlock()), true);\n     SyncWithValidationInterfaceQueue();\n \n     // subscribe to events (this subscriber will validate event ordering)\n@@ -154,17 +153,16 @@ BOOST_AUTO_TEST_CASE(processnewblock_signals_ordering)\n     // will subscribe to events generated during block validation and assert on ordering invariance\n     boost::thread_group threads;\n     for (int i = 0; i < 10; i++) {\n-        threads.create_thread([&blocks]() {\n-            bool ignored;\n+        threads.create_thread([this, &blocks]() {\n             for (int i = 0; i < 1000; i++) {\n                 auto block = blocks[GetRand(blocks.size() - 1)];\n-                ProcessNewBlock(Params(), block, true, &ignored);\n+                g_validation_layer->SubmitForValidation(block, true);\n             }\n \n             // to make sure that eventually we process the full chain - do it here\n             for (auto block : blocks) {\n                 if (block->vtx.size() == 1) {\n-                    bool processed = ProcessNewBlock(Params(), block, true, &ignored);\n+                    bool processed = g_validation_layer->Validate(block, true).block_valid;\n                     assert(processed);\n                 }\n             }"
      }
    ]
  },
  {
    "sha": "377873614b3fa143147ecaba5b750f8be1bdd8a4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNzc4NzM2MTRiM2ZhMTQzMTQ3ZWNhYmE1Yjc1MGY4YmUxYmRkOGE0",
    "commit": {
      "author": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-05-08T19:06:36Z"
      },
      "committer": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-07-25T17:27:01Z"
      },
      "message": "Limit available scope of ProcessNewBlock to ValidationLayer (move-only)",
      "tree": {
        "sha": "7778397c70c12150aa8dedb191bb694a1521834a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7778397c70c12150aa8dedb191bb694a1521834a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/377873614b3fa143147ecaba5b750f8be1bdd8a4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/377873614b3fa143147ecaba5b750f8be1bdd8a4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/377873614b3fa143147ecaba5b750f8be1bdd8a4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/377873614b3fa143147ecaba5b750f8be1bdd8a4/comments",
    "author": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ce1d845a975d11b3f4e439dfd3ab2823895cf419",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ce1d845a975d11b3f4e439dfd3ab2823895cf419",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ce1d845a975d11b3f4e439dfd3ab2823895cf419"
      }
    ],
    "stats": {
      "total": 45,
      "additions": 22,
      "deletions": 23
    },
    "files": [
      {
        "sha": "3506c8c55bc46c26203c9faa57217f726f962f14",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 0,
        "deletions": 22,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/377873614b3fa143147ecaba5b750f8be1bdd8a4/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/377873614b3fa143147ecaba5b750f8be1bdd8a4/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=377873614b3fa143147ecaba5b750f8be1bdd8a4",
        "patch": "@@ -207,28 +207,6 @@ static const unsigned int DEFAULT_CHECKLEVEL = 3;\n // Setting the target to > than 550MB will make it likely we can respect the target.\n static const uint64_t MIN_DISK_SPACE_FOR_BLOCK_FILES = 550 * 1024 * 1024;\n \n-/**\n- * Process an incoming block. This only returns after the best known valid\n- * block is made active. Note that it does not, however, guarantee that the\n- * specific block passed to it has been checked for validity!\n- *\n- * If you want to *possibly* get feedback on whether pblock is valid, you must\n- * install a CValidationInterface (see validationinterface.h) - this will have\n- * its BlockChecked method called whenever *any* block completes validation.\n- *\n- * Note that we guarantee that either the proof-of-work is valid on pblock, or\n- * (and possibly also) BlockChecked will have been called.\n- *\n- * May not be called in a\n- * validationinterface callback.\n- *\n- * @param[in]   pblock  The block we want to process.\n- * @param[in]   fForceProcessing Process this block even if unrequested; used for non-network block sources and whitelisted peers.\n- * @param[out]  fNewBlock A boolean which is set to indicate if the block was first received via this call\n- * @return True if state.IsValid()\n- */\n-bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, bool fForceProcessing, bool* fNewBlock) LOCKS_EXCLUDED(cs_main);\n-\n /**\n  * Process incoming block headers.\n  *"
      },
      {
        "sha": "63ac0c0b18dcf47134423d46fba759bbad31d0d6",
        "filename": "src/validation_layer.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 1,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/377873614b3fa143147ecaba5b750f8be1bdd8a4/src/validation_layer.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/377873614b3fa143147ecaba5b750f8be1bdd8a4/src/validation_layer.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation_layer.cpp?ref=377873614b3fa143147ecaba5b750f8be1bdd8a4",
        "patch": "@@ -3,7 +3,28 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <validation_layer.h>\n-#include <validation.h>\n+\n+/**\n+ * Process an incoming block. This only returns after the best known valid\n+ * block is made active. Note that it does not, however, guarantee that the\n+ * specific block passed to it has been checked for validity!\n+ *\n+ * If you want to *possibly* get feedback on whether pblock is valid, you must\n+ * install a CValidationInterface (see validationinterface.h) - this will have\n+ * its BlockChecked method called whenever *any* block completes validation.\n+ *\n+ * Note that we guarantee that either the proof-of-work is valid on pblock, or\n+ * (and possibly also) BlockChecked will have been called.\n+ *\n+ * May not be called in a\n+ * validationinterface callback.\n+ *\n+ * @param[in]   pblock  The block we want to process.\n+ * @param[in]   fForceProcessing Process this block even if unrequested; used for non-network block sources and whitelisted peers.\n+ * @param[out]  fNewBlock A boolean which is set to indicate if the block was first received via this call\n+ * @return True if state.IsValid()\n+ */\n+bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, bool fForceProcessing, bool* fNewBlock);\n \n void BlockValidationRequest::operator()()\n {"
      }
    ]
  },
  {
    "sha": "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozZDZmMDM4MTRjZGU5ODg2OWNhNWI4YWQzNjViYjNhMGFhZTUyMmQ5",
    "commit": {
      "author": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-05-09T15:08:28Z"
      },
      "committer": {
        "name": "Jesse Cohen",
        "email": "jc@jc.lol",
        "date": "2018-07-25T17:27:01Z"
      },
      "message": "Fix whitespace in test_bitcoin.cpp (whitespace,move-only)",
      "tree": {
        "sha": "ece56c5a3363f2b316931b53d81bdeb1365efe76",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ece56c5a3363f2b316931b53d81bdeb1365efe76"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3d6f03814cde98869ca5b8ad365bb3a0aae522d9/comments",
    "author": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "skeees",
      "id": 195769,
      "node_id": "MDQ6VXNlcjE5NTc2OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/195769?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/skeees",
      "html_url": "https://github.com/skeees",
      "followers_url": "https://api.github.com/users/skeees/followers",
      "following_url": "https://api.github.com/users/skeees/following{/other_user}",
      "gists_url": "https://api.github.com/users/skeees/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/skeees/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/skeees/subscriptions",
      "organizations_url": "https://api.github.com/users/skeees/orgs",
      "repos_url": "https://api.github.com/users/skeees/repos",
      "events_url": "https://api.github.com/users/skeees/events{/privacy}",
      "received_events_url": "https://api.github.com/users/skeees/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "377873614b3fa143147ecaba5b750f8be1bdd8a4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/377873614b3fa143147ecaba5b750f8be1bdd8a4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/377873614b3fa143147ecaba5b750f8be1bdd8a4"
      }
    ],
    "stats": {
      "total": 86,
      "additions": 43,
      "deletions": 43
    },
    "files": [
      {
        "sha": "2801572e5b0549e6e31bb429dd9a4ca0e20b61b3",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 43,
        "deletions": 43,
        "changes": 86,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3d6f03814cde98869ca5b8ad365bb3a0aae522d9/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3d6f03814cde98869ca5b8ad365bb3a0aae522d9/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
        "patch": "@@ -79,56 +79,56 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n {\n     SetDataDir(\"tempdir\");\n     const CChainParams& chainparams = Params();\n-        // Ideally we'd move all the RPC tests to the functional testing framework\n-        // instead of unit tests, but for now we need these here.\n-\n-        RegisterAllCoreRPCCommands(tableRPC);\n-        ClearDatadirCache();\n-\n-        // We have to run a scheduler thread to prevent ActivateBestChain\n-        // from blocking due to queue overrun.\n-        threadGroup.create_thread(boost::bind(&CScheduler::serviceQueue, &scheduler));\n-        GetMainSignals().RegisterBackgroundSignalScheduler(scheduler);\n-\n-        mempool.setSanityCheck(1.0);\n-        pblocktree.reset(new CBlockTreeDB(1 << 20, true));\n-        pcoinsdbview.reset(new CCoinsViewDB(1 << 23, true));\n-        pcoinsTip.reset(new CCoinsViewCache(pcoinsdbview.get()));\n-        if (!LoadGenesisBlock(chainparams)) {\n-            throw std::runtime_error(\"LoadGenesisBlock failed.\");\n-        }\n-        {\n-            CValidationState state;\n-            if (!ActivateBestChain(state, chainparams)) {\n-                throw std::runtime_error(strprintf(\"ActivateBestChain failed. (%s)\", FormatStateMessage(state)));\n-            }\n+    // Ideally we'd move all the RPC tests to the functional testing framework\n+    // instead of unit tests, but for now we need these here.\n+\n+    RegisterAllCoreRPCCommands(tableRPC);\n+    ClearDatadirCache();\n+\n+    // We have to run a scheduler thread to prevent ActivateBestChain\n+    // from blocking due to queue overrun.\n+    threadGroup.create_thread(boost::bind(&CScheduler::serviceQueue, &scheduler));\n+    GetMainSignals().RegisterBackgroundSignalScheduler(scheduler);\n+\n+    mempool.setSanityCheck(1.0);\n+    pblocktree.reset(new CBlockTreeDB(1 << 20, true));\n+    pcoinsdbview.reset(new CCoinsViewDB(1 << 23, true));\n+    pcoinsTip.reset(new CCoinsViewCache(pcoinsdbview.get()));\n+    if (!LoadGenesisBlock(chainparams)) {\n+        throw std::runtime_error(\"LoadGenesisBlock failed.\");\n+    }\n+    {\n+        CValidationState state;\n+        if (!ActivateBestChain(state, chainparams)) {\n+            throw std::runtime_error(strprintf(\"ActivateBestChain failed. (%s)\", FormatStateMessage(state)));\n         }\n-        nScriptCheckThreads = 3;\n-        for (int i=0; i < nScriptCheckThreads-1; i++)\n-            threadGroup.create_thread(&ThreadScriptCheck);\n-        g_connman = std::unique_ptr<CConnman>(new CConnman(0x1337, 0x1337)); // Deterministic randomness for tests.\n-        connman = g_connman.get();\n+    }\n+    nScriptCheckThreads = 3;\n+    for (int i=0; i < nScriptCheckThreads-1; i++)\n+        threadGroup.create_thread(&ThreadScriptCheck);\n+    g_connman = std::unique_ptr<CConnman>(new CConnman(0x1337, 0x1337)); // Deterministic randomness for tests.\n+    connman = g_connman.get();\n \n-        g_validation_layer.reset(new ValidationLayer(Params()));\n-        g_validation_layer->Start();\n+    g_validation_layer.reset(new ValidationLayer(Params()));\n+    g_validation_layer->Start();\n \n-        peerLogic.reset(new PeerLogicValidation(connman, *g_validation_layer, scheduler, /*enable_bip61=*/true));\n+    peerLogic.reset(new PeerLogicValidation(connman, *g_validation_layer, scheduler, /*enable_bip61=*/true));\n }\n \n TestingSetup::~TestingSetup()\n {\n-        threadGroup.interrupt_all();\n-        threadGroup.join_all();\n-        GetMainSignals().FlushBackgroundCallbacks();\n-        GetMainSignals().UnregisterBackgroundSignalScheduler();\n-        g_connman.reset();\n-        peerLogic.reset();\n-        if (g_validation_layer) g_validation_layer->Stop();\n-        g_validation_layer.reset();\n-        UnloadBlockIndex();\n-        pcoinsTip.reset();\n-        pcoinsdbview.reset();\n-        pblocktree.reset();\n+    threadGroup.interrupt_all();\n+    threadGroup.join_all();\n+    GetMainSignals().FlushBackgroundCallbacks();\n+    GetMainSignals().UnregisterBackgroundSignalScheduler();\n+    g_connman.reset();\n+    peerLogic.reset();\n+    if (g_validation_layer) g_validation_layer->Stop();\n+    g_validation_layer.reset();\n+    UnloadBlockIndex();\n+    pcoinsTip.reset();\n+    pcoinsdbview.reset();\n+    pblocktree.reset();\n }\n \n TestChain100Setup::TestChain100Setup() : TestingSetup(CBaseChainParams::REGTEST)"
      }
    ]
  }
]