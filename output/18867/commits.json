[
  {
    "sha": "f9b22e3bdb54acb2f830b3ebbad47ff17dfb5781",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmOWIyMmUzYmRiNTRhY2IyZjgzMGIzZWJiYWQ0N2ZmMTdkZmI1Nzgx",
    "commit": {
      "author": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2020-04-28T12:27:56Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2020-05-25T10:05:06Z"
      },
      "message": "tests: Add fuzzing harness for CCoinsViewCache",
      "tree": {
        "sha": "92fe0607d55de25c993027e29cba4e68413fc0f9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/92fe0607d55de25c993027e29cba4e68413fc0f9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f9b22e3bdb54acb2f830b3ebbad47ff17dfb5781",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f9b22e3bdb54acb2f830b3ebbad47ff17dfb5781",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f9b22e3bdb54acb2f830b3ebbad47ff17dfb5781",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f9b22e3bdb54acb2f830b3ebbad47ff17dfb5781/comments",
    "author": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "24f70290642c9c5108d3dc62dbe055f5d1bcff9d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/24f70290642c9c5108d3dc62dbe055f5d1bcff9d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/24f70290642c9c5108d3dc62dbe055f5d1bcff9d"
      }
    ],
    "stats": {
      "total": 313,
      "additions": 313,
      "deletions": 0
    },
    "files": [
      {
        "sha": "2480cdadbbd4ab704ca3d511c108220ade629cbb",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f9b22e3bdb54acb2f830b3ebbad47ff17dfb5781/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f9b22e3bdb54acb2f830b3ebbad47ff17dfb5781/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=f9b22e3bdb54acb2f830b3ebbad47ff17dfb5781",
        "patch": "@@ -31,6 +31,7 @@ FUZZ_TARGETS = \\\n   test/fuzz/chain \\\n   test/fuzz/checkqueue \\\n   test/fuzz/coins_deserialize \\\n+  test/fuzz/coins_view \\\n   test/fuzz/cuckoocache \\\n   test/fuzz/decode_tx \\\n   test/fuzz/descriptor_parse \\\n@@ -466,6 +467,12 @@ test_fuzz_coins_deserialize_LDADD = $(FUZZ_SUITE_LD_COMMON)\n test_fuzz_coins_deserialize_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n test_fuzz_coins_deserialize_SOURCES = test/fuzz/deserialize.cpp\n \n+test_fuzz_coins_view_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n+test_fuzz_coins_view_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+test_fuzz_coins_view_LDADD = $(FUZZ_SUITE_LD_COMMON)\n+test_fuzz_coins_view_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n+test_fuzz_coins_view_SOURCES = test/fuzz/coins_view.cpp\n+\n test_fuzz_cuckoocache_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n test_fuzz_cuckoocache_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_cuckoocache_LDADD = $(FUZZ_SUITE_LD_COMMON)"
      },
      {
        "sha": "52dd62a14561d5138d2f56018eb5d9e8f2edb2e2",
        "filename": "src/test/fuzz/coins_view.cpp",
        "status": "added",
        "additions": 294,
        "deletions": 0,
        "changes": 294,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f9b22e3bdb54acb2f830b3ebbad47ff17dfb5781/src/test/fuzz/coins_view.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f9b22e3bdb54acb2f830b3ebbad47ff17dfb5781/src/test/fuzz/coins_view.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/coins_view.cpp?ref=f9b22e3bdb54acb2f830b3ebbad47ff17dfb5781",
        "patch": "@@ -0,0 +1,294 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <amount.h>\n+#include <chainparams.h>\n+#include <chainparamsbase.h>\n+#include <coins.h>\n+#include <consensus/tx_verify.h>\n+#include <consensus/validation.h>\n+#include <key.h>\n+#include <node/coinstats.h>\n+#include <policy/policy.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <validation.h>\n+\n+#include <cstdint>\n+#include <limits>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+const Coin EMPTY_COIN{};\n+\n+bool operator==(const Coin& a, const Coin& b)\n+{\n+    if (a.IsSpent() && b.IsSpent()) return true;\n+    return a.fCoinBase == b.fCoinBase && a.nHeight == b.nHeight && a.out == b.out;\n+}\n+} // namespace\n+\n+void initialize()\n+{\n+    static const ECCVerifyHandle ecc_verify_handle;\n+    ECC_Start();\n+    SelectParams(CBaseChainParams::REGTEST);\n+}\n+\n+void test_one_input(const std::vector<uint8_t>& buffer)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CCoinsView backend_coins_view;\n+    CCoinsViewCache coins_view_cache{&backend_coins_view};\n+    COutPoint random_out_point;\n+    Coin random_coin;\n+    CMutableTransaction random_mutable_transaction;\n+    while (fuzzed_data_provider.ConsumeBool()) {\n+        switch (fuzzed_data_provider.ConsumeIntegralInRange<int>(0, 9)) {\n+        case 0: {\n+            if (random_coin.IsSpent()) {\n+                break;\n+            }\n+            Coin coin = random_coin;\n+            bool expected_code_path = false;\n+            const bool possible_overwrite = fuzzed_data_provider.ConsumeBool();\n+            try {\n+                coins_view_cache.AddCoin(random_out_point, std::move(coin), possible_overwrite);\n+                expected_code_path = true;\n+            } catch (const std::logic_error& e) {\n+                if (e.what() == std::string{\"Attempted to overwrite an unspent coin (when possible_overwrite is false)\"}) {\n+                    assert(!possible_overwrite);\n+                    expected_code_path = true;\n+                }\n+            }\n+            assert(expected_code_path);\n+            break;\n+        }\n+        case 1: {\n+            (void)coins_view_cache.Flush();\n+            break;\n+        }\n+        case 2: {\n+            coins_view_cache.SetBestBlock(ConsumeUInt256(fuzzed_data_provider));\n+            break;\n+        }\n+        case 3: {\n+            Coin move_to;\n+            (void)coins_view_cache.SpendCoin(random_out_point, fuzzed_data_provider.ConsumeBool() ? &move_to : nullptr);\n+            break;\n+        }\n+        case 4: {\n+            coins_view_cache.Uncache(random_out_point);\n+            break;\n+        }\n+        case 5: {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                backend_coins_view = CCoinsView{};\n+            }\n+            coins_view_cache.SetBackend(backend_coins_view);\n+            break;\n+        }\n+        case 6: {\n+            const std::optional<COutPoint> opt_out_point = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+            if (!opt_out_point) {\n+                break;\n+            }\n+            random_out_point = *opt_out_point;\n+            break;\n+        }\n+        case 7: {\n+            const std::optional<Coin> opt_coin = ConsumeDeserializable<Coin>(fuzzed_data_provider);\n+            if (!opt_coin) {\n+                break;\n+            }\n+            random_coin = *opt_coin;\n+            break;\n+        }\n+        case 8: {\n+            const std::optional<CMutableTransaction> opt_mutable_transaction = ConsumeDeserializable<CMutableTransaction>(fuzzed_data_provider);\n+            if (!opt_mutable_transaction) {\n+                break;\n+            }\n+            random_mutable_transaction = *opt_mutable_transaction;\n+            break;\n+        }\n+        case 9: {\n+            CCoinsMap coins_map;\n+            while (fuzzed_data_provider.ConsumeBool()) {\n+                CCoinsCacheEntry coins_cache_entry;\n+                coins_cache_entry.flags = fuzzed_data_provider.ConsumeIntegral<unsigned char>();\n+                if (fuzzed_data_provider.ConsumeBool()) {\n+                    coins_cache_entry.coin = random_coin;\n+                } else {\n+                    const std::optional<Coin> opt_coin = ConsumeDeserializable<Coin>(fuzzed_data_provider);\n+                    if (!opt_coin) {\n+                        break;\n+                    }\n+                    coins_cache_entry.coin = *opt_coin;\n+                }\n+                coins_map.emplace(random_out_point, std::move(coins_cache_entry));\n+            }\n+            bool expected_code_path = false;\n+            try {\n+                coins_view_cache.BatchWrite(coins_map, fuzzed_data_provider.ConsumeBool() ? ConsumeUInt256(fuzzed_data_provider) : coins_view_cache.GetBestBlock());\n+                expected_code_path = true;\n+            } catch (const std::logic_error& e) {\n+                if (e.what() == std::string{\"FRESH flag misapplied to coin that exists in parent cache\"}) {\n+                    expected_code_path = true;\n+                }\n+            }\n+            assert(expected_code_path);\n+            break;\n+        }\n+        }\n+    }\n+\n+    {\n+        const Coin& coin_using_access_coin = coins_view_cache.AccessCoin(random_out_point);\n+        const bool exists_using_access_coin = !(coin_using_access_coin == EMPTY_COIN);\n+        const bool exists_using_have_coin = coins_view_cache.HaveCoin(random_out_point);\n+        const bool exists_using_have_coin_in_cache = coins_view_cache.HaveCoinInCache(random_out_point);\n+        Coin coin_using_get_coin;\n+        const bool exists_using_get_coin = coins_view_cache.GetCoin(random_out_point, coin_using_get_coin);\n+        if (exists_using_get_coin) {\n+            assert(coin_using_get_coin == coin_using_access_coin);\n+        }\n+        assert((exists_using_access_coin && exists_using_have_coin_in_cache && exists_using_have_coin && exists_using_get_coin) ||\n+               (!exists_using_access_coin && !exists_using_have_coin_in_cache && !exists_using_have_coin && !exists_using_get_coin));\n+        const bool exists_using_have_coin_in_backend = backend_coins_view.HaveCoin(random_out_point);\n+        if (exists_using_have_coin_in_backend) {\n+            assert(exists_using_have_coin);\n+        }\n+        Coin coin_using_backend_get_coin;\n+        if (backend_coins_view.GetCoin(random_out_point, coin_using_backend_get_coin)) {\n+            assert(exists_using_have_coin_in_backend);\n+            assert(coin_using_get_coin == coin_using_backend_get_coin);\n+        } else {\n+            assert(!exists_using_have_coin_in_backend);\n+        }\n+    }\n+\n+    {\n+        bool expected_code_path = false;\n+        try {\n+            (void)coins_view_cache.Cursor();\n+        } catch (const std::logic_error&) {\n+            expected_code_path = true;\n+        }\n+        assert(expected_code_path);\n+        (void)coins_view_cache.DynamicMemoryUsage();\n+        (void)coins_view_cache.EstimateSize();\n+        (void)coins_view_cache.GetBestBlock();\n+        (void)coins_view_cache.GetCacheSize();\n+        (void)coins_view_cache.GetHeadBlocks();\n+        (void)coins_view_cache.HaveInputs(CTransaction{random_mutable_transaction});\n+    }\n+\n+    {\n+        const CCoinsViewCursor* coins_view_cursor = backend_coins_view.Cursor();\n+        assert(coins_view_cursor == nullptr);\n+        (void)backend_coins_view.EstimateSize();\n+        (void)backend_coins_view.GetBestBlock();\n+        (void)backend_coins_view.GetHeadBlocks();\n+    }\n+\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        switch (fuzzed_data_provider.ConsumeIntegralInRange<int>(0, 6)) {\n+        case 0: {\n+            const CTransaction transaction{random_mutable_transaction};\n+            bool is_spent = false;\n+            for (const CTxOut& tx_out : transaction.vout) {\n+                if (Coin{tx_out, 0, transaction.IsCoinBase()}.IsSpent()) {\n+                    is_spent = true;\n+                }\n+            }\n+            if (is_spent) {\n+                // Avoid:\n+                // coins.cpp:69: void CCoinsViewCache::AddCoin(const COutPoint &, Coin &&, bool): Assertion `!coin.IsSpent()' failed.\n+                break;\n+            }\n+            bool expected_code_path = false;\n+            const int height = fuzzed_data_provider.ConsumeIntegral<int>();\n+            const bool possible_overwrite = fuzzed_data_provider.ConsumeBool();\n+            try {\n+                AddCoins(coins_view_cache, transaction, height, possible_overwrite);\n+                expected_code_path = true;\n+            } catch (const std::logic_error& e) {\n+                if (e.what() == std::string{\"Attempted to overwrite an unspent coin (when possible_overwrite is false)\"}) {\n+                    assert(!possible_overwrite);\n+                    expected_code_path = true;\n+                }\n+            }\n+            assert(expected_code_path);\n+            break;\n+        }\n+        case 1: {\n+            (void)AreInputsStandard(CTransaction{random_mutable_transaction}, coins_view_cache);\n+            break;\n+        }\n+        case 2: {\n+            TxValidationState state;\n+            CAmount tx_fee_out;\n+            const CTransaction transaction{random_mutable_transaction};\n+            if (ContainsSpentInput(transaction, coins_view_cache)) {\n+                // Avoid:\n+                // consensus/tx_verify.cpp:171: bool Consensus::CheckTxInputs(const CTransaction &, TxValidationState &, const CCoinsViewCache &, int, CAmount &): Assertion `!coin.IsSpent()' failed.\n+                break;\n+            }\n+            try {\n+                (void)Consensus::CheckTxInputs(transaction, state, coins_view_cache, fuzzed_data_provider.ConsumeIntegralInRange<int>(0, std::numeric_limits<int>::max()), tx_fee_out);\n+                assert(MoneyRange(tx_fee_out));\n+            } catch (const std::runtime_error&) {\n+            }\n+            break;\n+        }\n+        case 3: {\n+            const CTransaction transaction{random_mutable_transaction};\n+            if (ContainsSpentInput(transaction, coins_view_cache)) {\n+                // Avoid:\n+                // consensus/tx_verify.cpp:130: unsigned int GetP2SHSigOpCount(const CTransaction &, const CCoinsViewCache &): Assertion `!coin.IsSpent()' failed.\n+                break;\n+            }\n+            (void)GetP2SHSigOpCount(transaction, coins_view_cache);\n+            break;\n+        }\n+        case 4: {\n+            const CTransaction transaction{random_mutable_transaction};\n+            if (ContainsSpentInput(transaction, coins_view_cache)) {\n+                // Avoid:\n+                // consensus/tx_verify.cpp:130: unsigned int GetP2SHSigOpCount(const CTransaction &, const CCoinsViewCache &): Assertion `!coin.IsSpent()' failed.\n+                break;\n+            }\n+            const int flags = fuzzed_data_provider.ConsumeIntegral<int>();\n+            if (!transaction.vin.empty() && (flags & SCRIPT_VERIFY_WITNESS) != 0 && (flags & SCRIPT_VERIFY_P2SH) == 0) {\n+                // Avoid:\n+                // script/interpreter.cpp:1705: size_t CountWitnessSigOps(const CScript &, const CScript &, const CScriptWitness *, unsigned int): Assertion `(flags & SCRIPT_VERIFY_P2SH) != 0' failed.\n+                break;\n+            }\n+            (void)GetTransactionSigOpCost(transaction, coins_view_cache, flags);\n+            break;\n+        }\n+        case 5: {\n+            CCoinsStats stats;\n+            bool expected_code_path = false;\n+            try {\n+                (void)GetUTXOStats(&coins_view_cache, stats);\n+            } catch (const std::logic_error&) {\n+                expected_code_path = true;\n+            }\n+            assert(expected_code_path);\n+            break;\n+        }\n+        case 6: {\n+            (void)IsWitnessStandard(CTransaction{random_mutable_transaction}, coins_view_cache);\n+            break;\n+        }\n+        }\n+    }\n+}"
      },
      {
        "sha": "9d0fb02128baa93538e2abae0d9ba4083f684525",
        "filename": "src/test/fuzz/util.h",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f9b22e3bdb54acb2f830b3ebbad47ff17dfb5781/src/test/fuzz/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f9b22e3bdb54acb2f830b3ebbad47ff17dfb5781/src/test/fuzz/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/util.h?ref=f9b22e3bdb54acb2f830b3ebbad47ff17dfb5781",
        "patch": "@@ -8,6 +8,7 @@\n #include <amount.h>\n #include <arith_uint256.h>\n #include <attributes.h>\n+#include <coins.h>\n #include <consensus/consensus.h>\n #include <primitives/transaction.h>\n #include <script/script.h>\n@@ -149,4 +150,15 @@ NODISCARD bool AdditionOverflow(const T i, const T j) noexcept\n     return std::numeric_limits<T>::max() - i < j;\n }\n \n+NODISCARD inline bool ContainsSpentInput(const CTransaction& tx, const CCoinsViewCache& inputs) noexcept\n+{\n+    for (const CTxIn& tx_in : tx.vin) {\n+        const Coin& coin = inputs.AccessCoin(tx_in.prevout);\n+        if (coin.IsSpent()) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n #endif // BITCOIN_TEST_FUZZ_UTIL_H"
      }
    ]
  }
]