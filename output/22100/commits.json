[
  {
    "sha": "b11a195ef450bd138aa03204a5e74fdd3ddced26",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMTFhMTk1ZWY0NTBiZDEzOGFhMDMyMDRhNWU3NGZkZDNkZGNlZDI2",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2021-02-12T23:01:22Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2021-09-01T07:22:58Z"
      },
      "message": "refactor: Detach wallet transaction methods (followup for move-only)\n\nFollowup to commit \"MOVEONLY: CWallet transaction code out of\nwallet.cpp/.h\" that detaches and renames some CWalletTx methods, making\ninto them into standalone functions or CWallet methods instead.\n\nThere are no changes in behavior and no code changes that aren't purely\nmechanical. It just gives spend and receive functions more consistent\nnames and removes the circular dependencies added by the earlier\nMOVEONLY commit.\n\nThere are also no comment or documentation changes. Removed comments\nfrom transaction.h are just migrated to spend.h, receive.h, and\nwallet.h.",
      "tree": {
        "sha": "d8213bbf127031c6a13e0f9a14458fbc527ebafa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d8213bbf127031c6a13e0f9a14458fbc527ebafa"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b11a195ef450bd138aa03204a5e74fdd3ddced26",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b11a195ef450bd138aa03204a5e74fdd3ddced26",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b11a195ef450bd138aa03204a5e74fdd3ddced26",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b11a195ef450bd138aa03204a5e74fdd3ddced26/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b3a2b8c29fda5d924726d3087535bd34af7012b6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b3a2b8c29fda5d924726d3087535bd34af7012b6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b3a2b8c29fda5d924726d3087535bd34af7012b6"
      }
    ],
    "stats": {
      "total": 986,
      "additions": 499,
      "deletions": 487
    },
    "files": [
      {
        "sha": "aa79aab755f5c91236322596a1bc58d9bbd4415c",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=b11a195ef450bd138aa03204a5e74fdd3ddced26",
        "patch": "@@ -6,6 +6,7 @@\n #include <interfaces/chain.h>\n #include <node/context.h>\n #include <wallet/coinselection.h>\n+#include <wallet/spend.h>\n #include <wallet/wallet.h>\n \n #include <set>\n@@ -17,7 +18,7 @@ static void addCoin(const CAmount& nValue, const CWallet& wallet, std::vector<st\n     tx.nLockTime = nextLockTime++; // so all transactions get different hashes\n     tx.vout.resize(1);\n     tx.vout[0].nValue = nValue;\n-    wtxs.push_back(std::make_unique<CWalletTx>(&wallet, MakeTransactionRef(std::move(tx))));\n+    wtxs.push_back(std::make_unique<CWalletTx>(MakeTransactionRef(std::move(tx))));\n }\n \n // Simple benchmark for wallet coin selection. Note that it maybe be necessary\n@@ -45,7 +46,7 @@ static void CoinSelection(benchmark::Bench& bench)\n     // Create coins\n     std::vector<COutput> coins;\n     for (const auto& wtx : wtxs) {\n-        coins.emplace_back(wtx.get(), 0 /* iIn */, 6 * 24 /* nDepthIn */, true /* spendable */, true /* solvable */, true /* safe */);\n+        coins.emplace_back(wallet, *wtx, 0 /* iIn */, 6 * 24 /* nDepthIn */, true /* spendable */, true /* solvable */, true /* safe */);\n     }\n \n     const CoinEligibilityFilter filter_standard(1, 6, 0);\n@@ -56,7 +57,7 @@ static void CoinSelection(benchmark::Bench& bench)\n     bench.run([&] {\n         std::set<CInputCoin> setCoinsRet;\n         CAmount nValueRet;\n-        bool success = wallet.AttemptSelection(1003 * COIN, filter_standard, coins, setCoinsRet, nValueRet, coin_selection_params);\n+        bool success = AttemptSelection(wallet, 1003 * COIN, filter_standard, coins, setCoinsRet, nValueRet, coin_selection_params);\n         assert(success);\n         assert(nValueRet == 1003 * COIN);\n         assert(setCoinsRet.size() == 2);\n@@ -75,9 +76,9 @@ static void add_coin(const CAmount& nValue, int nInput, std::vector<OutputGroup>\n     CMutableTransaction tx;\n     tx.vout.resize(nInput + 1);\n     tx.vout[nInput].nValue = nValue;\n-    std::unique_ptr<CWalletTx> wtx = std::make_unique<CWalletTx>(&testWallet, MakeTransactionRef(std::move(tx)));\n+    std::unique_ptr<CWalletTx> wtx = std::make_unique<CWalletTx>(MakeTransactionRef(std::move(tx)));\n     set.emplace_back();\n-    set.back().Insert(COutput(wtx.get(), nInput, 0, true, true, true).GetInputCoin(), 0, true, 0, 0, false);\n+    set.back().Insert(COutput(testWallet, *wtx, nInput, 0, true, true, true).GetInputCoin(), 0, true, 0, 0, false);\n     wtxn.emplace_back(std::move(wtx));\n }\n // Copied from src/wallet/test/coinselector_tests.cpp"
      },
      {
        "sha": "a205d8b6e76db2f01ef427d83c9729f15f45af2a",
        "filename": "src/bench/wallet_balance.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/bench/wallet_balance.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/bench/wallet_balance.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/wallet_balance.cpp?ref=b11a195ef450bd138aa03204a5e74fdd3ddced26",
        "patch": "@@ -9,6 +9,7 @@\n #include <test/util/setup_common.h>\n #include <test/util/wallet.h>\n #include <validationinterface.h>\n+#include <wallet/receive.h>\n #include <wallet/wallet.h>\n \n #include <optional>\n@@ -35,11 +36,11 @@ static void WalletBalance(benchmark::Bench& bench, const bool set_dirty, const b\n     }\n     SyncWithValidationInterfaceQueue();\n \n-    auto bal = wallet.GetBalance(); // Cache\n+    auto bal = GetBalance(wallet); // Cache\n \n     bench.run([&] {\n         if (set_dirty) wallet.MarkDirty();\n-        bal = wallet.GetBalance();\n+        bal = GetBalance(wallet);\n         if (add_mine) assert(bal.m_mine_trusted > 0);\n         if (add_watchonly) assert(bal.m_watchonly_trusted > 0);\n     });"
      },
      {
        "sha": "f2de68295e3704b045d919d45fede6d429d563f7",
        "filename": "src/wallet/feebumper.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 6,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/feebumper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/feebumper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.cpp?ref=b11a195ef450bd138aa03204a5e74fdd3ddced26",
        "patch": "@@ -12,6 +12,8 @@\n #include <wallet/coincontrol.h>\n #include <wallet/feebumper.h>\n #include <wallet/fees.h>\n+#include <wallet/receive.h>\n+#include <wallet/spend.h>\n #include <wallet/wallet.h>\n \n //! Check whether transaction has descendant in wallet or mempool, or has been\n@@ -30,7 +32,7 @@ static feebumper::Result PreconditionChecks(const CWallet& wallet, const CWallet\n         }\n     }\n \n-    if (wtx.GetDepthInMainChain() != 0) {\n+    if (wallet.GetTxDepthInMainChain(wtx) != 0) {\n         errors.push_back(Untranslated(\"Transaction has been mined, or is conflicted with a mined transaction\"));\n         return feebumper::Result::WALLET_ERROR;\n     }\n@@ -48,7 +50,7 @@ static feebumper::Result PreconditionChecks(const CWallet& wallet, const CWallet\n     // check that original tx consists entirely of our inputs\n     // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n     isminefilter filter = wallet.GetLegacyScriptPubKeyMan() && wallet.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) ? ISMINE_WATCH_ONLY : ISMINE_SPENDABLE;\n-    if (!wallet.IsAllFromMe(*wtx.tx, filter)) {\n+    if (!AllInputsMine(wallet, *wtx.tx, filter)) {\n         errors.push_back(Untranslated(\"Transaction contains inputs that don't belong to this wallet\"));\n         return feebumper::Result::WALLET_ERROR;\n     }\n@@ -81,7 +83,7 @@ static feebumper::Result CheckFeeRate(const CWallet& wallet, const CWalletTx& wt\n \n     // Given old total fee and transaction size, calculate the old feeRate\n     isminefilter filter = wallet.GetLegacyScriptPubKeyMan() && wallet.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) ? ISMINE_WATCH_ONLY : ISMINE_SPENDABLE;\n-    CAmount old_fee = wtx.GetDebit(filter) - wtx.tx->GetValueOut();\n+    CAmount old_fee = CachedTxGetDebit(wallet, wtx, filter) - wtx.tx->GetValueOut();\n     const int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n     CFeeRate nOldFeeRate(old_fee, txSize);\n     // Min total fee is old fee + relay fee\n@@ -174,7 +176,7 @@ Result CreateRateBumpTransaction(CWallet& wallet, const uint256& txid, const CCo\n     // Fill in recipients(and preserve a single change key if there is one)\n     std::vector<CRecipient> recipients;\n     for (const auto& output : wtx.tx->vout) {\n-        if (!wallet.IsChange(output)) {\n+        if (!OutputIsChange(wallet, output)) {\n             CRecipient recipient = {output.scriptPubKey, output.nValue, false};\n             recipients.push_back(recipient);\n         } else {\n@@ -185,7 +187,7 @@ Result CreateRateBumpTransaction(CWallet& wallet, const uint256& txid, const CCo\n     }\n \n     isminefilter filter = wallet.GetLegacyScriptPubKeyMan() && wallet.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) ? ISMINE_WATCH_ONLY : ISMINE_SPENDABLE;\n-    old_fee = wtx.GetDebit(filter) - wtx.tx->GetValueOut();\n+    old_fee = CachedTxGetDebit(wallet, wtx, filter) - wtx.tx->GetValueOut();\n \n     if (coin_control.m_feerate) {\n         // The user provided a feeRate argument.\n@@ -220,7 +222,7 @@ Result CreateRateBumpTransaction(CWallet& wallet, const uint256& txid, const CCo\n     int change_pos_in_out = -1; // No requested location for change\n     bilingual_str fail_reason;\n     FeeCalculation fee_calc_out;\n-    if (!wallet.CreateTransaction(recipients, tx_new, fee_ret, change_pos_in_out, fail_reason, new_coin_control, fee_calc_out, false)) {\n+    if (!CreateTransaction(wallet, recipients, tx_new, fee_ret, change_pos_in_out, fail_reason, new_coin_control, fee_calc_out, false)) {\n         errors.push_back(Untranslated(\"Unable to create transaction.\") + Untranslated(\" \") + fail_reason);\n         return Result::WALLET_ERROR;\n     }"
      },
      {
        "sha": "9a8c1e3c02330efd12e9d572a7cfc006729139ee",
        "filename": "src/wallet/interfaces.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 16,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/interfaces.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/interfaces.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/interfaces.cpp?ref=b11a195ef450bd138aa03204a5e74fdd3ddced26",
        "patch": "@@ -23,7 +23,9 @@\n #include <wallet/fees.h>\n #include <wallet/ismine.h>\n #include <wallet/load.h>\n+#include <wallet/receive.h>\n #include <wallet/rpcwallet.h>\n+#include <wallet/spend.h>\n #include <wallet/wallet.h>\n \n #include <memory>\n@@ -55,7 +57,7 @@ WalletTx MakeWalletTx(CWallet& wallet, const CWalletTx& wtx)\n     result.tx = wtx.tx;\n     result.txin_is_mine.reserve(wtx.tx->vin.size());\n     for (const auto& txin : wtx.tx->vin) {\n-        result.txin_is_mine.emplace_back(wallet.IsMine(txin));\n+        result.txin_is_mine.emplace_back(InputIsMine(wallet, txin));\n     }\n     result.txout_is_mine.reserve(wtx.tx->vout.size());\n     result.txout_address.reserve(wtx.tx->vout.size());\n@@ -67,9 +69,9 @@ WalletTx MakeWalletTx(CWallet& wallet, const CWalletTx& wtx)\n                                                       wallet.IsMine(result.txout_address.back()) :\n                                                       ISMINE_NO);\n     }\n-    result.credit = wtx.GetCredit(ISMINE_ALL);\n-    result.debit = wtx.GetDebit(ISMINE_ALL);\n-    result.change = wtx.GetChange();\n+    result.credit = CachedTxGetCredit(wallet, wtx, ISMINE_ALL);\n+    result.debit = CachedTxGetDebit(wallet, wtx, ISMINE_ALL);\n+    result.change = CachedTxGetChange(wallet, wtx);\n     result.time = wtx.GetTxTime();\n     result.value_map = wtx.mapValue;\n     result.is_coinbase = wtx.IsCoinBase();\n@@ -81,15 +83,15 @@ WalletTxStatus MakeWalletTxStatus(const CWallet& wallet, const CWalletTx& wtx)\n {\n     WalletTxStatus result;\n     result.block_height = wtx.m_confirm.block_height > 0 ? wtx.m_confirm.block_height : std::numeric_limits<int>::max();\n-    result.blocks_to_maturity = wtx.GetBlocksToMaturity();\n-    result.depth_in_main_chain = wtx.GetDepthInMainChain();\n+    result.blocks_to_maturity = wallet.GetTxBlocksToMaturity(wtx);\n+    result.depth_in_main_chain = wallet.GetTxDepthInMainChain(wtx);\n     result.time_received = wtx.nTimeReceived;\n     result.lock_time = wtx.tx->nLockTime;\n     result.is_final = wallet.chain().checkFinalTx(*wtx.tx);\n-    result.is_trusted = wtx.IsTrusted();\n+    result.is_trusted = CachedTxIsTrusted(wallet, wtx);\n     result.is_abandoned = wtx.isAbandoned();\n     result.is_coinbase = wtx.IsCoinBase();\n-    result.is_in_main_chain = wtx.IsInMainChain();\n+    result.is_in_main_chain = wallet.IsTxInMainChain(wtx);\n     return result;\n }\n \n@@ -242,7 +244,7 @@ class WalletImpl : public Wallet\n         LOCK(m_wallet->cs_wallet);\n         CTransactionRef tx;\n         FeeCalculation fee_calc_out;\n-        if (!m_wallet->CreateTransaction(recipients, tx, fee, change_pos,\n+        if (!CreateTransaction(*m_wallet, recipients, tx, fee, change_pos,\n                 fail_reason, coin_control, fee_calc_out, sign)) {\n             return {};\n         }\n@@ -358,7 +360,7 @@ class WalletImpl : public Wallet\n     }\n     WalletBalances getBalances() override\n     {\n-        const auto bal = m_wallet->GetBalance();\n+        const auto bal = GetBalance(*m_wallet);\n         WalletBalances result;\n         result.balance = bal.m_mine_trusted;\n         result.unconfirmed_balance = bal.m_mine_untrusted_pending;\n@@ -381,15 +383,15 @@ class WalletImpl : public Wallet\n         balances = getBalances();\n         return true;\n     }\n-    CAmount getBalance() override { return m_wallet->GetBalance().m_mine_trusted; }\n+    CAmount getBalance() override { return GetBalance(*m_wallet).m_mine_trusted; }\n     CAmount getAvailableBalance(const CCoinControl& coin_control) override\n     {\n-        return m_wallet->GetAvailableBalance(&coin_control);\n+        return GetAvailableBalance(*m_wallet, &coin_control);\n     }\n     isminetype txinIsMine(const CTxIn& txin) override\n     {\n         LOCK(m_wallet->cs_wallet);\n-        return m_wallet->IsMine(txin);\n+        return InputIsMine(*m_wallet, txin);\n     }\n     isminetype txoutIsMine(const CTxOut& txout) override\n     {\n@@ -404,13 +406,13 @@ class WalletImpl : public Wallet\n     CAmount getCredit(const CTxOut& txout, isminefilter filter) override\n     {\n         LOCK(m_wallet->cs_wallet);\n-        return m_wallet->GetCredit(txout, filter);\n+        return OutputGetCredit(*m_wallet, txout, filter);\n     }\n     CoinsList listCoins() override\n     {\n         LOCK(m_wallet->cs_wallet);\n         CoinsList result;\n-        for (const auto& entry : m_wallet->ListCoins()) {\n+        for (const auto& entry : ListCoins(*m_wallet)) {\n             auto& group = result[entry.first];\n             for (const auto& coin : entry.second) {\n                 group.emplace_back(COutPoint(coin.tx->GetHash(), coin.i),\n@@ -428,7 +430,7 @@ class WalletImpl : public Wallet\n             result.emplace_back();\n             auto it = m_wallet->mapWallet.find(output.hash);\n             if (it != m_wallet->mapWallet.end()) {\n-                int depth = it->second.GetDepthInMainChain();\n+                int depth = m_wallet->GetTxDepthInMainChain(it->second);\n                 if (depth >= 0) {\n                     result.back() = MakeWalletTxOut(*m_wallet, it->second, output.n, depth);\n                 }"
      },
      {
        "sha": "a994976394d79c0ae85771a888257b218814ebfa",
        "filename": "src/wallet/load.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/load.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/load.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/load.cpp?ref=b11a195ef450bd138aa03204a5e74fdd3ddced26",
        "patch": "@@ -13,6 +13,7 @@\n #include <util/system.h>\n #include <util/translation.h>\n #include <wallet/context.h>\n+#include <wallet/spend.h>\n #include <wallet/wallet.h>\n #include <wallet/walletdb.h>\n "
      },
      {
        "sha": "98706dcdf8086866cfc12f98c4ea7c362197e15d",
        "filename": "src/wallet/receive.cpp",
        "status": "modified",
        "additions": 116,
        "deletions": 113,
        "changes": 229,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/receive.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/receive.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/receive.cpp?ref=b11a195ef450bd138aa03204a5e74fdd3ddced26",
        "patch": "@@ -7,61 +7,61 @@\n #include <wallet/transaction.h>\n #include <wallet/wallet.h>\n \n-isminetype CWallet::IsMine(const CTxIn &txin) const\n+isminetype InputIsMine(const CWallet& wallet, const CTxIn &txin)\n {\n-    AssertLockHeld(cs_wallet);\n-    std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n-    if (mi != mapWallet.end())\n+    AssertLockHeld(wallet.cs_wallet);\n+    std::map<uint256, CWalletTx>::const_iterator mi = wallet.mapWallet.find(txin.prevout.hash);\n+    if (mi != wallet.mapWallet.end())\n     {\n         const CWalletTx& prev = (*mi).second;\n         if (txin.prevout.n < prev.tx->vout.size())\n-            return IsMine(prev.tx->vout[txin.prevout.n]);\n+            return wallet.IsMine(prev.tx->vout[txin.prevout.n]);\n     }\n     return ISMINE_NO;\n }\n \n-bool CWallet::IsAllFromMe(const CTransaction& tx, const isminefilter& filter) const\n+bool AllInputsMine(const CWallet& wallet, const CTransaction& tx, const isminefilter& filter)\n {\n-    LOCK(cs_wallet);\n+    LOCK(wallet.cs_wallet);\n \n     for (const CTxIn& txin : tx.vin)\n     {\n-        auto mi = mapWallet.find(txin.prevout.hash);\n-        if (mi == mapWallet.end())\n+        auto mi = wallet.mapWallet.find(txin.prevout.hash);\n+        if (mi == wallet.mapWallet.end())\n             return false; // any unknown inputs can't be from us\n \n         const CWalletTx& prev = (*mi).second;\n \n         if (txin.prevout.n >= prev.tx->vout.size())\n             return false; // invalid input!\n \n-        if (!(IsMine(prev.tx->vout[txin.prevout.n]) & filter))\n+        if (!(wallet.IsMine(prev.tx->vout[txin.prevout.n]) & filter))\n             return false;\n     }\n     return true;\n }\n \n-CAmount CWallet::GetCredit(const CTxOut& txout, const isminefilter& filter) const\n+CAmount OutputGetCredit(const CWallet& wallet, const CTxOut& txout, const isminefilter& filter)\n {\n     if (!MoneyRange(txout.nValue))\n         throw std::runtime_error(std::string(__func__) + \": value out of range\");\n-    LOCK(cs_wallet);\n-    return ((IsMine(txout) & filter) ? txout.nValue : 0);\n+    LOCK(wallet.cs_wallet);\n+    return ((wallet.IsMine(txout) & filter) ? txout.nValue : 0);\n }\n \n-CAmount CWallet::GetCredit(const CTransaction& tx, const isminefilter& filter) const\n+CAmount TxGetCredit(const CWallet& wallet, const CTransaction& tx, const isminefilter& filter)\n {\n     CAmount nCredit = 0;\n     for (const CTxOut& txout : tx.vout)\n     {\n-        nCredit += GetCredit(txout, filter);\n+        nCredit += OutputGetCredit(wallet, txout, filter);\n         if (!MoneyRange(nCredit))\n             throw std::runtime_error(std::string(__func__) + \": value out of range\");\n     }\n     return nCredit;\n }\n \n-bool CWallet::IsChange(const CScript& script) const\n+bool ScriptIsChange(const CWallet& wallet, const CScript& script)\n {\n     // TODO: fix handling of 'change' outputs. The assumption is that any\n     // payment to a script that is ours, but is not in the address book\n@@ -70,179 +70,177 @@ bool CWallet::IsChange(const CScript& script) const\n     // a better way of identifying which outputs are 'the send' and which are\n     // 'the change' will need to be implemented (maybe extend CWalletTx to remember\n     // which output, if any, was change).\n-    AssertLockHeld(cs_wallet);\n-    if (IsMine(script))\n+    AssertLockHeld(wallet.cs_wallet);\n+    if (wallet.IsMine(script))\n     {\n         CTxDestination address;\n         if (!ExtractDestination(script, address))\n             return true;\n-        if (!FindAddressBookEntry(address)) {\n+        if (!wallet.FindAddressBookEntry(address)) {\n             return true;\n         }\n     }\n     return false;\n }\n \n-bool CWallet::IsChange(const CTxOut& txout) const\n+bool OutputIsChange(const CWallet& wallet, const CTxOut& txout)\n {\n-    return IsChange(txout.scriptPubKey);\n+    return ScriptIsChange(wallet, txout.scriptPubKey);\n }\n \n-CAmount CWallet::GetChange(const CTxOut& txout) const\n+CAmount OutputGetChange(const CWallet& wallet, const CTxOut& txout)\n {\n-    AssertLockHeld(cs_wallet);\n+    AssertLockHeld(wallet.cs_wallet);\n     if (!MoneyRange(txout.nValue))\n         throw std::runtime_error(std::string(__func__) + \": value out of range\");\n-    return (IsChange(txout) ? txout.nValue : 0);\n+    return (OutputIsChange(wallet, txout) ? txout.nValue : 0);\n }\n \n-CAmount CWallet::GetChange(const CTransaction& tx) const\n+CAmount TxGetChange(const CWallet& wallet, const CTransaction& tx)\n {\n-    LOCK(cs_wallet);\n+    LOCK(wallet.cs_wallet);\n     CAmount nChange = 0;\n     for (const CTxOut& txout : tx.vout)\n     {\n-        nChange += GetChange(txout);\n+        nChange += OutputGetChange(wallet, txout);\n         if (!MoneyRange(nChange))\n             throw std::runtime_error(std::string(__func__) + \": value out of range\");\n     }\n     return nChange;\n }\n \n-CAmount CWalletTx::GetCachableAmount(AmountType type, const isminefilter& filter, bool recalculate) const\n+static CAmount GetCachableAmount(const CWallet& wallet, const CWalletTx& wtx, CWalletTx::AmountType type, const isminefilter& filter, bool recalculate = false)\n {\n-    auto& amount = m_amounts[type];\n+    auto& amount = wtx.m_amounts[type];\n     if (recalculate || !amount.m_cached[filter]) {\n-        amount.Set(filter, type == DEBIT ? pwallet->GetDebit(*tx, filter) : pwallet->GetCredit(*tx, filter));\n-        m_is_cache_empty = false;\n+        amount.Set(filter, type == CWalletTx::DEBIT ? wallet.GetDebit(*wtx.tx, filter) : TxGetCredit(wallet, *wtx.tx, filter));\n+        wtx.m_is_cache_empty = false;\n     }\n     return amount.m_value[filter];\n }\n \n-CAmount CWalletTx::GetCredit(const isminefilter& filter) const\n+CAmount CachedTxGetCredit(const CWallet& wallet, const CWalletTx& wtx, const isminefilter& filter)\n {\n     // Must wait until coinbase is safely deep enough in the chain before valuing it\n-    if (IsImmatureCoinBase())\n+    if (wallet.IsTxImmatureCoinBase(wtx))\n         return 0;\n \n     CAmount credit = 0;\n     if (filter & ISMINE_SPENDABLE) {\n         // GetBalance can assume transactions in mapWallet won't change\n-        credit += GetCachableAmount(CREDIT, ISMINE_SPENDABLE);\n+        credit += GetCachableAmount(wallet, wtx, CWalletTx::CREDIT, ISMINE_SPENDABLE);\n     }\n     if (filter & ISMINE_WATCH_ONLY) {\n-        credit += GetCachableAmount(CREDIT, ISMINE_WATCH_ONLY);\n+        credit += GetCachableAmount(wallet, wtx, CWalletTx::CREDIT, ISMINE_WATCH_ONLY);\n     }\n     return credit;\n }\n \n-CAmount CWalletTx::GetDebit(const isminefilter& filter) const\n+CAmount CachedTxGetDebit(const CWallet& wallet, const CWalletTx& wtx, const isminefilter& filter)\n {\n-    if (tx->vin.empty())\n+    if (wtx.tx->vin.empty())\n         return 0;\n \n     CAmount debit = 0;\n     if (filter & ISMINE_SPENDABLE) {\n-        debit += GetCachableAmount(DEBIT, ISMINE_SPENDABLE);\n+        debit += GetCachableAmount(wallet, wtx, CWalletTx::DEBIT, ISMINE_SPENDABLE);\n     }\n     if (filter & ISMINE_WATCH_ONLY) {\n-        debit += GetCachableAmount(DEBIT, ISMINE_WATCH_ONLY);\n+        debit += GetCachableAmount(wallet, wtx, CWalletTx::DEBIT, ISMINE_WATCH_ONLY);\n     }\n     return debit;\n }\n \n-CAmount CWalletTx::GetChange() const\n+CAmount CachedTxGetChange(const CWallet& wallet, const CWalletTx& wtx)\n {\n-    if (fChangeCached)\n-        return nChangeCached;\n-    nChangeCached = pwallet->GetChange(*tx);\n-    fChangeCached = true;\n-    return nChangeCached;\n+    if (wtx.fChangeCached)\n+        return wtx.nChangeCached;\n+    wtx.nChangeCached = TxGetChange(wallet, *wtx.tx);\n+    wtx.fChangeCached = true;\n+    return wtx.nChangeCached;\n }\n \n-CAmount CWalletTx::GetImmatureCredit(bool fUseCache) const\n+CAmount CachedTxGetImmatureCredit(const CWallet& wallet, const CWalletTx& wtx, bool fUseCache)\n {\n-    if (IsImmatureCoinBase() && IsInMainChain()) {\n-        return GetCachableAmount(IMMATURE_CREDIT, ISMINE_SPENDABLE, !fUseCache);\n+    if (wallet.IsTxImmatureCoinBase(wtx) && wallet.IsTxInMainChain(wtx)) {\n+        return GetCachableAmount(wallet, wtx, CWalletTx::IMMATURE_CREDIT, ISMINE_SPENDABLE, !fUseCache);\n     }\n \n     return 0;\n }\n \n-CAmount CWalletTx::GetImmatureWatchOnlyCredit(const bool fUseCache) const\n+CAmount CachedTxGetImmatureWatchOnlyCredit(const CWallet& wallet, const CWalletTx& wtx, const bool fUseCache)\n {\n-    if (IsImmatureCoinBase() && IsInMainChain()) {\n-        return GetCachableAmount(IMMATURE_CREDIT, ISMINE_WATCH_ONLY, !fUseCache);\n+    if (wallet.IsTxImmatureCoinBase(wtx) && wallet.IsTxInMainChain(wtx)) {\n+        return GetCachableAmount(wallet, wtx, CWalletTx::IMMATURE_CREDIT, ISMINE_WATCH_ONLY, !fUseCache);\n     }\n \n     return 0;\n }\n \n-CAmount CWalletTx::GetAvailableCredit(bool fUseCache, const isminefilter& filter) const\n+CAmount CachedTxGetAvailableCredit(const CWallet& wallet, const CWalletTx& wtx, bool fUseCache, const isminefilter& filter)\n {\n-    if (pwallet == nullptr)\n-        return 0;\n-\n     // Avoid caching ismine for NO or ALL cases (could remove this check and simplify in the future).\n     bool allow_cache = (filter & ISMINE_ALL) && (filter & ISMINE_ALL) != ISMINE_ALL;\n \n     // Must wait until coinbase is safely deep enough in the chain before valuing it\n-    if (IsImmatureCoinBase())\n+    if (wallet.IsTxImmatureCoinBase(wtx))\n         return 0;\n \n-    if (fUseCache && allow_cache && m_amounts[AVAILABLE_CREDIT].m_cached[filter]) {\n-        return m_amounts[AVAILABLE_CREDIT].m_value[filter];\n+    if (fUseCache && allow_cache && wtx.m_amounts[CWalletTx::AVAILABLE_CREDIT].m_cached[filter]) {\n+        return wtx.m_amounts[CWalletTx::AVAILABLE_CREDIT].m_value[filter];\n     }\n \n-    bool allow_used_addresses = (filter & ISMINE_USED) || !pwallet->IsWalletFlagSet(WALLET_FLAG_AVOID_REUSE);\n+    bool allow_used_addresses = (filter & ISMINE_USED) || !wallet.IsWalletFlagSet(WALLET_FLAG_AVOID_REUSE);\n     CAmount nCredit = 0;\n-    uint256 hashTx = GetHash();\n-    for (unsigned int i = 0; i < tx->vout.size(); i++)\n+    uint256 hashTx = wtx.GetHash();\n+    for (unsigned int i = 0; i < wtx.tx->vout.size(); i++)\n     {\n-        if (!pwallet->IsSpent(hashTx, i) && (allow_used_addresses || !pwallet->IsSpentKey(hashTx, i))) {\n-            const CTxOut &txout = tx->vout[i];\n-            nCredit += pwallet->GetCredit(txout, filter);\n+        if (!wallet.IsSpent(hashTx, i) && (allow_used_addresses || !wallet.IsSpentKey(hashTx, i))) {\n+            const CTxOut &txout = wtx.tx->vout[i];\n+            nCredit += OutputGetCredit(wallet, txout, filter);\n             if (!MoneyRange(nCredit))\n                 throw std::runtime_error(std::string(__func__) + \" : value out of range\");\n         }\n     }\n \n     if (allow_cache) {\n-        m_amounts[AVAILABLE_CREDIT].Set(filter, nCredit);\n-        m_is_cache_empty = false;\n+        wtx.m_amounts[CWalletTx::AVAILABLE_CREDIT].Set(filter, nCredit);\n+        wtx.m_is_cache_empty = false;\n     }\n \n     return nCredit;\n }\n \n-void CWalletTx::GetAmounts(std::list<COutputEntry>& listReceived,\n-                           std::list<COutputEntry>& listSent, CAmount& nFee, const isminefilter& filter) const\n+void CachedTxGetAmounts(const CWallet& wallet, const CWalletTx& wtx,\n+                  std::list<COutputEntry>& listReceived,\n+                  std::list<COutputEntry>& listSent, CAmount& nFee, const isminefilter& filter)\n {\n     nFee = 0;\n     listReceived.clear();\n     listSent.clear();\n \n     // Compute fee:\n-    CAmount nDebit = GetDebit(filter);\n+    CAmount nDebit = CachedTxGetDebit(wallet, wtx, filter);\n     if (nDebit > 0) // debit>0 means we signed/sent this transaction\n     {\n-        CAmount nValueOut = tx->GetValueOut();\n+        CAmount nValueOut = wtx.tx->GetValueOut();\n         nFee = nDebit - nValueOut;\n     }\n \n-    LOCK(pwallet->cs_wallet);\n+    LOCK(wallet.cs_wallet);\n     // Sent/received.\n-    for (unsigned int i = 0; i < tx->vout.size(); ++i)\n+    for (unsigned int i = 0; i < wtx.tx->vout.size(); ++i)\n     {\n-        const CTxOut& txout = tx->vout[i];\n-        isminetype fIsMine = pwallet->IsMine(txout);\n+        const CTxOut& txout = wtx.tx->vout[i];\n+        isminetype fIsMine = wallet.IsMine(txout);\n         // Only need to handle txouts if AT LEAST one of these is true:\n         //   1) they debit from us (sent)\n         //   2) the output is to us (received)\n         if (nDebit > 0)\n         {\n             // Don't report 'change' txouts\n-            if (pwallet->IsChange(txout))\n+            if (OutputIsChange(wallet, txout))\n                 continue;\n         }\n         else if (!(fIsMine & filter))\n@@ -253,8 +251,8 @@ void CWalletTx::GetAmounts(std::list<COutputEntry>& listReceived,\n \n         if (!ExtractDestination(txout.scriptPubKey, address) && !txout.scriptPubKey.IsUnspendable())\n         {\n-            pwallet->WalletLogPrintf(\"CWalletTx::GetAmounts: Unknown transaction type found, txid %s\\n\",\n-                                    this->GetHash().ToString());\n+            wallet.WalletLogPrintf(\"CWalletTx::GetAmounts: Unknown transaction type found, txid %s\\n\",\n+                                    wtx.GetHash().ToString());\n             address = CNoDestination();\n         }\n \n@@ -271,16 +269,21 @@ void CWalletTx::GetAmounts(std::list<COutputEntry>& listReceived,\n \n }\n \n-bool CWallet::IsTrusted(const CWalletTx& wtx, std::set<uint256>& trusted_parents) const\n+bool CachedTxIsFromMe(const CWallet& wallet, const CWalletTx& wtx, const isminefilter& filter)\n+{\n+    return (CachedTxGetDebit(wallet, wtx, filter) > 0);\n+}\n+\n+bool CachedTxIsTrusted(const CWallet& wallet, const CWalletTx& wtx, std::set<uint256>& trusted_parents)\n {\n-    AssertLockHeld(cs_wallet);\n+    AssertLockHeld(wallet.cs_wallet);\n     // Quick answer in most cases\n-    if (!chain().checkFinalTx(*wtx.tx)) return false;\n-    int nDepth = wtx.GetDepthInMainChain();\n+    if (!wallet.chain().checkFinalTx(*wtx.tx)) return false;\n+    int nDepth = wallet.GetTxDepthInMainChain(wtx);\n     if (nDepth >= 1) return true;\n     if (nDepth < 0) return false;\n     // using wtx's cached debit\n-    if (!m_spend_zero_conf_change || !wtx.IsFromMe(ISMINE_ALL)) return false;\n+    if (!wallet.m_spend_zero_conf_change || !CachedTxIsFromMe(wallet, wtx, ISMINE_ALL)) return false;\n \n     // Don't trust unconfirmed transactions from us unless they are in the mempool.\n     if (!wtx.InMempool()) return false;\n@@ -289,41 +292,41 @@ bool CWallet::IsTrusted(const CWalletTx& wtx, std::set<uint256>& trusted_parents\n     for (const CTxIn& txin : wtx.tx->vin)\n     {\n         // Transactions not sent by us: not trusted\n-        const CWalletTx* parent = GetWalletTx(txin.prevout.hash);\n+        const CWalletTx* parent = wallet.GetWalletTx(txin.prevout.hash);\n         if (parent == nullptr) return false;\n         const CTxOut& parentOut = parent->tx->vout[txin.prevout.n];\n         // Check that this specific input being spent is trusted\n-        if (IsMine(parentOut) != ISMINE_SPENDABLE) return false;\n+        if (wallet.IsMine(parentOut) != ISMINE_SPENDABLE) return false;\n         // If we've already trusted this parent, continue\n         if (trusted_parents.count(parent->GetHash())) continue;\n         // Recurse to check that the parent is also trusted\n-        if (!IsTrusted(*parent, trusted_parents)) return false;\n+        if (!CachedTxIsTrusted(wallet, *parent, trusted_parents)) return false;\n         trusted_parents.insert(parent->GetHash());\n     }\n     return true;\n }\n \n-bool CWalletTx::IsTrusted() const\n+bool CachedTxIsTrusted(const CWallet& wallet, const CWalletTx& wtx)\n {\n     std::set<uint256> trusted_parents;\n-    LOCK(pwallet->cs_wallet);\n-    return pwallet->IsTrusted(*this, trusted_parents);\n+    LOCK(wallet.cs_wallet);\n+    return CachedTxIsTrusted(wallet, wtx, trusted_parents);\n }\n \n-CWallet::Balance CWallet::GetBalance(const int min_depth, bool avoid_reuse) const\n+Balance GetBalance(const CWallet& wallet, const int min_depth, bool avoid_reuse)\n {\n     Balance ret;\n     isminefilter reuse_filter = avoid_reuse ? ISMINE_NO : ISMINE_USED;\n     {\n-        LOCK(cs_wallet);\n+        LOCK(wallet.cs_wallet);\n         std::set<uint256> trusted_parents;\n-        for (const auto& entry : mapWallet)\n+        for (const auto& entry : wallet.mapWallet)\n         {\n             const CWalletTx& wtx = entry.second;\n-            const bool is_trusted{IsTrusted(wtx, trusted_parents)};\n-            const int tx_depth{wtx.GetDepthInMainChain()};\n-            const CAmount tx_credit_mine{wtx.GetAvailableCredit(/* fUseCache */ true, ISMINE_SPENDABLE | reuse_filter)};\n-            const CAmount tx_credit_watchonly{wtx.GetAvailableCredit(/* fUseCache */ true, ISMINE_WATCH_ONLY | reuse_filter)};\n+            const bool is_trusted{CachedTxIsTrusted(wallet, wtx, trusted_parents)};\n+            const int tx_depth{wallet.GetTxDepthInMainChain(wtx)};\n+            const CAmount tx_credit_mine{CachedTxGetAvailableCredit(wallet, wtx, /* fUseCache */ true, ISMINE_SPENDABLE | reuse_filter)};\n+            const CAmount tx_credit_watchonly{CachedTxGetAvailableCredit(wallet, wtx, /* fUseCache */ true, ISMINE_WATCH_ONLY | reuse_filter)};\n             if (is_trusted && tx_depth >= min_depth) {\n                 ret.m_mine_trusted += tx_credit_mine;\n                 ret.m_watchonly_trusted += tx_credit_watchonly;\n@@ -332,43 +335,43 @@ CWallet::Balance CWallet::GetBalance(const int min_depth, bool avoid_reuse) cons\n                 ret.m_mine_untrusted_pending += tx_credit_mine;\n                 ret.m_watchonly_untrusted_pending += tx_credit_watchonly;\n             }\n-            ret.m_mine_immature += wtx.GetImmatureCredit();\n-            ret.m_watchonly_immature += wtx.GetImmatureWatchOnlyCredit();\n+            ret.m_mine_immature += CachedTxGetImmatureCredit(wallet, wtx);\n+            ret.m_watchonly_immature += CachedTxGetImmatureWatchOnlyCredit(wallet, wtx);\n         }\n     }\n     return ret;\n }\n \n-std::map<CTxDestination, CAmount> CWallet::GetAddressBalances() const\n+std::map<CTxDestination, CAmount> GetAddressBalances(const CWallet& wallet)\n {\n     std::map<CTxDestination, CAmount> balances;\n \n     {\n-        LOCK(cs_wallet);\n+        LOCK(wallet.cs_wallet);\n         std::set<uint256> trusted_parents;\n-        for (const auto& walletEntry : mapWallet)\n+        for (const auto& walletEntry : wallet.mapWallet)\n         {\n             const CWalletTx& wtx = walletEntry.second;\n \n-            if (!IsTrusted(wtx, trusted_parents))\n+            if (!CachedTxIsTrusted(wallet, wtx, trusted_parents))\n                 continue;\n \n-            if (wtx.IsImmatureCoinBase())\n+            if (wallet.IsTxImmatureCoinBase(wtx))\n                 continue;\n \n-            int nDepth = wtx.GetDepthInMainChain();\n-            if (nDepth < (wtx.IsFromMe(ISMINE_ALL) ? 0 : 1))\n+            int nDepth = wallet.GetTxDepthInMainChain(wtx);\n+            if (nDepth < (CachedTxIsFromMe(wallet, wtx, ISMINE_ALL) ? 0 : 1))\n                 continue;\n \n             for (unsigned int i = 0; i < wtx.tx->vout.size(); i++)\n             {\n                 CTxDestination addr;\n-                if (!IsMine(wtx.tx->vout[i]))\n+                if (!wallet.IsMine(wtx.tx->vout[i]))\n                     continue;\n                 if(!ExtractDestination(wtx.tx->vout[i].scriptPubKey, addr))\n                     continue;\n \n-                CAmount n = IsSpent(walletEntry.first, i) ? 0 : wtx.tx->vout[i].nValue;\n+                CAmount n = wallet.IsSpent(walletEntry.first, i) ? 0 : wtx.tx->vout[i].nValue;\n                 balances[addr] += n;\n             }\n         }\n@@ -377,13 +380,13 @@ std::map<CTxDestination, CAmount> CWallet::GetAddressBalances() const\n     return balances;\n }\n \n-std::set< std::set<CTxDestination> > CWallet::GetAddressGroupings() const\n+std::set< std::set<CTxDestination> > GetAddressGroupings(const CWallet& wallet)\n {\n-    AssertLockHeld(cs_wallet);\n+    AssertLockHeld(wallet.cs_wallet);\n     std::set< std::set<CTxDestination> > groupings;\n     std::set<CTxDestination> grouping;\n \n-    for (const auto& walletEntry : mapWallet)\n+    for (const auto& walletEntry : wallet.mapWallet)\n     {\n         const CWalletTx& wtx = walletEntry.second;\n \n@@ -394,9 +397,9 @@ std::set< std::set<CTxDestination> > CWallet::GetAddressGroupings() const\n             for (const CTxIn& txin : wtx.tx->vin)\n             {\n                 CTxDestination address;\n-                if(!IsMine(txin)) /* If this input isn't mine, ignore it */\n+                if(!InputIsMine(wallet, txin)) /* If this input isn't mine, ignore it */\n                     continue;\n-                if(!ExtractDestination(mapWallet.at(txin.prevout.hash).tx->vout[txin.prevout.n].scriptPubKey, address))\n+                if(!ExtractDestination(wallet.mapWallet.at(txin.prevout.hash).tx->vout[txin.prevout.n].scriptPubKey, address))\n                     continue;\n                 grouping.insert(address);\n                 any_mine = true;\n@@ -406,7 +409,7 @@ std::set< std::set<CTxDestination> > CWallet::GetAddressGroupings() const\n             if (any_mine)\n             {\n                for (const CTxOut& txout : wtx.tx->vout)\n-                   if (IsChange(txout))\n+                   if (OutputIsChange(wallet, txout))\n                    {\n                        CTxDestination txoutAddr;\n                        if(!ExtractDestination(txout.scriptPubKey, txoutAddr))\n@@ -423,7 +426,7 @@ std::set< std::set<CTxDestination> > CWallet::GetAddressGroupings() const\n \n         // group lone addrs by themselves\n         for (const auto& txout : wtx.tx->vout)\n-            if (IsMine(txout))\n+            if (wallet.IsMine(txout))\n             {\n                 CTxDestination address;\n                 if(!ExtractDestination(txout.scriptPubKey, address))"
      },
      {
        "sha": "b4b311636b626b27e2e0fa034b1e39a155cb392f",
        "filename": "src/wallet/receive.h",
        "status": "modified",
        "additions": 44,
        "deletions": 0,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/receive.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/receive.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/receive.h?ref=b11a195ef450bd138aa03204a5e74fdd3ddced26",
        "patch": "@@ -10,11 +10,55 @@\n #include <wallet/transaction.h>\n #include <wallet/wallet.h>\n \n+isminetype InputIsMine(const CWallet& wallet, const CTxIn& txin) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet);\n+\n+/** Returns whether all of the inputs match the filter */\n+bool AllInputsMine(const CWallet& wallet, const CTransaction& tx, const isminefilter& filter);\n+\n+CAmount OutputGetCredit(const CWallet& wallet, const CTxOut& txout, const isminefilter& filter);\n+CAmount TxGetCredit(const CWallet& wallet, const CTransaction& tx, const isminefilter& filter);\n+\n+bool ScriptIsChange(const CWallet& wallet, const CScript& script) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet);\n+bool OutputIsChange(const CWallet& wallet, const CTxOut& txout) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet);\n+CAmount OutputGetChange(const CWallet& wallet, const CTxOut& txout) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet);\n+CAmount TxGetChange(const CWallet& wallet, const CTransaction& tx);\n+\n+CAmount CachedTxGetCredit(const CWallet& wallet, const CWalletTx& wtx, const isminefilter& filter);\n+//! filter decides which addresses will count towards the debit\n+CAmount CachedTxGetDebit(const CWallet& wallet, const CWalletTx& wtx, const isminefilter& filter);\n+CAmount CachedTxGetChange(const CWallet& wallet, const CWalletTx& wtx);\n+CAmount CachedTxGetImmatureCredit(const CWallet& wallet, const CWalletTx& wtx, bool fUseCache = true);\n+CAmount CachedTxGetImmatureWatchOnlyCredit(const CWallet& wallet, const CWalletTx& wtx, const bool fUseCache = true);\n+// TODO: Remove \"NO_THREAD_SAFETY_ANALYSIS\" and replace it with the correct\n+// annotation \"EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\". The\n+// annotation \"NO_THREAD_SAFETY_ANALYSIS\" was temporarily added to avoid\n+// having to resolve the issue of member access into incomplete type CWallet.\n+CAmount CachedTxGetAvailableCredit(const CWallet& wallet, const CWalletTx& wtx, bool fUseCache = true, const isminefilter& filter = ISMINE_SPENDABLE) NO_THREAD_SAFETY_ANALYSIS;\n struct COutputEntry\n {\n     CTxDestination destination;\n     CAmount amount;\n     int vout;\n };\n+void CachedTxGetAmounts(const CWallet& wallet, const CWalletTx& wtx,\n+                        std::list<COutputEntry>& listReceived,\n+                        std::list<COutputEntry>& listSent,\n+                        CAmount& nFee, const isminefilter& filter);\n+bool CachedTxIsFromMe(const CWallet& wallet, const CWalletTx& wtx, const isminefilter& filter);\n+bool CachedTxIsTrusted(const CWallet& wallet, const CWalletTx& wtx, std::set<uint256>& trusted_parents) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet);\n+bool CachedTxIsTrusted(const CWallet& wallet, const CWalletTx& wtx);\n+\n+struct Balance {\n+    CAmount m_mine_trusted{0};           //!< Trusted, at depth=GetBalance.min_depth or more\n+    CAmount m_mine_untrusted_pending{0}; //!< Untrusted, but in mempool (pending)\n+    CAmount m_mine_immature{0};          //!< Immature coinbases in the main chain\n+    CAmount m_watchonly_trusted{0};\n+    CAmount m_watchonly_untrusted_pending{0};\n+    CAmount m_watchonly_immature{0};\n+};\n+Balance GetBalance(const CWallet& wallet, int min_depth = 0, bool avoid_reuse = true);\n+\n+std::map<CTxDestination, CAmount> GetAddressBalances(const CWallet& wallet);\n+std::set<std::set<CTxDestination>> GetAddressGroupings(const CWallet& wallet) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet);\n \n #endif // BITCOIN_WALLET_RECEIVE_H"
      },
      {
        "sha": "ff9e10c5ad1da29d4b2daa12f0991c964058bea5",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 30,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=b11a195ef450bd138aa03204a5e74fdd3ddced26",
        "patch": "@@ -31,7 +31,9 @@\n #include <wallet/context.h>\n #include <wallet/feebumper.h>\n #include <wallet/load.h>\n+#include <wallet/receive.h>\n #include <wallet/rpcwallet.h>\n+#include <wallet/spend.h>\n #include <wallet/wallet.h>\n #include <wallet/walletdb.h>\n #include <wallet/walletutil.h>\n@@ -147,9 +149,10 @@ LegacyScriptPubKeyMan& EnsureLegacyScriptPubKeyMan(CWallet& wallet, bool also_cr\n     return *spk_man;\n }\n \n-static void WalletTxToJSON(interfaces::Chain& chain, const CWalletTx& wtx, UniValue& entry)\n+static void WalletTxToJSON(const CWallet& wallet, const CWalletTx& wtx, UniValue& entry)\n {\n-    int confirms = wtx.GetDepthInMainChain();\n+    interfaces::Chain& chain = wallet.chain();\n+    int confirms = wallet.GetTxDepthInMainChain(wtx);\n     entry.pushKV(\"confirmations\", confirms);\n     if (wtx.IsCoinBase())\n         entry.pushKV(\"generated\", true);\n@@ -162,12 +165,12 @@ static void WalletTxToJSON(interfaces::Chain& chain, const CWalletTx& wtx, UniVa\n         CHECK_NONFATAL(chain.findBlock(wtx.m_confirm.hashBlock, FoundBlock().time(block_time)));\n         entry.pushKV(\"blocktime\", block_time);\n     } else {\n-        entry.pushKV(\"trusted\", wtx.IsTrusted());\n+        entry.pushKV(\"trusted\", CachedTxIsTrusted(wallet, wtx));\n     }\n     uint256 hash = wtx.GetHash();\n     entry.pushKV(\"txid\", hash.GetHex());\n     UniValue conflicts(UniValue::VARR);\n-    for (const uint256& conflict : wtx.GetConflicts())\n+    for (const uint256& conflict : wallet.GetTxConflicts(wtx))\n         conflicts.push_back(conflict.GetHex());\n     entry.pushKV(\"walletconflicts\", conflicts);\n     entry.pushKV(\"time\", wtx.GetTxTime());\n@@ -423,7 +426,7 @@ UniValue SendMoney(CWallet& wallet, const CCoinControl &coin_control, std::vecto\n     bilingual_str error;\n     CTransactionRef tx;\n     FeeCalculation fee_calc_out;\n-    const bool fCreated = wallet.CreateTransaction(recipients, tx, nFeeRequired, nChangePosRet, error, coin_control, fee_calc_out, true);\n+    const bool fCreated = CreateTransaction(wallet, recipients, tx, nFeeRequired, nChangePosRet, error, coin_control, fee_calc_out, true);\n     if (!fCreated) {\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, error.original);\n     }\n@@ -576,8 +579,8 @@ static RPCHelpMan listaddressgroupings()\n     LOCK(pwallet->cs_wallet);\n \n     UniValue jsonGroupings(UniValue::VARR);\n-    std::map<CTxDestination, CAmount> balances = pwallet->GetAddressBalances();\n-    for (const std::set<CTxDestination>& grouping : pwallet->GetAddressGroupings()) {\n+    std::map<CTxDestination, CAmount> balances = GetAddressBalances(*pwallet);\n+    for (const std::set<CTxDestination>& grouping : GetAddressGroupings(*pwallet)) {\n         UniValue jsonGrouping(UniValue::VARR);\n         for (const CTxDestination& address : grouping)\n         {\n@@ -686,7 +689,7 @@ static CAmount GetReceived(const CWallet& wallet, const UniValue& params, bool b\n     CAmount amount = 0;\n     for (const std::pair<const uint256, CWalletTx>& wtx_pair : wallet.mapWallet) {\n         const CWalletTx& wtx = wtx_pair.second;\n-        if (wtx.IsCoinBase() || !wallet.chain().checkFinalTx(*wtx.tx) || wtx.GetDepthInMainChain() < min_depth) {\n+        if (wtx.IsCoinBase() || !wallet.chain().checkFinalTx(*wtx.tx) || wallet.GetTxDepthInMainChain(wtx) < min_depth) {\n             continue;\n         }\n \n@@ -826,7 +829,7 @@ static RPCHelpMan getbalance()\n \n     bool avoid_reuse = GetAvoidReuseFlag(*pwallet, request.params[3]);\n \n-    const auto bal = pwallet->GetBalance(min_depth, avoid_reuse);\n+    const auto bal = GetBalance(*pwallet, min_depth, avoid_reuse);\n \n     return ValueFromAmount(bal.m_mine_trusted + (include_watchonly ? bal.m_watchonly_trusted : 0));\n },\n@@ -851,7 +854,7 @@ static RPCHelpMan getunconfirmedbalance()\n \n     LOCK(pwallet->cs_wallet);\n \n-    return ValueFromAmount(pwallet->GetBalance().m_mine_untrusted_pending);\n+    return ValueFromAmount(GetBalance(*pwallet).m_mine_untrusted_pending);\n },\n     };\n }\n@@ -1085,7 +1088,7 @@ static UniValue ListReceived(const CWallet& wallet, const UniValue& params, bool\n             continue;\n         }\n \n-        int nDepth = wtx.GetDepthInMainChain();\n+        int nDepth = wallet.GetTxDepthInMainChain(wtx);\n         if (nDepth < nMinDepth)\n             continue;\n \n@@ -1310,9 +1313,9 @@ static void ListTransactions(const CWallet& wallet, const CWalletTx& wtx, int nM\n     std::list<COutputEntry> listReceived;\n     std::list<COutputEntry> listSent;\n \n-    wtx.GetAmounts(listReceived, listSent, nFee, filter_ismine);\n+    CachedTxGetAmounts(wallet, wtx, listReceived, listSent, nFee, filter_ismine);\n \n-    bool involvesWatchonly = wtx.IsFromMe(ISMINE_WATCH_ONLY);\n+    bool involvesWatchonly = CachedTxIsFromMe(wallet, wtx, ISMINE_WATCH_ONLY);\n \n     // Sent\n     if (!filter_label)\n@@ -1333,14 +1336,14 @@ static void ListTransactions(const CWallet& wallet, const CWalletTx& wtx, int nM\n             entry.pushKV(\"vout\", s.vout);\n             entry.pushKV(\"fee\", ValueFromAmount(-nFee));\n             if (fLong)\n-                WalletTxToJSON(wallet.chain(), wtx, entry);\n+                WalletTxToJSON(wallet, wtx, entry);\n             entry.pushKV(\"abandoned\", wtx.isAbandoned());\n             ret.push_back(entry);\n         }\n     }\n \n     // Received\n-    if (listReceived.size() > 0 && wtx.GetDepthInMainChain() >= nMinDepth) {\n+    if (listReceived.size() > 0 && wallet.GetTxDepthInMainChain(wtx) >= nMinDepth) {\n         for (const COutputEntry& r : listReceived)\n         {\n             std::string label;\n@@ -1358,9 +1361,9 @@ static void ListTransactions(const CWallet& wallet, const CWalletTx& wtx, int nM\n             MaybePushAddress(entry, r.destination);\n             if (wtx.IsCoinBase())\n             {\n-                if (wtx.GetDepthInMainChain() < 1)\n+                if (wallet.GetTxDepthInMainChain(wtx) < 1)\n                     entry.pushKV(\"category\", \"orphan\");\n-                else if (wtx.IsImmatureCoinBase())\n+                else if (wallet.IsTxImmatureCoinBase(wtx))\n                     entry.pushKV(\"category\", \"immature\");\n                 else\n                     entry.pushKV(\"category\", \"generate\");\n@@ -1375,7 +1378,7 @@ static void ListTransactions(const CWallet& wallet, const CWalletTx& wtx, int nM\n             }\n             entry.pushKV(\"vout\", r.vout);\n             if (fLong)\n-                WalletTxToJSON(wallet.chain(), wtx, entry);\n+                WalletTxToJSON(wallet, wtx, entry);\n             ret.push_back(entry);\n         }\n     }\n@@ -1615,7 +1618,7 @@ static RPCHelpMan listsinceblock()\n     for (const std::pair<const uint256, CWalletTx>& pairWtx : wallet.mapWallet) {\n         const CWalletTx& tx = pairWtx.second;\n \n-        if (depth == -1 || abs(tx.GetDepthInMainChain()) < depth) {\n+        if (depth == -1 || abs(wallet.GetTxDepthInMainChain(tx)) < depth) {\n             ListTransactions(wallet, tx, 0, true, transactions, filter, nullptr /* filter_label */);\n         }\n     }\n@@ -1736,16 +1739,16 @@ static RPCHelpMan gettransaction()\n     }\n     const CWalletTx& wtx = it->second;\n \n-    CAmount nCredit = wtx.GetCredit(filter);\n-    CAmount nDebit = wtx.GetDebit(filter);\n+    CAmount nCredit = CachedTxGetCredit(*pwallet, wtx, filter);\n+    CAmount nDebit = CachedTxGetDebit(*pwallet, wtx, filter);\n     CAmount nNet = nCredit - nDebit;\n-    CAmount nFee = (wtx.IsFromMe(filter) ? wtx.tx->GetValueOut() - nDebit : 0);\n+    CAmount nFee = (CachedTxIsFromMe(*pwallet, wtx, filter) ? wtx.tx->GetValueOut() - nDebit : 0);\n \n     entry.pushKV(\"amount\", ValueFromAmount(nNet - nFee));\n-    if (wtx.IsFromMe(filter))\n+    if (CachedTxIsFromMe(*pwallet, wtx, filter))\n         entry.pushKV(\"fee\", ValueFromAmount(nFee));\n \n-    WalletTxToJSON(pwallet->chain(), wtx, entry);\n+    WalletTxToJSON(*pwallet, wtx, entry);\n \n     UniValue details(UniValue::VARR);\n     ListTransactions(*pwallet, wtx, 0, false, details, filter, nullptr /* filter_label */);\n@@ -2384,7 +2387,7 @@ static RPCHelpMan getbalances()\n \n     LOCK(wallet.cs_wallet);\n \n-    const auto bal = wallet.GetBalance();\n+    const auto bal = GetBalance(wallet);\n     UniValue balances{UniValue::VOBJ};\n     {\n         UniValue balances_mine{UniValue::VOBJ};\n@@ -2394,7 +2397,7 @@ static RPCHelpMan getbalances()\n         if (wallet.IsWalletFlagSet(WALLET_FLAG_AVOID_REUSE)) {\n             // If the AVOID_REUSE flag is set, bal has been set to just the un-reused address balance. Get\n             // the total balance, and then subtract bal to get the reused address balance.\n-            const auto full_bal = wallet.GetBalance(0, false);\n+            const auto full_bal = GetBalance(wallet, 0, false);\n             balances_mine.pushKV(\"used\", ValueFromAmount(full_bal.m_mine_trusted + full_bal.m_mine_untrusted_pending - bal.m_mine_trusted - bal.m_mine_untrusted_pending));\n         }\n         balances.pushKV(\"mine\", balances_mine);\n@@ -2462,7 +2465,7 @@ static RPCHelpMan getwalletinfo()\n     UniValue obj(UniValue::VOBJ);\n \n     size_t kpExternalSize = pwallet->KeypoolCountExternalKeys();\n-    const auto bal = pwallet->GetBalance();\n+    const auto bal = GetBalance(*pwallet);\n     int64_t kp_oldest = pwallet->GetOldestKeyPoolTime();\n     obj.pushKV(\"walletname\", pwallet->GetName());\n     obj.pushKV(\"walletversion\", pwallet->GetVersion());\n@@ -3058,7 +3061,7 @@ static RPCHelpMan listunspent()\n         cctl.m_max_depth = nMaxDepth;\n         cctl.m_include_unsafe_inputs = include_unsafe;\n         LOCK(pwallet->cs_wallet);\n-        pwallet->AvailableCoins(vecOutputs, &cctl, nMinimumAmount, nMaximumAmount, nMinimumSumAmount, nMaximumCount);\n+        AvailableCoins(*pwallet, vecOutputs, &cctl, nMinimumAmount, nMaximumAmount, nMinimumSumAmount, nMaximumCount);\n     }\n \n     LOCK(pwallet->cs_wallet);\n@@ -3274,7 +3277,7 @@ void FundTransaction(CWallet& wallet, CMutableTransaction& tx, CAmount& fee_out,\n \n     bilingual_str error;\n \n-    if (!wallet.FundTransaction(tx, fee_out, change_position, error, lockUnspents, setSubtractFeeFromOutputs, coinControl)) {\n+    if (!FundTransaction(wallet, tx, fee_out, change_position, error, lockUnspents, setSubtractFeeFromOutputs, coinControl)) {\n         throw JSONRPCError(RPC_WALLET_ERROR, error.original);\n     }\n }\n@@ -3959,7 +3962,7 @@ RPCHelpMan getaddressinfo()\n     UniValue detail = DescribeWalletAddress(*pwallet, dest);\n     ret.pushKVs(detail);\n \n-    ret.pushKV(\"ischange\", pwallet->IsChange(scriptPubKey));\n+    ret.pushKV(\"ischange\", ScriptIsChange(*pwallet, scriptPubKey));\n \n     ScriptPubKeyMan* spk_man = pwallet->GetScriptPubKeyMan(scriptPubKey);\n     if (spk_man) {"
      },
      {
        "sha": "4a7a26898227d96e646816f124ffd1790c2c828c",
        "filename": "src/wallet/spend.cpp",
        "status": "modified",
        "additions": 99,
        "deletions": 92,
        "changes": 191,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/spend.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/spend.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/spend.cpp?ref=b11a195ef450bd138aa03204a5e74fdd3ddced26",
        "patch": "@@ -21,6 +21,11 @@ using interfaces::FoundBlock;\n \n static constexpr size_t OUTPUT_GROUP_MAX_ENTRIES{100};\n \n+int GetTxSpendSize(const CWallet& wallet, const CWalletTx& wtx, unsigned int out, bool use_max_sig)\n+{\n+    return CalculateMaximumSignedInputSize(wtx.tx->vout[out], &wallet, use_max_sig);\n+}\n+\n std::string COutput::ToString() const\n {\n     return strprintf(\"COutput(%s, %d, %d) [%s]\", tx->GetHash().ToString(), i, nDepth, FormatMoney(tx->tx->vout[i].nValue));\n@@ -64,33 +69,33 @@ TxSize CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *walle\n     return CalculateMaximumSignedTxSize(tx, wallet, txouts, use_max_sig);\n }\n \n-void CWallet::AvailableCoins(std::vector<COutput>& vCoins, const CCoinControl* coinControl, const CAmount& nMinimumAmount, const CAmount& nMaximumAmount, const CAmount& nMinimumSumAmount, const uint64_t nMaximumCount) const\n+void AvailableCoins(const CWallet& wallet, std::vector<COutput>& vCoins, const CCoinControl* coinControl, const CAmount& nMinimumAmount, const CAmount& nMaximumAmount, const CAmount& nMinimumSumAmount, const uint64_t nMaximumCount)\n {\n-    AssertLockHeld(cs_wallet);\n+    AssertLockHeld(wallet.cs_wallet);\n \n     vCoins.clear();\n     CAmount nTotal = 0;\n     // Either the WALLET_FLAG_AVOID_REUSE flag is not set (in which case we always allow), or we default to avoiding, and only in the case where\n     // a coin control object is provided, and has the avoid address reuse flag set to false, do we allow already used addresses\n-    bool allow_used_addresses = !IsWalletFlagSet(WALLET_FLAG_AVOID_REUSE) || (coinControl && !coinControl->m_avoid_address_reuse);\n+    bool allow_used_addresses = !wallet.IsWalletFlagSet(WALLET_FLAG_AVOID_REUSE) || (coinControl && !coinControl->m_avoid_address_reuse);\n     const int min_depth = {coinControl ? coinControl->m_min_depth : DEFAULT_MIN_DEPTH};\n     const int max_depth = {coinControl ? coinControl->m_max_depth : DEFAULT_MAX_DEPTH};\n     const bool only_safe = {coinControl ? !coinControl->m_include_unsafe_inputs : true};\n \n     std::set<uint256> trusted_parents;\n-    for (const auto& entry : mapWallet)\n+    for (const auto& entry : wallet.mapWallet)\n     {\n         const uint256& wtxid = entry.first;\n         const CWalletTx& wtx = entry.second;\n \n-        if (!chain().checkFinalTx(*wtx.tx)) {\n+        if (!wallet.chain().checkFinalTx(*wtx.tx)) {\n             continue;\n         }\n \n-        if (wtx.IsImmatureCoinBase())\n+        if (wallet.IsTxImmatureCoinBase(wtx))\n             continue;\n \n-        int nDepth = wtx.GetDepthInMainChain();\n+        int nDepth = wallet.GetTxDepthInMainChain(wtx);\n         if (nDepth < 0)\n             continue;\n \n@@ -99,7 +104,7 @@ void CWallet::AvailableCoins(std::vector<COutput>& vCoins, const CCoinControl* c\n         if (nDepth == 0 && !wtx.InMempool())\n             continue;\n \n-        bool safeTx = IsTrusted(wtx, trusted_parents);\n+        bool safeTx = CachedTxIsTrusted(wallet, wtx, trusted_parents);\n \n         // We should not consider coins from transactions that are replacing\n         // other transactions.\n@@ -152,28 +157,28 @@ void CWallet::AvailableCoins(std::vector<COutput>& vCoins, const CCoinControl* c\n             if (coinControl && coinControl->HasSelected() && !coinControl->fAllowOtherInputs && !coinControl->IsSelected(COutPoint(entry.first, i)))\n                 continue;\n \n-            if (IsLockedCoin(entry.first, i))\n+            if (wallet.IsLockedCoin(entry.first, i))\n                 continue;\n \n-            if (IsSpent(wtxid, i))\n+            if (wallet.IsSpent(wtxid, i))\n                 continue;\n \n-            isminetype mine = IsMine(wtx.tx->vout[i]);\n+            isminetype mine = wallet.IsMine(wtx.tx->vout[i]);\n \n             if (mine == ISMINE_NO) {\n                 continue;\n             }\n \n-            if (!allow_used_addresses && IsSpentKey(wtxid, i)) {\n+            if (!allow_used_addresses && wallet.IsSpentKey(wtxid, i)) {\n                 continue;\n             }\n \n-            std::unique_ptr<SigningProvider> provider = GetSolvingProvider(wtx.tx->vout[i].scriptPubKey);\n+            std::unique_ptr<SigningProvider> provider = wallet.GetSolvingProvider(wtx.tx->vout[i].scriptPubKey);\n \n             bool solvable = provider ? IsSolvable(*provider, wtx.tx->vout[i].scriptPubKey) : false;\n             bool spendable = ((mine & ISMINE_SPENDABLE) != ISMINE_NO) || (((mine & ISMINE_WATCH_ONLY) != ISMINE_NO) && (coinControl && coinControl->fAllowWatchOnly && solvable));\n \n-            vCoins.push_back(COutput(&wtx, i, nDepth, spendable, solvable, safeTx, (coinControl && coinControl->fAllowWatchOnly)));\n+            vCoins.push_back(COutput(wallet, wtx, i, nDepth, spendable, solvable, safeTx, (coinControl && coinControl->fAllowWatchOnly)));\n \n             // Checks the sum amount of all UTXO's.\n             if (nMinimumSumAmount != MAX_MONEY) {\n@@ -192,13 +197,13 @@ void CWallet::AvailableCoins(std::vector<COutput>& vCoins, const CCoinControl* c\n     }\n }\n \n-CAmount CWallet::GetAvailableBalance(const CCoinControl* coinControl) const\n+CAmount GetAvailableBalance(const CWallet& wallet, const CCoinControl* coinControl)\n {\n-    LOCK(cs_wallet);\n+    LOCK(wallet.cs_wallet);\n \n     CAmount balance = 0;\n     std::vector<COutput> vCoins;\n-    AvailableCoins(vCoins, coinControl);\n+    AvailableCoins(wallet, vCoins, coinControl);\n     for (const COutput& out : vCoins) {\n         if (out.fSpendable) {\n             balance += out.tx->tx->vout[out.i].nValue;\n@@ -207,16 +212,16 @@ CAmount CWallet::GetAvailableBalance(const CCoinControl* coinControl) const\n     return balance;\n }\n \n-const CTxOut& CWallet::FindNonChangeParentOutput(const CTransaction& tx, int output) const\n+const CTxOut& FindNonChangeParentOutput(const CWallet& wallet, const CTransaction& tx, int output)\n {\n-    AssertLockHeld(cs_wallet);\n+    AssertLockHeld(wallet.cs_wallet);\n     const CTransaction* ptx = &tx;\n     int n = output;\n-    while (IsChange(ptx->vout[n]) && ptx->vin.size() > 0) {\n+    while (OutputIsChange(wallet, ptx->vout[n]) && ptx->vin.size() > 0) {\n         const COutPoint& prevout = ptx->vin[0].prevout;\n-        auto it = mapWallet.find(prevout.hash);\n-        if (it == mapWallet.end() || it->second.tx->vout.size() <= prevout.n ||\n-            !IsMine(it->second.tx->vout[prevout.n])) {\n+        auto it = wallet.mapWallet.find(prevout.hash);\n+        if (it == wallet.mapWallet.end() || it->second.tx->vout.size() <= prevout.n ||\n+            !wallet.IsMine(it->second.tx->vout[prevout.n])) {\n             break;\n         }\n         ptx = it->second.tx.get();\n@@ -225,39 +230,39 @@ const CTxOut& CWallet::FindNonChangeParentOutput(const CTransaction& tx, int out\n     return ptx->vout[n];\n }\n \n-std::map<CTxDestination, std::vector<COutput>> CWallet::ListCoins() const\n+std::map<CTxDestination, std::vector<COutput>> ListCoins(const CWallet& wallet)\n {\n-    AssertLockHeld(cs_wallet);\n+    AssertLockHeld(wallet.cs_wallet);\n \n     std::map<CTxDestination, std::vector<COutput>> result;\n     std::vector<COutput> availableCoins;\n \n-    AvailableCoins(availableCoins);\n+    AvailableCoins(wallet, availableCoins);\n \n     for (const COutput& coin : availableCoins) {\n         CTxDestination address;\n-        if ((coin.fSpendable || (IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) && coin.fSolvable)) &&\n-            ExtractDestination(FindNonChangeParentOutput(*coin.tx->tx, coin.i).scriptPubKey, address)) {\n+        if ((coin.fSpendable || (wallet.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) && coin.fSolvable)) &&\n+            ExtractDestination(FindNonChangeParentOutput(wallet, *coin.tx->tx, coin.i).scriptPubKey, address)) {\n             result[address].emplace_back(std::move(coin));\n         }\n     }\n \n     std::vector<COutPoint> lockedCoins;\n-    ListLockedCoins(lockedCoins);\n+    wallet.ListLockedCoins(lockedCoins);\n     // Include watch-only for LegacyScriptPubKeyMan wallets without private keys\n-    const bool include_watch_only = GetLegacyScriptPubKeyMan() && IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS);\n+    const bool include_watch_only = wallet.GetLegacyScriptPubKeyMan() && wallet.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS);\n     const isminetype is_mine_filter = include_watch_only ? ISMINE_WATCH_ONLY : ISMINE_SPENDABLE;\n     for (const COutPoint& output : lockedCoins) {\n-        auto it = mapWallet.find(output.hash);\n-        if (it != mapWallet.end()) {\n-            int depth = it->second.GetDepthInMainChain();\n+        auto it = wallet.mapWallet.find(output.hash);\n+        if (it != wallet.mapWallet.end()) {\n+            int depth = wallet.GetTxDepthInMainChain(it->second);\n             if (depth >= 0 && output.n < it->second.tx->vout.size() &&\n-                IsMine(it->second.tx->vout[output.n]) == is_mine_filter\n+                wallet.IsMine(it->second.tx->vout[output.n]) == is_mine_filter\n             ) {\n                 CTxDestination address;\n-                if (ExtractDestination(FindNonChangeParentOutput(*it->second.tx, output.n).scriptPubKey, address)) {\n+                if (ExtractDestination(FindNonChangeParentOutput(wallet, *it->second.tx, output.n).scriptPubKey, address)) {\n                     result[address].emplace_back(\n-                        &it->second, output.n, depth, true /* spendable */, true /* solvable */, false /* safe */);\n+                        wallet, it->second, output.n, depth, true /* spendable */, true /* solvable */, false /* safe */);\n                 }\n             }\n         }\n@@ -266,7 +271,7 @@ std::map<CTxDestination, std::vector<COutput>> CWallet::ListCoins() const\n     return result;\n }\n \n-std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outputs, const CoinSelectionParams& coin_sel_params, const CoinEligibilityFilter& filter, bool positive_only) const\n+std::vector<OutputGroup> GroupOutputs(const CWallet& wallet, const std::vector<COutput>& outputs, const CoinSelectionParams& coin_sel_params, const CoinEligibilityFilter& filter, bool positive_only)\n {\n     std::vector<OutputGroup> groups_out;\n \n@@ -277,12 +282,12 @@ std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outpu\n             if (!output.fSpendable) continue;\n \n             size_t ancestors, descendants;\n-            chain().getTransactionAncestry(output.tx->GetHash(), ancestors, descendants);\n+            wallet.chain().getTransactionAncestry(output.tx->GetHash(), ancestors, descendants);\n             CInputCoin input_coin = output.GetInputCoin();\n \n             // Make an OutputGroup containing just this output\n             OutputGroup group{coin_sel_params};\n-            group.Insert(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants, positive_only);\n+            group.Insert(input_coin, output.nDepth, CachedTxIsFromMe(wallet, *output.tx, ISMINE_ALL), ancestors, descendants, positive_only);\n \n             // Check the OutputGroup's eligibility. Only add the eligible ones.\n             if (positive_only && group.GetSelectionAmount() <= 0) continue;\n@@ -303,7 +308,7 @@ std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outpu\n         if (!output.fSpendable) continue;\n \n         size_t ancestors, descendants;\n-        chain().getTransactionAncestry(output.tx->GetHash(), ancestors, descendants);\n+        wallet.chain().getTransactionAncestry(output.tx->GetHash(), ancestors, descendants);\n         CInputCoin input_coin = output.GetInputCoin();\n         CScript spk = input_coin.txout.scriptPubKey;\n \n@@ -327,7 +332,7 @@ std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outpu\n         }\n \n         // Add the input_coin to group\n-        group->Insert(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants, positive_only);\n+        group->Insert(input_coin, output.nDepth, CachedTxIsFromMe(wallet, *output.tx, ISMINE_ALL), ancestors, descendants, positive_only);\n     }\n \n     // Now we go through the entire map and pull out the OutputGroups\n@@ -352,8 +357,8 @@ std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outpu\n     return groups_out;\n }\n \n-bool CWallet::AttemptSelection(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<COutput> coins,\n-                                 std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params) const\n+bool AttemptSelection(const CWallet& wallet, const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<COutput> coins,\n+                                 std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params)\n {\n     setCoinsRet.clear();\n     nValueRet = 0;\n@@ -363,7 +368,7 @@ bool CWallet::AttemptSelection(const CAmount& nTargetValue, const CoinEligibilit\n     std::vector<std::tuple<CAmount, std::set<CInputCoin>, CAmount>> results;\n \n     // Note that unlike KnapsackSolver, we do not include the fee for creating a change output as BnB will not create a change output.\n-    std::vector<OutputGroup> positive_groups = GroupOutputs(coins, coin_selection_params, eligibility_filter, true /* positive_only */);\n+    std::vector<OutputGroup> positive_groups = GroupOutputs(wallet, coins, coin_selection_params, eligibility_filter, true /* positive_only */);\n     std::set<CInputCoin> bnb_coins;\n     CAmount bnb_value;\n     if (SelectCoinsBnB(positive_groups, nTargetValue, coin_selection_params.m_cost_of_change, bnb_coins, bnb_value)) {\n@@ -372,7 +377,7 @@ bool CWallet::AttemptSelection(const CAmount& nTargetValue, const CoinEligibilit\n     }\n \n     // The knapsack solver has some legacy behavior where it will spend dust outputs. We retain this behavior, so don't filter for positive only here.\n-    std::vector<OutputGroup> all_groups = GroupOutputs(coins, coin_selection_params, eligibility_filter, false /* positive_only */);\n+    std::vector<OutputGroup> all_groups = GroupOutputs(wallet, coins, coin_selection_params, eligibility_filter, false /* positive_only */);\n     // While nTargetValue includes the transaction fees for non-input things, it does not include the fee for creating a change output.\n     // So we need to include that for KnapsackSolver as well, as we are expecting to create a change output.\n     std::set<CInputCoin> knapsack_coins;\n@@ -397,7 +402,7 @@ bool CWallet::AttemptSelection(const CAmount& nTargetValue, const CoinEligibilit\n     return true;\n }\n \n-bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CCoinControl& coin_control, CoinSelectionParams& coin_selection_params) const\n+bool SelectCoins(const CWallet& wallet, const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CCoinControl& coin_control, CoinSelectionParams& coin_selection_params)\n {\n     std::vector<COutput> vCoins(vAvailableCoins);\n     CAmount value_to_select = nTargetValue;\n@@ -423,16 +428,16 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n     coin_control.ListSelected(vPresetInputs);\n     for (const COutPoint& outpoint : vPresetInputs)\n     {\n-        std::map<uint256, CWalletTx>::const_iterator it = mapWallet.find(outpoint.hash);\n-        if (it != mapWallet.end())\n+        std::map<uint256, CWalletTx>::const_iterator it = wallet.mapWallet.find(outpoint.hash);\n+        if (it != wallet.mapWallet.end())\n         {\n             const CWalletTx& wtx = it->second;\n             // Clearly invalid input, fail\n             if (wtx.tx->vout.size() <= outpoint.n) {\n                 return false;\n             }\n             // Just to calculate the marginal byte size\n-            CInputCoin coin(wtx.tx, outpoint.n, wtx.GetSpendSize(outpoint.n, false));\n+            CInputCoin coin(wtx.tx, outpoint.n, GetTxSpendSize(wallet, wtx, outpoint.n, false));\n             nValueFromPresetInputs += coin.txout.nValue;\n             if (coin.m_input_bytes <= 0) {\n                 return false; // Not solvable, can't estimate size for fee\n@@ -460,7 +465,7 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n \n     unsigned int limit_ancestor_count = 0;\n     unsigned int limit_descendant_count = 0;\n-    chain().getPackageLimits(limit_ancestor_count, limit_descendant_count);\n+    wallet.chain().getPackageLimits(limit_ancestor_count, limit_descendant_count);\n     const size_t max_ancestors = (size_t)std::max<int64_t>(1, limit_ancestor_count);\n     const size_t max_descendants = (size_t)std::max<int64_t>(1, limit_descendant_count);\n     const bool fRejectLongChains = gArgs.GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS);\n@@ -483,40 +488,40 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n \n         // If possible, fund the transaction with confirmed UTXOs only. Prefer at least six\n         // confirmations on outputs received from other wallets and only spend confirmed change.\n-        if (AttemptSelection(value_to_select, CoinEligibilityFilter(1, 6, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params)) return true;\n-        if (AttemptSelection(value_to_select, CoinEligibilityFilter(1, 1, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params)) return true;\n+        if (AttemptSelection(wallet, value_to_select, CoinEligibilityFilter(1, 6, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params)) return true;\n+        if (AttemptSelection(wallet, value_to_select, CoinEligibilityFilter(1, 1, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params)) return true;\n \n         // Fall back to using zero confirmation change (but with as few ancestors in the mempool as\n         // possible) if we cannot fund the transaction otherwise.\n-        if (m_spend_zero_conf_change) {\n-            if (AttemptSelection(value_to_select, CoinEligibilityFilter(0, 1, 2), vCoins, setCoinsRet, nValueRet, coin_selection_params)) return true;\n-            if (AttemptSelection(value_to_select, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)),\n+        if (wallet.m_spend_zero_conf_change) {\n+            if (AttemptSelection(wallet, value_to_select, CoinEligibilityFilter(0, 1, 2), vCoins, setCoinsRet, nValueRet, coin_selection_params)) return true;\n+            if (AttemptSelection(wallet, value_to_select, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)),\n                                    vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n                 return true;\n             }\n-            if (AttemptSelection(value_to_select, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2),\n+            if (AttemptSelection(wallet, value_to_select, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2),\n                                    vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n                 return true;\n             }\n             // If partial groups are allowed, relax the requirement of spending OutputGroups (groups\n             // of UTXOs sent to the same address, which are obviously controlled by a single wallet)\n             // in their entirety.\n-            if (AttemptSelection(value_to_select, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1, true /* include_partial_groups */),\n+            if (AttemptSelection(wallet, value_to_select, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1, true /* include_partial_groups */),\n                                    vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n                 return true;\n             }\n             // Try with unsafe inputs if they are allowed. This may spend unconfirmed outputs\n             // received from other wallets.\n             if (coin_control.m_include_unsafe_inputs\n-                && AttemptSelection(value_to_select,\n+                && AttemptSelection(wallet, value_to_select,\n                     CoinEligibilityFilter(0 /* conf_mine */, 0 /* conf_theirs */, max_ancestors-1, max_descendants-1, true /* include_partial_groups */),\n                     vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n                 return true;\n             }\n             // Try with unlimited ancestors/descendants. The transaction will still need to meet\n             // mempool ancestor/descendant policy to be accepted to mempool and broadcasted, but\n             // OutputGroups use heuristics that may overestimate ancestor/descendant counts.\n-            if (!fRejectLongChains && AttemptSelection(value_to_select,\n+            if (!fRejectLongChains && AttemptSelection(wallet, value_to_select,\n                                       CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max(), std::numeric_limits<uint64_t>::max(), true /* include_partial_groups */),\n                                       vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n                 return true;\n@@ -595,30 +600,31 @@ static uint32_t GetLocktimeForNewTransaction(interfaces::Chain& chain, const uin\n     return locktime;\n }\n \n-bool CWallet::CreateTransactionInternal(\n+static bool CreateTransactionInternal(\n+        CWallet& wallet,\n         const std::vector<CRecipient>& vecSend,\n         CTransactionRef& tx,\n         CAmount& nFeeRet,\n         int& nChangePosInOut,\n         bilingual_str& error,\n         const CCoinControl& coin_control,\n         FeeCalculation& fee_calc_out,\n-        bool sign)\n+        bool sign) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet)\n {\n-    AssertLockHeld(cs_wallet);\n+    AssertLockHeld(wallet.cs_wallet);\n \n     CMutableTransaction txNew; // The resulting transaction that we make\n-    txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n+    txNew.nLockTime = GetLocktimeForNewTransaction(wallet.chain(), wallet.GetLastBlockHash(), wallet.GetLastBlockHeight());\n \n     CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n     coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;\n \n     // Set the long term feerate estimate to the wallet's consolidate feerate\n-    coin_selection_params.m_long_term_feerate = m_consolidate_feerate;\n+    coin_selection_params.m_long_term_feerate = wallet.m_consolidate_feerate;\n \n     CAmount recipients_sum = 0;\n-    const OutputType change_type = TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : m_default_change_type, vecSend);\n-    ReserveDestination reservedest(this, change_type);\n+    const OutputType change_type = wallet.TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : wallet.m_default_change_type, vecSend);\n+    ReserveDestination reservedest(&wallet, change_type);\n     unsigned int outputs_to_subtract_fee_from = 0; // The number of outputs which we are subtracting the fee from\n     for (const auto& recipient : vecSend) {\n         recipients_sum += recipient.nAmount;\n@@ -662,7 +668,7 @@ bool CWallet::CreateTransactionInternal(\n     coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout);\n \n     // Get size of spending the change output\n-    int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n+    int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, &wallet);\n     // If the wallet doesn't know how to sign change output, assume p2sh-p2wpkh\n     // as lower-bound to allow BnB to do it's thing\n     if (change_spend_size == -1) {\n@@ -672,18 +678,18 @@ bool CWallet::CreateTransactionInternal(\n     }\n \n     // Set discard feerate\n-    coin_selection_params.m_discard_feerate = GetDiscardRate(*this);\n+    coin_selection_params.m_discard_feerate = GetDiscardRate(wallet);\n \n     // Get the fee rate to use effective values in coin selection\n     FeeCalculation feeCalc;\n-    coin_selection_params.m_effective_feerate = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n+    coin_selection_params.m_effective_feerate = GetMinimumFeeRate(wallet, coin_control, &feeCalc);\n     // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n     // provided one\n     if (coin_control.m_feerate && coin_selection_params.m_effective_feerate > *coin_control.m_feerate) {\n         error = strprintf(_(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\"), coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), coin_selection_params.m_effective_feerate.ToString(FeeEstimateMode::SAT_VB));\n         return false;\n     }\n-    if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n+    if (feeCalc.reason == FeeReason::FALLBACK && !wallet.m_allow_fallback_fee) {\n         // eventually allow a fallback fee\n         error = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n         return false;\n@@ -710,7 +716,7 @@ bool CWallet::CreateTransactionInternal(\n             coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);\n         }\n \n-        if (IsDust(txout, chain().relayDustFee()))\n+        if (IsDust(txout, wallet.chain().relayDustFee()))\n         {\n             error = _(\"Transaction amount too small\");\n             return false;\n@@ -724,12 +730,12 @@ bool CWallet::CreateTransactionInternal(\n \n     // Get available coins\n     std::vector<COutput> vAvailableCoins;\n-    AvailableCoins(vAvailableCoins, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);\n+    AvailableCoins(wallet, vAvailableCoins, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);\n \n     // Choose coins to use\n     CAmount inputs_sum = 0;\n     std::set<CInputCoin> setCoins;\n-    if (!SelectCoins(vAvailableCoins, /* nTargetValue */ selection_target, setCoins, inputs_sum, coin_control, coin_selection_params))\n+    if (!SelectCoins(wallet, vAvailableCoins, /* nTargetValue */ selection_target, setCoins, inputs_sum, coin_control, coin_selection_params))\n     {\n         error = _(\"Insufficient funds\");\n         return false;\n@@ -767,13 +773,13 @@ bool CWallet::CreateTransactionInternal(\n     // to avoid conflicting with other possible uses of nSequence,\n     // and in the spirit of \"smallest possible change from prior\n     // behavior.\"\n-    const uint32_t nSequence = coin_control.m_signal_bip125_rbf.value_or(m_signal_rbf) ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n+    const uint32_t nSequence = coin_control.m_signal_bip125_rbf.value_or(wallet.m_signal_rbf) ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n     for (const auto& coin : selected_coins) {\n         txNew.vin.push_back(CTxIn(coin.outpoint, CScript(), nSequence));\n     }\n \n     // Calculate the transaction fee\n-    TxSize tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n+    TxSize tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), &wallet, coin_control.fAllowWatchOnly);\n     int nBytes = tx_sizes.vsize;\n     if (nBytes < 0) {\n         error = _(\"Signing transaction failed\");\n@@ -798,7 +804,7 @@ bool CWallet::CreateTransactionInternal(\n         txNew.vout.erase(change_position);\n \n         // Because we have dropped this change, the tx size and required fee will be different, so let's recalculate those\n-        tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n+        tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), &wallet, coin_control.fAllowWatchOnly);\n         nBytes = tx_sizes.vsize;\n         fee_needed = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n     }\n@@ -835,7 +841,7 @@ bool CWallet::CreateTransactionInternal(\n                 }\n \n                 // Error if this output is reduced to be below dust\n-                if (IsDust(txout, chain().relayDustFee())) {\n+                if (IsDust(txout, wallet.chain().relayDustFee())) {\n                     if (txout.nValue < 0) {\n                         error = _(\"The transaction amount is too small to pay the fee\");\n                     } else {\n@@ -854,7 +860,7 @@ bool CWallet::CreateTransactionInternal(\n         return false;\n     }\n \n-    if (sign && !SignTransaction(txNew)) {\n+    if (sign && !wallet.SignTransaction(txNew)) {\n         error = _(\"Signing transaction failed\");\n         return false;\n     }\n@@ -870,14 +876,14 @@ bool CWallet::CreateTransactionInternal(\n         return false;\n     }\n \n-    if (nFeeRet > m_default_max_tx_fee) {\n+    if (nFeeRet > wallet.m_default_max_tx_fee) {\n         error = TransactionErrorString(TransactionError::MAX_FEE_EXCEEDED);\n         return false;\n     }\n \n     if (gArgs.GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS)) {\n         // Lastly, ensure this tx will pass the mempool's chain limits\n-        if (!chain().checkChainLimits(tx)) {\n+        if (!wallet.chain().checkChainLimits(tx)) {\n             error = _(\"Transaction has too long of a mempool chain\");\n             return false;\n         }\n@@ -888,7 +894,7 @@ bool CWallet::CreateTransactionInternal(\n     reservedest.KeepDestination();\n     fee_calc_out = feeCalc;\n \n-    WalletLogPrintf(\"Fee Calculation: Fee:%d Bytes:%u Tgt:%d (requested %d) Reason:\\\"%s\\\" Decay %.5f: Estimation: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out) Fail: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out)\\n\",\n+    wallet.WalletLogPrintf(\"Fee Calculation: Fee:%d Bytes:%u Tgt:%d (requested %d) Reason:\\\"%s\\\" Decay %.5f: Estimation: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out) Fail: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out)\\n\",\n               nFeeRet, nBytes, feeCalc.returnedTarget, feeCalc.desiredTarget, StringForFeeReason(feeCalc.reason), feeCalc.est.decay,\n               feeCalc.est.pass.start, feeCalc.est.pass.end,\n               (feeCalc.est.pass.totalConfirmed + feeCalc.est.pass.inMempool + feeCalc.est.pass.leftMempool) > 0.0 ? 100 * feeCalc.est.pass.withinTarget / (feeCalc.est.pass.totalConfirmed + feeCalc.est.pass.inMempool + feeCalc.est.pass.leftMempool) : 0.0,\n@@ -899,7 +905,8 @@ bool CWallet::CreateTransactionInternal(\n     return true;\n }\n \n-bool CWallet::CreateTransaction(\n+bool CreateTransaction(\n+        CWallet& wallet,\n         const std::vector<CRecipient>& vecSend,\n         CTransactionRef& tx,\n         CAmount& nFeeRet,\n@@ -919,23 +926,23 @@ bool CWallet::CreateTransaction(\n         return false;\n     }\n \n-    LOCK(cs_wallet);\n+    LOCK(wallet.cs_wallet);\n \n     int nChangePosIn = nChangePosInOut;\n     Assert(!tx); // tx is an out-param. TODO change the return type from bool to tx (or nullptr)\n-    bool res = CreateTransactionInternal(vecSend, tx, nFeeRet, nChangePosInOut, error, coin_control, fee_calc_out, sign);\n+    bool res = CreateTransactionInternal(wallet, vecSend, tx, nFeeRet, nChangePosInOut, error, coin_control, fee_calc_out, sign);\n     // try with avoidpartialspends unless it's enabled already\n-    if (res && nFeeRet > 0 /* 0 means non-functional fee rate estimation */ && m_max_aps_fee > -1 && !coin_control.m_avoid_partial_spends) {\n+    if (res && nFeeRet > 0 /* 0 means non-functional fee rate estimation */ && wallet.m_max_aps_fee > -1 && !coin_control.m_avoid_partial_spends) {\n         CCoinControl tmp_cc = coin_control;\n         tmp_cc.m_avoid_partial_spends = true;\n         CAmount nFeeRet2;\n         CTransactionRef tx2;\n         int nChangePosInOut2 = nChangePosIn;\n         bilingual_str error2; // fired and forgotten; if an error occurs, we discard the results\n-        if (CreateTransactionInternal(vecSend, tx2, nFeeRet2, nChangePosInOut2, error2, tmp_cc, fee_calc_out, sign)) {\n+        if (CreateTransactionInternal(wallet, vecSend, tx2, nFeeRet2, nChangePosInOut2, error2, tmp_cc, fee_calc_out, sign)) {\n             // if fee of this alternative one is within the range of the max fee, we use this one\n-            const bool use_aps = nFeeRet2 <= nFeeRet + m_max_aps_fee;\n-            WalletLogPrintf(\"Fee non-grouped = %lld, grouped = %lld, using %s\\n\", nFeeRet, nFeeRet2, use_aps ? \"grouped\" : \"non-grouped\");\n+            const bool use_aps = nFeeRet2 <= nFeeRet + wallet.m_max_aps_fee;\n+            wallet.WalletLogPrintf(\"Fee non-grouped = %lld, grouped = %lld, using %s\\n\", nFeeRet, nFeeRet2, use_aps ? \"grouped\" : \"non-grouped\");\n             if (use_aps) {\n                 tx = tx2;\n                 nFeeRet = nFeeRet2;\n@@ -946,7 +953,7 @@ bool CWallet::CreateTransaction(\n     return res;\n }\n \n-bool CWallet::FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nChangePosInOut, bilingual_str& error, bool lockUnspents, const std::set<int>& setSubtractFeeFromOutputs, CCoinControl coinControl)\n+bool FundTransaction(CWallet& wallet, CMutableTransaction& tx, CAmount& nFeeRet, int& nChangePosInOut, bilingual_str& error, bool lockUnspents, const std::set<int>& setSubtractFeeFromOutputs, CCoinControl coinControl)\n {\n     std::vector<CRecipient> vecSend;\n \n@@ -965,11 +972,11 @@ bool CWallet::FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nC\n \n     // Acquire the locks to prevent races to the new locked unspents between the\n     // CreateTransaction call and LockCoin calls (when lockUnspents is true).\n-    LOCK(cs_wallet);\n+    LOCK(wallet.cs_wallet);\n \n     CTransactionRef tx_new;\n     FeeCalculation fee_calc_out;\n-    if (!CreateTransaction(vecSend, tx_new, nFeeRet, nChangePosInOut, error, coinControl, fee_calc_out, false)) {\n+    if (!CreateTransaction(wallet, vecSend, tx_new, nFeeRet, nChangePosInOut, error, coinControl, fee_calc_out, false)) {\n         return false;\n     }\n \n@@ -990,7 +997,7 @@ bool CWallet::FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nC\n \n         }\n         if (lockUnspents) {\n-            LockCoin(txin.prevout);\n+            wallet.LockCoin(txin.prevout);\n         }\n \n     }"
      },
      {
        "sha": "e39f134dc3636f8cdbf3f70536bf026dff2b40a1",
        "filename": "src/wallet/spend.h",
        "status": "modified",
        "additions": 79,
        "deletions": 4,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/spend.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/spend.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/spend.h?ref=b11a195ef450bd138aa03204a5e74fdd3ddced26",
        "patch": "@@ -9,6 +9,9 @@\n #include <wallet/transaction.h>\n #include <wallet/wallet.h>\n \n+/** Get the marginal bytes if spending the specified output from this transaction */\n+int GetTxSpendSize(const CWallet& wallet, const CWalletTx& wtx, unsigned int out, bool use_max_sig = false);\n+\n class COutput\n {\n public:\n@@ -43,13 +46,13 @@ class COutput\n      */\n     bool fSafe;\n \n-    COutput(const CWalletTx *txIn, int iIn, int nDepthIn, bool fSpendableIn, bool fSolvableIn, bool fSafeIn, bool use_max_sig_in = false)\n+    COutput(const CWallet& wallet, const CWalletTx& wtx, int iIn, int nDepthIn, bool fSpendableIn, bool fSolvableIn, bool fSafeIn, bool use_max_sig_in = false)\n     {\n-        tx = txIn; i = iIn; nDepth = nDepthIn; fSpendable = fSpendableIn; fSolvable = fSolvableIn; fSafe = fSafeIn; nInputBytes = -1; use_max_sig = use_max_sig_in;\n+        tx = &wtx; i = iIn; nDepth = nDepthIn; fSpendable = fSpendableIn; fSolvable = fSolvableIn; fSafe = fSafeIn; nInputBytes = -1; use_max_sig = use_max_sig_in;\n         // If known and signable by the given wallet, compute nInputBytes\n         // Failure will keep this value -1\n-        if (fSpendable && tx) {\n-            nInputBytes = tx->GetSpendSize(i, use_max_sig);\n+        if (fSpendable) {\n+            nInputBytes = GetTxSpendSize(wallet, wtx, i, use_max_sig);\n         }\n     }\n \n@@ -61,4 +64,76 @@ class COutput\n     }\n };\n \n+//Get the marginal bytes of spending the specified output\n+int CalculateMaximumSignedInputSize(const CTxOut& txout, const CWallet* pwallet, bool use_max_sig = false);\n+\n+struct TxSize {\n+    int64_t vsize{-1};\n+    int64_t weight{-1};\n+};\n+\n+/** Calculate the size of the transaction assuming all signatures are max size\n+* Use DummySignatureCreator, which inserts 71 byte signatures everywhere.\n+* NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+* be AllInputsMine). */\n+TxSize CalculateMaximumSignedTxSize(const CTransaction& tx, const CWallet* wallet, const std::vector<CTxOut>& txouts, bool use_max_sig = false);\n+TxSize CalculateMaximumSignedTxSize(const CTransaction& tx, const CWallet* wallet, bool use_max_sig = false) EXCLUSIVE_LOCKS_REQUIRED(wallet->cs_wallet);\n+\n+/**\n+ * populate vCoins with vector of available COutputs.\n+ */\n+void AvailableCoins(const CWallet& wallet, std::vector<COutput>& vCoins, const CCoinControl* coinControl = nullptr, const CAmount& nMinimumAmount = 1, const CAmount& nMaximumAmount = MAX_MONEY, const CAmount& nMinimumSumAmount = MAX_MONEY, const uint64_t nMaximumCount = 0) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet);\n+\n+CAmount GetAvailableBalance(const CWallet& wallet, const CCoinControl* coinControl = nullptr);\n+\n+/**\n+ * Find non-change parent output.\n+ */\n+const CTxOut& FindNonChangeParentOutput(const CWallet& wallet, const CTransaction& tx, int output) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet);\n+\n+/**\n+ * Return list of available coins and locked coins grouped by non-change output address.\n+ */\n+std::map<CTxDestination, std::vector<COutput>> ListCoins(const CWallet& wallet) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet);\n+\n+std::vector<OutputGroup> GroupOutputs(const CWallet& wallet, const std::vector<COutput>& outputs, const CoinSelectionParams& coin_sel_params, const CoinEligibilityFilter& filter, bool positive_only);\n+\n+/**\n+ * Shuffle and select coins until nTargetValue is reached while avoiding\n+ * small change; This method is stochastic for some inputs and upon\n+ * completion the coin set and corresponding actual target value is\n+ * assembled\n+ * param@[in]   coins           Set of UTXOs to consider. These will be categorized into\n+ *                              OutputGroups and filtered using eligibility_filter before\n+ *                              selecting coins.\n+ * param@[out]  setCoinsRet     Populated with the coins selected if successful.\n+ * param@[out]  nValueRet       Used to return the total value of selected coins.\n+ */\n+bool AttemptSelection(const CWallet& wallet, const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<COutput> coins,\n+                        std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params);\n+\n+/**\n+ * Select a set of coins such that nValueRet >= nTargetValue and at least\n+ * all coins from coin_control are selected; never select unconfirmed coins if they are not ours\n+ * param@[out]  setCoinsRet         Populated with inputs including pre-selected inputs from\n+ *                                  coin_control and Coin Selection if successful.\n+ * param@[out]  nValueRet           Total value of selected coins including pre-selected ones\n+ *                                  from coin_control and Coin Selection if successful.\n+ */\n+bool SelectCoins(const CWallet& wallet, const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet,\n+                 const CCoinControl& coin_control, CoinSelectionParams& coin_selection_params) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet);\n+\n+/**\n+ * Create a new transaction paying the recipients with a set of coins\n+ * selected by SelectCoins(); Also create the change output, when needed\n+ * @note passing nChangePosInOut as -1 will result in setting a random position\n+ */\n+bool CreateTransaction(CWallet& wallet, const std::vector<CRecipient>& vecSend, CTransactionRef& tx, CAmount& nFeeRet, int& nChangePosInOut, bilingual_str& error, const CCoinControl& coin_control, FeeCalculation& fee_calc_out, bool sign = true);\n+\n+/**\n+ * Insert additional inputs into the transaction by\n+ * calling CreateTransaction();\n+ */\n+bool FundTransaction(CWallet& wallet, CMutableTransaction& tx, CAmount& nFeeRet, int& nChangePosInOut, bilingual_str& error, bool lockUnspents, const std::set<int>& setSubtractFeeFromOutputs, CCoinControl);\n+\n #endif // BITCOIN_WALLET_SPEND_H"
      },
      {
        "sha": "f901679efc80f2813a8969dbb75c384fc15824ce",
        "filename": "src/wallet/test/coinselector_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/test/coinselector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/test/coinselector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/coinselector_tests.cpp?ref=b11a195ef450bd138aa03204a5e74fdd3ddced26",
        "patch": "@@ -10,6 +10,7 @@\n #include <util/translation.h>\n #include <wallet/coincontrol.h>\n #include <wallet/coinselection.h>\n+#include <wallet/spend.h>\n #include <wallet/test/wallet_test_fixture.h>\n #include <wallet/wallet.h>\n \n@@ -87,7 +88,7 @@ static void add_coin(CWallet& wallet, const CAmount& nValue, int nAge = 6*24, bo\n         wtx->m_amounts[CWalletTx::DEBIT].Set(ISMINE_SPENDABLE, 1);\n         wtx->m_is_cache_empty = false;\n     }\n-    COutput output(wtx, nInput, nAge, true /* spendable */, true /* solvable */, true /* safe */);\n+    COutput output(wallet, *wtx, nInput, nAge, true /* spendable */, true /* solvable */, true /* safe */);\n     vCoins.push_back(output);\n }\n static void add_coin(const CAmount& nValue, int nAge = 6*24, bool fIsFromMe = false, int nInput=0, bool spendable = false)\n@@ -144,7 +145,7 @@ inline std::vector<OutputGroup>& GroupCoins(const std::vector<COutput>& coins)\n inline std::vector<OutputGroup>& KnapsackGroupOutputs(const CoinEligibilityFilter& filter)\n {\n     static std::vector<OutputGroup> static_groups;\n-    static_groups = testWallet.GroupOutputs(vCoins, coin_selection_params, filter, /* positive_only */false);\n+    static_groups = GroupOutputs(testWallet, vCoins, coin_selection_params, filter, /* positive_only */false);\n     return static_groups;\n }\n \n@@ -316,7 +317,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n         coin_control.fAllowOtherInputs = true;\n         coin_control.Select(COutPoint(vCoins.at(0).tx->GetHash(), vCoins.at(0).i));\n         coin_selection_params_bnb.m_effective_feerate = CFeeRate(0);\n-        BOOST_CHECK(wallet->SelectCoins(vCoins, 10 * CENT, setCoinsRet, nValueRet, coin_control, coin_selection_params_bnb));\n+        BOOST_CHECK(SelectCoins(*wallet, vCoins, 10 * CENT, setCoinsRet, nValueRet, coin_control, coin_selection_params_bnb));\n     }\n }\n \n@@ -657,7 +658,7 @@ BOOST_AUTO_TEST_CASE(SelectCoins_test)\n         CoinSet out_set;\n         CAmount out_value = 0;\n         CCoinControl cc;\n-        BOOST_CHECK(testWallet.SelectCoins(vCoins, target, out_set, out_value, cc, cs_params));\n+        BOOST_CHECK(SelectCoins(testWallet, vCoins, target, out_set, out_value, cc, cs_params));\n         BOOST_CHECK_GE(out_value, target);\n     }\n }"
      },
      {
        "sha": "8a97f7779dfcd980ef89cc15e27f4286ee562c44",
        "filename": "src/wallet/test/psbt_wallet_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/test/psbt_wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/test/psbt_wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/psbt_wallet_tests.cpp?ref=b11a195ef450bd138aa03204a5e74fdd3ddced26",
        "patch": "@@ -22,12 +22,12 @@ BOOST_AUTO_TEST_CASE(psbt_updater_test)\n     CDataStream s_prev_tx1(ParseHex(\"0200000000010158e87a21b56daf0c23be8e7070456c336f7cbaa5c8757924f545887bb2abdd7501000000171600145f275f436b09a8cc9a2eb2a2f528485c68a56323feffffff02d8231f1b0100000017a914aed962d6654f9a2b36608eb9d64d2b260db4f1118700c2eb0b0000000017a914b7f5faf40e3d40a5a459b1db3535f2b72fa921e88702483045022100a22edcc6e5bc511af4cc4ae0de0fcd75c7e04d8c1c3a8aa9d820ed4b967384ec02200642963597b9b1bc22c75e9f3e117284a962188bf5e8a74c895089046a20ad770121035509a48eb623e10aace8bfd0212fdb8a8e5af3c94b0b133b95e114cab89e4f7965000000\"), SER_NETWORK, PROTOCOL_VERSION);\n     CTransactionRef prev_tx1;\n     s_prev_tx1 >> prev_tx1;\n-    m_wallet.mapWallet.emplace(std::piecewise_construct, std::forward_as_tuple(prev_tx1->GetHash()), std::forward_as_tuple(&m_wallet, prev_tx1));\n+    m_wallet.mapWallet.emplace(std::piecewise_construct, std::forward_as_tuple(prev_tx1->GetHash()), std::forward_as_tuple(prev_tx1));\n \n     CDataStream s_prev_tx2(ParseHex(\"0200000001aad73931018bd25f84ae400b68848be09db706eac2ac18298babee71ab656f8b0000000048473044022058f6fc7c6a33e1b31548d481c826c015bd30135aad42cd67790dab66d2ad243b02204a1ced2604c6735b6393e5b41691dd78b00f0c5942fb9f751856faa938157dba01feffffff0280f0fa020000000017a9140fb9463421696b82c833af241c78c17ddbde493487d0f20a270100000017a91429ca74f8a08f81999428185c97b5d852e4063f618765000000\"), SER_NETWORK, PROTOCOL_VERSION);\n     CTransactionRef prev_tx2;\n     s_prev_tx2 >> prev_tx2;\n-    m_wallet.mapWallet.emplace(std::piecewise_construct, std::forward_as_tuple(prev_tx2->GetHash()), std::forward_as_tuple(&m_wallet, prev_tx2));\n+    m_wallet.mapWallet.emplace(std::piecewise_construct, std::forward_as_tuple(prev_tx2->GetHash()), std::forward_as_tuple(prev_tx2));\n \n     // Add scripts\n     CScript rs1;"
      },
      {
        "sha": "e779b2450f5327cbbbb26168b5a8b8d1e4243ba9",
        "filename": "src/wallet/test/spend_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/test/spend_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/test/spend_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/spend_tests.cpp?ref=b11a195ef450bd138aa03204a5e74fdd3ddced26",
        "patch": "@@ -5,6 +5,7 @@\n #include <policy/fees.h>\n #include <validation.h>\n #include <wallet/coincontrol.h>\n+#include <wallet/spend.h>\n #include <wallet/test/util.h>\n #include <wallet/test/wallet_test_fixture.h>\n \n@@ -32,7 +33,7 @@ BOOST_FIXTURE_TEST_CASE(SubtractFee, TestChain100Setup)\n         coin_control.m_feerate.emplace(10000);\n         coin_control.fOverrideFeeRate = true;\n         FeeCalculation fee_calc;\n-        BOOST_CHECK(wallet->CreateTransaction({recipient}, tx, fee, change_pos, error, coin_control, fee_calc));\n+        BOOST_CHECK(CreateTransaction(*wallet, {recipient}, tx, fee, change_pos, error, coin_control, fee_calc));\n         BOOST_CHECK_EQUAL(tx->vout.size(), 1);\n         BOOST_CHECK_EQUAL(tx->vout[0].nValue, recipient.nAmount + leftover_input_amount - fee);\n         BOOST_CHECK_GT(fee, 0);"
      },
      {
        "sha": "12a22f458a209ecef7d54cf6e011dd4596a6ca12",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 15,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=b11a195ef450bd138aa03204a5e74fdd3ddced26",
        "patch": "@@ -21,6 +21,8 @@\n #include <validation.h>\n #include <wallet/coincontrol.h>\n #include <wallet/context.h>\n+#include <wallet/receive.h>\n+#include <wallet/spend.h>\n #include <wallet/test/util.h>\n #include <wallet/test/wallet_test_fixture.h>\n \n@@ -103,7 +105,7 @@ BOOST_FIXTURE_TEST_CASE(scan_for_wallet_transactions, TestChain100Setup)\n         BOOST_CHECK(result.last_failed_block.IsNull());\n         BOOST_CHECK(result.last_scanned_block.IsNull());\n         BOOST_CHECK(!result.last_scanned_height);\n-        BOOST_CHECK_EQUAL(wallet.GetBalance().m_mine_immature, 0);\n+        BOOST_CHECK_EQUAL(GetBalance(wallet).m_mine_immature, 0);\n     }\n \n     // Verify ScanForWalletTransactions picks up transactions in both the old\n@@ -122,7 +124,7 @@ BOOST_FIXTURE_TEST_CASE(scan_for_wallet_transactions, TestChain100Setup)\n         BOOST_CHECK(result.last_failed_block.IsNull());\n         BOOST_CHECK_EQUAL(result.last_scanned_block, newTip->GetBlockHash());\n         BOOST_CHECK_EQUAL(*result.last_scanned_height, newTip->nHeight);\n-        BOOST_CHECK_EQUAL(wallet.GetBalance().m_mine_immature, 100 * COIN);\n+        BOOST_CHECK_EQUAL(GetBalance(wallet).m_mine_immature, 100 * COIN);\n     }\n \n     // Prune the older block file.\n@@ -148,7 +150,7 @@ BOOST_FIXTURE_TEST_CASE(scan_for_wallet_transactions, TestChain100Setup)\n         BOOST_CHECK_EQUAL(result.last_failed_block, oldTip->GetBlockHash());\n         BOOST_CHECK_EQUAL(result.last_scanned_block, newTip->GetBlockHash());\n         BOOST_CHECK_EQUAL(*result.last_scanned_height, newTip->nHeight);\n-        BOOST_CHECK_EQUAL(wallet.GetBalance().m_mine_immature, 50 * COIN);\n+        BOOST_CHECK_EQUAL(GetBalance(wallet).m_mine_immature, 50 * COIN);\n     }\n \n     // Prune the remaining block file.\n@@ -173,7 +175,7 @@ BOOST_FIXTURE_TEST_CASE(scan_for_wallet_transactions, TestChain100Setup)\n         BOOST_CHECK_EQUAL(result.last_failed_block, newTip->GetBlockHash());\n         BOOST_CHECK(result.last_scanned_block.IsNull());\n         BOOST_CHECK(!result.last_scanned_height);\n-        BOOST_CHECK_EQUAL(wallet.GetBalance().m_mine_immature, 0);\n+        BOOST_CHECK_EQUAL(GetBalance(wallet).m_mine_immature, 0);\n     }\n }\n \n@@ -319,7 +321,7 @@ BOOST_FIXTURE_TEST_CASE(coin_mark_dirty_immature_credit, TestChain100Setup)\n {\n     CWallet wallet(m_node.chain.get(), \"\", CreateDummyWalletDatabase());\n     auto spk_man = wallet.GetOrCreateLegacyScriptPubKeyMan();\n-    CWalletTx wtx(&wallet, m_coinbase_txns.back());\n+    CWalletTx wtx(m_coinbase_txns.back());\n \n     LOCK2(wallet.cs_wallet, spk_man->cs_KeyStore);\n     wallet.SetLastBlockProcessed(m_node.chainman->ActiveChain().Height(), m_node.chainman->ActiveChain().Tip()->GetBlockHash());\n@@ -329,13 +331,13 @@ BOOST_FIXTURE_TEST_CASE(coin_mark_dirty_immature_credit, TestChain100Setup)\n \n     // Call GetImmatureCredit() once before adding the key to the wallet to\n     // cache the current immature credit amount, which is 0.\n-    BOOST_CHECK_EQUAL(wtx.GetImmatureCredit(), 0);\n+    BOOST_CHECK_EQUAL(CachedTxGetImmatureCredit(wallet, wtx), 0);\n \n     // Invalidate the cached value, add the key, and make sure a new immature\n     // credit amount is calculated.\n     wtx.MarkDirty();\n     BOOST_CHECK(spk_man->AddKeyPubKey(coinbaseKey, coinbaseKey.GetPubKey()));\n-    BOOST_CHECK_EQUAL(wtx.GetImmatureCredit(), 50*COIN);\n+    BOOST_CHECK_EQUAL(CachedTxGetImmatureCredit(wallet, wtx), 50*COIN);\n }\n \n static int64_t AddTx(ChainstateManager& chainman, CWallet& wallet, uint32_t lockTime, int64_t mockTime, int64_t blockTime)\n@@ -506,7 +508,7 @@ class ListCoinsTestingSetup : public TestChain100Setup\n         CCoinControl dummy;\n         FeeCalculation fee_calc_out;\n         {\n-            BOOST_CHECK(wallet->CreateTransaction({recipient}, tx, fee, changePos, error, dummy, fee_calc_out));\n+            BOOST_CHECK(CreateTransaction(*wallet, {recipient}, tx, fee, changePos, error, dummy, fee_calc_out));\n         }\n         wallet->CommitTransaction(tx, {}, {});\n         CMutableTransaction blocktx;\n@@ -528,7 +530,7 @@ class ListCoinsTestingSetup : public TestChain100Setup\n     std::unique_ptr<CWallet> wallet;\n };\n \n-BOOST_FIXTURE_TEST_CASE(ListCoins, ListCoinsTestingSetup)\n+BOOST_FIXTURE_TEST_CASE(ListCoinsTest, ListCoinsTestingSetup)\n {\n     std::string coinbaseAddress = coinbaseKey.GetPubKey().GetID().ToString();\n \n@@ -537,14 +539,14 @@ BOOST_FIXTURE_TEST_CASE(ListCoins, ListCoinsTestingSetup)\n     std::map<CTxDestination, std::vector<COutput>> list;\n     {\n         LOCK(wallet->cs_wallet);\n-        list = wallet->ListCoins();\n+        list = ListCoins(*wallet);\n     }\n     BOOST_CHECK_EQUAL(list.size(), 1U);\n     BOOST_CHECK_EQUAL(std::get<PKHash>(list.begin()->first).ToString(), coinbaseAddress);\n     BOOST_CHECK_EQUAL(list.begin()->second.size(), 1U);\n \n     // Check initial balance from one mature coinbase transaction.\n-    BOOST_CHECK_EQUAL(50 * COIN, wallet->GetAvailableBalance());\n+    BOOST_CHECK_EQUAL(50 * COIN, GetAvailableBalance(*wallet));\n \n     // Add a transaction creating a change address, and confirm ListCoins still\n     // returns the coin associated with the change address underneath the\n@@ -553,7 +555,7 @@ BOOST_FIXTURE_TEST_CASE(ListCoins, ListCoinsTestingSetup)\n     AddTx(CRecipient{GetScriptForRawPubKey({}), 1 * COIN, false /* subtract fee */});\n     {\n         LOCK(wallet->cs_wallet);\n-        list = wallet->ListCoins();\n+        list = ListCoins(*wallet);\n     }\n     BOOST_CHECK_EQUAL(list.size(), 1U);\n     BOOST_CHECK_EQUAL(std::get<PKHash>(list.begin()->first).ToString(), coinbaseAddress);\n@@ -563,7 +565,7 @@ BOOST_FIXTURE_TEST_CASE(ListCoins, ListCoinsTestingSetup)\n     {\n         LOCK(wallet->cs_wallet);\n         std::vector<COutput> available;\n-        wallet->AvailableCoins(available);\n+        AvailableCoins(*wallet, available);\n         BOOST_CHECK_EQUAL(available.size(), 2U);\n     }\n     for (const auto& group : list) {\n@@ -575,14 +577,14 @@ BOOST_FIXTURE_TEST_CASE(ListCoins, ListCoinsTestingSetup)\n     {\n         LOCK(wallet->cs_wallet);\n         std::vector<COutput> available;\n-        wallet->AvailableCoins(available);\n+        AvailableCoins(*wallet, available);\n         BOOST_CHECK_EQUAL(available.size(), 0U);\n     }\n     // Confirm ListCoins still returns same result as before, despite coins\n     // being locked.\n     {\n         LOCK(wallet->cs_wallet);\n-        list = wallet->ListCoins();\n+        list = ListCoins(*wallet);\n     }\n     BOOST_CHECK_EQUAL(list.size(), 1U);\n     BOOST_CHECK_EQUAL(std::get<PKHash>(list.begin()->first).ToString(), coinbaseAddress);"
      },
      {
        "sha": "094221adf2f68db554a6c267593e158bb68c3b48",
        "filename": "src/wallet/transaction.h",
        "status": "modified",
        "additions": 3,
        "deletions": 70,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/transaction.h?ref=b11a195ef450bd138aa03204a5e74fdd3ddced26",
        "patch": "@@ -17,12 +17,8 @@\n #include <list>\n #include <vector>\n \n-struct COutputEntry;\n-\n typedef std::map<std::string, std::string> mapValue_t;\n \n-//Get the marginal bytes of spending the specified output\n-int CalculateMaximumSignedInputSize(const CTxOut& txout, const CWallet* pwallet, bool use_max_sig = false);\n \n static inline void ReadOrderPos(int64_t& nOrderPos, mapValue_t& mapValue)\n {\n@@ -34,6 +30,7 @@ static inline void ReadOrderPos(int64_t& nOrderPos, mapValue_t& mapValue)\n     nOrderPos = atoi64(mapValue[\"n\"]);\n }\n \n+\n static inline void WriteOrderPos(const int64_t& nOrderPos, mapValue_t& mapValue)\n {\n     if (nOrderPos == -1)\n@@ -68,8 +65,6 @@ class CMerkleTx\n class CWalletTx\n {\n private:\n-    const CWallet* const pwallet;\n-\n     /** Constant used in hashBlock to indicate tx has been abandoned, only used at\n      * serialization/deserialization to avoid ambiguity with conflicted.\n      */\n@@ -126,7 +121,6 @@ class CWalletTx\n \n     // memory only\n     enum AmountType { DEBIT, CREDIT, IMMATURE_CREDIT, AVAILABLE_CREDIT, AMOUNTTYPE_ENUM_ELEMENTS };\n-    CAmount GetCachableAmount(AmountType type, const isminefilter& filter, bool recalculate = false) const;\n     mutable CachableAmount m_amounts[AMOUNTTYPE_ENUM_ELEMENTS];\n     /**\n      * This flag is true if all m_amounts caches are empty. This is particularly\n@@ -139,9 +133,8 @@ class CWalletTx\n     mutable bool fInMempool;\n     mutable CAmount nChangeCached;\n \n-    CWalletTx(const CWallet* wallet, CTransactionRef arg)\n-        : pwallet(wallet),\n-          tx(std::move(arg))\n+    CWalletTx(CTransactionRef arg)\n+        : tx(std::move(arg))\n     {\n         Init();\n     }\n@@ -264,72 +257,13 @@ class CWalletTx\n         m_is_cache_empty = true;\n     }\n \n-    //! filter decides which addresses will count towards the debit\n-    CAmount GetDebit(const isminefilter& filter) const;\n-    CAmount GetCredit(const isminefilter& filter) const;\n-    CAmount GetImmatureCredit(bool fUseCache = true) const;\n-    // TODO: Remove \"NO_THREAD_SAFETY_ANALYSIS\" and replace it with the correct\n-    // annotation \"EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\". The\n-    // annotation \"NO_THREAD_SAFETY_ANALYSIS\" was temporarily added to avoid\n-    // having to resolve the issue of member access into incomplete type CWallet.\n-    CAmount GetAvailableCredit(bool fUseCache = true, const isminefilter& filter = ISMINE_SPENDABLE) const NO_THREAD_SAFETY_ANALYSIS;\n-    CAmount GetImmatureWatchOnlyCredit(const bool fUseCache = true) const;\n-    CAmount GetChange() const;\n-\n-    /** Get the marginal bytes if spending the specified output from this transaction */\n-    int GetSpendSize(unsigned int out, bool use_max_sig = false) const\n-    {\n-        return CalculateMaximumSignedInputSize(tx->vout[out], pwallet, use_max_sig);\n-    }\n-\n-    void GetAmounts(std::list<COutputEntry>& listReceived,\n-                    std::list<COutputEntry>& listSent, CAmount& nFee, const isminefilter& filter) const;\n-\n-    bool IsFromMe(const isminefilter& filter) const\n-    {\n-        return (GetDebit(filter) > 0);\n-    }\n-\n     /** True if only scriptSigs are different */\n     bool IsEquivalentTo(const CWalletTx& tx) const;\n \n     bool InMempool() const;\n-    bool IsTrusted() const;\n \n     int64_t GetTxTime() const;\n \n-    /** Pass this transaction to node for mempool insertion and relay to peers if flag set to true */\n-    bool SubmitMemoryPoolAndRelay(std::string& err_string, bool relay);\n-\n-    // TODO: Remove \"NO_THREAD_SAFETY_ANALYSIS\" and replace it with the correct\n-    // annotation \"EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\". The annotation\n-    // \"NO_THREAD_SAFETY_ANALYSIS\" was temporarily added to avoid having to\n-    // resolve the issue of member access into incomplete type CWallet. Note\n-    // that we still have the runtime check \"AssertLockHeld(pwallet->cs_wallet)\"\n-    // in place.\n-    std::set<uint256> GetConflicts() const NO_THREAD_SAFETY_ANALYSIS;\n-\n-    /**\n-     * Return depth of transaction in blockchain:\n-     * <0  : conflicts with a transaction this deep in the blockchain\n-     *  0  : in memory pool, waiting to be included in a block\n-     * >=1 : this many blocks deep in the main chain\n-     */\n-    // TODO: Remove \"NO_THREAD_SAFETY_ANALYSIS\" and replace it with the correct\n-    // annotation \"EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\". The annotation\n-    // \"NO_THREAD_SAFETY_ANALYSIS\" was temporarily added to avoid having to\n-    // resolve the issue of member access into incomplete type CWallet. Note\n-    // that we still have the runtime check \"AssertLockHeld(pwallet->cs_wallet)\"\n-    // in place.\n-    int GetDepthInMainChain() const NO_THREAD_SAFETY_ANALYSIS;\n-    bool IsInMainChain() const { return GetDepthInMainChain() > 0; }\n-\n-    /**\n-     * @return number of blocks to maturity for this transaction:\n-     *  0 : is not a coinbase transaction, or is a mature coinbase transaction\n-     * >0 : is a coinbase transaction which matures in this many blocks\n-     */\n-    int GetBlocksToMaturity() const;\n     bool isAbandoned() const { return m_confirm.status == CWalletTx::ABANDONED; }\n     void setAbandoned()\n     {\n@@ -346,7 +280,6 @@ class CWalletTx\n     void setConfirmed() { m_confirm.status = CWalletTx::CONFIRMED; }\n     const uint256& GetHash() const { return tx->GetHash(); }\n     bool IsCoinBase() const { return tx->IsCoinBase(); }\n-    bool IsImmatureCoinBase() const;\n \n     // Disable copying of CWalletTx objects to prevent bugs where instances get\n     // copied in and out of the mapWallet map, and fields are updated in the"
      },
      {
        "sha": "f3af9885a2eff2775ec3abf0e78bc3952da6fa05",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 34,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=b11a195ef450bd138aa03204a5e74fdd3ddced26",
        "patch": "@@ -581,7 +581,7 @@ bool CWallet::IsSpent(const uint256& hash, unsigned int n) const\n         const uint256& wtxid = it->second;\n         std::map<uint256, CWalletTx>::const_iterator mit = mapWallet.find(wtxid);\n         if (mit != mapWallet.end()) {\n-            int depth = mit->second.GetDepthInMainChain();\n+            int depth = GetTxDepthInMainChain(mit->second);\n             if (depth > 0  || (depth == 0 && !mit->second.isAbandoned()))\n                 return true; // Spent\n         }\n@@ -900,7 +900,7 @@ CWalletTx* CWallet::AddToWallet(CTransactionRef tx, const CWalletTx::Confirmatio\n     }\n \n     // Inserts only if not already there, returns tx inserted or tx found\n-    auto ret = mapWallet.emplace(std::piecewise_construct, std::forward_as_tuple(hash), std::forward_as_tuple(this, tx));\n+    auto ret = mapWallet.emplace(std::piecewise_construct, std::forward_as_tuple(hash), std::forward_as_tuple(tx));\n     CWalletTx& wtx = (*ret.first).second;\n     bool fInsertedNew = ret.second;\n     bool fUpdated = update_wtx && update_wtx(wtx, fInsertedNew);\n@@ -984,7 +984,7 @@ CWalletTx* CWallet::AddToWallet(CTransactionRef tx, const CWalletTx::Confirmatio\n \n bool CWallet::LoadToWallet(const uint256& hash, const UpdateWalletTxFn& fill_wtx)\n {\n-    const auto& ins = mapWallet.emplace(std::piecewise_construct, std::forward_as_tuple(hash), std::forward_as_tuple(this, nullptr));\n+    const auto& ins = mapWallet.emplace(std::piecewise_construct, std::forward_as_tuple(hash), std::forward_as_tuple(nullptr));\n     CWalletTx& wtx = ins.first->second;\n     if (!fill_wtx(wtx, ins.second)) {\n         return false;\n@@ -1074,7 +1074,7 @@ bool CWallet::TransactionCanBeAbandoned(const uint256& hashTx) const\n {\n     LOCK(cs_wallet);\n     const CWalletTx* wtx = GetWalletTx(hashTx);\n-    return wtx && !wtx->isAbandoned() && wtx->GetDepthInMainChain() == 0 && !wtx->InMempool();\n+    return wtx && !wtx->isAbandoned() && GetTxDepthInMainChain(*wtx) == 0 && !wtx->InMempool();\n }\n \n void CWallet::MarkInputsDirty(const CTransactionRef& tx)\n@@ -1100,7 +1100,7 @@ bool CWallet::AbandonTransaction(const uint256& hashTx)\n     auto it = mapWallet.find(hashTx);\n     assert(it != mapWallet.end());\n     const CWalletTx& origtx = it->second;\n-    if (origtx.GetDepthInMainChain() != 0 || origtx.InMempool()) {\n+    if (GetTxDepthInMainChain(origtx) != 0 || origtx.InMempool()) {\n         return false;\n     }\n \n@@ -1113,7 +1113,7 @@ bool CWallet::AbandonTransaction(const uint256& hashTx)\n         auto it = mapWallet.find(now);\n         assert(it != mapWallet.end());\n         CWalletTx& wtx = it->second;\n-        int currentconfirm = wtx.GetDepthInMainChain();\n+        int currentconfirm = GetTxDepthInMainChain(wtx);\n         // If the orig tx was not in block, none of its spends can be\n         assert(currentconfirm <= 0);\n         // if (currentconfirm < 0) {Tx and spends are already conflicted, no need to abandon}\n@@ -1168,7 +1168,7 @@ void CWallet::MarkConflicted(const uint256& hashBlock, int conflicting_height, c\n         auto it = mapWallet.find(now);\n         assert(it != mapWallet.end());\n         CWalletTx& wtx = it->second;\n-        int currentconfirm = wtx.GetDepthInMainChain();\n+        int currentconfirm = GetTxDepthInMainChain(wtx);\n         if (conflictconfirms < currentconfirm) {\n             // Block is 'more conflicted' than current confirm; update.\n             // Mark transaction as conflicted with this block.\n@@ -1698,7 +1698,7 @@ void CWallet::ReacceptWalletTransactions()\n         CWalletTx& wtx = item.second;\n         assert(wtx.GetHash() == wtxid);\n \n-        int nDepth = wtx.GetDepthInMainChain();\n+        int nDepth = GetTxDepthInMainChain(wtx);\n \n         if (!wtx.IsCoinBase() && (nDepth == 0 && !wtx.isAbandoned())) {\n             mapSorted.insert(std::make_pair(wtx.nOrderPos, &wtx));\n@@ -1709,24 +1709,24 @@ void CWallet::ReacceptWalletTransactions()\n     for (const std::pair<const int64_t, CWalletTx*>& item : mapSorted) {\n         CWalletTx& wtx = *(item.second);\n         std::string unused_err_string;\n-        wtx.SubmitMemoryPoolAndRelay(unused_err_string, false);\n+        SubmitTxMemoryPoolAndRelay(wtx, unused_err_string, false);\n     }\n }\n \n-bool CWalletTx::SubmitMemoryPoolAndRelay(std::string& err_string, bool relay)\n+bool CWallet::SubmitTxMemoryPoolAndRelay(const CWalletTx& wtx, std::string& err_string, bool relay) const\n {\n     // Can't relay if wallet is not broadcasting\n-    if (!pwallet->GetBroadcastTransactions()) return false;\n+    if (!GetBroadcastTransactions()) return false;\n     // Don't relay abandoned transactions\n-    if (isAbandoned()) return false;\n+    if (wtx.isAbandoned()) return false;\n     // Don't try to submit coinbase transactions. These would fail anyway but would\n     // cause log spam.\n-    if (IsCoinBase()) return false;\n+    if (wtx.IsCoinBase()) return false;\n     // Don't try to submit conflicted or confirmed transactions.\n-    if (GetDepthInMainChain() != 0) return false;\n+    if (GetTxDepthInMainChain(wtx) != 0) return false;\n \n     // Submit transaction to mempool for relay\n-    pwallet->WalletLogPrintf(\"Submitting wtx %s to mempool for relay\\n\", GetHash().ToString());\n+    WalletLogPrintf(\"Submitting wtx %s to mempool for relay\\n\", wtx.GetHash().ToString());\n     // We must set fInMempool here - while it will be re-set to true by the\n     // entered-mempool callback, if we did not there would be a race where a\n     // user could call sendmoney in a loop and hit spurious out of funds errors\n@@ -1736,18 +1736,17 @@ bool CWalletTx::SubmitMemoryPoolAndRelay(std::string& err_string, bool relay)\n     // Irrespective of the failure reason, un-marking fInMempool\n     // out-of-order is incorrect - it should be unmarked when\n     // TransactionRemovedFromMempool fires.\n-    bool ret = pwallet->chain().broadcastTransaction(tx, pwallet->m_default_max_tx_fee, relay, err_string);\n-    fInMempool |= ret;\n+    bool ret = chain().broadcastTransaction(wtx.tx, m_default_max_tx_fee, relay, err_string);\n+    wtx.fInMempool |= ret;\n     return ret;\n }\n \n-std::set<uint256> CWalletTx::GetConflicts() const\n+std::set<uint256> CWallet::GetTxConflicts(const CWalletTx& wtx) const\n {\n     std::set<uint256> result;\n-    if (pwallet != nullptr)\n     {\n-        uint256 myHash = GetHash();\n-        result = pwallet->GetConflicts(myHash);\n+        uint256 myHash = wtx.GetHash();\n+        result = GetConflicts(myHash);\n         result.erase(myHash);\n     }\n     return result;\n@@ -1785,11 +1784,11 @@ void CWallet::ResendWalletTransactions()\n         for (std::pair<const uint256, CWalletTx>& item : mapWallet) {\n             CWalletTx& wtx = item.second;\n             // Attempt to rebroadcast all txes more than 5 minutes older than\n-            // the last block. SubmitMemoryPoolAndRelay() will not rebroadcast\n+            // the last block. SubmitTxMemoryPoolAndRelay() will not rebroadcast\n             // any confirmed or conflicting txs.\n             if (wtx.nTimeReceived > m_best_block_time - 5 * 60) continue;\n             std::string unused_err_string;\n-            if (wtx.SubmitMemoryPoolAndRelay(unused_err_string, true)) ++submitted_tx_count;\n+            if (SubmitTxMemoryPoolAndRelay(wtx, unused_err_string, true)) ++submitted_tx_count;\n         }\n     } // cs_wallet\n \n@@ -1977,7 +1976,7 @@ void CWallet::CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::ve\n     }\n \n     std::string err_string;\n-    if (!wtx.SubmitMemoryPoolAndRelay(err_string, true)) {\n+    if (!SubmitTxMemoryPoolAndRelay(wtx, err_string, true)) {\n         WalletLogPrintf(\"CommitTransaction(): Transaction cannot be broadcast immediately, %s\\n\", err_string);\n         // TODO: if we expect the failure to be long term or permanent, instead delete wtx from the wallet and return failure.\n     }\n@@ -2911,28 +2910,27 @@ CKeyPool::CKeyPool(const CPubKey& vchPubKeyIn, bool internalIn)\n     m_pre_split = false;\n }\n \n-int CWalletTx::GetDepthInMainChain() const\n+int CWallet::GetTxDepthInMainChain(const CWalletTx& wtx) const\n {\n-    assert(pwallet != nullptr);\n-    AssertLockHeld(pwallet->cs_wallet);\n-    if (isUnconfirmed() || isAbandoned()) return 0;\n+    AssertLockHeld(cs_wallet);\n+    if (wtx.isUnconfirmed() || wtx.isAbandoned()) return 0;\n \n-    return (pwallet->GetLastBlockHeight() - m_confirm.block_height + 1) * (isConflicted() ? -1 : 1);\n+    return (GetLastBlockHeight() - wtx.m_confirm.block_height + 1) * (wtx.isConflicted() ? -1 : 1);\n }\n \n-int CWalletTx::GetBlocksToMaturity() const\n+int CWallet::GetTxBlocksToMaturity(const CWalletTx& wtx) const\n {\n-    if (!IsCoinBase())\n+    if (!wtx.IsCoinBase())\n         return 0;\n-    int chain_depth = GetDepthInMainChain();\n+    int chain_depth = GetTxDepthInMainChain(wtx);\n     assert(chain_depth >= 0); // coinbase tx should not be conflicted\n     return std::max(0, (COINBASE_MATURITY+1) - chain_depth);\n }\n \n-bool CWalletTx::IsImmatureCoinBase() const\n+bool CWallet::IsTxImmatureCoinBase(const CWalletTx& wtx) const\n {\n     // note GetBlocksToMaturity is 0 for non-coinbase tx\n-    return GetBlocksToMaturity() > 0;\n+    return GetTxBlocksToMaturity(wtx) > 0;\n }\n \n bool CWallet::IsCrypted() const"
      },
      {
        "sha": "fbeec2aa30c8b4d498d7d378b3cb9f25dea2b25a",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 29,
        "deletions": 87,
        "changes": 116,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=b11a195ef450bd138aa03204a5e74fdd3ddced26",
        "patch": "@@ -21,9 +21,7 @@\n #include <validationinterface.h>\n #include <wallet/coinselection.h>\n #include <wallet/crypter.h>\n-#include <wallet/receive.h>\n #include <wallet/scriptpubkeyman.h>\n-#include <wallet/spend.h>\n #include <wallet/transaction.h>\n #include <wallet/walletdb.h>\n #include <wallet/walletutil.h>\n@@ -331,8 +329,6 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     // ScriptPubKeyMan::GetID. In many cases it will be the hash of an internal structure\n     std::map<uint256, std::unique_ptr<ScriptPubKeyMan>> m_spk_managers;\n \n-    bool CreateTransactionInternal(const std::vector<CRecipient>& vecSend, CTransactionRef& tx, CAmount& nFeeRet, int& nChangePosInOut, bilingual_str& error, const CCoinControl& coin_control, FeeCalculation& fee_calc_out, bool sign) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-\n     /**\n      * Catch wallet up to current chain, scanning new blocks, updating the best\n      * block locator and m_last_block_processed, and registering for\n@@ -353,17 +349,6 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n         return *m_database;\n     }\n \n-    /**\n-     * Select a set of coins such that nValueRet >= nTargetValue and at least\n-     * all coins from coin_control are selected; never select unconfirmed coins if they are not ours\n-     * param@[out]  setCoinsRet         Populated with inputs including pre-selected inputs from\n-     *                                  coin_control and Coin Selection if successful.\n-     * param@[out]  nValueRet           Total value of selected coins including pre-selected ones\n-     *                                  from coin_control and Coin Selection if successful.\n-     */\n-    bool SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet,\n-                    const CCoinControl& coin_control, CoinSelectionParams& coin_selection_params) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-\n     /** Get a name for this wallet for logging/debugging purposes.\n      */\n     const std::string& GetName() const { return m_name; }\n@@ -419,48 +404,47 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     interfaces::Chain& chain() const { assert(m_chain); return *m_chain; }\n \n     const CWalletTx* GetWalletTx(const uint256& hash) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    bool IsTrusted(const CWalletTx& wtx, std::set<uint256>& trusted_parents) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-\n-    //! check whether we support the named feature\n-    bool CanSupportFeature(enum WalletFeature wf) const override EXCLUSIVE_LOCKS_REQUIRED(cs_wallet) { AssertLockHeld(cs_wallet); return IsFeatureSupported(nWalletVersion, wf); }\n \n-    /**\n-     * populate vCoins with vector of available COutputs.\n-     */\n-    void AvailableCoins(std::vector<COutput>& vCoins, const CCoinControl* coinControl = nullptr, const CAmount& nMinimumAmount = 1, const CAmount& nMaximumAmount = MAX_MONEY, const CAmount& nMinimumSumAmount = MAX_MONEY, const uint64_t nMaximumCount = 0) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    // TODO: Remove \"NO_THREAD_SAFETY_ANALYSIS\" and replace it with the correct\n+    // annotation \"EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\". The annotation\n+    // \"NO_THREAD_SAFETY_ANALYSIS\" was temporarily added to avoid having to\n+    // resolve the issue of member access into incomplete type CWallet. Note\n+    // that we still have the runtime check \"AssertLockHeld(pwallet->cs_wallet)\"\n+    // in place.\n+    std::set<uint256> GetTxConflicts(const CWalletTx& wtx) const NO_THREAD_SAFETY_ANALYSIS;\n \n     /**\n-     * Return list of available coins and locked coins grouped by non-change output address.\n+     * Return depth of transaction in blockchain:\n+     * <0  : conflicts with a transaction this deep in the blockchain\n+     *  0  : in memory pool, waiting to be included in a block\n+     * >=1 : this many blocks deep in the main chain\n      */\n-    std::map<CTxDestination, std::vector<COutput>> ListCoins() const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    // TODO: Remove \"NO_THREAD_SAFETY_ANALYSIS\" and replace it with the correct\n+    // annotation \"EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\". The annotation\n+    // \"NO_THREAD_SAFETY_ANALYSIS\" was temporarily added to avoid having to\n+    // resolve the issue of member access into incomplete type CWallet. Note\n+    // that we still have the runtime check \"AssertLockHeld(pwallet->cs_wallet)\"\n+    // in place.\n+    int GetTxDepthInMainChain(const CWalletTx& wtx) const NO_THREAD_SAFETY_ANALYSIS;\n+    bool IsTxInMainChain(const CWalletTx& wtx) const { return GetTxDepthInMainChain(wtx) > 0; }\n \n     /**\n-     * Find non-change parent output.\n+     * @return number of blocks to maturity for this transaction:\n+     *  0 : is not a coinbase transaction, or is a mature coinbase transaction\n+     * >0 : is a coinbase transaction which matures in this many blocks\n      */\n-    const CTxOut& FindNonChangeParentOutput(const CTransaction& tx, int output) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    int GetTxBlocksToMaturity(const CWalletTx& wtx) const;\n+    bool IsTxImmatureCoinBase(const CWalletTx& wtx) const;\n \n-    /**\n-     * Shuffle and select coins until nTargetValue is reached while avoiding\n-     * small change; This method is stochastic for some inputs and upon\n-     * completion the coin set and corresponding actual target value is\n-     * assembled\n-     * param@[in]   coins           Set of UTXOs to consider. These will be categorized into\n-     *                              OutputGroups and filtered using eligibility_filter before\n-     *                              selecting coins.\n-     * param@[out]  setCoinsRet     Populated with the coins selected if successful.\n-     * param@[out]  nValueRet       Used to return the total value of selected coins.\n-     */\n-    bool AttemptSelection(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<COutput> coins,\n-        std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params) const;\n+    //! check whether we support the named feature\n+    bool CanSupportFeature(enum WalletFeature wf) const override EXCLUSIVE_LOCKS_REQUIRED(cs_wallet) { AssertLockHeld(cs_wallet); return IsFeatureSupported(nWalletVersion, wf); }\n \n     bool IsSpent(const uint256& hash, unsigned int n) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n     // Whether this or any known UTXO with the same single key has been spent.\n     bool IsSpentKey(const uint256& hash, unsigned int n) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     void SetSpentKeyState(WalletBatch& batch, const uint256& hash, unsigned int n, bool used, std::set<CTxDestination>& tx_destinations) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n-    std::vector<OutputGroup> GroupOutputs(const std::vector<COutput>& outputs, const CoinSelectionParams& coin_sel_params, const CoinEligibilityFilter& filter, bool positive_only) const;\n-\n     /** Display address on an external signer. Returns false if external signer support is not compiled */\n     bool DisplayAddress(const CTxDestination& dest) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n@@ -546,24 +530,9 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     void transactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t mempool_sequence) override;\n     void ReacceptWalletTransactions() EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     void ResendWalletTransactions();\n-    struct Balance {\n-        CAmount m_mine_trusted{0};           //!< Trusted, at depth=GetBalance.min_depth or more\n-        CAmount m_mine_untrusted_pending{0}; //!< Untrusted, but in mempool (pending)\n-        CAmount m_mine_immature{0};          //!< Immature coinbases in the main chain\n-        CAmount m_watchonly_trusted{0};\n-        CAmount m_watchonly_untrusted_pending{0};\n-        CAmount m_watchonly_immature{0};\n-    };\n-    Balance GetBalance(int min_depth = 0, bool avoid_reuse = true) const;\n-    CAmount GetAvailableBalance(const CCoinControl* coinControl = nullptr) const;\n \n     OutputType TransactionChangeType(const std::optional<OutputType>& change_type, const std::vector<CRecipient>& vecSend) const;\n \n-    /**\n-     * Insert additional inputs into the transaction by\n-     * calling CreateTransaction();\n-     */\n-    bool FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nChangePosInOut, bilingual_str& error, bool lockUnspents, const std::set<int>& setSubtractFeeFromOutputs, CCoinControl);\n     /** Fetch the inputs and sign with SIGHASH_ALL. */\n     bool SignTransaction(CMutableTransaction& tx) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     /** Sign the tx given the input coins and sighash. */\n@@ -590,12 +559,6 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n                   bool bip32derivs = true,\n                   size_t* n_signed = nullptr) const;\n \n-    /**\n-     * Create a new transaction paying the recipients with a set of coins\n-     * selected by SelectCoins(); Also create the change output, when needed\n-     * @note passing nChangePosInOut as -1 will result in setting a random position\n-     */\n-    bool CreateTransaction(const std::vector<CRecipient>& vecSend, CTransactionRef& tx, CAmount& nFeeRet, int& nChangePosInOut, bilingual_str& error, const CCoinControl& coin_control, FeeCalculation& fee_calc_out, bool sign = true);\n     /**\n      * Submit the transaction to the node's mempool and then relay to peers.\n      * Should be called after CreateTransaction unless you want to abort\n@@ -607,6 +570,9 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n      */\n     void CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::vector<std::pair<std::string, std::string>> orderForm);\n \n+    /** Pass this transaction to node for mempool insertion and relay to peers if flag set to true */\n+    bool SubmitTxMemoryPoolAndRelay(const CWalletTx& wtx, std::string& err_string, bool relay) const;\n+\n     bool DummySignTx(CMutableTransaction &txNew, const std::set<CTxOut> &txouts, bool use_max_sig = false) const\n     {\n         std::vector<CTxOut> v_txouts(txouts.size());\n@@ -664,9 +630,6 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n \n     int64_t GetOldestKeyPoolTime() const;\n \n-    std::set<std::set<CTxDestination>> GetAddressGroupings() const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    std::map<CTxDestination, CAmount> GetAddressBalances() const;\n-\n     std::set<CTxDestination> GetLabelAddresses(const std::string& label) const;\n \n     /**\n@@ -680,25 +643,16 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n \n     isminetype IsMine(const CTxDestination& dest) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     isminetype IsMine(const CScript& script) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    isminetype IsMine(const CTxIn& txin) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     /**\n      * Returns amount of debit if the input matches the\n      * filter, otherwise returns 0\n      */\n     CAmount GetDebit(const CTxIn& txin, const isminefilter& filter) const;\n     isminetype IsMine(const CTxOut& txout) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    CAmount GetCredit(const CTxOut& txout, const isminefilter& filter) const;\n-    bool IsChange(const CTxOut& txout) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    bool IsChange(const CScript& script) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    CAmount GetChange(const CTxOut& txout) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     bool IsMine(const CTransaction& tx) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     /** should probably be renamed to IsRelevantToMe */\n     bool IsFromMe(const CTransaction& tx) const;\n     CAmount GetDebit(const CTransaction& tx, const isminefilter& filter) const;\n-    /** Returns whether all of the inputs match the filter */\n-    bool IsAllFromMe(const CTransaction& tx, const isminefilter& filter) const;\n-    CAmount GetCredit(const CTransaction& tx, const isminefilter& filter) const;\n-    CAmount GetChange(const CTransaction& tx) const;\n     void chainStateFlushed(const CBlockLocator& loc) override;\n \n     DBErrors LoadWallet();\n@@ -965,18 +919,6 @@ class WalletRescanReserver\n     }\n };\n \n-struct TxSize {\n-    int64_t vsize{-1};\n-    int64_t weight{-1};\n-};\n-\n-/** Calculate the size of the transaction assuming all signatures are max size\n-* Use DummySignatureCreator, which inserts 71 byte signatures everywhere.\n-* NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n-* be IsAllFromMe). */\n-TxSize CalculateMaximumSignedTxSize(const CTransaction& tx, const CWallet* wallet, bool use_max_sig = false) EXCLUSIVE_LOCKS_REQUIRED(wallet->cs_wallet);\n-TxSize CalculateMaximumSignedTxSize(const CTransaction& tx, const CWallet* wallet, const std::vector<CTxOut>& txouts, bool use_max_sig = false);\n-\n //! Add wallet name to persistent configuration so it will be loaded on startup.\n bool AddWalletSetting(interfaces::Chain& chain, const std::string& wallet_name);\n "
      },
      {
        "sha": "03464cd2c83566cc8407f667fa15add83fb03ba3",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b11a195ef450bd138aa03204a5e74fdd3ddced26/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=b11a195ef450bd138aa03204a5e74fdd3ddced26",
        "patch": "@@ -954,7 +954,7 @@ DBErrors WalletBatch::FindWalletTx(std::vector<uint256>& vTxHash, std::list<CWal\n                 uint256 hash;\n                 ssKey >> hash;\n                 vTxHash.push_back(hash);\n-                vWtx.emplace_back(nullptr /* wallet */, nullptr /* tx */);\n+                vWtx.emplace_back(nullptr /* tx */);\n                 ssValue >> vWtx.back();\n             }\n         }"
      },
      {
        "sha": "ab38ddb996828ff2e5d5a56ed563824b74a0f027",
        "filename": "test/functional/wallet_basic.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b11a195ef450bd138aa03204a5e74fdd3ddced26/test/functional/wallet_basic.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b11a195ef450bd138aa03204a5e74fdd3ddced26/test/functional/wallet_basic.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_basic.py?ref=b11a195ef450bd138aa03204a5e74fdd3ddced26",
        "patch": "@@ -600,7 +600,7 @@ def run_test(self):\n         total_txs = len(self.nodes[0].listtransactions(\"*\", 99999))\n \n         # Try with walletrejectlongchains\n-        # Double chain limit but require combining inputs, so we pass SelectCoinsMinConf\n+        # Double chain limit but require combining inputs, so we pass AttemptSelection\n         self.stop_node(0)\n         extra_args = [\"-walletrejectlongchains\", \"-limitancestorcount=\" + str(2 * chainlimit)]\n         self.start_node(0, extra_args=extra_args)"
      },
      {
        "sha": "8e74f41bb6e9b6087965d96a97bd0638dae18140",
        "filename": "test/lint/lint-circular-dependencies.sh",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b11a195ef450bd138aa03204a5e74fdd3ddced26/test/lint/lint-circular-dependencies.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b11a195ef450bd138aa03204a5e74fdd3ddced26/test/lint/lint-circular-dependencies.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-circular-dependencies.sh?ref=b11a195ef450bd138aa03204a5e74fdd3ddced26",
        "patch": "@@ -24,10 +24,6 @@ EXPECTED_CIRCULAR_DEPENDENCIES=(\n     \"wallet/fees -> wallet/wallet -> wallet/fees\"\n     \"wallet/wallet -> wallet/walletdb -> wallet/wallet\"\n     \"node/coinstats -> validation -> node/coinstats\"\n-    # Temporary circular dependencies that allow wallet.h/wallet.cpp to be\n-    # split up in a MOVEONLY commit. These are removed in #21206.\n-    \"wallet/receive -> wallet/wallet -> wallet/receive\"\n-    \"wallet/spend -> wallet/wallet -> wallet/spend\"\n )\n \n EXIT_CODE=0"
      }
    ]
  }
]