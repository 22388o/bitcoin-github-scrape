[
  {
    "sha": "8bfda948fd321edb3ab86da126ea915444ff15e7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YmZkYTk0OGZkMzIxZWRiM2FiODZkYTEyNmVhOTE1NDQ0ZmYxNWU3",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2016-03-15T20:28:56Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2016-03-15T21:07:09Z"
      },
      "message": "Make GetAncestor more robust\n\nThis check for pskip != NULL was introduced in #5927 for 0.12.\nIt is in general safer and allows GetAncestor to be used in more places, specifically in the mining tests for the backport of BIP 68 to 0.11.",
      "tree": {
        "sha": "ac41719c7957756d048b2385892684f944c79eb3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ac41719c7957756d048b2385892684f944c79eb3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8bfda948fd321edb3ab86da126ea915444ff15e7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8bfda948fd321edb3ab86da126ea915444ff15e7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8bfda948fd321edb3ab86da126ea915444ff15e7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8bfda948fd321edb3ab86da126ea915444ff15e7/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0ba7020cf6f9b83f3b2c004695a792c264255d49",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0ba7020cf6f9b83f3b2c004695a792c264255d49",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0ba7020cf6f9b83f3b2c004695a792c264255d49"
      }
    ],
    "stats": {
      "total": 7,
      "additions": 4,
      "deletions": 3
    },
    "files": [
      {
        "sha": "f2573c6d4829d8874f7464cec863013ef41c0480",
        "filename": "src/chain.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8bfda948fd321edb3ab86da126ea915444ff15e7/src/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8bfda948fd321edb3ab86da126ea915444ff15e7/src/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.cpp?ref=8bfda948fd321edb3ab86da126ea915444ff15e7",
        "patch": "@@ -82,9 +82,10 @@ CBlockIndex* CBlockIndex::GetAncestor(int height)\n     while (heightWalk > height) {\n         int heightSkip = GetSkipHeight(heightWalk);\n         int heightSkipPrev = GetSkipHeight(heightWalk - 1);\n-        if (heightSkip == height ||\n-            (heightSkip > height && !(heightSkipPrev < heightSkip - 2 &&\n-                                      heightSkipPrev >= height))) {\n+         if (pindexWalk->pskip != NULL &&\n+             (heightSkip == height ||\n+              (heightSkip > height && !(heightSkipPrev < heightSkip - 2 &&\n+                                        heightSkipPrev >= height)))) {\n             // Only follow pskip if pprev->pskip isn't better than pskip->pprev.\n             pindexWalk = pindexWalk->pskip;\n             heightWalk = heightSkip;"
      }
    ]
  },
  {
    "sha": "7bfe5228fd62657eb399778b73c7752f4dd184a0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3YmZlNTIyOGZkNjI2NTdlYjM5OTc3OGI3M2M3NzUyZjRkZDE4NGEw",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-12-07T20:44:16Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2016-03-15T21:07:10Z"
      },
      "message": "[0.11] Backport BIP 68",
      "tree": {
        "sha": "900989519669924ab31391e72537b249d3c30996",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/900989519669924ab31391e72537b249d3c30996"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7bfe5228fd62657eb399778b73c7752f4dd184a0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7bfe5228fd62657eb399778b73c7752f4dd184a0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7bfe5228fd62657eb399778b73c7752f4dd184a0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7bfe5228fd62657eb399778b73c7752f4dd184a0/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8bfda948fd321edb3ab86da126ea915444ff15e7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8bfda948fd321edb3ab86da126ea915444ff15e7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8bfda948fd321edb3ab86da126ea915444ff15e7"
      }
    ],
    "stats": {
      "total": 743,
      "additions": 696,
      "deletions": 47
    },
    "files": [
      {
        "sha": "bd61282fa18e49a2530cd2ba89db137f713bee21",
        "filename": "qa/rpc-tests/bip68-sequence.py",
        "status": "added",
        "additions": 387,
        "deletions": 0,
        "changes": 387,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7bfe5228fd62657eb399778b73c7752f4dd184a0/qa/rpc-tests/bip68-sequence.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7bfe5228fd62657eb399778b73c7752f4dd184a0/qa/rpc-tests/bip68-sequence.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bip68-sequence.py?ref=7bfe5228fd62657eb399778b73c7752f4dd184a0",
        "patch": "@@ -0,0 +1,387 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014-2015 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test BIP68 implementation (mempool only)\n+#\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.script import *\n+from test_framework.mininode import *\n+from test_framework.blocktools import *\n+\n+COIN = 100000000\n+SEQUENCE_LOCKTIME_DISABLE_FLAG = (1<<31)\n+SEQUENCE_LOCKTIME_TYPE_FLAG = (1<<22) # this means use time (0 means height)\n+SEQUENCE_LOCKTIME_GRANULARITY = 9 # this is a bit-shift\n+SEQUENCE_LOCKTIME_MASK = 0x0000ffff\n+\n+# RPC error for non-BIP68 final transactions\n+NOT_FINAL_ERROR = \"64: non-BIP68-final\"\n+\n+class BIP68Test(BitcoinTestFramework):\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-blockprioritysize=0\"]))\n+        self.is_network_split = False\n+        self.relayfee = self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+\n+    def run_test(self):\n+        # Generate some coins\n+        self.nodes[0].generate(110)\n+\n+        print \"Running test disable flag\"\n+        self.test_disable_flag()\n+\n+        print \"Running test sequence-lock-confirmed-inputs\"\n+        self.test_sequence_lock_confirmed_inputs()\n+\n+        print \"Running test sequence-lock-unconfirmed-inputs\"\n+        self.test_sequence_lock_unconfirmed_inputs()\n+\n+        # This test needs to change when BIP68 becomes consensus\n+        print \"Running test BIP68 not consensus\"\n+        self.test_bip68_not_consensus()\n+\n+        print \"Passed\\n\"\n+\n+    # Test that BIP68 is not in effect if tx version is 1, or if\n+    # the first sequence bit is set.\n+    def test_disable_flag(self):\n+        # Create some unconfirmed inputs\n+        new_addr = self.nodes[0].getnewaddress()\n+        self.nodes[0].sendtoaddress(new_addr, 2) # send 2 BTC\n+\n+        utxos = self.nodes[0].listunspent(0, 0)\n+        assert(len(utxos) > 0)\n+\n+        utxo = utxos[0]\n+\n+        tx1 = CTransaction()\n+        value = satoshi_round(utxo[\"amount\"] - self.relayfee)*COIN\n+\n+        # Check that the disable flag disables relative locktime.\n+        # If sequence locks were used, this would require 1 block for the\n+        # input to mature.\n+        sequence_value = SEQUENCE_LOCKTIME_DISABLE_FLAG | 1\n+        tx1.vin = [CTxIn(COutPoint(int(utxo[\"txid\"], 16), utxo[\"vout\"]), nSequence=sequence_value)] \n+        tx1.vout = [CTxOut(value, CScript([b'a']))]\n+\n+        tx1_signed = self.nodes[0].signrawtransaction(ToHex(tx1))[\"hex\"]\n+        tx1_id = self.nodes[0].sendrawtransaction(tx1_signed)\n+        tx1_id = int(tx1_id, 16)\n+\n+        # This transaction will enable sequence-locks, so this transaction should\n+        # fail\n+        tx2 = CTransaction()\n+        tx2.nVersion = 2\n+        sequence_value = sequence_value & 0x7fffffff\n+        tx2.vin = [CTxIn(COutPoint(tx1_id, 0), nSequence=sequence_value)]\n+        tx2.vout = [CTxOut(int(value-self.relayfee*COIN), CScript([b'a']))]\n+        tx2.rehash()\n+\n+        try:\n+            self.nodes[0].sendrawtransaction(ToHex(tx2))\n+        except JSONRPCException as exp:\n+            assert_equal(exp.error[\"message\"], NOT_FINAL_ERROR)\n+        else:\n+            assert(False)\n+\n+        # Setting the version back down to 1 should disable the sequence lock,\n+        # so this should be accepted.\n+        tx2.nVersion = 1\n+\n+        self.nodes[0].sendrawtransaction(ToHex(tx2))\n+\n+    # Calculate the median time past of a prior block (\"confirmations\" before\n+    # the current tip).\n+    def get_median_time_past(self, confirmations):\n+        block_hash = self.nodes[0].getblockhash(self.nodes[0].getblockcount()-confirmations)\n+        return self.nodes[0].getblockheader(block_hash)[\"mediantime\"]\n+\n+    # Test that sequence locks are respected for transactions spending confirmed inputs.\n+    def test_sequence_lock_confirmed_inputs(self):\n+        # Create lots of confirmed utxos, and use them to generate lots of random\n+        # transactions.\n+        max_outputs = 50\n+        addresses = []\n+        while len(addresses) < max_outputs:\n+            addresses.append(self.nodes[0].getnewaddress())\n+        while len(self.nodes[0].listunspent()) < 200:\n+            import random\n+            random.shuffle(addresses)\n+            num_outputs = random.randint(1, max_outputs)\n+            outputs = {}\n+            for i in xrange(num_outputs):\n+                outputs[addresses[i]] = random.randint(1, 20)*0.01\n+            self.nodes[0].sendmany(\"\", outputs)\n+            self.nodes[0].generate(1)\n+\n+        utxos = self.nodes[0].listunspent()\n+\n+        # Try creating a lot of random transactions.\n+        # Each time, choose a random number of inputs, and randomly set\n+        # some of those inputs to be sequence locked (and randomly choose\n+        # between height/time locking). Small random chance of making the locks\n+        # all pass.\n+        for i in xrange(400):\n+            # Randomly choose up to 10 inputs\n+            num_inputs = random.randint(1, 10)\n+            random.shuffle(utxos)\n+\n+            # Track whether any sequence locks used should fail\n+            should_pass = True\n+            \n+            # Track whether this transaction was built with sequence locks\n+            using_sequence_locks = False\n+\n+            tx = CTransaction()\n+            tx.nVersion = 2\n+            value = 0\n+            for j in xrange(num_inputs):\n+                sequence_value = 0xfffffffe # this disables sequence locks\n+\n+                # 50% chance we enable sequence locks\n+                if random.randint(0,1):\n+                    using_sequence_locks = True\n+\n+                    # 10% of the time, make the input sequence value pass\n+                    input_will_pass = (random.randint(1,10) == 1)\n+                    sequence_value = utxos[j][\"confirmations\"]\n+                    if not input_will_pass:\n+                        sequence_value += 1\n+                        should_pass = False\n+\n+                    # Figure out what the median-time-past was for the confirmed input\n+                    # Note that if an input has N confirmations, we're going back N blocks\n+                    # from the tip so that we're looking up MTP of the block\n+                    # PRIOR to the one the input appears in, as per the BIP68 spec.\n+                    orig_time = self.get_median_time_past(utxos[j][\"confirmations\"])\n+                    cur_time = self.get_median_time_past(0) # MTP of the tip\n+\n+                    # can only timelock this input if it's not too old -- otherwise use height\n+                    can_time_lock = True\n+                    if ((cur_time - orig_time) >> SEQUENCE_LOCKTIME_GRANULARITY) >= SEQUENCE_LOCKTIME_MASK:\n+                        can_time_lock = False\n+\n+                    # if time-lockable, then 50% chance we make this a time lock\n+                    if random.randint(0,1) and can_time_lock:\n+                        # Find first time-lock value that fails, or latest one that succeeds\n+                        time_delta = sequence_value << SEQUENCE_LOCKTIME_GRANULARITY\n+                        if input_will_pass and time_delta > cur_time - orig_time:\n+                            sequence_value = ((cur_time - orig_time) >> SEQUENCE_LOCKTIME_GRANULARITY)\n+                        elif (not input_will_pass and time_delta <= cur_time - orig_time):\n+                            sequence_value = ((cur_time - orig_time) >> SEQUENCE_LOCKTIME_GRANULARITY)+1\n+                        sequence_value |= SEQUENCE_LOCKTIME_TYPE_FLAG\n+                tx.vin.append(CTxIn(COutPoint(int(utxos[j][\"txid\"], 16), utxos[j][\"vout\"]), nSequence=sequence_value))\n+                value += utxos[j][\"amount\"]*COIN\n+            # Overestimate the size of the tx - signatures should be less than 120 bytes, and leave 50 for the output\n+            tx_size = len(ToHex(tx))/2 + 120*num_inputs + 50\n+            tx.vout.append(CTxOut(value-self.relayfee*tx_size*COIN/1000, CScript([b'a'])))\n+            rawtx = self.nodes[0].signrawtransaction(ToHex(tx))[\"hex\"]\n+\n+            try:\n+                self.nodes[0].sendrawtransaction(rawtx)\n+            except JSONRPCException as exp:\n+                assert(not should_pass and using_sequence_locks)\n+                assert_equal(exp.error[\"message\"], NOT_FINAL_ERROR)\n+            else:\n+                assert(should_pass or not using_sequence_locks)\n+                # Recalculate utxos if we successfully sent the transaction\n+                utxos = self.nodes[0].listunspent()\n+\n+    # Test that sequence locks on unconfirmed inputs must have nSequence\n+    # height or time of 0 to be accepted.\n+    # Then test that BIP68-invalid transactions are removed from the mempool\n+    # after a reorg.\n+    def test_sequence_lock_unconfirmed_inputs(self):\n+        # Store height so we can easily reset the chain at the end of the test\n+        cur_height = self.nodes[0].getblockcount()\n+\n+        # Create a mempool tx.\n+        txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 2)\n+        tx1 = FromHex(CTransaction(), self.nodes[0].getrawtransaction(txid))\n+        tx1.rehash()\n+\n+        # Anyone-can-spend mempool tx.\n+        # Sequence lock of 0 should pass.\n+        tx2 = CTransaction()\n+        tx2.nVersion = 2\n+        tx2.vin = [CTxIn(COutPoint(tx1.sha256, 0), nSequence=0)]\n+        tx2.vout = [CTxOut(int(tx1.vout[0].nValue - self.relayfee*COIN), CScript([b'a']))]\n+        tx2_raw = self.nodes[0].signrawtransaction(ToHex(tx2))[\"hex\"]\n+        tx2 = FromHex(tx2, tx2_raw)\n+        tx2.rehash()\n+\n+        self.nodes[0].sendrawtransaction(tx2_raw)\n+\n+        # Create a spend of the 0th output of orig_tx with a sequence lock\n+        # of 1, and test what happens when submitting.\n+        # orig_tx.vout[0] must be an anyone-can-spend output\n+        def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n+            sequence_value = 1\n+            if not use_height_lock:\n+                sequence_value |= SEQUENCE_LOCKTIME_TYPE_FLAG\n+\n+            tx = CTransaction()\n+            tx.nVersion = 2\n+            tx.vin = [CTxIn(COutPoint(orig_tx.sha256, 0), nSequence=sequence_value)]\n+            tx.vout = [CTxOut(int(orig_tx.vout[0].nValue - relayfee*COIN), CScript([b'a']))]\n+            tx.rehash()\n+\n+            try:\n+                node.sendrawtransaction(ToHex(tx))\n+            except JSONRPCException as exp:\n+                assert_equal(exp.error[\"message\"], NOT_FINAL_ERROR)\n+                assert(orig_tx.hash in node.getrawmempool())\n+            else:\n+                # orig_tx must not be in mempool\n+                assert(orig_tx.hash not in node.getrawmempool())\n+            return tx\n+\n+        test_nonzero_locks(tx2, self.nodes[0], self.relayfee, use_height_lock=True)\n+        test_nonzero_locks(tx2, self.nodes[0], self.relayfee, use_height_lock=False)\n+\n+        # Now mine some blocks, but make sure tx2 doesn't get mined.\n+        # Use prioritisetransaction to lower the effective feerate to 0\n+        self.nodes[0].prioritisetransaction(tx2.hash, -1e15, int(-self.relayfee*COIN))\n+        cur_time = int(time.time())\n+        for i in xrange(10):\n+            self.nodes[0].setmocktime(cur_time + 600)\n+            self.nodes[0].generate(1)\n+            cur_time += 600\n+\n+        assert(tx2.hash in self.nodes[0].getrawmempool())\n+\n+        test_nonzero_locks(tx2, self.nodes[0], self.relayfee, use_height_lock=True)\n+        test_nonzero_locks(tx2, self.nodes[0], self.relayfee, use_height_lock=False)\n+\n+        # Mine tx2, and then try again\n+        self.nodes[0].prioritisetransaction(tx2.hash, 1e15, int(self.relayfee*COIN))\n+\n+        # Advance the time on the node so that we can test timelocks\n+        self.nodes[0].setmocktime(cur_time+600)\n+        self.nodes[0].generate(1)\n+        assert(tx2.hash not in self.nodes[0].getrawmempool())\n+\n+        # Now that tx2 is not in the mempool, a sequence locked spend should\n+        # succeed\n+        tx3 = test_nonzero_locks(tx2, self.nodes[0], self.relayfee, use_height_lock=False)\n+        assert(tx3.hash in self.nodes[0].getrawmempool())\n+\n+        self.nodes[0].generate(1)\n+        assert(tx3.hash not in self.nodes[0].getrawmempool())\n+\n+        # One more test, this time using height locks\n+        tx4 = test_nonzero_locks(tx3, self.nodes[0], self.relayfee, use_height_lock=True)\n+        assert(tx4.hash in self.nodes[0].getrawmempool())\n+\n+        # Now try combining confirmed and unconfirmed inputs\n+        tx5 = test_nonzero_locks(tx4, self.nodes[0], self.relayfee, use_height_lock=True)\n+        assert(tx5.hash not in self.nodes[0].getrawmempool())\n+\n+        utxos = self.nodes[0].listunspent()\n+        tx5.vin.append(CTxIn(COutPoint(int(utxos[0][\"txid\"], 16), utxos[0][\"vout\"]), nSequence=1))\n+        tx5.vout[0].nValue += int(utxos[0][\"amount\"]*COIN)\n+        raw_tx5 = self.nodes[0].signrawtransaction(ToHex(tx5))[\"hex\"]\n+\n+        try:\n+            self.nodes[0].sendrawtransaction(raw_tx5)\n+        except JSONRPCException as exp:\n+            assert_equal(exp.error[\"message\"], NOT_FINAL_ERROR)\n+        else:\n+            assert(False)\n+\n+        # Test mempool-BIP68 consistency after reorg\n+        #\n+        # State of the transactions in the last blocks:\n+        # ... -> [ tx2 ] ->  [ tx3 ]\n+        #         tip-1        tip\n+        # And currently tx4 is in the mempool.\n+        #\n+        # If we invalidate the tip, tx3 should get added to the mempool, causing\n+        # tx4 to be removed (fails sequence-lock).\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+        assert(tx4.hash not in self.nodes[0].getrawmempool())\n+        assert(tx3.hash in self.nodes[0].getrawmempool())\n+\n+        # Now mine 2 empty blocks to reorg out the current tip (labeled tip-1 in\n+        # diagram above).\n+        # This would cause tx2 to be added back to the mempool, which in turn causes\n+        # tx3 to be removed.\n+        tip = int(self.nodes[0].getblockhash(self.nodes[0].getblockcount()-1), 16)\n+        height = self.nodes[0].getblockcount()\n+        for i in xrange(2):\n+            block = create_block(tip, create_coinbase(height), cur_time)\n+            block.nVersion = 3\n+            block.rehash()\n+            block.solve()\n+            tip = block.sha256\n+            height += 1\n+            self.nodes[0].submitblock(ToHex(block))\n+            cur_time += 1\n+\n+        mempool = self.nodes[0].getrawmempool()\n+        assert(tx3.hash not in mempool)\n+        assert(tx2.hash in mempool)\n+\n+        # Reset the chain and get rid of the mocktimed-blocks\n+        self.nodes[0].setmocktime(0)\n+        self.nodes[0].invalidateblock(self.nodes[0].getblockhash(cur_height+1))\n+        self.nodes[0].generate(10)\n+\n+    # Make sure that BIP68 isn't being used to validate blocks.\n+    def test_bip68_not_consensus(self):\n+        txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 2)\n+\n+        tx1 = FromHex(CTransaction(), self.nodes[0].getrawtransaction(txid))\n+        tx1.rehash()\n+\n+        # Make an anyone-can-spend transaction\n+        tx2 = CTransaction()\n+        tx2.nVersion = 1\n+        tx2.vin = [CTxIn(COutPoint(tx1.sha256, 0), nSequence=0)]\n+        tx2.vout = [CTxOut(int(tx1.vout[0].nValue - self.relayfee*COIN), CScript([b'a']))]\n+\n+        # sign tx2\n+        tx2_raw = self.nodes[0].signrawtransaction(ToHex(tx2))[\"hex\"]\n+        tx2 = FromHex(tx2, tx2_raw)\n+        tx2.rehash()\n+\n+        self.nodes[0].sendrawtransaction(ToHex(tx2))\n+        \n+        # Now make an invalid spend of tx2 according to BIP68\n+        sequence_value = 100 # 100 block relative locktime\n+\n+        tx3 = CTransaction()\n+        tx3.nVersion = 2\n+        tx3.vin = [CTxIn(COutPoint(tx2.sha256, 0), nSequence=sequence_value)]\n+        tx3.vout = [CTxOut(int(tx2.vout[0].nValue - self.relayfee*COIN), CScript([b'a']))]\n+        tx3.rehash()\n+\n+        try:\n+            self.nodes[0].sendrawtransaction(ToHex(tx3))\n+        except JSONRPCException as exp:\n+            assert_equal(exp.error[\"message\"], NOT_FINAL_ERROR)\n+        else:\n+            assert(False)\n+\n+        # make a block that violates bip68; ensure that the tip updates\n+        tip = int(self.nodes[0].getbestblockhash(), 16)\n+        block = create_block(tip, create_coinbase(self.nodes[0].getblockcount()+1))\n+        block.nVersion = 3\n+        block.vtx.extend([tx1, tx2, tx3])\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        block.rehash()\n+        block.solve()\n+\n+        self.nodes[0].submitblock(ToHex(block))\n+        assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n+\n+\n+if __name__ == '__main__':\n+    BIP68Test().main()"
      },
      {
        "sha": "359a841705b3f9d8adecc5fc5e2bc34c56fa6684",
        "filename": "qa/rpc-tests/test_framework/mininode.py",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7bfe5228fd62657eb399778b73c7752f4dd184a0/qa/rpc-tests/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7bfe5228fd62657eb399778b73c7752f4dd184a0/qa/rpc-tests/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/mininode.py?ref=7bfe5228fd62657eb399778b73c7752f4dd184a0",
        "patch": "@@ -230,6 +230,14 @@ def ser_int_vector(l):\n         r += struct.pack(\"<i\", i)\n     return r\n \n+# Deserialize from a hex string representation (eg from RPC)\n+def FromHex(obj, hex_string):\n+    obj.deserialize(cStringIO.StringIO(binascii.unhexlify(hex_string)))\n+    return obj\n+\n+# Convert a binary-serializable object to hex (eg for submission via RPC)\n+def ToHex(obj):\n+    return binascii.hexlify(obj.serialize()).decode('utf-8')\n \n # Objects that map to bitcoind objects, which can be serialized/deserialized\n "
      },
      {
        "sha": "39bc68f6d66d0b96e5f94dffbd6fe234fd1f87e6",
        "filename": "src/consensus/consensus.h",
        "status": "modified",
        "additions": 7,
        "deletions": 3,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7bfe5228fd62657eb399778b73c7752f4dd184a0/src/consensus/consensus.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7bfe5228fd62657eb399778b73c7752f4dd184a0/src/consensus/consensus.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/consensus.h?ref=7bfe5228fd62657eb399778b73c7752f4dd184a0",
        "patch": "@@ -13,13 +13,17 @@ static const unsigned int MAX_BLOCK_SIGOPS = MAX_BLOCK_SIZE/50;\n /** Coinbase transaction outputs can only be spent after this number of new blocks (network rule) */\n static const int COINBASE_MATURITY = 100;\n \n-/** Flags for LockTime() */\n+/** Flags for nSequence and nLockTime locks */\n enum {\n+    /* Interpret sequence numbers as relative lock-time constraints. */\n+    LOCKTIME_VERIFY_SEQUENCE = (1 << 0),\n+\n     /* Use GetMedianTimePast() instead of nTime for end point timestamp. */\n     LOCKTIME_MEDIAN_TIME_PAST = (1 << 1),\n };\n \n-/** Used as the flags parameter to CheckFinalTx() in non-consensus code */\n-static const unsigned int STANDARD_LOCKTIME_VERIFY_FLAGS = LOCKTIME_MEDIAN_TIME_PAST;\n+/** Used as the flags parameter to sequence and nLocktime checks in non-consensus code. */\n+static const unsigned int STANDARD_LOCKTIME_VERIFY_FLAGS = LOCKTIME_VERIFY_SEQUENCE |\n+                                                           LOCKTIME_MEDIAN_TIME_PAST;\n \n #endif // BITCOIN_CONSENSUS_CONSENSUS_H"
      },
      {
        "sha": "948b6a67fc8490082424b33b23b9a1cbeb560d41",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 148,
        "deletions": 2,
        "changes": 150,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7bfe5228fd62657eb399778b73c7752f4dd184a0/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7bfe5228fd62657eb399778b73c7752f4dd184a0/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=7bfe5228fd62657eb399778b73c7752f4dd184a0",
        "patch": "@@ -703,9 +703,10 @@ bool IsFinalTx(const CTransaction &tx, int nBlockHeight, int64_t nBlockTime)\n         return true;\n     if ((int64_t)tx.nLockTime < ((int64_t)tx.nLockTime < LOCKTIME_THRESHOLD ? (int64_t)nBlockHeight : nBlockTime))\n         return true;\n-    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n-        if (!txin.IsFinal())\n+    BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n+        if (!(txin.nSequence == CTxIn::SEQUENCE_FINAL))\n             return false;\n+    }\n     return true;\n }\n \n@@ -808,6 +809,127 @@ bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n     return true;\n }\n \n+/**\n+ * Calculates the block height and previous block's median time past at\n+ * which the transaction will be considered final in the context of BIP 68.\n+ * Also removes from the vector of input heights any entries which did not\n+ * correspond to sequence locked inputs as they do not affect the calculation.\n+ */\n+static std::pair<int, int64_t> CalculateSequenceLocks(const CTransaction &tx, int flags, std::vector<int>* prevHeights, const CBlockIndex& block)\n+{\n+    assert(prevHeights->size() == tx.vin.size());\n+\n+    // Will be set to the equivalent height- and time-based nLockTime\n+    // values that would be necessary to satisfy all relative lock-\n+    // time constraints given our view of block chain history.\n+    // The semantics of nLockTime are the last invalid height/time, so\n+    // use -1 to have the effect of any height or time being valid.\n+    int nMinHeight = -1;\n+    int64_t nMinTime = -1;\n+\n+    // tx.nVersion is signed integer so requires cast to unsigned otherwise\n+    // we would be doing a signed comparison and half the range of nVersion\n+    // wouldn't support BIP 68.\n+    bool fEnforceBIP68 = static_cast<uint32_t>(tx.nVersion) >= 2\n+                      && flags & LOCKTIME_VERIFY_SEQUENCE;\n+\n+    // Do not enforce sequence numbers as a relative lock time\n+    // unless we have been instructed to\n+    if (!fEnforceBIP68) {\n+        return std::make_pair(nMinHeight, nMinTime);\n+    }\n+\n+    for (size_t txinIndex = 0; txinIndex < tx.vin.size(); txinIndex++) {\n+        const CTxIn& txin = tx.vin[txinIndex];\n+\n+        // Sequence numbers with the most significant bit set are not\n+        // treated as relative lock-times, nor are they given any\n+        // consensus-enforced meaning at this point.\n+        if (txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_DISABLE_FLAG) {\n+            // The height of this input is not relevant for sequence locks\n+            (*prevHeights)[txinIndex] = 0;\n+            continue;\n+        }\n+\n+        int nCoinHeight = (*prevHeights)[txinIndex];\n+\n+        if (txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG) {\n+            int64_t nCoinTime = block.GetAncestor(std::max(nCoinHeight-1, 0))->GetMedianTimePast();\n+            // NOTE: Subtract 1 to maintain nLockTime semantics\n+            // BIP 68 relative lock times have the semantics of calculating\n+            // the first block or time at which the transaction would be\n+            // valid. When calculating the effective block time or height\n+            // for the entire transaction, we switch to using the\n+            // semantics of nLockTime which is the last invalid block\n+            // time or height.  Thus we subtract 1 from the calculated\n+            // time or height.\n+\n+            // Time-based relative lock-times are measured from the\n+            // smallest allowed timestamp of the block containing the\n+            // txout being spent, which is the median time past of the\n+            // block prior.\n+            nMinTime = std::max(nMinTime, nCoinTime + (int64_t)((txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_MASK) << CTxIn::SEQUENCE_LOCKTIME_GRANULARITY) - 1);\n+        } else {\n+            nMinHeight = std::max(nMinHeight, nCoinHeight + (int)(txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_MASK) - 1);\n+        }\n+    }\n+\n+    return std::make_pair(nMinHeight, nMinTime);\n+}\n+\n+static bool EvaluateSequenceLocks(const CBlockIndex& block, std::pair<int, int64_t> lockPair)\n+{\n+    assert(block.pprev);\n+    int64_t nBlockTime = block.pprev->GetMedianTimePast();\n+    if (lockPair.first >= block.nHeight || lockPair.second >= nBlockTime)\n+        return false;\n+\n+    return true;\n+}\n+\n+bool SequenceLocks(const CTransaction &tx, int flags, std::vector<int>* prevHeights, const CBlockIndex& block)\n+{\n+    return EvaluateSequenceLocks(block, CalculateSequenceLocks(tx, flags, prevHeights, block));\n+}\n+\n+bool CheckSequenceLocks(const CTransaction &tx, int flags)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(mempool.cs);\n+\n+    CBlockIndex* tip = chainActive.Tip();\n+    CBlockIndex index;\n+    index.pprev = tip;\n+    // CheckSequenceLocks() uses chainActive.Height()+1 to evaluate\n+    // height based locks because when SequenceLocks() is called within\n+    // ConnectBlock(), the height of the block *being*\n+    // evaluated is what is used.\n+    // Thus if we want to know if a transaction can be part of the\n+    // *next* block, we need to use one more than chainActive.Height()\n+    index.nHeight = tip->nHeight + 1;\n+\n+    // pcoinsTip contains the UTXO set for chainActive.Tip()\n+    CCoinsViewMemPool viewMemPool(pcoinsTip, mempool);\n+    std::vector<int> prevheights;\n+    prevheights.resize(tx.vin.size());\n+    for (size_t txinIndex = 0; txinIndex < tx.vin.size(); txinIndex++) {\n+        const CTxIn& txin = tx.vin[txinIndex];\n+        CCoins coins;\n+        if (!viewMemPool.GetCoins(txin.prevout.hash, coins)) {\n+            return error(\"%s: Missing input\", __func__);\n+        }\n+        if (coins.nHeight == MEMPOOL_HEIGHT) {\n+            // Assume all mempool transaction confirm in the next block\n+            prevheights[txinIndex] = tip->nHeight + 1;\n+        } else {\n+            prevheights[txinIndex] = coins.nHeight;\n+        }\n+    }\n+\n+    std::pair<int, int64_t> lockPair = CalculateSequenceLocks(tx, flags, &prevheights, index);\n+    return EvaluateSequenceLocks(index, lockPair);\n+}\n+\n unsigned int GetLegacySigOpCount(const CTransaction& tx)\n {\n     unsigned int nSigOps = 0;\n@@ -1015,6 +1137,14 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n \n         // we have all inputs cached now, so switch back to dummy, so we don't need to keep lock on mempool\n         view.SetBackend(dummy);\n+\n+        // Only accept BIP68 sequence locked transactions that can be mined in the next\n+        // block; we don't want our mempool filled up with transactions that can't\n+        // be mined yet.\n+        // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n+        // CoinsViewCache instead of create its own\n+        if (!CheckSequenceLocks(tx, STANDARD_LOCKTIME_VERIFY_FLAGS))\n+            return state.DoS(0, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n         }\n \n         // Check for non-standard pay-to-script-hash in inputs\n@@ -1891,7 +2021,10 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n \n     CCheckQueueControl<CScriptCheck> control(fScriptChecks && nScriptCheckThreads ? &scriptcheckqueue : NULL);\n \n+\n     int64_t nTimeStart = GetTimeMicros();\n+    std::vector<int> prevheights;\n+    int nLockTimeFlags = 0;\n     CAmount nFees = 0;\n     int nInputs = 0;\n     unsigned int nSigOps = 0;\n@@ -1915,6 +2048,19 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n                 return state.DoS(100, error(\"ConnectBlock(): inputs missing/spent\"),\n                                  REJECT_INVALID, \"bad-txns-inputs-missingorspent\");\n \n+            // Check that transaction is BIP68 final\n+            // BIP68 lock checks (as opposed to nLockTime checks) must\n+            // be in ConnectBlock because they require the UTXO set\n+            prevheights.resize(tx.vin.size());\n+            for (size_t j = 0; j < tx.vin.size(); j++) {\n+                prevheights[j] = view.AccessCoins(tx.vin[j].prevout.hash)->nHeight;\n+            }\n+\n+            if (!SequenceLocks(tx, nLockTimeFlags, &prevheights, *pindex)) {\n+                return state.DoS(100, error(\"%s: contains a non-BIP68-final transaction\", __func__),\n+                                 REJECT_INVALID, \"bad-txns-nonfinal\");\n+            }\n+\n             if (fStrictPayToScriptHash)\n             {\n                 // Add in sigops done by pay-to-script-hash inputs;"
      },
      {
        "sha": "b18d5f5eeaaf57d03c7f66ba80ad00578d0c7390",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 16,
        "deletions": 1,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7bfe5228fd62657eb399778b73c7752f4dd184a0/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7bfe5228fd62657eb399778b73c7752f4dd184a0/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=7bfe5228fd62657eb399778b73c7752f4dd184a0",
        "patch": "@@ -343,7 +343,22 @@ bool IsFinalTx(const CTransaction &tx, int nBlockHeight, int64_t nBlockTime);\n  */\n bool CheckFinalTx(const CTransaction &tx, int flags = -1);\n \n-/** \n+/**\n+ * Check if transaction is final per BIP 68 sequence numbers and can be included in a block.\n+ * Consensus critical. Takes as input a list of heights at which tx's inputs (in order) confirmed.\n+ */\n+bool SequenceLocks(const CTransaction &tx, int flags, std::vector<int>* prevHeights, const CBlockIndex& block);\n+\n+/**\n+ * Check if transaction will be BIP 68 final in the next block to be created.\n+ *\n+ * Simulates calling SequenceLocks() with data from the tip of the current active chain.\n+ *\n+ * See consensus/consensus.h for flag definitions.\n+ */\n+bool CheckSequenceLocks(const CTransaction &tx, int flags);\n+\n+/**\n  * Closure representing one script verification\n  * Note that this stores references to the spending transaction \n  */"
      },
      {
        "sha": "e075dcdcff384b9e4203dc58a01d58ab1955f7d1",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7bfe5228fd62657eb399778b73c7752f4dd184a0/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7bfe5228fd62657eb399778b73c7752f4dd184a0/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=7bfe5228fd62657eb399778b73c7752f4dd184a0",
        "patch": "@@ -162,6 +162,10 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n             if (tx.IsCoinBase() || !IsFinalTx(tx, nHeight, nLockTimeCutoff))\n                 continue;\n \n+            // Check that transaction is BIP68 final\n+            if (!CheckSequenceLocks(tx, STANDARD_LOCKTIME_VERIFY_FLAGS))\n+                continue;\n+\n             COrphan* porphan = NULL;\n             double dPriority = 0;\n             CAmount nTotalIn = 0;"
      },
      {
        "sha": "0c8c0c64818572fdbb790fe37843a81f7e0e587b",
        "filename": "src/primitives/transaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7bfe5228fd62657eb399778b73c7752f4dd184a0/src/primitives/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7bfe5228fd62657eb399778b73c7752f4dd184a0/src/primitives/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.cpp?ref=7bfe5228fd62657eb399778b73c7752f4dd184a0",
        "patch": "@@ -37,7 +37,7 @@ std::string CTxIn::ToString() const\n         str += strprintf(\", coinbase %s\", HexStr(scriptSig));\n     else\n         str += strprintf(\", scriptSig=%s\", scriptSig.ToString().substr(0,24));\n-    if (nSequence != std::numeric_limits<unsigned int>::max())\n+    if (nSequence != SEQUENCE_FINAL)\n         str += strprintf(\", nSequence=%u\", nSequence);\n     str += \")\";\n     return str;"
      },
      {
        "sha": "0ac8ee03ffde19eaebd83160e79a8e44897338c7",
        "filename": "src/primitives/transaction.h",
        "status": "modified",
        "additions": 30,
        "deletions": 8,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7bfe5228fd62657eb399778b73c7752f4dd184a0/src/primitives/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7bfe5228fd62657eb399778b73c7752f4dd184a0/src/primitives/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.h?ref=7bfe5228fd62657eb399778b73c7752f4dd184a0",
        "patch": "@@ -61,13 +61,40 @@ class CTxIn\n     CScript scriptSig;\n     uint32_t nSequence;\n \n+    /* Setting nSequence to this value for every input in a transaction\n+     * disables nLockTime. */\n+    static const uint32_t SEQUENCE_FINAL = 0xffffffff;\n+\n+    /* Below flags apply in the context of BIP 68*/\n+    /* If this flag set, CTxIn::nSequence is NOT interpreted as a\n+     * relative lock-time. */\n+    static const uint32_t SEQUENCE_LOCKTIME_DISABLE_FLAG = (1 << 31);\n+\n+    /* If CTxIn::nSequence encodes a relative lock-time and this flag\n+     * is set, the relative lock-time has units of 512 seconds,\n+     * otherwise it specifies blocks with a granularity of 1. */\n+    static const uint32_t SEQUENCE_LOCKTIME_TYPE_FLAG = (1 << 22);\n+\n+    /* If CTxIn::nSequence encodes a relative lock-time, this mask is\n+     * applied to extract that lock-time from the sequence field. */\n+    static const uint32_t SEQUENCE_LOCKTIME_MASK = 0x0000ffff;\n+\n+    /* In order to use the same number of bits to encode roughly the\n+     * same wall-clock duration, and because blocks are naturally\n+     * limited to occur every 600s on average, the minimum granularity\n+     * for time-based relative lock-time is fixed at 512 seconds.\n+     * Converting from CTxIn::nSequence to seconds is performed by\n+     * multiplying by 512 = 2^9, or equivalently shifting up by\n+     * 9 bits. */\n+    static const int SEQUENCE_LOCKTIME_GRANULARITY = 9;\n+\n     CTxIn()\n     {\n-        nSequence = std::numeric_limits<unsigned int>::max();\n+        nSequence = SEQUENCE_FINAL;\n     }\n \n-    explicit CTxIn(COutPoint prevoutIn, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=std::numeric_limits<unsigned int>::max());\n-    CTxIn(uint256 hashPrevTx, uint32_t nOut, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=std::numeric_limits<uint32_t>::max());\n+    explicit CTxIn(COutPoint prevoutIn, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL);\n+    CTxIn(uint256 hashPrevTx, uint32_t nOut, CScript scriptSigIn=CScript(), uint32_t nSequenceIn=SEQUENCE_FINAL);\n \n     ADD_SERIALIZE_METHODS;\n \n@@ -78,11 +105,6 @@ class CTxIn\n         READWRITE(nSequence);\n     }\n \n-    bool IsFinal() const\n-    {\n-        return (nSequence == std::numeric_limits<uint32_t>::max());\n-    }\n-\n     friend bool operator==(const CTxIn& a, const CTxIn& b)\n     {\n         return (a.prevout   == b.prevout &&"
      },
      {
        "sha": "91f6446d1bfc8be627eb4f92427fdeeafe0daa4c",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7bfe5228fd62657eb399778b73c7752f4dd184a0/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7bfe5228fd62657eb399778b73c7752f4dd184a0/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=7bfe5228fd62657eb399778b73c7752f4dd184a0",
        "patch": "@@ -1156,7 +1156,7 @@ bool TransactionSignatureChecker::CheckLockTime(const CScriptNum& nLockTime) con\n     // prevent this condition. Alternatively we could test all\n     // inputs, but testing just this input minimizes the data\n     // required to prove correct CHECKLOCKTIMEVERIFY execution.\n-    if (txTo->vin[nIn].IsFinal())\n+    if (CTxIn::SEQUENCE_FINAL == txTo->vin[nIn].nSequence)\n         return false;\n \n     return true;"
      },
      {
        "sha": "64f06232727f45f7cb43d0d9f4d2b1c0814deeac",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 92,
        "deletions": 29,
        "changes": 121,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7bfe5228fd62657eb399778b73c7752f4dd184a0/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7bfe5228fd62657eb399778b73c7752f4dd184a0/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=7bfe5228fd62657eb399778b73c7752f4dd184a0",
        "patch": "@@ -50,6 +50,20 @@ struct {\n     {2, 0xbbbeb305}, {2, 0xfe1c810a},\n };\n \n+CBlockIndex CreateBlockIndex(int nHeight)\n+{\n+    CBlockIndex index;\n+    index.nHeight = nHeight;\n+    index.pprev = chainActive.Tip();\n+    return index;\n+}\n+\n+bool TestSequenceLocks(const CTransaction &tx, int flags)\n+{\n+    LOCK(mempool.cs);\n+    return CheckSequenceLocks(tx, flags);\n+}\n+\n // NOTE: These tests rely on CreateNewBlock doing its own self-validation!\n BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n {\n@@ -67,6 +81,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n \n     // We can't make transactions until we have inputs\n     // Therefore, load 100 blocks :)\n+    int baseheight = 0;\n     std::vector<CTransaction*>txFirst;\n     for (unsigned int i = 0; i < sizeof(blockinfo)/sizeof(*blockinfo); ++i)\n     {\n@@ -79,7 +94,9 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         txCoinbase.vin[0].scriptSig.push_back(chainActive.Height());\n         txCoinbase.vout[0].scriptPubKey = CScript();\n         pblock->vtx[0] = CTransaction(txCoinbase);\n-        if (txFirst.size() < 2)\n+        if (txFirst.size() == 0)\n+            baseheight = chainActive.Height();\n+        if (txFirst.size() < 4)\n             txFirst.push_back(new CTransaction(pblock->vtx[0]));\n         pblock->hashMerkleRoot = pblock->BuildMerkleTree();\n         pblock->nNonce = blockinfo[i].nonce;\n@@ -213,49 +230,95 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n \n     // non-final txs in mempool\n     SetMockTime(chainActive.Tip()->GetMedianTimePast()+1);\n+    int flags = LOCKTIME_VERIFY_SEQUENCE|LOCKTIME_MEDIAN_TIME_PAST;\n+    // height map\n+    std::vector<int> prevheights;\n \n-    // height locked\n-    tx.vin[0].prevout.hash = txFirst[0]->GetHash();\n+    // relative height locked\n+    tx.nVersion = 2;\n+    tx.vin.resize(1);\n+    prevheights.resize(1);\n+    tx.vin[0].prevout.hash = txFirst[0]->GetHash(); // only 1 transaction\n+    tx.vin[0].prevout.n = 0;\n     tx.vin[0].scriptSig = CScript() << OP_1;\n-    tx.vin[0].nSequence = 0;\n+    tx.vin[0].nSequence = chainActive.Tip()->nHeight + 1; // txFirst[0] is the 2nd block\n+    prevheights[0] = baseheight + 1;\n+    tx.vout.resize(1);\n     tx.vout[0].nValue = 4900000000LL;\n     tx.vout[0].scriptPubKey = CScript() << OP_1;\n-    tx.nLockTime = chainActive.Tip()->nHeight+1;\n+    tx.nLockTime = 0;\n+    hash = tx.GetHash();\n+    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n+    BOOST_CHECK(CheckFinalTx(tx, flags)); // Locktime passes\n+    BOOST_CHECK(!TestSequenceLocks(tx, flags)); // Sequence locks fail\n+    BOOST_CHECK(SequenceLocks(tx, flags, &prevheights, CreateBlockIndex(chainActive.Tip()->nHeight + 2))); // Sequence locks pass on 2nd block\n+\n+    // relative time locked\n+    tx.vin[0].prevout.hash = txFirst[1]->GetHash();\n+    tx.vin[0].nSequence = CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG | (((chainActive.Tip()->GetMedianTimePast()+1-chainActive[1]->GetMedianTimePast()) >> CTxIn::SEQUENCE_LOCKTIME_GRANULARITY) + 1); // txFirst[1] is the 3rd block\n+    prevheights[0] = baseheight + 2;\n     hash = tx.GetHash();\n     mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n-    BOOST_CHECK(!CheckFinalTx(tx, LOCKTIME_MEDIAN_TIME_PAST));\n-\n-    // time locked\n-    tx2.vin.resize(1);\n-    tx2.vin[0].prevout.hash = txFirst[1]->GetHash();\n-    tx2.vin[0].prevout.n = 0;\n-    tx2.vin[0].scriptSig = CScript() << OP_1;\n-    tx2.vin[0].nSequence = 0;\n-    tx2.vout.resize(1);\n-    tx2.vout[0].nValue = 4900000000LL;\n-    tx2.vout[0].scriptPubKey = CScript() << OP_1;\n-    tx2.nLockTime = chainActive.Tip()->GetMedianTimePast()+1;\n-    hash = tx2.GetHash();\n-    mempool.addUnchecked(hash, CTxMemPoolEntry(tx2, 11, GetTime(), 111.0, 11));\n-    BOOST_CHECK(!CheckFinalTx(tx2, LOCKTIME_MEDIAN_TIME_PAST));\n+    BOOST_CHECK(CheckFinalTx(tx, flags)); // Locktime passes\n+    BOOST_CHECK(!TestSequenceLocks(tx, flags)); // Sequence locks fail\n+\n+    for (int i = 0; i < CBlockIndex::nMedianTimeSpan; i++)\n+        chainActive.Tip()->GetAncestor(chainActive.Tip()->nHeight - i)->nTime += 512; //Trick the MedianTimePast\n+    BOOST_CHECK(SequenceLocks(tx, flags, &prevheights, CreateBlockIndex(chainActive.Tip()->nHeight + 1))); // Sequence locks pass 512 seconds later\n+    for (int i = 0; i < CBlockIndex::nMedianTimeSpan; i++)\n+        chainActive.Tip()->GetAncestor(chainActive.Tip()->nHeight - i)->nTime -= 512; //undo tricked MTP\n+\n+    // absolute height locked\n+    tx.vin[0].prevout.hash = txFirst[2]->GetHash();\n+    tx.vin[0].nSequence = CTxIn::SEQUENCE_FINAL - 1;\n+    prevheights[0] = baseheight + 3;\n+    tx.nLockTime = chainActive.Tip()->nHeight + 1;\n+    hash = tx.GetHash();\n+    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n+    BOOST_CHECK(!CheckFinalTx(tx, flags)); // Locktime fails\n+    BOOST_CHECK(TestSequenceLocks(tx, flags)); // Sequence locks pass\n+    BOOST_CHECK(IsFinalTx(tx, chainActive.Tip()->nHeight + 2, chainActive.Tip()->GetMedianTimePast())); // Locktime passes on 2nd block\n+\n+    // absolute time locked\n+    tx.vin[0].prevout.hash = txFirst[3]->GetHash();\n+    tx.nLockTime = chainActive.Tip()->GetMedianTimePast();\n+    prevheights.resize(1);\n+    prevheights[0] = baseheight + 4;\n+    hash = tx.GetHash();\n+    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n+    BOOST_CHECK(!CheckFinalTx(tx, flags)); // Locktime fails\n+    BOOST_CHECK(TestSequenceLocks(tx, flags)); // Sequence locks pass\n+    BOOST_CHECK(IsFinalTx(tx, chainActive.Tip()->nHeight + 2, chainActive.Tip()->GetMedianTimePast() + 1)); // Locktime passes 1 second later\n+\n+    // mempool-dependent transactions (not added)\n+    tx.vin[0].prevout.hash = hash;\n+    prevheights[0] = chainActive.Tip()->nHeight + 1;\n+    tx.nLockTime = 0;\n+    tx.vin[0].nSequence = 0;\n+    BOOST_CHECK(CheckFinalTx(tx, flags)); // Locktime passes\n+    BOOST_CHECK(TestSequenceLocks(tx, flags)); // Sequence locks pass\n+    tx.vin[0].nSequence = 1;\n+    BOOST_CHECK(!TestSequenceLocks(tx, flags)); // Sequence locks fail\n+    tx.vin[0].nSequence = CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG;\n+    BOOST_CHECK(TestSequenceLocks(tx, flags)); // Sequence locks pass\n+    tx.vin[0].nSequence = CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG | 1;\n+    BOOST_CHECK(!TestSequenceLocks(tx, flags)); // Sequence locks fail\n \n     BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n \n-    // Neither tx should have make it into the template.\n+    // None of the of the height/time locked tx should have made\n+    // it into the template because we check IsFinalTx and SequenceLocks in CreateNewBlock,\n     BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 1);\n     delete pblocktemplate;\n \n-    // However if we advance height and time by one, both will.\n+    // However if we advance height by 1 and time by 512, all of them should be mined\n+    for (int i = 0; i < CBlockIndex::nMedianTimeSpan; i++)\n+        chainActive.Tip()->GetAncestor(chainActive.Tip()->nHeight - i)->nTime += 512; //Trick the MedianTimePast\n     chainActive.Tip()->nHeight++;\n-    SetMockTime(chainActive.Tip()->GetMedianTimePast()+2);\n-\n-    // FIXME: we should *actually* create a new block so the following test\n-    //        works; CheckFinalTx() isn't fooled by monkey-patching nHeight.\n-    //BOOST_CHECK(CheckFinalTx(tx));\n-    //BOOST_CHECK(CheckFinalTx(tx2));\n+    SetMockTime(chainActive.Tip()->GetMedianTimePast() + 1);\n \n     BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n-    BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 2);\n+    BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 5);\n     delete pblocktemplate;\n \n     chainActive.Tip()->nHeight--;"
      },
      {
        "sha": "185d2862eb91a1c1e9283a5ccaa24dc6c343f374",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7bfe5228fd62657eb399778b73c7752f4dd184a0/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7bfe5228fd62657eb399778b73c7752f4dd184a0/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=7bfe5228fd62657eb399778b73c7752f4dd184a0",
        "patch": "@@ -65,7 +65,7 @@ CMutableTransaction BuildCreditingTransaction(const CScript& scriptPubKey)\n     txCredit.vout.resize(1);\n     txCredit.vin[0].prevout.SetNull();\n     txCredit.vin[0].scriptSig = CScript() << CScriptNum(0) << CScriptNum(0);\n-    txCredit.vin[0].nSequence = std::numeric_limits<unsigned int>::max();\n+    txCredit.vin[0].nSequence = CTxIn::SEQUENCE_FINAL;\n     txCredit.vout[0].scriptPubKey = scriptPubKey;\n     txCredit.vout[0].nValue = 0;\n \n@@ -82,7 +82,7 @@ CMutableTransaction BuildSpendingTransaction(const CScript& scriptSig, const CMu\n     txSpend.vin[0].prevout.hash = txCredit.GetHash();\n     txSpend.vin[0].prevout.n = 0;\n     txSpend.vin[0].scriptSig = scriptSig;\n-    txSpend.vin[0].nSequence = std::numeric_limits<unsigned int>::max();\n+    txSpend.vin[0].nSequence = CTxIn::SEQUENCE_FINAL;\n     txSpend.vout[0].scriptPubKey = CScript();\n     txSpend.vout[0].nValue = 0;\n "
      }
    ]
  },
  {
    "sha": "77c24fe8ebbed7c809805d85cb7c99d6c54db88a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3N2MyNGZlOGViYmVkN2M4MDk4MDVkODVjYjdjOTlkNmM1NGRiODhh",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2016-03-15T21:05:42Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2016-03-15T21:09:42Z"
      },
      "message": "fixup RPC test to work with 0.11",
      "tree": {
        "sha": "3a5beddb53148f84618a87a3bc956272e3c26cbb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3a5beddb53148f84618a87a3bc956272e3c26cbb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/77c24fe8ebbed7c809805d85cb7c99d6c54db88a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/77c24fe8ebbed7c809805d85cb7c99d6c54db88a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/77c24fe8ebbed7c809805d85cb7c99d6c54db88a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/77c24fe8ebbed7c809805d85cb7c99d6c54db88a/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7bfe5228fd62657eb399778b73c7752f4dd184a0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7bfe5228fd62657eb399778b73c7752f4dd184a0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7bfe5228fd62657eb399778b73c7752f4dd184a0"
      }
    ],
    "stats": {
      "total": 35,
      "additions": 30,
      "deletions": 5
    },
    "files": [
      {
        "sha": "c112ca171cf5b66b890dd429cf025630f2921d75",
        "filename": "qa/pull-tester/rpc-tests.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77c24fe8ebbed7c809805d85cb7c99d6c54db88a/qa/pull-tester/rpc-tests.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77c24fe8ebbed7c809805d85cb7c99d6c54db88a/qa/pull-tester/rpc-tests.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.sh?ref=77c24fe8ebbed7c809805d85cb7c99d6c54db88a",
        "patch": "@@ -27,6 +27,7 @@ testScripts=(\n     'merkle_blocks.py'\n     'signrawtransactions.py'\n     'walletbackup.py'\n+    'bip68-sequence.py'\n );\n testScriptsExt=(\n     'bipdersig-p2p.py'"
      },
      {
        "sha": "94744206a4b022cdc94023ee4eed5a91351047c5",
        "filename": "qa/rpc-tests/bip68-sequence.py",
        "status": "modified",
        "additions": 29,
        "deletions": 5,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77c24fe8ebbed7c809805d85cb7c99d6c54db88a/qa/rpc-tests/bip68-sequence.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77c24fe8ebbed7c809805d85cb7c99d6c54db88a/qa/rpc-tests/bip68-sequence.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bip68-sequence.py?ref=77c24fe8ebbed7c809805d85cb7c99d6c54db88a",
        "patch": "@@ -22,6 +22,9 @@\n # RPC error for non-BIP68 final transactions\n NOT_FINAL_ERROR = \"64: non-BIP68-final\"\n \n+def satoshi_round(amount):\n+    return  Decimal(amount).quantize(Decimal('0.00000001'), rounding=ROUND_DOWN)\n+\n class BIP68Test(BitcoinTestFramework):\n \n     def setup_network(self):\n@@ -101,7 +104,16 @@ def test_disable_flag(self):\n     # the current tip).\n     def get_median_time_past(self, confirmations):\n         block_hash = self.nodes[0].getblockhash(self.nodes[0].getblockcount()-confirmations)\n-        return self.nodes[0].getblockheader(block_hash)[\"mediantime\"]\n+        # Recreate calculation of median time past\n+        times = []\n+        while len(times) < 11:\n+            block = self.nodes[0].getblock(block_hash)\n+            times.append(block[\"time\"])\n+            if block[\"height\"] == 0:\n+                break;\n+            block_hash = block[\"previousblockhash\"]\n+        samples = len(times)\n+        return sorted(times)[samples/2]\n \n     # Test that sequence locks are respected for transactions spending confirmed inputs.\n     def test_sequence_lock_confirmed_inputs(self):\n@@ -304,15 +316,21 @@ def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n         # And currently tx4 is in the mempool.\n         #\n         # If we invalidate the tip, tx3 should get added to the mempool, causing\n-        # tx4 to be removed (fails sequence-lock).\n+        # tx4 to fail sequence lock\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n-        assert(tx4.hash not in self.nodes[0].getrawmempool())\n+        assert(tx4.hash in self.nodes[0].getrawmempool())\n         assert(tx3.hash in self.nodes[0].getrawmempool())\n+        # txs in the mempool which fail sequence locks should not make it into blocks\n+        self.nodes[0].setmocktime(cur_time+601) # increment mock time so different block is created\n+        blockhash = self.nodes[0].generate(1)[0]\n+        assert(tx3.hash in self.nodes[0].getblock(blockhash)[\"tx\"])\n+        assert(tx4.hash not in self.nodes[0].getblock(blockhash)[\"tx\"])\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n         # Now mine 2 empty blocks to reorg out the current tip (labeled tip-1 in\n         # diagram above).\n         # This would cause tx2 to be added back to the mempool, which in turn causes\n-        # tx3 to be removed.\n+        # tx3 to fail sequence lock\n         tip = int(self.nodes[0].getblockhash(self.nodes[0].getblockcount()-1), 16)\n         height = self.nodes[0].getblockcount()\n         for i in xrange(2):\n@@ -326,8 +344,14 @@ def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n             cur_time += 1\n \n         mempool = self.nodes[0].getrawmempool()\n-        assert(tx3.hash not in mempool)\n+        assert(tx3.hash in mempool)\n         assert(tx2.hash in mempool)\n+        # txs in the mempool which fail sequence locks should not make it into blocks\n+        blockhash = self.nodes[0].generate(1)[0]\n+        assert(tx2.hash in self.nodes[0].getblock(blockhash)[\"tx\"])\n+        assert(tx3.hash not in self.nodes[0].getblock(blockhash)[\"tx\"])\n+        self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n+\n \n         # Reset the chain and get rid of the mocktimed-blocks\n         self.nodes[0].setmocktime(0)"
      }
    ]
  }
]