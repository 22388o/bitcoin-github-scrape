[
  {
    "sha": "c59abe25892e32c803ec527c40e9a74ab31ea58a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNTlhYmUyNTg5MmUzMmM4MDNlYzUyN2M0MGU5YTc0YWIzMWVhNThh",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-05-10T16:44:07Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-05-11T15:02:11Z"
      },
      "message": "Use semaphores instead of condition variables",
      "tree": {
        "sha": "8ac4865091903e0d09a1e3e4f4fc08175b143ebe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8ac4865091903e0d09a1e3e4f4fc08175b143ebe"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c59abe25892e32c803ec527c40e9a74ab31ea58a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c59abe25892e32c803ec527c40e9a74ab31ea58a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c59abe25892e32c803ec527c40e9a74ab31ea58a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c59abe25892e32c803ec527c40e9a74ab31ea58a/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2692ed3f01fed4e107a0e1e1ecd3ef9b01267cc9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2692ed3f01fed4e107a0e1e1ecd3ef9b01267cc9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2692ed3f01fed4e107a0e1e1ecd3ef9b01267cc9"
      }
    ],
    "stats": {
      "total": 138,
      "additions": 91,
      "deletions": 47
    },
    "files": [
      {
        "sha": "67427a3e8ea859424c3c1803ad49b9fa9c35716c",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 34,
        "deletions": 32,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c59abe25892e32c803ec527c40e9a74ab31ea58a/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c59abe25892e32c803ec527c40e9a74ab31ea58a/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=c59abe25892e32c803ec527c40e9a74ab31ea58a",
        "patch": "@@ -35,7 +35,7 @@ void ThreadOpenAddedConnections2(void* parg);\n void ThreadMapPort2(void* parg);\n #endif\n void ThreadDNSAddressSeed2(void* parg);\n-bool OpenNetworkConnection(const CAddress& addrConnect, const char *strDest = NULL, bool fOneShot = false);\n+bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOutbound = NULL, const char *strDest = NULL, bool fOneShot = false);\n \n \n \n@@ -66,10 +66,7 @@ CCriticalSection cs_vOneShots;\n set<CNetAddr> setservAddNodeAddresses;\n CCriticalSection cs_setservAddNodeAddresses;\n \n-static CWaitableCriticalSection csOutbound;\n-static int nOutbound = 0;\n-static CConditionVariable condOutbound;\n-\n+static CSemaphore *semOutbound = NULL;\n \n void AddOneShot(string strDest)\n {\n@@ -463,10 +460,6 @@ CNode* ConnectNode(CAddress addrConnect, const char *pszDest, int64 nTimeout)\n             LOCK(cs_vNodes);\n             vNodes.push_back(pnode);\n         }\n-        {\n-            WAITABLE_LOCK(csOutbound);\n-            nOutbound++;\n-        }\n \n         pnode->nTimeConnected = GetTime();\n         return pnode;\n@@ -612,14 +605,8 @@ void ThreadSocketHandler2(void* parg)\n                     // remove from vNodes\n                     vNodes.erase(remove(vNodes.begin(), vNodes.end(), pnode), vNodes.end());\n \n-                    if (!pnode->fInbound)\n-                        {\n-                            WAITABLE_LOCK(csOutbound);\n-                            nOutbound--;\n-\n-                            // Connection slot(s) were removed, notify connection creator(s)\n-                            NOTIFY(condOutbound);\n-                        }\n+                    // release outbound grant (if any)\n+                    pnode->grantOutbound.Release();\n \n                     // close socket and cleanup\n                     pnode->CloseSocketDisconnect();\n@@ -1295,8 +1282,11 @@ void static ProcessOneShot()\n         vOneShots.pop_front();\n     }\n     CAddress addr;\n-    if (!OpenNetworkConnection(addr, strDest.c_str(), true))\n-        AddOneShot(strDest);\n+    CSemaphoreGrant grant(*semOutbound, true);\n+    if (grant) {\n+        if (!OpenNetworkConnection(addr, &grant, strDest.c_str(), true))\n+            AddOneShot(strDest);\n+    }\n }\n \n void ThreadOpenConnections2(void* parg)\n@@ -1312,7 +1302,7 @@ void ThreadOpenConnections2(void* parg)\n             BOOST_FOREACH(string strAddr, mapMultiArgs[\"-connect\"])\n             {\n                 CAddress addr;\n-                OpenNetworkConnection(addr, strAddr.c_str());\n+                OpenNetworkConnection(addr, NULL, strAddr.c_str());\n                 for (int i = 0; i < 10 && i < nLoop; i++)\n                 {\n                     Sleep(500);\n@@ -1335,13 +1325,9 @@ void ThreadOpenConnections2(void* parg)\n         if (fShutdown)\n             return;\n \n-        // Limit outbound connections\n-        int nMaxOutbound = min(MAX_OUTBOUND_CONNECTIONS, (int)GetArg(\"-maxconnections\", 125));\n+\n         vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n-        {\n-            WAITABLE_LOCK(csOutbound);\n-            WAIT(condOutbound, fShutdown || nOutbound < nMaxOutbound);\n-        }\n+        CSemaphoreGrant grant(*semOutbound);\n         vnThreadsRunning[THREAD_OPENCONNECTIONS]++;\n         if (fShutdown)\n             return;\n@@ -1374,11 +1360,15 @@ void ThreadOpenConnections2(void* parg)\n \n         // Only connect to one address per a.b.?.? range.\n         // Do this here so we don't have to critsect vNodes inside mapAddresses critsect.\n+        int nOutbound = 0;\n         set<vector<unsigned char> > setConnected;\n         {\n             LOCK(cs_vNodes);\n-            BOOST_FOREACH(CNode* pnode, vNodes)\n+            BOOST_FOREACH(CNode* pnode, vNodes) {\n                 setConnected.insert(pnode->addr.GetGroup());\n+                if (!pnode->fInbound)\n+                    nOutbound++;\n+            }\n         }\n \n         int64 nANow = GetAdjustedTime();\n@@ -1408,7 +1398,7 @@ void ThreadOpenConnections2(void* parg)\n         }\n \n         if (addrConnect.IsValid())\n-            OpenNetworkConnection(addrConnect);\n+            OpenNetworkConnection(addrConnect, &grant);\n     }\n }\n \n@@ -1442,7 +1432,8 @@ void ThreadOpenAddedConnections2(void* parg)\n         while(!fShutdown) {\n             BOOST_FOREACH(string& strAddNode, mapMultiArgs[\"-addnode\"]) {\n                 CAddress addr;\n-                OpenNetworkConnection(addr, strAddNode.c_str());\n+                CSemaphoreGrant grant(*semOutbound);\n+                OpenNetworkConnection(addr, &grant, strAddNode.c_str());\n                 Sleep(500);\n             }\n             vnThreadsRunning[THREAD_ADDEDCONNECTIONS]--;\n@@ -1485,7 +1476,8 @@ void ThreadOpenAddedConnections2(void* parg)\n         }\n         BOOST_FOREACH(vector<CService>& vserv, vservConnectAddresses)\n         {\n-            OpenNetworkConnection(CAddress(*(vserv.begin())));\n+            CSemaphoreGrant grant(*semOutbound);\n+            OpenNetworkConnection(CAddress(*(vserv.begin())), &grant);\n             Sleep(500);\n             if (fShutdown)\n                 return;\n@@ -1500,7 +1492,8 @@ void ThreadOpenAddedConnections2(void* parg)\n     }\n }\n \n-bool OpenNetworkConnection(const CAddress& addrConnect, const char *strDest, bool fOneShot)\n+// if succesful, this moves the passed grant to the constructed node\n+bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOutbound, const char *strDest, bool fOneShot)\n {\n     //\n     // Initiate outbound network connection\n@@ -1522,6 +1515,8 @@ bool OpenNetworkConnection(const CAddress& addrConnect, const char *strDest, boo\n         return false;\n     if (!pnode)\n         return false;\n+    if (grantOutbound)\n+        grantOutbound->MoveTo(pnode->grantOutbound);\n     pnode->fNetworkNode = true;\n     if (fOneShot)\n         pnode->fOneShot = true;\n@@ -1770,6 +1765,12 @@ void StartNode(void* parg)\n #endif\n #endif\n \n+    if (semOutbound == NULL) {\n+        // initialize semaphore\n+        int nMaxOutbound = min(MAX_OUTBOUND_CONNECTIONS, (int)GetArg(\"-maxconnections\", 125));\n+        semOutbound = new CSemaphore(nMaxOutbound);\n+    }\n+\n     if (pnodeLocalHost == NULL)\n         pnodeLocalHost = new CNode(INVALID_SOCKET, CAddress(CService(\"127.0.0.1\", 0), nLocalServices));\n \n@@ -1823,7 +1824,8 @@ bool StopNode()\n     fShutdown = true;\n     nTransactionsUpdated++;\n     int64 nStart = GetTime();\n-    NOTIFY_ALL(condOutbound);\n+    for (int i=0; i<MAX_OUTBOUND_CONNECTIONS; i++)\n+         semOutbound->post();\n     do\n     {\n         int nThreadsRunning = 0;"
      },
      {
        "sha": "4e4ea31ead87c935367dd0a0b3a66fa40d1e8a6d",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c59abe25892e32c803ec527c40e9a74ab31ea58a/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c59abe25892e32c803ec527c40e9a74ab31ea58a/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=c59abe25892e32c803ec527c40e9a74ab31ea58a",
        "patch": "@@ -147,6 +147,7 @@ class CNode\n     bool fNetworkNode;\n     bool fSuccessfullyConnected;\n     bool fDisconnect;\n+    CSemaphoreGrant grantOutbound;\n protected:\n     int nRefCount;\n "
      },
      {
        "sha": "61ff55353995111f066b3935fa76a047659b2524",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 56,
        "deletions": 15,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c59abe25892e32c803ec527c40e9a74ab31ea58a/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c59abe25892e32c803ec527c40e9a74ab31ea58a/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=c59abe25892e32c803ec527c40e9a74ab31ea58a",
        "patch": "@@ -23,7 +23,7 @@ typedef int pid_t; /* define for windows compatiblity */\n #include <boost/filesystem/path.hpp>\n #include <boost/interprocess/sync/interprocess_recursive_mutex.hpp>\n #include <boost/interprocess/sync/scoped_lock.hpp>\n-#include <boost/interprocess/sync/interprocess_condition.hpp>\n+#include <boost/interprocess/sync/interprocess_semaphore.hpp>\n #include <boost/interprocess/sync/lock_options.hpp>\n #include <boost/date_time/gregorian/gregorian_types.hpp>\n #include <boost/date_time/posix_time/posix_time_types.hpp>\n@@ -275,24 +275,10 @@ class CMutexLock\n };\n \n typedef CMutexLock<CCriticalSection> CCriticalBlock;\n-typedef CMutexLock<CWaitableCriticalSection> CWaitableCriticalBlock;\n-typedef boost::interprocess::interprocess_condition CConditionVariable;\n-\n-/** Wait for a given condition inside a WAITABLE_CRITICAL_BLOCK */\n-#define WAIT(name,condition) \\\n-   do { while(!(condition)) { (name).wait(waitablecriticalblock.GetLock()); } } while(0)\n-\n-/** Notify waiting threads that a condition may hold now */\n-#define NOTIFY(name) \\\n-   do { (name).notify_one(); } while(0)\n-\n-#define NOTIFY_ALL(name) \\\n-   do { (name).notify_all(); } while(0)\n \n #define LOCK(cs) CCriticalBlock criticalblock(cs, #cs, __FILE__, __LINE__)\n #define LOCK2(cs1,cs2) CCriticalBlock criticalblock1(cs1, #cs1, __FILE__, __LINE__),criticalblock2(cs2, #cs2, __FILE__, __LINE__)\n #define TRY_LOCK(cs,name) CCriticalBlock name(cs, #cs, __FILE__, __LINE__, true)\n-#define WAITABLE_LOCK(cs) CWaitableCriticalBlock waitablecriticalblock(cs, #cs, __FILE__, __LINE__)\n \n #define ENTER_CRITICAL_SECTION(cs) \\\n     { \\\n@@ -306,6 +292,61 @@ typedef boost::interprocess::interprocess_condition CConditionVariable;\n         LeaveCritical(); \\\n     }\n \n+typedef boost::interprocess::interprocess_semaphore CSemaphore;\n+\n+/** RAII-style semaphore lock */\n+class CSemaphoreGrant\n+{\n+private:\n+    CSemaphore *sem;\n+    bool fHaveGrant;\n+\n+public:\n+    void Acquire() {\n+        if (fHaveGrant)\n+            return;\n+        sem->wait();\n+        fHaveGrant = true;\n+    }\n+\n+    void Release() {\n+        if (!fHaveGrant)\n+            return;\n+        sem->post();\n+        fHaveGrant = false;\n+    }\n+\n+    bool TryAcquire() {\n+        if (!fHaveGrant && sem->try_wait())\n+            fHaveGrant = true;\n+        return fHaveGrant;\n+    }\n+\n+    void MoveTo(CSemaphoreGrant &grant) {\n+        grant.Release();\n+        grant.sem = sem;\n+        grant.fHaveGrant = fHaveGrant;\n+        sem = NULL;\n+        fHaveGrant = false;\n+    }\n+\n+    CSemaphoreGrant() : sem(NULL), fHaveGrant(false) {}\n+\n+    CSemaphoreGrant(CSemaphore &sema, bool fTry = false) : sem(&sema), fHaveGrant(false) {\n+        if (fTry)\n+            TryAcquire();\n+        else\n+            Acquire();\n+    }\n+\n+    ~CSemaphoreGrant() {\n+        Release();\n+    }\n+\n+    operator bool() {\n+        return fHaveGrant;\n+    }\n+};\n \n inline std::string i64tostr(int64 n)\n {"
      }
    ]
  },
  {
    "sha": "5456ef30926fa38b0d1705f9dcc6aa8def8a802d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1NDU2ZWYzMDkyNmZhMzhiMGQxNzA1ZjlkY2M2YWE4ZGVmOGE4MDJk",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-05-10T18:45:35Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-05-11T15:02:11Z"
      },
      "message": "Use polling instead of boost's broken semaphore on OSX",
      "tree": {
        "sha": "0559266ebfba329c089a77ef9dcd19581fb2770f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0559266ebfba329c089a77ef9dcd19581fb2770f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5456ef30926fa38b0d1705f9dcc6aa8def8a802d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5456ef30926fa38b0d1705f9dcc6aa8def8a802d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5456ef30926fa38b0d1705f9dcc6aa8def8a802d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5456ef30926fa38b0d1705f9dcc6aa8def8a802d/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c59abe25892e32c803ec527c40e9a74ab31ea58a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c59abe25892e32c803ec527c40e9a74ab31ea58a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c59abe25892e32c803ec527c40e9a74ab31ea58a"
      }
    ],
    "stats": {
      "total": 40,
      "additions": 40,
      "deletions": 0
    },
    "files": [
      {
        "sha": "f25a030f1914bb96b65960bf8c0724e0704663ee",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 40,
        "deletions": 0,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5456ef30926fa38b0d1705f9dcc6aa8def8a802d/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5456ef30926fa38b0d1705f9dcc6aa8def8a802d/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=5456ef30926fa38b0d1705f9dcc6aa8def8a802d",
        "patch": "@@ -292,7 +292,47 @@ typedef CMutexLock<CCriticalSection> CCriticalBlock;\n         LeaveCritical(); \\\n     }\n \n+#ifdef MAC_OSX\n+// boost::interprocess::interprocess_semaphore seems to spinlock on OSX; prefer polling instead\n+class CSemaphore\n+{\n+private:\n+    CCriticalSection cs;\n+    int val;\n+\n+public:\n+    CSemaphore(int init) : val(init) {}\n+\n+    void wait() {\n+        do {\n+            {\n+                LOCK(cs);\n+                if (val>0) {\n+                    val--;\n+                    return;\n+                }\n+            }\n+            Sleep(100);\n+        } while(1);\n+    }\n+\n+    bool try_wait() {\n+        LOCK(cs);\n+        if (val>0) {\n+            val--;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    void post() {\n+        LOCK(cs);\n+        val++;\n+    }\n+};\n+#else\n typedef boost::interprocess::interprocess_semaphore CSemaphore;\n+#endif\n \n /** RAII-style semaphore lock */\n class CSemaphoreGrant"
      }
    ]
  },
  {
    "sha": "7f3ccb59da31c7b1706ebfbb401910923221f076",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZjNjY2I1OWRhMzFjN2IxNzA2ZWJmYmI0MDE5MTA5MjMyMjFmMDc2",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-05-11T15:00:03Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-05-11T16:13:51Z"
      },
      "message": "Split synchronization mechanisms from util.{h,cpp}",
      "tree": {
        "sha": "4eaa4921ece1957d014791e52d8e02ccb95a8e2f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4eaa4921ece1957d014791e52d8e02ccb95a8e2f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7f3ccb59da31c7b1706ebfbb401910923221f076",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7f3ccb59da31c7b1706ebfbb401910923221f076",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7f3ccb59da31c7b1706ebfbb401910923221f076",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7f3ccb59da31c7b1706ebfbb401910923221f076/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5456ef30926fa38b0d1705f9dcc6aa8def8a802d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5456ef30926fa38b0d1705f9dcc6aa8def8a802d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5456ef30926fa38b0d1705f9dcc6aa8def8a802d"
      }
    ],
    "stats": {
      "total": 683,
      "additions": 353,
      "deletions": 330
    },
    "files": [
      {
        "sha": "c19fd4e002edc68a6447a9a0b1187dfb0f9bf513",
        "filename": "bitcoin-qt.pro",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f3ccb59da31c7b1706ebfbb401910923221f076/bitcoin-qt.pro",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f3ccb59da31c7b1706ebfbb401910923221f076/bitcoin-qt.pro",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/bitcoin-qt.pro?ref=7f3ccb59da31c7b1706ebfbb401910923221f076",
        "patch": "@@ -109,6 +109,7 @@ HEADERS += src/qt/bitcoingui.h \\\n     src/bignum.h \\\n     src/checkpoints.h \\\n     src/compat.h \\\n+    src/sync.h \\\n     src/util.h \\\n     src/uint256.h \\\n     src/serialize.h \\\n@@ -172,6 +173,7 @@ SOURCES += src/qt/bitcoin.cpp src/qt/bitcoingui.cpp \\\n     src/qt/editaddressdialog.cpp \\\n     src/qt/bitcoinaddressvalidator.cpp \\\n     src/version.cpp \\\n+    src/sync.cpp \\\n     src/util.cpp \\\n     src/netbase.cpp \\\n     src/key.cpp \\"
      },
      {
        "sha": "a1275da2d50d1a61a5fc816b93def5091e754d12",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f3ccb59da31c7b1706ebfbb401910923221f076/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f3ccb59da31c7b1706ebfbb401910923221f076/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=7f3ccb59da31c7b1706ebfbb401910923221f076",
        "patch": "@@ -7,6 +7,7 @@\n #include \"netbase.h\"\n #include \"protocol.h\"\n #include \"util.h\"\n+#include \"sync.h\"\n \n \n #include <map>"
      },
      {
        "sha": "52889b184ee0936e07ba28c2de579b88b004345f",
        "filename": "src/keystore.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f3ccb59da31c7b1706ebfbb401910923221f076/src/keystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f3ccb59da31c7b1706ebfbb401910923221f076/src/keystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.h?ref=7f3ccb59da31c7b1706ebfbb401910923221f076",
        "patch": "@@ -6,7 +6,7 @@\n #define BITCOIN_KEYSTORE_H\n \n #include \"crypter.h\"\n-#include \"util.h\"\n+#include \"sync.h\"\n #include \"base58.h\"\n \n class CScript;"
      },
      {
        "sha": "5ac5547a3e93cb32b79fd742942e41f7103fa2e4",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f3ccb59da31c7b1706ebfbb401910923221f076/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f3ccb59da31c7b1706ebfbb401910923221f076/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=7f3ccb59da31c7b1706ebfbb401910923221f076",
        "patch": "@@ -6,6 +6,7 @@\n #define BITCOIN_MAIN_H\n \n #include \"bignum.h\"\n+#include \"sync.h\"\n #include \"net.h\"\n #include \"script.h\"\n "
      },
      {
        "sha": "cc33bc0bc26568efd4679e1a40f7c3bbe5c3c0d5",
        "filename": "src/makefile.linux-mingw",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f3ccb59da31c7b1706ebfbb401910923221f076/src/makefile.linux-mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f3ccb59da31c7b1706ebfbb401910923221f076/src/makefile.linux-mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.linux-mingw?ref=7f3ccb59da31c7b1706ebfbb401910923221f076",
        "patch": "@@ -61,6 +61,7 @@ OBJS= \\\n     obj/bitcoinrpc.o \\\n     obj/rpcdump.o \\\n     obj/script.o \\\n+    obj/sync.o \\\n     obj/util.o \\\n     obj/wallet.o \\\n     obj/walletdb.o \\"
      },
      {
        "sha": "27d27565066af142d9403f6979e82bad26ca9a74",
        "filename": "src/makefile.mingw",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f3ccb59da31c7b1706ebfbb401910923221f076/src/makefile.mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f3ccb59da31c7b1706ebfbb401910923221f076/src/makefile.mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.mingw?ref=7f3ccb59da31c7b1706ebfbb401910923221f076",
        "patch": "@@ -58,6 +58,7 @@ OBJS= \\\n     obj/bitcoinrpc.o \\\n     obj/rpcdump.o \\\n     obj/script.o \\\n+    obj/sync.o \\\n     obj/util.o \\\n     obj/wallet.o \\\n     obj/walletdb.o \\"
      },
      {
        "sha": "b3afaa8e34ca47bf8da5588e07e51d573bfad28e",
        "filename": "src/makefile.osx",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f3ccb59da31c7b1706ebfbb401910923221f076/src/makefile.osx",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f3ccb59da31c7b1706ebfbb401910923221f076/src/makefile.osx",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.osx?ref=7f3ccb59da31c7b1706ebfbb401910923221f076",
        "patch": "@@ -85,6 +85,7 @@ OBJS= \\\n     obj/bitcoinrpc.o \\\n     obj/rpcdump.o \\\n     obj/script.o \\\n+    obj/sync.o \\\n     obj/util.o \\\n     obj/wallet.o \\\n     obj/walletdb.o \\"
      },
      {
        "sha": "5cbf45e98c666a68b14ba5592734f44b354d7520",
        "filename": "src/makefile.unix",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f3ccb59da31c7b1706ebfbb401910923221f076/src/makefile.unix",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f3ccb59da31c7b1706ebfbb401910923221f076/src/makefile.unix",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.unix?ref=7f3ccb59da31c7b1706ebfbb401910923221f076",
        "patch": "@@ -102,6 +102,7 @@ OBJS= \\\n     obj/bitcoinrpc.o \\\n     obj/rpcdump.o \\\n     obj/script.o \\\n+    obj/sync.o \\\n     obj/util.o \\\n     obj/wallet.o \\\n     obj/walletdb.o \\"
      },
      {
        "sha": "1f895e28ff66e800f929b98fd3d4305d0f743f38",
        "filename": "src/qt/messagepage.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f3ccb59da31c7b1706ebfbb401910923221f076/src/qt/messagepage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f3ccb59da31c7b1706ebfbb401910923221f076/src/qt/messagepage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/messagepage.cpp?ref=7f3ccb59da31c7b1706ebfbb401910923221f076",
        "patch": "@@ -10,7 +10,6 @@\n #include \"main.h\"\n #include \"wallet.h\"\n #include \"init.h\"\n-#include \"util.h\"\n \n #include \"messagepage.h\"\n #include \"ui_messagepage.h\""
      },
      {
        "sha": "06ada5aaca02e2b15e25db42543c865adc9b1e3e",
        "filename": "src/qt/qtipcserver.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f3ccb59da31c7b1706ebfbb401910923221f076/src/qt/qtipcserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f3ccb59da31c7b1706ebfbb401910923221f076/src/qt/qtipcserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/qtipcserver.cpp?ref=7f3ccb59da31c7b1706ebfbb401910923221f076",
        "patch": "@@ -8,7 +8,6 @@\n #include <boost/date_time/posix_time/posix_time.hpp>\n \n #include \"ui_interface.h\"\n-#include \"util.h\"\n #include \"qtipcserver.h\"\n \n using namespace boost::interprocess;"
      },
      {
        "sha": "fd9bcb62bcad9b897e1bda9a3625ab31ed0cc687",
        "filename": "src/sync.cpp",
        "status": "added",
        "additions": 119,
        "deletions": 0,
        "changes": 119,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f3ccb59da31c7b1706ebfbb401910923221f076/src/sync.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f3ccb59da31c7b1706ebfbb401910923221f076/src/sync.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.cpp?ref=7f3ccb59da31c7b1706ebfbb401910923221f076",
        "patch": "@@ -0,0 +1,119 @@\n+// Copyright (c) 2011-2012 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file license.txt or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"sync.h\"\n+\n+\n+\n+#ifdef DEBUG_LOCKORDER\n+//\n+// Early deadlock detection.\n+// Problem being solved:\n+//    Thread 1 locks  A, then B, then C\n+//    Thread 2 locks  D, then C, then A\n+//     --> may result in deadlock between the two threads, depending on when they run.\n+// Solution implemented here:\n+// Keep track of pairs of locks: (A before B), (A before C), etc.\n+// Complain if any thread trys to lock in a different order.\n+//\n+\n+struct CLockLocation\n+{\n+    CLockLocation(const char* pszName, const char* pszFile, int nLine)\n+    {\n+        mutexName = pszName;\n+        sourceFile = pszFile;\n+        sourceLine = nLine;\n+    }\n+\n+    std::string ToString() const\n+    {\n+        return mutexName+\"  \"+sourceFile+\":\"+itostr(sourceLine);\n+    }\n+\n+private:\n+    std::string mutexName;\n+    std::string sourceFile;\n+    int sourceLine;\n+};\n+\n+typedef std::vector< std::pair<void*, CLockLocation> > LockStack;\n+\n+static boost::interprocess::interprocess_mutex dd_mutex;\n+static std::map<std::pair<void*, void*>, LockStack> lockorders;\n+static boost::thread_specific_ptr<LockStack> lockstack;\n+\n+\n+static void potential_deadlock_detected(const std::pair<void*, void*>& mismatch, const LockStack& s1, const LockStack& s2)\n+{\n+    printf(\"POTENTIAL DEADLOCK DETECTED\\n\");\n+    printf(\"Previous lock order was:\\n\");\n+    BOOST_FOREACH(const PAIRTYPE(void*, CLockLocation)& i, s2)\n+    {\n+        if (i.first == mismatch.first) printf(\" (1)\");\n+        if (i.first == mismatch.second) printf(\" (2)\");\n+        printf(\" %s\\n\", i.second.ToString().c_str());\n+    }\n+    printf(\"Current lock order is:\\n\");\n+    BOOST_FOREACH(const PAIRTYPE(void*, CLockLocation)& i, s1)\n+    {\n+        if (i.first == mismatch.first) printf(\" (1)\");\n+        if (i.first == mismatch.second) printf(\" (2)\");\n+        printf(\" %s\\n\", i.second.ToString().c_str());\n+    }\n+}\n+\n+static void push_lock(void* c, const CLockLocation& locklocation, bool fTry)\n+{\n+    bool fOrderOK = true;\n+    if (lockstack.get() == NULL)\n+        lockstack.reset(new LockStack);\n+\n+    if (fDebug) printf(\"Locking: %s\\n\", locklocation.ToString().c_str());\n+    dd_mutex.lock();\n+\n+    (*lockstack).push_back(std::make_pair(c, locklocation));\n+\n+    if (!fTry) BOOST_FOREACH(const PAIRTYPE(void*, CLockLocation)& i, (*lockstack))\n+    {\n+        if (i.first == c) break;\n+\n+        std::pair<void*, void*> p1 = std::make_pair(i.first, c);\n+        if (lockorders.count(p1))\n+            continue;\n+        lockorders[p1] = (*lockstack);\n+\n+        std::pair<void*, void*> p2 = std::make_pair(c, i.first);\n+        if (lockorders.count(p2))\n+        {\n+            potential_deadlock_detected(p1, lockorders[p2], lockorders[p1]);\n+            break;\n+        }\n+    }\n+    dd_mutex.unlock();\n+}\n+\n+static void pop_lock()\n+{\n+    if (fDebug) \n+    {\n+        const CLockLocation& locklocation = (*lockstack).rbegin()->second;\n+        printf(\"Unlocked: %s\\n\", locklocation.ToString().c_str());\n+    }\n+    dd_mutex.lock();\n+    (*lockstack).pop_back();\n+    dd_mutex.unlock();\n+}\n+\n+void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry)\n+{\n+    push_lock(cs, CLockLocation(pszName, pszFile, nLine), fTry);\n+}\n+\n+void LeaveCritical()\n+{\n+    pop_lock();\n+}\n+\n+#endif /* DEBUG_LOCKORDER */"
      },
      {
        "sha": "44d753ac1565b013de00d948f44c5b0e3f304aed",
        "filename": "src/sync.h",
        "status": "added",
        "additions": 216,
        "deletions": 0,
        "changes": 216,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f3ccb59da31c7b1706ebfbb401910923221f076/src/sync.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f3ccb59da31c7b1706ebfbb401910923221f076/src/sync.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.h?ref=7f3ccb59da31c7b1706ebfbb401910923221f076",
        "patch": "@@ -0,0 +1,216 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2012 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file license.txt or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef BITCOIN_SYNC_H\n+#define BITCOIN_SYNC_H\n+\n+#include <boost/interprocess/sync/interprocess_recursive_mutex.hpp>\n+#include <boost/interprocess/sync/scoped_lock.hpp>\n+#include <boost/interprocess/sync/interprocess_semaphore.hpp>\n+#include <boost/interprocess/sync/lock_options.hpp>\n+\n+\n+\n+\n+/** Wrapped boost mutex: supports recursive locking, but no waiting  */\n+typedef boost::interprocess::interprocess_recursive_mutex CCriticalSection;\n+\n+/** Wrapped boost mutex: supports waiting but not recursive locking */\n+typedef boost::interprocess::interprocess_mutex CWaitableCriticalSection;\n+\n+#ifdef DEBUG_LOCKORDER\n+void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false);\n+void LeaveCritical();\n+#else\n+void static inline EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false) {}\n+void static inline LeaveCritical() {}\n+#endif\n+\n+/** Wrapper around boost::interprocess::scoped_lock */\n+template<typename Mutex>\n+class CMutexLock\n+{\n+private:\n+    boost::interprocess::scoped_lock<Mutex> lock;\n+public:\n+\n+    void Enter(const char* pszName, const char* pszFile, int nLine)\n+    {\n+        if (!lock.owns())\n+        {\n+            EnterCritical(pszName, pszFile, nLine, (void*)(lock.mutex()));\n+#ifdef DEBUG_LOCKCONTENTION\n+            if (!lock.try_lock())\n+            {\n+                printf(\"LOCKCONTENTION: %s\\n\", pszName);\n+                printf(\"Locker: %s:%d\\n\", pszFile, nLine);\n+#endif\n+            lock.lock();\n+#ifdef DEBUG_LOCKCONTENTION\n+            }\n+#endif\n+        }\n+    }\n+\n+    void Leave()\n+    {\n+        if (lock.owns())\n+        {\n+            lock.unlock();\n+            LeaveCritical();\n+        }\n+    }\n+\n+    bool TryEnter(const char* pszName, const char* pszFile, int nLine)\n+    {\n+        if (!lock.owns())\n+        {\n+            EnterCritical(pszName, pszFile, nLine, (void*)(lock.mutex()), true);\n+            lock.try_lock();\n+            if (!lock.owns())\n+                LeaveCritical();\n+        }\n+        return lock.owns();\n+    }\n+\n+    CMutexLock(Mutex& mutexIn, const char* pszName, const char* pszFile, int nLine, bool fTry = false) : lock(mutexIn, boost::interprocess::defer_lock)\n+    {\n+        if (fTry)\n+            TryEnter(pszName, pszFile, nLine);\n+        else\n+            Enter(pszName, pszFile, nLine);\n+    }\n+\n+    ~CMutexLock()\n+    {\n+        if (lock.owns())\n+            LeaveCritical();\n+    }\n+\n+    operator bool()\n+    {\n+        return lock.owns();\n+    }\n+\n+    boost::interprocess::scoped_lock<Mutex> &GetLock()\n+    {\n+        return lock;\n+    }\n+};\n+\n+typedef CMutexLock<CCriticalSection> CCriticalBlock;\n+\n+#define LOCK(cs) CCriticalBlock criticalblock(cs, #cs, __FILE__, __LINE__)\n+#define LOCK2(cs1,cs2) CCriticalBlock criticalblock1(cs1, #cs1, __FILE__, __LINE__),criticalblock2(cs2, #cs2, __FILE__, __LINE__)\n+#define TRY_LOCK(cs,name) CCriticalBlock name(cs, #cs, __FILE__, __LINE__, true)\n+\n+#define ENTER_CRITICAL_SECTION(cs) \\\n+    { \\\n+        EnterCritical(#cs, __FILE__, __LINE__, (void*)(&cs)); \\\n+        (cs).lock(); \\\n+    }\n+\n+#define LEAVE_CRITICAL_SECTION(cs) \\\n+    { \\\n+        (cs).unlock(); \\\n+        LeaveCritical(); \\\n+    }\n+\n+#ifdef MAC_OSX\n+// boost::interprocess::interprocess_semaphore seems to spinlock on OSX; prefer polling instead\n+class CSemaphore\n+{\n+private:\n+    CCriticalSection cs;\n+    int val;\n+\n+public:\n+    CSemaphore(int init) : val(init) {}\n+\n+    void wait() {\n+        do {\n+            {\n+                LOCK(cs);\n+                if (val>0) {\n+                    val--;\n+                    return;\n+                }\n+            }\n+            Sleep(100);\n+        } while(1);\n+    }\n+\n+    bool try_wait() {\n+        LOCK(cs);\n+        if (val>0) {\n+            val--;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    void post() {\n+        LOCK(cs);\n+        val++;\n+    }\n+};\n+#else\n+typedef boost::interprocess::interprocess_semaphore CSemaphore;\n+#endif\n+\n+/** RAII-style semaphore lock */\n+class CSemaphoreGrant\n+{\n+private:\n+    CSemaphore *sem;\n+    bool fHaveGrant;\n+\n+public:\n+    void Acquire() {\n+        if (fHaveGrant)\n+            return;\n+        sem->wait();\n+        fHaveGrant = true;\n+    }\n+\n+    void Release() {\n+        if (!fHaveGrant)\n+            return;\n+        sem->post();\n+        fHaveGrant = false;\n+    }\n+\n+    bool TryAcquire() {\n+        if (!fHaveGrant && sem->try_wait())\n+            fHaveGrant = true;\n+        return fHaveGrant;\n+    }\n+\n+    void MoveTo(CSemaphoreGrant &grant) {\n+        grant.Release();\n+        grant.sem = sem;\n+        grant.fHaveGrant = fHaveGrant;\n+        sem = NULL;\n+        fHaveGrant = false;\n+    }\n+\n+    CSemaphoreGrant() : sem(NULL), fHaveGrant(false) {}\n+\n+    CSemaphoreGrant(CSemaphore &sema, bool fTry = false) : sem(&sema), fHaveGrant(false) {\n+        if (fTry)\n+            TryAcquire();\n+        else\n+            Acquire();\n+    }\n+\n+    ~CSemaphoreGrant() {\n+        Release();\n+    }\n+\n+    operator bool() {\n+        return fHaveGrant;\n+    }\n+};\n+#endif\n+"
      },
      {
        "sha": "d2db7cec8f7d8fcaba6d8b44a68c1f267e46c91a",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 123,
        "changes": 132,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f3ccb59da31c7b1706ebfbb401910923221f076/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f3ccb59da31c7b1706ebfbb401910923221f076/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=7f3ccb59da31c7b1706ebfbb401910923221f076",
        "patch": "@@ -4,6 +4,7 @@\n // file license.txt or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"util.h\"\n+#include \"sync.h\"\n #include \"strlcpy.h\"\n #include \"version.h\"\n #include \"ui_interface.h\"\n@@ -23,8 +24,6 @@ namespace boost {\n #include <boost/program_options/parsers.hpp>\n #include <boost/filesystem.hpp>\n #include <boost/filesystem/fstream.hpp>\n-#include <boost/interprocess/sync/interprocess_mutex.hpp>\n-#include <boost/interprocess/sync/interprocess_recursive_mutex.hpp>\n #include <boost/foreach.hpp>\n #include <openssl/crypto.h>\n #include <openssl/rand.h>\n@@ -71,13 +70,14 @@ bool fLogTimestamps = false;\n CMedianFilter<int64> vTimeOffsets(200,0);\n \n // Init openssl library multithreading support\n-static boost::interprocess::interprocess_mutex** ppmutexOpenSSL;\n+static CCriticalSection** ppmutexOpenSSL;\n void locking_callback(int mode, int i, const char* file, int line)\n {\n-    if (mode & CRYPTO_LOCK)\n-        ppmutexOpenSSL[i]->lock();\n-    else\n-        ppmutexOpenSSL[i]->unlock();\n+    if (mode & CRYPTO_LOCK) {\n+        ENTER_CRITICAL_SECTION(*ppmutexOpenSSL[i]);\n+    } else {\n+        LEAVE_CRITICAL_SECTION(*ppmutexOpenSSL[i]);\n+    }\n }\n \n // Init\n@@ -87,9 +87,9 @@ class CInit\n     CInit()\n     {\n         // Init openssl library multithreading support\n-        ppmutexOpenSSL = (boost::interprocess::interprocess_mutex**)OPENSSL_malloc(CRYPTO_num_locks() * sizeof(boost::interprocess::interprocess_mutex*));\n+        ppmutexOpenSSL = (CCriticalSection**)OPENSSL_malloc(CRYPTO_num_locks() * sizeof(CCriticalSection*));\n         for (int i = 0; i < CRYPTO_num_locks(); i++)\n-            ppmutexOpenSSL[i] = new boost::interprocess::interprocess_mutex();\n+            ppmutexOpenSSL[i] = new CCriticalSection();\n         CRYPTO_set_locking_callback(locking_callback);\n \n #ifdef WIN32\n@@ -1221,117 +1221,3 @@ bool GetStartOnSystemStartup() { return false; }\n bool SetStartOnSystemStartup(bool fAutoStart) { return false; }\n \n #endif\n-\n-\n-\n-#ifdef DEBUG_LOCKORDER\n-//\n-// Early deadlock detection.\n-// Problem being solved:\n-//    Thread 1 locks  A, then B, then C\n-//    Thread 2 locks  D, then C, then A\n-//     --> may result in deadlock between the two threads, depending on when they run.\n-// Solution implemented here:\n-// Keep track of pairs of locks: (A before B), (A before C), etc.\n-// Complain if any thread trys to lock in a different order.\n-//\n-\n-struct CLockLocation\n-{\n-    CLockLocation(const char* pszName, const char* pszFile, int nLine)\n-    {\n-        mutexName = pszName;\n-        sourceFile = pszFile;\n-        sourceLine = nLine;\n-    }\n-\n-    std::string ToString() const\n-    {\n-        return mutexName+\"  \"+sourceFile+\":\"+itostr(sourceLine);\n-    }\n-\n-private:\n-    std::string mutexName;\n-    std::string sourceFile;\n-    int sourceLine;\n-};\n-\n-typedef std::vector< std::pair<void*, CLockLocation> > LockStack;\n-\n-static boost::interprocess::interprocess_mutex dd_mutex;\n-static std::map<std::pair<void*, void*>, LockStack> lockorders;\n-static boost::thread_specific_ptr<LockStack> lockstack;\n-\n-\n-static void potential_deadlock_detected(const std::pair<void*, void*>& mismatch, const LockStack& s1, const LockStack& s2)\n-{\n-    printf(\"POTENTIAL DEADLOCK DETECTED\\n\");\n-    printf(\"Previous lock order was:\\n\");\n-    BOOST_FOREACH(const PAIRTYPE(void*, CLockLocation)& i, s2)\n-    {\n-        if (i.first == mismatch.first) printf(\" (1)\");\n-        if (i.first == mismatch.second) printf(\" (2)\");\n-        printf(\" %s\\n\", i.second.ToString().c_str());\n-    }\n-    printf(\"Current lock order is:\\n\");\n-    BOOST_FOREACH(const PAIRTYPE(void*, CLockLocation)& i, s1)\n-    {\n-        if (i.first == mismatch.first) printf(\" (1)\");\n-        if (i.first == mismatch.second) printf(\" (2)\");\n-        printf(\" %s\\n\", i.second.ToString().c_str());\n-    }\n-}\n-\n-static void push_lock(void* c, const CLockLocation& locklocation, bool fTry)\n-{\n-    bool fOrderOK = true;\n-    if (lockstack.get() == NULL)\n-        lockstack.reset(new LockStack);\n-\n-    if (fDebug) printf(\"Locking: %s\\n\", locklocation.ToString().c_str());\n-    dd_mutex.lock();\n-\n-    (*lockstack).push_back(std::make_pair(c, locklocation));\n-\n-    if (!fTry) BOOST_FOREACH(const PAIRTYPE(void*, CLockLocation)& i, (*lockstack))\n-    {\n-        if (i.first == c) break;\n-\n-        std::pair<void*, void*> p1 = std::make_pair(i.first, c);\n-        if (lockorders.count(p1))\n-            continue;\n-        lockorders[p1] = (*lockstack);\n-\n-        std::pair<void*, void*> p2 = std::make_pair(c, i.first);\n-        if (lockorders.count(p2))\n-        {\n-            potential_deadlock_detected(p1, lockorders[p2], lockorders[p1]);\n-            break;\n-        }\n-    }\n-    dd_mutex.unlock();\n-}\n-\n-static void pop_lock()\n-{\n-    if (fDebug) \n-    {\n-        const CLockLocation& locklocation = (*lockstack).rbegin()->second;\n-        printf(\"Unlocked: %s\\n\", locklocation.ToString().c_str());\n-    }\n-    dd_mutex.lock();\n-    (*lockstack).pop_back();\n-    dd_mutex.unlock();\n-}\n-\n-void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry)\n-{\n-    push_lock(cs, CLockLocation(pszName, pszFile, nLine), fTry);\n-}\n-\n-void LeaveCritical()\n-{\n-    pop_lock();\n-}\n-\n-#endif /* DEBUG_LOCKORDER */"
      },
      {
        "sha": "1363fbbbf9a89fca848695022b122819f5987f81",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 0,
        "deletions": 204,
        "changes": 204,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f3ccb59da31c7b1706ebfbb401910923221f076/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f3ccb59da31c7b1706ebfbb401910923221f076/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=7f3ccb59da31c7b1706ebfbb401910923221f076",
        "patch": "@@ -21,10 +21,6 @@ typedef int pid_t; /* define for windows compatiblity */\n #include <boost/thread.hpp>\n #include <boost/filesystem.hpp>\n #include <boost/filesystem/path.hpp>\n-#include <boost/interprocess/sync/interprocess_recursive_mutex.hpp>\n-#include <boost/interprocess/sync/scoped_lock.hpp>\n-#include <boost/interprocess/sync/interprocess_semaphore.hpp>\n-#include <boost/interprocess/sync/lock_options.hpp>\n #include <boost/date_time/gregorian/gregorian_types.hpp>\n #include <boost/date_time/posix_time/posix_time_types.hpp>\n \n@@ -188,206 +184,6 @@ void AddTimeData(const CNetAddr& ip, int64 nTime);\n \n \n \n-/** Wrapped boost mutex: supports recursive locking, but no waiting  */\n-typedef boost::interprocess::interprocess_recursive_mutex CCriticalSection;\n-\n-/** Wrapped boost mutex: supports waiting but not recursive locking */\n-typedef boost::interprocess::interprocess_mutex CWaitableCriticalSection;\n-\n-#ifdef DEBUG_LOCKORDER\n-void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false);\n-void LeaveCritical();\n-#else\n-void static inline EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false) {}\n-void static inline LeaveCritical() {}\n-#endif\n-\n-/** Wrapper around boost::interprocess::scoped_lock */\n-template<typename Mutex>\n-class CMutexLock\n-{\n-private:\n-    boost::interprocess::scoped_lock<Mutex> lock;\n-public:\n-\n-    void Enter(const char* pszName, const char* pszFile, int nLine)\n-    {\n-        if (!lock.owns())\n-        {\n-            EnterCritical(pszName, pszFile, nLine, (void*)(lock.mutex()));\n-#ifdef DEBUG_LOCKCONTENTION\n-            if (!lock.try_lock())\n-            {\n-                printf(\"LOCKCONTENTION: %s\\n\", pszName);\n-                printf(\"Locker: %s:%d\\n\", pszFile, nLine);\n-#endif\n-            lock.lock();\n-#ifdef DEBUG_LOCKCONTENTION\n-            }\n-#endif\n-        }\n-    }\n-\n-    void Leave()\n-    {\n-        if (lock.owns())\n-        {\n-            lock.unlock();\n-            LeaveCritical();\n-        }\n-    }\n-\n-    bool TryEnter(const char* pszName, const char* pszFile, int nLine)\n-    {\n-        if (!lock.owns())\n-        {\n-            EnterCritical(pszName, pszFile, nLine, (void*)(lock.mutex()), true);\n-            lock.try_lock();\n-            if (!lock.owns())\n-                LeaveCritical();\n-        }\n-        return lock.owns();\n-    }\n-\n-    CMutexLock(Mutex& mutexIn, const char* pszName, const char* pszFile, int nLine, bool fTry = false) : lock(mutexIn, boost::interprocess::defer_lock)\n-    {\n-        if (fTry)\n-            TryEnter(pszName, pszFile, nLine);\n-        else\n-            Enter(pszName, pszFile, nLine);\n-    }\n-\n-    ~CMutexLock()\n-    {\n-        if (lock.owns())\n-            LeaveCritical();\n-    }\n-\n-    operator bool()\n-    {\n-        return lock.owns();\n-    }\n-\n-    boost::interprocess::scoped_lock<Mutex> &GetLock()\n-    {\n-        return lock;\n-    }\n-};\n-\n-typedef CMutexLock<CCriticalSection> CCriticalBlock;\n-\n-#define LOCK(cs) CCriticalBlock criticalblock(cs, #cs, __FILE__, __LINE__)\n-#define LOCK2(cs1,cs2) CCriticalBlock criticalblock1(cs1, #cs1, __FILE__, __LINE__),criticalblock2(cs2, #cs2, __FILE__, __LINE__)\n-#define TRY_LOCK(cs,name) CCriticalBlock name(cs, #cs, __FILE__, __LINE__, true)\n-\n-#define ENTER_CRITICAL_SECTION(cs) \\\n-    { \\\n-        EnterCritical(#cs, __FILE__, __LINE__, (void*)(&cs)); \\\n-        (cs).lock(); \\\n-    }\n-\n-#define LEAVE_CRITICAL_SECTION(cs) \\\n-    { \\\n-        (cs).unlock(); \\\n-        LeaveCritical(); \\\n-    }\n-\n-#ifdef MAC_OSX\n-// boost::interprocess::interprocess_semaphore seems to spinlock on OSX; prefer polling instead\n-class CSemaphore\n-{\n-private:\n-    CCriticalSection cs;\n-    int val;\n-\n-public:\n-    CSemaphore(int init) : val(init) {}\n-\n-    void wait() {\n-        do {\n-            {\n-                LOCK(cs);\n-                if (val>0) {\n-                    val--;\n-                    return;\n-                }\n-            }\n-            Sleep(100);\n-        } while(1);\n-    }\n-\n-    bool try_wait() {\n-        LOCK(cs);\n-        if (val>0) {\n-            val--;\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    void post() {\n-        LOCK(cs);\n-        val++;\n-    }\n-};\n-#else\n-typedef boost::interprocess::interprocess_semaphore CSemaphore;\n-#endif\n-\n-/** RAII-style semaphore lock */\n-class CSemaphoreGrant\n-{\n-private:\n-    CSemaphore *sem;\n-    bool fHaveGrant;\n-\n-public:\n-    void Acquire() {\n-        if (fHaveGrant)\n-            return;\n-        sem->wait();\n-        fHaveGrant = true;\n-    }\n-\n-    void Release() {\n-        if (!fHaveGrant)\n-            return;\n-        sem->post();\n-        fHaveGrant = false;\n-    }\n-\n-    bool TryAcquire() {\n-        if (!fHaveGrant && sem->try_wait())\n-            fHaveGrant = true;\n-        return fHaveGrant;\n-    }\n-\n-    void MoveTo(CSemaphoreGrant &grant) {\n-        grant.Release();\n-        grant.sem = sem;\n-        grant.fHaveGrant = fHaveGrant;\n-        sem = NULL;\n-        fHaveGrant = false;\n-    }\n-\n-    CSemaphoreGrant() : sem(NULL), fHaveGrant(false) {}\n-\n-    CSemaphoreGrant(CSemaphore &sema, bool fTry = false) : sem(&sema), fHaveGrant(false) {\n-        if (fTry)\n-            TryAcquire();\n-        else\n-            Acquire();\n-    }\n-\n-    ~CSemaphoreGrant() {\n-        Release();\n-    }\n-\n-    operator bool() {\n-        return fHaveGrant;\n-    }\n-};\n-\n inline std::string i64tostr(int64 n)\n {\n     return strprintf(\"%\"PRI64d, n);"
      }
    ]
  }
]