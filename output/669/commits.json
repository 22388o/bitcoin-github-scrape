[
  {
    "sha": "7e55c1ab650163011a690daf74cb1cc89bdd563b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZTU1YzFhYjY1MDE2MzAxMWE2OTBkYWY3NGNiMWNjODliZGQ1NjNi",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-09-29T13:46:52Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-12-19T17:39:47Z"
      },
      "message": "Collapse no-op ExtractAddress/ExtractAddressInner",
      "tree": {
        "sha": "497906b6cc9da65ca250e718c1c729f853b7ca1f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/497906b6cc9da65ca250e718c1c729f853b7ca1f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7e55c1ab650163011a690daf74cb1cc89bdd563b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7e55c1ab650163011a690daf74cb1cc89bdd563b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7e55c1ab650163011a690daf74cb1cc89bdd563b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7e55c1ab650163011a690daf74cb1cc89bdd563b/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "99a289f531e9dc42aa81ea32ff84b807a46b6a9c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/99a289f531e9dc42aa81ea32ff84b807a46b6a9c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/99a289f531e9dc42aa81ea32ff84b807a46b6a9c"
      }
    ],
    "stats": {
      "total": 11,
      "additions": 1,
      "deletions": 10
    },
    "files": [
      {
        "sha": "4b2dc9a1a6e3c8f17a2e5e3bb19b74e34291bbf5",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 10,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7e55c1ab650163011a690daf74cb1cc89bdd563b/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7e55c1ab650163011a690daf74cb1cc89bdd563b/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=7e55c1ab650163011a690daf74cb1cc89bdd563b",
        "patch": "@@ -1117,7 +1117,7 @@ bool IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n     return true;\n }\n \n-bool static ExtractAddressInner(const CScript& scriptPubKey, const CKeyStore* keystore, CBitcoinAddress& addressRet)\n+bool ExtractAddress(const CScript& scriptPubKey, const CKeyStore* keystore, CBitcoinAddress& addressRet)\n {\n     vector<pair<opcodetype, valtype> > vSolution;\n     if (!Solver(scriptPubKey, vSolution))\n@@ -1137,15 +1137,6 @@ bool static ExtractAddressInner(const CScript& scriptPubKey, const CKeyStore* ke\n }\n \n \n-bool ExtractAddress(const CScript& scriptPubKey, const CKeyStore* keystore, CBitcoinAddress& addressRet)\n-{\n-    if (keystore)\n-        return ExtractAddressInner(scriptPubKey, keystore, addressRet);\n-    else\n-        return ExtractAddressInner(scriptPubKey, NULL, addressRet);\n-    return false;\n-}\n-\n \n bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, int nHashType)\n {"
      }
    ]
  },
  {
    "sha": "1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxNDY2YjhiNzhhZDhjYWJmOTNhYzNmNjVmNTkyOTIxM2M1ZGQzYzhm",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-10-11T23:50:06Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-12-19T17:39:47Z"
      },
      "message": "Rework unit tests so test_bitcoin.cpp does not #include them all",
      "tree": {
        "sha": "0dc75b665913468ec2f81ab08b934e29b0e7b088",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0dc75b665913468ec2f81ab08b934e29b0e7b088"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7e55c1ab650163011a690daf74cb1cc89bdd563b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7e55c1ab650163011a690daf74cb1cc89bdd563b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7e55c1ab650163011a690daf74cb1cc89bdd563b"
      }
    ],
    "stats": {
      "total": 67,
      "additions": 34,
      "deletions": 33
    },
    "files": [
      {
        "sha": "bd72e6bc0324ba8de047ddc8759369c6328bc4e8",
        "filename": "src/makefile.osx",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f/src/makefile.osx",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f/src/makefile.osx",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.osx?ref=1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f",
        "patch": "@@ -10,6 +10,7 @@ CXX=llvm-g++\n DEPSDIR=/opt/local\n \n INCLUDEPATHS= \\\n+ -I\"$(CURDIR)\" \\\n  -I\"$(DEPSDIR)/include\" \\\n  -I\"$(DEPSDIR)/include/db48\"\n \n@@ -112,14 +113,16 @@ obj/nogui/%.o: %.cpp\n bitcoind: $(OBJS:obj/%=obj/nogui/%)\n \t$(CXX) $(CFLAGS) -o $@ $(LIBPATHS) $^ $(LIBS)\n \n+TESTOBJS := $(patsubst test/%.cpp,obj/test/%.o,$(wildcard test/*.cpp))\n+\n obj/test/%.o: test/%.cpp\n \t$(CXX) -c $(CFLAGS) -MMD -o $@ $<\n \t@cp $(@:%.o=%.d) $(@:%.o=%.P); \\\n \t  sed -e 's/#.*//' -e 's/^[^:]*: *//' -e 's/ *\\\\$$//' \\\n \t      -e '/^$$/ d' -e 's/$$/ :/' < $(@:%.o=%.d) >> $(@:%.o=%.P); \\\n \t  rm -f $(@:%.o=%.d)\n \n-test_bitcoin: obj/test/test_bitcoin.o $(filter-out obj/nogui/init.o,$(OBJS:obj/%=obj/nogui/%))\n+test_bitcoin: $(TESTOBJS) $(filter-out obj/nogui/init.o,$(OBJS:obj/%=obj/nogui/%))\n \t$(CXX) $(CFLAGS) -o $@ $(LIBPATHS) $^ $(LIBS) $(DEPSDIR)/lib/libboost_unit_test_framework-mt.a\n \n clean:"
      },
      {
        "sha": "055f7ab297c849654692892d7726f8b1dba3616c",
        "filename": "src/makefile.unix",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f/src/makefile.unix",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f/src/makefile.unix",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.unix?ref=1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f",
        "patch": "@@ -6,7 +6,7 @@ USE_UPNP:=0\n \n DEFS=-DNOPCH\n \n-DEFS += $(addprefix -I,$(BOOST_INCLUDE_PATH) $(BDB_INCLUDE_PATH) $(OPENSSL_INCLUDE_PATH))\n+DEFS += $(addprefix -I,$(CURDIR) $(BOOST_INCLUDE_PATH) $(BDB_INCLUDE_PATH) $(OPENSSL_INCLUDE_PATH))\n LIBS += $(addprefix -l,$(BOOST_LIB_PATH) $(BDB_LIB_PATH) $(OPENSSL_LIB_PATH))\n \n LMODE = dynamic\n@@ -141,14 +141,16 @@ obj/nogui/%.o: %.cpp\n bitcoind: $(OBJS:obj/%=obj/nogui/%)\n \t$(CXX) $(xCXXFLAGS) -o $@ $^ $(LDFLAGS) $(LIBS)\n \n+TESTOBJS := $(patsubst test/%.cpp,obj/test/%.o,$(wildcard test/*.cpp))\n+\n obj/test/%.o: test/%.cpp\n \t$(CXX) -c $(xCXXFLAGS) -MMD -o $@ $<\n \t@cp $(@:%.o=%.d) $(@:%.o=%.P); \\\n \t  sed -e 's/#.*//' -e 's/^[^:]*: *//' -e 's/ *\\\\$$//' \\\n \t      -e '/^$$/ d' -e 's/$$/ :/' < $(@:%.o=%.d) >> $(@:%.o=%.P); \\\n \t  rm -f $(@:%.o=%.d)\n \n-test_bitcoin: obj/test/test_bitcoin.o $(filter-out obj/nogui/init.o,$(OBJS:obj/%=obj/nogui/%))\n+test_bitcoin: $(TESTOBJS) $(filter-out obj/nogui/init.o,$(OBJS:obj/%=obj/nogui/%))\n \t$(CXX) $(xCXXFLAGS) -o $@ $(LIBPATHS) $^ -Wl,-Bstatic -lboost_unit_test_framework $(LDFLAGS) $(LIBS)\n \n clean:"
      },
      {
        "sha": "e9b7b4517aeeb36e8293516cdcc5187fded01310",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f",
        "patch": "@@ -5,9 +5,10 @@\n #include <boost/test/unit_test.hpp>\n #include <boost/foreach.hpp>\n \n-#include \"../main.h\"\n-#include \"../net.h\"\n-#include \"../util.h\"\n+#include \"main.h\"\n+#include \"wallet.h\"\n+#include \"net.h\"\n+#include \"util.h\"\n \n using namespace std;\n "
      },
      {
        "sha": "d52ac7498256654306f65e26c271c09acfa555b4",
        "filename": "src/test/base58_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f/src/test/base58_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f/src/test/base58_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/base58_tests.cpp?ref=1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f",
        "patch": "@@ -1,6 +1,8 @@\n #include <boost/test/unit_test.hpp>\n \n-#include \"../util.h\"\n+#include \"main.h\"\n+#include \"wallet.h\"\n+#include \"util.h\"\n \n BOOST_AUTO_TEST_SUITE(base58_tests)\n "
      },
      {
        "sha": "fff30ef5eb6b05df178e6c15872b0fbff0db60d7",
        "filename": "src/test/base64_tests.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 5,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f/src/test/base64_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f/src/test/base64_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/base64_tests.cpp?ref=1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f",
        "patch": "@@ -1,18 +1,20 @@\n #include <boost/test/unit_test.hpp>\n \n-#include \"../util.h\"\n+#include \"main.h\"\n+#include \"wallet.h\"\n+#include \"util.h\"\n \n BOOST_AUTO_TEST_SUITE(base64_tests)\n \n BOOST_AUTO_TEST_CASE(base64_testvectors)\n {\n-    static const string vstrIn[]  = {\"\",\"f\",\"fo\",\"foo\",\"foob\",\"fooba\",\"foobar\"};\n-    static const string vstrOut[] = {\"\",\"Zg==\",\"Zm8=\",\"Zm9v\",\"Zm9vYg==\",\"Zm9vYmE=\",\"Zm9vYmFy\"};\n+    static const std::string vstrIn[]  = {\"\",\"f\",\"fo\",\"foo\",\"foob\",\"fooba\",\"foobar\"};\n+    static const std::string vstrOut[] = {\"\",\"Zg==\",\"Zm8=\",\"Zm9v\",\"Zm9vYg==\",\"Zm9vYmE=\",\"Zm9vYmFy\"};\n     for (int i=0; i<sizeof(vstrIn)/sizeof(vstrIn[0]); i++)\n     {\n-        string strEnc = EncodeBase64(vstrIn[i]);\n+        std::string strEnc = EncodeBase64(vstrIn[i]);\n         BOOST_CHECK(strEnc == vstrOut[i]);\n-        string strDec = DecodeBase64(strEnc);\n+        std::string strDec = DecodeBase64(strEnc);\n         BOOST_CHECK(strDec == vstrIn[i]);\n     }\n }"
      },
      {
        "sha": "d4abd6d2a7e90fdae8cc88e7bd721bfcc33b6e91",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f",
        "patch": "@@ -1,6 +1,6 @@\n #include <boost/test/unit_test.hpp>\n \n-#include \"../uint256.h\"\n+#include \"uint256.h\"\n \n extern void SHA256Transform(void* pstate, void* pinput, const void* pinit);\n "
      },
      {
        "sha": "f3fa5c3a1b2cae8ce179aca02b6646aabbf006e0",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f",
        "patch": "@@ -2,8 +2,8 @@\n #include <boost/test/unit_test.hpp>\n #include <boost/foreach.hpp>\n \n-#include \"../main.h\"\n-#include \"../wallet.h\"\n+#include \"main.h\"\n+#include \"wallet.h\"\n \n using namespace std;\n extern uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);"
      },
      {
        "sha": "c7f45a0877fe9b5c3bfc8bfb3cac3cccd6f863bc",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 13,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f",
        "patch": "@@ -1,19 +1,8 @@\n #define BOOST_TEST_MODULE Bitcoin Test Suite\n #include <boost/test/unit_test.hpp>\n \n-#include \"../main.h\"\n-#include \"../wallet.h\"\n-\n-#include \"uint160_tests.cpp\"\n-#include \"uint256_tests.cpp\"\n-#include \"script_tests.cpp\"\n-#include \"transaction_tests.cpp\"\n-#include \"DoS_tests.cpp\"\n-#include \"base64_tests.cpp\"\n-#include \"util_tests.cpp\"\n-#include \"base58_tests.cpp\"\n-#include \"miner_tests.cpp\"\n-#include \"Checkpoints_tests.cpp\"\n+#include \"main.h\"\n+#include \"wallet.h\"\n \n CWallet* pwalletMain;\n "
      },
      {
        "sha": "3268343bbe12cbbcf34795e46da56392b82cdc62",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f",
        "patch": "@@ -1,7 +1,7 @@\n #include <boost/test/unit_test.hpp>\n \n-#include \"../main.h\"\n-#include \"../wallet.h\"\n+#include \"main.h\"\n+#include \"wallet.h\"\n \n using namespace std;\n "
      },
      {
        "sha": "35cb35b25ad07fc34a90692ac971cd2e4ced5a09",
        "filename": "src/test/uint160_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f/src/test/uint160_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f/src/test/uint160_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/uint160_tests.cpp?ref=1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f",
        "patch": "@@ -1,6 +1,6 @@\n #include <boost/test/unit_test.hpp>\n \n-#include \"../uint256.h\"\n+#include \"uint256.h\"\n \n BOOST_AUTO_TEST_SUITE(uint160_tests)\n "
      },
      {
        "sha": "efdc8a6aeb77ffff72ca2e2fb312240c5559e27c",
        "filename": "src/test/uint256_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f/src/test/uint256_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f/src/test/uint256_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/uint256_tests.cpp?ref=1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f",
        "patch": "@@ -1,6 +1,6 @@\n #include <boost/test/unit_test.hpp>\n \n-#include \"../uint256.h\"\n+#include \"uint256.h\"\n \n BOOST_AUTO_TEST_SUITE(uint256_tests)\n "
      },
      {
        "sha": "9571c4738269f9ea86a126ba916dc948a0ab6c70",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f",
        "patch": "@@ -2,7 +2,9 @@\n #include <boost/test/unit_test.hpp>\n #include <boost/foreach.hpp>\n \n-#include \"../util.h\"\n+#include \"main.h\"\n+#include \"wallet.h\"\n+#include \"util.h\"\n \n using namespace std;\n "
      }
    ]
  },
  {
    "sha": "bf798734db4539a39edd6badf54a1c3aecf193e5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiZjc5ODczNGRiNDUzOWEzOWVkZDZiYWRmNTRhMWMzYWVjZjE5M2U1",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-09-28T16:30:06Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-12-19T17:40:19Z"
      },
      "message": "Support 3 new multisignature IsStandard transactions\n\nInitial support for (a and b), (a or b), and 2-of-3 escrow\ntransactions (where a, b, and c are keys).",
      "tree": {
        "sha": "850f60c149335de2c85c0aafd10a8fc50aca9c7e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/850f60c149335de2c85c0aafd10a8fc50aca9c7e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bf798734db4539a39edd6badf54a1c3aecf193e5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bf798734db4539a39edd6badf54a1c3aecf193e5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bf798734db4539a39edd6badf54a1c3aecf193e5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bf798734db4539a39edd6badf54a1c3aecf193e5/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1466b8b78ad8cabf93ac3f65f5929213c5dd3c8f"
      }
    ],
    "stats": {
      "total": 663,
      "additions": 575,
      "deletions": 88
    },
    "files": [
      {
        "sha": "122bf61b8fc2874ef4aa610dcc7e5cf62a2afb63",
        "filename": "src/bitcoinrpc.cpp",
        "status": "modified",
        "additions": 117,
        "deletions": 1,
        "changes": 118,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bf798734db4539a39edd6badf54a1c3aecf193e5/src/bitcoinrpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bf798734db4539a39edd6badf54a1c3aecf193e5/src/bitcoinrpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.cpp?ref=bf798734db4539a39edd6badf54a1c3aecf193e5",
        "patch": "@@ -936,6 +936,101 @@ Value sendmany(const Array& params, bool fHelp)\n     return wtx.GetHash().GetHex();\n }\n \n+Value sendmultisig(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 4 || params.size() > 7)\n+    {\n+        string msg = \"sendmultisig <fromaccount> <type> <[\\\"key\\\",\\\"key\\\"]> <amount> [minconf=1] [comment] [comment-to]\\n\"\n+            \"<type> is one of: \\\"and\\\", \\\"or\\\", \\\"escrow\\\"\\n\"\n+            \"<keys> is an array of strings (in JSON array format); each key is a bitcoin address, hex or base58 public key\\n\"\n+            \"<amount> is a real and is rounded to the nearest 0.00000001\";\n+        if (pwalletMain->IsCrypted())\n+            msg += \"\\nrequires wallet passphrase to be set with walletpassphrase first\";\n+        throw runtime_error(msg);\n+    }\n+\n+    string strAccount = AccountFromValue(params[0]);\n+    string strType = params[1].get_str();\n+    const Array& keys = params[2].get_array();\n+    int64 nAmount = AmountFromValue(params[3]);\n+    int nMinDepth = 1;\n+    if (params.size() > 4)\n+        nMinDepth = params[4].get_int();\n+\n+    CWalletTx wtx;\n+    wtx.strFromAccount = strAccount;\n+    if (params.size() > 5 && params[5].type() != null_type && !params[5].get_str().empty())\n+        wtx.mapValue[\"comment\"] = params[5].get_str();\n+    if (params.size() > 6 && params[6].type() != null_type && !params[6].get_str().empty())\n+        wtx.mapValue[\"to\"]      = params[6].get_str();\n+\n+    if (pwalletMain->IsLocked())\n+        throw JSONRPCError(-13, \"Error: Please enter the wallet passphrase with walletpassphrase first.\");\n+\n+    // Check funds\n+    int64 nBalance = GetAccountBalance(strAccount, nMinDepth);\n+    if (nAmount > nBalance)\n+        throw JSONRPCError(-6, \"Account has insufficient funds\");\n+\n+    // Gather public keys\n+    int nKeysNeeded = 0;\n+    if (strType == \"and\" || strType == \"or\")\n+        nKeysNeeded = 2;\n+    else if (strType == \"escrow\")\n+        nKeysNeeded = 3;\n+    else\n+        throw runtime_error(\"sendmultisig: <type> must be one of: and or and_or\");\n+    if (keys.size() != nKeysNeeded)\n+        throw runtime_error(\n+            strprintf(\"sendmultisig: wrong number of keys (got %d, need %d)\", keys.size(), nKeysNeeded));\n+    std::vector<CKey> pubkeys;\n+    pubkeys.resize(nKeysNeeded);\n+    for (int i = 0; i < nKeysNeeded; i++)\n+    {\n+        const std::string& ks = keys[i].get_str();\n+        if (ks.size() == 130) // hex public key\n+            pubkeys[i].SetPubKey(ParseHex(ks));\n+        else if (ks.size() > 34) // base58-encoded\n+        {\n+            std::vector<unsigned char> vchPubKey;\n+            if (DecodeBase58(ks, vchPubKey))\n+                pubkeys[i].SetPubKey(vchPubKey);\n+            else\n+                throw runtime_error(\"Error base58 decoding key: \"+ks);\n+        }\n+        else // bitcoin address for key in this wallet\n+        {\n+            CBitcoinAddress address(ks);\n+            if (!pwalletMain->GetKey(address, pubkeys[i]))\n+                throw runtime_error(\n+                    strprintf(\"sendmultisig: unknown address: %s\",ks.c_str()));\n+        }\n+    }\n+\n+    // Send\n+    CScript scriptPubKey;\n+    if (strType == \"and\")\n+        scriptPubKey.SetMultisigAnd(pubkeys);\n+    else if (strType == \"or\")\n+        scriptPubKey.SetMultisigOr(pubkeys);\n+    else\n+        scriptPubKey.SetMultisigEscrow(pubkeys);\n+\n+    CReserveKey keyChange(pwalletMain);\n+    int64 nFeeRequired = 0;\n+    bool fCreated = pwalletMain->CreateTransaction(scriptPubKey, nAmount, wtx, keyChange, nFeeRequired);\n+    if (!fCreated)\n+    {\n+        if (nAmount + nFeeRequired > pwalletMain->GetBalance())\n+            throw JSONRPCError(-6, \"Insufficient funds\");\n+        throw JSONRPCError(-4, \"Transaction creation failed\");\n+    }\n+    if (!pwalletMain->CommitTransaction(wtx, keyChange))\n+        throw JSONRPCError(-4, \"Transaction commit failed\");\n+\n+    return wtx.GetHash().GetHex();\n+}\n+\n \n struct tallyitem\n {\n@@ -1596,7 +1691,17 @@ Value validateaddress(const Array& params, bool fHelp)\n         // version of the address:\n         string currentAddress = address.ToString();\n         ret.push_back(Pair(\"address\", currentAddress));\n-        ret.push_back(Pair(\"ismine\", (pwalletMain->HaveKey(address) > 0)));\n+        if (pwalletMain->HaveKey(address))\n+        {\n+            ret.push_back(Pair(\"ismine\", true));\n+            std::vector<unsigned char> vchPubKey;\n+            pwalletMain->GetPubKey(address, vchPubKey);\n+            ret.push_back(Pair(\"pubkey\", HexStr(vchPubKey)));\n+            std::string strPubKey(vchPubKey.begin(), vchPubKey.end());\n+            ret.push_back(Pair(\"pubkey58\", EncodeBase58(vchPubKey)));\n+        }\n+        else\n+            ret.push_back(Pair(\"ismine\", false));\n         if (pwalletMain->mapAddressBook.count(address))\n             ret.push_back(Pair(\"account\", pwalletMain->mapAddressBook[address]));\n     }\n@@ -1841,6 +1946,7 @@ pair<string, rpcfn_type> pCallTable[] =\n     make_pair(\"move\",                   &movecmd),\n     make_pair(\"sendfrom\",               &sendfrom),\n     make_pair(\"sendmany\",               &sendmany),\n+    make_pair(\"sendmultisig\",           &sendmultisig),\n     make_pair(\"gettransaction\",         &gettransaction),\n     make_pair(\"listtransactions\",       &listtransactions),\n     make_pair(\"signmessage\",            &signmessage),\n@@ -2484,6 +2590,16 @@ int CommandLineRPC(int argc, char *argv[])\n             params[1] = v.get_obj();\n         }\n         if (strMethod == \"sendmany\"                && n > 2) ConvertTo<boost::int64_t>(params[2]);\n+        if (strMethod == \"sendmultisig\"            && n > 2)\n+        {\n+            string s = params[2].get_str();\n+            Value v;\n+            if (!read_string(s, v) || v.type() != array_type)\n+                throw runtime_error(\"sendmultisig: type mismatch \"+s);\n+            params[2] = v.get_array();\n+        }\n+        if (strMethod == \"sendmultisig\"            && n > 3) ConvertTo<double>(params[3]);\n+        if (strMethod == \"sendmultisig\"            && n > 4) ConvertTo<boost::int64_t>(params[4]);\n \n         // Execute\n         Object reply = CallRPC(strMethod, params);"
      },
      {
        "sha": "6a7913b0d543816d6a41cf7f018c6237d053918a",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 156,
        "deletions": 67,
        "changes": 223,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bf798734db4539a39edd6badf54a1c3aecf193e5/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bf798734db4539a39edd6badf54a1c3aecf193e5/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=bf798734db4539a39edd6badf54a1c3aecf193e5",
        "patch": "@@ -963,8 +963,11 @@ bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CSc\n \n \n \n-\n-bool Solver(const CScript& scriptPubKey, vector<pair<opcodetype, valtype> >& vSolutionRet)\n+//\n+// Returns lists of public keys (or public key hashes), any one of which can\n+// satisfy scriptPubKey\n+//\n+bool Solver(const CScript& scriptPubKey, vector<vector<pair<opcodetype, valtype> > >& vSolutionsRet)\n {\n     // Templates\n     static vector<CScript> vTemplates;\n@@ -975,13 +978,24 @@ bool Solver(const CScript& scriptPubKey, vector<pair<opcodetype, valtype> >& vSo\n \n         // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n         vTemplates.push_back(CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG);\n+\n+        // Sender provides two pubkeys, receivers provides two signatures\n+        vTemplates.push_back(CScript() << OP_2 << OP_PUBKEY << OP_PUBKEY << OP_2 << OP_CHECKMULTISIG);\n+\n+        // Sender provides two pubkeys, receivers provides one of two signatures\n+        vTemplates.push_back(CScript() << OP_1 << OP_PUBKEY << OP_PUBKEY << OP_2 << OP_CHECKMULTISIG);\n+\n+        // Sender provides three pubkeys, receiver provides 2 of 3 signatures.\n+        vTemplates.push_back(CScript() << OP_2 << OP_PUBKEY << OP_PUBKEY << OP_PUBKEY << OP_3 << OP_CHECKMULTISIG);\n     }\n \n     // Scan templates\n     const CScript& script1 = scriptPubKey;\n     BOOST_FOREACH(const CScript& script2, vTemplates)\n     {\n-        vSolutionRet.clear();\n+        vSolutionsRet.clear();\n+\n+        vector<pair<opcodetype, valtype> > currentSolution;\n         opcodetype opcode1, opcode2;\n         vector<unsigned char> vch1, vch2;\n \n@@ -992,9 +1006,7 @@ bool Solver(const CScript& scriptPubKey, vector<pair<opcodetype, valtype> >& vSo\n         {\n             if (pc1 == script1.end() && pc2 == script2.end())\n             {\n-                // Found a match\n-                reverse(vSolutionRet.begin(), vSolutionRet.end());\n-                return true;\n+                return !vSolutionsRet.empty();\n             }\n             if (!script1.GetOp(pc1, opcode1, vch1))\n                 break;\n@@ -1004,13 +1016,54 @@ bool Solver(const CScript& scriptPubKey, vector<pair<opcodetype, valtype> >& vSo\n             {\n                 if (vch1.size() < 33 || vch1.size() > 120)\n                     break;\n-                vSolutionRet.push_back(make_pair(opcode2, vch1));\n+                currentSolution.push_back(make_pair(opcode2, vch1));\n             }\n             else if (opcode2 == OP_PUBKEYHASH)\n             {\n                 if (vch1.size() != sizeof(uint160))\n                     break;\n-                vSolutionRet.push_back(make_pair(opcode2, vch1));\n+                currentSolution.push_back(make_pair(opcode2, vch1));\n+            }\n+            else if (opcode2 == OP_CHECKSIG)\n+            {\n+                vSolutionsRet.push_back(currentSolution);\n+                currentSolution.clear();\n+            }\n+            else if (opcode2 == OP_CHECKMULTISIG)\n+            {   // Dig out the \"m\" from before the pubkeys:\n+                CScript::const_iterator it = script2.begin();\n+                opcodetype op_m;\n+                script2.GetOp(it, op_m, vch1);\n+                int m = CScript::DecodeOP_N(op_m);\n+                int n = currentSolution.size();\n+\n+                if (m == 2 && n == 2)\n+                {\n+                    vSolutionsRet.push_back(currentSolution);\n+                    currentSolution.clear();\n+                }\n+                else if (m == 1 && n == 2)\n+                { // 2 solutions: either first key or second\n+                    for (int i = 0; i < 2; i++)\n+                    {\n+                        vector<pair<opcodetype, valtype> > s;\n+                        s.push_back(currentSolution[i]);\n+                        vSolutionsRet.push_back(s);\n+                    }\n+                    currentSolution.clear();\n+                }\n+                else if (m == 2 && n == 3)\n+                { // 3 solutions: any pair\n+                    for (int i = 0; i < 2; i++)\n+                        for (int j = i+1; j < 3; j++)\n+                        {\n+                            vector<pair<opcodetype, valtype> > s;\n+                            s.push_back(currentSolution[i]);\n+                            s.push_back(currentSolution[j]);\n+                            vSolutionsRet.push_back(s);\n+                        }\n+                    currentSolution.clear();\n+                }\n             }\n             else if (opcode1 != opcode2 || vch1 != vch2)\n             {\n@@ -1019,7 +1072,7 @@ bool Solver(const CScript& scriptPubKey, vector<pair<opcodetype, valtype> >& vSo\n         }\n     }\n \n-    vSolutionRet.clear();\n+    vSolutionsRet.clear();\n     return false;\n }\n \n@@ -1028,111 +1081,128 @@ bool Solver(const CKeyStore& keystore, const CScript& scriptPubKey, uint256 hash\n {\n     scriptSigRet.clear();\n \n-    vector<pair<opcodetype, valtype> > vSolution;\n-    if (!Solver(scriptPubKey, vSolution))\n+    vector<vector<pair<opcodetype, valtype> > > vSolutions;\n+    if (!Solver(scriptPubKey, vSolutions))\n         return false;\n \n-    // Compile solution\n-    BOOST_FOREACH(PAIRTYPE(opcodetype, valtype)& item, vSolution)\n+    // See if we have all the keys for any of the solutions:\n+    int whichSolution = -1;\n+    for (int i = 0; i < vSolutions.size(); i++)\n     {\n-        if (item.first == OP_PUBKEY)\n+        int keysFound = 0;\n+        CScript scriptSig;\n+\n+        BOOST_FOREACH(PAIRTYPE(opcodetype, valtype)& item, vSolutions[i])\n         {\n-            // Sign\n-            const valtype& vchPubKey = item.second;\n-            CKey key;\n-            if (!keystore.GetKey(Hash160(vchPubKey), key))\n-                return false;\n-            if (key.GetPubKey() != vchPubKey)\n-                return false;\n-            if (hash != 0)\n+            if (item.first == OP_PUBKEY)\n             {\n+                const valtype& vchPubKey = item.second;\n+                CKey key;\n                 vector<unsigned char> vchSig;\n-                if (!key.Sign(hash, vchSig))\n-                    return false;\n-                vchSig.push_back((unsigned char)nHashType);\n-                scriptSigRet << vchSig;\n+                if (keystore.GetKey(Hash160(vchPubKey), key) && key.GetPubKey() == vchPubKey\n+                    && hash != 0 && key.Sign(hash, vchSig))\n+                {\n+                    vchSig.push_back((unsigned char)nHashType);\n+                    scriptSig << vchSig;\n+                    ++keysFound;\n+                }\n             }\n-        }\n-        else if (item.first == OP_PUBKEYHASH)\n-        {\n-            // Sign and give pubkey\n-            CKey key;\n-            if (!keystore.GetKey(uint160(item.second), key))\n-                return false;\n-            if (hash != 0)\n+            else if (item.first == OP_PUBKEYHASH)\n             {\n+                CKey key;\n                 vector<unsigned char> vchSig;\n-                if (!key.Sign(hash, vchSig))\n-                    return false;\n-                vchSig.push_back((unsigned char)nHashType);\n-                scriptSigRet << vchSig << key.GetPubKey();\n+                if (keystore.GetKey(uint160(item.second), key) \n+                    && hash != 0 && key.Sign(hash, vchSig))\n+                {\n+                    vchSig.push_back((unsigned char)nHashType);\n+                    scriptSig << vchSig << key.GetPubKey();\n+                    ++keysFound;\n+                }\n             }\n         }\n-        else\n+        if (keysFound == vSolutions[i].size())\n         {\n-            return false;\n+            whichSolution = i;\n+            scriptSigRet = scriptSig;\n+            break;\n         }\n     }\n+    if (whichSolution == -1)\n+        return false;\n+\n+    // CHECKMULTISIG bug workaround:\n+    if (vSolutions.size() != 1 ||\n+        vSolutions[0].size() != 1)\n+    {\n+        scriptSigRet.insert(scriptSigRet.begin(), OP_0);\n+    }\n \n     return true;\n }\n \n \n bool IsStandard(const CScript& scriptPubKey)\n {\n-    vector<pair<opcodetype, valtype> > vSolution;\n-    return Solver(scriptPubKey, vSolution);\n+    vector<vector<pair<opcodetype, valtype> > > vSolutions;\n+    return Solver(scriptPubKey, vSolutions);\n }\n \n \n bool IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n {\n-    vector<pair<opcodetype, valtype> > vSolution;\n-    if (!Solver(scriptPubKey, vSolution))\n+    vector<vector<pair<opcodetype, valtype> > > vSolutions;\n+    if (!Solver(scriptPubKey, vSolutions))\n         return false;\n \n-    // Compile solution\n-    BOOST_FOREACH(PAIRTYPE(opcodetype, valtype)& item, vSolution)\n+    int keysFound = 0;\n+    int keysRequired = 0;\n+    for (int i = 0; i < vSolutions.size(); i++)\n     {\n-        if (item.first == OP_PUBKEY)\n-        {\n-            const valtype& vchPubKey = item.second;\n-            vector<unsigned char> vchPubKeyFound;\n-            if (!keystore.GetPubKey(Hash160(vchPubKey), vchPubKeyFound))\n-                return false;\n-            if (vchPubKeyFound != vchPubKey)\n-                return false;\n-        }\n-        else if (item.first == OP_PUBKEYHASH)\n-        {\n-            if (!keystore.HaveKey(uint160(item.second)))\n-                return false;\n-        }\n-        else\n+        BOOST_FOREACH(PAIRTYPE(opcodetype, valtype)& item, vSolutions[i])\n         {\n-            return false;\n+            ++keysRequired;\n+            if (item.first == OP_PUBKEY)\n+            {\n+                const valtype& vchPubKey = item.second;\n+                vector<unsigned char> vchPubKeyFound;\n+                if (keystore.GetPubKey(Hash160(vchPubKey), vchPubKeyFound) && vchPubKeyFound == vchPubKey)\n+                    ++keysFound;\n+            }\n+            else if (item.first == OP_PUBKEYHASH)\n+            {\n+                if (keystore.HaveKey(uint160(item.second)))\n+                    ++keysFound;\n+            }\n         }\n     }\n \n-    return true;\n+    // Only consider transactions \"mine\" if we own ALL the\n+    // keys involved. multi-signature transactions that are\n+    // partially owned (somebody else has a key that can spend\n+    // them) enable spend-out-from-under-you attacks, especially\n+    // for shared-wallet situations.\n+    return (keysFound == keysRequired);\n }\n \n bool ExtractAddress(const CScript& scriptPubKey, const CKeyStore* keystore, CBitcoinAddress& addressRet)\n {\n-    vector<pair<opcodetype, valtype> > vSolution;\n-    if (!Solver(scriptPubKey, vSolution))\n+    vector<vector<pair<opcodetype, valtype> > > vSolutions;\n+    if (!Solver(scriptPubKey, vSolutions))\n         return false;\n \n-    BOOST_FOREACH(PAIRTYPE(opcodetype, valtype)& item, vSolution)\n+    for (int i = 0; i < vSolutions.size(); i++)\n     {\n+        if (vSolutions[i].size() != 1)\n+            continue; // Can't return more than one address...\n+\n+        PAIRTYPE(opcodetype, valtype)& item = vSolutions[i][0];\n         if (item.first == OP_PUBKEY)\n             addressRet.SetPubKey(item.second);\n         else if (item.first == OP_PUBKEYHASH)\n             addressRet.SetHash160((uint160)item.second);\n         if (keystore == NULL || keystore->HaveKey(addressRet))\n             return true;\n     }\n-\n     return false;\n }\n \n@@ -1192,3 +1262,22 @@ bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsig\n \n     return true;\n }\n+\n+void CScript::SetMultisigAnd(const std::vector<CKey>& keys)\n+{\n+    assert(keys.size() >= 2);\n+    this->clear();\n+    *this << OP_2 << keys[0].GetPubKey() << keys[1].GetPubKey() << OP_2 << OP_CHECKMULTISIG;\n+}\n+void CScript::SetMultisigOr(const std::vector<CKey>& keys)\n+{\n+    assert(keys.size() >= 2);\n+    this->clear();\n+    *this << OP_1 << keys[0].GetPubKey() << keys[1].GetPubKey() << OP_2 << OP_CHECKMULTISIG;\n+}\n+void CScript::SetMultisigEscrow(const std::vector<CKey>& keys)\n+{\n+    assert(keys.size() >= 3);\n+    this->clear();\n+    *this << OP_2 << keys[0].GetPubKey() << keys[1].GetPubKey() << keys[1].GetPubKey() << OP_3 << OP_CHECKMULTISIG;\n+}"
      },
      {
        "sha": "a5a1e1868c9cb9097ee8ebda5df1c309ff09eafb",
        "filename": "src/script.h",
        "status": "modified",
        "additions": 10,
        "deletions": 15,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bf798734db4539a39edd6badf54a1c3aecf193e5/src/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bf798734db4539a39edd6badf54a1c3aecf193e5/src/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.h?ref=bf798734db4539a39edd6badf54a1c3aecf193e5",
        "patch": "@@ -574,6 +574,13 @@ class CScript : public std::vector<unsigned char>\n         return true;\n     }\n \n+    static int DecodeOP_N(opcodetype opcode)\n+    {\n+        if (opcode == OP_0)\n+            return 0;\n+        assert(opcode >= OP_1 && opcode <= OP_16);\n+        return (int)opcode - (int)(OP_1 - 1);\n+    }\n \n     void FindAndDelete(const CScript& b)\n     {\n@@ -625,21 +632,6 @@ class CScript : public std::vector<unsigned char>\n     }\n \n \n-    CBitcoinAddress GetBitcoinAddress() const\n-    {\n-        opcodetype opcode;\n-        std::vector<unsigned char> vch;\n-        CScript::const_iterator pc = begin();\n-        if (!GetOp(pc, opcode, vch) || opcode != OP_DUP) return 0;\n-        if (!GetOp(pc, opcode, vch) || opcode != OP_HASH160) return 0;\n-        if (!GetOp(pc, opcode, vch) || vch.size() != sizeof(uint160)) return 0;\n-        uint160 hash160 = uint160(vch);\n-        if (!GetOp(pc, opcode, vch) || opcode != OP_EQUALVERIFY) return 0;\n-        if (!GetOp(pc, opcode, vch) || opcode != OP_CHECKSIG) return 0;\n-        if (pc != end()) return 0;\n-        return CBitcoinAddress(hash160);\n-    }\n-\n     void SetBitcoinAddress(const CBitcoinAddress& address)\n     {\n         this->clear();\n@@ -650,6 +642,9 @@ class CScript : public std::vector<unsigned char>\n     {\n         SetBitcoinAddress(CBitcoinAddress(vchPubKey));\n     }\n+    void SetMultisigAnd(const std::vector<CKey>& keys);\n+    void SetMultisigOr(const std::vector<CKey>& keys);\n+    void SetMultisigEscrow(const std::vector<CKey>& keys);\n \n \n     void PrintHex() const"
      },
      {
        "sha": "459d112369489bae4d542e433431679d49133ee4",
        "filename": "src/test/multisig_tests.cpp",
        "status": "added",
        "additions": 288,
        "deletions": 0,
        "changes": 288,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bf798734db4539a39edd6badf54a1c3aecf193e5/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bf798734db4539a39edd6badf54a1c3aecf193e5/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=bf798734db4539a39edd6badf54a1c3aecf193e5",
        "patch": "@@ -0,0 +1,288 @@\n+#include <boost/assert.hpp>\n+#include <boost/assign/list_of.hpp>\n+#include <boost/assign/list_inserter.hpp>\n+#include <boost/assign/std/vector.hpp>\n+#include <boost/test/unit_test.hpp>\n+#include <boost/foreach.hpp>\n+#include <boost/tuple/tuple.hpp>\n+\n+#include <openssl/ec.h>\n+#include <openssl/err.h>\n+\n+#include \"keystore.h\"\n+#include \"main.h\"\n+#include \"script.h\"\n+#include \"wallet.h\"\n+\n+using namespace std;\n+using namespace boost::assign;\n+\n+typedef vector<unsigned char> valtype;\n+\n+extern uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n+extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, int nHashType);\n+extern bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, int nHashType);\n+extern bool Solver(const CScript& scriptPubKey, vector<vector<pair<opcodetype, valtype> > >& vSolutionsRet);\n+\n+BOOST_AUTO_TEST_SUITE(multisig_tests)\n+\n+CScript\n+sign_multisig(CScript scriptPubKey, vector<CKey> keys, CTransaction transaction, int whichIn)\n+{\n+    uint256 hash = SignatureHash(scriptPubKey, transaction, whichIn, SIGHASH_ALL);\n+\n+    CScript result;\n+    result << OP_0; // CHECKMULTISIG bug workaround\n+    BOOST_FOREACH(CKey key, keys)\n+    {\n+        vector<unsigned char> vchSig;\n+        BOOST_CHECK(key.Sign(hash, vchSig));\n+        vchSig.push_back((unsigned char)SIGHASH_ALL);\n+        result << vchSig;\n+    }\n+    return result;\n+}\n+\n+BOOST_AUTO_TEST_CASE(multisig_verify)\n+{\n+    CKey key[4];\n+    for (int i = 0; i < 4; i++)\n+        key[i].MakeNewKey();\n+\n+    CScript a_and_b;\n+    a_and_b << OP_2 << key[0].GetPubKey() << key[1].GetPubKey() << OP_2 << OP_CHECKMULTISIG;\n+\n+    CScript a_or_b;\n+    a_or_b << OP_1 << key[0].GetPubKey() << key[1].GetPubKey() << OP_2 << OP_CHECKMULTISIG;\n+\n+    CScript escrow;\n+    escrow << OP_2 << key[0].GetPubKey() << key[1].GetPubKey() << key[2].GetPubKey() << OP_3 << OP_CHECKMULTISIG;\n+\n+    CTransaction txFrom;  // Funding transaction\n+    txFrom.vout.resize(3);\n+    txFrom.vout[0].scriptPubKey = a_and_b;\n+    txFrom.vout[1].scriptPubKey = a_or_b;\n+    txFrom.vout[2].scriptPubKey = escrow;\n+\n+    CTransaction txTo[3]; // Spending transaction\n+    for (int i = 0; i < 3; i++)\n+    {\n+        txTo[i].vin.resize(1);\n+        txTo[i].vout.resize(1);\n+        txTo[i].vin[0].prevout.n = i;\n+        txTo[i].vin[0].prevout.hash = txFrom.GetHash();\n+        txTo[i].vout[0].nValue = 1;\n+    }\n+\n+    vector<CKey> keys;\n+    CScript s;\n+\n+    // Test a AND b:\n+    keys.clear();\n+    keys += key[0],key[1]; // magic operator+= from boost.assign\n+    s = sign_multisig(a_and_b, keys, txTo[0], 0);\n+    BOOST_CHECK(VerifyScript(s, a_and_b, txTo[0], 0, 0));\n+\n+    for (int i = 0; i < 4; i++)\n+    {\n+        keys.clear();\n+        keys += key[i];\n+        s = sign_multisig(a_and_b, keys, txTo[0], 0);\n+        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, 0), strprintf(\"a&b 1: %d\", i));\n+\n+        keys.clear();\n+        keys += key[1],key[i];\n+        s = sign_multisig(a_and_b, keys, txTo[0], 0);\n+        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, 0), strprintf(\"a&b 2: %d\", i));\n+    }\n+\n+    // Test a OR b:\n+    for (int i = 0; i < 4; i++)\n+    {\n+        keys.clear();\n+        keys += key[i];\n+        s = sign_multisig(a_or_b, keys, txTo[1], 0);\n+        if (i == 0 || i == 1)\n+            BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, txTo[1], 0, 0), strprintf(\"a|b: %d\", i));\n+        else\n+            BOOST_CHECK_MESSAGE(!VerifyScript(s, a_or_b, txTo[1], 0, 0), strprintf(\"a|b: %d\", i));\n+    }\n+    s.clear();\n+    s << OP_0 << OP_0;\n+    BOOST_CHECK(!VerifyScript(s, a_or_b, txTo[1], 0, 0));\n+    s.clear();\n+    s << OP_0 << OP_1;\n+    BOOST_CHECK(!VerifyScript(s, a_or_b, txTo[1], 0, 0));\n+\n+\n+    for (int i = 0; i < 4; i++)\n+        for (int j = 0; j < 4; j++)\n+        {\n+            keys.clear();\n+            keys += key[i],key[j];\n+            s = sign_multisig(escrow, keys, txTo[2], 0);\n+            if (i < j && i < 3 && j < 3)\n+                BOOST_CHECK_MESSAGE(VerifyScript(s, escrow, txTo[2], 0, 0), strprintf(\"escrow 1: %d %d\", i, j));\n+            else\n+                BOOST_CHECK_MESSAGE(!VerifyScript(s, escrow, txTo[2], 0, 0), strprintf(\"escrow 2: %d %d\", i, j));\n+        }\n+}\n+\n+BOOST_AUTO_TEST_CASE(multisig_IsStandard)\n+{\n+    CKey key[3];\n+    for (int i = 0; i < 3; i++)\n+        key[i].MakeNewKey();\n+\n+    CScript a_and_b;\n+    a_and_b << OP_2 << key[0].GetPubKey() << key[1].GetPubKey() << OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(::IsStandard(a_and_b));\n+\n+    CScript a_or_b;\n+    a_or_b  << OP_1 << key[0].GetPubKey() << key[1].GetPubKey() << OP_2 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(::IsStandard(a_or_b));\n+\n+    CScript escrow;\n+    escrow << OP_2 << key[0].GetPubKey() << key[1].GetPubKey() << key[2].GetPubKey() << OP_3 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(::IsStandard(escrow));\n+}\n+\n+BOOST_AUTO_TEST_CASE(multisig_Solver1)\n+{\n+    // Tests Solver() that returns lists of keys that are\n+    // required to satisfy a ScriptPubKey\n+    //\n+    // Also tests IsMine() and ExtractAddress()\n+    //\n+    // Note: ExtractAddress for the multisignature transactions\n+    // always returns false for this release, even if you have\n+    // one key that would satisfy an (a|b) or 2-of-3 keys needed\n+    // to spend an escrow transaction.\n+    //\n+    CBasicKeyStore keystore, emptykeystore;\n+    CKey key[3];\n+    CBitcoinAddress keyaddr[3];\n+    for (int i = 0; i < 3; i++)\n+    {\n+        key[i].MakeNewKey();\n+        keystore.AddKey(key[i]);\n+        keyaddr[i].SetPubKey(key[i].GetPubKey());\n+    }\n+\n+    {\n+        vector<vector<pair<opcodetype, valtype> > > solutions;\n+        CScript s;\n+        s << key[0].GetPubKey() << OP_CHECKSIG;\n+        BOOST_CHECK(Solver(s, solutions));\n+        BOOST_CHECK(solutions.size() == 1);\n+        if (solutions.size() == 1)\n+            BOOST_CHECK(solutions[0].size() == 1);\n+        CBitcoinAddress addr;\n+        BOOST_CHECK(ExtractAddress(s, &keystore, addr));\n+        BOOST_CHECK(addr == keyaddr[0]);\n+        BOOST_CHECK(IsMine(keystore, s));\n+        BOOST_CHECK(!IsMine(emptykeystore, s));\n+    }\n+    {\n+        vector<vector<pair<opcodetype, valtype> > > solutions;\n+        CScript s;\n+        s << OP_DUP << OP_HASH160 << Hash160(key[0].GetPubKey()) << OP_EQUALVERIFY << OP_CHECKSIG;\n+        BOOST_CHECK(Solver(s, solutions));\n+        BOOST_CHECK(solutions.size() == 1);\n+        if (solutions.size() == 1)\n+            BOOST_CHECK(solutions[0].size() == 1);\n+        CBitcoinAddress addr;\n+        BOOST_CHECK(ExtractAddress(s, &keystore, addr));\n+        BOOST_CHECK(addr == keyaddr[0]);\n+        BOOST_CHECK(IsMine(keystore, s));\n+        BOOST_CHECK(!IsMine(emptykeystore, s));\n+    }\n+    {\n+        vector<vector<pair<opcodetype, valtype> > > solutions;\n+        CScript s;\n+        s << OP_2 << key[0].GetPubKey() << key[1].GetPubKey() << OP_2 << OP_CHECKMULTISIG;\n+        BOOST_CHECK(Solver(s, solutions));\n+        BOOST_CHECK(solutions.size() == 1);\n+        if (solutions.size() == 1)\n+            BOOST_CHECK(solutions[0].size() == 2);\n+        CBitcoinAddress addr;\n+        BOOST_CHECK(!ExtractAddress(s, &keystore, addr));\n+        BOOST_CHECK(IsMine(keystore, s));\n+        BOOST_CHECK(!IsMine(emptykeystore, s));\n+    }\n+    {\n+        vector<vector<pair<opcodetype, valtype> > > solutions;\n+        CScript s;\n+        s << OP_1 << key[0].GetPubKey() << key[1].GetPubKey() << OP_2 << OP_CHECKMULTISIG;\n+        BOOST_CHECK(Solver(s, solutions));\n+        BOOST_CHECK(solutions.size() == 2);\n+        if (solutions.size() == 2)\n+        {\n+            BOOST_CHECK(solutions[0].size() == 1);\n+            BOOST_CHECK(solutions[1].size() == 1);\n+        }\n+        CBitcoinAddress addr;\n+        BOOST_CHECK(ExtractAddress(s, &keystore, addr));\n+        BOOST_CHECK(addr == keyaddr[0]);\n+        BOOST_CHECK(IsMine(keystore, s));\n+        BOOST_CHECK(!IsMine(emptykeystore, s));\n+    }\n+    {\n+        vector<vector<pair<opcodetype, valtype> > > solutions;\n+        CScript s;\n+        s << OP_2 << key[0].GetPubKey() << key[1].GetPubKey() << key[2].GetPubKey() << OP_3 << OP_CHECKMULTISIG;\n+        BOOST_CHECK(Solver(s, solutions));\n+        BOOST_CHECK(solutions.size() == 3);\n+        if (solutions.size() == 3)\n+        {\n+            BOOST_CHECK(solutions[0].size() == 2);\n+            BOOST_CHECK(solutions[1].size() == 2);\n+            BOOST_CHECK(solutions[2].size() == 2);\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(multisig_Sign)\n+{\n+    // Test SignSignature() (and therefore the version of Solver() that signs transactions)\n+    CBasicKeyStore keystore;\n+    CKey key[4];\n+    for (int i = 0; i < 4; i++)\n+    {\n+        key[i].MakeNewKey();\n+        keystore.AddKey(key[i]);\n+    }\n+\n+    CScript a_and_b;\n+    a_and_b << OP_2 << key[0].GetPubKey() << key[1].GetPubKey() << OP_2 << OP_CHECKMULTISIG;\n+\n+    CScript a_or_b;\n+    a_or_b  << OP_1 << key[0].GetPubKey() << key[1].GetPubKey() << OP_2 << OP_CHECKMULTISIG;\n+\n+    CScript escrow;\n+    escrow << OP_2 << key[0].GetPubKey() << key[1].GetPubKey() << key[2].GetPubKey() << OP_3 << OP_CHECKMULTISIG;\n+\n+    CTransaction txFrom;  // Funding transaction\n+    txFrom.vout.resize(3);\n+    txFrom.vout[0].scriptPubKey = a_and_b;\n+    txFrom.vout[1].scriptPubKey = a_or_b;\n+    txFrom.vout[2].scriptPubKey = escrow;\n+\n+    CTransaction txTo[3]; // Spending transaction\n+    for (int i = 0; i < 3; i++)\n+    {\n+        txTo[i].vin.resize(1);\n+        txTo[i].vout.resize(1);\n+        txTo[i].vin[0].prevout.n = i;\n+        txTo[i].vin[0].prevout.hash = txFrom.GetHash();\n+        txTo[i].vout[0].nValue = 1;\n+    }\n+\n+    for (int i = 0; i < 3; i++)\n+    {\n+        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0), strprintf(\"SignSignature %d\", i));\n+    }\n+}\n+\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "a662111d4948428c62d2a314c3343d834da77ab6",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bf798734db4539a39edd6badf54a1c3aecf193e5/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bf798734db4539a39edd6badf54a1c3aecf193e5/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=bf798734db4539a39edd6badf54a1c3aecf193e5",
        "patch": "@@ -997,12 +997,11 @@ bool CWallet::CreateTransaction(const vector<pair<CScript, int64> >& vecSend, CW\n                     vector<unsigned char> vchPubKey = reservekey.GetReservedKey();\n                     // assert(mapKeys.count(vchPubKey));\n \n-                    // Fill a vout to ourself, using same address type as the payment\n+                    // Fill a vout to ourself\n+                    // TODO: pass in scriptChange instead of reservekey so\n+                    // change transaction isn't always pay-to-bitcoin-address\n                     CScript scriptChange;\n-                    if (vecSend[0].first.GetBitcoinAddress().IsValid())\n-                        scriptChange.SetBitcoinAddress(vchPubKey);\n-                    else\n-                        scriptChange << vchPubKey << OP_CHECKSIG;\n+                    scriptChange.SetBitcoinAddress(vchPubKey);\n \n                     // Insert change txn at random position:\n                     vector<CTxOut>::iterator position = wtxNew.vout.begin()+GetRandInt(wtxNew.vout.size());"
      }
    ]
  },
  {
    "sha": "cc40ba2151a627b6da9af4932e0bee58e69aacb5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjYzQwYmEyMTUxYTYyN2I2ZGE5YWY0OTMyZTBiZWU1OGU2OWFhY2I1",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-10-03T20:14:13Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-12-19T17:40:19Z"
      },
      "message": "Global fixture to send output to console instead of debug.log",
      "tree": {
        "sha": "c8fd986dd581f35d01241b695ca1b2823c27f24a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c8fd986dd581f35d01241b695ca1b2823c27f24a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cc40ba2151a627b6da9af4932e0bee58e69aacb5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cc40ba2151a627b6da9af4932e0bee58e69aacb5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cc40ba2151a627b6da9af4932e0bee58e69aacb5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cc40ba2151a627b6da9af4932e0bee58e69aacb5/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bf798734db4539a39edd6badf54a1c3aecf193e5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bf798734db4539a39edd6badf54a1c3aecf193e5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bf798734db4539a39edd6badf54a1c3aecf193e5"
      }
    ],
    "stats": {
      "total": 10,
      "additions": 10,
      "deletions": 0
    },
    "files": [
      {
        "sha": "4b52b74cfe6ea94a6bbf2c61c31af810e42a0d95",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cc40ba2151a627b6da9af4932e0bee58e69aacb5/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cc40ba2151a627b6da9af4932e0bee58e69aacb5/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=cc40ba2151a627b6da9af4932e0bee58e69aacb5",
        "patch": "@@ -4,6 +4,16 @@\n #include \"main.h\"\n #include \"wallet.h\"\n \n+extern bool fPrintToConsole;\n+struct TestingSetup {\n+    TestingSetup() {\n+        fPrintToConsole = true; // don't want to write to debug.log file\n+    }\n+    ~TestingSetup() { }\n+};\n+\n+BOOST_GLOBAL_FIXTURE(TestingSetup);\n+\n CWallet* pwalletMain;\n \n void Shutdown(void* parg)"
      }
    ]
  },
  {
    "sha": "e679ec969c8b22c676ebb10bea1038f6c8f13b33",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNjc5ZWM5NjljOGIyMmM2NzZlYmIxMGJlYTEwMzhmNmM4ZjEzYjMz",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-10-03T17:05:43Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-12-19T17:40:19Z"
      },
      "message": "OP_EVAL implementation\n\nOP_EVAL is a new opcode that evaluates an item on the stack as a script.\nIt enables a new type of bitcoin address that needs an arbitrarily\ncomplex script to redeem.",
      "tree": {
        "sha": "c584f1a152c376ca0df93261d447c5b719449508",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c584f1a152c376ca0df93261d447c5b719449508"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e679ec969c8b22c676ebb10bea1038f6c8f13b33",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e679ec969c8b22c676ebb10bea1038f6c8f13b33",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e679ec969c8b22c676ebb10bea1038f6c8f13b33",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e679ec969c8b22c676ebb10bea1038f6c8f13b33/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cc40ba2151a627b6da9af4932e0bee58e69aacb5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cc40ba2151a627b6da9af4932e0bee58e69aacb5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cc40ba2151a627b6da9af4932e0bee58e69aacb5"
      }
    ],
    "stats": {
      "total": 1727,
      "additions": 1155,
      "deletions": 572
    },
    "files": [
      {
        "sha": "8fc546c50568d015a860a2a12bba02b7e2b709e4",
        "filename": "src/base58.h",
        "status": "modified",
        "additions": 25,
        "deletions": 0,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/base58.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/base58.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.h?ref=e679ec969c8b22c676ebb10bea1038f6c8f13b33",
        "patch": "@@ -268,16 +268,33 @@ class CBitcoinAddress : public CBase58Data\n         SetHash160(Hash160(vchPubKey));\n     }\n \n+    bool SetScriptHash160(const uint160& hash160)\n+    {\n+        SetData(fTestNet ? 112 : 1, &hash160, 20);\n+        return true;\n+    }\n+\n     bool IsValid() const\n     {\n         int nExpectedSize = 20;\n         bool fExpectTestNet = false;\n         switch(nVersion)\n         {\n             case 0:\n+                nExpectedSize = 20; // Hash of public key\n+                fExpectTestNet = false;\n+                break;\n+            case 1:\n+                nExpectedSize = 20; // OP_EVAL, hash of CScript\n+                fExpectTestNet = false;\n                 break;\n \n             case 111:\n+                nExpectedSize = 20;\n+                fExpectTestNet = true;\n+                break;\n+            case 112:\n+                nExpectedSize = 20;\n                 fExpectTestNet = true;\n                 break;\n \n@@ -286,6 +303,14 @@ class CBitcoinAddress : public CBase58Data\n         }\n         return fExpectTestNet == fTestNet && vchData.size() == nExpectedSize;\n     }\n+    bool IsScript() const\n+    {\n+        if (!IsValid())\n+            return false;\n+        if (fTestNet)\n+            return nVersion == 112;\n+        return nVersion == 1;\n+    }\n \n     CBitcoinAddress()\n     {"
      },
      {
        "sha": "3e42e7038761ecd283da2d1237708d2a7cc2b770",
        "filename": "src/bitcoinrpc.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 70,
        "changes": 122,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/bitcoinrpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/bitcoinrpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.cpp?ref=e679ec969c8b22c676ebb10bea1038f6c8f13b33",
        "patch": "@@ -667,7 +667,7 @@ Value getreceivedbyaccount(const Array& params, bool fHelp)\n     if (params.size() > 1)\n         nMinDepth = params[1].get_int();\n \n-    // Get the set of pub keys that have the label\n+    // Get the set of pub keys assigned to account\n     string strAccount = AccountFromValue(params[0]);\n     set<CBitcoinAddress> setAddress;\n     GetAccountAddresses(strAccount, setAddress);\n@@ -936,56 +936,30 @@ Value sendmany(const Array& params, bool fHelp)\n     return wtx.GetHash().GetHex();\n }\n \n-Value sendmultisig(const Array& params, bool fHelp)\n+Value addmultisigaddress(const Array& params, bool fHelp)\n {\n-    if (fHelp || params.size() < 4 || params.size() > 7)\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n     {\n-        string msg = \"sendmultisig <fromaccount> <type> <[\\\"key\\\",\\\"key\\\"]> <amount> [minconf=1] [comment] [comment-to]\\n\"\n-            \"<type> is one of: \\\"and\\\", \\\"or\\\", \\\"escrow\\\"\\n\"\n-            \"<keys> is an array of strings (in JSON array format); each key is a bitcoin address, hex or base58 public key\\n\"\n-            \"<amount> is a real and is rounded to the nearest 0.00000001\";\n-        if (pwalletMain->IsCrypted())\n-            msg += \"\\nrequires wallet passphrase to be set with walletpassphrase first\";\n+        string msg = \"addmultisigaddress <nrequired> <'[\\\"key\\\",\\\"key\\\"]'> [account]\\n\"\n+            \"Add a nrequired-to-sign multisignature address to the wallet\\\"\\n\"\n+            \"each key is a bitcoin address, hex or base58 public key\\n\"\n+            \"If [account] is specified, assign address to [account].\";\n         throw runtime_error(msg);\n     }\n \n-    string strAccount = AccountFromValue(params[0]);\n-    string strType = params[1].get_str();\n-    const Array& keys = params[2].get_array();\n-    int64 nAmount = AmountFromValue(params[3]);\n-    int nMinDepth = 1;\n-    if (params.size() > 4)\n-        nMinDepth = params[4].get_int();\n-\n-    CWalletTx wtx;\n-    wtx.strFromAccount = strAccount;\n-    if (params.size() > 5 && params[5].type() != null_type && !params[5].get_str().empty())\n-        wtx.mapValue[\"comment\"] = params[5].get_str();\n-    if (params.size() > 6 && params[6].type() != null_type && !params[6].get_str().empty())\n-        wtx.mapValue[\"to\"]      = params[6].get_str();\n-\n-    if (pwalletMain->IsLocked())\n-        throw JSONRPCError(-13, \"Error: Please enter the wallet passphrase with walletpassphrase first.\");\n-\n-    // Check funds\n-    int64 nBalance = GetAccountBalance(strAccount, nMinDepth);\n-    if (nAmount > nBalance)\n-        throw JSONRPCError(-6, \"Account has insufficient funds\");\n+    int nRequired = params[0].get_int();\n+    const Array& keys = params[1].get_array();\n+    string strAccount;\n+    if (params.size() > 2)\n+        strAccount = AccountFromValue(params[2]);\n \n     // Gather public keys\n-    int nKeysNeeded = 0;\n-    if (strType == \"and\" || strType == \"or\")\n-        nKeysNeeded = 2;\n-    else if (strType == \"escrow\")\n-        nKeysNeeded = 3;\n-    else\n-        throw runtime_error(\"sendmultisig: <type> must be one of: and or and_or\");\n-    if (keys.size() != nKeysNeeded)\n+    if (keys.size() < nRequired)\n         throw runtime_error(\n-            strprintf(\"sendmultisig: wrong number of keys (got %d, need %d)\", keys.size(), nKeysNeeded));\n+            strprintf(\"addmultisigaddress: wrong number of keys (got %d, need at least %d)\", keys.size(), nRequired));\n     std::vector<CKey> pubkeys;\n-    pubkeys.resize(nKeysNeeded);\n-    for (int i = 0; i < nKeysNeeded; i++)\n+    pubkeys.resize(keys.size());\n+    for (int i = 0; i < keys.size(); i++)\n     {\n         const std::string& ks = keys[i].get_str();\n         if (ks.size() == 130) // hex public key\n@@ -1003,32 +977,23 @@ Value sendmultisig(const Array& params, bool fHelp)\n             CBitcoinAddress address(ks);\n             if (!pwalletMain->GetKey(address, pubkeys[i]))\n                 throw runtime_error(\n-                    strprintf(\"sendmultisig: unknown address: %s\",ks.c_str()));\n+                    strprintf(\"addmultisigaddress: unknown address: %s\",ks.c_str()));\n         }\n     }\n \n-    // Send\n-    CScript scriptPubKey;\n-    if (strType == \"and\")\n-        scriptPubKey.SetMultisigAnd(pubkeys);\n-    else if (strType == \"or\")\n-        scriptPubKey.SetMultisigOr(pubkeys);\n-    else\n-        scriptPubKey.SetMultisigEscrow(pubkeys);\n+    // Construct using OP_EVAL\n+    CScript inner;\n+    inner.SetMultisig(nRequired, pubkeys);\n \n-    CReserveKey keyChange(pwalletMain);\n-    int64 nFeeRequired = 0;\n-    bool fCreated = pwalletMain->CreateTransaction(scriptPubKey, nAmount, wtx, keyChange, nFeeRequired);\n-    if (!fCreated)\n-    {\n-        if (nAmount + nFeeRequired > pwalletMain->GetBalance())\n-            throw JSONRPCError(-6, \"Insufficient funds\");\n-        throw JSONRPCError(-4, \"Transaction creation failed\");\n-    }\n-    if (!pwalletMain->CommitTransaction(wtx, keyChange))\n-        throw JSONRPCError(-4, \"Transaction commit failed\");\n+    uint160 scriptHash = Hash160(inner);\n+    CScript scriptPubKey;\n+    scriptPubKey.SetEval(inner);\n+    pwalletMain->AddCScript(scriptHash, inner);\n+    CBitcoinAddress address;\n+    address.SetScriptHash160(scriptHash);\n \n-    return wtx.GetHash().GetHex();\n+    pwalletMain->SetAddressBookName(address, strAccount);\n+    return address.ToString();\n }\n \n \n@@ -1700,6 +1665,24 @@ Value validateaddress(const Array& params, bool fHelp)\n             std::string strPubKey(vchPubKey.begin(), vchPubKey.end());\n             ret.push_back(Pair(\"pubkey58\", EncodeBase58(vchPubKey)));\n         }\n+        else if (pwalletMain->HaveCScript(address.GetHash160()))\n+        {\n+            ret.push_back(Pair(\"isscript\", true));\n+            CScript subscript;\n+            pwalletMain->GetCScript(address.GetHash160(), subscript);\n+            ret.push_back(Pair(\"ismine\", ::IsMine(*pwalletMain, subscript)));\n+            std::vector<CBitcoinAddress> addresses;\n+            txntype whichType;\n+            int nRequired;\n+            ExtractAddresses(subscript, pwalletMain, whichType, addresses, nRequired);\n+            ret.push_back(Pair(\"script\", GetTxnTypeName(whichType)));\n+            Array a;\n+            BOOST_FOREACH(const CBitcoinAddress& addr, addresses)\n+                a.push_back(addr.ToString());\n+            ret.push_back(Pair(\"addresses\", a));\n+            if (whichType == TX_MULTISIG)\n+                ret.push_back(Pair(\"sigsrequired\", nRequired));\n+        }\n         else\n             ret.push_back(Pair(\"ismine\", false));\n         if (pwalletMain->mapAddressBook.count(address))\n@@ -1946,7 +1929,7 @@ pair<string, rpcfn_type> pCallTable[] =\n     make_pair(\"move\",                   &movecmd),\n     make_pair(\"sendfrom\",               &sendfrom),\n     make_pair(\"sendmany\",               &sendmany),\n-    make_pair(\"sendmultisig\",           &sendmultisig),\n+    make_pair(\"addmultisigaddress\",     &addmultisigaddress),\n     make_pair(\"gettransaction\",         &gettransaction),\n     make_pair(\"listtransactions\",       &listtransactions),\n     make_pair(\"signmessage\",            &signmessage),\n@@ -2590,16 +2573,15 @@ int CommandLineRPC(int argc, char *argv[])\n             params[1] = v.get_obj();\n         }\n         if (strMethod == \"sendmany\"                && n > 2) ConvertTo<boost::int64_t>(params[2]);\n-        if (strMethod == \"sendmultisig\"            && n > 2)\n+        if (strMethod == \"addmultisigaddress\"      && n > 0) ConvertTo<boost::int64_t>(params[0]);\n+        if (strMethod == \"addmultisigaddress\"      && n > 1)\n         {\n-            string s = params[2].get_str();\n+            string s = params[1].get_str();\n             Value v;\n             if (!read_string(s, v) || v.type() != array_type)\n-                throw runtime_error(\"sendmultisig: type mismatch \"+s);\n-            params[2] = v.get_array();\n+                throw runtime_error(\"addmultisigaddress: type mismatch \"+s);\n+            params[1] = v.get_array();\n         }\n-        if (strMethod == \"sendmultisig\"            && n > 3) ConvertTo<double>(params[3]);\n-        if (strMethod == \"sendmultisig\"            && n > 4) ConvertTo<boost::int64_t>(params[4]);\n \n         // Execute\n         Object reply = CallRPC(strMethod, params);"
      },
      {
        "sha": "52ad695c71ae3e9e9b5288dadd8a90a86142a142",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=e679ec969c8b22c676ebb10bea1038f6c8f13b33",
        "patch": "@@ -934,6 +934,15 @@ int CWalletDB::LoadWallet(CWallet* pwallet)\n                 if (nMinVersion > CLIENT_VERSION)\n                     return DB_TOO_NEW;\n             }\n+            else if (strType == \"cscript\")\n+            {\n+                uint160 hash;\n+                ssKey >> hash;\n+                std::vector<unsigned char> script;\n+                ssValue >> script;\n+                if (!pwallet->LoadCScript(hash, script))\n+                    return DB_CORRUPT;\n+            }\n         }\n         pcursor->close();\n     }"
      },
      {
        "sha": "99dd88b491a0906cf151aafdb749b71ce1ae8014",
        "filename": "src/db.h",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.h?ref=e679ec969c8b22c676ebb10bea1038f6c8f13b33",
        "patch": "@@ -420,6 +420,18 @@ class CWalletDB : public CDB\n         return Write(std::make_pair(std::string(\"mkey\"), nID), kMasterKey, true);\n     }\n \n+    bool ReadCScript(const uint160 &hash, std::vector<unsigned char>& data)\n+    {\n+        data.clear();\n+        return Read(std::make_pair(std::string(\"cscript\"), hash), data);\n+    }\n+\n+    bool WriteCScript(const uint160& hash, const std::vector<unsigned char>& data)\n+    {\n+        nWalletDBUpdated++;\n+        return Write(std::make_pair(std::string(\"cscript\"), hash), data, false);\n+    }\n+\n     bool WriteBestBlock(const CBlockLocator& locator)\n     {\n         nWalletDBUpdated++;"
      },
      {
        "sha": "c9b9b4a5de1b2785fff4d47791178549962b373e",
        "filename": "src/keystore.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 0,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/keystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/keystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.cpp?ref=e679ec969c8b22c676ebb10bea1038f6c8f13b33",
        "patch": "@@ -33,6 +33,36 @@ bool CBasicKeyStore::AddKey(const CKey& key)\n     return true;\n }\n \n+bool CBasicKeyStore::AddCScript(const uint160 &hash, const std::vector<unsigned char>& data)\n+{\n+    CRITICAL_BLOCK(cs_KeyStore)\n+        mapData[hash] = data;\n+    return true;\n+}\n+\n+bool CBasicKeyStore::HaveCScript(const uint160& hash) const\n+{\n+    bool result;\n+    CRITICAL_BLOCK(cs_KeyStore)\n+        result = (mapData.count(hash) > 0);\n+    return result;\n+}\n+\n+\n+bool CBasicKeyStore::GetCScript(const uint160 &hash, std::vector<unsigned char>& dataOut) const\n+{\n+    CRITICAL_BLOCK(cs_KeyStore)\n+    {\n+        DataMap::const_iterator mi = mapData.find(hash);\n+        if (mi != mapData.end())\n+        {\n+            dataOut = (*mi).second;\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n bool CCryptoKeyStore::SetCrypted()\n {\n     CRITICAL_BLOCK(cs_KeyStore)"
      },
      {
        "sha": "942fb9ae9c39f4b3e356b1b90edc255d963baf3b",
        "filename": "src/keystore.h",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/keystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/keystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.h?ref=e679ec969c8b22c676ebb10bea1038f6c8f13b33",
        "patch": "@@ -31,6 +31,10 @@ class CKeyStore\n     virtual void GetKeys(std::set<CBitcoinAddress> &setAddress) const =0;\n     virtual bool GetPubKey(const CBitcoinAddress &address, std::vector<unsigned char>& vchPubKeyOut) const;\n \n+    virtual bool AddCScript(const uint160 &hash, const std::vector<unsigned char>& data) =0;\n+    virtual bool HaveCScript(const uint160 &hash) const =0;\n+    virtual bool GetCScript(const uint160 &hash, std::vector<unsigned char>& dataOut) const =0;\n+\n     // Generate a new key, and add it to the store\n     virtual std::vector<unsigned char> GenerateNewKey();\n     virtual bool GetSecret(const CBitcoinAddress &address, CSecret& vchSecret) const\n@@ -44,12 +48,14 @@ class CKeyStore\n };\n \n typedef std::map<CBitcoinAddress, CSecret> KeyMap;\n+typedef std::map<uint160, std::vector<unsigned char> > DataMap;\n \n // Basic key store, that keeps keys in an address->secret map\n class CBasicKeyStore : public CKeyStore\n {\n protected:\n     KeyMap mapKeys;\n+    DataMap mapData;\n \n public:\n     bool AddKey(const CKey& key);\n@@ -86,6 +92,9 @@ class CBasicKeyStore : public CKeyStore\n         }\n         return false;\n     }\n+    virtual bool AddCScript(const uint160 &hash, const std::vector<unsigned char>& data);\n+    virtual bool HaveCScript(const uint160 &hash) const;\n+    virtual bool GetCScript(const uint160 &hash, std::vector<unsigned char>& dataOut) const;\n };\n \n typedef std::map<CBitcoinAddress, std::pair<std::vector<unsigned char>, std::vector<unsigned char> > > CryptedKeyMap;"
      },
      {
        "sha": "0fb383f59300deca7d1efa6710e5995acf38fdb4",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 171,
        "deletions": 59,
        "changes": 230,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=e679ec969c8b22c676ebb10bea1038f6c8f13b33",
        "patch": "@@ -246,6 +246,65 @@ bool CTransaction::ReadFromDisk(COutPoint prevout)\n     return ReadFromDisk(txdb, prevout, txindex);\n }\n \n+bool CTransaction::IsStandard() const\n+{\n+    BOOST_FOREACH(const CTxIn& txin, vin)\n+    {\n+        // Biggest 'standard' txin is a 2-signature 2-of-3 escrow\n+        // in an OP_EVAL, which is 2 ~80-byte signatures, 3\n+        // ~65-byte public keys, plus a few script ops.\n+        if (txin.scriptSig.size() > 400)\n+            return error(\"nonstandard txin, size %d\\n\", txin.scriptSig.size());\n+        if (!txin.scriptSig.IsPushOnly())\n+            return error(\"nonstandard txin: %s\", txin.scriptSig.ToString().c_str());\n+    }\n+    BOOST_FOREACH(const CTxOut& txout, vout)\n+        if (!::IsStandard(txout.scriptPubKey))\n+            return error(\"nonstandard txout: %s\", txout.scriptPubKey.ToString().c_str());\n+    return true;\n+}\n+\n+//\n+// Check transaction inputs, and make sure any\n+// OP_EVAL transactions are evaluating IsStandard scripts\n+//\n+// Why bother? To avoid denial-of-service attacks; an attacker\n+// can submit a standard DUP HASH... OP_EVAL transaction,\n+// which will get accepted into blocks. The script being\n+// EVAL'ed can be anything; an attacker could use a very\n+// expensive-to-check-upon-redemption script like:\n+//   DUP CHECKSIG DROP ... repeated 100 times... OP_1\n+//\n+bool CTransaction::IsStandardInputs(std::map<uint256, std::pair<CTxIndex, CTransaction> > mapInputs) const\n+{\n+    if (fTestNet)\n+        return true; // Allow non-standard on testnet\n+\n+    for (int i = 0; i < vin.size(); i++)\n+    {\n+        COutPoint prevout = vin[i].prevout;\n+        assert(mapInputs.count(prevout.hash) > 0);\n+        CTransaction& txPrev = mapInputs[prevout.hash].second;\n+\n+        vector<vector<unsigned char> > vSolutions;\n+        txntype whichType;\n+        if (!Solver(txPrev.vout[vin[i].prevout.n].scriptPubKey, whichType, vSolutions))\n+            return false;\n+        if (whichType == TX_SCRIPTHASH)\n+        {\n+            vector<vector<unsigned char> > stack;\n+            int nUnused;\n+            if (!EvalScript(stack, vin[i].scriptSig, *this, i, 0, nUnused))\n+                return false;\n+            const vector<unsigned char>& subscript = stack.back();\n+            if (!::IsStandard(CScript(subscript.begin(), subscript.end())))\n+                return false;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n \n \n int CMerkleTx::SetMerkleBranch(const CBlock* pblock)\n@@ -369,15 +428,6 @@ bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMi\n     if ((int64)nLockTime > INT_MAX)\n         return error(\"AcceptToMemoryPool() : not accepting nLockTime beyond 2038 yet\");\n \n-    // Safety limits\n-    unsigned int nSize = ::GetSerializeSize(*this, SER_NETWORK);\n-    // Checking ECDSA signatures is a CPU bottleneck, so to avoid denial-of-service\n-    // attacks disallow transactions with more than one SigOp per 34 bytes.\n-    // 34 bytes because a TxOut is:\n-    //   20-byte address + 8 byte bitcoin amount + 5 bytes of ops + 1 byte script length\n-    if (GetSigOpCount() > nSize / 34 || nSize < 100)\n-        return error(\"AcceptToMemoryPool() : transaction with out-of-bounds SigOpCount\");\n-\n     // Rather not work on nonstandard transactions (unless -testnet)\n     if (!fTestNet && !IsStandard())\n         return error(\"AcceptToMemoryPool() : nonstandard transaction type\");\n@@ -421,15 +471,34 @@ bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMi\n \n     if (fCheckInputs)\n     {\n-        // Check against previous transactions\n+        map<uint256, pair<CTxIndex, CTransaction> > mapInputs;\n         map<uint256, CTxIndex> mapUnused;\n+        if (!FetchInputs(txdb, mapUnused, false, false, mapInputs))\n+        {\n+            if (pfMissingInputs)\n+                *pfMissingInputs = true;\n+            return error(\"AcceptToMemoryPool() : FetchInputs failed %s\", hash.ToString().substr(0,10).c_str());\n+        }\n+\n+        // Check for non-standard OP_EVALs in inputs\n+        if (!IsStandardInputs(mapInputs))\n+            return error(\"AcceptToMemoryPool() : nonstandard transaction input\");\n+\n+        // Check against previous transactions\n         int64 nFees = 0;\n-        if (!ConnectInputs(txdb, mapUnused, CDiskTxPos(1,1,1), pindexBest, nFees, false, false))\n+        int nSigOps = 0;\n+        if (!ConnectInputs(mapInputs, mapUnused, CDiskTxPos(1,1,1), pindexBest, nFees, false, false, nSigOps))\n         {\n             if (pfMissingInputs)\n                 *pfMissingInputs = true;\n             return error(\"AcceptToMemoryPool() : ConnectInputs failed %s\", hash.ToString().substr(0,10).c_str());\n         }\n+        // Checking ECDSA signatures is a CPU bottleneck, so to avoid denial-of-service\n+        // attacks disallow transactions with more than one SigOp per 65 bytes.\n+        // 65 bytes because that is the minimum size of an ECDSA signature\n+        unsigned int nSize = ::GetSerializeSize(*this, SER_NETWORK);\n+        if (nSigOps > nSize / 65 || nSize < 100)\n+            return error(\"AcceptToMemoryPool() : transaction with out-of-bounds SigOpCount\");\n \n         // Don't accept it if it can't get into a block\n         if (nFees < GetMinFee(1000, true, true))\n@@ -826,8 +895,61 @@ bool CTransaction::DisconnectInputs(CTxDB& txdb)\n }\n \n \n-bool CTransaction::ConnectInputs(CTxDB& txdb, map<uint256, CTxIndex>& mapTestPool, CDiskTxPos posThisTx,\n-                                 CBlockIndex* pindexBlock, int64& nFees, bool fBlock, bool fMiner, int64 nMinFee)\n+bool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTestPool,\n+                               bool fBlock, bool fMiner, map<uint256, pair<CTxIndex, CTransaction> >& inputsRet)\n+{\n+    if (IsCoinBase())\n+        return true; // Coinbase transactions have no inputs to fetch.\n+    \n+    for (int i = 0; i < vin.size(); i++)\n+    {\n+        COutPoint prevout = vin[i].prevout;\n+        if (inputsRet.count(prevout.hash))\n+            continue; // Got it already\n+\n+        // Read txindex\n+        CTxIndex& txindex = inputsRet[prevout.hash].first;\n+        bool fFound = true;\n+        if ((fBlock || fMiner) && mapTestPool.count(prevout.hash))\n+        {\n+            // Get txindex from current proposed changes\n+            txindex = mapTestPool.find(prevout.hash)->second;\n+        }\n+        else\n+        {\n+            // Read txindex from txdb\n+            fFound = txdb.ReadTxIndex(prevout.hash, txindex);\n+        }\n+        if (!fFound && (fBlock || fMiner))\n+            return fMiner ? false : error(\"FetchInputs() : %s prev tx %s index entry not found\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n+\n+        // Read txPrev\n+        CTransaction& txPrev = inputsRet[prevout.hash].second;\n+        if (!fFound || txindex.pos == CDiskTxPos(1,1,1))\n+        {\n+            // Get prev tx from single transactions in memory\n+            CRITICAL_BLOCK(cs_mapTransactions)\n+            {\n+                if (!mapTransactions.count(prevout.hash))\n+                    return error(\"FetchInputs() : %s mapTransactions prev not found %s\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n+                txPrev = mapTransactions[prevout.hash];\n+            }\n+            if (!fFound)\n+                txindex.vSpent.resize(txPrev.vout.size());\n+        }\n+        else\n+        {\n+            // Get prev tx from disk\n+            if (!txPrev.ReadFromDisk(txindex.pos))\n+                return error(\"FetchInputs() : %s ReadFromDisk prev tx %s failed\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n+        }\n+    }\n+    return true;\n+}\n+\n+bool CTransaction::ConnectInputs(map<uint256, pair<CTxIndex, CTransaction> > inputs,\n+                                 map<uint256, CTxIndex>& mapTestPool, CDiskTxPos posThisTx,\n+                                 CBlockIndex* pindexBlock, int64& nFees, bool fBlock, bool fMiner, int& nSigOpsRet, int64 nMinFee)\n {\n     // Take over previous transactions' spent pointers\n     // fBlock is true when this is called from AcceptBlock when a new best-block is added to the blockchain\n@@ -839,43 +961,9 @@ bool CTransaction::ConnectInputs(CTxDB& txdb, map<uint256, CTxIndex>& mapTestPoo\n         for (int i = 0; i < vin.size(); i++)\n         {\n             COutPoint prevout = vin[i].prevout;\n-\n-            // Read txindex\n-            CTxIndex txindex;\n-            bool fFound = true;\n-            if ((fBlock || fMiner) && mapTestPool.count(prevout.hash))\n-            {\n-                // Get txindex from current proposed changes\n-                txindex = mapTestPool[prevout.hash];\n-            }\n-            else\n-            {\n-                // Read txindex from txdb\n-                fFound = txdb.ReadTxIndex(prevout.hash, txindex);\n-            }\n-            if (!fFound && (fBlock || fMiner))\n-                return fMiner ? false : error(\"ConnectInputs() : %s prev tx %s index entry not found\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n-\n-            // Read txPrev\n-            CTransaction txPrev;\n-            if (!fFound || txindex.pos == CDiskTxPos(1,1,1))\n-            {\n-                // Get prev tx from single transactions in memory\n-                CRITICAL_BLOCK(cs_mapTransactions)\n-                {\n-                    if (!mapTransactions.count(prevout.hash))\n-                        return error(\"ConnectInputs() : %s mapTransactions prev not found %s\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n-                    txPrev = mapTransactions[prevout.hash];\n-                }\n-                if (!fFound)\n-                    txindex.vSpent.resize(txPrev.vout.size());\n-            }\n-            else\n-            {\n-                // Get prev tx from disk\n-                if (!txPrev.ReadFromDisk(txindex.pos))\n-                    return error(\"ConnectInputs() : %s ReadFromDisk prev tx %s failed\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n-            }\n+            assert(inputs.count(prevout.hash) > 0);\n+            CTxIndex& txindex = inputs[prevout.hash].first;\n+            CTransaction& txPrev = inputs[prevout.hash].second;\n \n             if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n                 return DoS(100, error(\"ConnectInputs() : %s prevout.n out of range %d %d %d prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n@@ -891,7 +979,7 @@ bool CTransaction::ConnectInputs(CTxDB& txdb, map<uint256, CTxIndex>& mapTestPoo\n             // still computed and checked, and any change will be caught at the next checkpoint.\n             if (!(fBlock && IsInitialBlockDownload()))\n                 // Verify signature\n-                if (!VerifySignature(txPrev, *this, i))\n+                if (!VerifySignature(txPrev, *this, i, nSigOpsRet))\n                     return DoS(100,error(\"ConnectInputs() : %s VerifySignature failed\", GetHash().ToString().substr(0,10).c_str()));\n \n             // Check for conflicts (double-spend)\n@@ -965,7 +1053,8 @@ bool CTransaction::ClientConnectInputs()\n                 return false;\n \n             // Verify signature\n-            if (!VerifySignature(txPrev, *this, i))\n+            int nUnused = 0;\n+            if (!VerifySignature(txPrev, *this, i, nUnused))\n                 return error(\"ConnectInputs() : VerifySignature failed\");\n \n             ///// this is redundant with the mapNextTx stuff, not sure which I want to get rid of\n@@ -1023,14 +1112,21 @@ bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n \n     map<uint256, CTxIndex> mapQueuedChanges;\n     int64 nFees = 0;\n+    int nSigOps = 0;\n     BOOST_FOREACH(CTransaction& tx, vtx)\n     {\n         CDiskTxPos posThisTx(pindex->nFile, pindex->nBlockPos, nTxPos);\n         nTxPos += ::GetSerializeSize(tx, SER_DISK);\n \n-        if (!tx.ConnectInputs(txdb, mapQueuedChanges, posThisTx, pindex, nFees, true, false))\n+        map<uint256, pair<CTxIndex, CTransaction> > mapInputs;\n+        if (!tx.FetchInputs(txdb, mapQueuedChanges, true, false, mapInputs))\n+            return false;\n+        if (!tx.ConnectInputs(mapInputs, mapQueuedChanges, posThisTx, pindex, nFees, true, false, nSigOps))\n             return false;\n+        if (nSigOps > MAX_BLOCK_SIGOPS)\n+            return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n     }\n+\n     // Write queued txindex changes\n     for (map<uint256, CTxIndex>::iterator mi = mapQueuedChanges.begin(); mi != mapQueuedChanges.end(); ++mi)\n     {\n@@ -1291,8 +1387,21 @@ bool CBlock::CheckBlock() const\n         if (!tx.CheckTransaction())\n             return DoS(tx.nDoS, error(\"CheckBlock() : CheckTransaction failed\"));\n \n-    // Check that it's not full of nonstandard transactions\n-    if (GetSigOpCount() > MAX_BLOCK_SIGOPS)\n+    // This code should be removed when a compatibility-breaking block chain split has passed.\n+    // Compatibility check for old clients that counted sigops differently:\n+    int nSigOps = 0;\n+    BOOST_FOREACH(const CTransaction& tx, vtx)\n+    {\n+        BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+        {\n+            nSigOps += txin.scriptSig.GetSigOpCount();\n+        }\n+        BOOST_FOREACH(const CTxOut& txout, tx.vout)\n+        {\n+            nSigOps += txout.scriptPubKey.GetSigOpCount();\n+        }\n+    }\n+    if (nSigOps > MAX_BLOCK_SIGOPS)\n         return DoS(100, error(\"CheckBlock() : out-of-bounds SigOpCount\"));\n \n     // Check merkleroot\n@@ -2827,9 +2936,6 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n             unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK);\n             if (nBlockSize + nTxSize >= MAX_BLOCK_SIZE_GEN)\n                 continue;\n-            int nTxSigOps = tx.GetSigOpCount();\n-            if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n-                continue;\n \n             // Transaction fee required depends on block size\n             bool fAllowFree = (nBlockSize + nTxSize < 4000 || CTransaction::AllowFree(dPriority));\n@@ -2838,7 +2944,13 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n             // Connecting shouldn't fail due to dependency on other memory pool transactions\n             // because we're already processing them in order of dependency\n             map<uint256, CTxIndex> mapTestPoolTmp(mapTestPool);\n-            if (!tx.ConnectInputs(txdb, mapTestPoolTmp, CDiskTxPos(1,1,1), pindexPrev, nFees, false, true, nMinFee))\n+            map<uint256, pair<CTxIndex, CTransaction> > mapInputs;\n+            if (!tx.FetchInputs(txdb, mapTestPoolTmp, false, true, mapInputs))\n+                continue;\n+            int nTxSigOps = 0;\n+            if (!tx.ConnectInputs(mapInputs, mapTestPoolTmp, CDiskTxPos(1,1,1), pindexPrev, nFees, false, true, nTxSigOps, nMinFee))\n+                continue;\n+            if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n                 continue;\n             swap(mapTestPool, mapTestPoolTmp);\n "
      },
      {
        "sha": "bf31234c29402e3623740be256ac52a413a89e9f",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 7,
        "deletions": 29,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=e679ec969c8b22c676ebb10bea1038f6c8f13b33",
        "patch": "@@ -493,26 +493,8 @@ class CTransaction\n         return (vin.size() == 1 && vin[0].prevout.IsNull());\n     }\n \n-    int GetSigOpCount() const\n-    {\n-        int n = 0;\n-        BOOST_FOREACH(const CTxIn& txin, vin)\n-            n += txin.scriptSig.GetSigOpCount();\n-        BOOST_FOREACH(const CTxOut& txout, vout)\n-            n += txout.scriptPubKey.GetSigOpCount();\n-        return n;\n-    }\n-\n-    bool IsStandard() const\n-    {\n-        BOOST_FOREACH(const CTxIn& txin, vin)\n-            if (!txin.scriptSig.IsPushOnly())\n-                return error(\"nonstandard txin: %s\", txin.scriptSig.ToString().c_str());\n-        BOOST_FOREACH(const CTxOut& txout, vout)\n-            if (!::IsStandard(txout.scriptPubKey))\n-                return error(\"nonstandard txout: %s\", txout.scriptPubKey.ToString().c_str());\n-        return true;\n-    }\n+    bool IsStandard() const;\n+    bool IsStandardInputs(std::map<uint256, std::pair<CTxIndex, CTransaction> > mapInputs) const;\n \n     int64 GetValueOut() const\n     {\n@@ -640,8 +622,11 @@ class CTransaction\n     bool ReadFromDisk(CTxDB& txdb, COutPoint prevout);\n     bool ReadFromDisk(COutPoint prevout);\n     bool DisconnectInputs(CTxDB& txdb);\n-    bool ConnectInputs(CTxDB& txdb, std::map<uint256, CTxIndex>& mapTestPool, CDiskTxPos posThisTx,\n-                       CBlockIndex* pindexBlock, int64& nFees, bool fBlock, bool fMiner, int64 nMinFee=0);\n+    bool FetchInputs(CTxDB& txdb, const std::map<uint256, CTxIndex>& mapTestPool,\n+                     bool fBlock, bool fMiner, std::map<uint256, std::pair<CTxIndex, CTransaction> >& inputsRet);\n+    bool ConnectInputs(std::map<uint256, std::pair<CTxIndex, CTransaction> > inputs,\n+                       std::map<uint256, CTxIndex>& mapTestPool, CDiskTxPos posThisTx,\n+                       CBlockIndex* pindexBlock, int64& nFees, bool fBlock, bool fMiner, int& nSigOpsRet, int64 nMinFee=0);\n     bool ClientConnectInputs();\n     bool CheckTransaction() const;\n     bool AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs=true, bool* pfMissingInputs=NULL);\n@@ -851,13 +836,6 @@ class CBlock\n         return (int64)nTime;\n     }\n \n-    int GetSigOpCount() const\n-    {\n-        int n = 0;\n-        BOOST_FOREACH(const CTransaction& tx, vtx)\n-            n += tx.GetSigOpCount();\n-        return n;\n-    }\n \n \n     uint256 BuildMerkleTree() const"
      },
      {
        "sha": "c103d57510e279b96851b2af6817ff2f59d6428a",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 488,
        "deletions": 168,
        "changes": 656,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=e679ec969c8b22c676ebb10bea1038f6c8f13b33",
        "patch": "@@ -70,20 +70,186 @@ static inline void popstack(vector<valtype>& stack)\n }\n \n \n-bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, int nHashType)\n+const char* GetTxnTypeName(txntype t)\n+{\n+    switch (t)\n+    {\n+    case TX_NONSTANDARD: return \"nonstandard\";\n+    case TX_PUBKEY: return \"pubkey\";\n+    case TX_PUBKEYHASH: return \"pubkeyhash\";\n+    case TX_SCRIPTHASH: return \"scripthash\";\n+    case TX_MULTISIG: return \"multisig\";\n+    }\n+    return NULL;\n+}\n+\n+\n+const char* GetOpName(opcodetype opcode)\n+{\n+    switch (opcode)\n+    {\n+    // push value\n+    case OP_0                      : return \"0\";\n+    case OP_PUSHDATA1              : return \"OP_PUSHDATA1\";\n+    case OP_PUSHDATA2              : return \"OP_PUSHDATA2\";\n+    case OP_PUSHDATA4              : return \"OP_PUSHDATA4\";\n+    case OP_1NEGATE                : return \"-1\";\n+    case OP_RESERVED               : return \"OP_RESERVED\";\n+    case OP_1                      : return \"1\";\n+    case OP_2                      : return \"2\";\n+    case OP_3                      : return \"3\";\n+    case OP_4                      : return \"4\";\n+    case OP_5                      : return \"5\";\n+    case OP_6                      : return \"6\";\n+    case OP_7                      : return \"7\";\n+    case OP_8                      : return \"8\";\n+    case OP_9                      : return \"9\";\n+    case OP_10                     : return \"10\";\n+    case OP_11                     : return \"11\";\n+    case OP_12                     : return \"12\";\n+    case OP_13                     : return \"13\";\n+    case OP_14                     : return \"14\";\n+    case OP_15                     : return \"15\";\n+    case OP_16                     : return \"16\";\n+\n+    // control\n+    case OP_NOP                    : return \"OP_NOP\";\n+    case OP_VER                    : return \"OP_VER\";\n+    case OP_IF                     : return \"OP_IF\";\n+    case OP_NOTIF                  : return \"OP_NOTIF\";\n+    case OP_VERIF                  : return \"OP_VERIF\";\n+    case OP_VERNOTIF               : return \"OP_VERNOTIF\";\n+    case OP_ELSE                   : return \"OP_ELSE\";\n+    case OP_ENDIF                  : return \"OP_ENDIF\";\n+    case OP_VERIFY                 : return \"OP_VERIFY\";\n+    case OP_RETURN                 : return \"OP_RETURN\";\n+\n+    // stack ops\n+    case OP_TOALTSTACK             : return \"OP_TOALTSTACK\";\n+    case OP_FROMALTSTACK           : return \"OP_FROMALTSTACK\";\n+    case OP_2DROP                  : return \"OP_2DROP\";\n+    case OP_2DUP                   : return \"OP_2DUP\";\n+    case OP_3DUP                   : return \"OP_3DUP\";\n+    case OP_2OVER                  : return \"OP_2OVER\";\n+    case OP_2ROT                   : return \"OP_2ROT\";\n+    case OP_2SWAP                  : return \"OP_2SWAP\";\n+    case OP_IFDUP                  : return \"OP_IFDUP\";\n+    case OP_DEPTH                  : return \"OP_DEPTH\";\n+    case OP_DROP                   : return \"OP_DROP\";\n+    case OP_DUP                    : return \"OP_DUP\";\n+    case OP_NIP                    : return \"OP_NIP\";\n+    case OP_OVER                   : return \"OP_OVER\";\n+    case OP_PICK                   : return \"OP_PICK\";\n+    case OP_ROLL                   : return \"OP_ROLL\";\n+    case OP_ROT                    : return \"OP_ROT\";\n+    case OP_SWAP                   : return \"OP_SWAP\";\n+    case OP_TUCK                   : return \"OP_TUCK\";\n+\n+    // splice ops\n+    case OP_CAT                    : return \"OP_CAT\";\n+    case OP_SUBSTR                 : return \"OP_SUBSTR\";\n+    case OP_LEFT                   : return \"OP_LEFT\";\n+    case OP_RIGHT                  : return \"OP_RIGHT\";\n+    case OP_SIZE                   : return \"OP_SIZE\";\n+\n+    // bit logic\n+    case OP_INVERT                 : return \"OP_INVERT\";\n+    case OP_AND                    : return \"OP_AND\";\n+    case OP_OR                     : return \"OP_OR\";\n+    case OP_XOR                    : return \"OP_XOR\";\n+    case OP_EQUAL                  : return \"OP_EQUAL\";\n+    case OP_EQUALVERIFY            : return \"OP_EQUALVERIFY\";\n+    case OP_RESERVED1              : return \"OP_RESERVED1\";\n+    case OP_RESERVED2              : return \"OP_RESERVED2\";\n+\n+    // numeric\n+    case OP_1ADD                   : return \"OP_1ADD\";\n+    case OP_1SUB                   : return \"OP_1SUB\";\n+    case OP_2MUL                   : return \"OP_2MUL\";\n+    case OP_2DIV                   : return \"OP_2DIV\";\n+    case OP_NEGATE                 : return \"OP_NEGATE\";\n+    case OP_ABS                    : return \"OP_ABS\";\n+    case OP_NOT                    : return \"OP_NOT\";\n+    case OP_0NOTEQUAL              : return \"OP_0NOTEQUAL\";\n+    case OP_ADD                    : return \"OP_ADD\";\n+    case OP_SUB                    : return \"OP_SUB\";\n+    case OP_MUL                    : return \"OP_MUL\";\n+    case OP_DIV                    : return \"OP_DIV\";\n+    case OP_MOD                    : return \"OP_MOD\";\n+    case OP_LSHIFT                 : return \"OP_LSHIFT\";\n+    case OP_RSHIFT                 : return \"OP_RSHIFT\";\n+    case OP_BOOLAND                : return \"OP_BOOLAND\";\n+    case OP_BOOLOR                 : return \"OP_BOOLOR\";\n+    case OP_NUMEQUAL               : return \"OP_NUMEQUAL\";\n+    case OP_NUMEQUALVERIFY         : return \"OP_NUMEQUALVERIFY\";\n+    case OP_NUMNOTEQUAL            : return \"OP_NUMNOTEQUAL\";\n+    case OP_LESSTHAN               : return \"OP_LESSTHAN\";\n+    case OP_GREATERTHAN            : return \"OP_GREATERTHAN\";\n+    case OP_LESSTHANOREQUAL        : return \"OP_LESSTHANOREQUAL\";\n+    case OP_GREATERTHANOREQUAL     : return \"OP_GREATERTHANOREQUAL\";\n+    case OP_MIN                    : return \"OP_MIN\";\n+    case OP_MAX                    : return \"OP_MAX\";\n+    case OP_WITHIN                 : return \"OP_WITHIN\";\n+\n+    // crypto\n+    case OP_RIPEMD160              : return \"OP_RIPEMD160\";\n+    case OP_SHA1                   : return \"OP_SHA1\";\n+    case OP_SHA256                 : return \"OP_SHA256\";\n+    case OP_HASH160                : return \"OP_HASH160\";\n+    case OP_HASH256                : return \"OP_HASH256\";\n+    case OP_CODESEPARATOR          : return \"OP_CODESEPARATOR\";\n+    case OP_CHECKSIG               : return \"OP_CHECKSIG\";\n+    case OP_CHECKSIGVERIFY         : return \"OP_CHECKSIGVERIFY\";\n+    case OP_CHECKMULTISIG          : return \"OP_CHECKMULTISIG\";\n+    case OP_CHECKMULTISIGVERIFY    : return \"OP_CHECKMULTISIGVERIFY\";\n+\n+    // meta\n+    case OP_EVAL                   : return \"OP_EVAL\";\n+\n+    // expanson\n+    case OP_NOP2                   : return \"OP_NOP2\";\n+    case OP_NOP3                   : return \"OP_NOP3\";\n+    case OP_NOP4                   : return \"OP_NOP4\";\n+    case OP_NOP5                   : return \"OP_NOP5\";\n+    case OP_NOP6                   : return \"OP_NOP6\";\n+    case OP_NOP7                   : return \"OP_NOP7\";\n+    case OP_NOP8                   : return \"OP_NOP8\";\n+    case OP_NOP9                   : return \"OP_NOP9\";\n+    case OP_NOP10                  : return \"OP_NOP10\";\n+\n+\n+\n+    // template matching params\n+    case OP_SCRIPTHASH             : return \"OP_SCRIPTHASH\";\n+    case OP_PUBKEYHASH             : return \"OP_PUBKEYHASH\";\n+    case OP_PUBKEY                 : return \"OP_PUBKEY\";\n+\n+    case OP_INVALIDOPCODE          : return \"OP_INVALIDOPCODE\";\n+    default:\n+        return \"OP_UNKNOWN\";\n+    }\n+}\n+\n+\n+//\n+// Returns true if script is valid.\n+//\n+bool EvalScriptInner(vector<vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, int nHashType,\n+                     CScript::const_iterator pbegincodehash, CScript::const_iterator pendcodehash, int& nOpCount, int& nSigOpCount, int nRecurseDepth)\n {\n     CAutoBN_CTX pctx;\n     CScript::const_iterator pc = script.begin();\n     CScript::const_iterator pend = script.end();\n-    CScript::const_iterator pbegincodehash = script.begin();\n     opcodetype opcode;\n     valtype vchPushValue;\n     vector<bool> vfExec;\n     vector<valtype> altstack;\n     if (script.size() > 10000)\n         return false;\n-    int nOpCount = 0;\n \n+    // Limit OP_EVAL recursion\n+    if (nRecurseDepth > 2)\n+        return false;\n \n     try\n     {\n@@ -155,7 +321,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, co\n                 // Control\n                 //\n                 case OP_NOP:\n-                case OP_NOP1: case OP_NOP2: case OP_NOP3: case OP_NOP4: case OP_NOP5:\n+                case OP_NOP2: case OP_NOP3: case OP_NOP4: case OP_NOP5:\n                 case OP_NOP6: case OP_NOP7: case OP_NOP8: case OP_NOP9: case OP_NOP10:\n                 break;\n \n@@ -751,12 +917,13 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, co\n                     //PrintHex(vchPubKey.begin(), vchPubKey.end(), \"pubkey: %s\\n\");\n \n                     // Subset of script starting at the most recent codeseparator\n-                    CScript scriptCode(pbegincodehash, pend);\n+                    CScript scriptCode(pbegincodehash, pendcodehash);\n \n                     // Drop the signature, since there's no way for a signature to sign itself\n                     scriptCode.FindAndDelete(CScript(vchSig));\n \n                     bool fSuccess = CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType);\n+                    nSigOpCount++;\n \n                     popstack(stack);\n                     popstack(stack);\n@@ -800,7 +967,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, co\n                         return false;\n \n                     // Subset of script starting at the most recent codeseparator\n-                    CScript scriptCode(pbegincodehash, pend);\n+                    CScript scriptCode(pbegincodehash, pendcodehash);\n \n                     // Drop the signatures, since there's no way for a signature to sign itself\n                     for (int k = 0; k < nSigsCount; k++)\n@@ -823,6 +990,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, co\n                         }\n                         ikey++;\n                         nKeysCount--;\n+                        nSigOpCount++;\n \n                         // If there are more signatures left than keys left,\n                         // then too many signatures have failed\n@@ -844,6 +1012,26 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, co\n                 }\n                 break;\n \n+                case OP_EVAL:\n+                {\n+                    // Evaluate the top item on the stack as a Script\n+                    // [serialized script ] -- [result(s) of executing script]\n+                    if (stack.size() < 1)\n+                        return false;\n+                    valtype& vchScript = stacktop(-1);\n+                    CScript subscript(vchScript.begin(), vchScript.end());\n+                    popstack(stack);\n+                    \n+                    // Codeseparators not allowed\n+                    if (subscript.Find(OP_CODESEPARATOR))\n+                        return false;\n+\n+                    if (!EvalScriptInner(stack, subscript, txTo, nIn, nHashType,\n+                                         pbegincodehash, pendcodehash, nOpCount, nSigOpCount, nRecurseDepth++))\n+                        return false;\n+                }\n+                break;\n+\n                 default:\n                     return false;\n             }\n@@ -865,6 +1053,17 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, co\n     return true;\n }\n \n+bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script,\n+                const CTransaction& txTo, unsigned int nIn, int nHashType, int& nSigOpCountRet)\n+{\n+    CScript::const_iterator pbegincodehash = script.begin();\n+    CScript::const_iterator pendcodehash = script.end();\n+\n+    int nOpCount = 0;\n+    return EvalScriptInner(stack, script, txTo, nIn, nHashType, pbegincodehash, pendcodehash,\n+                           nOpCount, nSigOpCountRet, 0);\n+}\n+\n \n \n \n@@ -964,38 +1163,35 @@ bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CSc\n \n \n //\n-// Returns lists of public keys (or public key hashes), any one of which can\n-// satisfy scriptPubKey\n+// Return public keys or hashes from scriptPubKey, for 'standard' transaction types.\n //\n-bool Solver(const CScript& scriptPubKey, vector<vector<pair<opcodetype, valtype> > >& vSolutionsRet)\n+bool Solver(const CScript& scriptPubKey, txntype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n {\n     // Templates\n-    static vector<CScript> vTemplates;\n-    if (vTemplates.empty())\n+    static map<txntype, CScript> mTemplates;\n+    if (mTemplates.empty())\n     {\n         // Standard tx, sender provides pubkey, receiver adds signature\n-        vTemplates.push_back(CScript() << OP_PUBKEY << OP_CHECKSIG);\n+        mTemplates.insert(make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n \n         // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n-        vTemplates.push_back(CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG);\n-\n-        // Sender provides two pubkeys, receivers provides two signatures\n-        vTemplates.push_back(CScript() << OP_2 << OP_PUBKEY << OP_PUBKEY << OP_2 << OP_CHECKMULTISIG);\n+        mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n \n-        // Sender provides two pubkeys, receivers provides one of two signatures\n-        vTemplates.push_back(CScript() << OP_1 << OP_PUBKEY << OP_PUBKEY << OP_2 << OP_CHECKMULTISIG);\n+        // Sender provides N pubkeys, receivers provides M signatures\n+        mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n \n-        // Sender provides three pubkeys, receiver provides 2 of 3 signatures.\n-        vTemplates.push_back(CScript() << OP_2 << OP_PUBKEY << OP_PUBKEY << OP_PUBKEY << OP_3 << OP_CHECKMULTISIG);\n+        // Sender provides script hash, receiver provides script and\n+        // as many signatures as required to satisfy script\n+        mTemplates.insert(make_pair(TX_SCRIPTHASH, CScript() << OP_DUP << OP_HASH160 << OP_SCRIPTHASH << OP_EQUALVERIFY << OP_EVAL));\n     }\n \n     // Scan templates\n     const CScript& script1 = scriptPubKey;\n-    BOOST_FOREACH(const CScript& script2, vTemplates)\n+    BOOST_FOREACH(const PAIRTYPE(txntype, CScript)& tplate, mTemplates)\n     {\n+        const CScript& script2 = tplate.second;\n         vSolutionsRet.clear();\n \n-        vector<pair<opcodetype, valtype> > currentSolution;\n         opcodetype opcode1, opcode2;\n         vector<unsigned char> vch1, vch2;\n \n@@ -1006,218 +1202,333 @@ bool Solver(const CScript& scriptPubKey, vector<vector<pair<opcodetype, valtype>\n         {\n             if (pc1 == script1.end() && pc2 == script2.end())\n             {\n-                return !vSolutionsRet.empty();\n+                // Found a match\n+                typeRet = tplate.first;\n+                if (typeRet == TX_MULTISIG)\n+                {\n+                    // Additional checks for TX_MULTISIG:\n+                    unsigned char m = vSolutionsRet.front()[0];\n+                    unsigned char n = vSolutionsRet.back()[0];\n+                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size()-2 != n)\n+                        return false;\n+                }\n+                return true;\n             }\n             if (!script1.GetOp(pc1, opcode1, vch1))\n                 break;\n             if (!script2.GetOp(pc2, opcode2, vch2))\n                 break;\n+\n+            // Template matching opcodes:\n+            if (opcode2 == OP_PUBKEYS)\n+            {\n+                while (vch1.size() >= 33 && vch1.size() <= 120)\n+                {\n+                    vSolutionsRet.push_back(vch1);\n+                    if (!script1.GetOp(pc1, opcode1, vch1))\n+                        break;\n+                }\n+                if (!script2.GetOp(pc2, opcode2, vch2))\n+                    break;\n+                // Normal situation is to fall through\n+                // to other if/else statments\n+            }\n+\n             if (opcode2 == OP_PUBKEY)\n             {\n                 if (vch1.size() < 33 || vch1.size() > 120)\n                     break;\n-                currentSolution.push_back(make_pair(opcode2, vch1));\n+                vSolutionsRet.push_back(vch1);\n             }\n             else if (opcode2 == OP_PUBKEYHASH)\n             {\n                 if (vch1.size() != sizeof(uint160))\n                     break;\n-                currentSolution.push_back(make_pair(opcode2, vch1));\n+                vSolutionsRet.push_back(vch1);\n             }\n-            else if (opcode2 == OP_CHECKSIG)\n+            else if (opcode2 == OP_SCRIPTHASH)\n             {\n-                vSolutionsRet.push_back(currentSolution);\n-                currentSolution.clear();\n+                if (vch1.size() != sizeof(uint160))\n+                    break;\n+                vSolutionsRet.push_back(vch1);\n             }\n-            else if (opcode2 == OP_CHECKMULTISIG)\n-            {   // Dig out the \"m\" from before the pubkeys:\n-                CScript::const_iterator it = script2.begin();\n-                opcodetype op_m;\n-                script2.GetOp(it, op_m, vch1);\n-                int m = CScript::DecodeOP_N(op_m);\n-                int n = currentSolution.size();\n-\n-                if (m == 2 && n == 2)\n+            else if (opcode2 == OP_SMALLINTEGER)\n+            {   // Single-byte small integer pushed onto vSolutions\n+                if (opcode1 == OP_0 ||\n+                    (opcode1 >= OP_1 && opcode1 <= OP_16))\n                 {\n-                    vSolutionsRet.push_back(currentSolution);\n-                    currentSolution.clear();\n-                }\n-                else if (m == 1 && n == 2)\n-                { // 2 solutions: either first key or second\n-                    for (int i = 0; i < 2; i++)\n-                    {\n-                        vector<pair<opcodetype, valtype> > s;\n-                        s.push_back(currentSolution[i]);\n-                        vSolutionsRet.push_back(s);\n-                    }\n-                    currentSolution.clear();\n-                }\n-                else if (m == 2 && n == 3)\n-                { // 3 solutions: any pair\n-                    for (int i = 0; i < 2; i++)\n-                        for (int j = i+1; j < 3; j++)\n-                        {\n-                            vector<pair<opcodetype, valtype> > s;\n-                            s.push_back(currentSolution[i]);\n-                            s.push_back(currentSolution[j]);\n-                            vSolutionsRet.push_back(s);\n-                        }\n-                    currentSolution.clear();\n+                    char n = (char)CScript::DecodeOP_N(opcode1);\n+                    vSolutionsRet.push_back(valtype(1, n));\n                 }\n+                else\n+                    break;\n             }\n             else if (opcode1 != opcode2 || vch1 != vch2)\n             {\n+                // Others must match exactly\n                 break;\n             }\n         }\n     }\n \n     vSolutionsRet.clear();\n+    typeRet = TX_NONSTANDARD;\n     return false;\n }\n \n \n-bool Solver(const CKeyStore& keystore, const CScript& scriptPubKey, uint256 hash, int nHashType, CScript& scriptSigRet)\n+bool Sign1(const CBitcoinAddress& address, const CKeyStore& keystore, uint256 hash, int nHashType, CScript& scriptSigRet)\n {\n-    scriptSigRet.clear();\n+    CKey key;\n+    if (!keystore.GetKey(address, key))\n+        return false;\n \n-    vector<vector<pair<opcodetype, valtype> > > vSolutions;\n-    if (!Solver(scriptPubKey, vSolutions))\n+    vector<unsigned char> vchSig;\n+    if (!key.Sign(hash, vchSig))\n         return false;\n+    vchSig.push_back((unsigned char)nHashType);\n+    scriptSigRet << vchSig;\n \n-    // See if we have all the keys for any of the solutions:\n-    int whichSolution = -1;\n-    for (int i = 0; i < vSolutions.size(); i++)\n-    {\n-        int keysFound = 0;\n-        CScript scriptSig;\n+    return true;\n+}\n \n-        BOOST_FOREACH(PAIRTYPE(opcodetype, valtype)& item, vSolutions[i])\n-        {\n-            if (item.first == OP_PUBKEY)\n-            {\n-                const valtype& vchPubKey = item.second;\n-                CKey key;\n-                vector<unsigned char> vchSig;\n-                if (keystore.GetKey(Hash160(vchPubKey), key) && key.GetPubKey() == vchPubKey\n-                    && hash != 0 && key.Sign(hash, vchSig))\n-                {\n-                    vchSig.push_back((unsigned char)nHashType);\n-                    scriptSig << vchSig;\n-                    ++keysFound;\n-                }\n-            }\n-            else if (item.first == OP_PUBKEYHASH)\n-            {\n-                CKey key;\n-                vector<unsigned char> vchSig;\n-                if (keystore.GetKey(uint160(item.second), key) \n-                    && hash != 0 && key.Sign(hash, vchSig))\n-                {\n-                    vchSig.push_back((unsigned char)nHashType);\n-                    scriptSig << vchSig << key.GetPubKey();\n-                    ++keysFound;\n-                }\n-            }\n-        }\n-        if (keysFound == vSolutions[i].size())\n+bool SignN(const vector<valtype>& multisigdata, const CKeyStore& keystore, uint256 hash, int nHashType, CScript& scriptSigRet)\n+{\n+    int nSigned = 0;\n+    int nRequired = multisigdata.front()[0];\n+    for (vector<valtype>::const_iterator it = multisigdata.begin()+1; it != multisigdata.begin()+multisigdata.size()-1; it++)\n+    {\n+        const valtype& pubkey = *it;\n+        CBitcoinAddress address;\n+        address.SetPubKey(pubkey);\n+        if (Sign1(address, keystore, hash, nHashType, scriptSigRet))\n         {\n-            whichSolution = i;\n-            scriptSigRet = scriptSig;\n-            break;\n+            ++nSigned;\n+            if (nSigned == nRequired) break;\n         }\n     }\n-    if (whichSolution == -1)\n+    return nSigned==nRequired;\n+}\n+\n+//\n+// Sign scriptPubKey with private keys stored in keystore, given transaction hash and hash type.\n+// Signatures are returned in scriptSigRet (or returns false if scriptPubKey can't be signed).\n+// Returns true if scriptPubKey could be completely satisified.\n+//\n+bool Solver(const CKeyStore& keystore, const CScript& scriptPubKey, uint256 hash, int nHashType, CScript& scriptSigRet)\n+{\n+    scriptSigRet.clear();\n+\n+    txntype whichType;\n+    vector<valtype> vSolutions;\n+    if (!Solver(scriptPubKey, whichType, vSolutions))\n         return false;\n \n-    // CHECKMULTISIG bug workaround:\n-    if (vSolutions.size() != 1 ||\n-        vSolutions[0].size() != 1)\n+    CBitcoinAddress address;\n+    valtype subscript;\n+    switch (whichType)\n     {\n-        scriptSigRet.insert(scriptSigRet.begin(), OP_0);\n+    case TX_NONSTANDARD:\n+        return false;\n+    case TX_PUBKEY:\n+        address.SetPubKey(vSolutions[0]);\n+        return Sign1(address, keystore, hash, nHashType, scriptSigRet);\n+    case TX_PUBKEYHASH:\n+        address.SetHash160(uint160(vSolutions[0]));\n+        if (!Sign1(address, keystore, hash, nHashType, scriptSigRet))\n+            return false;\n+        else\n+        {\n+            valtype vch;\n+            keystore.GetPubKey(address, vch);\n+            scriptSigRet << vch;\n+        }\n+        break;\n+    case TX_SCRIPTHASH:\n+        if (!keystore.GetCScript(uint160(vSolutions[0]), subscript))\n+            return false;\n+        if (!Solver(keystore, CScript(subscript.begin(), subscript.end()), hash, nHashType, scriptSigRet))\n+            return false;\n+        if (hash != 0)\n+            scriptSigRet << subscript; // signatures AND serialized script\n+        break;\n+    case TX_MULTISIG:\n+        scriptSigRet << OP_0; // workaround CHECKMULTISIG bug\n+        return (SignN(vSolutions, keystore, hash, nHashType, scriptSigRet));\n     }\n-\n     return true;\n }\n \n \n bool IsStandard(const CScript& scriptPubKey)\n {\n-    vector<vector<pair<opcodetype, valtype> > > vSolutions;\n-    return Solver(scriptPubKey, vSolutions);\n+    vector<valtype> vSolutions;\n+    txntype whichType;\n+    if (!Solver(scriptPubKey, whichType, vSolutions))\n+        return false;\n+\n+    if (whichType == TX_MULTISIG)\n+    {\n+        unsigned char m = vSolutions.front()[0];\n+        unsigned char n = vSolutions.back()[0];\n+        // Support up to x-of-3 multisig txns as standard\n+        if (n < 1 || n > 3)\n+            return false;\n+        if (m < 1 || m > n)\n+            return false;\n+    }\n+\n+    return whichType != TX_NONSTANDARD;\n }\n \n \n+int HaveKeys(const vector<valtype>& pubkeys, const CKeyStore& keystore)\n+{\n+    int nResult = 0;\n+    BOOST_FOREACH(const valtype& pubkey, pubkeys)\n+    {\n+        CBitcoinAddress address;\n+        address.SetPubKey(pubkey);\n+        if (keystore.HaveKey(address))\n+            ++nResult;\n+    }\n+    return nResult;\n+}\n+\n bool IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n {\n-    vector<vector<pair<opcodetype, valtype> > > vSolutions;\n-    if (!Solver(scriptPubKey, vSolutions))\n+    vector<valtype> vSolutions;\n+    txntype whichType;\n+    if (!Solver(scriptPubKey, whichType, vSolutions))\n         return false;\n \n-    int keysFound = 0;\n-    int keysRequired = 0;\n-    for (int i = 0; i < vSolutions.size(); i++)\n+    CBitcoinAddress address;\n+    switch (whichType)\n     {\n-        BOOST_FOREACH(PAIRTYPE(opcodetype, valtype)& item, vSolutions[i])\n-        {\n-            ++keysRequired;\n-            if (item.first == OP_PUBKEY)\n-            {\n-                const valtype& vchPubKey = item.second;\n-                vector<unsigned char> vchPubKeyFound;\n-                if (keystore.GetPubKey(Hash160(vchPubKey), vchPubKeyFound) && vchPubKeyFound == vchPubKey)\n-                    ++keysFound;\n-            }\n-            else if (item.first == OP_PUBKEYHASH)\n-            {\n-                if (keystore.HaveKey(uint160(item.second)))\n-                    ++keysFound;\n-            }\n-        }\n+    case TX_NONSTANDARD:\n+        return false;\n+    case TX_PUBKEY:\n+        address.SetPubKey(vSolutions[0]);\n+        return keystore.HaveKey(address);\n+    case TX_PUBKEYHASH:\n+        address.SetHash160(uint160(vSolutions[0]));\n+        return keystore.HaveKey(address);\n+    case TX_SCRIPTHASH:\n+    {\n+        valtype subscript;\n+        if (!keystore.GetCScript(uint160(vSolutions[0]), subscript))\n+            return false;\n+        return IsMine(keystore, CScript(subscript.begin(), subscript.end()));\n     }\n-\n-    // Only consider transactions \"mine\" if we own ALL the\n-    // keys involved. multi-signature transactions that are\n-    // partially owned (somebody else has a key that can spend\n-    // them) enable spend-out-from-under-you attacks, especially\n-    // for shared-wallet situations.\n-    return (keysFound == keysRequired);\n+    case TX_MULTISIG:\n+    {\n+        // Only consider transactions \"mine\" if we own ALL the\n+        // keys involved. multi-signature transactions that are\n+        // partially owned (somebody else has a key that can spend\n+        // them) enable spend-out-from-under-you attacks, especially\n+        // in shared-wallet situations.\n+        vector<valtype> keys(vSolutions.begin()+1, vSolutions.begin()+vSolutions.size()-1);\n+        return HaveKeys(vSolutions, keystore);\n+    }\n+    }\n+    return false;\n }\n \n bool ExtractAddress(const CScript& scriptPubKey, const CKeyStore* keystore, CBitcoinAddress& addressRet)\n {\n-    vector<vector<pair<opcodetype, valtype> > > vSolutions;\n-    if (!Solver(scriptPubKey, vSolutions))\n+    vector<valtype> vSolutions;\n+    txntype whichType;\n+    if (!Solver(scriptPubKey, whichType, vSolutions))\n         return false;\n \n-    for (int i = 0; i < vSolutions.size(); i++)\n+    if (whichType == TX_PUBKEY)\n     {\n-        if (vSolutions[i].size() != 1)\n-            continue; // Can't return more than one address...\n-\n-        PAIRTYPE(opcodetype, valtype)& item = vSolutions[i][0];\n-        if (item.first == OP_PUBKEY)\n-            addressRet.SetPubKey(item.second);\n-        else if (item.first == OP_PUBKEYHASH)\n-            addressRet.SetHash160((uint160)item.second);\n-        if (keystore == NULL || keystore->HaveKey(addressRet))\n-            return true;\n+        addressRet.SetPubKey(vSolutions[0]);\n+        return true;\n     }\n+    else if (whichType == TX_PUBKEYHASH)\n+    {\n+        addressRet.SetHash160(uint160(vSolutions[0]));\n+        return true;\n+    }\n+    else if (whichType == TX_SCRIPTHASH)\n+    {\n+        addressRet.SetScriptHash160(uint160(vSolutions[0]));\n+        return true;\n+    }\n+    // Multisig txns have more than one address...\n     return false;\n }\n \n+bool ExtractAddresses(const CScript& scriptPubKey, const CKeyStore* keystore, txntype& typeRet, vector<CBitcoinAddress>& addressRet, int& nRequiredRet)\n+{\n+    addressRet.clear();\n+    typeRet = TX_NONSTANDARD;\n+    vector<valtype> vSolutions;\n+    if (!Solver(scriptPubKey, typeRet, vSolutions))\n+        return false;\n \n+    if (typeRet == TX_MULTISIG)\n+    {\n+        nRequiredRet = vSolutions.front()[0];\n+        int n = vSolutions.back()[0];\n+        for (vector<valtype>::const_iterator it = vSolutions.begin()+1; it != vSolutions.begin()+vSolutions.size()-1; it++)\n+        {\n+            CBitcoinAddress address;\n+            address.SetPubKey(*it);\n+            addressRet.push_back(address);\n+        }\n+    }\n+    else\n+    {\n+        nRequiredRet = 1;\n+        CBitcoinAddress address;\n+        if (typeRet == TX_PUBKEYHASH)\n+            address.SetHash160(uint160(vSolutions.front()));\n+        else if (typeRet == TX_SCRIPTHASH)\n+            address.SetScriptHash160(uint160(vSolutions.front()));\n+        else if (typeRet == TX_PUBKEY)\n+            address.SetPubKey(vSolutions.front());\n+        addressRet.push_back(address);\n+    }\n \n-bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, int nHashType)\n+    return true;\n+}\n+\n+bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, int& nSigOpCountRet, int nHashType)\n {\n     vector<vector<unsigned char> > stack;\n-    if (!EvalScript(stack, scriptSig, txTo, nIn, nHashType))\n+    if (!EvalScript(stack, scriptSig, txTo, nIn, nHashType, nSigOpCountRet))\n         return false;\n-    if (!EvalScript(stack, scriptPubKey, txTo, nIn, nHashType))\n+    if (!EvalScript(stack, scriptPubKey, txTo, nIn, nHashType, nSigOpCountRet))\n         return false;\n     if (stack.empty())\n         return false;\n-    return CastToBool(stack.back());\n+    bool fResult = CastToBool(stack.back());\n+\n+    // This code should be removed when a compatibility-breaking block chain split has passed.\n+    // Special check for OP_EVAL backwards-compatibility: if scriptPubKey or scriptSig contains\n+    // OP_EVAL, then result must be identical if OP_EVAL is treated as a no-op:\n+    if (scriptSig.Find(OP_EVAL)+scriptPubKey.Find(OP_EVAL) > 0)\n+    {\n+        int nUnused = 0;\n+        stack.clear();\n+        CScript sigCopy = scriptSig;\n+        sigCopy.FindAndDelete(CScript(OP_EVAL));\n+        CScript pubKeyCopy = scriptPubKey;\n+        pubKeyCopy.FindAndDelete(CScript(OP_EVAL));\n+\n+        if (!EvalScript(stack, sigCopy, txTo, nIn, nHashType, nUnused))\n+            return false;\n+        if (!EvalScript(stack, pubKeyCopy, txTo, nIn, nHashType, nUnused))\n+            return false;\n+        if (stack.empty())\n+            return false;\n+        if (fResult != CastToBool(stack.back()))\n+            return false;\n+    }\n+\n+    return fResult;\n }\n \n \n@@ -1238,15 +1549,16 @@ bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CTrans\n     txin.scriptSig = scriptPrereq + txin.scriptSig;\n \n     // Test solution\n+    int nUnused = 0;\n     if (scriptPrereq.empty())\n-        if (!VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, 0))\n+        if (!VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, nUnused, 0))\n             return false;\n \n     return true;\n }\n \n \n-bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, int nHashType)\n+bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, int& nSigOpCountRet, int nHashType)\n {\n     assert(nIn < txTo.vin.size());\n     const CTxIn& txin = txTo.vin[nIn];\n@@ -1257,27 +1569,35 @@ bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsig\n     if (txin.prevout.hash != txFrom.GetHash())\n         return false;\n \n-    if (!VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, nHashType))\n+    if (!VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, nSigOpCountRet, nHashType))\n         return false;\n \n     return true;\n }\n \n-void CScript::SetMultisigAnd(const std::vector<CKey>& keys)\n+void CScript::SetBitcoinAddress(const CBitcoinAddress& address)\n {\n-    assert(keys.size() >= 2);\n     this->clear();\n-    *this << OP_2 << keys[0].GetPubKey() << keys[1].GetPubKey() << OP_2 << OP_CHECKMULTISIG;\n+    if (address.IsScript())\n+        *this << OP_DUP << OP_HASH160 << address.GetHash160() << OP_EQUALVERIFY << OP_EVAL;\n+    else\n+        *this << OP_DUP << OP_HASH160 << address.GetHash160() << OP_EQUALVERIFY << OP_CHECKSIG;\n }\n-void CScript::SetMultisigOr(const std::vector<CKey>& keys)\n+\n+void CScript::SetMultisig(int nRequired, const std::vector<CKey>& keys)\n {\n-    assert(keys.size() >= 2);\n     this->clear();\n-    *this << OP_1 << keys[0].GetPubKey() << keys[1].GetPubKey() << OP_2 << OP_CHECKMULTISIG;\n+\n+    *this << EncodeOP_N(nRequired);\n+    BOOST_FOREACH(const CKey& key, keys)\n+        *this << key.GetPubKey();\n+    *this << EncodeOP_N(keys.size()) << OP_CHECKMULTISIG;\n }\n-void CScript::SetMultisigEscrow(const std::vector<CKey>& keys)\n+\n+void CScript::SetEval(const CScript& subscript)\n {\n-    assert(keys.size() >= 3);\n+    assert(!subscript.empty());\n+    uint160 subscriptHash = Hash160(subscript);\n     this->clear();\n-    *this << OP_2 << keys[0].GetPubKey() << keys[1].GetPubKey() << keys[1].GetPubKey() << OP_3 << OP_CHECKMULTISIG;\n+    *this << OP_DUP << OP_HASH160 << subscriptHash << OP_EQUALVERIFY << OP_EVAL;\n }"
      },
      {
        "sha": "ee0be02a82cf58440c3368c939557d3855e6087e",
        "filename": "src/script.h",
        "status": "modified",
        "additions": 52,
        "deletions": 170,
        "changes": 222,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.h?ref=e679ec969c8b22c676ebb10bea1038f6c8f13b33",
        "patch": "@@ -24,6 +24,17 @@ enum\n };\n \n \n+enum txntype\n+{\n+    TX_NONSTANDARD,\n+    // 'standard' transaction types:\n+    TX_PUBKEY,\n+    TX_PUBKEYHASH,\n+    TX_SCRIPTHASH,\n+    TX_MULTISIG,\n+};\n+\n+const char* GetTxnTypeName(txntype t);\n \n enum opcodetype\n {\n@@ -147,8 +158,10 @@ enum opcodetype\n     OP_CHECKMULTISIG,\n     OP_CHECKMULTISIGVERIFY,\n \n+    // meta\n+    OP_EVAL, // Was OP_NOP1\n+\n     // expansion\n-    OP_NOP1,\n     OP_NOP2,\n     OP_NOP3,\n     OP_NOP4,\n@@ -162,162 +175,16 @@ enum opcodetype\n \n \n     // template matching params\n+    OP_SMALLINTEGER = 0xfa,\n+    OP_PUBKEYS = 0xfb,\n+    OP_SCRIPTHASH = 0xfc,\n     OP_PUBKEYHASH = 0xfd,\n     OP_PUBKEY = 0xfe,\n \n     OP_INVALIDOPCODE = 0xff,\n };\n \n-\n-\n-\n-\n-\n-\n-\n-inline const char* GetOpName(opcodetype opcode)\n-{\n-    switch (opcode)\n-    {\n-    // push value\n-    case OP_0                      : return \"0\";\n-    case OP_PUSHDATA1              : return \"OP_PUSHDATA1\";\n-    case OP_PUSHDATA2              : return \"OP_PUSHDATA2\";\n-    case OP_PUSHDATA4              : return \"OP_PUSHDATA4\";\n-    case OP_1NEGATE                : return \"-1\";\n-    case OP_RESERVED               : return \"OP_RESERVED\";\n-    case OP_1                      : return \"1\";\n-    case OP_2                      : return \"2\";\n-    case OP_3                      : return \"3\";\n-    case OP_4                      : return \"4\";\n-    case OP_5                      : return \"5\";\n-    case OP_6                      : return \"6\";\n-    case OP_7                      : return \"7\";\n-    case OP_8                      : return \"8\";\n-    case OP_9                      : return \"9\";\n-    case OP_10                     : return \"10\";\n-    case OP_11                     : return \"11\";\n-    case OP_12                     : return \"12\";\n-    case OP_13                     : return \"13\";\n-    case OP_14                     : return \"14\";\n-    case OP_15                     : return \"15\";\n-    case OP_16                     : return \"16\";\n-\n-    // control\n-    case OP_NOP                    : return \"OP_NOP\";\n-    case OP_VER                    : return \"OP_VER\";\n-    case OP_IF                     : return \"OP_IF\";\n-    case OP_NOTIF                  : return \"OP_NOTIF\";\n-    case OP_VERIF                  : return \"OP_VERIF\";\n-    case OP_VERNOTIF               : return \"OP_VERNOTIF\";\n-    case OP_ELSE                   : return \"OP_ELSE\";\n-    case OP_ENDIF                  : return \"OP_ENDIF\";\n-    case OP_VERIFY                 : return \"OP_VERIFY\";\n-    case OP_RETURN                 : return \"OP_RETURN\";\n-\n-    // stack ops\n-    case OP_TOALTSTACK             : return \"OP_TOALTSTACK\";\n-    case OP_FROMALTSTACK           : return \"OP_FROMALTSTACK\";\n-    case OP_2DROP                  : return \"OP_2DROP\";\n-    case OP_2DUP                   : return \"OP_2DUP\";\n-    case OP_3DUP                   : return \"OP_3DUP\";\n-    case OP_2OVER                  : return \"OP_2OVER\";\n-    case OP_2ROT                   : return \"OP_2ROT\";\n-    case OP_2SWAP                  : return \"OP_2SWAP\";\n-    case OP_IFDUP                  : return \"OP_IFDUP\";\n-    case OP_DEPTH                  : return \"OP_DEPTH\";\n-    case OP_DROP                   : return \"OP_DROP\";\n-    case OP_DUP                    : return \"OP_DUP\";\n-    case OP_NIP                    : return \"OP_NIP\";\n-    case OP_OVER                   : return \"OP_OVER\";\n-    case OP_PICK                   : return \"OP_PICK\";\n-    case OP_ROLL                   : return \"OP_ROLL\";\n-    case OP_ROT                    : return \"OP_ROT\";\n-    case OP_SWAP                   : return \"OP_SWAP\";\n-    case OP_TUCK                   : return \"OP_TUCK\";\n-\n-    // splice ops\n-    case OP_CAT                    : return \"OP_CAT\";\n-    case OP_SUBSTR                 : return \"OP_SUBSTR\";\n-    case OP_LEFT                   : return \"OP_LEFT\";\n-    case OP_RIGHT                  : return \"OP_RIGHT\";\n-    case OP_SIZE                   : return \"OP_SIZE\";\n-\n-    // bit logic\n-    case OP_INVERT                 : return \"OP_INVERT\";\n-    case OP_AND                    : return \"OP_AND\";\n-    case OP_OR                     : return \"OP_OR\";\n-    case OP_XOR                    : return \"OP_XOR\";\n-    case OP_EQUAL                  : return \"OP_EQUAL\";\n-    case OP_EQUALVERIFY            : return \"OP_EQUALVERIFY\";\n-    case OP_RESERVED1              : return \"OP_RESERVED1\";\n-    case OP_RESERVED2              : return \"OP_RESERVED2\";\n-\n-    // numeric\n-    case OP_1ADD                   : return \"OP_1ADD\";\n-    case OP_1SUB                   : return \"OP_1SUB\";\n-    case OP_2MUL                   : return \"OP_2MUL\";\n-    case OP_2DIV                   : return \"OP_2DIV\";\n-    case OP_NEGATE                 : return \"OP_NEGATE\";\n-    case OP_ABS                    : return \"OP_ABS\";\n-    case OP_NOT                    : return \"OP_NOT\";\n-    case OP_0NOTEQUAL              : return \"OP_0NOTEQUAL\";\n-    case OP_ADD                    : return \"OP_ADD\";\n-    case OP_SUB                    : return \"OP_SUB\";\n-    case OP_MUL                    : return \"OP_MUL\";\n-    case OP_DIV                    : return \"OP_DIV\";\n-    case OP_MOD                    : return \"OP_MOD\";\n-    case OP_LSHIFT                 : return \"OP_LSHIFT\";\n-    case OP_RSHIFT                 : return \"OP_RSHIFT\";\n-    case OP_BOOLAND                : return \"OP_BOOLAND\";\n-    case OP_BOOLOR                 : return \"OP_BOOLOR\";\n-    case OP_NUMEQUAL               : return \"OP_NUMEQUAL\";\n-    case OP_NUMEQUALVERIFY         : return \"OP_NUMEQUALVERIFY\";\n-    case OP_NUMNOTEQUAL            : return \"OP_NUMNOTEQUAL\";\n-    case OP_LESSTHAN               : return \"OP_LESSTHAN\";\n-    case OP_GREATERTHAN            : return \"OP_GREATERTHAN\";\n-    case OP_LESSTHANOREQUAL        : return \"OP_LESSTHANOREQUAL\";\n-    case OP_GREATERTHANOREQUAL     : return \"OP_GREATERTHANOREQUAL\";\n-    case OP_MIN                    : return \"OP_MIN\";\n-    case OP_MAX                    : return \"OP_MAX\";\n-    case OP_WITHIN                 : return \"OP_WITHIN\";\n-\n-    // crypto\n-    case OP_RIPEMD160              : return \"OP_RIPEMD160\";\n-    case OP_SHA1                   : return \"OP_SHA1\";\n-    case OP_SHA256                 : return \"OP_SHA256\";\n-    case OP_HASH160                : return \"OP_HASH160\";\n-    case OP_HASH256                : return \"OP_HASH256\";\n-    case OP_CODESEPARATOR          : return \"OP_CODESEPARATOR\";\n-    case OP_CHECKSIG               : return \"OP_CHECKSIG\";\n-    case OP_CHECKSIGVERIFY         : return \"OP_CHECKSIGVERIFY\";\n-    case OP_CHECKMULTISIG          : return \"OP_CHECKMULTISIG\";\n-    case OP_CHECKMULTISIGVERIFY    : return \"OP_CHECKMULTISIGVERIFY\";\n-\n-    // expanson\n-    case OP_NOP1                   : return \"OP_NOP1\";\n-    case OP_NOP2                   : return \"OP_NOP2\";\n-    case OP_NOP3                   : return \"OP_NOP3\";\n-    case OP_NOP4                   : return \"OP_NOP4\";\n-    case OP_NOP5                   : return \"OP_NOP5\";\n-    case OP_NOP6                   : return \"OP_NOP6\";\n-    case OP_NOP7                   : return \"OP_NOP7\";\n-    case OP_NOP8                   : return \"OP_NOP8\";\n-    case OP_NOP9                   : return \"OP_NOP9\";\n-    case OP_NOP10                  : return \"OP_NOP10\";\n-\n-\n-\n-    // template matching params\n-    case OP_PUBKEYHASH             : return \"OP_PUBKEYHASH\";\n-    case OP_PUBKEY                 : return \"OP_PUBKEY\";\n-\n-    case OP_INVALIDOPCODE          : return \"OP_INVALIDOPCODE\";\n-    default:\n-        return \"OP_UNKNOWN\";\n-    }\n-};\n-\n+const char* GetOpName(opcodetype opcode);\n \n \n \n@@ -574,29 +441,52 @@ class CScript : public std::vector<unsigned char>\n         return true;\n     }\n \n+    // Encode/decode small integers:\n     static int DecodeOP_N(opcodetype opcode)\n     {\n         if (opcode == OP_0)\n             return 0;\n         assert(opcode >= OP_1 && opcode <= OP_16);\n         return (int)opcode - (int)(OP_1 - 1);\n     }\n+    static opcodetype EncodeOP_N(int n)\n+    {\n+        assert(n >= 0 && n <= 16);\n+        if (n == 0)\n+            return OP_0;\n+        return (opcodetype)(OP_1+n-1);\n+    }\n \n-    void FindAndDelete(const CScript& b)\n+    int FindAndDelete(const CScript& b)\n     {\n+        int nFound = 0;\n         if (b.empty())\n-            return;\n+            return nFound;\n         iterator pc = begin();\n         opcodetype opcode;\n         do\n         {\n             while (end() - pc >= b.size() && memcmp(&pc[0], &b[0], b.size()) == 0)\n+            {\n                 erase(pc, pc + b.size());\n+                ++nFound;\n+            }\n         }\n         while (GetOp(pc, opcode));\n+        return nFound;\n+    }\n+    int Find(opcodetype op) const\n+    {\n+        int nFound = 0;\n+        opcodetype opcode;\n+        for (const_iterator pc = begin(); pc != end() && GetOp(pc, opcode);)\n+            if (opcode == op)\n+                ++nFound;\n+        return nFound;\n     }\n \n-\n+    // This method should be removed when a compatibility-breaking block chain split has passed.\n+    // Compatibility method for old clients that count sigops differently:\n     int GetSigOpCount() const\n     {\n         int n = 0;\n@@ -614,11 +504,9 @@ class CScript : public std::vector<unsigned char>\n         return n;\n     }\n \n-\n+    // Called by CTransaction::IsStandard\n     bool IsPushOnly() const\n     {\n-        if (size() > 200)\n-            return false;\n         const_iterator pc = begin();\n         while (pc < end())\n         {\n@@ -632,19 +520,13 @@ class CScript : public std::vector<unsigned char>\n     }\n \n \n-    void SetBitcoinAddress(const CBitcoinAddress& address)\n-    {\n-        this->clear();\n-        *this << OP_DUP << OP_HASH160 << address.GetHash160() << OP_EQUALVERIFY << OP_CHECKSIG;\n-    }\n-\n+    void SetBitcoinAddress(const CBitcoinAddress& address);\n     void SetBitcoinAddress(const std::vector<unsigned char>& vchPubKey)\n     {\n         SetBitcoinAddress(CBitcoinAddress(vchPubKey));\n     }\n-    void SetMultisigAnd(const std::vector<CKey>& keys);\n-    void SetMultisigOr(const std::vector<CKey>& keys);\n-    void SetMultisigEscrow(const std::vector<CKey>& keys);\n+    void SetMultisig(int nRequired, const std::vector<CKey>& keys);\n+    void SetEval(const CScript& subscript);\n \n \n     void PrintHex() const\n@@ -685,14 +567,14 @@ class CScript : public std::vector<unsigned char>\n \n \n \n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, int nHashType, int& nSigOpCountRet);\n \n-\n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, int nHashType);\n-\n+bool Solver(const CScript& scriptPubKey, txntype& typeRet, std::vector<std::vector<unsigned char> >& vSolutionsRet);\n bool IsStandard(const CScript& scriptPubKey);\n bool IsMine(const CKeyStore& keystore, const CScript& scriptPubKey);\n bool ExtractAddress(const CScript& scriptPubKey, const CKeyStore* pkeystore, CBitcoinAddress& addressRet);\n+bool ExtractAddresses(const CScript& scriptPubKey, const CKeyStore* pkeystore, txntype& typeRet, std::vector<CBitcoinAddress>& addressRet, int& nRequiredRet);\n bool SignSignature(const CKeyStore& keystore, const CTransaction& txFrom, CTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL, CScript scriptPrereq=CScript());\n-bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, int nHashType=0);\n+bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, int& nSigOpCountRet, int nHashType=0);\n \n #endif"
      },
      {
        "sha": "75c764dd65238f476bf266eceb35e70919110690",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 47,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=e679ec969c8b22c676ebb10bea1038f6c8f13b33",
        "patch": "@@ -20,9 +20,7 @@ using namespace boost::assign;\n typedef vector<unsigned char> valtype;\n \n extern uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n-extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, int nHashType);\n-extern bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, int nHashType);\n-extern bool Solver(const CScript& scriptPubKey, vector<vector<pair<opcodetype, valtype> > >& vSolutionsRet);\n+extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, int& nSigOpCount, int nHashType);\n \n BOOST_AUTO_TEST_SUITE(multisig_tests)\n \n@@ -76,24 +74,25 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n \n     vector<CKey> keys;\n     CScript s;\n+    int nUnused = 0;\n \n     // Test a AND b:\n     keys.clear();\n     keys += key[0],key[1]; // magic operator+= from boost.assign\n     s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-    BOOST_CHECK(VerifyScript(s, a_and_b, txTo[0], 0, 0));\n+    BOOST_CHECK(VerifyScript(s, a_and_b, txTo[0], 0, nUnused, 0));\n \n     for (int i = 0; i < 4; i++)\n     {\n         keys.clear();\n         keys += key[i];\n         s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, 0), strprintf(\"a&b 1: %d\", i));\n+        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, nUnused, 0), strprintf(\"a&b 1: %d\", i));\n \n         keys.clear();\n         keys += key[1],key[i];\n         s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, 0), strprintf(\"a&b 2: %d\", i));\n+        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, nUnused, 0), strprintf(\"a&b 2: %d\", i));\n     }\n \n     // Test a OR b:\n@@ -103,16 +102,16 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n         keys += key[i];\n         s = sign_multisig(a_or_b, keys, txTo[1], 0);\n         if (i == 0 || i == 1)\n-            BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, txTo[1], 0, 0), strprintf(\"a|b: %d\", i));\n+            BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, txTo[1], 0, nUnused, 0), strprintf(\"a|b: %d\", i));\n         else\n-            BOOST_CHECK_MESSAGE(!VerifyScript(s, a_or_b, txTo[1], 0, 0), strprintf(\"a|b: %d\", i));\n+            BOOST_CHECK_MESSAGE(!VerifyScript(s, a_or_b, txTo[1], 0, nUnused, 0), strprintf(\"a|b: %d\", i));\n     }\n     s.clear();\n     s << OP_0 << OP_0;\n-    BOOST_CHECK(!VerifyScript(s, a_or_b, txTo[1], 0, 0));\n+    BOOST_CHECK(!VerifyScript(s, a_or_b, txTo[1], 0, nUnused, 0));\n     s.clear();\n     s << OP_0 << OP_1;\n-    BOOST_CHECK(!VerifyScript(s, a_or_b, txTo[1], 0, 0));\n+    BOOST_CHECK(!VerifyScript(s, a_or_b, txTo[1], 0, nUnused, 0));\n \n \n     for (int i = 0; i < 4; i++)\n@@ -122,16 +121,16 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n             keys += key[i],key[j];\n             s = sign_multisig(escrow, keys, txTo[2], 0);\n             if (i < j && i < 3 && j < 3)\n-                BOOST_CHECK_MESSAGE(VerifyScript(s, escrow, txTo[2], 0, 0), strprintf(\"escrow 1: %d %d\", i, j));\n+                BOOST_CHECK_MESSAGE(VerifyScript(s, escrow, txTo[2], 0, nUnused, 0), strprintf(\"escrow 1: %d %d\", i, j));\n             else\n-                BOOST_CHECK_MESSAGE(!VerifyScript(s, escrow, txTo[2], 0, 0), strprintf(\"escrow 2: %d %d\", i, j));\n+                BOOST_CHECK_MESSAGE(!VerifyScript(s, escrow, txTo[2], 0, nUnused, 0), strprintf(\"escrow 2: %d %d\", i, j));\n         }\n }\n \n BOOST_AUTO_TEST_CASE(multisig_IsStandard)\n {\n-    CKey key[3];\n-    for (int i = 0; i < 3; i++)\n+    CKey key[4];\n+    for (int i = 0; i < 4; i++)\n         key[i].MakeNewKey();\n \n     CScript a_and_b;\n@@ -145,6 +144,21 @@ BOOST_AUTO_TEST_CASE(multisig_IsStandard)\n     CScript escrow;\n     escrow << OP_2 << key[0].GetPubKey() << key[1].GetPubKey() << key[2].GetPubKey() << OP_3 << OP_CHECKMULTISIG;\n     BOOST_CHECK(::IsStandard(escrow));\n+\n+    CScript one_of_four;\n+    one_of_four << OP_1 << key[0].GetPubKey() << key[1].GetPubKey() << key[2].GetPubKey() << key[3].GetPubKey() << OP_4 << OP_CHECKMULTISIG;\n+    BOOST_CHECK(!::IsStandard(one_of_four));\n+\n+    CScript malformed[6];\n+    malformed[0] << OP_3 << key[0].GetPubKey() << key[1].GetPubKey() << OP_2 << OP_CHECKMULTISIG;\n+    malformed[1] << OP_2 << key[0].GetPubKey() << key[1].GetPubKey() << OP_3 << OP_CHECKMULTISIG;\n+    malformed[2] << OP_0 << key[0].GetPubKey() << key[1].GetPubKey() << OP_2 << OP_CHECKMULTISIG;\n+    malformed[3] << OP_1 << key[0].GetPubKey() << key[1].GetPubKey() << OP_0 << OP_CHECKMULTISIG;\n+    malformed[4] << OP_1 << key[0].GetPubKey() << key[1].GetPubKey() << OP_CHECKMULTISIG;\n+    malformed[5] << OP_1 << key[0].GetPubKey() << key[1].GetPubKey();\n+\n+    for (int i = 0; i < 6; i++)\n+        BOOST_CHECK(!::IsStandard(malformed[i]));\n }\n \n BOOST_AUTO_TEST_CASE(multisig_Solver1)\n@@ -170,75 +184,66 @@ BOOST_AUTO_TEST_CASE(multisig_Solver1)\n     }\n \n     {\n-        vector<vector<pair<opcodetype, valtype> > > solutions;\n+        vector<valtype> solutions;\n+        txntype whichType;\n         CScript s;\n         s << key[0].GetPubKey() << OP_CHECKSIG;\n-        BOOST_CHECK(Solver(s, solutions));\n+        BOOST_CHECK(Solver(s, whichType, solutions));\n         BOOST_CHECK(solutions.size() == 1);\n-        if (solutions.size() == 1)\n-            BOOST_CHECK(solutions[0].size() == 1);\n         CBitcoinAddress addr;\n         BOOST_CHECK(ExtractAddress(s, &keystore, addr));\n         BOOST_CHECK(addr == keyaddr[0]);\n         BOOST_CHECK(IsMine(keystore, s));\n         BOOST_CHECK(!IsMine(emptykeystore, s));\n     }\n     {\n-        vector<vector<pair<opcodetype, valtype> > > solutions;\n+        vector<valtype> solutions;\n+        txntype whichType;\n         CScript s;\n         s << OP_DUP << OP_HASH160 << Hash160(key[0].GetPubKey()) << OP_EQUALVERIFY << OP_CHECKSIG;\n-        BOOST_CHECK(Solver(s, solutions));\n+        BOOST_CHECK(Solver(s, whichType, solutions));\n         BOOST_CHECK(solutions.size() == 1);\n-        if (solutions.size() == 1)\n-            BOOST_CHECK(solutions[0].size() == 1);\n         CBitcoinAddress addr;\n         BOOST_CHECK(ExtractAddress(s, &keystore, addr));\n         BOOST_CHECK(addr == keyaddr[0]);\n         BOOST_CHECK(IsMine(keystore, s));\n         BOOST_CHECK(!IsMine(emptykeystore, s));\n     }\n     {\n-        vector<vector<pair<opcodetype, valtype> > > solutions;\n+        vector<valtype> solutions;\n+        txntype whichType;\n         CScript s;\n         s << OP_2 << key[0].GetPubKey() << key[1].GetPubKey() << OP_2 << OP_CHECKMULTISIG;\n-        BOOST_CHECK(Solver(s, solutions));\n-        BOOST_CHECK(solutions.size() == 1);\n-        if (solutions.size() == 1)\n-            BOOST_CHECK(solutions[0].size() == 2);\n+        BOOST_CHECK(Solver(s, whichType, solutions));\n+        BOOST_CHECK_EQUAL(solutions.size(), 4);\n         CBitcoinAddress addr;\n         BOOST_CHECK(!ExtractAddress(s, &keystore, addr));\n         BOOST_CHECK(IsMine(keystore, s));\n         BOOST_CHECK(!IsMine(emptykeystore, s));\n     }\n     {\n-        vector<vector<pair<opcodetype, valtype> > > solutions;\n+        vector<valtype> solutions;\n+        txntype whichType;\n         CScript s;\n         s << OP_1 << key[0].GetPubKey() << key[1].GetPubKey() << OP_2 << OP_CHECKMULTISIG;\n-        BOOST_CHECK(Solver(s, solutions));\n-        BOOST_CHECK(solutions.size() == 2);\n-        if (solutions.size() == 2)\n-        {\n-            BOOST_CHECK(solutions[0].size() == 1);\n-            BOOST_CHECK(solutions[1].size() == 1);\n-        }\n-        CBitcoinAddress addr;\n-        BOOST_CHECK(ExtractAddress(s, &keystore, addr));\n-        BOOST_CHECK(addr == keyaddr[0]);\n+        BOOST_CHECK(Solver(s, whichType, solutions));\n+        BOOST_CHECK_EQUAL(solutions.size(), 4);\n+        vector<CBitcoinAddress> addrs;\n+        int nRequired;\n+        BOOST_CHECK(ExtractAddresses(s, &keystore, whichType, addrs, nRequired));\n+        BOOST_CHECK(addrs[0] == keyaddr[0]);\n+        BOOST_CHECK(addrs[1] == keyaddr[1]);\n+        BOOST_CHECK(nRequired = 1);\n         BOOST_CHECK(IsMine(keystore, s));\n         BOOST_CHECK(!IsMine(emptykeystore, s));\n     }\n     {\n-        vector<vector<pair<opcodetype, valtype> > > solutions;\n+        vector<valtype> solutions;\n+        txntype whichType;\n         CScript s;\n         s << OP_2 << key[0].GetPubKey() << key[1].GetPubKey() << key[2].GetPubKey() << OP_3 << OP_CHECKMULTISIG;\n-        BOOST_CHECK(Solver(s, solutions));\n-        BOOST_CHECK(solutions.size() == 3);\n-        if (solutions.size() == 3)\n-        {\n-            BOOST_CHECK(solutions[0].size() == 2);\n-            BOOST_CHECK(solutions[1].size() == 2);\n-            BOOST_CHECK(solutions[2].size() == 2);\n-        }\n+        BOOST_CHECK(Solver(s, whichType, solutions));\n+        BOOST_CHECK(solutions.size() == 5);\n     }\n }\n "
      },
      {
        "sha": "857d04bc6dc6be4fc83d84df5eb2ae3b18e1eb89",
        "filename": "src/test/script_op_eval_tests.cpp",
        "status": "added",
        "additions": 203,
        "deletions": 0,
        "changes": 203,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/test/script_op_eval_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/test/script_op_eval_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_op_eval_tests.cpp?ref=e679ec969c8b22c676ebb10bea1038f6c8f13b33",
        "patch": "@@ -0,0 +1,203 @@\n+#include <boost/assert.hpp>\n+#include <boost/assign/list_of.hpp>\n+#include <boost/assign/list_inserter.hpp>\n+#include <boost/assign/std/vector.hpp>\n+#include <boost/test/unit_test.hpp>\n+#include <boost/foreach.hpp>\n+\n+#include \"../main.h\"\n+#include \"../script.h\"\n+#include \"../wallet.h\"\n+\n+using namespace std;\n+\n+// Test routines internal to script.cpp:\n+extern uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n+extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, int& nSigOps, int nHashType);\n+\n+BOOST_AUTO_TEST_SUITE(script_op_eval_tests)\n+\n+BOOST_AUTO_TEST_CASE(script_op_eval1)\n+{\n+    // OP_EVAL looks like this:\n+    // scriptSig:    <sig> <sig...> <serialized_script>\n+    // scriptPubKey: DUP HASH160 <hash> EQUALVERIFY EVAL\n+\n+    // Test SignSignature() (and therefore the version of Solver() that signs transactions)\n+    CBasicKeyStore keystore;\n+    CKey key[4];\n+    for (int i = 0; i < 4; i++)\n+    {\n+        key[i].MakeNewKey();\n+        keystore.AddKey(key[i]);\n+    }\n+\n+    // 8 Scripts: checking all combinations of\n+    // different keys, straight/EVAL, pubkey/pubkeyhash\n+    CScript standardScripts[4];\n+    standardScripts[0] << key[0].GetPubKey() << OP_CHECKSIG;\n+    standardScripts[1].SetBitcoinAddress(key[1].GetPubKey());\n+    standardScripts[2] << key[1].GetPubKey() << OP_CHECKSIG;\n+    standardScripts[3].SetBitcoinAddress(key[2].GetPubKey());\n+    CScript evalScripts[4];\n+    uint160 sigScriptHashes[4];\n+    for (int i = 0; i < 4; i++)\n+    {\n+        sigScriptHashes[i] = Hash160(standardScripts[i]);\n+        keystore.AddCScript(sigScriptHashes[i], standardScripts[i]);\n+        evalScripts[i] << OP_DUP << OP_HASH160 << sigScriptHashes[i] << OP_EQUALVERIFY << OP_EVAL;\n+    }\n+\n+    CTransaction txFrom;  // Funding transaction:\n+    txFrom.vout.resize(8);\n+    for (int i = 0; i < 4; i++)\n+    {\n+        txFrom.vout[i].scriptPubKey = evalScripts[i];\n+        txFrom.vout[i+4].scriptPubKey = standardScripts[i];\n+    }\n+    BOOST_CHECK(txFrom.IsStandard());\n+\n+    CTransaction txTo[8]; // Spending transactions\n+    for (int i = 0; i < 8; i++)\n+    {\n+        txTo[i].vin.resize(1);\n+        txTo[i].vout.resize(1);\n+        txTo[i].vin[0].prevout.n = i;\n+        txTo[i].vin[0].prevout.hash = txFrom.GetHash();\n+        txTo[i].vout[0].nValue = 1;\n+        BOOST_CHECK_MESSAGE(IsMine(keystore, txFrom.vout[i].scriptPubKey), strprintf(\"IsMine %d\", i));\n+    }\n+    for (int i = 0; i < 8; i++)\n+    {\n+        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0), strprintf(\"SignSignature %d\", i));\n+    }\n+    // All of the above should be OK, and the txTos have valid signatures\n+    // Check to make sure signature verification fails if we use the wrong ScriptSig:\n+    for (int i = 0; i < 8; i++)\n+        for (int j = 0; j < 8; j++)\n+        {\n+            CScript sigSave = txTo[i].vin[0].scriptSig;\n+            txTo[i].vin[0].scriptSig = txTo[j].vin[0].scriptSig;\n+            int nUnused = 0;\n+            bool sigOK = VerifySignature(txFrom, txTo[i], 0, nUnused);\n+            if (i == j)\n+                BOOST_CHECK_MESSAGE(sigOK, strprintf(\"VerifySignature %d %d\", i, j));\n+            else\n+                BOOST_CHECK_MESSAGE(!sigOK, strprintf(\"VerifySignature %d %d\", i, j));\n+            txTo[i].vin[0].scriptSig = sigSave;\n+        }\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_op_eval2)\n+{\n+    // Test OP_EVAL edge cases\n+\n+    CScript recurse;\n+    recurse << OP_DUP << OP_EVAL;\n+\n+    uint160 recurseHash = Hash160(recurse);\n+\n+    CScript fund;\n+    fund << OP_DUP << OP_HASH160 << recurseHash << OP_EQUALVERIFY << OP_EVAL;\n+\n+    CTransaction txFrom;  // Funding transaction:\n+    txFrom.vout.resize(1);\n+    txFrom.vout[0].scriptPubKey = fund;\n+\n+    BOOST_CHECK(txFrom.IsStandard()); // Looks like a standard transaction until you try to spend it\n+\n+    CTransaction txTo;\n+    txTo.vin.resize(1);\n+    txTo.vout.resize(1);\n+    txTo.vin[0].prevout.n = 0;\n+    txTo.vin[0].prevout.hash = txFrom.GetHash();\n+    txTo.vin[0].scriptSig = CScript() << static_cast<std::vector<unsigned char> >(recurse);\n+    txTo.vout[0].nValue = 1;\n+\n+    int nUnused = 0;\n+    BOOST_CHECK(!VerifyScript(txTo.vin[0].scriptSig, txFrom.vout[0].scriptPubKey, txTo, 0, nUnused, 0));\n+    BOOST_CHECK(!VerifySignature(txFrom, txTo, 0, nUnused));\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_op_eval3)\n+{\n+    // Test the CScript::Set* methods\n+    CBasicKeyStore keystore;\n+    CKey key[4];\n+    std::vector<CKey> keys;\n+    for (int i = 0; i < 4; i++)\n+    {\n+        key[i].MakeNewKey();\n+        keystore.AddKey(key[i]);\n+        keys.push_back(key[i]);\n+    }\n+\n+    CScript inner[4];\n+    inner[0].SetBitcoinAddress(key[0].GetPubKey());\n+    inner[1].SetMultisig(2, std::vector<CKey>(keys.begin(), keys.begin()+2));\n+    inner[2].SetMultisig(1, std::vector<CKey>(keys.begin(), keys.begin()+2));\n+    inner[3].SetMultisig(2, std::vector<CKey>(keys.begin(), keys.begin()+3));\n+\n+    CScript outer[4];\n+    for (int i = 0; i < 4; i++)\n+    {\n+        outer[i].SetEval(inner[i]);\n+        keystore.AddCScript(Hash160(inner[i]), inner[i]);\n+    }\n+\n+    CTransaction txFrom;  // Funding transaction:\n+    txFrom.vout.resize(4);\n+    for (int i = 0; i < 4; i++)\n+    {\n+        txFrom.vout[i].scriptPubKey = outer[i];\n+    }\n+    BOOST_CHECK(txFrom.IsStandard());\n+\n+    CTransaction txTo[4]; // Spending transactions\n+    for (int i = 0; i < 4; i++)\n+    {\n+        txTo[i].vin.resize(1);\n+        txTo[i].vout.resize(1);\n+        txTo[i].vin[0].prevout.n = i;\n+        txTo[i].vin[0].prevout.hash = txFrom.GetHash();\n+        txTo[i].vout[0].nValue = 1;\n+        txTo[i].vout[0].scriptPubKey = inner[i];\n+        BOOST_CHECK_MESSAGE(IsMine(keystore, txFrom.vout[i].scriptPubKey), strprintf(\"IsMine %d\", i));\n+    }\n+    for (int i = 0; i < 4; i++)\n+    {\n+        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0), strprintf(\"SignSignature %d\", i));\n+        BOOST_CHECK_MESSAGE(txTo[i].IsStandard(), strprintf(\"txTo[%d].IsStandard\", i));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_op_eval_backcompat)\n+{\n+    // Check backwards-incompatibility-testing code\n+    CScript returnsEleven;\n+    returnsEleven << OP_11;\n+\n+    // This will validate on new clients, but will\n+    // be invalid on old clients (that interpret OP_EVAL as a no-op)\n+    CScript fund;\n+    fund << OP_EVAL << OP_11 << OP_EQUAL;\n+\n+    CTransaction txFrom;  // Funding transaction:\n+    txFrom.vout.resize(1);\n+    txFrom.vout[0].scriptPubKey = fund;\n+\n+    CTransaction txTo;\n+    txTo.vin.resize(1);\n+    txTo.vout.resize(1);\n+    txTo.vin[0].prevout.n = 0;\n+    txTo.vin[0].prevout.hash = txFrom.GetHash();\n+    txTo.vin[0].scriptSig = CScript() << static_cast<std::vector<unsigned char> >(returnsEleven);\n+    txTo.vout[0].nValue = 1;\n+\n+    int nUnused = 0;\n+    BOOST_CHECK(!VerifyScript(txTo.vin[0].scriptSig, txFrom.vout[0].scriptPubKey, txTo, 0, nUnused, 0));\n+    BOOST_CHECK(!VerifySignature(txFrom, txTo, 0, nUnused));\n+}\n+\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "3d1c218700d9856e29fb6d09bdca559a57d5a222",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 18,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=e679ec969c8b22c676ebb10bea1038f6c8f13b33",
        "patch": "@@ -7,7 +7,7 @@\n \n using namespace std;\n extern uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n-extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, int nHashType);\n+extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, int& nSigOps, int nHashType);\n extern bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, int nHashType);\n \n BOOST_AUTO_TEST_SUITE(script_tests)\n@@ -21,19 +21,21 @@ BOOST_AUTO_TEST_CASE(script_PushData)\n     static const unsigned char pushdata2[] = { OP_PUSHDATA2, 1, 0, 0x5a };\n     static const unsigned char pushdata4[] = { OP_PUSHDATA4, 1, 0, 0, 0, 0x5a };\n \n+    int nUnused = 0;\n+\n     vector<vector<unsigned char> > directStack;\n-    BOOST_CHECK(EvalScript(directStack, CScript(&direct[0], &direct[sizeof(direct)]), CTransaction(), 0, 0));\n+    BOOST_CHECK(EvalScript(directStack, CScript(&direct[0], &direct[sizeof(direct)]), CTransaction(), 0, 0, nUnused));\n \n     vector<vector<unsigned char> > pushdata1Stack;\n-    BOOST_CHECK(EvalScript(pushdata1Stack, CScript(&pushdata1[0], &pushdata1[sizeof(pushdata1)]), CTransaction(), 0, 0));\n+    BOOST_CHECK(EvalScript(pushdata1Stack, CScript(&pushdata1[0], &pushdata1[sizeof(pushdata1)]), CTransaction(), 0, 0, nUnused));\n     BOOST_CHECK(pushdata1Stack == directStack);\n \n     vector<vector<unsigned char> > pushdata2Stack;\n-    BOOST_CHECK(EvalScript(pushdata2Stack, CScript(&pushdata2[0], &pushdata2[sizeof(pushdata2)]), CTransaction(), 0, 0));\n+    BOOST_CHECK(EvalScript(pushdata2Stack, CScript(&pushdata2[0], &pushdata2[sizeof(pushdata2)]), CTransaction(), 0, 0, nUnused));\n     BOOST_CHECK(pushdata2Stack == directStack);\n \n     vector<vector<unsigned char> > pushdata4Stack;\n-    BOOST_CHECK(EvalScript(pushdata4Stack, CScript(&pushdata4[0], &pushdata4[sizeof(pushdata4)]), CTransaction(), 0, 0));\n+    BOOST_CHECK(EvalScript(pushdata4Stack, CScript(&pushdata4[0], &pushdata4[sizeof(pushdata4)]), CTransaction(), 0, 0, nUnused));\n     BOOST_CHECK(pushdata4Stack == directStack);\n }\n \n@@ -71,6 +73,7 @@ sign_multisig(CScript scriptPubKey, CKey key, CTransaction transaction)\n \n BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG12)\n {\n+    int nUnused = 0;\n     CKey key1, key2, key3;\n     key1.MakeNewKey();\n     key2.MakeNewKey();\n@@ -91,19 +94,20 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG12)\n     txTo12.vout[0].nValue = 1;\n \n     CScript goodsig1 = sign_multisig(scriptPubKey12, key1, txTo12);\n-    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey12, txTo12, 0, 0));\n+    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey12, txTo12, 0, nUnused, 0));\n     txTo12.vout[0].nValue = 2;\n-    BOOST_CHECK(!VerifyScript(goodsig1, scriptPubKey12, txTo12, 0, 0));\n+    BOOST_CHECK(!VerifyScript(goodsig1, scriptPubKey12, txTo12, 0, nUnused, 0));\n \n     CScript goodsig2 = sign_multisig(scriptPubKey12, key2, txTo12);\n-    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey12, txTo12, 0, 0));\n+    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey12, txTo12, 0, nUnused, 0));\n \n     CScript badsig1 = sign_multisig(scriptPubKey12, key3, txTo12);\n-    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey12, txTo12, 0, 0));\n+    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey12, txTo12, 0, nUnused, 0));\n }\n \n BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n {\n+    int nUnused = 0;\n     CKey key1, key2, key3, key4;\n     key1.MakeNewKey();\n     key2.MakeNewKey();\n@@ -127,46 +131,46 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n     std::vector<CKey> keys;\n     keys.push_back(key1); keys.push_back(key2);\n     CScript goodsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey23, txTo23, 0, 0));\n+    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey23, txTo23, 0, nUnused, 0));\n \n     keys.clear();\n     keys.push_back(key1); keys.push_back(key3);\n     CScript goodsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey23, txTo23, 0, 0));\n+    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey23, txTo23, 0, nUnused, 0));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key3);\n     CScript goodsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig3, scriptPubKey23, txTo23, 0, 0));\n+    BOOST_CHECK(VerifyScript(goodsig3, scriptPubKey23, txTo23, 0, nUnused, 0));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key2); // Can't re-use sig\n     CScript badsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey23, txTo23, 0, 0));\n+    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey23, txTo23, 0, nUnused, 0));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key1); // sigs must be in correct order\n     CScript badsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig2, scriptPubKey23, txTo23, 0, 0));\n+    BOOST_CHECK(!VerifyScript(badsig2, scriptPubKey23, txTo23, 0, nUnused, 0));\n \n     keys.clear();\n     keys.push_back(key3); keys.push_back(key2); // sigs must be in correct order\n     CScript badsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig3, scriptPubKey23, txTo23, 0, 0));\n+    BOOST_CHECK(!VerifyScript(badsig3, scriptPubKey23, txTo23, 0, nUnused, 0));\n \n     keys.clear();\n     keys.push_back(key4); keys.push_back(key2); // sigs must match pubkeys\n     CScript badsig4 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig4, scriptPubKey23, txTo23, 0, 0));\n+    BOOST_CHECK(!VerifyScript(badsig4, scriptPubKey23, txTo23, 0, nUnused, 0));\n \n     keys.clear();\n     keys.push_back(key1); keys.push_back(key4); // sigs must match pubkeys\n     CScript badsig5 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig5, scriptPubKey23, txTo23, 0, 0));\n+    BOOST_CHECK(!VerifyScript(badsig5, scriptPubKey23, txTo23, 0, nUnused, 0));\n \n     keys.clear(); // Must have signatures\n     CScript badsig6 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig6, scriptPubKey23, txTo23, 0, 0));\n+    BOOST_CHECK(!VerifyScript(badsig6, scriptPubKey23, txTo23, 0, nUnused, 0));\n }    \n \n "
      },
      {
        "sha": "5d44b1fb8dba1a2ad0a809fc0f11c684dc2b38ed",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 2,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=e679ec969c8b22c676ebb10bea1038f6c8f13b33",
        "patch": "@@ -42,6 +42,15 @@ bool CWallet::AddCryptedKey(const vector<unsigned char> &vchPubKey, const vector\n     return false;\n }\n \n+bool CWallet::AddCScript(const uint160 &hash, const std::vector<unsigned char>& data)\n+{\n+    if (!CCryptoKeyStore::AddCScript(hash, data))\n+        return false;\n+    if (!fFileBacked)\n+        return true;\n+    return CWalletDB(strWalletFile).WriteCScript(hash, data);\n+}\n+\n bool CWallet::Unlock(const SecureString& strWalletPassphrase)\n {\n     if (!IsLocked())\n@@ -374,6 +383,16 @@ int64 CWallet::GetDebit(const CTxIn &txin) const\n     return 0;\n }\n \n+bool CWallet::IsChange(const CTxOut& txout) const\n+{\n+    CBitcoinAddress address;\n+    if (ExtractAddress(txout.scriptPubKey, this, address) && !address.IsScript())\n+        CRITICAL_BLOCK(cs_wallet)\n+            if (!mapAddressBook.count(address))\n+                return true;\n+    return false;\n+}\n+\n int64 CWalletTx::GetTxTime() const\n {\n     return nTimeReceived;\n@@ -443,8 +462,7 @@ void CWalletTx::GetAmounts(int64& nGeneratedImmature, int64& nGeneratedMature, l\n         nFee = nDebit - nValueOut;\n     }\n \n-    // Sent/received.  Standard client will never generate a send-to-multiple-recipients,\n-    // but non-standard clients might (so return a list of address/amount pairs)\n+    // Sent/received.\n     BOOST_FOREACH(const CTxOut& txout, vout)\n     {\n         CBitcoinAddress address;"
      },
      {
        "sha": "34090ec803ab50b7f3e9a1370e1caec53a1a4a39",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 3,
        "deletions": 9,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e679ec969c8b22c676ebb10bea1038f6c8f13b33/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=e679ec969c8b22c676ebb10bea1038f6c8f13b33",
        "patch": "@@ -69,6 +69,8 @@ class CWallet : public CCryptoKeyStore\n     bool AddCryptedKey(const std::vector<unsigned char> &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret);\n     // Adds an encrypted key to the store, without saving it to disk (used by LoadWallet)\n     bool LoadCryptedKey(const std::vector<unsigned char> &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret) { return CCryptoKeyStore::AddCryptedKey(vchPubKey, vchCryptedSecret); }\n+    bool AddCScript(const uint160& hash, const std::vector<unsigned char>& data);\n+    bool LoadCScript(const uint160& hash, const std::vector<unsigned char>& data) { return CCryptoKeyStore::AddCScript(hash, data); }\n \n     bool Unlock(const SecureString& strWalletPassphrase);\n     bool ChangeWalletPassphrase(const SecureString& strOldWalletPassphrase, const SecureString& strNewWalletPassphrase);\n@@ -114,15 +116,7 @@ class CWallet : public CCryptoKeyStore\n             throw std::runtime_error(\"CWallet::GetCredit() : value out of range\");\n         return (IsMine(txout) ? txout.nValue : 0);\n     }\n-    bool IsChange(const CTxOut& txout) const\n-    {\n-        CBitcoinAddress address;\n-        if (ExtractAddress(txout.scriptPubKey, this, address))\n-            CRITICAL_BLOCK(cs_wallet)\n-                if (!mapAddressBook.count(address))\n-                    return true;\n-        return false;\n-    }\n+    bool IsChange(const CTxOut& txout) const;\n     int64 GetChange(const CTxOut& txout) const\n     {\n         if (!MoneyRange(txout.nValue))"
      }
    ]
  },
  {
    "sha": "d7062ef1bd3319689d402027131f2c46efeddcb6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNzA2MmVmMWJkMzMxOTY4OWQ0MDIwMjcxMzFmMmM0NmVmZWRkY2I2",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-10-13T20:03:58Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-12-19T18:24:48Z"
      },
      "message": "Put OP_EVAL string in coinbase of generated blocks",
      "tree": {
        "sha": "975b65f6410e515c4463ad15f1f306909337987b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/975b65f6410e515c4463ad15f1f306909337987b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d7062ef1bd3319689d402027131f2c46efeddcb6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d7062ef1bd3319689d402027131f2c46efeddcb6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d7062ef1bd3319689d402027131f2c46efeddcb6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d7062ef1bd3319689d402027131f2c46efeddcb6/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e679ec969c8b22c676ebb10bea1038f6c8f13b33",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e679ec969c8b22c676ebb10bea1038f6c8f13b33",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e679ec969c8b22c676ebb10bea1038f6c8f13b33"
      }
    ],
    "stats": {
      "total": 17,
      "additions": 12,
      "deletions": 5
    },
    "files": [
      {
        "sha": "4be1198903d44eb396a1106366b44288ec2165e4",
        "filename": "src/base58.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d7062ef1bd3319689d402027131f2c46efeddcb6/src/base58.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d7062ef1bd3319689d402027131f2c46efeddcb6/src/base58.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.h?ref=d7062ef1bd3319689d402027131f2c46efeddcb6",
        "patch": "@@ -270,7 +270,7 @@ class CBitcoinAddress : public CBase58Data\n \n     bool SetScriptHash160(const uint160& hash160)\n     {\n-        SetData(fTestNet ? 112 : 1, &hash160, 20);\n+        SetData(fTestNet ? 111^2 : 2, &hash160, 20);\n         return true;\n     }\n \n@@ -284,7 +284,7 @@ class CBitcoinAddress : public CBase58Data\n                 nExpectedSize = 20; // Hash of public key\n                 fExpectTestNet = false;\n                 break;\n-            case 1:\n+            case 2:\n                 nExpectedSize = 20; // OP_EVAL, hash of CScript\n                 fExpectTestNet = false;\n                 break;\n@@ -293,7 +293,7 @@ class CBitcoinAddress : public CBase58Data\n                 nExpectedSize = 20;\n                 fExpectTestNet = true;\n                 break;\n-            case 112:\n+            case 111^2:\n                 nExpectedSize = 20;\n                 fExpectTestNet = true;\n                 break;\n@@ -308,8 +308,8 @@ class CBitcoinAddress : public CBase58Data\n         if (!IsValid())\n             return false;\n         if (fTestNet)\n-            return nVersion == 112;\n-        return nVersion == 1;\n+            return nVersion == 111^2;\n+        return nVersion == 2;\n     }\n \n     CBitcoinAddress()"
      },
      {
        "sha": "1b5bf528079f2b51c9317a8c346e0f9dfae2c57e",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d7062ef1bd3319689d402027131f2c46efeddcb6/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d7062ef1bd3319689d402027131f2c46efeddcb6/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=d7062ef1bd3319689d402027131f2c46efeddcb6",
        "patch": "@@ -2999,6 +2999,13 @@ void IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int&\n     }\n     ++nExtraNonce;\n     pblock->vtx[0].vin[0].scriptSig = CScript() << pblock->nTime << CBigNum(nExtraNonce);\n+\n+    // Put \"OP_EVAL\" in the coinbase so everybody can tell when\n+    // a majority of miners support it\n+    const char* pOpEvalName = GetOpName(OP_EVAL);\n+    pblock->vtx[0].vin[0].scriptSig += CScript() << std::vector<unsigned char>(pOpEvalName, pOpEvalName+strlen(pOpEvalName));\n+    assert(pblock->vtx[0].vin[0].scriptSig.size() <= 100);\n+\n     pblock->hashMerkleRoot = pblock->BuildMerkleTree();\n }\n "
      }
    ]
  },
  {
    "sha": "fae3e2aab646a4813c6b9ad28b4c9cf4330c1a59",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYWUzZTJhYWI2NDZhNDgxM2M2YjlhZDI4YjRjOWNmNDMzMGMxYTU5",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-10-19T13:50:15Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-12-19T18:24:48Z"
      },
      "message": "Disable addmultisigaddress if not testnet",
      "tree": {
        "sha": "5dcad7e4b5dc84b3c52a2230ce778f13f727151e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5dcad7e4b5dc84b3c52a2230ce778f13f727151e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fae3e2aab646a4813c6b9ad28b4c9cf4330c1a59",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fae3e2aab646a4813c6b9ad28b4c9cf4330c1a59",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fae3e2aab646a4813c6b9ad28b4c9cf4330c1a59",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fae3e2aab646a4813c6b9ad28b4c9cf4330c1a59/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d7062ef1bd3319689d402027131f2c46efeddcb6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d7062ef1bd3319689d402027131f2c46efeddcb6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d7062ef1bd3319689d402027131f2c46efeddcb6"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 2,
      "deletions": 0
    },
    "files": [
      {
        "sha": "47fd9830aa7cf28fd448ac4046ebfb67eb52f9fd",
        "filename": "src/bitcoinrpc.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fae3e2aab646a4813c6b9ad28b4c9cf4330c1a59/src/bitcoinrpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fae3e2aab646a4813c6b9ad28b4c9cf4330c1a59/src/bitcoinrpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.cpp?ref=fae3e2aab646a4813c6b9ad28b4c9cf4330c1a59",
        "patch": "@@ -946,6 +946,8 @@ Value addmultisigaddress(const Array& params, bool fHelp)\n             \"If [account] is specified, assign address to [account].\";\n         throw runtime_error(msg);\n     }\n+    if (!fTestNet)\n+        throw runtime_error(\"addmultisigaddress available only when running -testnet\\n\");\n \n     int nRequired = params[0].get_int();\n     const Array& keys = params[1].get_array();"
      }
    ]
  },
  {
    "sha": "a0871afb2b1d6d358c833fd08bca2f13c840fd4d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphMDg3MWFmYjJiMWQ2ZDM1OGM4MzNmZDA4YmNhMmYxM2M4NDBmZDRk",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-10-21T17:12:05Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-12-19T18:24:48Z"
      },
      "message": "Interpret OP_EVAL as OP_NOP until Feb 1, 2012",
      "tree": {
        "sha": "e983da1f47c6d64d16eb2bf83b58d2764b4853d0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e983da1f47c6d64d16eb2bf83b58d2764b4853d0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a0871afb2b1d6d358c833fd08bca2f13c840fd4d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a0871afb2b1d6d358c833fd08bca2f13c840fd4d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a0871afb2b1d6d358c833fd08bca2f13c840fd4d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a0871afb2b1d6d358c833fd08bca2f13c840fd4d/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fae3e2aab646a4813c6b9ad28b4c9cf4330c1a59",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fae3e2aab646a4813c6b9ad28b4c9cf4330c1a59",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fae3e2aab646a4813c6b9ad28b4c9cf4330c1a59"
      }
    ],
    "stats": {
      "total": 66,
      "additions": 63,
      "deletions": 3
    },
    "files": [
      {
        "sha": "e60399120ff4738c2d6d6b57a3c718851bc2b32c",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a0871afb2b1d6d358c833fd08bca2f13c840fd4d/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a0871afb2b1d6d358c833fd08bca2f13c840fd4d/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=a0871afb2b1d6d358c833fd08bca2f13c840fd4d",
        "patch": "@@ -1014,6 +1014,18 @@ bool EvalScriptInner(vector<vector<unsigned char> >& stack, const CScript& scrip\n \n                 case OP_EVAL:\n                 {\n+                    // This code should be removed when OP_EVAL has\n+                    // a majority of hashing power on the network.\n+                    // OP_EVAL behaves just like OP_NOP until\n+                    // opevaltime :\n+                    if (!fTestNet || fDebug)\n+                    {\n+                        // 1328054400 is Feb 1, 2012\n+                        int64 nEvalSwitchTime = GetArg(\"opevaltime\", 1328054400);\n+                        if (GetTime() < nEvalSwitchTime)\n+                            break;\n+                    }\n+\n                     // Evaluate the top item on the stack as a Script\n                     // [serialized script ] -- [result(s) of executing script]\n                     if (stack.size() < 1)"
      },
      {
        "sha": "6c683b57297e12723e54f0d913a5ecb29cca11d5",
        "filename": "src/test/script_op_eval_tests.cpp",
        "status": "modified",
        "additions": 51,
        "deletions": 3,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a0871afb2b1d6d358c833fd08bca2f13c840fd4d/src/test/script_op_eval_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a0871afb2b1d6d358c833fd08bca2f13c840fd4d/src/test/script_op_eval_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_op_eval_tests.cpp?ref=a0871afb2b1d6d358c833fd08bca2f13c840fd4d",
        "patch": "@@ -15,7 +15,22 @@ using namespace std;\n extern uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, int& nSigOps, int nHashType);\n \n-BOOST_AUTO_TEST_SUITE(script_op_eval_tests)\n+static const int64 nEvalSwitchover = 1328054400;\n+\n+struct CEvalFixture {\n+    CEvalFixture()\n+    {\n+        // Set mock time to AFTER OP_EVAL deployed\n+        SetMockTime(nEvalSwitchover+1);\n+    }\n+    ~CEvalFixture()\n+    {\n+        // Reset back to use-real-time\n+        SetMockTime(0);\n+    }\n+};\n+\n+BOOST_FIXTURE_TEST_SUITE(script_op_eval_tests, CEvalFixture)\n \n BOOST_AUTO_TEST_CASE(script_op_eval1)\n {\n@@ -171,14 +186,16 @@ BOOST_AUTO_TEST_CASE(script_op_eval3)\n     }\n }\n \n-BOOST_AUTO_TEST_CASE(script_op_eval_backcompat)\n+BOOST_AUTO_TEST_CASE(script_op_eval_backcompat1)\n {\n     // Check backwards-incompatibility-testing code\n     CScript returnsEleven;\n     returnsEleven << OP_11;\n \n-    // This will validate on new clients, but will\n+    // This should validate on new clients, but will\n     // be invalid on old clients (that interpret OP_EVAL as a no-op)\n+    //  ... except there's a special rule that makes new clients reject\n+    // it.\n     CScript fund;\n     fund << OP_EVAL << OP_11 << OP_EQUAL;\n \n@@ -199,5 +216,36 @@ BOOST_AUTO_TEST_CASE(script_op_eval_backcompat)\n     BOOST_CHECK(!VerifySignature(txFrom, txTo, 0, nUnused));\n }\n \n+BOOST_AUTO_TEST_CASE(script_op_eval_switchover)\n+{\n+    // Use SetMockTime to test OP_EVAL switchover code\n+    CScript notValid;\n+    notValid << OP_11 << OP_12 << OP_EQUALVERIFY;\n+\n+    // This will be valid under old rules, invalid under new:\n+    CScript fund;\n+    fund << OP_EVAL;\n+\n+    CTransaction txFrom;  // Funding transaction:\n+    txFrom.vout.resize(1);\n+    txFrom.vout[0].scriptPubKey = fund;\n+\n+    CTransaction txTo;\n+    txTo.vin.resize(1);\n+    txTo.vout.resize(1);\n+    txTo.vin[0].prevout.n = 0;\n+    txTo.vin[0].prevout.hash = txFrom.GetHash();\n+    txTo.vin[0].scriptSig = CScript() << static_cast<std::vector<unsigned char> >(notValid);\n+    txTo.vout[0].nValue = 1;\n+\n+    SetMockTime(nEvalSwitchover-1);\n+\n+    int nUnused = 0;\n+    BOOST_CHECK(VerifyScript(txTo.vin[0].scriptSig, txFrom.vout[0].scriptPubKey, txTo, 0, nUnused, 0));\n+\n+    // After eval switchover time, it should validate:\n+    SetMockTime(nEvalSwitchover);\n+    BOOST_CHECK(!VerifyScript(txTo.vin[0].scriptSig, txFrom.vout[0].scriptPubKey, txTo, 0, nUnused, 0));\n+}\n \n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyYTQ1YTQ5NGIwYmVjNmEwZjFmYzZhYjdmMjZjMjYwYjg1ZTdmZjNl",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-11-08T18:20:29Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-12-19T18:24:48Z"
      },
      "message": "Use block times for 'hard' OP_EVAL switchover, and refactored EvalScript\nso it takes a flag for how to interpret OP_EVAL.\nAlso increased IsStandard size of scriptSigs to 500 bytes, so\na 3-of-3 multisig transaction IsStandard.",
      "tree": {
        "sha": "a6c8ad492ea81d6f1c2b8694351a7b7bfa785ae6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a6c8ad492ea81d6f1c2b8694351a7b7bfa785ae6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a0871afb2b1d6d358c833fd08bca2f13c840fd4d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a0871afb2b1d6d358c833fd08bca2f13c840fd4d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a0871afb2b1d6d358c833fd08bca2f13c840fd4d"
      }
    ],
    "stats": {
      "total": 354,
      "additions": 177,
      "deletions": 177
    },
    "files": [
      {
        "sha": "1a1c99157fcf1af055876753732df8d9a1e23a8c",
        "filename": "src/bitcoinrpc.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e/src/bitcoinrpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e/src/bitcoinrpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.cpp?ref=2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e",
        "patch": "@@ -1674,10 +1674,10 @@ Value validateaddress(const Array& params, bool fHelp)\n             pwalletMain->GetCScript(address.GetHash160(), subscript);\n             ret.push_back(Pair(\"ismine\", ::IsMine(*pwalletMain, subscript)));\n             std::vector<CBitcoinAddress> addresses;\n-            txntype whichType;\n+            txnouttype whichType;\n             int nRequired;\n             ExtractAddresses(subscript, pwalletMain, whichType, addresses, nRequired);\n-            ret.push_back(Pair(\"script\", GetTxnTypeName(whichType)));\n+            ret.push_back(Pair(\"script\", GetTxnOutputType(whichType)));\n             Array a;\n             BOOST_FOREACH(const CBitcoinAddress& addr, addresses)\n                 a.push_back(addr.ToString());"
      },
      {
        "sha": "f43b2a565675238253fb807e38d27e0c4aa23147",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e",
        "patch": "@@ -938,7 +938,7 @@ int CWalletDB::LoadWallet(CWallet* pwallet)\n             {\n                 uint160 hash;\n                 ssKey >> hash;\n-                std::vector<unsigned char> script;\n+                CScript script;\n                 ssValue >> script;\n                 if (!pwallet->LoadCScript(hash, script))\n                     return DB_CORRUPT;"
      },
      {
        "sha": "e593ae28ed172bdd084ba4a72b31d1045f231de6",
        "filename": "src/db.h",
        "status": "modified",
        "additions": 13,
        "deletions": 12,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e/src/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e/src/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.h?ref=2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e",
        "patch": "@@ -13,17 +13,17 @@\n \n #include <db_cxx.h>\n \n-class CTxIndex;\n+class CAccount;\n+class CAccountingEntry;\n+class CAddress;\n+class CBlockLocator;\n class CDiskBlockIndex;\n class CDiskTxPos;\n+class CMasterKey;\n class COutPoint;\n-class CAddress;\n-class CWalletTx;\n+class CTxIndex;\n class CWallet;\n-class CAccount;\n-class CAccountingEntry;\n-class CBlockLocator;\n-\n+class CWalletTx;\n \n extern unsigned int nWalletDBUpdated;\n extern DbEnv dbenv;\n@@ -420,16 +420,17 @@ class CWalletDB : public CDB\n         return Write(std::make_pair(std::string(\"mkey\"), nID), kMasterKey, true);\n     }\n \n-    bool ReadCScript(const uint160 &hash, std::vector<unsigned char>& data)\n+    // Support for BIP 0013 : see https://en.bitcoin.it/wiki/BIP_0013\n+    bool ReadCScript(const uint160 &hash, CScript& redeemScript)\n     {\n-        data.clear();\n-        return Read(std::make_pair(std::string(\"cscript\"), hash), data);\n+        redeemScript.clear();\n+        return Read(std::make_pair(std::string(\"cscript\"), hash), redeemScript);\n     }\n \n-    bool WriteCScript(const uint160& hash, const std::vector<unsigned char>& data)\n+    bool WriteCScript(const uint160& hash, const CScript& redeemScript)\n     {\n         nWalletDBUpdated++;\n-        return Write(std::make_pair(std::string(\"cscript\"), hash), data, false);\n+        return Write(std::make_pair(std::string(\"cscript\"), hash), redeemScript, false);\n     }\n \n     bool WriteBestBlock(const CBlockLocator& locator)"
      },
      {
        "sha": "21fb0f91b23d609dcc52dafc64a8d40dcfcf7e98",
        "filename": "src/keystore.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 8,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e/src/keystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e/src/keystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.cpp?ref=2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e",
        "patch": "@@ -4,8 +4,9 @@\n // file license.txt or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"headers.h\"\n-#include \"db.h\"\n #include \"crypter.h\"\n+#include \"db.h\"\n+#include \"script.h\"\n \n std::vector<unsigned char> CKeyStore::GenerateNewKey()\n {\n@@ -33,30 +34,30 @@ bool CBasicKeyStore::AddKey(const CKey& key)\n     return true;\n }\n \n-bool CBasicKeyStore::AddCScript(const uint160 &hash, const std::vector<unsigned char>& data)\n+bool CBasicKeyStore::AddCScript(const uint160 &hash, const CScript& redeemScript)\n {\n     CRITICAL_BLOCK(cs_KeyStore)\n-        mapData[hash] = data;\n+        mapScripts[hash] = redeemScript;\n     return true;\n }\n \n bool CBasicKeyStore::HaveCScript(const uint160& hash) const\n {\n     bool result;\n     CRITICAL_BLOCK(cs_KeyStore)\n-        result = (mapData.count(hash) > 0);\n+        result = (mapScripts.count(hash) > 0);\n     return result;\n }\n \n \n-bool CBasicKeyStore::GetCScript(const uint160 &hash, std::vector<unsigned char>& dataOut) const\n+bool CBasicKeyStore::GetCScript(const uint160 &hash, CScript& redeemScriptOut) const\n {\n     CRITICAL_BLOCK(cs_KeyStore)\n     {\n-        DataMap::const_iterator mi = mapData.find(hash);\n-        if (mi != mapData.end())\n+        ScriptMap::const_iterator mi = mapScripts.find(hash);\n+        if (mi != mapScripts.end())\n         {\n-            dataOut = (*mi).second;\n+            redeemScriptOut = (*mi).second;\n             return true;\n         }\n     }"
      },
      {
        "sha": "669bf90174eb2bd92d4e8ef921f46af759d290af",
        "filename": "src/keystore.h",
        "status": "modified",
        "additions": 8,
        "deletions": 6,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e/src/keystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e/src/keystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.h?ref=2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e",
        "patch": "@@ -6,6 +6,7 @@\n #define BITCOIN_KEYSTORE_H\n \n #include \"crypter.h\"\n+#include \"script.h\"\n \n // A virtual base class for key stores\n class CKeyStore\n@@ -31,9 +32,10 @@ class CKeyStore\n     virtual void GetKeys(std::set<CBitcoinAddress> &setAddress) const =0;\n     virtual bool GetPubKey(const CBitcoinAddress &address, std::vector<unsigned char>& vchPubKeyOut) const;\n \n-    virtual bool AddCScript(const uint160 &hash, const std::vector<unsigned char>& data) =0;\n+    // Support for BIP 0013 : see https://en.bitcoin.it/wiki/BIP_0013\n+    virtual bool AddCScript(const uint160 &hash, const CScript& redeemScript) =0;\n     virtual bool HaveCScript(const uint160 &hash) const =0;\n-    virtual bool GetCScript(const uint160 &hash, std::vector<unsigned char>& dataOut) const =0;\n+    virtual bool GetCScript(const uint160 &hash, CScript& redeemScriptOut) const =0;\n \n     // Generate a new key, and add it to the store\n     virtual std::vector<unsigned char> GenerateNewKey();\n@@ -48,14 +50,14 @@ class CKeyStore\n };\n \n typedef std::map<CBitcoinAddress, CSecret> KeyMap;\n-typedef std::map<uint160, std::vector<unsigned char> > DataMap;\n+typedef std::map<uint160, CScript > ScriptMap;\n \n // Basic key store, that keeps keys in an address->secret map\n class CBasicKeyStore : public CKeyStore\n {\n protected:\n     KeyMap mapKeys;\n-    DataMap mapData;\n+    ScriptMap mapScripts;\n \n public:\n     bool AddKey(const CKey& key);\n@@ -92,9 +94,9 @@ class CBasicKeyStore : public CKeyStore\n         }\n         return false;\n     }\n-    virtual bool AddCScript(const uint160 &hash, const std::vector<unsigned char>& data);\n+    virtual bool AddCScript(const uint160 &hash, const CScript& redeemScript);\n     virtual bool HaveCScript(const uint160 &hash) const;\n-    virtual bool GetCScript(const uint160 &hash, std::vector<unsigned char>& dataOut) const;\n+    virtual bool GetCScript(const uint160 &hash, CScript& redeemScriptOut) const;\n };\n \n typedef std::map<CBitcoinAddress, std::pair<std::vector<unsigned char>, std::vector<unsigned char> > > CryptedKeyMap;"
      },
      {
        "sha": "81dd76fc49a6117345ca57c0bbb21907f839e88c",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 16,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e",
        "patch": "@@ -250,13 +250,13 @@ bool CTransaction::IsStandard() const\n {\n     BOOST_FOREACH(const CTxIn& txin, vin)\n     {\n-        // Biggest 'standard' txin is a 2-signature 2-of-3 escrow\n-        // in an OP_EVAL, which is 2 ~80-byte signatures, 3\n+        // Biggest 'standard' txin is a 3-signature 3-of-3 CHECKMULTISIG\n+        // in an OP_EVAL, which is 3 ~80-byte signatures, 3\n         // ~65-byte public keys, plus a few script ops.\n-        if (txin.scriptSig.size() > 400)\n-            return error(\"nonstandard txin, size %d\\n\", txin.scriptSig.size());\n+        if (txin.scriptSig.size() > 500)\n+            return error(\"nonstandard txin, size %d is too large\\n\", txin.scriptSig.size());\n         if (!txin.scriptSig.IsPushOnly())\n-            return error(\"nonstandard txin: %s\", txin.scriptSig.ToString().c_str());\n+            return error(\"nonstandard txin (opcodes other than PUSH): %s\", txin.scriptSig.ToString().c_str());\n     }\n     BOOST_FOREACH(const CTxOut& txout, vout)\n         if (!::IsStandard(txout.scriptPubKey))\n@@ -275,7 +275,7 @@ bool CTransaction::IsStandard() const\n // expensive-to-check-upon-redemption script like:\n //   DUP CHECKSIG DROP ... repeated 100 times... OP_1\n //\n-bool CTransaction::IsStandardInputs(std::map<uint256, std::pair<CTxIndex, CTransaction> > mapInputs) const\n+bool CTransaction::AreInputsStandard(std::map<uint256, std::pair<CTxIndex, CTransaction> > mapInputs) const\n {\n     if (fTestNet)\n         return true; // Allow non-standard on testnet\n@@ -287,18 +287,20 @@ bool CTransaction::IsStandardInputs(std::map<uint256, std::pair<CTxIndex, CTrans\n         CTransaction& txPrev = mapInputs[prevout.hash].second;\n \n         vector<vector<unsigned char> > vSolutions;\n-        txntype whichType;\n-        if (!Solver(txPrev.vout[vin[i].prevout.n].scriptPubKey, whichType, vSolutions))\n-            return false;\n+        txnouttype whichType;\n+        // get the scriptPubKey corresponding to this input:\n+        CScript& prevScript = txPrev.vout[prevout.n].scriptPubKey;\n+        if (!Solver(prevScript, whichType, vSolutions))\n+            return error(\"nonstandard txin (spending nonstandard txout %s)\", prevScript.ToString().c_str());\n         if (whichType == TX_SCRIPTHASH)\n         {\n             vector<vector<unsigned char> > stack;\n             int nUnused;\n-            if (!EvalScript(stack, vin[i].scriptSig, *this, i, 0, nUnused))\n-                return false;\n-            const vector<unsigned char>& subscript = stack.back();\n-            if (!::IsStandard(CScript(subscript.begin(), subscript.end())))\n+            if (!EvalScript(stack, vin[i].scriptSig, *this, i, 0, true, nUnused))\n                 return false;\n+            CScript subscript(stack.back().begin(), stack.back().end());\n+            if (!::IsStandard(subscript))\n+                return error(\"nonstandard txin (nonstandard OP_EVAL subscript %s)\", subscript.ToString().c_str());\n         }\n     }\n \n@@ -481,7 +483,7 @@ bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMi\n         }\n \n         // Check for non-standard OP_EVALs in inputs\n-        if (!IsStandardInputs(mapInputs))\n+        if (!AreInputsStandard(mapInputs))\n             return error(\"AcceptToMemoryPool() : nonstandard transaction input\");\n \n         // Check against previous transactions\n@@ -978,9 +980,27 @@ bool CTransaction::ConnectInputs(map<uint256, pair<CTxIndex, CTransaction> > inp\n             // (before the last blockchain checkpoint). This is safe because block merkle hashes are\n             // still computed and checked, and any change will be caught at the next checkpoint.\n             if (!(fBlock && IsInitialBlockDownload()))\n+            {\n+                bool fStrictOpEval = true;\n+                // This code should be removed when OP_EVAL has\n+                // a majority of hashing power on the network.\n+                if (fBlock)\n+                {\n+                    // To avoid being on the short end of a block-chain split,\n+                    // interpret OP_EVAL as a NO_OP until blocks with timestamps\n+                    // after opevaltime:\n+                    int64 nEvalSwitchTime = GetArg(\"opevaltime\", 1328054400); // Feb 1, 2012\n+                    fStrictOpEval = (pindexBlock->nTime >= nEvalSwitchTime);\n+                }\n+                // if !fBlock, then always be strict-- don't accept\n+                // invalid-under-new-rules OP_EVAL transactions into\n+                // our memory pool (don't relay them, don't include them\n+                // in blocks we mine).\n+\n                 // Verify signature\n-                if (!VerifySignature(txPrev, *this, i, nSigOpsRet))\n+                if (!VerifySignature(txPrev, *this, i, nSigOpsRet, fStrictOpEval))\n                     return DoS(100,error(\"ConnectInputs() : %s VerifySignature failed\", GetHash().ToString().substr(0,10).c_str()));\n+            }\n \n             // Check for conflicts (double-spend)\n             // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n@@ -1054,7 +1074,7 @@ bool CTransaction::ClientConnectInputs()\n \n             // Verify signature\n             int nUnused = 0;\n-            if (!VerifySignature(txPrev, *this, i, nUnused))\n+            if (!VerifySignature(txPrev, *this, i, nUnused, false))\n                 return error(\"ConnectInputs() : VerifySignature failed\");\n \n             ///// this is redundant with the mapNextTx stuff, not sure which I want to get rid of"
      },
      {
        "sha": "26d14b0d3fec2ba88dd9e52d6eca2775d031d79c",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e",
        "patch": "@@ -494,7 +494,7 @@ class CTransaction\n     }\n \n     bool IsStandard() const;\n-    bool IsStandardInputs(std::map<uint256, std::pair<CTxIndex, CTransaction> > mapInputs) const;\n+    bool AreInputsStandard(std::map<uint256, std::pair<CTxIndex, CTransaction> > mapInputs) const;\n \n     int64 GetValueOut() const\n     {\n@@ -622,6 +622,8 @@ class CTransaction\n     bool ReadFromDisk(CTxDB& txdb, COutPoint prevout);\n     bool ReadFromDisk(COutPoint prevout);\n     bool DisconnectInputs(CTxDB& txdb);\n+\n+    // Fetch from memory and/or disk. inputsRet keys are transaction hashes.\n     bool FetchInputs(CTxDB& txdb, const std::map<uint256, CTxIndex>& mapTestPool,\n                      bool fBlock, bool fMiner, std::map<uint256, std::pair<CTxIndex, CTransaction> >& inputsRet);\n     bool ConnectInputs(std::map<uint256, std::pair<CTxIndex, CTransaction> > inputs,"
      },
      {
        "sha": "5487c01fabc1f5d18c98c25c0a00f85e7472c1df",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 38,
        "deletions": 57,
        "changes": 95,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e",
        "patch": "@@ -70,7 +70,7 @@ static inline void popstack(vector<valtype>& stack)\n }\n \n \n-const char* GetTxnTypeName(txntype t)\n+const char* GetTxnOutputType(txnouttype t)\n {\n     switch (t)\n     {\n@@ -230,12 +230,12 @@ const char* GetOpName(opcodetype opcode)\n     }\n }\n \n-\n //\n // Returns true if script is valid.\n //\n bool EvalScriptInner(vector<vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, int nHashType,\n-                     CScript::const_iterator pbegincodehash, CScript::const_iterator pendcodehash, int& nOpCount, int& nSigOpCount, int nRecurseDepth)\n+                     CScript::const_iterator pbegincodehash, CScript::const_iterator pendcodehash, int& nOpCount, int& nSigOpCount,\n+                     bool fStrictOpEval, int nRecurseDepth)\n {\n     CAutoBN_CTX pctx;\n     CScript::const_iterator pc = script.begin();\n@@ -1014,17 +1014,9 @@ bool EvalScriptInner(vector<vector<unsigned char> >& stack, const CScript& scrip\n \n                 case OP_EVAL:\n                 {\n-                    // This code should be removed when OP_EVAL has\n-                    // a majority of hashing power on the network.\n-                    // OP_EVAL behaves just like OP_NOP until\n-                    // opevaltime :\n-                    if (!fTestNet || fDebug)\n-                    {\n-                        // 1328054400 is Feb 1, 2012\n-                        int64 nEvalSwitchTime = GetArg(\"opevaltime\", 1328054400);\n-                        if (GetTime() < nEvalSwitchTime)\n-                            break;\n-                    }\n+                    if (!fStrictOpEval)\n+                        break; // Act as a NO_OP\n+\n \n                     // Evaluate the top item on the stack as a Script\n                     // [serialized script ] -- [result(s) of executing script]\n@@ -1034,12 +1026,14 @@ bool EvalScriptInner(vector<vector<unsigned char> >& stack, const CScript& scrip\n                     CScript subscript(vchScript.begin(), vchScript.end());\n                     popstack(stack);\n                     \n-                    // Codeseparators not allowed\n+                    // Codeseparators not allowed; they don't make sense 'inside' an OP_EVAL, because\n+                    // their purpose is to change which parts of the scriptPubKey script is copied\n+                    // and signed by OP_CHECKSIG, but OP_EVAl'ed code is in the scriptSig, not the scriptPubKey.\n                     if (subscript.Find(OP_CODESEPARATOR))\n                         return false;\n \n                     if (!EvalScriptInner(stack, subscript, txTo, nIn, nHashType,\n-                                         pbegincodehash, pendcodehash, nOpCount, nSigOpCount, nRecurseDepth++))\n+                                         pbegincodehash, pendcodehash, nOpCount, nSigOpCount, fStrictOpEval, nRecurseDepth++))\n                         return false;\n                 }\n                 break;\n@@ -1066,14 +1060,15 @@ bool EvalScriptInner(vector<vector<unsigned char> >& stack, const CScript& scrip\n }\n \n bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script,\n-                const CTransaction& txTo, unsigned int nIn, int nHashType, int& nSigOpCountRet)\n+                const CTransaction& txTo, unsigned int nIn, int nHashType,\n+                bool fStrictOpEval, int& nSigOpCountRet)\n {\n     CScript::const_iterator pbegincodehash = script.begin();\n     CScript::const_iterator pendcodehash = script.end();\n \n     int nOpCount = 0;\n     return EvalScriptInner(stack, script, txTo, nIn, nHashType, pbegincodehash, pendcodehash,\n-                           nOpCount, nSigOpCountRet, 0);\n+                           nOpCount, nSigOpCountRet, fStrictOpEval, 0);\n }\n \n \n@@ -1177,10 +1172,10 @@ bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CSc\n //\n // Return public keys or hashes from scriptPubKey, for 'standard' transaction types.\n //\n-bool Solver(const CScript& scriptPubKey, txntype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n+bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n {\n     // Templates\n-    static map<txntype, CScript> mTemplates;\n+    static map<txnouttype, CScript> mTemplates;\n     if (mTemplates.empty())\n     {\n         // Standard tx, sender provides pubkey, receiver adds signature\n@@ -1199,7 +1194,7 @@ bool Solver(const CScript& scriptPubKey, txntype& typeRet, vector<vector<unsigne\n \n     // Scan templates\n     const CScript& script1 = scriptPubKey;\n-    BOOST_FOREACH(const PAIRTYPE(txntype, CScript)& tplate, mTemplates)\n+    BOOST_FOREACH(const PAIRTYPE(txnouttype, CScript)& tplate, mTemplates)\n     {\n         const CScript& script2 = tplate.second;\n         vSolutionsRet.clear();\n@@ -1331,13 +1326,13 @@ bool Solver(const CKeyStore& keystore, const CScript& scriptPubKey, uint256 hash\n {\n     scriptSigRet.clear();\n \n-    txntype whichType;\n+    txnouttype whichType;\n     vector<valtype> vSolutions;\n     if (!Solver(scriptPubKey, whichType, vSolutions))\n         return false;\n \n     CBitcoinAddress address;\n-    valtype subscript;\n+    CScript subscript;\n     switch (whichType)\n     {\n     case TX_NONSTANDARD:\n@@ -1359,10 +1354,11 @@ bool Solver(const CKeyStore& keystore, const CScript& scriptPubKey, uint256 hash\n     case TX_SCRIPTHASH:\n         if (!keystore.GetCScript(uint160(vSolutions[0]), subscript))\n             return false;\n-        if (!Solver(keystore, CScript(subscript.begin(), subscript.end()), hash, nHashType, scriptSigRet))\n+        if (!Solver(keystore, subscript, hash, nHashType, scriptSigRet))\n             return false;\n         if (hash != 0)\n-            scriptSigRet << subscript; // signatures AND serialized script\n+            // static_cast to get vector.operator<< instead of CScript.operator<<\n+            scriptSigRet << static_cast<valtype>(subscript); // signatures AND serialized script\n         break;\n     case TX_MULTISIG:\n         scriptSigRet << OP_0; // workaround CHECKMULTISIG bug\n@@ -1375,7 +1371,7 @@ bool Solver(const CKeyStore& keystore, const CScript& scriptPubKey, uint256 hash\n bool IsStandard(const CScript& scriptPubKey)\n {\n     vector<valtype> vSolutions;\n-    txntype whichType;\n+    txnouttype whichType;\n     if (!Solver(scriptPubKey, whichType, vSolutions))\n         return false;\n \n@@ -1410,7 +1406,7 @@ int HaveKeys(const vector<valtype>& pubkeys, const CKeyStore& keystore)\n bool IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n {\n     vector<valtype> vSolutions;\n-    txntype whichType;\n+    txnouttype whichType;\n     if (!Solver(scriptPubKey, whichType, vSolutions))\n         return false;\n \n@@ -1427,10 +1423,10 @@ bool IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n         return keystore.HaveKey(address);\n     case TX_SCRIPTHASH:\n     {\n-        valtype subscript;\n+        CScript subscript;\n         if (!keystore.GetCScript(uint160(vSolutions[0]), subscript))\n             return false;\n-        return IsMine(keystore, CScript(subscript.begin(), subscript.end()));\n+        return IsMine(keystore, subscript);\n     }\n     case TX_MULTISIG:\n     {\n@@ -1449,7 +1445,7 @@ bool IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n bool ExtractAddress(const CScript& scriptPubKey, const CKeyStore* keystore, CBitcoinAddress& addressRet)\n {\n     vector<valtype> vSolutions;\n-    txntype whichType;\n+    txnouttype whichType;\n     if (!Solver(scriptPubKey, whichType, vSolutions))\n         return false;\n \n@@ -1472,7 +1468,7 @@ bool ExtractAddress(const CScript& scriptPubKey, const CKeyStore* keystore, CBit\n     return false;\n }\n \n-bool ExtractAddresses(const CScript& scriptPubKey, const CKeyStore* keystore, txntype& typeRet, vector<CBitcoinAddress>& addressRet, int& nRequiredRet)\n+bool ExtractAddresses(const CScript& scriptPubKey, const CKeyStore* keystore, txnouttype& typeRet, vector<CBitcoinAddress>& addressRet, int& nRequiredRet)\n {\n     addressRet.clear();\n     typeRet = TX_NONSTANDARD;\n@@ -1484,10 +1480,10 @@ bool ExtractAddresses(const CScript& scriptPubKey, const CKeyStore* keystore, tx\n     {\n         nRequiredRet = vSolutions.front()[0];\n         int n = vSolutions.back()[0];\n-        for (vector<valtype>::const_iterator it = vSolutions.begin()+1; it != vSolutions.begin()+vSolutions.size()-1; it++)\n+        for (int i = 1; i < vSolutions.size()-1; i++)\n         {\n             CBitcoinAddress address;\n-            address.SetPubKey(*it);\n+            address.SetPubKey(vSolutions[i]);\n             addressRet.push_back(address);\n         }\n     }\n@@ -1507,12 +1503,13 @@ bool ExtractAddresses(const CScript& scriptPubKey, const CKeyStore* keystore, tx\n     return true;\n }\n \n-bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, int& nSigOpCountRet, int nHashType)\n+bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, int& nSigOpCountRet,\n+                  int nHashType, bool fStrictOpEval)\n {\n     vector<vector<unsigned char> > stack;\n-    if (!EvalScript(stack, scriptSig, txTo, nIn, nHashType, nSigOpCountRet))\n+    if (!EvalScript(stack, scriptSig, txTo, nIn, nHashType, fStrictOpEval, nSigOpCountRet))\n         return false;\n-    if (!EvalScript(stack, scriptPubKey, txTo, nIn, nHashType, nSigOpCountRet))\n+    if (!EvalScript(stack, scriptPubKey, txTo, nIn, nHashType, fStrictOpEval, nSigOpCountRet))\n         return false;\n     if (stack.empty())\n         return false;\n@@ -1521,24 +1518,8 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n     // This code should be removed when a compatibility-breaking block chain split has passed.\n     // Special check for OP_EVAL backwards-compatibility: if scriptPubKey or scriptSig contains\n     // OP_EVAL, then result must be identical if OP_EVAL is treated as a no-op:\n-    if (scriptSig.Find(OP_EVAL)+scriptPubKey.Find(OP_EVAL) > 0)\n-    {\n-        int nUnused = 0;\n-        stack.clear();\n-        CScript sigCopy = scriptSig;\n-        sigCopy.FindAndDelete(CScript(OP_EVAL));\n-        CScript pubKeyCopy = scriptPubKey;\n-        pubKeyCopy.FindAndDelete(CScript(OP_EVAL));\n-\n-        if (!EvalScript(stack, sigCopy, txTo, nIn, nHashType, nUnused))\n-            return false;\n-        if (!EvalScript(stack, pubKeyCopy, txTo, nIn, nHashType, nUnused))\n-            return false;\n-        if (stack.empty())\n-            return false;\n-        if (fResult != CastToBool(stack.back()))\n-            return false;\n-    }\n+    if (fResult && fStrictOpEval && (scriptPubKey.Find(OP_EVAL) || scriptSig.Find(OP_EVAL)))\n+        return VerifyScript(scriptSig, scriptPubKey, txTo, nIn, nSigOpCountRet, nHashType, false);\n \n     return fResult;\n }\n@@ -1563,14 +1544,14 @@ bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CTrans\n     // Test solution\n     int nUnused = 0;\n     if (scriptPrereq.empty())\n-        if (!VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, nUnused, 0))\n+        if (!VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, nUnused, 0, true))\n             return false;\n \n     return true;\n }\n \n \n-bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, int& nSigOpCountRet, int nHashType)\n+bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, int& nSigOpCountRet, int nHashType, bool fStrictOpEval)\n {\n     assert(nIn < txTo.vin.size());\n     const CTxIn& txin = txTo.vin[nIn];\n@@ -1581,7 +1562,7 @@ bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsig\n     if (txin.prevout.hash != txFrom.GetHash())\n         return false;\n \n-    if (!VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, nSigOpCountRet, nHashType))\n+    if (!VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, nSigOpCountRet, nHashType, fStrictOpEval))\n         return false;\n \n     return true;"
      },
      {
        "sha": "b671e159632a8c061a54f26d9a5ed220482edb95",
        "filename": "src/script.h",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e/src/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e/src/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.h?ref=2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e",
        "patch": "@@ -6,14 +6,14 @@\n #define H_BITCOIN_SCRIPT\n \n #include \"base58.h\"\n-#include \"keystore.h\"\n \n #include <string>\n #include <vector>\n \n #include <boost/foreach.hpp>\n \n class CTransaction;\n+class CKeyStore;\n \n enum\n {\n@@ -24,7 +24,7 @@ enum\n };\n \n \n-enum txntype\n+enum txnouttype\n {\n     TX_NONSTANDARD,\n     // 'standard' transaction types:\n@@ -34,7 +34,7 @@ enum txntype\n     TX_MULTISIG,\n };\n \n-const char* GetTxnTypeName(txntype t);\n+const char* GetTxnOutputType(txnouttype t);\n \n enum opcodetype\n {\n@@ -567,14 +567,14 @@ class CScript : public std::vector<unsigned char>\n \n \n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, int nHashType, int& nSigOpCountRet);\n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, int nHashType, bool fStrictOpEval, int& nSigOpCountRet);\n \n-bool Solver(const CScript& scriptPubKey, txntype& typeRet, std::vector<std::vector<unsigned char> >& vSolutionsRet);\n+bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<std::vector<unsigned char> >& vSolutionsRet);\n bool IsStandard(const CScript& scriptPubKey);\n bool IsMine(const CKeyStore& keystore, const CScript& scriptPubKey);\n bool ExtractAddress(const CScript& scriptPubKey, const CKeyStore* pkeystore, CBitcoinAddress& addressRet);\n-bool ExtractAddresses(const CScript& scriptPubKey, const CKeyStore* pkeystore, txntype& typeRet, std::vector<CBitcoinAddress>& addressRet, int& nRequiredRet);\n+bool ExtractAddresses(const CScript& scriptPubKey, const CKeyStore* pkeystore, txnouttype& typeRet, std::vector<CBitcoinAddress>& addressRet, int& nRequiredRet);\n bool SignSignature(const CKeyStore& keystore, const CTransaction& txFrom, CTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL, CScript scriptPrereq=CScript());\n-bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, int& nSigOpCountRet, int nHashType=0);\n+bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, int& nSigOpCountRet, int nHashType=0, bool fStrictOpEval=true);\n \n #endif"
      },
      {
        "sha": "58f62b9542ef376a7378323d395b1237c2f4db23",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 15,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e",
        "patch": "@@ -20,7 +20,8 @@ using namespace boost::assign;\n typedef vector<unsigned char> valtype;\n \n extern uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n-extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, int& nSigOpCount, int nHashType);\n+extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, int& nSigOpCount,\n+                         int nHashType, bool fStrictOpEval);\n \n BOOST_AUTO_TEST_SUITE(multisig_tests)\n \n@@ -80,19 +81,19 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n     keys.clear();\n     keys += key[0],key[1]; // magic operator+= from boost.assign\n     s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-    BOOST_CHECK(VerifyScript(s, a_and_b, txTo[0], 0, nUnused, 0));\n+    BOOST_CHECK(VerifyScript(s, a_and_b, txTo[0], 0, nUnused, 0, true));\n \n     for (int i = 0; i < 4; i++)\n     {\n         keys.clear();\n         keys += key[i];\n         s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, nUnused, 0), strprintf(\"a&b 1: %d\", i));\n+        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, nUnused, 0, true), strprintf(\"a&b 1: %d\", i));\n \n         keys.clear();\n         keys += key[1],key[i];\n         s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, nUnused, 0), strprintf(\"a&b 2: %d\", i));\n+        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, nUnused, 0, true), strprintf(\"a&b 2: %d\", i));\n     }\n \n     // Test a OR b:\n@@ -102,16 +103,16 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n         keys += key[i];\n         s = sign_multisig(a_or_b, keys, txTo[1], 0);\n         if (i == 0 || i == 1)\n-            BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, txTo[1], 0, nUnused, 0), strprintf(\"a|b: %d\", i));\n+            BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, txTo[1], 0, nUnused, 0, true), strprintf(\"a|b: %d\", i));\n         else\n-            BOOST_CHECK_MESSAGE(!VerifyScript(s, a_or_b, txTo[1], 0, nUnused, 0), strprintf(\"a|b: %d\", i));\n+            BOOST_CHECK_MESSAGE(!VerifyScript(s, a_or_b, txTo[1], 0, nUnused, 0, true), strprintf(\"a|b: %d\", i));\n     }\n     s.clear();\n     s << OP_0 << OP_0;\n-    BOOST_CHECK(!VerifyScript(s, a_or_b, txTo[1], 0, nUnused, 0));\n+    BOOST_CHECK(!VerifyScript(s, a_or_b, txTo[1], 0, nUnused, 0, true));\n     s.clear();\n     s << OP_0 << OP_1;\n-    BOOST_CHECK(!VerifyScript(s, a_or_b, txTo[1], 0, nUnused, 0));\n+    BOOST_CHECK(!VerifyScript(s, a_or_b, txTo[1], 0, nUnused, 0, true));\n \n \n     for (int i = 0; i < 4; i++)\n@@ -121,9 +122,9 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n             keys += key[i],key[j];\n             s = sign_multisig(escrow, keys, txTo[2], 0);\n             if (i < j && i < 3 && j < 3)\n-                BOOST_CHECK_MESSAGE(VerifyScript(s, escrow, txTo[2], 0, nUnused, 0), strprintf(\"escrow 1: %d %d\", i, j));\n+                BOOST_CHECK_MESSAGE(VerifyScript(s, escrow, txTo[2], 0, nUnused, 0, true), strprintf(\"escrow 1: %d %d\", i, j));\n             else\n-                BOOST_CHECK_MESSAGE(!VerifyScript(s, escrow, txTo[2], 0, nUnused, 0), strprintf(\"escrow 2: %d %d\", i, j));\n+                BOOST_CHECK_MESSAGE(!VerifyScript(s, escrow, txTo[2], 0, nUnused, 0, true), strprintf(\"escrow 2: %d %d\", i, j));\n         }\n }\n \n@@ -185,7 +186,7 @@ BOOST_AUTO_TEST_CASE(multisig_Solver1)\n \n     {\n         vector<valtype> solutions;\n-        txntype whichType;\n+        txnouttype whichType;\n         CScript s;\n         s << key[0].GetPubKey() << OP_CHECKSIG;\n         BOOST_CHECK(Solver(s, whichType, solutions));\n@@ -198,7 +199,7 @@ BOOST_AUTO_TEST_CASE(multisig_Solver1)\n     }\n     {\n         vector<valtype> solutions;\n-        txntype whichType;\n+        txnouttype whichType;\n         CScript s;\n         s << OP_DUP << OP_HASH160 << Hash160(key[0].GetPubKey()) << OP_EQUALVERIFY << OP_CHECKSIG;\n         BOOST_CHECK(Solver(s, whichType, solutions));\n@@ -211,7 +212,7 @@ BOOST_AUTO_TEST_CASE(multisig_Solver1)\n     }\n     {\n         vector<valtype> solutions;\n-        txntype whichType;\n+        txnouttype whichType;\n         CScript s;\n         s << OP_2 << key[0].GetPubKey() << key[1].GetPubKey() << OP_2 << OP_CHECKMULTISIG;\n         BOOST_CHECK(Solver(s, whichType, solutions));\n@@ -223,7 +224,7 @@ BOOST_AUTO_TEST_CASE(multisig_Solver1)\n     }\n     {\n         vector<valtype> solutions;\n-        txntype whichType;\n+        txnouttype whichType;\n         CScript s;\n         s << OP_1 << key[0].GetPubKey() << key[1].GetPubKey() << OP_2 << OP_CHECKMULTISIG;\n         BOOST_CHECK(Solver(s, whichType, solutions));\n@@ -239,7 +240,7 @@ BOOST_AUTO_TEST_CASE(multisig_Solver1)\n     }\n     {\n         vector<valtype> solutions;\n-        txntype whichType;\n+        txnouttype whichType;\n         CScript s;\n         s << OP_2 << key[0].GetPubKey() << key[1].GetPubKey() << key[2].GetPubKey() << OP_3 << OP_CHECKMULTISIG;\n         BOOST_CHECK(Solver(s, whichType, solutions));"
      },
      {
        "sha": "c44642c6e990f285de066970ccffec91906eee03",
        "filename": "src/test/script_op_eval_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 28,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e/src/test/script_op_eval_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e/src/test/script_op_eval_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_op_eval_tests.cpp?ref=2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e",
        "patch": "@@ -13,24 +13,10 @@ using namespace std;\n \n // Test routines internal to script.cpp:\n extern uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n-extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, int& nSigOps, int nHashType);\n+extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, int& nSigOps,\n+                         int nHashType, bool fStrictOpEval);\n \n-static const int64 nEvalSwitchover = 1328054400;\n-\n-struct CEvalFixture {\n-    CEvalFixture()\n-    {\n-        // Set mock time to AFTER OP_EVAL deployed\n-        SetMockTime(nEvalSwitchover+1);\n-    }\n-    ~CEvalFixture()\n-    {\n-        // Reset back to use-real-time\n-        SetMockTime(0);\n-    }\n-};\n-\n-BOOST_FIXTURE_TEST_SUITE(script_op_eval_tests, CEvalFixture)\n+BOOST_AUTO_TEST_SUITE(script_op_eval_tests)\n \n BOOST_AUTO_TEST_CASE(script_op_eval1)\n {\n@@ -130,8 +116,8 @@ BOOST_AUTO_TEST_CASE(script_op_eval2)\n     txTo.vout[0].nValue = 1;\n \n     int nUnused = 0;\n-    BOOST_CHECK(!VerifyScript(txTo.vin[0].scriptSig, txFrom.vout[0].scriptPubKey, txTo, 0, nUnused, 0));\n-    BOOST_CHECK(!VerifySignature(txFrom, txTo, 0, nUnused));\n+    BOOST_CHECK(!VerifyScript(txTo.vin[0].scriptSig, txFrom.vout[0].scriptPubKey, txTo, 0, nUnused, 0, true));\n+    BOOST_CHECK(!VerifySignature(txFrom, txTo, 0, nUnused, true));\n }\n \n BOOST_AUTO_TEST_CASE(script_op_eval3)\n@@ -212,13 +198,13 @@ BOOST_AUTO_TEST_CASE(script_op_eval_backcompat1)\n     txTo.vout[0].nValue = 1;\n \n     int nUnused = 0;\n-    BOOST_CHECK(!VerifyScript(txTo.vin[0].scriptSig, txFrom.vout[0].scriptPubKey, txTo, 0, nUnused, 0));\n-    BOOST_CHECK(!VerifySignature(txFrom, txTo, 0, nUnused));\n+    BOOST_CHECK(!VerifyScript(txTo.vin[0].scriptSig, txFrom.vout[0].scriptPubKey, txTo, 0, nUnused, 0, true));\n+    BOOST_CHECK(!VerifySignature(txFrom, txTo, 0, nUnused, true));\n }\n \n BOOST_AUTO_TEST_CASE(script_op_eval_switchover)\n {\n-    // Use SetMockTime to test OP_EVAL switchover code\n+    // Test OP_EVAL switchover code\n     CScript notValid;\n     notValid << OP_11 << OP_12 << OP_EQUALVERIFY;\n \n@@ -238,14 +224,11 @@ BOOST_AUTO_TEST_CASE(script_op_eval_switchover)\n     txTo.vin[0].scriptSig = CScript() << static_cast<std::vector<unsigned char> >(notValid);\n     txTo.vout[0].nValue = 1;\n \n-    SetMockTime(nEvalSwitchover-1);\n-\n     int nUnused = 0;\n-    BOOST_CHECK(VerifyScript(txTo.vin[0].scriptSig, txFrom.vout[0].scriptPubKey, txTo, 0, nUnused, 0));\n+    BOOST_CHECK(VerifyScript(txTo.vin[0].scriptSig, txFrom.vout[0].scriptPubKey, txTo, 0, nUnused, 0, false));\n \n-    // After eval switchover time, it should validate:\n-    SetMockTime(nEvalSwitchover);\n-    BOOST_CHECK(!VerifyScript(txTo.vin[0].scriptSig, txFrom.vout[0].scriptPubKey, txTo, 0, nUnused, 0));\n+    // Under strict op_eval switchover, it should be considered invalid:\n+    BOOST_CHECK(!VerifyScript(txTo.vin[0].scriptSig, txFrom.vout[0].scriptPubKey, txTo, 0, nUnused, 0, true));\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "22885a64387b5fc8e60f6dabff1de8acadd34709",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 19,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e",
        "patch": "@@ -7,8 +7,8 @@\n \n using namespace std;\n extern uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n-extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, int& nSigOps, int nHashType);\n-extern bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, int nHashType);\n+extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, int& nSigOps,\n+                         int nHashType, bool fStrictOpEval);\n \n BOOST_AUTO_TEST_SUITE(script_tests)\n \n@@ -24,18 +24,18 @@ BOOST_AUTO_TEST_CASE(script_PushData)\n     int nUnused = 0;\n \n     vector<vector<unsigned char> > directStack;\n-    BOOST_CHECK(EvalScript(directStack, CScript(&direct[0], &direct[sizeof(direct)]), CTransaction(), 0, 0, nUnused));\n+    BOOST_CHECK(EvalScript(directStack, CScript(&direct[0], &direct[sizeof(direct)]), CTransaction(), 0, 0, true, nUnused));\n \n     vector<vector<unsigned char> > pushdata1Stack;\n-    BOOST_CHECK(EvalScript(pushdata1Stack, CScript(&pushdata1[0], &pushdata1[sizeof(pushdata1)]), CTransaction(), 0, 0, nUnused));\n+    BOOST_CHECK(EvalScript(pushdata1Stack, CScript(&pushdata1[0], &pushdata1[sizeof(pushdata1)]), CTransaction(), 0, 0, true, nUnused));\n     BOOST_CHECK(pushdata1Stack == directStack);\n \n     vector<vector<unsigned char> > pushdata2Stack;\n-    BOOST_CHECK(EvalScript(pushdata2Stack, CScript(&pushdata2[0], &pushdata2[sizeof(pushdata2)]), CTransaction(), 0, 0, nUnused));\n+    BOOST_CHECK(EvalScript(pushdata2Stack, CScript(&pushdata2[0], &pushdata2[sizeof(pushdata2)]), CTransaction(), 0, 0, true, nUnused));\n     BOOST_CHECK(pushdata2Stack == directStack);\n \n     vector<vector<unsigned char> > pushdata4Stack;\n-    BOOST_CHECK(EvalScript(pushdata4Stack, CScript(&pushdata4[0], &pushdata4[sizeof(pushdata4)]), CTransaction(), 0, 0, nUnused));\n+    BOOST_CHECK(EvalScript(pushdata4Stack, CScript(&pushdata4[0], &pushdata4[sizeof(pushdata4)]), CTransaction(), 0, 0, true, nUnused));\n     BOOST_CHECK(pushdata4Stack == directStack);\n }\n \n@@ -94,15 +94,15 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG12)\n     txTo12.vout[0].nValue = 1;\n \n     CScript goodsig1 = sign_multisig(scriptPubKey12, key1, txTo12);\n-    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey12, txTo12, 0, nUnused, 0));\n+    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey12, txTo12, 0, nUnused, 0, true));\n     txTo12.vout[0].nValue = 2;\n-    BOOST_CHECK(!VerifyScript(goodsig1, scriptPubKey12, txTo12, 0, nUnused, 0));\n+    BOOST_CHECK(!VerifyScript(goodsig1, scriptPubKey12, txTo12, 0, nUnused, 0, true));\n \n     CScript goodsig2 = sign_multisig(scriptPubKey12, key2, txTo12);\n-    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey12, txTo12, 0, nUnused, 0));\n+    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey12, txTo12, 0, nUnused, 0, true));\n \n     CScript badsig1 = sign_multisig(scriptPubKey12, key3, txTo12);\n-    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey12, txTo12, 0, nUnused, 0));\n+    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey12, txTo12, 0, nUnused, 0, true));\n }\n \n BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n@@ -131,46 +131,46 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n     std::vector<CKey> keys;\n     keys.push_back(key1); keys.push_back(key2);\n     CScript goodsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey23, txTo23, 0, nUnused, 0));\n+    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey23, txTo23, 0, nUnused, 0, true));\n \n     keys.clear();\n     keys.push_back(key1); keys.push_back(key3);\n     CScript goodsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey23, txTo23, 0, nUnused, 0));\n+    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey23, txTo23, 0, nUnused, 0, true));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key3);\n     CScript goodsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig3, scriptPubKey23, txTo23, 0, nUnused, 0));\n+    BOOST_CHECK(VerifyScript(goodsig3, scriptPubKey23, txTo23, 0, nUnused, 0, true));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key2); // Can't re-use sig\n     CScript badsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey23, txTo23, 0, nUnused, 0));\n+    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey23, txTo23, 0, nUnused, 0, true));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key1); // sigs must be in correct order\n     CScript badsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig2, scriptPubKey23, txTo23, 0, nUnused, 0));\n+    BOOST_CHECK(!VerifyScript(badsig2, scriptPubKey23, txTo23, 0, nUnused, 0, true));\n \n     keys.clear();\n     keys.push_back(key3); keys.push_back(key2); // sigs must be in correct order\n     CScript badsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig3, scriptPubKey23, txTo23, 0, nUnused, 0));\n+    BOOST_CHECK(!VerifyScript(badsig3, scriptPubKey23, txTo23, 0, nUnused, 0, true));\n \n     keys.clear();\n     keys.push_back(key4); keys.push_back(key2); // sigs must match pubkeys\n     CScript badsig4 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig4, scriptPubKey23, txTo23, 0, nUnused, 0));\n+    BOOST_CHECK(!VerifyScript(badsig4, scriptPubKey23, txTo23, 0, nUnused, 0, true));\n \n     keys.clear();\n     keys.push_back(key1); keys.push_back(key4); // sigs must match pubkeys\n     CScript badsig5 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig5, scriptPubKey23, txTo23, 0, nUnused, 0));\n+    BOOST_CHECK(!VerifyScript(badsig5, scriptPubKey23, txTo23, 0, nUnused, 0, true));\n \n     keys.clear(); // Must have signatures\n     CScript badsig6 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig6, scriptPubKey23, txTo23, 0, nUnused, 0));\n+    BOOST_CHECK(!VerifyScript(badsig6, scriptPubKey23, txTo23, 0, nUnused, 0, true));\n }    \n \n "
      },
      {
        "sha": "25eb6247ffcee8ced0921c2b0a91389daf8c186b",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 3,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e",
        "patch": "@@ -42,13 +42,13 @@ bool CWallet::AddCryptedKey(const vector<unsigned char> &vchPubKey, const vector\n     return false;\n }\n \n-bool CWallet::AddCScript(const uint160 &hash, const std::vector<unsigned char>& data)\n+bool CWallet::AddCScript(const uint160 &hash, const CScript& redeemScript)\n {\n-    if (!CCryptoKeyStore::AddCScript(hash, data))\n+    if (!CCryptoKeyStore::AddCScript(hash, redeemScript))\n         return false;\n     if (!fFileBacked)\n         return true;\n-    return CWalletDB(strWalletFile).WriteCScript(hash, data);\n+    return CWalletDB(strWalletFile).WriteCScript(hash, redeemScript);\n }\n \n bool CWallet::Unlock(const SecureString& strWalletPassphrase)\n@@ -386,6 +386,14 @@ int64 CWallet::GetDebit(const CTxIn &txin) const\n bool CWallet::IsChange(const CTxOut& txout) const\n {\n     CBitcoinAddress address;\n+\n+    // TODO: fix handling of 'change' outputs. The assumption is that any\n+    // payment to a TX_PUBKEYHASH that is mine but isn't in the address book\n+    // is change. That assumption is likely to break when we implement multisignature\n+    // wallets that return change back into a multi-signature-protected address;\n+    // a better way of identifying which outputs are 'the send' and which are\n+    // 'the change' will need to be implemented (maybe extend CWalletTx to remember\n+    // which output, if any, was change).\n     if (ExtractAddress(txout.scriptPubKey, this, address) && !address.IsScript())\n         CRITICAL_BLOCK(cs_wallet)\n             if (!mapAddressBook.count(address))"
      },
      {
        "sha": "a7d07c993fc728f4e15c1a2d3c7037c2060ddf12",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e",
        "patch": "@@ -7,6 +7,7 @@\n \n #include \"bignum.h\"\n #include \"key.h\"\n+#include \"keystore.h\"\n #include \"script.h\"\n \n class CWalletTx;\n@@ -69,8 +70,8 @@ class CWallet : public CCryptoKeyStore\n     bool AddCryptedKey(const std::vector<unsigned char> &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret);\n     // Adds an encrypted key to the store, without saving it to disk (used by LoadWallet)\n     bool LoadCryptedKey(const std::vector<unsigned char> &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret) { return CCryptoKeyStore::AddCryptedKey(vchPubKey, vchCryptedSecret); }\n-    bool AddCScript(const uint160& hash, const std::vector<unsigned char>& data);\n-    bool LoadCScript(const uint160& hash, const std::vector<unsigned char>& data) { return CCryptoKeyStore::AddCScript(hash, data); }\n+    bool AddCScript(const uint160& hash, const CScript& redeemScript);\n+    bool LoadCScript(const uint160& hash, const CScript& redeemScript) { return CCryptoKeyStore::AddCScript(hash, redeemScript); }\n \n     bool Unlock(const SecureString& strWalletPassphrase);\n     bool ChangeWalletPassphrase(const SecureString& strOldWalletPassphrase, const SecureString& strNewWalletPassphrase);"
      }
    ]
  },
  {
    "sha": "be237c119e82a4c01f4ef3da4264faa6c900e9e3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiZTIzN2MxMTllODJhNGMwMWY0ZWYzZGE0MjY0ZmFhNmM5MDBlOWUz",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-12-05T15:32:35Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-12-19T18:24:49Z"
      },
      "message": "Fix logic for IsChange() for send-to-self transactions.",
      "tree": {
        "sha": "68e672f788c7242a32153208f5511eea4f510ae1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/68e672f788c7242a32153208f5511eea4f510ae1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/be237c119e82a4c01f4ef3da4264faa6c900e9e3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/be237c119e82a4c01f4ef3da4264faa6c900e9e3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/be237c119e82a4c01f4ef3da4264faa6c900e9e3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/be237c119e82a4c01f4ef3da4264faa6c900e9e3/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2a45a494b0bec6a0f1fc6ab7f26c260b85e7ff3e"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "3dc804c851bb6786e7b1d0a33204d8be19b3064e",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/be237c119e82a4c01f4ef3da4264faa6c900e9e3/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/be237c119e82a4c01f4ef3da4264faa6c900e9e3/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=be237c119e82a4c01f4ef3da4264faa6c900e9e3",
        "patch": "@@ -394,7 +394,7 @@ bool CWallet::IsChange(const CTxOut& txout) const\n     // a better way of identifying which outputs are 'the send' and which are\n     // 'the change' will need to be implemented (maybe extend CWalletTx to remember\n     // which output, if any, was change).\n-    if (ExtractAddress(txout.scriptPubKey, this, address) && !address.IsScript())\n+    if (ExtractAddress(txout.scriptPubKey, this, address))\n         CRITICAL_BLOCK(cs_wallet)\n             if (!mapAddressBook.count(address))\n                 return true;"
      }
    ]
  },
  {
    "sha": "9e470585b35a84fcb7f6aa41ac0216c117e2a5e1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZTQ3MDU4NWIzNWE4NGZjYjdmNmFhNDFhYzAyMTZjMTE3ZTJhNWUx",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-12-16T23:03:48Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-12-19T18:24:51Z"
      },
      "message": "Update bitcoin address numbers for latest luke-jr/sipa scheme",
      "tree": {
        "sha": "88ead3af4b648db71bda23131b4b70d5c1af7f6e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/88ead3af4b648db71bda23131b4b70d5c1af7f6e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9e470585b35a84fcb7f6aa41ac0216c117e2a5e1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9e470585b35a84fcb7f6aa41ac0216c117e2a5e1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9e470585b35a84fcb7f6aa41ac0216c117e2a5e1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9e470585b35a84fcb7f6aa41ac0216c117e2a5e1/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "be237c119e82a4c01f4ef3da4264faa6c900e9e3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/be237c119e82a4c01f4ef3da4264faa6c900e9e3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/be237c119e82a4c01f4ef3da4264faa6c900e9e3"
      }
    ],
    "stats": {
      "total": 37,
      "additions": 25,
      "deletions": 12
    },
    "files": [
      {
        "sha": "cba638f4e08c567a0b45f34a2a337d68940ee0fb",
        "filename": "src/base58.h",
        "status": "modified",
        "additions": 23,
        "deletions": 10,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e470585b35a84fcb7f6aa41ac0216c117e2a5e1/src/base58.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e470585b35a84fcb7f6aa41ac0216c117e2a5e1/src/base58.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.h?ref=9e470585b35a84fcb7f6aa41ac0216c117e2a5e1",
        "patch": "@@ -253,14 +253,26 @@ class CBase58Data\n };\n \n // base58-encoded bitcoin addresses\n-// Addresses have version 0 or 111 (testnet)\n+// Public-key-hash-addresses have version 0 (or 192 testnet)\n // The data vector contains RIPEMD160(SHA256(pubkey)), where pubkey is the serialized public key\n+// Script-hash-addresses (OP_EVAL) have version 5 (or 196 testnet)\n+// The data vector contains RIPEMD160(SHA256(cscript)), where cscript is the serialized redemption script\n class CBitcoinAddress : public CBase58Data\n {\n public:\n-    void SetHash160(const uint160& hash160)\n+    enum\n     {\n-        SetData(fTestNet ? 111 : 0, &hash160, 20);\n+        PUBKEY_ADDRESS = 0,\n+        SCRIPT_ADDRESS = 5,\n+        PUBKEY_ADDRESS_TEST = 192,\n+        PUBKEY_ADDRESS_TEST_LEGACY = 111,  // Deprecated: old testnet address\n+        SCRIPT_ADDRESS_TEST = 196,\n+    };\n+\n+    bool SetHash160(const uint160& hash160)\n+    {\n+        SetData(fTestNet ? PUBKEY_ADDRESS_TEST : PUBKEY_ADDRESS, &hash160, 20);\n+        return true;\n     }\n \n     void SetPubKey(const std::vector<unsigned char>& vchPubKey)\n@@ -270,7 +282,7 @@ class CBitcoinAddress : public CBase58Data\n \n     bool SetScriptHash160(const uint160& hash160)\n     {\n-        SetData(fTestNet ? 111^2 : 2, &hash160, 20);\n+        SetData(fTestNet ? SCRIPT_ADDRESS_TEST : SCRIPT_ADDRESS, &hash160, 20);\n         return true;\n     }\n \n@@ -280,20 +292,21 @@ class CBitcoinAddress : public CBase58Data\n         bool fExpectTestNet = false;\n         switch(nVersion)\n         {\n-            case 0:\n+            case PUBKEY_ADDRESS:\n                 nExpectedSize = 20; // Hash of public key\n                 fExpectTestNet = false;\n                 break;\n-            case 2:\n+            case SCRIPT_ADDRESS:\n                 nExpectedSize = 20; // OP_EVAL, hash of CScript\n                 fExpectTestNet = false;\n                 break;\n \n-            case 111:\n+            case PUBKEY_ADDRESS_TEST_LEGACY:\n+            case PUBKEY_ADDRESS_TEST:\n                 nExpectedSize = 20;\n                 fExpectTestNet = true;\n                 break;\n-            case 111^2:\n+            case SCRIPT_ADDRESS_TEST:\n                 nExpectedSize = 20;\n                 fExpectTestNet = true;\n                 break;\n@@ -308,8 +321,8 @@ class CBitcoinAddress : public CBase58Data\n         if (!IsValid())\n             return false;\n         if (fTestNet)\n-            return nVersion == 111^2;\n-        return nVersion == 2;\n+            return nVersion == SCRIPT_ADDRESS_TEST;\n+        return nVersion == SCRIPT_ADDRESS;\n     }\n \n     CBitcoinAddress()"
      },
      {
        "sha": "5db708a8cfc1166ff276060b654e909d846c208c",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e470585b35a84fcb7f6aa41ac0216c117e2a5e1/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e470585b35a84fcb7f6aa41ac0216c117e2a5e1/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=9e470585b35a84fcb7f6aa41ac0216c117e2a5e1",
        "patch": "@@ -902,7 +902,7 @@ bool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTes\n {\n     if (IsCoinBase())\n         return true; // Coinbase transactions have no inputs to fetch.\n-    \n+\n     for (int i = 0; i < vin.size(); i++)\n     {\n         COutPoint prevout = vin[i].prevout;"
      },
      {
        "sha": "467cb2f0df8b5423b9aa7aa1825b620818f6c6e5",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e470585b35a84fcb7f6aa41ac0216c117e2a5e1/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e470585b35a84fcb7f6aa41ac0216c117e2a5e1/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=9e470585b35a84fcb7f6aa41ac0216c117e2a5e1",
        "patch": "@@ -1025,7 +1025,7 @@ bool EvalScriptInner(vector<vector<unsigned char> >& stack, const CScript& scrip\n                     valtype& vchScript = stacktop(-1);\n                     CScript subscript(vchScript.begin(), vchScript.end());\n                     popstack(stack);\n-                    \n+\n                     // Codeseparators not allowed; they don't make sense 'inside' an OP_EVAL, because\n                     // their purpose is to change which parts of the scriptPubKey script is copied\n                     // and signed by OP_CHECKSIG, but OP_EVAl'ed code is in the scriptSig, not the scriptPubKey."
      }
    ]
  },
  {
    "sha": "77f21f1583deb89bf3fffe80fe9b181fedb1dd60",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3N2YyMWYxNTgzZGViODliZjNmZmZlODBmZTliMTgxZmVkYjFkZDYw",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-12-20T17:21:47Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2011-12-20T17:21:47Z"
      },
      "message": "include util.h to get SecureString definition.",
      "tree": {
        "sha": "a09b310f27f334784f6d2be2e83fc77c74a10543",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a09b310f27f334784f6d2be2e83fc77c74a10543"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/77f21f1583deb89bf3fffe80fe9b181fedb1dd60",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/77f21f1583deb89bf3fffe80fe9b181fedb1dd60",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/77f21f1583deb89bf3fffe80fe9b181fedb1dd60",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/77f21f1583deb89bf3fffe80fe9b181fedb1dd60/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9e470585b35a84fcb7f6aa41ac0216c117e2a5e1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9e470585b35a84fcb7f6aa41ac0216c117e2a5e1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9e470585b35a84fcb7f6aa41ac0216c117e2a5e1"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 1,
      "deletions": 0
    },
    "files": [
      {
        "sha": "e52ebc01c751f7b4348588a7c8d17f24ead8e6e6",
        "filename": "src/crypter.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/77f21f1583deb89bf3fffe80fe9b181fedb1dd60/src/crypter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/77f21f1583deb89bf3fffe80fe9b181fedb1dd60/src/crypter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypter.h?ref=77f21f1583deb89bf3fffe80fe9b181fedb1dd60",
        "patch": "@@ -4,6 +4,7 @@\n #ifndef __CRYPTER_H__\n #define __CRYPTER_H__\n \n+#include \"util.h\" /* for SecureString */\n #include \"key.h\"\n \n const unsigned int WALLET_CRYPTO_KEY_SIZE = 32;"
      }
    ]
  }
]