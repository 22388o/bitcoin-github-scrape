[
  {
    "sha": "e7c3fa5f06fbaa362eaefd6f50172f8657a6b079",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplN2MzZmE1ZjA2ZmJhYTM2MmVhZWZkNmY1MDE3MmY4NjU3YTZiMDc5",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-09-24T17:21:31Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-09-24T17:21:31Z"
      },
      "message": "Reverse the sort on the mempool's feerate index",
      "tree": {
        "sha": "c82514109b845ff9f08cb4b54d3220d13cd68769",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c82514109b845ff9f08cb4b54d3220d13cd68769"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e7c3fa5f06fbaa362eaefd6f50172f8657a6b079",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e7c3fa5f06fbaa362eaefd6f50172f8657a6b079",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e7c3fa5f06fbaa362eaefd6f50172f8657a6b079",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e7c3fa5f06fbaa362eaefd6f50172f8657a6b079/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "82d2aef7b3e05abda81db03a8d4725d52f06f203",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/82d2aef7b3e05abda81db03a8d4725d52f06f203",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/82d2aef7b3e05abda81db03a8d4725d52f06f203"
      }
    ],
    "stats": {
      "total": 50,
      "additions": 25,
      "deletions": 25
    },
    "files": [
      {
        "sha": "79d806bd224204f155b856ad68b8d4d2bb313bbd",
        "filename": "src/test/mempool_tests.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 23,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e7c3fa5f06fbaa362eaefd6f50172f8657a6b079/src/test/mempool_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e7c3fa5f06fbaa362eaefd6f50172f8657a6b079/src/test/mempool_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/mempool_tests.cpp?ref=e7c3fa5f06fbaa362eaefd6f50172f8657a6b079",
        "patch": "@@ -153,11 +153,11 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n \n     std::vector<std::string> sortedOrder;\n     sortedOrder.resize(5);\n-    sortedOrder[0] = tx2.GetHash().ToString(); // 20000\n-    sortedOrder[1] = tx4.GetHash().ToString(); // 15000\n+    sortedOrder[0] = tx3.GetHash().ToString(); // 0\n+    sortedOrder[1] = tx5.GetHash().ToString(); // 10000\n     sortedOrder[2] = tx1.GetHash().ToString(); // 10000\n-    sortedOrder[3] = tx5.GetHash().ToString(); // 10000\n-    sortedOrder[4] = tx3.GetHash().ToString(); // 0\n+    sortedOrder[3] = tx4.GetHash().ToString(); // 15000\n+    sortedOrder[4] = tx2.GetHash().ToString(); // 20000\n     CheckSort(pool, sortedOrder);\n \n     /* low fee but with high fee child */\n@@ -169,7 +169,7 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n     pool.addUnchecked(tx6.GetHash(), CTxMemPoolEntry(tx6, 0LL, 1, 10.0, 1, true));\n     BOOST_CHECK_EQUAL(pool.size(), 6);\n     // Check that at this point, tx6 is sorted low\n-    sortedOrder.push_back(tx6.GetHash().ToString());\n+    sortedOrder.insert(sortedOrder.begin(), tx6.GetHash().ToString());\n     CheckSort(pool, sortedOrder);\n \n     CTxMemPool::setEntries setAncestors;\n@@ -194,9 +194,9 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n     BOOST_CHECK_EQUAL(pool.size(), 7);\n \n     // Now tx6 should be sorted higher (high fee child): tx7, tx6, tx2, ...\n-    sortedOrder.erase(sortedOrder.end()-1);\n-    sortedOrder.insert(sortedOrder.begin(), tx6.GetHash().ToString());\n-    sortedOrder.insert(sortedOrder.begin(), tx7.GetHash().ToString());\n+    sortedOrder.erase(sortedOrder.begin());\n+    sortedOrder.push_back(tx6.GetHash().ToString());\n+    sortedOrder.push_back(tx7.GetHash().ToString());\n     CheckSort(pool, sortedOrder);\n \n     /* low fee child of tx7 */\n@@ -211,7 +211,7 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n     pool.addUnchecked(tx8.GetHash(), CTxMemPoolEntry(tx8, 0LL, 2, 10.0, 1, true), setAncestors);\n \n     // Now tx8 should be sorted low, but tx6/tx both high\n-    sortedOrder.push_back(tx8.GetHash().ToString());\n+    sortedOrder.insert(sortedOrder.begin(), tx8.GetHash().ToString());\n     CheckSort(pool, sortedOrder);\n \n     /* low fee child of tx7 */\n@@ -226,7 +226,7 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n \n     // tx9 should be sorted low\n     BOOST_CHECK_EQUAL(pool.size(), 9);\n-    sortedOrder.push_back(tx9.GetHash().ToString());\n+    sortedOrder.insert(sortedOrder.begin(), tx9.GetHash().ToString());\n     CheckSort(pool, sortedOrder);\n \n     std::vector<std::string> snapshotOrder = sortedOrder;\n@@ -255,21 +255,21 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n      *  tx8 and tx9 should both now be sorted higher\n      *  Final order after tx10 is added:\n      *\n-     *  tx7 = 2.2M (4 txs)\n-     *  tx6 = 2.2M (5 txs)\n-     *  tx10 = 200k (1 tx)\n-     *  tx8 = 200k (2 txs)\n-     *  tx9 = 200k (2 txs)\n-     *  tx2 = 20000 (1)\n-     *  tx4 = 15000 (1)\n-     *  tx1 = 10000 (1)\n-     *  tx5 = 10000 (1)\n      *  tx3 = 0 (1)\n+     *  tx5 = 10000 (1)\n+     *  tx1 = 10000 (1)\n+     *  tx4 = 15000 (1)\n+     *  tx2 = 20000 (1)\n+     *  tx9 = 200k (2 txs)\n+     *  tx8 = 200k (2 txs)\n+     *  tx10 = 200k (1 tx)\n+     *  tx6 = 2.2M (5 txs)\n+     *  tx7 = 2.2M (4 txs)\n      */\n-    sortedOrder.erase(sortedOrder.end()-2, sortedOrder.end()); // take out tx8, tx9 from the end\n-    sortedOrder.insert(sortedOrder.begin()+2, tx10.GetHash().ToString()); // tx10 is after tx6\n-    sortedOrder.insert(sortedOrder.begin()+3, tx9.GetHash().ToString());\n-    sortedOrder.insert(sortedOrder.begin()+3, tx8.GetHash().ToString());\n+    sortedOrder.erase(sortedOrder.begin(), sortedOrder.begin()+2); // take out tx9, tx8 from the beginning\n+    sortedOrder.insert(sortedOrder.begin()+5, tx9.GetHash().ToString());\n+    sortedOrder.insert(sortedOrder.begin()+6, tx8.GetHash().ToString());\n+    sortedOrder.insert(sortedOrder.begin()+7, tx10.GetHash().ToString()); // tx10 is just before tx6\n     CheckSort(pool, sortedOrder);\n \n     // there should be 10 transactions in the mempool"
      },
      {
        "sha": "2085b718e26c20494bc1c92be86998dd663f340f",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e7c3fa5f06fbaa362eaefd6f50172f8657a6b079/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e7c3fa5f06fbaa362eaefd6f50172f8657a6b079/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=e7c3fa5f06fbaa362eaefd6f50172f8657a6b079",
        "patch": "@@ -160,9 +160,9 @@ class CompareTxMemPoolEntryByFee\n         double f2 = aSize * bFees;\n \n         if (f1 == f2) {\n-            return a.GetTime() < b.GetTime();\n+            return a.GetTime() >= b.GetTime();\n         }\n-        return f1 > f2;\n+        return f1 < f2;\n     }\n \n     // Calculate which feerate to use for an entry (avoiding division)."
      }
    ]
  },
  {
    "sha": "ef80cab476dc5f4c008811d810a78498b64cf88d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplZjgwY2FiNDc2ZGM1ZjRjMDA4ODExZDgxMGE3ODQ5OGI2NGNmODhk",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-09-25T12:47:00Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-09-25T17:40:23Z"
      },
      "message": "Add work limit to CTxMemPool::CalculateDescendants",
      "tree": {
        "sha": "cf7c93c9b060f7c242d7948124610897874d02b9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cf7c93c9b060f7c242d7948124610897874d02b9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ef80cab476dc5f4c008811d810a78498b64cf88d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ef80cab476dc5f4c008811d810a78498b64cf88d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ef80cab476dc5f4c008811d810a78498b64cf88d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ef80cab476dc5f4c008811d810a78498b64cf88d/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e7c3fa5f06fbaa362eaefd6f50172f8657a6b079",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e7c3fa5f06fbaa362eaefd6f50172f8657a6b079",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e7c3fa5f06fbaa362eaefd6f50172f8657a6b079"
      }
    ],
    "stats": {
      "total": 17,
      "additions": 14,
      "deletions": 3
    },
    "files": [
      {
        "sha": "21f6d2f4f3bb089755dd30549ef84caf1f0874a5",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ef80cab476dc5f4c008811d810a78498b64cf88d/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ef80cab476dc5f4c008811d810a78498b64cf88d/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=ef80cab476dc5f4c008811d810a78498b64cf88d",
        "patch": "@@ -410,7 +410,9 @@ void CTxMemPool::removeUnchecked(txiter it)\n // Also assumes that if an entry is in setDescendants already, then all\n // in-mempool descendants of it are already in setDescendants as well, so that we\n // can save time by not iterating over those entries.\n-void CTxMemPool::CalculateDescendants(txiter entryit, setEntries &setDescendants)\n+// If maxDescendantCount is passed in with a positive value, stop the calculation if we\n+// would exceed that number of descendants, and return false.\n+bool CTxMemPool::CalculateDescendants(txiter entryit, setEntries &setDescendants, uint64_t maxDescendantCount /* = 0 */)\n {\n     setEntries stage;\n     if (setDescendants.count(entryit) == 0) {\n@@ -429,8 +431,12 @@ void CTxMemPool::CalculateDescendants(txiter entryit, setEntries &setDescendants\n             if (!setDescendants.count(childiter)) {\n                 stage.insert(childiter);\n             }\n+            if (maxDescendantCount && stage.size() + setDescendants.size() > maxDescendantCount) {\n+                return false;\n+            }\n         }\n     }\n+    return true;\n }\n \n void CTxMemPool::remove(const CTransaction &origTx, std::list<CTransaction>& removed, bool fRecursive)"
      },
      {
        "sha": "551408d4d51068040ec15dbc3bf443fb60a52a53",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 7,
        "deletions": 2,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ef80cab476dc5f4c008811d810a78498b64cf88d/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ef80cab476dc5f4c008811d810a78498b64cf88d/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=ef80cab476dc5f4c008811d810a78498b64cf88d",
        "patch": "@@ -458,8 +458,13 @@ class CTxMemPool\n     void UpdateChildrenForRemoval(txiter entry);\n     /** Populate setDescendants with all in-mempool descendants of hash.\n      *  Assumes that setDescendants includes all in-mempool descendants of anything\n-     *  already in it.  */\n-    void CalculateDescendants(txiter it, setEntries &setDescendants);\n+     *  already in it.\n+     *  Can specify maximum number of descendants to follow before aborting\n+     *  calculation by passing in a non-zero value for maxDescendantCount.\n+     *  Returns true if setDescendants is properly updated, false if the\n+     *  maxDescendantCount  is reached before finishing the calculation.\n+     */\n+    bool CalculateDescendants(txiter it, setEntries &setDescendants, uint64_t maxDescendantCount = 0);\n \n     /** Before calling removeUnchecked for a given transaction,\n      *  UpdateForRemoveFromMempool must be called on the entire (dependent) set"
      }
    ]
  },
  {
    "sha": "7721d934e51ea8febf430f0300446bb1655cb0a8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3NzIxZDkzNGU1MWVhOGZlYmY0MzBmMDMwMDQ0NmJiMTY1NWNiMGE4",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "sipa@ulyssis.org",
        "date": "2015-07-11T14:49:11Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-09-25T17:40:23Z"
      },
      "message": "Move orphan tx handling to a separate log class",
      "tree": {
        "sha": "fcc886d9c77e002c848ef147ac107b0d311f98dc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fcc886d9c77e002c848ef147ac107b0d311f98dc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7721d934e51ea8febf430f0300446bb1655cb0a8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7721d934e51ea8febf430f0300446bb1655cb0a8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7721d934e51ea8febf430f0300446bb1655cb0a8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7721d934e51ea8febf430f0300446bb1655cb0a8/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ef80cab476dc5f4c008811d810a78498b64cf88d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ef80cab476dc5f4c008811d810a78498b64cf88d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ef80cab476dc5f4c008811d810a78498b64cf88d"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 7,
      "deletions": 7
    },
    "files": [
      {
        "sha": "8450aaa04f3cee8afadf560cc1c9bddce7e3dc7e",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7721d934e51ea8febf430f0300446bb1655cb0a8/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7721d934e51ea8febf430f0300446bb1655cb0a8/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=7721d934e51ea8febf430f0300446bb1655cb0a8",
        "patch": "@@ -574,7 +574,7 @@ bool AddOrphanTx(const CTransaction& tx, NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(c\n     unsigned int sz = tx.GetSerializeSize(SER_NETWORK, CTransaction::CURRENT_VERSION);\n     if (sz > 5000)\n     {\n-        LogPrint(\"mempool\", \"ignoring large orphan tx (size: %u, hash: %s)\\n\", sz, hash.ToString());\n+        LogPrint(\"orphan\", \"ignoring large orphan tx (size: %u, hash: %s)\\n\", sz, hash.ToString());\n         return false;\n     }\n \n@@ -583,7 +583,7 @@ bool AddOrphanTx(const CTransaction& tx, NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(c\n     BOOST_FOREACH(const CTxIn& txin, tx.vin)\n         mapOrphanTransactionsByPrev[txin.prevout.hash].insert(hash);\n \n-    LogPrint(\"mempool\", \"stored orphan tx %s (mapsz %u prevsz %u)\\n\", hash.ToString(),\n+    LogPrint(\"orphan\", \"stored orphan tx %s (mapsz %u prevsz %u)\\n\", hash.ToString(),\n              mapOrphanTransactions.size(), mapOrphanTransactionsByPrev.size());\n     return true;\n }\n@@ -618,7 +618,7 @@ void EraseOrphansFor(NodeId peer)\n             ++nErased;\n         }\n     }\n-    if (nErased > 0) LogPrint(\"mempool\", \"Erased %d orphan tx from peer %d\\n\", nErased, peer);\n+    if (nErased > 0) LogPrint(\"orphan\", \"Erased %d orphan tx from peer %d\\n\", nErased, peer);\n }\n \n \n@@ -4316,7 +4316,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                         continue;\n                     if (AcceptToMemoryPool(mempool, stateDummy, orphanTx, true, &fMissingInputs2))\n                     {\n-                        LogPrint(\"mempool\", \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n+                        LogPrint(\"orphan\", \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n                         RelayTransaction(orphanTx);\n                         vWorkQueue.push_back(orphanHash);\n                         vEraseQueue.push_back(orphanHash);\n@@ -4329,11 +4329,11 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                             // Punish peer that gave us an invalid orphan tx\n                             Misbehaving(fromPeer, nDos);\n                             setMisbehaving.insert(fromPeer);\n-                            LogPrint(\"mempool\", \"   invalid orphan tx %s\\n\", orphanHash.ToString());\n+                            LogPrint(\"orphan\", \"   invalid orphan tx %s\\n\", orphanHash.ToString());\n                         }\n                         // Has inputs but not accepted to mempool\n                         // Probably non-standard or insufficient fee/priority\n-                        LogPrint(\"mempool\", \"   removed orphan tx %s\\n\", orphanHash.ToString());\n+                        LogPrint(\"orphan\", \"   removed orphan tx %s\\n\", orphanHash.ToString());\n                         vEraseQueue.push_back(orphanHash);\n                         assert(recentRejects);\n                         recentRejects->insert(orphanHash);\n@@ -4353,7 +4353,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             unsigned int nMaxOrphanTx = (unsigned int)std::max((int64_t)0, GetArg(\"-maxorphantx\", DEFAULT_MAX_ORPHAN_TRANSACTIONS));\n             unsigned int nEvicted = LimitOrphanTxSize(nMaxOrphanTx);\n             if (nEvicted > 0)\n-                LogPrint(\"mempool\", \"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n+                LogPrint(\"orphan\", \"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n         } else {\n             // AcceptToMemoryPool() returned false, possibly because the tx is\n             // already in the mempool; if the tx isn't in the mempool that"
      }
    ]
  },
  {
    "sha": "7008233767bd5e03521d96cde414394975e940d7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3MDA4MjMzNzY3YmQ1ZTAzNTIxZDk2Y2RlNDE0Mzk0OTc1ZTk0MGQ3",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-07-10T21:52:53Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-09-25T19:39:29Z"
      },
      "message": "Implement on-the-fly mempool size limitation.\n\nUses a notion of reserved space:\nThe mempool will now have a soft cap set below its hard cap.  After it fills up\nto the soft cap, transactions must first try using TrimMempool to evict the\namount of size they are adding.  If they fail they can still be let into the\nmempool if they pass a higher relay minimum.  The minimum increases at every\nband between the soft cap and hard cap.\n\nAlso implement a perioidic trim from reserve space:\nUse reserve space between soft cap and hard cap as a reservoir of surplus fees\nthat have been paid above the minRelayTxFee and occasionally use the aggregate\nusage there to trim from the bottom of the mempool.\n\nThis is based on earlier work by Pieter Wuille.",
      "tree": {
        "sha": "73e8f4969a1332ddd04134969ccdece50d77c678",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/73e8f4969a1332ddd04134969ccdece50d77c678"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7008233767bd5e03521d96cde414394975e940d7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7008233767bd5e03521d96cde414394975e940d7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7008233767bd5e03521d96cde414394975e940d7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7008233767bd5e03521d96cde414394975e940d7/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7721d934e51ea8febf430f0300446bb1655cb0a8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7721d934e51ea8febf430f0300446bb1655cb0a8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7721d934e51ea8febf430f0300446bb1655cb0a8"
      }
    ],
    "stats": {
      "total": 425,
      "additions": 378,
      "deletions": 47
    },
    "files": [
      {
        "sha": "3fb5ba1230255fb4fc51948a3191795d1ce67738",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7008233767bd5e03521d96cde414394975e940d7/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7008233767bd5e03521d96cde414394975e940d7/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=7008233767bd5e03521d96cde414394975e940d7",
        "patch": "@@ -320,6 +320,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-dbcache=<n>\", strprintf(_(\"Set database cache size in megabytes (%d to %d, default: %d)\"), nMinDbCache, nMaxDbCache, nDefaultDbCache));\n     strUsage += HelpMessageOpt(\"-loadblock=<file>\", _(\"Imports blocks from external blk000??.dat file\") + \" \" + _(\"on startup\"));\n     strUsage += HelpMessageOpt(\"-maxorphantx=<n>\", strprintf(_(\"Keep at most <n> unconnectable transactions in memory (default: %u)\"), DEFAULT_MAX_ORPHAN_TRANSACTIONS));\n+    strUsage += HelpMessageOpt(\"-maxmempool=<n>\", strprintf(_(\"Keep the transaction memory pool below <n> megabytes n <= 0 disables mempool limiting (default: %u)\"), DEFAULT_MAX_MEMPOOL_SIZE));\n     strUsage += HelpMessageOpt(\"-par=<n>\", strprintf(_(\"Set the number of script verification threads (%u to %d, 0 = auto, <0 = leave that many cores free, default: %d)\"),\n         -GetNumCores(), MAX_SCRIPTCHECK_THREADS, DEFAULT_SCRIPTCHECK_THREADS));\n #ifndef WIN32\n@@ -414,7 +415,7 @@ std::string HelpMessage(HelpMessageMode mode)\n         strUsage += HelpMessageOpt(\"-limitancestorcount=<n>\", strprintf(\"Do not accept transactions if number of in-mempool ancestors is <n> or more (default: %u)\", DEFAULT_ANCESTOR_LIMIT));\n         strUsage += HelpMessageOpt(\"-limitancestorsize=<n>\", strprintf(\"Do not accept transactions whose size with all in-mempool ancestors exceeds <n> kilobytes (default: %u)\", DEFAULT_ANCESTOR_SIZE_LIMIT));\n         strUsage += HelpMessageOpt(\"-limitdescendantcount=<n>\", strprintf(\"Do not accept transactions if any ancestor would have <n> or more in-mempool descendants (default: %u)\", DEFAULT_DESCENDANT_LIMIT));\n-        strUsage += HelpMessageOpt(\"-limitdescendantsize=<n>\", strprintf(\"Do not accept transactions if any ancestor would have more than <n> kilobytes of in-mempool descendants (default: %u).\", DEFAULT_DESCENDANT_SIZE_LIMIT));\n+        strUsage += HelpMessageOpt(\"-limitdescendantsize=<n>\", strprintf(\"Do not accept transactions if any ancestor would have more than <n> kilobytes of in-mempool descendants (default: min(%u, -maxmempool*1000/40). Adjusting this can affect efficiency of mempool limiting\", DEFAULT_DESCENDANT_SIZE_LIMIT));\n     }\n     string debugCategories = \"addrman, alert, bench, coindb, db, lock, rand, rpc, selectcoins, mempool, mempoolrej, net, proxy, prune, http, libevent\"; // Don't translate these and qt below\n     if (mode == HMM_BITCOIN_QT)"
      },
      {
        "sha": "cec3057b881efe9a27ef72237ca296fcd1feb328",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 191,
        "deletions": 20,
        "changes": 211,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7008233767bd5e03521d96cde414394975e940d7/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7008233767bd5e03521d96cde414394975e940d7/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=7008233767bd5e03521d96cde414394975e940d7",
        "patch": "@@ -206,6 +206,8 @@ namespace {\n \n     /** Dirty block file entries. */\n     set<int> setDirtyFileInfo;\n+    /** Last timestamp we tried to use mempool reserve space to evict. */\n+    int64_t lastReserveTrimTime = 0;\n } // anon namespace\n \n //////////////////////////////////////////////////////////////////////////////\n@@ -778,6 +780,48 @@ static std::string FormatStateMessage(const CValidationState &state)\n         state.GetRejectCode());\n }\n \n+/**\n+ * Mempool limiting:\n+ * A maximum memory usage can be set using -maxmempool.\n+ * This value is the hard cap, a threshold we try to never exceed.\n+ * We set the soft cap equal to 50% of this value.  As long as we're\n+ * below the soft cap, new transactions are accepted as long as they are valid\n+ * and meet the base relay requirements.\n+ *\n+ * Once the mempool usage is above the soft cap, new transactions can try to\n+ * enter the mempool by evicting existing transactions. In order for\n+ * transaction A to evict a transaction B, it must also evict all of the\n+ * in-mempool descendants of B.\n+ * Let S be the set containing B and those descendant transactions; then we\n+ * require:\n+ * - feerate(A) > feerate(S).\n+ *   We try to keep the highest fee rate transactions.\n+ * - fees(A) > fees(S)\n+ *   We can't allow total fees in the mempool to decrease without risking a DoS\n+ *   vulnerability.  We use the minrelayfee to ensure that using relay\n+ *   bandwidth incurs a cost, and allowing the fees in the mempool to decrease\n+ *   could allow an attacker to relay transactions for free.\n+ * - (fees(A) - fees(S)) > feerequired(A)\n+ *   Any transaction must pay for its own relay, after accounting for the fees\n+ *   of transactions being removed.\n+ *\n+ * This eviction code is run when calling TrimMempool().\n+ *\n+ * If a new transaction arrives when usage is above the softcap but is unable\n+ * to enter by evicting existing transactions, then it has another chance to enter\n+ * the mempool if its feerate is sufficiently high.  We take the usage between the\n+ * soft cap and the hard cap, and divide it up into 75 bands.  Within\n+ * a band, we accept transactions without evicting existing transactions if the\n+ * feerate is above minrelayfee * 1.1^(n), where n is the band number.\n+ *\n+ * Once we're above the soft cap, we can use the existence of higher fee rate\n+ * transactions in the aggregate to try to evict transactions as well.  The idea\n+ * is that the eviction algorithm described above generally makes it difficult\n+ * for small transactions, even with a high fee rate, to evict long low-fee\n+ * rate chains, because the total fee is hard to exceed. Using the knowledge\n+ * that we have known high-fee-rate transactions in the reserve space, we can\n+ * use them in the aggregate to try to evict large packages of transactions.\n+ */\n bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransaction &tx, bool fLimitFree,\n                         bool* pfMissingInputs, bool fRejectAbsurdFee)\n {\n@@ -879,7 +923,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         CAmount nFees = nValueIn-nValueOut;\n         double dPriority = view.GetPriority(tx, chainActive.Height());\n \n-        CTxMemPoolEntry entry(tx, nFees, GetTime(), dPriority, chainActive.Height(), mempool.HasNoInputsOf(tx));\n+        CTxMemPoolEntry entry(tx, nFees, GetTime(), dPriority, chainActive.Height(), pool.HasNoInputsOf(tx));\n         unsigned int nSize = entry.GetTxSize();\n \n         // Don't accept it if it can't get into a block\n@@ -893,11 +937,131 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n             return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient priority\");\n         }\n \n-        // Continuously rate-limit free (really, very-low-fee) transactions\n-        // This mitigates 'penny-flooding' -- sending thousands of free transactions just to\n-        // be annoying or make others' transactions take longer to confirm.\n-        if (fLimitFree && nFees < ::minRelayTxFee.GetFee(nSize))\n+        // Set an absolute cap on the size of the mempool (0 turns off mempool limiting) and reserve\n+        // 50% of it to operate with the default minimum fee.  Divide the remaining 50% up into\n+        // 75 bands of increasing required fee.  10% increase per band leads to over 1000x greater effective\n+        // fee before the mempool hits the hard cap, which should be sufficiently future proof.\n+        static const double bandIncrease = 1.1;\n+        static const int numBands = 75;\n+        size_t mempoolHardCap = std::max((int64_t)0, GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+        size_t mempoolSoftCap = mempoolHardCap / 2;\n+        size_t mempoolBandSize = (mempoolHardCap - mempoolSoftCap) / numBands;\n+        size_t nLimitDescendants = GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        size_t nLimitAncestors = GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        size_t nLimitAncestorSize = GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n+        // Using more than about 1/5 of our reserve space for a mempool trim will be inefficient\n+        // so by default cap the largest transaction package at size corresponding to that so we will be able\n+        // to effectively evict any package from the mempool if necessary.\n+        size_t defaultDescendantSize = DEFAULT_DESCENDANT_SIZE_LIMIT;\n+        if (mempoolHardCap)\n+            defaultDescendantSize = std::min(defaultDescendantSize, (mempoolHardCap - mempoolSoftCap) / 1000 / 5 / USAGE_TO_SIZE_RATIO);\n+        size_t nLimitDescendantSize = GetArg(\"-limitdescendantsize\", defaultDescendantSize)*1000;\n         {\n+        LOCK(pool.cs); // Keep holding this lock for both stagedelete and setAncestors from calculation to use.\n+        size_t curUsage = pool.DynamicMemoryUsage();\n+\n+        // Try to use excess relay fees paid by txs above the soft cap to trim in aggregate\n+        // Assume trimGoal worth of transactions entered the mempool while the required\n+        // fee was at least the fee rate of the band at the beginning of that size, and thus\n+        // we can use that multiplier (-1 to pay for current relay) to evict transactions\n+        if (mempoolHardCap && fLimitFree && curUsage > mempoolSoftCap) {\n+            size_t excessUsage = curUsage - mempoolSoftCap;\n+            int64_t timeNow = GetTime();\n+            size_t trimGoal = 1000000; // Try to trim up to 1MB worth of memory usage at a time by default\n+            if (timeNow % 10 == 0) {\n+                // Try to trim a larger size on occasion.\n+                // We want to try to use enough reserve size for the trim that we can\n+                // match a maximum size descendant package.\n+                // It doesn't really matter if it turns out 1MB is greater than\n+                // nLimitDescendantSize * USAGE_TO_SIZE_RATIO (maxmempool < 10MB).\n+                trimGoal = nLimitDescendantSize * USAGE_TO_SIZE_RATIO;\n+            }\n+            int payForOwnRelay = 0;\n+            if (pool.bypassedUsage) {\n+                // During a reorg, it doesn't make sense to be evicting anything from the mempool to make\n+                // room for txs readded from disconnected blocks.  If however after the reorg, there is significant\n+                // growth in mempool size it could temporarily impede new txs, so it makes sense to try to trim away\n+                // any growth.  We're not worried about free relay in this case, so there is no exact restriction on\n+                // what fee rate we can use for eviction, so just use the highest logical choice which is the fee rate\n+                // of the current band.\n+                trimGoal = std::min(pool.bypassedUsage, excessUsage);\n+            }\n+            else if (timeNow > lastReserveTrimTime && excessUsage > trimGoal) {\n+                excessUsage -= trimGoal; // Calculate surplus fee at the beginning of the set of txs\n+                payForOwnRelay = 1; // Use all but 1x multiple of min relay fee to try to evict\n+                lastReserveTrimTime = timeNow;\n+            }\n+            else {\n+                trimGoal = 0;\n+            }\n+            if (trimGoal) {\n+                int bandNumber = excessUsage/mempoolBandSize + 1;\n+                double relayMultiplier = pow(bandIncrease, bandNumber) - payForOwnRelay;\n+                CFeeRate excessRate(relayMultiplier * ::minRelayTxFee.GetFeePerK());\n+                size_t sizeToTrim = trimGoal / USAGE_TO_SIZE_RATIO;\n+                CTxMemPool::setEntries noancestors;\n+                CTxMemPool::setEntries txsToDelete;\n+                pool.TrimMempool(trimGoal, noancestors, 0, sizeToTrim, excessRate.GetFee(sizeToTrim), nLimitDescendants, txsToDelete);\n+                if (!txsToDelete.empty()) {\n+                    size_t oldUsage = curUsage;\n+                    size_t numDeleted = txsToDelete.size();\n+                    pool.RemoveStaged(txsToDelete);\n+                    curUsage = pool.DynamicMemoryUsage();\n+                    LogPrint(\"mempool\", \"Removing %u transactions (%ld total usage) using periodic trim from reserve size\\n\", numDeleted, oldUsage - curUsage);\n+                }\n+            }\n+        }\n+\n+        // Calculate in-mempool ancestors, up to a limit.\n+        CTxMemPool::setEntries setAncestors;\n+        std::string errString;\n+        if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n+            return state.DoS(0, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", false, errString);\n+        }\n+\n+        // If the predicted mempool usage is over the soft cap, TrimMempool\n+        // will attempt to find appropriate transactions of lesser\n+        // feerate to evict from the mempool.  If this fails and the mempool usage would be under\n+        // the hardcap there is an opportunity for this transaction to enter the mempool anyway if\n+        // it has a fee high enough to pass the increased minimum relay feerate of the band indicated\n+        // by the mempool's current size.\n+        size_t incrementalUsage = pool.GuessDynamicMemoryUsage(entry);\n+        size_t expectedUsage = curUsage + incrementalUsage; // Track the expected resulting memory usage of the mempool.\n+        CTxMemPool::setEntries stagedelete;\n+        if (mempoolHardCap && fLimitFree && expectedUsage > mempoolSoftCap) {\n+            if (nFees < ::minRelayTxFee.GetFee(nSize)) {\n+                return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient fee after soft cap\", false,\n+                                 strprintf(\"%d < %d\", nFees, ::minRelayTxFee.GetFee(nSize)));\n+            }\n+            size_t trimGoal = std::min(expectedUsage - mempoolSoftCap, incrementalUsage);\n+            uint64_t maxPackageCount = 50 + nSize/200;  // Be willing to explore longer chains for bigger replacement txs\n+            if (!pool.TrimMempool(trimGoal, setAncestors, ::minRelayTxFee.GetFee(nSize), nSize, nFees, maxPackageCount, stagedelete)) {\n+                if (expectedUsage > mempoolHardCap) {\n+                    return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full hard cap\", false,\n+                                     strprintf(\"%u > %u\", expectedUsage, mempoolHardCap));\n+                } else {\n+                    int bandNumber = (expectedUsage - mempoolSoftCap)/mempoolBandSize + 1;\n+                    double relayMultiplier = pow(bandIncrease, bandNumber);\n+                    if (nFees < relayMultiplier * ::minRelayTxFee.GetFee(nSize)) {\n+                        return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full soft cap\", false,\n+                                         strprintf(\"Mult: %.1f - %ld < %ld\", relayMultiplier, nFees, relayMultiplier * ::minRelayTxFee.GetFee(nSize)));\n+                    } else {\n+                        // The fee rate of this transaction is high enough to enter into the reserve space\n+                        // If stagedelete is non-empty at this point, it has only been populated with sets of transactions\n+                        // that each have lower fee-rate than this transaction.  As such, it is safe to also still delete\n+                        // the partial eviction set, as the effective fee rate for any remaining part of the transaction\n+                        // would only have been higher than the original fee rate, and still passed the test for reserve space.\n+                        LogPrint(\"mempool\", \"Tx %s (%ld fee, %u bytes) eligible for reserve space at usage of %lu and mult of %.1f\\n\",\n+                                 tx.GetHash().ToString().substr(0,10).c_str(), nFees, nSize, expectedUsage, relayMultiplier);\n+                    }\n+                }\n+            }\n+        }\n+        else if (fLimitFree && nFees < ::minRelayTxFee.GetFee(nSize))\n+        {\n+            // Continuously rate-limit free (really, very-low-fee) transactions\n+            // This mitigates 'penny-flooding' -- sending thousands of free transactions just to\n+            // be annoying or make others' transactions take longer to confirm.\n             static CCriticalSection csFreeLimiter;\n             static double dFreeCount;\n             static int64_t nLastTime;\n@@ -921,17 +1085,6 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n                 REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, ::minRelayTxFee.GetFee(nSize) * 10000));\n \n-        // Calculate in-mempool ancestors, up to a limit.\n-        CTxMemPool::setEntries setAncestors;\n-        size_t nLimitAncestors = GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n-        size_t nLimitAncestorSize = GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n-        size_t nLimitDescendants = GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n-        size_t nLimitDescendantSize = GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n-        std::string errString;\n-        if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n-            return state.DoS(0, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", false, errString);\n-        }\n-\n         // Check against previous transactions\n         // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n         if (!CheckInputs(tx, state, view, true, STANDARD_SCRIPT_VERIFY_FLAGS, true))\n@@ -952,8 +1105,25 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n                 __func__, hash.ToString(), FormatStateMessage(state));\n         }\n \n+        // Delete staged transactions to actually make space in mempool\n+        if (!stagedelete.empty()) {\n+            size_t oldUsage = curUsage;\n+            size_t numDeleted = stagedelete.size();\n+            pool.RemoveStaged(stagedelete);\n+            curUsage = pool.DynamicMemoryUsage();\n+            LogPrint(\"mempool\", \"Removing %u transactions (%ld total usage) from the mempool to make space for %s\\n\", numDeleted, oldUsage - curUsage, tx.GetHash().ToString());\n+        }\n+        if (!fLimitFree) {\n+            // We let these transactions in without respecting mempool limits.\n+            // Track freely added size and trim mempool later so reserve space hasn't caused min fee to go too high\n+            pool.bypassedUsage += incrementalUsage;\n+        } else {\n+            // We would have trimmed for it if necessary.\n+            pool.bypassedUsage = 0;\n+        }\n         // Store transaction in memory\n         pool.addUnchecked(hash, entry, setAncestors, !IsInitialBlockDownload());\n+        }\n     }\n \n     SyncWithWallets(tx, NULL);\n@@ -4286,10 +4456,11 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             RelayTransaction(tx);\n             vWorkQueue.push_back(inv.hash);\n \n-            LogPrint(\"mempool\", \"AcceptToMemoryPool: peer=%d: accepted %s (poolsz %u)\\n\",\n-                pfrom->id,\n-                tx.GetHash().ToString(),\n-                mempool.size());\n+            LogPrint(\"mempool\", \"AcceptToMemoryPool: peer=%d: accepted %s (poolsz %u txs %.2f M usage)\\n\",\n+                     pfrom->id,\n+                     tx.GetHash().ToString(),\n+                     mempool.size(),\n+                     (double)mempool.DynamicMemoryUsage()/1000000);\n \n             // Recursively process any orphan transactions that depended on this one\n             set<NodeId> setMisbehaving;"
      },
      {
        "sha": "3b205b3991f1bb78136c012e1ad487f8bb88094b",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7008233767bd5e03521d96cde414394975e940d7/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7008233767bd5e03521d96cde414394975e940d7/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=7008233767bd5e03521d96cde414394975e940d7",
        "patch": "@@ -43,6 +43,8 @@ struct CNodeStateStats;\n static const bool DEFAULT_ALERTS = true;\n /** Default for -maxorphantx, maximum number of orphan transactions kept in memory */\n static const unsigned int DEFAULT_MAX_ORPHAN_TRANSACTIONS = 100;\n+/** Default for -maxmempool, maximum megabytes of mempool memory usage */\n+static const unsigned int DEFAULT_MAX_MEMPOOL_SIZE = 500;\n /** Default for -limitancestorcount, max number of in-mempool ancestors */\n static const unsigned int DEFAULT_ANCESTOR_LIMIT = 100;\n /** Default for -limitancestorsize, maximum kilobytes of tx + all in-mempool ancestors */\n@@ -223,7 +225,15 @@ void FlushStateToDisk();\n /** Prune block files and flush state to disk. */\n void PruneAndFlush();\n \n-/** (try to) add transaction to memory pool **/\n+/**\n+ * Attempt to accept a new transaction into the memory pool\n+ * @param[in]   pool    A reference to the mempool\n+ * @param[out]  state   This may be set to an Invalid state if the transaction can not be accepted due to being invalid or failing policy requirements.  The reason for rejection is returned in the state.\n+ * @param[in]   tx      A reference to the tx to be accepted\n+ * @param[in]   fLimitFree  Whether free txs should be limited and mempool limits should be respected. Used during reorgs to prevent txs being readded from a disconnected block causing other mempool txs to be evicted.\n+ * @param[out]  pfMissingInputs Used to indicate the tx was missing inputs and should be considered an orphan\n+ * @param[in]   fRejectAbsurdFee Perform a high fee check before accepting (used for wallet txs).  Default: false\n+ **/\n bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransaction &tx, bool fLimitFree,\n                         bool* pfMissingInputs, bool fRejectAbsurdFee=false);\n "
      },
      {
        "sha": "f3060c8777fe699abc3da01d23b08394553339ee",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 129,
        "deletions": 0,
        "changes": 129,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7008233767bd5e03521d96cde414394975e940d7/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7008233767bd5e03521d96cde414394975e940d7/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=7008233767bd5e03521d96cde414394975e940d7",
        "patch": "@@ -308,6 +308,8 @@ void CTxMemPoolEntry::UpdateState(int64_t modifySize, CAmount modifyFee, int64_t\n CTxMemPool::CTxMemPool(const CFeeRate& _minRelayFee) :\n     nTransactionsUpdated(0)\n {\n+    clear();\n+\n     // Sanity checks off by default for performance, because otherwise\n     // accepting transactions becomes O(N^2) where N is the number\n     // of transactions in the pool\n@@ -554,6 +556,7 @@ void CTxMemPool::clear()\n     mapNextTx.clear();\n     totalTxSize = 0;\n     cachedInnerUsage = 0;\n+    bypassedUsage = 0;\n     ++nTransactionsUpdated;\n }\n \n@@ -760,6 +763,7 @@ void CTxMemPool::ClearPrioritisation(const uint256 hash)\n \n bool CTxMemPool::HasNoInputsOf(const CTransaction &tx) const\n {\n+    LOCK(cs);\n     for (unsigned int i = 0; i < tx.vin.size(); i++)\n         if (exists(tx.vin[i].prevout.hash))\n             return false;\n@@ -790,6 +794,131 @@ size_t CTxMemPool::DynamicMemoryUsage() const {\n     return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 9 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + memusage::DynamicUsage(mapLinks) + cachedInnerUsage;\n }\n \n+size_t CTxMemPool::GuessDynamicMemoryUsage(const CTxMemPoolEntry& entry) const {\n+    setEntries s;\n+    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 9 * sizeof(void*)) + entry.DynamicMemoryUsage() + (memusage::IncrementalDynamicUsage(mapNextTx) + memusage::IncrementalDynamicUsage(s)) * entry.GetTx().vin.size() + memusage::IncrementalDynamicUsage(mapLinks);\n+}\n+\n+bool CTxMemPool::TrimMempool(size_t usageToTrim, const setEntries &setAncestors, CAmount nFeesReserved, size_t sizeToUse, CAmount feeToUse,\n+                             uint64_t maxPackageCount, setEntries& stage) {\n+    size_t usageRemoved = 0;\n+    CAmount nFeesRemoved = 0;\n+    int fails = 0; // Number of packages explored that were not included in the stage.\n+\n+    // Before we've staged any transactions, the feerate sort and summary\n+    // information in each CTxMemPoolEntry should be enough to know whether a\n+    // package is evictable.\n+    // After we've staged an entry, the package summary information is no longer\n+    // enough to know whether a package is evictable, and we have to walk the\n+    // chain of transactions to find out.\n+    // Skip over packages whose length exceeds maxPackageCount, to bound the work\n+    // we will do.\n+    seed_insecure_rand();\n+\n+    // Iterate from lowest feerate package to highest in the mempool:\n+    indexed_transaction_set::nth_index<1>::type::iterator it = mapTx.get<1>().begin();\n+    while (usageRemoved < usageToTrim && it != mapTx.get<1>().end()) {\n+        if (fails > 5) {\n+            // Bail out after exploring 5 packages that weren't included\n+            break;\n+        }\n+        if (insecure_rand()%4) {\n+            // Only try 1/4 of the transactions so we don't get stuck on the same hard to evict chains\n+            it++;\n+            continue;\n+        }\n+        txiter hashiter = mapTx.project<0>(it); // convert to iterator on 0th index\n+        if (setAncestors.count(hashiter)) {\n+            // Move along to an entry this tx doesn't depend on\n+            fails++;\n+            it++;\n+            continue;\n+        }\n+        if (stage.count(hashiter)) {\n+            // If the transaction is already staged for deletion, we know its descendants are already processed, so skip it.\n+            it++;\n+            continue;\n+        }\n+        CAmount sortedFee = it->UseDescendantFeeRate() ? it->GetFeesWithDescendants() : it->GetFee();\n+        size_t sortedSize = it->UseDescendantFeeRate() ? it->GetSizeWithDescendants() : it->GetTxSize();\n+        if ((double)sortedFee * sizeToUse > (double)feeToUse * sortedSize) {\n+            // If we've already iterated past all transactions with lower feeRate and lower package feeRate\n+            // then we can't add anything else to evict.  Bail out.\n+            break;\n+        }\n+        if (nFeesReserved + it->GetFeesWithDescendants() > feeToUse) {\n+            // We know that even using our original available fees we couldn't evict this tx and its descendents\n+            // so we can shortcut following the descendant trail.\n+            // We can only test using our starting available fees, because although we may have already used\n+            // some fees up evicting other tx's, its possible those are also counted in the descendants of the tx\n+            // being considered.  (i.e. on a previous pass we picked up the same chain at a descendant)\n+            fails++;\n+            it++;\n+            continue;\n+        }\n+        if (!stage.empty() && it->GetCountWithDescendants() > maxPackageCount) {\n+            // This chain is long and could fail; bail out and look for\n+            // something smaller.\n+            fails++;\n+            it++;\n+            continue;\n+        }\n+\n+        // Calculate the full descendant package for evaluation\n+        setEntries setDescendants;\n+        if (it->IsDirty()) {\n+            // Dirty entries can always fail (they're not sorted in the right place), so\n+            // limit the work we're willing to do.\n+            if (!CalculateDescendants(hashiter, setDescendants, maxPackageCount)) {\n+                // The descendant chain was actually too long\n+                fails++;\n+                it++;\n+                continue;\n+            }\n+        } else {\n+            CalculateDescendants(hashiter, setDescendants);\n+        }\n+\n+        // Now determine if this package is evictable\n+        bool evictPackage = true;\n+        CAmount nowfee = 0;\n+        size_t nowsize = 0;\n+        size_t nowusage = 0;\n+        BOOST_FOREACH(txiter descendant, setDescendants) {\n+            // Skip over any descendants already staged for eviction\n+            if (stage.count(descendant))\n+                continue;\n+            nowfee += descendant->GetFee();\n+            if (nFeesReserved + nFeesRemoved + nowfee > feeToUse) {\n+                // This pushes up to the total fees deleted too high\n+                evictPackage = false;\n+                break;\n+            }\n+            nowusage += GuessDynamicMemoryUsage(*descendant);\n+            nowsize += descendant->GetTxSize();\n+        }\n+\n+        if (evictPackage && (double)nowfee * sizeToUse <= (double)feeToUse * nowsize) {\n+            // Ensure the new transaction's feerate is above that of the set\n+            // we're removing.  This might not be the case even though we're\n+            // iterating a mempool sorted by full package feerate.\n+            // If we're trying to evict A-B-C-D, then C-D, might already be\n+            // staged, and so what we are considering now is A-B, which\n+            // might have too high a fee rate.\n+            stage.insert(setDescendants.begin(), setDescendants.end());\n+            nFeesRemoved += nowfee;\n+            usageRemoved += nowusage;\n+        } else {\n+            fails++;\n+        }\n+        it++;\n+    }\n+    //We've added all we can.  Is it enough?\n+    if (usageRemoved < usageToTrim)\n+        return false;\n+    return true;\n+}\n+\n void CTxMemPool::RemoveStaged(setEntries &stage) {\n     AssertLockHeld(cs);\n     UpdateForRemoveFromMempool(stage);"
      },
      {
        "sha": "1de6cb0dde1735f8e29765aa4c0431ff8303be90",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 45,
        "deletions": 25,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7008233767bd5e03521d96cde414394975e940d7/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7008233767bd5e03521d96cde414394975e940d7/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=7008233767bd5e03521d96cde414394975e940d7",
        "patch": "@@ -34,14 +34,17 @@ inline bool AllowFree(double dPriority)\n \n /** Fake height value used in CCoins to signify they are only in the memory pool (since 0.8) */\n static const unsigned int MEMPOOL_HEIGHT = 0x7FFFFFFF;\n+/** Conservatively assume transactions use no more than 4x as much memory as their serialized size */\n+static const unsigned int USAGE_TO_SIZE_RATIO = 4;\n \n class CTxMemPool;\n \n /** \\class CTxMemPoolEntry\n  *\n  * CTxMemPoolEntry stores data about the correponding transaction, as well\n  * as data about all in-mempool transactions that depend on the transaction\n- * (\"descendant\" transactions).\n+ * (\"descendant\" transactions).  We track state for descendant transactions\n+ * in order to make limiting the size of the mempool work better (see below).\n  *\n  * When a new entry is added to the mempool, we update the descendant state\n  * (nCountWithDescendants, nSizeWithDescendants, and nFeesWithDescendants) for\n@@ -83,7 +86,7 @@ class CTxMemPoolEntry\n \n     const CTransaction& GetTx() const { return this->tx; }\n     double GetPriority(unsigned int currentHeight) const;\n-    CAmount GetFee() const { return nFee; }\n+    const CAmount& GetFee() const { return nFee; }\n     size_t GetTxSize() const { return nTxSize; }\n     int64_t GetTime() const { return nTime; }\n     unsigned int GetHeight() const { return nHeight; }\n@@ -103,6 +106,9 @@ class CTxMemPoolEntry\n     uint64_t GetCountWithDescendants() const { return nCountWithDescendants; }\n     uint64_t GetSizeWithDescendants() const { return nSizeWithDescendants; }\n     CAmount GetFeesWithDescendants() const { return nFeesWithDescendants; }\n+\n+    // Calculate which feerate to use for an entry (avoiding division).\n+    bool UseDescendantFeeRate() const { return (double)GetFeesWithDescendants() * GetTxSize() > (double)GetFee() * GetSizeWithDescendants(); }\n };\n \n // Helpers for modifying CTxMemPool::mapTx, which is a boost multi_index.\n@@ -137,17 +143,17 @@ struct mempoolentry_txid\n     }\n };\n \n-/** \\class CompareTxMemPoolEntryByFee\n+/** \\class CompareTxMemPoolEntryByFeeRate\n  *\n  *  Sort an entry by max(feerate of entry's tx, feerate with all descendants).\n  */\n-class CompareTxMemPoolEntryByFee\n+class CompareTxMemPoolEntryByFeeRate\n {\n public:\n     bool operator()(const CTxMemPoolEntry& a, const CTxMemPoolEntry& b)\n     {\n-        bool fUseADescendants = UseDescendantFeeRate(a);\n-        bool fUseBDescendants = UseDescendantFeeRate(b);\n+        bool fUseADescendants = a.UseDescendantFeeRate();\n+        bool fUseBDescendants = b.UseDescendantFeeRate();\n \n         double aFees = fUseADescendants ? a.GetFeesWithDescendants() : a.GetFee();\n         double aSize = fUseADescendants ? a.GetSizeWithDescendants() : a.GetTxSize();\n@@ -164,14 +170,6 @@ class CompareTxMemPoolEntryByFee\n         }\n         return f1 < f2;\n     }\n-\n-    // Calculate which feerate to use for an entry (avoiding division).\n-    bool UseDescendantFeeRate(const CTxMemPoolEntry &a)\n-    {\n-        double f1 = (double)a.GetFee() * a.GetSizeWithDescendants();\n-        double f2 = (double)a.GetFeesWithDescendants() * a.GetTxSize();\n-        return f2 > f1;\n-    }\n };\n \n class CompareTxMemPoolEntryByEntryTime\n@@ -209,16 +207,24 @@ class CInPoint\n  * an input of a transaction in the pool, it is dropped,\n  * as are non-standard transactions.\n  *\n+ * Note: the term \"descendant\" refers to in-mempool transactions that depend on\n+ * a given tx, while \"ancestor\" refers to in-mempool transactions that a given\n+ * transaction depends on.\n+ *\n+ * Mempool limiting:\n+ *\n+ * The mempool's max memory usage can be specified with -maxmempool.\n+ * TrimMempool is used to return a consistent set of transactions (all\n+ * in mempool descendants are included) that can be evicted given a\n+ * fee and size to use for the eviction. The logic for mempool limiting\n+ * and this eviction code is described in AcceptToMemoryPool.\n+ *\n  * CTxMemPool::mapTx, and CTxMemPoolEntry bookkeeping:\n  *\n  * mapTx is a boost::multi_index that sorts the mempool on 2 criteria:\n  * - transaction hash\n  * - feerate [we use max(feerate of tx, feerate of tx with all descendants)]\n  *\n- * Note: the term \"descendant\" refers to in-mempool transactions that depend on\n- * this one, while \"ancestor\" refers to in-mempool transactions that a given\n- * transaction depends on.\n- *\n  * In order for the feerate sort to remain correct, we must update transactions\n  * in the mempool when new descendants arrive.  To facilitate this, we track\n  * the set of in-mempool direct parents and direct children in mapLinks.  Within\n@@ -227,14 +233,15 @@ class CInPoint\n  * Usually when a new transaction is added to the mempool, it has no in-mempool\n  * children (because any such children would be an orphan).  So in\n  * addUnchecked(), we:\n- * - update a new entry's setMemPoolParents to include all in-mempool parents\n- * - update the new entry's direct parents to include the new tx as a child\n+ * - update a new entry's mapLinks[].parents to include all in-mempool parents\n+ * - update those in-mempool parents' maplinks[].children to include the new tx\n+ *   as a child\n  * - update all ancestors of the transaction to include the new tx's size/fee\n  *\n  * When a transaction is removed from the mempool, we must:\n- * - update all in-mempool parents to not track the tx in setMemPoolChildren\n+ * - update all in-mempool parents to not track the tx in mapLinks[].children\n  * - update all ancestors to not include the tx's size/fees in descendant state\n- * - update all in-mempool children to not include it as a parent\n+ * - update all in-mempool children to not include it in mapLinks[].parents\n  *\n  * These happen in UpdateForRemoveFromMempool().  (Note that when removing a\n  * transaction along with its descendants, we must calculate that set of\n@@ -263,7 +270,9 @@ class CInPoint\n  * Updating all in-mempool ancestors of a newly added transaction can be slow,\n  * if no bound exists on how many in-mempool ancestors there may be.\n  * CalculateMemPoolAncestors() takes configurable limits that are designed to\n- * prevent these calculations from being too CPU intensive.\n+ * prevent these calculations from being too CPU intensive, and for ensuring\n+ * that transaction packages can't be too large for the eviction code to be\n+ * able to properly function.  See comments below.\n  *\n  * Adding transactions from a disconnected block can be very time consuming,\n  * because we don't have a way to limit the number of in-mempool descendants.\n@@ -293,7 +302,7 @@ class CTxMemPool\n             // sorted by fee rate\n             boost::multi_index::ordered_non_unique<\n                 boost::multi_index::identity<CTxMemPoolEntry>,\n-                CompareTxMemPoolEntryByFee\n+                CompareTxMemPoolEntryByFeeRate\n             >\n         >\n     > indexed_transaction_set;\n@@ -327,6 +336,7 @@ class CTxMemPool\n public:\n     std::map<COutPoint, CInPoint> mapNextTx;\n     std::map<uint256, std::pair<double, CAmount> > mapDeltas;\n+    size_t bypassedUsage; //! Track cumulative memory usage of txs added to mempool during a reorg (while eviction is bypassed)\n \n     CTxMemPool(const CFeeRate& _minRelayFee);\n     ~CTxMemPool();\n@@ -368,7 +378,16 @@ class CTxMemPool\n     void ApplyDeltas(const uint256 hash, double &dPriorityDelta, CAmount &nFeeDelta);\n     void ClearPrioritisation(const uint256 hash);\n \n-public:\n+    /** TrimMempool will build a list of transactions (hashes) to remove until it reaches usageToTrim:\n+     *  - No txs in setAncestors are removed.\n+     *  - The total fees removed are not more than the feeToUse (minus any nFeesReserved).\n+     *  - The feerate of what is removed is not better than the feerate of feeToUse/sizeToUse.\n+     *  - maxPackageCount helps provide a bound on how many txs will be iterated over.\n+     *  - The list returned in stage is consistent (if a parent is included, all its descendants are included as well).\n+     *  - Returns true if it was able to remove enough txs to cover usageToTrim\n+     */\n+    bool TrimMempool(size_t usageToTrim, const setEntries &setAncestors, CAmount nFeesReserved, size_t sizeToUse, CAmount feeToUse,\n+\t\t     uint64_t maxPackageCount, setEntries& stage);\n     /** Remove a set of transactions from the mempool.\n      *  If a transaction is in this set, then all in-mempool descendants must\n      *  also be in the set.*/\n@@ -428,6 +447,7 @@ class CTxMemPool\n     bool ReadFeeEstimates(CAutoFile& filein);\n \n     size_t DynamicMemoryUsage() const;\n+    size_t GuessDynamicMemoryUsage(const CTxMemPoolEntry& entry) const;\n \n private:\n     /** UpdateForDescendants is used by UpdateTransactionsFromBlock to update"
      }
    ]
  },
  {
    "sha": "4c1404aebf8335803ddd6de125bd75ae83422fc7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0YzE0MDRhZWJmODMzNTgwM2RkZDZkZTEyNWJkNzVhZTgzNDIyZmM3",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-07-18T23:48:58Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-09-25T19:39:29Z"
      },
      "message": "Mempool expiry\n\n(note the 9x multiplier on (void*)'s for CTxMemPool::DynamicMemoryUsage was accidentally introduced in 5add7a7 but should have waited for this commit which adds the extra index)",
      "tree": {
        "sha": "5a49ca873d8d04d16bdde4dcab0a342c1fd14f91",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5a49ca873d8d04d16bdde4dcab0a342c1fd14f91"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4c1404aebf8335803ddd6de125bd75ae83422fc7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4c1404aebf8335803ddd6de125bd75ae83422fc7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4c1404aebf8335803ddd6de125bd75ae83422fc7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4c1404aebf8335803ddd6de125bd75ae83422fc7/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7008233767bd5e03521d96cde414394975e940d7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7008233767bd5e03521d96cde414394975e940d7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7008233767bd5e03521d96cde414394975e940d7"
      }
    ],
    "stats": {
      "total": 38,
      "additions": 37,
      "deletions": 1
    },
    "files": [
      {
        "sha": "79c81cc4511ddde33761abc86a67efa9a0e7e268",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c1404aebf8335803ddd6de125bd75ae83422fc7/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c1404aebf8335803ddd6de125bd75ae83422fc7/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=4c1404aebf8335803ddd6de125bd75ae83422fc7",
        "patch": "@@ -321,6 +321,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-loadblock=<file>\", _(\"Imports blocks from external blk000??.dat file\") + \" \" + _(\"on startup\"));\n     strUsage += HelpMessageOpt(\"-maxorphantx=<n>\", strprintf(_(\"Keep at most <n> unconnectable transactions in memory (default: %u)\"), DEFAULT_MAX_ORPHAN_TRANSACTIONS));\n     strUsage += HelpMessageOpt(\"-maxmempool=<n>\", strprintf(_(\"Keep the transaction memory pool below <n> megabytes n <= 0 disables mempool limiting (default: %u)\"), DEFAULT_MAX_MEMPOOL_SIZE));\n+    strUsage += HelpMessageOpt(\"-mempoolexpiry=<n>\", strprintf(_(\"Do not keep transactions in the mempool longer than <n> hours (default: %u)\"), DEFAULT_MEMPOOL_EXPIRY));\n     strUsage += HelpMessageOpt(\"-par=<n>\", strprintf(_(\"Set the number of script verification threads (%u to %d, 0 = auto, <0 = leave that many cores free, default: %d)\"),\n         -GetNumCores(), MAX_SCRIPTCHECK_THREADS, DEFAULT_SCRIPTCHECK_THREADS));\n #ifndef WIN32"
      },
      {
        "sha": "7bf3b39b3f6d520f5400e656fd1141a9ce2b37eb",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c1404aebf8335803ddd6de125bd75ae83422fc7/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c1404aebf8335803ddd6de125bd75ae83422fc7/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=4c1404aebf8335803ddd6de125bd75ae83422fc7",
        "patch": "@@ -919,6 +919,12 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n             return state.DoS(0, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\", false,\n                 strprintf(\"%d > %d\", nSigOps, MAX_STANDARD_TX_SIGOPS));\n \n+        // Expire old transactions before trying to replace low-priority ones.\n+        int expired = pool.Expire(GetTime() - GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n+        if (expired != 0) {\n+            LogPrint(\"mempool\", \"Expired %i transactions from the memory pool\\n\", expired);\n+        }\n+\n         CAmount nValueOut = tx.GetValueOut();\n         CAmount nFees = nValueIn-nValueOut;\n         double dPriority = view.GetPriority(tx, chainActive.Height());"
      },
      {
        "sha": "7cdeaccb509b270738c051a5eed76db5a6e03526",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c1404aebf8335803ddd6de125bd75ae83422fc7/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c1404aebf8335803ddd6de125bd75ae83422fc7/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=4c1404aebf8335803ddd6de125bd75ae83422fc7",
        "patch": "@@ -45,6 +45,8 @@ static const bool DEFAULT_ALERTS = true;\n static const unsigned int DEFAULT_MAX_ORPHAN_TRANSACTIONS = 100;\n /** Default for -maxmempool, maximum megabytes of mempool memory usage */\n static const unsigned int DEFAULT_MAX_MEMPOOL_SIZE = 500;\n+/** Default for -mempoolexpiry, expiration time for mempool transactions in hours */\n+static const unsigned int DEFAULT_MEMPOOL_EXPIRY = 168;\n /** Default for -limitancestorcount, max number of in-mempool ancestors */\n static const unsigned int DEFAULT_ANCESTOR_LIMIT = 100;\n /** Default for -limitancestorsize, maximum kilobytes of tx + all in-mempool ancestors */"
      },
      {
        "sha": "cea5c53015ba9ef37f5915b9e3ca2b61360965a8",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c1404aebf8335803ddd6de125bd75ae83422fc7/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c1404aebf8335803ddd6de125bd75ae83422fc7/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=4c1404aebf8335803ddd6de125bd75ae83422fc7",
        "patch": "@@ -927,6 +927,22 @@ void CTxMemPool::RemoveStaged(setEntries &stage) {\n     }\n }\n \n+int CTxMemPool::Expire(int64_t time) {\n+    LOCK(cs);\n+    indexed_transaction_set::nth_index<2>::type::iterator it = mapTx.get<2>().begin();\n+    setEntries toremove;\n+    while (it != mapTx.get<2>().end() && it->GetTime() < time) {\n+        toremove.insert(mapTx.project<0>(it));\n+        it++;\n+    }\n+    setEntries stage;\n+    BOOST_FOREACH(txiter removeit, toremove) {\n+        CalculateDescendants(removeit, stage);\n+    }\n+    RemoveStaged(stage);\n+    return stage.size();\n+}\n+\n bool CTxMemPool::addUnchecked(const uint256&hash, const CTxMemPoolEntry &entry, bool fCurrentEstimate)\n {\n     LOCK(cs);"
      },
      {
        "sha": "2748c79d90c12b26a4655c21828f95bc9245c6d8",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 12,
        "deletions": 1,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c1404aebf8335803ddd6de125bd75ae83422fc7/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c1404aebf8335803ddd6de125bd75ae83422fc7/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=4c1404aebf8335803ddd6de125bd75ae83422fc7",
        "patch": "@@ -218,12 +218,15 @@ class CInPoint\n  * in mempool descendants are included) that can be evicted given a\n  * fee and size to use for the eviction. The logic for mempool limiting\n  * and this eviction code is described in AcceptToMemoryPool.\n+ * There is also functionality for removing old transactions from\n+ * the mempool, via the Expire() function.\n  *\n  * CTxMemPool::mapTx, and CTxMemPoolEntry bookkeeping:\n  *\n- * mapTx is a boost::multi_index that sorts the mempool on 2 criteria:\n+ * mapTx is a boost::multi_index that sorts the mempool on 3 criteria:\n  * - transaction hash\n  * - feerate [we use max(feerate of tx, feerate of tx with all descendants)]\n+ * - time in mempool\n  *\n  * In order for the feerate sort to remain correct, we must update transactions\n  * in the mempool when new descendants arrive.  To facilitate this, we track\n@@ -303,6 +306,11 @@ class CTxMemPool\n             boost::multi_index::ordered_non_unique<\n                 boost::multi_index::identity<CTxMemPoolEntry>,\n                 CompareTxMemPoolEntryByFeeRate\n+            >,\n+            // sorted by entry time\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::identity<CTxMemPoolEntry>,\n+                CompareTxMemPoolEntryByEntryTime\n             >\n         >\n     > indexed_transaction_set;\n@@ -416,6 +424,9 @@ class CTxMemPool\n      */\n     bool CalculateMemPoolAncestors(const CTxMemPoolEntry &entry, setEntries &setAncestors, uint64_t limitAncestorCount, uint64_t limitAncestorSize, uint64_t limitDescendantCount, uint64_t limitDescendantSize, std::string &errString, bool fSearchForParents = true);\n \n+    /** Expire all transaction (and their dependencies) in the mempool older than time. Return the number of removed transactions. */\n+    int Expire(int64_t time);\n+\n     unsigned long size()\n     {\n         LOCK(cs);"
      }
    ]
  },
  {
    "sha": "0169bbdd678b831a24ca61e2c1bc4ef661311040",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMTY5YmJkZDY3OGI4MzFhMjRjYTYxZTJjMWJjNGVmNjYxMzExMDQw",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-09-29T13:17:53Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-09-29T20:01:29Z"
      },
      "message": "Switch exponential relay to continuous.\n\nEasier to more accurately account for surplus fees paid by txs in the reserve space.",
      "tree": {
        "sha": "4e25bde5ca052297d6aa9a64b44c14343d001f0d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4e25bde5ca052297d6aa9a64b44c14343d001f0d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0169bbdd678b831a24ca61e2c1bc4ef661311040",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0169bbdd678b831a24ca61e2c1bc4ef661311040",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0169bbdd678b831a24ca61e2c1bc4ef661311040",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0169bbdd678b831a24ca61e2c1bc4ef661311040/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4c1404aebf8335803ddd6de125bd75ae83422fc7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4c1404aebf8335803ddd6de125bd75ae83422fc7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4c1404aebf8335803ddd6de125bd75ae83422fc7"
      }
    ],
    "stats": {
      "total": 45,
      "additions": 23,
      "deletions": 22
    },
    "files": [
      {
        "sha": "4a61ea0f5bdeb221d36eac06171e14d09cac968a",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 22,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0169bbdd678b831a24ca61e2c1bc4ef661311040/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0169bbdd678b831a24ca61e2c1bc4ef661311040/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=0169bbdd678b831a24ca61e2c1bc4ef661311040",
        "patch": "@@ -809,10 +809,8 @@ static std::string FormatStateMessage(const CValidationState &state)\n  *\n  * If a new transaction arrives when usage is above the softcap but is unable\n  * to enter by evicting existing transactions, then it has another chance to enter\n- * the mempool if its feerate is sufficiently high.  We take the usage between the\n- * soft cap and the hard cap, and divide it up into 75 bands.  Within\n- * a band, we accept transactions without evicting existing transactions if the\n- * feerate is above minrelayfee * 1.1^(n), where n is the band number.\n+ * the mempool if its feerate is sufficiently high.  The effective min feerate required\n+ * increases exponentially between the soft cap and the hard cap based on the the usage.\n  *\n  * Once we're above the soft cap, we can use the existence of higher fee rate\n  * transactions in the aggregate to try to evict transactions as well.  The idea\n@@ -944,14 +942,14 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         }\n \n         // Set an absolute cap on the size of the mempool (0 turns off mempool limiting) and reserve\n-        // 50% of it to operate with the default minimum fee.  Divide the remaining 50% up into\n-        // 75 bands of increasing required fee.  10% increase per band leads to over 1000x greater effective\n-        // fee before the mempool hits the hard cap, which should be sufficiently future proof.\n-        static const double bandIncrease = 1.1;\n-        static const int numBands = 75;\n+        // 50% of it to operate with the default minimum fee.  The effective fee rate increases\n+        // exponentially over the remaining 50% doubling up to 10 times.\n         size_t mempoolHardCap = std::max((int64_t)0, GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n         size_t mempoolSoftCap = mempoolHardCap / 2;\n-        size_t mempoolBandSize = (mempoolHardCap - mempoolSoftCap) / numBands;\n+        static const int maxDoubles = 10;\n+        // Fee Multiplier = 2^(usage/doubleSize)\n+        static const unsigned int doubleSize = (mempoolHardCap - mempoolSoftCap)/maxDoubles;\n+\n         size_t nLimitDescendants = GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n         size_t nLimitAncestors = GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n         size_t nLimitAncestorSize = GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n@@ -967,9 +965,9 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         size_t curUsage = pool.DynamicMemoryUsage();\n \n         // Try to use excess relay fees paid by txs above the soft cap to trim in aggregate\n-        // Assume trimGoal worth of transactions entered the mempool while the required\n-        // fee was at least the fee rate of the band at the beginning of that size, and thus\n-        // we can use that multiplier (-1 to pay for current relay) to evict transactions\n+        // Calculate the cumulative feereate multiplier that must have been paid by the transactions\n+        // in a certain range (trimGoal) above the soft cap because of the exponentially increased\n+        // relay fee and use that multiplier (-1 if accounting for current relay) to evict transactions\n         if (mempoolHardCap && fLimitFree && curUsage > mempoolSoftCap) {\n             size_t excessUsage = curUsage - mempoolSoftCap;\n             int64_t timeNow = GetTime();\n@@ -990,20 +988,24 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n                 // any growth.  We're not worried about free relay in this case, so there is no exact restriction on\n                 // what fee rate we can use for eviction, so just use the highest logical choice which is the fee rate\n                 // of the current band.\n-                trimGoal = std::min(pool.bypassedUsage, excessUsage);\n+                trimGoal = pool.bypassedUsage;\n             }\n-            else if (timeNow > lastReserveTrimTime && excessUsage > trimGoal) {\n-                excessUsage -= trimGoal; // Calculate surplus fee at the beginning of the set of txs\n-                payForOwnRelay = 1; // Use all but 1x multiple of min relay fee to try to evict\n+            else if (timeNow > lastReserveTrimTime) {\n+                payForOwnRelay = 1; // Reserve 1x multiple of min relay fee to pay for own Fee.\n                 lastReserveTrimTime = timeNow;\n             }\n             else {\n                 trimGoal = 0;\n             }\n             if (trimGoal) {\n-                int bandNumber = excessUsage/mempoolBandSize + 1;\n-                double relayMultiplier = pow(bandIncrease, bandNumber) - payForOwnRelay;\n-                CFeeRate excessRate(relayMultiplier * ::minRelayTxFee.GetFeePerK());\n+                trimGoal = std::min(trimGoal, excessUsage);\n+                // Cumulative fee rate multiple paid from x bytes of excess usage to y bytes is the integral of the current fee\n+                // rate multiplier evaluated at y minus the integral evaluated at x all divided by (y-x) to get a fee rate.\n+                // integral = doubleSize/LN2 * 2^(usage/doubleSize)\n+                // CumulativeFeeRateMultiple = (integral(y) - integral(x))/(y -x)\n+                static const double LN2 = 0.69314718056;\n+                double cumulativeFeeRateMultiple = doubleSize/LN2 * (pow(2, (double)excessUsage/doubleSize) - pow(2, (double)(excessUsage-trimGoal)/doubleSize))/trimGoal;\n+                CFeeRate excessRate((cumulativeFeeRateMultiple - payForOwnRelay) * ::minRelayTxFee.GetFeePerK());\n                 size_t sizeToTrim = trimGoal / USAGE_TO_SIZE_RATIO;\n                 CTxMemPool::setEntries noancestors;\n                 CTxMemPool::setEntries txsToDelete;\n@@ -1046,8 +1048,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n                     return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full hard cap\", false,\n                                      strprintf(\"%u > %u\", expectedUsage, mempoolHardCap));\n                 } else {\n-                    int bandNumber = (expectedUsage - mempoolSoftCap)/mempoolBandSize + 1;\n-                    double relayMultiplier = pow(bandIncrease, bandNumber);\n+                    double relayMultiplier = pow(2, (double)(expectedUsage - mempoolSoftCap)/doubleSize);\n                     if (nFees < relayMultiplier * ::minRelayTxFee.GetFee(nSize)) {\n                         return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full soft cap\", false,\n                                          strprintf(\"Mult: %.1f - %ld < %ld\", relayMultiplier, nFees, relayMultiplier * ::minRelayTxFee.GetFee(nSize)));"
      }
    ]
  },
  {
    "sha": "9bc6546e8cf935b3365d5cf6aa6741537edad1be",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YmM2NTQ2ZThjZjkzNWIzMzY1ZDVjZjZhYTY3NDE1MzdlZGFkMWJl",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2015-09-29T16:00:13Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-09-29T20:28:08Z"
      },
      "message": "Consider ancestor fee rate for acceptance to mempool",
      "tree": {
        "sha": "01d9ac4cb00f3d45e54cdf02369f05e0acd71668",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/01d9ac4cb00f3d45e54cdf02369f05e0acd71668"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9bc6546e8cf935b3365d5cf6aa6741537edad1be",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9bc6546e8cf935b3365d5cf6aa6741537edad1be",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9bc6546e8cf935b3365d5cf6aa6741537edad1be",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9bc6546e8cf935b3365d5cf6aa6741537edad1be/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0169bbdd678b831a24ca61e2c1bc4ef661311040",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0169bbdd678b831a24ca61e2c1bc4ef661311040",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0169bbdd678b831a24ca61e2c1bc4ef661311040"
      }
    ],
    "stats": {
      "total": 34,
      "additions": 24,
      "deletions": 10
    },
    "files": [
      {
        "sha": "da0d041ae0fd4c80c1df9c4edf780ed0cf2920bb",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 2,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9bc6546e8cf935b3365d5cf6aa6741537edad1be/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9bc6546e8cf935b3365d5cf6aa6741537edad1be/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=9bc6546e8cf935b3365d5cf6aa6741537edad1be",
        "patch": "@@ -1009,7 +1009,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n                 size_t sizeToTrim = trimGoal / USAGE_TO_SIZE_RATIO;\n                 CTxMemPool::setEntries noancestors;\n                 CTxMemPool::setEntries txsToDelete;\n-                pool.TrimMempool(trimGoal, noancestors, 0, sizeToTrim, excessRate.GetFee(sizeToTrim), nLimitDescendants, txsToDelete);\n+                pool.TrimMempool(trimGoal, noancestors, excessRate.GetFee(sizeToTrim), excessRate, nLimitDescendants, txsToDelete);\n                 if (!txsToDelete.empty()) {\n                     size_t oldUsage = curUsage;\n                     size_t numDeleted = txsToDelete.size();\n@@ -1043,7 +1043,16 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n             }\n             size_t trimGoal = std::min(expectedUsage - mempoolSoftCap, incrementalUsage);\n             uint64_t maxPackageCount = 50 + nSize/200;  // Be willing to explore longer chains for bigger replacement txs\n-            if (!pool.TrimMempool(trimGoal, setAncestors, ::minRelayTxFee.GetFee(nSize), nSize, nFees, maxPackageCount, stagedelete)) {\n+            // Use min(feerate, feerate with ancestors)\n+            CAmount totalFeeWithAncestors = nFees;\n+            size_t totalSizeWithAncestors = nSize;\n+            BOOST_FOREACH(CTxMemPool::txiter it, setAncestors) {\n+                totalFeeWithAncestors += it->GetFee();\n+                totalSizeWithAncestors += it->GetTxSize();\n+            }\n+            CFeeRate ancestorFeeRate(totalFeeWithAncestors, totalSizeWithAncestors);\n+            CFeeRate feeRateToUse = std::min(ancestorFeeRate, CFeeRate(nFees, nSize));\n+            if (!pool.TrimMempool(trimGoal, setAncestors, nFees - ::minRelayTxFee.GetFee(nSize), feeRateToUse, maxPackageCount, stagedelete)) {\n                 if (expectedUsage > mempoolHardCap) {\n                     return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full hard cap\", false,\n                                      strprintf(\"%u > %u\", expectedUsage, mempoolHardCap));\n@@ -1052,6 +1061,11 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n                     if (nFees < relayMultiplier * ::minRelayTxFee.GetFee(nSize)) {\n                         return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full soft cap\", false,\n                                          strprintf(\"Mult: %.1f - %ld < %ld\", relayMultiplier, nFees, relayMultiplier * ::minRelayTxFee.GetFee(nSize)));\n+                    }\n+                    else if (ancestorFeeRate.GetFeePerK() < relayMultiplier * ::minRelayTxFee.GetFeePerK()) { //ancestor fee rate is too low\n+                        return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full soft cap\", false,\n+                                         strprintf(\"Mult: %.1f - Ancestor feerate %ld < %ld\", relayMultiplier,\n+                                                   ancestorFeeRate.GetFeePerK(), relayMultiplier * ::minRelayTxFee.GetFeePerK()));\n                     } else {\n                         // The fee rate of this transaction is high enough to enter into the reserve space\n                         // If stagedelete is non-empty at this point, it has only been populated with sets of transactions"
      },
      {
        "sha": "809bfb07407b961968047c22ed8c5c89edcdb9cb",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9bc6546e8cf935b3365d5cf6aa6741537edad1be/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9bc6546e8cf935b3365d5cf6aa6741537edad1be/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=9bc6546e8cf935b3365d5cf6aa6741537edad1be",
        "patch": "@@ -799,8 +799,8 @@ size_t CTxMemPool::GuessDynamicMemoryUsage(const CTxMemPoolEntry& entry) const {\n     return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 9 * sizeof(void*)) + entry.DynamicMemoryUsage() + (memusage::IncrementalDynamicUsage(mapNextTx) + memusage::IncrementalDynamicUsage(s)) * entry.GetTx().vin.size() + memusage::IncrementalDynamicUsage(mapLinks);\n }\n \n-bool CTxMemPool::TrimMempool(size_t usageToTrim, const setEntries &setAncestors, CAmount nFeesReserved, size_t sizeToUse, CAmount feeToUse,\n-                             uint64_t maxPackageCount, setEntries& stage) {\n+bool CTxMemPool::TrimMempool(size_t usageToTrim, const setEntries &setAncestors, CAmount feeToUse,\n+                             CFeeRate feeRateToUse, uint64_t maxPackageCount, setEntries& stage) {\n     size_t usageRemoved = 0;\n     CAmount nFeesRemoved = 0;\n     int fails = 0; // Number of packages explored that were not included in the stage.\n@@ -841,12 +841,12 @@ bool CTxMemPool::TrimMempool(size_t usageToTrim, const setEntries &setAncestors,\n         }\n         CAmount sortedFee = it->UseDescendantFeeRate() ? it->GetFeesWithDescendants() : it->GetFee();\n         size_t sortedSize = it->UseDescendantFeeRate() ? it->GetSizeWithDescendants() : it->GetTxSize();\n-        if ((double)sortedFee * sizeToUse > (double)feeToUse * sortedSize) {\n+        if (CFeeRate(sortedFee, sortedSize) > feeRateToUse) {\n             // If we've already iterated past all transactions with lower feeRate and lower package feeRate\n             // then we can't add anything else to evict.  Bail out.\n             break;\n         }\n-        if (nFeesReserved + it->GetFeesWithDescendants() > feeToUse) {\n+        if (it->GetFeesWithDescendants() > feeToUse) {\n             // We know that even using our original available fees we couldn't evict this tx and its descendents\n             // so we can shortcut following the descendant trail.\n             // We can only test using our starting available fees, because although we may have already used\n@@ -889,7 +889,7 @@ bool CTxMemPool::TrimMempool(size_t usageToTrim, const setEntries &setAncestors,\n             if (stage.count(descendant))\n                 continue;\n             nowfee += descendant->GetFee();\n-            if (nFeesReserved + nFeesRemoved + nowfee > feeToUse) {\n+            if (nFeesRemoved + nowfee > feeToUse) {\n                 // This pushes up to the total fees deleted too high\n                 evictPackage = false;\n                 break;\n@@ -898,7 +898,7 @@ bool CTxMemPool::TrimMempool(size_t usageToTrim, const setEntries &setAncestors,\n             nowsize += descendant->GetTxSize();\n         }\n \n-        if (evictPackage && (double)nowfee * sizeToUse <= (double)feeToUse * nowsize) {\n+        if (evictPackage && CFeeRate(nowfee, nowsize) <= feeRateToUse) {\n             // Ensure the new transaction's feerate is above that of the set\n             // we're removing.  This might not be the case even though we're\n             // iterating a mempool sorted by full package feerate."
      },
      {
        "sha": "c03b578ba1589338d39fc1da82dd937da4178f62",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9bc6546e8cf935b3365d5cf6aa6741537edad1be/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9bc6546e8cf935b3365d5cf6aa6741537edad1be/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=9bc6546e8cf935b3365d5cf6aa6741537edad1be",
        "patch": "@@ -394,8 +394,8 @@ class CTxMemPool\n      *  - The list returned in stage is consistent (if a parent is included, all its descendants are included as well).\n      *  - Returns true if it was able to remove enough txs to cover usageToTrim\n      */\n-    bool TrimMempool(size_t usageToTrim, const setEntries &setAncestors, CAmount nFeesReserved, size_t sizeToUse, CAmount feeToUse,\n-\t\t     uint64_t maxPackageCount, setEntries& stage);\n+    bool TrimMempool(size_t usageToTrim, const setEntries &setAncestors, CAmount feeToUse,\n+\t\t     CFeeRate feeRateToUse, uint64_t maxPackageCount, setEntries& stage);\n     /** Remove a set of transactions from the mempool.\n      *  If a transaction is in this set, then all in-mempool descendants must\n      *  also be in the set.*/"
      }
    ]
  }
]