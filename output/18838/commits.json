[
  {
    "sha": "35197243bc34b8b4a0c0a61a0a2d9228e6547bd9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNTE5NzI0M2JjMzRiOGI0YTBjMGE2MWEwYTJkOTIyOGU2NTQ3YmQ5",
    "commit": {
      "author": {
        "name": "KoukiNishihara",
        "email": "e175774@ie.u-ryukyu.ac.jp",
        "date": "2020-05-21T04:45:13Z"
      },
      "committer": {
        "name": "KoukiNishihara",
        "email": "e175774@ie.u-ryukyu.ac.jp",
        "date": "2020-05-21T04:45:13Z"
      },
      "message": "rebase and fix conflict",
      "tree": {
        "sha": "b1937fd041db86ddf77fbb7939659996eba87199",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b1937fd041db86ddf77fbb7939659996eba87199"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/35197243bc34b8b4a0c0a61a0a2d9228e6547bd9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/35197243bc34b8b4a0c0a61a0a2d9228e6547bd9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/35197243bc34b8b4a0c0a61a0a2d9228e6547bd9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/35197243bc34b8b4a0c0a61a0a2d9228e6547bd9/comments",
    "author": {
      "login": "Nishikoh",
      "id": 55723667,
      "node_id": "MDQ6VXNlcjU1NzIzNjY3",
      "avatar_url": "https://avatars.githubusercontent.com/u/55723667?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Nishikoh",
      "html_url": "https://github.com/Nishikoh",
      "followers_url": "https://api.github.com/users/Nishikoh/followers",
      "following_url": "https://api.github.com/users/Nishikoh/following{/other_user}",
      "gists_url": "https://api.github.com/users/Nishikoh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Nishikoh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Nishikoh/subscriptions",
      "organizations_url": "https://api.github.com/users/Nishikoh/orgs",
      "repos_url": "https://api.github.com/users/Nishikoh/repos",
      "events_url": "https://api.github.com/users/Nishikoh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Nishikoh/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "Nishikoh",
      "id": 55723667,
      "node_id": "MDQ6VXNlcjU1NzIzNjY3",
      "avatar_url": "https://avatars.githubusercontent.com/u/55723667?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Nishikoh",
      "html_url": "https://github.com/Nishikoh",
      "followers_url": "https://api.github.com/users/Nishikoh/followers",
      "following_url": "https://api.github.com/users/Nishikoh/following{/other_user}",
      "gists_url": "https://api.github.com/users/Nishikoh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Nishikoh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Nishikoh/subscriptions",
      "organizations_url": "https://api.github.com/users/Nishikoh/orgs",
      "repos_url": "https://api.github.com/users/Nishikoh/repos",
      "events_url": "https://api.github.com/users/Nishikoh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Nishikoh/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3eda7ea9ba724bfa53ad6f4f63af85fccb46da00",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3eda7ea9ba724bfa53ad6f4f63af85fccb46da00",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3eda7ea9ba724bfa53ad6f4f63af85fccb46da00"
      }
    ],
    "stats": {
      "total": 26,
      "additions": 13,
      "deletions": 13
    },
    "files": [
      {
        "sha": "08d3dc9ac72de1348f8eb09d476bea8e4eb0e2e3",
        "filename": "test/functional/feature_block.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/35197243bc34b8b4a0c0a61a0a2d9228e6547bd9/test/functional/feature_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/35197243bc34b8b4a0c0a61a0a2d9228e6547bd9/test/functional/feature_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_block.py?ref=35197243bc34b8b4a0c0a61a0a2d9228e6547bd9",
        "patch": "@@ -1393,7 +1393,7 @@ def bootstrap_p2p(self, timeout=10):\n         # an INV for the next block and receive two getheaders - one for the\n         # IBD and one for the INV. We'd respond to both and could get\n         # unexpectedly disconnected if the DoS score for that error is 50.\n-        self.nodes[0].p2p.wait_for_getheaders(timeout=timeout)\n+        self.nodes[0].p2p.wait_for_getheaders(header_hash=0, timeout=timeout)\n \n     def reconnect_p2p(self, timeout=60):\n         \"\"\"Tear down and bootstrap the P2P connection to the node."
      },
      {
        "sha": "7682b0a8f52131818513c99e5c440aa2b5149ebc",
        "filename": "test/functional/mining_basic.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/35197243bc34b8b4a0c0a61a0a2d9228e6547bd9/test/functional/mining_basic.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/35197243bc34b8b4a0c0a61a0a2d9228e6547bd9/test/functional/mining_basic.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mining_basic.py?ref=35197243bc34b8b4a0c0a61a0a2d9228e6547bd9",
        "patch": "@@ -233,7 +233,7 @@ def chain_tip(b_hash, *, status='headers-only', branchlen=1):\n \n         # Should ask for the block from a p2p node, if they announce the header as well:\n         node.add_p2p_connection(P2PDataStore())\n-        node.p2p.wait_for_getheaders(timeout=5)  # Drop the first getheaders\n+        node.p2p.wait_for_getheaders(header_hash=0, timeout=5)  # Drop the first getheaders\n         node.p2p.send_blocks_and_test(blocks=[block], node=node)\n         # Must be active now:\n         assert chain_tip(block.hash, status='active', branchlen=0) in node.getchaintips()"
      },
      {
        "sha": "f79ced52eb0f1fffa706fa73bd92af8bafadf4ba",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/35197243bc34b8b4a0c0a61a0a2d9228e6547bd9/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/35197243bc34b8b4a0c0a61a0a2d9228e6547bd9/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=35197243bc34b8b4a0c0a61a0a2d9228e6547bd9",
        "patch": "@@ -176,7 +176,7 @@ def announce_block_and_wait_for_getdata(self, block, use_header, timeout=60):\n             self.send_message(msg)\n         else:\n             self.send_message(msg_inv(inv=[CInv(MSG_BLOCK, block.sha256)]))\n-            self.wait_for_getheaders()\n+            self.wait_for_getheaders(block.sha256)\n             self.send_message(msg)\n         self.wait_for_getdata([block.sha256])\n "
      },
      {
        "sha": "bfe2007b54f71e936949080e2b738bb0a6fe8970",
        "filename": "test/functional/p2p_sendheaders.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/35197243bc34b8b4a0c0a61a0a2d9228e6547bd9/test/functional/p2p_sendheaders.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/35197243bc34b8b4a0c0a61a0a2d9228e6547bd9/test/functional/p2p_sendheaders.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_sendheaders.py?ref=35197243bc34b8b4a0c0a61a0a2d9228e6547bd9",
        "patch": "@@ -337,7 +337,7 @@ def test_nonnull_locators(self, test_node, inv_node):\n                 if j == 0:\n                     # Announce via inv\n                     test_node.send_block_inv(tip)\n-                    test_node.wait_for_getheaders()\n+                    test_node.wait_for_getheaders(tip)\n                     # Should have received a getheaders now\n                     test_node.send_header_for_blocks(blocks)\n                     # Test that duplicate inv's won't result in duplicate\n@@ -539,7 +539,7 @@ def test_nonnull_locators(self, test_node, inv_node):\n             with mininode_lock:\n                 test_node.last_message.pop(\"getheaders\", None)\n             test_node.send_header_for_blocks([blocks[1]])\n-            test_node.wait_for_getheaders()\n+            test_node.wait_for_getheaders(header_hash=0)\n             test_node.send_header_for_blocks(blocks)\n             test_node.wait_for_getdata([x.sha256 for x in blocks])\n             [test_node.send_message(msg_block(x)) for x in blocks]\n@@ -562,7 +562,7 @@ def test_nonnull_locators(self, test_node, inv_node):\n             with mininode_lock:\n                 test_node.last_message.pop(\"getheaders\", None)\n             test_node.send_header_for_blocks([blocks[i]])\n-            test_node.wait_for_getheaders()\n+            test_node.wait_for_getheaders(header_hash=0)\n \n         # Next header will connect, should re-set our count:\n         test_node.send_header_for_blocks([blocks[0]])\n@@ -577,7 +577,7 @@ def test_nonnull_locators(self, test_node, inv_node):\n             with mininode_lock:\n                 test_node.last_message.pop(\"getheaders\", None)\n             test_node.send_header_for_blocks([blocks[i % len(blocks)]])\n-            test_node.wait_for_getheaders()\n+            test_node.wait_for_getheaders(header_hash=0)\n \n         # Eventually this stops working.\n         test_node.send_header_for_blocks([blocks[-1]])"
      },
      {
        "sha": "7013eea1054b01337146c943aafb4ccbf826deee",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/35197243bc34b8b4a0c0a61a0a2d9228e6547bd9/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/35197243bc34b8b4a0c0a61a0a2d9228e6547bd9/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=35197243bc34b8b4a0c0a61a0a2d9228e6547bd9",
        "patch": "@@ -430,17 +430,17 @@ def test_function():\n \n         self.wait_until(test_function, timeout=timeout)\n \n-    def wait_for_getheaders(self, timeout=60):\n+    def wait_for_getheaders(self, header_hash, timeout=60):\n         \"\"\"Waits for a getheaders message.\n \n-        Receiving any getheaders message will satisfy the predicate. the last_message[\"getheaders\"]\n-        value must be explicitly cleared before calling this method, or this will return\n-        immediately with success. TODO: change this method to take a hash value and only\n-        return true if the correct block header has been requested.\"\"\"\n+        The object hashes in the hashstop  must match the provided header_hash.\"\"\"\n \n         def test_function():\n             assert self.is_connected\n-            return self.last_message.get(\"getheaders\")\n+            last_headers = self.last_message.get(\"getheaders\")\n+            if not last_headers:\n+                return False\n+            return last_headers.hashstop == header_hash\n \n         self.wait_until(test_function, timeout=timeout)\n "
      }
    ]
  }
]