[
  {
    "sha": "b8e50c6e529d8a54643a287b5095dd3e7bd83a2c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiOGU1MGM2ZTUyOWQ4YTU0NjQzYTI4N2I1MDk1ZGQzZTdiZDgzYTJj",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-06-06T14:14:14Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-06-06T14:49:26Z"
      },
      "message": "[wallet] don't set aggressive flag to salvage wallet",
      "tree": {
        "sha": "61e92c42a7b9dab9b7a72e104b6244410a48251a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/61e92c42a7b9dab9b7a72e104b6244410a48251a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b8e50c6e529d8a54643a287b5095dd3e7bd83a2c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b8e50c6e529d8a54643a287b5095dd3e7bd83a2c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b8e50c6e529d8a54643a287b5095dd3e7bd83a2c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b8e50c6e529d8a54643a287b5095dd3e7bd83a2c/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "300f8e7a828f3ffaa3a3e9d979a6dc90f15d0203",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/300f8e7a828f3ffaa3a3e9d979a6dc90f15d0203",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/300f8e7a828f3ffaa3a3e9d979a6dc90f15d0203"
      }
    ],
    "stats": {
      "total": 23,
      "additions": 7,
      "deletions": 16
    },
    "files": [
      {
        "sha": "c918fce5f3d0b0e60aed87cbdd98d867de0f8769",
        "filename": "src/wallet/db.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 14,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b8e50c6e529d8a54643a287b5095dd3e7bd83a2c/src/wallet/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b8e50c6e529d8a54643a287b5095dd3e7bd83a2c/src/wallet/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.cpp?ref=b8e50c6e529d8a54643a287b5095dd3e7bd83a2c",
        "patch": "@@ -164,8 +164,7 @@ bool CDB::Recover(const std::string& filename, void *callbackDataIn, bool (*reco\n {\n     // Recovery procedure:\n     // move wallet file to wallet.timestamp.bak\n-    // Call Salvage with fAggressive=true to\n-    // get as much data as possible.\n+    // Call Salvage to get as much data as possible.\n     // Rewrite salvaged data to fresh wallet file\n     // Set -rescan so any missing transactions will be\n     // found.\n@@ -183,13 +182,13 @@ bool CDB::Recover(const std::string& filename, void *callbackDataIn, bool (*reco\n     }\n \n     std::vector<CDBEnv::KeyValPair> salvagedData;\n-    bool fSuccess = bitdb.Salvage(newFilename, true, salvagedData);\n+    bool fSuccess = bitdb.Salvage(newFilename, salvagedData);\n     if (salvagedData.empty())\n     {\n-        LogPrintf(\"Salvage(aggressive) found no records in %s.\\n\", newFilename);\n+        LogPrintf(\"Salvage found no records in %s.\\n\", newFilename);\n         return false;\n     }\n-    LogPrintf(\"Salvage(aggressive) found %u records\\n\", salvagedData.size());\n+    LogPrintf(\"Salvage found %u records\\n\", salvagedData.size());\n \n     std::unique_ptr<Db> pdbCopy(new Db(bitdb.dbenv, 0));\n     int ret = pdbCopy->open(NULL,               // Txn pointer\n@@ -289,27 +288,20 @@ static const char *HEADER_END = \"HEADER=END\";\n /* End of key/value data */\n static const char *DATA_END = \"DATA=END\";\n \n-bool CDBEnv::Salvage(const std::string& strFile, bool fAggressive, std::vector<CDBEnv::KeyValPair>& vResult)\n+bool CDBEnv::Salvage(const std::string& strFile, std::vector<CDBEnv::KeyValPair>& vResult)\n {\n     LOCK(cs_db);\n     assert(mapFileUseCount.count(strFile) == 0);\n \n     u_int32_t flags = DB_SALVAGE;\n-    if (fAggressive)\n-        flags |= DB_AGGRESSIVE;\n \n     std::stringstream strDump;\n \n     Db db(dbenv, 0);\n     int result = db.verify(strFile.c_str(), NULL, &strDump, flags);\n     if (result == DB_VERIFY_BAD) {\n         LogPrintf(\"CDBEnv::Salvage: Database salvage found errors, all data may not be recoverable.\\n\");\n-        if (!fAggressive) {\n-            LogPrintf(\"CDBEnv::Salvage: Rerun with aggressive mode to ignore errors and continue.\\n\");\n-            return false;\n-        }\n-    }\n-    if (result != 0 && result != DB_VERIFY_BAD) {\n+    } else if (result != 0) {\n         LogPrintf(\"CDBEnv::Salvage: Database salvage failed with result %d.\\n\", result);\n         return false;\n     }"
      },
      {
        "sha": "d87f20c0dfaad4608aedc828f6ea019451f126ae",
        "filename": "src/wallet/db.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b8e50c6e529d8a54643a287b5095dd3e7bd83a2c/src/wallet/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b8e50c6e529d8a54643a287b5095dd3e7bd83a2c/src/wallet/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.h?ref=b8e50c6e529d8a54643a287b5095dd3e7bd83a2c",
        "patch": "@@ -58,13 +58,12 @@ class CDBEnv\n     VerifyResult Verify(const std::string& strFile, bool (*recoverFunc)(const std::string& strFile));\n     /**\n      * Salvage data from a file that Verify says is bad.\n-     * fAggressive sets the DB_AGGRESSIVE flag (see berkeley DB->verify() method documentation).\n      * Appends binary key/value pairs to vResult, returns true if successful.\n      * NOTE: reads the entire database into memory, so cannot be used\n      * for huge databases.\n      */\n     typedef std::pair<std::vector<unsigned char>, std::vector<unsigned char> > KeyValPair;\n-    bool Salvage(const std::string& strFile, bool fAggressive, std::vector<KeyValPair>& vResult);\n+    bool Salvage(const std::string& strFile, std::vector<KeyValPair>& vResult);\n \n     bool Open(const fs::path& path);\n     void Close();"
      }
    ]
  },
  {
    "sha": "b90c905d73145f6641b430924e7642ca6583a0f0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiOTBjOTA1ZDczMTQ1ZjY2NDFiNDMwOTI0ZTc2NDJjYTY1ODNhMGYw",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-06-05T15:36:10Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-06-06T14:49:31Z"
      },
      "message": "[tests] cleanup wallet.py",
      "tree": {
        "sha": "24cca3164b17c0aa4dd9274b30ba34811bf1c75d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/24cca3164b17c0aa4dd9274b30ba34811bf1c75d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b90c905d73145f6641b430924e7642ca6583a0f0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b90c905d73145f6641b430924e7642ca6583a0f0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b90c905d73145f6641b430924e7642ca6583a0f0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b90c905d73145f6641b430924e7642ca6583a0f0/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b8e50c6e529d8a54643a287b5095dd3e7bd83a2c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b8e50c6e529d8a54643a287b5095dd3e7bd83a2c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b8e50c6e529d8a54643a287b5095dd3e7bd83a2c"
      }
    ],
    "stats": {
      "total": 121,
      "additions": 66,
      "deletions": 55
    },
    "files": [
      {
        "sha": "3e9d490b651b928898c850836648fe113962f7f8",
        "filename": "test/functional/wallet.py",
        "status": "modified",
        "additions": 66,
        "deletions": 55,
        "changes": 121,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b90c905d73145f6641b430924e7642ca6583a0f0/test/functional/wallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b90c905d73145f6641b430924e7642ca6583a0f0/test/functional/wallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet.py?ref=b90c905d73145f6641b430924e7642ca6583a0f0",
        "patch": "@@ -3,8 +3,19 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the wallet.\"\"\"\n+import time\n+from decimal import Decimal\n+\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import *\n+from test_framework.util import (assert_array_result,\n+                                 assert_equal,\n+                                 assert_fee_amount,\n+                                 assert_raises_jsonrpc,\n+                                 connect_nodes_bi,\n+                                 count_bytes,\n+                                 sync_blocks,\n+                                 sync_mempools,\n+                                 )\n \n class WalletTest(BitcoinTestFramework):\n \n@@ -18,13 +29,13 @@ def __init__(self):\n         super().__init__()\n         self.setup_clean_chain = True\n         self.num_nodes = 4\n-        self.extra_args = [['-usehd={:d}'.format(i%2==0)] for i in range(4)]\n+        self.extra_args = [['-usehd={:d}'.format(i % 2 == 0)] for i in range(4)]\n \n     def setup_network(self):\n         self.nodes = self.start_nodes(3, self.options.tmpdir, self.extra_args[:3])\n-        connect_nodes_bi(self.nodes,0,1)\n-        connect_nodes_bi(self.nodes,1,2)\n-        connect_nodes_bi(self.nodes,0,2)\n+        connect_nodes_bi(self.nodes, 0, 1)\n+        connect_nodes_bi(self.nodes, 1, 2)\n+        connect_nodes_bi(self.nodes, 0, 2)\n         self.sync_all()\n \n     def run_test(self):\n@@ -105,7 +116,7 @@ def run_test(self):\n \n         # node0 should end up with 100 btc in block rewards plus fees, but\n         # minus the 21 plus fees sent to node2\n-        assert_equal(self.nodes[0].getbalance(), 100-21)\n+        assert_equal(self.nodes[0].getbalance(), 100 - 21)\n         assert_equal(self.nodes[2].getbalance(), 21)\n \n         # Node0 should have two unspent outputs.\n@@ -119,7 +130,7 @@ def run_test(self):\n         for utxo in node0utxos:\n             inputs = []\n             outputs = {}\n-            inputs.append({ \"txid\" : utxo[\"txid\"], \"vout\" : utxo[\"vout\"]})\n+            inputs.append({\"txid\": utxo[\"txid\"], \"vout\": utxo[\"vout\"]})\n             outputs[self.nodes[2].getnewaddress(\"from1\")] = utxo[\"amount\"] - 3\n             raw_tx = self.nodes[0].createrawtransaction(inputs, outputs)\n             txns_to_send.append(self.nodes[0].signrawtransaction(raw_tx))\n@@ -134,7 +145,7 @@ def run_test(self):\n \n         assert_equal(self.nodes[0].getbalance(), 0)\n         assert_equal(self.nodes[2].getbalance(), 94)\n-        assert_equal(self.nodes[2].getbalance(\"from1\"), 94-21)\n+        assert_equal(self.nodes[2].getbalance(\"from1\"), 94 - 21)\n \n         # Send 10 BTC normal\n         address = self.nodes[0].getnewaddress(\"test\")\n@@ -192,85 +203,85 @@ def run_test(self):\n         assert_equal(self.nodes[0].getwalletinfo()[\"unconfirmed_balance\"], 1)\n         assert_equal(self.nodes[0].getunconfirmedbalance(), 1)\n \n-        #check if we can list zero value tx as available coins\n-        #1. create rawtx\n-        #2. hex-changed one output to 0.0\n-        #3. sign and send\n-        #4. check if recipient (node0) can list the zero value tx\n+        # check if we can list zero value tx as available coins\n+        # 1. create rawtx\n+        # 2. hex-changed one output to 0.0\n+        # 3. sign and send\n+        # 4. check if recipient (node0) can list the zero value tx\n         usp = self.nodes[1].listunspent()\n-        inputs = [{\"txid\":usp[0]['txid'], \"vout\":usp[0]['vout']}]\n+        inputs = [{\"txid\": usp[0]['txid'], \"vout\":usp[0]['vout']}]\n         outputs = {self.nodes[1].getnewaddress(): 49.998, self.nodes[0].getnewaddress(): 11.11}\n \n-        rawTx = self.nodes[1].createrawtransaction(inputs, outputs).replace(\"c0833842\", \"00000000\") #replace 11.11 with 0.0 (int32)\n+        rawTx = self.nodes[1].createrawtransaction(inputs, outputs).replace(\"c0833842\", \"00000000\")  # replace 11.11 with 0.0 (int32)\n         decRawTx = self.nodes[1].decoderawtransaction(rawTx)\n         signedRawTx = self.nodes[1].signrawtransaction(rawTx)\n         decRawTx = self.nodes[1].decoderawtransaction(signedRawTx['hex'])\n-        zeroValueTxid= decRawTx['txid']\n-        sendResp = self.nodes[1].sendrawtransaction(signedRawTx['hex'])\n+        zeroValueTxid = decRawTx['txid']\n+        self.nodes[1].sendrawtransaction(signedRawTx['hex'])\n \n         self.sync_all()\n-        self.nodes[1].generate(1) #mine a block\n+        self.nodes[1].generate(1)  # mine a block\n         self.sync_all()\n \n-        unspentTxs = self.nodes[0].listunspent() #zero value tx must be in listunspents output\n+        unspentTxs = self.nodes[0].listunspent()  # zero value tx must be in listunspents output\n         found = False\n         for uTx in unspentTxs:\n             if uTx['txid'] == zeroValueTxid:\n                 found = True\n                 assert_equal(uTx['amount'], Decimal('0'))\n         assert(found)\n \n-        #do some -walletbroadcast tests\n+        # do some -walletbroadcast tests\n         self.stop_nodes()\n-        self.nodes = self.start_nodes(3, self.options.tmpdir, [[\"-walletbroadcast=0\"],[\"-walletbroadcast=0\"],[\"-walletbroadcast=0\"]])\n-        connect_nodes_bi(self.nodes,0,1)\n-        connect_nodes_bi(self.nodes,1,2)\n-        connect_nodes_bi(self.nodes,0,2)\n+        self.nodes = self.start_nodes(3, self.options.tmpdir, [[\"-walletbroadcast=0\"], [\"-walletbroadcast=0\"], [\"-walletbroadcast=0\"]])\n+        connect_nodes_bi(self.nodes, 0, 1)\n+        connect_nodes_bi(self.nodes, 1, 2)\n+        connect_nodes_bi(self.nodes, 0, 2)\n         self.sync_all()\n \n-        txIdNotBroadcasted  = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 2)\n+        txIdNotBroadcasted = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 2)\n         txObjNotBroadcasted = self.nodes[0].gettransaction(txIdNotBroadcasted)\n-        self.nodes[1].generate(1) #mine a block, tx should not be in there\n+        self.nodes[1].generate(1)  # mine a block, tx should not be in there\n         self.sync_all()\n-        assert_equal(self.nodes[2].getbalance(), node_2_bal) #should not be changed because tx was not broadcasted\n+        assert_equal(self.nodes[2].getbalance(), node_2_bal)  # should not be changed because tx was not broadcasted\n \n-        #now broadcast from another node, mine a block, sync, and check the balance\n+        # now broadcast from another node, mine a block, sync, and check the balance\n         self.nodes[1].sendrawtransaction(txObjNotBroadcasted['hex'])\n         self.nodes[1].generate(1)\n         self.sync_all()\n         node_2_bal += 2\n         txObjNotBroadcasted = self.nodes[0].gettransaction(txIdNotBroadcasted)\n         assert_equal(self.nodes[2].getbalance(), node_2_bal)\n \n-        #create another tx\n-        txIdNotBroadcasted  = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 2)\n+        # create another tx\n+        txIdNotBroadcasted = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 2)\n \n-        #restart the nodes with -walletbroadcast=1\n+        # restart the nodes with -walletbroadcast=1\n         self.stop_nodes()\n         self.nodes = self.start_nodes(3, self.options.tmpdir)\n-        connect_nodes_bi(self.nodes,0,1)\n-        connect_nodes_bi(self.nodes,1,2)\n-        connect_nodes_bi(self.nodes,0,2)\n+        connect_nodes_bi(self.nodes, 0, 1)\n+        connect_nodes_bi(self.nodes, 1, 2)\n+        connect_nodes_bi(self.nodes, 0, 2)\n         sync_blocks(self.nodes)\n \n         self.nodes[0].generate(1)\n         sync_blocks(self.nodes)\n         node_2_bal += 2\n \n-        #tx should be added to balance because after restarting the nodes tx should be broadcastet\n+        # tx should be added to balance because after restarting the nodes tx should be broadcastet\n         assert_equal(self.nodes[2].getbalance(), node_2_bal)\n \n-        #send a tx with value in a string (PR#6380 +)\n-        txId  = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), \"2\")\n+        # send a tx with value in a string (PR#6380 +)\n+        txId = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), \"2\")\n         txObj = self.nodes[0].gettransaction(txId)\n         assert_equal(txObj['amount'], Decimal('-2'))\n \n-        txId  = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), \"0.0001\")\n+        txId = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), \"0.0001\")\n         txObj = self.nodes[0].gettransaction(txId)\n         assert_equal(txObj['amount'], Decimal('-0.0001'))\n \n-        #check if JSON parser can handle scientific notation in strings\n-        txId  = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), \"1e-4\")\n+        # check if JSON parser can handle scientific notation in strings\n+        txId = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), \"1e-4\")\n         txObj = self.nodes[0].gettransaction(txId)\n         assert_equal(txObj['amount'], Decimal('-0.0001'))\n \n@@ -295,17 +306,17 @@ def run_test(self):\n \n         # 4. Check that the unspents after import are not spendable\n         assert_array_result(self.nodes[1].listunspent(),\n-                           {\"address\": address_to_import},\n-                           {\"spendable\": False})\n+                            {\"address\": address_to_import},\n+                            {\"spendable\": False})\n \n         # 5. Import private key of the previously imported address on node1\n         priv_key = self.nodes[2].dumpprivkey(address_to_import)\n         self.nodes[1].importprivkey(priv_key)\n \n         # 6. Check that the unspents are now spendable on node1\n         assert_array_result(self.nodes[1].listunspent(),\n-                           {\"address\": address_to_import},\n-                           {\"spendable\": True})\n+                            {\"address\": address_to_import},\n+                            {\"spendable\": True})\n \n         # Mine a block from node0 to an address from node1\n         cbAddr = self.nodes[1].getnewaddress()\n@@ -334,7 +345,7 @@ def run_test(self):\n                 label = self.nodes[0].getaccount(addr)\n                 assert_equal(label, s)\n                 assert(s in self.nodes[0].listaccounts().keys())\n-        self.nodes[0].ensure_ascii = True # restore to default\n+        self.nodes[0].ensure_ascii = True  # restore to default\n \n         # maintenance tests\n         maintenance = [\n@@ -350,7 +361,7 @@ def run_test(self):\n             self.log.info(\"check \" + m)\n             self.stop_nodes()\n             # set lower ancestor limit for later\n-            self.nodes = self.start_nodes(3, self.options.tmpdir, [[m, \"-limitancestorcount=\"+str(chainlimit)]] * 3)\n+            self.nodes = self.start_nodes(3, self.options.tmpdir, [[m, \"-limitancestorcount=\" + str(chainlimit)]] * 3)\n             while m == '-reindex' and [block_count] * 3 != [self.nodes[i].getblockcount() for i in range(3)]:\n                 # reindex will leave rpc warm up \"early\"; Wait for it to finish\n                 time.sleep(0.1)\n@@ -371,7 +382,7 @@ def run_test(self):\n         self.nodes[0].generate(1)\n         node0_balance = self.nodes[0].getbalance()\n         # Split into two chains\n-        rawtx = self.nodes[0].createrawtransaction([{\"txid\":singletxid, \"vout\":0}], {chain_addrs[0]:node0_balance/2-Decimal('0.01'), chain_addrs[1]:node0_balance/2-Decimal('0.01')})\n+        rawtx = self.nodes[0].createrawtransaction([{\"txid\": singletxid, \"vout\": 0}], {chain_addrs[0]: node0_balance / 2 - Decimal('0.01'), chain_addrs[1]: node0_balance / 2 - Decimal('0.01')})\n         signedtx = self.nodes[0].signrawtransaction(rawtx)\n         singletxid = self.nodes[0].sendrawtransaction(signedtx[\"hex\"])\n         self.nodes[0].generate(1)\n@@ -382,37 +393,37 @@ def run_test(self):\n         # So we should be able to generate exactly chainlimit txs for each original output\n         sending_addr = self.nodes[1].getnewaddress()\n         txid_list = []\n-        for i in range(chainlimit*2):\n+        for i in range(chainlimit * 2):\n             txid_list.append(self.nodes[0].sendtoaddress(sending_addr, Decimal('0.0001')))\n-        assert_equal(self.nodes[0].getmempoolinfo()['size'], chainlimit*2)\n-        assert_equal(len(txid_list), chainlimit*2)\n+        assert_equal(self.nodes[0].getmempoolinfo()['size'], chainlimit * 2)\n+        assert_equal(len(txid_list), chainlimit * 2)\n \n         # Without walletrejectlongchains, we will still generate a txid\n         # The tx will be stored in the wallet but not accepted to the mempool\n         extra_txid = self.nodes[0].sendtoaddress(sending_addr, Decimal('0.0001'))\n         assert(extra_txid not in self.nodes[0].getrawmempool())\n         assert(extra_txid in [tx[\"txid\"] for tx in self.nodes[0].listtransactions()])\n         self.nodes[0].abandontransaction(extra_txid)\n-        total_txs = len(self.nodes[0].listtransactions(\"*\",99999))\n+        total_txs = len(self.nodes[0].listtransactions(\"*\", 99999))\n \n         # Try with walletrejectlongchains\n         # Double chain limit but require combining inputs, so we pass SelectCoinsMinConf\n         self.stop_node(0)\n-        self.nodes[0] = self.start_node(0, self.options.tmpdir, [\"-walletrejectlongchains\", \"-limitancestorcount=\"+str(2*chainlimit)])\n+        self.nodes[0] = self.start_node(0, self.options.tmpdir, [\"-walletrejectlongchains\", \"-limitancestorcount=\" + str(2 * chainlimit)])\n \n         # wait for loadmempool\n         timeout = 10\n-        while (timeout > 0 and len(self.nodes[0].getrawmempool()) < chainlimit*2):\n+        while (timeout > 0 and len(self.nodes[0].getrawmempool()) < chainlimit * 2):\n             time.sleep(0.5)\n             timeout -= 0.5\n-        assert_equal(len(self.nodes[0].getrawmempool()), chainlimit*2)\n+        assert_equal(len(self.nodes[0].getrawmempool()), chainlimit * 2)\n \n         node0_balance = self.nodes[0].getbalance()\n         # With walletrejectlongchains we will not create the tx and store it in our wallet.\n         assert_raises_jsonrpc(-4, \"Transaction has too long of a mempool chain\", self.nodes[0].sendtoaddress, sending_addr, node0_balance - Decimal('0.01'))\n \n         # Verify nothing new in wallet\n-        assert_equal(total_txs, len(self.nodes[0].listtransactions(\"*\",99999)))\n+        assert_equal(total_txs, len(self.nodes[0].listtransactions(\"*\", 99999)))\n \n if __name__ == '__main__':\n     WalletTest().main()"
      }
    ]
  },
  {
    "sha": "7a4e314d93ffb932d0a920a2368a02e0f6ed0930",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3YTRlMzE0ZDkzZmZiOTMyZDBhOTIwYTIzNjhhMDJlMGY2ZWQwOTMw",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-06-06T14:40:01Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-06-06T14:49:34Z"
      },
      "message": "[tests] re-enable salvagewallet test",
      "tree": {
        "sha": "c4c32b29807b56647d412326cc27681c94a9d873",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c4c32b29807b56647d412326cc27681c94a9d873"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7a4e314d93ffb932d0a920a2368a02e0f6ed0930",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7a4e314d93ffb932d0a920a2368a02e0f6ed0930",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7a4e314d93ffb932d0a920a2368a02e0f6ed0930",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7a4e314d93ffb932d0a920a2368a02e0f6ed0930/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b90c905d73145f6641b430924e7642ca6583a0f0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b90c905d73145f6641b430924e7642ca6583a0f0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b90c905d73145f6641b430924e7642ca6583a0f0"
      }
    ],
    "stats": {
      "total": 3,
      "additions": 1,
      "deletions": 2
    },
    "files": [
      {
        "sha": "662ff50c45d1707a675046377211ca8141fb4ef7",
        "filename": "test/functional/wallet.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7a4e314d93ffb932d0a920a2368a02e0f6ed0930/test/functional/wallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7a4e314d93ffb932d0a920a2368a02e0f6ed0930/test/functional/wallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet.py?ref=7a4e314d93ffb932d0a920a2368a02e0f6ed0930",
        "patch": "@@ -353,8 +353,7 @@ def run_test(self):\n             '-reindex',\n             '-zapwallettxes=1',\n             '-zapwallettxes=2',\n-            # disabled until issue is fixed: https://github.com/bitcoin/bitcoin/issues/7463\n-            # '-salvagewallet',\n+            '-salvagewallet',\n         ]\n         chainlimit = 6\n         for m in maintenance:"
      }
    ]
  }
]