promag,2019-05-19 09:57:05,utACK 953ed47b.,https://github.com/bitcoin/bitcoin/pull/16045#issuecomment-493743065,493743065,
Empact,2019-05-20 15:24:48,utACK https://github.com/bitcoin/bitcoin/pull/16045/commits/953ed47b42eac7453ad7e6436098301f0cb523a4,https://github.com/bitcoin/bitcoin/pull/16045#issuecomment-494034654,494034654,
l2a5b1,2019-06-15 12:46:21,"Not sure if it's worth a discussion, but I don't see how the call to `memset` can result in undefined behaviour when `memset` takes a pointer to one past the last element of the `rkey` array and the `size_t` argument is `0`. This can't go wrong, can it?",https://github.com/bitcoin/bitcoin/pull/16045#issuecomment-502364018,502364018,
practicalswift,2019-06-15 15:22:54,"@l2a5b1 Did you read the discussion(s) linked in the OP? :-)\n\n* https://github.com/bitcoin/bitcoin/pull/15950#issuecomment-489461791\n* https://stackoverflow.com/questions/29844298/is-it-legal-to-call-memcpy-with-zero-length-on-a-pointer-just-past-the-end-of-an\n",https://github.com/bitcoin/bitcoin/pull/16045#issuecomment-502375384,502375384,
l2a5b1,2019-06-15 17:21:02,"@practicalswift Thanks, yes I did.\n\nFrom https://github.com/bitcoin/bitcoin/pull/15950#issuecomment-489461791\n\n> *p1 |= ((unsigned char)HexDigit(*psz--) << 4);\n\nI agree. Here the behaviour will be undefined when `psz` takes address one before the initial element.\n\nIn case of this pull request, taking a pointer to one past the last element of the `rkey` array is defined as long as t",https://github.com/bitcoin/bitcoin/pull/16045#issuecomment-502384248,502384248,
practicalswift,2019-06-16 20:47:28,"> I do agree that the spec leaves room for interpretation.\n\nIn cases where the spec is unclear I think it makes sense to err on the side of caution. From the OP:\n\n_""Nothing urgent obviously and perhaps not even an issue (the spec is a bit unclear) but would be nice to err on the side of caution in unclear cases like this :-)""_",https://github.com/bitcoin/bitcoin/pull/16045#issuecomment-502484644,502484644,
practicalswift,2019-06-25 12:53:19,@MarcoFalke Four utACK:s - ready for merge?,https://github.com/bitcoin/bitcoin/pull/16045#issuecomment-505430986,505430986,
jamesob,2019-06-26 15:00:37,NACKish lacking benchmarks showing this has any significance. We shouldn't be adding code to `src/crypto` without a more compelling reason.,https://github.com/bitcoin/bitcoin/pull/16045#issuecomment-505914452,505914452,
practicalswift,2019-06-26 15:05:10,@jamesob Benchmarking? This is not an optimisation :-),https://github.com/bitcoin/bitcoin/pull/16045#issuecomment-505916306,505916306,
JosuGZ,2019-06-26 17:30:27,"Although I agree on being conservative, I don't see how this could cause a problem (unless there is already a problem and this fixes it).",https://github.com/bitcoin/bitcoin/pull/16045#issuecomment-505971444,505971444,
laanwj,2019-06-05 13:37:07,"I… don't think this makes the code any more understandable, I had to think for a while to understand why this was `<64` and why one'd want to skip the memset if the data is smaller than that.\nCalling memset with size 0 is no problem. If calling it with a NULL pointer is, then a check for a null pointer should be added, not a check on the length.",https://github.com/bitcoin/bitcoin/pull/16045#discussion_r290741208,290741208,src/crypto/hmac_sha256.cpp
practicalswift,2019-06-05 22:51:56,"Oh, I might have been a bit brief in the OP - let me clarify:\n\nThe goal of this PR is _not_ try to avoid `memset(nullptr, …, …)` (plus: `rkey + keylen` cannot be `nullptr`).\n\nThe goal of the PR is to avoid `memset(p, …, …)` where `p` is a pointer which is outside of the object and thus not valid for writing.\n\nPlease note that `rkey + 64` is outside of the object.\n\nSee these discuss",https://github.com/bitcoin/bitcoin/pull/16045#discussion_r290965541,290965541,src/crypto/hmac_sha256.cpp
