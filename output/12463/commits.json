[
  {
    "sha": "60e0777eda9f2ba0d928de56b4484e53f9150b3c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MGUwNzc3ZWRhOWYyYmEwZDkyOGRlNTZiNDQ4NGU1M2Y5MTUwYjNj",
    "commit": {
      "author": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-02-05T15:06:49Z"
      },
      "committer": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-04-05T16:51:44Z"
      },
      "message": "Drop return argument from CValidationState::Invalid\n\nIt's false in every case.",
      "tree": {
        "sha": "8cd8f803943f8a83058bffb00d36d4dbf425f053",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8cd8f803943f8a83058bffb00d36d4dbf425f053"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/60e0777eda9f2ba0d928de56b4484e53f9150b3c",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE+XLHXoy4Dim7e8hvTYykuhgECQYFAlrGVCAACgkQTYykuhgE\nCQai5hAAoZz/qVA2F7K6VWz6ckRya4emrNzCiDs+WlY4p4MZGUAygx224fiOa4u6\nUxP5QAVSR5+bAkWG4seAud/dPjOx++YPmVvFjNcRj8cT692yqFgFqgne+4rtLsdJ\nhzCEC5IuqUWDvR6XfyCHa6Z78yjLautWE6eHv1w05HcxQKridvAlE+pPq2TIYIhj\nwYEMpI0YJCYhIfZTrJ73QewSRVGRIHmDzaEGIFvHKY5ci3y6IDVXokNO2KDhaNn3\nl1rwQzRiyutKiiYMWmXuYfXwuH2/xevRWXIv+wCgTzPJhHInxmySi2T5I1Jv7MlV\nCc60V9KxwzwyvUEaEILGUIbI2PI9eTaMG+60Dp6iv1UvgKvU8Z6CvtEoca768YwO\ng79SV7n0CrPuQEAwHllBgkdVMqecM4NvKJ/YZzke34ag6NrEid3B6a2DUhasnEiv\nSnQb3M8PyXotdd8kI9FrpVkdzSZ72BWcARkjRyqXxIf+AE7Ir+NUKFaf2hxfikdJ\ne2zFy8cadXcJTrxxA45LUGChqzdAkNAmjugFmBrxH071eJR55Z1iSHigSKhnQ+On\nISvcTzX04vlnfneZAafRTpOCSnB3LN7L1Vb7fWQlXKzJ+V0boHWjMIXv0tPuJg1x\nlhkOxpxBR5GYZQjW3UuV3XM1zXuqTDjzG+HtndaP2E8rSOfXopM=\n=ucMg\n-----END PGP SIGNATURE-----",
        "payload": "tree 8cd8f803943f8a83058bffb00d36d4dbf425f053\nparent c564424d98b1561f16e633528172b3583719e5f3\nauthor Ben Woosley <ben.woosley@gmail.com> 1517843209 -0500\ncommitter Ben Woosley <ben.woosley@gmail.com> 1522947104 -0700\n\nDrop return argument from CValidationState::Invalid\n\nIt's false in every case.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/60e0777eda9f2ba0d928de56b4484e53f9150b3c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/60e0777eda9f2ba0d928de56b4484e53f9150b3c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/60e0777eda9f2ba0d928de56b4484e53f9150b3c/comments",
    "author": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c564424d98b1561f16e633528172b3583719e5f3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c564424d98b1561f16e633528172b3583719e5f3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c564424d98b1561f16e633528172b3583719e5f3"
      }
    ],
    "stats": {
      "total": 43,
      "additions": 21,
      "deletions": 22
    },
    "files": [
      {
        "sha": "b8c48a1d4eadcaafac9b388e266cb271fc183986",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/60e0777eda9f2ba0d928de56b4484e53f9150b3c/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/60e0777eda9f2ba0d928de56b4484e53f9150b3c/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=60e0777eda9f2ba0d928de56b4484e53f9150b3c",
        "patch": "@@ -221,8 +221,7 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n \n         // If prev is coinbase, check that it's matured\n         if (coin.IsCoinBase() && nSpendHeight - coin.nHeight < COINBASE_MATURITY) {\n-            return state.Invalid(false,\n-                REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\",\n+            return state.Invalid(REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\",\n                 strprintf(\"tried to spend coinbase at depth %d\", nSpendHeight - coin.nHeight));\n         }\n "
      },
      {
        "sha": "16a9a5486e93508415744037d2b53d6516ff96ac",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/60e0777eda9f2ba0d928de56b4484e53f9150b3c/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/60e0777eda9f2ba0d928de56b4484e53f9150b3c/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=60e0777eda9f2ba0d928de56b4484e53f9150b3c",
        "patch": "@@ -51,10 +51,9 @@ class CValidationState {\n         mode = MODE_INVALID;\n         return ret;\n     }\n-    bool Invalid(bool ret = false,\n-                 unsigned int _chRejectCode=0, const std::string &_strRejectReason=\"\",\n-                 const std::string &_strDebugMessage=\"\") {\n-        return DoS(0, ret, _chRejectCode, _strRejectReason, false, _strDebugMessage);\n+    bool Invalid(unsigned int _chRejectCode = 0, const std::string& _strRejectReason = \"\", const std::string& _strDebugMessage = \"\")\n+    {\n+        return DoS(0, false, _chRejectCode, _strRejectReason, false, _strDebugMessage);\n     }\n     bool Error(const std::string& strRejectReasonIn) {\n         if (mode == MODE_VALID)"
      },
      {
        "sha": "55ba991a679c1085e7bcf4613ab181c2a1f6095e",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 16,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/60e0777eda9f2ba0d928de56b4484e53f9150b3c/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/60e0777eda9f2ba0d928de56b4484e53f9150b3c/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=60e0777eda9f2ba0d928de56b4484e53f9150b3c",
        "patch": "@@ -352,7 +352,7 @@ bool CheckSequenceLocks(const CTransaction &tx, int flags, LockPoints* lp, bool\n \n     CBlockIndex* tip = chainActive.Tip();\n     assert(tip != nullptr);\n-    \n+\n     CBlockIndex index;\n     index.pprev = tip;\n     // CheckSequenceLocks() uses chainActive.Height()+1 to evaluate\n@@ -579,7 +579,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n     // is it already in the memory pool?\n     if (pool.exists(hash)) {\n-        return state.Invalid(false, REJECT_DUPLICATE, \"txn-already-in-mempool\");\n+        return state.Invalid(REJECT_DUPLICATE, \"txn-already-in-mempool\");\n     }\n \n     // Check for conflicts with in-memory transactions\n@@ -617,7 +617,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     }\n                 }\n                 if (fReplacementOptOut) {\n-                    return state.Invalid(false, REJECT_DUPLICATE, \"txn-mempool-conflict\");\n+                    return state.Invalid(REJECT_DUPLICATE, \"txn-mempool-conflict\");\n                 }\n \n                 setConflicts.insert(ptxConflicting->GetHash());\n@@ -643,7 +643,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 for (size_t out = 0; out < tx.vout.size(); out++) {\n                     // Optimistically just do efficient check of cache for outputs\n                     if (pcoinsTip->HaveCoinInCache(COutPoint(hash, out))) {\n-                        return state.Invalid(false, REJECT_DUPLICATE, \"txn-already-known\");\n+                        return state.Invalid(REJECT_DUPLICATE, \"txn-already-known\");\n                     }\n                 }\n                 // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n@@ -675,7 +675,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n         // Check for non-standard pay-to-script-hash in inputs\n         if (fRequireStandard && !AreInputsStandard(tx, view))\n-            return state.Invalid(false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n+            return state.Invalid(REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n \n         // Check for non-standard witness in P2WSH\n         if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, view))\n@@ -722,8 +722,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         }\n \n         if (nAbsurdFee && nFees > nAbsurdFee)\n-            return state.Invalid(false,\n-                REJECT_HIGHFEE, \"absurdly-high-fee\",\n+            return state.Invalid(REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n         // Calculate in-mempool ancestors, up to a limit.\n@@ -1412,7 +1411,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                         CScriptCheck check2(coin.out, tx, i,\n                                 flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &txdata);\n                         if (check2())\n-                            return state.Invalid(false, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n+                            return state.Invalid(REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n                     }\n                     // Failures of other flags indicate a transaction that is\n                     // invalid in new blocks, e.g. an invalid P2SH. We DoS ban\n@@ -3062,8 +3061,8 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n     // Check transactions\n     for (const auto& tx : block.vtx)\n         if (!CheckTransaction(*tx, state, false))\n-            return state.Invalid(false, state.GetRejectCode(), state.GetRejectReason(),\n-                                 strprintf(\"Transaction check failed (tx hash %s) %s\", tx->GetHash().ToString(), state.GetDebugMessage()));\n+            return state.Invalid(state.GetRejectCode(), state.GetRejectReason(),\n+                strprintf(\"Transaction check failed (tx hash %s) %s\", tx->GetHash().ToString(), state.GetDebugMessage()));\n \n     unsigned int nSigOps = 0;\n     for (const auto& tx : block.vtx)\n@@ -3172,19 +3171,19 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n \n     // Check timestamp against prev\n     if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n-        return state.Invalid(false, REJECT_INVALID, \"time-too-old\", \"block's timestamp is too early\");\n+        return state.Invalid(REJECT_INVALID, \"time-too-old\", \"block's timestamp is too early\");\n \n     // Check timestamp\n     if (block.GetBlockTime() > nAdjustedTime + MAX_FUTURE_BLOCK_TIME)\n-        return state.Invalid(false, REJECT_INVALID, \"time-too-new\", \"block timestamp too far in the future\");\n+        return state.Invalid(REJECT_INVALID, \"time-too-new\", \"block timestamp too far in the future\");\n \n     // Reject outdated version blocks when 95% (75% on testnet) of the network has upgraded:\n     // check for version 2, 3 and 4 upgrades\n     if((block.nVersion < 2 && nHeight >= consensusParams.BIP34Height) ||\n        (block.nVersion < 3 && nHeight >= consensusParams.BIP66Height) ||\n        (block.nVersion < 4 && nHeight >= consensusParams.BIP65Height))\n-            return state.Invalid(false, REJECT_OBSOLETE, strprintf(\"bad-version(0x%08x)\", block.nVersion),\n-                                 strprintf(\"rejected nVersion=0x%08x block\", block.nVersion));\n+        return state.Invalid(REJECT_OBSOLETE, strprintf(\"bad-version(0x%08x)\", block.nVersion),\n+            strprintf(\"rejected nVersion=0x%08x block\", block.nVersion));\n \n     return true;\n }\n@@ -3289,8 +3288,10 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n             pindex = miSelf->second;\n             if (ppindex)\n                 *ppindex = pindex;\n-            if (pindex->nStatus & BLOCK_FAILED_MASK)\n-                return state.Invalid(error(\"%s: block %s is marked invalid\", __func__, hash.ToString()), 0, \"duplicate\");\n+            if (pindex->nStatus & BLOCK_FAILED_MASK) {\n+                error(\"%s: block %s is marked invalid\", __func__, hash.ToString());\n+                return state.Invalid(0, \"duplicate\");\n+            }\n             return true;\n         }\n "
      }
    ]
  },
  {
    "sha": "8f3a5ae31deec2ddee4021fcc3c4bce5d963db6d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4ZjNhNWFlMzFkZWVjMmRkZWU0MDIxZmNjM2M0YmNlNWQ5NjNkYjZk",
    "commit": {
      "author": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-02-05T15:18:34Z"
      },
      "committer": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-04-05T16:51:56Z"
      },
      "message": "Drop return argument from CValidationState::DoS\n\nIt was always false. Note error() always returns false.",
      "tree": {
        "sha": "80fc77e161f3caf99e6bf7d8fd3d7bf2a8ce5c0c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/80fc77e161f3caf99e6bf7d8fd3d7bf2a8ce5c0c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8f3a5ae31deec2ddee4021fcc3c4bce5d963db6d",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE+XLHXoy4Dim7e8hvTYykuhgECQYFAlrGVCwACgkQTYykuhgE\nCQZbcg/9GTT/Q6JIue20cwygbPCpZ+nQM/pyXvftjgWeUy1fopUUrHjrS8vYzlES\nNYZBmDvOnNxeyTkwIa6pW8yJ6gmBBbsS09pAD6M3a8yvlwQPe13XGBxTIdjzg2RN\n3L8rso4e49nOuA6rQHzU6nBT6KfFxerVxzeEEygYwdqqNMSbR2+AKQs+p5WkDQ3l\nE7Kb5HJF9HjmsqAt951La0FUVsrHnSVbitd064oYMMLp9z69oIWMEreGMRqdntsO\nx7PLfpm3oROhSDw1UUbENdhsuUXvcGRDy+On44a7ORJGaNIyWzEcxrQ8umVsjgBJ\nSUD5C8qIk8Vxy/vrwtZknX5EPBv8vObK4uHc2GN2rU3jnZSgeDbZ/7b2qexSPoWU\nCMcfWXe8RjHgMdN9wEB8dOXQwQlLt/1aiFnCAdxm4FQSkGj0j+DT9JrDU4OB7lPc\nP+lt9LqdR3OxCfhYsnHtKGI2pLcEFAujz05zj9MEMqw473xwDzMHj+0t8tWadBcn\nTn8g6U5bhoWTb8+dxTZwQ8Rp3Joxn1pSeHd0pgiDtAIyvDM5qFzansRnRqdqECnb\njrQhixhtudoK4tpkvu3WPrA1apK/TCtmGu0oEUqUNA8BCbGIb7iC2UZ7tpIUx4sV\n7TPzyS2pvWA0+Vx2oQyv41mQsq5ZWbAryms+pfa1pVs2RKpul3I=\n=nbfW\n-----END PGP SIGNATURE-----",
        "payload": "tree 80fc77e161f3caf99e6bf7d8fd3d7bf2a8ce5c0c\nparent 60e0777eda9f2ba0d928de56b4484e53f9150b3c\nauthor Ben Woosley <ben.woosley@gmail.com> 1517843914 -0500\ncommitter Ben Woosley <ben.woosley@gmail.com> 1522947116 -0700\n\nDrop return argument from CValidationState::DoS\n\nIt was always false. Note error() always returns false.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8f3a5ae31deec2ddee4021fcc3c4bce5d963db6d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8f3a5ae31deec2ddee4021fcc3c4bce5d963db6d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8f3a5ae31deec2ddee4021fcc3c4bce5d963db6d/comments",
    "author": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "60e0777eda9f2ba0d928de56b4484e53f9150b3c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/60e0777eda9f2ba0d928de56b4484e53f9150b3c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/60e0777eda9f2ba0d928de56b4484e53f9150b3c"
      }
    ],
    "stats": {
      "total": 206,
      "additions": 104,
      "deletions": 102
    },
    "files": [
      {
        "sha": "afb763efcfcb48f97889808d97082b72561c8666",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f3a5ae31deec2ddee4021fcc3c4bce5d963db6d/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f3a5ae31deec2ddee4021fcc3c4bce5d963db6d/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=8f3a5ae31deec2ddee4021fcc3c4bce5d963db6d",
        "patch": "@@ -160,24 +160,24 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n {\n     // Basic checks that don't depend on any context\n     if (tx.vin.empty())\n-        return state.DoS(10, false, REJECT_INVALID, \"bad-txns-vin-empty\");\n+        return state.DoS(10, REJECT_INVALID, \"bad-txns-vin-empty\");\n     if (tx.vout.empty())\n-        return state.DoS(10, false, REJECT_INVALID, \"bad-txns-vout-empty\");\n+        return state.DoS(10, REJECT_INVALID, \"bad-txns-vout-empty\");\n     // Size limits (this doesn't take the witness into account, as that hasn't been checked for malleability)\n     if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-oversize\");\n+        return state.DoS(100, REJECT_INVALID, \"bad-txns-oversize\");\n \n     // Check for negative or overflow output values\n     CAmount nValueOut = 0;\n     for (const auto& txout : tx.vout)\n     {\n         if (txout.nValue < 0)\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-vout-negative\");\n+            return state.DoS(100, REJECT_INVALID, \"bad-txns-vout-negative\");\n         if (txout.nValue > MAX_MONEY)\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-vout-toolarge\");\n+            return state.DoS(100, REJECT_INVALID, \"bad-txns-vout-toolarge\");\n         nValueOut += txout.nValue;\n         if (!MoneyRange(nValueOut))\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-txouttotal-toolarge\");\n+            return state.DoS(100, REJECT_INVALID, \"bad-txns-txouttotal-toolarge\");\n     }\n \n     // Check for duplicate inputs - note that this check is slow so we skip it in CheckBlock\n@@ -186,20 +186,20 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n         for (const auto& txin : tx.vin)\n         {\n             if (!vInOutPoints.insert(txin.prevout).second)\n-                return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n+                return state.DoS(100, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n         }\n     }\n \n     if (tx.IsCoinBase())\n     {\n         if (tx.vin[0].scriptSig.size() < 2 || tx.vin[0].scriptSig.size() > 100)\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-cb-length\");\n+            return state.DoS(100, REJECT_INVALID, \"bad-cb-length\");\n     }\n     else\n     {\n         for (const auto& txin : tx.vin)\n             if (txin.prevout.IsNull())\n-                return state.DoS(10, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n+                return state.DoS(10, REJECT_INVALID, \"bad-txns-prevout-null\");\n     }\n \n     return true;\n@@ -209,8 +209,8 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n {\n     // are the actual inputs available?\n     if (!inputs.HaveInputs(tx)) {\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-missingorspent\", false,\n-                         strprintf(\"%s: inputs missing/spent\", __func__));\n+        return state.DoS(100, REJECT_INVALID, \"bad-txns-inputs-missingorspent\", false,\n+            strprintf(\"%s: inputs missing/spent\", __func__));\n     }\n \n     CAmount nValueIn = 0;\n@@ -228,20 +228,20 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n         // Check for negative or overflow input values\n         nValueIn += coin.out.nValue;\n         if (!MoneyRange(coin.out.nValue) || !MoneyRange(nValueIn)) {\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputvalues-outofrange\");\n+            return state.DoS(100, REJECT_INVALID, \"bad-txns-inputvalues-outofrange\");\n         }\n     }\n \n     const CAmount value_out = tx.GetValueOut();\n     if (nValueIn < value_out) {\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-in-belowout\", false,\n+        return state.DoS(100, REJECT_INVALID, \"bad-txns-in-belowout\", false,\n             strprintf(\"value in (%s) < value out (%s)\", FormatMoney(nValueIn), FormatMoney(value_out)));\n     }\n \n     // Tally transaction fees\n     const CAmount txfee_aux = nValueIn - value_out;\n     if (!MoneyRange(txfee_aux)) {\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-fee-outofrange\");\n+        return state.DoS(100, REJECT_INVALID, \"bad-txns-fee-outofrange\");\n     }\n \n     txfee = txfee_aux;"
      },
      {
        "sha": "4dc63209118e5677c71a15ee4d8c9fc29a2359a0",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 5,
        "deletions": 7,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f3a5ae31deec2ddee4021fcc3c4bce5d963db6d/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f3a5ae31deec2ddee4021fcc3c4bce5d963db6d/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=8f3a5ae31deec2ddee4021fcc3c4bce5d963db6d",
        "patch": "@@ -37,23 +37,21 @@ class CValidationState {\n     std::string strDebugMessage;\n public:\n     CValidationState() : mode(MODE_VALID), nDoS(0), chRejectCode(0), corruptionPossible(false) {}\n-    bool DoS(int level, bool ret = false,\n-             unsigned int chRejectCodeIn=0, const std::string &strRejectReasonIn=\"\",\n-             bool corruptionIn=false,\n-             const std::string &strDebugMessageIn=\"\") {\n+    bool DoS(int level, unsigned int chRejectCodeIn = 0, const std::string& strRejectReasonIn = \"\", bool corruptionIn = false, const std::string& strDebugMessageIn = \"\")\n+    {\n         chRejectCode = chRejectCodeIn;\n         strRejectReason = strRejectReasonIn;\n         corruptionPossible = corruptionIn;\n         strDebugMessage = strDebugMessageIn;\n         if (mode == MODE_ERROR)\n-            return ret;\n+            return false;\n         nDoS += level;\n         mode = MODE_INVALID;\n-        return ret;\n+        return false;\n     }\n     bool Invalid(unsigned int _chRejectCode = 0, const std::string& _strRejectReason = \"\", const std::string& _strDebugMessage = \"\")\n     {\n-        return DoS(0, false, _chRejectCode, _strRejectReason, false, _strDebugMessage);\n+        return DoS(0, _chRejectCode, _strRejectReason, false, _strDebugMessage);\n     }\n     bool Error(const std::string& strRejectReasonIn) {\n         if (mode == MODE_VALID)"
      },
      {
        "sha": "930846f64c6b1a2f6833f8687211d18da10222de",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 85,
        "deletions": 81,
        "changes": 166,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f3a5ae31deec2ddee4021fcc3c4bce5d963db6d/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f3a5ae31deec2ddee4021fcc3c4bce5d963db6d/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=8f3a5ae31deec2ddee4021fcc3c4bce5d963db6d",
        "patch": "@@ -558,24 +558,24 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n     // Coinbase is only valid in a block, not as a loose transaction\n     if (tx.IsCoinBase())\n-        return state.DoS(100, false, REJECT_INVALID, \"coinbase\");\n+        return state.DoS(100, REJECT_INVALID, \"coinbase\");\n \n     // Reject transactions with witness before segregated witness activates (override with -prematurewitness)\n     bool witnessEnabled = IsWitnessEnabled(chainActive.Tip(), chainparams.GetConsensus());\n     if (!gArgs.GetBoolArg(\"-prematurewitness\", false) && tx.HasWitness() && !witnessEnabled) {\n-        return state.DoS(0, false, REJECT_NONSTANDARD, \"no-witness-yet\", true);\n+        return state.DoS(0, REJECT_NONSTANDARD, \"no-witness-yet\", true);\n     }\n \n     // Rather not work on nonstandard transactions (unless -testnet/-regtest)\n     std::string reason;\n     if (fRequireStandard && !IsStandardTx(tx, reason, witnessEnabled))\n-        return state.DoS(0, false, REJECT_NONSTANDARD, reason);\n+        return state.DoS(0, REJECT_NONSTANDARD, reason);\n \n     // Only accept nLockTime-using transactions that can be mined in the next\n     // block; we don't want our mempool filled up with transactions that can't\n     // be mined yet.\n     if (!CheckFinalTx(tx, STANDARD_LOCKTIME_VERIFY_FLAGS))\n-        return state.DoS(0, false, REJECT_NONSTANDARD, \"non-final\");\n+        return state.DoS(0, REJECT_NONSTANDARD, \"non-final\");\n \n     // is it already in the memory pool?\n     if (pool.exists(hash)) {\n@@ -666,7 +666,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n         // CoinsViewCache instead of create its own\n         if (!CheckSequenceLocks(tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n-            return state.DoS(0, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n+            return state.DoS(0, REJECT_NONSTANDARD, \"non-BIP68-final\");\n \n         CAmount nFees = 0;\n         if (!Consensus::CheckTxInputs(tx, state, view, GetSpendHeight(view), nFees)) {\n@@ -679,7 +679,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n         // Check for non-standard witness in P2WSH\n         if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, view))\n-            return state.DoS(0, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\", true);\n+            return state.DoS(0, REJECT_NONSTANDARD, \"bad-witness-nonstandard\", true);\n \n         int64_t nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);\n \n@@ -708,17 +708,17 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         // MAX_BLOCK_SIGOPS; we still consider this an invalid rather than\n         // merely non-standard transaction.\n         if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)\n-            return state.DoS(0, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\", false,\n+            return state.DoS(0, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\", false,\n                 strprintf(\"%d\", nSigOpsCost));\n \n         CAmount mempoolRejectFee = pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(nSize);\n         if (!bypass_limits && mempoolRejectFee > 0 && nModifiedFees < mempoolRejectFee) {\n-            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", false, strprintf(\"%d < %d\", nModifiedFees, mempoolRejectFee));\n+            return state.DoS(0, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", false, strprintf(\"%d < %d\", nModifiedFees, mempoolRejectFee));\n         }\n \n         // No transactions are allowed below minRelayTxFee except from disconnected blocks\n         if (!bypass_limits && nModifiedFees < ::minRelayTxFee.GetFee(nSize)) {\n-            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"min relay fee not met\");\n+            return state.DoS(0, REJECT_INSUFFICIENTFEE, \"min relay fee not met\");\n         }\n \n         if (nAbsurdFee && nFees > nAbsurdFee)\n@@ -733,7 +733,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n         std::string errString;\n         if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n-            return state.DoS(0, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", false, errString);\n+            return state.DoS(0, REJECT_NONSTANDARD, \"too-long-mempool-chain\", false, errString);\n         }\n \n         // A transaction that spends outputs that would be replaced by it is invalid. Now\n@@ -745,11 +745,10 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n             if (setConflicts.count(hashAncestor))\n             {\n-                return state.DoS(10, false,\n-                                 REJECT_INVALID, \"bad-txns-spends-conflicting-tx\", false,\n-                                 strprintf(\"%s spends conflicting transaction %s\",\n-                                           hash.ToString(),\n-                                           hashAncestor.ToString()));\n+                return state.DoS(10, REJECT_INVALID, \"bad-txns-spends-conflicting-tx\", false,\n+                    strprintf(\"%s spends conflicting transaction %s\",\n+                        hash.ToString(),\n+                        hashAncestor.ToString()));\n             }\n         }\n \n@@ -798,12 +797,11 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n                 if (newFeeRate <= oldFeeRate)\n                 {\n-                    return state.DoS(0, false,\n-                            REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n-                            strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n-                                  hash.ToString(),\n-                                  newFeeRate.ToString(),\n-                                  oldFeeRate.ToString()));\n+                    return state.DoS(0, REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                        strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n+                            hash.ToString(),\n+                            newFeeRate.ToString(),\n+                            oldFeeRate.ToString()));\n                 }\n \n                 for (const CTxIn &txin : mi->GetTx().vin)\n@@ -827,12 +825,11 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     nConflictingSize += it->GetTxSize();\n                 }\n             } else {\n-                return state.DoS(0, false,\n-                        REJECT_NONSTANDARD, \"too many potential replacements\", false,\n-                        strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n-                            hash.ToString(),\n-                            nConflictingCount,\n-                            maxDescendantsToVisit));\n+                return state.DoS(0, REJECT_NONSTANDARD, \"too many potential replacements\", false,\n+                    strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n+                        hash.ToString(),\n+                        nConflictingCount,\n+                        maxDescendantsToVisit));\n             }\n \n             for (unsigned int j = 0; j < tx.vin.size(); j++)\n@@ -847,10 +844,9 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     // it's cheaper to just check if the new input refers to a\n                     // tx that's in the mempool.\n                     if (pool.mapTx.find(tx.vin[j].prevout.hash) != pool.mapTx.end())\n-                        return state.DoS(0, false,\n-                                         REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\", false,\n-                                         strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n-                                                  hash.ToString(), j));\n+                        return state.DoS(0, REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\", false,\n+                            strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n+                                hash.ToString(), j));\n                 }\n             }\n \n@@ -859,23 +855,21 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             // transactions would not be paid for.\n             if (nModifiedFees < nConflictingFees)\n             {\n-                return state.DoS(0, false,\n-                                 REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n-                                 strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n-                                          hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)));\n+                return state.DoS(0, REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                    strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n+                        hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)));\n             }\n \n             // Finally in addition to paying more fees than the conflicts the\n             // new transaction must pay for its own bandwidth.\n             CAmount nDeltaFees = nModifiedFees - nConflictingFees;\n             if (nDeltaFees < ::incrementalRelayFee.GetFee(nSize))\n             {\n-                return state.DoS(0, false,\n-                        REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n-                        strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n-                              hash.ToString(),\n-                              FormatMoney(nDeltaFees),\n-                              FormatMoney(::incrementalRelayFee.GetFee(nSize))));\n+                return state.DoS(0, REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                    strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n+                        hash.ToString(),\n+                        FormatMoney(nDeltaFees),\n+                        FormatMoney(::incrementalRelayFee.GetFee(nSize))));\n             }\n         }\n \n@@ -966,7 +960,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         if (!bypass_limits) {\n             LimitMempoolSize(pool, gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, gArgs.GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n             if (!pool.exists(hash))\n-                return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full\");\n+                return state.DoS(0, REJECT_INSUFFICIENTFEE, \"mempool full\");\n         }\n     }\n \n@@ -1420,7 +1414,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                     // as to the correct behavior - we may want to continue\n                     // peering with non-upgraded nodes even after soft-fork\n                     // super-majority signaling has occurred.\n-                    return state.DoS(100,false, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n+                    return state.DoS(100, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n                 }\n             }\n \n@@ -1922,8 +1916,8 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n         for (const auto& tx : block.vtx) {\n             for (size_t o = 0; o < tx->vout.size(); o++) {\n                 if (view.HaveCoin(COutPoint(tx->GetHash(), o))) {\n-                    return state.DoS(100, error(\"ConnectBlock(): tried to overwrite transaction\"),\n-                                     REJECT_INVALID, \"bad-txns-BIP30\");\n+                    error(\"ConnectBlock(): tried to overwrite transaction\");\n+                    return state.DoS(100, REJECT_INVALID, \"bad-txns-BIP30\");\n                 }\n             }\n         }\n@@ -1966,8 +1960,8 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n             }\n             nFees += txfee;\n             if (!MoneyRange(nFees)) {\n-                return state.DoS(100, error(\"%s: accumulated fee in the block out of range.\", __func__),\n-                                 REJECT_INVALID, \"bad-txns-accumulated-fee-outofrange\");\n+                error(\"%s: accumulated fee in the block out of range.\", __func__);\n+                return state.DoS(100, REJECT_INVALID, \"bad-txns-accumulated-fee-outofrange\");\n             }\n \n             // Check that transaction is BIP68 final\n@@ -1979,8 +1973,8 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n             }\n \n             if (!SequenceLocks(tx, nLockTimeFlags, &prevheights, *pindex)) {\n-                return state.DoS(100, error(\"%s: contains a non-BIP68-final transaction\", __func__),\n-                                 REJECT_INVALID, \"bad-txns-nonfinal\");\n+                error(\"%s: contains a non-BIP68-final transaction\", __func__);\n+                return state.DoS(100, REJECT_INVALID, \"bad-txns-nonfinal\");\n             }\n         }\n \n@@ -1989,9 +1983,10 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n         // * p2sh (when P2SH enabled in flags and excludes coinbase)\n         // * witness (when witness enabled in flags and excludes coinbase)\n         nSigOpsCost += GetTransactionSigOpCost(tx, view, flags);\n-        if (nSigOpsCost > MAX_BLOCK_SIGOPS_COST)\n-            return state.DoS(100, error(\"ConnectBlock(): too many sigops\"),\n-                             REJECT_INVALID, \"bad-blk-sigops\");\n+        if (nSigOpsCost > MAX_BLOCK_SIGOPS_COST) {\n+            error(\"ConnectBlock(): too many sigops\");\n+            return state.DoS(100, REJECT_INVALID, \"bad-blk-sigops\");\n+        }\n \n         txdata.emplace_back(tx);\n         if (!tx.IsCoinBase())\n@@ -2014,14 +2009,16 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n     LogPrint(BCLog::BENCH, \"      - Connect %u transactions: %.2fms (%.3fms/tx, %.3fms/txin) [%.2fs (%.2fms/blk)]\\n\", (unsigned)block.vtx.size(), MILLI * (nTime3 - nTime2), MILLI * (nTime3 - nTime2) / block.vtx.size(), nInputs <= 1 ? 0 : MILLI * (nTime3 - nTime2) / (nInputs-1), nTimeConnect * MICRO, nTimeConnect * MILLI / nBlocksTotal);\n \n     CAmount blockReward = nFees + GetBlockSubsidy(pindex->nHeight, chainparams.GetConsensus());\n-    if (block.vtx[0]->GetValueOut() > blockReward)\n-        return state.DoS(100,\n-                         error(\"ConnectBlock(): coinbase pays too much (actual=%d vs limit=%d)\",\n-                               block.vtx[0]->GetValueOut(), blockReward),\n-                               REJECT_INVALID, \"bad-cb-amount\");\n-\n-    if (!control.Wait())\n-        return state.DoS(100, error(\"%s: CheckQueue failed\", __func__), REJECT_INVALID, \"block-validation-failed\");\n+    if (block.vtx[0]->GetValueOut() > blockReward) {\n+        error(\"ConnectBlock(): coinbase pays too much (actual=%d vs limit=%d)\",\n+            block.vtx[0]->GetValueOut(), blockReward);\n+        return state.DoS(100, REJECT_INVALID, \"bad-cb-amount\");\n+    }\n+\n+    if (!control.Wait()) {\n+        error(\"%s: CheckQueue failed\", __func__);\n+        return state.DoS(100, REJECT_INVALID, \"block-validation-failed\");\n+    }\n     int64_t nTime4 = GetTimeMicros(); nTimeVerify += nTime4 - nTime2;\n     LogPrint(BCLog::BENCH, \"    - Verify %u txins: %.2fms (%.3fms/txin) [%.2fs (%.2fms/blk)]\\n\", nInputs - 1, MILLI * (nTime4 - nTime2), nInputs <= 1 ? 0 : MILLI * (nTime4 - nTime2) / (nInputs-1), nTimeVerify * MICRO, nTimeVerify * MILLI / nBlocksTotal);\n \n@@ -3010,7 +3007,7 @@ static bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state,\n {\n     // Check proof of work matches claimed amount\n     if (fCheckPOW && !CheckProofOfWork(block.GetHash(), block.nBits, consensusParams))\n-        return state.DoS(50, false, REJECT_INVALID, \"high-hash\", false, \"proof of work failed\");\n+        return state.DoS(50, REJECT_INVALID, \"high-hash\", false, \"proof of work failed\");\n \n     return true;\n }\n@@ -3032,13 +3029,13 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n         bool mutated;\n         uint256 hashMerkleRoot2 = BlockMerkleRoot(block, &mutated);\n         if (block.hashMerkleRoot != hashMerkleRoot2)\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txnmrklroot\", true, \"hashMerkleRoot mismatch\");\n+            return state.DoS(100, REJECT_INVALID, \"bad-txnmrklroot\", true, \"hashMerkleRoot mismatch\");\n \n         // Check for merkle tree malleability (CVE-2012-2459): repeating sequences\n         // of transactions in a block without affecting the merkle root of a block,\n         // while still invalidating it.\n         if (mutated)\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-duplicate\", true, \"duplicate transaction\");\n+            return state.DoS(100, REJECT_INVALID, \"bad-txns-duplicate\", true, \"duplicate transaction\");\n     }\n \n     // All potential-corruption validation must be done before we do any\n@@ -3049,14 +3046,14 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n \n     // Size limits\n     if (block.vtx.empty() || block.vtx.size() * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-blk-length\", false, \"size limits failed\");\n+        return state.DoS(100, REJECT_INVALID, \"bad-blk-length\", false, \"size limits failed\");\n \n     // First transaction must be coinbase, the rest must not be\n     if (block.vtx.empty() || !block.vtx[0]->IsCoinBase())\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-cb-missing\", false, \"first tx is not coinbase\");\n+        return state.DoS(100, REJECT_INVALID, \"bad-cb-missing\", false, \"first tx is not coinbase\");\n     for (unsigned int i = 1; i < block.vtx.size(); i++)\n         if (block.vtx[i]->IsCoinBase())\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-cb-multiple\", false, \"more than one coinbase\");\n+            return state.DoS(100, REJECT_INVALID, \"bad-cb-multiple\", false, \"more than one coinbase\");\n \n     // Check transactions\n     for (const auto& tx : block.vtx)\n@@ -3070,7 +3067,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n         nSigOps += GetLegacySigOpCount(*tx);\n     }\n     if (nSigOps * WITNESS_SCALE_FACTOR > MAX_BLOCK_SIGOPS_COST)\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-blk-sigops\", false, \"out-of-bounds SigOpCount\");\n+        return state.DoS(100, REJECT_INVALID, \"bad-blk-sigops\", false, \"out-of-bounds SigOpCount\");\n \n     if (fCheckPOW && fCheckMerkleRoot)\n         block.fChecked = true;\n@@ -3157,16 +3154,18 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n     // Check proof of work\n     const Consensus::Params& consensusParams = params.GetConsensus();\n     if (block.nBits != GetNextWorkRequired(pindexPrev, &block, consensusParams))\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-diffbits\", false, \"incorrect proof of work\");\n+        return state.DoS(100, REJECT_INVALID, \"bad-diffbits\", false, \"incorrect proof of work\");\n \n     // Check against checkpoints\n     if (fCheckpointsEnabled) {\n         // Don't accept any forks from the main chain prior to last checkpoint.\n         // GetLastCheckpoint finds the last checkpoint in MapCheckpoints that's in our\n         // MapBlockIndex.\n         CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(params.Checkpoints());\n-        if (pcheckpoint && nHeight < pcheckpoint->nHeight)\n-            return state.DoS(100, error(\"%s: forked chain older than last checkpoint (height %d)\", __func__, nHeight), REJECT_CHECKPOINT, \"bad-fork-prior-to-checkpoint\");\n+        if (pcheckpoint && nHeight < pcheckpoint->nHeight) {\n+            error(\"%s: forked chain older than last checkpoint (height %d)\", __func__, nHeight);\n+            return state.DoS(100, REJECT_CHECKPOINT, \"bad-fork-prior-to-checkpoint\");\n+        }\n     }\n \n     // Check timestamp against prev\n@@ -3211,7 +3210,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     // Check that all transactions are finalized\n     for (const auto& tx : block.vtx) {\n         if (!IsFinalTx(*tx, nHeight, nLockTimeCutoff)) {\n-            return state.DoS(10, false, REJECT_INVALID, \"bad-txns-nonfinal\", false, \"non-final transaction\");\n+            return state.DoS(10, REJECT_INVALID, \"bad-txns-nonfinal\", false, \"non-final transaction\");\n         }\n     }\n \n@@ -3221,7 +3220,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n         CScript expect = CScript() << nHeight;\n         if (block.vtx[0]->vin[0].scriptSig.size() < expect.size() ||\n             !std::equal(expect.begin(), expect.end(), block.vtx[0]->vin[0].scriptSig.begin())) {\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-cb-height\", false, \"block height mismatch in coinbase\");\n+            return state.DoS(100, REJECT_INVALID, \"bad-cb-height\", false, \"block height mismatch in coinbase\");\n         }\n     }\n \n@@ -3243,11 +3242,11 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n             // already does not permit it, it is impossible to trigger in the\n             // witness tree.\n             if (block.vtx[0]->vin[0].scriptWitness.stack.size() != 1 || block.vtx[0]->vin[0].scriptWitness.stack[0].size() != 32) {\n-                return state.DoS(100, false, REJECT_INVALID, \"bad-witness-nonce-size\", true, strprintf(\"%s : invalid witness reserved value size\", __func__));\n+                return state.DoS(100, REJECT_INVALID, \"bad-witness-nonce-size\", true, strprintf(\"%s : invalid witness reserved value size\", __func__));\n             }\n             CHash256().Write(hashWitness.begin(), 32).Write(&block.vtx[0]->vin[0].scriptWitness.stack[0][0], 32).Finalize(hashWitness.begin());\n             if (memcmp(hashWitness.begin(), &block.vtx[0]->vout[commitpos].scriptPubKey[6], 32)) {\n-                return state.DoS(100, false, REJECT_INVALID, \"bad-witness-merkle-match\", true, strprintf(\"%s : witness merkle commitment mismatch\", __func__));\n+                return state.DoS(100, REJECT_INVALID, \"bad-witness-merkle-match\", true, strprintf(\"%s : witness merkle commitment mismatch\", __func__));\n             }\n             fHaveWitness = true;\n         }\n@@ -3257,7 +3256,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     if (!fHaveWitness) {\n       for (const auto& tx : block.vtx) {\n             if (tx->HasWitness()) {\n-                return state.DoS(100, false, REJECT_INVALID, \"unexpected-witness\", true, strprintf(\"%s : unexpected witness data found\", __func__));\n+                return state.DoS(100, REJECT_INVALID, \"unexpected-witness\", true, strprintf(\"%s : unexpected witness data found\", __func__));\n             }\n         }\n     }\n@@ -3269,7 +3268,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     // the block hash, so we couldn't mark the block as permanently\n     // failed).\n     if (GetBlockWeight(block) > MAX_BLOCK_WEIGHT) {\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-blk-weight\", false, strprintf(\"%s : weight limit failed\", __func__));\n+        return state.DoS(100, REJECT_INVALID, \"bad-blk-weight\", false, strprintf(\"%s : weight limit failed\", __func__));\n     }\n \n     return true;\n@@ -3301,11 +3300,15 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n         // Get prev block index\n         CBlockIndex* pindexPrev = nullptr;\n         BlockMap::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\n-        if (mi == mapBlockIndex.end())\n-            return state.DoS(10, error(\"%s: prev block not found\", __func__), 0, \"prev-blk-not-found\");\n+        if (mi == mapBlockIndex.end()) {\n+            error(\"%s: prev block not found\", __func__);\n+            return state.DoS(10, 0, \"prev-blk-not-found\");\n+        }\n         pindexPrev = (*mi).second;\n-        if (pindexPrev->nStatus & BLOCK_FAILED_MASK)\n-            return state.DoS(100, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n+        if (pindexPrev->nStatus & BLOCK_FAILED_MASK) {\n+            error(\"%s: prev block invalid\", __func__);\n+            return state.DoS(100, REJECT_INVALID, \"bad-prevblk\");\n+        }\n         if (!ContextualCheckBlockHeader(block, state, chainparams, pindexPrev, GetAdjustedTime()))\n             return error(\"%s: Consensus::ContextualCheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));\n \n@@ -3319,7 +3322,8 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n                         setDirtyBlockIndex.insert(invalid_walk);\n                         invalid_walk = invalid_walk->pprev;\n                     }\n-                    return state.DoS(100, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n+                    error(\"%s: prev block invalid\", __func__);\n+                    return state.DoS(100, REJECT_INVALID, \"bad-prevblk\");\n                 }\n             }\n         }"
      }
    ]
  },
  {
    "sha": "f3cd4e6583711ad9a4b21d02e8228582000537d3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmM2NkNGU2NTgzNzExYWQ5YTRiMjFkMDJlODIyODU4MjAwMDUzN2Qz",
    "commit": {
      "author": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-04-04T00:25:26Z"
      },
      "committer": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-04-05T16:51:56Z"
      },
      "message": "Drop unused default arguments to CValidationState::DoS and ::Invalid",
      "tree": {
        "sha": "19e50b840995746757588906d5aec4e15029049f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/19e50b840995746757588906d5aec4e15029049f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f3cd4e6583711ad9a4b21d02e8228582000537d3",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE+XLHXoy4Dim7e8hvTYykuhgECQYFAlrGVCwACgkQTYykuhgE\nCQYPmg/+PKbU2LTaFYuUEYwE7vldkivwFy/aCPM4a7l8XO+GZu5ypQZHlD21k5db\nRz7VvHfTJKEOR6no0kWepBkCafHKPP5EJCoog5FE5DNd0jzpmLAe4lkAEFUQrSfc\nIaD0rKa7aKCjo/l8DNrPWfALkBpBpobDU+KhMf8WJ37TRn32iHdYbGD1yZCg0gyk\nvn7EyF3rZglb3hudUbvcH6tCms97XlYQdBmIHapprrQeQPj8+gOuGSJ8CnUuwu9l\nuq78fi4KuSWD04c6dmQpEEb9dGCItSse7l5KJ8YdFN2BNw01gxdoe6/IdUPhlRhv\nIyl2RQVbp97E+YRm0Oiwpf6BBTIzv/XxAHMhT0KN1lra6RA3NlK0x28WvryLvnHL\n6GRKi6Z0YjnOFmHIa9kSMjK+Bc3l9WTCN9nZw65oGAsC2c6XekuiQ9UbXtGO2KiP\nKr0ligugK70m5/lxRwA6CB0Ha5wkPa+zR/NYbeS4rKbiJl0bsT4HfEKkXtK60uhU\n/HKkz5ZUIy/nnv3qQeRGoiOU4jtKXbqLkk6MBk/b4+a84FE7GC0sJjmNDnrB/mi0\nAHfCHvL+oIb5Om/fjTZBcJSfLy3Fav+89Vc0rCThHItYNM8S2M0vi69+m1tVlP9J\nDwttnDLLMWO+26cNWB0/FukEOTyvXJ1Ta7iS3adkuOrozYQUDgA=\n=Q0/e\n-----END PGP SIGNATURE-----",
        "payload": "tree 19e50b840995746757588906d5aec4e15029049f\nparent 8f3a5ae31deec2ddee4021fcc3c4bce5d963db6d\nauthor Ben Woosley <ben.woosley@gmail.com> 1522801526 -0700\ncommitter Ben Woosley <ben.woosley@gmail.com> 1522947116 -0700\n\nDrop unused default arguments to CValidationState::DoS and ::Invalid\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f3cd4e6583711ad9a4b21d02e8228582000537d3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f3cd4e6583711ad9a4b21d02e8228582000537d3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f3cd4e6583711ad9a4b21d02e8228582000537d3/comments",
    "author": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8f3a5ae31deec2ddee4021fcc3c4bce5d963db6d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8f3a5ae31deec2ddee4021fcc3c4bce5d963db6d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8f3a5ae31deec2ddee4021fcc3c4bce5d963db6d"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 2,
      "deletions": 2
    },
    "files": [
      {
        "sha": "8b9dd7febf4412b3e5a04759d217e2e8042fcead",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f3cd4e6583711ad9a4b21d02e8228582000537d3/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f3cd4e6583711ad9a4b21d02e8228582000537d3/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=f3cd4e6583711ad9a4b21d02e8228582000537d3",
        "patch": "@@ -37,7 +37,7 @@ class CValidationState {\n     std::string strDebugMessage;\n public:\n     CValidationState() : mode(MODE_VALID), nDoS(0), chRejectCode(0), corruptionPossible(false) {}\n-    bool DoS(int level, unsigned int chRejectCodeIn = 0, const std::string& strRejectReasonIn = \"\", bool corruptionIn = false, const std::string& strDebugMessageIn = \"\")\n+    bool DoS(int level, unsigned int chRejectCodeIn, const std::string& strRejectReasonIn, bool corruptionIn = false, const std::string& strDebugMessageIn = \"\")\n     {\n         chRejectCode = chRejectCodeIn;\n         strRejectReason = strRejectReasonIn;\n@@ -49,7 +49,7 @@ class CValidationState {\n         mode = MODE_INVALID;\n         return false;\n     }\n-    bool Invalid(unsigned int _chRejectCode = 0, const std::string& _strRejectReason = \"\", const std::string& _strDebugMessage = \"\")\n+    bool Invalid(unsigned int _chRejectCode, const std::string& _strRejectReason, const std::string& _strDebugMessage = \"\")\n     {\n         return DoS(0, _chRejectCode, _strRejectReason, false, _strDebugMessage);\n     }"
      }
    ]
  },
  {
    "sha": "a25d9b7f273534c96699a5bde2005582ab244fed",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphMjVkOWI3ZjI3MzUzNGM5NjY5OWE1YmRlMjAwNTU4MmFiMjQ0ZmVk",
    "commit": {
      "author": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-04-04T00:33:22Z"
      },
      "committer": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-04-05T16:51:57Z"
      },
      "message": "Make the level explicit for CValidationState::Invalid",
      "tree": {
        "sha": "8c345f69eb6cd657d56f158170bdce480ad2ae70",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8c345f69eb6cd657d56f158170bdce480ad2ae70"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a25d9b7f273534c96699a5bde2005582ab244fed",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE+XLHXoy4Dim7e8hvTYykuhgECQYFAlrGVC0ACgkQTYykuhgE\nCQaxYQ//cQ9uwrthSDIByNVTf4/V/V0Qaak6HnBp/Zq+PLo2Q21pJdGK0rMFjea8\nWoogfuSdXLaTzAUX0cZaUK1pOHRxmINgAFmgwLdWoMHFhWEmnE0RGAqZEhSxSLYj\nABORuONq53fC5yHzvr3HqacA2e9M/5Bx6UWdQdnzNQ14YbyQ7p/LvJ4yvy5JLVaQ\nKRbPOUGqYNNJxM080ZpFr16EYQRN0Mkor/qMjf2uMAzi1pFO5JnwaLXBI8ZCT2n2\n4H56I5qhKoca6nsGYCazR0zBfCR0h0F7EJJ1BWvs+V6BI5I1Y+W3/BsAWF4y2vtO\nHWnWs3DxzxYsWqg/E+/VJridES5KUwW2WEwpZRji67Tp05uHAviBQG2lwomWtjDC\nTDgMaxzDbJToQYJ4VWJ5YJv0mkhYzAEisXA4pSqEOxd9/T3lY4VT/+KEK+3ckbZk\nimW35xelqHSCyNLm78gB3zl7E9p2t08YpR+S213jAyzO2eGruaSJdr8OkpWFD4Q7\nI1zkEiv7MQlA+aiwJawe8PLZM6ITN1mn7IGhZUGURECfN7kHYA5ye5gatRbLHj7K\nwCw3eA2S6dP5enoax76GDSYtV+hFCp0fGSasZqs0jSdrSVjIXysNbN1HolLpO0+G\ni92i+7qNtufJws1KoZhHGBKMVHbBOf9iyCuCpSV3ET8DqfviSeg=\n=xWEs\n-----END PGP SIGNATURE-----",
        "payload": "tree 8c345f69eb6cd657d56f158170bdce480ad2ae70\nparent f3cd4e6583711ad9a4b21d02e8228582000537d3\nauthor Ben Woosley <ben.woosley@gmail.com> 1522802002 -0700\ncommitter Ben Woosley <ben.woosley@gmail.com> 1522947117 -0700\n\nMake the level explicit for CValidationState::Invalid\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a25d9b7f273534c96699a5bde2005582ab244fed",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a25d9b7f273534c96699a5bde2005582ab244fed",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a25d9b7f273534c96699a5bde2005582ab244fed/comments",
    "author": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f3cd4e6583711ad9a4b21d02e8228582000537d3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f3cd4e6583711ad9a4b21d02e8228582000537d3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f3cd4e6583711ad9a4b21d02e8228582000537d3"
      }
    ],
    "stats": {
      "total": 28,
      "additions": 14,
      "deletions": 14
    },
    "files": [
      {
        "sha": "059affb3cbb90db642be280295fe6598ab952d42",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a25d9b7f273534c96699a5bde2005582ab244fed/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a25d9b7f273534c96699a5bde2005582ab244fed/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=a25d9b7f273534c96699a5bde2005582ab244fed",
        "patch": "@@ -221,7 +221,7 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n \n         // If prev is coinbase, check that it's matured\n         if (coin.IsCoinBase() && nSpendHeight - coin.nHeight < COINBASE_MATURITY) {\n-            return state.Invalid(REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\",\n+            return state.Invalid(0, REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\",\n                 strprintf(\"tried to spend coinbase at depth %d\", nSpendHeight - coin.nHeight));\n         }\n "
      },
      {
        "sha": "0af4ad7a56d91c71251c164af5a906d723723398",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a25d9b7f273534c96699a5bde2005582ab244fed/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a25d9b7f273534c96699a5bde2005582ab244fed/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=a25d9b7f273534c96699a5bde2005582ab244fed",
        "patch": "@@ -49,9 +49,9 @@ class CValidationState {\n         mode = MODE_INVALID;\n         return false;\n     }\n-    bool Invalid(unsigned int _chRejectCode, const std::string& _strRejectReason, const std::string& _strDebugMessage = \"\")\n+    bool Invalid(int _level, unsigned int _chRejectCode, const std::string& _strRejectReason, const std::string& _strDebugMessage = \"\")\n     {\n-        return DoS(0, _chRejectCode, _strRejectReason, false, _strDebugMessage);\n+        return DoS(_level, _chRejectCode, _strRejectReason, false, _strDebugMessage);\n     }\n     bool Error(const std::string& strRejectReasonIn) {\n         if (mode == MODE_VALID)"
      },
      {
        "sha": "2f96faa8b082a2304ed825d6b3481de0cff76350",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a25d9b7f273534c96699a5bde2005582ab244fed/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a25d9b7f273534c96699a5bde2005582ab244fed/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=a25d9b7f273534c96699a5bde2005582ab244fed",
        "patch": "@@ -579,7 +579,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n     // is it already in the memory pool?\n     if (pool.exists(hash)) {\n-        return state.Invalid(REJECT_DUPLICATE, \"txn-already-in-mempool\");\n+        return state.Invalid(0, REJECT_DUPLICATE, \"txn-already-in-mempool\");\n     }\n \n     // Check for conflicts with in-memory transactions\n@@ -617,7 +617,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     }\n                 }\n                 if (fReplacementOptOut) {\n-                    return state.Invalid(REJECT_DUPLICATE, \"txn-mempool-conflict\");\n+                    return state.Invalid(0, REJECT_DUPLICATE, \"txn-mempool-conflict\");\n                 }\n \n                 setConflicts.insert(ptxConflicting->GetHash());\n@@ -643,7 +643,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 for (size_t out = 0; out < tx.vout.size(); out++) {\n                     // Optimistically just do efficient check of cache for outputs\n                     if (pcoinsTip->HaveCoinInCache(COutPoint(hash, out))) {\n-                        return state.Invalid(REJECT_DUPLICATE, \"txn-already-known\");\n+                        return state.Invalid(0, REJECT_DUPLICATE, \"txn-already-known\");\n                     }\n                 }\n                 // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n@@ -675,7 +675,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n         // Check for non-standard pay-to-script-hash in inputs\n         if (fRequireStandard && !AreInputsStandard(tx, view))\n-            return state.Invalid(REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n+            return state.Invalid(0, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n \n         // Check for non-standard witness in P2WSH\n         if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, view))\n@@ -722,7 +722,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         }\n \n         if (nAbsurdFee && nFees > nAbsurdFee)\n-            return state.Invalid(REJECT_HIGHFEE, \"absurdly-high-fee\",\n+            return state.Invalid(0, REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n         // Calculate in-mempool ancestors, up to a limit.\n@@ -1405,7 +1405,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                         CScriptCheck check2(coin.out, tx, i,\n                                 flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &txdata);\n                         if (check2())\n-                            return state.Invalid(REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n+                            return state.Invalid(0, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n                     }\n                     // Failures of other flags indicate a transaction that is\n                     // invalid in new blocks, e.g. an invalid P2SH. We DoS ban\n@@ -3058,7 +3058,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n     // Check transactions\n     for (const auto& tx : block.vtx)\n         if (!CheckTransaction(*tx, state, false))\n-            return state.Invalid(state.GetRejectCode(), state.GetRejectReason(),\n+            return state.Invalid(0, state.GetRejectCode(), state.GetRejectReason(),\n                 strprintf(\"Transaction check failed (tx hash %s) %s\", tx->GetHash().ToString(), state.GetDebugMessage()));\n \n     unsigned int nSigOps = 0;\n@@ -3170,18 +3170,18 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n \n     // Check timestamp against prev\n     if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n-        return state.Invalid(REJECT_INVALID, \"time-too-old\", \"block's timestamp is too early\");\n+        return state.Invalid(0, REJECT_INVALID, \"time-too-old\", \"block's timestamp is too early\");\n \n     // Check timestamp\n     if (block.GetBlockTime() > nAdjustedTime + MAX_FUTURE_BLOCK_TIME)\n-        return state.Invalid(REJECT_INVALID, \"time-too-new\", \"block timestamp too far in the future\");\n+        return state.Invalid(0, REJECT_INVALID, \"time-too-new\", \"block timestamp too far in the future\");\n \n     // Reject outdated version blocks when 95% (75% on testnet) of the network has upgraded:\n     // check for version 2, 3 and 4 upgrades\n     if((block.nVersion < 2 && nHeight >= consensusParams.BIP34Height) ||\n        (block.nVersion < 3 && nHeight >= consensusParams.BIP66Height) ||\n        (block.nVersion < 4 && nHeight >= consensusParams.BIP65Height))\n-        return state.Invalid(REJECT_OBSOLETE, strprintf(\"bad-version(0x%08x)\", block.nVersion),\n+        return state.Invalid(0, REJECT_OBSOLETE, strprintf(\"bad-version(0x%08x)\", block.nVersion),\n             strprintf(\"rejected nVersion=0x%08x block\", block.nVersion));\n \n     return true;\n@@ -3289,7 +3289,7 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n                 *ppindex = pindex;\n             if (pindex->nStatus & BLOCK_FAILED_MASK) {\n                 error(\"%s: block %s is marked invalid\", __func__, hash.ToString());\n-                return state.Invalid(0, \"duplicate\");\n+                return state.Invalid(0, 0, \"duplicate\");\n             }\n             return true;\n         }"
      }
    ]
  },
  {
    "sha": "e3721705fca33771955df449d63b6f6895a5a90e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMzcyMTcwNWZjYTMzNzcxOTU1ZGY0NDlkNjNiNmY2ODk1YTVhOTBl",
    "commit": {
      "author": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-04-04T00:44:49Z"
      },
      "committer": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-04-05T16:51:57Z"
      },
      "message": "Use ::SetCorruptionPossible to declare corruption together with ::DoS\n\nThis builds the object using two calls when possiblyCorrupt argument is\nset. This makes the interface more simple & explicit by making\nthis literal argument self-explanatory, and by not separating the\nmessage strings.",
      "tree": {
        "sha": "bc48ba1c0a09366b59f29bd9005718e4cd8ca411",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bc48ba1c0a09366b59f29bd9005718e4cd8ca411"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e3721705fca33771955df449d63b6f6895a5a90e",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE+XLHXoy4Dim7e8hvTYykuhgECQYFAlrGVC0ACgkQTYykuhgE\nCQYsTg/+PgcLJcJ7sHGLy4hc3P3HYNA3yan8z0zNT/IOqbGlUxrkSAI9A+LiHaku\nuOdWlqDlO+oo5HGisMMXIh0IFyvDWEc0b9euIqMNNlg3C3eT+W0T1xxRggqN2How\n46sCeL4LP1Uy1tltFygJNKV1H41k77l7UvGSZK5gj7ENQWq7IX4SjuSc5bYmVPsX\nyj+uVh0vYyKd/cDKDDk72oZvkuwyazM7QGRRHL7b7FeYmI1+4sQ/OgKWPYI3cW8f\n2AcOk7EVKRksYJqMvuPxLNgvv59RzTRC5H247tWLTx4gUCvJdrHRKsAcvwFhqEs1\nqM3eGPg/GMETd2UJBwCDJU0FEFMiDygifdeNB3pMD8E9GXxt+Ak3sKe7ac1YhKRu\nDrrNdHm9VATBLiqHkA4gNPVdtJ1gvK5sGlX5c+7k5HV7yaW5fmwMsgi1G8mzDNEj\nEyEZZ10u4wNpPzd5csf3k1+3LubuJ9oSD4r5QaRBidXK5yZTVVoIPS+Rkw6zUh3a\nS8inVg2Eo8NwBtNNQpVhB0fcDl8EDOuOBpOtF4NsnUBdh22nAqXR1i6D3RDTiE8D\nTtz27Dd+qwBWPGz387SpOH1vruhBeKBCIJYUgkYFm9hqsnFQt6Z13Nzi1f4JAhOG\nvrwFVfR1lpcM3Ie554Y4uIt3mvmGTWFaHckScCGp6JjWb4AwIqU=\n=EiuX\n-----END PGP SIGNATURE-----",
        "payload": "tree bc48ba1c0a09366b59f29bd9005718e4cd8ca411\nparent a25d9b7f273534c96699a5bde2005582ab244fed\nauthor Ben Woosley <ben.woosley@gmail.com> 1522802689 -0700\ncommitter Ben Woosley <ben.woosley@gmail.com> 1522947117 -0700\n\nUse ::SetCorruptionPossible to declare corruption together with ::DoS\n\nThis builds the object using two calls when possiblyCorrupt argument is\nset. This makes the interface more simple & explicit by making\nthis literal argument self-explanatory, and by not separating the\nmessage strings.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3721705fca33771955df449d63b6f6895a5a90e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e3721705fca33771955df449d63b6f6895a5a90e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3721705fca33771955df449d63b6f6895a5a90e/comments",
    "author": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a25d9b7f273534c96699a5bde2005582ab244fed",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a25d9b7f273534c96699a5bde2005582ab244fed",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a25d9b7f273534c96699a5bde2005582ab244fed"
      }
    ],
    "stats": {
      "total": 100,
      "additions": 49,
      "deletions": 51
    },
    "files": [
      {
        "sha": "f68667a0048641144be34d6a5f98398523fad757",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3721705fca33771955df449d63b6f6895a5a90e/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3721705fca33771955df449d63b6f6895a5a90e/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=e3721705fca33771955df449d63b6f6895a5a90e",
        "patch": "@@ -209,7 +209,7 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n {\n     // are the actual inputs available?\n     if (!inputs.HaveInputs(tx)) {\n-        return state.DoS(100, REJECT_INVALID, \"bad-txns-inputs-missingorspent\", false,\n+        return state.DoS(100, REJECT_INVALID, \"bad-txns-inputs-missingorspent\",\n             strprintf(\"%s: inputs missing/spent\", __func__));\n     }\n \n@@ -221,7 +221,7 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n \n         // If prev is coinbase, check that it's matured\n         if (coin.IsCoinBase() && nSpendHeight - coin.nHeight < COINBASE_MATURITY) {\n-            return state.Invalid(0, REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\",\n+            return state.DoS(0, REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\",\n                 strprintf(\"tried to spend coinbase at depth %d\", nSpendHeight - coin.nHeight));\n         }\n \n@@ -234,7 +234,7 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n \n     const CAmount value_out = tx.GetValueOut();\n     if (nValueIn < value_out) {\n-        return state.DoS(100, REJECT_INVALID, \"bad-txns-in-belowout\", false,\n+        return state.DoS(100, REJECT_INVALID, \"bad-txns-in-belowout\",\n             strprintf(\"value in (%s) < value out (%s)\", FormatMoney(nValueIn), FormatMoney(value_out)));\n     }\n "
      },
      {
        "sha": "f85e42b38bbff1a4d1a7080c7ce7440ceae8b793",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 8,
        "deletions": 11,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3721705fca33771955df449d63b6f6895a5a90e/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3721705fca33771955df449d63b6f6895a5a90e/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=e3721705fca33771955df449d63b6f6895a5a90e",
        "patch": "@@ -37,22 +37,17 @@ class CValidationState {\n     std::string strDebugMessage;\n public:\n     CValidationState() : mode(MODE_VALID), nDoS(0), chRejectCode(0), corruptionPossible(false) {}\n-    bool DoS(int level, unsigned int chRejectCodeIn, const std::string& strRejectReasonIn, bool corruptionIn = false, const std::string& strDebugMessageIn = \"\")\n+    bool DoS(int level, unsigned int chRejectCodeIn, const std::string& strRejectReasonIn, const std::string& strDebugMessageIn = \"\")\n     {\n         chRejectCode = chRejectCodeIn;\n         strRejectReason = strRejectReasonIn;\n-        corruptionPossible = corruptionIn;\n         strDebugMessage = strDebugMessageIn;\n-        if (mode == MODE_ERROR)\n-            return false;\n-        nDoS += level;\n-        mode = MODE_INVALID;\n+        if (mode != MODE_ERROR) {\n+            nDoS += level;\n+            mode = MODE_INVALID;\n+        }\n         return false;\n     }\n-    bool Invalid(int _level, unsigned int _chRejectCode, const std::string& _strRejectReason, const std::string& _strDebugMessage = \"\")\n-    {\n-        return DoS(_level, _chRejectCode, _strRejectReason, false, _strDebugMessage);\n-    }\n     bool Error(const std::string& strRejectReasonIn) {\n         if (mode == MODE_VALID)\n             strRejectReason = strRejectReasonIn;\n@@ -78,8 +73,10 @@ class CValidationState {\n     bool CorruptionPossible() const {\n         return corruptionPossible;\n     }\n-    void SetCorruptionPossible() {\n+    CValidationState& SetCorruptionPossible()\n+    {\n         corruptionPossible = true;\n+        return *this;\n     }\n     unsigned int GetRejectCode() const { return chRejectCode; }\n     std::string GetRejectReason() const { return strRejectReason; }"
      },
      {
        "sha": "9531e18d08ec0a3027baa39fda98a3d9af6a16f5",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 38,
        "deletions": 37,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3721705fca33771955df449d63b6f6895a5a90e/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3721705fca33771955df449d63b6f6895a5a90e/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=e3721705fca33771955df449d63b6f6895a5a90e",
        "patch": "@@ -563,7 +563,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n     // Reject transactions with witness before segregated witness activates (override with -prematurewitness)\n     bool witnessEnabled = IsWitnessEnabled(chainActive.Tip(), chainparams.GetConsensus());\n     if (!gArgs.GetBoolArg(\"-prematurewitness\", false) && tx.HasWitness() && !witnessEnabled) {\n-        return state.DoS(0, REJECT_NONSTANDARD, \"no-witness-yet\", true);\n+        return state.SetCorruptionPossible().DoS(0, REJECT_NONSTANDARD, \"no-witness-yet\");\n     }\n \n     // Rather not work on nonstandard transactions (unless -testnet/-regtest)\n@@ -579,7 +579,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n     // is it already in the memory pool?\n     if (pool.exists(hash)) {\n-        return state.Invalid(0, REJECT_DUPLICATE, \"txn-already-in-mempool\");\n+        return state.DoS(0, REJECT_DUPLICATE, \"txn-already-in-mempool\");\n     }\n \n     // Check for conflicts with in-memory transactions\n@@ -617,7 +617,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     }\n                 }\n                 if (fReplacementOptOut) {\n-                    return state.Invalid(0, REJECT_DUPLICATE, \"txn-mempool-conflict\");\n+                    return state.DoS(0, REJECT_DUPLICATE, \"txn-mempool-conflict\");\n                 }\n \n                 setConflicts.insert(ptxConflicting->GetHash());\n@@ -643,14 +643,14 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 for (size_t out = 0; out < tx.vout.size(); out++) {\n                     // Optimistically just do efficient check of cache for outputs\n                     if (pcoinsTip->HaveCoinInCache(COutPoint(hash, out))) {\n-                        return state.Invalid(0, REJECT_DUPLICATE, \"txn-already-known\");\n+                        return state.DoS(0, REJECT_DUPLICATE, \"txn-already-known\");\n                     }\n                 }\n                 // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n                 if (pfMissingInputs) {\n                     *pfMissingInputs = true;\n                 }\n-                return false; // fMissingInputs and !state.IsInvalid() is used to detect this condition, don't set state.Invalid()\n+                return false; // fMissingInputs and !state.IsInvalid() is used to detect this condition, don't set state.DoS()\n             }\n         }\n \n@@ -675,11 +675,11 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n         // Check for non-standard pay-to-script-hash in inputs\n         if (fRequireStandard && !AreInputsStandard(tx, view))\n-            return state.Invalid(0, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n+            return state.DoS(0, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n \n         // Check for non-standard witness in P2WSH\n         if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, view))\n-            return state.DoS(0, REJECT_NONSTANDARD, \"bad-witness-nonstandard\", true);\n+            return state.SetCorruptionPossible().DoS(0, REJECT_NONSTANDARD, \"bad-witness-nonstandard\");\n \n         int64_t nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);\n \n@@ -708,12 +708,13 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         // MAX_BLOCK_SIGOPS; we still consider this an invalid rather than\n         // merely non-standard transaction.\n         if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)\n-            return state.DoS(0, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\", false,\n+            return state.DoS(0, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\",\n                 strprintf(\"%d\", nSigOpsCost));\n \n         CAmount mempoolRejectFee = pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(nSize);\n         if (!bypass_limits && mempoolRejectFee > 0 && nModifiedFees < mempoolRejectFee) {\n-            return state.DoS(0, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", false, strprintf(\"%d < %d\", nModifiedFees, mempoolRejectFee));\n+            return state.DoS(0, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\",\n+                strprintf(\"%d < %d\", nModifiedFees, mempoolRejectFee));\n         }\n \n         // No transactions are allowed below minRelayTxFee except from disconnected blocks\n@@ -722,7 +723,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         }\n \n         if (nAbsurdFee && nFees > nAbsurdFee)\n-            return state.Invalid(0, REJECT_HIGHFEE, \"absurdly-high-fee\",\n+            return state.DoS(0, REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n         // Calculate in-mempool ancestors, up to a limit.\n@@ -733,7 +734,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n         std::string errString;\n         if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n-            return state.DoS(0, REJECT_NONSTANDARD, \"too-long-mempool-chain\", false, errString);\n+            return state.DoS(0, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n         }\n \n         // A transaction that spends outputs that would be replaced by it is invalid. Now\n@@ -745,7 +746,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n             if (setConflicts.count(hashAncestor))\n             {\n-                return state.DoS(10, REJECT_INVALID, \"bad-txns-spends-conflicting-tx\", false,\n+                return state.DoS(10, REJECT_INVALID, \"bad-txns-spends-conflicting-tx\",\n                     strprintf(\"%s spends conflicting transaction %s\",\n                         hash.ToString(),\n                         hashAncestor.ToString()));\n@@ -797,7 +798,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n                 if (newFeeRate <= oldFeeRate)\n                 {\n-                    return state.DoS(0, REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                    return state.DoS(0, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n                         strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n                             hash.ToString(),\n                             newFeeRate.ToString(),\n@@ -825,7 +826,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     nConflictingSize += it->GetTxSize();\n                 }\n             } else {\n-                return state.DoS(0, REJECT_NONSTANDARD, \"too many potential replacements\", false,\n+                return state.DoS(0, REJECT_NONSTANDARD, \"too many potential replacements\",\n                     strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n                         hash.ToString(),\n                         nConflictingCount,\n@@ -844,7 +845,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     // it's cheaper to just check if the new input refers to a\n                     // tx that's in the mempool.\n                     if (pool.mapTx.find(tx.vin[j].prevout.hash) != pool.mapTx.end())\n-                        return state.DoS(0, REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\", false,\n+                        return state.DoS(0, REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\",\n                             strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n                                 hash.ToString(), j));\n                 }\n@@ -855,7 +856,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             // transactions would not be paid for.\n             if (nModifiedFees < nConflictingFees)\n             {\n-                return state.DoS(0, REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                return state.DoS(0, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n                     strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n                         hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)));\n             }\n@@ -865,7 +866,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             CAmount nDeltaFees = nModifiedFees - nConflictingFees;\n             if (nDeltaFees < ::incrementalRelayFee.GetFee(nSize))\n             {\n-                return state.DoS(0, REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                return state.DoS(0, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n                     strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n                         hash.ToString(),\n                         FormatMoney(nDeltaFees),\n@@ -1405,7 +1406,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                         CScriptCheck check2(coin.out, tx, i,\n                                 flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &txdata);\n                         if (check2())\n-                            return state.Invalid(0, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n+                            return state.DoS(0, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n                     }\n                     // Failures of other flags indicate a transaction that is\n                     // invalid in new blocks, e.g. an invalid P2SH. We DoS ban\n@@ -3007,7 +3008,7 @@ static bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state,\n {\n     // Check proof of work matches claimed amount\n     if (fCheckPOW && !CheckProofOfWork(block.GetHash(), block.nBits, consensusParams))\n-        return state.DoS(50, REJECT_INVALID, \"high-hash\", false, \"proof of work failed\");\n+        return state.DoS(50, REJECT_INVALID, \"high-hash\", \"proof of work failed\");\n \n     return true;\n }\n@@ -3029,13 +3030,13 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n         bool mutated;\n         uint256 hashMerkleRoot2 = BlockMerkleRoot(block, &mutated);\n         if (block.hashMerkleRoot != hashMerkleRoot2)\n-            return state.DoS(100, REJECT_INVALID, \"bad-txnmrklroot\", true, \"hashMerkleRoot mismatch\");\n+            return state.SetCorruptionPossible().DoS(100, REJECT_INVALID, \"bad-txnmrklroot\", \"hashMerkleRoot mismatch\");\n \n         // Check for merkle tree malleability (CVE-2012-2459): repeating sequences\n         // of transactions in a block without affecting the merkle root of a block,\n         // while still invalidating it.\n         if (mutated)\n-            return state.DoS(100, REJECT_INVALID, \"bad-txns-duplicate\", true, \"duplicate transaction\");\n+            return state.SetCorruptionPossible().DoS(100, REJECT_INVALID, \"bad-txns-duplicate\", \"duplicate transaction\");\n     }\n \n     // All potential-corruption validation must be done before we do any\n@@ -3046,19 +3047,19 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n \n     // Size limits\n     if (block.vtx.empty() || block.vtx.size() * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n-        return state.DoS(100, REJECT_INVALID, \"bad-blk-length\", false, \"size limits failed\");\n+        return state.DoS(100, REJECT_INVALID, \"bad-blk-length\", \"size limits failed\");\n \n     // First transaction must be coinbase, the rest must not be\n     if (block.vtx.empty() || !block.vtx[0]->IsCoinBase())\n-        return state.DoS(100, REJECT_INVALID, \"bad-cb-missing\", false, \"first tx is not coinbase\");\n+        return state.DoS(100, REJECT_INVALID, \"bad-cb-missing\", \"first tx is not coinbase\");\n     for (unsigned int i = 1; i < block.vtx.size(); i++)\n         if (block.vtx[i]->IsCoinBase())\n-            return state.DoS(100, REJECT_INVALID, \"bad-cb-multiple\", false, \"more than one coinbase\");\n+            return state.DoS(100, REJECT_INVALID, \"bad-cb-multiple\", \"more than one coinbase\");\n \n     // Check transactions\n     for (const auto& tx : block.vtx)\n         if (!CheckTransaction(*tx, state, false))\n-            return state.Invalid(0, state.GetRejectCode(), state.GetRejectReason(),\n+            return state.DoS(0, state.GetRejectCode(), state.GetRejectReason(),\n                 strprintf(\"Transaction check failed (tx hash %s) %s\", tx->GetHash().ToString(), state.GetDebugMessage()));\n \n     unsigned int nSigOps = 0;\n@@ -3067,7 +3068,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n         nSigOps += GetLegacySigOpCount(*tx);\n     }\n     if (nSigOps * WITNESS_SCALE_FACTOR > MAX_BLOCK_SIGOPS_COST)\n-        return state.DoS(100, REJECT_INVALID, \"bad-blk-sigops\", false, \"out-of-bounds SigOpCount\");\n+        return state.DoS(100, REJECT_INVALID, \"bad-blk-sigops\", \"out-of-bounds SigOpCount\");\n \n     if (fCheckPOW && fCheckMerkleRoot)\n         block.fChecked = true;\n@@ -3154,7 +3155,7 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n     // Check proof of work\n     const Consensus::Params& consensusParams = params.GetConsensus();\n     if (block.nBits != GetNextWorkRequired(pindexPrev, &block, consensusParams))\n-        return state.DoS(100, REJECT_INVALID, \"bad-diffbits\", false, \"incorrect proof of work\");\n+        return state.DoS(100, REJECT_INVALID, \"bad-diffbits\", \"incorrect proof of work\");\n \n     // Check against checkpoints\n     if (fCheckpointsEnabled) {\n@@ -3170,18 +3171,18 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n \n     // Check timestamp against prev\n     if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n-        return state.Invalid(0, REJECT_INVALID, \"time-too-old\", \"block's timestamp is too early\");\n+        return state.DoS(0, REJECT_INVALID, \"time-too-old\", \"block's timestamp is too early\");\n \n     // Check timestamp\n     if (block.GetBlockTime() > nAdjustedTime + MAX_FUTURE_BLOCK_TIME)\n-        return state.Invalid(0, REJECT_INVALID, \"time-too-new\", \"block timestamp too far in the future\");\n+        return state.DoS(0, REJECT_INVALID, \"time-too-new\", \"block timestamp too far in the future\");\n \n     // Reject outdated version blocks when 95% (75% on testnet) of the network has upgraded:\n     // check for version 2, 3 and 4 upgrades\n     if((block.nVersion < 2 && nHeight >= consensusParams.BIP34Height) ||\n        (block.nVersion < 3 && nHeight >= consensusParams.BIP66Height) ||\n        (block.nVersion < 4 && nHeight >= consensusParams.BIP65Height))\n-        return state.Invalid(0, REJECT_OBSOLETE, strprintf(\"bad-version(0x%08x)\", block.nVersion),\n+        return state.DoS(0, REJECT_OBSOLETE, strprintf(\"bad-version(0x%08x)\", block.nVersion),\n             strprintf(\"rejected nVersion=0x%08x block\", block.nVersion));\n \n     return true;\n@@ -3210,7 +3211,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     // Check that all transactions are finalized\n     for (const auto& tx : block.vtx) {\n         if (!IsFinalTx(*tx, nHeight, nLockTimeCutoff)) {\n-            return state.DoS(10, REJECT_INVALID, \"bad-txns-nonfinal\", false, \"non-final transaction\");\n+            return state.DoS(10, REJECT_INVALID, \"bad-txns-nonfinal\", \"non-final transaction\");\n         }\n     }\n \n@@ -3220,7 +3221,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n         CScript expect = CScript() << nHeight;\n         if (block.vtx[0]->vin[0].scriptSig.size() < expect.size() ||\n             !std::equal(expect.begin(), expect.end(), block.vtx[0]->vin[0].scriptSig.begin())) {\n-            return state.DoS(100, REJECT_INVALID, \"bad-cb-height\", false, \"block height mismatch in coinbase\");\n+            return state.DoS(100, REJECT_INVALID, \"bad-cb-height\", \"block height mismatch in coinbase\");\n         }\n     }\n \n@@ -3242,11 +3243,11 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n             // already does not permit it, it is impossible to trigger in the\n             // witness tree.\n             if (block.vtx[0]->vin[0].scriptWitness.stack.size() != 1 || block.vtx[0]->vin[0].scriptWitness.stack[0].size() != 32) {\n-                return state.DoS(100, REJECT_INVALID, \"bad-witness-nonce-size\", true, strprintf(\"%s : invalid witness reserved value size\", __func__));\n+                return state.SetCorruptionPossible().DoS(100, REJECT_INVALID, \"bad-witness-nonce-size\", strprintf(\"%s : invalid witness reserved value size\", __func__));\n             }\n             CHash256().Write(hashWitness.begin(), 32).Write(&block.vtx[0]->vin[0].scriptWitness.stack[0][0], 32).Finalize(hashWitness.begin());\n             if (memcmp(hashWitness.begin(), &block.vtx[0]->vout[commitpos].scriptPubKey[6], 32)) {\n-                return state.DoS(100, REJECT_INVALID, \"bad-witness-merkle-match\", true, strprintf(\"%s : witness merkle commitment mismatch\", __func__));\n+                return state.SetCorruptionPossible().DoS(100, REJECT_INVALID, \"bad-witness-merkle-match\", strprintf(\"%s : witness merkle commitment mismatch\", __func__));\n             }\n             fHaveWitness = true;\n         }\n@@ -3256,7 +3257,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     if (!fHaveWitness) {\n       for (const auto& tx : block.vtx) {\n             if (tx->HasWitness()) {\n-                return state.DoS(100, REJECT_INVALID, \"unexpected-witness\", true, strprintf(\"%s : unexpected witness data found\", __func__));\n+                return state.SetCorruptionPossible().DoS(100, REJECT_INVALID, \"unexpected-witness\", strprintf(\"%s : unexpected witness data found\", __func__));\n             }\n         }\n     }\n@@ -3268,7 +3269,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     // the block hash, so we couldn't mark the block as permanently\n     // failed).\n     if (GetBlockWeight(block) > MAX_BLOCK_WEIGHT) {\n-        return state.DoS(100, REJECT_INVALID, \"bad-blk-weight\", false, strprintf(\"%s : weight limit failed\", __func__));\n+        return state.DoS(100, REJECT_INVALID, \"bad-blk-weight\", strprintf(\"%s : weight limit failed\", __func__));\n     }\n \n     return true;\n@@ -3289,7 +3290,7 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n                 *ppindex = pindex;\n             if (pindex->nStatus & BLOCK_FAILED_MASK) {\n                 error(\"%s: block %s is marked invalid\", __func__, hash.ToString());\n-                return state.Invalid(0, 0, \"duplicate\");\n+                return state.DoS(0, 0, \"duplicate\");\n             }\n             return true;\n         }"
      }
    ]
  },
  {
    "sha": "9d45816f0b0683f1f0d29ac35a4a7312ac515756",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZDQ1ODE2ZjBiMDY4M2YxZjBkMjlhYzM1YTRhNzMxMmFjNTE1NzU2",
    "commit": {
      "author": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-04-05T19:18:13Z"
      },
      "committer": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-04-05T19:43:52Z"
      },
      "message": "scripted-diff: Rename CValidationState::DoS to ::Reject\n\nTo protect against silent merge conflicts.\n\n-BEGIN VERIFY SCRIPT-\nfind ./src -type f \\( -name *.cpp -o -name *.h \\) -exec sed -i -e 's/\\bDoS(/Reject(/' {} \\;\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "e4d3d7f0135e892526ece6055acf1808bff8368e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e4d3d7f0135e892526ece6055acf1808bff8368e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9d45816f0b0683f1f0d29ac35a4a7312ac515756",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE+XLHXoy4Dim7e8hvTYykuhgECQYFAlrGfIcACgkQTYykuhgE\nCQYd1BAAhRbCSphphFtZ48knJEqE/Q6iJxc9cji/+jBJxDCq02xYmNrDrqeHd6O3\n1QdSkO5NJ2yujIsq8GaUwRtejvGTHz9KOR/FilNMrqUdktLMEl8CCekk43UglcnQ\nOsyL/HaFgQNn3B2LW+6zWlZU8ZY0lf4LNTTOF6OWv3bbyT85puW+WNgP/bXb9woP\nN3hA8llvB4tYwPRXMxNlqa2X1K/4sXVwagwasHSXBzk7StXRrAcu+Jg5BNR+YPNU\nxXxDEPL+LPmQ2AIjQeQnVyOyoQkgZ9jF5Z34UbTZWiBOJ81Tfxfue4R3xZImPrbo\n1U7gGOmtodCIQto9x0q//ZkSVQho4VE3s+tLYLu6uXh7kMsJJLgyu3dusxIaP7m8\nwV6GbwHj1u50dkkbWIWCtwVPRQTb06gBf56il2ddP9ygE9UWNkpAwES6MlTqzEai\nKrz5N1bT4QVz4qikmDy2RHSlDLiU+L+kq4ykRKI4r8axYKsGu0+w8Z5Ozit98uZV\nwbvsXwMbbAYjF8ffJvQQyz7Ocw5FZ4G0aQDNkT8uDXGWuAL1rxOR+N46mddt/R0e\nD+tOhmhqsfhWwWXOzqropIlj1lid2ZGitnvCYdZFP0S9yDb3NSYM93GuuE0K2wIp\nelFumr7QtDEX9WENgrU99v9FzZwqUdWUuEWKVd2KeCF/ziIrzxc=\n=xVSY\n-----END PGP SIGNATURE-----",
        "payload": "tree e4d3d7f0135e892526ece6055acf1808bff8368e\nparent e3721705fca33771955df449d63b6f6895a5a90e\nauthor Ben Woosley <ben.woosley@gmail.com> 1522955893 -0700\ncommitter Ben Woosley <ben.woosley@gmail.com> 1522957432 -0700\n\nscripted-diff: Rename CValidationState::DoS to ::Reject\n\nTo protect against silent merge conflicts.\n\n-BEGIN VERIFY SCRIPT-\nfind ./src -type f \\( -name *.cpp -o -name *.h \\) -exec sed -i -e 's/\\bDoS(/Reject(/' {} \\;\n-END VERIFY SCRIPT-\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9d45816f0b0683f1f0d29ac35a4a7312ac515756",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9d45816f0b0683f1f0d29ac35a4a7312ac515756",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9d45816f0b0683f1f0d29ac35a4a7312ac515756/comments",
    "author": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e3721705fca33771955df449d63b6f6895a5a90e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3721705fca33771955df449d63b6f6895a5a90e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e3721705fca33771955df449d63b6f6895a5a90e"
      }
    ],
    "stats": {
      "total": 138,
      "additions": 69,
      "deletions": 69
    },
    "files": [
      {
        "sha": "51f6823f4311720cfbc8cef5a2a91fce8182a549",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9d45816f0b0683f1f0d29ac35a4a7312ac515756/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9d45816f0b0683f1f0d29ac35a4a7312ac515756/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=9d45816f0b0683f1f0d29ac35a4a7312ac515756",
        "patch": "@@ -160,24 +160,24 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n {\n     // Basic checks that don't depend on any context\n     if (tx.vin.empty())\n-        return state.DoS(10, REJECT_INVALID, \"bad-txns-vin-empty\");\n+        return state.Reject(10, REJECT_INVALID, \"bad-txns-vin-empty\");\n     if (tx.vout.empty())\n-        return state.DoS(10, REJECT_INVALID, \"bad-txns-vout-empty\");\n+        return state.Reject(10, REJECT_INVALID, \"bad-txns-vout-empty\");\n     // Size limits (this doesn't take the witness into account, as that hasn't been checked for malleability)\n     if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n-        return state.DoS(100, REJECT_INVALID, \"bad-txns-oversize\");\n+        return state.Reject(100, REJECT_INVALID, \"bad-txns-oversize\");\n \n     // Check for negative or overflow output values\n     CAmount nValueOut = 0;\n     for (const auto& txout : tx.vout)\n     {\n         if (txout.nValue < 0)\n-            return state.DoS(100, REJECT_INVALID, \"bad-txns-vout-negative\");\n+            return state.Reject(100, REJECT_INVALID, \"bad-txns-vout-negative\");\n         if (txout.nValue > MAX_MONEY)\n-            return state.DoS(100, REJECT_INVALID, \"bad-txns-vout-toolarge\");\n+            return state.Reject(100, REJECT_INVALID, \"bad-txns-vout-toolarge\");\n         nValueOut += txout.nValue;\n         if (!MoneyRange(nValueOut))\n-            return state.DoS(100, REJECT_INVALID, \"bad-txns-txouttotal-toolarge\");\n+            return state.Reject(100, REJECT_INVALID, \"bad-txns-txouttotal-toolarge\");\n     }\n \n     // Check for duplicate inputs - note that this check is slow so we skip it in CheckBlock\n@@ -186,20 +186,20 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n         for (const auto& txin : tx.vin)\n         {\n             if (!vInOutPoints.insert(txin.prevout).second)\n-                return state.DoS(100, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n+                return state.Reject(100, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n         }\n     }\n \n     if (tx.IsCoinBase())\n     {\n         if (tx.vin[0].scriptSig.size() < 2 || tx.vin[0].scriptSig.size() > 100)\n-            return state.DoS(100, REJECT_INVALID, \"bad-cb-length\");\n+            return state.Reject(100, REJECT_INVALID, \"bad-cb-length\");\n     }\n     else\n     {\n         for (const auto& txin : tx.vin)\n             if (txin.prevout.IsNull())\n-                return state.DoS(10, REJECT_INVALID, \"bad-txns-prevout-null\");\n+                return state.Reject(10, REJECT_INVALID, \"bad-txns-prevout-null\");\n     }\n \n     return true;\n@@ -209,7 +209,7 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n {\n     // are the actual inputs available?\n     if (!inputs.HaveInputs(tx)) {\n-        return state.DoS(100, REJECT_INVALID, \"bad-txns-inputs-missingorspent\",\n+        return state.Reject(100, REJECT_INVALID, \"bad-txns-inputs-missingorspent\",\n             strprintf(\"%s: inputs missing/spent\", __func__));\n     }\n \n@@ -221,27 +221,27 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n \n         // If prev is coinbase, check that it's matured\n         if (coin.IsCoinBase() && nSpendHeight - coin.nHeight < COINBASE_MATURITY) {\n-            return state.DoS(0, REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\",\n+            return state.Reject(0, REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\",\n                 strprintf(\"tried to spend coinbase at depth %d\", nSpendHeight - coin.nHeight));\n         }\n \n         // Check for negative or overflow input values\n         nValueIn += coin.out.nValue;\n         if (!MoneyRange(coin.out.nValue) || !MoneyRange(nValueIn)) {\n-            return state.DoS(100, REJECT_INVALID, \"bad-txns-inputvalues-outofrange\");\n+            return state.Reject(100, REJECT_INVALID, \"bad-txns-inputvalues-outofrange\");\n         }\n     }\n \n     const CAmount value_out = tx.GetValueOut();\n     if (nValueIn < value_out) {\n-        return state.DoS(100, REJECT_INVALID, \"bad-txns-in-belowout\",\n+        return state.Reject(100, REJECT_INVALID, \"bad-txns-in-belowout\",\n             strprintf(\"value in (%s) < value out (%s)\", FormatMoney(nValueIn), FormatMoney(value_out)));\n     }\n \n     // Tally transaction fees\n     const CAmount txfee_aux = nValueIn - value_out;\n     if (!MoneyRange(txfee_aux)) {\n-        return state.DoS(100, REJECT_INVALID, \"bad-txns-fee-outofrange\");\n+        return state.Reject(100, REJECT_INVALID, \"bad-txns-fee-outofrange\");\n     }\n \n     txfee = txfee_aux;"
      },
      {
        "sha": "d881ab609266b0044343cc4f87a9d0502346b604",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9d45816f0b0683f1f0d29ac35a4a7312ac515756/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9d45816f0b0683f1f0d29ac35a4a7312ac515756/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=9d45816f0b0683f1f0d29ac35a4a7312ac515756",
        "patch": "@@ -37,7 +37,7 @@ class CValidationState {\n     std::string strDebugMessage;\n public:\n     CValidationState() : mode(MODE_VALID), nDoS(0), chRejectCode(0), corruptionPossible(false) {}\n-    bool DoS(int level, unsigned int chRejectCodeIn, const std::string& strRejectReasonIn, const std::string& strDebugMessageIn = \"\")\n+    bool Reject(int level, unsigned int chRejectCodeIn, const std::string& strRejectReasonIn, const std::string& strDebugMessageIn = \"\")\n     {\n         chRejectCode = chRejectCodeIn;\n         strRejectReason = strRejectReasonIn;"
      },
      {
        "sha": "2accf9520292e92f3fcaf3c6f49a160b5683fc3f",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 54,
        "deletions": 54,
        "changes": 108,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9d45816f0b0683f1f0d29ac35a4a7312ac515756/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9d45816f0b0683f1f0d29ac35a4a7312ac515756/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=9d45816f0b0683f1f0d29ac35a4a7312ac515756",
        "patch": "@@ -558,28 +558,28 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n     // Coinbase is only valid in a block, not as a loose transaction\n     if (tx.IsCoinBase())\n-        return state.DoS(100, REJECT_INVALID, \"coinbase\");\n+        return state.Reject(100, REJECT_INVALID, \"coinbase\");\n \n     // Reject transactions with witness before segregated witness activates (override with -prematurewitness)\n     bool witnessEnabled = IsWitnessEnabled(chainActive.Tip(), chainparams.GetConsensus());\n     if (!gArgs.GetBoolArg(\"-prematurewitness\", false) && tx.HasWitness() && !witnessEnabled) {\n-        return state.SetCorruptionPossible().DoS(0, REJECT_NONSTANDARD, \"no-witness-yet\");\n+        return state.SetCorruptionPossible().Reject(0, REJECT_NONSTANDARD, \"no-witness-yet\");\n     }\n \n     // Rather not work on nonstandard transactions (unless -testnet/-regtest)\n     std::string reason;\n     if (fRequireStandard && !IsStandardTx(tx, reason, witnessEnabled))\n-        return state.DoS(0, REJECT_NONSTANDARD, reason);\n+        return state.Reject(0, REJECT_NONSTANDARD, reason);\n \n     // Only accept nLockTime-using transactions that can be mined in the next\n     // block; we don't want our mempool filled up with transactions that can't\n     // be mined yet.\n     if (!CheckFinalTx(tx, STANDARD_LOCKTIME_VERIFY_FLAGS))\n-        return state.DoS(0, REJECT_NONSTANDARD, \"non-final\");\n+        return state.Reject(0, REJECT_NONSTANDARD, \"non-final\");\n \n     // is it already in the memory pool?\n     if (pool.exists(hash)) {\n-        return state.DoS(0, REJECT_DUPLICATE, \"txn-already-in-mempool\");\n+        return state.Reject(0, REJECT_DUPLICATE, \"txn-already-in-mempool\");\n     }\n \n     // Check for conflicts with in-memory transactions\n@@ -617,7 +617,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     }\n                 }\n                 if (fReplacementOptOut) {\n-                    return state.DoS(0, REJECT_DUPLICATE, \"txn-mempool-conflict\");\n+                    return state.Reject(0, REJECT_DUPLICATE, \"txn-mempool-conflict\");\n                 }\n \n                 setConflicts.insert(ptxConflicting->GetHash());\n@@ -643,14 +643,14 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 for (size_t out = 0; out < tx.vout.size(); out++) {\n                     // Optimistically just do efficient check of cache for outputs\n                     if (pcoinsTip->HaveCoinInCache(COutPoint(hash, out))) {\n-                        return state.DoS(0, REJECT_DUPLICATE, \"txn-already-known\");\n+                        return state.Reject(0, REJECT_DUPLICATE, \"txn-already-known\");\n                     }\n                 }\n                 // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n                 if (pfMissingInputs) {\n                     *pfMissingInputs = true;\n                 }\n-                return false; // fMissingInputs and !state.IsInvalid() is used to detect this condition, don't set state.DoS()\n+                return false; // fMissingInputs and !state.IsInvalid() is used to detect this condition, don't set state.Reject()\n             }\n         }\n \n@@ -666,7 +666,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n         // CoinsViewCache instead of create its own\n         if (!CheckSequenceLocks(tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n-            return state.DoS(0, REJECT_NONSTANDARD, \"non-BIP68-final\");\n+            return state.Reject(0, REJECT_NONSTANDARD, \"non-BIP68-final\");\n \n         CAmount nFees = 0;\n         if (!Consensus::CheckTxInputs(tx, state, view, GetSpendHeight(view), nFees)) {\n@@ -675,11 +675,11 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n         // Check for non-standard pay-to-script-hash in inputs\n         if (fRequireStandard && !AreInputsStandard(tx, view))\n-            return state.DoS(0, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n+            return state.Reject(0, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n \n         // Check for non-standard witness in P2WSH\n         if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, view))\n-            return state.SetCorruptionPossible().DoS(0, REJECT_NONSTANDARD, \"bad-witness-nonstandard\");\n+            return state.SetCorruptionPossible().Reject(0, REJECT_NONSTANDARD, \"bad-witness-nonstandard\");\n \n         int64_t nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);\n \n@@ -708,22 +708,22 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         // MAX_BLOCK_SIGOPS; we still consider this an invalid rather than\n         // merely non-standard transaction.\n         if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)\n-            return state.DoS(0, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\",\n+            return state.Reject(0, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\",\n                 strprintf(\"%d\", nSigOpsCost));\n \n         CAmount mempoolRejectFee = pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(nSize);\n         if (!bypass_limits && mempoolRejectFee > 0 && nModifiedFees < mempoolRejectFee) {\n-            return state.DoS(0, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\",\n+            return state.Reject(0, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\",\n                 strprintf(\"%d < %d\", nModifiedFees, mempoolRejectFee));\n         }\n \n         // No transactions are allowed below minRelayTxFee except from disconnected blocks\n         if (!bypass_limits && nModifiedFees < ::minRelayTxFee.GetFee(nSize)) {\n-            return state.DoS(0, REJECT_INSUFFICIENTFEE, \"min relay fee not met\");\n+            return state.Reject(0, REJECT_INSUFFICIENTFEE, \"min relay fee not met\");\n         }\n \n         if (nAbsurdFee && nFees > nAbsurdFee)\n-            return state.DoS(0, REJECT_HIGHFEE, \"absurdly-high-fee\",\n+            return state.Reject(0, REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n         // Calculate in-mempool ancestors, up to a limit.\n@@ -734,7 +734,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n         std::string errString;\n         if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n-            return state.DoS(0, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            return state.Reject(0, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n         }\n \n         // A transaction that spends outputs that would be replaced by it is invalid. Now\n@@ -746,7 +746,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n             if (setConflicts.count(hashAncestor))\n             {\n-                return state.DoS(10, REJECT_INVALID, \"bad-txns-spends-conflicting-tx\",\n+                return state.Reject(10, REJECT_INVALID, \"bad-txns-spends-conflicting-tx\",\n                     strprintf(\"%s spends conflicting transaction %s\",\n                         hash.ToString(),\n                         hashAncestor.ToString()));\n@@ -798,7 +798,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n                 if (newFeeRate <= oldFeeRate)\n                 {\n-                    return state.DoS(0, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n+                    return state.Reject(0, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n                         strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n                             hash.ToString(),\n                             newFeeRate.ToString(),\n@@ -826,7 +826,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     nConflictingSize += it->GetTxSize();\n                 }\n             } else {\n-                return state.DoS(0, REJECT_NONSTANDARD, \"too many potential replacements\",\n+                return state.Reject(0, REJECT_NONSTANDARD, \"too many potential replacements\",\n                     strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n                         hash.ToString(),\n                         nConflictingCount,\n@@ -845,7 +845,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     // it's cheaper to just check if the new input refers to a\n                     // tx that's in the mempool.\n                     if (pool.mapTx.find(tx.vin[j].prevout.hash) != pool.mapTx.end())\n-                        return state.DoS(0, REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\",\n+                        return state.Reject(0, REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\",\n                             strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n                                 hash.ToString(), j));\n                 }\n@@ -856,7 +856,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             // transactions would not be paid for.\n             if (nModifiedFees < nConflictingFees)\n             {\n-                return state.DoS(0, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n+                return state.Reject(0, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n                     strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n                         hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)));\n             }\n@@ -866,7 +866,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             CAmount nDeltaFees = nModifiedFees - nConflictingFees;\n             if (nDeltaFees < ::incrementalRelayFee.GetFee(nSize))\n             {\n-                return state.DoS(0, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n+                return state.Reject(0, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n                     strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n                         hash.ToString(),\n                         FormatMoney(nDeltaFees),\n@@ -961,7 +961,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         if (!bypass_limits) {\n             LimitMempoolSize(pool, gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, gArgs.GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n             if (!pool.exists(hash))\n-                return state.DoS(0, REJECT_INSUFFICIENTFEE, \"mempool full\");\n+                return state.Reject(0, REJECT_INSUFFICIENTFEE, \"mempool full\");\n         }\n     }\n \n@@ -1406,7 +1406,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                         CScriptCheck check2(coin.out, tx, i,\n                                 flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &txdata);\n                         if (check2())\n-                            return state.DoS(0, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n+                            return state.Reject(0, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n                     }\n                     // Failures of other flags indicate a transaction that is\n                     // invalid in new blocks, e.g. an invalid P2SH. We DoS ban\n@@ -1415,7 +1415,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                     // as to the correct behavior - we may want to continue\n                     // peering with non-upgraded nodes even after soft-fork\n                     // super-majority signaling has occurred.\n-                    return state.DoS(100, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n+                    return state.Reject(100, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n                 }\n             }\n \n@@ -1918,7 +1918,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n             for (size_t o = 0; o < tx->vout.size(); o++) {\n                 if (view.HaveCoin(COutPoint(tx->GetHash(), o))) {\n                     error(\"ConnectBlock(): tried to overwrite transaction\");\n-                    return state.DoS(100, REJECT_INVALID, \"bad-txns-BIP30\");\n+                    return state.Reject(100, REJECT_INVALID, \"bad-txns-BIP30\");\n                 }\n             }\n         }\n@@ -1962,7 +1962,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n             nFees += txfee;\n             if (!MoneyRange(nFees)) {\n                 error(\"%s: accumulated fee in the block out of range.\", __func__);\n-                return state.DoS(100, REJECT_INVALID, \"bad-txns-accumulated-fee-outofrange\");\n+                return state.Reject(100, REJECT_INVALID, \"bad-txns-accumulated-fee-outofrange\");\n             }\n \n             // Check that transaction is BIP68 final\n@@ -1975,7 +1975,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n \n             if (!SequenceLocks(tx, nLockTimeFlags, &prevheights, *pindex)) {\n                 error(\"%s: contains a non-BIP68-final transaction\", __func__);\n-                return state.DoS(100, REJECT_INVALID, \"bad-txns-nonfinal\");\n+                return state.Reject(100, REJECT_INVALID, \"bad-txns-nonfinal\");\n             }\n         }\n \n@@ -1986,7 +1986,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n         nSigOpsCost += GetTransactionSigOpCost(tx, view, flags);\n         if (nSigOpsCost > MAX_BLOCK_SIGOPS_COST) {\n             error(\"ConnectBlock(): too many sigops\");\n-            return state.DoS(100, REJECT_INVALID, \"bad-blk-sigops\");\n+            return state.Reject(100, REJECT_INVALID, \"bad-blk-sigops\");\n         }\n \n         txdata.emplace_back(tx);\n@@ -2013,12 +2013,12 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n     if (block.vtx[0]->GetValueOut() > blockReward) {\n         error(\"ConnectBlock(): coinbase pays too much (actual=%d vs limit=%d)\",\n             block.vtx[0]->GetValueOut(), blockReward);\n-        return state.DoS(100, REJECT_INVALID, \"bad-cb-amount\");\n+        return state.Reject(100, REJECT_INVALID, \"bad-cb-amount\");\n     }\n \n     if (!control.Wait()) {\n         error(\"%s: CheckQueue failed\", __func__);\n-        return state.DoS(100, REJECT_INVALID, \"block-validation-failed\");\n+        return state.Reject(100, REJECT_INVALID, \"block-validation-failed\");\n     }\n     int64_t nTime4 = GetTimeMicros(); nTimeVerify += nTime4 - nTime2;\n     LogPrint(BCLog::BENCH, \"    - Verify %u txins: %.2fms (%.3fms/txin) [%.2fs (%.2fms/blk)]\\n\", nInputs - 1, MILLI * (nTime4 - nTime2), nInputs <= 1 ? 0 : MILLI * (nTime4 - nTime2) / (nInputs-1), nTimeVerify * MICRO, nTimeVerify * MILLI / nBlocksTotal);\n@@ -3008,7 +3008,7 @@ static bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state,\n {\n     // Check proof of work matches claimed amount\n     if (fCheckPOW && !CheckProofOfWork(block.GetHash(), block.nBits, consensusParams))\n-        return state.DoS(50, REJECT_INVALID, \"high-hash\", \"proof of work failed\");\n+        return state.Reject(50, REJECT_INVALID, \"high-hash\", \"proof of work failed\");\n \n     return true;\n }\n@@ -3030,13 +3030,13 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n         bool mutated;\n         uint256 hashMerkleRoot2 = BlockMerkleRoot(block, &mutated);\n         if (block.hashMerkleRoot != hashMerkleRoot2)\n-            return state.SetCorruptionPossible().DoS(100, REJECT_INVALID, \"bad-txnmrklroot\", \"hashMerkleRoot mismatch\");\n+            return state.SetCorruptionPossible().Reject(100, REJECT_INVALID, \"bad-txnmrklroot\", \"hashMerkleRoot mismatch\");\n \n         // Check for merkle tree malleability (CVE-2012-2459): repeating sequences\n         // of transactions in a block without affecting the merkle root of a block,\n         // while still invalidating it.\n         if (mutated)\n-            return state.SetCorruptionPossible().DoS(100, REJECT_INVALID, \"bad-txns-duplicate\", \"duplicate transaction\");\n+            return state.SetCorruptionPossible().Reject(100, REJECT_INVALID, \"bad-txns-duplicate\", \"duplicate transaction\");\n     }\n \n     // All potential-corruption validation must be done before we do any\n@@ -3047,19 +3047,19 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n \n     // Size limits\n     if (block.vtx.empty() || block.vtx.size() * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n-        return state.DoS(100, REJECT_INVALID, \"bad-blk-length\", \"size limits failed\");\n+        return state.Reject(100, REJECT_INVALID, \"bad-blk-length\", \"size limits failed\");\n \n     // First transaction must be coinbase, the rest must not be\n     if (block.vtx.empty() || !block.vtx[0]->IsCoinBase())\n-        return state.DoS(100, REJECT_INVALID, \"bad-cb-missing\", \"first tx is not coinbase\");\n+        return state.Reject(100, REJECT_INVALID, \"bad-cb-missing\", \"first tx is not coinbase\");\n     for (unsigned int i = 1; i < block.vtx.size(); i++)\n         if (block.vtx[i]->IsCoinBase())\n-            return state.DoS(100, REJECT_INVALID, \"bad-cb-multiple\", \"more than one coinbase\");\n+            return state.Reject(100, REJECT_INVALID, \"bad-cb-multiple\", \"more than one coinbase\");\n \n     // Check transactions\n     for (const auto& tx : block.vtx)\n         if (!CheckTransaction(*tx, state, false))\n-            return state.DoS(0, state.GetRejectCode(), state.GetRejectReason(),\n+            return state.Reject(0, state.GetRejectCode(), state.GetRejectReason(),\n                 strprintf(\"Transaction check failed (tx hash %s) %s\", tx->GetHash().ToString(), state.GetDebugMessage()));\n \n     unsigned int nSigOps = 0;\n@@ -3068,7 +3068,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n         nSigOps += GetLegacySigOpCount(*tx);\n     }\n     if (nSigOps * WITNESS_SCALE_FACTOR > MAX_BLOCK_SIGOPS_COST)\n-        return state.DoS(100, REJECT_INVALID, \"bad-blk-sigops\", \"out-of-bounds SigOpCount\");\n+        return state.Reject(100, REJECT_INVALID, \"bad-blk-sigops\", \"out-of-bounds SigOpCount\");\n \n     if (fCheckPOW && fCheckMerkleRoot)\n         block.fChecked = true;\n@@ -3155,7 +3155,7 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n     // Check proof of work\n     const Consensus::Params& consensusParams = params.GetConsensus();\n     if (block.nBits != GetNextWorkRequired(pindexPrev, &block, consensusParams))\n-        return state.DoS(100, REJECT_INVALID, \"bad-diffbits\", \"incorrect proof of work\");\n+        return state.Reject(100, REJECT_INVALID, \"bad-diffbits\", \"incorrect proof of work\");\n \n     // Check against checkpoints\n     if (fCheckpointsEnabled) {\n@@ -3165,24 +3165,24 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n         CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(params.Checkpoints());\n         if (pcheckpoint && nHeight < pcheckpoint->nHeight) {\n             error(\"%s: forked chain older than last checkpoint (height %d)\", __func__, nHeight);\n-            return state.DoS(100, REJECT_CHECKPOINT, \"bad-fork-prior-to-checkpoint\");\n+            return state.Reject(100, REJECT_CHECKPOINT, \"bad-fork-prior-to-checkpoint\");\n         }\n     }\n \n     // Check timestamp against prev\n     if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n-        return state.DoS(0, REJECT_INVALID, \"time-too-old\", \"block's timestamp is too early\");\n+        return state.Reject(0, REJECT_INVALID, \"time-too-old\", \"block's timestamp is too early\");\n \n     // Check timestamp\n     if (block.GetBlockTime() > nAdjustedTime + MAX_FUTURE_BLOCK_TIME)\n-        return state.DoS(0, REJECT_INVALID, \"time-too-new\", \"block timestamp too far in the future\");\n+        return state.Reject(0, REJECT_INVALID, \"time-too-new\", \"block timestamp too far in the future\");\n \n     // Reject outdated version blocks when 95% (75% on testnet) of the network has upgraded:\n     // check for version 2, 3 and 4 upgrades\n     if((block.nVersion < 2 && nHeight >= consensusParams.BIP34Height) ||\n        (block.nVersion < 3 && nHeight >= consensusParams.BIP66Height) ||\n        (block.nVersion < 4 && nHeight >= consensusParams.BIP65Height))\n-        return state.DoS(0, REJECT_OBSOLETE, strprintf(\"bad-version(0x%08x)\", block.nVersion),\n+        return state.Reject(0, REJECT_OBSOLETE, strprintf(\"bad-version(0x%08x)\", block.nVersion),\n             strprintf(\"rejected nVersion=0x%08x block\", block.nVersion));\n \n     return true;\n@@ -3211,7 +3211,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     // Check that all transactions are finalized\n     for (const auto& tx : block.vtx) {\n         if (!IsFinalTx(*tx, nHeight, nLockTimeCutoff)) {\n-            return state.DoS(10, REJECT_INVALID, \"bad-txns-nonfinal\", \"non-final transaction\");\n+            return state.Reject(10, REJECT_INVALID, \"bad-txns-nonfinal\", \"non-final transaction\");\n         }\n     }\n \n@@ -3221,7 +3221,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n         CScript expect = CScript() << nHeight;\n         if (block.vtx[0]->vin[0].scriptSig.size() < expect.size() ||\n             !std::equal(expect.begin(), expect.end(), block.vtx[0]->vin[0].scriptSig.begin())) {\n-            return state.DoS(100, REJECT_INVALID, \"bad-cb-height\", \"block height mismatch in coinbase\");\n+            return state.Reject(100, REJECT_INVALID, \"bad-cb-height\", \"block height mismatch in coinbase\");\n         }\n     }\n \n@@ -3243,11 +3243,11 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n             // already does not permit it, it is impossible to trigger in the\n             // witness tree.\n             if (block.vtx[0]->vin[0].scriptWitness.stack.size() != 1 || block.vtx[0]->vin[0].scriptWitness.stack[0].size() != 32) {\n-                return state.SetCorruptionPossible().DoS(100, REJECT_INVALID, \"bad-witness-nonce-size\", strprintf(\"%s : invalid witness reserved value size\", __func__));\n+                return state.SetCorruptionPossible().Reject(100, REJECT_INVALID, \"bad-witness-nonce-size\", strprintf(\"%s : invalid witness reserved value size\", __func__));\n             }\n             CHash256().Write(hashWitness.begin(), 32).Write(&block.vtx[0]->vin[0].scriptWitness.stack[0][0], 32).Finalize(hashWitness.begin());\n             if (memcmp(hashWitness.begin(), &block.vtx[0]->vout[commitpos].scriptPubKey[6], 32)) {\n-                return state.SetCorruptionPossible().DoS(100, REJECT_INVALID, \"bad-witness-merkle-match\", strprintf(\"%s : witness merkle commitment mismatch\", __func__));\n+                return state.SetCorruptionPossible().Reject(100, REJECT_INVALID, \"bad-witness-merkle-match\", strprintf(\"%s : witness merkle commitment mismatch\", __func__));\n             }\n             fHaveWitness = true;\n         }\n@@ -3257,7 +3257,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     if (!fHaveWitness) {\n       for (const auto& tx : block.vtx) {\n             if (tx->HasWitness()) {\n-                return state.SetCorruptionPossible().DoS(100, REJECT_INVALID, \"unexpected-witness\", strprintf(\"%s : unexpected witness data found\", __func__));\n+                return state.SetCorruptionPossible().Reject(100, REJECT_INVALID, \"unexpected-witness\", strprintf(\"%s : unexpected witness data found\", __func__));\n             }\n         }\n     }\n@@ -3269,7 +3269,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     // the block hash, so we couldn't mark the block as permanently\n     // failed).\n     if (GetBlockWeight(block) > MAX_BLOCK_WEIGHT) {\n-        return state.DoS(100, REJECT_INVALID, \"bad-blk-weight\", strprintf(\"%s : weight limit failed\", __func__));\n+        return state.Reject(100, REJECT_INVALID, \"bad-blk-weight\", strprintf(\"%s : weight limit failed\", __func__));\n     }\n \n     return true;\n@@ -3290,7 +3290,7 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n                 *ppindex = pindex;\n             if (pindex->nStatus & BLOCK_FAILED_MASK) {\n                 error(\"%s: block %s is marked invalid\", __func__, hash.ToString());\n-                return state.DoS(0, 0, \"duplicate\");\n+                return state.Reject(0, 0, \"duplicate\");\n             }\n             return true;\n         }\n@@ -3303,12 +3303,12 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n         BlockMap::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\n         if (mi == mapBlockIndex.end()) {\n             error(\"%s: prev block not found\", __func__);\n-            return state.DoS(10, 0, \"prev-blk-not-found\");\n+            return state.Reject(10, 0, \"prev-blk-not-found\");\n         }\n         pindexPrev = (*mi).second;\n         if (pindexPrev->nStatus & BLOCK_FAILED_MASK) {\n             error(\"%s: prev block invalid\", __func__);\n-            return state.DoS(100, REJECT_INVALID, \"bad-prevblk\");\n+            return state.Reject(100, REJECT_INVALID, \"bad-prevblk\");\n         }\n         if (!ContextualCheckBlockHeader(block, state, chainparams, pindexPrev, GetAdjustedTime()))\n             return error(\"%s: Consensus::ContextualCheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));\n@@ -3324,7 +3324,7 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n                         invalid_walk = invalid_walk->pprev;\n                     }\n                     error(\"%s: prev block invalid\", __func__);\n-                    return state.DoS(100, REJECT_INVALID, \"bad-prevblk\");\n+                    return state.Reject(100, REJECT_INVALID, \"bad-prevblk\");\n                 }\n             }\n         }"
      }
    ]
  }
]