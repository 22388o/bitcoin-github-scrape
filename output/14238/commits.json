[
  {
    "sha": "c9ee9a1ae3e5fb440b91889544045f2a8d4071e7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjOWVlOWExYWUzZTVmYjQ0MGI5MTg4OTU0NDA0NWYyYThkNDA3MWU3",
    "commit": {
      "author": {
        "name": "Kostiantyn Stepaniuk",
        "email": "kostya.stepanyuk@gmail.com",
        "date": "2018-09-17T10:15:33Z"
      },
      "committer": {
        "name": "Kostiantyn Stepaniuk",
        "email": "kostya.stepanyuk@gmail.com",
        "date": "2018-09-17T11:58:06Z"
      },
      "message": "Remove unnamed block in SendMessages function\n\nThis unnamed root block doesn't give any benefits as it wraps the entire\nfunction body but having it makes it harder to read this long function\nbecause of extra indentation.",
      "tree": {
        "sha": "6fed8be05454cecf3555ff0324a4ea6cc6dd87f9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6fed8be05454cecf3555ff0324a4ea6cc6dd87f9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c9ee9a1ae3e5fb440b91889544045f2a8d4071e7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c9ee9a1ae3e5fb440b91889544045f2a8d4071e7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c9ee9a1ae3e5fb440b91889544045f2a8d4071e7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c9ee9a1ae3e5fb440b91889544045f2a8d4071e7/comments",
    "author": {
      "login": "kostyantyn",
      "id": 296795,
      "node_id": "MDQ6VXNlcjI5Njc5NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/296795?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kostyantyn",
      "html_url": "https://github.com/kostyantyn",
      "followers_url": "https://api.github.com/users/kostyantyn/followers",
      "following_url": "https://api.github.com/users/kostyantyn/following{/other_user}",
      "gists_url": "https://api.github.com/users/kostyantyn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kostyantyn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kostyantyn/subscriptions",
      "organizations_url": "https://api.github.com/users/kostyantyn/orgs",
      "repos_url": "https://api.github.com/users/kostyantyn/repos",
      "events_url": "https://api.github.com/users/kostyantyn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kostyantyn/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kostyantyn",
      "id": 296795,
      "node_id": "MDQ6VXNlcjI5Njc5NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/296795?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kostyantyn",
      "html_url": "https://github.com/kostyantyn",
      "followers_url": "https://api.github.com/users/kostyantyn/followers",
      "following_url": "https://api.github.com/users/kostyantyn/following{/other_user}",
      "gists_url": "https://api.github.com/users/kostyantyn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kostyantyn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kostyantyn/subscriptions",
      "organizations_url": "https://api.github.com/users/kostyantyn/orgs",
      "repos_url": "https://api.github.com/users/kostyantyn/repos",
      "events_url": "https://api.github.com/users/kostyantyn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kostyantyn/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3832c25f176753b7ddb724c26ee7543fb1e1819e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3832c25f176753b7ddb724c26ee7543fb1e1819e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3832c25f176753b7ddb724c26ee7543fb1e1819e"
      }
    ],
    "stats": {
      "total": 930,
      "additions": 465,
      "deletions": 465
    },
    "files": [
      {
        "sha": "63c2966df268637be8200a29f6d76acf32a1b27e",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 465,
        "deletions": 465,
        "changes": 930,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9ee9a1ae3e5fb440b91889544045f2a8d4071e7/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9ee9a1ae3e5fb440b91889544045f2a8d4071e7/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=c9ee9a1ae3e5fb440b91889544045f2a8d4071e7",
        "patch": "@@ -3235,533 +3235,533 @@ class CompareInvMempoolOrder\n bool PeerLogicValidation::SendMessages(CNode* pto)\n {\n     const Consensus::Params& consensusParams = Params().GetConsensus();\n-    {\n-        // Don't send anything until the version handshake is complete\n-        if (!pto->fSuccessfullyConnected || pto->fDisconnect)\n-            return true;\n \n-        // If we get here, the outgoing message serialization version is set and can't change.\n-        const CNetMsgMaker msgMaker(pto->GetSendVersion());\n+    // Don't send anything until the version handshake is complete\n+    if (!pto->fSuccessfullyConnected || pto->fDisconnect)\n+        return true;\n \n-        //\n-        // Message: ping\n-        //\n-        bool pingSend = false;\n-        if (pto->fPingQueued) {\n-            // RPC ping request by user\n-            pingSend = true;\n-        }\n-        if (pto->nPingNonceSent == 0 && pto->nPingUsecStart + PING_INTERVAL * 1000000 < GetTimeMicros()) {\n-            // Ping automatically sent as a latency probe & keepalive.\n-            pingSend = true;\n-        }\n-        if (pingSend) {\n-            uint64_t nonce = 0;\n-            while (nonce == 0) {\n-                GetRandBytes((unsigned char*)&nonce, sizeof(nonce));\n-            }\n-            pto->fPingQueued = false;\n-            pto->nPingUsecStart = GetTimeMicros();\n-            if (pto->nVersion > BIP0031_VERSION) {\n-                pto->nPingNonceSent = nonce;\n-                connman->PushMessage(pto, msgMaker.Make(NetMsgType::PING, nonce));\n-            } else {\n-                // Peer is too old to support ping command with nonce, pong will never arrive.\n-                pto->nPingNonceSent = 0;\n-                connman->PushMessage(pto, msgMaker.Make(NetMsgType::PING));\n-            }\n+    // If we get here, the outgoing message serialization version is set and can't change.\n+    const CNetMsgMaker msgMaker(pto->GetSendVersion());\n+\n+    //\n+    // Message: ping\n+    //\n+    bool pingSend = false;\n+    if (pto->fPingQueued) {\n+        // RPC ping request by user\n+        pingSend = true;\n+    }\n+    if (pto->nPingNonceSent == 0 && pto->nPingUsecStart + PING_INTERVAL * 1000000 < GetTimeMicros()) {\n+        // Ping automatically sent as a latency probe & keepalive.\n+        pingSend = true;\n+    }\n+    if (pingSend) {\n+        uint64_t nonce = 0;\n+        while (nonce == 0) {\n+            GetRandBytes((unsigned char*)&nonce, sizeof(nonce));\n+        }\n+        pto->fPingQueued = false;\n+        pto->nPingUsecStart = GetTimeMicros();\n+        if (pto->nVersion > BIP0031_VERSION) {\n+            pto->nPingNonceSent = nonce;\n+            connman->PushMessage(pto, msgMaker.Make(NetMsgType::PING, nonce));\n+        } else {\n+            // Peer is too old to support ping command with nonce, pong will never arrive.\n+            pto->nPingNonceSent = 0;\n+            connman->PushMessage(pto, msgMaker.Make(NetMsgType::PING));\n         }\n+    }\n \n-        TRY_LOCK(cs_main, lockMain); // Acquire cs_main for IsInitialBlockDownload() and CNodeState()\n-        if (!lockMain)\n-            return true;\n+    TRY_LOCK(cs_main, lockMain); // Acquire cs_main for IsInitialBlockDownload() and CNodeState()\n+    if (!lockMain)\n+        return true;\n \n-        if (SendRejectsAndCheckIfBanned(pto, connman, m_enable_bip61))\n-            return true;\n-        CNodeState &state = *State(pto->GetId());\n+    if (SendRejectsAndCheckIfBanned(pto, connman, m_enable_bip61))\n+        return true;\n+    CNodeState &state = *State(pto->GetId());\n \n-        // Address refresh broadcast\n-        int64_t nNow = GetTimeMicros();\n-        if (!IsInitialBlockDownload() && pto->nNextLocalAddrSend < nNow) {\n-            AdvertiseLocal(pto);\n-            pto->nNextLocalAddrSend = PoissonNextSend(nNow, AVG_LOCAL_ADDRESS_BROADCAST_INTERVAL);\n-        }\n+    // Address refresh broadcast\n+    int64_t nNow = GetTimeMicros();\n+    if (!IsInitialBlockDownload() && pto->nNextLocalAddrSend < nNow) {\n+        AdvertiseLocal(pto);\n+        pto->nNextLocalAddrSend = PoissonNextSend(nNow, AVG_LOCAL_ADDRESS_BROADCAST_INTERVAL);\n+    }\n \n-        //\n-        // Message: addr\n-        //\n-        if (pto->nNextAddrSend < nNow) {\n-            pto->nNextAddrSend = PoissonNextSend(nNow, AVG_ADDRESS_BROADCAST_INTERVAL);\n-            std::vector<CAddress> vAddr;\n-            vAddr.reserve(pto->vAddrToSend.size());\n-            for (const CAddress& addr : pto->vAddrToSend)\n+    //\n+    // Message: addr\n+    //\n+    if (pto->nNextAddrSend < nNow) {\n+        pto->nNextAddrSend = PoissonNextSend(nNow, AVG_ADDRESS_BROADCAST_INTERVAL);\n+        std::vector<CAddress> vAddr;\n+        vAddr.reserve(pto->vAddrToSend.size());\n+        for (const CAddress& addr : pto->vAddrToSend)\n+        {\n+            if (!pto->addrKnown.contains(addr.GetKey()))\n             {\n-                if (!pto->addrKnown.contains(addr.GetKey()))\n+                pto->addrKnown.insert(addr.GetKey());\n+                vAddr.push_back(addr);\n+                // receiver rejects addr messages larger than 1000\n+                if (vAddr.size() >= 1000)\n                 {\n-                    pto->addrKnown.insert(addr.GetKey());\n-                    vAddr.push_back(addr);\n-                    // receiver rejects addr messages larger than 1000\n-                    if (vAddr.size() >= 1000)\n-                    {\n-                        connman->PushMessage(pto, msgMaker.Make(NetMsgType::ADDR, vAddr));\n-                        vAddr.clear();\n-                    }\n+                    connman->PushMessage(pto, msgMaker.Make(NetMsgType::ADDR, vAddr));\n+                    vAddr.clear();\n                 }\n             }\n-            pto->vAddrToSend.clear();\n-            if (!vAddr.empty())\n-                connman->PushMessage(pto, msgMaker.Make(NetMsgType::ADDR, vAddr));\n-            // we only send the big addr message once\n-            if (pto->vAddrToSend.capacity() > 40)\n-                pto->vAddrToSend.shrink_to_fit();\n-        }\n-\n-        // Start block sync\n-        if (pindexBestHeader == nullptr)\n-            pindexBestHeader = chainActive.Tip();\n-        bool fFetch = state.fPreferredDownload || (nPreferredDownload == 0 && !pto->fClient && !pto->fOneShot); // Download if this is a nice peer, or we have no nice peers and this one might do.\n-        if (!state.fSyncStarted && !pto->fClient && !fImporting && !fReindex) {\n-            // Only actively request headers from a single peer, unless we're close to today.\n-            if ((nSyncStarted == 0 && fFetch) || pindexBestHeader->GetBlockTime() > GetAdjustedTime() - 24 * 60 * 60) {\n-                state.fSyncStarted = true;\n-                state.nHeadersSyncTimeout = GetTimeMicros() + HEADERS_DOWNLOAD_TIMEOUT_BASE + HEADERS_DOWNLOAD_TIMEOUT_PER_HEADER * (GetAdjustedTime() - pindexBestHeader->GetBlockTime())/(consensusParams.nPowTargetSpacing);\n-                nSyncStarted++;\n-                const CBlockIndex *pindexStart = pindexBestHeader;\n-                /* If possible, start at the block preceding the currently\n-                   best known header.  This ensures that we always get a\n-                   non-empty list of headers back as long as the peer\n-                   is up-to-date.  With a non-empty response, we can initialise\n-                   the peer's known best block.  This wouldn't be possible\n-                   if we requested starting at pindexBestHeader and\n-                   got back an empty response.  */\n-                if (pindexStart->pprev)\n-                    pindexStart = pindexStart->pprev;\n-                LogPrint(BCLog::NET, \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, pto->GetId(), pto->nStartingHeight);\n-                connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexStart), uint256()));\n-            }\n-        }\n-\n-        // Resend wallet transactions that haven't gotten in a block yet\n-        // Except during reindex, importing and IBD, when old wallet\n-        // transactions become unconfirmed and spams other nodes.\n-        if (!fReindex && !fImporting && !IsInitialBlockDownload())\n-        {\n-            GetMainSignals().Broadcast(nTimeBestReceived, connman);\n         }\n+        pto->vAddrToSend.clear();\n+        if (!vAddr.empty())\n+            connman->PushMessage(pto, msgMaker.Make(NetMsgType::ADDR, vAddr));\n+        // we only send the big addr message once\n+        if (pto->vAddrToSend.capacity() > 40)\n+            pto->vAddrToSend.shrink_to_fit();\n+    }\n+\n+    // Start block sync\n+    if (pindexBestHeader == nullptr)\n+        pindexBestHeader = chainActive.Tip();\n+    bool fFetch = state.fPreferredDownload || (nPreferredDownload == 0 && !pto->fClient && !pto->fOneShot); // Download if this is a nice peer, or we have no nice peers and this one might do.\n+    if (!state.fSyncStarted && !pto->fClient && !fImporting && !fReindex) {\n+        // Only actively request headers from a single peer, unless we're close to today.\n+        if ((nSyncStarted == 0 && fFetch) || pindexBestHeader->GetBlockTime() > GetAdjustedTime() - 24 * 60 * 60) {\n+            state.fSyncStarted = true;\n+            state.nHeadersSyncTimeout = GetTimeMicros() + HEADERS_DOWNLOAD_TIMEOUT_BASE + HEADERS_DOWNLOAD_TIMEOUT_PER_HEADER * (GetAdjustedTime() - pindexBestHeader->GetBlockTime())/(consensusParams.nPowTargetSpacing);\n+            nSyncStarted++;\n+            const CBlockIndex *pindexStart = pindexBestHeader;\n+            /* If possible, start at the block preceding the currently\n+               best known header.  This ensures that we always get a\n+               non-empty list of headers back as long as the peer\n+               is up-to-date.  With a non-empty response, we can initialise\n+               the peer's known best block.  This wouldn't be possible\n+               if we requested starting at pindexBestHeader and\n+               got back an empty response.  */\n+            if (pindexStart->pprev)\n+                pindexStart = pindexStart->pprev;\n+            LogPrint(BCLog::NET, \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, pto->GetId(), pto->nStartingHeight);\n+            connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexStart), uint256()));\n+        }\n+    }\n+\n+    // Resend wallet transactions that haven't gotten in a block yet\n+    // Except during reindex, importing and IBD, when old wallet\n+    // transactions become unconfirmed and spams other nodes.\n+    if (!fReindex && !fImporting && !IsInitialBlockDownload())\n+    {\n+        GetMainSignals().Broadcast(nTimeBestReceived, connman);\n+    }\n \n-        //\n-        // Try sending block announcements via headers\n-        //\n-        {\n-            // If we have less than MAX_BLOCKS_TO_ANNOUNCE in our\n-            // list of block hashes we're relaying, and our peer wants\n-            // headers announcements, then find the first header\n-            // not yet known to our peer but would connect, and send.\n-            // If no header would connect, or if we have too many\n-            // blocks, or if the peer doesn't want headers, just\n-            // add all to the inv queue.\n-            LOCK(pto->cs_inventory);\n-            std::vector<CBlock> vHeaders;\n-            bool fRevertToInv = ((!state.fPreferHeaders &&\n-                                 (!state.fPreferHeaderAndIDs || pto->vBlockHashesToAnnounce.size() > 1)) ||\n-                                pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n-            const CBlockIndex *pBestIndex = nullptr; // last header queued for delivery\n-            ProcessBlockAvailability(pto->GetId()); // ensure pindexBestKnownBlock is up-to-date\n-\n-            if (!fRevertToInv) {\n-                bool fFoundStartingHeader = false;\n-                // Try to find first header that our peer doesn't have, and\n-                // then send all headers past that one.  If we come across any\n-                // headers that aren't on chainActive, give up.\n-                for (const uint256 &hash : pto->vBlockHashesToAnnounce) {\n-                    const CBlockIndex* pindex = LookupBlockIndex(hash);\n-                    assert(pindex);\n-                    if (chainActive[pindex->nHeight] != pindex) {\n-                        // Bail out if we reorged away from this block\n-                        fRevertToInv = true;\n-                        break;\n-                    }\n-                    if (pBestIndex != nullptr && pindex->pprev != pBestIndex) {\n-                        // This means that the list of blocks to announce don't\n-                        // connect to each other.\n-                        // This shouldn't really be possible to hit during\n-                        // regular operation (because reorgs should take us to\n-                        // a chain that has some block not on the prior chain,\n-                        // which should be caught by the prior check), but one\n-                        // way this could happen is by using invalidateblock /\n-                        // reconsiderblock repeatedly on the tip, causing it to\n-                        // be added multiple times to vBlockHashesToAnnounce.\n-                        // Robustly deal with this rare situation by reverting\n-                        // to an inv.\n-                        fRevertToInv = true;\n-                        break;\n-                    }\n-                    pBestIndex = pindex;\n-                    if (fFoundStartingHeader) {\n-                        // add this to the headers message\n-                        vHeaders.push_back(pindex->GetBlockHeader());\n-                    } else if (PeerHasHeader(&state, pindex)) {\n-                        continue; // keep looking for the first new block\n-                    } else if (pindex->pprev == nullptr || PeerHasHeader(&state, pindex->pprev)) {\n-                        // Peer doesn't have this header but they do have the prior one.\n-                        // Start sending headers.\n-                        fFoundStartingHeader = true;\n-                        vHeaders.push_back(pindex->GetBlockHeader());\n-                    } else {\n-                        // Peer doesn't have this header or the prior one -- nothing will\n-                        // connect, so bail out.\n-                        fRevertToInv = true;\n-                        break;\n-                    }\n+    //\n+    // Try sending block announcements via headers\n+    //\n+    {\n+        // If we have less than MAX_BLOCKS_TO_ANNOUNCE in our\n+        // list of block hashes we're relaying, and our peer wants\n+        // headers announcements, then find the first header\n+        // not yet known to our peer but would connect, and send.\n+        // If no header would connect, or if we have too many\n+        // blocks, or if the peer doesn't want headers, just\n+        // add all to the inv queue.\n+        LOCK(pto->cs_inventory);\n+        std::vector<CBlock> vHeaders;\n+        bool fRevertToInv = ((!state.fPreferHeaders &&\n+                             (!state.fPreferHeaderAndIDs || pto->vBlockHashesToAnnounce.size() > 1)) ||\n+                            pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n+        const CBlockIndex *pBestIndex = nullptr; // last header queued for delivery\n+        ProcessBlockAvailability(pto->GetId()); // ensure pindexBestKnownBlock is up-to-date\n+\n+        if (!fRevertToInv) {\n+            bool fFoundStartingHeader = false;\n+            // Try to find first header that our peer doesn't have, and\n+            // then send all headers past that one.  If we come across any\n+            // headers that aren't on chainActive, give up.\n+            for (const uint256 &hash : pto->vBlockHashesToAnnounce) {\n+                const CBlockIndex* pindex = LookupBlockIndex(hash);\n+                assert(pindex);\n+                if (chainActive[pindex->nHeight] != pindex) {\n+                    // Bail out if we reorged away from this block\n+                    fRevertToInv = true;\n+                    break;\n+                }\n+                if (pBestIndex != nullptr && pindex->pprev != pBestIndex) {\n+                    // This means that the list of blocks to announce don't\n+                    // connect to each other.\n+                    // This shouldn't really be possible to hit during\n+                    // regular operation (because reorgs should take us to\n+                    // a chain that has some block not on the prior chain,\n+                    // which should be caught by the prior check), but one\n+                    // way this could happen is by using invalidateblock /\n+                    // reconsiderblock repeatedly on the tip, causing it to\n+                    // be added multiple times to vBlockHashesToAnnounce.\n+                    // Robustly deal with this rare situation by reverting\n+                    // to an inv.\n+                    fRevertToInv = true;\n+                    break;\n+                }\n+                pBestIndex = pindex;\n+                if (fFoundStartingHeader) {\n+                    // add this to the headers message\n+                    vHeaders.push_back(pindex->GetBlockHeader());\n+                } else if (PeerHasHeader(&state, pindex)) {\n+                    continue; // keep looking for the first new block\n+                } else if (pindex->pprev == nullptr || PeerHasHeader(&state, pindex->pprev)) {\n+                    // Peer doesn't have this header but they do have the prior one.\n+                    // Start sending headers.\n+                    fFoundStartingHeader = true;\n+                    vHeaders.push_back(pindex->GetBlockHeader());\n+                } else {\n+                    // Peer doesn't have this header or the prior one -- nothing will\n+                    // connect, so bail out.\n+                    fRevertToInv = true;\n+                    break;\n                 }\n             }\n-            if (!fRevertToInv && !vHeaders.empty()) {\n-                if (vHeaders.size() == 1 && state.fPreferHeaderAndIDs) {\n-                    // We only send up to 1 block as header-and-ids, as otherwise\n-                    // probably means we're doing an initial-ish-sync or they're slow\n-                    LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", __func__,\n-                            vHeaders.front().GetHash().ToString(), pto->GetId());\n+        }\n+        if (!fRevertToInv && !vHeaders.empty()) {\n+            if (vHeaders.size() == 1 && state.fPreferHeaderAndIDs) {\n+                // We only send up to 1 block as header-and-ids, as otherwise\n+                // probably means we're doing an initial-ish-sync or they're slow\n+                LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", __func__,\n+                        vHeaders.front().GetHash().ToString(), pto->GetId());\n \n-                    int nSendFlags = state.fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n+                int nSendFlags = state.fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n \n-                    bool fGotBlockFromCache = false;\n-                    {\n-                        LOCK(cs_most_recent_block);\n-                        if (most_recent_block_hash == pBestIndex->GetBlockHash()) {\n-                            if (state.fWantsCmpctWitness || !fWitnessesPresentInMostRecentCompactBlock)\n-                                connman->PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *most_recent_compact_block));\n-                            else {\n-                                CBlockHeaderAndShortTxIDs cmpctblock(*most_recent_block, state.fWantsCmpctWitness);\n-                                connman->PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n-                            }\n-                            fGotBlockFromCache = true;\n+                bool fGotBlockFromCache = false;\n+                {\n+                    LOCK(cs_most_recent_block);\n+                    if (most_recent_block_hash == pBestIndex->GetBlockHash()) {\n+                        if (state.fWantsCmpctWitness || !fWitnessesPresentInMostRecentCompactBlock)\n+                            connman->PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *most_recent_compact_block));\n+                        else {\n+                            CBlockHeaderAndShortTxIDs cmpctblock(*most_recent_block, state.fWantsCmpctWitness);\n+                            connman->PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n                         }\n+                        fGotBlockFromCache = true;\n                     }\n-                    if (!fGotBlockFromCache) {\n-                        CBlock block;\n-                        bool ret = ReadBlockFromDisk(block, pBestIndex, consensusParams);\n-                        assert(ret);\n-                        CBlockHeaderAndShortTxIDs cmpctblock(block, state.fWantsCmpctWitness);\n-                        connman->PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n-                    }\n-                    state.pindexBestHeaderSent = pBestIndex;\n-                } else if (state.fPreferHeaders) {\n-                    if (vHeaders.size() > 1) {\n-                        LogPrint(BCLog::NET, \"%s: %u headers, range (%s, %s), to peer=%d\\n\", __func__,\n-                                vHeaders.size(),\n-                                vHeaders.front().GetHash().ToString(),\n-                                vHeaders.back().GetHash().ToString(), pto->GetId());\n-                    } else {\n-                        LogPrint(BCLog::NET, \"%s: sending header %s to peer=%d\\n\", __func__,\n-                                vHeaders.front().GetHash().ToString(), pto->GetId());\n-                    }\n-                    connman->PushMessage(pto, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n-                    state.pindexBestHeaderSent = pBestIndex;\n-                } else\n-                    fRevertToInv = true;\n-            }\n-            if (fRevertToInv) {\n-                // If falling back to using an inv, just try to inv the tip.\n-                // The last entry in vBlockHashesToAnnounce was our tip at some point\n-                // in the past.\n-                if (!pto->vBlockHashesToAnnounce.empty()) {\n-                    const uint256 &hashToAnnounce = pto->vBlockHashesToAnnounce.back();\n-                    const CBlockIndex* pindex = LookupBlockIndex(hashToAnnounce);\n-                    assert(pindex);\n-\n-                    // Warn if we're announcing a block that is not on the main chain.\n-                    // This should be very rare and could be optimized out.\n-                    // Just log for now.\n-                    if (chainActive[pindex->nHeight] != pindex) {\n-                        LogPrint(BCLog::NET, \"Announcing block %s not on main chain (tip=%s)\\n\",\n-                            hashToAnnounce.ToString(), chainActive.Tip()->GetBlockHash().ToString());\n-                    }\n+                }\n+                if (!fGotBlockFromCache) {\n+                    CBlock block;\n+                    bool ret = ReadBlockFromDisk(block, pBestIndex, consensusParams);\n+                    assert(ret);\n+                    CBlockHeaderAndShortTxIDs cmpctblock(block, state.fWantsCmpctWitness);\n+                    connman->PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n+                }\n+                state.pindexBestHeaderSent = pBestIndex;\n+            } else if (state.fPreferHeaders) {\n+                if (vHeaders.size() > 1) {\n+                    LogPrint(BCLog::NET, \"%s: %u headers, range (%s, %s), to peer=%d\\n\", __func__,\n+                            vHeaders.size(),\n+                            vHeaders.front().GetHash().ToString(),\n+                            vHeaders.back().GetHash().ToString(), pto->GetId());\n+                } else {\n+                    LogPrint(BCLog::NET, \"%s: sending header %s to peer=%d\\n\", __func__,\n+                            vHeaders.front().GetHash().ToString(), pto->GetId());\n+                }\n+                connman->PushMessage(pto, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n+                state.pindexBestHeaderSent = pBestIndex;\n+            } else\n+                fRevertToInv = true;\n+        }\n+        if (fRevertToInv) {\n+            // If falling back to using an inv, just try to inv the tip.\n+            // The last entry in vBlockHashesToAnnounce was our tip at some point\n+            // in the past.\n+            if (!pto->vBlockHashesToAnnounce.empty()) {\n+                const uint256 &hashToAnnounce = pto->vBlockHashesToAnnounce.back();\n+                const CBlockIndex* pindex = LookupBlockIndex(hashToAnnounce);\n+                assert(pindex);\n+\n+                // Warn if we're announcing a block that is not on the main chain.\n+                // This should be very rare and could be optimized out.\n+                // Just log for now.\n+                if (chainActive[pindex->nHeight] != pindex) {\n+                    LogPrint(BCLog::NET, \"Announcing block %s not on main chain (tip=%s)\\n\",\n+                        hashToAnnounce.ToString(), chainActive.Tip()->GetBlockHash().ToString());\n+                }\n \n-                    // If the peer's chain has this block, don't inv it back.\n-                    if (!PeerHasHeader(&state, pindex)) {\n-                        pto->PushInventory(CInv(MSG_BLOCK, hashToAnnounce));\n-                        LogPrint(BCLog::NET, \"%s: sending inv peer=%d hash=%s\\n\", __func__,\n-                            pto->GetId(), hashToAnnounce.ToString());\n-                    }\n+                // If the peer's chain has this block, don't inv it back.\n+                if (!PeerHasHeader(&state, pindex)) {\n+                    pto->PushInventory(CInv(MSG_BLOCK, hashToAnnounce));\n+                    LogPrint(BCLog::NET, \"%s: sending inv peer=%d hash=%s\\n\", __func__,\n+                        pto->GetId(), hashToAnnounce.ToString());\n                 }\n             }\n-            pto->vBlockHashesToAnnounce.clear();\n         }\n+        pto->vBlockHashesToAnnounce.clear();\n+    }\n \n-        //\n-        // Message: inventory\n-        //\n-        std::vector<CInv> vInv;\n-        {\n-            LOCK(pto->cs_inventory);\n-            vInv.reserve(std::max<size_t>(pto->vInventoryBlockToSend.size(), INVENTORY_BROADCAST_MAX));\n+    //\n+    // Message: inventory\n+    //\n+    std::vector<CInv> vInv;\n+    {\n+        LOCK(pto->cs_inventory);\n+        vInv.reserve(std::max<size_t>(pto->vInventoryBlockToSend.size(), INVENTORY_BROADCAST_MAX));\n \n-            // Add blocks\n-            for (const uint256& hash : pto->vInventoryBlockToSend) {\n-                vInv.push_back(CInv(MSG_BLOCK, hash));\n-                if (vInv.size() == MAX_INV_SZ) {\n-                    connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n-                    vInv.clear();\n-                }\n+        // Add blocks\n+        for (const uint256& hash : pto->vInventoryBlockToSend) {\n+            vInv.push_back(CInv(MSG_BLOCK, hash));\n+            if (vInv.size() == MAX_INV_SZ) {\n+                connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n+                vInv.clear();\n             }\n-            pto->vInventoryBlockToSend.clear();\n+        }\n+        pto->vInventoryBlockToSend.clear();\n \n-            // Check whether periodic sends should happen\n-            bool fSendTrickle = pto->fWhitelisted;\n-            if (pto->nNextInvSend < nNow) {\n-                fSendTrickle = true;\n-                if (pto->fInbound) {\n-                    pto->nNextInvSend = connman->PoissonNextSendInbound(nNow, INVENTORY_BROADCAST_INTERVAL);\n-                } else {\n-                    // Use half the delay for outbound peers, as there is less privacy concern for them.\n-                    pto->nNextInvSend = PoissonNextSend(nNow, INVENTORY_BROADCAST_INTERVAL >> 1);\n-                }\n+        // Check whether periodic sends should happen\n+        bool fSendTrickle = pto->fWhitelisted;\n+        if (pto->nNextInvSend < nNow) {\n+            fSendTrickle = true;\n+            if (pto->fInbound) {\n+                pto->nNextInvSend = connman->PoissonNextSendInbound(nNow, INVENTORY_BROADCAST_INTERVAL);\n+            } else {\n+                // Use half the delay for outbound peers, as there is less privacy concern for them.\n+                pto->nNextInvSend = PoissonNextSend(nNow, INVENTORY_BROADCAST_INTERVAL >> 1);\n             }\n+        }\n \n-            // Time to send but the peer has requested we not relay transactions.\n-            if (fSendTrickle) {\n-                LOCK(pto->cs_filter);\n-                if (!pto->fRelayTxes) pto->setInventoryTxToSend.clear();\n-            }\n+        // Time to send but the peer has requested we not relay transactions.\n+        if (fSendTrickle) {\n+            LOCK(pto->cs_filter);\n+            if (!pto->fRelayTxes) pto->setInventoryTxToSend.clear();\n+        }\n \n-            // Respond to BIP35 mempool requests\n-            if (fSendTrickle && pto->fSendMempool) {\n-                auto vtxinfo = mempool.infoAll();\n-                pto->fSendMempool = false;\n-                CAmount filterrate = 0;\n-                {\n-                    LOCK(pto->cs_feeFilter);\n-                    filterrate = pto->minFeeFilter;\n-                }\n+        // Respond to BIP35 mempool requests\n+        if (fSendTrickle && pto->fSendMempool) {\n+            auto vtxinfo = mempool.infoAll();\n+            pto->fSendMempool = false;\n+            CAmount filterrate = 0;\n+            {\n+                LOCK(pto->cs_feeFilter);\n+                filterrate = pto->minFeeFilter;\n+            }\n \n-                LOCK(pto->cs_filter);\n+            LOCK(pto->cs_filter);\n \n-                for (const auto& txinfo : vtxinfo) {\n-                    const uint256& hash = txinfo.tx->GetHash();\n-                    CInv inv(MSG_TX, hash);\n-                    pto->setInventoryTxToSend.erase(hash);\n-                    if (filterrate) {\n-                        if (txinfo.feeRate.GetFeePerK() < filterrate)\n-                            continue;\n-                    }\n-                    if (pto->pfilter) {\n-                        if (!pto->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n-                    }\n-                    pto->filterInventoryKnown.insert(hash);\n-                    vInv.push_back(inv);\n-                    if (vInv.size() == MAX_INV_SZ) {\n-                        connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n-                        vInv.clear();\n-                    }\n+            for (const auto& txinfo : vtxinfo) {\n+                const uint256& hash = txinfo.tx->GetHash();\n+                CInv inv(MSG_TX, hash);\n+                pto->setInventoryTxToSend.erase(hash);\n+                if (filterrate) {\n+                    if (txinfo.feeRate.GetFeePerK() < filterrate)\n+                        continue;\n+                }\n+                if (pto->pfilter) {\n+                    if (!pto->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n+                }\n+                pto->filterInventoryKnown.insert(hash);\n+                vInv.push_back(inv);\n+                if (vInv.size() == MAX_INV_SZ) {\n+                    connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n+                    vInv.clear();\n                 }\n-                pto->timeLastMempoolReq = GetTime();\n             }\n+            pto->timeLastMempoolReq = GetTime();\n+        }\n \n-            // Determine transactions to relay\n-            if (fSendTrickle) {\n-                // Produce a vector with all candidates for sending\n-                std::vector<std::set<uint256>::iterator> vInvTx;\n-                vInvTx.reserve(pto->setInventoryTxToSend.size());\n-                for (std::set<uint256>::iterator it = pto->setInventoryTxToSend.begin(); it != pto->setInventoryTxToSend.end(); it++) {\n-                    vInvTx.push_back(it);\n+        // Determine transactions to relay\n+        if (fSendTrickle) {\n+            // Produce a vector with all candidates for sending\n+            std::vector<std::set<uint256>::iterator> vInvTx;\n+            vInvTx.reserve(pto->setInventoryTxToSend.size());\n+            for (std::set<uint256>::iterator it = pto->setInventoryTxToSend.begin(); it != pto->setInventoryTxToSend.end(); it++) {\n+                vInvTx.push_back(it);\n+            }\n+            CAmount filterrate = 0;\n+            {\n+                LOCK(pto->cs_feeFilter);\n+                filterrate = pto->minFeeFilter;\n+            }\n+            // Topologically and fee-rate sort the inventory we send for privacy and priority reasons.\n+            // A heap is used so that not all items need sorting if only a few are being sent.\n+            CompareInvMempoolOrder compareInvMempoolOrder(&mempool);\n+            std::make_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n+            // No reason to drain out at many times the network's capacity,\n+            // especially since we have many peers and some will draw much shorter delays.\n+            unsigned int nRelayedTransactions = 0;\n+            LOCK(pto->cs_filter);\n+            while (!vInvTx.empty() && nRelayedTransactions < INVENTORY_BROADCAST_MAX) {\n+                // Fetch the top element from the heap\n+                std::pop_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n+                std::set<uint256>::iterator it = vInvTx.back();\n+                vInvTx.pop_back();\n+                uint256 hash = *it;\n+                // Remove it from the to-be-sent set\n+                pto->setInventoryTxToSend.erase(it);\n+                // Check if not in the filter already\n+                if (pto->filterInventoryKnown.contains(hash)) {\n+                    continue;\n                 }\n-                CAmount filterrate = 0;\n-                {\n-                    LOCK(pto->cs_feeFilter);\n-                    filterrate = pto->minFeeFilter;\n+                // Not in the mempool anymore? don't bother sending it.\n+                auto txinfo = mempool.info(hash);\n+                if (!txinfo.tx) {\n+                    continue;\n                 }\n-                // Topologically and fee-rate sort the inventory we send for privacy and priority reasons.\n-                // A heap is used so that not all items need sorting if only a few are being sent.\n-                CompareInvMempoolOrder compareInvMempoolOrder(&mempool);\n-                std::make_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n-                // No reason to drain out at many times the network's capacity,\n-                // especially since we have many peers and some will draw much shorter delays.\n-                unsigned int nRelayedTransactions = 0;\n-                LOCK(pto->cs_filter);\n-                while (!vInvTx.empty() && nRelayedTransactions < INVENTORY_BROADCAST_MAX) {\n-                    // Fetch the top element from the heap\n-                    std::pop_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n-                    std::set<uint256>::iterator it = vInvTx.back();\n-                    vInvTx.pop_back();\n-                    uint256 hash = *it;\n-                    // Remove it from the to-be-sent set\n-                    pto->setInventoryTxToSend.erase(it);\n-                    // Check if not in the filter already\n-                    if (pto->filterInventoryKnown.contains(hash)) {\n-                        continue;\n-                    }\n-                    // Not in the mempool anymore? don't bother sending it.\n-                    auto txinfo = mempool.info(hash);\n-                    if (!txinfo.tx) {\n-                        continue;\n-                    }\n-                    if (filterrate && txinfo.feeRate.GetFeePerK() < filterrate) {\n-                        continue;\n-                    }\n-                    if (pto->pfilter && !pto->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n-                    // Send\n-                    vInv.push_back(CInv(MSG_TX, hash));\n-                    nRelayedTransactions++;\n+                if (filterrate && txinfo.feeRate.GetFeePerK() < filterrate) {\n+                    continue;\n+                }\n+                if (pto->pfilter && !pto->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n+                // Send\n+                vInv.push_back(CInv(MSG_TX, hash));\n+                nRelayedTransactions++;\n+                {\n+                    // Expire old relay messages\n+                    while (!vRelayExpiration.empty() && vRelayExpiration.front().first < nNow)\n                     {\n-                        // Expire old relay messages\n-                        while (!vRelayExpiration.empty() && vRelayExpiration.front().first < nNow)\n-                        {\n-                            mapRelay.erase(vRelayExpiration.front().second);\n-                            vRelayExpiration.pop_front();\n-                        }\n-\n-                        auto ret = mapRelay.insert(std::make_pair(hash, std::move(txinfo.tx)));\n-                        if (ret.second) {\n-                            vRelayExpiration.push_back(std::make_pair(nNow + 15 * 60 * 1000000, ret.first));\n-                        }\n+                        mapRelay.erase(vRelayExpiration.front().second);\n+                        vRelayExpiration.pop_front();\n                     }\n-                    if (vInv.size() == MAX_INV_SZ) {\n-                        connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n-                        vInv.clear();\n+\n+                    auto ret = mapRelay.insert(std::make_pair(hash, std::move(txinfo.tx)));\n+                    if (ret.second) {\n+                        vRelayExpiration.push_back(std::make_pair(nNow + 15 * 60 * 1000000, ret.first));\n                     }\n-                    pto->filterInventoryKnown.insert(hash);\n                 }\n+                if (vInv.size() == MAX_INV_SZ) {\n+                    connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n+                    vInv.clear();\n+                }\n+                pto->filterInventoryKnown.insert(hash);\n             }\n         }\n-        if (!vInv.empty())\n-            connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n+    }\n+    if (!vInv.empty())\n+        connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n-        // Detect whether we're stalling\n-        nNow = GetTimeMicros();\n-        if (state.nStallingSince && state.nStallingSince < nNow - 1000000 * BLOCK_STALLING_TIMEOUT) {\n-            // Stalling only triggers when the block download window cannot move. During normal steady state,\n-            // the download window should be much larger than the to-be-downloaded set of blocks, so disconnection\n-            // should only happen during initial block download.\n-            LogPrintf(\"Peer=%d is stalling block download, disconnecting\\n\", pto->GetId());\n+    // Detect whether we're stalling\n+    nNow = GetTimeMicros();\n+    if (state.nStallingSince && state.nStallingSince < nNow - 1000000 * BLOCK_STALLING_TIMEOUT) {\n+        // Stalling only triggers when the block download window cannot move. During normal steady state,\n+        // the download window should be much larger than the to-be-downloaded set of blocks, so disconnection\n+        // should only happen during initial block download.\n+        LogPrintf(\"Peer=%d is stalling block download, disconnecting\\n\", pto->GetId());\n+        pto->fDisconnect = true;\n+        return true;\n+    }\n+    // In case there is a block that has been in flight from this peer for 2 + 0.5 * N times the block interval\n+    // (with N the number of peers from which we're downloading validated blocks), disconnect due to timeout.\n+    // We compensate for other peers to prevent killing off peers due to our own downstream link\n+    // being saturated. We only count validated in-flight blocks so peers can't advertise non-existing block hashes\n+    // to unreasonably increase our timeout.\n+    if (state.vBlocksInFlight.size() > 0) {\n+        QueuedBlock &queuedBlock = state.vBlocksInFlight.front();\n+        int nOtherPeersWithValidatedDownloads = nPeersWithValidatedDownloads - (state.nBlocksInFlightValidHeaders > 0);\n+        if (nNow > state.nDownloadingSince + consensusParams.nPowTargetSpacing * (BLOCK_DOWNLOAD_TIMEOUT_BASE + BLOCK_DOWNLOAD_TIMEOUT_PER_PEER * nOtherPeersWithValidatedDownloads)) {\n+            LogPrintf(\"Timeout downloading block %s from peer=%d, disconnecting\\n\", queuedBlock.hash.ToString(), pto->GetId());\n             pto->fDisconnect = true;\n             return true;\n         }\n-        // In case there is a block that has been in flight from this peer for 2 + 0.5 * N times the block interval\n-        // (with N the number of peers from which we're downloading validated blocks), disconnect due to timeout.\n-        // We compensate for other peers to prevent killing off peers due to our own downstream link\n-        // being saturated. We only count validated in-flight blocks so peers can't advertise non-existing block hashes\n-        // to unreasonably increase our timeout.\n-        if (state.vBlocksInFlight.size() > 0) {\n-            QueuedBlock &queuedBlock = state.vBlocksInFlight.front();\n-            int nOtherPeersWithValidatedDownloads = nPeersWithValidatedDownloads - (state.nBlocksInFlightValidHeaders > 0);\n-            if (nNow > state.nDownloadingSince + consensusParams.nPowTargetSpacing * (BLOCK_DOWNLOAD_TIMEOUT_BASE + BLOCK_DOWNLOAD_TIMEOUT_PER_PEER * nOtherPeersWithValidatedDownloads)) {\n-                LogPrintf(\"Timeout downloading block %s from peer=%d, disconnecting\\n\", queuedBlock.hash.ToString(), pto->GetId());\n-                pto->fDisconnect = true;\n-                return true;\n-            }\n-        }\n-        // Check for headers sync timeouts\n-        if (state.fSyncStarted && state.nHeadersSyncTimeout < std::numeric_limits<int64_t>::max()) {\n-            // Detect whether this is a stalling initial-headers-sync peer\n-            if (pindexBestHeader->GetBlockTime() <= GetAdjustedTime() - 24*60*60) {\n-                if (nNow > state.nHeadersSyncTimeout && nSyncStarted == 1 && (nPreferredDownload - state.fPreferredDownload >= 1)) {\n-                    // Disconnect a (non-whitelisted) peer if it is our only sync peer,\n-                    // and we have others we could be using instead.\n-                    // Note: If all our peers are inbound, then we won't\n-                    // disconnect our sync peer for stalling; we have bigger\n-                    // problems if we can't get any outbound peers.\n-                    if (!pto->fWhitelisted) {\n-                        LogPrintf(\"Timeout downloading headers from peer=%d, disconnecting\\n\", pto->GetId());\n-                        pto->fDisconnect = true;\n-                        return true;\n-                    } else {\n-                        LogPrintf(\"Timeout downloading headers from whitelisted peer=%d, not disconnecting\\n\", pto->GetId());\n-                        // Reset the headers sync state so that we have a\n-                        // chance to try downloading from a different peer.\n-                        // Note: this will also result in at least one more\n-                        // getheaders message to be sent to\n-                        // this peer (eventually).\n-                        state.fSyncStarted = false;\n-                        nSyncStarted--;\n-                        state.nHeadersSyncTimeout = 0;\n-                    }\n+    }\n+    // Check for headers sync timeouts\n+    if (state.fSyncStarted && state.nHeadersSyncTimeout < std::numeric_limits<int64_t>::max()) {\n+        // Detect whether this is a stalling initial-headers-sync peer\n+        if (pindexBestHeader->GetBlockTime() <= GetAdjustedTime() - 24*60*60) {\n+            if (nNow > state.nHeadersSyncTimeout && nSyncStarted == 1 && (nPreferredDownload - state.fPreferredDownload >= 1)) {\n+                // Disconnect a (non-whitelisted) peer if it is our only sync peer,\n+                // and we have others we could be using instead.\n+                // Note: If all our peers are inbound, then we won't\n+                // disconnect our sync peer for stalling; we have bigger\n+                // problems if we can't get any outbound peers.\n+                if (!pto->fWhitelisted) {\n+                    LogPrintf(\"Timeout downloading headers from peer=%d, disconnecting\\n\", pto->GetId());\n+                    pto->fDisconnect = true;\n+                    return true;\n+                } else {\n+                    LogPrintf(\"Timeout downloading headers from whitelisted peer=%d, not disconnecting\\n\", pto->GetId());\n+                    // Reset the headers sync state so that we have a\n+                    // chance to try downloading from a different peer.\n+                    // Note: this will also result in at least one more\n+                    // getheaders message to be sent to\n+                    // this peer (eventually).\n+                    state.fSyncStarted = false;\n+                    nSyncStarted--;\n+                    state.nHeadersSyncTimeout = 0;\n                 }\n-            } else {\n-                // After we've caught up once, reset the timeout so we can't trigger\n-                // disconnect later.\n-                state.nHeadersSyncTimeout = std::numeric_limits<int64_t>::max();\n             }\n+        } else {\n+            // After we've caught up once, reset the timeout so we can't trigger\n+            // disconnect later.\n+            state.nHeadersSyncTimeout = std::numeric_limits<int64_t>::max();\n         }\n+    }\n \n-        // Check that outbound peers have reasonable chains\n-        // GetTime() is used by this anti-DoS logic so we can test this using mocktime\n-        ConsiderEviction(pto, GetTime());\n+    // Check that outbound peers have reasonable chains\n+    // GetTime() is used by this anti-DoS logic so we can test this using mocktime\n+    ConsiderEviction(pto, GetTime());\n \n-        //\n-        // Message: getdata (blocks)\n-        //\n-        std::vector<CInv> vGetData;\n-        if (!pto->fClient && ((fFetch && !pto->m_limited_node) || !IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n-            std::vector<const CBlockIndex*> vToDownload;\n-            NodeId staller = -1;\n-            FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams);\n-            for (const CBlockIndex *pindex : vToDownload) {\n-                uint32_t nFetchFlags = GetFetchFlags(pto);\n-                vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n-                MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), pindex);\n-                LogPrint(BCLog::NET, \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n-                    pindex->nHeight, pto->GetId());\n-            }\n-            if (state.nBlocksInFlight == 0 && staller != -1) {\n-                if (State(staller)->nStallingSince == 0) {\n-                    State(staller)->nStallingSince = nNow;\n-                    LogPrint(BCLog::NET, \"Stall started peer=%d\\n\", staller);\n-                }\n+    //\n+    // Message: getdata (blocks)\n+    //\n+    std::vector<CInv> vGetData;\n+    if (!pto->fClient && ((fFetch && !pto->m_limited_node) || !IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+        std::vector<const CBlockIndex*> vToDownload;\n+        NodeId staller = -1;\n+        FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams);\n+        for (const CBlockIndex *pindex : vToDownload) {\n+            uint32_t nFetchFlags = GetFetchFlags(pto);\n+            vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n+            MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), pindex);\n+            LogPrint(BCLog::NET, \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n+                pindex->nHeight, pto->GetId());\n+        }\n+        if (state.nBlocksInFlight == 0 && staller != -1) {\n+            if (State(staller)->nStallingSince == 0) {\n+                State(staller)->nStallingSince = nNow;\n+                LogPrint(BCLog::NET, \"Stall started peer=%d\\n\", staller);\n             }\n         }\n+    }\n \n-        //\n-        // Message: getdata (non-blocks)\n-        //\n-        while (!pto->mapAskFor.empty() && (*pto->mapAskFor.begin()).first <= nNow)\n+    //\n+    // Message: getdata (non-blocks)\n+    //\n+    while (!pto->mapAskFor.empty() && (*pto->mapAskFor.begin()).first <= nNow)\n+    {\n+        const CInv& inv = (*pto->mapAskFor.begin()).second;\n+        if (!AlreadyHave(inv))\n         {\n-            const CInv& inv = (*pto->mapAskFor.begin()).second;\n-            if (!AlreadyHave(inv))\n+            LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->GetId());\n+            vGetData.push_back(inv);\n+            if (vGetData.size() >= 1000)\n             {\n-                LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->GetId());\n-                vGetData.push_back(inv);\n-                if (vGetData.size() >= 1000)\n-                {\n-                    connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n-                    vGetData.clear();\n-                }\n-            } else {\n-                //If we're not going to ask, don't expect a response.\n-                pto->setAskFor.erase(inv.hash);\n+                connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n+                vGetData.clear();\n             }\n-            pto->mapAskFor.erase(pto->mapAskFor.begin());\n+        } else {\n+            //If we're not going to ask, don't expect a response.\n+            pto->setAskFor.erase(inv.hash);\n         }\n-        if (!vGetData.empty())\n-            connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n+        pto->mapAskFor.erase(pto->mapAskFor.begin());\n+    }\n+    if (!vGetData.empty())\n+        connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n \n-        //\n-        // Message: feefilter\n-        //\n-        // We don't want white listed peers to filter txs to us if we have -whitelistforcerelay\n-        if (pto->nVersion >= FEEFILTER_VERSION && gArgs.GetBoolArg(\"-feefilter\", DEFAULT_FEEFILTER) &&\n-            !(pto->fWhitelisted && gArgs.GetBoolArg(\"-whitelistforcerelay\", DEFAULT_WHITELISTFORCERELAY))) {\n-            CAmount currentFilter = mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFeePerK();\n-            int64_t timeNow = GetTimeMicros();\n-            if (timeNow > pto->nextSendTimeFeeFilter) {\n-                static CFeeRate default_feerate(DEFAULT_MIN_RELAY_TX_FEE);\n-                static FeeFilterRounder filterRounder(default_feerate);\n-                CAmount filterToSend = filterRounder.round(currentFilter);\n-                // We always have a fee filter of at least minRelayTxFee\n-                filterToSend = std::max(filterToSend, ::minRelayTxFee.GetFeePerK());\n-                if (filterToSend != pto->lastSentFeeFilter) {\n-                    connman->PushMessage(pto, msgMaker.Make(NetMsgType::FEEFILTER, filterToSend));\n-                    pto->lastSentFeeFilter = filterToSend;\n-                }\n-                pto->nextSendTimeFeeFilter = PoissonNextSend(timeNow, AVG_FEEFILTER_BROADCAST_INTERVAL);\n-            }\n-            // If the fee filter has changed substantially and it's still more than MAX_FEEFILTER_CHANGE_DELAY\n-            // until scheduled broadcast, then move the broadcast to within MAX_FEEFILTER_CHANGE_DELAY.\n-            else if (timeNow + MAX_FEEFILTER_CHANGE_DELAY * 1000000 < pto->nextSendTimeFeeFilter &&\n-                     (currentFilter < 3 * pto->lastSentFeeFilter / 4 || currentFilter > 4 * pto->lastSentFeeFilter / 3)) {\n-                pto->nextSendTimeFeeFilter = timeNow + GetRandInt(MAX_FEEFILTER_CHANGE_DELAY) * 1000000;\n-            }\n+    //\n+    // Message: feefilter\n+    //\n+    // We don't want white listed peers to filter txs to us if we have -whitelistforcerelay\n+    if (pto->nVersion >= FEEFILTER_VERSION && gArgs.GetBoolArg(\"-feefilter\", DEFAULT_FEEFILTER) &&\n+        !(pto->fWhitelisted && gArgs.GetBoolArg(\"-whitelistforcerelay\", DEFAULT_WHITELISTFORCERELAY))) {\n+        CAmount currentFilter = mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFeePerK();\n+        int64_t timeNow = GetTimeMicros();\n+        if (timeNow > pto->nextSendTimeFeeFilter) {\n+            static CFeeRate default_feerate(DEFAULT_MIN_RELAY_TX_FEE);\n+            static FeeFilterRounder filterRounder(default_feerate);\n+            CAmount filterToSend = filterRounder.round(currentFilter);\n+            // We always have a fee filter of at least minRelayTxFee\n+            filterToSend = std::max(filterToSend, ::minRelayTxFee.GetFeePerK());\n+            if (filterToSend != pto->lastSentFeeFilter) {\n+                connman->PushMessage(pto, msgMaker.Make(NetMsgType::FEEFILTER, filterToSend));\n+                pto->lastSentFeeFilter = filterToSend;\n+            }\n+            pto->nextSendTimeFeeFilter = PoissonNextSend(timeNow, AVG_FEEFILTER_BROADCAST_INTERVAL);\n+        }\n+        // If the fee filter has changed substantially and it's still more than MAX_FEEFILTER_CHANGE_DELAY\n+        // until scheduled broadcast, then move the broadcast to within MAX_FEEFILTER_CHANGE_DELAY.\n+        else if (timeNow + MAX_FEEFILTER_CHANGE_DELAY * 1000000 < pto->nextSendTimeFeeFilter &&\n+                 (currentFilter < 3 * pto->lastSentFeeFilter / 4 || currentFilter > 4 * pto->lastSentFeeFilter / 3)) {\n+            pto->nextSendTimeFeeFilter = timeNow + GetRandInt(MAX_FEEFILTER_CHANGE_DELAY) * 1000000;\n         }\n     }\n+\n     return true;\n }\n "
      }
    ]
  }
]